{"buggy_code": ["<?php\n\n/*\n\n\tCopyright (c) 2009-2019 F3::Factory/Bong Cosca, All rights reserved.\n\n\tThis file is part of the Fat-Free Framework (http://fatfreeframework.com).\n\n\tThis is free software: you can redistribute it and/or modify it under the\n\tterms of the GNU General Public License as published by the Free Software\n\tFoundation, either version 3 of the License, or later.\n\n\tFat-Free Framework is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tGeneral Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License along\n\twith Fat-Free Framework.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n//! Factory class for single-instance objects\nabstract class Prefab {\n\n\t/**\n\t*\tReturn class instance\n\t*\t@return static\n\t**/\n\tstatic function instance() {\n\t\tif (!Registry::exists($class=get_called_class())) {\n\t\t\t$ref=new ReflectionClass($class);\n\t\t\t$args=func_get_args();\n\t\t\tRegistry::set($class,\n\t\t\t\t$args?$ref->newinstanceargs($args):new $class);\n\t\t}\n\t\treturn Registry::get($class);\n\t}\n\n}\n\n//! Base structure\nfinal class Base extends Prefab implements ArrayAccess {\n\n\t//@{ Framework details\n\tconst\n\t\tPACKAGE='Fat-Free Framework',\n\t\tVERSION='3.7.1-Release';\n\t//@}\n\n\t//@{ HTTP status codes (RFC 2616)\n\tconst\n\t\tHTTP_100='Continue',\n\t\tHTTP_101='Switching Protocols',\n\t\tHTTP_103='Early Hints',\n\t\tHTTP_200='OK',\n\t\tHTTP_201='Created',\n\t\tHTTP_202='Accepted',\n\t\tHTTP_203='Non-Authorative Information',\n\t\tHTTP_204='No Content',\n\t\tHTTP_205='Reset Content',\n\t\tHTTP_206='Partial Content',\n\t\tHTTP_300='Multiple Choices',\n\t\tHTTP_301='Moved Permanently',\n\t\tHTTP_302='Found',\n\t\tHTTP_303='See Other',\n\t\tHTTP_304='Not Modified',\n\t\tHTTP_305='Use Proxy',\n\t\tHTTP_307='Temporary Redirect',\n\t\tHTTP_308='Permanent Redirect',\n\t\tHTTP_400='Bad Request',\n\t\tHTTP_401='Unauthorized',\n\t\tHTTP_402='Payment Required',\n\t\tHTTP_403='Forbidden',\n\t\tHTTP_404='Not Found',\n\t\tHTTP_405='Method Not Allowed',\n\t\tHTTP_406='Not Acceptable',\n\t\tHTTP_407='Proxy Authentication Required',\n\t\tHTTP_408='Request Timeout',\n\t\tHTTP_409='Conflict',\n\t\tHTTP_410='Gone',\n\t\tHTTP_411='Length Required',\n\t\tHTTP_412='Precondition Failed',\n\t\tHTTP_413='Request Entity Too Large',\n\t\tHTTP_414='Request-URI Too Long',\n\t\tHTTP_415='Unsupported Media Type',\n\t\tHTTP_416='Requested Range Not Satisfiable',\n\t\tHTTP_417='Expectation Failed',\n\t\tHTTP_421='Misdirected Request',\n\t\tHTTP_422='Unprocessable Entity',\n\t\tHTTP_423='Locked',\n\t\tHTTP_429='Too Many Requests',\n\t\tHTTP_451='Unavailable For Legal Reasons',\n\t\tHTTP_500='Internal Server Error',\n\t\tHTTP_501='Not Implemented',\n\t\tHTTP_502='Bad Gateway',\n\t\tHTTP_503='Service Unavailable',\n\t\tHTTP_504='Gateway Timeout',\n\t\tHTTP_505='HTTP Version Not Supported',\n\t\tHTTP_507='Insufficient Storage',\n\t\tHTTP_511='Network Authentication Required';\n\t//@}\n\n\tconst\n\t\t//! Mapped PHP globals\n\t\tGLOBALS='GET|POST|COOKIE|REQUEST|SESSION|FILES|SERVER|ENV',\n\t\t//! HTTP verbs\n\t\tVERBS='GET|HEAD|POST|PUT|PATCH|DELETE|CONNECT|OPTIONS',\n\t\t//! Default directory permissions\n\t\tMODE=0755,\n\t\t//! Syntax highlighting stylesheet\n\t\tCSS='code.css';\n\n\t//@{ Request types\n\tconst\n\t\tREQ_SYNC=1,\n\t\tREQ_AJAX=2,\n\t\tREQ_CLI=4;\n\t//@}\n\n\t//@{ Error messages\n\tconst\n\t\tE_Pattern='Invalid routing pattern: %s',\n\t\tE_Named='Named route does not exist: %s',\n\t\tE_Alias='Invalid named route alias: %s',\n\t\tE_Fatal='Fatal error: %s',\n\t\tE_Open='Unable to open %s',\n\t\tE_Routes='No routes specified',\n\t\tE_Class='Invalid class %s',\n\t\tE_Method='Invalid method %s',\n\t\tE_Hive='Invalid hive key %s';\n\t//@}\n\n\tprivate\n\t\t//! Globals\n\t\t$hive,\n\t\t//! Initial settings\n\t\t$init,\n\t\t//! Language lookup sequence\n\t\t$languages,\n\t\t//! Mutex locks\n\t\t$locks=[],\n\t\t//! Default fallback language\n\t\t$fallback='en';\n\n\t/**\n\t*\tSync PHP global with corresponding hive key\n\t*\t@return array\n\t*\t@param $key string\n\t**/\n\tfunction sync($key) {\n\t\treturn $this->hive[$key]=&$GLOBALS['_'.$key];\n\t}\n\n\t/**\n\t*\tReturn the parts of specified hive key\n\t*\t@return array\n\t*\t@param $key string\n\t**/\n\tprivate function cut($key) {\n\t\treturn preg_split('/\\[\\h*[\\'\"]?(.+?)[\\'\"]?\\h*\\]|(->)|\\./',\n\t\t\t$key,NULL,PREG_SPLIT_NO_EMPTY|PREG_SPLIT_DELIM_CAPTURE);\n\t}\n\n\t/**\n\t*\tReplace tokenized URL with available token values\n\t*\t@return string\n\t*\t@param $url array|string\n\t*\t@param $args array\n\t**/\n\tfunction build($url,$args=[]) {\n\t\t$args+=$this->hive['PARAMS'];\n\t\tif (is_array($url))\n\t\t\tforeach ($url as &$var) {\n\t\t\t\t$var=$this->build($var,$args);\n\t\t\t\tunset($var);\n\t\t\t}\n\t\telse {\n\t\t\t$i=0;\n\t\t\t$url=preg_replace_callback('/(\\{)?@(\\w+)(?(1)\\})|(\\*)/',\n\t\t\t\tfunction($match) use(&$i,$args) {\n\t\t\t\t\tif (isset($match[2]) &&\n\t\t\t\t\t\tarray_key_exists($match[2],$args))\n\t\t\t\t\t\treturn $args[$match[2]];\n\t\t\t\t\tif (isset($match[3]) &&\n\t\t\t\t\t\tarray_key_exists($match[3],$args)) {\n\t\t\t\t\t\tif (!is_array($args[$match[3]]))\n\t\t\t\t\t\t\treturn $args[$match[3]];\n\t\t\t\t\t\t$i++;\n\t\t\t\t\t\treturn $args[$match[3]][$i-1];\n\t\t\t\t\t}\n\t\t\t\t\treturn $match[0];\n\t\t\t\t},$url);\n\t\t}\n\t\treturn $url;\n\t}\n\n\t/**\n\t*\tParse string containing key-value pairs\n\t*\t@return array\n\t*\t@param $str string\n\t**/\n\tfunction parse($str) {\n\t\tpreg_match_all('/(\\w+|\\*)\\h*=\\h*(?:\\[(.+?)\\]|(.+?))(?=,|$)/',\n\t\t\t$str,$pairs,PREG_SET_ORDER);\n\t\t$out=[];\n\t\tforeach ($pairs as $pair)\n\t\t\tif ($pair[2]) {\n\t\t\t\t$out[$pair[1]]=[];\n\t\t\t\tforeach (explode(',',$pair[2]) as $val)\n\t\t\t\t\tarray_push($out[$pair[1]],$val);\n\t\t\t}\n\t\t\telse\n\t\t\t\t$out[$pair[1]]=trim($pair[3]);\n\t\treturn $out;\n\t}\n\n\t/**\n\t * Cast string variable to PHP type or constant\n\t * @param $val\n\t * @return mixed\n\t */\n\tfunction cast($val) {\n\t\tif (preg_match('/^(?:0x[0-9a-f]+|0[0-7]+|0b[01]+)$/i',$val))\n\t\t\treturn intval($val,0);\n\t\tif (is_numeric($val))\n\t\t\treturn $val+0;\n\t\t$val=trim($val);\n\t\tif (preg_match('/^\\w+$/i',$val) && defined($val))\n\t\t\treturn constant($val);\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tConvert JS-style token to PHP expression\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction compile($str) {\n\t\treturn preg_replace_callback(\n\t\t\t'/(?<!\\w)@(\\w+(?:(?:\\->|::)\\w+)?)'.\n\t\t\t'((?:\\.\\w+|\\[(?:(?:[^\\[\\]]*|(?R))*)\\]|(?:\\->|::)\\w+|\\()*)/',\n\t\t\tfunction($expr) {\n\t\t\t\t$str='$'.$expr[1];\n\t\t\t\tif (isset($expr[2]))\n\t\t\t\t\t$str.=preg_replace_callback(\n\t\t\t\t\t\t'/\\.(\\w+)(\\()?|\\[((?:[^\\[\\]]*|(?R))*)\\]/',\n\t\t\t\t\t\tfunction($sub) {\n\t\t\t\t\t\t\tif (empty($sub[2])) {\n\t\t\t\t\t\t\t\tif (ctype_digit($sub[1]))\n\t\t\t\t\t\t\t\t\t$sub[1]=(int)$sub[1];\n\t\t\t\t\t\t\t\t$out='['.\n\t\t\t\t\t\t\t\t\t(isset($sub[3])?\n\t\t\t\t\t\t\t\t\t\t$this->compile($sub[3]):\n\t\t\t\t\t\t\t\t\t\t$this->export($sub[1])).\n\t\t\t\t\t\t\t\t']';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t$out=function_exists($sub[1])?\n\t\t\t\t\t\t\t\t\t$sub[0]:\n\t\t\t\t\t\t\t\t\t('['.$this->export($sub[1]).']'.$sub[2]);\n\t\t\t\t\t\t\treturn $out;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t$expr[2]\n\t\t\t\t\t);\n\t\t\t\treturn $str;\n\t\t\t},\n\t\t\t$str\n\t\t);\n\t}\n\n\t/**\n\t*\tGet hive key reference/contents; Add non-existent hive keys,\n\t*\tarray elements, and object properties by default\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $add bool\n\t*\t@param $var mixed\n\t**/\n\tfunction &ref($key,$add=TRUE,&$var=NULL) {\n\t\t$null=NULL;\n\t\t$parts=$this->cut($key);\n\t\tif ($parts[0]=='SESSION') {\n\t\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\tsession_start();\n\t\t\t$this->sync('SESSION');\n\t\t}\n\t\telseif (!preg_match('/^\\w+$/',$parts[0]))\n\t\t\tuser_error(sprintf(self::E_Hive,$this->stringify($key)),\n\t\t\t\tE_USER_ERROR);\n\t\tif (is_null($var)) {\n\t\t\tif ($add)\n\t\t\t\t$var=&$this->hive;\n\t\t\telse\n\t\t\t\t$var=$this->hive;\n\t\t}\n\t\t$obj=FALSE;\n\t\tforeach ($parts as $part)\n\t\t\tif ($part=='->')\n\t\t\t\t$obj=TRUE;\n\t\t\telseif ($obj) {\n\t\t\t\t$obj=FALSE;\n\t\t\t\tif (!is_object($var))\n\t\t\t\t\t$var=new stdClass;\n\t\t\t\tif ($add || property_exists($var,$part))\n\t\t\t\t\t$var=&$var->$part;\n\t\t\t\telse {\n\t\t\t\t\t$var=&$null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!is_array($var))\n\t\t\t\t\t$var=[];\n\t\t\t\tif ($add || array_key_exists($part,$var))\n\t\t\t\t\t$var=&$var[$part];\n\t\t\t\telse {\n\t\t\t\t\t$var=&$null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\treturn $var;\n\t}\n\n\t/**\n\t*\tReturn TRUE if hive key is set\n\t*\t(or return timestamp and TTL if cached)\n\t*\t@return bool\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction exists($key,&$val=NULL) {\n\t\t$val=$this->ref($key,FALSE);\n\t\treturn isset($val)?\n\t\t\tTRUE:\n\t\t\t(Cache::instance()->exists($this->hash($key).'.var',$val)?:FALSE);\n\t}\n\n\t/**\n\t*\tReturn TRUE if hive key is empty and not cached\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t*\t@return bool\n\t**/\n\tfunction devoid($key,&$val=NULL) {\n\t\t$val=$this->ref($key,FALSE);\n\t\treturn empty($val) &&\n\t\t\t(!Cache::instance()->exists($this->hash($key).'.var',$val) ||\n\t\t\t\t!$val);\n\t}\n\n\t/**\n\t*\tBind value to hive key\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t*\t@param $ttl int\n\t**/\n\tfunction set($key,$val,$ttl=0) {\n\t\t$time=(int)$this->hive['TIME'];\n\t\tif (preg_match('/^(GET|POST|COOKIE)\\b(.+)/',$key,$expr)) {\n\t\t\t$this->set('REQUEST'.$expr[2],$val);\n\t\t\tif ($expr[1]=='COOKIE') {\n\t\t\t\t$parts=$this->cut($key);\n\t\t\t\t$jar=$this->unserialize($this->serialize($this->hive['JAR']));\n\t\t\t\tunset($jar['lifetime']);\n\t\t\t\tif (version_compare(PHP_VERSION, '7.3.0') >= 0) {\n\t\t\t\t\tunset($jar['expire']);\n\t\t\t\t\tif (isset($_COOKIE[$parts[1]]))\n\t\t\t\t\t\tsetcookie($parts[1],NULL,['expires'=>0]+$jar);\n\t\t\t\t\tif ($ttl)\n\t\t\t\t\t\t$jar['expires']=$time+$ttl;\n\t\t\t\t\tsetcookie($parts[1],$val,$jar);\n\t\t\t\t} else {\n\t\t\t\t\tunset($jar['samesite']);\n\t\t\t\t\tif (isset($_COOKIE[$parts[1]]))\n\t\t\t\t\t\tcall_user_func_array('setcookie',\n\t\t\t\t\t\t\tarray_merge([$parts[1],NULL],['expire'=>0]+$jar));\n\t\t\t\t\tif ($ttl)\n\t\t\t\t\t\t$jar['expire']=$time+$ttl;\n\t\t\t\t\tcall_user_func_array('setcookie',[$parts[1],$val]+$jar);\n\t\t\t\t}\n\t\t\t\t$_COOKIE[$parts[1]]=$val;\n\t\t\t\treturn $val;\n\t\t\t}\n\t\t}\n\t\telse switch ($key) {\n\t\tcase 'CACHE':\n\t\t\t$val=Cache::instance()->load($val);\n\t\t\tbreak;\n\t\tcase 'ENCODING':\n\t\t\tini_set('default_charset',$val);\n\t\t\tif (extension_loaded('mbstring'))\n\t\t\t\tmb_internal_encoding($val);\n\t\t\tbreak;\n\t\tcase 'FALLBACK':\n\t\t\t$this->fallback=$val;\n\t\t\t$lang=$this->language($this->hive['LANGUAGE']);\n\t\tcase 'LANGUAGE':\n\t\t\tif (!isset($lang))\n\t\t\t\t$val=$this->language($val);\n\t\t\t$lex=$this->lexicon($this->hive['LOCALES'],$ttl);\n\t\tcase 'LOCALES':\n\t\t\tif (isset($lex) || $lex=$this->lexicon($val,$ttl))\n\t\t\t\tforeach ($lex as $dt=>$dd) {\n\t\t\t\t\t$ref=&$this->ref($this->hive['PREFIX'].$dt);\n\t\t\t\t\t$ref=$dd;\n\t\t\t\t\tunset($ref);\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase 'TZ':\n\t\t\tdate_default_timezone_set($val);\n\t\t\tbreak;\n\t\t}\n\t\t$ref=&$this->ref($key);\n\t\t$ref=$val;\n\t\tif (preg_match('/^JAR\\b/',$key)) {\n\t\t\tif ($key=='JAR.lifetime')\n\t\t\t\t$this->set('JAR.expire',$val==0?0:\n\t\t\t\t\t(is_int($val)?$time+$val:strtotime($val)));\n\t\t\telse {\n\t\t\t\tif ($key=='JAR.expire')\n\t\t\t\t\t$this->hive['JAR']['lifetime']=max(0,$val-$time);\n\t\t\t\t$jar=$this->unserialize($this->serialize($this->hive['JAR']));\n\t\t\t\tunset($jar['expire']);\n\t\t\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\t\tif (version_compare(PHP_VERSION, '7.3.0') >= 0)\n\t\t\t\t\t\tsession_set_cookie_params($jar);\n\t\t\t\t\telse {\n\t\t\t\t\t\tunset($jar['samesite']);\n\t\t\t\t\t\tcall_user_func_array('session_set_cookie_params',$jar);\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($ttl)\n\t\t\t// Persist the key-value pair\n\t\t\tCache::instance()->set($this->hash($key).'.var',$val,$ttl);\n\t\treturn $ref;\n\t}\n\n\t/**\n\t*\tRetrieve contents of hive key\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $args string|array\n\t**/\n\tfunction get($key,$args=NULL) {\n\t\tif (is_string($val=$this->ref($key,FALSE)) && !is_null($args))\n\t\t\treturn call_user_func_array(\n\t\t\t\t[$this,'format'],\n\t\t\t\tarray_merge([$val],is_array($args)?$args:[$args])\n\t\t\t);\n\t\tif (is_null($val)) {\n\t\t\t// Attempt to retrieve from cache\n\t\t\tif (Cache::instance()->exists($this->hash($key).'.var',$data))\n\t\t\t\treturn $data;\n\t\t}\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tUnset hive key\n\t*\t@param $key string\n\t**/\n\tfunction clear($key) {\n\t\t// Normalize array literal\n\t\t$cache=Cache::instance();\n\t\t$parts=$this->cut($key);\n\t\tif ($key=='CACHE')\n\t\t\t// Clear cache contents\n\t\t\t$cache->reset();\n\t\telseif (preg_match('/^(GET|POST|COOKIE)\\b(.+)/',$key,$expr)) {\n\t\t\t$this->clear('REQUEST'.$expr[2]);\n\t\t\tif ($expr[1]=='COOKIE') {\n\t\t\t\t$parts=$this->cut($key);\n\t\t\t\t$jar=$this->hive['JAR'];\n\t\t\t\tunset($jar['lifetime']);\n\t\t\t\t$jar['expire']=0;\n\t\t\t\tif (version_compare(PHP_VERSION, '7.3.0') >= 0) {\n\t\t\t\t\t$jar['expires']=$jar['expire'];\n\t\t\t\t\tunset($jar['expire']);\n\t\t\t\t\tsetcookie($parts[1],NULL,$jar);\n\t\t\t\t} else {\n\t\t\t\t\tunset($jar['samesite']);\n\t\t\t\t\tcall_user_func_array('setcookie',\n\t\t\t\t\t\tarray_merge([$parts[1],NULL],$jar));\n\t\t\t\t}\n\t\t\t\tunset($_COOKIE[$parts[1]]);\n\t\t\t}\n\t\t}\n\t\telseif ($parts[0]=='SESSION') {\n\t\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\tsession_start();\n\t\t\tif (empty($parts[1])) {\n\t\t\t\t// End session\n\t\t\t\tsession_unset();\n\t\t\t\tsession_destroy();\n\t\t\t\t$this->clear('COOKIE.'.session_name());\n\t\t\t}\n\t\t\t$this->sync('SESSION');\n\t\t}\n\t\tif (!isset($parts[1]) && array_key_exists($parts[0],$this->init))\n\t\t\t// Reset global to default value\n\t\t\t$this->hive[$parts[0]]=$this->init[$parts[0]];\n\t\telse {\n\t\t\teval('unset('.$this->compile('@this->hive.'.$key).');');\n\t\t\tif ($parts[0]=='SESSION') {\n\t\t\t\tsession_commit();\n\t\t\t\tsession_start();\n\t\t\t}\n\t\t\tif ($cache->exists($hash=$this->hash($key).'.var'))\n\t\t\t\t// Remove from cache\n\t\t\t\t$cache->clear($hash);\n\t\t}\n\t}\n\n\t/**\n\t*\tReturn TRUE if hive variable is 'on'\n\t*\t@return bool\n\t*\t@param $key string\n\t**/\n\tfunction checked($key) {\n\t\t$ref=&$this->ref($key);\n\t\treturn $ref=='on';\n\t}\n\n\t/**\n\t*\tReturn TRUE if property has public visibility\n\t*\t@return bool\n\t*\t@param $obj object\n\t*\t@param $key string\n\t**/\n\tfunction visible($obj,$key) {\n\t\tif (property_exists($obj,$key)) {\n\t\t\t$ref=new ReflectionProperty(get_class($obj),$key);\n\t\t\t$out=$ref->ispublic();\n\t\t\tunset($ref);\n\t\t\treturn $out;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tMulti-variable assignment using associative array\n\t*\t@param $vars array\n\t*\t@param $prefix string\n\t*\t@param $ttl int\n\t**/\n\tfunction mset(array $vars,$prefix='',$ttl=0) {\n\t\tforeach ($vars as $key=>$val)\n\t\t\t$this->set($prefix.$key,$val,$ttl);\n\t}\n\n\t/**\n\t*\tPublish hive contents\n\t*\t@return array\n\t**/\n\tfunction hive() {\n\t\treturn $this->hive;\n\t}\n\n\t/**\n\t*\tCopy contents of hive variable to another\n\t*\t@return mixed\n\t*\t@param $src string\n\t*\t@param $dst string\n\t**/\n\tfunction copy($src,$dst) {\n\t\t$ref=&$this->ref($dst);\n\t\treturn $ref=$this->ref($src,FALSE);\n\t}\n\n\t/**\n\t*\tConcatenate string to hive string variable\n\t*\t@return string\n\t*\t@param $key string\n\t*\t@param $val string\n\t**/\n\tfunction concat($key,$val) {\n\t\t$ref=&$this->ref($key);\n\t\t$ref.=$val;\n\t\treturn $ref;\n\t}\n\n\t/**\n\t*\tSwap keys and values of hive array variable\n\t*\t@return array\n\t*\t@param $key string\n\t*\t@public\n\t**/\n\tfunction flip($key) {\n\t\t$ref=&$this->ref($key);\n\t\treturn $ref=array_combine(array_values($ref),array_keys($ref));\n\t}\n\n\t/**\n\t*\tAdd element to the end of hive array variable\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction push($key,$val) {\n\t\t$ref=&$this->ref($key);\n\t\t$ref[]=$val;\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tRemove last element of hive array variable\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction pop($key) {\n\t\t$ref=&$this->ref($key);\n\t\treturn array_pop($ref);\n\t}\n\n\t/**\n\t*\tAdd element to the beginning of hive array variable\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction unshift($key,$val) {\n\t\t$ref=&$this->ref($key);\n\t\tarray_unshift($ref,$val);\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tRemove first element of hive array variable\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction shift($key) {\n\t\t$ref=&$this->ref($key);\n\t\treturn array_shift($ref);\n\t}\n\n\t/**\n\t*\tMerge array with hive array variable\n\t*\t@return array\n\t*\t@param $key string\n\t*\t@param $src string|array\n\t*\t@param $keep bool\n\t**/\n\tfunction merge($key,$src,$keep=FALSE) {\n\t\t$ref=&$this->ref($key);\n\t\tif (!$ref)\n\t\t\t$ref=[];\n\t\t$out=array_merge($ref,is_string($src)?$this->hive[$src]:$src);\n\t\tif ($keep)\n\t\t\t$ref=$out;\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tExtend hive array variable with default values from $src\n\t*\t@return array\n\t*\t@param $key string\n\t*\t@param $src string|array\n\t*\t@param $keep bool\n\t**/\n\tfunction extend($key,$src,$keep=FALSE) {\n\t\t$ref=&$this->ref($key);\n\t\tif (!$ref)\n\t\t\t$ref=[];\n\t\t$out=array_replace_recursive(\n\t\t\tis_string($src)?$this->hive[$src]:$src,$ref);\n\t\tif ($keep)\n\t\t\t$ref=$out;\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tConvert backslashes to slashes\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction fixslashes($str) {\n\t\treturn $str?strtr($str,'\\\\','/'):$str;\n\t}\n\n\t/**\n\t*\tSplit comma-, semi-colon, or pipe-separated string\n\t*\t@return array\n\t*\t@param $str string\n\t*\t@param $noempty bool\n\t**/\n\tfunction split($str,$noempty=TRUE) {\n\t\treturn array_map('trim',\n\t\t\tpreg_split('/[,;|]/',$str,0,$noempty?PREG_SPLIT_NO_EMPTY:0));\n\t}\n\n\t/**\n\t*\tConvert PHP expression/value to compressed exportable string\n\t*\t@return string\n\t*\t@param $arg mixed\n\t*\t@param $stack array\n\t**/\n\tfunction stringify($arg,array $stack=NULL) {\n\t\tif ($stack) {\n\t\t\tforeach ($stack as $node)\n\t\t\t\tif ($arg===$node)\n\t\t\t\t\treturn '*RECURSION*';\n\t\t}\n\t\telse\n\t\t\t$stack=[];\n\t\tswitch (gettype($arg)) {\n\t\t\tcase 'object':\n\t\t\t\t$str='';\n\t\t\t\tforeach (get_object_vars($arg) as $key=>$val)\n\t\t\t\t\t$str.=($str?',':'').\n\t\t\t\t\t\t$this->export($key).'=>'.\n\t\t\t\t\t\t$this->stringify($val,\n\t\t\t\t\t\t\tarray_merge($stack,[$arg]));\n\t\t\t\treturn get_class($arg).'::__set_state(['.$str.'])';\n\t\t\tcase 'array':\n\t\t\t\t$str='';\n\t\t\t\t$num=isset($arg[0]) &&\n\t\t\t\t\tctype_digit(implode('',array_keys($arg)));\n\t\t\t\tforeach ($arg as $key=>$val)\n\t\t\t\t\t$str.=($str?',':'').\n\t\t\t\t\t\t($num?'':($this->export($key).'=>')).\n\t\t\t\t\t\t$this->stringify($val,array_merge($stack,[$arg]));\n\t\t\t\treturn '['.$str.']';\n\t\t\tdefault:\n\t\t\t\treturn $this->export($arg);\n\t\t}\n\t}\n\n\t/**\n\t*\tFlatten array values and return as CSV string\n\t*\t@return string\n\t*\t@param $args array\n\t**/\n\tfunction csv(array $args) {\n\t\treturn implode(',',array_map('stripcslashes',\n\t\t\tarray_map([$this,'stringify'],$args)));\n\t}\n\n\t/**\n\t*\tConvert snakecase string to camelcase\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction camelcase($str) {\n\t\treturn preg_replace_callback(\n\t\t\t'/_(\\pL)/u',\n\t\t\tfunction($match) {\n\t\t\t\treturn strtoupper($match[1]);\n\t\t\t},\n\t\t\t$str\n\t\t);\n\t}\n\n\t/**\n\t*\tConvert camelcase string to snakecase\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction snakecase($str) {\n\t\treturn strtolower(preg_replace('/(?!^)\\p{Lu}/u','_\\0',$str));\n\t}\n\n\t/**\n\t*\tReturn -1 if specified number is negative, 0 if zero,\n\t*\tor 1 if the number is positive\n\t*\t@return int\n\t*\t@param $num mixed\n\t**/\n\tfunction sign($num) {\n\t\treturn $num?($num/abs($num)):0;\n\t}\n\n\t/**\n\t*\tExtract values of array whose keys start with the given prefix\n\t*\t@return array\n\t*\t@param $arr array\n\t*\t@param $prefix string\n\t**/\n\tfunction extract($arr,$prefix) {\n\t\t$out=[];\n\t\tforeach (preg_grep('/^'.preg_quote($prefix,'/').'/',array_keys($arr))\n\t\t\tas $key)\n\t\t\t$out[substr($key,strlen($prefix))]=$arr[$key];\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tConvert class constants to array\n\t*\t@return array\n\t*\t@param $class object|string\n\t*\t@param $prefix string\n\t**/\n\tfunction constants($class,$prefix='') {\n\t\t$ref=new ReflectionClass($class);\n\t\treturn $this->extract($ref->getconstants(),$prefix);\n\t}\n\n\t/**\n\t*\tGenerate 64bit/base36 hash\n\t*\t@return string\n\t*\t@param $str\n\t**/\n\tfunction hash($str) {\n\t\treturn str_pad(base_convert(\n\t\t\tsubstr(sha1($str),-16),16,36),11,'0',STR_PAD_LEFT);\n\t}\n\n\t/**\n\t*\tReturn Base64-encoded equivalent\n\t*\t@return string\n\t*\t@param $data string\n\t*\t@param $mime string\n\t**/\n\tfunction base64($data,$mime) {\n\t\treturn 'data:'.$mime.';base64,'.base64_encode($data);\n\t}\n\n\t/**\n\t*\tConvert special characters to HTML entities\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction encode($str) {\n\t\treturn @htmlspecialchars($str,$this->hive['BITMASK'],\n\t\t\t$this->hive['ENCODING'])?:$this->scrub($str);\n\t}\n\n\t/**\n\t*\tConvert HTML entities back to characters\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction decode($str) {\n\t\treturn htmlspecialchars_decode($str,$this->hive['BITMASK']);\n\t}\n\n\t/**\n\t*\tInvoke callback recursively for all data types\n\t*\t@return mixed\n\t*\t@param $arg mixed\n\t*\t@param $func callback\n\t*\t@param $stack array\n\t**/\n\tfunction recursive($arg,$func,$stack=[]) {\n\t\tif ($stack) {\n\t\t\tforeach ($stack as $node)\n\t\t\t\tif ($arg===$node)\n\t\t\t\t\treturn $arg;\n\t\t}\n\t\tswitch (gettype($arg)) {\n\t\t\tcase 'object':\n\t\t\t\t$ref=new ReflectionClass($arg);\n\t\t\t\tif ($ref->iscloneable()) {\n\t\t\t\t\t$arg=clone($arg);\n\t\t\t\t\t$cast=is_a($arg,'IteratorAggregate')?\n\t\t\t\t\t\titerator_to_array($arg):get_object_vars($arg);\n\t\t\t\t\tforeach ($cast as $key=>$val)\n\t\t\t\t\t\t$arg->$key=$this->recursive(\n\t\t\t\t\t\t\t$val,$func,array_merge($stack,[$arg]));\n\t\t\t\t}\n\t\t\t\treturn $arg;\n\t\t\tcase 'array':\n\t\t\t\t$copy=[];\n\t\t\t\tforeach ($arg as $key=>$val)\n\t\t\t\t\t$copy[$key]=$this->recursive($val,$func,\n\t\t\t\t\t\tarray_merge($stack,[$arg]));\n\t\t\t\treturn $copy;\n\t\t}\n\t\treturn $func($arg);\n\t}\n\n\t/**\n\t*\tRemove HTML tags (except those enumerated) and non-printable\n\t*\tcharacters to mitigate XSS/code injection attacks\n\t*\t@return mixed\n\t*\t@param $arg mixed\n\t*\t@param $tags string\n\t**/\n\tfunction clean($arg,$tags=NULL) {\n\t\treturn $this->recursive($arg,\n\t\t\tfunction($val) use($tags) {\n\t\t\t\tif ($tags!='*')\n\t\t\t\t\t$val=trim(strip_tags($val,\n\t\t\t\t\t\t'<'.implode('><',$this->split($tags)).'>'));\n\t\t\t\treturn trim(preg_replace(\n\t\t\t\t\t'/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/','',$val));\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t*\tSimilar to clean(), except that variable is passed by reference\n\t*\t@return mixed\n\t*\t@param $var mixed\n\t*\t@param $tags string\n\t**/\n\tfunction scrub(&$var,$tags=NULL) {\n\t\treturn $var=$this->clean($var,$tags);\n\t}\n\n\t/**\n\t*\tReturn locale-aware formatted string\n\t*\t@return string\n\t**/\n\tfunction format() {\n\t\t$args=func_get_args();\n\t\t$val=array_shift($args);\n\t\t// Get formatting rules\n\t\t$conv=localeconv();\n\t\treturn preg_replace_callback(\n\t\t\t'/\\{\\s*(?P<pos>\\d+)\\s*(?:,\\s*(?P<type>\\w+)\\s*'.\n\t\t\t'(?:,\\s*(?P<mod>(?:\\w+(?:\\s*\\{.+?\\}\\s*,?\\s*)?)*)'.\n\t\t\t'(?:,\\s*(?P<prop>.+?))?)?)?\\s*\\}/',\n\t\t\tfunction($expr) use($args,$conv) {\n\t\t\t\t/**\n\t\t\t\t * @var string $pos\n\t\t\t\t * @var string $mod\n\t\t\t\t * @var string $type\n\t\t\t\t * @var string $prop\n\t\t\t\t */\n\t\t\t\textract($expr);\n\t\t\t\t/**\n\t\t\t\t * @var string $thousands_sep\n\t\t\t\t * @var string $negative_sign\n\t\t\t\t * @var string $positive_sign\n\t\t\t\t * @var string $frac_digits\n\t\t\t\t * @var string $decimal_point\n\t\t\t\t * @var string $int_curr_symbol\n\t\t\t\t * @var string $currency_symbol\n\t\t\t\t */\n\t\t\t\textract($conv);\n\t\t\t\tif (!array_key_exists($pos,$args))\n\t\t\t\t\treturn $expr[0];\n\t\t\t\tif (isset($type)) {\n\t\t\t\t\tif (isset($this->hive['FORMATS'][$type]))\n\t\t\t\t\t\treturn $this->call(\n\t\t\t\t\t\t\t$this->hive['FORMATS'][$type],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t$args[$pos],\n\t\t\t\t\t\t\t\tisset($mod)?$mod:null,\n\t\t\t\t\t\t\t\tisset($prop)?$prop:null\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t);\n\t\t\t\t\tswitch ($type) {\n\t\t\t\t\t\tcase 'plural':\n\t\t\t\t\t\t\tpreg_match_all('/(?<tag>\\w+)'.\n\t\t\t\t\t\t\t\t'(?:\\s*\\{\\s*(?<data>.+?)\\s*\\})/',\n\t\t\t\t\t\t\t\t$mod,$matches,PREG_SET_ORDER);\n\t\t\t\t\t\t\t$ord=['zero','one','two'];\n\t\t\t\t\t\t\tforeach ($matches as $match) {\n\t\t\t\t\t\t\t\t/** @var string $tag */\n\t\t\t\t\t\t\t\t/** @var string $data */\n\t\t\t\t\t\t\t\textract($match);\n\t\t\t\t\t\t\t\tif (isset($ord[$args[$pos]]) &&\n\t\t\t\t\t\t\t\t\t$tag==$ord[$args[$pos]] || $tag=='other')\n\t\t\t\t\t\t\t\t\treturn str_replace('#',$args[$pos],$data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tif (isset($mod))\n\t\t\t\t\t\t\t\tswitch ($mod) {\n\t\t\t\t\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\t\t\t\t\treturn number_format(\n\t\t\t\t\t\t\t\t\t\t\t$args[$pos],0,'',$thousands_sep);\n\t\t\t\t\t\t\t\t\tcase 'currency':\n\t\t\t\t\t\t\t\t\t\t$int=$cstm=FALSE;\n\t\t\t\t\t\t\t\t\t\tif (isset($prop) &&\n\t\t\t\t\t\t\t\t\t\t\t$cstm=!$int=($prop=='int'))\n\t\t\t\t\t\t\t\t\t\t\t$currency_symbol=$prop;\n\t\t\t\t\t\t\t\t\t\tif (!$cstm &&\n\t\t\t\t\t\t\t\t\t\t\tfunction_exists('money_format'))\n\t\t\t\t\t\t\t\t\t\t\treturn money_format(\n\t\t\t\t\t\t\t\t\t\t\t\t'%'.($int?'i':'n'),$args[$pos]);\n\t\t\t\t\t\t\t\t\t\t$fmt=[\n\t\t\t\t\t\t\t\t\t\t\t0=>'(nc)',1=>'(n c)',\n\t\t\t\t\t\t\t\t\t\t\t2=>'(nc)',10=>'+nc',\n\t\t\t\t\t\t\t\t\t\t\t11=>'+n c',12=>'+ nc',\n\t\t\t\t\t\t\t\t\t\t\t20=>'nc+',21=>'n c+',\n\t\t\t\t\t\t\t\t\t\t\t22=>'nc +',30=>'n+c',\n\t\t\t\t\t\t\t\t\t\t\t31=>'n +c',32=>'n+ c',\n\t\t\t\t\t\t\t\t\t\t\t40=>'nc+',41=>'n c+',\n\t\t\t\t\t\t\t\t\t\t\t42=>'nc +',100=>'(cn)',\n\t\t\t\t\t\t\t\t\t\t\t101=>'(c n)',102=>'(cn)',\n\t\t\t\t\t\t\t\t\t\t\t110=>'+cn',111=>'+c n',\n\t\t\t\t\t\t\t\t\t\t\t112=>'+ cn',120=>'cn+',\n\t\t\t\t\t\t\t\t\t\t\t121=>'c n+',122=>'cn +',\n\t\t\t\t\t\t\t\t\t\t\t130=>'+cn',131=>'+c n',\n\t\t\t\t\t\t\t\t\t\t\t132=>'+ cn',140=>'c+n',\n\t\t\t\t\t\t\t\t\t\t\t141=>'c+ n',142=>'c +n'\n\t\t\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t\t\t\tif ($args[$pos]<0) {\n\t\t\t\t\t\t\t\t\t\t\t$sgn=$negative_sign;\n\t\t\t\t\t\t\t\t\t\t\t$pre='n';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t$sgn=$positive_sign;\n\t\t\t\t\t\t\t\t\t\t\t$pre='p';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn str_replace(\n\t\t\t\t\t\t\t\t\t\t\t['+','n','c'],\n\t\t\t\t\t\t\t\t\t\t\t[$sgn,number_format(\n\t\t\t\t\t\t\t\t\t\t\t\tabs($args[$pos]),\n\t\t\t\t\t\t\t\t\t\t\t\t$frac_digits,\n\t\t\t\t\t\t\t\t\t\t\t\t$decimal_point,\n\t\t\t\t\t\t\t\t\t\t\t\t$thousands_sep),\n\t\t\t\t\t\t\t\t\t\t\t\t$int?$int_curr_symbol\n\t\t\t\t\t\t\t\t\t\t\t\t\t:$currency_symbol],\n\t\t\t\t\t\t\t\t\t\t\t$fmt[(int)(\n\t\t\t\t\t\t\t\t\t\t\t\t(${$pre.'_cs_precedes'}%2).\n\t\t\t\t\t\t\t\t\t\t\t\t(${$pre.'_sign_posn'}%5).\n\t\t\t\t\t\t\t\t\t\t\t\t(${$pre.'_sep_by_space'}%3)\n\t\t\t\t\t\t\t\t\t\t\t)]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcase 'percent':\n\t\t\t\t\t\t\t\t\t\treturn number_format(\n\t\t\t\t\t\t\t\t\t\t\t$args[$pos]*100,0,$decimal_point,\n\t\t\t\t\t\t\t\t\t\t\t$thousands_sep).'%';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$frac=$args[$pos]-(int)$args[$pos];\n\t\t\t\t\t\t\treturn number_format(\n\t\t\t\t\t\t\t\t$args[$pos],\n\t\t\t\t\t\t\t\tisset($prop)?\n\t\t\t\t\t\t\t\t\t$prop:\n\t\t\t\t\t\t\t\t\t($frac?strlen($frac)-2:0),\n\t\t\t\t\t\t\t\t$decimal_point,$thousands_sep);\n\t\t\t\t\t\tcase 'date':\n\t\t\t\t\t\t\tif (empty($mod) || $mod=='short')\n\t\t\t\t\t\t\t\t$prop='%x';\n\t\t\t\t\t\t\telseif ($mod=='full')\n\t\t\t\t\t\t\t\t$prop='%A, %d %B %Y';\n\t\t\t\t\t\t\telseif ($mod!='custom')\n\t\t\t\t\t\t\t\t$prop='%d %B %Y';\n\t\t\t\t\t\t\treturn strftime($prop,$args[$pos]);\n\t\t\t\t\t\tcase 'time':\n\t\t\t\t\t\t\tif (empty($mod) || $mod=='short')\n\t\t\t\t\t\t\t\t$prop='%X';\n\t\t\t\t\t\t\telseif ($mod!='custom')\n\t\t\t\t\t\t\t\t$prop='%r';\n\t\t\t\t\t\t\treturn strftime($prop,$args[$pos]);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn $expr[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn $args[$pos];\n\t\t\t},\n\t\t\t$val\n\t\t);\n\t}\n\n\t/**\n\t*\tReturn string representation of expression\n\t*\t@return string\n\t*\t@param $expr mixed\n\t**/\n\tfunction export($expr) {\n\t\treturn var_export($expr,TRUE);\n\t}\n\n\t/**\n\t*\tAssign/auto-detect language\n\t*\t@return string\n\t*\t@param $code string\n\t**/\n\tfunction language($code) {\n\t\t$code=preg_replace('/\\h+|;q=[0-9.]+/','',$code);\n\t\t$code.=($code?',':'').$this->fallback;\n\t\t$this->languages=[];\n\t\tforeach (array_reverse(explode(',',$code)) as $lang)\n\t\t\tif (preg_match('/^(\\w{2})(?:-(\\w{2}))?\\b/i',$lang,$parts)) {\n\t\t\t\t// Generic language\n\t\t\t\tarray_unshift($this->languages,$parts[1]);\n\t\t\t\tif (isset($parts[2])) {\n\t\t\t\t\t// Specific language\n\t\t\t\t\t$parts[0]=$parts[1].'-'.($parts[2]=strtoupper($parts[2]));\n\t\t\t\t\tarray_unshift($this->languages,$parts[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t$this->languages=array_unique($this->languages);\n\t\t$locales=[];\n\t\t$windows=preg_match('/^win/i',PHP_OS);\n\t\t// Work around PHP's Turkish locale bug\n\t\tforeach (preg_grep('/^(?!tr)/i',$this->languages) as $locale) {\n\t\t\tif ($windows) {\n\t\t\t\t$parts=explode('-',$locale);\n\t\t\t\t$locale=@constant('ISO::LC_'.$parts[0]);\n\t\t\t\tif (isset($parts[1]) &&\n\t\t\t\t\t$country=@constant('ISO::CC_'.strtolower($parts[1])))\n\t\t\t\t\t$locale.='-'.$country;\n\t\t\t}\n\t\t\t$locale=str_replace('-','_',$locale);\n\t\t\t$locales[]=$locale.'.'.ini_get('default_charset');\n\t\t\t$locales[]=$locale;\n\t\t}\n\t\tsetlocale(LC_ALL,$locales);\n\t\treturn $this->hive['LANGUAGE']=implode(',',$this->languages);\n\t}\n\n\t/**\n\t*\tReturn lexicon entries\n\t*\t@return array\n\t*\t@param $path string\n\t*\t@param $ttl int\n\t**/\n\tfunction lexicon($path,$ttl=0) {\n\t\t$languages=$this->languages?:explode(',',$this->fallback);\n\t\t$cache=Cache::instance();\n\t\tif ($cache->exists(\n\t\t\t$hash=$this->hash(implode(',',$languages).$path).'.dic',$lex))\n\t\t\treturn $lex;\n\t\t$lex=[];\n\t\tforeach ($languages as $lang)\n\t\t\tforeach ($this->split($path) as $dir)\n\t\t\t\tif ((is_file($file=($base=$dir.$lang).'.php') ||\n\t\t\t\t\tis_file($file=$base.'.php')) &&\n\t\t\t\t\tis_array($dict=require($file)))\n\t\t\t\t\t$lex+=$dict;\n\t\t\t\telseif (is_file($file=$base.'.json') &&\n\t\t\t\t\tis_array($dict=json_decode(file_get_contents($file), true)))\n\t\t\t\t\t$lex+=$dict;\n\t\t\t\telseif (is_file($file=$base.'.ini')) {\n\t\t\t\t\tpreg_match_all(\n\t\t\t\t\t\t'/(?<=^|\\n)(?:'.\n\t\t\t\t\t\t\t'\\[(?<prefix>.+?)\\]|'.\n\t\t\t\t\t\t\t'(?<lval>[^\\h\\r\\n;].*?)\\h*=\\h*'.\n\t\t\t\t\t\t\t'(?<rval>(?:\\\\\\\\\\h*\\r?\\n|.+?)*)'.\n\t\t\t\t\t\t')(?=\\r?\\n|$)/',\n\t\t\t\t\t\t$this->read($file),$matches,PREG_SET_ORDER);\n\t\t\t\t\tif ($matches) {\n\t\t\t\t\t\t$prefix='';\n\t\t\t\t\t\tforeach ($matches as $match)\n\t\t\t\t\t\t\tif ($match['prefix'])\n\t\t\t\t\t\t\t\t$prefix=$match['prefix'].'.';\n\t\t\t\t\t\t\telseif (!array_key_exists(\n\t\t\t\t\t\t\t\t$key=$prefix.$match['lval'],$lex))\n\t\t\t\t\t\t\t\t$lex[$key]=trim(preg_replace(\n\t\t\t\t\t\t\t\t\t'/\\\\\\\\\\h*\\r?\\n/',\"\\n\",$match['rval']));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tif ($ttl)\n\t\t\t$cache->set($hash,$lex,$ttl);\n\t\treturn $lex;\n\t}\n\n\t/**\n\t*\tReturn string representation of PHP value\n\t*\t@return string\n\t*\t@param $arg mixed\n\t**/\n\tfunction serialize($arg) {\n\t\tswitch (strtolower($this->hive['SERIALIZER'])) {\n\t\t\tcase 'igbinary':\n\t\t\t\treturn igbinary_serialize($arg);\n\t\t\tdefault:\n\t\t\t\treturn serialize($arg);\n\t\t}\n\t}\n\n\t/**\n\t*\tReturn PHP value derived from string\n\t*\t@return string\n\t*\t@param $arg mixed\n\t**/\n\tfunction unserialize($arg) {\n\t\tswitch (strtolower($this->hive['SERIALIZER'])) {\n\t\t\tcase 'igbinary':\n\t\t\t\treturn igbinary_unserialize($arg);\n\t\t\tdefault:\n\t\t\t\treturn unserialize($arg);\n\t\t}\n\t}\n\n\t/**\n\t*\tSend HTTP status header; Return text equivalent of status code\n\t*\t@return string\n\t*\t@param $code int\n\t**/\n\tfunction status($code) {\n\t\t$reason=@constant('self::HTTP_'.$code);\n\t\tif (!$this->hive['CLI'] && !headers_sent())\n\t\t\theader($_SERVER['SERVER_PROTOCOL'].' '.$code.' '.$reason);\n\t\treturn $reason;\n\t}\n\n\t/**\n\t*\tSend cache metadata to HTTP client\n\t*\t@param $secs int\n\t**/\n\tfunction expire($secs=0) {\n\t\tif (!$this->hive['CLI'] && !headers_sent()) {\n\t\t\t$secs=(int)$secs;\n\t\t\tif ($this->hive['PACKAGE'])\n\t\t\t\theader('X-Powered-By: '.$this->hive['PACKAGE']);\n\t\t\tif ($this->hive['XFRAME'])\n\t\t\t\theader('X-Frame-Options: '.$this->hive['XFRAME']);\n\t\t\theader('X-XSS-Protection: 1; mode=block');\n\t\t\theader('X-Content-Type-Options: nosniff');\n\t\t\tif ($this->hive['VERB']=='GET' && $secs) {\n\t\t\t\t$time=microtime(TRUE);\n\t\t\t\theader_remove('Pragma');\n\t\t\t\theader('Cache-Control: max-age='.$secs);\n\t\t\t\theader('Expires: '.gmdate('r',$time+$secs));\n\t\t\t\theader('Last-Modified: '.gmdate('r'));\n\t\t\t}\n\t\t\telse {\n\t\t\t\theader('Pragma: no-cache');\n\t\t\t\theader('Cache-Control: no-cache, no-store, must-revalidate');\n\t\t\t\theader('Expires: '.gmdate('r',0));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t*\tReturn HTTP user agent\n\t*\t@return string\n\t**/\n\tfunction agent() {\n\t\t$headers=$this->hive['HEADERS'];\n\t\treturn isset($headers['X-Operamini-Phone-UA'])?\n\t\t\t$headers['X-Operamini-Phone-UA']:\n\t\t\t(isset($headers['X-Skyfire-Phone'])?\n\t\t\t\t$headers['X-Skyfire-Phone']:\n\t\t\t\t(isset($headers['User-Agent'])?\n\t\t\t\t\t$headers['User-Agent']:''));\n\t}\n\n\t/**\n\t*\tReturn TRUE if XMLHttpRequest detected\n\t*\t@return bool\n\t**/\n\tfunction ajax() {\n\t\t$headers=$this->hive['HEADERS'];\n\t\treturn isset($headers['X-Requested-With']) &&\n\t\t\t$headers['X-Requested-With']=='XMLHttpRequest';\n\t}\n\n\t/**\n\t*\tSniff IP address\n\t*\t@return string\n\t**/\n\tfunction ip() {\n\t\t$headers=$this->hive['HEADERS'];\n\t\treturn isset($headers['Client-IP'])?\n\t\t\t$headers['Client-IP']:\n\t\t\t(isset($headers['X-Forwarded-For'])?\n\t\t\t\texplode(',',$headers['X-Forwarded-For'])[0]:\n\t\t\t\t(isset($_SERVER['REMOTE_ADDR'])?\n\t\t\t\t\t$_SERVER['REMOTE_ADDR']:''));\n\t}\n\n\t/**\n\t*\tReturn filtered stack trace as a formatted string (or array)\n\t*\t@return string|array\n\t*\t@param $trace array|NULL\n\t*\t@param $format bool\n\t**/\n\tfunction trace(array $trace=NULL,$format=TRUE) {\n\t\tif (!$trace) {\n\t\t\t$trace=debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);\n\t\t\t$frame=$trace[0];\n\t\t\tif (isset($frame['file']) && $frame['file']==__FILE__)\n\t\t\t\tarray_shift($trace);\n\t\t}\n\t\t$debug=$this->hive['DEBUG'];\n\t\t$trace=array_filter(\n\t\t\t$trace,\n\t\t\tfunction($frame) use($debug) {\n\t\t\t\treturn isset($frame['file']) &&\n\t\t\t\t\t($debug>1 ||\n\t\t\t\t\t($frame['file']!=__FILE__ || $debug) &&\n\t\t\t\t\t(empty($frame['function']) ||\n\t\t\t\t\t!preg_match('/^(?:(?:trigger|user)_error|'.\n\t\t\t\t\t\t'__call|call_user_func)/',$frame['function'])));\n\t\t\t}\n\t\t);\n\t\tif (!$format)\n\t\t\treturn $trace;\n\t\t$out='';\n\t\t$eol=\"\\n\";\n\t\t// Analyze stack trace\n\t\tforeach ($trace as $frame) {\n\t\t\t$line='';\n\t\t\tif (isset($frame['class']))\n\t\t\t\t$line.=$frame['class'].$frame['type'];\n\t\t\tif (isset($frame['function']))\n\t\t\t\t$line.=$frame['function'].'('.\n\t\t\t\t\t($debug>2 && isset($frame['args'])?\n\t\t\t\t\t\t$this->csv($frame['args']):'').')';\n\t\t\t$src=$this->fixslashes(str_replace($_SERVER['DOCUMENT_ROOT'].\n\t\t\t\t'/','',$frame['file'])).':'.$frame['line'];\n\t\t\t$out.='['.$src.'] '.$line.$eol;\n\t\t}\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tLog error; Execute ONERROR handler if defined, else display\n\t*\tdefault error page (HTML for synchronous requests, JSON string\n\t*\tfor AJAX requests)\n\t*\t@param $code int\n\t*\t@param $text string\n\t*\t@param $trace array\n\t*\t@param $level int\n\t**/\n\tfunction error($code,$text='',array $trace=NULL,$level=0) {\n\t\t$prior=$this->hive['ERROR'];\n\t\t$header=$this->status($code);\n\t\t$req=$this->hive['VERB'].' '.$this->hive['PATH'];\n\t\tif ($this->hive['QUERY'])\n\t\t\t$req.='?'.$this->hive['QUERY'];\n\t\tif (!$text)\n\t\t\t$text='HTTP '.$code.' ('.$req.')';\n\t\t$trace=$this->trace($trace);\n\t\t$loggable=$this->hive['LOGGABLE'];\n\t\tif (!is_array($loggable))\n\t\t\t$loggable=$this->split($loggable);\n\t\tforeach ($loggable as $status)\n\t\t\tif ($status=='*' ||\n\t\t\t\tpreg_match('/^'.preg_replace('/\\D/','\\d',$status).'$/',$code)) {\n\t\t\t\terror_log($text);\n\t\t\t\tforeach (explode(\"\\n\",$trace) as $nexus)\n\t\t\t\t\tif ($nexus)\n\t\t\t\t\t\terror_log($nexus);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif ($highlight=!$this->hive['CLI'] && !$this->hive['AJAX'] &&\n\t\t\t$this->hive['HIGHLIGHT'] && is_file($css=__DIR__.'/'.self::CSS))\n\t\t\t$trace=$this->highlight($trace);\n\t\t$this->hive['ERROR']=[\n\t\t\t'status'=>$header,\n\t\t\t'code'=>$code,\n\t\t\t'text'=>$text,\n\t\t\t'trace'=>$trace,\n\t\t\t'level'=>$level\n\t\t];\n\t\t$this->expire(-1);\n\t\t$handler=$this->hive['ONERROR'];\n\t\t$this->hive['ONERROR']=NULL;\n\t\t$eol=\"\\n\";\n\t\tif ((!$handler ||\n\t\t\t$this->call($handler,[$this,$this->hive['PARAMS']],\n\t\t\t\t'beforeroute,afterroute')===FALSE) &&\n\t\t\t!$prior && !$this->hive['CLI'] && !$this->hive['QUIET'])\n\t\t\techo $this->hive['AJAX']?\n\t\t\t\tjson_encode(\n\t\t\t\t\tarray_diff_key(\n\t\t\t\t\t\t$this->hive['ERROR'],\n\t\t\t\t\t\t$this->hive['DEBUG']?\n\t\t\t\t\t\t\t[]:\n\t\t\t\t\t\t\t['trace'=>1]\n\t\t\t\t\t)\n\t\t\t\t):\n\t\t\t\t('<!DOCTYPE html>'.$eol.\n\t\t\t\t'<html>'.$eol.\n\t\t\t\t'<head>'.\n\t\t\t\t\t'<title>'.$code.' '.$header.'</title>'.\n\t\t\t\t\t($highlight?\n\t\t\t\t\t\t('<style>'.$this->read($css).'</style>'):'').\n\t\t\t\t'</head>'.$eol.\n\t\t\t\t'<body>'.$eol.\n\t\t\t\t\t'<h1>'.$header.'</h1>'.$eol.\n\t\t\t\t\t'<p>'.$this->encode($text?:$req).'</p>'.$eol.\n\t\t\t\t\t($this->hive['DEBUG']?('<pre>'.$trace.'</pre>'.$eol):'').\n\t\t\t\t'</body>'.$eol.\n\t\t\t\t'</html>');\n\t\tif ($this->hive['HALT'])\n\t\t\tdie(1);\n\t}\n\n\t/**\n\t*\tMock HTTP request\n\t*\t@return mixed\n\t*\t@param $pattern string\n\t*\t@param $args array\n\t*\t@param $headers array\n\t*\t@param $body string\n\t**/\n\tfunction mock($pattern,\n\t\tarray $args=NULL,array $headers=NULL,$body=NULL) {\n\t\tif (!$args)\n\t\t\t$args=[];\n\t\t$types=['sync','ajax','cli'];\n\t\tpreg_match('/([\\|\\w]+)\\h+(?:@(\\w+)(?:(\\(.+?)\\))*|([^\\h]+))'.\n\t\t\t'(?:\\h+\\[('.implode('|',$types).')\\])?/',$pattern,$parts);\n\t\t$verb=strtoupper($parts[1]);\n\t\tif ($parts[2]) {\n\t\t\tif (empty($this->hive['ALIASES'][$parts[2]]))\n\t\t\t\tuser_error(sprintf(self::E_Named,$parts[2]),E_USER_ERROR);\n\t\t\t$parts[4]=$this->hive['ALIASES'][$parts[2]];\n\t\t\t$parts[4]=$this->build($parts[4],\n\t\t\t\tisset($parts[3])?$this->parse($parts[3]):[]);\n\t\t}\n\t\tif (empty($parts[4]))\n\t\t\tuser_error(sprintf(self::E_Pattern,$pattern),E_USER_ERROR);\n\t\t$url=parse_url($parts[4]);\n\t\tparse_str(@$url['query'],$GLOBALS['_GET']);\n\t\tif (preg_match('/GET|HEAD/',$verb))\n\t\t\t$GLOBALS['_GET']=array_merge($GLOBALS['_GET'],$args);\n\t\t$GLOBALS['_POST']=$verb=='POST'?$args:[];\n\t\t$GLOBALS['_REQUEST']=array_merge($GLOBALS['_GET'],$GLOBALS['_POST']);\n\t\tforeach ($headers?:[] as $key=>$val)\n\t\t\t$_SERVER['HTTP_'.strtr(strtoupper($key),'-','_')]=$val;\n\t\t$this->hive['VERB']=$verb;\n\t\t$this->hive['PATH']=$url['path'];\n\t\t$this->hive['URI']=$this->hive['BASE'].$url['path'];\n\t\tif ($GLOBALS['_GET'])\n\t\t\t$this->hive['URI'].='?'.http_build_query($GLOBALS['_GET']);\n\t\t$this->hive['BODY']='';\n\t\tif (!preg_match('/GET|HEAD/',$verb))\n\t\t\t$this->hive['BODY']=$body?:http_build_query($args);\n\t\t$this->hive['AJAX']=isset($parts[5]) &&\n\t\t\tpreg_match('/ajax/i',$parts[5]);\n\t\t$this->hive['CLI']=isset($parts[5]) &&\n\t\t\tpreg_match('/cli/i',$parts[5]);\n\t\treturn $this->run();\n\t}\n\n\t/**\n\t*\tAssemble url from alias name\n\t*\t@return string\n\t*\t@param $name string\n\t*\t@param $params array|string\n\t*\t@param $query string|array\n\t*\t@param $fragment string\n\t**/\n\tfunction alias($name,$params=[],$query=NULL,$fragment=NULL) {\n\t\tif (!is_array($params))\n\t\t\t$params=$this->parse($params);\n\t\tif (empty($this->hive['ALIASES'][$name]))\n\t\t\tuser_error(sprintf(self::E_Named,$name),E_USER_ERROR);\n\t\t$url=$this->build($this->hive['ALIASES'][$name],$params);\n\t\tif (is_array($query))\n\t\t\t$query=http_build_query($query);\n\t\treturn $url.($query?('?'.$query):'').($fragment?'#'.$fragment:'');\n\t}\n\n\t/**\n\t*\tBind handler to route pattern\n\t*\t@return NULL\n\t*\t@param $pattern string|array\n\t*\t@param $handler callback\n\t*\t@param $ttl int\n\t*\t@param $kbps int\n\t**/\n\tfunction route($pattern,$handler,$ttl=0,$kbps=0) {\n\t\t$types=['sync','ajax','cli'];\n\t\t$alias=null;\n\t\tif (is_array($pattern)) {\n\t\t\tforeach ($pattern as $item)\n\t\t\t\t$this->route($item,$handler,$ttl,$kbps);\n\t\t\treturn;\n\t\t}\n\t\tpreg_match('/([\\|\\w]+)\\h+(?:(?:@?(.+?)\\h*:\\h*)?(@(\\w+)|[^\\h]+))'.\n\t\t\t'(?:\\h+\\[('.implode('|',$types).')\\])?/u',$pattern,$parts);\n\t\tif (isset($parts[2]) && $parts[2]) {\n\t\t\tif (!preg_match('/^\\w+$/',$parts[2]))\n\t\t\t\tuser_error(sprintf(self::E_Alias,$parts[2]),E_USER_ERROR);\n\t\t\t$this->hive['ALIASES'][$alias=$parts[2]]=$parts[3];\n\t\t}\n\t\telseif (!empty($parts[4])) {\n\t\t\tif (empty($this->hive['ALIASES'][$parts[4]]))\n\t\t\t\tuser_error(sprintf(self::E_Named,$parts[4]),E_USER_ERROR);\n\t\t\t$parts[3]=$this->hive['ALIASES'][$alias=$parts[4]];\n\t\t}\n\t\tif (empty($parts[3]))\n\t\t\tuser_error(sprintf(self::E_Pattern,$pattern),E_USER_ERROR);\n\t\t$type=empty($parts[5])?0:constant('self::REQ_'.strtoupper($parts[5]));\n\t\tforeach ($this->split($parts[1]) as $verb) {\n\t\t\tif (!preg_match('/'.self::VERBS.'/',$verb))\n\t\t\t\t$this->error(501,$verb.' '.$this->hive['URI']);\n\t\t\t$this->hive['ROUTES'][$parts[3]][$type][strtoupper($verb)]=\n\t\t\t\t[$handler,$ttl,$kbps,$alias];\n\t\t}\n\t}\n\n\t/**\n\t*\tReroute to specified URI\n\t*\t@return NULL\n\t*\t@param $url array|string\n\t*\t@param $permanent bool\n\t*\t@param $die bool\n\t**/\n\tfunction reroute($url=NULL,$permanent=FALSE,$die=TRUE) {\n\t\tif (!$url)\n\t\t\t$url=$this->hive['REALM'];\n\t\tif (is_array($url))\n\t\t\t$url=call_user_func_array([$this,'alias'],$url);\n\t\telseif (preg_match('/^(?:@([^\\/()?#]+)(?:\\((.+?)\\))*(\\?[^#]+)*(#.+)*)/',\n\t\t\t$url,$parts) && isset($this->hive['ALIASES'][$parts[1]]))\n\t\t\t$url=$this->build($this->hive['ALIASES'][$parts[1]],\n\t\t\t\t\tisset($parts[2])?$this->parse($parts[2]):[]).\n\t\t\t\t(isset($parts[3])?$parts[3]:'').(isset($parts[4])?$parts[4]:'');\n\t\tif (($handler=$this->hive['ONREROUTE']) &&\n\t\t\t$this->call($handler,[$url,$permanent,$die])!==FALSE)\n\t\t\treturn;\n\t\tif ($url[0]!='/' && !preg_match('/^\\w+:\\/\\//i',$url))\n\t\t\t$url='/'.$url;\n\t\tif ($url[0]=='/' && (empty($url[1]) || $url[1]!='/')) {\n\t\t\t$port=$this->hive['PORT'];\n\t\t\t$port=in_array($port,[80,443])?'':(':'.$port);\n\t\t\t$url=$this->hive['SCHEME'].'://'.\n\t\t\t\t$this->hive['HOST'].$port.$this->hive['BASE'].$url;\n\t\t}\n\t\tif ($this->hive['CLI'])\n\t\t\t$this->mock('GET '.$url.' [cli]');\n\t\telse {\n\t\t\theader('Location: '.$url);\n\t\t\t$this->status($permanent?301:302);\n\t\t\tif ($die)\n\t\t\t\tdie;\n\t\t}\n\t}\n\n\t/**\n\t*\tProvide ReST interface by mapping HTTP verb to class method\n\t*\t@return NULL\n\t*\t@param $url string\n\t*\t@param $class string|object\n\t*\t@param $ttl int\n\t*\t@param $kbps int\n\t**/\n\tfunction map($url,$class,$ttl=0,$kbps=0) {\n\t\tif (is_array($url)) {\n\t\t\tforeach ($url as $item)\n\t\t\t\t$this->map($item,$class,$ttl,$kbps);\n\t\t\treturn;\n\t\t}\n\t\tforeach (explode('|',self::VERBS) as $method)\n\t\t\t$this->route($method.' '.$url,is_string($class)?\n\t\t\t\t$class.'->'.$this->hive['PREMAP'].strtolower($method):\n\t\t\t\t[$class,$this->hive['PREMAP'].strtolower($method)],\n\t\t\t\t$ttl,$kbps);\n\t}\n\n\t/**\n\t*\tRedirect a route to another URL\n\t*\t@return NULL\n\t*\t@param $pattern string|array\n\t*\t@param $url string\n\t*\t@param $permanent bool\n\t*/\n\tfunction redirect($pattern,$url,$permanent=TRUE) {\n\t\tif (is_array($pattern)) {\n\t\t\tforeach ($pattern as $item)\n\t\t\t\t$this->redirect($item,$url,$permanent);\n\t\t\treturn;\n\t\t}\n\t\t$this->route($pattern,function($fw) use($url,$permanent) {\n\t\t\t$fw->reroute($url,$permanent);\n\t\t});\n\t}\n\n\t/**\n\t*\tReturn TRUE if IPv4 address exists in DNSBL\n\t*\t@return bool\n\t*\t@param $ip string\n\t**/\n\tfunction blacklisted($ip) {\n\t\tif ($this->hive['DNSBL'] &&\n\t\t\t!in_array($ip,\n\t\t\t\tis_array($this->hive['EXEMPT'])?\n\t\t\t\t\t$this->hive['EXEMPT']:\n\t\t\t\t\t$this->split($this->hive['EXEMPT']))) {\n\t\t\t// Reverse IPv4 dotted quad\n\t\t\t$rev=implode('.',array_reverse(explode('.',$ip)));\n\t\t\tforeach (is_array($this->hive['DNSBL'])?\n\t\t\t\t$this->hive['DNSBL']:\n\t\t\t\t$this->split($this->hive['DNSBL']) as $server)\n\t\t\t\t// DNSBL lookup\n\t\t\t\tif (checkdnsrr($rev.'.'.$server,'A'))\n\t\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tApplies the specified URL mask and returns parameterized matches\n\t*\t@return $args array\n\t*\t@param $pattern string\n\t*\t@param $url string|NULL\n\t**/\n\tfunction mask($pattern,$url=NULL) {\n\t\tif (!$url)\n\t\t\t$url=$this->rel($this->hive['URI']);\n\t\t$case=$this->hive['CASELESS']?'i':'';\n\t\t$wild=preg_quote($pattern,'/');\n\t\t$i=0;\n\t\twhile (is_int($pos=strpos($wild,'\\*'))) {\n\t\t\t$wild=substr_replace($wild,'(?P<_'.$i.'>[^\\?]*)',$pos,2);\n\t\t\t$i++;\n\t\t}\n\t\tpreg_match('/^'.\n\t\t\tpreg_replace(\n\t\t\t\t'/((\\\\\\{)?@(\\w+\\b)(?(2)\\\\\\}))/',\n\t\t\t\t'(?P<\\3>[^\\/\\?]+)',\n\t\t\t\t$wild).'\\/?$/'.$case.'um',$url,$args);\n\t\tforeach (array_keys($args) as $key) {\n\t\t\tif (preg_match('/^_\\d+$/',$key)) {\n\t\t\t\tif (empty($args['*']))\n\t\t\t\t\t$args['*']=$args[$key];\n\t\t\t\telse {\n\t\t\t\t\tif (is_string($args['*']))\n\t\t\t\t\t\t$args['*']=[$args['*']];\n\t\t\t\t\tarray_push($args['*'],$args[$key]);\n\t\t\t\t}\n\t\t\t\tunset($args[$key]);\n\t\t\t}\n\t\t\telseif (is_numeric($key) && $key)\n\t\t\t\tunset($args[$key]);\n\t\t}\n\t\treturn $args;\n\t}\n\n\t/**\n\t*\tMatch routes against incoming URI\n\t*\t@return mixed\n\t**/\n\tfunction run() {\n\t\tif ($this->blacklisted($this->hive['IP']))\n\t\t\t// Spammer detected\n\t\t\t$this->error(403);\n\t\tif (!$this->hive['ROUTES'])\n\t\t\t// No routes defined\n\t\t\tuser_error(self::E_Routes,E_USER_ERROR);\n\t\t// Match specific routes first\n\t\t$paths=[];\n\t\tforeach ($keys=array_keys($this->hive['ROUTES']) as $key) {\n\t\t\t$path=preg_replace('/@\\w+/','*@',$key);\n\t\t\tif (substr($path,-1)!='*')\n\t\t\t\t$path.='+';\n\t\t\t$paths[]=$path;\n\t\t}\n\t\t$vals=array_values($this->hive['ROUTES']);\n\t\tarray_multisort($paths,SORT_DESC,$keys,$vals);\n\t\t$this->hive['ROUTES']=array_combine($keys,$vals);\n\t\t// Convert to BASE-relative URL\n\t\t$req=urldecode($this->hive['PATH']);\n\t\t$preflight=FALSE;\n\t\tif ($cors=(isset($this->hive['HEADERS']['Origin']) &&\n\t\t\t$this->hive['CORS']['origin'])) {\n\t\t\t$cors=$this->hive['CORS'];\n\t\t\theader('Access-Control-Allow-Origin: '.$cors['origin']);\n\t\t\theader('Access-Control-Allow-Credentials: '.\n\t\t\t\t$this->export($cors['credentials']));\n\t\t\t$preflight=\n\t\t\t\tisset($this->hive['HEADERS']['Access-Control-Request-Method']);\n\t\t}\n\t\t$allowed=[];\n\t\tforeach ($this->hive['ROUTES'] as $pattern=>$routes) {\n\t\t\tif (!$args=$this->mask($pattern,$req))\n\t\t\t\tcontinue;\n\t\t\tksort($args);\n\t\t\t$route=NULL;\n\t\t\t$ptr=$this->hive['CLI']?self::REQ_CLI:$this->hive['AJAX']+1;\n\t\t\tif (isset($routes[$ptr][$this->hive['VERB']]) ||\n\t\t\t\tisset($routes[$ptr=0]))\n\t\t\t\t$route=$routes[$ptr];\n\t\t\tif (!$route)\n\t\t\t\tcontinue;\n\t\t\tif (isset($route[$this->hive['VERB']]) && !$preflight) {\n\t\t\t\tif ($this->hive['VERB']=='GET' &&\n\t\t\t\t\tpreg_match('/.+\\/$/',$this->hive['PATH']))\n\t\t\t\t\t$this->reroute(substr($this->hive['PATH'],0,-1).\n\t\t\t\t\t\t($this->hive['QUERY']?('?'.$this->hive['QUERY']):''));\n\t\t\t\tlist($handler,$ttl,$kbps,$alias)=$route[$this->hive['VERB']];\n\t\t\t\t// Capture values of route pattern tokens\n\t\t\t\t$this->hive['PARAMS']=$args;\n\t\t\t\t// Save matching route\n\t\t\t\t$this->hive['ALIAS']=$alias;\n\t\t\t\t$this->hive['PATTERN']=$pattern;\n\t\t\t\tif ($cors && $cors['expose'])\n\t\t\t\t\theader('Access-Control-Expose-Headers: '.\n\t\t\t\t\t\t(is_array($cors['expose'])?\n\t\t\t\t\t\t\timplode(',',$cors['expose']):$cors['expose']));\n\t\t\t\tif (is_string($handler)) {\n\t\t\t\t\t// Replace route pattern tokens in handler if any\n\t\t\t\t\t$handler=preg_replace_callback('/({)?@(\\w+\\b)(?(1)})/',\n\t\t\t\t\t\tfunction($id) use($args) {\n\t\t\t\t\t\t\t$pid=count($id)>2?2:1;\n\t\t\t\t\t\t\treturn isset($args[$id[$pid]])?\n\t\t\t\t\t\t\t\t$args[$id[$pid]]:\n\t\t\t\t\t\t\t\t$id[0];\n\t\t\t\t\t\t},\n\t\t\t\t\t\t$handler\n\t\t\t\t\t);\n\t\t\t\t\tif (preg_match('/(.+)\\h*(?:->|::)/',$handler,$match) &&\n\t\t\t\t\t\t!class_exists($match[1]))\n\t\t\t\t\t\t$this->error(404);\n\t\t\t\t}\n\t\t\t\t// Process request\n\t\t\t\t$result=NULL;\n\t\t\t\t$body='';\n\t\t\t\t$now=microtime(TRUE);\n\t\t\t\tif (preg_match('/GET|HEAD/',$this->hive['VERB']) && $ttl) {\n\t\t\t\t\t// Only GET and HEAD requests are cacheable\n\t\t\t\t\t$headers=$this->hive['HEADERS'];\n\t\t\t\t\t$cache=Cache::instance();\n\t\t\t\t\t$cached=$cache->exists(\n\t\t\t\t\t\t$hash=$this->hash($this->hive['VERB'].' '.\n\t\t\t\t\t\t\t$this->hive['URI']).'.url',$data);\n\t\t\t\t\tif ($cached) {\n\t\t\t\t\t\tif (isset($headers['If-Modified-Since']) &&\n\t\t\t\t\t\t\tstrtotime($headers['If-Modified-Since'])+\n\t\t\t\t\t\t\t\t$ttl>$now) {\n\t\t\t\t\t\t\t$this->status(304);\n\t\t\t\t\t\t\tdie;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Retrieve from cache backend\n\t\t\t\t\t\tlist($headers,$body,$result)=$data;\n\t\t\t\t\t\tif (!$this->hive['CLI'])\n\t\t\t\t\t\t\tarray_walk($headers,'header');\n\t\t\t\t\t\t$this->expire($cached[0]+$ttl-$now);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t// Expire HTTP client-cached page\n\t\t\t\t\t\t$this->expire($ttl);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t$this->expire(0);\n\t\t\t\tif (!strlen($body)) {\n\t\t\t\t\tif (!$this->hive['RAW'] && !$this->hive['BODY'])\n\t\t\t\t\t\t$this->hive['BODY']=file_get_contents('php://input');\n\t\t\t\t\tob_start();\n\t\t\t\t\t// Call route handler\n\t\t\t\t\t$result=$this->call($handler,[$this,$args,$handler],\n\t\t\t\t\t\t'beforeroute,afterroute');\n\t\t\t\t\t$body=ob_get_clean();\n\t\t\t\t\tif (isset($cache) && !error_get_last()) {\n\t\t\t\t\t\t// Save to cache backend\n\t\t\t\t\t\t$cache->set($hash,[\n\t\t\t\t\t\t\t// Remove cookies\n\t\t\t\t\t\t\tpreg_grep('/Set-Cookie\\:/',headers_list(),\n\t\t\t\t\t\t\t\tPREG_GREP_INVERT),$body,$result],$ttl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$this->hive['RESPONSE']=$body;\n\t\t\t\tif (!$this->hive['QUIET']) {\n\t\t\t\t\tif ($kbps) {\n\t\t\t\t\t\t$ctr=0;\n\t\t\t\t\t\tforeach (str_split($body,1024) as $part) {\n\t\t\t\t\t\t\t// Throttle output\n\t\t\t\t\t\t\t$ctr++;\n\t\t\t\t\t\t\tif ($ctr/$kbps>($elapsed=microtime(TRUE)-$now) &&\n\t\t\t\t\t\t\t\t!connection_aborted())\n\t\t\t\t\t\t\t\tusleep(1e6*($ctr/$kbps-$elapsed));\n\t\t\t\t\t\t\techo $part;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\techo $body;\n\t\t\t\t}\n\t\t\t\tif ($result || $this->hive['VERB']!='OPTIONS')\n\t\t\t\t\treturn $result;\n\t\t\t}\n\t\t\t$allowed=array_merge($allowed,array_keys($route));\n\t\t}\n\t\tif (!$allowed)\n\t\t\t// URL doesn't match any route\n\t\t\t$this->error(404);\n\t\telseif (!$this->hive['CLI']) {\n\t\t\tif (!preg_grep('/Allow:/',$headers_send=headers_list()))\n\t\t\t\t// Unhandled HTTP method\n\t\t\t\theader('Allow: '.implode(',',array_unique($allowed)));\n\t\t\tif ($cors) {\n\t\t\t\tif (!preg_grep('/Access-Control-Allow-Methods:/',$headers_send))\n\t\t\t\t\theader('Access-Control-Allow-Methods: OPTIONS,'.\n\t\t\t\t\t\timplode(',',$allowed));\n\t\t\t\tif ($cors['headers'] &&\n\t\t\t\t\t!preg_grep('/Access-Control-Allow-Headers:/',$headers_send))\n\t\t\t\t\theader('Access-Control-Allow-Headers: '.\n\t\t\t\t\t\t(is_array($cors['headers'])?\n\t\t\t\t\t\t\timplode(',',$cors['headers']):\n\t\t\t\t\t\t\t$cors['headers']));\n\t\t\t\tif ($cors['ttl']>0)\n\t\t\t\t\theader('Access-Control-Max-Age: '.$cors['ttl']);\n\t\t\t}\n\t\t\tif ($this->hive['VERB']!='OPTIONS')\n\t\t\t\t$this->error(405);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tLoop until callback returns TRUE (for long polling)\n\t*\t@return mixed\n\t*\t@param $func callback\n\t*\t@param $args array\n\t*\t@param $timeout int\n\t**/\n\tfunction until($func,$args=NULL,$timeout=60) {\n\t\tif (!$args)\n\t\t\t$args=[];\n\t\t$time=time();\n\t\t$max=ini_get('max_execution_time');\n\t\t$limit=max(0,($max?min($timeout,$max):$timeout)-1);\n\t\t$out='';\n\t\t// Turn output buffering on\n\t\tob_start();\n\t\t// Not for the weak of heart\n\t\twhile (\n\t\t\t// No error occurred\n\t\t\t!$this->hive['ERROR'] &&\n\t\t\t// Got time left?\n\t\t\ttime()-$time+1<$limit &&\n\t\t\t// Still alive?\n\t\t\t!connection_aborted() &&\n\t\t\t// Restart session\n\t\t\t!headers_sent() &&\n\t\t\t(session_status()==PHP_SESSION_ACTIVE || session_start()) &&\n\t\t\t// CAUTION: Callback will kill host if it never becomes truthy!\n\t\t\t!$out=$this->call($func,$args)) {\n\t\t\tif (!$this->hive['CLI'])\n\t\t\t\tsession_commit();\n\t\t\t// Hush down\n\t\t\tsleep(1);\n\t\t}\n\t\tob_flush();\n\t\tflush();\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tDisconnect HTTP client;\n\t*\tSet FcgidOutputBufferSize to zero if server uses mod_fcgid;\n\t*\tDisable mod_deflate when rendering text/html output\n\t**/\n\tfunction abort() {\n\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\tsession_start();\n\t\t$out='';\n\t\twhile (ob_get_level())\n\t\t\t$out=ob_get_clean().$out;\n\t\tif (!headers_sent()) {\n\t\t\theader('Content-Length: '.strlen($out));\n\t\t\theader('Connection: close');\n\t\t}\n\t\tsession_commit();\n\t\techo $out;\n\t\tflush();\n\t\tif (function_exists('fastcgi_finish_request'))\n\t\t\tfastcgi_finish_request();\n\t}\n\n\t/**\n\t*\tGrab the real route handler behind the string expression\n\t*\t@return string|array\n\t*\t@param $func string\n\t*\t@param $args array\n\t**/\n\tfunction grab($func,$args=NULL) {\n\t\tif (preg_match('/(.+)\\h*(->|::)\\h*(.+)/s',$func,$parts)) {\n\t\t\t// Convert string to executable PHP callback\n\t\t\tif (!class_exists($parts[1]))\n\t\t\t\tuser_error(sprintf(self::E_Class,$parts[1]),E_USER_ERROR);\n\t\t\tif ($parts[2]=='->') {\n\t\t\t\tif (is_subclass_of($parts[1],'Prefab'))\n\t\t\t\t\t$parts[1]=call_user_func($parts[1].'::instance');\n\t\t\t\telseif ($container=$this->get('CONTAINER')) {\n\t\t\t\t\tif (is_object($container) && is_callable([$container,'has'])\n\t\t\t\t\t\t&& $container->has($parts[1])) // PSR11\n\t\t\t\t\t\t$parts[1]=call_user_func([$container,'get'],$parts[1]);\n\t\t\t\t\telseif (is_callable($container))\n\t\t\t\t\t\t$parts[1]=call_user_func($container,$parts[1],$args);\n\t\t\t\t\telseif (is_string($container) &&\n\t\t\t\t\t\tis_subclass_of($container,'Prefab'))\n\t\t\t\t\t\t$parts[1]=call_user_func($container.'::instance')->\n\t\t\t\t\t\t\tget($parts[1]);\n\t\t\t\t\telse\n\t\t\t\t\t\tuser_error(sprintf(self::E_Class,\n\t\t\t\t\t\t\t$this->stringify($parts[1])),\n\t\t\t\t\t\t\tE_USER_ERROR);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$ref=new ReflectionClass($parts[1]);\n\t\t\t\t\t$parts[1]=method_exists($parts[1],'__construct') && $args?\n\t\t\t\t\t\t$ref->newinstanceargs($args):\n\t\t\t\t\t\t$ref->newinstance();\n\t\t\t\t}\n\t\t\t}\n\t\t\t$func=[$parts[1],$parts[3]];\n\t\t}\n\t\treturn $func;\n\t}\n\n\t/**\n\t*\tExecute callback/hooks (supports 'class->method' format)\n\t*\t@return mixed|FALSE\n\t*\t@param $func callback\n\t*\t@param $args mixed\n\t*\t@param $hooks string\n\t**/\n\tfunction call($func,$args=NULL,$hooks='') {\n\t\tif (!is_array($args))\n\t\t\t$args=[$args];\n\t\t// Grab the real handler behind the string representation\n\t\tif (is_string($func))\n\t\t\t$func=$this->grab($func,$args);\n\t\t// Execute function; abort if callback/hook returns FALSE\n\t\tif (!is_callable($func))\n\t\t\t// No route handler\n\t\t\tif ($hooks=='beforeroute,afterroute') {\n\t\t\t\t$allowed=[];\n\t\t\t\tif (is_array($func))\n\t\t\t\t\t$allowed=array_intersect(\n\t\t\t\t\t\tarray_map('strtoupper',get_class_methods($func[0])),\n\t\t\t\t\t\texplode('|',self::VERBS)\n\t\t\t\t\t);\n\t\t\t\theader('Allow: '.implode(',',$allowed));\n\t\t\t\t$this->error(405);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuser_error(sprintf(self::E_Method,\n\t\t\t\t\tis_string($func)?$func:$this->stringify($func)),\n\t\t\t\t\tE_USER_ERROR);\n\t\t$obj=FALSE;\n\t\tif (is_array($func)) {\n\t\t\t$hooks=$this->split($hooks);\n\t\t\t$obj=TRUE;\n\t\t}\n\t\t// Execute pre-route hook if any\n\t\tif ($obj && $hooks && in_array($hook='beforeroute',$hooks) &&\n\t\t\tmethod_exists($func[0],$hook) &&\n\t\t\tcall_user_func_array([$func[0],$hook],$args)===FALSE)\n\t\t\treturn FALSE;\n\t\t// Execute callback\n\t\t$out=call_user_func_array($func,$args?:[]);\n\t\tif ($out===FALSE)\n\t\t\treturn FALSE;\n\t\t// Execute post-route hook if any\n\t\tif ($obj && $hooks && in_array($hook='afterroute',$hooks) &&\n\t\t\tmethod_exists($func[0],$hook) &&\n\t\t\tcall_user_func_array([$func[0],$hook],$args)===FALSE)\n\t\t\treturn FALSE;\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tExecute specified callbacks in succession; Apply same arguments\n\t*\tto all callbacks\n\t*\t@return array\n\t*\t@param $funcs array|string\n\t*\t@param $args mixed\n\t**/\n\tfunction chain($funcs,$args=NULL) {\n\t\t$out=[];\n\t\tforeach (is_array($funcs)?$funcs:$this->split($funcs) as $func)\n\t\t\t$out[]=$this->call($func,$args);\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tExecute specified callbacks in succession; Relay result of\n\t*\tprevious callback as argument to the next callback\n\t*\t@return array\n\t*\t@param $funcs array|string\n\t*\t@param $args mixed\n\t**/\n\tfunction relay($funcs,$args=NULL) {\n\t\tforeach (is_array($funcs)?$funcs:$this->split($funcs) as $func)\n\t\t\t$args=[$this->call($func,$args)];\n\t\treturn array_shift($args);\n\t}\n\n\t/**\n\t*\tConfigure framework according to .ini-style file settings;\n\t*\tIf optional 2nd arg is provided, template strings are interpreted\n\t*\t@return object\n\t*\t@param $source string|array\n\t*\t@param $allow bool\n\t**/\n\tfunction config($source,$allow=FALSE) {\n\t\tif (is_string($source))\n\t\t\t$source=$this->split($source);\n\t\tif ($allow)\n\t\t\t$preview=Preview::instance();\n\t\tforeach ($source as $file) {\n\t\t\tpreg_match_all(\n\t\t\t\t'/(?<=^|\\n)(?:'.\n\t\t\t\t\t'\\[(?<section>.+?)\\]|'.\n\t\t\t\t\t'(?<lval>[^\\h\\r\\n;].*?)\\h*=\\h*'.\n\t\t\t\t\t'(?<rval>(?:\\\\\\\\\\h*\\r?\\n|.+?)*)'.\n\t\t\t\t')(?=\\r?\\n|$)/',\n\t\t\t\t$this->read($file),\n\t\t\t\t$matches,PREG_SET_ORDER);\n\t\t\tif ($matches) {\n\t\t\t\t$sec='globals';\n\t\t\t\t$cmd=[];\n\t\t\t\tforeach ($matches as $match) {\n\t\t\t\t\tif ($match['section']) {\n\t\t\t\t\t\t$sec=$match['section'];\n\t\t\t\t\t\tif (preg_match(\n\t\t\t\t\t\t\t'/^(?!(?:global|config|route|map|redirect)s\\b)'.\n\t\t\t\t\t\t\t'((?:[^:])+)/i',$sec,$msec) &&\n\t\t\t\t\t\t\t!$this->exists($msec[0]))\n\t\t\t\t\t\t\t$this->set($msec[0],NULL);\n\t\t\t\t\t\tpreg_match('/^(config|route|map|redirect)s\\b|'.\n\t\t\t\t\t\t\t'^((?:[^:])+)\\s*\\>\\s*(.*)/i',$sec,$cmd);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ($allow)\n\t\t\t\t\t\tforeach (['lval','rval'] as $ndx)\n\t\t\t\t\t\t\t$match[$ndx]=$preview->\n\t\t\t\t\t\t\t\tresolve($match[$ndx],NULL,0,FALSE,FALSE);\n\t\t\t\t\tif (!empty($cmd)) {\n\t\t\t\t\t\tisset($cmd[3])?\n\t\t\t\t\t\t$this->call($cmd[3],\n\t\t\t\t\t\t\t[$match['lval'],$match['rval'],$cmd[2]]):\n\t\t\t\t\t\tcall_user_func_array(\n\t\t\t\t\t\t\t[$this,$cmd[1]],\n\t\t\t\t\t\t\tarray_merge([$match['lval']],\n\t\t\t\t\t\t\t\tstr_getcsv($cmd[1]=='config'?\n\t\t\t\t\t\t\t\t$this->cast($match['rval']):\n\t\t\t\t\t\t\t\t\t$match['rval']))\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$rval=preg_replace(\n\t\t\t\t\t\t\t'/\\\\\\\\\\h*(\\r?\\n)/','\\1',$match['rval']);\n\t\t\t\t\t\t$ttl=NULL;\n\t\t\t\t\t\tif (preg_match('/^(.+)\\|\\h*(\\d+)$/',$rval,$tmp)) {\n\t\t\t\t\t\t\tarray_shift($tmp);\n\t\t\t\t\t\t\tlist($rval,$ttl)=$tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$args=array_map(\n\t\t\t\t\t\t\tfunction($val) {\n\t\t\t\t\t\t\t\t$val=$this->cast($val);\n\t\t\t\t\t\t\t\tif (is_string($val))\n\t\t\t\t\t\t\t\t\t$val=strlen($val)?\n\t\t\t\t\t\t\t\t\t\tpreg_replace('/\\\\\\\\\"/','\"',$val):\n\t\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t\t\t\t\treturn $val;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// Mark quoted strings with 0x00 whitespace\n\t\t\t\t\t\t\tstr_getcsv(preg_replace(\n\t\t\t\t\t\t\t\t'/(?<!\\\\\\\\)(\")(.*?)\\1/',\n\t\t\t\t\t\t\t\t\"\\\\1\\x00\\\\2\\\\1\",trim($rval)))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tpreg_match('/^(?<section>[^:]+)(?:\\:(?<func>.+))?/',\n\t\t\t\t\t\t\t$sec,$parts);\n\t\t\t\t\t\t$func=isset($parts['func'])?$parts['func']:NULL;\n\t\t\t\t\t\t$custom=(strtolower($parts['section'])!='globals');\n\t\t\t\t\t\tif ($func)\n\t\t\t\t\t\t\t$args=[$this->call($func,$args)];\n\t\t\t\t\t\tif (count($args)>1)\n\t\t\t\t\t\t\t$args=[$args];\n\t\t\t\t\t\tif (isset($ttl))\n\t\t\t\t\t\t\t$args=array_merge($args,[$ttl]);\n\t\t\t\t\t\tcall_user_func_array(\n\t\t\t\t\t\t\t[$this,'set'],\n\t\t\t\t\t\t\tarray_merge(\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t($custom?($parts['section'].'.'):'').\n\t\t\t\t\t\t\t\t\t$match['lval']\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t$args\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $this;\n\t}\n\n\t/**\n\t*\tCreate mutex, invoke callback then drop ownership when done\n\t*\t@return mixed\n\t*\t@param $id string\n\t*\t@param $func callback\n\t*\t@param $args mixed\n\t**/\n\tfunction mutex($id,$func,$args=NULL) {\n\t\tif (!is_dir($tmp=$this->hive['TEMP']))\n\t\t\tmkdir($tmp,self::MODE,TRUE);\n\t\t// Use filesystem lock\n\t\tif (is_file($lock=$tmp.\n\t\t\t$this->get('SEED').'.'.$this->hash($id).'.lock') &&\n\t\t\tfilemtime($lock)+ini_get('max_execution_time')<microtime(TRUE))\n\t\t\t// Stale lock\n\t\t\t@unlink($lock);\n\t\twhile (!($handle=@fopen($lock,'x')) && !connection_aborted())\n\t\t\tusleep(mt_rand(0,100));\n\t\t$this->locks[$id]=$lock;\n\t\t$out=$this->call($func,$args);\n\t\tfclose($handle);\n\t\t@unlink($lock);\n\t\tunset($this->locks[$id]);\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tRead file (with option to apply Unix LF as standard line ending)\n\t*\t@return string\n\t*\t@param $file string\n\t*\t@param $lf bool\n\t**/\n\tfunction read($file,$lf=FALSE) {\n\t\t$out=@file_get_contents($file);\n\t\treturn $lf?preg_replace('/\\r\\n|\\r/',\"\\n\",$out):$out;\n\t}\n\n\t/**\n\t*\tExclusive file write\n\t*\t@return int|FALSE\n\t*\t@param $file string\n\t*\t@param $data mixed\n\t*\t@param $append bool\n\t**/\n\tfunction write($file,$data,$append=FALSE) {\n\t\treturn file_put_contents($file,$data,$this->hive['LOCK']|($append?FILE_APPEND:0));\n\t}\n\n\t/**\n\t*\tApply syntax highlighting\n\t*\t@return string\n\t*\t@param $text string\n\t**/\n\tfunction highlight($text) {\n\t\t$out='';\n\t\t$pre=FALSE;\n\t\t$text=trim($text);\n\t\tif ($text && !preg_match('/^<\\?php/',$text)) {\n\t\t\t$text='<?php '.$text;\n\t\t\t$pre=TRUE;\n\t\t}\n\t\tforeach (token_get_all($text) as $token)\n\t\t\tif ($pre)\n\t\t\t\t$pre=FALSE;\n\t\t\telse\n\t\t\t\t$out.='<span'.\n\t\t\t\t\t(is_array($token)?\n\t\t\t\t\t\t(' class=\"'.\n\t\t\t\t\t\t\tsubstr(strtolower(token_name($token[0])),2).'\">'.\n\t\t\t\t\t\t\t$this->encode($token[1]).''):\n\t\t\t\t\t\t('>'.$this->encode($token))).\n\t\t\t\t\t'</span>';\n\t\treturn $out?('<code>'.$out.'</code>'):$text;\n\t}\n\n\t/**\n\t*\tDump expression with syntax highlighting\n\t*\t@param $expr mixed\n\t**/\n\tfunction dump($expr) {\n\t\techo $this->highlight($this->stringify($expr));\n\t}\n\n\t/**\n\t*\tReturn path (and query parameters) relative to the base directory\n\t*\t@return string\n\t*\t@param $url string\n\t**/\n\tfunction rel($url) {\n\t\treturn preg_replace('/^(?:https?:\\/\\/)?'.\n\t\t\tpreg_quote($this->hive['BASE'],'/').'(\\/.*|$)/','\\1',$url);\n\t}\n\n\t/**\n\t*\tNamespace-aware class autoloader\n\t*\t@return mixed\n\t*\t@param $class string\n\t**/\n\tprotected function autoload($class) {\n\t\t$class=$this->fixslashes(ltrim($class,'\\\\'));\n\t\t/** @var callable $func */\n\t\t$func=NULL;\n\t\tif (is_array($path=$this->hive['AUTOLOAD']) &&\n\t\t\tisset($path[1]) && is_callable($path[1]))\n\t\t\tlist($path,$func)=$path;\n\t\tforeach ($this->split($this->hive['PLUGINS'].';'.$path) as $auto)\n\t\t\tif ($func && is_file($file=$func($auto.$class).'.php') ||\n\t\t\t\tis_file($file=$auto.$class.'.php') ||\n\t\t\t\tis_file($file=$auto.strtolower($class).'.php') ||\n\t\t\t\tis_file($file=strtolower($auto.$class).'.php'))\n\t\t\t\treturn require($file);\n\t}\n\n\t/**\n\t*\tExecute framework/application shutdown sequence\n\t*\t@param $cwd string\n\t**/\n\tfunction unload($cwd) {\n\t\tchdir($cwd);\n\t\tif (!($error=error_get_last()) &&\n\t\t\tsession_status()==PHP_SESSION_ACTIVE)\n\t\t\tsession_commit();\n\t\tforeach ($this->locks as $lock)\n\t\t\t@unlink($lock);\n\t\t$handler=$this->hive['UNLOAD'];\n\t\tif ((!$handler || $this->call($handler,$this)===FALSE) &&\n\t\t\t$error && in_array($error['type'],\n\t\t\t[E_ERROR,E_PARSE,E_CORE_ERROR,E_COMPILE_ERROR]))\n\t\t\t// Fatal error detected\n\t\t\t$this->error(500,\n\t\t\t\tsprintf(self::E_Fatal,$error['message']),[$error]);\n\t}\n\n\t/**\n\t*\tConvenience method for checking hive key\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction offsetexists($key) {\n\t\treturn $this->exists($key);\n\t}\n\n\t/**\n\t*\tConvenience method for assigning hive value\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction offsetset($key,$val) {\n\t\treturn $this->set($key,$val);\n\t}\n\n\t/**\n\t*\tConvenience method for retrieving hive value\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction &offsetget($key) {\n\t\t$val=&$this->ref($key);\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tConvenience method for removing hive key\n\t*\t@param $key string\n\t**/\n\tfunction offsetunset($key) {\n\t\t$this->clear($key);\n\t}\n\n\t/**\n\t*\tAlias for offsetexists()\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction __isset($key) {\n\t\treturn $this->offsetexists($key);\n\t}\n\n\t/**\n\t*\tAlias for offsetset()\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction __set($key,$val) {\n\t\treturn $this->offsetset($key,$val);\n\t}\n\n\t/**\n\t*\tAlias for offsetget()\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction &__get($key) {\n\t\t$val=&$this->offsetget($key);\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tAlias for offsetunset()\n\t*\t@param $key string\n\t**/\n\tfunction __unset($key) {\n\t\t$this->offsetunset($key);\n\t}\n\n\t/**\n\t*\tCall function identified by hive key\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $args array\n\t**/\n\tfunction __call($key,array $args) {\n\t\tif ($this->exists($key,$val))\n\t\t\treturn call_user_func_array($val,$args);\n\t\tuser_error(sprintf(self::E_Method,$key),E_USER_ERROR);\n\t}\n\n\t//! Prohibit cloning\n\tprivate function __clone() {\n\t}\n\n\t//! Bootstrap\n\tfunction __construct() {\n\t\t// Managed directives\n\t\tini_set('default_charset',$charset='UTF-8');\n\t\tif (extension_loaded('mbstring'))\n\t\t\tmb_internal_encoding($charset);\n\t\tini_set('display_errors',0);\n\t\t// Deprecated directives\n\t\t@ini_set('magic_quotes_gpc',0);\n\t\t@ini_set('register_globals',0);\n\t\t// Intercept errors/exceptions; PHP5.3-compatible\n\t\t$check=error_reporting((E_ALL|E_STRICT)&~(E_NOTICE|E_USER_NOTICE));\n\t\tset_exception_handler(\n\t\t\tfunction($obj) {\n\t\t\t\t/** @var Exception $obj */\n\t\t\t\t$this->hive['EXCEPTION']=$obj;\n\t\t\t\t$this->error(500,\n\t\t\t\t\t$obj->getmessage().' '.\n\t\t\t\t\t'['.$obj->getFile().':'.$obj->getLine().']',\n\t\t\t\t\t$obj->gettrace());\n\t\t\t}\n\t\t);\n\t\tset_error_handler(\n\t\t\tfunction($level,$text,$file,$line) {\n\t\t\t\tif ($level & error_reporting())\n\t\t\t\t\t$this->error(500,$text,NULL,$level);\n\t\t\t}\n\t\t);\n\t\tif (!isset($_SERVER['SERVER_NAME']) || $_SERVER['SERVER_NAME']==='')\n\t\t\t$_SERVER['SERVER_NAME']=gethostname();\n\t\t$headers=[];\n\t\tif ($cli=PHP_SAPI=='cli') {\n\t\t\t// Emulate HTTP request\n\t\t\t$_SERVER['REQUEST_METHOD']='GET';\n\t\t\tif (!isset($_SERVER['argv'][1])) {\n\t\t\t\t$_SERVER['argc']++;\n\t\t\t\t$_SERVER['argv'][1]='/';\n\t\t\t}\n\t\t\t$req=$query='';\n\t\t\tif (substr($_SERVER['argv'][1],0,1)=='/') {\n\t\t\t\t$req=$_SERVER['argv'][1];\n\t\t\t\t$query=parse_url($req,PHP_URL_QUERY);\n\t\t\t} else {\n\t\t\t\tforeach($_SERVER['argv'] as $i=>$arg) {\n\t\t\t\t\tif (!$i) continue;\n\t\t\t\t\tif (preg_match('/^\\-(\\-)?(\\w+)(?:\\=(.*))?$/',$arg,$m)) {\n\t\t\t\t\t\tforeach($m[1]?[$m[2]]:str_split($m[2]) as $k)\n\t\t\t\t\t\t\t$query.=($query?'&':'').urlencode($k).'=';\n\t\t\t\t\t\tif (isset($m[3]))\n\t\t\t\t\t\t\t$query.=urlencode($m[3]);\n\t\t\t\t\t} else\n\t\t\t\t\t\t$req.='/'.$arg;\n\t\t\t\t}\n\t\t\t\tif (!$req)\n\t\t\t\t\t$req='/';\n\t\t\t\tif ($query)\n\t\t\t\t\t$req.='?'.$query;\n\t\t\t}\n\t\t\t$_SERVER['REQUEST_URI']=$req;\n\t\t\tparse_str($query,$GLOBALS['_GET']);\n\t\t}\n\t\telseif (function_exists('getallheaders')) {\n\t\t\tforeach (getallheaders() as $key=>$val) {\n\t\t\t\t$tmp=strtoupper(strtr($key,'-','_'));\n\t\t\t\t// TODO: use ucwords delimiters for php 5.4.32+ & 5.5.16+\n\t\t\t\t$key=strtr(ucwords(strtolower(strtr($key,'-',' '))),' ','-');\n\t\t\t\t$headers[$key]=$val;\n\t\t\t\tif (isset($_SERVER['HTTP_'.$tmp]))\n\t\t\t\t\t$headers[$key]=&$_SERVER['HTTP_'.$tmp];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (isset($_SERVER['CONTENT_LENGTH']))\n\t\t\t\t$headers['Content-Length']=&$_SERVER['CONTENT_LENGTH'];\n\t\t\tif (isset($_SERVER['CONTENT_TYPE']))\n\t\t\t\t$headers['Content-Type']=&$_SERVER['CONTENT_TYPE'];\n\t\t\tforeach (array_keys($_SERVER) as $key)\n\t\t\t\tif (substr($key,0,5)=='HTTP_')\n\t\t\t\t\t$headers[strtr(ucwords(strtolower(strtr(\n\t\t\t\t\t\tsubstr($key,5),'_',' '))),' ','-')]=&$_SERVER[$key];\n\t\t}\n\t\tif (isset($headers['X-HTTP-Method-Override']))\n\t\t\t$_SERVER['REQUEST_METHOD']=$headers['X-HTTP-Method-Override'];\n\t\telseif ($_SERVER['REQUEST_METHOD']=='POST' && isset($_POST['_method']))\n\t\t\t$_SERVER['REQUEST_METHOD']=strtoupper($_POST['_method']);\n\t\t$scheme=isset($_SERVER['HTTPS']) && $_SERVER['HTTPS']=='on' ||\n\t\t\tisset($headers['X-Forwarded-Proto']) &&\n\t\t\t$headers['X-Forwarded-Proto']=='https'?'https':'http';\n\t\t// Create hive early on to expose header methods\n\t\t$this->hive=['HEADERS'=>&$headers];\n\t\tif (function_exists('apache_setenv')) {\n\t\t\t// Work around Apache pre-2.4 VirtualDocumentRoot bug\n\t\t\t$_SERVER['DOCUMENT_ROOT']=str_replace($_SERVER['SCRIPT_NAME'],'',\n\t\t\t\t$_SERVER['SCRIPT_FILENAME']);\n\t\t\tapache_setenv(\"DOCUMENT_ROOT\",$_SERVER['DOCUMENT_ROOT']);\n\t\t}\n\t\t$_SERVER['DOCUMENT_ROOT']=realpath($_SERVER['DOCUMENT_ROOT']);\n\t\t$base='';\n\t\tif (!$cli)\n\t\t\t$base=rtrim($this->fixslashes(\n\t\t\t\tdirname($_SERVER['SCRIPT_NAME'])),'/');\n\t\t$uri=parse_url((preg_match('/^\\w+:\\/\\//',$_SERVER['REQUEST_URI'])?'':\n\t\t\t\t$scheme.'://'.$_SERVER['SERVER_NAME']).$_SERVER['REQUEST_URI']);\n\t\t$_SERVER['REQUEST_URI']=$uri['path'].\n\t\t\t(isset($uri['query'])?'?'.$uri['query']:'').\n\t\t\t(isset($uri['fragment'])?'#'.$uri['fragment']:'');\n\t\t$path=preg_replace('/^'.preg_quote($base,'/').'/','',$uri['path']);\n\t\t$jar=[\n\t\t\t'expire'=>0,\n\t\t\t'lifetime'=>0,\n\t\t\t'path'=>$base?:'/',\n\t\t\t'domain'=>is_int(strpos($_SERVER['SERVER_NAME'],'.')) &&\n\t\t\t\t!filter_var($_SERVER['SERVER_NAME'],FILTER_VALIDATE_IP)?\n\t\t\t\t$_SERVER['SERVER_NAME']:'',\n\t\t\t'secure'=>($scheme=='https'),\n\t\t\t'httponly'=>TRUE,\n\t\t\t'samesite'=>'Lax',\n\t\t];\n\t\t$port=80;\n\t\tif (isset($headers['X-Forwarded-Port']))\n\t\t\t$port=$headers['X-Forwarded-Port'];\n\t\telseif (isset($_SERVER['SERVER_PORT']))\n\t\t\t$port=$_SERVER['SERVER_PORT'];\n\t\t// Default configuration\n\t\t$this->hive+=[\n\t\t\t'AGENT'=>$this->agent(),\n\t\t\t'AJAX'=>$this->ajax(),\n\t\t\t'ALIAS'=>NULL,\n\t\t\t'ALIASES'=>[],\n\t\t\t'AUTOLOAD'=>'./',\n\t\t\t'BASE'=>$base,\n\t\t\t'BITMASK'=>ENT_COMPAT,\n\t\t\t'BODY'=>NULL,\n\t\t\t'CACHE'=>FALSE,\n\t\t\t'CASELESS'=>TRUE,\n\t\t\t'CLI'=>$cli,\n\t\t\t'CORS'=>[\n\t\t\t\t'headers'=>'',\n\t\t\t\t'origin'=>FALSE,\n\t\t\t\t'credentials'=>FALSE,\n\t\t\t\t'expose'=>FALSE,\n\t\t\t\t'ttl'=>0\n\t\t\t],\n\t\t\t'DEBUG'=>0,\n\t\t\t'DIACRITICS'=>[],\n\t\t\t'DNSBL'=>'',\n\t\t\t'EMOJI'=>[],\n\t\t\t'ENCODING'=>$charset,\n\t\t\t'ERROR'=>NULL,\n\t\t\t'ESCAPE'=>TRUE,\n\t\t\t'EXCEPTION'=>NULL,\n\t\t\t'EXEMPT'=>NULL,\n\t\t\t'FALLBACK'=>$this->fallback,\n\t\t\t'FORMATS'=>[],\n\t\t\t'FRAGMENT'=>isset($uri['fragment'])?$uri['fragment']:'',\n\t\t\t'HALT'=>TRUE,\n\t\t\t'HIGHLIGHT'=>FALSE,\n\t\t\t'HOST'=>$_SERVER['SERVER_NAME'],\n\t\t\t'IP'=>$this->ip(),\n\t\t\t'JAR'=>$jar,\n\t\t\t'LANGUAGE'=>isset($headers['Accept-Language'])?\n\t\t\t\t$this->language($headers['Accept-Language']):\n\t\t\t\t$this->fallback,\n\t\t\t'LOCALES'=>'./',\n\t\t\t'LOCK'=>LOCK_EX,\n\t\t\t'LOGGABLE'=>'*',\n\t\t\t'LOGS'=>'./',\n\t\t\t'MB'=>extension_loaded('mbstring'),\n\t\t\t'ONERROR'=>NULL,\n\t\t\t'ONREROUTE'=>NULL,\n\t\t\t'PACKAGE'=>self::PACKAGE,\n\t\t\t'PARAMS'=>[],\n\t\t\t'PATH'=>$path,\n\t\t\t'PATTERN'=>NULL,\n\t\t\t'PLUGINS'=>$this->fixslashes(__DIR__).'/',\n\t\t\t'PORT'=>$port,\n\t\t\t'PREFIX'=>NULL,\n\t\t\t'PREMAP'=>'',\n\t\t\t'QUERY'=>isset($uri['query'])?$uri['query']:'',\n\t\t\t'QUIET'=>FALSE,\n\t\t\t'RAW'=>FALSE,\n\t\t\t'REALM'=>$scheme.'://'.$_SERVER['SERVER_NAME'].\n\t\t\t\t($port && !in_array($port,[80,443])?(':'.$port):'').\n\t\t\t\t$_SERVER['REQUEST_URI'],\n\t\t\t'RESPONSE'=>'',\n\t\t\t'ROOT'=>$_SERVER['DOCUMENT_ROOT'],\n\t\t\t'ROUTES'=>[],\n\t\t\t'SCHEME'=>$scheme,\n\t\t\t'SEED'=>$this->hash($_SERVER['SERVER_NAME'].$base),\n\t\t\t'SERIALIZER'=>extension_loaded($ext='igbinary')?$ext:'php',\n\t\t\t'TEMP'=>'tmp/',\n\t\t\t'TIME'=>&$_SERVER['REQUEST_TIME_FLOAT'],\n\t\t\t'TZ'=>@date_default_timezone_get(),\n\t\t\t'UI'=>'./',\n\t\t\t'UNLOAD'=>NULL,\n\t\t\t'UPLOADS'=>'./',\n\t\t\t'URI'=>&$_SERVER['REQUEST_URI'],\n\t\t\t'VERB'=>&$_SERVER['REQUEST_METHOD'],\n\t\t\t'VERSION'=>self::VERSION,\n\t\t\t'XFRAME'=>'SAMEORIGIN'\n\t\t];\n\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE) {\n\t\t\tunset($jar['expire']);\n\t\t\tsession_cache_limiter('');\n\t\t\tif (version_compare(PHP_VERSION, '7.3.0') >= 0)\n\t\t\t\tsession_set_cookie_params($jar);\n\t\t\telse {\n\t\t\t\tunset($jar['samesite']);\n\t\t\t\tcall_user_func_array('session_set_cookie_params',$jar);\n\t\t\t}\n\t\t}\n\t\tif (PHP_SAPI=='cli-server' &&\n\t\t\tpreg_match('/^'.preg_quote($base,'/').'$/',$this->hive['URI']))\n\t\t\t$this->reroute('/');\n\t\tif (ini_get('auto_globals_jit'))\n\t\t\t// Override setting\n\t\t\t$GLOBALS+=['_ENV'=>$_ENV,'_REQUEST'=>$_REQUEST];\n\t\t// Sync PHP globals with corresponding hive keys\n\t\t$this->init=$this->hive;\n\t\tforeach (explode('|',self::GLOBALS) as $global) {\n\t\t\t$sync=$this->sync($global);\n\t\t\t$this->init+=[\n\t\t\t\t$global=>preg_match('/SERVER|ENV/',$global)?$sync:[]\n\t\t\t];\n\t\t}\n\t\tif ($check && $error=error_get_last())\n\t\t\t// Error detected\n\t\t\t$this->error(500,\n\t\t\t\tsprintf(self::E_Fatal,$error['message']),[$error]);\n\t\tdate_default_timezone_set($this->hive['TZ']);\n\t\t// Register framework autoloader\n\t\tspl_autoload_register([$this,'autoload']);\n\t\t// Register shutdown handler\n\t\tregister_shutdown_function([$this,'unload'],getcwd());\n\t}\n\n}\n\n//! Cache engine\nclass Cache extends Prefab {\n\n\tprotected\n\t\t//! Cache DSN\n\t\t$dsn,\n\t\t//! Prefix for cache entries\n\t\t$prefix,\n\t\t//! MemCache or Redis object\n\t\t$ref;\n\n\t/**\n\t*\tReturn timestamp and TTL of cache entry or FALSE if not found\n\t*\t@return array|FALSE\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction exists($key,&$val=NULL) {\n\t\t$fw=Base::instance();\n\t\tif (!$this->dsn)\n\t\t\treturn FALSE;\n\t\t$ndx=$this->prefix.'.'.$key;\n\t\t$parts=explode('=',$this->dsn,2);\n\t\tswitch ($parts[0]) {\n\t\t\tcase 'apc':\n\t\t\tcase 'apcu':\n\t\t\t\t$raw=call_user_func($parts[0].'_fetch',$ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'redis':\n\t\t\t\t$raw=$this->ref->get($ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'memcache':\n\t\t\t\t$raw=memcache_get($this->ref,$ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'memcached':\n\t\t\t\t$raw=$this->ref->get($ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'wincache':\n\t\t\t\t$raw=wincache_ucache_get($ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'xcache':\n\t\t\t\t$raw=xcache_get($ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'folder':\n\t\t\t\t$raw=$fw->read($parts[1].$ndx);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!empty($raw)) {\n\t\t\tlist($val,$time,$ttl)=(array)$fw->unserialize($raw);\n\t\t\tif ($ttl===0 || $time+$ttl>microtime(TRUE))\n\t\t\t\treturn [$time,$ttl];\n\t\t\t$val=null;\n\t\t\t$this->clear($key);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tStore value in cache\n\t*\t@return mixed|FALSE\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t*\t@param $ttl int\n\t**/\n\tfunction set($key,$val,$ttl=0) {\n\t\t$fw=Base::instance();\n\t\tif (!$this->dsn)\n\t\t\treturn TRUE;\n\t\t$ndx=$this->prefix.'.'.$key;\n\t\tif ($cached=$this->exists($key))\n\t\t\t$ttl=$cached[1];\n\t\t$data=$fw->serialize([$val,microtime(TRUE),$ttl]);\n\t\t$parts=explode('=',$this->dsn,2);\n\t\tswitch ($parts[0]) {\n\t\t\tcase 'apc':\n\t\t\tcase 'apcu':\n\t\t\t\treturn call_user_func($parts[0].'_store',$ndx,$data,$ttl);\n\t\t\tcase 'redis':\n\t\t\t\treturn $this->ref->set($ndx,$data,$ttl?['ex'=>$ttl]:[]);\n\t\t\tcase 'memcache':\n\t\t\t\treturn memcache_set($this->ref,$ndx,$data,0,$ttl);\n\t\t\tcase 'memcached':\n\t\t\t\treturn $this->ref->set($ndx,$data,$ttl);\n\t\t\tcase 'wincache':\n\t\t\t\treturn wincache_ucache_set($ndx,$data,$ttl);\n\t\t\tcase 'xcache':\n\t\t\t\treturn xcache_set($ndx,$data,$ttl);\n\t\t\tcase 'folder':\n\t\t\t\treturn $fw->write($parts[1].\n\t\t\t\t\tstr_replace(['/','\\\\'],'',$ndx),$data);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tRetrieve value of cache entry\n\t*\t@return mixed|FALSE\n\t*\t@param $key string\n\t**/\n\tfunction get($key) {\n\t\treturn $this->dsn && $this->exists($key,$data)?$data:FALSE;\n\t}\n\n\t/**\n\t*\tDelete cache entry\n\t*\t@return bool\n\t*\t@param $key string\n\t**/\n\tfunction clear($key) {\n\t\tif (!$this->dsn)\n\t\t\treturn;\n\t\t$ndx=$this->prefix.'.'.$key;\n\t\t$parts=explode('=',$this->dsn,2);\n\t\tswitch ($parts[0]) {\n\t\t\tcase 'apc':\n\t\t\tcase 'apcu':\n\t\t\t\treturn call_user_func($parts[0].'_delete',$ndx);\n\t\t\tcase 'redis':\n\t\t\t\treturn $this->ref->del($ndx);\n\t\t\tcase 'memcache':\n\t\t\t\treturn memcache_delete($this->ref,$ndx);\n\t\t\tcase 'memcached':\n\t\t\t\treturn $this->ref->delete($ndx);\n\t\t\tcase 'wincache':\n\t\t\t\treturn wincache_ucache_delete($ndx);\n\t\t\tcase 'xcache':\n\t\t\t\treturn xcache_unset($ndx);\n\t\t\tcase 'folder':\n\t\t\t\treturn @unlink($parts[1].$ndx);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tClear contents of cache backend\n\t*\t@return bool\n\t*\t@param $suffix string\n\t**/\n\tfunction reset($suffix=NULL) {\n\t\tif (!$this->dsn)\n\t\t\treturn TRUE;\n\t\t$regex='/'.preg_quote($this->prefix.'.','/').'.*'.\n\t\t\tpreg_quote($suffix,'/').'/';\n\t\t$parts=explode('=',$this->dsn,2);\n\t\tswitch ($parts[0]) {\n\t\t\tcase 'apc':\n\t\t\tcase 'apcu':\n\t\t\t\t$info=call_user_func($parts[0].'_cache_info',\n\t\t\t\t\t$parts[0]=='apcu'?FALSE:'user');\n\t\t\t\tif (!empty($info['cache_list'])) {\n\t\t\t\t\t$key=array_key_exists('info',\n\t\t\t\t\t\t$info['cache_list'][0])?'info':'key';\n\t\t\t\t\tforeach ($info['cache_list'] as $item)\n\t\t\t\t\t\tif (preg_match($regex,$item[$key]))\n\t\t\t\t\t\t\tcall_user_func($parts[0].'_delete',$item[$key]);\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\tcase 'redis':\n\t\t\t\t$keys=$this->ref->keys($this->prefix.'.*'.$suffix);\n\t\t\t\tforeach($keys as $key)\n\t\t\t\t\t$this->ref->del($key);\n\t\t\t\treturn TRUE;\n\t\t\tcase 'memcache':\n\t\t\t\tforeach (memcache_get_extended_stats(\n\t\t\t\t\t$this->ref,'slabs') as $slabs)\n\t\t\t\t\tforeach (array_filter(array_keys($slabs),'is_numeric')\n\t\t\t\t\t\tas $id)\n\t\t\t\t\t\tforeach (memcache_get_extended_stats(\n\t\t\t\t\t\t\t$this->ref,'cachedump',$id) as $data)\n\t\t\t\t\t\t\tif (is_array($data))\n\t\t\t\t\t\t\t\tforeach (array_keys($data) as $key)\n\t\t\t\t\t\t\t\t\tif (preg_match($regex,$key))\n\t\t\t\t\t\t\t\t\t\tmemcache_delete($this->ref,$key);\n\t\t\t\treturn TRUE;\n\t\t\tcase 'memcached':\n\t\t\t\tforeach ($this->ref->getallkeys()?:[] as $key)\n\t\t\t\t\tif (preg_match($regex,$key))\n\t\t\t\t\t\t$this->ref->delete($key);\n\t\t\t\treturn TRUE;\n\t\t\tcase 'wincache':\n\t\t\t\t$info=wincache_ucache_info();\n\t\t\t\tforeach ($info['ucache_entries'] as $item)\n\t\t\t\t\tif (preg_match($regex,$item['key_name']))\n\t\t\t\t\t\twincache_ucache_delete($item['key_name']);\n\t\t\t\treturn TRUE;\n\t\t\tcase 'xcache':\n\t\t\t\tif ($suffix && !ini_get('xcache.admin.enable_auth')) {\n\t\t\t\t\t$cnt=xcache_count(XC_TYPE_VAR);\n\t\t\t\t\tfor ($i=0;$i<$cnt;$i++) {\n\t\t\t\t\t\t$list=xcache_list(XC_TYPE_VAR,$i);\n\t\t\t\t\t\tforeach ($list['cache_list'] as $item)\n\t\t\t\t\t\t\tif (preg_match($regex,$item['name']))\n\t\t\t\t\t\t\t\txcache_unset($item['name']);\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\txcache_unset_by_prefix($this->prefix.'.');\n\t\t\t\treturn TRUE;\n\t\t\tcase 'folder':\n\t\t\t\tif ($glob=@glob($parts[1].'*'))\n\t\t\t\t\tforeach ($glob as $file)\n\t\t\t\t\t\tif (preg_match($regex,basename($file)))\n\t\t\t\t\t\t\t@unlink($file);\n\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tLoad/auto-detect cache backend\n\t*\t@return string\n\t*\t@param $dsn bool|string\n\t*\t@param $seed bool|string\n\t**/\n\tfunction load($dsn,$seed=NULL) {\n\t\t$fw=Base::instance();\n\t\tif ($dsn=trim($dsn)) {\n\t\t\tif (preg_match('/^redis=(.+)/',$dsn,$parts) &&\n\t\t\t\textension_loaded('redis')) {\n\t\t\t\tlist($host,$port,$db,$password)=explode(':',$parts[1])+[1=>6379,2=>NULL,3=>NULL];\n\t\t\t\t$this->ref=new Redis;\n\t\t\t\tif(!$this->ref->connect($host,$port,2))\n\t\t\t\t\t$this->ref=NULL;\n\t\t\t\tif(!empty($password))\n\t\t\t\t\t$this->ref->auth($password);\n\t\t\t\tif(isset($db))\n\t\t\t\t\t$this->ref->select($db);\n\t\t\t}\n\t\t\telseif (preg_match('/^memcache=(.+)/',$dsn,$parts) &&\n\t\t\t\textension_loaded('memcache'))\n\t\t\t\tforeach ($fw->split($parts[1]) as $server) {\n\t\t\t\t\tlist($host,$port)=explode(':',$server)+[1=>11211];\n\t\t\t\t\tif (empty($this->ref))\n\t\t\t\t\t\t$this->ref=@memcache_connect($host,$port)?:NULL;\n\t\t\t\t\telse\n\t\t\t\t\t\tmemcache_add_server($this->ref,$host,$port);\n\t\t\t\t}\n\t\t\telseif (preg_match('/^memcached=(.+)/',$dsn,$parts) &&\n\t\t\t\textension_loaded('memcached'))\n\t\t\t\tforeach ($fw->split($parts[1]) as $server) {\n\t\t\t\t\tlist($host,$port)=explode(':',$server)+[1=>11211];\n\t\t\t\t\tif (empty($this->ref))\n\t\t\t\t\t\t$this->ref=new Memcached();\n\t\t\t\t\t$this->ref->addServer($host,$port);\n\t\t\t\t}\n\t\t\tif (empty($this->ref) && !preg_match('/^folder\\h*=/',$dsn))\n\t\t\t\t$dsn=($grep=preg_grep('/^(apc|wincache|xcache)/',\n\t\t\t\t\tarray_map('strtolower',get_loaded_extensions())))?\n\t\t\t\t\t\t// Auto-detect\n\t\t\t\t\t\tcurrent($grep):\n\t\t\t\t\t\t// Use filesystem as fallback\n\t\t\t\t\t\t('folder='.$fw->TEMP.'cache/');\n\t\t\tif (preg_match('/^folder\\h*=\\h*(.+)/',$dsn,$parts) &&\n\t\t\t\t!is_dir($parts[1]))\n\t\t\t\tmkdir($parts[1],Base::MODE,TRUE);\n\t\t}\n\t\t$this->prefix=$seed?:$fw->SEED;\n\t\treturn $this->dsn=$dsn;\n\t}\n\n\t/**\n\t*\tClass constructor\n\t*\t@param $dsn bool|string\n\t**/\n\tfunction __construct($dsn=FALSE) {\n\t\tif ($dsn)\n\t\t\t$this->load($dsn);\n\t}\n\n}\n\n//! View handler\nclass View extends Prefab {\n\n\tprivate\n\t\t//! Temporary hive\n\t\t$temp;\n\n\tprotected\n\t\t//! Template file\n\t\t$file,\n\t\t//! Post-rendering handler\n\t\t$trigger,\n\t\t//! Nesting level\n\t\t$level=0;\n\n\t/** @var \\Base Framework instance */\n\tprotected $fw;\n\n\tfunction __construct() {\n\t\t$this->fw=\\Base::instance();\n\t}\n\n\t/**\n\t*\tEncode characters to equivalent HTML entities\n\t*\t@return string\n\t*\t@param $arg mixed\n\t**/\n\tfunction esc($arg) {\n\t\treturn $this->fw->recursive($arg,\n\t\t\tfunction($val) {\n\t\t\t\treturn is_string($val)?$this->fw->encode($val):$val;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t*\tDecode HTML entities to equivalent characters\n\t*\t@return string\n\t*\t@param $arg mixed\n\t**/\n\tfunction raw($arg) {\n\t\treturn $this->fw->recursive($arg,\n\t\t\tfunction($val) {\n\t\t\t\treturn is_string($val)?$this->fw->decode($val):$val;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t*\tCreate sandbox for template execution\n\t*\t@return string\n\t*\t@param $hive array\n\t*\t@param $mime string\n\t**/\n\tprotected function sandbox(array $hive=NULL,$mime=NULL) {\n\t\t$fw=$this->fw;\n\t\t$implicit=FALSE;\n\t\tif (is_null($hive)) {\n\t\t\t$implicit=TRUE;\n\t\t\t$hive=$fw->hive();\n\t\t}\n\t\tif ($this->level<1 || $implicit) {\n\t\t\tif (!$fw->CLI && $mime && !headers_sent() &&\n\t\t\t\t!preg_grep ('/^Content-Type:/',headers_list()))\n\t\t\t\theader('Content-Type: '.$mime.'; '.\n\t\t\t\t\t'charset='.$fw->ENCODING);\n\t\t\tif ($fw->ESCAPE)\n\t\t\t\t$hive=$this->esc($hive);\n\t\t\tif (isset($hive['ALIASES']))\n\t\t\t\t$hive['ALIASES']=$fw->build($hive['ALIASES']);\n\t\t}\n\t\t$this->temp=$hive;\n\t\tunset($fw,$hive,$implicit,$mime);\n\t\textract($this->temp);\n\t\t$this->temp=NULL;\n\t\t$this->level++;\n\t\tob_start();\n\t\trequire($this->file);\n\t\t$this->level--;\n\t\treturn ob_get_clean();\n\t}\n\n\t/**\n\t*\tRender template\n\t*\t@return string\n\t*\t@param $file string\n\t*\t@param $mime string\n\t*\t@param $hive array\n\t*\t@param $ttl int\n\t**/\n\tfunction render($file,$mime='text/html',array $hive=NULL,$ttl=0) {\n\t\t$fw=$this->fw;\n\t\t$cache=Cache::instance();\n\t\tforeach ($fw->split($fw->UI) as $dir) {\n\t\t\tif ($cache->exists($hash=$fw->hash($dir.$file),$data))\n\t\t\t\treturn $data;\n\t\t\tif (is_file($this->file=$fw->fixslashes($dir.$file))) {\n\t\t\t\tif (isset($_COOKIE[session_name()]) &&\n\t\t\t\t\t!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\t\tsession_start();\n\t\t\t\t$fw->sync('SESSION');\n\t\t\t\t$data=$this->sandbox($hive,$mime);\n\t\t\t\tif (isset($this->trigger['afterrender']))\n\t\t\t\t\tforeach($this->trigger['afterrender'] as $func)\n\t\t\t\t\t\t$data=$fw->call($func,[$data, $dir.$file]);\n\t\t\t\tif ($ttl)\n\t\t\t\t\t$cache->set($hash,$data,$ttl);\n\t\t\t\treturn $data;\n\t\t\t}\n\t\t}\n\t\tuser_error(sprintf(Base::E_Open,$file),E_USER_ERROR);\n\t}\n\n\t/**\n\t*\tpost rendering handler\n\t*\t@param $func callback\n\t*/\n\tfunction afterrender($func) {\n\t\t$this->trigger['afterrender'][]=$func;\n\t}\n\n}\n\n//! Lightweight template engine\nclass Preview extends View {\n\n\tprotected\n\t\t//! token filter\n\t\t$filter=[\n\t\t\t'c'=>'$this->c',\n\t\t\t'esc'=>'$this->esc',\n\t\t\t'raw'=>'$this->raw',\n\t\t\t'export'=>'Base::instance()->export',\n\t\t\t'alias'=>'Base::instance()->alias',\n\t\t\t'format'=>'Base::instance()->format'\n\t\t];\n\n\tprotected\n\t\t//! newline interpolation\n\t\t$interpolation=true;\n\n\t/**\n\t * Enable/disable markup parsing interpolation\n\t * mainly used for adding appropriate newlines\n\t * @param $bool bool\n\t */\n\tfunction interpolation($bool) {\n\t\t$this->interpolation=$bool;\n\t}\n\n\t/**\n\t*\tReturn C-locale equivalent of number\n\t*\t@return string\n\t*\t@param $val int|float\n\t**/\n\tfunction c($val) {\n\t\t$locale=setlocale(LC_NUMERIC,0);\n\t\tsetlocale(LC_NUMERIC,'C');\n\t\t$out=(string)(float)$val;\n\t\t$locale=setlocale(LC_NUMERIC,$locale);\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tConvert token to variable\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction token($str) {\n\t\t$fw=$this->fw;\n\t\t$str=trim(preg_replace('/\\{\\{(.+?)\\}\\}/s',trim('\\1'),\n\t\t\t$fw->compile($str)));\n\t\tif (preg_match('/^(.+)(?<!\\|)\\|((?:\\h*\\w+(?:\\h*[,;]?))+)$/s',\n\t\t\t$str,$parts)) {\n\t\t\t$str=trim($parts[1]);\n\t\t\tforeach ($fw->split(trim($parts[2],\"\\xC2\\xA0\")) as $func)\n\t\t\t\t$str=((empty($this->filter[$cmd=$func]) &&\n\t\t\t\t\tfunction_exists($cmd)) ||\n\t\t\t\t\tis_string($cmd=$this->filter($func)))?\n\t\t\t\t\t$cmd.'('.$str.')':\n\t\t\t\t\t'Base::instance()->'.\n\t\t\t\t\t\t'call($this->filter(\\''.$func.'\\'),['.$str.'])';\n\t\t}\n\t\treturn $str;\n\t}\n\n\t/**\n\t*\tRegister or get (one specific or all) token filters\n\t*\t@param string $key\n\t*\t@param string|closure $func\n\t*\t@return array|closure|string\n\t*/\n\tfunction filter($key=NULL,$func=NULL) {\n\t\tif (!$key)\n\t\t\treturn array_keys($this->filter);\n\t\t$key=strtolower($key);\n\t\tif (!$func)\n\t\t\treturn $this->filter[$key];\n\t\t$this->filter[$key]=$func;\n\t}\n\n\t/**\n\t*\tAssemble markup\n\t*\t@return string\n\t*\t@param $node string\n\t**/\n\tprotected function build($node) {\n\t\treturn preg_replace_callback(\n\t\t\t'/\\{~(.+?)~\\}|\\{\\*(.+?)\\*\\}|\\{\\-(.+?)\\-\\}|'.\n\t\t\t'\\{\\{(.+?)\\}\\}((\\r?\\n)*)/s',\n\t\t\tfunction($expr) {\n\t\t\t\tif ($expr[1])\n\t\t\t\t\t$str='<?php '.$this->token($expr[1]).' ?>';\n\t\t\t\telseif ($expr[2])\n\t\t\t\t\treturn '';\n\t\t\t\telseif ($expr[3])\n\t\t\t\t\t$str=$expr[3];\n\t\t\t\telse {\n\t\t\t\t\t$str='<?= ('.trim($this->token($expr[4])).')'.\n\t\t\t\t\t\t($this->interpolation?\n\t\t\t\t\t\t\t(!empty($expr[6])?'.\"'.$expr[6].'\"':''):'').' ?>';\n\t\t\t\t\tif (isset($expr[5]))\n\t\t\t\t\t\t$str.=$expr[5];\n\t\t\t\t}\n\t\t\t\treturn $str;\n\t\t\t},\n\t\t\t$node\n\t\t);\n\t}\n\n\t/**\n\t*\tRender template string\n\t*\t@return string\n\t*\t@param $node string|array\n\t*\t@param $hive array\n\t*\t@param $ttl int\n\t*\t@param $persist bool\n\t*\t@param $escape bool\n\t**/\n\tfunction resolve($node,array $hive=NULL,$ttl=0,$persist=FALSE,$escape=NULL) {\n\t\t$fw=$this->fw;\n\t\t$cache=Cache::instance();\n\t\tif ($escape!==NULL) {\n\t\t\t$esc=$fw->ESCAPE;\n\t\t\t$fw->ESCAPE=$escape;\n\t\t}\n\t\tif ($ttl || $persist)\n\t\t\t$hash=$fw->hash($fw->serialize($node));\n\t\tif ($ttl && $cache->exists($hash,$data))\n\t\t\treturn $data;\n\t\tif ($persist) {\n\t\t\tif (!is_dir($tmp=$fw->TEMP))\n\t\t\t\tmkdir($tmp,Base::MODE,TRUE);\n\t\t\tif (!is_file($this->file=($tmp.\n\t\t\t\t$fw->SEED.'.'.$hash.'.php')))\n\t\t\t\t$fw->write($this->file,$this->build($node));\n\t\t\tif (isset($_COOKIE[session_name()]) &&\n\t\t\t\t!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\tsession_start();\n\t\t\t$fw->sync('SESSION');\n\t\t\t$data=$this->sandbox($hive);\n\t\t}\n\t\telse {\n\t\t\tif (!$hive)\n\t\t\t\t$hive=$fw->hive();\n\t\t\tif ($fw->ESCAPE)\n\t\t\t\t$hive=$this->esc($hive);\n\t\t\textract($hive);\n\t\t\tunset($hive);\n\t\t\tob_start();\n\t\t\teval(' ?>'.$this->build($node).'<?php ');\n\t\t\t$data=ob_get_clean();\n\t\t}\n\t\tif ($ttl)\n\t\t\t$cache->set($hash,$data,$ttl);\n\t\tif ($escape!==NULL)\n\t\t\t$fw->ESCAPE=$esc;\n\t\treturn $data;\n\t}\n\n\t/**\n\t *\tParse template string\n\t *\t@return string\n\t *\t@param $text string\n\t **/\n\tfunction parse($text) {\n\t\t// Remove PHP code and comments\n\t\treturn preg_replace(\n\t\t\t'/\\h*<\\?(?!xml)(?:php|\\s*=)?.+?\\?>\\h*|'.\n\t\t\t'\\{\\*.+?\\*\\}/is','', $text);\n\t}\n\n\t/**\n\t*\tRender template\n\t*\t@return string\n\t*\t@param $file string\n\t*\t@param $mime string\n\t*\t@param $hive array\n\t*\t@param $ttl int\n\t**/\n\tfunction render($file,$mime='text/html',array $hive=NULL,$ttl=0) {\n\t\t$fw=$this->fw;\n\t\t$cache=Cache::instance();\n\t\tif (!is_dir($tmp=$fw->TEMP))\n\t\t\tmkdir($tmp,Base::MODE,TRUE);\n\t\tforeach ($fw->split($fw->UI) as $dir) {\n\t\t\tif ($cache->exists($hash=$fw->hash($dir.$file),$data))\n\t\t\t\treturn $data;\n\t\t\tif (is_file($view=$fw->fixslashes($dir.$file))) {\n\t\t\t\tif (!is_file($this->file=($tmp.\n\t\t\t\t\t$fw->SEED.'.'.$fw->hash($view).'.php')) ||\n\t\t\t\t\tfilemtime($this->file)<filemtime($view)) {\n\t\t\t\t\t$contents=$fw->read($view);\n\t\t\t\t\tif (isset($this->trigger['beforerender']))\n\t\t\t\t\t\tforeach ($this->trigger['beforerender'] as $func)\n\t\t\t\t\t\t\t$contents=$fw->call($func, [$contents, $view]);\n\t\t\t\t\t$text=$this->parse($contents);\n\t\t\t\t\t$fw->write($this->file,$this->build($text));\n\t\t\t\t}\n\t\t\t\tif (isset($_COOKIE[session_name()]) &&\n\t\t\t\t\t!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\t\tsession_start();\n\t\t\t\t$fw->sync('SESSION');\n\t\t\t\t$data=$this->sandbox($hive,$mime);\n\t\t\t\tif(isset($this->trigger['afterrender']))\n\t\t\t\t\tforeach ($this->trigger['afterrender'] as $func)\n\t\t\t\t\t\t$data=$fw->call($func, [$data, $view]);\n\t\t\t\tif ($ttl)\n\t\t\t\t\t$cache->set($hash,$data,$ttl);\n\t\t\t\treturn $data;\n\t\t\t}\n\t\t}\n\t\tuser_error(sprintf(Base::E_Open,$file),E_USER_ERROR);\n\t}\n\n\t/**\n\t *\tpost rendering handler\n\t *\t@param $func callback\n\t */\n\tfunction beforerender($func) {\n\t\t$this->trigger['beforerender'][]=$func;\n\t}\n\n}\n\n//! ISO language/country codes\nclass ISO extends Prefab {\n\n\t//@{ ISO 3166-1 country codes\n\tconst\n\t\tCC_af='Afghanistan',\n\t\tCC_ax='\u00c5land Islands',\n\t\tCC_al='Albania',\n\t\tCC_dz='Algeria',\n\t\tCC_as='American Samoa',\n\t\tCC_ad='Andorra',\n\t\tCC_ao='Angola',\n\t\tCC_ai='Anguilla',\n\t\tCC_aq='Antarctica',\n\t\tCC_ag='Antigua and Barbuda',\n\t\tCC_ar='Argentina',\n\t\tCC_am='Armenia',\n\t\tCC_aw='Aruba',\n\t\tCC_au='Australia',\n\t\tCC_at='Austria',\n\t\tCC_az='Azerbaijan',\n\t\tCC_bs='Bahamas',\n\t\tCC_bh='Bahrain',\n\t\tCC_bd='Bangladesh',\n\t\tCC_bb='Barbados',\n\t\tCC_by='Belarus',\n\t\tCC_be='Belgium',\n\t\tCC_bz='Belize',\n\t\tCC_bj='Benin',\n\t\tCC_bm='Bermuda',\n\t\tCC_bt='Bhutan',\n\t\tCC_bo='Bolivia',\n\t\tCC_bq='Bonaire, Sint Eustatius and Saba',\n\t\tCC_ba='Bosnia and Herzegovina',\n\t\tCC_bw='Botswana',\n\t\tCC_bv='Bouvet Island',\n\t\tCC_br='Brazil',\n\t\tCC_io='British Indian Ocean Territory',\n\t\tCC_bn='Brunei Darussalam',\n\t\tCC_bg='Bulgaria',\n\t\tCC_bf='Burkina Faso',\n\t\tCC_bi='Burundi',\n\t\tCC_kh='Cambodia',\n\t\tCC_cm='Cameroon',\n\t\tCC_ca='Canada',\n\t\tCC_cv='Cape Verde',\n\t\tCC_ky='Cayman Islands',\n\t\tCC_cf='Central African Republic',\n\t\tCC_td='Chad',\n\t\tCC_cl='Chile',\n\t\tCC_cn='China',\n\t\tCC_cx='Christmas Island',\n\t\tCC_cc='Cocos (Keeling) Islands',\n\t\tCC_co='Colombia',\n\t\tCC_km='Comoros',\n\t\tCC_cg='Congo',\n\t\tCC_cd='Congo, The Democratic Republic of',\n\t\tCC_ck='Cook Islands',\n\t\tCC_cr='Costa Rica',\n\t\tCC_ci='C\u00f4te d\\'ivoire',\n\t\tCC_hr='Croatia',\n\t\tCC_cu='Cuba',\n\t\tCC_cw='Cura\u00e7ao',\n\t\tCC_cy='Cyprus',\n\t\tCC_cz='Czech Republic',\n\t\tCC_dk='Denmark',\n\t\tCC_dj='Djibouti',\n\t\tCC_dm='Dominica',\n\t\tCC_do='Dominican Republic',\n\t\tCC_ec='Ecuador',\n\t\tCC_eg='Egypt',\n\t\tCC_sv='El Salvador',\n\t\tCC_gq='Equatorial Guinea',\n\t\tCC_er='Eritrea',\n\t\tCC_ee='Estonia',\n\t\tCC_et='Ethiopia',\n\t\tCC_fk='Falkland Islands (Malvinas)',\n\t\tCC_fo='Faroe Islands',\n\t\tCC_fj='Fiji',\n\t\tCC_fi='Finland',\n\t\tCC_fr='France',\n\t\tCC_gf='French Guiana',\n\t\tCC_pf='French Polynesia',\n\t\tCC_tf='French Southern Territories',\n\t\tCC_ga='Gabon',\n\t\tCC_gm='Gambia',\n\t\tCC_ge='Georgia',\n\t\tCC_de='Germany',\n\t\tCC_gh='Ghana',\n\t\tCC_gi='Gibraltar',\n\t\tCC_gr='Greece',\n\t\tCC_gl='Greenland',\n\t\tCC_gd='Grenada',\n\t\tCC_gp='Guadeloupe',\n\t\tCC_gu='Guam',\n\t\tCC_gt='Guatemala',\n\t\tCC_gg='Guernsey',\n\t\tCC_gn='Guinea',\n\t\tCC_gw='Guinea-Bissau',\n\t\tCC_gy='Guyana',\n\t\tCC_ht='Haiti',\n\t\tCC_hm='Heard Island and McDonald Islands',\n\t\tCC_va='Holy See (Vatican City State)',\n\t\tCC_hn='Honduras',\n\t\tCC_hk='Hong Kong',\n\t\tCC_hu='Hungary',\n\t\tCC_is='Iceland',\n\t\tCC_in='India',\n\t\tCC_id='Indonesia',\n\t\tCC_ir='Iran, Islamic Republic of',\n\t\tCC_iq='Iraq',\n\t\tCC_ie='Ireland',\n\t\tCC_im='Isle of Man',\n\t\tCC_il='Israel',\n\t\tCC_it='Italy',\n\t\tCC_jm='Jamaica',\n\t\tCC_jp='Japan',\n\t\tCC_je='Jersey',\n\t\tCC_jo='Jordan',\n\t\tCC_kz='Kazakhstan',\n\t\tCC_ke='Kenya',\n\t\tCC_ki='Kiribati',\n\t\tCC_kp='Korea, Democratic People\\'s Republic of',\n\t\tCC_kr='Korea, Republic of',\n\t\tCC_kw='Kuwait',\n\t\tCC_kg='Kyrgyzstan',\n\t\tCC_la='Lao People\\'s Democratic Republic',\n\t\tCC_lv='Latvia',\n\t\tCC_lb='Lebanon',\n\t\tCC_ls='Lesotho',\n\t\tCC_lr='Liberia',\n\t\tCC_ly='Libya',\n\t\tCC_li='Liechtenstein',\n\t\tCC_lt='Lithuania',\n\t\tCC_lu='Luxembourg',\n\t\tCC_mo='Macao',\n\t\tCC_mk='Macedonia, The Former Yugoslav Republic of',\n\t\tCC_mg='Madagascar',\n\t\tCC_mw='Malawi',\n\t\tCC_my='Malaysia',\n\t\tCC_mv='Maldives',\n\t\tCC_ml='Mali',\n\t\tCC_mt='Malta',\n\t\tCC_mh='Marshall Islands',\n\t\tCC_mq='Martinique',\n\t\tCC_mr='Mauritania',\n\t\tCC_mu='Mauritius',\n\t\tCC_yt='Mayotte',\n\t\tCC_mx='Mexico',\n\t\tCC_fm='Micronesia, Federated States of',\n\t\tCC_md='Moldova, Republic of',\n\t\tCC_mc='Monaco',\n\t\tCC_mn='Mongolia',\n\t\tCC_me='Montenegro',\n\t\tCC_ms='Montserrat',\n\t\tCC_ma='Morocco',\n\t\tCC_mz='Mozambique',\n\t\tCC_mm='Myanmar',\n\t\tCC_na='Namibia',\n\t\tCC_nr='Nauru',\n\t\tCC_np='Nepal',\n\t\tCC_nl='Netherlands',\n\t\tCC_nc='New Caledonia',\n\t\tCC_nz='New Zealand',\n\t\tCC_ni='Nicaragua',\n\t\tCC_ne='Niger',\n\t\tCC_ng='Nigeria',\n\t\tCC_nu='Niue',\n\t\tCC_nf='Norfolk Island',\n\t\tCC_mp='Northern Mariana Islands',\n\t\tCC_no='Norway',\n\t\tCC_om='Oman',\n\t\tCC_pk='Pakistan',\n\t\tCC_pw='Palau',\n\t\tCC_ps='Palestinian Territory, Occupied',\n\t\tCC_pa='Panama',\n\t\tCC_pg='Papua New Guinea',\n\t\tCC_py='Paraguay',\n\t\tCC_pe='Peru',\n\t\tCC_ph='Philippines',\n\t\tCC_pn='Pitcairn',\n\t\tCC_pl='Poland',\n\t\tCC_pt='Portugal',\n\t\tCC_pr='Puerto Rico',\n\t\tCC_qa='Qatar',\n\t\tCC_re='R\u00e9union',\n\t\tCC_ro='Romania',\n\t\tCC_ru='Russian Federation',\n\t\tCC_rw='Rwanda',\n\t\tCC_bl='Saint Barth\u00e9lemy',\n\t\tCC_sh='Saint Helena, Ascension and Tristan da Cunha',\n\t\tCC_kn='Saint Kitts and Nevis',\n\t\tCC_lc='Saint Lucia',\n\t\tCC_mf='Saint Martin (French Part)',\n\t\tCC_pm='Saint Pierre and Miquelon',\n\t\tCC_vc='Saint Vincent and The Grenadines',\n\t\tCC_ws='Samoa',\n\t\tCC_sm='San Marino',\n\t\tCC_st='Sao Tome and Principe',\n\t\tCC_sa='Saudi Arabia',\n\t\tCC_sn='Senegal',\n\t\tCC_rs='Serbia',\n\t\tCC_sc='Seychelles',\n\t\tCC_sl='Sierra Leone',\n\t\tCC_sg='Singapore',\n\t\tCC_sk='Slovakia',\n\t\tCC_sx='Sint Maarten (Dutch Part)',\n\t\tCC_si='Slovenia',\n\t\tCC_sb='Solomon Islands',\n\t\tCC_so='Somalia',\n\t\tCC_za='South Africa',\n\t\tCC_gs='South Georgia and The South Sandwich Islands',\n\t\tCC_ss='South Sudan',\n\t\tCC_es='Spain',\n\t\tCC_lk='Sri Lanka',\n\t\tCC_sd='Sudan',\n\t\tCC_sr='Suriname',\n\t\tCC_sj='Svalbard and Jan Mayen',\n\t\tCC_sz='Swaziland',\n\t\tCC_se='Sweden',\n\t\tCC_ch='Switzerland',\n\t\tCC_sy='Syrian Arab Republic',\n\t\tCC_tw='Taiwan, Province of China',\n\t\tCC_tj='Tajikistan',\n\t\tCC_tz='Tanzania, United Republic of',\n\t\tCC_th='Thailand',\n\t\tCC_tl='Timor-Leste',\n\t\tCC_tg='Togo',\n\t\tCC_tk='Tokelau',\n\t\tCC_to='Tonga',\n\t\tCC_tt='Trinidad and Tobago',\n\t\tCC_tn='Tunisia',\n\t\tCC_tr='Turkey',\n\t\tCC_tm='Turkmenistan',\n\t\tCC_tc='Turks and Caicos Islands',\n\t\tCC_tv='Tuvalu',\n\t\tCC_ug='Uganda',\n\t\tCC_ua='Ukraine',\n\t\tCC_ae='United Arab Emirates',\n\t\tCC_gb='United Kingdom',\n\t\tCC_us='United States',\n\t\tCC_um='United States Minor Outlying Islands',\n\t\tCC_uy='Uruguay',\n\t\tCC_uz='Uzbekistan',\n\t\tCC_vu='Vanuatu',\n\t\tCC_ve='Venezuela',\n\t\tCC_vn='Viet Nam',\n\t\tCC_vg='Virgin Islands, British',\n\t\tCC_vi='Virgin Islands, U.S.',\n\t\tCC_wf='Wallis and Futuna',\n\t\tCC_eh='Western Sahara',\n\t\tCC_ye='Yemen',\n\t\tCC_zm='Zambia',\n\t\tCC_zw='Zimbabwe';\n\t//@}\n\n\t//@{ ISO 639-1 language codes (Windows-compatibility subset)\n\tconst\n\t\tLC_af='Afrikaans',\n\t\tLC_am='Amharic',\n\t\tLC_ar='Arabic',\n\t\tLC_as='Assamese',\n\t\tLC_ba='Bashkir',\n\t\tLC_be='Belarusian',\n\t\tLC_bg='Bulgarian',\n\t\tLC_bn='Bengali',\n\t\tLC_bo='Tibetan',\n\t\tLC_br='Breton',\n\t\tLC_ca='Catalan',\n\t\tLC_co='Corsican',\n\t\tLC_cs='Czech',\n\t\tLC_cy='Welsh',\n\t\tLC_da='Danish',\n\t\tLC_de='German',\n\t\tLC_dv='Divehi',\n\t\tLC_el='Greek',\n\t\tLC_en='English',\n\t\tLC_es='Spanish',\n\t\tLC_et='Estonian',\n\t\tLC_eu='Basque',\n\t\tLC_fa='Persian',\n\t\tLC_fi='Finnish',\n\t\tLC_fo='Faroese',\n\t\tLC_fr='French',\n\t\tLC_gd='Scottish Gaelic',\n\t\tLC_gl='Galician',\n\t\tLC_gu='Gujarati',\n\t\tLC_he='Hebrew',\n\t\tLC_hi='Hindi',\n\t\tLC_hr='Croatian',\n\t\tLC_hu='Hungarian',\n\t\tLC_hy='Armenian',\n\t\tLC_id='Indonesian',\n\t\tLC_ig='Igbo',\n\t\tLC_is='Icelandic',\n\t\tLC_it='Italian',\n\t\tLC_ja='Japanese',\n\t\tLC_ka='Georgian',\n\t\tLC_kk='Kazakh',\n\t\tLC_km='Khmer',\n\t\tLC_kn='Kannada',\n\t\tLC_ko='Korean',\n\t\tLC_lb='Luxembourgish',\n\t\tLC_lo='Lao',\n\t\tLC_lt='Lithuanian',\n\t\tLC_lv='Latvian',\n\t\tLC_mi='Maori',\n\t\tLC_ml='Malayalam',\n\t\tLC_mr='Marathi',\n\t\tLC_ms='Malay',\n\t\tLC_mt='Maltese',\n\t\tLC_ne='Nepali',\n\t\tLC_nl='Dutch',\n\t\tLC_no='Norwegian',\n\t\tLC_oc='Occitan',\n\t\tLC_or='Oriya',\n\t\tLC_pl='Polish',\n\t\tLC_ps='Pashto',\n\t\tLC_pt='Portuguese',\n\t\tLC_qu='Quechua',\n\t\tLC_ro='Romanian',\n\t\tLC_ru='Russian',\n\t\tLC_rw='Kinyarwanda',\n\t\tLC_sa='Sanskrit',\n\t\tLC_si='Sinhala',\n\t\tLC_sk='Slovak',\n\t\tLC_sl='Slovenian',\n\t\tLC_sq='Albanian',\n\t\tLC_sv='Swedish',\n\t\tLC_ta='Tamil',\n\t\tLC_te='Telugu',\n\t\tLC_th='Thai',\n\t\tLC_tk='Turkmen',\n\t\tLC_tr='Turkish',\n\t\tLC_tt='Tatar',\n\t\tLC_uk='Ukrainian',\n\t\tLC_ur='Urdu',\n\t\tLC_vi='Vietnamese',\n\t\tLC_wo='Wolof',\n\t\tLC_yo='Yoruba',\n\t\tLC_zh='Chinese';\n\t//@}\n\n\t/**\n\t*\tReturn list of languages indexed by ISO 639-1 language code\n\t*\t@return array\n\t**/\n\tfunction languages() {\n\t\treturn \\Base::instance()->constants($this,'LC_');\n\t}\n\n\t/**\n\t*\tReturn list of countries indexed by ISO 3166-1 country code\n\t*\t@return array\n\t**/\n\tfunction countries() {\n\t\treturn \\Base::instance()->constants($this,'CC_');\n\t}\n\n}\n\n//! Container for singular object instances\nfinal class Registry {\n\n\tprivate static\n\t\t//! Object catalog\n\t\t$table;\n\n\t/**\n\t*\tReturn TRUE if object exists in catalog\n\t*\t@return bool\n\t*\t@param $key string\n\t**/\n\tstatic function exists($key) {\n\t\treturn isset(self::$table[$key]);\n\t}\n\n\t/**\n\t*\tAdd object to catalog\n\t*\t@return object\n\t*\t@param $key string\n\t*\t@param $obj object\n\t**/\n\tstatic function set($key,$obj) {\n\t\treturn self::$table[$key]=$obj;\n\t}\n\n\t/**\n\t*\tRetrieve object from catalog\n\t*\t@return object\n\t*\t@param $key string\n\t**/\n\tstatic function get($key) {\n\t\treturn self::$table[$key];\n\t}\n\n\t/**\n\t*\tDelete object from catalog\n\t*\t@param $key string\n\t**/\n\tstatic function clear($key) {\n\t\tself::$table[$key]=NULL;\n\t\tunset(self::$table[$key]);\n\t}\n\n\t//! Prohibit cloning\n\tprivate function __clone() {\n\t}\n\n\t//! Prohibit instantiation\n\tprivate function __construct() {\n\t}\n\n}\n\nreturn Base::instance();\n"], "fixing_code": ["<?php\n\n/*\n\n\tCopyright (c) 2009-2019 F3::Factory/Bong Cosca, All rights reserved.\n\n\tThis file is part of the Fat-Free Framework (http://fatfreeframework.com).\n\n\tThis is free software: you can redistribute it and/or modify it under the\n\tterms of the GNU General Public License as published by the Free Software\n\tFoundation, either version 3 of the License, or later.\n\n\tFat-Free Framework is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tGeneral Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License along\n\twith Fat-Free Framework.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n//! Factory class for single-instance objects\nabstract class Prefab {\n\n\t/**\n\t*\tReturn class instance\n\t*\t@return static\n\t**/\n\tstatic function instance() {\n\t\tif (!Registry::exists($class=get_called_class())) {\n\t\t\t$ref=new ReflectionClass($class);\n\t\t\t$args=func_get_args();\n\t\t\tRegistry::set($class,\n\t\t\t\t$args?$ref->newinstanceargs($args):new $class);\n\t\t}\n\t\treturn Registry::get($class);\n\t}\n\n}\n\n//! Base structure\nfinal class Base extends Prefab implements ArrayAccess {\n\n\t//@{ Framework details\n\tconst\n\t\tPACKAGE='Fat-Free Framework',\n\t\tVERSION='3.7.1-Release';\n\t//@}\n\n\t//@{ HTTP status codes (RFC 2616)\n\tconst\n\t\tHTTP_100='Continue',\n\t\tHTTP_101='Switching Protocols',\n\t\tHTTP_103='Early Hints',\n\t\tHTTP_200='OK',\n\t\tHTTP_201='Created',\n\t\tHTTP_202='Accepted',\n\t\tHTTP_203='Non-Authorative Information',\n\t\tHTTP_204='No Content',\n\t\tHTTP_205='Reset Content',\n\t\tHTTP_206='Partial Content',\n\t\tHTTP_300='Multiple Choices',\n\t\tHTTP_301='Moved Permanently',\n\t\tHTTP_302='Found',\n\t\tHTTP_303='See Other',\n\t\tHTTP_304='Not Modified',\n\t\tHTTP_305='Use Proxy',\n\t\tHTTP_307='Temporary Redirect',\n\t\tHTTP_308='Permanent Redirect',\n\t\tHTTP_400='Bad Request',\n\t\tHTTP_401='Unauthorized',\n\t\tHTTP_402='Payment Required',\n\t\tHTTP_403='Forbidden',\n\t\tHTTP_404='Not Found',\n\t\tHTTP_405='Method Not Allowed',\n\t\tHTTP_406='Not Acceptable',\n\t\tHTTP_407='Proxy Authentication Required',\n\t\tHTTP_408='Request Timeout',\n\t\tHTTP_409='Conflict',\n\t\tHTTP_410='Gone',\n\t\tHTTP_411='Length Required',\n\t\tHTTP_412='Precondition Failed',\n\t\tHTTP_413='Request Entity Too Large',\n\t\tHTTP_414='Request-URI Too Long',\n\t\tHTTP_415='Unsupported Media Type',\n\t\tHTTP_416='Requested Range Not Satisfiable',\n\t\tHTTP_417='Expectation Failed',\n\t\tHTTP_421='Misdirected Request',\n\t\tHTTP_422='Unprocessable Entity',\n\t\tHTTP_423='Locked',\n\t\tHTTP_429='Too Many Requests',\n\t\tHTTP_451='Unavailable For Legal Reasons',\n\t\tHTTP_500='Internal Server Error',\n\t\tHTTP_501='Not Implemented',\n\t\tHTTP_502='Bad Gateway',\n\t\tHTTP_503='Service Unavailable',\n\t\tHTTP_504='Gateway Timeout',\n\t\tHTTP_505='HTTP Version Not Supported',\n\t\tHTTP_507='Insufficient Storage',\n\t\tHTTP_511='Network Authentication Required';\n\t//@}\n\n\tconst\n\t\t//! Mapped PHP globals\n\t\tGLOBALS='GET|POST|COOKIE|REQUEST|SESSION|FILES|SERVER|ENV',\n\t\t//! HTTP verbs\n\t\tVERBS='GET|HEAD|POST|PUT|PATCH|DELETE|CONNECT|OPTIONS',\n\t\t//! Default directory permissions\n\t\tMODE=0755,\n\t\t//! Syntax highlighting stylesheet\n\t\tCSS='code.css';\n\n\t//@{ Request types\n\tconst\n\t\tREQ_SYNC=1,\n\t\tREQ_AJAX=2,\n\t\tREQ_CLI=4;\n\t//@}\n\n\t//@{ Error messages\n\tconst\n\t\tE_Pattern='Invalid routing pattern: %s',\n\t\tE_Named='Named route does not exist: %s',\n\t\tE_Alias='Invalid named route alias: %s',\n\t\tE_Fatal='Fatal error: %s',\n\t\tE_Open='Unable to open %s',\n\t\tE_Routes='No routes specified',\n\t\tE_Class='Invalid class %s',\n\t\tE_Method='Invalid method %s',\n\t\tE_Hive='Invalid hive key %s';\n\t//@}\n\n\tprivate\n\t\t//! Globals\n\t\t$hive,\n\t\t//! Initial settings\n\t\t$init,\n\t\t//! Language lookup sequence\n\t\t$languages,\n\t\t//! Mutex locks\n\t\t$locks=[],\n\t\t//! Default fallback language\n\t\t$fallback='en';\n\n\t/**\n\t*\tSync PHP global with corresponding hive key\n\t*\t@return array\n\t*\t@param $key string\n\t**/\n\tfunction sync($key) {\n\t\treturn $this->hive[$key]=&$GLOBALS['_'.$key];\n\t}\n\n\t/**\n\t*\tReturn the parts of specified hive key\n\t*\t@return array\n\t*\t@param $key string\n\t**/\n\tprivate function cut($key) {\n\t\treturn preg_split('/\\[\\h*[\\'\"]?(.+?)[\\'\"]?\\h*\\]|(->)|\\./',\n\t\t\t$key,NULL,PREG_SPLIT_NO_EMPTY|PREG_SPLIT_DELIM_CAPTURE);\n\t}\n\n\t/**\n\t*\tReplace tokenized URL with available token values\n\t*\t@return string\n\t*\t@param $url array|string\n\t*\t@param $args array\n\t**/\n\tfunction build($url,$args=[]) {\n\t\t$args+=$this->hive['PARAMS'];\n\t\tif (is_array($url))\n\t\t\tforeach ($url as &$var) {\n\t\t\t\t$var=$this->build($var,$args);\n\t\t\t\tunset($var);\n\t\t\t}\n\t\telse {\n\t\t\t$i=0;\n\t\t\t$url=preg_replace_callback('/(\\{)?@(\\w+)(?(1)\\})|(\\*)/',\n\t\t\t\tfunction($match) use(&$i,$args) {\n\t\t\t\t\tif (isset($match[2]) &&\n\t\t\t\t\t\tarray_key_exists($match[2],$args))\n\t\t\t\t\t\treturn $args[$match[2]];\n\t\t\t\t\tif (isset($match[3]) &&\n\t\t\t\t\t\tarray_key_exists($match[3],$args)) {\n\t\t\t\t\t\tif (!is_array($args[$match[3]]))\n\t\t\t\t\t\t\treturn $args[$match[3]];\n\t\t\t\t\t\t$i++;\n\t\t\t\t\t\treturn $args[$match[3]][$i-1];\n\t\t\t\t\t}\n\t\t\t\t\treturn $match[0];\n\t\t\t\t},$url);\n\t\t}\n\t\treturn $url;\n\t}\n\n\t/**\n\t*\tParse string containing key-value pairs\n\t*\t@return array\n\t*\t@param $str string\n\t**/\n\tfunction parse($str) {\n\t\tpreg_match_all('/(\\w+|\\*)\\h*=\\h*(?:\\[(.+?)\\]|(.+?))(?=,|$)/',\n\t\t\t$str,$pairs,PREG_SET_ORDER);\n\t\t$out=[];\n\t\tforeach ($pairs as $pair)\n\t\t\tif ($pair[2]) {\n\t\t\t\t$out[$pair[1]]=[];\n\t\t\t\tforeach (explode(',',$pair[2]) as $val)\n\t\t\t\t\tarray_push($out[$pair[1]],$val);\n\t\t\t}\n\t\t\telse\n\t\t\t\t$out[$pair[1]]=trim($pair[3]);\n\t\treturn $out;\n\t}\n\n\t/**\n\t * Cast string variable to PHP type or constant\n\t * @param $val\n\t * @return mixed\n\t */\n\tfunction cast($val) {\n\t\tif (preg_match('/^(?:0x[0-9a-f]+|0[0-7]+|0b[01]+)$/i',$val))\n\t\t\treturn intval($val,0);\n\t\tif (is_numeric($val))\n\t\t\treturn $val+0;\n\t\t$val=trim($val);\n\t\tif (preg_match('/^\\w+$/i',$val) && defined($val))\n\t\t\treturn constant($val);\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tConvert JS-style token to PHP expression\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction compile($str) {\n\t\treturn preg_replace_callback(\n\t\t\t'/(?<!\\w)@(\\w+(?:(?:\\->|::)\\w+)?)'.\n\t\t\t'((?:\\.\\w+|\\[(?:(?:[^\\[\\]]*|(?R))*)\\]|(?:\\->|::)\\w+|\\()*)/',\n\t\t\tfunction($expr) {\n\t\t\t\t$str='$'.$expr[1];\n\t\t\t\tif (isset($expr[2]))\n\t\t\t\t\t$str.=preg_replace_callback(\n\t\t\t\t\t\t'/\\.(\\w+)(\\()?|\\[((?:[^\\[\\]]*|(?R))*)\\]/',\n\t\t\t\t\t\tfunction($sub) {\n\t\t\t\t\t\t\tif (empty($sub[2])) {\n\t\t\t\t\t\t\t\tif (ctype_digit($sub[1]))\n\t\t\t\t\t\t\t\t\t$sub[1]=(int)$sub[1];\n\t\t\t\t\t\t\t\t$out='['.\n\t\t\t\t\t\t\t\t\t(isset($sub[3])?\n\t\t\t\t\t\t\t\t\t\t$this->compile($sub[3]):\n\t\t\t\t\t\t\t\t\t\t$this->export($sub[1])).\n\t\t\t\t\t\t\t\t']';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t$out=function_exists($sub[1])?\n\t\t\t\t\t\t\t\t\t$sub[0]:\n\t\t\t\t\t\t\t\t\t('['.$this->export($sub[1]).']'.$sub[2]);\n\t\t\t\t\t\t\treturn $out;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t$expr[2]\n\t\t\t\t\t);\n\t\t\t\treturn $str;\n\t\t\t},\n\t\t\t$str\n\t\t);\n\t}\n\n\t/**\n\t*\tGet hive key reference/contents; Add non-existent hive keys,\n\t*\tarray elements, and object properties by default\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $add bool\n\t*\t@param $var mixed\n\t**/\n\tfunction &ref($key,$add=TRUE,&$var=NULL) {\n\t\t$null=NULL;\n\t\t$parts=$this->cut($key);\n\t\tif ($parts[0]=='SESSION') {\n\t\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\tsession_start();\n\t\t\t$this->sync('SESSION');\n\t\t}\n\t\telseif (!preg_match('/^\\w+$/',$parts[0]))\n\t\t\tuser_error(sprintf(self::E_Hive,$this->stringify($key)),\n\t\t\t\tE_USER_ERROR);\n\t\tif (is_null($var)) {\n\t\t\tif ($add)\n\t\t\t\t$var=&$this->hive;\n\t\t\telse\n\t\t\t\t$var=$this->hive;\n\t\t}\n\t\t$obj=FALSE;\n\t\tforeach ($parts as $part)\n\t\t\tif ($part=='->')\n\t\t\t\t$obj=TRUE;\n\t\t\telseif ($obj) {\n\t\t\t\t$obj=FALSE;\n\t\t\t\tif (!is_object($var))\n\t\t\t\t\t$var=new stdClass;\n\t\t\t\tif ($add || property_exists($var,$part))\n\t\t\t\t\t$var=&$var->$part;\n\t\t\t\telse {\n\t\t\t\t\t$var=&$null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!is_array($var))\n\t\t\t\t\t$var=[];\n\t\t\t\tif ($add || array_key_exists($part,$var))\n\t\t\t\t\t$var=&$var[$part];\n\t\t\t\telse {\n\t\t\t\t\t$var=&$null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\treturn $var;\n\t}\n\n\t/**\n\t*\tReturn TRUE if hive key is set\n\t*\t(or return timestamp and TTL if cached)\n\t*\t@return bool\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction exists($key,&$val=NULL) {\n\t\t$val=$this->ref($key,FALSE);\n\t\treturn isset($val)?\n\t\t\tTRUE:\n\t\t\t(Cache::instance()->exists($this->hash($key).'.var',$val)?:FALSE);\n\t}\n\n\t/**\n\t*\tReturn TRUE if hive key is empty and not cached\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t*\t@return bool\n\t**/\n\tfunction devoid($key,&$val=NULL) {\n\t\t$val=$this->ref($key,FALSE);\n\t\treturn empty($val) &&\n\t\t\t(!Cache::instance()->exists($this->hash($key).'.var',$val) ||\n\t\t\t\t!$val);\n\t}\n\n\t/**\n\t*\tBind value to hive key\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t*\t@param $ttl int\n\t**/\n\tfunction set($key,$val,$ttl=0) {\n\t\t$time=(int)$this->hive['TIME'];\n\t\tif (preg_match('/^(GET|POST|COOKIE)\\b(.+)/',$key,$expr)) {\n\t\t\t$this->set('REQUEST'.$expr[2],$val);\n\t\t\tif ($expr[1]=='COOKIE') {\n\t\t\t\t$parts=$this->cut($key);\n\t\t\t\t$jar=$this->unserialize($this->serialize($this->hive['JAR']));\n\t\t\t\tunset($jar['lifetime']);\n\t\t\t\tif (version_compare(PHP_VERSION, '7.3.0') >= 0) {\n\t\t\t\t\tunset($jar['expire']);\n\t\t\t\t\tif (isset($_COOKIE[$parts[1]]))\n\t\t\t\t\t\tsetcookie($parts[1],NULL,['expires'=>0]+$jar);\n\t\t\t\t\tif ($ttl)\n\t\t\t\t\t\t$jar['expires']=$time+$ttl;\n\t\t\t\t\tsetcookie($parts[1],$val,$jar);\n\t\t\t\t} else {\n\t\t\t\t\tunset($jar['samesite']);\n\t\t\t\t\tif (isset($_COOKIE[$parts[1]]))\n\t\t\t\t\t\tcall_user_func_array('setcookie',\n\t\t\t\t\t\t\tarray_merge([$parts[1],NULL],['expire'=>0]+$jar));\n\t\t\t\t\tif ($ttl)\n\t\t\t\t\t\t$jar['expire']=$time+$ttl;\n\t\t\t\t\tcall_user_func_array('setcookie',[$parts[1],$val]+$jar);\n\t\t\t\t}\n\t\t\t\t$_COOKIE[$parts[1]]=$val;\n\t\t\t\treturn $val;\n\t\t\t}\n\t\t}\n\t\telse switch ($key) {\n\t\tcase 'CACHE':\n\t\t\t$val=Cache::instance()->load($val);\n\t\t\tbreak;\n\t\tcase 'ENCODING':\n\t\t\tini_set('default_charset',$val);\n\t\t\tif (extension_loaded('mbstring'))\n\t\t\t\tmb_internal_encoding($val);\n\t\t\tbreak;\n\t\tcase 'FALLBACK':\n\t\t\t$this->fallback=$val;\n\t\t\t$lang=$this->language($this->hive['LANGUAGE']);\n\t\tcase 'LANGUAGE':\n\t\t\tif (!isset($lang))\n\t\t\t\t$val=$this->language($val);\n\t\t\t$lex=$this->lexicon($this->hive['LOCALES'],$ttl);\n\t\tcase 'LOCALES':\n\t\t\tif (isset($lex) || $lex=$this->lexicon($val,$ttl))\n\t\t\t\tforeach ($lex as $dt=>$dd) {\n\t\t\t\t\t$ref=&$this->ref($this->hive['PREFIX'].$dt);\n\t\t\t\t\t$ref=$dd;\n\t\t\t\t\tunset($ref);\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase 'TZ':\n\t\t\tdate_default_timezone_set($val);\n\t\t\tbreak;\n\t\t}\n\t\t$ref=&$this->ref($key);\n\t\t$ref=$val;\n\t\tif (preg_match('/^JAR\\b/',$key)) {\n\t\t\tif ($key=='JAR.lifetime')\n\t\t\t\t$this->set('JAR.expire',$val==0?0:\n\t\t\t\t\t(is_int($val)?$time+$val:strtotime($val)));\n\t\t\telse {\n\t\t\t\tif ($key=='JAR.expire')\n\t\t\t\t\t$this->hive['JAR']['lifetime']=max(0,$val-$time);\n\t\t\t\t$jar=$this->unserialize($this->serialize($this->hive['JAR']));\n\t\t\t\tunset($jar['expire']);\n\t\t\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\t\tif (version_compare(PHP_VERSION, '7.3.0') >= 0)\n\t\t\t\t\t\tsession_set_cookie_params($jar);\n\t\t\t\t\telse {\n\t\t\t\t\t\tunset($jar['samesite']);\n\t\t\t\t\t\tcall_user_func_array('session_set_cookie_params',$jar);\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ($ttl)\n\t\t\t// Persist the key-value pair\n\t\t\tCache::instance()->set($this->hash($key).'.var',$val,$ttl);\n\t\treturn $ref;\n\t}\n\n\t/**\n\t*\tRetrieve contents of hive key\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $args string|array\n\t**/\n\tfunction get($key,$args=NULL) {\n\t\tif (is_string($val=$this->ref($key,FALSE)) && !is_null($args))\n\t\t\treturn call_user_func_array(\n\t\t\t\t[$this,'format'],\n\t\t\t\tarray_merge([$val],is_array($args)?$args:[$args])\n\t\t\t);\n\t\tif (is_null($val)) {\n\t\t\t// Attempt to retrieve from cache\n\t\t\tif (Cache::instance()->exists($this->hash($key).'.var',$data))\n\t\t\t\treturn $data;\n\t\t}\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tUnset hive key\n\t*\t@param $key string\n\t**/\n\tfunction clear($key) {\n\t\t// Normalize array literal\n\t\t$cache=Cache::instance();\n\t\t$parts=$this->cut($key);\n\t\tif ($key=='CACHE')\n\t\t\t// Clear cache contents\n\t\t\t$cache->reset();\n\t\telseif (preg_match('/^(GET|POST|COOKIE)\\b(.+)/',$key,$expr)) {\n\t\t\t$this->clear('REQUEST'.$expr[2]);\n\t\t\tif ($expr[1]=='COOKIE') {\n\t\t\t\t$parts=$this->cut($key);\n\t\t\t\t$jar=$this->hive['JAR'];\n\t\t\t\tunset($jar['lifetime']);\n\t\t\t\t$jar['expire']=0;\n\t\t\t\tif (version_compare(PHP_VERSION, '7.3.0') >= 0) {\n\t\t\t\t\t$jar['expires']=$jar['expire'];\n\t\t\t\t\tunset($jar['expire']);\n\t\t\t\t\tsetcookie($parts[1],NULL,$jar);\n\t\t\t\t} else {\n\t\t\t\t\tunset($jar['samesite']);\n\t\t\t\t\tcall_user_func_array('setcookie',\n\t\t\t\t\t\tarray_merge([$parts[1],NULL],$jar));\n\t\t\t\t}\n\t\t\t\tunset($_COOKIE[$parts[1]]);\n\t\t\t}\n\t\t}\n\t\telseif ($parts[0]=='SESSION') {\n\t\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\tsession_start();\n\t\t\tif (empty($parts[1])) {\n\t\t\t\t// End session\n\t\t\t\tsession_unset();\n\t\t\t\tsession_destroy();\n\t\t\t\t$this->clear('COOKIE.'.session_name());\n\t\t\t}\n\t\t\t$this->sync('SESSION');\n\t\t}\n\t\tif (!isset($parts[1]) && array_key_exists($parts[0],$this->init))\n\t\t\t// Reset global to default value\n\t\t\t$this->hive[$parts[0]]=$this->init[$parts[0]];\n\t\telse {\n\t\t\t// Ensure we have no code injection\n\t\t\t$key=preg_replace('/(\\)\\W*\\w+.*$)/','',$key);\n\t\t\teval('unset('.$this->compile('@this->hive.'.$key).');');\n\t\t\tif ($parts[0]=='SESSION') {\n\t\t\t\tsession_commit();\n\t\t\t\tsession_start();\n\t\t\t}\n\t\t\tif ($cache->exists($hash=$this->hash($key).'.var'))\n\t\t\t\t// Remove from cache\n\t\t\t\t$cache->clear($hash);\n\t\t}\n\t}\n\n\t/**\n\t*\tReturn TRUE if hive variable is 'on'\n\t*\t@return bool\n\t*\t@param $key string\n\t**/\n\tfunction checked($key) {\n\t\t$ref=&$this->ref($key);\n\t\treturn $ref=='on';\n\t}\n\n\t/**\n\t*\tReturn TRUE if property has public visibility\n\t*\t@return bool\n\t*\t@param $obj object\n\t*\t@param $key string\n\t**/\n\tfunction visible($obj,$key) {\n\t\tif (property_exists($obj,$key)) {\n\t\t\t$ref=new ReflectionProperty(get_class($obj),$key);\n\t\t\t$out=$ref->ispublic();\n\t\t\tunset($ref);\n\t\t\treturn $out;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tMulti-variable assignment using associative array\n\t*\t@param $vars array\n\t*\t@param $prefix string\n\t*\t@param $ttl int\n\t**/\n\tfunction mset(array $vars,$prefix='',$ttl=0) {\n\t\tforeach ($vars as $key=>$val)\n\t\t\t$this->set($prefix.$key,$val,$ttl);\n\t}\n\n\t/**\n\t*\tPublish hive contents\n\t*\t@return array\n\t**/\n\tfunction hive() {\n\t\treturn $this->hive;\n\t}\n\n\t/**\n\t*\tCopy contents of hive variable to another\n\t*\t@return mixed\n\t*\t@param $src string\n\t*\t@param $dst string\n\t**/\n\tfunction copy($src,$dst) {\n\t\t$ref=&$this->ref($dst);\n\t\treturn $ref=$this->ref($src,FALSE);\n\t}\n\n\t/**\n\t*\tConcatenate string to hive string variable\n\t*\t@return string\n\t*\t@param $key string\n\t*\t@param $val string\n\t**/\n\tfunction concat($key,$val) {\n\t\t$ref=&$this->ref($key);\n\t\t$ref.=$val;\n\t\treturn $ref;\n\t}\n\n\t/**\n\t*\tSwap keys and values of hive array variable\n\t*\t@return array\n\t*\t@param $key string\n\t*\t@public\n\t**/\n\tfunction flip($key) {\n\t\t$ref=&$this->ref($key);\n\t\treturn $ref=array_combine(array_values($ref),array_keys($ref));\n\t}\n\n\t/**\n\t*\tAdd element to the end of hive array variable\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction push($key,$val) {\n\t\t$ref=&$this->ref($key);\n\t\t$ref[]=$val;\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tRemove last element of hive array variable\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction pop($key) {\n\t\t$ref=&$this->ref($key);\n\t\treturn array_pop($ref);\n\t}\n\n\t/**\n\t*\tAdd element to the beginning of hive array variable\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction unshift($key,$val) {\n\t\t$ref=&$this->ref($key);\n\t\tarray_unshift($ref,$val);\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tRemove first element of hive array variable\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction shift($key) {\n\t\t$ref=&$this->ref($key);\n\t\treturn array_shift($ref);\n\t}\n\n\t/**\n\t*\tMerge array with hive array variable\n\t*\t@return array\n\t*\t@param $key string\n\t*\t@param $src string|array\n\t*\t@param $keep bool\n\t**/\n\tfunction merge($key,$src,$keep=FALSE) {\n\t\t$ref=&$this->ref($key);\n\t\tif (!$ref)\n\t\t\t$ref=[];\n\t\t$out=array_merge($ref,is_string($src)?$this->hive[$src]:$src);\n\t\tif ($keep)\n\t\t\t$ref=$out;\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tExtend hive array variable with default values from $src\n\t*\t@return array\n\t*\t@param $key string\n\t*\t@param $src string|array\n\t*\t@param $keep bool\n\t**/\n\tfunction extend($key,$src,$keep=FALSE) {\n\t\t$ref=&$this->ref($key);\n\t\tif (!$ref)\n\t\t\t$ref=[];\n\t\t$out=array_replace_recursive(\n\t\t\tis_string($src)?$this->hive[$src]:$src,$ref);\n\t\tif ($keep)\n\t\t\t$ref=$out;\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tConvert backslashes to slashes\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction fixslashes($str) {\n\t\treturn $str?strtr($str,'\\\\','/'):$str;\n\t}\n\n\t/**\n\t*\tSplit comma-, semi-colon, or pipe-separated string\n\t*\t@return array\n\t*\t@param $str string\n\t*\t@param $noempty bool\n\t**/\n\tfunction split($str,$noempty=TRUE) {\n\t\treturn array_map('trim',\n\t\t\tpreg_split('/[,;|]/',$str,0,$noempty?PREG_SPLIT_NO_EMPTY:0));\n\t}\n\n\t/**\n\t*\tConvert PHP expression/value to compressed exportable string\n\t*\t@return string\n\t*\t@param $arg mixed\n\t*\t@param $stack array\n\t**/\n\tfunction stringify($arg,array $stack=NULL) {\n\t\tif ($stack) {\n\t\t\tforeach ($stack as $node)\n\t\t\t\tif ($arg===$node)\n\t\t\t\t\treturn '*RECURSION*';\n\t\t}\n\t\telse\n\t\t\t$stack=[];\n\t\tswitch (gettype($arg)) {\n\t\t\tcase 'object':\n\t\t\t\t$str='';\n\t\t\t\tforeach (get_object_vars($arg) as $key=>$val)\n\t\t\t\t\t$str.=($str?',':'').\n\t\t\t\t\t\t$this->export($key).'=>'.\n\t\t\t\t\t\t$this->stringify($val,\n\t\t\t\t\t\t\tarray_merge($stack,[$arg]));\n\t\t\t\treturn get_class($arg).'::__set_state(['.$str.'])';\n\t\t\tcase 'array':\n\t\t\t\t$str='';\n\t\t\t\t$num=isset($arg[0]) &&\n\t\t\t\t\tctype_digit(implode('',array_keys($arg)));\n\t\t\t\tforeach ($arg as $key=>$val)\n\t\t\t\t\t$str.=($str?',':'').\n\t\t\t\t\t\t($num?'':($this->export($key).'=>')).\n\t\t\t\t\t\t$this->stringify($val,array_merge($stack,[$arg]));\n\t\t\t\treturn '['.$str.']';\n\t\t\tdefault:\n\t\t\t\treturn $this->export($arg);\n\t\t}\n\t}\n\n\t/**\n\t*\tFlatten array values and return as CSV string\n\t*\t@return string\n\t*\t@param $args array\n\t**/\n\tfunction csv(array $args) {\n\t\treturn implode(',',array_map('stripcslashes',\n\t\t\tarray_map([$this,'stringify'],$args)));\n\t}\n\n\t/**\n\t*\tConvert snakecase string to camelcase\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction camelcase($str) {\n\t\treturn preg_replace_callback(\n\t\t\t'/_(\\pL)/u',\n\t\t\tfunction($match) {\n\t\t\t\treturn strtoupper($match[1]);\n\t\t\t},\n\t\t\t$str\n\t\t);\n\t}\n\n\t/**\n\t*\tConvert camelcase string to snakecase\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction snakecase($str) {\n\t\treturn strtolower(preg_replace('/(?!^)\\p{Lu}/u','_\\0',$str));\n\t}\n\n\t/**\n\t*\tReturn -1 if specified number is negative, 0 if zero,\n\t*\tor 1 if the number is positive\n\t*\t@return int\n\t*\t@param $num mixed\n\t**/\n\tfunction sign($num) {\n\t\treturn $num?($num/abs($num)):0;\n\t}\n\n\t/**\n\t*\tExtract values of array whose keys start with the given prefix\n\t*\t@return array\n\t*\t@param $arr array\n\t*\t@param $prefix string\n\t**/\n\tfunction extract($arr,$prefix) {\n\t\t$out=[];\n\t\tforeach (preg_grep('/^'.preg_quote($prefix,'/').'/',array_keys($arr))\n\t\t\tas $key)\n\t\t\t$out[substr($key,strlen($prefix))]=$arr[$key];\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tConvert class constants to array\n\t*\t@return array\n\t*\t@param $class object|string\n\t*\t@param $prefix string\n\t**/\n\tfunction constants($class,$prefix='') {\n\t\t$ref=new ReflectionClass($class);\n\t\treturn $this->extract($ref->getconstants(),$prefix);\n\t}\n\n\t/**\n\t*\tGenerate 64bit/base36 hash\n\t*\t@return string\n\t*\t@param $str\n\t**/\n\tfunction hash($str) {\n\t\treturn str_pad(base_convert(\n\t\t\tsubstr(sha1($str),-16),16,36),11,'0',STR_PAD_LEFT);\n\t}\n\n\t/**\n\t*\tReturn Base64-encoded equivalent\n\t*\t@return string\n\t*\t@param $data string\n\t*\t@param $mime string\n\t**/\n\tfunction base64($data,$mime) {\n\t\treturn 'data:'.$mime.';base64,'.base64_encode($data);\n\t}\n\n\t/**\n\t*\tConvert special characters to HTML entities\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction encode($str) {\n\t\treturn @htmlspecialchars($str,$this->hive['BITMASK'],\n\t\t\t$this->hive['ENCODING'])?:$this->scrub($str);\n\t}\n\n\t/**\n\t*\tConvert HTML entities back to characters\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction decode($str) {\n\t\treturn htmlspecialchars_decode($str,$this->hive['BITMASK']);\n\t}\n\n\t/**\n\t*\tInvoke callback recursively for all data types\n\t*\t@return mixed\n\t*\t@param $arg mixed\n\t*\t@param $func callback\n\t*\t@param $stack array\n\t**/\n\tfunction recursive($arg,$func,$stack=[]) {\n\t\tif ($stack) {\n\t\t\tforeach ($stack as $node)\n\t\t\t\tif ($arg===$node)\n\t\t\t\t\treturn $arg;\n\t\t}\n\t\tswitch (gettype($arg)) {\n\t\t\tcase 'object':\n\t\t\t\t$ref=new ReflectionClass($arg);\n\t\t\t\tif ($ref->iscloneable()) {\n\t\t\t\t\t$arg=clone($arg);\n\t\t\t\t\t$cast=is_a($arg,'IteratorAggregate')?\n\t\t\t\t\t\titerator_to_array($arg):get_object_vars($arg);\n\t\t\t\t\tforeach ($cast as $key=>$val)\n\t\t\t\t\t\t$arg->$key=$this->recursive(\n\t\t\t\t\t\t\t$val,$func,array_merge($stack,[$arg]));\n\t\t\t\t}\n\t\t\t\treturn $arg;\n\t\t\tcase 'array':\n\t\t\t\t$copy=[];\n\t\t\t\tforeach ($arg as $key=>$val)\n\t\t\t\t\t$copy[$key]=$this->recursive($val,$func,\n\t\t\t\t\t\tarray_merge($stack,[$arg]));\n\t\t\t\treturn $copy;\n\t\t}\n\t\treturn $func($arg);\n\t}\n\n\t/**\n\t*\tRemove HTML tags (except those enumerated) and non-printable\n\t*\tcharacters to mitigate XSS/code injection attacks\n\t*\t@return mixed\n\t*\t@param $arg mixed\n\t*\t@param $tags string\n\t**/\n\tfunction clean($arg,$tags=NULL) {\n\t\treturn $this->recursive($arg,\n\t\t\tfunction($val) use($tags) {\n\t\t\t\tif ($tags!='*')\n\t\t\t\t\t$val=trim(strip_tags($val,\n\t\t\t\t\t\t'<'.implode('><',$this->split($tags)).'>'));\n\t\t\t\treturn trim(preg_replace(\n\t\t\t\t\t'/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/','',$val));\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t*\tSimilar to clean(), except that variable is passed by reference\n\t*\t@return mixed\n\t*\t@param $var mixed\n\t*\t@param $tags string\n\t**/\n\tfunction scrub(&$var,$tags=NULL) {\n\t\treturn $var=$this->clean($var,$tags);\n\t}\n\n\t/**\n\t*\tReturn locale-aware formatted string\n\t*\t@return string\n\t**/\n\tfunction format() {\n\t\t$args=func_get_args();\n\t\t$val=array_shift($args);\n\t\t// Get formatting rules\n\t\t$conv=localeconv();\n\t\treturn preg_replace_callback(\n\t\t\t'/\\{\\s*(?P<pos>\\d+)\\s*(?:,\\s*(?P<type>\\w+)\\s*'.\n\t\t\t'(?:,\\s*(?P<mod>(?:\\w+(?:\\s*\\{.+?\\}\\s*,?\\s*)?)*)'.\n\t\t\t'(?:,\\s*(?P<prop>.+?))?)?)?\\s*\\}/',\n\t\t\tfunction($expr) use($args,$conv) {\n\t\t\t\t/**\n\t\t\t\t * @var string $pos\n\t\t\t\t * @var string $mod\n\t\t\t\t * @var string $type\n\t\t\t\t * @var string $prop\n\t\t\t\t */\n\t\t\t\textract($expr);\n\t\t\t\t/**\n\t\t\t\t * @var string $thousands_sep\n\t\t\t\t * @var string $negative_sign\n\t\t\t\t * @var string $positive_sign\n\t\t\t\t * @var string $frac_digits\n\t\t\t\t * @var string $decimal_point\n\t\t\t\t * @var string $int_curr_symbol\n\t\t\t\t * @var string $currency_symbol\n\t\t\t\t */\n\t\t\t\textract($conv);\n\t\t\t\tif (!array_key_exists($pos,$args))\n\t\t\t\t\treturn $expr[0];\n\t\t\t\tif (isset($type)) {\n\t\t\t\t\tif (isset($this->hive['FORMATS'][$type]))\n\t\t\t\t\t\treturn $this->call(\n\t\t\t\t\t\t\t$this->hive['FORMATS'][$type],\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t$args[$pos],\n\t\t\t\t\t\t\t\tisset($mod)?$mod:null,\n\t\t\t\t\t\t\t\tisset($prop)?$prop:null\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t);\n\t\t\t\t\tswitch ($type) {\n\t\t\t\t\t\tcase 'plural':\n\t\t\t\t\t\t\tpreg_match_all('/(?<tag>\\w+)'.\n\t\t\t\t\t\t\t\t'(?:\\s*\\{\\s*(?<data>.+?)\\s*\\})/',\n\t\t\t\t\t\t\t\t$mod,$matches,PREG_SET_ORDER);\n\t\t\t\t\t\t\t$ord=['zero','one','two'];\n\t\t\t\t\t\t\tforeach ($matches as $match) {\n\t\t\t\t\t\t\t\t/** @var string $tag */\n\t\t\t\t\t\t\t\t/** @var string $data */\n\t\t\t\t\t\t\t\textract($match);\n\t\t\t\t\t\t\t\tif (isset($ord[$args[$pos]]) &&\n\t\t\t\t\t\t\t\t\t$tag==$ord[$args[$pos]] || $tag=='other')\n\t\t\t\t\t\t\t\t\treturn str_replace('#',$args[$pos],$data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tif (isset($mod))\n\t\t\t\t\t\t\t\tswitch ($mod) {\n\t\t\t\t\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\t\t\t\t\treturn number_format(\n\t\t\t\t\t\t\t\t\t\t\t$args[$pos],0,'',$thousands_sep);\n\t\t\t\t\t\t\t\t\tcase 'currency':\n\t\t\t\t\t\t\t\t\t\t$int=$cstm=FALSE;\n\t\t\t\t\t\t\t\t\t\tif (isset($prop) &&\n\t\t\t\t\t\t\t\t\t\t\t$cstm=!$int=($prop=='int'))\n\t\t\t\t\t\t\t\t\t\t\t$currency_symbol=$prop;\n\t\t\t\t\t\t\t\t\t\tif (!$cstm &&\n\t\t\t\t\t\t\t\t\t\t\tfunction_exists('money_format'))\n\t\t\t\t\t\t\t\t\t\t\treturn money_format(\n\t\t\t\t\t\t\t\t\t\t\t\t'%'.($int?'i':'n'),$args[$pos]);\n\t\t\t\t\t\t\t\t\t\t$fmt=[\n\t\t\t\t\t\t\t\t\t\t\t0=>'(nc)',1=>'(n c)',\n\t\t\t\t\t\t\t\t\t\t\t2=>'(nc)',10=>'+nc',\n\t\t\t\t\t\t\t\t\t\t\t11=>'+n c',12=>'+ nc',\n\t\t\t\t\t\t\t\t\t\t\t20=>'nc+',21=>'n c+',\n\t\t\t\t\t\t\t\t\t\t\t22=>'nc +',30=>'n+c',\n\t\t\t\t\t\t\t\t\t\t\t31=>'n +c',32=>'n+ c',\n\t\t\t\t\t\t\t\t\t\t\t40=>'nc+',41=>'n c+',\n\t\t\t\t\t\t\t\t\t\t\t42=>'nc +',100=>'(cn)',\n\t\t\t\t\t\t\t\t\t\t\t101=>'(c n)',102=>'(cn)',\n\t\t\t\t\t\t\t\t\t\t\t110=>'+cn',111=>'+c n',\n\t\t\t\t\t\t\t\t\t\t\t112=>'+ cn',120=>'cn+',\n\t\t\t\t\t\t\t\t\t\t\t121=>'c n+',122=>'cn +',\n\t\t\t\t\t\t\t\t\t\t\t130=>'+cn',131=>'+c n',\n\t\t\t\t\t\t\t\t\t\t\t132=>'+ cn',140=>'c+n',\n\t\t\t\t\t\t\t\t\t\t\t141=>'c+ n',142=>'c +n'\n\t\t\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t\t\t\tif ($args[$pos]<0) {\n\t\t\t\t\t\t\t\t\t\t\t$sgn=$negative_sign;\n\t\t\t\t\t\t\t\t\t\t\t$pre='n';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t$sgn=$positive_sign;\n\t\t\t\t\t\t\t\t\t\t\t$pre='p';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn str_replace(\n\t\t\t\t\t\t\t\t\t\t\t['+','n','c'],\n\t\t\t\t\t\t\t\t\t\t\t[$sgn,number_format(\n\t\t\t\t\t\t\t\t\t\t\t\tabs($args[$pos]),\n\t\t\t\t\t\t\t\t\t\t\t\t$frac_digits,\n\t\t\t\t\t\t\t\t\t\t\t\t$decimal_point,\n\t\t\t\t\t\t\t\t\t\t\t\t$thousands_sep),\n\t\t\t\t\t\t\t\t\t\t\t\t$int?$int_curr_symbol\n\t\t\t\t\t\t\t\t\t\t\t\t\t:$currency_symbol],\n\t\t\t\t\t\t\t\t\t\t\t$fmt[(int)(\n\t\t\t\t\t\t\t\t\t\t\t\t(${$pre.'_cs_precedes'}%2).\n\t\t\t\t\t\t\t\t\t\t\t\t(${$pre.'_sign_posn'}%5).\n\t\t\t\t\t\t\t\t\t\t\t\t(${$pre.'_sep_by_space'}%3)\n\t\t\t\t\t\t\t\t\t\t\t)]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcase 'percent':\n\t\t\t\t\t\t\t\t\t\treturn number_format(\n\t\t\t\t\t\t\t\t\t\t\t$args[$pos]*100,0,$decimal_point,\n\t\t\t\t\t\t\t\t\t\t\t$thousands_sep).'%';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$frac=$args[$pos]-(int)$args[$pos];\n\t\t\t\t\t\t\treturn number_format(\n\t\t\t\t\t\t\t\t$args[$pos],\n\t\t\t\t\t\t\t\tisset($prop)?\n\t\t\t\t\t\t\t\t\t$prop:\n\t\t\t\t\t\t\t\t\t($frac?strlen($frac)-2:0),\n\t\t\t\t\t\t\t\t$decimal_point,$thousands_sep);\n\t\t\t\t\t\tcase 'date':\n\t\t\t\t\t\t\tif (empty($mod) || $mod=='short')\n\t\t\t\t\t\t\t\t$prop='%x';\n\t\t\t\t\t\t\telseif ($mod=='full')\n\t\t\t\t\t\t\t\t$prop='%A, %d %B %Y';\n\t\t\t\t\t\t\telseif ($mod!='custom')\n\t\t\t\t\t\t\t\t$prop='%d %B %Y';\n\t\t\t\t\t\t\treturn strftime($prop,$args[$pos]);\n\t\t\t\t\t\tcase 'time':\n\t\t\t\t\t\t\tif (empty($mod) || $mod=='short')\n\t\t\t\t\t\t\t\t$prop='%X';\n\t\t\t\t\t\t\telseif ($mod!='custom')\n\t\t\t\t\t\t\t\t$prop='%r';\n\t\t\t\t\t\t\treturn strftime($prop,$args[$pos]);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn $expr[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn $args[$pos];\n\t\t\t},\n\t\t\t$val\n\t\t);\n\t}\n\n\t/**\n\t*\tReturn string representation of expression\n\t*\t@return string\n\t*\t@param $expr mixed\n\t**/\n\tfunction export($expr) {\n\t\treturn var_export($expr,TRUE);\n\t}\n\n\t/**\n\t*\tAssign/auto-detect language\n\t*\t@return string\n\t*\t@param $code string\n\t**/\n\tfunction language($code) {\n\t\t$code=preg_replace('/\\h+|;q=[0-9.]+/','',$code);\n\t\t$code.=($code?',':'').$this->fallback;\n\t\t$this->languages=[];\n\t\tforeach (array_reverse(explode(',',$code)) as $lang)\n\t\t\tif (preg_match('/^(\\w{2})(?:-(\\w{2}))?\\b/i',$lang,$parts)) {\n\t\t\t\t// Generic language\n\t\t\t\tarray_unshift($this->languages,$parts[1]);\n\t\t\t\tif (isset($parts[2])) {\n\t\t\t\t\t// Specific language\n\t\t\t\t\t$parts[0]=$parts[1].'-'.($parts[2]=strtoupper($parts[2]));\n\t\t\t\t\tarray_unshift($this->languages,$parts[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t$this->languages=array_unique($this->languages);\n\t\t$locales=[];\n\t\t$windows=preg_match('/^win/i',PHP_OS);\n\t\t// Work around PHP's Turkish locale bug\n\t\tforeach (preg_grep('/^(?!tr)/i',$this->languages) as $locale) {\n\t\t\tif ($windows) {\n\t\t\t\t$parts=explode('-',$locale);\n\t\t\t\t$locale=@constant('ISO::LC_'.$parts[0]);\n\t\t\t\tif (isset($parts[1]) &&\n\t\t\t\t\t$country=@constant('ISO::CC_'.strtolower($parts[1])))\n\t\t\t\t\t$locale.='-'.$country;\n\t\t\t}\n\t\t\t$locale=str_replace('-','_',$locale);\n\t\t\t$locales[]=$locale.'.'.ini_get('default_charset');\n\t\t\t$locales[]=$locale;\n\t\t}\n\t\tsetlocale(LC_ALL,$locales);\n\t\treturn $this->hive['LANGUAGE']=implode(',',$this->languages);\n\t}\n\n\t/**\n\t*\tReturn lexicon entries\n\t*\t@return array\n\t*\t@param $path string\n\t*\t@param $ttl int\n\t**/\n\tfunction lexicon($path,$ttl=0) {\n\t\t$languages=$this->languages?:explode(',',$this->fallback);\n\t\t$cache=Cache::instance();\n\t\tif ($cache->exists(\n\t\t\t$hash=$this->hash(implode(',',$languages).$path).'.dic',$lex))\n\t\t\treturn $lex;\n\t\t$lex=[];\n\t\tforeach ($languages as $lang)\n\t\t\tforeach ($this->split($path) as $dir)\n\t\t\t\tif ((is_file($file=($base=$dir.$lang).'.php') ||\n\t\t\t\t\tis_file($file=$base.'.php')) &&\n\t\t\t\t\tis_array($dict=require($file)))\n\t\t\t\t\t$lex+=$dict;\n\t\t\t\telseif (is_file($file=$base.'.json') &&\n\t\t\t\t\tis_array($dict=json_decode(file_get_contents($file), true)))\n\t\t\t\t\t$lex+=$dict;\n\t\t\t\telseif (is_file($file=$base.'.ini')) {\n\t\t\t\t\tpreg_match_all(\n\t\t\t\t\t\t'/(?<=^|\\n)(?:'.\n\t\t\t\t\t\t\t'\\[(?<prefix>.+?)\\]|'.\n\t\t\t\t\t\t\t'(?<lval>[^\\h\\r\\n;].*?)\\h*=\\h*'.\n\t\t\t\t\t\t\t'(?<rval>(?:\\\\\\\\\\h*\\r?\\n|.+?)*)'.\n\t\t\t\t\t\t')(?=\\r?\\n|$)/',\n\t\t\t\t\t\t$this->read($file),$matches,PREG_SET_ORDER);\n\t\t\t\t\tif ($matches) {\n\t\t\t\t\t\t$prefix='';\n\t\t\t\t\t\tforeach ($matches as $match)\n\t\t\t\t\t\t\tif ($match['prefix'])\n\t\t\t\t\t\t\t\t$prefix=$match['prefix'].'.';\n\t\t\t\t\t\t\telseif (!array_key_exists(\n\t\t\t\t\t\t\t\t$key=$prefix.$match['lval'],$lex))\n\t\t\t\t\t\t\t\t$lex[$key]=trim(preg_replace(\n\t\t\t\t\t\t\t\t\t'/\\\\\\\\\\h*\\r?\\n/',\"\\n\",$match['rval']));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tif ($ttl)\n\t\t\t$cache->set($hash,$lex,$ttl);\n\t\treturn $lex;\n\t}\n\n\t/**\n\t*\tReturn string representation of PHP value\n\t*\t@return string\n\t*\t@param $arg mixed\n\t**/\n\tfunction serialize($arg) {\n\t\tswitch (strtolower($this->hive['SERIALIZER'])) {\n\t\t\tcase 'igbinary':\n\t\t\t\treturn igbinary_serialize($arg);\n\t\t\tdefault:\n\t\t\t\treturn serialize($arg);\n\t\t}\n\t}\n\n\t/**\n\t*\tReturn PHP value derived from string\n\t*\t@return string\n\t*\t@param $arg mixed\n\t**/\n\tfunction unserialize($arg) {\n\t\tswitch (strtolower($this->hive['SERIALIZER'])) {\n\t\t\tcase 'igbinary':\n\t\t\t\treturn igbinary_unserialize($arg);\n\t\t\tdefault:\n\t\t\t\treturn unserialize($arg);\n\t\t}\n\t}\n\n\t/**\n\t*\tSend HTTP status header; Return text equivalent of status code\n\t*\t@return string\n\t*\t@param $code int\n\t**/\n\tfunction status($code) {\n\t\t$reason=@constant('self::HTTP_'.$code);\n\t\tif (!$this->hive['CLI'] && !headers_sent())\n\t\t\theader($_SERVER['SERVER_PROTOCOL'].' '.$code.' '.$reason);\n\t\treturn $reason;\n\t}\n\n\t/**\n\t*\tSend cache metadata to HTTP client\n\t*\t@param $secs int\n\t**/\n\tfunction expire($secs=0) {\n\t\tif (!$this->hive['CLI'] && !headers_sent()) {\n\t\t\t$secs=(int)$secs;\n\t\t\tif ($this->hive['PACKAGE'])\n\t\t\t\theader('X-Powered-By: '.$this->hive['PACKAGE']);\n\t\t\tif ($this->hive['XFRAME'])\n\t\t\t\theader('X-Frame-Options: '.$this->hive['XFRAME']);\n\t\t\theader('X-XSS-Protection: 1; mode=block');\n\t\t\theader('X-Content-Type-Options: nosniff');\n\t\t\tif ($this->hive['VERB']=='GET' && $secs) {\n\t\t\t\t$time=microtime(TRUE);\n\t\t\t\theader_remove('Pragma');\n\t\t\t\theader('Cache-Control: max-age='.$secs);\n\t\t\t\theader('Expires: '.gmdate('r',$time+$secs));\n\t\t\t\theader('Last-Modified: '.gmdate('r'));\n\t\t\t}\n\t\t\telse {\n\t\t\t\theader('Pragma: no-cache');\n\t\t\t\theader('Cache-Control: no-cache, no-store, must-revalidate');\n\t\t\t\theader('Expires: '.gmdate('r',0));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t*\tReturn HTTP user agent\n\t*\t@return string\n\t**/\n\tfunction agent() {\n\t\t$headers=$this->hive['HEADERS'];\n\t\treturn isset($headers['X-Operamini-Phone-UA'])?\n\t\t\t$headers['X-Operamini-Phone-UA']:\n\t\t\t(isset($headers['X-Skyfire-Phone'])?\n\t\t\t\t$headers['X-Skyfire-Phone']:\n\t\t\t\t(isset($headers['User-Agent'])?\n\t\t\t\t\t$headers['User-Agent']:''));\n\t}\n\n\t/**\n\t*\tReturn TRUE if XMLHttpRequest detected\n\t*\t@return bool\n\t**/\n\tfunction ajax() {\n\t\t$headers=$this->hive['HEADERS'];\n\t\treturn isset($headers['X-Requested-With']) &&\n\t\t\t$headers['X-Requested-With']=='XMLHttpRequest';\n\t}\n\n\t/**\n\t*\tSniff IP address\n\t*\t@return string\n\t**/\n\tfunction ip() {\n\t\t$headers=$this->hive['HEADERS'];\n\t\treturn isset($headers['Client-IP'])?\n\t\t\t$headers['Client-IP']:\n\t\t\t(isset($headers['X-Forwarded-For'])?\n\t\t\t\texplode(',',$headers['X-Forwarded-For'])[0]:\n\t\t\t\t(isset($_SERVER['REMOTE_ADDR'])?\n\t\t\t\t\t$_SERVER['REMOTE_ADDR']:''));\n\t}\n\n\t/**\n\t*\tReturn filtered stack trace as a formatted string (or array)\n\t*\t@return string|array\n\t*\t@param $trace array|NULL\n\t*\t@param $format bool\n\t**/\n\tfunction trace(array $trace=NULL,$format=TRUE) {\n\t\tif (!$trace) {\n\t\t\t$trace=debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS);\n\t\t\t$frame=$trace[0];\n\t\t\tif (isset($frame['file']) && $frame['file']==__FILE__)\n\t\t\t\tarray_shift($trace);\n\t\t}\n\t\t$debug=$this->hive['DEBUG'];\n\t\t$trace=array_filter(\n\t\t\t$trace,\n\t\t\tfunction($frame) use($debug) {\n\t\t\t\treturn isset($frame['file']) &&\n\t\t\t\t\t($debug>1 ||\n\t\t\t\t\t($frame['file']!=__FILE__ || $debug) &&\n\t\t\t\t\t(empty($frame['function']) ||\n\t\t\t\t\t!preg_match('/^(?:(?:trigger|user)_error|'.\n\t\t\t\t\t\t'__call|call_user_func)/',$frame['function'])));\n\t\t\t}\n\t\t);\n\t\tif (!$format)\n\t\t\treturn $trace;\n\t\t$out='';\n\t\t$eol=\"\\n\";\n\t\t// Analyze stack trace\n\t\tforeach ($trace as $frame) {\n\t\t\t$line='';\n\t\t\tif (isset($frame['class']))\n\t\t\t\t$line.=$frame['class'].$frame['type'];\n\t\t\tif (isset($frame['function']))\n\t\t\t\t$line.=$frame['function'].'('.\n\t\t\t\t\t($debug>2 && isset($frame['args'])?\n\t\t\t\t\t\t$this->csv($frame['args']):'').')';\n\t\t\t$src=$this->fixslashes(str_replace($_SERVER['DOCUMENT_ROOT'].\n\t\t\t\t'/','',$frame['file'])).':'.$frame['line'];\n\t\t\t$out.='['.$src.'] '.$line.$eol;\n\t\t}\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tLog error; Execute ONERROR handler if defined, else display\n\t*\tdefault error page (HTML for synchronous requests, JSON string\n\t*\tfor AJAX requests)\n\t*\t@param $code int\n\t*\t@param $text string\n\t*\t@param $trace array\n\t*\t@param $level int\n\t**/\n\tfunction error($code,$text='',array $trace=NULL,$level=0) {\n\t\t$prior=$this->hive['ERROR'];\n\t\t$header=$this->status($code);\n\t\t$req=$this->hive['VERB'].' '.$this->hive['PATH'];\n\t\tif ($this->hive['QUERY'])\n\t\t\t$req.='?'.$this->hive['QUERY'];\n\t\tif (!$text)\n\t\t\t$text='HTTP '.$code.' ('.$req.')';\n\t\t$trace=$this->trace($trace);\n\t\t$loggable=$this->hive['LOGGABLE'];\n\t\tif (!is_array($loggable))\n\t\t\t$loggable=$this->split($loggable);\n\t\tforeach ($loggable as $status)\n\t\t\tif ($status=='*' ||\n\t\t\t\tpreg_match('/^'.preg_replace('/\\D/','\\d',$status).'$/',$code)) {\n\t\t\t\terror_log($text);\n\t\t\t\tforeach (explode(\"\\n\",$trace) as $nexus)\n\t\t\t\t\tif ($nexus)\n\t\t\t\t\t\terror_log($nexus);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif ($highlight=!$this->hive['CLI'] && !$this->hive['AJAX'] &&\n\t\t\t$this->hive['HIGHLIGHT'] && is_file($css=__DIR__.'/'.self::CSS))\n\t\t\t$trace=$this->highlight($trace);\n\t\t$this->hive['ERROR']=[\n\t\t\t'status'=>$header,\n\t\t\t'code'=>$code,\n\t\t\t'text'=>$text,\n\t\t\t'trace'=>$trace,\n\t\t\t'level'=>$level\n\t\t];\n\t\t$this->expire(-1);\n\t\t$handler=$this->hive['ONERROR'];\n\t\t$this->hive['ONERROR']=NULL;\n\t\t$eol=\"\\n\";\n\t\tif ((!$handler ||\n\t\t\t$this->call($handler,[$this,$this->hive['PARAMS']],\n\t\t\t\t'beforeroute,afterroute')===FALSE) &&\n\t\t\t!$prior && !$this->hive['CLI'] && !$this->hive['QUIET'])\n\t\t\techo $this->hive['AJAX']?\n\t\t\t\tjson_encode(\n\t\t\t\t\tarray_diff_key(\n\t\t\t\t\t\t$this->hive['ERROR'],\n\t\t\t\t\t\t$this->hive['DEBUG']?\n\t\t\t\t\t\t\t[]:\n\t\t\t\t\t\t\t['trace'=>1]\n\t\t\t\t\t)\n\t\t\t\t):\n\t\t\t\t('<!DOCTYPE html>'.$eol.\n\t\t\t\t'<html>'.$eol.\n\t\t\t\t'<head>'.\n\t\t\t\t\t'<title>'.$code.' '.$header.'</title>'.\n\t\t\t\t\t($highlight?\n\t\t\t\t\t\t('<style>'.$this->read($css).'</style>'):'').\n\t\t\t\t'</head>'.$eol.\n\t\t\t\t'<body>'.$eol.\n\t\t\t\t\t'<h1>'.$header.'</h1>'.$eol.\n\t\t\t\t\t'<p>'.$this->encode($text?:$req).'</p>'.$eol.\n\t\t\t\t\t($this->hive['DEBUG']?('<pre>'.$trace.'</pre>'.$eol):'').\n\t\t\t\t'</body>'.$eol.\n\t\t\t\t'</html>');\n\t\tif ($this->hive['HALT'])\n\t\t\tdie(1);\n\t}\n\n\t/**\n\t*\tMock HTTP request\n\t*\t@return mixed\n\t*\t@param $pattern string\n\t*\t@param $args array\n\t*\t@param $headers array\n\t*\t@param $body string\n\t**/\n\tfunction mock($pattern,\n\t\tarray $args=NULL,array $headers=NULL,$body=NULL) {\n\t\tif (!$args)\n\t\t\t$args=[];\n\t\t$types=['sync','ajax','cli'];\n\t\tpreg_match('/([\\|\\w]+)\\h+(?:@(\\w+)(?:(\\(.+?)\\))*|([^\\h]+))'.\n\t\t\t'(?:\\h+\\[('.implode('|',$types).')\\])?/',$pattern,$parts);\n\t\t$verb=strtoupper($parts[1]);\n\t\tif ($parts[2]) {\n\t\t\tif (empty($this->hive['ALIASES'][$parts[2]]))\n\t\t\t\tuser_error(sprintf(self::E_Named,$parts[2]),E_USER_ERROR);\n\t\t\t$parts[4]=$this->hive['ALIASES'][$parts[2]];\n\t\t\t$parts[4]=$this->build($parts[4],\n\t\t\t\tisset($parts[3])?$this->parse($parts[3]):[]);\n\t\t}\n\t\tif (empty($parts[4]))\n\t\t\tuser_error(sprintf(self::E_Pattern,$pattern),E_USER_ERROR);\n\t\t$url=parse_url($parts[4]);\n\t\tparse_str(@$url['query'],$GLOBALS['_GET']);\n\t\tif (preg_match('/GET|HEAD/',$verb))\n\t\t\t$GLOBALS['_GET']=array_merge($GLOBALS['_GET'],$args);\n\t\t$GLOBALS['_POST']=$verb=='POST'?$args:[];\n\t\t$GLOBALS['_REQUEST']=array_merge($GLOBALS['_GET'],$GLOBALS['_POST']);\n\t\tforeach ($headers?:[] as $key=>$val)\n\t\t\t$_SERVER['HTTP_'.strtr(strtoupper($key),'-','_')]=$val;\n\t\t$this->hive['VERB']=$verb;\n\t\t$this->hive['PATH']=$url['path'];\n\t\t$this->hive['URI']=$this->hive['BASE'].$url['path'];\n\t\tif ($GLOBALS['_GET'])\n\t\t\t$this->hive['URI'].='?'.http_build_query($GLOBALS['_GET']);\n\t\t$this->hive['BODY']='';\n\t\tif (!preg_match('/GET|HEAD/',$verb))\n\t\t\t$this->hive['BODY']=$body?:http_build_query($args);\n\t\t$this->hive['AJAX']=isset($parts[5]) &&\n\t\t\tpreg_match('/ajax/i',$parts[5]);\n\t\t$this->hive['CLI']=isset($parts[5]) &&\n\t\t\tpreg_match('/cli/i',$parts[5]);\n\t\treturn $this->run();\n\t}\n\n\t/**\n\t*\tAssemble url from alias name\n\t*\t@return string\n\t*\t@param $name string\n\t*\t@param $params array|string\n\t*\t@param $query string|array\n\t*\t@param $fragment string\n\t**/\n\tfunction alias($name,$params=[],$query=NULL,$fragment=NULL) {\n\t\tif (!is_array($params))\n\t\t\t$params=$this->parse($params);\n\t\tif (empty($this->hive['ALIASES'][$name]))\n\t\t\tuser_error(sprintf(self::E_Named,$name),E_USER_ERROR);\n\t\t$url=$this->build($this->hive['ALIASES'][$name],$params);\n\t\tif (is_array($query))\n\t\t\t$query=http_build_query($query);\n\t\treturn $url.($query?('?'.$query):'').($fragment?'#'.$fragment:'');\n\t}\n\n\t/**\n\t*\tBind handler to route pattern\n\t*\t@return NULL\n\t*\t@param $pattern string|array\n\t*\t@param $handler callback\n\t*\t@param $ttl int\n\t*\t@param $kbps int\n\t**/\n\tfunction route($pattern,$handler,$ttl=0,$kbps=0) {\n\t\t$types=['sync','ajax','cli'];\n\t\t$alias=null;\n\t\tif (is_array($pattern)) {\n\t\t\tforeach ($pattern as $item)\n\t\t\t\t$this->route($item,$handler,$ttl,$kbps);\n\t\t\treturn;\n\t\t}\n\t\tpreg_match('/([\\|\\w]+)\\h+(?:(?:@?(.+?)\\h*:\\h*)?(@(\\w+)|[^\\h]+))'.\n\t\t\t'(?:\\h+\\[('.implode('|',$types).')\\])?/u',$pattern,$parts);\n\t\tif (isset($parts[2]) && $parts[2]) {\n\t\t\tif (!preg_match('/^\\w+$/',$parts[2]))\n\t\t\t\tuser_error(sprintf(self::E_Alias,$parts[2]),E_USER_ERROR);\n\t\t\t$this->hive['ALIASES'][$alias=$parts[2]]=$parts[3];\n\t\t}\n\t\telseif (!empty($parts[4])) {\n\t\t\tif (empty($this->hive['ALIASES'][$parts[4]]))\n\t\t\t\tuser_error(sprintf(self::E_Named,$parts[4]),E_USER_ERROR);\n\t\t\t$parts[3]=$this->hive['ALIASES'][$alias=$parts[4]];\n\t\t}\n\t\tif (empty($parts[3]))\n\t\t\tuser_error(sprintf(self::E_Pattern,$pattern),E_USER_ERROR);\n\t\t$type=empty($parts[5])?0:constant('self::REQ_'.strtoupper($parts[5]));\n\t\tforeach ($this->split($parts[1]) as $verb) {\n\t\t\tif (!preg_match('/'.self::VERBS.'/',$verb))\n\t\t\t\t$this->error(501,$verb.' '.$this->hive['URI']);\n\t\t\t$this->hive['ROUTES'][$parts[3]][$type][strtoupper($verb)]=\n\t\t\t\t[$handler,$ttl,$kbps,$alias];\n\t\t}\n\t}\n\n\t/**\n\t*\tReroute to specified URI\n\t*\t@return NULL\n\t*\t@param $url array|string\n\t*\t@param $permanent bool\n\t*\t@param $die bool\n\t**/\n\tfunction reroute($url=NULL,$permanent=FALSE,$die=TRUE) {\n\t\tif (!$url)\n\t\t\t$url=$this->hive['REALM'];\n\t\tif (is_array($url))\n\t\t\t$url=call_user_func_array([$this,'alias'],$url);\n\t\telseif (preg_match('/^(?:@([^\\/()?#]+)(?:\\((.+?)\\))*(\\?[^#]+)*(#.+)*)/',\n\t\t\t$url,$parts) && isset($this->hive['ALIASES'][$parts[1]]))\n\t\t\t$url=$this->build($this->hive['ALIASES'][$parts[1]],\n\t\t\t\t\tisset($parts[2])?$this->parse($parts[2]):[]).\n\t\t\t\t(isset($parts[3])?$parts[3]:'').(isset($parts[4])?$parts[4]:'');\n\t\tif (($handler=$this->hive['ONREROUTE']) &&\n\t\t\t$this->call($handler,[$url,$permanent,$die])!==FALSE)\n\t\t\treturn;\n\t\tif ($url[0]!='/' && !preg_match('/^\\w+:\\/\\//i',$url))\n\t\t\t$url='/'.$url;\n\t\tif ($url[0]=='/' && (empty($url[1]) || $url[1]!='/')) {\n\t\t\t$port=$this->hive['PORT'];\n\t\t\t$port=in_array($port,[80,443])?'':(':'.$port);\n\t\t\t$url=$this->hive['SCHEME'].'://'.\n\t\t\t\t$this->hive['HOST'].$port.$this->hive['BASE'].$url;\n\t\t}\n\t\tif ($this->hive['CLI'])\n\t\t\t$this->mock('GET '.$url.' [cli]');\n\t\telse {\n\t\t\theader('Location: '.$url);\n\t\t\t$this->status($permanent?301:302);\n\t\t\tif ($die)\n\t\t\t\tdie;\n\t\t}\n\t}\n\n\t/**\n\t*\tProvide ReST interface by mapping HTTP verb to class method\n\t*\t@return NULL\n\t*\t@param $url string\n\t*\t@param $class string|object\n\t*\t@param $ttl int\n\t*\t@param $kbps int\n\t**/\n\tfunction map($url,$class,$ttl=0,$kbps=0) {\n\t\tif (is_array($url)) {\n\t\t\tforeach ($url as $item)\n\t\t\t\t$this->map($item,$class,$ttl,$kbps);\n\t\t\treturn;\n\t\t}\n\t\tforeach (explode('|',self::VERBS) as $method)\n\t\t\t$this->route($method.' '.$url,is_string($class)?\n\t\t\t\t$class.'->'.$this->hive['PREMAP'].strtolower($method):\n\t\t\t\t[$class,$this->hive['PREMAP'].strtolower($method)],\n\t\t\t\t$ttl,$kbps);\n\t}\n\n\t/**\n\t*\tRedirect a route to another URL\n\t*\t@return NULL\n\t*\t@param $pattern string|array\n\t*\t@param $url string\n\t*\t@param $permanent bool\n\t*/\n\tfunction redirect($pattern,$url,$permanent=TRUE) {\n\t\tif (is_array($pattern)) {\n\t\t\tforeach ($pattern as $item)\n\t\t\t\t$this->redirect($item,$url,$permanent);\n\t\t\treturn;\n\t\t}\n\t\t$this->route($pattern,function($fw) use($url,$permanent) {\n\t\t\t$fw->reroute($url,$permanent);\n\t\t});\n\t}\n\n\t/**\n\t*\tReturn TRUE if IPv4 address exists in DNSBL\n\t*\t@return bool\n\t*\t@param $ip string\n\t**/\n\tfunction blacklisted($ip) {\n\t\tif ($this->hive['DNSBL'] &&\n\t\t\t!in_array($ip,\n\t\t\t\tis_array($this->hive['EXEMPT'])?\n\t\t\t\t\t$this->hive['EXEMPT']:\n\t\t\t\t\t$this->split($this->hive['EXEMPT']))) {\n\t\t\t// Reverse IPv4 dotted quad\n\t\t\t$rev=implode('.',array_reverse(explode('.',$ip)));\n\t\t\tforeach (is_array($this->hive['DNSBL'])?\n\t\t\t\t$this->hive['DNSBL']:\n\t\t\t\t$this->split($this->hive['DNSBL']) as $server)\n\t\t\t\t// DNSBL lookup\n\t\t\t\tif (checkdnsrr($rev.'.'.$server,'A'))\n\t\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tApplies the specified URL mask and returns parameterized matches\n\t*\t@return $args array\n\t*\t@param $pattern string\n\t*\t@param $url string|NULL\n\t**/\n\tfunction mask($pattern,$url=NULL) {\n\t\tif (!$url)\n\t\t\t$url=$this->rel($this->hive['URI']);\n\t\t$case=$this->hive['CASELESS']?'i':'';\n\t\t$wild=preg_quote($pattern,'/');\n\t\t$i=0;\n\t\twhile (is_int($pos=strpos($wild,'\\*'))) {\n\t\t\t$wild=substr_replace($wild,'(?P<_'.$i.'>[^\\?]*)',$pos,2);\n\t\t\t$i++;\n\t\t}\n\t\tpreg_match('/^'.\n\t\t\tpreg_replace(\n\t\t\t\t'/((\\\\\\{)?@(\\w+\\b)(?(2)\\\\\\}))/',\n\t\t\t\t'(?P<\\3>[^\\/\\?]+)',\n\t\t\t\t$wild).'\\/?$/'.$case.'um',$url,$args);\n\t\tforeach (array_keys($args) as $key) {\n\t\t\tif (preg_match('/^_\\d+$/',$key)) {\n\t\t\t\tif (empty($args['*']))\n\t\t\t\t\t$args['*']=$args[$key];\n\t\t\t\telse {\n\t\t\t\t\tif (is_string($args['*']))\n\t\t\t\t\t\t$args['*']=[$args['*']];\n\t\t\t\t\tarray_push($args['*'],$args[$key]);\n\t\t\t\t}\n\t\t\t\tunset($args[$key]);\n\t\t\t}\n\t\t\telseif (is_numeric($key) && $key)\n\t\t\t\tunset($args[$key]);\n\t\t}\n\t\treturn $args;\n\t}\n\n\t/**\n\t*\tMatch routes against incoming URI\n\t*\t@return mixed\n\t**/\n\tfunction run() {\n\t\tif ($this->blacklisted($this->hive['IP']))\n\t\t\t// Spammer detected\n\t\t\t$this->error(403);\n\t\tif (!$this->hive['ROUTES'])\n\t\t\t// No routes defined\n\t\t\tuser_error(self::E_Routes,E_USER_ERROR);\n\t\t// Match specific routes first\n\t\t$paths=[];\n\t\tforeach ($keys=array_keys($this->hive['ROUTES']) as $key) {\n\t\t\t$path=preg_replace('/@\\w+/','*@',$key);\n\t\t\tif (substr($path,-1)!='*')\n\t\t\t\t$path.='+';\n\t\t\t$paths[]=$path;\n\t\t}\n\t\t$vals=array_values($this->hive['ROUTES']);\n\t\tarray_multisort($paths,SORT_DESC,$keys,$vals);\n\t\t$this->hive['ROUTES']=array_combine($keys,$vals);\n\t\t// Convert to BASE-relative URL\n\t\t$req=urldecode($this->hive['PATH']);\n\t\t$preflight=FALSE;\n\t\tif ($cors=(isset($this->hive['HEADERS']['Origin']) &&\n\t\t\t$this->hive['CORS']['origin'])) {\n\t\t\t$cors=$this->hive['CORS'];\n\t\t\theader('Access-Control-Allow-Origin: '.$cors['origin']);\n\t\t\theader('Access-Control-Allow-Credentials: '.\n\t\t\t\t$this->export($cors['credentials']));\n\t\t\t$preflight=\n\t\t\t\tisset($this->hive['HEADERS']['Access-Control-Request-Method']);\n\t\t}\n\t\t$allowed=[];\n\t\tforeach ($this->hive['ROUTES'] as $pattern=>$routes) {\n\t\t\tif (!$args=$this->mask($pattern,$req))\n\t\t\t\tcontinue;\n\t\t\tksort($args);\n\t\t\t$route=NULL;\n\t\t\t$ptr=$this->hive['CLI']?self::REQ_CLI:$this->hive['AJAX']+1;\n\t\t\tif (isset($routes[$ptr][$this->hive['VERB']]) ||\n\t\t\t\tisset($routes[$ptr=0]))\n\t\t\t\t$route=$routes[$ptr];\n\t\t\tif (!$route)\n\t\t\t\tcontinue;\n\t\t\tif (isset($route[$this->hive['VERB']]) && !$preflight) {\n\t\t\t\tif ($this->hive['VERB']=='GET' &&\n\t\t\t\t\tpreg_match('/.+\\/$/',$this->hive['PATH']))\n\t\t\t\t\t$this->reroute(substr($this->hive['PATH'],0,-1).\n\t\t\t\t\t\t($this->hive['QUERY']?('?'.$this->hive['QUERY']):''));\n\t\t\t\tlist($handler,$ttl,$kbps,$alias)=$route[$this->hive['VERB']];\n\t\t\t\t// Capture values of route pattern tokens\n\t\t\t\t$this->hive['PARAMS']=$args;\n\t\t\t\t// Save matching route\n\t\t\t\t$this->hive['ALIAS']=$alias;\n\t\t\t\t$this->hive['PATTERN']=$pattern;\n\t\t\t\tif ($cors && $cors['expose'])\n\t\t\t\t\theader('Access-Control-Expose-Headers: '.\n\t\t\t\t\t\t(is_array($cors['expose'])?\n\t\t\t\t\t\t\timplode(',',$cors['expose']):$cors['expose']));\n\t\t\t\tif (is_string($handler)) {\n\t\t\t\t\t// Replace route pattern tokens in handler if any\n\t\t\t\t\t$handler=preg_replace_callback('/({)?@(\\w+\\b)(?(1)})/',\n\t\t\t\t\t\tfunction($id) use($args) {\n\t\t\t\t\t\t\t$pid=count($id)>2?2:1;\n\t\t\t\t\t\t\treturn isset($args[$id[$pid]])?\n\t\t\t\t\t\t\t\t$args[$id[$pid]]:\n\t\t\t\t\t\t\t\t$id[0];\n\t\t\t\t\t\t},\n\t\t\t\t\t\t$handler\n\t\t\t\t\t);\n\t\t\t\t\tif (preg_match('/(.+)\\h*(?:->|::)/',$handler,$match) &&\n\t\t\t\t\t\t!class_exists($match[1]))\n\t\t\t\t\t\t$this->error(404);\n\t\t\t\t}\n\t\t\t\t// Process request\n\t\t\t\t$result=NULL;\n\t\t\t\t$body='';\n\t\t\t\t$now=microtime(TRUE);\n\t\t\t\tif (preg_match('/GET|HEAD/',$this->hive['VERB']) && $ttl) {\n\t\t\t\t\t// Only GET and HEAD requests are cacheable\n\t\t\t\t\t$headers=$this->hive['HEADERS'];\n\t\t\t\t\t$cache=Cache::instance();\n\t\t\t\t\t$cached=$cache->exists(\n\t\t\t\t\t\t$hash=$this->hash($this->hive['VERB'].' '.\n\t\t\t\t\t\t\t$this->hive['URI']).'.url',$data);\n\t\t\t\t\tif ($cached) {\n\t\t\t\t\t\tif (isset($headers['If-Modified-Since']) &&\n\t\t\t\t\t\t\tstrtotime($headers['If-Modified-Since'])+\n\t\t\t\t\t\t\t\t$ttl>$now) {\n\t\t\t\t\t\t\t$this->status(304);\n\t\t\t\t\t\t\tdie;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Retrieve from cache backend\n\t\t\t\t\t\tlist($headers,$body,$result)=$data;\n\t\t\t\t\t\tif (!$this->hive['CLI'])\n\t\t\t\t\t\t\tarray_walk($headers,'header');\n\t\t\t\t\t\t$this->expire($cached[0]+$ttl-$now);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t// Expire HTTP client-cached page\n\t\t\t\t\t\t$this->expire($ttl);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t$this->expire(0);\n\t\t\t\tif (!strlen($body)) {\n\t\t\t\t\tif (!$this->hive['RAW'] && !$this->hive['BODY'])\n\t\t\t\t\t\t$this->hive['BODY']=file_get_contents('php://input');\n\t\t\t\t\tob_start();\n\t\t\t\t\t// Call route handler\n\t\t\t\t\t$result=$this->call($handler,[$this,$args,$handler],\n\t\t\t\t\t\t'beforeroute,afterroute');\n\t\t\t\t\t$body=ob_get_clean();\n\t\t\t\t\tif (isset($cache) && !error_get_last()) {\n\t\t\t\t\t\t// Save to cache backend\n\t\t\t\t\t\t$cache->set($hash,[\n\t\t\t\t\t\t\t// Remove cookies\n\t\t\t\t\t\t\tpreg_grep('/Set-Cookie\\:/',headers_list(),\n\t\t\t\t\t\t\t\tPREG_GREP_INVERT),$body,$result],$ttl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$this->hive['RESPONSE']=$body;\n\t\t\t\tif (!$this->hive['QUIET']) {\n\t\t\t\t\tif ($kbps) {\n\t\t\t\t\t\t$ctr=0;\n\t\t\t\t\t\tforeach (str_split($body,1024) as $part) {\n\t\t\t\t\t\t\t// Throttle output\n\t\t\t\t\t\t\t$ctr++;\n\t\t\t\t\t\t\tif ($ctr/$kbps>($elapsed=microtime(TRUE)-$now) &&\n\t\t\t\t\t\t\t\t!connection_aborted())\n\t\t\t\t\t\t\t\tusleep(1e6*($ctr/$kbps-$elapsed));\n\t\t\t\t\t\t\techo $part;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\techo $body;\n\t\t\t\t}\n\t\t\t\tif ($result || $this->hive['VERB']!='OPTIONS')\n\t\t\t\t\treturn $result;\n\t\t\t}\n\t\t\t$allowed=array_merge($allowed,array_keys($route));\n\t\t}\n\t\tif (!$allowed)\n\t\t\t// URL doesn't match any route\n\t\t\t$this->error(404);\n\t\telseif (!$this->hive['CLI']) {\n\t\t\tif (!preg_grep('/Allow:/',$headers_send=headers_list()))\n\t\t\t\t// Unhandled HTTP method\n\t\t\t\theader('Allow: '.implode(',',array_unique($allowed)));\n\t\t\tif ($cors) {\n\t\t\t\tif (!preg_grep('/Access-Control-Allow-Methods:/',$headers_send))\n\t\t\t\t\theader('Access-Control-Allow-Methods: OPTIONS,'.\n\t\t\t\t\t\timplode(',',$allowed));\n\t\t\t\tif ($cors['headers'] &&\n\t\t\t\t\t!preg_grep('/Access-Control-Allow-Headers:/',$headers_send))\n\t\t\t\t\theader('Access-Control-Allow-Headers: '.\n\t\t\t\t\t\t(is_array($cors['headers'])?\n\t\t\t\t\t\t\timplode(',',$cors['headers']):\n\t\t\t\t\t\t\t$cors['headers']));\n\t\t\t\tif ($cors['ttl']>0)\n\t\t\t\t\theader('Access-Control-Max-Age: '.$cors['ttl']);\n\t\t\t}\n\t\t\tif ($this->hive['VERB']!='OPTIONS')\n\t\t\t\t$this->error(405);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tLoop until callback returns TRUE (for long polling)\n\t*\t@return mixed\n\t*\t@param $func callback\n\t*\t@param $args array\n\t*\t@param $timeout int\n\t**/\n\tfunction until($func,$args=NULL,$timeout=60) {\n\t\tif (!$args)\n\t\t\t$args=[];\n\t\t$time=time();\n\t\t$max=ini_get('max_execution_time');\n\t\t$limit=max(0,($max?min($timeout,$max):$timeout)-1);\n\t\t$out='';\n\t\t// Turn output buffering on\n\t\tob_start();\n\t\t// Not for the weak of heart\n\t\twhile (\n\t\t\t// No error occurred\n\t\t\t!$this->hive['ERROR'] &&\n\t\t\t// Got time left?\n\t\t\ttime()-$time+1<$limit &&\n\t\t\t// Still alive?\n\t\t\t!connection_aborted() &&\n\t\t\t// Restart session\n\t\t\t!headers_sent() &&\n\t\t\t(session_status()==PHP_SESSION_ACTIVE || session_start()) &&\n\t\t\t// CAUTION: Callback will kill host if it never becomes truthy!\n\t\t\t!$out=$this->call($func,$args)) {\n\t\t\tif (!$this->hive['CLI'])\n\t\t\t\tsession_commit();\n\t\t\t// Hush down\n\t\t\tsleep(1);\n\t\t}\n\t\tob_flush();\n\t\tflush();\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tDisconnect HTTP client;\n\t*\tSet FcgidOutputBufferSize to zero if server uses mod_fcgid;\n\t*\tDisable mod_deflate when rendering text/html output\n\t**/\n\tfunction abort() {\n\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\tsession_start();\n\t\t$out='';\n\t\twhile (ob_get_level())\n\t\t\t$out=ob_get_clean().$out;\n\t\tif (!headers_sent()) {\n\t\t\theader('Content-Length: '.strlen($out));\n\t\t\theader('Connection: close');\n\t\t}\n\t\tsession_commit();\n\t\techo $out;\n\t\tflush();\n\t\tif (function_exists('fastcgi_finish_request'))\n\t\t\tfastcgi_finish_request();\n\t}\n\n\t/**\n\t*\tGrab the real route handler behind the string expression\n\t*\t@return string|array\n\t*\t@param $func string\n\t*\t@param $args array\n\t**/\n\tfunction grab($func,$args=NULL) {\n\t\tif (preg_match('/(.+)\\h*(->|::)\\h*(.+)/s',$func,$parts)) {\n\t\t\t// Convert string to executable PHP callback\n\t\t\tif (!class_exists($parts[1]))\n\t\t\t\tuser_error(sprintf(self::E_Class,$parts[1]),E_USER_ERROR);\n\t\t\tif ($parts[2]=='->') {\n\t\t\t\tif (is_subclass_of($parts[1],'Prefab'))\n\t\t\t\t\t$parts[1]=call_user_func($parts[1].'::instance');\n\t\t\t\telseif ($container=$this->get('CONTAINER')) {\n\t\t\t\t\tif (is_object($container) && is_callable([$container,'has'])\n\t\t\t\t\t\t&& $container->has($parts[1])) // PSR11\n\t\t\t\t\t\t$parts[1]=call_user_func([$container,'get'],$parts[1]);\n\t\t\t\t\telseif (is_callable($container))\n\t\t\t\t\t\t$parts[1]=call_user_func($container,$parts[1],$args);\n\t\t\t\t\telseif (is_string($container) &&\n\t\t\t\t\t\tis_subclass_of($container,'Prefab'))\n\t\t\t\t\t\t$parts[1]=call_user_func($container.'::instance')->\n\t\t\t\t\t\t\tget($parts[1]);\n\t\t\t\t\telse\n\t\t\t\t\t\tuser_error(sprintf(self::E_Class,\n\t\t\t\t\t\t\t$this->stringify($parts[1])),\n\t\t\t\t\t\t\tE_USER_ERROR);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$ref=new ReflectionClass($parts[1]);\n\t\t\t\t\t$parts[1]=method_exists($parts[1],'__construct') && $args?\n\t\t\t\t\t\t$ref->newinstanceargs($args):\n\t\t\t\t\t\t$ref->newinstance();\n\t\t\t\t}\n\t\t\t}\n\t\t\t$func=[$parts[1],$parts[3]];\n\t\t}\n\t\treturn $func;\n\t}\n\n\t/**\n\t*\tExecute callback/hooks (supports 'class->method' format)\n\t*\t@return mixed|FALSE\n\t*\t@param $func callback\n\t*\t@param $args mixed\n\t*\t@param $hooks string\n\t**/\n\tfunction call($func,$args=NULL,$hooks='') {\n\t\tif (!is_array($args))\n\t\t\t$args=[$args];\n\t\t// Grab the real handler behind the string representation\n\t\tif (is_string($func))\n\t\t\t$func=$this->grab($func,$args);\n\t\t// Execute function; abort if callback/hook returns FALSE\n\t\tif (!is_callable($func))\n\t\t\t// No route handler\n\t\t\tif ($hooks=='beforeroute,afterroute') {\n\t\t\t\t$allowed=[];\n\t\t\t\tif (is_array($func))\n\t\t\t\t\t$allowed=array_intersect(\n\t\t\t\t\t\tarray_map('strtoupper',get_class_methods($func[0])),\n\t\t\t\t\t\texplode('|',self::VERBS)\n\t\t\t\t\t);\n\t\t\t\theader('Allow: '.implode(',',$allowed));\n\t\t\t\t$this->error(405);\n\t\t\t}\n\t\t\telse\n\t\t\t\tuser_error(sprintf(self::E_Method,\n\t\t\t\t\tis_string($func)?$func:$this->stringify($func)),\n\t\t\t\t\tE_USER_ERROR);\n\t\t$obj=FALSE;\n\t\tif (is_array($func)) {\n\t\t\t$hooks=$this->split($hooks);\n\t\t\t$obj=TRUE;\n\t\t}\n\t\t// Execute pre-route hook if any\n\t\tif ($obj && $hooks && in_array($hook='beforeroute',$hooks) &&\n\t\t\tmethod_exists($func[0],$hook) &&\n\t\t\tcall_user_func_array([$func[0],$hook],$args)===FALSE)\n\t\t\treturn FALSE;\n\t\t// Execute callback\n\t\t$out=call_user_func_array($func,$args?:[]);\n\t\tif ($out===FALSE)\n\t\t\treturn FALSE;\n\t\t// Execute post-route hook if any\n\t\tif ($obj && $hooks && in_array($hook='afterroute',$hooks) &&\n\t\t\tmethod_exists($func[0],$hook) &&\n\t\t\tcall_user_func_array([$func[0],$hook],$args)===FALSE)\n\t\t\treturn FALSE;\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tExecute specified callbacks in succession; Apply same arguments\n\t*\tto all callbacks\n\t*\t@return array\n\t*\t@param $funcs array|string\n\t*\t@param $args mixed\n\t**/\n\tfunction chain($funcs,$args=NULL) {\n\t\t$out=[];\n\t\tforeach (is_array($funcs)?$funcs:$this->split($funcs) as $func)\n\t\t\t$out[]=$this->call($func,$args);\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tExecute specified callbacks in succession; Relay result of\n\t*\tprevious callback as argument to the next callback\n\t*\t@return array\n\t*\t@param $funcs array|string\n\t*\t@param $args mixed\n\t**/\n\tfunction relay($funcs,$args=NULL) {\n\t\tforeach (is_array($funcs)?$funcs:$this->split($funcs) as $func)\n\t\t\t$args=[$this->call($func,$args)];\n\t\treturn array_shift($args);\n\t}\n\n\t/**\n\t*\tConfigure framework according to .ini-style file settings;\n\t*\tIf optional 2nd arg is provided, template strings are interpreted\n\t*\t@return object\n\t*\t@param $source string|array\n\t*\t@param $allow bool\n\t**/\n\tfunction config($source,$allow=FALSE) {\n\t\tif (is_string($source))\n\t\t\t$source=$this->split($source);\n\t\tif ($allow)\n\t\t\t$preview=Preview::instance();\n\t\tforeach ($source as $file) {\n\t\t\tpreg_match_all(\n\t\t\t\t'/(?<=^|\\n)(?:'.\n\t\t\t\t\t'\\[(?<section>.+?)\\]|'.\n\t\t\t\t\t'(?<lval>[^\\h\\r\\n;].*?)\\h*=\\h*'.\n\t\t\t\t\t'(?<rval>(?:\\\\\\\\\\h*\\r?\\n|.+?)*)'.\n\t\t\t\t')(?=\\r?\\n|$)/',\n\t\t\t\t$this->read($file),\n\t\t\t\t$matches,PREG_SET_ORDER);\n\t\t\tif ($matches) {\n\t\t\t\t$sec='globals';\n\t\t\t\t$cmd=[];\n\t\t\t\tforeach ($matches as $match) {\n\t\t\t\t\tif ($match['section']) {\n\t\t\t\t\t\t$sec=$match['section'];\n\t\t\t\t\t\tif (preg_match(\n\t\t\t\t\t\t\t'/^(?!(?:global|config|route|map|redirect)s\\b)'.\n\t\t\t\t\t\t\t'((?:[^:])+)/i',$sec,$msec) &&\n\t\t\t\t\t\t\t!$this->exists($msec[0]))\n\t\t\t\t\t\t\t$this->set($msec[0],NULL);\n\t\t\t\t\t\tpreg_match('/^(config|route|map|redirect)s\\b|'.\n\t\t\t\t\t\t\t'^((?:[^:])+)\\s*\\>\\s*(.*)/i',$sec,$cmd);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ($allow)\n\t\t\t\t\t\tforeach (['lval','rval'] as $ndx)\n\t\t\t\t\t\t\t$match[$ndx]=$preview->\n\t\t\t\t\t\t\t\tresolve($match[$ndx],NULL,0,FALSE,FALSE);\n\t\t\t\t\tif (!empty($cmd)) {\n\t\t\t\t\t\tisset($cmd[3])?\n\t\t\t\t\t\t$this->call($cmd[3],\n\t\t\t\t\t\t\t[$match['lval'],$match['rval'],$cmd[2]]):\n\t\t\t\t\t\tcall_user_func_array(\n\t\t\t\t\t\t\t[$this,$cmd[1]],\n\t\t\t\t\t\t\tarray_merge([$match['lval']],\n\t\t\t\t\t\t\t\tstr_getcsv($cmd[1]=='config'?\n\t\t\t\t\t\t\t\t$this->cast($match['rval']):\n\t\t\t\t\t\t\t\t\t$match['rval']))\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t$rval=preg_replace(\n\t\t\t\t\t\t\t'/\\\\\\\\\\h*(\\r?\\n)/','\\1',$match['rval']);\n\t\t\t\t\t\t$ttl=NULL;\n\t\t\t\t\t\tif (preg_match('/^(.+)\\|\\h*(\\d+)$/',$rval,$tmp)) {\n\t\t\t\t\t\t\tarray_shift($tmp);\n\t\t\t\t\t\t\tlist($rval,$ttl)=$tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$args=array_map(\n\t\t\t\t\t\t\tfunction($val) {\n\t\t\t\t\t\t\t\t$val=$this->cast($val);\n\t\t\t\t\t\t\t\tif (is_string($val))\n\t\t\t\t\t\t\t\t\t$val=strlen($val)?\n\t\t\t\t\t\t\t\t\t\tpreg_replace('/\\\\\\\\\"/','\"',$val):\n\t\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t\t\t\t\treturn $val;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t// Mark quoted strings with 0x00 whitespace\n\t\t\t\t\t\t\tstr_getcsv(preg_replace(\n\t\t\t\t\t\t\t\t'/(?<!\\\\\\\\)(\")(.*?)\\1/',\n\t\t\t\t\t\t\t\t\"\\\\1\\x00\\\\2\\\\1\",trim($rval)))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tpreg_match('/^(?<section>[^:]+)(?:\\:(?<func>.+))?/',\n\t\t\t\t\t\t\t$sec,$parts);\n\t\t\t\t\t\t$func=isset($parts['func'])?$parts['func']:NULL;\n\t\t\t\t\t\t$custom=(strtolower($parts['section'])!='globals');\n\t\t\t\t\t\tif ($func)\n\t\t\t\t\t\t\t$args=[$this->call($func,$args)];\n\t\t\t\t\t\tif (count($args)>1)\n\t\t\t\t\t\t\t$args=[$args];\n\t\t\t\t\t\tif (isset($ttl))\n\t\t\t\t\t\t\t$args=array_merge($args,[$ttl]);\n\t\t\t\t\t\tcall_user_func_array(\n\t\t\t\t\t\t\t[$this,'set'],\n\t\t\t\t\t\t\tarray_merge(\n\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t($custom?($parts['section'].'.'):'').\n\t\t\t\t\t\t\t\t\t$match['lval']\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t$args\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn $this;\n\t}\n\n\t/**\n\t*\tCreate mutex, invoke callback then drop ownership when done\n\t*\t@return mixed\n\t*\t@param $id string\n\t*\t@param $func callback\n\t*\t@param $args mixed\n\t**/\n\tfunction mutex($id,$func,$args=NULL) {\n\t\tif (!is_dir($tmp=$this->hive['TEMP']))\n\t\t\tmkdir($tmp,self::MODE,TRUE);\n\t\t// Use filesystem lock\n\t\tif (is_file($lock=$tmp.\n\t\t\t$this->get('SEED').'.'.$this->hash($id).'.lock') &&\n\t\t\tfilemtime($lock)+ini_get('max_execution_time')<microtime(TRUE))\n\t\t\t// Stale lock\n\t\t\t@unlink($lock);\n\t\twhile (!($handle=@fopen($lock,'x')) && !connection_aborted())\n\t\t\tusleep(mt_rand(0,100));\n\t\t$this->locks[$id]=$lock;\n\t\t$out=$this->call($func,$args);\n\t\tfclose($handle);\n\t\t@unlink($lock);\n\t\tunset($this->locks[$id]);\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tRead file (with option to apply Unix LF as standard line ending)\n\t*\t@return string\n\t*\t@param $file string\n\t*\t@param $lf bool\n\t**/\n\tfunction read($file,$lf=FALSE) {\n\t\t$out=@file_get_contents($file);\n\t\treturn $lf?preg_replace('/\\r\\n|\\r/',\"\\n\",$out):$out;\n\t}\n\n\t/**\n\t*\tExclusive file write\n\t*\t@return int|FALSE\n\t*\t@param $file string\n\t*\t@param $data mixed\n\t*\t@param $append bool\n\t**/\n\tfunction write($file,$data,$append=FALSE) {\n\t\treturn file_put_contents($file,$data,$this->hive['LOCK']|($append?FILE_APPEND:0));\n\t}\n\n\t/**\n\t*\tApply syntax highlighting\n\t*\t@return string\n\t*\t@param $text string\n\t**/\n\tfunction highlight($text) {\n\t\t$out='';\n\t\t$pre=FALSE;\n\t\t$text=trim($text);\n\t\tif ($text && !preg_match('/^<\\?php/',$text)) {\n\t\t\t$text='<?php '.$text;\n\t\t\t$pre=TRUE;\n\t\t}\n\t\tforeach (token_get_all($text) as $token)\n\t\t\tif ($pre)\n\t\t\t\t$pre=FALSE;\n\t\t\telse\n\t\t\t\t$out.='<span'.\n\t\t\t\t\t(is_array($token)?\n\t\t\t\t\t\t(' class=\"'.\n\t\t\t\t\t\t\tsubstr(strtolower(token_name($token[0])),2).'\">'.\n\t\t\t\t\t\t\t$this->encode($token[1]).''):\n\t\t\t\t\t\t('>'.$this->encode($token))).\n\t\t\t\t\t'</span>';\n\t\treturn $out?('<code>'.$out.'</code>'):$text;\n\t}\n\n\t/**\n\t*\tDump expression with syntax highlighting\n\t*\t@param $expr mixed\n\t**/\n\tfunction dump($expr) {\n\t\techo $this->highlight($this->stringify($expr));\n\t}\n\n\t/**\n\t*\tReturn path (and query parameters) relative to the base directory\n\t*\t@return string\n\t*\t@param $url string\n\t**/\n\tfunction rel($url) {\n\t\treturn preg_replace('/^(?:https?:\\/\\/)?'.\n\t\t\tpreg_quote($this->hive['BASE'],'/').'(\\/.*|$)/','\\1',$url);\n\t}\n\n\t/**\n\t*\tNamespace-aware class autoloader\n\t*\t@return mixed\n\t*\t@param $class string\n\t**/\n\tprotected function autoload($class) {\n\t\t$class=$this->fixslashes(ltrim($class,'\\\\'));\n\t\t/** @var callable $func */\n\t\t$func=NULL;\n\t\tif (is_array($path=$this->hive['AUTOLOAD']) &&\n\t\t\tisset($path[1]) && is_callable($path[1]))\n\t\t\tlist($path,$func)=$path;\n\t\tforeach ($this->split($this->hive['PLUGINS'].';'.$path) as $auto)\n\t\t\tif ($func && is_file($file=$func($auto.$class).'.php') ||\n\t\t\t\tis_file($file=$auto.$class.'.php') ||\n\t\t\t\tis_file($file=$auto.strtolower($class).'.php') ||\n\t\t\t\tis_file($file=strtolower($auto.$class).'.php'))\n\t\t\t\treturn require($file);\n\t}\n\n\t/**\n\t*\tExecute framework/application shutdown sequence\n\t*\t@param $cwd string\n\t**/\n\tfunction unload($cwd) {\n\t\tchdir($cwd);\n\t\tif (!($error=error_get_last()) &&\n\t\t\tsession_status()==PHP_SESSION_ACTIVE)\n\t\t\tsession_commit();\n\t\tforeach ($this->locks as $lock)\n\t\t\t@unlink($lock);\n\t\t$handler=$this->hive['UNLOAD'];\n\t\tif ((!$handler || $this->call($handler,$this)===FALSE) &&\n\t\t\t$error && in_array($error['type'],\n\t\t\t[E_ERROR,E_PARSE,E_CORE_ERROR,E_COMPILE_ERROR]))\n\t\t\t// Fatal error detected\n\t\t\t$this->error(500,\n\t\t\t\tsprintf(self::E_Fatal,$error['message']),[$error]);\n\t}\n\n\t/**\n\t*\tConvenience method for checking hive key\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction offsetexists($key) {\n\t\treturn $this->exists($key);\n\t}\n\n\t/**\n\t*\tConvenience method for assigning hive value\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction offsetset($key,$val) {\n\t\treturn $this->set($key,$val);\n\t}\n\n\t/**\n\t*\tConvenience method for retrieving hive value\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction &offsetget($key) {\n\t\t$val=&$this->ref($key);\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tConvenience method for removing hive key\n\t*\t@param $key string\n\t**/\n\tfunction offsetunset($key) {\n\t\t$this->clear($key);\n\t}\n\n\t/**\n\t*\tAlias for offsetexists()\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction __isset($key) {\n\t\treturn $this->offsetexists($key);\n\t}\n\n\t/**\n\t*\tAlias for offsetset()\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction __set($key,$val) {\n\t\treturn $this->offsetset($key,$val);\n\t}\n\n\t/**\n\t*\tAlias for offsetget()\n\t*\t@return mixed\n\t*\t@param $key string\n\t**/\n\tfunction &__get($key) {\n\t\t$val=&$this->offsetget($key);\n\t\treturn $val;\n\t}\n\n\t/**\n\t*\tAlias for offsetunset()\n\t*\t@param $key string\n\t**/\n\tfunction __unset($key) {\n\t\t$this->offsetunset($key);\n\t}\n\n\t/**\n\t*\tCall function identified by hive key\n\t*\t@return mixed\n\t*\t@param $key string\n\t*\t@param $args array\n\t**/\n\tfunction __call($key,array $args) {\n\t\tif ($this->exists($key,$val))\n\t\t\treturn call_user_func_array($val,$args);\n\t\tuser_error(sprintf(self::E_Method,$key),E_USER_ERROR);\n\t}\n\n\t//! Prohibit cloning\n\tprivate function __clone() {\n\t}\n\n\t//! Bootstrap\n\tfunction __construct() {\n\t\t// Managed directives\n\t\tini_set('default_charset',$charset='UTF-8');\n\t\tif (extension_loaded('mbstring'))\n\t\t\tmb_internal_encoding($charset);\n\t\tini_set('display_errors',0);\n\t\t// Deprecated directives\n\t\t@ini_set('magic_quotes_gpc',0);\n\t\t@ini_set('register_globals',0);\n\t\t// Intercept errors/exceptions; PHP5.3-compatible\n\t\t$check=error_reporting((E_ALL|E_STRICT)&~(E_NOTICE|E_USER_NOTICE));\n\t\tset_exception_handler(\n\t\t\tfunction($obj) {\n\t\t\t\t/** @var Exception $obj */\n\t\t\t\t$this->hive['EXCEPTION']=$obj;\n\t\t\t\t$this->error(500,\n\t\t\t\t\t$obj->getmessage().' '.\n\t\t\t\t\t'['.$obj->getFile().':'.$obj->getLine().']',\n\t\t\t\t\t$obj->gettrace());\n\t\t\t}\n\t\t);\n\t\tset_error_handler(\n\t\t\tfunction($level,$text,$file,$line) {\n\t\t\t\tif ($level & error_reporting())\n\t\t\t\t\t$this->error(500,$text,NULL,$level);\n\t\t\t}\n\t\t);\n\t\tif (!isset($_SERVER['SERVER_NAME']) || $_SERVER['SERVER_NAME']==='')\n\t\t\t$_SERVER['SERVER_NAME']=gethostname();\n\t\t$headers=[];\n\t\tif ($cli=PHP_SAPI=='cli') {\n\t\t\t// Emulate HTTP request\n\t\t\t$_SERVER['REQUEST_METHOD']='GET';\n\t\t\tif (!isset($_SERVER['argv'][1])) {\n\t\t\t\t$_SERVER['argc']++;\n\t\t\t\t$_SERVER['argv'][1]='/';\n\t\t\t}\n\t\t\t$req=$query='';\n\t\t\tif (substr($_SERVER['argv'][1],0,1)=='/') {\n\t\t\t\t$req=$_SERVER['argv'][1];\n\t\t\t\t$query=parse_url($req,PHP_URL_QUERY);\n\t\t\t} else {\n\t\t\t\tforeach($_SERVER['argv'] as $i=>$arg) {\n\t\t\t\t\tif (!$i) continue;\n\t\t\t\t\tif (preg_match('/^\\-(\\-)?(\\w+)(?:\\=(.*))?$/',$arg,$m)) {\n\t\t\t\t\t\tforeach($m[1]?[$m[2]]:str_split($m[2]) as $k)\n\t\t\t\t\t\t\t$query.=($query?'&':'').urlencode($k).'=';\n\t\t\t\t\t\tif (isset($m[3]))\n\t\t\t\t\t\t\t$query.=urlencode($m[3]);\n\t\t\t\t\t} else\n\t\t\t\t\t\t$req.='/'.$arg;\n\t\t\t\t}\n\t\t\t\tif (!$req)\n\t\t\t\t\t$req='/';\n\t\t\t\tif ($query)\n\t\t\t\t\t$req.='?'.$query;\n\t\t\t}\n\t\t\t$_SERVER['REQUEST_URI']=$req;\n\t\t\tparse_str($query,$GLOBALS['_GET']);\n\t\t}\n\t\telseif (function_exists('getallheaders')) {\n\t\t\tforeach (getallheaders() as $key=>$val) {\n\t\t\t\t$tmp=strtoupper(strtr($key,'-','_'));\n\t\t\t\t// TODO: use ucwords delimiters for php 5.4.32+ & 5.5.16+\n\t\t\t\t$key=strtr(ucwords(strtolower(strtr($key,'-',' '))),' ','-');\n\t\t\t\t$headers[$key]=$val;\n\t\t\t\tif (isset($_SERVER['HTTP_'.$tmp]))\n\t\t\t\t\t$headers[$key]=&$_SERVER['HTTP_'.$tmp];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (isset($_SERVER['CONTENT_LENGTH']))\n\t\t\t\t$headers['Content-Length']=&$_SERVER['CONTENT_LENGTH'];\n\t\t\tif (isset($_SERVER['CONTENT_TYPE']))\n\t\t\t\t$headers['Content-Type']=&$_SERVER['CONTENT_TYPE'];\n\t\t\tforeach (array_keys($_SERVER) as $key)\n\t\t\t\tif (substr($key,0,5)=='HTTP_')\n\t\t\t\t\t$headers[strtr(ucwords(strtolower(strtr(\n\t\t\t\t\t\tsubstr($key,5),'_',' '))),' ','-')]=&$_SERVER[$key];\n\t\t}\n\t\tif (isset($headers['X-HTTP-Method-Override']))\n\t\t\t$_SERVER['REQUEST_METHOD']=$headers['X-HTTP-Method-Override'];\n\t\telseif ($_SERVER['REQUEST_METHOD']=='POST' && isset($_POST['_method']))\n\t\t\t$_SERVER['REQUEST_METHOD']=strtoupper($_POST['_method']);\n\t\t$scheme=isset($_SERVER['HTTPS']) && $_SERVER['HTTPS']=='on' ||\n\t\t\tisset($headers['X-Forwarded-Proto']) &&\n\t\t\t$headers['X-Forwarded-Proto']=='https'?'https':'http';\n\t\t// Create hive early on to expose header methods\n\t\t$this->hive=['HEADERS'=>&$headers];\n\t\tif (function_exists('apache_setenv')) {\n\t\t\t// Work around Apache pre-2.4 VirtualDocumentRoot bug\n\t\t\t$_SERVER['DOCUMENT_ROOT']=str_replace($_SERVER['SCRIPT_NAME'],'',\n\t\t\t\t$_SERVER['SCRIPT_FILENAME']);\n\t\t\tapache_setenv(\"DOCUMENT_ROOT\",$_SERVER['DOCUMENT_ROOT']);\n\t\t}\n\t\t$_SERVER['DOCUMENT_ROOT']=realpath($_SERVER['DOCUMENT_ROOT']);\n\t\t$base='';\n\t\tif (!$cli)\n\t\t\t$base=rtrim($this->fixslashes(\n\t\t\t\tdirname($_SERVER['SCRIPT_NAME'])),'/');\n\t\t$uri=parse_url((preg_match('/^\\w+:\\/\\//',$_SERVER['REQUEST_URI'])?'':\n\t\t\t\t$scheme.'://'.$_SERVER['SERVER_NAME']).$_SERVER['REQUEST_URI']);\n\t\t$_SERVER['REQUEST_URI']=$uri['path'].\n\t\t\t(isset($uri['query'])?'?'.$uri['query']:'').\n\t\t\t(isset($uri['fragment'])?'#'.$uri['fragment']:'');\n\t\t$path=preg_replace('/^'.preg_quote($base,'/').'/','',$uri['path']);\n\t\t$jar=[\n\t\t\t'expire'=>0,\n\t\t\t'lifetime'=>0,\n\t\t\t'path'=>$base?:'/',\n\t\t\t'domain'=>is_int(strpos($_SERVER['SERVER_NAME'],'.')) &&\n\t\t\t\t!filter_var($_SERVER['SERVER_NAME'],FILTER_VALIDATE_IP)?\n\t\t\t\t$_SERVER['SERVER_NAME']:'',\n\t\t\t'secure'=>($scheme=='https'),\n\t\t\t'httponly'=>TRUE,\n\t\t\t'samesite'=>'Lax',\n\t\t];\n\t\t$port=80;\n\t\tif (isset($headers['X-Forwarded-Port']))\n\t\t\t$port=$headers['X-Forwarded-Port'];\n\t\telseif (isset($_SERVER['SERVER_PORT']))\n\t\t\t$port=$_SERVER['SERVER_PORT'];\n\t\t// Default configuration\n\t\t$this->hive+=[\n\t\t\t'AGENT'=>$this->agent(),\n\t\t\t'AJAX'=>$this->ajax(),\n\t\t\t'ALIAS'=>NULL,\n\t\t\t'ALIASES'=>[],\n\t\t\t'AUTOLOAD'=>'./',\n\t\t\t'BASE'=>$base,\n\t\t\t'BITMASK'=>ENT_COMPAT,\n\t\t\t'BODY'=>NULL,\n\t\t\t'CACHE'=>FALSE,\n\t\t\t'CASELESS'=>TRUE,\n\t\t\t'CLI'=>$cli,\n\t\t\t'CORS'=>[\n\t\t\t\t'headers'=>'',\n\t\t\t\t'origin'=>FALSE,\n\t\t\t\t'credentials'=>FALSE,\n\t\t\t\t'expose'=>FALSE,\n\t\t\t\t'ttl'=>0\n\t\t\t],\n\t\t\t'DEBUG'=>0,\n\t\t\t'DIACRITICS'=>[],\n\t\t\t'DNSBL'=>'',\n\t\t\t'EMOJI'=>[],\n\t\t\t'ENCODING'=>$charset,\n\t\t\t'ERROR'=>NULL,\n\t\t\t'ESCAPE'=>TRUE,\n\t\t\t'EXCEPTION'=>NULL,\n\t\t\t'EXEMPT'=>NULL,\n\t\t\t'FALLBACK'=>$this->fallback,\n\t\t\t'FORMATS'=>[],\n\t\t\t'FRAGMENT'=>isset($uri['fragment'])?$uri['fragment']:'',\n\t\t\t'HALT'=>TRUE,\n\t\t\t'HIGHLIGHT'=>FALSE,\n\t\t\t'HOST'=>$_SERVER['SERVER_NAME'],\n\t\t\t'IP'=>$this->ip(),\n\t\t\t'JAR'=>$jar,\n\t\t\t'LANGUAGE'=>isset($headers['Accept-Language'])?\n\t\t\t\t$this->language($headers['Accept-Language']):\n\t\t\t\t$this->fallback,\n\t\t\t'LOCALES'=>'./',\n\t\t\t'LOCK'=>LOCK_EX,\n\t\t\t'LOGGABLE'=>'*',\n\t\t\t'LOGS'=>'./',\n\t\t\t'MB'=>extension_loaded('mbstring'),\n\t\t\t'ONERROR'=>NULL,\n\t\t\t'ONREROUTE'=>NULL,\n\t\t\t'PACKAGE'=>self::PACKAGE,\n\t\t\t'PARAMS'=>[],\n\t\t\t'PATH'=>$path,\n\t\t\t'PATTERN'=>NULL,\n\t\t\t'PLUGINS'=>$this->fixslashes(__DIR__).'/',\n\t\t\t'PORT'=>$port,\n\t\t\t'PREFIX'=>NULL,\n\t\t\t'PREMAP'=>'',\n\t\t\t'QUERY'=>isset($uri['query'])?$uri['query']:'',\n\t\t\t'QUIET'=>FALSE,\n\t\t\t'RAW'=>FALSE,\n\t\t\t'REALM'=>$scheme.'://'.$_SERVER['SERVER_NAME'].\n\t\t\t\t($port && !in_array($port,[80,443])?(':'.$port):'').\n\t\t\t\t$_SERVER['REQUEST_URI'],\n\t\t\t'RESPONSE'=>'',\n\t\t\t'ROOT'=>$_SERVER['DOCUMENT_ROOT'],\n\t\t\t'ROUTES'=>[],\n\t\t\t'SCHEME'=>$scheme,\n\t\t\t'SEED'=>$this->hash($_SERVER['SERVER_NAME'].$base),\n\t\t\t'SERIALIZER'=>extension_loaded($ext='igbinary')?$ext:'php',\n\t\t\t'TEMP'=>'tmp/',\n\t\t\t'TIME'=>&$_SERVER['REQUEST_TIME_FLOAT'],\n\t\t\t'TZ'=>@date_default_timezone_get(),\n\t\t\t'UI'=>'./',\n\t\t\t'UNLOAD'=>NULL,\n\t\t\t'UPLOADS'=>'./',\n\t\t\t'URI'=>&$_SERVER['REQUEST_URI'],\n\t\t\t'VERB'=>&$_SERVER['REQUEST_METHOD'],\n\t\t\t'VERSION'=>self::VERSION,\n\t\t\t'XFRAME'=>'SAMEORIGIN'\n\t\t];\n\t\tif (!headers_sent() && session_status()!=PHP_SESSION_ACTIVE) {\n\t\t\tunset($jar['expire']);\n\t\t\tsession_cache_limiter('');\n\t\t\tif (version_compare(PHP_VERSION, '7.3.0') >= 0)\n\t\t\t\tsession_set_cookie_params($jar);\n\t\t\telse {\n\t\t\t\tunset($jar['samesite']);\n\t\t\t\tcall_user_func_array('session_set_cookie_params',$jar);\n\t\t\t}\n\t\t}\n\t\tif (PHP_SAPI=='cli-server' &&\n\t\t\tpreg_match('/^'.preg_quote($base,'/').'$/',$this->hive['URI']))\n\t\t\t$this->reroute('/');\n\t\tif (ini_get('auto_globals_jit'))\n\t\t\t// Override setting\n\t\t\t$GLOBALS+=['_ENV'=>$_ENV,'_REQUEST'=>$_REQUEST];\n\t\t// Sync PHP globals with corresponding hive keys\n\t\t$this->init=$this->hive;\n\t\tforeach (explode('|',self::GLOBALS) as $global) {\n\t\t\t$sync=$this->sync($global);\n\t\t\t$this->init+=[\n\t\t\t\t$global=>preg_match('/SERVER|ENV/',$global)?$sync:[]\n\t\t\t];\n\t\t}\n\t\tif ($check && $error=error_get_last())\n\t\t\t// Error detected\n\t\t\t$this->error(500,\n\t\t\t\tsprintf(self::E_Fatal,$error['message']),[$error]);\n\t\tdate_default_timezone_set($this->hive['TZ']);\n\t\t// Register framework autoloader\n\t\tspl_autoload_register([$this,'autoload']);\n\t\t// Register shutdown handler\n\t\tregister_shutdown_function([$this,'unload'],getcwd());\n\t}\n\n}\n\n//! Cache engine\nclass Cache extends Prefab {\n\n\tprotected\n\t\t//! Cache DSN\n\t\t$dsn,\n\t\t//! Prefix for cache entries\n\t\t$prefix,\n\t\t//! MemCache or Redis object\n\t\t$ref;\n\n\t/**\n\t*\tReturn timestamp and TTL of cache entry or FALSE if not found\n\t*\t@return array|FALSE\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t**/\n\tfunction exists($key,&$val=NULL) {\n\t\t$fw=Base::instance();\n\t\tif (!$this->dsn)\n\t\t\treturn FALSE;\n\t\t$ndx=$this->prefix.'.'.$key;\n\t\t$parts=explode('=',$this->dsn,2);\n\t\tswitch ($parts[0]) {\n\t\t\tcase 'apc':\n\t\t\tcase 'apcu':\n\t\t\t\t$raw=call_user_func($parts[0].'_fetch',$ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'redis':\n\t\t\t\t$raw=$this->ref->get($ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'memcache':\n\t\t\t\t$raw=memcache_get($this->ref,$ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'memcached':\n\t\t\t\t$raw=$this->ref->get($ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'wincache':\n\t\t\t\t$raw=wincache_ucache_get($ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'xcache':\n\t\t\t\t$raw=xcache_get($ndx);\n\t\t\t\tbreak;\n\t\t\tcase 'folder':\n\t\t\t\t$raw=$fw->read($parts[1].$ndx);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!empty($raw)) {\n\t\t\tlist($val,$time,$ttl)=(array)$fw->unserialize($raw);\n\t\t\tif ($ttl===0 || $time+$ttl>microtime(TRUE))\n\t\t\t\treturn [$time,$ttl];\n\t\t\t$val=null;\n\t\t\t$this->clear($key);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tStore value in cache\n\t*\t@return mixed|FALSE\n\t*\t@param $key string\n\t*\t@param $val mixed\n\t*\t@param $ttl int\n\t**/\n\tfunction set($key,$val,$ttl=0) {\n\t\t$fw=Base::instance();\n\t\tif (!$this->dsn)\n\t\t\treturn TRUE;\n\t\t$ndx=$this->prefix.'.'.$key;\n\t\tif ($cached=$this->exists($key))\n\t\t\t$ttl=$cached[1];\n\t\t$data=$fw->serialize([$val,microtime(TRUE),$ttl]);\n\t\t$parts=explode('=',$this->dsn,2);\n\t\tswitch ($parts[0]) {\n\t\t\tcase 'apc':\n\t\t\tcase 'apcu':\n\t\t\t\treturn call_user_func($parts[0].'_store',$ndx,$data,$ttl);\n\t\t\tcase 'redis':\n\t\t\t\treturn $this->ref->set($ndx,$data,$ttl?['ex'=>$ttl]:[]);\n\t\t\tcase 'memcache':\n\t\t\t\treturn memcache_set($this->ref,$ndx,$data,0,$ttl);\n\t\t\tcase 'memcached':\n\t\t\t\treturn $this->ref->set($ndx,$data,$ttl);\n\t\t\tcase 'wincache':\n\t\t\t\treturn wincache_ucache_set($ndx,$data,$ttl);\n\t\t\tcase 'xcache':\n\t\t\t\treturn xcache_set($ndx,$data,$ttl);\n\t\t\tcase 'folder':\n\t\t\t\treturn $fw->write($parts[1].\n\t\t\t\t\tstr_replace(['/','\\\\'],'',$ndx),$data);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tRetrieve value of cache entry\n\t*\t@return mixed|FALSE\n\t*\t@param $key string\n\t**/\n\tfunction get($key) {\n\t\treturn $this->dsn && $this->exists($key,$data)?$data:FALSE;\n\t}\n\n\t/**\n\t*\tDelete cache entry\n\t*\t@return bool\n\t*\t@param $key string\n\t**/\n\tfunction clear($key) {\n\t\tif (!$this->dsn)\n\t\t\treturn;\n\t\t$ndx=$this->prefix.'.'.$key;\n\t\t$parts=explode('=',$this->dsn,2);\n\t\tswitch ($parts[0]) {\n\t\t\tcase 'apc':\n\t\t\tcase 'apcu':\n\t\t\t\treturn call_user_func($parts[0].'_delete',$ndx);\n\t\t\tcase 'redis':\n\t\t\t\treturn $this->ref->del($ndx);\n\t\t\tcase 'memcache':\n\t\t\t\treturn memcache_delete($this->ref,$ndx);\n\t\t\tcase 'memcached':\n\t\t\t\treturn $this->ref->delete($ndx);\n\t\t\tcase 'wincache':\n\t\t\t\treturn wincache_ucache_delete($ndx);\n\t\t\tcase 'xcache':\n\t\t\t\treturn xcache_unset($ndx);\n\t\t\tcase 'folder':\n\t\t\t\treturn @unlink($parts[1].$ndx);\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tClear contents of cache backend\n\t*\t@return bool\n\t*\t@param $suffix string\n\t**/\n\tfunction reset($suffix=NULL) {\n\t\tif (!$this->dsn)\n\t\t\treturn TRUE;\n\t\t$regex='/'.preg_quote($this->prefix.'.','/').'.*'.\n\t\t\tpreg_quote($suffix,'/').'/';\n\t\t$parts=explode('=',$this->dsn,2);\n\t\tswitch ($parts[0]) {\n\t\t\tcase 'apc':\n\t\t\tcase 'apcu':\n\t\t\t\t$info=call_user_func($parts[0].'_cache_info',\n\t\t\t\t\t$parts[0]=='apcu'?FALSE:'user');\n\t\t\t\tif (!empty($info['cache_list'])) {\n\t\t\t\t\t$key=array_key_exists('info',\n\t\t\t\t\t\t$info['cache_list'][0])?'info':'key';\n\t\t\t\t\tforeach ($info['cache_list'] as $item)\n\t\t\t\t\t\tif (preg_match($regex,$item[$key]))\n\t\t\t\t\t\t\tcall_user_func($parts[0].'_delete',$item[$key]);\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\tcase 'redis':\n\t\t\t\t$keys=$this->ref->keys($this->prefix.'.*'.$suffix);\n\t\t\t\tforeach($keys as $key)\n\t\t\t\t\t$this->ref->del($key);\n\t\t\t\treturn TRUE;\n\t\t\tcase 'memcache':\n\t\t\t\tforeach (memcache_get_extended_stats(\n\t\t\t\t\t$this->ref,'slabs') as $slabs)\n\t\t\t\t\tforeach (array_filter(array_keys($slabs),'is_numeric')\n\t\t\t\t\t\tas $id)\n\t\t\t\t\t\tforeach (memcache_get_extended_stats(\n\t\t\t\t\t\t\t$this->ref,'cachedump',$id) as $data)\n\t\t\t\t\t\t\tif (is_array($data))\n\t\t\t\t\t\t\t\tforeach (array_keys($data) as $key)\n\t\t\t\t\t\t\t\t\tif (preg_match($regex,$key))\n\t\t\t\t\t\t\t\t\t\tmemcache_delete($this->ref,$key);\n\t\t\t\treturn TRUE;\n\t\t\tcase 'memcached':\n\t\t\t\tforeach ($this->ref->getallkeys()?:[] as $key)\n\t\t\t\t\tif (preg_match($regex,$key))\n\t\t\t\t\t\t$this->ref->delete($key);\n\t\t\t\treturn TRUE;\n\t\t\tcase 'wincache':\n\t\t\t\t$info=wincache_ucache_info();\n\t\t\t\tforeach ($info['ucache_entries'] as $item)\n\t\t\t\t\tif (preg_match($regex,$item['key_name']))\n\t\t\t\t\t\twincache_ucache_delete($item['key_name']);\n\t\t\t\treturn TRUE;\n\t\t\tcase 'xcache':\n\t\t\t\tif ($suffix && !ini_get('xcache.admin.enable_auth')) {\n\t\t\t\t\t$cnt=xcache_count(XC_TYPE_VAR);\n\t\t\t\t\tfor ($i=0;$i<$cnt;$i++) {\n\t\t\t\t\t\t$list=xcache_list(XC_TYPE_VAR,$i);\n\t\t\t\t\t\tforeach ($list['cache_list'] as $item)\n\t\t\t\t\t\t\tif (preg_match($regex,$item['name']))\n\t\t\t\t\t\t\t\txcache_unset($item['name']);\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\txcache_unset_by_prefix($this->prefix.'.');\n\t\t\t\treturn TRUE;\n\t\t\tcase 'folder':\n\t\t\t\tif ($glob=@glob($parts[1].'*'))\n\t\t\t\t\tforeach ($glob as $file)\n\t\t\t\t\t\tif (preg_match($regex,basename($file)))\n\t\t\t\t\t\t\t@unlink($file);\n\t\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\t/**\n\t*\tLoad/auto-detect cache backend\n\t*\t@return string\n\t*\t@param $dsn bool|string\n\t*\t@param $seed bool|string\n\t**/\n\tfunction load($dsn,$seed=NULL) {\n\t\t$fw=Base::instance();\n\t\tif ($dsn=trim($dsn)) {\n\t\t\tif (preg_match('/^redis=(.+)/',$dsn,$parts) &&\n\t\t\t\textension_loaded('redis')) {\n\t\t\t\tlist($host,$port,$db,$password)=explode(':',$parts[1])+[1=>6379,2=>NULL,3=>NULL];\n\t\t\t\t$this->ref=new Redis;\n\t\t\t\tif(!$this->ref->connect($host,$port,2))\n\t\t\t\t\t$this->ref=NULL;\n\t\t\t\tif(!empty($password))\n\t\t\t\t\t$this->ref->auth($password);\n\t\t\t\tif(isset($db))\n\t\t\t\t\t$this->ref->select($db);\n\t\t\t}\n\t\t\telseif (preg_match('/^memcache=(.+)/',$dsn,$parts) &&\n\t\t\t\textension_loaded('memcache'))\n\t\t\t\tforeach ($fw->split($parts[1]) as $server) {\n\t\t\t\t\tlist($host,$port)=explode(':',$server)+[1=>11211];\n\t\t\t\t\tif (empty($this->ref))\n\t\t\t\t\t\t$this->ref=@memcache_connect($host,$port)?:NULL;\n\t\t\t\t\telse\n\t\t\t\t\t\tmemcache_add_server($this->ref,$host,$port);\n\t\t\t\t}\n\t\t\telseif (preg_match('/^memcached=(.+)/',$dsn,$parts) &&\n\t\t\t\textension_loaded('memcached'))\n\t\t\t\tforeach ($fw->split($parts[1]) as $server) {\n\t\t\t\t\tlist($host,$port)=explode(':',$server)+[1=>11211];\n\t\t\t\t\tif (empty($this->ref))\n\t\t\t\t\t\t$this->ref=new Memcached();\n\t\t\t\t\t$this->ref->addServer($host,$port);\n\t\t\t\t}\n\t\t\tif (empty($this->ref) && !preg_match('/^folder\\h*=/',$dsn))\n\t\t\t\t$dsn=($grep=preg_grep('/^(apc|wincache|xcache)/',\n\t\t\t\t\tarray_map('strtolower',get_loaded_extensions())))?\n\t\t\t\t\t\t// Auto-detect\n\t\t\t\t\t\tcurrent($grep):\n\t\t\t\t\t\t// Use filesystem as fallback\n\t\t\t\t\t\t('folder='.$fw->TEMP.'cache/');\n\t\t\tif (preg_match('/^folder\\h*=\\h*(.+)/',$dsn,$parts) &&\n\t\t\t\t!is_dir($parts[1]))\n\t\t\t\tmkdir($parts[1],Base::MODE,TRUE);\n\t\t}\n\t\t$this->prefix=$seed?:$fw->SEED;\n\t\treturn $this->dsn=$dsn;\n\t}\n\n\t/**\n\t*\tClass constructor\n\t*\t@param $dsn bool|string\n\t**/\n\tfunction __construct($dsn=FALSE) {\n\t\tif ($dsn)\n\t\t\t$this->load($dsn);\n\t}\n\n}\n\n//! View handler\nclass View extends Prefab {\n\n\tprivate\n\t\t//! Temporary hive\n\t\t$temp;\n\n\tprotected\n\t\t//! Template file\n\t\t$file,\n\t\t//! Post-rendering handler\n\t\t$trigger,\n\t\t//! Nesting level\n\t\t$level=0;\n\n\t/** @var \\Base Framework instance */\n\tprotected $fw;\n\n\tfunction __construct() {\n\t\t$this->fw=\\Base::instance();\n\t}\n\n\t/**\n\t*\tEncode characters to equivalent HTML entities\n\t*\t@return string\n\t*\t@param $arg mixed\n\t**/\n\tfunction esc($arg) {\n\t\treturn $this->fw->recursive($arg,\n\t\t\tfunction($val) {\n\t\t\t\treturn is_string($val)?$this->fw->encode($val):$val;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t*\tDecode HTML entities to equivalent characters\n\t*\t@return string\n\t*\t@param $arg mixed\n\t**/\n\tfunction raw($arg) {\n\t\treturn $this->fw->recursive($arg,\n\t\t\tfunction($val) {\n\t\t\t\treturn is_string($val)?$this->fw->decode($val):$val;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t*\tCreate sandbox for template execution\n\t*\t@return string\n\t*\t@param $hive array\n\t*\t@param $mime string\n\t**/\n\tprotected function sandbox(array $hive=NULL,$mime=NULL) {\n\t\t$fw=$this->fw;\n\t\t$implicit=FALSE;\n\t\tif (is_null($hive)) {\n\t\t\t$implicit=TRUE;\n\t\t\t$hive=$fw->hive();\n\t\t}\n\t\tif ($this->level<1 || $implicit) {\n\t\t\tif (!$fw->CLI && $mime && !headers_sent() &&\n\t\t\t\t!preg_grep ('/^Content-Type:/',headers_list()))\n\t\t\t\theader('Content-Type: '.$mime.'; '.\n\t\t\t\t\t'charset='.$fw->ENCODING);\n\t\t\tif ($fw->ESCAPE)\n\t\t\t\t$hive=$this->esc($hive);\n\t\t\tif (isset($hive['ALIASES']))\n\t\t\t\t$hive['ALIASES']=$fw->build($hive['ALIASES']);\n\t\t}\n\t\t$this->temp=$hive;\n\t\tunset($fw,$hive,$implicit,$mime);\n\t\textract($this->temp);\n\t\t$this->temp=NULL;\n\t\t$this->level++;\n\t\tob_start();\n\t\trequire($this->file);\n\t\t$this->level--;\n\t\treturn ob_get_clean();\n\t}\n\n\t/**\n\t*\tRender template\n\t*\t@return string\n\t*\t@param $file string\n\t*\t@param $mime string\n\t*\t@param $hive array\n\t*\t@param $ttl int\n\t**/\n\tfunction render($file,$mime='text/html',array $hive=NULL,$ttl=0) {\n\t\t$fw=$this->fw;\n\t\t$cache=Cache::instance();\n\t\tforeach ($fw->split($fw->UI) as $dir) {\n\t\t\tif ($cache->exists($hash=$fw->hash($dir.$file),$data))\n\t\t\t\treturn $data;\n\t\t\tif (is_file($this->file=$fw->fixslashes($dir.$file))) {\n\t\t\t\tif (isset($_COOKIE[session_name()]) &&\n\t\t\t\t\t!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\t\tsession_start();\n\t\t\t\t$fw->sync('SESSION');\n\t\t\t\t$data=$this->sandbox($hive,$mime);\n\t\t\t\tif (isset($this->trigger['afterrender']))\n\t\t\t\t\tforeach($this->trigger['afterrender'] as $func)\n\t\t\t\t\t\t$data=$fw->call($func,[$data, $dir.$file]);\n\t\t\t\tif ($ttl)\n\t\t\t\t\t$cache->set($hash,$data,$ttl);\n\t\t\t\treturn $data;\n\t\t\t}\n\t\t}\n\t\tuser_error(sprintf(Base::E_Open,$file),E_USER_ERROR);\n\t}\n\n\t/**\n\t*\tpost rendering handler\n\t*\t@param $func callback\n\t*/\n\tfunction afterrender($func) {\n\t\t$this->trigger['afterrender'][]=$func;\n\t}\n\n}\n\n//! Lightweight template engine\nclass Preview extends View {\n\n\tprotected\n\t\t//! token filter\n\t\t$filter=[\n\t\t\t'c'=>'$this->c',\n\t\t\t'esc'=>'$this->esc',\n\t\t\t'raw'=>'$this->raw',\n\t\t\t'export'=>'Base::instance()->export',\n\t\t\t'alias'=>'Base::instance()->alias',\n\t\t\t'format'=>'Base::instance()->format'\n\t\t];\n\n\tprotected\n\t\t//! newline interpolation\n\t\t$interpolation=true;\n\n\t/**\n\t * Enable/disable markup parsing interpolation\n\t * mainly used for adding appropriate newlines\n\t * @param $bool bool\n\t */\n\tfunction interpolation($bool) {\n\t\t$this->interpolation=$bool;\n\t}\n\n\t/**\n\t*\tReturn C-locale equivalent of number\n\t*\t@return string\n\t*\t@param $val int|float\n\t**/\n\tfunction c($val) {\n\t\t$locale=setlocale(LC_NUMERIC,0);\n\t\tsetlocale(LC_NUMERIC,'C');\n\t\t$out=(string)(float)$val;\n\t\t$locale=setlocale(LC_NUMERIC,$locale);\n\t\treturn $out;\n\t}\n\n\t/**\n\t*\tConvert token to variable\n\t*\t@return string\n\t*\t@param $str string\n\t**/\n\tfunction token($str) {\n\t\t$str=trim(preg_replace('/\\{\\{(.+?)\\}\\}/s','\\1',$this->fw->compile($str)));\n\t\tif (preg_match('/^(.+)(?<!\\|)\\|((?:\\h*\\w+(?:\\h*[,;]?))+)$/s',\n\t\t\t$str,$parts)) {\n\t\t\t$str=trim($parts[1]);\n\t\t\tforeach ($this->fw->split(trim($parts[2],\"\\xC2\\xA0\")) as $func)\n\t\t\t\t$str=((empty($this->filter[$cmd=$func]) &&\n\t\t\t\t\tfunction_exists($cmd)) ||\n\t\t\t\t\tis_string($cmd=$this->filter($func)))?\n\t\t\t\t\t$cmd.'('.$str.')':\n\t\t\t\t\t'Base::instance()->'.\n\t\t\t\t\t\t'call($this->filter(\\''.$func.'\\'),['.$str.'])';\n\t\t}\n\t\treturn $str;\n\t}\n\n\t/**\n\t*\tRegister or get (one specific or all) token filters\n\t*\t@param string $key\n\t*\t@param string|closure $func\n\t*\t@return array|closure|string\n\t*/\n\tfunction filter($key=NULL,$func=NULL) {\n\t\tif (!$key)\n\t\t\treturn array_keys($this->filter);\n\t\t$key=strtolower($key);\n\t\tif (!$func)\n\t\t\treturn $this->filter[$key];\n\t\t$this->filter[$key]=$func;\n\t}\n\n\t/**\n\t*\tAssemble markup\n\t*\t@return string\n\t*\t@param $node string\n\t**/\n\tprotected function build($node) {\n\t\treturn preg_replace_callback(\n\t\t\t'/\\{~(.+?)~\\}|\\{\\*(.+?)\\*\\}|\\{\\-(.+?)\\-\\}|'.\n\t\t\t'\\{\\{(.+?)\\}\\}((\\r?\\n)*)/s',\n\t\t\tfunction($expr) {\n\t\t\t\tif ($expr[1])\n\t\t\t\t\t$str='<?php '.$this->token($expr[1]).' ?>';\n\t\t\t\telseif ($expr[2])\n\t\t\t\t\treturn '';\n\t\t\t\telseif ($expr[3])\n\t\t\t\t\t$str=$expr[3];\n\t\t\t\telse {\n\t\t\t\t\t$str='<?= ('.trim($this->token($expr[4])).')'.\n\t\t\t\t\t\t($this->interpolation?\n\t\t\t\t\t\t\t(!empty($expr[6])?'.\"'.$expr[6].'\"':''):'').' ?>';\n\t\t\t\t\tif (isset($expr[5]))\n\t\t\t\t\t\t$str.=$expr[5];\n\t\t\t\t}\n\t\t\t\treturn $str;\n\t\t\t},\n\t\t\t$node\n\t\t);\n\t}\n\n\t/**\n\t*\tRender template string\n\t*\t@return string\n\t*\t@param $node string|array\n\t*\t@param $hive array\n\t*\t@param $ttl int\n\t*\t@param $persist bool\n\t*\t@param $escape bool\n\t**/\n\tfunction resolve($node,array $hive=NULL,$ttl=0,$persist=FALSE,$escape=NULL) {\n\t\t$fw=$this->fw;\n\t\t$cache=Cache::instance();\n\t\tif ($escape!==NULL) {\n\t\t\t$esc=$fw->ESCAPE;\n\t\t\t$fw->ESCAPE=$escape;\n\t\t}\n\t\tif ($ttl || $persist)\n\t\t\t$hash=$fw->hash($fw->serialize($node));\n\t\tif ($ttl && $cache->exists($hash,$data))\n\t\t\treturn $data;\n\t\tif ($persist) {\n\t\t\tif (!is_dir($tmp=$fw->TEMP))\n\t\t\t\tmkdir($tmp,Base::MODE,TRUE);\n\t\t\tif (!is_file($this->file=($tmp.\n\t\t\t\t$fw->SEED.'.'.$hash.'.php')))\n\t\t\t\t$fw->write($this->file,$this->build($node));\n\t\t\tif (isset($_COOKIE[session_name()]) &&\n\t\t\t\t!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\tsession_start();\n\t\t\t$fw->sync('SESSION');\n\t\t\t$data=$this->sandbox($hive);\n\t\t}\n\t\telse {\n\t\t\tif (!$hive)\n\t\t\t\t$hive=$fw->hive();\n\t\t\tif ($fw->ESCAPE)\n\t\t\t\t$hive=$this->esc($hive);\n\t\t\textract($hive);\n\t\t\tunset($hive);\n\t\t\tob_start();\n\t\t\teval(' ?>'.$this->build($node).'<?php ');\n\t\t\t$data=ob_get_clean();\n\t\t}\n\t\tif ($ttl)\n\t\t\t$cache->set($hash,$data,$ttl);\n\t\tif ($escape!==NULL)\n\t\t\t$fw->ESCAPE=$esc;\n\t\treturn $data;\n\t}\n\n\t/**\n\t *\tParse template string\n\t *\t@return string\n\t *\t@param $text string\n\t **/\n\tfunction parse($text) {\n\t\t// Remove PHP code and comments\n\t\treturn preg_replace(\n\t\t\t'/\\h*<\\?(?!xml)(?:php|\\s*=)?.+?\\?>\\h*|'.\n\t\t\t'\\{\\*.+?\\*\\}/is','', $text);\n\t}\n\n\t/**\n\t*\tRender template\n\t*\t@return string\n\t*\t@param $file string\n\t*\t@param $mime string\n\t*\t@param $hive array\n\t*\t@param $ttl int\n\t**/\n\tfunction render($file,$mime='text/html',array $hive=NULL,$ttl=0) {\n\t\t$fw=$this->fw;\n\t\t$cache=Cache::instance();\n\t\tif (!is_dir($tmp=$fw->TEMP))\n\t\t\tmkdir($tmp,Base::MODE,TRUE);\n\t\tforeach ($fw->split($fw->UI) as $dir) {\n\t\t\tif ($cache->exists($hash=$fw->hash($dir.$file),$data))\n\t\t\t\treturn $data;\n\t\t\tif (is_file($view=$fw->fixslashes($dir.$file))) {\n\t\t\t\tif (!is_file($this->file=($tmp.\n\t\t\t\t\t$fw->SEED.'.'.$fw->hash($view).'.php')) ||\n\t\t\t\t\tfilemtime($this->file)<filemtime($view)) {\n\t\t\t\t\t$contents=$fw->read($view);\n\t\t\t\t\tif (isset($this->trigger['beforerender']))\n\t\t\t\t\t\tforeach ($this->trigger['beforerender'] as $func)\n\t\t\t\t\t\t\t$contents=$fw->call($func, [$contents, $view]);\n\t\t\t\t\t$text=$this->parse($contents);\n\t\t\t\t\t$fw->write($this->file,$this->build($text));\n\t\t\t\t}\n\t\t\t\tif (isset($_COOKIE[session_name()]) &&\n\t\t\t\t\t!headers_sent() && session_status()!=PHP_SESSION_ACTIVE)\n\t\t\t\t\tsession_start();\n\t\t\t\t$fw->sync('SESSION');\n\t\t\t\t$data=$this->sandbox($hive,$mime);\n\t\t\t\tif(isset($this->trigger['afterrender']))\n\t\t\t\t\tforeach ($this->trigger['afterrender'] as $func)\n\t\t\t\t\t\t$data=$fw->call($func, [$data, $view]);\n\t\t\t\tif ($ttl)\n\t\t\t\t\t$cache->set($hash,$data,$ttl);\n\t\t\t\treturn $data;\n\t\t\t}\n\t\t}\n\t\tuser_error(sprintf(Base::E_Open,$file),E_USER_ERROR);\n\t}\n\n\t/**\n\t *\tpost rendering handler\n\t *\t@param $func callback\n\t */\n\tfunction beforerender($func) {\n\t\t$this->trigger['beforerender'][]=$func;\n\t}\n\n}\n\n//! ISO language/country codes\nclass ISO extends Prefab {\n\n\t//@{ ISO 3166-1 country codes\n\tconst\n\t\tCC_af='Afghanistan',\n\t\tCC_ax='\u00c5land Islands',\n\t\tCC_al='Albania',\n\t\tCC_dz='Algeria',\n\t\tCC_as='American Samoa',\n\t\tCC_ad='Andorra',\n\t\tCC_ao='Angola',\n\t\tCC_ai='Anguilla',\n\t\tCC_aq='Antarctica',\n\t\tCC_ag='Antigua and Barbuda',\n\t\tCC_ar='Argentina',\n\t\tCC_am='Armenia',\n\t\tCC_aw='Aruba',\n\t\tCC_au='Australia',\n\t\tCC_at='Austria',\n\t\tCC_az='Azerbaijan',\n\t\tCC_bs='Bahamas',\n\t\tCC_bh='Bahrain',\n\t\tCC_bd='Bangladesh',\n\t\tCC_bb='Barbados',\n\t\tCC_by='Belarus',\n\t\tCC_be='Belgium',\n\t\tCC_bz='Belize',\n\t\tCC_bj='Benin',\n\t\tCC_bm='Bermuda',\n\t\tCC_bt='Bhutan',\n\t\tCC_bo='Bolivia',\n\t\tCC_bq='Bonaire, Sint Eustatius and Saba',\n\t\tCC_ba='Bosnia and Herzegovina',\n\t\tCC_bw='Botswana',\n\t\tCC_bv='Bouvet Island',\n\t\tCC_br='Brazil',\n\t\tCC_io='British Indian Ocean Territory',\n\t\tCC_bn='Brunei Darussalam',\n\t\tCC_bg='Bulgaria',\n\t\tCC_bf='Burkina Faso',\n\t\tCC_bi='Burundi',\n\t\tCC_kh='Cambodia',\n\t\tCC_cm='Cameroon',\n\t\tCC_ca='Canada',\n\t\tCC_cv='Cape Verde',\n\t\tCC_ky='Cayman Islands',\n\t\tCC_cf='Central African Republic',\n\t\tCC_td='Chad',\n\t\tCC_cl='Chile',\n\t\tCC_cn='China',\n\t\tCC_cx='Christmas Island',\n\t\tCC_cc='Cocos (Keeling) Islands',\n\t\tCC_co='Colombia',\n\t\tCC_km='Comoros',\n\t\tCC_cg='Congo',\n\t\tCC_cd='Congo, The Democratic Republic of',\n\t\tCC_ck='Cook Islands',\n\t\tCC_cr='Costa Rica',\n\t\tCC_ci='C\u00f4te d\\'ivoire',\n\t\tCC_hr='Croatia',\n\t\tCC_cu='Cuba',\n\t\tCC_cw='Cura\u00e7ao',\n\t\tCC_cy='Cyprus',\n\t\tCC_cz='Czech Republic',\n\t\tCC_dk='Denmark',\n\t\tCC_dj='Djibouti',\n\t\tCC_dm='Dominica',\n\t\tCC_do='Dominican Republic',\n\t\tCC_ec='Ecuador',\n\t\tCC_eg='Egypt',\n\t\tCC_sv='El Salvador',\n\t\tCC_gq='Equatorial Guinea',\n\t\tCC_er='Eritrea',\n\t\tCC_ee='Estonia',\n\t\tCC_et='Ethiopia',\n\t\tCC_fk='Falkland Islands (Malvinas)',\n\t\tCC_fo='Faroe Islands',\n\t\tCC_fj='Fiji',\n\t\tCC_fi='Finland',\n\t\tCC_fr='France',\n\t\tCC_gf='French Guiana',\n\t\tCC_pf='French Polynesia',\n\t\tCC_tf='French Southern Territories',\n\t\tCC_ga='Gabon',\n\t\tCC_gm='Gambia',\n\t\tCC_ge='Georgia',\n\t\tCC_de='Germany',\n\t\tCC_gh='Ghana',\n\t\tCC_gi='Gibraltar',\n\t\tCC_gr='Greece',\n\t\tCC_gl='Greenland',\n\t\tCC_gd='Grenada',\n\t\tCC_gp='Guadeloupe',\n\t\tCC_gu='Guam',\n\t\tCC_gt='Guatemala',\n\t\tCC_gg='Guernsey',\n\t\tCC_gn='Guinea',\n\t\tCC_gw='Guinea-Bissau',\n\t\tCC_gy='Guyana',\n\t\tCC_ht='Haiti',\n\t\tCC_hm='Heard Island and McDonald Islands',\n\t\tCC_va='Holy See (Vatican City State)',\n\t\tCC_hn='Honduras',\n\t\tCC_hk='Hong Kong',\n\t\tCC_hu='Hungary',\n\t\tCC_is='Iceland',\n\t\tCC_in='India',\n\t\tCC_id='Indonesia',\n\t\tCC_ir='Iran, Islamic Republic of',\n\t\tCC_iq='Iraq',\n\t\tCC_ie='Ireland',\n\t\tCC_im='Isle of Man',\n\t\tCC_il='Israel',\n\t\tCC_it='Italy',\n\t\tCC_jm='Jamaica',\n\t\tCC_jp='Japan',\n\t\tCC_je='Jersey',\n\t\tCC_jo='Jordan',\n\t\tCC_kz='Kazakhstan',\n\t\tCC_ke='Kenya',\n\t\tCC_ki='Kiribati',\n\t\tCC_kp='Korea, Democratic People\\'s Republic of',\n\t\tCC_kr='Korea, Republic of',\n\t\tCC_kw='Kuwait',\n\t\tCC_kg='Kyrgyzstan',\n\t\tCC_la='Lao People\\'s Democratic Republic',\n\t\tCC_lv='Latvia',\n\t\tCC_lb='Lebanon',\n\t\tCC_ls='Lesotho',\n\t\tCC_lr='Liberia',\n\t\tCC_ly='Libya',\n\t\tCC_li='Liechtenstein',\n\t\tCC_lt='Lithuania',\n\t\tCC_lu='Luxembourg',\n\t\tCC_mo='Macao',\n\t\tCC_mk='Macedonia, The Former Yugoslav Republic of',\n\t\tCC_mg='Madagascar',\n\t\tCC_mw='Malawi',\n\t\tCC_my='Malaysia',\n\t\tCC_mv='Maldives',\n\t\tCC_ml='Mali',\n\t\tCC_mt='Malta',\n\t\tCC_mh='Marshall Islands',\n\t\tCC_mq='Martinique',\n\t\tCC_mr='Mauritania',\n\t\tCC_mu='Mauritius',\n\t\tCC_yt='Mayotte',\n\t\tCC_mx='Mexico',\n\t\tCC_fm='Micronesia, Federated States of',\n\t\tCC_md='Moldova, Republic of',\n\t\tCC_mc='Monaco',\n\t\tCC_mn='Mongolia',\n\t\tCC_me='Montenegro',\n\t\tCC_ms='Montserrat',\n\t\tCC_ma='Morocco',\n\t\tCC_mz='Mozambique',\n\t\tCC_mm='Myanmar',\n\t\tCC_na='Namibia',\n\t\tCC_nr='Nauru',\n\t\tCC_np='Nepal',\n\t\tCC_nl='Netherlands',\n\t\tCC_nc='New Caledonia',\n\t\tCC_nz='New Zealand',\n\t\tCC_ni='Nicaragua',\n\t\tCC_ne='Niger',\n\t\tCC_ng='Nigeria',\n\t\tCC_nu='Niue',\n\t\tCC_nf='Norfolk Island',\n\t\tCC_mp='Northern Mariana Islands',\n\t\tCC_no='Norway',\n\t\tCC_om='Oman',\n\t\tCC_pk='Pakistan',\n\t\tCC_pw='Palau',\n\t\tCC_ps='Palestinian Territory, Occupied',\n\t\tCC_pa='Panama',\n\t\tCC_pg='Papua New Guinea',\n\t\tCC_py='Paraguay',\n\t\tCC_pe='Peru',\n\t\tCC_ph='Philippines',\n\t\tCC_pn='Pitcairn',\n\t\tCC_pl='Poland',\n\t\tCC_pt='Portugal',\n\t\tCC_pr='Puerto Rico',\n\t\tCC_qa='Qatar',\n\t\tCC_re='R\u00e9union',\n\t\tCC_ro='Romania',\n\t\tCC_ru='Russian Federation',\n\t\tCC_rw='Rwanda',\n\t\tCC_bl='Saint Barth\u00e9lemy',\n\t\tCC_sh='Saint Helena, Ascension and Tristan da Cunha',\n\t\tCC_kn='Saint Kitts and Nevis',\n\t\tCC_lc='Saint Lucia',\n\t\tCC_mf='Saint Martin (French Part)',\n\t\tCC_pm='Saint Pierre and Miquelon',\n\t\tCC_vc='Saint Vincent and The Grenadines',\n\t\tCC_ws='Samoa',\n\t\tCC_sm='San Marino',\n\t\tCC_st='Sao Tome and Principe',\n\t\tCC_sa='Saudi Arabia',\n\t\tCC_sn='Senegal',\n\t\tCC_rs='Serbia',\n\t\tCC_sc='Seychelles',\n\t\tCC_sl='Sierra Leone',\n\t\tCC_sg='Singapore',\n\t\tCC_sk='Slovakia',\n\t\tCC_sx='Sint Maarten (Dutch Part)',\n\t\tCC_si='Slovenia',\n\t\tCC_sb='Solomon Islands',\n\t\tCC_so='Somalia',\n\t\tCC_za='South Africa',\n\t\tCC_gs='South Georgia and The South Sandwich Islands',\n\t\tCC_ss='South Sudan',\n\t\tCC_es='Spain',\n\t\tCC_lk='Sri Lanka',\n\t\tCC_sd='Sudan',\n\t\tCC_sr='Suriname',\n\t\tCC_sj='Svalbard and Jan Mayen',\n\t\tCC_sz='Swaziland',\n\t\tCC_se='Sweden',\n\t\tCC_ch='Switzerland',\n\t\tCC_sy='Syrian Arab Republic',\n\t\tCC_tw='Taiwan, Province of China',\n\t\tCC_tj='Tajikistan',\n\t\tCC_tz='Tanzania, United Republic of',\n\t\tCC_th='Thailand',\n\t\tCC_tl='Timor-Leste',\n\t\tCC_tg='Togo',\n\t\tCC_tk='Tokelau',\n\t\tCC_to='Tonga',\n\t\tCC_tt='Trinidad and Tobago',\n\t\tCC_tn='Tunisia',\n\t\tCC_tr='Turkey',\n\t\tCC_tm='Turkmenistan',\n\t\tCC_tc='Turks and Caicos Islands',\n\t\tCC_tv='Tuvalu',\n\t\tCC_ug='Uganda',\n\t\tCC_ua='Ukraine',\n\t\tCC_ae='United Arab Emirates',\n\t\tCC_gb='United Kingdom',\n\t\tCC_us='United States',\n\t\tCC_um='United States Minor Outlying Islands',\n\t\tCC_uy='Uruguay',\n\t\tCC_uz='Uzbekistan',\n\t\tCC_vu='Vanuatu',\n\t\tCC_ve='Venezuela',\n\t\tCC_vn='Viet Nam',\n\t\tCC_vg='Virgin Islands, British',\n\t\tCC_vi='Virgin Islands, U.S.',\n\t\tCC_wf='Wallis and Futuna',\n\t\tCC_eh='Western Sahara',\n\t\tCC_ye='Yemen',\n\t\tCC_zm='Zambia',\n\t\tCC_zw='Zimbabwe';\n\t//@}\n\n\t//@{ ISO 639-1 language codes (Windows-compatibility subset)\n\tconst\n\t\tLC_af='Afrikaans',\n\t\tLC_am='Amharic',\n\t\tLC_ar='Arabic',\n\t\tLC_as='Assamese',\n\t\tLC_ba='Bashkir',\n\t\tLC_be='Belarusian',\n\t\tLC_bg='Bulgarian',\n\t\tLC_bn='Bengali',\n\t\tLC_bo='Tibetan',\n\t\tLC_br='Breton',\n\t\tLC_ca='Catalan',\n\t\tLC_co='Corsican',\n\t\tLC_cs='Czech',\n\t\tLC_cy='Welsh',\n\t\tLC_da='Danish',\n\t\tLC_de='German',\n\t\tLC_dv='Divehi',\n\t\tLC_el='Greek',\n\t\tLC_en='English',\n\t\tLC_es='Spanish',\n\t\tLC_et='Estonian',\n\t\tLC_eu='Basque',\n\t\tLC_fa='Persian',\n\t\tLC_fi='Finnish',\n\t\tLC_fo='Faroese',\n\t\tLC_fr='French',\n\t\tLC_gd='Scottish Gaelic',\n\t\tLC_gl='Galician',\n\t\tLC_gu='Gujarati',\n\t\tLC_he='Hebrew',\n\t\tLC_hi='Hindi',\n\t\tLC_hr='Croatian',\n\t\tLC_hu='Hungarian',\n\t\tLC_hy='Armenian',\n\t\tLC_id='Indonesian',\n\t\tLC_ig='Igbo',\n\t\tLC_is='Icelandic',\n\t\tLC_it='Italian',\n\t\tLC_ja='Japanese',\n\t\tLC_ka='Georgian',\n\t\tLC_kk='Kazakh',\n\t\tLC_km='Khmer',\n\t\tLC_kn='Kannada',\n\t\tLC_ko='Korean',\n\t\tLC_lb='Luxembourgish',\n\t\tLC_lo='Lao',\n\t\tLC_lt='Lithuanian',\n\t\tLC_lv='Latvian',\n\t\tLC_mi='Maori',\n\t\tLC_ml='Malayalam',\n\t\tLC_mr='Marathi',\n\t\tLC_ms='Malay',\n\t\tLC_mt='Maltese',\n\t\tLC_ne='Nepali',\n\t\tLC_nl='Dutch',\n\t\tLC_no='Norwegian',\n\t\tLC_oc='Occitan',\n\t\tLC_or='Oriya',\n\t\tLC_pl='Polish',\n\t\tLC_ps='Pashto',\n\t\tLC_pt='Portuguese',\n\t\tLC_qu='Quechua',\n\t\tLC_ro='Romanian',\n\t\tLC_ru='Russian',\n\t\tLC_rw='Kinyarwanda',\n\t\tLC_sa='Sanskrit',\n\t\tLC_si='Sinhala',\n\t\tLC_sk='Slovak',\n\t\tLC_sl='Slovenian',\n\t\tLC_sq='Albanian',\n\t\tLC_sv='Swedish',\n\t\tLC_ta='Tamil',\n\t\tLC_te='Telugu',\n\t\tLC_th='Thai',\n\t\tLC_tk='Turkmen',\n\t\tLC_tr='Turkish',\n\t\tLC_tt='Tatar',\n\t\tLC_uk='Ukrainian',\n\t\tLC_ur='Urdu',\n\t\tLC_vi='Vietnamese',\n\t\tLC_wo='Wolof',\n\t\tLC_yo='Yoruba',\n\t\tLC_zh='Chinese';\n\t//@}\n\n\t/**\n\t*\tReturn list of languages indexed by ISO 639-1 language code\n\t*\t@return array\n\t**/\n\tfunction languages() {\n\t\treturn \\Base::instance()->constants($this,'LC_');\n\t}\n\n\t/**\n\t*\tReturn list of countries indexed by ISO 3166-1 country code\n\t*\t@return array\n\t**/\n\tfunction countries() {\n\t\treturn \\Base::instance()->constants($this,'CC_');\n\t}\n\n}\n\n//! Container for singular object instances\nfinal class Registry {\n\n\tprivate static\n\t\t//! Object catalog\n\t\t$table;\n\n\t/**\n\t*\tReturn TRUE if object exists in catalog\n\t*\t@return bool\n\t*\t@param $key string\n\t**/\n\tstatic function exists($key) {\n\t\treturn isset(self::$table[$key]);\n\t}\n\n\t/**\n\t*\tAdd object to catalog\n\t*\t@return object\n\t*\t@param $key string\n\t*\t@param $obj object\n\t**/\n\tstatic function set($key,$obj) {\n\t\treturn self::$table[$key]=$obj;\n\t}\n\n\t/**\n\t*\tRetrieve object from catalog\n\t*\t@return object\n\t*\t@param $key string\n\t**/\n\tstatic function get($key) {\n\t\treturn self::$table[$key];\n\t}\n\n\t/**\n\t*\tDelete object from catalog\n\t*\t@param $key string\n\t**/\n\tstatic function clear($key) {\n\t\tself::$table[$key]=NULL;\n\t\tunset(self::$table[$key]);\n\t}\n\n\t//! Prohibit cloning\n\tprivate function __clone() {\n\t}\n\n\t//! Prohibit instantiation\n\tprivate function __construct() {\n\t}\n\n}\n\nreturn Base::instance();\n"], "filenames": ["base.php"], "buggy_code_start_loc": [505], "buggy_code_end_loc": [2973], "fixing_code_start_loc": [506], "fixing_code_end_loc": [2973], "type": "CWE-20", "message": "In Fat-Free Framework 3.7.1, attackers can achieve arbitrary code execution if developers choose to pass user controlled input (e.g., $_REQUEST, $_GET, or $_POST) to the framework's Clear method.", "other": {"cve": {"id": "CVE-2020-5203", "sourceIdentifier": "cve@mitre.org", "published": "2020-03-11T14:15:14.623", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Fat-Free Framework 3.7.1, attackers can achieve arbitrary code execution if developers choose to pass user controlled input (e.g., $_REQUEST, $_GET, or $_POST) to the framework's Clear method."}, {"lang": "es", "value": "En Fat-Free Framework versi\u00f3n 3.7.1, atacantes pueden lograr una ejecuci\u00f3n de c\u00f3digo arbitraria si los desarrolladores eligen pasar una entrada controlada por el usuario (por ejemplo, $_REQUEST, $_GET, o $_POST) hacia el m\u00e9todo Clear del framework."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fatfreeframework:fat-free_framework:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "FDF0750A-26A2-4FC7-89CB-ADCBB9C35982"}]}]}], "references": [{"url": "https://github.com/bcosca/fatfree-core/commit/dae95a0baf3963a9ef87c17cee52f78f77e21829", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bcosca/fatfree/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bcosca/fatfree-core/commit/dae95a0baf3963a9ef87c17cee52f78f77e21829"}}