{"buggy_code": ["// This is a port of the test suite:\n// hungry/js/test/parse_file_test.js\n\n'use strict';\n\nconst { FilesController } = require('../lib/Controllers/FilesController');\nconst request = require('../lib/request');\n\nconst str = 'Hello World!';\nconst data = [];\nfor (let i = 0; i < str.length; i++) {\n  data.push(str.charCodeAt(i));\n}\n\ndescribe('Parse.File testing', () => {\n  describe('creating files', () => {\n    it('works with Content-Type', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('works with _ContentType', done => {\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/files/file',\n        body: JSON.stringify({\n          _ApplicationId: 'test',\n          _JavaScriptKey: 'test',\n          _ContentType: 'text/html',\n          base64: 'PGh0bWw+PC9odG1sPgo=',\n        }),\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.html/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.html$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          try {\n            expect(response.headers['content-type']).toMatch('^text/html');\n            expect(body).toEqual('<html></html>\\n');\n          } catch (e) {\n            jfail(e);\n          }\n          done();\n        });\n      });\n    });\n\n    it('works without Content-Type', done => {\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({ url: b.url }).then(response => {\n          expect(response.text).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('supports REST end-to-end file create, read, delete, read', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/testfile.txt',\n        body: 'check one two',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_testfile.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*testfile.txt$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('check one two');\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'test',\n            },\n            url: 'http://localhost:8378/1/files/' + b.name,\n          }).then(response => {\n            expect(response.status).toEqual(200);\n            request({\n              headers: {\n                'X-Parse-Application-Id': 'test',\n                'X-Parse-REST-API-Key': 'rest',\n              },\n              url: b.url,\n            }).then(fail, response => {\n              expect(response.status).toEqual(404);\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('blocks file deletions with missing or incorrect master-key header', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/thefile.jpg',\n        body: 'the file body',\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*thefile.jpg$/);\n        // missing X-Parse-Master-Key header\n        request({\n          method: 'DELETE',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/files/' + b.name,\n        }).then(fail, response => {\n          const del_b = response.data;\n          expect(response.status).toEqual(403);\n          expect(del_b.error).toMatch(/unauthorized/);\n          // incorrect X-Parse-Master-Key header\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'tryagain',\n            },\n            url: 'http://localhost:8378/1/files/' + b.name,\n          }).then(fail, response => {\n            const del_b2 = response.data;\n            expect(response.status).toEqual(403);\n            expect(del_b2.error).toMatch(/unauthorized/);\n            done();\n          });\n        });\n      });\n    });\n\n    it('handles other filetypes', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.jpg',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.jpg$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/.*file.jpg$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('save file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n    });\n\n    it('saves the file with tags', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      const tags = { hello: 'world' };\n      file.setTags(tags);\n      expect(file.url()).toBeUndefined();\n      const result = await file.save();\n      expect(file.name()).toBeDefined();\n      expect(file.url()).toBeDefined();\n      expect(result.tags()).toEqual(tags);\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        tags: tags,\n        metadata: {},\n      });\n    });\n\n    it('does not pass empty file tags while saving', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      expect(file.url()).toBeUndefined();\n      expect(file.name()).toBeDefined();\n      await file.save();\n      expect(file.url()).toBeDefined();\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        metadata: {},\n      });\n    });\n\n    it('save file in object', async done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n\n      const object = new Parse.Object('TestObject');\n      await object.save({ file: file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n      done();\n    });\n\n    it('save file in object with escaped characters in filename', async () => {\n      const file = new Parse.File('hello . txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello . txt');\n\n      const object = new Parse.Object('TestObject');\n      await object.save({ file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n    });\n\n    it('autosave file in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({ file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      file = objectAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });\n\n    it('autosave file in object in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n\n      const child = new Parse.Object('Child');\n      child.set('file', file);\n\n      const parent = new Parse.Object('Parent');\n      parent.set('child', child);\n\n      await parent.save();\n      const query = new Parse.Query('Parent');\n      query.include('child');\n      const parentAgain = await query.get(parent.id);\n      const childAgain = parentAgain.get('child');\n      file = childAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });\n\n    it('saving an already saved file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      const previousName = file.name();\n\n      await file.save();\n      equal(file.name(), previousName);\n    });\n\n    it('two saves at the same time', done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n\n      let firstName;\n      let secondName;\n\n      const firstSave = file.save().then(function () {\n        firstName = file.name();\n      });\n      const secondSave = file.save().then(function () {\n        secondName = file.name();\n      });\n\n      Promise.all([firstSave, secondSave]).then(\n        function () {\n          equal(firstName, secondName);\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n    });\n\n    it('file toJSON testing', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({\n        file: file,\n      });\n      ok(object.toJSON().file.url);\n    });\n\n    it('content-type used with no extension', done => {\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file',\n        body: 'fee fi fo',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/\\.html$/);\n        request({ url: b.url }).then(response => {\n          expect(response.headers['content-type']).toMatch(/^text\\/html/);\n          done();\n        });\n      });\n    });\n\n    it('filename is url encoded', done => {\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/hello world.txt',\n        body: 'oh emm gee',\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/hello%20world/);\n        done();\n      });\n    });\n\n    it('supports array of files', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep',\n      };\n      const files = [file, file];\n      const obj = new Parse.Object('FilesArrayTest');\n      obj.set('files', files);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FilesArrayTest');\n          return query.first();\n        })\n        .then(result => {\n          const filesAgain = result.get('files');\n          expect(filesAgain.length).toEqual(2);\n          expect(filesAgain[0].name()).toEqual('meep');\n          expect(filesAgain[0].url()).toEqual('http://meep.meep');\n          done();\n        });\n    });\n\n    it('validates filename characters', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/di$avowed.txt',\n        body: 'will fail',\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });\n\n    it('validates filename length', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const fileName =\n        'Onceuponamidnightdrearywhileiponderedweak' +\n        'andwearyOveramanyquaintandcuriousvolumeof' +\n        'forgottenloreWhileinoddednearlynappingsud' +\n        'denlytherecameatapping';\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/' + fileName,\n        body: 'will fail',\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });\n\n    it('supports a dictionary with file', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep',\n      };\n      const dict = {\n        file: file,\n      };\n      const obj = new Parse.Object('FileObjTest');\n      obj.set('obj', dict);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FileObjTest');\n          return query.first();\n        })\n        .then(result => {\n          const dictAgain = result.get('obj');\n          expect(typeof dictAgain).toEqual('object');\n          const fileAgain = dictAgain['file'];\n          expect(fileAgain.name()).toEqual('meep');\n          expect(fileAgain.url()).toEqual('http://meep.meep');\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('creates correct url for old files hosted on files.parsetfss.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'tfss-123.txt',\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('OldFileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('oldfile');\n          expect(fileAgain.url()).toEqual('http://files.parsetfss.com/test/tfss-123.txt');\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('creates correct url for old files hosted on files.parse.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'd6e80979-a128-4c57-a167-302f874700dc-123.txt',\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('OldFileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('oldfile');\n          expect(fileAgain.url()).toEqual(\n            'http://files.parse.com/test/d6e80979-a128-4c57-a167-302f874700dc-123.txt'\n          );\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('supports files in objects without urls', done => {\n      const file = {\n        __type: 'File',\n        name: '123.txt',\n      };\n      const obj = new Parse.Object('FileTest');\n      obj.set('file', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('file');\n          expect(fileAgain.url()).toMatch(/123.txt$/);\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('return with publicServerURL when provided', done => {\n      reconfigureServer({\n        publicServerURL: 'https://mydomain/parse',\n      })\n        .then(() => {\n          const file = {\n            __type: 'File',\n            name: '123.txt',\n          };\n          const obj = new Parse.Object('FileTest');\n          obj.set('file', file);\n          return obj.save();\n        })\n        .then(() => {\n          const query = new Parse.Query('FileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('file');\n          expect(fileAgain.url().indexOf('https://mydomain/parse')).toBe(0);\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('fails to upload an empty file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: '',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":130,\"error\":\"Invalid file upload.\"}');\n        done();\n      });\n    });\n\n    it('fails to upload without a file name', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/',\n        body: 'yolo',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":122,\"error\":\"Filename not provided.\"}');\n        done();\n      });\n    });\n  });\n\n  describe('deleting files', () => {\n    it('fails to delete an unkown file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Master-Key': 'test',\n      };\n      request({\n        method: 'DELETE',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(typeof body).toBe('string');\n        const { code, error } = JSON.parse(body);\n        expect(code).toBe(153);\n        expect(typeof error).toBe('string');\n        expect(error.length).toBeGreaterThan(0);\n        done();\n      });\n    });\n  });\n\n  xdescribe('Gridstore Range tests', () => {\n    it('supports range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle ');\n          done();\n        });\n      });\n    });\n\n    it('supports small range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-2',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('arg');\n          done();\n        });\n      });\n    });\n\n    // See specs https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    it('supports getting one byte', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=2-2',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('g');\n          done();\n        });\n      });\n    });\n\n    xit('supports getting last n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=-4',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toBe(4);\n          expect(body).toEqual('rent');\n          done();\n        });\n      });\n    });\n\n    it('supports getting first n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=10-',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('different');\n          done();\n        });\n      });\n    });\n\n    function repeat(string, count) {\n      let s = string;\n      while (count > 0) {\n        s += string;\n        count--;\n      }\n      return s;\n    }\n\n    it('supports large range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: repeat('argle bargle', 100),\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=13-240',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toEqual(228);\n          expect(body.indexOf('rgle barglea')).toBe(0);\n          done();\n        });\n      });\n    });\n\n    it('fails to stream unknown file', done => {\n      request({\n        url: 'http://localhost:8378/1/files/test/file.txt',\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest',\n          Range: 'bytes=13-240',\n        },\n      }).then(response => {\n        expect(response.status).toBe(404);\n        const body = response.text;\n        expect(body).toEqual('File not found.');\n        done();\n      });\n    });\n  });\n\n  // Because GridStore is not loaded on PG, those are perfect\n  // for fallback tests\n  describe_only_db('postgres')('Default Range tests', () => {\n    it('fallback to regular request', async done => {\n      await reconfigureServer();\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n  });\n\n  describe('file upload configuration', () => {\n    it('allows file upload only for authenticated user by default', async () => {\n      await reconfigureServer({\n        fileUpload: {},\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('allows file upload with master key', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save({ useMasterKey: true })).toBeResolved();\n    });\n\n    it('rejects all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: true,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('allows file upload only for public', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows file upload only for anonymous user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows file upload only for authenticated user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: true,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('rejects invalid fileUpload configuration', async () => {\n      const invalidConfigs = [\n        { fileUpload: undefined },\n        { fileUpload: null },\n        { fileUpload: [] },\n        { fileUpload: 1 },\n        { fileUpload: 'string' },\n      ];\n      const validConfigs = [{ fileUpload: {} }];\n      const keys = ['enableForPublic', 'enableForAnonymousUser', 'enableForAuthenticatedUser'];\n      const invalidValues = [[], {}, 1, 'string', null];\n      const validValues = [undefined, true, false];\n      for (const config of invalidConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeRejectedWith(\n          'fileUpload must be an object value.'\n        );\n      }\n      for (const config of validConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeResolved();\n      }\n      for (const key of keys) {\n        for (const value of invalidValues) {\n          await expectAsync(reconfigureServer({ fileUpload: { [key]: value } })).toBeRejectedWith(\n            `fileUpload.${key} must be a boolean value.`\n          );\n        }\n        for (const value of validValues) {\n          await expectAsync(reconfigureServer({ fileUpload: { [key]: value } })).toBeResolved();\n        }\n      }\n    });\n  });\n});\n", "import express from 'express';\nimport BodyParser from 'body-parser';\nimport * as Middlewares from '../middlewares';\nimport Parse from 'parse/node';\nimport Config from '../Config';\nimport mime from 'mime';\nimport logger from '../logger';\nconst triggers = require('../triggers');\nconst http = require('http');\n\nconst downloadFileFromURI = uri => {\n  return new Promise((res, rej) => {\n    http\n      .get(uri, response => {\n        response.setDefaultEncoding('base64');\n        let body = `data:${response.headers['content-type']};base64,`;\n        response.on('data', data => (body += data));\n        response.on('end', () => res(body));\n      })\n      .on('error', e => {\n        rej(`Error downloading file from ${uri}: ${e.message}`);\n      });\n  });\n};\n\nconst addFileDataIfNeeded = async file => {\n  if (file._source.format === 'uri') {\n    const base64 = await downloadFileFromURI(file._source.uri);\n    file._previousSave = file;\n    file._data = base64;\n    file._requestTask = null;\n  }\n  return file;\n};\n\nexport class FilesRouter {\n  expressRouter({ maxUploadSize = '20Mb' } = {}) {\n    var router = express.Router();\n    router.get('/files/:appId/:filename', this.getHandler);\n    router.get('/files/:appId/metadata/:filename', this.metadataHandler);\n\n    router.post('/files', function (req, res, next) {\n      next(new Parse.Error(Parse.Error.INVALID_FILE_NAME, 'Filename not provided.'));\n    });\n\n    router.post(\n      '/files/:filename',\n      BodyParser.raw({\n        type: () => {\n          return true;\n        },\n        limit: maxUploadSize,\n      }), // Allow uploads without Content-Type, or with any Content-Type.\n      Middlewares.handleParseHeaders,\n      this.createHandler\n    );\n\n    router.delete(\n      '/files/:filename',\n      Middlewares.handleParseHeaders,\n      Middlewares.enforceMasterKeyAccess,\n      this.deleteHandler\n    );\n    return router;\n  }\n\n  getHandler(req, res) {\n    const config = Config.get(req.params.appId);\n    const filesController = config.filesController;\n    const filename = req.params.filename;\n    const contentType = mime.getType(filename);\n    if (isFileStreamable(req, filesController)) {\n      filesController.handleFileStream(config, filename, req, res, contentType).catch(() => {\n        res.status(404);\n        res.set('Content-Type', 'text/plain');\n        res.end('File not found.');\n      });\n    } else {\n      filesController\n        .getFileData(config, filename)\n        .then(data => {\n          res.status(200);\n          res.set('Content-Type', contentType);\n          res.set('Content-Length', data.length);\n          res.end(data);\n        })\n        .catch(() => {\n          res.status(404);\n          res.set('Content-Type', 'text/plain');\n          res.end('File not found.');\n        });\n    }\n  }\n\n  async createHandler(req, res, next) {\n    const config = req.config;\n    const user = req.auth.user;\n    const isMaster = req.auth.isMaster;\n    const isLinked = user && Parse.AnonymousUtils.isLinked(user);\n    if (!isMaster && !config.fileUpload.enableForAnonymousUser && isLinked) {\n      next(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForAuthenticatedUser && !isLinked && user) {\n      next(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForPublic && !user) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      return;\n    }\n    const filesController = config.filesController;\n    const { filename } = req.params;\n    const contentType = req.get('Content-type');\n\n    if (!req.body || !req.body.length) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'Invalid file upload.'));\n      return;\n    }\n\n    const error = filesController.validateFilename(filename);\n    if (error) {\n      next(error);\n      return;\n    }\n\n    const base64 = req.body.toString('base64');\n    const file = new Parse.File(filename, { base64 }, contentType);\n    const { metadata = {}, tags = {} } = req.fileData || {};\n    file.setTags(tags);\n    file.setMetadata(metadata);\n    const fileSize = Buffer.byteLength(req.body);\n    const fileObject = { file, fileSize };\n    try {\n      // run beforeSaveFile trigger\n      const triggerResult = await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeSaveFile,\n        fileObject,\n        config,\n        req.auth\n      );\n      let saveResult;\n      // if a new ParseFile is returned check if it's an already saved file\n      if (triggerResult instanceof Parse.File) {\n        fileObject.file = triggerResult;\n        if (triggerResult.url()) {\n          // set fileSize to null because we wont know how big it is here\n          fileObject.fileSize = null;\n          saveResult = {\n            url: triggerResult.url(),\n            name: triggerResult._name,\n          };\n        }\n      }\n      // if the file returned by the trigger has already been saved skip saving anything\n      if (!saveResult) {\n        // if the ParseFile returned is type uri, download the file before saving it\n        await addFileDataIfNeeded(fileObject.file);\n        // update fileSize\n        const bufferData = Buffer.from(fileObject.file._data, 'base64');\n        fileObject.fileSize = Buffer.byteLength(bufferData);\n        // prepare file options\n        const fileOptions = {\n          metadata: fileObject.file._metadata,\n        };\n        // some s3-compatible providers (DigitalOcean, Linode) do not accept tags\n        // so we do not include the tags option if it is empty.\n        const fileTags =\n          Object.keys(fileObject.file._tags).length > 0 ? { tags: fileObject.file._tags } : {};\n        Object.assign(fileOptions, fileTags);\n        // save file\n        const createFileResult = await filesController.createFile(\n          config,\n          fileObject.file._name,\n          bufferData,\n          fileObject.file._source.type,\n          fileOptions\n        );\n        // update file with new data\n        fileObject.file._name = createFileResult.name;\n        fileObject.file._url = createFileResult.url;\n        fileObject.file._requestTask = null;\n        fileObject.file._previousSave = Promise.resolve(fileObject.file);\n        saveResult = {\n          url: createFileResult.url,\n          name: createFileResult.name,\n        };\n      }\n      // run afterSaveFile trigger\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.afterSaveFile,\n        fileObject,\n        config,\n        req.auth\n      );\n      res.status(201);\n      res.set('Location', saveResult.url);\n      res.json(saveResult);\n    } catch (e) {\n      logger.error('Error creating a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_SAVE_ERROR,\n        message: `Could not store file: ${fileObject.file._name}.`,\n      });\n      next(error);\n    }\n  }\n\n  async deleteHandler(req, res, next) {\n    try {\n      const { filesController } = req.config;\n      const { filename } = req.params;\n      // run beforeDeleteFile trigger\n      const file = new Parse.File(filename);\n      file._url = filesController.adapter.getFileLocation(req.config, filename);\n      const fileObject = { file, fileSize: null };\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeDeleteFile,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      // delete file\n      await filesController.deleteFile(req.config, filename);\n      // run afterDeleteFile trigger\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.afterDeleteFile,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      res.status(200);\n      // TODO: return useful JSON here?\n      res.end();\n    } catch (e) {\n      logger.error('Error deleting a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_DELETE_ERROR,\n        message: 'Could not delete file.',\n      });\n      next(error);\n    }\n  }\n\n  async metadataHandler(req, res) {\n    const config = Config.get(req.params.appId);\n    const { filesController } = config;\n    const { filename } = req.params;\n    try {\n      const data = await filesController.getMetadata(filename);\n      res.status(200);\n      res.json(data);\n    } catch (e) {\n      res.status(200);\n      res.json({});\n    }\n  }\n}\n\nfunction isFileStreamable(req, filesController) {\n  return req.get('Range') && typeof filesController.adapter.handleFileStream === 'function';\n}\n"], "fixing_code": ["// This is a port of the test suite:\n// hungry/js/test/parse_file_test.js\n\n'use strict';\n\nconst { FilesController } = require('../lib/Controllers/FilesController');\nconst request = require('../lib/request');\n\nconst str = 'Hello World!';\nconst data = [];\nfor (let i = 0; i < str.length; i++) {\n  data.push(str.charCodeAt(i));\n}\n\ndescribe('Parse.File testing', () => {\n  describe('creating files', () => {\n    it('works with Content-Type', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('works with _ContentType', done => {\n      request({\n        method: 'POST',\n        url: 'http://localhost:8378/1/files/file',\n        body: JSON.stringify({\n          _ApplicationId: 'test',\n          _JavaScriptKey: 'test',\n          _ContentType: 'text/html',\n          base64: 'PGh0bWw+PC9odG1sPgo=',\n        }),\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.html/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.html$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          try {\n            expect(response.headers['content-type']).toMatch('^text/html');\n            expect(body).toEqual('<html></html>\\n');\n          } catch (e) {\n            jfail(e);\n          }\n          done();\n        });\n      });\n    });\n\n    it('works without Content-Type', done => {\n      const headers = {\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*file.txt$/);\n        request({ url: b.url }).then(response => {\n          expect(response.text).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('supports REST end-to-end file create, read, delete, read', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/testfile.txt',\n        body: 'check one two',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_testfile.txt$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*testfile.txt$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('check one two');\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'test',\n            },\n            url: 'http://localhost:8378/1/files/' + b.name,\n          }).then(response => {\n            expect(response.status).toEqual(200);\n            request({\n              headers: {\n                'X-Parse-Application-Id': 'test',\n                'X-Parse-REST-API-Key': 'rest',\n              },\n              url: b.url,\n            }).then(fail, response => {\n              expect(response.status).toEqual(404);\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    it('blocks file deletions with missing or incorrect master-key header', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/thefile.jpg',\n        body: 'the file body',\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/test\\/.*thefile.jpg$/);\n        // missing X-Parse-Master-Key header\n        request({\n          method: 'DELETE',\n          headers: {\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n          },\n          url: 'http://localhost:8378/1/files/' + b.name,\n        }).then(fail, response => {\n          const del_b = response.data;\n          expect(response.status).toEqual(403);\n          expect(del_b.error).toMatch(/unauthorized/);\n          // incorrect X-Parse-Master-Key header\n          request({\n            method: 'DELETE',\n            headers: {\n              'X-Parse-Application-Id': 'test',\n              'X-Parse-REST-API-Key': 'rest',\n              'X-Parse-Master-Key': 'tryagain',\n            },\n            url: 'http://localhost:8378/1/files/' + b.name,\n          }).then(fail, response => {\n            const del_b2 = response.data;\n            expect(response.status).toEqual(403);\n            expect(del_b2.error).toMatch(/unauthorized/);\n            done();\n          });\n        });\n      });\n    });\n\n    it('handles other filetypes', done => {\n      const headers = {\n        'Content-Type': 'image/jpeg',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.jpg',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/_file.jpg$/);\n        expect(b.url).toMatch(/^http:\\/\\/localhost:8378\\/1\\/files\\/.*file.jpg$/);\n        request({ url: b.url }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n\n    it('save file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n    });\n\n    it('saves the file with tags', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      const tags = { hello: 'world' };\n      file.setTags(tags);\n      expect(file.url()).toBeUndefined();\n      const result = await file.save();\n      expect(file.name()).toBeDefined();\n      expect(file.url()).toBeDefined();\n      expect(result.tags()).toEqual(tags);\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        tags: tags,\n        metadata: {},\n      });\n    });\n\n    it('does not pass empty file tags while saving', async () => {\n      spyOn(FilesController.prototype, 'createFile').and.callThrough();\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      expect(file.url()).toBeUndefined();\n      expect(file.name()).toBeDefined();\n      await file.save();\n      expect(file.url()).toBeDefined();\n      expect(FilesController.prototype.createFile.calls.argsFor(0)[4]).toEqual({\n        metadata: {},\n      });\n    });\n\n    it('save file in object', async done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n\n      const object = new Parse.Object('TestObject');\n      await object.save({ file: file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n      done();\n    });\n\n    it('save file in object with escaped characters in filename', async () => {\n      const file = new Parse.File('hello . txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello . txt');\n\n      const object = new Parse.Object('TestObject');\n      await object.save({ file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      ok(objectAgain.get('file') instanceof Parse.File);\n    });\n\n    it('autosave file in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({ file });\n      const objectAgain = await new Parse.Query('TestObject').get(object.id);\n      file = objectAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });\n\n    it('autosave file in object in object', async done => {\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n\n      const child = new Parse.Object('Child');\n      child.set('file', file);\n\n      const parent = new Parse.Object('Parent');\n      parent.set('child', child);\n\n      await parent.save();\n      const query = new Parse.Query('Parent');\n      query.include('child');\n      const parentAgain = await query.get(parent.id);\n      const childAgain = parentAgain.get('child');\n      file = childAgain.get('file');\n      ok(file instanceof Parse.File);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      done();\n    });\n\n    it('saving an already saved file', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const result = await file.save();\n      strictEqual(result, file);\n      ok(file.name());\n      ok(file.url());\n      notEqual(file.name(), 'hello.txt');\n      const previousName = file.name();\n\n      await file.save();\n      equal(file.name(), previousName);\n    });\n\n    it('two saves at the same time', done => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n\n      let firstName;\n      let secondName;\n\n      const firstSave = file.save().then(function () {\n        firstName = file.name();\n      });\n      const secondSave = file.save().then(function () {\n        secondName = file.name();\n      });\n\n      Promise.all([firstSave, secondSave]).then(\n        function () {\n          equal(firstName, secondName);\n          done();\n        },\n        function (error) {\n          ok(false, error);\n          done();\n        }\n      );\n    });\n\n    it('file toJSON testing', async () => {\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      ok(!file.url());\n      const object = new Parse.Object('TestObject');\n      await object.save({\n        file: file,\n      });\n      ok(object.toJSON().file.url);\n    });\n\n    it('content-type used with no extension', done => {\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file',\n        body: 'fee fi fo',\n      }).then(response => {\n        const b = response.data;\n        expect(b.name).toMatch(/\\.html$/);\n        request({ url: b.url }).then(response => {\n          expect(response.headers['content-type']).toMatch(/^text\\/html/);\n          done();\n        });\n      });\n    });\n\n    it('filename is url encoded', done => {\n      const headers = {\n        'Content-Type': 'text/html',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/hello world.txt',\n        body: 'oh emm gee',\n      }).then(response => {\n        const b = response.data;\n        expect(b.url).toMatch(/hello%20world/);\n        done();\n      });\n    });\n\n    it('supports array of files', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep',\n      };\n      const files = [file, file];\n      const obj = new Parse.Object('FilesArrayTest');\n      obj.set('files', files);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FilesArrayTest');\n          return query.first();\n        })\n        .then(result => {\n          const filesAgain = result.get('files');\n          expect(filesAgain.length).toEqual(2);\n          expect(filesAgain[0].name()).toEqual('meep');\n          expect(filesAgain[0].url()).toEqual('http://meep.meep');\n          done();\n        });\n    });\n\n    it('validates filename characters', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/di$avowed.txt',\n        body: 'will fail',\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });\n\n    it('validates filename length', done => {\n      const headers = {\n        'Content-Type': 'text/plain',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const fileName =\n        'Onceuponamidnightdrearywhileiponderedweak' +\n        'andwearyOveramanyquaintandcuriousvolumeof' +\n        'forgottenloreWhileinoddednearlynappingsud' +\n        'denlytherecameatapping';\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/' + fileName,\n        body: 'will fail',\n      }).then(fail, response => {\n        const b = response.data;\n        expect(b.code).toEqual(122);\n        done();\n      });\n    });\n\n    it('supports a dictionary with file', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://meep.meep',\n        name: 'meep',\n      };\n      const dict = {\n        file: file,\n      };\n      const obj = new Parse.Object('FileObjTest');\n      obj.set('obj', dict);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FileObjTest');\n          return query.first();\n        })\n        .then(result => {\n          const dictAgain = result.get('obj');\n          expect(typeof dictAgain).toEqual('object');\n          const fileAgain = dictAgain['file'];\n          expect(fileAgain.name()).toEqual('meep');\n          expect(fileAgain.url()).toEqual('http://meep.meep');\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('creates correct url for old files hosted on files.parsetfss.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'tfss-123.txt',\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('OldFileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('oldfile');\n          expect(fileAgain.url()).toEqual('http://files.parsetfss.com/test/tfss-123.txt');\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('creates correct url for old files hosted on files.parse.com', done => {\n      const file = {\n        __type: 'File',\n        url: 'http://irrelevant.elephant/',\n        name: 'd6e80979-a128-4c57-a167-302f874700dc-123.txt',\n      };\n      const obj = new Parse.Object('OldFileTest');\n      obj.set('oldfile', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('OldFileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('oldfile');\n          expect(fileAgain.url()).toEqual(\n            'http://files.parse.com/test/d6e80979-a128-4c57-a167-302f874700dc-123.txt'\n          );\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('supports files in objects without urls', done => {\n      const file = {\n        __type: 'File',\n        name: '123.txt',\n      };\n      const obj = new Parse.Object('FileTest');\n      obj.set('file', file);\n      obj\n        .save()\n        .then(() => {\n          const query = new Parse.Query('FileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('file');\n          expect(fileAgain.url()).toMatch(/123.txt$/);\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('return with publicServerURL when provided', done => {\n      reconfigureServer({\n        publicServerURL: 'https://mydomain/parse',\n      })\n        .then(() => {\n          const file = {\n            __type: 'File',\n            name: '123.txt',\n          };\n          const obj = new Parse.Object('FileTest');\n          obj.set('file', file);\n          return obj.save();\n        })\n        .then(() => {\n          const query = new Parse.Query('FileTest');\n          return query.first();\n        })\n        .then(result => {\n          const fileAgain = result.get('file');\n          expect(fileAgain.url().indexOf('https://mydomain/parse')).toBe(0);\n          done();\n        })\n        .catch(e => {\n          jfail(e);\n          done();\n        });\n    });\n\n    it('fails to upload an empty file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: '',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":130,\"error\":\"Invalid file upload.\"}');\n        done();\n      });\n    });\n\n    it('fails to upload without a file name', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/',\n        body: 'yolo',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(body).toEqual('{\"code\":122,\"error\":\"Filename not provided.\"}');\n        done();\n      });\n    });\n  });\n\n  describe('deleting files', () => {\n    it('fails to delete an unkown file', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n        'X-Parse-Master-Key': 'test',\n      };\n      request({\n        method: 'DELETE',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n      }).then(fail, response => {\n        expect(response.status).toBe(400);\n        const body = response.text;\n        expect(typeof body).toBe('string');\n        const { code, error } = JSON.parse(body);\n        expect(code).toBe(153);\n        expect(typeof error).toBe('string');\n        expect(error.length).toBeGreaterThan(0);\n        done();\n      });\n    });\n  });\n\n  describe('getting files', () => {\n    it('does not crash on file request with invalid app ID', async () => {\n      const res1 = await request({\n        url: 'http://localhost:8378/1/files/invalid-id/invalid-file.txt',\n      }).catch(e => e);\n      expect(res1.status).toBe(403);\n      expect(res1.data).toEqual({ code: 119, error: 'Invalid application ID.' });\n      // Ensure server did not crash\n      const res2 = await request({ url: 'http://localhost:8378/1/health' });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({ status: 'ok' });\n    });\n\n    it('does not crash on file request with invalid path', async () => {\n      const res1 = await request({\n        url: 'http://localhost:8378/1/files/invalid-id//invalid-path/%20/invalid-file.txt',\n      }).catch(e => e);\n      expect(res1.status).toBe(403);\n      expect(res1.data).toEqual({ error: 'unauthorized' });\n      // Ensure server did not crash\n      const res2 = await request({ url: 'http://localhost:8378/1/health' });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({ status: 'ok' });\n    });\n\n    it('does not crash on file metadata request with invalid app ID', async () => {\n      const res1 = await request({\n        url: `http://localhost:8378/1/files/invalid-id/metadata/invalid-file.txt`,\n      });\n      expect(res1.status).toBe(200);\n      expect(res1.data).toEqual({});\n      // Ensure server did not crash\n      const res2 = await request({ url: 'http://localhost:8378/1/health' });\n      expect(res2.status).toEqual(200);\n      expect(res2.data).toEqual({ status: 'ok' });\n    });\n  });\n\n  xdescribe('Gridstore Range tests', () => {\n    it('supports range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle ');\n          done();\n        });\n      });\n    });\n\n    it('supports small range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-2',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('arg');\n          done();\n        });\n      });\n    });\n\n    // See specs https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-p5-range-latest.html#byte.ranges\n    it('supports getting one byte', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=2-2',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('g');\n          done();\n        });\n      });\n    });\n\n    xit('supports getting last n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=-4',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toBe(4);\n          expect(body).toEqual('rent');\n          done();\n        });\n      });\n    });\n\n    it('supports getting first n bytes', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'something different',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=10-',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('different');\n          done();\n        });\n      });\n    });\n\n    function repeat(string, count) {\n      let s = string;\n      while (count > 0) {\n        s += string;\n        count--;\n      }\n      return s;\n    }\n\n    it('supports large range requests', done => {\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: repeat('argle bargle', 100),\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=13-240',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body.length).toEqual(228);\n          expect(body.indexOf('rgle barglea')).toBe(0);\n          done();\n        });\n      });\n    });\n\n    it('fails to stream unknown file', done => {\n      request({\n        url: 'http://localhost:8378/1/files/test/file.txt',\n        headers: {\n          'Content-Type': 'application/octet-stream',\n          'X-Parse-Application-Id': 'test',\n          'X-Parse-REST-API-Key': 'rest',\n          Range: 'bytes=13-240',\n        },\n      }).then(response => {\n        expect(response.status).toBe(404);\n        const body = response.text;\n        expect(body).toEqual('File not found.');\n        done();\n      });\n    });\n  });\n\n  // Because GridStore is not loaded on PG, those are perfect\n  // for fallback tests\n  describe_only_db('postgres')('Default Range tests', () => {\n    it('fallback to regular request', async done => {\n      await reconfigureServer();\n      const headers = {\n        'Content-Type': 'application/octet-stream',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      request({\n        method: 'POST',\n        headers: headers,\n        url: 'http://localhost:8378/1/files/file.txt',\n        body: 'argle bargle',\n      }).then(response => {\n        const b = response.data;\n        request({\n          url: b.url,\n          headers: {\n            'Content-Type': 'application/octet-stream',\n            'X-Parse-Application-Id': 'test',\n            'X-Parse-REST-API-Key': 'rest',\n            Range: 'bytes=0-5',\n          },\n        }).then(response => {\n          const body = response.text;\n          expect(body).toEqual('argle bargle');\n          done();\n        });\n      });\n    });\n  });\n\n  describe('file upload configuration', () => {\n    it('allows file upload only for authenticated user by default', async () => {\n      await reconfigureServer({\n        fileUpload: {},\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('allows file upload with master key', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save({ useMasterKey: true })).toBeResolved();\n    });\n\n    it('rejects all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows all file uploads', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: true,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('allows file upload only for public', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: true,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows file upload only for anonymous user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: true,\n          enableForAuthenticatedUser: false,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeResolved();\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n    });\n\n    it('allows file upload only for authenticated user', async () => {\n      await reconfigureServer({\n        fileUpload: {\n          enableForPublic: false,\n          enableForAnonymousUser: false,\n          enableForAuthenticatedUser: true,\n        },\n      });\n      let file = new Parse.File('hello.txt', data, 'text/plain');\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const anonUser = await Parse.AnonymousUtils.logIn();\n      await expectAsync(file.save({ sessionToken: anonUser.getSessionToken() })).toBeRejectedWith(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      file = new Parse.File('hello.txt', data, 'text/plain');\n      const authUser = await Parse.User.signUp('user', 'password');\n      await expectAsync(file.save({ sessionToken: authUser.getSessionToken() })).toBeResolved();\n    });\n\n    it('rejects invalid fileUpload configuration', async () => {\n      const invalidConfigs = [\n        { fileUpload: undefined },\n        { fileUpload: null },\n        { fileUpload: [] },\n        { fileUpload: 1 },\n        { fileUpload: 'string' },\n      ];\n      const validConfigs = [{ fileUpload: {} }];\n      const keys = ['enableForPublic', 'enableForAnonymousUser', 'enableForAuthenticatedUser'];\n      const invalidValues = [[], {}, 1, 'string', null];\n      const validValues = [undefined, true, false];\n      for (const config of invalidConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeRejectedWith(\n          'fileUpload must be an object value.'\n        );\n      }\n      for (const config of validConfigs) {\n        await expectAsync(reconfigureServer(config)).toBeResolved();\n      }\n      for (const key of keys) {\n        for (const value of invalidValues) {\n          await expectAsync(reconfigureServer({ fileUpload: { [key]: value } })).toBeRejectedWith(\n            `fileUpload.${key} must be a boolean value.`\n          );\n        }\n        for (const value of validValues) {\n          await expectAsync(reconfigureServer({ fileUpload: { [key]: value } })).toBeResolved();\n        }\n      }\n    });\n  });\n});\n", "import express from 'express';\nimport BodyParser from 'body-parser';\nimport * as Middlewares from '../middlewares';\nimport Parse from 'parse/node';\nimport Config from '../Config';\nimport mime from 'mime';\nimport logger from '../logger';\nconst triggers = require('../triggers');\nconst http = require('http');\n\nconst downloadFileFromURI = uri => {\n  return new Promise((res, rej) => {\n    http\n      .get(uri, response => {\n        response.setDefaultEncoding('base64');\n        let body = `data:${response.headers['content-type']};base64,`;\n        response.on('data', data => (body += data));\n        response.on('end', () => res(body));\n      })\n      .on('error', e => {\n        rej(`Error downloading file from ${uri}: ${e.message}`);\n      });\n  });\n};\n\nconst addFileDataIfNeeded = async file => {\n  if (file._source.format === 'uri') {\n    const base64 = await downloadFileFromURI(file._source.uri);\n    file._previousSave = file;\n    file._data = base64;\n    file._requestTask = null;\n  }\n  return file;\n};\n\nexport class FilesRouter {\n  expressRouter({ maxUploadSize = '20Mb' } = {}) {\n    var router = express.Router();\n    router.get('/files/:appId/:filename', this.getHandler);\n    router.get('/files/:appId/metadata/:filename', this.metadataHandler);\n\n    router.post('/files', function (req, res, next) {\n      next(new Parse.Error(Parse.Error.INVALID_FILE_NAME, 'Filename not provided.'));\n    });\n\n    router.post(\n      '/files/:filename',\n      BodyParser.raw({\n        type: () => {\n          return true;\n        },\n        limit: maxUploadSize,\n      }), // Allow uploads without Content-Type, or with any Content-Type.\n      Middlewares.handleParseHeaders,\n      this.createHandler\n    );\n\n    router.delete(\n      '/files/:filename',\n      Middlewares.handleParseHeaders,\n      Middlewares.enforceMasterKeyAccess,\n      this.deleteHandler\n    );\n    return router;\n  }\n\n  getHandler(req, res) {\n    const config = Config.get(req.params.appId);\n    if (!config) {\n      res.status(403);\n      const err = new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Invalid application ID.');\n      res.json({ code: err.code, error: err.message });\n      return;\n    }\n    const filesController = config.filesController;\n    const filename = req.params.filename;\n    const contentType = mime.getType(filename);\n    if (isFileStreamable(req, filesController)) {\n      filesController.handleFileStream(config, filename, req, res, contentType).catch(() => {\n        res.status(404);\n        res.set('Content-Type', 'text/plain');\n        res.end('File not found.');\n      });\n    } else {\n      filesController\n        .getFileData(config, filename)\n        .then(data => {\n          res.status(200);\n          res.set('Content-Type', contentType);\n          res.set('Content-Length', data.length);\n          res.end(data);\n        })\n        .catch(() => {\n          res.status(404);\n          res.set('Content-Type', 'text/plain');\n          res.end('File not found.');\n        });\n    }\n  }\n\n  async createHandler(req, res, next) {\n    const config = req.config;\n    const user = req.auth.user;\n    const isMaster = req.auth.isMaster;\n    const isLinked = user && Parse.AnonymousUtils.isLinked(user);\n    if (!isMaster && !config.fileUpload.enableForAnonymousUser && isLinked) {\n      next(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForAuthenticatedUser && !isLinked && user) {\n      next(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForPublic && !user) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      return;\n    }\n    const filesController = config.filesController;\n    const { filename } = req.params;\n    const contentType = req.get('Content-type');\n\n    if (!req.body || !req.body.length) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'Invalid file upload.'));\n      return;\n    }\n\n    const error = filesController.validateFilename(filename);\n    if (error) {\n      next(error);\n      return;\n    }\n\n    const base64 = req.body.toString('base64');\n    const file = new Parse.File(filename, { base64 }, contentType);\n    const { metadata = {}, tags = {} } = req.fileData || {};\n    file.setTags(tags);\n    file.setMetadata(metadata);\n    const fileSize = Buffer.byteLength(req.body);\n    const fileObject = { file, fileSize };\n    try {\n      // run beforeSaveFile trigger\n      const triggerResult = await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeSaveFile,\n        fileObject,\n        config,\n        req.auth\n      );\n      let saveResult;\n      // if a new ParseFile is returned check if it's an already saved file\n      if (triggerResult instanceof Parse.File) {\n        fileObject.file = triggerResult;\n        if (triggerResult.url()) {\n          // set fileSize to null because we wont know how big it is here\n          fileObject.fileSize = null;\n          saveResult = {\n            url: triggerResult.url(),\n            name: triggerResult._name,\n          };\n        }\n      }\n      // if the file returned by the trigger has already been saved skip saving anything\n      if (!saveResult) {\n        // if the ParseFile returned is type uri, download the file before saving it\n        await addFileDataIfNeeded(fileObject.file);\n        // update fileSize\n        const bufferData = Buffer.from(fileObject.file._data, 'base64');\n        fileObject.fileSize = Buffer.byteLength(bufferData);\n        // prepare file options\n        const fileOptions = {\n          metadata: fileObject.file._metadata,\n        };\n        // some s3-compatible providers (DigitalOcean, Linode) do not accept tags\n        // so we do not include the tags option if it is empty.\n        const fileTags =\n          Object.keys(fileObject.file._tags).length > 0 ? { tags: fileObject.file._tags } : {};\n        Object.assign(fileOptions, fileTags);\n        // save file\n        const createFileResult = await filesController.createFile(\n          config,\n          fileObject.file._name,\n          bufferData,\n          fileObject.file._source.type,\n          fileOptions\n        );\n        // update file with new data\n        fileObject.file._name = createFileResult.name;\n        fileObject.file._url = createFileResult.url;\n        fileObject.file._requestTask = null;\n        fileObject.file._previousSave = Promise.resolve(fileObject.file);\n        saveResult = {\n          url: createFileResult.url,\n          name: createFileResult.name,\n        };\n      }\n      // run afterSaveFile trigger\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.afterSaveFile,\n        fileObject,\n        config,\n        req.auth\n      );\n      res.status(201);\n      res.set('Location', saveResult.url);\n      res.json(saveResult);\n    } catch (e) {\n      logger.error('Error creating a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_SAVE_ERROR,\n        message: `Could not store file: ${fileObject.file._name}.`,\n      });\n      next(error);\n    }\n  }\n\n  async deleteHandler(req, res, next) {\n    try {\n      const { filesController } = req.config;\n      const { filename } = req.params;\n      // run beforeDeleteFile trigger\n      const file = new Parse.File(filename);\n      file._url = filesController.adapter.getFileLocation(req.config, filename);\n      const fileObject = { file, fileSize: null };\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeDeleteFile,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      // delete file\n      await filesController.deleteFile(req.config, filename);\n      // run afterDeleteFile trigger\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.afterDeleteFile,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      res.status(200);\n      // TODO: return useful JSON here?\n      res.end();\n    } catch (e) {\n      logger.error('Error deleting a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_DELETE_ERROR,\n        message: 'Could not delete file.',\n      });\n      next(error);\n    }\n  }\n\n  async metadataHandler(req, res) {\n    try {\n      const config = Config.get(req.params.appId);\n      const { filesController } = config;\n      const { filename } = req.params;\n      const data = await filesController.getMetadata(filename);\n      res.status(200);\n      res.json(data);\n    } catch (e) {\n      res.status(200);\n      res.json({});\n    }\n  }\n}\n\nfunction isFileStreamable(req, filesController) {\n  return req.get('Range') && typeof filesController.adapter.handleFileStream === 'function';\n}\n"], "filenames": ["spec/ParseFile.spec.js", "src/Routers/FilesRouter.js"], "buggy_code_start_loc": [653, 68], "buggy_code_end_loc": [653, 256], "fixing_code_start_loc": [654, 69], "fixing_code_end_loc": [692, 263], "type": "CWE-252", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. In affected versions certain types of invalid files requests are not handled properly and can crash the server. If you are running multiple Parse Server instances in a cluster, the availability impact may be low; if you are running Parse Server as single instance without redundancy, the availability impact may be high. This issue has been addressed in versions 4.10.12 and 5.2.3. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31089", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-27T21:15:08.457", "lastModified": "2022-07-07T18:37:56.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. In affected versions certain types of invalid files requests are not handled properly and can crash the server. If you are running multiple Parse Server instances in a cluster, the availability impact may be low; if you are running Parse Server as single instance without redundancy, the availability impact may be high. This issue has been addressed in versions 4.10.12 and 5.2.3. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "Parse Server es un backend de c\u00f3digo abierto que puede desplegarse en cualquier infraestructura que pueda ejecutar Node.js. En versiones afectadas, determinados tipos de peticiones de archivos no v\u00e1lidos no son administrados apropiadamente y pueden bloquear el servidor. Si est\u00e1 ejecutando varias instancias de Parse Server en un cl\u00faster, el impacto en la disponibilidad puede ser bajo; si est\u00e1 ejecutando Parse Server como instancia \u00fanica sin redundancia, el impacto en la disponibilidad puede ser alto. Este problema ha sido abordado en versiones 4.10.12 y 5.2.3. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-252"}, {"lang": "en", "value": "CWE-706"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.10.12", "matchCriteriaId": "B8497D85-8A7E-4877-8E32-7EF3CFACF651"}, {"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.3", "matchCriteriaId": "FE840B11-02D3-492F-918F-4DC5508BB9F5"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/5be375dec2fa35425c1003ae81c55995ac72af92", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-xw6g-jjvf-wwf9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/5be375dec2fa35425c1003ae81c55995ac72af92"}}