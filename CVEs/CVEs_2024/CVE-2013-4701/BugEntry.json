{"buggy_code": ["<?php\n\n/**\n * XML-parsing classes to wrap the domxml and DOM extensions for PHP 4\n * and 5, respectively.\n *\n * @package OpenID\n */\n\n/**\n * The base class for wrappers for available PHP XML-parsing\n * extensions.  To work with this Yadis library, subclasses of this\n * class MUST implement the API as defined in the remarks for this\n * class.  Subclasses of Auth_Yadis_XMLParser are used to wrap\n * particular PHP XML extensions such as 'domxml'.  These are used\n * internally by the library depending on the availability of\n * supported PHP XML extensions.\n *\n * @package OpenID\n */\nclass Auth_Yadis_XMLParser {\n    /**\n     * Initialize an instance of Auth_Yadis_XMLParser with some\n     * XML and namespaces.  This SHOULD NOT be overridden by\n     * subclasses.\n     *\n     * @param string $xml_string A string of XML to be parsed.\n     * @param array $namespace_map An array of ($ns_name => $ns_uri)\n     * to be registered with the XML parser.  May be empty.\n     * @return boolean $result True if the initialization and\n     * namespace registration(s) succeeded; false otherwise.\n     */\n    function init($xml_string, $namespace_map)\n    {\n        if (!$this->setXML($xml_string)) {\n            return false;\n        }\n\n        foreach ($namespace_map as $prefix => $uri) {\n            if (!$this->registerNamespace($prefix, $uri)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Register a namespace with the XML parser.  This should be\n     * overridden by subclasses.\n     *\n     * @param string $prefix The namespace prefix to appear in XML tag\n     * names.\n     *\n     * @param string $uri The namespace URI to be used to identify the\n     * namespace in the XML.\n     *\n     * @return boolean $result True if the registration succeeded;\n     * false otherwise.\n     */\n    function registerNamespace($prefix, $uri)\n    {\n        // Not implemented.\n    }\n\n    /**\n     * Set this parser object's XML payload.  This should be\n     * overridden by subclasses.\n     *\n     * @param string $xml_string The XML string to pass to this\n     * object's XML parser.\n     *\n     * @return boolean $result True if the initialization succeeded;\n     * false otherwise.\n     */\n    function setXML($xml_string)\n    {\n        // Not implemented.\n    }\n\n    /**\n     * Evaluate an XPath expression and return the resulting node\n     * list.  This should be overridden by subclasses.\n     *\n     * @param string $xpath The XPath expression to be evaluated.\n     *\n     * @param mixed $node A node object resulting from a previous\n     * evalXPath call.  This node, if specified, provides the context\n     * for the evaluation of this xpath expression.\n     *\n     * @return array $node_list An array of matching opaque node\n     * objects to be used with other methods of this parser class.\n     */\n    function &evalXPath($xpath, $node = null)\n    {\n        // Not implemented.\n    }\n\n    /**\n     * Return the textual content of a specified node.\n     *\n     * @param mixed $node A node object from a previous call to\n     * $this->evalXPath().\n     *\n     * @return string $content The content of this node.\n     */\n    function content($node)\n    {\n        // Not implemented.\n    }\n\n    /**\n     * Return the attributes of a specified node.\n     *\n     * @param mixed $node A node object from a previous call to\n     * $this->evalXPath().\n     *\n     * @return array $attrs An array mapping attribute names to\n     * values.\n     */\n    function attributes($node)\n    {\n        // Not implemented.\n    }\n}\n\n/**\n * This concrete implementation of Auth_Yadis_XMLParser implements\n * the appropriate API for the 'domxml' extension which is typically\n * packaged with PHP 4.  This class will be used whenever the 'domxml'\n * extension is detected.  See the Auth_Yadis_XMLParser class for\n * details on this class's methods.\n *\n * @package OpenID\n */\nclass Auth_Yadis_domxml extends Auth_Yadis_XMLParser {\n    function Auth_Yadis_domxml()\n    {\n        $this->xml = null;\n        $this->doc = null;\n        $this->xpath = null;\n        $this->errors = array();\n    }\n\n    function setXML($xml_string)\n    {\n        $this->xml = $xml_string;\n        $this->doc = @domxml_open_mem($xml_string, DOMXML_LOAD_PARSING,\n                                      $this->errors);\n\n        if (!$this->doc) {\n            return false;\n        }\n\n        $this->xpath = $this->doc->xpath_new_context();\n\n        return true;\n    }\n\n    function registerNamespace($prefix, $uri)\n    {\n        return xpath_register_ns($this->xpath, $prefix, $uri);\n    }\n\n    function &evalXPath($xpath, $node = null)\n    {\n        if ($node) {\n            $result = @$this->xpath->xpath_eval($xpath, $node);\n        } else {\n            $result = @$this->xpath->xpath_eval($xpath);\n        }\n\n        if (!$result) {\n            $n = array();\n            return $n;\n        }\n\n        if (!$result->nodeset) {\n            $n = array();\n            return $n;\n        }\n\n        return $result->nodeset;\n    }\n\n    function content($node)\n    {\n        if ($node) {\n            return $node->get_content();\n        }\n    }\n\n    function attributes($node)\n    {\n        if ($node) {\n            $arr = $node->attributes();\n            $result = array();\n\n            if ($arr) {\n                foreach ($arr as $attrnode) {\n                    $result[$attrnode->name] = $attrnode->value;\n                }\n            }\n\n            return $result;\n        }\n    }\n}\n\n/**\n * This concrete implementation of Auth_Yadis_XMLParser implements\n * the appropriate API for the 'dom' extension which is typically\n * packaged with PHP 5.  This class will be used whenever the 'dom'\n * extension is detected.  See the Auth_Yadis_XMLParser class for\n * details on this class's methods.\n *\n * @package OpenID\n */\nclass Auth_Yadis_dom extends Auth_Yadis_XMLParser {\n    function Auth_Yadis_dom()\n    {\n        $this->xml = null;\n        $this->doc = null;\n        $this->xpath = null;\n        $this->errors = array();\n    }\n\n    function setXML($xml_string)\n    {\n        $this->xml = $xml_string;\n        $this->doc = new DOMDocument;\n\n        if (!$this->doc) {\n            return false;\n        }\n\n        if (!@$this->doc->loadXML($xml_string)) {\n            return false;\n        }\n\n        $this->xpath = new DOMXPath($this->doc);\n\n        if ($this->xpath) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function registerNamespace($prefix, $uri)\n    {\n        return $this->xpath->registerNamespace($prefix, $uri);\n    }\n\n    function &evalXPath($xpath, $node = null)\n    {\n        if ($node) {\n            $result = @$this->xpath->query($xpath, $node);\n        } else {\n            $result = @$this->xpath->query($xpath);\n        }\n\n        $n = array();\n\n        if (!$result) {\n            return $n;\n        }\n\n        for ($i = 0; $i < $result->length; $i++) {\n            $n[] = $result->item($i);\n        }\n\n        return $n;\n    }\n\n    function content($node)\n    {\n        if ($node) {\n            return $node->textContent;\n        }\n    }\n\n    function attributes($node)\n    {\n        if ($node) {\n            $arr = $node->attributes;\n            $result = array();\n\n            if ($arr) {\n                for ($i = 0; $i < $arr->length; $i++) {\n                    $node = $arr->item($i);\n                    $result[$node->nodeName] = $node->nodeValue;\n                }\n            }\n\n            return $result;\n        }\n    }\n}\n\nglobal $__Auth_Yadis_defaultParser;\n$__Auth_Yadis_defaultParser = null;\n\n/**\n * Set a default parser to override the extension-driven selection of\n * available parser classes.  This is helpful in a test environment or\n * one in which multiple parsers can be used but one is more\n * desirable.\n *\n * @param Auth_Yadis_XMLParser $parser An instance of a\n * Auth_Yadis_XMLParser subclass.\n */\nfunction Auth_Yadis_setDefaultParser($parser)\n{\n    global $__Auth_Yadis_defaultParser;\n    $__Auth_Yadis_defaultParser = $parser;\n}\n\nfunction Auth_Yadis_getSupportedExtensions()\n{\n    return array('dom'    => 'Auth_Yadis_dom',\n                 'domxml' => 'Auth_Yadis_domxml');\n}\n\n/**\n * Returns an instance of a Auth_Yadis_XMLParser subclass based on\n * the availability of PHP extensions for XML parsing.  If\n * Auth_Yadis_setDefaultParser has been called, the parser used in\n * that call will be returned instead.\n */\nfunction Auth_Yadis_getXMLParser()\n{\n    global $__Auth_Yadis_defaultParser;\n    \n    if (isset($__Auth_Yadis_defaultParser)) {\n        return $__Auth_Yadis_defaultParser;\n    }\n    \n    foreach(Auth_Yadis_getSupportedExtensions() as $extension => $classname)\n    {\n      if (extension_loaded($extension))\n      {\n        $p = new $classname();\n        Auth_Yadis_setDefaultParser($p);\n        return $p;\n      }\n    }\n    \n    return false;\n}\n\n\n"], "fixing_code": ["<?php\n\n/**\n * XML-parsing classes to wrap the domxml and DOM extensions for PHP 4\n * and 5, respectively.\n *\n * @package OpenID\n */\n\n/**\n * The base class for wrappers for available PHP XML-parsing\n * extensions.  To work with this Yadis library, subclasses of this\n * class MUST implement the API as defined in the remarks for this\n * class.  Subclasses of Auth_Yadis_XMLParser are used to wrap\n * particular PHP XML extensions such as 'domxml'.  These are used\n * internally by the library depending on the availability of\n * supported PHP XML extensions.\n *\n * @package OpenID\n */\nclass Auth_Yadis_XMLParser {\n    /**\n     * Initialize an instance of Auth_Yadis_XMLParser with some\n     * XML and namespaces.  This SHOULD NOT be overridden by\n     * subclasses.\n     *\n     * @param string $xml_string A string of XML to be parsed.\n     * @param array $namespace_map An array of ($ns_name => $ns_uri)\n     * to be registered with the XML parser.  May be empty.\n     * @return boolean $result True if the initialization and\n     * namespace registration(s) succeeded; false otherwise.\n     */\n    function init($xml_string, $namespace_map)\n    {\n        if (!$this->setXML($xml_string)) {\n            return false;\n        }\n\n        foreach ($namespace_map as $prefix => $uri) {\n            if (!$this->registerNamespace($prefix, $uri)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Register a namespace with the XML parser.  This should be\n     * overridden by subclasses.\n     *\n     * @param string $prefix The namespace prefix to appear in XML tag\n     * names.\n     *\n     * @param string $uri The namespace URI to be used to identify the\n     * namespace in the XML.\n     *\n     * @return boolean $result True if the registration succeeded;\n     * false otherwise.\n     */\n    function registerNamespace($prefix, $uri)\n    {\n        // Not implemented.\n    }\n\n    /**\n     * Set this parser object's XML payload.  This should be\n     * overridden by subclasses.\n     *\n     * @param string $xml_string The XML string to pass to this\n     * object's XML parser.\n     *\n     * @return boolean $result True if the initialization succeeded;\n     * false otherwise.\n     */\n    function setXML($xml_string)\n    {\n        // Not implemented.\n    }\n\n    /**\n     * Evaluate an XPath expression and return the resulting node\n     * list.  This should be overridden by subclasses.\n     *\n     * @param string $xpath The XPath expression to be evaluated.\n     *\n     * @param mixed $node A node object resulting from a previous\n     * evalXPath call.  This node, if specified, provides the context\n     * for the evaluation of this xpath expression.\n     *\n     * @return array $node_list An array of matching opaque node\n     * objects to be used with other methods of this parser class.\n     */\n    function &evalXPath($xpath, $node = null)\n    {\n        // Not implemented.\n    }\n\n    /**\n     * Return the textual content of a specified node.\n     *\n     * @param mixed $node A node object from a previous call to\n     * $this->evalXPath().\n     *\n     * @return string $content The content of this node.\n     */\n    function content($node)\n    {\n        // Not implemented.\n    }\n\n    /**\n     * Return the attributes of a specified node.\n     *\n     * @param mixed $node A node object from a previous call to\n     * $this->evalXPath().\n     *\n     * @return array $attrs An array mapping attribute names to\n     * values.\n     */\n    function attributes($node)\n    {\n        // Not implemented.\n    }\n}\n\n/**\n * This concrete implementation of Auth_Yadis_XMLParser implements\n * the appropriate API for the 'domxml' extension which is typically\n * packaged with PHP 4.  This class will be used whenever the 'domxml'\n * extension is detected.  See the Auth_Yadis_XMLParser class for\n * details on this class's methods.\n *\n * @package OpenID\n */\nclass Auth_Yadis_domxml extends Auth_Yadis_XMLParser {\n    function Auth_Yadis_domxml()\n    {\n        $this->xml = null;\n        $this->doc = null;\n        $this->xpath = null;\n        $this->errors = array();\n    }\n\n    function setXML($xml_string)\n    {\n        $this->xml = $xml_string;\n        $this->doc = @domxml_open_mem($xml_string, DOMXML_LOAD_PARSING,\n                                      $this->errors);\n\n        if (!$this->doc) {\n            return false;\n        }\n\n        $this->xpath = $this->doc->xpath_new_context();\n\n        return true;\n    }\n\n    function registerNamespace($prefix, $uri)\n    {\n        return xpath_register_ns($this->xpath, $prefix, $uri);\n    }\n\n    function &evalXPath($xpath, $node = null)\n    {\n        if ($node) {\n            $result = @$this->xpath->xpath_eval($xpath, $node);\n        } else {\n            $result = @$this->xpath->xpath_eval($xpath);\n        }\n\n        if (!$result) {\n            $n = array();\n            return $n;\n        }\n\n        if (!$result->nodeset) {\n            $n = array();\n            return $n;\n        }\n\n        return $result->nodeset;\n    }\n\n    function content($node)\n    {\n        if ($node) {\n            return $node->get_content();\n        }\n    }\n\n    function attributes($node)\n    {\n        if ($node) {\n            $arr = $node->attributes();\n            $result = array();\n\n            if ($arr) {\n                foreach ($arr as $attrnode) {\n                    $result[$attrnode->name] = $attrnode->value;\n                }\n            }\n\n            return $result;\n        }\n    }\n}\n\n/**\n * This concrete implementation of Auth_Yadis_XMLParser implements\n * the appropriate API for the 'dom' extension which is typically\n * packaged with PHP 5.  This class will be used whenever the 'dom'\n * extension is detected.  See the Auth_Yadis_XMLParser class for\n * details on this class's methods.\n *\n * @package OpenID\n */\nclass Auth_Yadis_dom extends Auth_Yadis_XMLParser {\n    function Auth_Yadis_dom()\n    {\n        $this->xml = null;\n        $this->doc = null;\n        $this->xpath = null;\n        $this->errors = array();\n    }\n\n    function setXML($xml_string)\n    {\n        $this->xml = $xml_string;\n        $this->doc = new DOMDocument;\n\n        if (!$this->doc) {\n            return false;\n        }\n\n        // disable external entities and libxml errors\n        $loader = libxml_disable_entity_loader(true);\n        $errors = libxml_use_internal_errors(true);\n        $parse_result = @$this->doc->loadXML($xml_string);\n        libxml_disable_entity_loader($loader);\n        libxml_use_internal_errors($errors);\n\n        if (!$parse_result) {\n            return false;\n        }\n\n        $this->xpath = new DOMXPath($this->doc);\n\n        if ($this->xpath) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function registerNamespace($prefix, $uri)\n    {\n        return $this->xpath->registerNamespace($prefix, $uri);\n    }\n\n    function &evalXPath($xpath, $node = null)\n    {\n        if ($node) {\n            $result = @$this->xpath->query($xpath, $node);\n        } else {\n            $result = @$this->xpath->query($xpath);\n        }\n\n        $n = array();\n\n        if (!$result) {\n            return $n;\n        }\n\n        for ($i = 0; $i < $result->length; $i++) {\n            $n[] = $result->item($i);\n        }\n\n        return $n;\n    }\n\n    function content($node)\n    {\n        if ($node) {\n            return $node->textContent;\n        }\n    }\n\n    function attributes($node)\n    {\n        if ($node) {\n            $arr = $node->attributes;\n            $result = array();\n\n            if ($arr) {\n                for ($i = 0; $i < $arr->length; $i++) {\n                    $node = $arr->item($i);\n                    $result[$node->nodeName] = $node->nodeValue;\n                }\n            }\n\n            return $result;\n        }\n    }\n}\n\nglobal $__Auth_Yadis_defaultParser;\n$__Auth_Yadis_defaultParser = null;\n\n/**\n * Set a default parser to override the extension-driven selection of\n * available parser classes.  This is helpful in a test environment or\n * one in which multiple parsers can be used but one is more\n * desirable.\n *\n * @param Auth_Yadis_XMLParser $parser An instance of a\n * Auth_Yadis_XMLParser subclass.\n */\nfunction Auth_Yadis_setDefaultParser($parser)\n{\n    global $__Auth_Yadis_defaultParser;\n    $__Auth_Yadis_defaultParser = $parser;\n}\n\nfunction Auth_Yadis_getSupportedExtensions()\n{\n    return array('dom'    => 'Auth_Yadis_dom',\n                 'domxml' => 'Auth_Yadis_domxml');\n}\n\n/**\n * Returns an instance of a Auth_Yadis_XMLParser subclass based on\n * the availability of PHP extensions for XML parsing.  If\n * Auth_Yadis_setDefaultParser has been called, the parser used in\n * that call will be returned instead.\n */\nfunction Auth_Yadis_getXMLParser()\n{\n    global $__Auth_Yadis_defaultParser;\n    \n    if (isset($__Auth_Yadis_defaultParser)) {\n        return $__Auth_Yadis_defaultParser;\n    }\n    \n    foreach(Auth_Yadis_getSupportedExtensions() as $extension => $classname)\n    {\n      if (extension_loaded($extension))\n      {\n        $p = new $classname();\n        Auth_Yadis_setDefaultParser($p);\n        return $p;\n      }\n    }\n    \n    return false;\n}\n\n\n"], "filenames": ["Auth/Yadis/XML.php"], "buggy_code_start_loc": [237], "buggy_code_end_loc": [238], "fixing_code_start_loc": [237], "fixing_code_end_loc": [245], "type": "NVD-CWE-noinfo", "message": "Auth/Yadis/XML.php in PHP OpenID Library 2.2.2 and earlier allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via XRDS data containing an external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue.", "other": {"cve": {"id": "CVE-2013-4701", "sourceIdentifier": "vultures@jpcert.or.jp", "published": "2013-08-21T16:55:11.310", "lastModified": "2016-11-28T19:09:40.473", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Auth/Yadis/XML.php in PHP OpenID Library 2.2.2 and earlier allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service (CPU and memory consumption) via XRDS data containing an external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue."}, {"lang": "es", "value": "Auth/Yadis/XML.php en PHP OpenID Library v2.2.2 y anteriores permite a atacantes remotos leer archivos arbitrarios, enviar peticiones HTTP a los servidores de intranet, o causar una denegaci\u00f3n de servicio (consumo de CPU y de memoria) a trav\u00e9s de datos XRDS que contienen una declaraci\u00f3n de entidad externa en conjunto con una referencia a una entidad, en relaci\u00f3n con un fallo en una XML External Entity (XXE)."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:janrain:php-openid:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.2", "matchCriteriaId": "2CA39B2D-D419-4CC2-A01B-F594148127CC"}]}]}], "references": [{"url": "http://jvn.jp/en/jp/JVN24713981/index.html", "source": "vultures@jpcert.or.jp"}, {"url": "http://jvndb.jvn.jp/jvndb/JVNDB-2013-000080", "source": "vultures@jpcert.or.jp"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00028.html", "source": "vultures@jpcert.or.jp"}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00083.html", "source": "vultures@jpcert.or.jp"}, {"url": "https://github.com/openid/php-openid/commit/625c16bb28bb120d262b3f19f89c2c06cb9b0da9", "source": "vultures@jpcert.or.jp", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/openid/php-openid/commit/625c16bb28bb120d262b3f19f89c2c06cb9b0da9"}}