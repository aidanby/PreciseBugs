{"buggy_code": ["/*\n * (C) 1997 Linus Torvalds\n * (C) 1999 Andrea Arcangeli <andrea@suse.de> (dynamic inode allocation)\n */\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/hash.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/cdev.h>\n#include <linux/bootmem.h>\n#include <linux/fsnotify.h>\n#include <linux/mount.h>\n#include <linux/posix_acl.h>\n#include <linux/prefetch.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/ratelimit.h>\n#include <linux/list_lru.h>\n#include <linux/iversion.h>\n#include <trace/events/writeback.h>\n#include \"internal.h\"\n\n/*\n * Inode locking rules:\n *\n * inode->i_lock protects:\n *   inode->i_state, inode->i_hash, __iget()\n * Inode LRU list locks protect:\n *   inode->i_sb->s_inode_lru, inode->i_lru\n * inode->i_sb->s_inode_list_lock protects:\n *   inode->i_sb->s_inodes, inode->i_sb_list\n * bdi->wb.list_lock protects:\n *   bdi->wb.b_{dirty,io,more_io,dirty_time}, inode->i_io_list\n * inode_hash_lock protects:\n *   inode_hashtable, inode->i_hash\n *\n * Lock ordering:\n *\n * inode->i_sb->s_inode_list_lock\n *   inode->i_lock\n *     Inode LRU list locks\n *\n * bdi->wb.list_lock\n *   inode->i_lock\n *\n * inode_hash_lock\n *   inode->i_sb->s_inode_list_lock\n *   inode->i_lock\n *\n * iunique_lock\n *   inode_hash_lock\n */\n\nstatic unsigned int i_hash_mask __read_mostly;\nstatic unsigned int i_hash_shift __read_mostly;\nstatic struct hlist_head *inode_hashtable __read_mostly;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\n\n/*\n * Empty aops. Can be used for the cases where the user does not\n * define any of the address_space operations.\n */\nconst struct address_space_operations empty_aops = {\n};\nEXPORT_SYMBOL(empty_aops);\n\n/*\n * Statistics gathering..\n */\nstruct inodes_stat_t inodes_stat;\n\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nstatic struct kmem_cache *inode_cachep __read_mostly;\n\nstatic long get_nr_inodes(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_inodes, i);\n\treturn sum < 0 ? 0 : sum;\n}\n\nstatic inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}\n\nlong get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}\n\n/*\n * Handle nr_inode sysctl\n */\n#ifdef CONFIG_SYSCTL\nint proc_nr_inodes(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tinodes_stat.nr_inodes = get_nr_inodes();\n\tinodes_stat.nr_unused = get_nr_inodes_unused();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}\n#endif\n\nstatic int no_open(struct inode *inode, struct file *file)\n{\n\treturn -ENXIO;\n}\n\n/**\n * inode_init_always - perform inode structure initialisation\n * @sb: superblock inode belongs to\n * @inode: inode to initialise\n *\n * These are initializations that need to be done on every inode\n * allocation as the fields are not initialised by slab allocation.\n */\nint inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\tif (sb->s_xattr)\n\t\tinode->i_opflags |= IOP_XATTR;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_write_hint = WRITE_LIFE_NOT_SET;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_link = NULL;\n\tinode->i_dir_seq = 0;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tinode->i_wb_frn_winner = 0;\n\tinode->i_wb_frn_avg_time = 0;\n\tinode->i_wb_frn_history = 0;\n#endif\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tinit_rwsem(&inode->i_rwsem);\n\tlockdep_set_class(&inode->i_rwsem, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping->wb_err = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(inode_init_always);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}\n\nvoid free_inode_nonrcu(struct inode *inode)\n{\n\tkmem_cache_free(inode_cachep, inode);\n}\nEXPORT_SYMBOL(free_inode_nonrcu);\n\nvoid __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tinode_detach_wb(inode);\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && !is_uncached_acl(inode->i_acl))\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && !is_uncached_acl(inode->i_default_acl))\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}\nEXPORT_SYMBOL(__destroy_inode);\n\nstatic void i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(inode_cachep, inode);\n}\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}\n\n/**\n * drop_nlink - directly drop an inode's link count\n * @inode: inode\n *\n * This is a low-level filesystem helper to replace any\n * direct filesystem manipulation of i_nlink.  In cases\n * where we are attempting to track writes to the\n * filesystem, a decrement to zero means an imminent\n * write when the file is truncated and actually unlinked\n * on the filesystem.\n */\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}\nEXPORT_SYMBOL(drop_nlink);\n\n/**\n * clear_nlink - directly zero an inode's link count\n * @inode: inode\n *\n * This is a low-level filesystem helper to replace any\n * direct filesystem manipulation of i_nlink.  See\n * drop_nlink() for why we care about i_nlink hitting zero.\n */\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}\nEXPORT_SYMBOL(clear_nlink);\n\n/**\n * set_nlink - directly set an inode's link count\n * @inode: inode\n * @nlink: new nlink (should be non-zero)\n *\n * This is a low-level filesystem helper to replace any\n * direct filesystem manipulation of i_nlink.\n */\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}\nEXPORT_SYMBOL(set_nlink);\n\n/**\n * inc_nlink - directly increment an inode's link count\n * @inode: inode\n *\n * This is a low-level filesystem helper to replace any\n * direct filesystem manipulation of i_nlink.  Currently,\n * it is only here for parity with dec_nlink().\n */\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}\nEXPORT_SYMBOL(inc_nlink);\n\nstatic void __address_space_init_once(struct address_space *mapping)\n{\n\tINIT_RADIX_TREE(&mapping->i_pages, GFP_ATOMIC | __GFP_ACCOUNT);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT_CACHED;\n}\n\nvoid address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\t__address_space_init_once(mapping);\n}\nEXPORT_SYMBOL(address_space_init_once);\n\n/*\n * These are initializations that only need to be done\n * once, because the fields are idempotent across use\n * of the inode, so let the slab aware of that.\n */\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_io_list);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\t__address_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n}\nEXPORT_SYMBOL(inode_init_once);\n\nstatic void init_once(void *foo)\n{\n\tstruct inode *inode = (struct inode *) foo;\n\n\tinode_init_once(inode);\n}\n\n/*\n * inode->i_lock must be held\n */\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}\n\n/*\n * get additional reference to inode; caller must already hold one.\n */\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}\nEXPORT_SYMBOL(ihold);\n\nstatic void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n\telse\n\t\tinode->i_state |= I_REFERENCED;\n}\n\n/*\n * Add inode to LRU if needed (inode is unused and clean).\n *\n * Needs inode->i_lock held.\n */\nvoid inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & SB_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}\n\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}\n\n/**\n * inode_sb_list_add - add inode to the superblock list of inodes\n * @inode: inode to add\n */\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}\nEXPORT_SYMBOL_GPL(inode_sb_list_add);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}\n\nstatic unsigned long hash(struct super_block *sb, unsigned long hashval)\n{\n\tunsigned long tmp;\n\n\ttmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) /\n\t\t\tL1_CACHE_BYTES;\n\ttmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) >> i_hash_shift);\n\treturn tmp & i_hash_mask;\n}\n\n/**\n *\t__insert_inode_hash - hash an inode\n *\t@inode: unhashed inode\n *\t@hashval: unsigned long value used to locate this object in the\n *\t\tinode_hashtable.\n *\n *\tAdd an inode to the inode hash for this superblock.\n */\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}\nEXPORT_SYMBOL(__insert_inode_hash);\n\n/**\n *\t__remove_inode_hash - remove an inode from the hash\n *\t@inode: inode to unhash\n *\n *\tRemove an inode from the superblock.\n */\nvoid __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}\nEXPORT_SYMBOL(__remove_inode_hash);\n\nvoid clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}\nEXPORT_SYMBOL(clear_inode);\n\n/*\n * Free the inode passed in, removing it from the lists it is still connected\n * to. We remove any pages still attached to the inode and wait for any IO that\n * is still in progress before finally destroying the inode.\n *\n * An inode must already be marked I_FREEING so that we avoid the inode being\n * moved back onto lists if we race with other code that manipulates the lists\n * (e.g. writeback_single_inode). The caller is responsible for setting this.\n *\n * An inode must already be removed from the LRU list before being evicted from\n * the cache. This should occur atomically with setting the I_FREEING state\n * flag, so no inodes here should ever be on the LRU when being evicted.\n */\nstatic void evict(struct inode *inode)\n{\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(!list_empty(&inode->i_lru));\n\n\tif (!list_empty(&inode->i_io_list))\n\t\tinode_io_list_del(inode);\n\n\tinode_sb_list_del(inode);\n\n\t/*\n\t * Wait for flusher thread to be done with the inode so that filesystem\n\t * does not start destroying it while writeback is still running. Since\n\t * the inode has I_FREEING set, flusher thread won't start new work on\n\t * the inode.  We just have to wait for running writeback to finish.\n\t */\n\tinode_wait_for_writeback(inode);\n\n\tif (op->evict_inode) {\n\t\top->evict_inode(inode);\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\tclear_inode(inode);\n\t}\n\tif (S_ISBLK(inode->i_mode) && inode->i_bdev)\n\t\tbd_forget(inode);\n\tif (S_ISCHR(inode->i_mode) && inode->i_cdev)\n\t\tcd_forget(inode);\n\n\tremove_inode_hash(inode);\n\n\tspin_lock(&inode->i_lock);\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tBUG_ON(inode->i_state != (I_FREEING | I_CLEAR));\n\tspin_unlock(&inode->i_lock);\n\n\tdestroy_inode(inode);\n}\n\n/*\n * dispose_list - dispose of the contents of a local list\n * @head: the head of the list to free\n *\n * Dispose-list gets a local list with local inodes in it, so it doesn't\n * need to worry about list corruption and SMP locks.\n */\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}\n\n/**\n * evict_inodes\t- evict all evictable inodes for a superblock\n * @sb:\t\tsuperblock to operate on\n *\n * Make sure that no inodes with zero refcount are retained.  This is\n * called by superblock shutdown after having SB_ACTIVE flag removed,\n * so any inode reaching zero refcount during or after that call will\n * be immediately evicted.\n */\nvoid evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}\nEXPORT_SYMBOL_GPL(evict_inodes);\n\n/**\n * invalidate_inodes\t- attempt to free all inodes on a superblock\n * @sb:\t\tsuperblock to operate on\n * @kill_dirty: flag to guide handling of dirty inodes\n *\n * Attempts to free all inodes for a given superblock.  If there were any\n * busy inodes return a non-zero value, else zero.\n * If @kill_dirty is set, discard dirty inodes too, otherwise treat\n * them as busy.\n */\nint invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}\n\n/*\n * Isolate the inode from the LRU in preparation for freeing it.\n *\n * Any inodes which are pinned purely because of attached pagecache have their\n * pagecache removed.  If the inode has metadata buffers attached to\n * mapping->private_list then try to remove them.\n *\n * If the inode has the I_REFERENCED flag set, then it means that it has been\n * used recently - the flag is set in iput_final(). When we encounter such an\n * inode, clear the flag and move it to the back of the LRU so it gets another\n * pass through the LRU before it gets reclaimed. This is necessary because of\n * the fact we are doing lazy LRU updates to minimise lock contention so the\n * LRU does not have strict ordering. Hence we don't want to reclaim inodes\n * with this flag set because they are the inodes that are out of order.\n */\nstatic enum lru_status inode_lru_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct inode\t*inode = container_of(item, struct inode, i_lru);\n\n\t/*\n\t * we are inverting the lru lock/inode->i_lock here, so use a trylock.\n\t * If we fail to get the lock, just skip it.\n\t */\n\tif (!spin_trylock(&inode->i_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * Referenced or dirty inodes are still in use. Give them another pass\n\t * through the LRU as we canot reclaim them now.\n\t */\n\tif (atomic_read(&inode->i_count) ||\n\t    (inode->i_state & ~I_REFERENCED)) {\n\t\tlist_lru_isolate(lru, &inode->i_lru);\n\t\tspin_unlock(&inode->i_lock);\n\t\tthis_cpu_dec(nr_unused);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t/* recently referenced inodes get one more pass */\n\tif (inode->i_state & I_REFERENCED) {\n\t\tinode->i_state &= ~I_REFERENCED;\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn LRU_ROTATE;\n\t}\n\n\tif (inode_has_buffers(inode) || inode->i_data.nrpages) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(lru_lock);\n\t\tif (remove_inode_buffers(inode)) {\n\t\t\tunsigned long reap;\n\t\t\treap = invalidate_mapping_pages(&inode->i_data, 0, -1);\n\t\t\tif (current_is_kswapd())\n\t\t\t\t__count_vm_events(KSWAPD_INODESTEAL, reap);\n\t\t\telse\n\t\t\t\t__count_vm_events(PGINODESTEAL, reap);\n\t\t\tif (current->reclaim_state)\n\t\t\t\tcurrent->reclaim_state->reclaimed_slab += reap;\n\t\t}\n\t\tiput(inode);\n\t\tspin_lock(lru_lock);\n\t\treturn LRU_RETRY;\n\t}\n\n\tWARN_ON(inode->i_state & I_NEW);\n\tinode->i_state |= I_FREEING;\n\tlist_lru_isolate_move(lru, &inode->i_lru, freeable);\n\tspin_unlock(&inode->i_lock);\n\n\tthis_cpu_dec(nr_unused);\n\treturn LRU_REMOVED;\n}\n\n/*\n * Walk the superblock inode LRU for freeable inodes and attempt to free them.\n * This is called from the superblock shrinker function with a number of inodes\n * to trim from the LRU. Inodes to be freed are moved to a temporary list and\n * then are freed outside inode_lock by dispose_list().\n */\nlong prune_icache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(freeable);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_inode_lru, sc,\n\t\t\t\t     inode_lru_isolate, &freeable);\n\tdispose_list(&freeable);\n\treturn freed;\n}\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n/*\n * Called with the inode lock held.\n */\nstatic struct inode *find_inode(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head,\n\t\t\t\tint (*test)(struct inode *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tif (!test(inode, data))\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}\n\n/*\n * find_inode_fast is the fast path version of find_inode, see the comment at\n * iget_locked for details.\n */\nstatic struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}\n\n/*\n * Each cpu owns a range of LAST_INO_BATCH numbers.\n * 'shared_last_ino' is dirtied only once out of LAST_INO_BATCH allocations,\n * to renew the exhausted range.\n *\n * This does not significantly increase overflow rate because every CPU can\n * consume at most LAST_INO_BATCH-1 unused inode numbers. So there is\n * NR_CPUS*(LAST_INO_BATCH-1) wastage. At 4096 and 1024, this is ~0.1% of the\n * 2^32 range, and is a worst-case. Even a 50% wastage would only increase\n * overflow rate by 2x, which does not seem too significant.\n *\n * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n * error if st_ino won't fit in target struct field. Use 32bit counter\n * here to attempt to avoid that.\n */\n#define LAST_INO_BATCH 1024\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}\nEXPORT_SYMBOL(get_next_ino);\n\n/**\n *\tnew_inode_pseudo \t- obtain an inode\n *\t@sb: superblock\n *\n *\tAllocates a new inode for given superblock.\n *\tInode wont be chained in superblock s_inodes list\n *\tThis means :\n *\t- fs can't be unmount\n *\t- quotas, fsnotify, writeback can't work\n */\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}\n\n/**\n *\tnew_inode \t- obtain an inode\n *\t@sb: superblock\n *\n *\tAllocates a new inode for given superblock. The default gfp_mask\n *\tfor allocations related to inode->i_mapping is GFP_HIGHUSER_MOVABLE.\n *\tIf HIGHMEM pages are unsuitable or it is known that pages allocated\n *\tfor the page cache are not reclaimable or migratable,\n *\tmapping_set_gfp_mask() must be called with suitable flags on the\n *\tnewly created inode's mapping\n *\n */\nstruct inode *new_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tspin_lock_prefetch(&sb->s_inode_list_lock);\n\n\tinode = new_inode_pseudo(sb);\n\tif (inode)\n\t\tinode_sb_list_add(inode);\n\treturn inode;\n}\nEXPORT_SYMBOL(new_inode);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(lockdep_annotate_inode_mutex_key);\n#endif\n\n/**\n * unlock_new_inode - clear the I_NEW state and wake up any waiters\n * @inode:\tnew inode to unlock\n *\n * Called when the inode is fully initialised to clear the new state of the\n * inode and wake up anyone waiting for the inode to finish initialisation.\n */\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL(unlock_new_inode);\n\n/**\n * lock_two_nondirectories - take two i_mutexes on non-directory objects\n *\n * Lock any non-NULL argument that is not a directory.\n * Zero, one or two objects may be locked by this function.\n *\n * @inode1: first inode to lock\n * @inode2: second inode to lock\n */\nvoid lock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 > inode2)\n\t\tswap(inode1, inode2);\n\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tinode_lock(inode1);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tinode_lock_nested(inode2, I_MUTEX_NONDIR2);\n}\nEXPORT_SYMBOL(lock_two_nondirectories);\n\n/**\n * unlock_two_nondirectories - release locks from lock_two_nondirectories()\n * @inode1: first inode to unlock\n * @inode2: second inode to unlock\n */\nvoid unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tinode_unlock(inode1);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tinode_unlock(inode2);\n}\nEXPORT_SYMBOL(unlock_two_nondirectories);\n\n/**\n * inode_insert5 - obtain an inode from a mounted file system\n * @inode:\tpre-allocated inode to use for insert to cache\n * @hashval:\thash value (usually inode number) to get\n * @test:\tcallback used for comparisons between inodes\n * @set:\tcallback used to initialize a new struct inode\n * @data:\topaque data pointer to pass to @test and @set\n *\n * Search for the inode specified by @hashval and @data in the inode cache,\n * and if present it is return it with an increased reference count. This is\n * a variant of iget5_locked() for callers that don't want to fail on memory\n * allocation of inode.\n *\n * If the inode is not in cache, insert the pre-allocated inode to cache and\n * return it locked, hashed, and with the I_NEW flag set. The file system gets\n * to fill it in before unlocking it via unlock_new_inode().\n *\n * Note both @test and @set are called with the inode_hash_lock held, so can't\n * sleep.\n */\nstruct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}\nEXPORT_SYMBOL(inode_insert5);\n\n/**\n * iget5_locked - obtain an inode from a mounted file system\n * @sb:\t\tsuper block of file system\n * @hashval:\thash value (usually inode number) to get\n * @test:\tcallback used for comparisons between inodes\n * @set:\tcallback used to initialize a new struct inode\n * @data:\topaque data pointer to pass to @test and @set\n *\n * Search for the inode specified by @hashval and @data in the inode cache,\n * and if present it is return it with an increased reference count. This is\n * a generalized version of iget_locked() for file systems where the inode\n * number is not sufficient for unique identification of an inode.\n *\n * If the inode is not in cache, allocate a new inode and return it locked,\n * hashed, and with the I_NEW flag set. The file system gets to fill it in\n * before unlocking it via unlock_new_inode().\n *\n * Note both @test and @set are called with the inode_hash_lock held, so can't\n * sleep.\n */\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5(sb, hashval, test, data);\n\n\tif (!inode) {\n\t\tstruct inode *new = new_inode(sb);\n\n\t\tif (new) {\n\t\t\tinode = inode_insert5(new, hashval, test, set, data);\n\t\t\tif (unlikely(inode != new))\n\t\t\t\tiput(new);\n\t\t}\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(iget5_locked);\n\n/**\n * iget_locked - obtain an inode from a mounted file system\n * @sb:\t\tsuper block of file system\n * @ino:\tinode number to get\n *\n * Search for the inode specified by @ino in the inode cache and if present\n * return it with an increased reference count. This is for file systems\n * where the inode number is sufficient for unique identification of an inode.\n *\n * If the inode is not in cache, allocate a new inode and return it locked,\n * hashed, and with the I_NEW flag set.  The file system gets to fill it in\n * before unlocking it via unlock_new_inode().\n */\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\nagain:\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(iget_locked);\n\n/*\n * search the inode cache for a matching inode number.\n * If we find one, then the inode number we are trying to\n * allocate is not unique and so we should not use it.\n *\n * Returns 1 if the inode number is unique, 0 if it is not.\n */\nstatic int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}\n\n/**\n *\tiunique - get a unique inode number\n *\t@sb: superblock\n *\t@max_reserved: highest reserved inode number\n *\n *\tObtain an inode number that is unique on the system for a given\n *\tsuperblock. This is used by file systems that have no natural\n *\tpermanent inode numbering system. An inode number is returned that\n *\tis higher than the reserved limit but unique.\n *\n *\tBUGS:\n *\tWith a large number of inodes live on the file system this function\n *\tcurrently becomes quite slow.\n */\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}\nEXPORT_SYMBOL(iunique);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(igrab);\n\n/**\n * ilookup5_nowait - search for an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @hashval:\thash value (usually inode number) to search for\n * @test:\tcallback used for comparisons between inodes\n * @data:\topaque data pointer to pass to @test\n *\n * Search for the inode specified by @hashval and @data in the inode cache.\n * If the inode is in the cache, the inode is returned with an incremented\n * reference count.\n *\n * Note: I_NEW is not waited upon so you have to be very careful what you do\n * with the returned inode.  You probably should be using ilookup5() instead.\n *\n * Note2: @test is called with the inode_hash_lock held, so can't sleep.\n */\nstruct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}\nEXPORT_SYMBOL(ilookup5_nowait);\n\n/**\n * ilookup5 - search for an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @hashval:\thash value (usually inode number) to search for\n * @test:\tcallback used for comparisons between inodes\n * @data:\topaque data pointer to pass to @test\n *\n * Search for the inode specified by @hashval and @data in the inode cache,\n * and if the inode is in the cache, return the inode with an incremented\n * reference count.  Waits on I_NEW before returning the inode.\n * returned with an incremented reference count.\n *\n * This is a generalized version of ilookup() for file systems where the\n * inode number is not sufficient for unique identification of an inode.\n *\n * Note: @test is called with the inode_hash_lock held, so can't sleep.\n */\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode;\nagain:\n\tinode = ilookup5_nowait(sb, hashval, test, data);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(ilookup5);\n\n/**\n * ilookup - search for an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @ino:\tinode number to search for\n *\n * Search for the inode @ino in the inode cache, and if the inode is in the\n * cache, the inode is returned with an incremented reference count.\n */\nstruct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\nagain:\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(ilookup);\n\n/**\n * find_inode_nowait - find an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @hashval:\thash value (usually inode number) to search for\n * @match:\tcallback used for comparisons between inodes\n * @data:\topaque data pointer to pass to @match\n *\n * Search for the inode specified by @hashval and @data in the inode\n * cache, where the helper function @match will return 0 if the inode\n * does not match, 1 if the inode does match, and -1 if the search\n * should be stopped.  The @match function must be responsible for\n * taking the i_lock spin_lock and checking i_state for an inode being\n * freed or being initialized, and incrementing the reference count\n * before returning 1.  It also must not sleep, since it is called with\n * the inode_hash_lock spinlock held.\n *\n * This is a even more generalized version of ilookup5() when the\n * function must never block --- find_inode() can block in\n * __wait_on_freeing_inode() --- or when the caller can not increment\n * the reference count because the resulting iput() might cause an\n * inode eviction.  The tradeoff is that the @match funtion must be\n * very carefully implemented.\n */\nstruct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}\nEXPORT_SYMBOL(find_inode_nowait);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}\nEXPORT_SYMBOL(insert_inode_locked);\n\nint insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *old = inode_insert5(inode, hashval, test, NULL, data);\n\n\tif (old != inode) {\n\t\tiput(old);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(insert_inode_locked4);\n\n\nint generic_delete_inode(struct inode *inode)\n{\n\treturn 1;\n}\nEXPORT_SYMBOL(generic_delete_inode);\n\n/*\n * Called when we're dropping the last reference\n * to an inode.\n *\n * Call the FS \"drop_inode()\" function, defaulting to\n * the legacy UNIX filesystem behaviour.  If it tells\n * us to evict inode, do so.  Otherwise, retain inode\n * in cache if fs is alive, sync and evict if fs is\n * shutting down.\n */\nstatic void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & SB_ACTIVE)) {\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}\n\n/**\n *\tiput\t- put an inode\n *\t@inode: inode to put\n *\n *\tPuts an inode, dropping its usage count. If the inode use count hits\n *\tzero, the inode is then freed and may also be destroyed.\n *\n *\tConsequently, iput() can sleep.\n */\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}\nEXPORT_SYMBOL(iput);\n\n/**\n *\tbmap\t- find a block number in a file\n *\t@inode: inode of file\n *\t@block: block to find\n *\n *\tReturns the block number on the device holding the inode that\n *\tis the disk block number for the block of the file requested.\n *\tThat is, asked for block 4 of inode 1 the function will return the\n *\tdisk block relative to the disk start that holds that block of the\n *\tfile.\n */\nsector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}\nEXPORT_SYMBOL(bmap);\n\n/*\n * Update times in overlayed inode from underlying real inode\n */\nstatic void update_ovl_inode_times(struct dentry *dentry, struct inode *inode,\n\t\t\t       bool rcu)\n{\n\tstruct dentry *upperdentry;\n\n\t/*\n\t * Nothing to do if in rcu or if non-overlayfs\n\t */\n\tif (rcu || likely(!(dentry->d_flags & DCACHE_OP_REAL)))\n\t\treturn;\n\n\tupperdentry = d_real(dentry, NULL, 0, D_REAL_UPPER);\n\n\t/*\n\t * If file is on lower then we can't update atime, so no worries about\n\t * stale mtime/ctime.\n\t */\n\tif (upperdentry) {\n\t\tstruct inode *realinode = d_inode(upperdentry);\n\n\t\tif ((!timespec64_equal(&inode->i_mtime, &realinode->i_mtime) ||\n\t\t     !timespec64_equal(&inode->i_ctime, &realinode->i_ctime))) {\n\t\t\tinode->i_mtime = realinode->i_mtime;\n\t\t\tinode->i_ctime = realinode->i_ctime;\n\t\t}\n\t}\n}\n\n/*\n * With relative atime, only update atime if the previous atime is\n * earlier than either the ctime or mtime or if at least a day has\n * passed since the last atime update.\n */\nstatic int relatime_need_update(const struct path *path, struct inode *inode,\n\t\t\t\tstruct timespec now, bool rcu)\n{\n\n\tif (!(path->mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\n\tupdate_ovl_inode_times(path->dentry, inode, rcu);\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}\n\nint generic_update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint iflags = I_DIRTY_TIME;\n\tbool dirty = false;\n\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *time;\n\tif (flags & S_VERSION)\n\t\tdirty = inode_maybe_inc_iversion(inode, false);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *time;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *time;\n\tif ((flags & (S_ATIME | S_CTIME | S_MTIME)) &&\n\t    !(inode->i_sb->s_flags & SB_LAZYTIME))\n\t\tdirty = true;\n\n\tif (dirty)\n\t\tiflags |= I_DIRTY_SYNC;\n\t__mark_inode_dirty(inode, iflags);\n\treturn 0;\n}\nEXPORT_SYMBOL(generic_update_time);\n\n/*\n * This does the actual work of updating an inodes time or version.  Must have\n * had called mnt_want_write() before calling this.\n */\nstatic int update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}\n\n/**\n *\ttouch_atime\t-\tupdate the access time\n *\t@path: the &struct path to update\n *\t@inode: inode to update\n *\n *\tUpdate the accessed time on an inode and mark it for writeback.\n *\tThis function automatically handles read only file systems and media,\n *\tas well as the \"noatime\" flag and inode specific \"noatime\" markers.\n */\nbool __atime_needs_update(const struct path *path, struct inode *inode,\n\t\t\t  bool rcu)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct timespec64 now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn false;\n\n\t/* Atime updates will likely cause i_uid and i_gid to be written\n\t * back improprely if their true value is unknown to the vfs.\n\t */\n\tif (HAS_UNMAPPED_ID(inode))\n\t\treturn false;\n\n\tif (IS_NOATIME(inode))\n\t\treturn false;\n\tif ((inode->i_sb->s_flags & SB_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn false;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tnow = current_time(inode);\n\n\tif (!relatime_need_update(path, inode, timespec64_to_timespec(now), rcu))\n\t\treturn false;\n\n\tif (timespec64_equal(&inode->i_atime, &now))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct timespec64 now;\n\n\tif (!__atime_needs_update(path, inode, false))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt) != 0)\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tnow = current_time(inode);\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}\nEXPORT_SYMBOL(touch_atime);\n\n/*\n * The logic we want is\n *\n *\tif suid or (sgid and xgrp)\n *\t\tremove privs\n */\nint should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = d_inode(dentry)->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(should_remove_suid);\n\n/*\n * Return mask of changes for notify_change() that need to be done as a\n * response to write or truncate. Return 0 if nothing has to be changed.\n * Negative value on error (change should be denied).\n */\nint dentry_needs_remove_privs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint mask = 0;\n\tint ret;\n\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tmask = should_remove_suid(dentry);\n\tret = security_inode_need_killpriv(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tmask |= ATTR_KILL_PRIV;\n\treturn mask;\n}\n\nstatic int __remove_privs(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}\n\n/*\n * Remove special file priviledges (suid, capabilities) when file is written\n * to or truncated.\n */\nint file_remove_privs(struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = file_inode(file);\n\tint kill;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkill = dentry_needs_remove_privs(dentry);\n\tif (kill < 0)\n\t\treturn kill;\n\tif (kill)\n\t\terror = __remove_privs(dentry, kill);\n\tif (!error)\n\t\tinode_has_no_xattr(inode);\n\n\treturn error;\n}\nEXPORT_SYMBOL(file_remove_privs);\n\n/**\n *\tfile_update_time\t-\tupdate mtime and ctime time\n *\t@file: file accessed\n *\n *\tUpdate the mtime and ctime members of an inode and mark the inode\n *\tfor writeback.  Note that this function is meant exclusively for\n *\tusage in the file write path of filesystems, and filesystems may\n *\tchoose to explicitly ignore update via this function with the\n *\tS_NOCMTIME inode flag, e.g. for network filesystem where these\n *\ttimestamps are handled by the server.  This can return an error for\n *\tfile systems who need to allocate space in order to update an inode.\n */\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec64 now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_time(inode);\n\tif (!timespec64_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec64_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode) && inode_iversion_need_inc(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(file_update_time);\n\nint inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(inode_needs_sync);\n\n/*\n * If we try to find an inode in the inode hash while it is being\n * deleted, we have to wait until the filesystem completes its\n * deletion before reporting that it isn't found.  This function waits\n * until the deletion _might_ have completed.  Callers are responsible\n * to recheck inode state.\n *\n * It doesn't matter if I_NEW is not set initially, a call to\n * wake_up_bit(&inode->i_state, __I_NEW) after removing from the hash list\n * will DTRT.\n */\nstatic void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wq_entry);\n\tspin_lock(&inode_hash_lock);\n}\n\nstatic __initdata unsigned long ihash_entries;\nstatic int __init set_ihash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tihash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}\n__setup(\"ihash_entries=\", set_ihash_entries);\n\n/*\n * Initialize the waitqueues and inode hash table.\n */\nvoid __init inode_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}\n\nvoid __init inode_init(void)\n{\n\t/* inode slab cache */\n\tinode_cachep = kmem_cache_create(\"inode_cache\",\n\t\t\t\t\t sizeof(struct inode),\n\t\t\t\t\t 0,\n\t\t\t\t\t (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t init_once);\n\n\t/* Hash may have been set up in inode_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}\nEXPORT_SYMBOL(init_special_inode);\n\n/**\n * inode_init_owner - Init uid,gid,mode for new inode according to posix standards\n * @inode: New inode\n * @dir: Directory inode\n * @mode: mode of the new inode\n */\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}\nEXPORT_SYMBOL(inode_init_owner);\n\n/**\n * inode_owner_or_capable - check current task permissions to inode\n * @inode: inode being checked\n *\n * Return true if current either has CAP_FOWNER in a namespace with the\n * inode owner uid mapped, or owns the file.\n */\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL(inode_owner_or_capable);\n\n/*\n * Direct i/o helper functions\n */\nstatic void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wq_entry, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wq_entry);\n}\n\n/**\n * inode_dio_wait - wait for outstanding DIO requests to finish\n * @inode: inode to wait for\n *\n * Waits for all pending direct I/O requests to finish so that we can\n * proceed with a truncate or equivalent operation.\n *\n * Must be called under a lock that serializes taking new references\n * to i_dio_count, usually by inode->i_mutex.\n */\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}\nEXPORT_SYMBOL(inode_dio_wait);\n\n/*\n * inode_set_flags - atomically set some inode flags\n *\n * Note: the caller should be holding i_mutex, or else be sure that\n * they have exclusive access to the inode structure (i.e., while the\n * inode is being instantiated).  The reason for the cmpxchg() loop\n * --- which wouldn't be necessary if all code paths which modify\n * i_flags actually followed this rule, is that there is at least one\n * code path which doesn't today so we use cmpxchg() out of an abundance\n * of caution.\n *\n * In the long run, i_mutex is overkill, and we should probably look\n * at using the i_lock spinlock to protect i_flags, and then make sure\n * it is so documented in include/linux/fs.h and that all code follows\n * the locking convention!!\n */\nvoid inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = READ_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}\nEXPORT_SYMBOL(inode_set_flags);\n\nvoid inode_nohighmem(struct inode *inode)\n{\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_USER);\n}\nEXPORT_SYMBOL(inode_nohighmem);\n\n/**\n * timespec64_trunc - Truncate timespec64 to a granularity\n * @t: Timespec64\n * @gran: Granularity in ns.\n *\n * Truncate a timespec64 to a granularity. Always rounds down. gran must\n * not be 0 nor greater than a second (NSEC_PER_SEC, or 10^9 ns).\n */\nstruct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran)\n{\n\t/* Avoid division in the common cases 1 ns and 1 s. */\n\tif (gran == 1) {\n\t\t/* nothing */\n\t} else if (gran == NSEC_PER_SEC) {\n\t\tt.tv_nsec = 0;\n\t} else if (gran > 1 && gran < NSEC_PER_SEC) {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t} else {\n\t\tWARN(1, \"illegal file time granularity: %u\", gran);\n\t}\n\treturn t;\n}\nEXPORT_SYMBOL(timespec64_trunc);\n\n/**\n * current_time - Return FS time\n * @inode: inode.\n *\n * Return the current time truncated to the time granularity supported by\n * the fs.\n *\n * Note that inode and inode->sb cannot be NULL.\n * Otherwise, the function warns and returns time without truncation.\n */\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}\nEXPORT_SYMBOL(current_time);\n"], "fixing_code": ["/*\n * (C) 1997 Linus Torvalds\n * (C) 1999 Andrea Arcangeli <andrea@suse.de> (dynamic inode allocation)\n */\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/backing-dev.h>\n#include <linux/hash.h>\n#include <linux/swap.h>\n#include <linux/security.h>\n#include <linux/cdev.h>\n#include <linux/bootmem.h>\n#include <linux/fsnotify.h>\n#include <linux/mount.h>\n#include <linux/posix_acl.h>\n#include <linux/prefetch.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/ratelimit.h>\n#include <linux/list_lru.h>\n#include <linux/iversion.h>\n#include <trace/events/writeback.h>\n#include \"internal.h\"\n\n/*\n * Inode locking rules:\n *\n * inode->i_lock protects:\n *   inode->i_state, inode->i_hash, __iget()\n * Inode LRU list locks protect:\n *   inode->i_sb->s_inode_lru, inode->i_lru\n * inode->i_sb->s_inode_list_lock protects:\n *   inode->i_sb->s_inodes, inode->i_sb_list\n * bdi->wb.list_lock protects:\n *   bdi->wb.b_{dirty,io,more_io,dirty_time}, inode->i_io_list\n * inode_hash_lock protects:\n *   inode_hashtable, inode->i_hash\n *\n * Lock ordering:\n *\n * inode->i_sb->s_inode_list_lock\n *   inode->i_lock\n *     Inode LRU list locks\n *\n * bdi->wb.list_lock\n *   inode->i_lock\n *\n * inode_hash_lock\n *   inode->i_sb->s_inode_list_lock\n *   inode->i_lock\n *\n * iunique_lock\n *   inode_hash_lock\n */\n\nstatic unsigned int i_hash_mask __read_mostly;\nstatic unsigned int i_hash_shift __read_mostly;\nstatic struct hlist_head *inode_hashtable __read_mostly;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\n\n/*\n * Empty aops. Can be used for the cases where the user does not\n * define any of the address_space operations.\n */\nconst struct address_space_operations empty_aops = {\n};\nEXPORT_SYMBOL(empty_aops);\n\n/*\n * Statistics gathering..\n */\nstruct inodes_stat_t inodes_stat;\n\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nstatic struct kmem_cache *inode_cachep __read_mostly;\n\nstatic long get_nr_inodes(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_inodes, i);\n\treturn sum < 0 ? 0 : sum;\n}\n\nstatic inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}\n\nlong get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}\n\n/*\n * Handle nr_inode sysctl\n */\n#ifdef CONFIG_SYSCTL\nint proc_nr_inodes(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tinodes_stat.nr_inodes = get_nr_inodes();\n\tinodes_stat.nr_unused = get_nr_inodes_unused();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}\n#endif\n\nstatic int no_open(struct inode *inode, struct file *file)\n{\n\treturn -ENXIO;\n}\n\n/**\n * inode_init_always - perform inode structure initialisation\n * @sb: superblock inode belongs to\n * @inode: inode to initialise\n *\n * These are initializations that need to be done on every inode\n * allocation as the fields are not initialised by slab allocation.\n */\nint inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\tif (sb->s_xattr)\n\t\tinode->i_opflags |= IOP_XATTR;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_write_hint = WRITE_LIFE_NOT_SET;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_link = NULL;\n\tinode->i_dir_seq = 0;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tinode->i_wb_frn_winner = 0;\n\tinode->i_wb_frn_avg_time = 0;\n\tinode->i_wb_frn_history = 0;\n#endif\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tinit_rwsem(&inode->i_rwsem);\n\tlockdep_set_class(&inode->i_rwsem, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping->wb_err = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(inode_init_always);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}\n\nvoid free_inode_nonrcu(struct inode *inode)\n{\n\tkmem_cache_free(inode_cachep, inode);\n}\nEXPORT_SYMBOL(free_inode_nonrcu);\n\nvoid __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tinode_detach_wb(inode);\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && !is_uncached_acl(inode->i_acl))\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && !is_uncached_acl(inode->i_default_acl))\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}\nEXPORT_SYMBOL(__destroy_inode);\n\nstatic void i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(inode_cachep, inode);\n}\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}\n\n/**\n * drop_nlink - directly drop an inode's link count\n * @inode: inode\n *\n * This is a low-level filesystem helper to replace any\n * direct filesystem manipulation of i_nlink.  In cases\n * where we are attempting to track writes to the\n * filesystem, a decrement to zero means an imminent\n * write when the file is truncated and actually unlinked\n * on the filesystem.\n */\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}\nEXPORT_SYMBOL(drop_nlink);\n\n/**\n * clear_nlink - directly zero an inode's link count\n * @inode: inode\n *\n * This is a low-level filesystem helper to replace any\n * direct filesystem manipulation of i_nlink.  See\n * drop_nlink() for why we care about i_nlink hitting zero.\n */\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}\nEXPORT_SYMBOL(clear_nlink);\n\n/**\n * set_nlink - directly set an inode's link count\n * @inode: inode\n * @nlink: new nlink (should be non-zero)\n *\n * This is a low-level filesystem helper to replace any\n * direct filesystem manipulation of i_nlink.\n */\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}\nEXPORT_SYMBOL(set_nlink);\n\n/**\n * inc_nlink - directly increment an inode's link count\n * @inode: inode\n *\n * This is a low-level filesystem helper to replace any\n * direct filesystem manipulation of i_nlink.  Currently,\n * it is only here for parity with dec_nlink().\n */\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}\nEXPORT_SYMBOL(inc_nlink);\n\nstatic void __address_space_init_once(struct address_space *mapping)\n{\n\tINIT_RADIX_TREE(&mapping->i_pages, GFP_ATOMIC | __GFP_ACCOUNT);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT_CACHED;\n}\n\nvoid address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\t__address_space_init_once(mapping);\n}\nEXPORT_SYMBOL(address_space_init_once);\n\n/*\n * These are initializations that only need to be done\n * once, because the fields are idempotent across use\n * of the inode, so let the slab aware of that.\n */\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_io_list);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\t__address_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n}\nEXPORT_SYMBOL(inode_init_once);\n\nstatic void init_once(void *foo)\n{\n\tstruct inode *inode = (struct inode *) foo;\n\n\tinode_init_once(inode);\n}\n\n/*\n * inode->i_lock must be held\n */\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}\n\n/*\n * get additional reference to inode; caller must already hold one.\n */\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}\nEXPORT_SYMBOL(ihold);\n\nstatic void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n\telse\n\t\tinode->i_state |= I_REFERENCED;\n}\n\n/*\n * Add inode to LRU if needed (inode is unused and clean).\n *\n * Needs inode->i_lock held.\n */\nvoid inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & SB_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}\n\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}\n\n/**\n * inode_sb_list_add - add inode to the superblock list of inodes\n * @inode: inode to add\n */\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}\nEXPORT_SYMBOL_GPL(inode_sb_list_add);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}\n\nstatic unsigned long hash(struct super_block *sb, unsigned long hashval)\n{\n\tunsigned long tmp;\n\n\ttmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) /\n\t\t\tL1_CACHE_BYTES;\n\ttmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) >> i_hash_shift);\n\treturn tmp & i_hash_mask;\n}\n\n/**\n *\t__insert_inode_hash - hash an inode\n *\t@inode: unhashed inode\n *\t@hashval: unsigned long value used to locate this object in the\n *\t\tinode_hashtable.\n *\n *\tAdd an inode to the inode hash for this superblock.\n */\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}\nEXPORT_SYMBOL(__insert_inode_hash);\n\n/**\n *\t__remove_inode_hash - remove an inode from the hash\n *\t@inode: inode to unhash\n *\n *\tRemove an inode from the superblock.\n */\nvoid __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}\nEXPORT_SYMBOL(__remove_inode_hash);\n\nvoid clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}\nEXPORT_SYMBOL(clear_inode);\n\n/*\n * Free the inode passed in, removing it from the lists it is still connected\n * to. We remove any pages still attached to the inode and wait for any IO that\n * is still in progress before finally destroying the inode.\n *\n * An inode must already be marked I_FREEING so that we avoid the inode being\n * moved back onto lists if we race with other code that manipulates the lists\n * (e.g. writeback_single_inode). The caller is responsible for setting this.\n *\n * An inode must already be removed from the LRU list before being evicted from\n * the cache. This should occur atomically with setting the I_FREEING state\n * flag, so no inodes here should ever be on the LRU when being evicted.\n */\nstatic void evict(struct inode *inode)\n{\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(!list_empty(&inode->i_lru));\n\n\tif (!list_empty(&inode->i_io_list))\n\t\tinode_io_list_del(inode);\n\n\tinode_sb_list_del(inode);\n\n\t/*\n\t * Wait for flusher thread to be done with the inode so that filesystem\n\t * does not start destroying it while writeback is still running. Since\n\t * the inode has I_FREEING set, flusher thread won't start new work on\n\t * the inode.  We just have to wait for running writeback to finish.\n\t */\n\tinode_wait_for_writeback(inode);\n\n\tif (op->evict_inode) {\n\t\top->evict_inode(inode);\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\tclear_inode(inode);\n\t}\n\tif (S_ISBLK(inode->i_mode) && inode->i_bdev)\n\t\tbd_forget(inode);\n\tif (S_ISCHR(inode->i_mode) && inode->i_cdev)\n\t\tcd_forget(inode);\n\n\tremove_inode_hash(inode);\n\n\tspin_lock(&inode->i_lock);\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tBUG_ON(inode->i_state != (I_FREEING | I_CLEAR));\n\tspin_unlock(&inode->i_lock);\n\n\tdestroy_inode(inode);\n}\n\n/*\n * dispose_list - dispose of the contents of a local list\n * @head: the head of the list to free\n *\n * Dispose-list gets a local list with local inodes in it, so it doesn't\n * need to worry about list corruption and SMP locks.\n */\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}\n\n/**\n * evict_inodes\t- evict all evictable inodes for a superblock\n * @sb:\t\tsuperblock to operate on\n *\n * Make sure that no inodes with zero refcount are retained.  This is\n * called by superblock shutdown after having SB_ACTIVE flag removed,\n * so any inode reaching zero refcount during or after that call will\n * be immediately evicted.\n */\nvoid evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}\nEXPORT_SYMBOL_GPL(evict_inodes);\n\n/**\n * invalidate_inodes\t- attempt to free all inodes on a superblock\n * @sb:\t\tsuperblock to operate on\n * @kill_dirty: flag to guide handling of dirty inodes\n *\n * Attempts to free all inodes for a given superblock.  If there were any\n * busy inodes return a non-zero value, else zero.\n * If @kill_dirty is set, discard dirty inodes too, otherwise treat\n * them as busy.\n */\nint invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}\n\n/*\n * Isolate the inode from the LRU in preparation for freeing it.\n *\n * Any inodes which are pinned purely because of attached pagecache have their\n * pagecache removed.  If the inode has metadata buffers attached to\n * mapping->private_list then try to remove them.\n *\n * If the inode has the I_REFERENCED flag set, then it means that it has been\n * used recently - the flag is set in iput_final(). When we encounter such an\n * inode, clear the flag and move it to the back of the LRU so it gets another\n * pass through the LRU before it gets reclaimed. This is necessary because of\n * the fact we are doing lazy LRU updates to minimise lock contention so the\n * LRU does not have strict ordering. Hence we don't want to reclaim inodes\n * with this flag set because they are the inodes that are out of order.\n */\nstatic enum lru_status inode_lru_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct inode\t*inode = container_of(item, struct inode, i_lru);\n\n\t/*\n\t * we are inverting the lru lock/inode->i_lock here, so use a trylock.\n\t * If we fail to get the lock, just skip it.\n\t */\n\tif (!spin_trylock(&inode->i_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * Referenced or dirty inodes are still in use. Give them another pass\n\t * through the LRU as we canot reclaim them now.\n\t */\n\tif (atomic_read(&inode->i_count) ||\n\t    (inode->i_state & ~I_REFERENCED)) {\n\t\tlist_lru_isolate(lru, &inode->i_lru);\n\t\tspin_unlock(&inode->i_lock);\n\t\tthis_cpu_dec(nr_unused);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t/* recently referenced inodes get one more pass */\n\tif (inode->i_state & I_REFERENCED) {\n\t\tinode->i_state &= ~I_REFERENCED;\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn LRU_ROTATE;\n\t}\n\n\tif (inode_has_buffers(inode) || inode->i_data.nrpages) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(lru_lock);\n\t\tif (remove_inode_buffers(inode)) {\n\t\t\tunsigned long reap;\n\t\t\treap = invalidate_mapping_pages(&inode->i_data, 0, -1);\n\t\t\tif (current_is_kswapd())\n\t\t\t\t__count_vm_events(KSWAPD_INODESTEAL, reap);\n\t\t\telse\n\t\t\t\t__count_vm_events(PGINODESTEAL, reap);\n\t\t\tif (current->reclaim_state)\n\t\t\t\tcurrent->reclaim_state->reclaimed_slab += reap;\n\t\t}\n\t\tiput(inode);\n\t\tspin_lock(lru_lock);\n\t\treturn LRU_RETRY;\n\t}\n\n\tWARN_ON(inode->i_state & I_NEW);\n\tinode->i_state |= I_FREEING;\n\tlist_lru_isolate_move(lru, &inode->i_lru, freeable);\n\tspin_unlock(&inode->i_lock);\n\n\tthis_cpu_dec(nr_unused);\n\treturn LRU_REMOVED;\n}\n\n/*\n * Walk the superblock inode LRU for freeable inodes and attempt to free them.\n * This is called from the superblock shrinker function with a number of inodes\n * to trim from the LRU. Inodes to be freed are moved to a temporary list and\n * then are freed outside inode_lock by dispose_list().\n */\nlong prune_icache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(freeable);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_inode_lru, sc,\n\t\t\t\t     inode_lru_isolate, &freeable);\n\tdispose_list(&freeable);\n\treturn freed;\n}\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n/*\n * Called with the inode lock held.\n */\nstatic struct inode *find_inode(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head,\n\t\t\t\tint (*test)(struct inode *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tif (!test(inode, data))\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}\n\n/*\n * find_inode_fast is the fast path version of find_inode, see the comment at\n * iget_locked for details.\n */\nstatic struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}\n\n/*\n * Each cpu owns a range of LAST_INO_BATCH numbers.\n * 'shared_last_ino' is dirtied only once out of LAST_INO_BATCH allocations,\n * to renew the exhausted range.\n *\n * This does not significantly increase overflow rate because every CPU can\n * consume at most LAST_INO_BATCH-1 unused inode numbers. So there is\n * NR_CPUS*(LAST_INO_BATCH-1) wastage. At 4096 and 1024, this is ~0.1% of the\n * 2^32 range, and is a worst-case. Even a 50% wastage would only increase\n * overflow rate by 2x, which does not seem too significant.\n *\n * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n * error if st_ino won't fit in target struct field. Use 32bit counter\n * here to attempt to avoid that.\n */\n#define LAST_INO_BATCH 1024\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}\nEXPORT_SYMBOL(get_next_ino);\n\n/**\n *\tnew_inode_pseudo \t- obtain an inode\n *\t@sb: superblock\n *\n *\tAllocates a new inode for given superblock.\n *\tInode wont be chained in superblock s_inodes list\n *\tThis means :\n *\t- fs can't be unmount\n *\t- quotas, fsnotify, writeback can't work\n */\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}\n\n/**\n *\tnew_inode \t- obtain an inode\n *\t@sb: superblock\n *\n *\tAllocates a new inode for given superblock. The default gfp_mask\n *\tfor allocations related to inode->i_mapping is GFP_HIGHUSER_MOVABLE.\n *\tIf HIGHMEM pages are unsuitable or it is known that pages allocated\n *\tfor the page cache are not reclaimable or migratable,\n *\tmapping_set_gfp_mask() must be called with suitable flags on the\n *\tnewly created inode's mapping\n *\n */\nstruct inode *new_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tspin_lock_prefetch(&sb->s_inode_list_lock);\n\n\tinode = new_inode_pseudo(sb);\n\tif (inode)\n\t\tinode_sb_list_add(inode);\n\treturn inode;\n}\nEXPORT_SYMBOL(new_inode);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(lockdep_annotate_inode_mutex_key);\n#endif\n\n/**\n * unlock_new_inode - clear the I_NEW state and wake up any waiters\n * @inode:\tnew inode to unlock\n *\n * Called when the inode is fully initialised to clear the new state of the\n * inode and wake up anyone waiting for the inode to finish initialisation.\n */\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}\nEXPORT_SYMBOL(unlock_new_inode);\n\n/**\n * lock_two_nondirectories - take two i_mutexes on non-directory objects\n *\n * Lock any non-NULL argument that is not a directory.\n * Zero, one or two objects may be locked by this function.\n *\n * @inode1: first inode to lock\n * @inode2: second inode to lock\n */\nvoid lock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 > inode2)\n\t\tswap(inode1, inode2);\n\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tinode_lock(inode1);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tinode_lock_nested(inode2, I_MUTEX_NONDIR2);\n}\nEXPORT_SYMBOL(lock_two_nondirectories);\n\n/**\n * unlock_two_nondirectories - release locks from lock_two_nondirectories()\n * @inode1: first inode to unlock\n * @inode2: second inode to unlock\n */\nvoid unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tinode_unlock(inode1);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tinode_unlock(inode2);\n}\nEXPORT_SYMBOL(unlock_two_nondirectories);\n\n/**\n * inode_insert5 - obtain an inode from a mounted file system\n * @inode:\tpre-allocated inode to use for insert to cache\n * @hashval:\thash value (usually inode number) to get\n * @test:\tcallback used for comparisons between inodes\n * @set:\tcallback used to initialize a new struct inode\n * @data:\topaque data pointer to pass to @test and @set\n *\n * Search for the inode specified by @hashval and @data in the inode cache,\n * and if present it is return it with an increased reference count. This is\n * a variant of iget5_locked() for callers that don't want to fail on memory\n * allocation of inode.\n *\n * If the inode is not in cache, insert the pre-allocated inode to cache and\n * return it locked, hashed, and with the I_NEW flag set. The file system gets\n * to fill it in before unlocking it via unlock_new_inode().\n *\n * Note both @test and @set are called with the inode_hash_lock held, so can't\n * sleep.\n */\nstruct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}\nEXPORT_SYMBOL(inode_insert5);\n\n/**\n * iget5_locked - obtain an inode from a mounted file system\n * @sb:\t\tsuper block of file system\n * @hashval:\thash value (usually inode number) to get\n * @test:\tcallback used for comparisons between inodes\n * @set:\tcallback used to initialize a new struct inode\n * @data:\topaque data pointer to pass to @test and @set\n *\n * Search for the inode specified by @hashval and @data in the inode cache,\n * and if present it is return it with an increased reference count. This is\n * a generalized version of iget_locked() for file systems where the inode\n * number is not sufficient for unique identification of an inode.\n *\n * If the inode is not in cache, allocate a new inode and return it locked,\n * hashed, and with the I_NEW flag set. The file system gets to fill it in\n * before unlocking it via unlock_new_inode().\n *\n * Note both @test and @set are called with the inode_hash_lock held, so can't\n * sleep.\n */\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5(sb, hashval, test, data);\n\n\tif (!inode) {\n\t\tstruct inode *new = new_inode(sb);\n\n\t\tif (new) {\n\t\t\tinode = inode_insert5(new, hashval, test, set, data);\n\t\t\tif (unlikely(inode != new))\n\t\t\t\tiput(new);\n\t\t}\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(iget5_locked);\n\n/**\n * iget_locked - obtain an inode from a mounted file system\n * @sb:\t\tsuper block of file system\n * @ino:\tinode number to get\n *\n * Search for the inode specified by @ino in the inode cache and if present\n * return it with an increased reference count. This is for file systems\n * where the inode number is sufficient for unique identification of an inode.\n *\n * If the inode is not in cache, allocate a new inode and return it locked,\n * hashed, and with the I_NEW flag set.  The file system gets to fill it in\n * before unlocking it via unlock_new_inode().\n */\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\nagain:\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(iget_locked);\n\n/*\n * search the inode cache for a matching inode number.\n * If we find one, then the inode number we are trying to\n * allocate is not unique and so we should not use it.\n *\n * Returns 1 if the inode number is unique, 0 if it is not.\n */\nstatic int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}\n\n/**\n *\tiunique - get a unique inode number\n *\t@sb: superblock\n *\t@max_reserved: highest reserved inode number\n *\n *\tObtain an inode number that is unique on the system for a given\n *\tsuperblock. This is used by file systems that have no natural\n *\tpermanent inode numbering system. An inode number is returned that\n *\tis higher than the reserved limit but unique.\n *\n *\tBUGS:\n *\tWith a large number of inodes live on the file system this function\n *\tcurrently becomes quite slow.\n */\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}\nEXPORT_SYMBOL(iunique);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(igrab);\n\n/**\n * ilookup5_nowait - search for an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @hashval:\thash value (usually inode number) to search for\n * @test:\tcallback used for comparisons between inodes\n * @data:\topaque data pointer to pass to @test\n *\n * Search for the inode specified by @hashval and @data in the inode cache.\n * If the inode is in the cache, the inode is returned with an incremented\n * reference count.\n *\n * Note: I_NEW is not waited upon so you have to be very careful what you do\n * with the returned inode.  You probably should be using ilookup5() instead.\n *\n * Note2: @test is called with the inode_hash_lock held, so can't sleep.\n */\nstruct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}\nEXPORT_SYMBOL(ilookup5_nowait);\n\n/**\n * ilookup5 - search for an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @hashval:\thash value (usually inode number) to search for\n * @test:\tcallback used for comparisons between inodes\n * @data:\topaque data pointer to pass to @test\n *\n * Search for the inode specified by @hashval and @data in the inode cache,\n * and if the inode is in the cache, return the inode with an incremented\n * reference count.  Waits on I_NEW before returning the inode.\n * returned with an incremented reference count.\n *\n * This is a generalized version of ilookup() for file systems where the\n * inode number is not sufficient for unique identification of an inode.\n *\n * Note: @test is called with the inode_hash_lock held, so can't sleep.\n */\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode;\nagain:\n\tinode = ilookup5_nowait(sb, hashval, test, data);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(ilookup5);\n\n/**\n * ilookup - search for an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @ino:\tinode number to search for\n *\n * Search for the inode @ino in the inode cache, and if the inode is in the\n * cache, the inode is returned with an incremented reference count.\n */\nstruct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\nagain:\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}\nEXPORT_SYMBOL(ilookup);\n\n/**\n * find_inode_nowait - find an inode in the inode cache\n * @sb:\t\tsuper block of file system to search\n * @hashval:\thash value (usually inode number) to search for\n * @match:\tcallback used for comparisons between inodes\n * @data:\topaque data pointer to pass to @match\n *\n * Search for the inode specified by @hashval and @data in the inode\n * cache, where the helper function @match will return 0 if the inode\n * does not match, 1 if the inode does match, and -1 if the search\n * should be stopped.  The @match function must be responsible for\n * taking the i_lock spin_lock and checking i_state for an inode being\n * freed or being initialized, and incrementing the reference count\n * before returning 1.  It also must not sleep, since it is called with\n * the inode_hash_lock spinlock held.\n *\n * This is a even more generalized version of ilookup5() when the\n * function must never block --- find_inode() can block in\n * __wait_on_freeing_inode() --- or when the caller can not increment\n * the reference count because the resulting iput() might cause an\n * inode eviction.  The tradeoff is that the @match funtion must be\n * very carefully implemented.\n */\nstruct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}\nEXPORT_SYMBOL(find_inode_nowait);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}\nEXPORT_SYMBOL(insert_inode_locked);\n\nint insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *old = inode_insert5(inode, hashval, test, NULL, data);\n\n\tif (old != inode) {\n\t\tiput(old);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(insert_inode_locked4);\n\n\nint generic_delete_inode(struct inode *inode)\n{\n\treturn 1;\n}\nEXPORT_SYMBOL(generic_delete_inode);\n\n/*\n * Called when we're dropping the last reference\n * to an inode.\n *\n * Call the FS \"drop_inode()\" function, defaulting to\n * the legacy UNIX filesystem behaviour.  If it tells\n * us to evict inode, do so.  Otherwise, retain inode\n * in cache if fs is alive, sync and evict if fs is\n * shutting down.\n */\nstatic void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & SB_ACTIVE)) {\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}\n\n/**\n *\tiput\t- put an inode\n *\t@inode: inode to put\n *\n *\tPuts an inode, dropping its usage count. If the inode use count hits\n *\tzero, the inode is then freed and may also be destroyed.\n *\n *\tConsequently, iput() can sleep.\n */\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}\nEXPORT_SYMBOL(iput);\n\n/**\n *\tbmap\t- find a block number in a file\n *\t@inode: inode of file\n *\t@block: block to find\n *\n *\tReturns the block number on the device holding the inode that\n *\tis the disk block number for the block of the file requested.\n *\tThat is, asked for block 4 of inode 1 the function will return the\n *\tdisk block relative to the disk start that holds that block of the\n *\tfile.\n */\nsector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}\nEXPORT_SYMBOL(bmap);\n\n/*\n * Update times in overlayed inode from underlying real inode\n */\nstatic void update_ovl_inode_times(struct dentry *dentry, struct inode *inode,\n\t\t\t       bool rcu)\n{\n\tstruct dentry *upperdentry;\n\n\t/*\n\t * Nothing to do if in rcu or if non-overlayfs\n\t */\n\tif (rcu || likely(!(dentry->d_flags & DCACHE_OP_REAL)))\n\t\treturn;\n\n\tupperdentry = d_real(dentry, NULL, 0, D_REAL_UPPER);\n\n\t/*\n\t * If file is on lower then we can't update atime, so no worries about\n\t * stale mtime/ctime.\n\t */\n\tif (upperdentry) {\n\t\tstruct inode *realinode = d_inode(upperdentry);\n\n\t\tif ((!timespec64_equal(&inode->i_mtime, &realinode->i_mtime) ||\n\t\t     !timespec64_equal(&inode->i_ctime, &realinode->i_ctime))) {\n\t\t\tinode->i_mtime = realinode->i_mtime;\n\t\t\tinode->i_ctime = realinode->i_ctime;\n\t\t}\n\t}\n}\n\n/*\n * With relative atime, only update atime if the previous atime is\n * earlier than either the ctime or mtime or if at least a day has\n * passed since the last atime update.\n */\nstatic int relatime_need_update(const struct path *path, struct inode *inode,\n\t\t\t\tstruct timespec now, bool rcu)\n{\n\n\tif (!(path->mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\n\tupdate_ovl_inode_times(path->dentry, inode, rcu);\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}\n\nint generic_update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint iflags = I_DIRTY_TIME;\n\tbool dirty = false;\n\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *time;\n\tif (flags & S_VERSION)\n\t\tdirty = inode_maybe_inc_iversion(inode, false);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *time;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *time;\n\tif ((flags & (S_ATIME | S_CTIME | S_MTIME)) &&\n\t    !(inode->i_sb->s_flags & SB_LAZYTIME))\n\t\tdirty = true;\n\n\tif (dirty)\n\t\tiflags |= I_DIRTY_SYNC;\n\t__mark_inode_dirty(inode, iflags);\n\treturn 0;\n}\nEXPORT_SYMBOL(generic_update_time);\n\n/*\n * This does the actual work of updating an inodes time or version.  Must have\n * had called mnt_want_write() before calling this.\n */\nstatic int update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}\n\n/**\n *\ttouch_atime\t-\tupdate the access time\n *\t@path: the &struct path to update\n *\t@inode: inode to update\n *\n *\tUpdate the accessed time on an inode and mark it for writeback.\n *\tThis function automatically handles read only file systems and media,\n *\tas well as the \"noatime\" flag and inode specific \"noatime\" markers.\n */\nbool __atime_needs_update(const struct path *path, struct inode *inode,\n\t\t\t  bool rcu)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct timespec64 now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn false;\n\n\t/* Atime updates will likely cause i_uid and i_gid to be written\n\t * back improprely if their true value is unknown to the vfs.\n\t */\n\tif (HAS_UNMAPPED_ID(inode))\n\t\treturn false;\n\n\tif (IS_NOATIME(inode))\n\t\treturn false;\n\tif ((inode->i_sb->s_flags & SB_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn false;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tnow = current_time(inode);\n\n\tif (!relatime_need_update(path, inode, timespec64_to_timespec(now), rcu))\n\t\treturn false;\n\n\tif (timespec64_equal(&inode->i_atime, &now))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct timespec64 now;\n\n\tif (!__atime_needs_update(path, inode, false))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt) != 0)\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tnow = current_time(inode);\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}\nEXPORT_SYMBOL(touch_atime);\n\n/*\n * The logic we want is\n *\n *\tif suid or (sgid and xgrp)\n *\t\tremove privs\n */\nint should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = d_inode(dentry)->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(should_remove_suid);\n\n/*\n * Return mask of changes for notify_change() that need to be done as a\n * response to write or truncate. Return 0 if nothing has to be changed.\n * Negative value on error (change should be denied).\n */\nint dentry_needs_remove_privs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint mask = 0;\n\tint ret;\n\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tmask = should_remove_suid(dentry);\n\tret = security_inode_need_killpriv(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tmask |= ATTR_KILL_PRIV;\n\treturn mask;\n}\n\nstatic int __remove_privs(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}\n\n/*\n * Remove special file priviledges (suid, capabilities) when file is written\n * to or truncated.\n */\nint file_remove_privs(struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = file_inode(file);\n\tint kill;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkill = dentry_needs_remove_privs(dentry);\n\tif (kill < 0)\n\t\treturn kill;\n\tif (kill)\n\t\terror = __remove_privs(dentry, kill);\n\tif (!error)\n\t\tinode_has_no_xattr(inode);\n\n\treturn error;\n}\nEXPORT_SYMBOL(file_remove_privs);\n\n/**\n *\tfile_update_time\t-\tupdate mtime and ctime time\n *\t@file: file accessed\n *\n *\tUpdate the mtime and ctime members of an inode and mark the inode\n *\tfor writeback.  Note that this function is meant exclusively for\n *\tusage in the file write path of filesystems, and filesystems may\n *\tchoose to explicitly ignore update via this function with the\n *\tS_NOCMTIME inode flag, e.g. for network filesystem where these\n *\ttimestamps are handled by the server.  This can return an error for\n *\tfile systems who need to allocate space in order to update an inode.\n */\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec64 now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_time(inode);\n\tif (!timespec64_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec64_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode) && inode_iversion_need_inc(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(file_update_time);\n\nint inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(inode_needs_sync);\n\n/*\n * If we try to find an inode in the inode hash while it is being\n * deleted, we have to wait until the filesystem completes its\n * deletion before reporting that it isn't found.  This function waits\n * until the deletion _might_ have completed.  Callers are responsible\n * to recheck inode state.\n *\n * It doesn't matter if I_NEW is not set initially, a call to\n * wake_up_bit(&inode->i_state, __I_NEW) after removing from the hash list\n * will DTRT.\n */\nstatic void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wq_entry);\n\tspin_lock(&inode_hash_lock);\n}\n\nstatic __initdata unsigned long ihash_entries;\nstatic int __init set_ihash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tihash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}\n__setup(\"ihash_entries=\", set_ihash_entries);\n\n/*\n * Initialize the waitqueues and inode hash table.\n */\nvoid __init inode_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}\n\nvoid __init inode_init(void)\n{\n\t/* inode slab cache */\n\tinode_cachep = kmem_cache_create(\"inode_cache\",\n\t\t\t\t\t sizeof(struct inode),\n\t\t\t\t\t 0,\n\t\t\t\t\t (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t init_once);\n\n\t/* Hash may have been set up in inode_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}\nEXPORT_SYMBOL(init_special_inode);\n\n/**\n * inode_init_owner - Init uid,gid,mode for new inode according to posix standards\n * @inode: New inode\n * @dir: Directory inode\n * @mode: mode of the new inode\n */\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\n\t\t/* Directories are special, and always inherit S_ISGID */\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}\nEXPORT_SYMBOL(inode_init_owner);\n\n/**\n * inode_owner_or_capable - check current task permissions to inode\n * @inode: inode being checked\n *\n * Return true if current either has CAP_FOWNER in a namespace with the\n * inode owner uid mapped, or owns the file.\n */\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL(inode_owner_or_capable);\n\n/*\n * Direct i/o helper functions\n */\nstatic void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wq_entry, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wq_entry);\n}\n\n/**\n * inode_dio_wait - wait for outstanding DIO requests to finish\n * @inode: inode to wait for\n *\n * Waits for all pending direct I/O requests to finish so that we can\n * proceed with a truncate or equivalent operation.\n *\n * Must be called under a lock that serializes taking new references\n * to i_dio_count, usually by inode->i_mutex.\n */\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}\nEXPORT_SYMBOL(inode_dio_wait);\n\n/*\n * inode_set_flags - atomically set some inode flags\n *\n * Note: the caller should be holding i_mutex, or else be sure that\n * they have exclusive access to the inode structure (i.e., while the\n * inode is being instantiated).  The reason for the cmpxchg() loop\n * --- which wouldn't be necessary if all code paths which modify\n * i_flags actually followed this rule, is that there is at least one\n * code path which doesn't today so we use cmpxchg() out of an abundance\n * of caution.\n *\n * In the long run, i_mutex is overkill, and we should probably look\n * at using the i_lock spinlock to protect i_flags, and then make sure\n * it is so documented in include/linux/fs.h and that all code follows\n * the locking convention!!\n */\nvoid inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = READ_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}\nEXPORT_SYMBOL(inode_set_flags);\n\nvoid inode_nohighmem(struct inode *inode)\n{\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_USER);\n}\nEXPORT_SYMBOL(inode_nohighmem);\n\n/**\n * timespec64_trunc - Truncate timespec64 to a granularity\n * @t: Timespec64\n * @gran: Granularity in ns.\n *\n * Truncate a timespec64 to a granularity. Always rounds down. gran must\n * not be 0 nor greater than a second (NSEC_PER_SEC, or 10^9 ns).\n */\nstruct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran)\n{\n\t/* Avoid division in the common cases 1 ns and 1 s. */\n\tif (gran == 1) {\n\t\t/* nothing */\n\t} else if (gran == NSEC_PER_SEC) {\n\t\tt.tv_nsec = 0;\n\t} else if (gran > 1 && gran < NSEC_PER_SEC) {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t} else {\n\t\tWARN(1, \"illegal file time granularity: %u\", gran);\n\t}\n\treturn t;\n}\nEXPORT_SYMBOL(timespec64_trunc);\n\n/**\n * current_time - Return FS time\n * @inode: inode.\n *\n * Return the current time truncated to the time granularity supported by\n * the fs.\n *\n * Note that inode and inode->sb cannot be NULL.\n * Otherwise, the function warns and returns time without truncation.\n */\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}\nEXPORT_SYMBOL(current_time);\n"], "filenames": ["fs/inode.c"], "buggy_code_start_loc": [2001], "buggy_code_end_loc": [2003], "fixing_code_start_loc": [2002], "fixing_code_end_loc": [2010], "type": "CWE-269", "message": "The inode_init_owner function in fs/inode.c in the Linux kernel through 3.16 allows local users to create files with an unintended group ownership, in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of that group. Here, the non-member can trigger creation of a plain file whose group ownership is that group. The intended behavior was that the non-member can trigger creation of a directory (but not a plain file) whose group ownership is that group. The non-member can escalate privileges by making the plain file executable and SGID.", "other": {"cve": {"id": "CVE-2018-13405", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-06T14:29:01.223", "lastModified": "2022-04-06T15:28:03.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The inode_init_owner function in fs/inode.c in the Linux kernel through 3.16 allows local users to create files with an unintended group ownership, in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of that group. Here, the non-member can trigger creation of a plain file whose group ownership is that group. The intended behavior was that the non-member can trigger creation of a directory (but not a plain file) whose group ownership is that group. The non-member can escalate privileges by making the plain file executable and SGID."}, {"lang": "es", "value": "La funci\u00f3n inode_init_owner en fs/inode.c en el kernel de Linux hasta la versi\u00f3n 3.16 permite a los usuarios locales crear archivos con una propiedad de grupo no deseada, en un escenario donde un directorio es SGID a un cierto grupo y es escribible por un usuario que no es miembro de ese grupo. En este caso, el no miembro puede desencadenar la creaci\u00f3n de un archivo simple cuya propiedad de grupo sea ese grupo. El comportamiento previsto era que el no miembro puede activar la creaci\u00f3n de un directorio (pero no un archivo plano) cuya propiedad de grupo sea ese grupo. El no miembro puede aumentar sus privilegios haciendo el archivo plano ejecutable y el SGID"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.16", "matchCriteriaId": "500A2ABC-14CF-439E-ABFB-60271177BA63"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:mrg_realtime:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "AFB0FFE3-4BE1-4024-BCC6-1B87074DE2E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6BBD7A51-0590-4DDF-8249-5AFA8D645CB6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "CB33390A-F51F-4451-8FEA-7FC31F1AA51C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "F96E3779-F56A-45FF-BB3D-4980527D721E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "0CF73560-2F5B-4723-A8A1-9AADBB3ADA00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_real_time:7:*:*:*:*:*:*:*", "matchCriteriaId": "C2B15608-BABC-4663-A58F-B74BD2D1A734"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "16E6D998-B41D-4B49-9E00-8336D2E40A4A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "1C8D871B-AEA1-4407-AEE3-47EC782250FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "6755B6AD-0422-467B-8115-34A60B1D1A40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D5F7E11E-FB34-4467-8919-2B6BEAABF665"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_access_policy_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "2E89CA5F-C65B-49B7-9B3F-4ED023B78069"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_access_policy_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "9432081E-3796-4A28-92EA-05E10A35CCDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_access_policy_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "E9170095-A9BB-4D24-9925-39256D7CE2C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_access_policy_manager:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "DCA6CE41-1D13-4A7A-94D8-C0D5740870A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_access_policy_manager:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "543B57B8-C1C7-4A70-976C-6E76FCB4E2AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_advanced_firewall_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "9AAC0F00-1726-4249-9681-43C7CED06E98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_advanced_firewall_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "C24412C3-72FC-40E9-8AED-E233649CDABF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_advanced_firewall_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "5B59E16D-7645-492A-9C1D-A8724FFCA28F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_advanced_firewall_manager:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "71B7081C-A869-402A-9C58-219B3225DB70"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_advanced_firewall_manager:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D52CFC7F-2A7F-4E23-8E6C-91B91436419C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_analytics:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "04C1A189-E227-4D17-9E48-035CCBCC0754"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_analytics:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "0579A45D-748E-49E5-A11A-A06253CC7895"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_analytics:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "92F370C2-3C5A-416D-83C1-A4F84866E958"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_analytics:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "08E29063-889A-4499-AEAC-D79165EA34A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_analytics:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4FCCA87-C81C-4DB9-B5CE-E24B7C504330"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "CB2B6684-7399-470B-B91C-B5F7A500A30C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "79180EBD-26CE-4012-A55C-320626E236B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "997D12F1-098D-4C42-A6A2-B4F59AC78F0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "5C32BB88-ECE9-49C1-B75D-D47A17399C10"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "99398E30-A7D1-4A88-BE09-524DEF26C8DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_security_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "5B226347-71D7-4235-8802-4C1F82EB948E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_security_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "2AD3FDA5-5E5A-41F9-ABB4-4C7A166A4A28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_security_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "E6C4B56F-D022-4268-9D78-6E4D12AE9215"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_security_manager:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "14612AC5-945C-4402-AFF0-5FCE11B7C785"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_security_manager:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "321CC6FB-A330-41AA-9E8D-1FC1A1E75884"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_domain_name_system:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "CF91F21C-80D9-42E2-8DD9-D523D05CA39A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_domain_name_system:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "EA7525A1-439A-495C-9D37-3D34D396BD61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_domain_name_system:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "EAFC0D83-7F64-44F2-A014-37DE3CAF846A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_domain_name_system:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "74DEDC05-82FC-4AD5-9DDD-D0D68DA9E26D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_domain_name_system:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "693F34DB-A79D-41E1-85E6-4B7BC2DCF7FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_edge_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "25CA8B66-C7A2-42DE-9FD4-620EBEC0B226"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_edge_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "6A2444CF-5BA9-4DD0-9910-C156F9FCDA27"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_edge_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "DC1CC599-DA9C-46BD-9C5C-FD25D57AE9D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_edge_gateway:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "76F48A48-9C6E-49CD-8C89-C4F75BF2982A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_edge_gateway:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "C026F902-7258-43A6-BB36-A72121BE72CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_fraud_protection_service:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "1102BBCB-6D9E-46AA-9DA2-A739A8159D8F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_fraud_protection_service:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "F0714D8F-01FA-4644-BEFD-587B28528727"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_fraud_protection_service:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "920BC3DD-A1D4-403B-83D2-00636C20FFC0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_fraud_protection_service:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "3E634D59-2B6D-49B8-A7BD-E2962CD2B455"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_fraud_protection_service:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "3836F05D-0EE6-441E-A498-FC3E25960CE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_global_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "50D80416-4AA8-4A26-9B0C-6AE5A84301E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_global_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "A599B58A-A3D5-4CC1-A090-8AD73BB579F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_global_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "49C8BE4A-DED6-451A-B6EE-AC95DD26F85A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_global_traffic_manager:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "5756EA61-D0E4-4AC1-882D-71EE4BB6CEB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_global_traffic_manager:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "7171DEF9-C5EB-490B-9BD5-4C7CB0331D61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_link_controller:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "07F2C5EE-2106-4FC1-9C43-2621330A1585"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_link_controller:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "6E51A79D-3602-4FC4-9FD9-07E64361B1F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_link_controller:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "DEC0E30F-6550-4BC9-8DA7-6BD495DBF415"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_link_controller:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "E847B072-2E86-416D-9D39-FD796770A0B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_link_controller:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "9AEF72B3-8334-4848-9835-614B6E1144FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_local_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "99A188D5-B165-4A11-B0CA-26C46F67C4BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_local_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "94BD1043-CF12-45FA-B64B-EF57EBD708F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_local_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "D5D90F4A-FA2A-412F-8591-D1CA6399ECAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_local_traffic_manager:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "461C4C1D-B0F9-44EF-A535-BCE9FE501A94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_local_traffic_manager:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "7543A048-FFC5-442C-A008-5E7458317F14"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_policy_enforcement_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "AE322801-EBC9-4B51-AAC2-1371111207AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_policy_enforcement_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "58D7CC86-ADC4-4E70-BC80-D8850B746420"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_policy_enforcement_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "BAD2867D-D646-4B01-A383-6A47B51D059E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_policy_enforcement_manager:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "C1C2B883-EA96-4B51-865B-B1DE1561096C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_policy_enforcement_manager:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "1F65E0AC-FDE1-485F-99AA-387096A02DD9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.0.0", "versionEndExcluding": "13.1.3.5", "matchCriteriaId": "CAEFCA7B-85ED-4825-A15D-E7357FC97AB0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.3.1", "matchCriteriaId": "4CD80613-FE83-46A3-B28E-EA9524214BC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.4", "matchCriteriaId": "126DC4FA-E5EB-43E1-83F9-19F29E852E03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:15.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "5C5A9DDF-C18B-4628-AE26-50FBDAD4654B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:16.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "A055174D-5D6D-43A2-9B36-AF81FD3196E2"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://openwall.com/lists/oss-security/2018/07/13/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/106503", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2948", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3083", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3096", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0717", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2476", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2566", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2696", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2730", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:4159", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:4164", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=0b3369840cd61c23e2b9241093737b4c395cb406", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00014.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HRBNBX73SAFKQWBOX76SLMWPTKJPVGEJ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MTKKIAUMR5FAYLZ7HLEPOXMKAAE3BYBQ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K00854051", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://twitter.com/grsecurity/status/1015082951204327425", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3753-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3753-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4266", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/45033/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7"}}