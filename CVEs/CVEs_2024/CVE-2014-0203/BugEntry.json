{"buggy_code": ["/*\n *  linux/fs/namei.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n * Some corrections by tytso.\n */\n\n/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname\n * lookup logic.\n */\n/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/ima.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/device_cgroup.h>\n#include <linux/fs_struct.h>\n#include <asm/uaccess.h>\n\n#include \"internal.h\"\n\n/* [Feb-1997 T. Schoebel-Theuer]\n * Fundamental changes in the pathname lookup mechanisms (namei)\n * were necessary because of omirr.  The reason is that omirr needs\n * to know the _real_ pathname, not the user-supplied one, in case\n * of symlinks (and also when transname replacements occur).\n *\n * The new code replaces the old recursive symlink resolution with\n * an iterative one (in case of non-nested symlink chains).  It does\n * this with calls to <fs>_follow_link().\n * As a side effect, dir_namei(), _namei() and follow_link() are now \n * replaced with a single function lookup_dentry() that can handle all \n * the special cases of the former code.\n *\n * With the new dcache, the pathname is stored at each inode, at least as\n * long as the refcount of the inode is positive.  As a side effect, the\n * size of the dcache depends on the inode cache and thus is dynamic.\n *\n * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink\n * resolution to correspond with current state of the code.\n *\n * Note that the symlink resolution is not *completely* iterative.\n * There is still a significant amount of tail- and mid- recursion in\n * the algorithm.  Also, note that <fs>_readlink() is not used in\n * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()\n * may return different results than <fs>_follow_link().  Many virtual\n * filesystems (including /proc) exhibit this behavior.\n */\n\n/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:\n * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL\n * and the name already exists in form of a symlink, try to create the new\n * name indicated by the symlink. The old code always complained that the\n * name already exists, due to not following the symlink even if its target\n * is nonexistent.  The new semantics affects also mknod() and link() when\n * the name is a symlink pointing to a non-existant name.\n *\n * I don't know which semantics is the right one, since I have no access\n * to standards. But I found by trial that HP-UX 9.0 has the full \"new\"\n * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the\n * \"old\" one. Personally, I think the new semantics is much more logical.\n * Note that \"ln old new\" where \"new\" is a symlink pointing to a non-existing\n * file does succeed in both HP-UX and SunOs, but not in Solaris\n * and in the old Linux semantics.\n */\n\n/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink\n * semantics.  See the comments in \"open_namei\" and \"do_link\" below.\n *\n * [10-Sep-98 Alan Modra] Another symlink change.\n */\n\n/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:\n *\tinside the path - always follow.\n *\tin the last component in creation/removal/renaming - never follow.\n *\tif LOOKUP_FOLLOW passed - follow.\n *\tif the pathname has trailing slashes - follow.\n *\totherwise - don't follow.\n * (applied in that order).\n *\n * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT\n * restored for 2.4. This is the last surviving part of old 4.2BSD bug.\n * During the 2.4 we need to fix the userland stuff depending on it -\n * hopefully we will be able to get rid of that wart in 2.5. So far only\n * XEmacs seems to be relying on it...\n */\n/*\n * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)\n * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives\n * any extra contention...\n */\n\n/* In order to reduce some races, while at the same time doing additional\n * checking and hopefully speeding things up, we copy filenames to the\n * kernel data space before using them..\n *\n * POSIX.1 2.4: an empty pathname is invalid (ENOENT).\n * PATH_MAX includes the nul terminator --RR.\n */\nstatic int do_getname(const char __user *filename, char *page)\n{\n\tint retval;\n\tunsigned long len = PATH_MAX;\n\n\tif (!segment_eq(get_fs(), KERNEL_DS)) {\n\t\tif ((unsigned long) filename >= TASK_SIZE)\n\t\t\treturn -EFAULT;\n\t\tif (TASK_SIZE - (unsigned long) filename < PATH_MAX)\n\t\t\tlen = TASK_SIZE - (unsigned long) filename;\n\t}\n\n\tretval = strncpy_from_user(page, filename, len);\n\tif (retval > 0) {\n\t\tif (retval < len)\n\t\t\treturn 0;\n\t\treturn -ENAMETOOLONG;\n\t} else if (!retval)\n\t\tretval = -ENOENT;\n\treturn retval;\n}\n\nchar * getname(const char __user * filename)\n{\n\tchar *tmp, *result;\n\n\tresult = ERR_PTR(-ENOMEM);\n\ttmp = __getname();\n\tif (tmp)  {\n\t\tint retval = do_getname(filename, tmp);\n\n\t\tresult = tmp;\n\t\tif (retval < 0) {\n\t\t\t__putname(tmp);\n\t\t\tresult = ERR_PTR(retval);\n\t\t}\n\t}\n\taudit_getname(result);\n\treturn result;\n}\n\n#ifdef CONFIG_AUDITSYSCALL\nvoid putname(const char *name)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\taudit_putname(name);\n\telse\n\t\t__putname(name);\n}\nEXPORT_SYMBOL(putname);\n#endif\n\n/*\n * This does basic POSIX ACL permission checking\n */\nstatic int acl_permission_check(struct inode *inode, int mask,\n\t\tint (*check_acl)(struct inode *inode, int mask))\n{\n\tumode_t\t\t\tmode = inode->i_mode;\n\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\n\tif (current_fsuid() == inode->i_uid)\n\t\tmode >>= 6;\n\telse {\n\t\tif (IS_POSIXACL(inode) && (mode & S_IRWXG) && check_acl) {\n\t\t\tint error = check_acl(inode, mask);\n\t\t\tif (error != -EAGAIN)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tmode >>= 3;\n\t}\n\n\t/*\n\t * If the DACs are ok we don't need any capability check.\n\t */\n\tif ((mask & ~mode) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/**\n * generic_permission  -  check for access rights on a Posix-like filesystem\n * @inode:\tinode to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n * @check_acl:\toptional callback to check for Posix ACLs\n *\n * Used to check for read/write/execute permissions on a file.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things..\n */\nint generic_permission(struct inode *inode, int mask,\n\t\tint (*check_acl)(struct inode *inode, int mask))\n{\n\tint ret;\n\n\t/*\n\t * Do the basic POSIX ACL permission checks.\n\t */\n\tret = acl_permission_check(inode, mask, check_acl);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable if at least one exec bit is set.\n\t */\n\tif (!(mask & MAY_EXEC) || execute_ok(inode))\n\t\tif (capable(CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ || (S_ISDIR(inode->i_mode) && !(mask & MAY_WRITE)))\n\t\tif (capable(CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\n\n/**\n * inode_permission  -  check for access rights to a given inode\n * @inode:\tinode to check permission on\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Used to check for read/write/execute permissions on an inode.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things.\n */\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tif (mask & MAY_WRITE) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\t/*\n\t\t * Nobody gets write access to a read-only fs.\n\t\t */\n\t\tif (IS_RDONLY(inode) &&\n\t\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\treturn -EROFS;\n\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (inode->i_op->permission)\n\t\tretval = inode->i_op->permission(inode, mask);\n\telse\n\t\tretval = generic_permission(inode, mask, inode->i_op->check_acl);\n\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode,\n\t\t\tmask & (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND));\n}\n\n/**\n * file_permission  -  check for additional access rights to a given file\n * @file:\tfile to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Used to check for read/write/execute permissions on an already opened\n * file.\n *\n * Note:\n *\tDo not use this function in new code.  All access checks should\n *\tbe done using inode_permission().\n */\nint file_permission(struct file *file, int mask)\n{\n\treturn inode_permission(file->f_path.dentry->d_inode, mask);\n}\n\n/*\n * get_write_access() gets write permission for a file.\n * put_write_access() releases this write permission.\n * This is used for regular files.\n * We cannot support write (and maybe mmap read-write shared) accesses and\n * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode\n * can have the following values:\n * 0: no writers, no VM_DENYWRITE mappings\n * < 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist\n * > 0: (i_writecount) users are writing to the file.\n *\n * Normally we operate on that counter with atomic_{inc,dec} and it's safe\n * except for the cases where we don't hold i_writecount yet. Then we need to\n * use {get,deny}_write_access() - these functions check the sign and refuse\n * to do the change if sign is wrong. Exclusion between them is provided by\n * the inode->i_lock spinlock.\n */\n\nint get_write_access(struct inode * inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (atomic_read(&inode->i_writecount) < 0) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn -ETXTBSY;\n\t}\n\tatomic_inc(&inode->i_writecount);\n\tspin_unlock(&inode->i_lock);\n\n\treturn 0;\n}\n\nint deny_write_access(struct file * file)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\n\tspin_lock(&inode->i_lock);\n\tif (atomic_read(&inode->i_writecount) > 0) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn -ETXTBSY;\n\t}\n\tatomic_dec(&inode->i_writecount);\n\tspin_unlock(&inode->i_lock);\n\n\treturn 0;\n}\n\n/**\n * path_get - get a reference to a path\n * @path: path to get the reference to\n *\n * Given a path increment the reference count to the dentry and the vfsmount.\n */\nvoid path_get(struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}\nEXPORT_SYMBOL(path_get);\n\n/**\n * path_put - put a reference to a path\n * @path: path to put the reference to\n *\n * Given a path decrement the reference count to the dentry and the vfsmount.\n */\nvoid path_put(struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\nEXPORT_SYMBOL(path_put);\n\n/**\n * release_open_intent - free up open intent resources\n * @nd: pointer to nameidata\n */\nvoid release_open_intent(struct nameidata *nd)\n{\n\tif (nd->intent.open.file->f_path.dentry == NULL)\n\t\tput_filp(nd->intent.open.file);\n\telse\n\t\tfput(nd->intent.open.file);\n}\n\nstatic inline struct dentry *\ndo_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tint status = dentry->d_op->d_revalidate(dentry, nd);\n\tif (unlikely(status <= 0)) {\n\t\t/*\n\t\t * The dentry failed validation.\n\t\t * If d_revalidate returned 0 attempt to invalidate\n\t\t * the dentry otherwise d_revalidate is asking us\n\t\t * to return a fail status.\n\t\t */\n\t\tif (!status) {\n\t\t\tif (!d_invalidate(dentry)) {\n\t\t\t\tdput(dentry);\n\t\t\t\tdentry = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(status);\n\t\t}\n\t}\n\treturn dentry;\n}\n\n/*\n * force_reval_path - force revalidation of a dentry\n *\n * In some situations the path walking code will trust dentries without\n * revalidating them. This causes problems for filesystems that depend on\n * d_revalidate to handle file opens (e.g. NFSv4). When FS_REVAL_DOT is set\n * (which indicates that it's possible for the dentry to go stale), force\n * a d_revalidate call before proceeding.\n *\n * Returns 0 if the revalidation was successful. If the revalidation fails,\n * either return the error returned by d_revalidate or -ESTALE if the\n * revalidation it just returned 0. If d_revalidate returns 0, we attempt to\n * invalidate the dentry. It's up to the caller to handle putting references\n * to the path if necessary.\n */\nstatic int\nforce_reval_path(struct path *path, struct nameidata *nd)\n{\n\tint status;\n\tstruct dentry *dentry = path->dentry;\n\n\t/*\n\t * only check on filesystems where it's possible for the dentry to\n\t * become stale. It's assumed that if this flag is set then the\n\t * d_revalidate op will also be defined.\n\t */\n\tif (!(dentry->d_sb->s_type->fs_flags & FS_REVAL_DOT))\n\t\treturn 0;\n\n\tstatus = dentry->d_op->d_revalidate(dentry, nd);\n\tif (status > 0)\n\t\treturn 0;\n\n\tif (!status) {\n\t\td_invalidate(dentry);\n\t\tstatus = -ESTALE;\n\t}\n\treturn status;\n}\n\n/*\n * Short-cut version of permission(), for calling on directories\n * during pathname resolution.  Combines parts of permission()\n * and generic_permission(), and tests ONLY for MAY_EXEC permission.\n *\n * If appropriate, check DAC only.  If not appropriate, or\n * short-cut DAC fails, then call ->permission() to do more\n * complete permission check.\n */\nstatic int exec_permission(struct inode *inode)\n{\n\tint ret;\n\n\tif (inode->i_op->permission) {\n\t\tret = inode->i_op->permission(inode, MAY_EXEC);\n\t\tif (!ret)\n\t\t\tgoto ok;\n\t\treturn ret;\n\t}\n\tret = acl_permission_check(inode, MAY_EXEC, inode->i_op->check_acl);\n\tif (!ret)\n\t\tgoto ok;\n\n\tif (capable(CAP_DAC_OVERRIDE) || capable(CAP_DAC_READ_SEARCH))\n\t\tgoto ok;\n\n\treturn ret;\nok:\n\treturn security_inode_permission(inode, MAY_EXEC);\n}\n\nstatic __always_inline void set_root(struct nameidata *nd)\n{\n\tif (!nd->root.mnt) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tread_lock(&fs->lock);\n\t\tnd->root = fs->root;\n\t\tpath_get(&nd->root);\n\t\tread_unlock(&fs->lock);\n\t}\n}\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstatic __always_inline int __vfs_follow_link(struct nameidata *nd, const char *link)\n{\n\tint res = 0;\n\tchar *name;\n\tif (IS_ERR(link))\n\t\tgoto fail;\n\n\tif (*link == '/') {\n\t\tset_root(nd);\n\t\tpath_put(&nd->path);\n\t\tnd->path = nd->root;\n\t\tpath_get(&nd->root);\n\t}\n\n\tres = link_path_walk(link, nd);\n\tif (nd->depth || res || nd->last_type!=LAST_NORM)\n\t\treturn res;\n\t/*\n\t * If it is an iterative symlinks resolution in open_namei() we\n\t * have to copy the last component. And all that crap because of\n\t * bloody create() on broken symlinks. Furrfu...\n\t */\n\tname = __getname();\n\tif (unlikely(!name)) {\n\t\tpath_put(&nd->path);\n\t\treturn -ENOMEM;\n\t}\n\tstrcpy(name, nd->last.name);\n\tnd->last.name = name;\n\treturn 0;\nfail:\n\tpath_put(&nd->path);\n\treturn PTR_ERR(link);\n}\n\nstatic void path_put_conditional(struct path *path, struct nameidata *nd)\n{\n\tdput(path->dentry);\n\tif (path->mnt != nd->path.mnt)\n\t\tmntput(path->mnt);\n}\n\nstatic inline void path_to_nameidata(struct path *path, struct nameidata *nd)\n{\n\tdput(nd->path.dentry);\n\tif (nd->path.mnt != path->mnt)\n\t\tmntput(nd->path.mnt);\n\tnd->path.mnt = path->mnt;\n\tnd->path.dentry = path->dentry;\n}\n\nstatic __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n\t\tdget(dentry);\n\t}\n\tmntget(path->mnt);\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(cookie);\n\tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}\n\n/*\n * This limits recursive symlink follows to 8, while\n * limiting consecutive symlinks to 40.\n *\n * Without that kind of total limit, nasty chains of consecutive\n * symlinks can cause almost arbitrarily long lookups. \n */\nstatic inline int do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint err = -ELOOP;\n\tif (current->link_count >= MAX_NESTED_LINKS)\n\t\tgoto loop;\n\tif (current->total_link_count >= 40)\n\t\tgoto loop;\n\tBUG_ON(nd->depth >= MAX_NESTED_LINKS);\n\tcond_resched();\n\terr = security_inode_follow_link(path->dentry, nd);\n\tif (err)\n\t\tgoto loop;\n\tcurrent->link_count++;\n\tcurrent->total_link_count++;\n\tnd->depth++;\n\terr = __do_follow_link(path, nd);\n\tpath_put(path);\n\tcurrent->link_count--;\n\tnd->depth--;\n\treturn err;\nloop:\n\tpath_put_conditional(path, nd);\n\tpath_put(&nd->path);\n\treturn err;\n}\n\nint follow_up(struct path *path)\n{\n\tstruct vfsmount *parent;\n\tstruct dentry *mountpoint;\n\tspin_lock(&vfsmount_lock);\n\tparent = path->mnt->mnt_parent;\n\tif (parent == path->mnt) {\n\t\tspin_unlock(&vfsmount_lock);\n\t\treturn 0;\n\t}\n\tmntget(parent);\n\tmountpoint = dget(path->mnt->mnt_mountpoint);\n\tspin_unlock(&vfsmount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = parent;\n\treturn 1;\n}\n\n/* no need for dcache_lock, as serialization is taken care in\n * namespace.c\n */\nstatic int __follow_mount(struct path *path)\n{\n\tint res = 0;\n\twhile (d_mountpoint(path->dentry)) {\n\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tdput(path->dentry);\n\t\tif (res)\n\t\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\tres = 1;\n\t}\n\treturn res;\n}\n\nstatic void follow_mount(struct path *path)\n{\n\twhile (d_mountpoint(path->dentry)) {\n\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t}\n}\n\n/* no need for dcache_lock, as serialization is taken care in\n * namespace.c\n */\nint follow_down(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __always_inline void follow_dotdot(struct nameidata *nd)\n{\n\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct vfsmount *parent;\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tspin_lock(&dcache_lock);\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget(nd->path.dentry->d_parent);\n\t\t\tspin_unlock(&dcache_lock);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&dcache_lock);\n\t\tspin_lock(&vfsmount_lock);\n\t\tparent = nd->path.mnt->mnt_parent;\n\t\tif (parent == nd->path.mnt) {\n\t\t\tspin_unlock(&vfsmount_lock);\n\t\t\tbreak;\n\t\t}\n\t\tmntget(parent);\n\t\tnd->path.dentry = dget(nd->path.mnt->mnt_mountpoint);\n\t\tspin_unlock(&vfsmount_lock);\n\t\tdput(old);\n\t\tmntput(nd->path.mnt);\n\t\tnd->path.mnt = parent;\n\t}\n\tfollow_mount(&nd->path);\n}\n\n/*\n *  It's more convoluted than I'd like it to be, but... it's still fairly\n *  small and for now I'd prefer to have fast path as straight as possible.\n *  It _is_ time-critical.\n */\nstatic int do_lookup(struct nameidata *nd, struct qstr *name,\n\t\t     struct path *path)\n{\n\tstruct vfsmount *mnt = nd->path.mnt;\n\tstruct dentry *dentry, *parent;\n\tstruct inode *dir;\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (nd->path.dentry->d_op && nd->path.dentry->d_op->d_hash) {\n\t\tint err = nd->path.dentry->d_op->d_hash(nd->path.dentry, name);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tdentry = __d_lookup(nd->path.dentry, name);\n\tif (!dentry)\n\t\tgoto need_lookup;\n\tif (dentry->d_op && dentry->d_op->d_revalidate)\n\t\tgoto need_revalidate;\ndone:\n\tpath->mnt = mnt;\n\tpath->dentry = dentry;\n\t__follow_mount(path);\n\treturn 0;\n\nneed_lookup:\n\tparent = nd->path.dentry;\n\tdir = parent->d_inode;\n\n\tmutex_lock(&dir->i_mutex);\n\t/*\n\t * First re-do the cached lookup just in case it was created\n\t * while we waited for the directory semaphore..\n\t *\n\t * FIXME! This could use version numbering or similar to\n\t * avoid unnecessary cache lookups.\n\t *\n\t * The \"dcache_lock\" is purely to protect the RCU list walker\n\t * from concurrent renames at this point (we mustn't get false\n\t * negatives from the RCU list walk here, unlike the optimistic\n\t * fast walk).\n\t *\n\t * so doing d_lookup() (with seqlock), instead of lockfree __d_lookup\n\t */\n\tdentry = d_lookup(parent, name);\n\tif (!dentry) {\n\t\tstruct dentry *new;\n\n\t\t/* Don't create child dentry for a dead directory. */\n\t\tdentry = ERR_PTR(-ENOENT);\n\t\tif (IS_DEADDIR(dir))\n\t\t\tgoto out_unlock;\n\n\t\tnew = d_alloc(parent, name);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tif (new) {\n\t\t\tdentry = dir->i_op->lookup(dir, new, nd);\n\t\t\tif (dentry)\n\t\t\t\tdput(new);\n\t\t\telse\n\t\t\t\tdentry = new;\n\t\t}\nout_unlock:\n\t\tmutex_unlock(&dir->i_mutex);\n\t\tif (IS_ERR(dentry))\n\t\t\tgoto fail;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Uhhuh! Nasty case: the cache was re-populated while\n\t * we waited on the semaphore. Need to revalidate.\n\t */\n\tmutex_unlock(&dir->i_mutex);\n\tif (dentry->d_op && dentry->d_op->d_revalidate) {\n\t\tdentry = do_revalidate(dentry, nd);\n\t\tif (!dentry)\n\t\t\tdentry = ERR_PTR(-ENOENT);\n\t}\n\tif (IS_ERR(dentry))\n\t\tgoto fail;\n\tgoto done;\n\nneed_revalidate:\n\tdentry = do_revalidate(dentry, nd);\n\tif (!dentry)\n\t\tgoto need_lookup;\n\tif (IS_ERR(dentry))\n\t\tgoto fail;\n\tgoto done;\n\nfail:\n\treturn PTR_ERR(dentry);\n}\n\n/*\n * Name resolution.\n * This is the basic name resolution function, turning a pathname into\n * the final dentry. We expect 'base' to be positive and a directory.\n *\n * Returns 0 and nd will have valid dentry and mnt on success.\n * Returns error and drops reference to input namei data on failure.\n */\nstatic int link_path_walk(const char *name, struct nameidata *nd)\n{\n\tstruct path next;\n\tstruct inode *inode;\n\tint err;\n\tunsigned int lookup_flags = nd->flags;\n\t\n\twhile (*name=='/')\n\t\tname++;\n\tif (!*name)\n\t\tgoto return_reval;\n\n\tinode = nd->path.dentry->d_inode;\n\tif (nd->depth)\n\t\tlookup_flags = LOOKUP_FOLLOW | (nd->flags & LOOKUP_CONTINUE);\n\n\t/* At this point we know we have a real path component. */\n\tfor(;;) {\n\t\tunsigned long hash;\n\t\tstruct qstr this;\n\t\tunsigned int c;\n\n\t\tnd->flags |= LOOKUP_CONTINUE;\n\t\terr = exec_permission(inode);\n \t\tif (err)\n\t\t\tbreak;\n\n\t\tthis.name = name;\n\t\tc = *(const unsigned char *)name;\n\n\t\thash = init_name_hash();\n\t\tdo {\n\t\t\tname++;\n\t\t\thash = partial_name_hash(c, hash);\n\t\t\tc = *(const unsigned char *)name;\n\t\t} while (c && (c != '/'));\n\t\tthis.len = name - (const char *) this.name;\n\t\tthis.hash = end_name_hash(hash);\n\n\t\t/* remove trailing slashes? */\n\t\tif (!c)\n\t\t\tgoto last_component;\n\t\twhile (*++name == '/');\n\t\tif (!*name)\n\t\t\tgoto last_with_slashes;\n\n\t\t/*\n\t\t * \".\" and \"..\" are special - \"..\" especially so because it has\n\t\t * to be able to know about the current root directory and\n\t\t * parent relationships.\n\t\t */\n\t\tif (this.name[0] == '.') switch (this.len) {\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\tcase 2:\t\n\t\t\t\tif (this.name[1] != '.')\n\t\t\t\t\tbreak;\n\t\t\t\tfollow_dotdot(nd);\n\t\t\t\tinode = nd->path.dentry->d_inode;\n\t\t\t\t/* fallthrough */\n\t\t\tcase 1:\n\t\t\t\tcontinue;\n\t\t}\n\t\t/* This does the actual lookups.. */\n\t\terr = do_lookup(nd, &this, &next);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = -ENOENT;\n\t\tinode = next.dentry->d_inode;\n\t\tif (!inode)\n\t\t\tgoto out_dput;\n\n\t\tif (inode->i_op->follow_link) {\n\t\t\terr = do_follow_link(&next, nd);\n\t\t\tif (err)\n\t\t\t\tgoto return_err;\n\t\t\terr = -ENOENT;\n\t\t\tinode = nd->path.dentry->d_inode;\n\t\t\tif (!inode)\n\t\t\t\tbreak;\n\t\t} else\n\t\t\tpath_to_nameidata(&next, nd);\n\t\terr = -ENOTDIR; \n\t\tif (!inode->i_op->lookup)\n\t\t\tbreak;\n\t\tcontinue;\n\t\t/* here ends the main loop */\n\nlast_with_slashes:\n\t\tlookup_flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nlast_component:\n\t\t/* Clear LOOKUP_CONTINUE iff it was previously unset */\n\t\tnd->flags &= lookup_flags | ~LOOKUP_CONTINUE;\n\t\tif (lookup_flags & LOOKUP_PARENT)\n\t\t\tgoto lookup_parent;\n\t\tif (this.name[0] == '.') switch (this.len) {\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\tcase 2:\t\n\t\t\t\tif (this.name[1] != '.')\n\t\t\t\t\tbreak;\n\t\t\t\tfollow_dotdot(nd);\n\t\t\t\tinode = nd->path.dentry->d_inode;\n\t\t\t\t/* fallthrough */\n\t\t\tcase 1:\n\t\t\t\tgoto return_reval;\n\t\t}\n\t\terr = do_lookup(nd, &this, &next);\n\t\tif (err)\n\t\t\tbreak;\n\t\tinode = next.dentry->d_inode;\n\t\tif ((lookup_flags & LOOKUP_FOLLOW)\n\t\t    && inode && inode->i_op->follow_link) {\n\t\t\terr = do_follow_link(&next, nd);\n\t\t\tif (err)\n\t\t\t\tgoto return_err;\n\t\t\tinode = nd->path.dentry->d_inode;\n\t\t} else\n\t\t\tpath_to_nameidata(&next, nd);\n\t\terr = -ENOENT;\n\t\tif (!inode)\n\t\t\tbreak;\n\t\tif (lookup_flags & LOOKUP_DIRECTORY) {\n\t\t\terr = -ENOTDIR; \n\t\t\tif (!inode->i_op->lookup)\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto return_base;\nlookup_parent:\n\t\tnd->last = this;\n\t\tnd->last_type = LAST_NORM;\n\t\tif (this.name[0] != '.')\n\t\t\tgoto return_base;\n\t\tif (this.len == 1)\n\t\t\tnd->last_type = LAST_DOT;\n\t\telse if (this.len == 2 && this.name[1] == '.')\n\t\t\tnd->last_type = LAST_DOTDOT;\n\t\telse\n\t\t\tgoto return_base;\nreturn_reval:\n\t\t/*\n\t\t * We bypassed the ordinary revalidation routines.\n\t\t * We may need to check the cached dentry for staleness.\n\t\t */\n\t\tif (nd->path.dentry && nd->path.dentry->d_sb &&\n\t\t    (nd->path.dentry->d_sb->s_type->fs_flags & FS_REVAL_DOT)) {\n\t\t\terr = -ESTALE;\n\t\t\t/* Note: we do not d_invalidate() */\n\t\t\tif (!nd->path.dentry->d_op->d_revalidate(\n\t\t\t\t\tnd->path.dentry, nd))\n\t\t\t\tbreak;\n\t\t}\nreturn_base:\n\t\treturn 0;\nout_dput:\n\t\tpath_put_conditional(&next, nd);\n\t\tbreak;\n\t}\n\tpath_put(&nd->path);\nreturn_err:\n\treturn err;\n}\n\nstatic int path_walk(const char *name, struct nameidata *nd)\n{\n\tstruct path save = nd->path;\n\tint result;\n\n\tcurrent->total_link_count = 0;\n\n\t/* make sure the stuff we saved doesn't go away */\n\tpath_get(&save);\n\n\tresult = link_path_walk(name, nd);\n\tif (result == -ESTALE) {\n\t\t/* nd->path had been dropped */\n\t\tcurrent->total_link_count = 0;\n\t\tnd->path = save;\n\t\tpath_get(&nd->path);\n\t\tnd->flags |= LOOKUP_REVAL;\n\t\tresult = link_path_walk(name, nd);\n\t}\n\n\tpath_put(&save);\n\n\treturn result;\n}\n\nstatic int path_init(int dfd, const char *name, unsigned int flags, struct nameidata *nd)\n{\n\tint retval = 0;\n\tint fput_needed;\n\tstruct file *file;\n\n\tnd->last_type = LAST_ROOT; /* if there are only slashes... */\n\tnd->flags = flags;\n\tnd->depth = 0;\n\tnd->root.mnt = NULL;\n\n\tif (*name=='/') {\n\t\tset_root(nd);\n\t\tnd->path = nd->root;\n\t\tpath_get(&nd->root);\n\t} else if (dfd == AT_FDCWD) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tread_lock(&fs->lock);\n\t\tnd->path = fs->pwd;\n\t\tpath_get(&fs->pwd);\n\t\tread_unlock(&fs->lock);\n\t} else {\n\t\tstruct dentry *dentry;\n\n\t\tfile = fget_light(dfd, &fput_needed);\n\t\tretval = -EBADF;\n\t\tif (!file)\n\t\t\tgoto out_fail;\n\n\t\tdentry = file->f_path.dentry;\n\n\t\tretval = -ENOTDIR;\n\t\tif (!S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tgoto fput_fail;\n\n\t\tretval = file_permission(file, MAY_EXEC);\n\t\tif (retval)\n\t\t\tgoto fput_fail;\n\n\t\tnd->path = file->f_path;\n\t\tpath_get(&file->f_path);\n\n\t\tfput_light(file, fput_needed);\n\t}\n\treturn 0;\n\nfput_fail:\n\tfput_light(file, fput_needed);\nout_fail:\n\treturn retval;\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int do_path_lookup(int dfd, const char *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tint retval = path_init(dfd, name, flags, nd);\n\tif (!retval)\n\t\tretval = path_walk(name, nd);\n\tif (unlikely(!retval && !audit_dummy_context() && nd->path.dentry &&\n\t\t\t\tnd->path.dentry->d_inode))\n\t\taudit_inode(name, nd->path.dentry);\n\tif (nd->root.mnt) {\n\t\tpath_put(&nd->root);\n\t\tnd->root.mnt = NULL;\n\t}\n\treturn retval;\n}\n\nint path_lookup(const char *name, unsigned int flags,\n\t\t\tstruct nameidata *nd)\n{\n\treturn do_path_lookup(AT_FDCWD, name, flags, nd);\n}\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}\n\n/**\n * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair\n * @dentry:  pointer to dentry of the base directory\n * @mnt: pointer to vfs mount of the base directory\n * @name: pointer to file name\n * @flags: lookup flags\n * @nd: pointer to nameidata\n */\nint vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct nameidata *nd)\n{\n\tint retval;\n\n\t/* same as do_path_lookup */\n\tnd->last_type = LAST_ROOT;\n\tnd->flags = flags;\n\tnd->depth = 0;\n\n\tnd->path.dentry = dentry;\n\tnd->path.mnt = mnt;\n\tpath_get(&nd->path);\n\tnd->root = nd->path;\n\tpath_get(&nd->root);\n\n\tretval = path_walk(name, nd);\n\tif (unlikely(!retval && !audit_dummy_context() && nd->path.dentry &&\n\t\t\t\tnd->path.dentry->d_inode))\n\t\taudit_inode(name, nd->path.dentry);\n\n\tpath_put(&nd->root);\n\tnd->root.mnt = NULL;\n\n\treturn retval;\n}\n\nstatic struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, struct nameidata *nd)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = base->d_inode;\n\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_op && base->d_op->d_hash) {\n\t\terr = base->d_op->d_hash(base, name);\n\t\tdentry = ERR_PTR(err);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tdentry = __d_lookup(base, name);\n\n\t/* lockess __d_lookup may fail due to concurrent d_move()\n\t * in some unrelated directory, so try with d_lookup\n\t */\n\tif (!dentry)\n\t\tdentry = d_lookup(base, name);\n\n\tif (dentry && dentry->d_op && dentry->d_op->d_revalidate)\n\t\tdentry = do_revalidate(dentry, nd);\n\n\tif (!dentry) {\n\t\tstruct dentry *new;\n\n\t\t/* Don't create child dentry for a dead directory. */\n\t\tdentry = ERR_PTR(-ENOENT);\n\t\tif (IS_DEADDIR(inode))\n\t\t\tgoto out;\n\n\t\tnew = d_alloc(base, name);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tif (!new)\n\t\t\tgoto out;\n\t\tdentry = inode->i_op->lookup(inode, new, nd);\n\t\tif (!dentry)\n\t\t\tdentry = new;\n\t\telse\n\t\t\tdput(new);\n\t}\nout:\n\treturn dentry;\n}\n\n/*\n * Restricted form of lookup. Doesn't follow links, single-component only,\n * needs parent already locked. Doesn't follow mounts.\n * SMP-safe.\n */\nstatic struct dentry *lookup_hash(struct nameidata *nd)\n{\n\tint err;\n\n\terr = exec_permission(nd->path.dentry->d_inode);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn __lookup_hash(&nd->last, nd->path.dentry, nd);\n}\n\nstatic int __lookup_one_len(const char *name, struct qstr *this,\n\t\tstruct dentry *base, int len)\n{\n\tunsigned long hash;\n\tunsigned int c;\n\n\tthis->name = name;\n\tthis->len = len;\n\tif (!len)\n\t\treturn -EACCES;\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn -EACCES;\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tthis->hash = end_name_hash(hash);\n\treturn 0;\n}\n\n/**\n * lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.  Also note that by using this function the\n * nameidata argument is passed to the filesystem methods and a filesystem\n * using this helper needs to be prepared for that.\n */\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tint err;\n\tstruct qstr this;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\terr = __lookup_one_len(name, &this, base, len);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = exec_permission(base->d_inode);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn __lookup_hash(&this, base, NULL);\n}\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\tstruct nameidata nd;\n\tchar *tmp = getname(name);\n\tint err = PTR_ERR(tmp);\n\tif (!IS_ERR(tmp)) {\n\n\t\tBUG_ON(flags & LOOKUP_PARENT);\n\n\t\terr = do_path_lookup(dfd, tmp, flags, &nd);\n\t\tputname(tmp);\n\t\tif (!err)\n\t\t\t*path = nd.path;\n\t}\n\treturn err;\n}\n\nstatic int user_path_parent(int dfd, const char __user *path,\n\t\t\tstruct nameidata *nd, char **name)\n{\n\tchar *s = getname(path);\n\tint error;\n\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\n\terror = do_path_lookup(dfd, s, LOOKUP_PARENT, nd);\n\tif (error)\n\t\tputname(s);\n\telse\n\t\t*name = s;\n\n\treturn error;\n}\n\n/*\n * It's inline, so penalty for filesystems that don't use sticky bit is\n * minimal.\n */\nstatic inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tuid_t fsuid = current_fsuid();\n\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (inode->i_uid == fsuid)\n\t\treturn 0;\n\tif (dir->i_uid == fsuid)\n\t\treturn 0;\n\treturn !capable(CAP_FOWNER);\n}\n\n/*\n *\tCheck whether we can remove a link victim from directory dir, check\n *  whether the type of victim is right.\n *  1. We can't do it if dir is read-only (done in permission())\n *  2. We should have write and exec permissions on dir\n *  3. We can't remove anything from append-only dir\n *  4. We can't do anything with immutable dir (done in permission())\n *  5. If the sticky bit on dir is set we should either\n *\ta. be owner of dir, or\n *\tb. be owner of victim, or\n *\tc. have CAP_FOWNER capability\n *  6. If the victim is append-only or immutable we can't do antyhing with\n *     links pointing to it.\n *  7. If we were asked to remove a directory and victim isn't one - ENOTDIR.\n *  8. If we were asked to remove a non-directory and victim isn't one - EISDIR.\n *  9. We can't remove a root or mountpoint.\n * 10. We don't allow removal of NFS sillyrenamed files; it's handled by\n *     nfs_async_unlink().\n */\nstatic int may_delete(struct inode *dir,struct dentry *victim,int isdir)\n{\n\tint error;\n\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(victim->d_name.name, victim, dir);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!S_ISDIR(victim->d_inode->i_mode))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (S_ISDIR(victim->d_inode->i_mode))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n/*\tCheck whether we can create an object with dentry child in directory\n *  dir.\n *  1. We can't do it if child already exists (open has special treatment for\n *     this case, but since we are inlined it's OK)\n *  2. We can't do it if dir is read-only (done in permission())\n *  3. We should have write and exec permissions on dir\n *  4. We can't do it if dir is immutable (done in permission())\n */\nstatic inline int may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}\n\n/* \n * O_DIRECTORY translates into forcing a directory lookup.\n */\nstatic inline int lookup_flags(unsigned int f)\n{\n\tunsigned long retval = LOOKUP_FOLLOW;\n\n\tif (f & O_NOFOLLOW)\n\t\tretval &= ~LOOKUP_FOLLOW;\n\t\n\tif (f & O_DIRECTORY)\n\t\tretval |= LOOKUP_DIRECTORY;\n\n\treturn retval;\n}\n\n/*\n * p1 and p2 should be directories on the same fs.\n */\nstruct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tif (p1 == p2) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\treturn NULL;\n}\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}\n\nint vfs_create(struct inode *dir, struct dentry *dentry, int mode,\n\t\tstruct nameidata *nd)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\tvfs_dq_init(dir);\n\terror = dir->i_op->create(dir, dentry, mode, nd);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\n\nint may_open(struct path *path, int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (path->mnt->mnt_flags & MNT_NODEV)\n\t\t\treturn -EACCES;\n\t\t/*FALLTHRU*/\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(inode, acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * An append-only file must be opened in append mode for writing.\n\t */\n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & FMODE_WRITE) && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* O_NOATIME can only be set by the owner or superuser */\n\tif (flag & O_NOATIME && !is_owner_or_cap(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * Ensure there are no outstanding leases on the file.\n\t */\n\treturn break_lease(inode, flag);\n}\n\nstatic int handle_truncate(struct path *path)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tint error = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Refuse to truncate files with mandatory locks held on them.\n\t */\n\terror = locks_verify_locked(inode);\n\tif (!error)\n\t\terror = security_path_truncate(path, 0,\n\t\t\t\t       ATTR_MTIME|ATTR_CTIME|ATTR_OPEN);\n\tif (!error) {\n\t\terror = do_truncate(path->dentry, 0,\n\t\t\t\t    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,\n\t\t\t\t    NULL);\n\t}\n\tput_write_access(inode);\n\treturn error;\n}\n\n/*\n * Be careful about ever adding any more callers of this\n * function.  Its flags must be in the namei format, not\n * what get passed to sys_open().\n */\nstatic int __open_namei_create(struct nameidata *nd, struct path *path,\n\t\t\t\tint flag, int mode)\n{\n\tint error;\n\tstruct dentry *dir = nd->path.dentry;\n\n\tif (!IS_POSIXACL(dir->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mknod(&nd->path, path->dentry, mode, 0);\n\tif (error)\n\t\tgoto out_unlock;\n\terror = vfs_create(dir->d_inode, path->dentry, mode, nd);\nout_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(nd->path.dentry);\n\tnd->path.dentry = path->dentry;\n\tif (error)\n\t\treturn error;\n\t/* Don't check for write permission, don't truncate */\n\treturn may_open(&nd->path, 0, flag & ~O_TRUNC);\n}\n\n/*\n * Note that while the flag value (low two bits) for sys_open means:\n *\t00 - read-only\n *\t01 - write-only\n *\t10 - read-write\n *\t11 - special\n * it is changed into\n *\t00 - no permissions needed\n *\t01 - read-permission\n *\t10 - write-permission\n *\t11 - read-write\n * for the internal routines (ie open_namei()/follow_link() etc)\n * This is more logical, and also allows the 00 \"no perm needed\"\n * to be used for symlinks (where the permissions are checked\n * later).\n *\n*/\nstatic inline int open_to_namei_flags(int flag)\n{\n\tif ((flag+1) & O_ACCMODE)\n\t\tflag++;\n\treturn flag;\n}\n\nstatic int open_will_truncate(int flag, struct inode *inode)\n{\n\t/*\n\t * We'll never write to the fs underlying\n\t * a device file.\n\t */\n\tif (special_file(inode->i_mode))\n\t\treturn 0;\n\treturn (flag & O_TRUNC);\n}\n\n/*\n * Note that the low bits of the passed in \"open_flag\"\n * are not the same as in the local variable \"flag\". See\n * open_to_namei_flags() for more details.\n */\nstruct file *do_filp_open(int dfd, const char *pathname,\n\t\tint open_flag, int mode, int acc_mode)\n{\n\tstruct file *filp;\n\tstruct nameidata nd;\n\tint error;\n\tstruct path path, save;\n\tstruct dentry *dir;\n\tint count = 0;\n\tint will_truncate;\n\tint flag = open_to_namei_flags(open_flag);\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (open_flag & __O_SYNC)\n\t\topen_flag |= O_DSYNC;\n\n\tif (!acc_mode)\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flag);\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flag & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append \n\t   access from general write access. */\n\tif (flag & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\t/*\n\t * The simplest case - just a plain lookup.\n\t */\n\tif (!(flag & O_CREAT)) {\n\t\tfilp = get_empty_filp();\n\n\t\tif (filp == NULL)\n\t\t\treturn ERR_PTR(-ENFILE);\n\t\tnd.intent.open.file = filp;\n\t\tfilp->f_flags = open_flag;\n\t\tnd.intent.open.flags = flag;\n\t\tnd.intent.open.create_mode = 0;\n\t\terror = do_path_lookup(dfd, pathname,\n\t\t\t\t\tlookup_flags(flag)|LOOKUP_OPEN, &nd);\n\t\tif (IS_ERR(nd.intent.open.file)) {\n\t\t\tif (error == 0) {\n\t\t\t\terror = PTR_ERR(nd.intent.open.file);\n\t\t\t\tpath_put(&nd.path);\n\t\t\t}\n\t\t} else if (error)\n\t\t\trelease_open_intent(&nd);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tgoto ok;\n\t}\n\n\t/*\n\t * Create - we need to know the parent.\n\t */\n\terror = path_init(dfd, pathname, LOOKUP_PARENT, &nd);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\terror = path_walk(pathname, &nd);\n\tif (error) {\n\t\tif (nd.root.mnt)\n\t\t\tpath_put(&nd.root);\n\t\treturn ERR_PTR(error);\n\t}\n\tif (unlikely(!audit_dummy_context()))\n\t\taudit_inode(pathname, nd.path.dentry);\n\n\t/*\n\t * We have the parent and last component. First of all, check\n\t * that we are not asked to creat(2) an obvious directory - that\n\t * will not do.\n\t */\n\terror = -EISDIR;\n\tif (nd.last_type != LAST_NORM || nd.last.name[nd.last.len])\n\t\tgoto exit_parent;\n\n\terror = -ENFILE;\n\tfilp = get_empty_filp();\n\tif (filp == NULL)\n\t\tgoto exit_parent;\n\tnd.intent.open.file = filp;\n\tfilp->f_flags = open_flag;\n\tnd.intent.open.flags = flag;\n\tnd.intent.open.create_mode = mode;\n\tdir = nd.path.dentry;\n\tnd.flags &= ~LOOKUP_PARENT;\n\tnd.flags |= LOOKUP_CREATE | LOOKUP_OPEN;\n\tif (flag & O_EXCL)\n\t\tnd.flags |= LOOKUP_EXCL;\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tpath.dentry = lookup_hash(&nd);\n\tpath.mnt = nd.path.mnt;\n\ndo_last:\n\terror = PTR_ERR(path.dentry);\n\tif (IS_ERR(path.dentry)) {\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tgoto exit;\n\t}\n\n\tif (IS_ERR(nd.intent.open.file)) {\n\t\terror = PTR_ERR(nd.intent.open.file);\n\t\tgoto exit_mutex_unlock;\n\t}\n\n\t/* Negative dentry, just create the file */\n\tif (!path.dentry->d_inode) {\n\t\t/*\n\t\t * This write is needed to ensure that a\n\t\t * ro->rw transition does not occur between\n\t\t * the time when the file is created and when\n\t\t * a permanent write count is taken through\n\t\t * the 'struct file' in nameidata_to_filp().\n\t\t */\n\t\terror = mnt_want_write(nd.path.mnt);\n\t\tif (error)\n\t\t\tgoto exit_mutex_unlock;\n\t\terror = __open_namei_create(&nd, &path, flag, mode);\n\t\tif (error) {\n\t\t\tmnt_drop_write(nd.path.mnt);\n\t\t\tgoto exit;\n\t\t}\n\t\tfilp = nameidata_to_filp(&nd);\n\t\tmnt_drop_write(nd.path.mnt);\n\t\tif (nd.root.mnt)\n\t\t\tpath_put(&nd.root);\n\t\tif (!IS_ERR(filp)) {\n\t\t\terror = ima_path_check(&filp->f_path, filp->f_mode &\n\t\t\t\t       (MAY_READ | MAY_WRITE | MAY_EXEC));\n\t\t\tif (error) {\n\t\t\t\tfput(filp);\n\t\t\t\tfilp = ERR_PTR(error);\n\t\t\t}\n\t\t}\n\t\treturn filp;\n\t}\n\n\t/*\n\t * It already exists.\n\t */\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\taudit_inode(pathname, path.dentry);\n\n\terror = -EEXIST;\n\tif (flag & O_EXCL)\n\t\tgoto exit_dput;\n\n\tif (__follow_mount(&path)) {\n\t\terror = -ELOOP;\n\t\tif (flag & O_NOFOLLOW)\n\t\t\tgoto exit_dput;\n\t}\n\n\terror = -ENOENT;\n\tif (!path.dentry->d_inode)\n\t\tgoto exit_dput;\n\tif (path.dentry->d_inode->i_op->follow_link)\n\t\tgoto do_link;\n\n\tpath_to_nameidata(&path, &nd);\n\terror = -EISDIR;\n\tif (S_ISDIR(path.dentry->d_inode->i_mode))\n\t\tgoto exit;\nok:\n\t/*\n\t * Consider:\n\t * 1. may_open() truncates a file\n\t * 2. a rw->ro mount transition occurs\n\t * 3. nameidata_to_filp() fails due to\n\t *    the ro mount.\n\t * That would be inconsistent, and should\n\t * be avoided. Taking this mnt write here\n\t * ensures that (2) can not occur.\n\t */\n\twill_truncate = open_will_truncate(flag, nd.path.dentry->d_inode);\n\tif (will_truncate) {\n\t\terror = mnt_want_write(nd.path.mnt);\n\t\tif (error)\n\t\t\tgoto exit;\n\t}\n\terror = may_open(&nd.path, acc_mode, flag);\n\tif (error) {\n\t\tif (will_truncate)\n\t\t\tmnt_drop_write(nd.path.mnt);\n\t\tgoto exit;\n\t}\n\tfilp = nameidata_to_filp(&nd);\n\tif (!IS_ERR(filp)) {\n\t\terror = ima_path_check(&filp->f_path, filp->f_mode &\n\t\t\t       (MAY_READ | MAY_WRITE | MAY_EXEC));\n\t\tif (error) {\n\t\t\tfput(filp);\n\t\t\tfilp = ERR_PTR(error);\n\t\t}\n\t}\n\tif (!IS_ERR(filp)) {\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\tvfs_dq_init(nd.path.dentry->d_inode);\n\n\t\tif (will_truncate) {\n\t\t\terror = handle_truncate(&nd.path);\n\t\t\tif (error) {\n\t\t\t\tfput(filp);\n\t\t\t\tfilp = ERR_PTR(error);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * It is now safe to drop the mnt write\n\t * because the filp has had a write taken\n\t * on its behalf.\n\t */\n\tif (will_truncate)\n\t\tmnt_drop_write(nd.path.mnt);\n\tif (nd.root.mnt)\n\t\tpath_put(&nd.root);\n\treturn filp;\n\nexit_mutex_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\nexit_dput:\n\tpath_put_conditional(&path, &nd);\nexit:\n\tif (!IS_ERR(nd.intent.open.file))\n\t\trelease_open_intent(&nd);\nexit_parent:\n\tif (nd.root.mnt)\n\t\tpath_put(&nd.root);\n\tpath_put(&nd.path);\n\treturn ERR_PTR(error);\n\ndo_link:\n\terror = -ELOOP;\n\tif (flag & O_NOFOLLOW)\n\t\tgoto exit_dput;\n\t/*\n\t * This is subtle. Instead of calling do_follow_link() we do the\n\t * thing by hands. The reason is that this way we have zero link_count\n\t * and path_walk() (called from ->follow_link) honoring LOOKUP_PARENT.\n\t * After that we have the parent and last component, i.e.\n\t * we are in the same situation as after the first path_walk().\n\t * Well, almost - if the last component is normal we get its copy\n\t * stored in nd->last.name and we will have to putname() it when we\n\t * are done. Procfs-like symlinks just set LAST_BIND.\n\t */\n\tnd.flags |= LOOKUP_PARENT;\n\terror = security_inode_follow_link(path.dentry, &nd);\n\tif (error)\n\t\tgoto exit_dput;\n\tsave = nd.path;\n\tpath_get(&save);\n\terror = __do_follow_link(&path, &nd);\n\tif (error == -ESTALE) {\n\t\t/* nd.path had been dropped */\n\t\tnd.path = save;\n\t\tpath_get(&nd.path);\n\t\tnd.flags |= LOOKUP_REVAL;\n\t\terror = __do_follow_link(&path, &nd);\n\t}\n\tpath_put(&save);\n\tpath_put(&path);\n\tif (error) {\n\t\t/* Does someone understand code flow here? Or it is only\n\t\t * me so stupid? Anathema to whoever designed this non-sense\n\t\t * with \"intent.open\".\n\t\t */\n\t\trelease_open_intent(&nd);\n\t\tif (nd.root.mnt)\n\t\t\tpath_put(&nd.root);\n\t\treturn ERR_PTR(error);\n\t}\n\tnd.flags &= ~LOOKUP_PARENT;\n\tif (nd.last_type == LAST_BIND)\n\t\tgoto ok;\n\terror = -EISDIR;\n\tif (nd.last_type != LAST_NORM)\n\t\tgoto exit;\n\tif (nd.last.name[nd.last.len]) {\n\t\t__putname(nd.last.name);\n\t\tgoto exit;\n\t}\n\terror = -ELOOP;\n\tif (count++==32) {\n\t\t__putname(nd.last.name);\n\t\tgoto exit;\n\t}\n\tdir = nd.path.dentry;\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tpath.dentry = lookup_hash(&nd);\n\tpath.mnt = nd.path.mnt;\n\t__putname(nd.last.name);\n\tgoto do_last;\n}\n\n/**\n * filp_open - open file and return file pointer\n *\n * @filename:\tpath to open\n * @flags:\topen flags as per the open(2) second argument\n * @mode:\tmode for the new file if O_CREAT is set, else ignored\n *\n * This is the helper to open a file from kernelspace if you really\n * have to.  But in generally you should not do this, so please move\n * along, nothing to see here..\n */\nstruct file *filp_open(const char *filename, int flags, int mode)\n{\n\treturn do_filp_open(AT_FDCWD, filename, flags, mode, 0);\n}\nEXPORT_SYMBOL(filp_open);\n\n/**\n * lookup_create - lookup a dentry, creating it if it doesn't exist\n * @nd: nameidata info\n * @is_dir: directory flag\n *\n * Simple function to lookup and return a dentry and create it\n * if it doesn't exist.  Is SMP-safe.\n *\n * Returns with nd->path.dentry->d_inode->i_mutex locked.\n */\nstruct dentry *lookup_create(struct nameidata *nd, int is_dir)\n{\n\tstruct dentry *dentry = ERR_PTR(-EEXIST);\n\n\tmutex_lock_nested(&nd->path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\t/*\n\t * Yucky last component or no last component at all?\n\t * (foo/., foo/.., /////)\n\t */\n\tif (nd->last_type != LAST_NORM)\n\t\tgoto fail;\n\tnd->flags &= ~LOOKUP_PARENT;\n\tnd->flags |= LOOKUP_CREATE | LOOKUP_EXCL;\n\tnd->intent.open.flags = O_EXCL;\n\n\t/*\n\t * Do the final lookup.\n\t */\n\tdentry = lookup_hash(nd);\n\tif (IS_ERR(dentry))\n\t\tgoto fail;\n\n\tif (dentry->d_inode)\n\t\tgoto eexist;\n\t/*\n\t * Special case - lookup gave negative, but... we had foo/bar/\n\t * From the vfs_mknod() POV we just have a negative dentry -\n\t * all is fine. Let's be bastards - you had / on the end, you've\n\t * been asking for (non-existent) directory. -ENOENT for you.\n\t */\n\tif (unlikely(!is_dir && nd->last.name[nd->last.len])) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-ENOENT);\n\t}\n\treturn dentry;\neexist:\n\tdput(dentry);\n\tdentry = ERR_PTR(-EEXIST);\nfail:\n\treturn dentry;\n}\nEXPORT_SYMBOL_GPL(lookup_create);\n\nint vfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\tvfs_dq_init(dir);\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\n\nstatic int may_mknod(mode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\tcase 0: /* zero mode translates to S_IFREG */\n\t\treturn 0;\n\tcase S_IFDIR:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, int, mode,\n\t\tunsigned, dev)\n{\n\tint error;\n\tchar *tmp;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\tif (S_ISDIR(mode))\n\t\treturn -EPERM;\n\n\terror = user_path_parent(dfd, filename, &nd, &tmp);\n\tif (error)\n\t\treturn error;\n\n\tdentry = lookup_create(&nd, 0);\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tif (!IS_POSIXACL(nd.path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = may_mknod(mode);\n\tif (error)\n\t\tgoto out_dput;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_mknod(&nd.path, dentry, mode, dev);\n\tif (error)\n\t\tgoto out_drop_write;\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,\n\t\t\t\t\tnew_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tpath_put(&nd.path);\n\tputname(tmp);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mknod, const char __user *, filename, int, mode, unsigned, dev)\n{\n\treturn sys_mknodat(AT_FDCWD, filename, mode, dev);\n}\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tvfs_dq_init(dir);\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, int, mode)\n{\n\tint error = 0;\n\tchar * tmp;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\terror = user_path_parent(dfd, pathname, &nd, &tmp);\n\tif (error)\n\t\tgoto out_err;\n\n\tdentry = lookup_create(&nd, 1);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\tif (!IS_POSIXACL(nd.path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_mkdir(&nd.path, dentry, mode);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tpath_put(&nd.path);\n\tputname(tmp);\nout_err:\n\treturn error;\n}\n\nSYSCALL_DEFINE2(mkdir, const char __user *, pathname, int, mode)\n{\n\treturn sys_mkdirat(AT_FDCWD, pathname, mode);\n}\n\n/*\n * We try to drop the dentry early: we should have\n * a usage count of 2 if we're the only user of this\n * dentry, and if that is true (possibly after pruning\n * the dcache), then we drop the dentry now.\n *\n * A low-level filesystem can, if it choses, legally\n * do a\n *\n *\tif (!d_unhashed(dentry))\n *\t\treturn -EBUSY;\n *\n * if it cannot handle the case of removing a directory\n * that is still in use by something else..\n */\nvoid dentry_unhash(struct dentry *dentry)\n{\n\tdget(dentry);\n\tshrink_dcache_parent(dentry);\n\tspin_lock(&dcache_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (atomic_read(&dentry->d_count) == 2)\n\t\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dcache_lock);\n}\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tvfs_dq_init(dir);\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tdentry_unhash(dentry);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_rmdir(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = dir->i_op->rmdir(dir, dentry);\n\t\t\tif (!error)\n\t\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t}\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error) {\n\t\td_delete(dentry);\n\t}\n\tdput(dentry);\n\n\treturn error;\n}\n\nstatic long do_rmdir(int dfd, const char __user *pathname)\n{\n\tint error = 0;\n\tchar * name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\terror = user_path_parent(dfd, pathname, &nd, &name);\n\tif (error)\n\t\treturn error;\n\n\tswitch(nd.last_type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit1;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit1;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit1;\n\t}\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit2;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto exit3;\n\terror = security_path_rmdir(&nd.path, dentry);\n\tif (error)\n\t\tgoto exit4;\n\terror = vfs_rmdir(nd.path.dentry->d_inode, dentry);\nexit4:\n\tmnt_drop_write(nd.path.mnt);\nexit3:\n\tdput(dentry);\nexit2:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\treturn error;\n}\n\nSYSCALL_DEFINE1(rmdir, const char __user *, pathname)\n{\n\treturn do_rmdir(AT_FDCWD, pathname);\n}\n\nint vfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tvfs_dq_init(dir);\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error)\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(dentry->d_inode);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}\n\n/*\n * Make sure that the actual truncation of the file will occur outside its\n * directory's i_mutex.  Truncate can take a long time if there is a lot of\n * writeout happening, and we don't want to prevent access to the directory\n * while waiting on the I/O.\n */\nstatic long do_unlinkat(int dfd, const char __user *pathname)\n{\n\tint error;\n\tchar *name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\tstruct inode *inode = NULL;\n\n\terror = user_path_parent(dfd, pathname, &nd, &name);\n\tif (error)\n\t\treturn error;\n\n\terror = -EISDIR;\n\tif (nd.last_type != LAST_NORM)\n\t\tgoto exit1;\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\t\t/* Why not before? Because we want correct error value */\n\t\tif (nd.last.name[nd.last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (inode)\n\t\t\tatomic_inc(&inode->i_count);\n\t\terror = mnt_want_write(nd.path.mnt);\n\t\tif (error)\n\t\t\tgoto exit2;\n\t\terror = security_path_unlink(&nd.path, dentry);\n\t\tif (error)\n\t\t\tgoto exit3;\n\t\terror = vfs_unlink(nd.path.dentry->d_inode, dentry);\nexit3:\n\t\tmnt_drop_write(nd.path.mnt);\n\texit2:\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tif (inode)\n\t\tiput(inode);\t/* truncate the inode here */\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\treturn error;\n\nslashes:\n\terror = !dentry->d_inode ? -ENOENT :\n\t\tS_ISDIR(dentry->d_inode->i_mode) ? -EISDIR : -ENOTDIR;\n\tgoto exit2;\n}\n\nSYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)\n{\n\tif ((flag & ~AT_REMOVEDIR) != 0)\n\t\treturn -EINVAL;\n\n\tif (flag & AT_REMOVEDIR)\n\t\treturn do_rmdir(dfd, pathname);\n\n\treturn do_unlinkat(dfd, pathname);\n}\n\nSYSCALL_DEFINE1(unlink, const char __user *, pathname)\n{\n\treturn do_unlinkat(AT_FDCWD, pathname);\n}\n\nint vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\tvfs_dq_init(dir);\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(symlinkat, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\tint error;\n\tchar *from;\n\tchar *to;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\tfrom = getname(oldname);\n\tif (IS_ERR(from))\n\t\treturn PTR_ERR(from);\n\n\terror = user_path_parent(newdfd, newname, &nd, &to);\n\tif (error)\n\t\tgoto out_putname;\n\n\tdentry = lookup_create(&nd, 0);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_symlink(&nd.path, dentry, from);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = vfs_symlink(nd.path.dentry->d_inode, dentry, from);\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tpath_put(&nd.path);\n\tputname(to);\nout_putname:\n\tputname(from);\n\treturn error;\n}\n\nSYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_symlinkat(oldname, AT_FDCWD, newname);\n}\n\nint vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\tvfs_dq_init(dir);\n\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}\n\n/*\n * Hardlinks are often used in delicate situations.  We avoid\n * security-related surprises by not following symlinks on the\n * newname.  --KAB\n *\n * We don't follow them on the oldname either to be compatible\n * with linux 2.0, and to avoid hard-linking to directories\n * and other special files.  --ADM\n */\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\tstruct dentry *new_dentry;\n\tstruct nameidata nd;\n\tstruct path old_path;\n\tint error;\n\tchar *to;\n\n\tif ((flags & ~AT_SYMLINK_FOLLOW) != 0)\n\t\treturn -EINVAL;\n\n\terror = user_path_at(olddfd, oldname,\n\t\t\t     flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,\n\t\t\t     &old_path);\n\tif (error)\n\t\treturn error;\n\n\terror = user_path_parent(newdfd, newname, &nd, &to);\n\tif (error)\n\t\tgoto out;\n\terror = -EXDEV;\n\tif (old_path.mnt != nd.path.mnt)\n\t\tgoto out_release;\n\tnew_dentry = lookup_create(&nd, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out_unlock;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &nd.path, new_dentry);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = vfs_link(old_path.dentry, nd.path.dentry->d_inode, new_dentry);\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(new_dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\nout_release:\n\tpath_put(&nd.path);\n\tputname(to);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\n/*\n * The worst of all namespace operations - renaming directory. \"Perverted\"\n * doesn't even start to describe it. Somebody in UCB had a heck of a trip...\n * Problems:\n *\ta) we can get into loop creation. Check is done in is_subdir().\n *\tb) race potential - two innocent renames can create a loop together.\n *\t   That's where 4.4 screws up. Current fix: serialization on\n *\t   sb->s_vfs_rename_mutex. We might be more accurate, but that's another\n *\t   story.\n *\tc) we have to lock _three_ objects - parents and victim (if it exists).\n *\t   And that - after we got ->i_mutex on parents (until then we don't know\n *\t   whether the target exists).  Solution: try to be smart with locking\n *\t   order for inodes.  We rely on the fact that tree topology may change\n *\t   only under ->s_vfs_rename_mutex _and_ that parent of the object we\n *\t   move will be locked.  Thus we can rank directories by the tree\n *\t   (ancestors first) and rank all non-directories after them.\n *\t   That works since everybody except rename does \"lock parent, lookup,\n *\t   lock child\" and rename is under ->s_vfs_rename_mutex.\n *\t   HOWEVER, it relies on the assumption that any object with ->lookup()\n *\t   has no more than 1 dentry.  If \"hybrid\" objects will ever appear,\n *\t   we'd better make sure that there's no link(2) for them.\n *\td) some filesystems don't support opened-but-unlinked directories,\n *\t   either because of layout or because they are not ready to deal with\n *\t   all cases correctly. The latter will be fixed (taking this sort of\n *\t   stuff into VFS), but the former is not going away. Solution: the same\n *\t   trick as in rmdir().\n *\te) conversion from fhandle to dentry may come in the wrong moment - when\n *\t   we are removing the target. Solution: we will have to grab ->i_mutex\n *\t   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on\n *\t   ->i_mutex on parents, which works but leads to some truely excessive\n *\t   locking].\n */\nstatic int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint error = 0;\n\tstruct inode *target;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\terror = inode_permission(old_dentry->d_inode, MAY_WRITE);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\ttarget = new_dentry->d_inode;\n\tif (target) {\n\t\tmutex_lock(&target->i_mutex);\n\t\tdentry_unhash(new_dentry);\n\t}\n\tif (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))\n\t\terror = -EBUSY;\n\telse \n\t\terror = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);\n\tif (target) {\n\t\tif (!error)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tmutex_unlock(&target->i_mutex);\n\t\tif (d_unhashed(new_dentry))\n\t\t\td_rehash(new_dentry);\n\t\tdput(new_dentry);\n\t}\n\tif (!error)\n\t\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))\n\t\t\td_move(old_dentry,new_dentry);\n\treturn error;\n}\n\nstatic int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t    struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *target;\n\tint error;\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tdget(new_dentry);\n\ttarget = new_dentry->d_inode;\n\tif (target)\n\t\tmutex_lock(&target->i_mutex);\n\tif (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))\n\t\terror = -EBUSY;\n\telse\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);\n\tif (!error) {\n\t\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))\n\t\t\td_move(old_dentry, new_dentry);\n\t}\n\tif (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\treturn error;\n}\n\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint error;\n\tint is_dir = S_ISDIR(old_dentry->d_inode->i_mode);\n\tconst char *old_name;\n\n\tif (old_dentry->d_inode == new_dentry->d_inode)\n \t\treturn 0;\n \n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!new_dentry->d_inode)\n\t\terror = may_create(new_dir, new_dentry);\n\telse\n\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\tvfs_dq_init(old_dir);\n\tvfs_dq_init(new_dir);\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\n\tif (is_dir)\n\t\terror = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);\n\telse\n\t\terror = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);\n\tif (!error) {\n\t\tconst char *new_name = old_dentry->d_name.name;\n\t\tfsnotify_move(old_dir, new_dir, old_name, new_name, is_dir,\n\t\t\t      new_dentry->d_inode, old_dentry);\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\tstruct dentry *old_dir, *new_dir;\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct nameidata oldnd, newnd;\n\tchar *from;\n\tchar *to;\n\tint error;\n\n\terror = user_path_parent(olddfd, oldname, &oldnd, &from);\n\tif (error)\n\t\tgoto exit;\n\n\terror = user_path_parent(newdfd, newname, &newnd, &to);\n\tif (error)\n\t\tgoto exit1;\n\n\terror = -EXDEV;\n\tif (oldnd.path.mnt != newnd.path.mnt)\n\t\tgoto exit2;\n\n\told_dir = oldnd.path.dentry;\n\terror = -EBUSY;\n\tif (oldnd.last_type != LAST_NORM)\n\t\tgoto exit2;\n\n\tnew_dir = newnd.path.dentry;\n\tif (newnd.last_type != LAST_NORM)\n\t\tgoto exit2;\n\n\toldnd.flags &= ~LOOKUP_PARENT;\n\tnewnd.flags &= ~LOOKUP_PARENT;\n\tnewnd.flags |= LOOKUP_RENAME_TARGET;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\n\told_dentry = lookup_hash(&oldnd);\n\terror = PTR_ERR(old_dentry);\n\tif (IS_ERR(old_dentry))\n\t\tgoto exit3;\n\t/* source must exist */\n\terror = -ENOENT;\n\tif (!old_dentry->d_inode)\n\t\tgoto exit4;\n\t/* unless the source is a directory trailing slashes give -ENOTDIR */\n\tif (!S_ISDIR(old_dentry->d_inode->i_mode)) {\n\t\terror = -ENOTDIR;\n\t\tif (oldnd.last.name[oldnd.last.len])\n\t\t\tgoto exit4;\n\t\tif (newnd.last.name[newnd.last.len])\n\t\t\tgoto exit4;\n\t}\n\t/* source should not be ancestor of target */\n\terror = -EINVAL;\n\tif (old_dentry == trap)\n\t\tgoto exit4;\n\tnew_dentry = lookup_hash(&newnd);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto exit4;\n\t/* target should not be an ancestor of source */\n\terror = -ENOTEMPTY;\n\tif (new_dentry == trap)\n\t\tgoto exit5;\n\n\terror = mnt_want_write(oldnd.path.mnt);\n\tif (error)\n\t\tgoto exit5;\n\terror = security_path_rename(&oldnd.path, old_dentry,\n\t\t\t\t     &newnd.path, new_dentry);\n\tif (error)\n\t\tgoto exit6;\n\terror = vfs_rename(old_dir->d_inode, old_dentry,\n\t\t\t\t   new_dir->d_inode, new_dentry);\nexit6:\n\tmnt_drop_write(oldnd.path.mnt);\nexit5:\n\tdput(new_dentry);\nexit4:\n\tdput(old_dentry);\nexit3:\n\tunlock_rename(new_dir, old_dir);\nexit2:\n\tpath_put(&newnd.path);\n\tputname(to);\nexit1:\n\tpath_put(&oldnd.path);\n\tputname(from);\nexit:\n\treturn error;\n}\n\nSYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_renameat(AT_FDCWD, oldname, AT_FDCWD, newname);\n}\n\nint vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)\n{\n\tint len;\n\n\tlen = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}\n\n/*\n * A helper for ->readlink().  This should be used *ONLY* for symlinks that\n * have ->follow_link() touching nd only in nd_set_link().  Using (or not\n * using) it for any given inode is up to filesystem.\n */\nint generic_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct nameidata nd;\n\tvoid *cookie;\n\tint res;\n\n\tnd.depth = 0;\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, &nd);\n\tif (IS_ERR(cookie))\n\t\treturn PTR_ERR(cookie);\n\n\tres = vfs_readlink(dentry, buffer, buflen, nd_get_link(&nd));\n\tif (dentry->d_inode->i_op->put_link)\n\t\tdentry->d_inode->i_op->put_link(dentry, &nd, cookie);\n\treturn res;\n}\n\nint vfs_follow_link(struct nameidata *nd, const char *link)\n{\n\treturn __vfs_follow_link(nd, link);\n}\n\n/* get the link contents into pagecache */\nstatic char *page_getlink(struct dentry * dentry, struct page **ppage)\n{\n\tchar *kaddr;\n\tstruct page *page;\n\tstruct address_space *mapping = dentry->d_inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn (char*)page;\n\t*ppage = page;\n\tkaddr = kmap(page);\n\tnd_terminate_link(kaddr, dentry->d_inode->i_size, PAGE_SIZE - 1);\n\treturn kaddr;\n}\n\nint page_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct page *page = NULL;\n\tchar *s = page_getlink(dentry, &page);\n\tint res = vfs_readlink(dentry,buffer,buflen,s);\n\tif (page) {\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn res;\n}\n\nvoid *page_follow_link_light(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct page *page = NULL;\n\tnd_set_link(nd, page_getlink(dentry, &page));\n\treturn page;\n}\n\nvoid page_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)\n{\n\tstruct page *page = cookie;\n\n\tif (page) {\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t}\n}\n\n/*\n * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS\n */\nint __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tchar *kaddr;\n\tunsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tkaddr = kmap_atomic(page, KM_USER0);\n\tmemcpy(kaddr, symname, len-1);\n\tkunmap_atomic(kaddr, KM_USER0);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}\n\nconst struct inode_operations page_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n};\n\nEXPORT_SYMBOL(user_path_at);\nEXPORT_SYMBOL(follow_down);\nEXPORT_SYMBOL(follow_up);\nEXPORT_SYMBOL(get_write_access); /* binfmt_aout */\nEXPORT_SYMBOL(getname);\nEXPORT_SYMBOL(lock_rename);\nEXPORT_SYMBOL(lookup_one_len);\nEXPORT_SYMBOL(page_follow_link_light);\nEXPORT_SYMBOL(page_put_link);\nEXPORT_SYMBOL(page_readlink);\nEXPORT_SYMBOL(__page_symlink);\nEXPORT_SYMBOL(page_symlink);\nEXPORT_SYMBOL(page_symlink_inode_operations);\nEXPORT_SYMBOL(path_lookup);\nEXPORT_SYMBOL(kern_path);\nEXPORT_SYMBOL(vfs_path_lookup);\nEXPORT_SYMBOL(inode_permission);\nEXPORT_SYMBOL(file_permission);\nEXPORT_SYMBOL(unlock_rename);\nEXPORT_SYMBOL(vfs_create);\nEXPORT_SYMBOL(vfs_follow_link);\nEXPORT_SYMBOL(vfs_link);\nEXPORT_SYMBOL(vfs_mkdir);\nEXPORT_SYMBOL(vfs_mknod);\nEXPORT_SYMBOL(generic_permission);\nEXPORT_SYMBOL(vfs_readlink);\nEXPORT_SYMBOL(vfs_rename);\nEXPORT_SYMBOL(vfs_rmdir);\nEXPORT_SYMBOL(vfs_symlink);\nEXPORT_SYMBOL(vfs_unlink);\nEXPORT_SYMBOL(dentry_unhash);\nEXPORT_SYMBOL(generic_readlink);\n", "/*\n *  linux/fs/proc/base.c\n *\n *  Copyright (C) 1991, 1992 Linus Torvalds\n *\n *  proc base directory handling functions\n *\n *  1999, Al Viro. Rewritten. Now it covers the whole per-process part.\n *  Instead of using magical inumbers to determine the kind of object\n *  we allocate and fill in-core inodes upon lookup. They don't even\n *  go into icache. We cache the reference to task_struct upon lookup too.\n *  Eventually it should become a filesystem in its own. We don't use the\n *  rest of procfs anymore.\n *\n *\n *  Changelog:\n *  17-Jan-2005\n *  Allan Bezerra\n *  Bruna Moreira <bruna.moreira@indt.org.br>\n *  Edjard Mota <edjard.mota@indt.org.br>\n *  Ilias Biris <ilias.biris@indt.org.br>\n *  Mauricio Lin <mauricio.lin@indt.org.br>\n *\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *\n *  A new process specific entry (smaps) included in /proc. It shows the\n *  size of rss for each memory area. The maps entry lacks information\n *  about physical memory size (rss) for each mapped file, i.e.,\n *  rss information for executables and library files.\n *  This additional information is useful for any tools that need to know\n *  about physical memory consumption for a process specific library.\n *\n *  Changelog:\n *  21-Feb-2005\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *  Pud inclusion in the page table walking.\n *\n *  ChangeLog:\n *  10-Mar-2005\n *  10LE Instituto Nokia de Tecnologia - INdT:\n *  A better way to walks through the page table as suggested by Hugh Dickins.\n *\n *  Simo Piiroinen <simo.piiroinen@nokia.com>:\n *  Smaps information related to shared, private, clean and dirty pages.\n *\n *  Paul Mundt <paul.mundt@nokia.com>:\n *  Overall revision about smaps.\n */\n\n#include <asm/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/namei.h>\n#include <linux/mnt_namespace.h>\n#include <linux/mm.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/resource.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/tracehook.h>\n#include <linux/cgroup.h>\n#include <linux/cpuset.h>\n#include <linux/audit.h>\n#include <linux/poll.h>\n#include <linux/nsproxy.h>\n#include <linux/oom.h>\n#include <linux/elf.h>\n#include <linux/pid_namespace.h>\n#include <linux/fs_struct.h>\n#include \"internal.h\"\n\n/* NOTE:\n *\tImplementing inode permission operations in /proc is almost\n *\tcertainly an error.  Permission checks need to happen during\n *\teach system call not at open time.  The reason is that most of\n *\twhat we wish to check for permissions in /proc varies at runtime.\n *\n *\tThe classic example of a problem is opening file descriptors\n *\tin /proc for a task before it execs a suid executable.\n */\n\nstruct pid_entry {\n\tchar *name;\n\tint len;\n\tmode_t mode;\n\tconst struct inode_operations *iop;\n\tconst struct file_operations *fop;\n\tunion proc_op op;\n};\n\n#define NOD(NAME, MODE, IOP, FOP, OP) {\t\t\t\\\n\t.name = (NAME),\t\t\t\t\t\\\n\t.len  = sizeof(NAME) - 1,\t\t\t\\\n\t.mode = MODE,\t\t\t\t\t\\\n\t.iop  = IOP,\t\t\t\t\t\\\n\t.fop  = FOP,\t\t\t\t\t\\\n\t.op   = OP,\t\t\t\t\t\\\n}\n\n#define DIR(NAME, MODE, iops, fops)\t\\\n\tNOD(NAME, (S_IFDIR|(MODE)), &iops, &fops, {} )\n#define LNK(NAME, get_link)\t\t\t\t\t\\\n\tNOD(NAME, (S_IFLNK|S_IRWXUGO),\t\t\t\t\\\n\t\t&proc_pid_link_inode_operations, NULL,\t\t\\\n\t\t{ .proc_get_link = get_link } )\n#define REG(NAME, MODE, fops)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), NULL, &fops, {})\n#define INF(NAME, MODE, read)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_info_file_operations,\t\\\n\t\t{ .proc_read = read } )\n#define ONE(NAME, MODE, show)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_single_file_operations,\t\\\n\t\t{ .proc_show = show } )\n\n/*\n * Count the number of hardlinks for the pid_entry table, excluding the .\n * and .. links.\n */\nstatic unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}\n\nstatic int get_fs_path(struct task_struct *task, struct path *path, bool root)\n{\n\tstruct fs_struct *fs;\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tfs = task->fs;\n\tif (fs) {\n\t\tread_lock(&fs->lock);\n\t\t*path = root ? fs->root : fs->pwd;\n\t\tpath_get(path);\n\t\tread_unlock(&fs->lock);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}\n\nstatic int get_nr_threads(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tint count = 0;\n\n\tif (lock_task_sighand(tsk, &flags)) {\n\t\tcount = atomic_read(&tsk->signal->count);\n\t\tunlock_task_sighand(tsk, &flags);\n\t}\n\treturn count;\n}\n\nstatic int proc_cwd_link(struct inode *inode, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_fs_path(task, path, 0);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic int proc_root_link(struct inode *inode, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_fs_path(task, path, 1);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\n/*\n * Return zero if current may access user memory in @task, -error if not.\n */\nstatic int check_mem_permission(struct task_struct *task)\n{\n\t/*\n\t * A task can always look at itself, in case it chooses\n\t * to use system calls instead of load instructions.\n\t */\n\tif (task == current)\n\t\treturn 0;\n\n\t/*\n\t * If current is actively ptrace'ing, and would also be\n\t * permitted to freshly attach with ptrace now, permit it.\n\t */\n\tif (task_is_stopped_or_traced(task)) {\n\t\tint match;\n\t\trcu_read_lock();\n\t\tmatch = (tracehook_tracer_task(task) == current);\n\t\trcu_read_unlock();\n\t\tif (match && ptrace_may_access(task, PTRACE_MODE_ATTACH))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Noone else is allowed.\n\t */\n\treturn -EPERM;\n}\n\nstruct mm_struct *mm_for_maps(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\tif (mutex_lock_killable(&task->cred_guard_mutex))\n\t\treturn NULL;\n\n\tmm = get_task_mm(task);\n\tif (mm && mm != current->mm &&\n\t\t\t!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tmmput(mm);\n\t\tmm = NULL;\n\t}\n\tmutex_unlock(&task->cred_guard_mutex);\n\n\treturn mm;\n}\n\nstatic int proc_pid_cmdline(struct task_struct *task, char * buffer)\n{\n\tint res = 0;\n\tunsigned int len;\n\tstruct mm_struct *mm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out;\n\tif (!mm->arg_end)\n\t\tgoto out_mm;\t/* Shh! No looking before we're done */\n\n \tlen = mm->arg_end - mm->arg_start;\n \n\tif (len > PAGE_SIZE)\n\t\tlen = PAGE_SIZE;\n \n\tres = access_process_vm(task, mm->arg_start, buffer, len, 0);\n\n\t// If the nul at the end of args has been overwritten, then\n\t// assume application is using setproctitle(3).\n\tif (res > 0 && buffer[res-1] != '\\0' && len < PAGE_SIZE) {\n\t\tlen = strnlen(buffer, res);\n\t\tif (len < res) {\n\t\t    res = len;\n\t\t} else {\n\t\t\tlen = mm->env_end - mm->env_start;\n\t\t\tif (len > PAGE_SIZE - res)\n\t\t\t\tlen = PAGE_SIZE - res;\n\t\t\tres += access_process_vm(task, mm->env_start, buffer+res, len, 0);\n\t\t\tres = strnlen(buffer, res);\n\t\t}\n\t}\nout_mm:\n\tmmput(mm);\nout:\n\treturn res;\n}\n\nstatic int proc_pid_auxv(struct task_struct *task, char *buffer)\n{\n\tint res = 0;\n\tstruct mm_struct *mm = get_task_mm(task);\n\tif (mm) {\n\t\tunsigned int nwords = 0;\n\t\tdo {\n\t\t\tnwords += 2;\n\t\t} while (mm->saved_auxv[nwords - 2] != 0); /* AT_NULL */\n\t\tres = nwords * sizeof(mm->saved_auxv[0]);\n\t\tif (res > PAGE_SIZE)\n\t\t\tres = PAGE_SIZE;\n\t\tmemcpy(buffer, mm->saved_auxv, res);\n\t\tmmput(mm);\n\t}\n\treturn res;\n}\n\n\n#ifdef CONFIG_KALLSYMS\n/*\n * Provides a wchan file via kallsyms in a proper one-value-per-file format.\n * Returns the resolved symbol.  If that fails, simply return the address.\n */\nstatic int proc_pid_wchan(struct task_struct *task, char *buffer)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\n\twchan = get_wchan(task);\n\n\tif (lookup_symbol_name(wchan, symname) < 0)\n\t\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn sprintf(buffer, \"%lu\", wchan);\n\telse\n\t\treturn sprintf(buffer, \"%s\", symname);\n}\n#endif /* CONFIG_KALLSYMS */\n\n#ifdef CONFIG_STACKTRACE\n\n#define MAX_STACK_TRACE_DEPTH\t64\n\nstatic int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tstruct stack_trace trace;\n\tunsigned long *entries;\n\tint i;\n\n\tentries = kmalloc(MAX_STACK_TRACE_DEPTH * sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= MAX_STACK_TRACE_DEPTH;\n\ttrace.entries\t\t= entries;\n\ttrace.skip\t\t= 0;\n\tsave_stack_trace_tsk(task, &trace);\n\n\tfor (i = 0; i < trace.nr_entries; i++) {\n\t\tseq_printf(m, \"[<%p>] %pS\\n\",\n\t\t\t   (void *)entries[i], (void *)entries[i]);\n\t}\n\tkfree(entries);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n/*\n * Provides /proc/PID/schedstat\n */\nstatic int proc_pid_schedstat(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer, \"%llu %llu %lu\\n\",\n\t\t\t(unsigned long long)task->se.sum_exec_runtime,\n\t\t\t(unsigned long long)task->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}\n#endif\n\n#ifdef CONFIG_LATENCYTOP\nstatic int lstats_show_proc(struct seq_file *m, void *v)\n{\n\tint i;\n\tstruct inode *inode = m->private;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tif (task->latency_record[i].backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %li %li \",\n\t\t\t\ttask->latency_record[i].count,\n\t\t\t\ttask->latency_record[i].time,\n\t\t\t\ttask->latency_record[i].max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tchar sym[KSYM_SYMBOL_LEN];\n\t\t\t\tchar *c;\n\t\t\t\tif (!task->latency_record[i].backtrace[q])\n\t\t\t\t\tbreak;\n\t\t\t\tif (task->latency_record[i].backtrace[q] == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tsprint_symbol(sym, task->latency_record[i].backtrace[q]);\n\t\t\t\tc = strchr(sym, '+');\n\t\t\t\tif (c)\n\t\t\t\t\t*c = 0;\n\t\t\t\tseq_printf(m, \"%s \", sym);\n\t\t\t}\n\t\t\tseq_printf(m, \"\\n\");\n\t\t}\n\n\t}\n\tput_task_struct(task);\n\treturn 0;\n}\n\nstatic int lstats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lstats_show_proc, inode);\n}\n\nstatic ssize_t lstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tclear_all_latency_tracing(task);\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_lstats_operations = {\n\t.open\t\t= lstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\n/* The badness from the OOM killer */\nunsigned long badness(struct task_struct *p, unsigned long uptime);\nstatic int proc_oom_score(struct task_struct *task, char *buffer)\n{\n\tunsigned long points;\n\tstruct timespec uptime;\n\n\tdo_posix_clock_monotonic_gettime(&uptime);\n\tread_lock(&tasklist_lock);\n\tpoints = badness(task->group_leader, uptime.tv_sec);\n\tread_unlock(&tasklist_lock);\n\treturn sprintf(buffer, \"%lu\\n\", points);\n}\n\nstruct limit_names {\n\tchar *name;\n\tchar *unit;\n};\n\nstatic const struct limit_names lnames[RLIM_NLIMITS] = {\n\t[RLIMIT_CPU] = {\"Max cpu time\", \"seconds\"},\n\t[RLIMIT_FSIZE] = {\"Max file size\", \"bytes\"},\n\t[RLIMIT_DATA] = {\"Max data size\", \"bytes\"},\n\t[RLIMIT_STACK] = {\"Max stack size\", \"bytes\"},\n\t[RLIMIT_CORE] = {\"Max core file size\", \"bytes\"},\n\t[RLIMIT_RSS] = {\"Max resident set\", \"bytes\"},\n\t[RLIMIT_NPROC] = {\"Max processes\", \"processes\"},\n\t[RLIMIT_NOFILE] = {\"Max open files\", \"files\"},\n\t[RLIMIT_MEMLOCK] = {\"Max locked memory\", \"bytes\"},\n\t[RLIMIT_AS] = {\"Max address space\", \"bytes\"},\n\t[RLIMIT_LOCKS] = {\"Max file locks\", \"locks\"},\n\t[RLIMIT_SIGPENDING] = {\"Max pending signals\", \"signals\"},\n\t[RLIMIT_MSGQUEUE] = {\"Max msgqueue size\", \"bytes\"},\n\t[RLIMIT_NICE] = {\"Max nice priority\", NULL},\n\t[RLIMIT_RTPRIO] = {\"Max realtime priority\", NULL},\n\t[RLIMIT_RTTIME] = {\"Max realtime timeout\", \"us\"},\n};\n\n/* Display limits for a process */\nstatic int proc_pid_limits(struct task_struct *task, char *buffer)\n{\n\tunsigned int i;\n\tint count = 0;\n\tunsigned long flags;\n\tchar *bufptr = buffer;\n\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn 0;\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\n\t/*\n\t * print the file header\n\t */\n\tcount += sprintf(&bufptr[count], \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-20lu \",\n\t\t\t\t\t rlim[i].rlim_max);\n\n\t\tif (lnames[i].unit)\n\t\t\tcount += sprintf(&bufptr[count], \"%-10s\\n\",\n\t\t\t\t\t lnames[i].unit);\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"\\n\");\n\t}\n\n\treturn count;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\nstatic int proc_pid_syscall(struct task_struct *task, char *buffer)\n{\n\tlong nr;\n\tunsigned long args[6], sp, pc;\n\n\tif (task_current_syscall(task, &nr, args, 6, &sp, &pc))\n\t\treturn sprintf(buffer, \"running\\n\");\n\n\tif (nr < 0)\n\t\treturn sprintf(buffer, \"%ld 0x%lx 0x%lx\\n\", nr, sp, pc);\n\n\treturn sprintf(buffer,\n\t\t       \"%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t       nr,\n\t\t       args[0], args[1], args[2], args[3], args[4], args[5],\n\t\t       sp, pc);\n}\n#endif /* CONFIG_HAVE_ARCH_TRACEHOOK */\n\n/************************************************************************/\n/*                       Here the fs part begins                        */\n/************************************************************************/\n\n/* permission checks */\nstatic int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}\n\nstatic int proc_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (!error)\n\t\terror = inode_setattr(inode, attr);\n\treturn error;\n}\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      const struct seq_operations *op)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (task) {\n\t\trcu_read_lock();\n\t\tnsp = task_nsproxy(task);\n\t\tif (nsp) {\n\t\t\tns = nsp->mnt_ns;\n\t\t\tif (ns)\n\t\t\t\tget_mnt_ns(ns);\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (ns && get_fs_path(task, &root, 1) == 0)\n\t\t\tret = 0;\n\t\tput_task_struct(task);\n\t}\n\n\tif (!ns)\n\t\tgoto err;\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->m.private = p;\n\tp->ns = ns;\n\tp->root = root;\n\tp->event = ns->event;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}\n\nstatic int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release(inode, file);\n}\n\nstatic unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tstruct mnt_namespace *ns = p->ns;\n\tunsigned res = POLLIN | POLLRDNORM;\n\n\tpoll_wait(file, &ns->poll, wait);\n\n\tspin_lock(&vfsmount_lock);\n\tif (p->event != ns->event) {\n\t\tp->event = ns->event;\n\t\tres |= POLLERR | POLLPRI;\n\t}\n\tspin_unlock(&vfsmount_lock);\n\n\treturn res;\n}\n\nstatic int mounts_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mounts_op);\n}\n\nstatic const struct file_operations proc_mounts_operations = {\n\t.open\t\t= mounts_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nstatic int mountinfo_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mountinfo_op);\n}\n\nstatic const struct file_operations proc_mountinfo_operations = {\n\t.open\t\t= mountinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nstatic int mountstats_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mountstats_op);\n}\n\nstatic const struct file_operations proc_mountstats_operations = {\n\t.open\t\t= mountstats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n};\n\n#define PROC_BLOCK_SIZE\t(3*1024)\t\t/* 4K page size but our output routines use some slack for overruns */\n\nstatic ssize_t proc_info_read(struct file * file, char __user * buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tunsigned long page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (count > PROC_BLOCK_SIZE)\n\t\tcount = PROC_BLOCK_SIZE;\n\n\tlength = -ENOMEM;\n\tif (!(page = __get_free_page(GFP_TEMPORARY)))\n\t\tgoto out;\n\n\tlength = PROC_I(inode)->op.proc_read(task, (char*)page);\n\n\tif (length >= 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, (char *)page, length);\n\tfree_page(page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_info_file_operations = {\n\t.read\t\t= proc_info_read,\n};\n\nstatic int proc_single_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tint ret;\n\n\tns = inode->i_sb->s_fs_info;\n\tpid = proc_pid(inode);\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = PROC_I(inode)->op.proc_show(m, ns, pid, task);\n\n\tput_task_struct(task);\n\treturn ret;\n}\n\nstatic int proc_single_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\tret = single_open(filp, proc_single_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_single_file_operations = {\n\t.open\t\t= proc_single_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int mem_open(struct inode* inode, struct file* file)\n{\n\tfile->private_data = (void*)((long)current->self_exec_id);\n\treturn 0;\n}\n\nstatic ssize_t mem_read(struct file * file, char __user * buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (check_mem_permission(task))\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tret = 0;\n \n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_free;\n\n\tret = -EIO;\n \n\tif (file->private_data != (void*)((long)current->self_exec_id))\n\t\tgoto out_put;\n\n\tret = 0;\n \n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tretval = access_process_vm(task, src, page, this_len, 0);\n\t\tif (!retval || check_mem_permission(task)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n \n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\nout_put:\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\n#define mem_write NULL\n\n#ifndef mem_write\n/* This is a security hazard */\nstatic ssize_t mem_write(struct file * file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint copied;\n\tchar *page;\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tunsigned long dst = *ppos;\n\n\tcopied = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (check_mem_permission(task))\n\t\tgoto out;\n\n\tcopied = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tcopied = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tif (copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tretval = access_process_vm(task, dst, page, this_len, 1);\n\t\tif (!retval) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += retval;\n\t\tbuf += retval;\n\t\tdst += retval;\n\t\tcount -= retval;\t\t\t\n\t}\n\t*ppos = dst;\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn copied;\n}\n#endif\n\nloff_t mem_lseek(struct file *file, loff_t offset, int orig)\n{\n\tswitch (orig) {\n\tcase 0:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tcase 1:\n\t\tfile->f_pos += offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tforce_successful_syscall_return();\n\treturn file->f_pos;\n}\n\nstatic const struct file_operations proc_mem_operations = {\n\t.llseek\t\t= mem_lseek,\n\t.read\t\t= mem_read,\n\t.write\t\t= mem_write,\n\t.open\t\t= mem_open,\n};\n\nstatic ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tret = 0;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_free;\n\n\twhile (count > 0) {\n\t\tint this_len, retval, max_len;\n\n\t\tthis_len = mm->env_end - (mm->env_start + src);\n\n\t\tif (this_len <= 0)\n\t\t\tbreak;\n\n\t\tmax_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tthis_len = (this_len > max_len) ? max_len : this_len;\n\n\t\tretval = access_process_vm(task, (mm->env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_environ_operations = {\n\t.read\t\t= environ_read,\n};\n\nstatic ssize_t oom_adjust_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint oom_adjust = OOM_DISABLE;\n\tunsigned long flags;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_adjust = task->signal->oom_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", oom_adjust);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t oom_adjust_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tlong oom_adjust;\n\tunsigned long flags;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\terr = strict_strtol(strstrip(buffer), 0, &oom_adjust);\n\tif (err)\n\t\treturn -EINVAL;\n\tif ((oom_adjust < OOM_ADJUST_MIN || oom_adjust > OOM_ADJUST_MAX) &&\n\t     oom_adjust != OOM_DISABLE)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file->f_path.dentry->d_inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (!lock_task_sighand(task, &flags)) {\n\t\tput_task_struct(task);\n\t\treturn -ESRCH;\n\t}\n\n\tif (oom_adjust < task->signal->oom_adj && !capable(CAP_SYS_RESOURCE)) {\n\t\tunlock_task_sighand(task, &flags);\n\t\tput_task_struct(task);\n\t\treturn -EACCES;\n\t}\n\n\ttask->signal->oom_adj = oom_adjust;\n\n\tunlock_task_sighand(task, &flags);\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_oom_adjust_operations = {\n\t.read\t\t= oom_adjust_read,\n\t.write\t\t= oom_adjust_write,\n};\n\n#ifdef CONFIG_AUDITSYSCALL\n#define TMPBUFLEN 21\nstatic ssize_t proc_loginuid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_loginuid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic ssize_t proc_loginuid_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *page, *tmp;\n\tssize_t length;\n\tuid_t loginuid;\n\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\n\tif (current != pid_task(proc_pid(inode), PIDTYPE_PID))\n\t\treturn -EPERM;\n\n\tif (count >= PAGE_SIZE)\n\t\tcount = PAGE_SIZE - 1;\n\n\tif (*ppos != 0) {\n\t\t/* No partial writes. */\n\t\treturn -EINVAL;\n\t}\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free_page;\n\n\tpage[count] = '\\0';\n\tloginuid = simple_strtoul(page, &tmp, 10);\n\tif (tmp == page) {\n\t\tlength = -EINVAL;\n\t\tgoto out_free_page;\n\n\t}\n\tlength = audit_set_loginuid(current, loginuid);\n\tif (likely(length == 0))\n\t\tlength = count;\n\nout_free_page:\n\tfree_page((unsigned long) page);\n\treturn length;\n}\n\nstatic const struct file_operations proc_loginuid_operations = {\n\t.read\t\t= proc_loginuid_read,\n\t.write\t\t= proc_loginuid_write,\n};\n\nstatic ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations proc_sessionid_operations = {\n\t.read\t\t= proc_sessionid_read,\n};\n#endif\n\n#ifdef CONFIG_FAULT_INJECTION\nstatic ssize_t proc_fault_inject_read(struct file * file, char __user * buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint make_it_fail;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tmake_it_fail = task->make_it_fail;\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", make_it_fail);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t proc_fault_inject_write(struct file * file,\n\t\t\tconst char __user * buf, size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF], *end;\n\tint make_it_fail;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\tmake_it_fail = simple_strtol(strstrip(buffer), &end, 0);\n\tif (*end)\n\t\treturn -EINVAL;\n\ttask = get_proc_task(file->f_dentry->d_inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->make_it_fail = make_it_fail;\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_fault_inject_operations = {\n\t.read\t\t= proc_fault_inject_read,\n\t.write\t\t= proc_fault_inject_write,\n};\n#endif\n\n\n#ifdef CONFIG_SCHED_DEBUG\n/*\n * Print out various scheduling related per-task fields:\n */\nstatic int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_set_task(p);\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, sched_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_sched_operations = {\n\t.open\t\t= sched_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\nstatic ssize_t comm_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\tchar buffer[TASK_COMM_LEN];\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (same_thread_group(current, p))\n\t\tset_task_comm(p, buffer);\n\telse\n\t\tcount = -EINVAL;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int comm_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\ttask_lock(p);\n\tseq_printf(m, \"%s\\n\", p->comm);\n\ttask_unlock(p);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic int comm_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, comm_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_set_comm_operations = {\n\t.open\t\t= comm_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= comm_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n/*\n * We added or removed a vma mapping the executable. The vmas are only mapped\n * during exec and are not mapped with the mmap system call.\n * Callers must hold down_write() on the mm's mmap_sem for these\n */\nvoid added_exe_file_vma(struct mm_struct *mm)\n{\n\tmm->num_exe_file_vmas++;\n}\n\nvoid removed_exe_file_vma(struct mm_struct *mm)\n{\n\tmm->num_exe_file_vmas--;\n\tif ((mm->num_exe_file_vmas == 0) && mm->exe_file){\n\t\tfput(mm->exe_file);\n\t\tmm->exe_file = NULL;\n\t}\n\n}\n\nvoid set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)\n{\n\tif (new_exe_file)\n\t\tget_file(new_exe_file);\n\tif (mm->exe_file)\n\t\tfput(mm->exe_file);\n\tmm->exe_file = new_exe_file;\n\tmm->num_exe_file_vmas = 0;\n}\n\nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\t/* We need mmap_sem to protect against races with removal of\n\t * VM_EXECUTABLE vmas */\n\tdown_read(&mm->mmap_sem);\n\texe_file = mm->exe_file;\n\tif (exe_file)\n\t\tget_file(exe_file);\n\tup_read(&mm->mmap_sem);\n\treturn exe_file;\n}\n\nvoid dup_mm_exe_file(struct mm_struct *oldmm, struct mm_struct *newmm)\n{\n\t/* It's safe to write the exe_file pointer without exe_file_lock because\n\t * this is called during fork when the task is not yet in /proc */\n\tnewmm->exe_file = get_mm_exe_file(oldmm);\n}\n\nstatic int proc_exe_link(struct inode *inode, struct path *exe_path)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct file *exe_file;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ENOENT;\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -ENOENT;\n\texe_file = get_mm_exe_file(mm);\n\tmmput(mm);\n\tif (exe_file) {\n\t\t*exe_path = exe_file->f_path;\n\t\tpath_get(&exe_file->f_path);\n\t\tfput(exe_file);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}\n\nstatic void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\n\t/* We don't need a base pointer in the /proc filesystem */\n\tpath_put(&nd->path);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}\n\nstatic int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}\n\nstatic int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path path;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_proc_readlink(&path, buffer, buflen);\n\tpath_put(&path);\nout:\n\treturn error;\n}\n\nstatic const struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.follow_link\t= proc_pid_follow_link,\n\t.setattr\t= proc_setattr,\n};\n\n\n/* building an inode */\n\nstatic int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif(dumpable == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\n\nstatic struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}\n\nstatic int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n/* dentry stuff */\n\n/*\n *\tExceptional case: normally we are not allowed to unhash a busy\n * directory. In this case, however, we can do it - no aliasing problems\n * due to the way we treat inodes.\n *\n * Rewrite the inode's ownerships here because the owning task may have\n * performed a setuid(), etc.\n *\n * Before the /proc/pid/status file was created the only way to read\n * the effective uid of a /process was to stat /proc/pid.  Reading\n * /proc/pid/status is slow enough that procps and other packages\n * kept stating /proc/pid.  To keep the rules in /proc simple I have\n * made this apply to all per process world readable and executable\n * directories.\n */\nstatic int pid_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tconst struct cred *cred;\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = 0;\n\t\t\tinode->i_gid = 0;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic int pid_delete_dentry(struct dentry * dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn !proc_pid(dentry->d_inode)->tasks[PIDTYPE_PID].first;\n}\n\nstatic const struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\n/* Lookups */\n\ntypedef struct dentry *instantiate_t(struct inode *, struct dentry *,\n\t\t\t\tstruct task_struct *, const void *);\n\n/*\n * Fill a directory entry.\n *\n * If possible create the dcache entry and derive our inode number and\n * file type from dcache entry.\n *\n * Since all of the proc inode numbers are dynamically generated, the inode\n * numbers do not exist until the inode is cache.  This means creating the\n * the dcache entry in readdir is necessary to keep the inode numbers\n * reported by readdir in sync with the inode numbers reported\n * by stat.\n */\nstatic int proc_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tchar *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = filp->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = name;\n\tqname.len  = len;\n\tqname.hash = full_name_hash(name, len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tstruct dentry *new;\n\t\tnew = d_alloc(dir, &qname);\n\t\tif (new) {\n\t\t\tchild = instantiate(dir->d_inode, new, task, ptr);\n\t\t\tif (child)\n\t\t\t\tdput(new);\n\t\t\telse\n\t\t\t\tchild = new;\n\t\t}\n\t}\n\tif (!child || IS_ERR(child) || !child->d_inode)\n\t\tgoto end_instantiate;\n\tinode = child->d_inode;\n\tif (inode) {\n\t\tino = inode->i_ino;\n\t\ttype = inode->i_mode >> 12;\n\t}\n\tdput(child);\nend_instantiate:\n\tif (!ino)\n\t\tino = find_inode_number(dir, &qname);\n\tif (!ino)\n\t\tino = 1;\n\treturn filldir(dirent, name, len, filp->f_pos, ino, type);\n}\n\nstatic unsigned name_to_int(struct dentry *dentry)\n{\n\tconst char *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}\n\n#define PROC_FDINFO_MAX 64\n\nstatic int proc_fd_info(struct inode *inode, struct path *path, char *info)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct files_struct *files = NULL;\n\tstruct file *file;\n\tint fd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tput_task_struct(task);\n\t}\n\tif (files) {\n\t\t/*\n\t\t * We are not taking a ref to the file structure, so we must\n\t\t * hold ->file_lock.\n\t\t */\n\t\tspin_lock(&files->file_lock);\n\t\tfile = fcheck_files(files, fd);\n\t\tif (file) {\n\t\t\tif (path) {\n\t\t\t\t*path = file->f_path;\n\t\t\t\tpath_get(&file->f_path);\n\t\t\t}\n\t\t\tif (info)\n\t\t\t\tsnprintf(info, PROC_FDINFO_MAX,\n\t\t\t\t\t \"pos:\\t%lli\\n\"\n\t\t\t\t\t \"flags:\\t0%o\\n\",\n\t\t\t\t\t (long long) file->f_pos,\n\t\t\t\t\t file->f_flags);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tput_files_struct(files);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\treturn -ENOENT;\n}\n\nstatic int proc_fd_link(struct inode *inode, struct path *path)\n{\n\treturn proc_fd_info(inode, path, NULL);\n}\n\nstatic int tid_fd_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tint fd = proc_fd(inode);\n\tstruct files_struct *files;\n\tconst struct cred *cred;\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\trcu_read_lock();\n\t\t\tif (fcheck_files(files, fd)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = 0;\n\t\t\t\t\tinode->i_gid = 0;\n\t\t\t\t}\n\t\t\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic const struct dentry_operations tid_fd_dentry_operations =\n{\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic struct dentry *proc_fd_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = *(const unsigned *)ptr;\n\tstruct file *file;\n\tstruct files_struct *files;\n \tstruct inode *inode;\n \tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\tfiles = get_files_struct(task);\n\tif (!files)\n\t\tgoto out_iput;\n\tinode->i_mode = S_IFLNK;\n\n\t/*\n\t * We are not taking a ref to the file structure, so we must\n\t * hold ->file_lock.\n\t */\n\tspin_lock(&files->file_lock);\n\tfile = fcheck_files(files, fd);\n\tif (!file)\n\t\tgoto out_unlock;\n\tif (file->f_mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR | S_IXUSR;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR | S_IXUSR;\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\n\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\tei->op.proc_get_link = proc_fd_link;\n\tdentry->d_op = &tid_fd_dentry_operations;\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, NULL))\n\t\terror = NULL;\n\n out:\n\treturn error;\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\nout_iput:\n\tiput(inode);\n\tgoto out;\n}\n\nstatic struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tunsigned fd = name_to_int(dentry);\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, &fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn result;\n}\n\nstatic int proc_readfd_common(struct file * filp, void * dirent,\n\t\t\t      filldir_t filldir, instantiate_t instantiate)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tunsigned int fd, ino;\n\tint retval;\n\tstruct files_struct * files;\n\n\tretval = -ENOENT;\n\tif (!p)\n\t\tgoto out_no_task;\n\tretval = 0;\n\n\tfd = filp->f_pos;\n\tswitch (fd) {\n\t\tcase 0:\n\t\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\tcase 1:\n\t\t\tino = parent_ino(dentry);\n\t\t\tif (filldir(dirent, \"..\", 2, 1, ino, DT_DIR) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\tdefault:\n\t\t\tfiles = get_files_struct(p);\n\t\t\tif (!files)\n\t\t\t\tgoto out;\n\t\t\trcu_read_lock();\n\t\t\tfor (fd = filp->f_pos-2;\n\t\t\t     fd < files_fdtable(files)->max_fds;\n\t\t\t     fd++, filp->f_pos++) {\n\t\t\t\tchar name[PROC_NUMBUF];\n\t\t\t\tint len;\n\n\t\t\t\tif (!fcheck_files(files, fd))\n\t\t\t\t\tcontinue;\n\t\t\t\trcu_read_unlock();\n\n\t\t\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\t\t\tif (proc_fill_cache(filp, dirent, filldir,\n\t\t\t\t\t\t    name, len, instantiate,\n\t\t\t\t\t\t    p, &fd) < 0) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trcu_read_lock();\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t}\nout:\n\tput_task_struct(p);\nout_no_task:\n\treturn retval;\n}\n\nstatic struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct nameidata *nd)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fd_instantiate);\n}\n\nstatic int proc_readfd(struct file *filp, void *dirent, filldir_t filldir)\n{\n\treturn proc_readfd_common(filp, dirent, filldir, proc_fd_instantiate);\n}\n\nstatic ssize_t proc_fdinfo_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *ppos)\n{\n\tchar tmp[PROC_FDINFO_MAX];\n\tint err = proc_fd_info(file->f_path.dentry->d_inode, NULL, tmp);\n\tif (!err)\n\t\terr = simple_read_from_buffer(buf, len, ppos, tmp, strlen(tmp));\n\treturn err;\n}\n\nstatic const struct file_operations proc_fdinfo_file_operations = {\n\t.open\t\t= nonseekable_open,\n\t.read\t\t= proc_fdinfo_read,\n};\n\nstatic const struct file_operations proc_fd_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_readfd,\n};\n\n/*\n * /proc/pid/fd needs a special permission handler so that a process can still\n * access /proc/self/fd after it has executed a setuid().\n */\nstatic int proc_fd_permission(struct inode *inode, int mask)\n{\n\tint rv;\n\n\trv = generic_permission(inode, mask, NULL);\n\tif (rv == 0)\n\t\treturn 0;\n\tif (task_pid(current) == proc_pid(inode))\n\t\trv = 0;\n\treturn rv;\n}\n\n/*\n * proc directories can do almost nothing..\n */\nstatic const struct inode_operations proc_fd_inode_operations = {\n\t.lookup\t\t= proc_lookupfd,\n\t.permission\t= proc_fd_permission,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_fdinfo_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = *(unsigned *)ptr;\n \tstruct inode *inode;\n \tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\tinode->i_mode = S_IFREG | S_IRUSR;\n\tinode->i_fop = &proc_fdinfo_file_operations;\n\tdentry->d_op = &tid_fd_dentry_operations;\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, NULL))\n\t\terror = NULL;\n\n out:\n\treturn error;\n}\n\nstatic struct dentry *proc_lookupfdinfo(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tstruct nameidata *nd)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fdinfo_instantiate);\n}\n\nstatic int proc_readfdinfo(struct file *filp, void *dirent, filldir_t filldir)\n{\n\treturn proc_readfd_common(filp, dirent, filldir,\n\t\t\t\t  proc_fdinfo_instantiate);\n}\n\nstatic const struct file_operations proc_fdinfo_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_readfdinfo,\n};\n\n/*\n * proc directories can do almost nothing..\n */\nstatic const struct inode_operations proc_fdinfo_inode_operations = {\n\t.lookup\t\t= proc_lookupfdinfo,\n\t.setattr\t= proc_setattr,\n};\n\n\nstatic struct dentry *proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_nlink = 2;\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}\n\nstatic int proc_pident_fill_cache(struct file *filp, void *dirent,\n\tfilldir_t filldir, struct task_struct *task, const struct pid_entry *p)\n{\n\treturn proc_fill_cache(filp, dirent, filldir, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p);\n}\n\nstatic int proc_pident_readdir(struct file *filp,\n\t\tvoid *dirent, filldir_t filldir,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tint i;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tconst struct pid_entry *p, *last;\n\tino_t ino;\n\tint ret;\n\n\tret = -ENOENT;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = 0;\n\ti = filp->f_pos;\n\tswitch (i) {\n\tcase 0:\n\t\tino = inode->i_ino;\n\t\tif (filldir(dirent, \".\", 1, i, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\ti++;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tcase 1:\n\t\tino = parent_ino(dentry);\n\t\tif (filldir(dirent, \"..\", 2, i, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\ti++;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\ti -= 2;\n\t\tif (i >= nents) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tp = ents + i;\n\t\tlast = &ents[nents - 1];\n\t\twhile (p <= last) {\n\t\t\tif (proc_pident_fill_cache(filp, dirent, filldir, task, p) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\t\tp++;\n\t\t}\n\t}\n\n\tret = 1;\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\n#ifdef CONFIG_SECURITY\nstatic ssize_t proc_pid_attr_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *p = NULL;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tlength = security_getprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      &p);\n\tput_task_struct(task);\n\tif (length > 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, p, length);\n\tkfree(p);\n\treturn length;\n}\n\nstatic ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free;\n\n\t/* Guard against adverse ptrace interaction */\n\tlength = mutex_lock_interruptible(&task->cred_guard_mutex);\n\tif (length < 0)\n\t\tgoto out_free;\n\n\tlength = security_setprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      (void*)page, count);\n\tmutex_unlock(&task->cred_guard_mutex);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_pid_attr_operations = {\n\t.read\t\t= proc_pid_attr_read,\n\t.write\t\t= proc_pid_attr_write,\n};\n\nstatic const struct pid_entry attr_dir_stuff[] = {\n\tREG(\"current\",    S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"prev\",       S_IRUGO,\t   proc_pid_attr_operations),\n\tREG(\"exec\",       S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"fscreate\",   S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"keycreate\",  S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"sockcreate\", S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n};\n\nstatic int proc_attr_dir_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   attr_dir_stuff,ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct file_operations proc_attr_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_attr_dir_readdir,\n};\n\nstatic struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, struct nameidata *nd)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct inode_operations proc_attr_dir_inode_operations = {\n\t.lookup\t\t= proc_attr_dir_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\n#endif\n\n#ifdef CONFIG_ELF_CORE\nstatic ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint ret;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = 0;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tlen = snprintf(buffer, sizeof(buffer), \"%08lx\\n\",\n\t\t\t       ((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT));\n\t\tmmput(mm);\n\t\tret = simple_read_from_buffer(buf, count, ppos, buffer, len);\n\t}\n\n\tput_task_struct(task);\n\n\treturn ret;\n}\n\nstatic ssize_t proc_coredump_filter_write(struct file *file,\n\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t  size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF], *end;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\tunsigned long mask;\n\n\tret = -EFAULT;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\tgoto out_no_task;\n\n\tret = -EINVAL;\n\tval = (unsigned int)simple_strtoul(buffer, &end, 0);\n\tif (*end == '\\n')\n\t\tend++;\n\tif (end - buffer == 0)\n\t\tgoto out_no_task;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(file->f_dentry->d_inode);\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = end - buffer;\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_no_mm;\n\n\tfor (i = 0, mask = 1; i < MMF_DUMP_FILTER_BITS; i++, mask <<= 1) {\n\t\tif (val & mask)\n\t\t\tset_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t\telse\n\t\t\tclear_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t}\n\n\tmmput(mm);\n out_no_mm:\n\tput_task_struct(task);\n out_no_task:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_coredump_filter_operations = {\n\t.read\t\t= proc_coredump_filter_read,\n\t.write\t\t= proc_coredump_filter_write,\n};\n#endif\n\n/*\n * /proc/self:\n */\nstatic int proc_self_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t      int buflen)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tchar tmp[PROC_NUMBUF];\n\tif (!tgid)\n\t\treturn -ENOENT;\n\tsprintf(tmp, \"%d\", tgid);\n\treturn vfs_readlink(dentry,buffer,buflen,tmp);\n}\n\nstatic void *proc_self_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tchar tmp[PROC_NUMBUF];\n\tif (!tgid)\n\t\treturn ERR_PTR(-ENOENT);\n\tsprintf(tmp, \"%d\", task_tgid_nr_ns(current, ns));\n\treturn ERR_PTR(vfs_follow_link(nd,tmp));\n}\n\nstatic const struct inode_operations proc_self_inode_operations = {\n\t.readlink\t= proc_self_readlink,\n\t.follow_link\t= proc_self_follow_link,\n};\n\n/*\n * proc base\n *\n * These are the directory entries in the root directory of /proc\n * that properly belong to the /proc filesystem, as they describe\n * describe something that is process related.\n */\nstatic const struct pid_entry proc_base_stuff[] = {\n\tNOD(\"self\", S_IFLNK|S_IRWXUGO,\n\t\t&proc_self_inode_operations, NULL, {}),\n};\n\n/*\n *\tExceptional case: normally we are not allowed to unhash a busy\n * directory. In this case, however, we can do it - no aliasing problems\n * due to the way we treat inodes.\n */\nstatic int proc_base_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tif (task) {\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic const struct dentry_operations proc_base_dentry_operations =\n{\n\t.d_revalidate\t= proc_base_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic struct dentry *proc_base_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-EINVAL);\n\n\t/* Allocate the inode */\n\terror = ERR_PTR(-ENOMEM);\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Initialize the inode */\n\tei = PROC_I(inode);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\t/*\n\t * grab the reference to the task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_iput;\n\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_nlink = 2;\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_size = 64;\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\tdentry->d_op = &proc_base_dentry_operations;\n\td_add(dentry, inode);\n\terror = NULL;\nout:\n\treturn error;\nout_iput:\n\tiput(inode);\n\tgoto out;\n}\n\nstatic struct dentry *proc_base_lookup(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/* Lookup the directory entry */\n\tlast = &proc_base_stuff[ARRAY_SIZE(proc_base_stuff) - 1];\n\tfor (p = proc_base_stuff; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_base_instantiate(dir, dentry, task, p);\n\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}\n\nstatic int proc_base_fill_cache(struct file *filp, void *dirent,\n\tfilldir_t filldir, struct task_struct *task, const struct pid_entry *p)\n{\n\treturn proc_fill_cache(filp, dirent, filldir, p->name, p->len,\n\t\t\t\tproc_base_instantiate, task, p);\n}\n\n#ifdef CONFIG_TASK_IO_ACCOUNTING\nstatic int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}\n\nstatic int proc_tid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn do_io_accounting(task, buffer, 0);\n}\n\nstatic int proc_tgid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn do_io_accounting(task, buffer, 1);\n}\n#endif /* CONFIG_TASK_IO_ACCOUNTING */\n\nstatic int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tseq_printf(m, \"%08x\\n\", task->personality);\n\treturn 0;\n}\n\n/*\n * Thread groups\n */\nstatic const struct file_operations proc_task_operations;\nstatic const struct inode_operations proc_task_inode_operations;\n\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tINF(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tINF(\"limits\",\t  S_IRUSR, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tINF(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tINF(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tINF(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tINF(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tREG(\"cpuset\",     S_IRUGO, proc_cpuset_operations),\n#endif\n#ifdef CONFIG_CGROUPS\n\tREG(\"cgroup\",  S_IRUGO, proc_cgroup_operations),\n#endif\n\tINF(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adjust_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tINF(\"io\",\tS_IRUGO, proc_tgid_io_accounting),\n#endif\n};\n\nstatic int proc_tgid_base_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   tgid_base_stuff,ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_tgid_base_readdir,\n};\n\nstatic struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\tshrink_dcache_parent(dentry);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\tshrink_dcache_parent(dentry);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}\n\n/**\n * proc_flush_task -  Remove dcache entries for @task from the /proc dcache.\n * @task: task that should be flushed.\n *\n * When flushing dentries from proc, one needs to flush them from global\n * proc (proc_mnt) and from all the namespaces' procs this task was seen\n * in. This call is supposed to do all of this job.\n *\n * Looks in the dcache for\n * /proc/@pid\n * /proc/@tgid/task/@pid\n * if either directory is present flushes it and all of it'ts children\n * from the dcache.\n *\n * It is safe and reasonable to cache /proc entries for a task until\n * that task exits.  After that they just clog up the dcache with\n * useless entries, possibly causing useful dcache entries to be\n * flushed instead.  This routine is proved to flush those useless\n * dcache entries at process exit time.\n *\n * NOTE: This routine is just an optimization so it does not guarantee\n *       that no dcache entries will exist at process exit time it\n *       just makes it very unlikely that any will persist.\n */\n\nvoid proc_flush_task(struct task_struct *task)\n{\n\tint i;\n\tstruct pid *pid, *tgid;\n\tstruct upid *upid;\n\n\tpid = task_pid(task);\n\ttgid = task_tgid(task);\n\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tupid = &pid->numbers[i];\n\t\tproc_flush_task_mnt(upid->ns->proc_mnt, upid->nr,\n\t\t\t\t\ttgid->numbers[i].nr);\n\t}\n\n\tupid = &pid->numbers[pid->level];\n\tif (upid->nr == 1)\n\t\tpid_ns_release_proc(upid->ns);\n}\n\nstatic struct dentry *proc_pid_instantiate(struct inode *dir,\n\t\t\t\t\t   struct dentry * dentry,\n\t\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tinode->i_nlink = 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\tARRAY_SIZE(tgid_base_stuff));\n\n\tdentry->d_op = &pid_dentry_operations;\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstruct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\tresult = proc_base_lookup(dir, dentry);\n\tif (!IS_ERR(result) || PTR_ERR(result) != -ENOENT)\n\t\tgoto out;\n\n\ttgid = name_to_int(dentry);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn result;\n}\n\n/*\n * Find the first task with tgid >= tgid\n *\n */\nstruct tgid_iter {\n\tunsigned int tgid;\n\tstruct task_struct *task;\n};\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}\n\n#define TGID_OFFSET (FIRST_PROCESS_ENTRY + ARRAY_SIZE(proc_base_stuff))\n\nstatic int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tstruct tgid_iter iter)\n{\n\tchar name[PROC_NUMBUF];\n\tint len = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\treturn proc_fill_cache(filp, dirent, filldir, name, len,\n\t\t\t\tproc_pid_instantiate, iter.task, NULL);\n}\n\n/* for the /proc/ directory itself, after non-process stuff has been done */\nint proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tunsigned int nr = filp->f_pos - FIRST_PROCESS_ENTRY;\n\tstruct task_struct *reaper = get_proc_task(filp->f_path.dentry->d_inode);\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns;\n\n\tif (!reaper)\n\t\tgoto out_no_task;\n\n\tfor (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {\n\t\tconst struct pid_entry *p = &proc_base_stuff[nr];\n\t\tif (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)\n\t\t\tgoto out;\n\t}\n\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\titer.task = NULL;\n\titer.tgid = filp->f_pos - TGID_OFFSET;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tfilp->f_pos = iter.tgid + TGID_OFFSET;\n\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {\n\t\t\tput_task_struct(iter.task);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfilp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;\nout:\n\tput_task_struct(reaper);\nout_no_task:\n\treturn 0;\n}\n\n/*\n * Tasks\n */\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fd_operations),\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tINF(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tINF(\"limits\",\t S_IRUSR, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tINF(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tINF(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tINF(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tINF(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tREG(\"cpuset\",    S_IRUGO, proc_cpuset_operations),\n#endif\n#ifdef CONFIG_CGROUPS\n\tREG(\"cgroup\",  S_IRUGO, proc_cgroup_operations),\n#endif\n\tINF(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adjust_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUSR, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tINF(\"io\",\tS_IRUGO, proc_tid_io_accounting),\n#endif\n};\n\nstatic int proc_tid_base_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   tid_base_stuff,ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_tid_base_readdir,\n};\n\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tinode->i_nlink = 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\tARRAY_SIZE(tid_base_stuff));\n\n\tdentry->d_op = &pid_dentry_operations;\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstatic struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\tstruct task_struct *task;\n\tstruct task_struct *leader = get_proc_task(dir);\n\tunsigned tid;\n\tstruct pid_namespace *ns;\n\n\tif (!leader)\n\t\tgoto out_no_task;\n\n\ttid = name_to_int(dentry);\n\tif (tid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\tif (!same_thread_group(leader, task))\n\t\tgoto out_drop_task;\n\n\tresult = proc_task_instantiate(dir, dentry, task, NULL);\nout_drop_task:\n\tput_task_struct(task);\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn result;\n}\n\n/*\n * Find the first tid of a thread group to return to user space.\n *\n * Usually this is just the thread group leader, but if the users\n * buffer was too small or there was a seek into the middle of the\n * directory we have more work todo.\n *\n * In the case of a short read we start with find_task_by_pid.\n *\n * In the case of a seek we start with the leader and walk nr\n * threads past it.\n */\nstatic struct task_struct *first_tid(struct task_struct *leader,\n\t\tint tid, int nr, struct pid_namespace *ns)\n{\n\tstruct task_struct *pos;\n\n\trcu_read_lock();\n\t/* Attempt to start with the pid of a thread */\n\tif (tid && (nr > 0)) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && (pos->group_leader == leader))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tpos = NULL;\n\tif (nr && nr >= get_nr_threads(leader))\n\t\tgoto out;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tfor (pos = leader; nr > 0; --nr) {\n\t\tpos = next_thread(pos);\n\t\tif (pos == leader) {\n\t\t\tpos = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}\n\n/*\n * Find the next thread in the thread list.\n * Return NULL if there is an error or no next thread.\n *\n * The reference to the input task_struct is released.\n */\nstatic struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}\n\nstatic int proc_task_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tstruct task_struct *task, int tid)\n{\n\tchar name[PROC_NUMBUF];\n\tint len = snprintf(name, sizeof(name), \"%d\", tid);\n\treturn proc_fill_cache(filp, dirent, filldir, name, len,\n\t\t\t\tproc_task_instantiate, task, NULL);\n}\n\n/* for the /proc/TGID/task/ directories */\nstatic int proc_task_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *leader = NULL;\n\tstruct task_struct *task;\n\tint retval = -ENOENT;\n\tino_t ino;\n\tint tid;\n\tstruct pid_namespace *ns;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_no_task;\n\trcu_read_lock();\n\tif (pid_alive(task)) {\n\t\tleader = task->group_leader;\n\t\tget_task_struct(leader);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(task);\n\tif (!leader)\n\t\tgoto out_no_task;\n\tretval = 0;\n\n\tswitch ((unsigned long)filp->f_pos) {\n\tcase 0:\n\t\tino = inode->i_ino;\n\t\tif (filldir(dirent, \".\", 1, filp->f_pos, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tcase 1:\n\t\tino = parent_ino(dentry);\n\t\tif (filldir(dirent, \"..\", 2, filp->f_pos, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\t}\n\n\t/* f_version caches the tgid value that the last readdir call couldn't\n\t * return. lseek aka telldir automagically resets f_version to 0.\n\t */\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\ttid = (int)filp->f_version;\n\tfilp->f_version = 0;\n\tfor (task = first_tid(leader, tid, filp->f_pos - 2, ns);\n\t     task;\n\t     task = next_tid(task), filp->f_pos++) {\n\t\ttid = task_pid_nr_ns(task, ns);\n\t\tif (proc_task_fill_cache(filp, dirent, filldir, task, tid) < 0) {\n\t\t\t/* returning this tgid failed, save it as the first\n\t\t\t * pid for the next readir call */\n\t\t\tfilp->f_version = (u64)tid;\n\t\t\tput_task_struct(task);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn retval;\n}\n\nstatic int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tgeneric_fillattr(inode, stat);\n\n\tif (p) {\n\t\tstat->nlink += get_nr_threads(p);\n\t\tput_task_struct(p);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_task_inode_operations = {\n\t.lookup\t\t= proc_task_lookup,\n\t.getattr\t= proc_task_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic const struct file_operations proc_task_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_task_readdir,\n};\n"], "fixing_code": ["/*\n *  linux/fs/namei.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n * Some corrections by tytso.\n */\n\n/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname\n * lookup logic.\n */\n/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/personality.h>\n#include <linux/security.h>\n#include <linux/ima.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/device_cgroup.h>\n#include <linux/fs_struct.h>\n#include <asm/uaccess.h>\n\n#include \"internal.h\"\n\n/* [Feb-1997 T. Schoebel-Theuer]\n * Fundamental changes in the pathname lookup mechanisms (namei)\n * were necessary because of omirr.  The reason is that omirr needs\n * to know the _real_ pathname, not the user-supplied one, in case\n * of symlinks (and also when transname replacements occur).\n *\n * The new code replaces the old recursive symlink resolution with\n * an iterative one (in case of non-nested symlink chains).  It does\n * this with calls to <fs>_follow_link().\n * As a side effect, dir_namei(), _namei() and follow_link() are now \n * replaced with a single function lookup_dentry() that can handle all \n * the special cases of the former code.\n *\n * With the new dcache, the pathname is stored at each inode, at least as\n * long as the refcount of the inode is positive.  As a side effect, the\n * size of the dcache depends on the inode cache and thus is dynamic.\n *\n * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink\n * resolution to correspond with current state of the code.\n *\n * Note that the symlink resolution is not *completely* iterative.\n * There is still a significant amount of tail- and mid- recursion in\n * the algorithm.  Also, note that <fs>_readlink() is not used in\n * lookup_dentry(): lookup_dentry() on the result of <fs>_readlink()\n * may return different results than <fs>_follow_link().  Many virtual\n * filesystems (including /proc) exhibit this behavior.\n */\n\n/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:\n * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL\n * and the name already exists in form of a symlink, try to create the new\n * name indicated by the symlink. The old code always complained that the\n * name already exists, due to not following the symlink even if its target\n * is nonexistent.  The new semantics affects also mknod() and link() when\n * the name is a symlink pointing to a non-existant name.\n *\n * I don't know which semantics is the right one, since I have no access\n * to standards. But I found by trial that HP-UX 9.0 has the full \"new\"\n * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the\n * \"old\" one. Personally, I think the new semantics is much more logical.\n * Note that \"ln old new\" where \"new\" is a symlink pointing to a non-existing\n * file does succeed in both HP-UX and SunOs, but not in Solaris\n * and in the old Linux semantics.\n */\n\n/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink\n * semantics.  See the comments in \"open_namei\" and \"do_link\" below.\n *\n * [10-Sep-98 Alan Modra] Another symlink change.\n */\n\n/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:\n *\tinside the path - always follow.\n *\tin the last component in creation/removal/renaming - never follow.\n *\tif LOOKUP_FOLLOW passed - follow.\n *\tif the pathname has trailing slashes - follow.\n *\totherwise - don't follow.\n * (applied in that order).\n *\n * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT\n * restored for 2.4. This is the last surviving part of old 4.2BSD bug.\n * During the 2.4 we need to fix the userland stuff depending on it -\n * hopefully we will be able to get rid of that wart in 2.5. So far only\n * XEmacs seems to be relying on it...\n */\n/*\n * [Sep 2001 AV] Single-semaphore locking scheme (kudos to David Holland)\n * implemented.  Let's see if raised priority of ->s_vfs_rename_mutex gives\n * any extra contention...\n */\n\n/* In order to reduce some races, while at the same time doing additional\n * checking and hopefully speeding things up, we copy filenames to the\n * kernel data space before using them..\n *\n * POSIX.1 2.4: an empty pathname is invalid (ENOENT).\n * PATH_MAX includes the nul terminator --RR.\n */\nstatic int do_getname(const char __user *filename, char *page)\n{\n\tint retval;\n\tunsigned long len = PATH_MAX;\n\n\tif (!segment_eq(get_fs(), KERNEL_DS)) {\n\t\tif ((unsigned long) filename >= TASK_SIZE)\n\t\t\treturn -EFAULT;\n\t\tif (TASK_SIZE - (unsigned long) filename < PATH_MAX)\n\t\t\tlen = TASK_SIZE - (unsigned long) filename;\n\t}\n\n\tretval = strncpy_from_user(page, filename, len);\n\tif (retval > 0) {\n\t\tif (retval < len)\n\t\t\treturn 0;\n\t\treturn -ENAMETOOLONG;\n\t} else if (!retval)\n\t\tretval = -ENOENT;\n\treturn retval;\n}\n\nchar * getname(const char __user * filename)\n{\n\tchar *tmp, *result;\n\n\tresult = ERR_PTR(-ENOMEM);\n\ttmp = __getname();\n\tif (tmp)  {\n\t\tint retval = do_getname(filename, tmp);\n\n\t\tresult = tmp;\n\t\tif (retval < 0) {\n\t\t\t__putname(tmp);\n\t\t\tresult = ERR_PTR(retval);\n\t\t}\n\t}\n\taudit_getname(result);\n\treturn result;\n}\n\n#ifdef CONFIG_AUDITSYSCALL\nvoid putname(const char *name)\n{\n\tif (unlikely(!audit_dummy_context()))\n\t\taudit_putname(name);\n\telse\n\t\t__putname(name);\n}\nEXPORT_SYMBOL(putname);\n#endif\n\n/*\n * This does basic POSIX ACL permission checking\n */\nstatic int acl_permission_check(struct inode *inode, int mask,\n\t\tint (*check_acl)(struct inode *inode, int mask))\n{\n\tumode_t\t\t\tmode = inode->i_mode;\n\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\n\tif (current_fsuid() == inode->i_uid)\n\t\tmode >>= 6;\n\telse {\n\t\tif (IS_POSIXACL(inode) && (mode & S_IRWXG) && check_acl) {\n\t\t\tint error = check_acl(inode, mask);\n\t\t\tif (error != -EAGAIN)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tmode >>= 3;\n\t}\n\n\t/*\n\t * If the DACs are ok we don't need any capability check.\n\t */\n\tif ((mask & ~mode) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\n/**\n * generic_permission  -  check for access rights on a Posix-like filesystem\n * @inode:\tinode to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n * @check_acl:\toptional callback to check for Posix ACLs\n *\n * Used to check for read/write/execute permissions on a file.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things..\n */\nint generic_permission(struct inode *inode, int mask,\n\t\tint (*check_acl)(struct inode *inode, int mask))\n{\n\tint ret;\n\n\t/*\n\t * Do the basic POSIX ACL permission checks.\n\t */\n\tret = acl_permission_check(inode, mask, check_acl);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable if at least one exec bit is set.\n\t */\n\tif (!(mask & MAY_EXEC) || execute_ok(inode))\n\t\tif (capable(CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ || (S_ISDIR(inode->i_mode) && !(mask & MAY_WRITE)))\n\t\tif (capable(CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}\n\n/**\n * inode_permission  -  check for access rights to a given inode\n * @inode:\tinode to check permission on\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Used to check for read/write/execute permissions on an inode.\n * We use \"fsuid\" for this, letting us set arbitrary permissions\n * for filesystem access without changing the \"normal\" uids which\n * are used for other things.\n */\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tif (mask & MAY_WRITE) {\n\t\tumode_t mode = inode->i_mode;\n\n\t\t/*\n\t\t * Nobody gets write access to a read-only fs.\n\t\t */\n\t\tif (IS_RDONLY(inode) &&\n\t\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n\t\t\treturn -EROFS;\n\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (inode->i_op->permission)\n\t\tretval = inode->i_op->permission(inode, mask);\n\telse\n\t\tretval = generic_permission(inode, mask, inode->i_op->check_acl);\n\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode,\n\t\t\tmask & (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND));\n}\n\n/**\n * file_permission  -  check for additional access rights to a given file\n * @file:\tfile to check access rights for\n * @mask:\tright to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC)\n *\n * Used to check for read/write/execute permissions on an already opened\n * file.\n *\n * Note:\n *\tDo not use this function in new code.  All access checks should\n *\tbe done using inode_permission().\n */\nint file_permission(struct file *file, int mask)\n{\n\treturn inode_permission(file->f_path.dentry->d_inode, mask);\n}\n\n/*\n * get_write_access() gets write permission for a file.\n * put_write_access() releases this write permission.\n * This is used for regular files.\n * We cannot support write (and maybe mmap read-write shared) accesses and\n * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode\n * can have the following values:\n * 0: no writers, no VM_DENYWRITE mappings\n * < 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist\n * > 0: (i_writecount) users are writing to the file.\n *\n * Normally we operate on that counter with atomic_{inc,dec} and it's safe\n * except for the cases where we don't hold i_writecount yet. Then we need to\n * use {get,deny}_write_access() - these functions check the sign and refuse\n * to do the change if sign is wrong. Exclusion between them is provided by\n * the inode->i_lock spinlock.\n */\n\nint get_write_access(struct inode * inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (atomic_read(&inode->i_writecount) < 0) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn -ETXTBSY;\n\t}\n\tatomic_inc(&inode->i_writecount);\n\tspin_unlock(&inode->i_lock);\n\n\treturn 0;\n}\n\nint deny_write_access(struct file * file)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\n\tspin_lock(&inode->i_lock);\n\tif (atomic_read(&inode->i_writecount) > 0) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn -ETXTBSY;\n\t}\n\tatomic_dec(&inode->i_writecount);\n\tspin_unlock(&inode->i_lock);\n\n\treturn 0;\n}\n\n/**\n * path_get - get a reference to a path\n * @path: path to get the reference to\n *\n * Given a path increment the reference count to the dentry and the vfsmount.\n */\nvoid path_get(struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}\nEXPORT_SYMBOL(path_get);\n\n/**\n * path_put - put a reference to a path\n * @path: path to put the reference to\n *\n * Given a path decrement the reference count to the dentry and the vfsmount.\n */\nvoid path_put(struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}\nEXPORT_SYMBOL(path_put);\n\n/**\n * release_open_intent - free up open intent resources\n * @nd: pointer to nameidata\n */\nvoid release_open_intent(struct nameidata *nd)\n{\n\tif (nd->intent.open.file->f_path.dentry == NULL)\n\t\tput_filp(nd->intent.open.file);\n\telse\n\t\tfput(nd->intent.open.file);\n}\n\nstatic inline struct dentry *\ndo_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tint status = dentry->d_op->d_revalidate(dentry, nd);\n\tif (unlikely(status <= 0)) {\n\t\t/*\n\t\t * The dentry failed validation.\n\t\t * If d_revalidate returned 0 attempt to invalidate\n\t\t * the dentry otherwise d_revalidate is asking us\n\t\t * to return a fail status.\n\t\t */\n\t\tif (!status) {\n\t\t\tif (!d_invalidate(dentry)) {\n\t\t\t\tdput(dentry);\n\t\t\t\tdentry = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tdput(dentry);\n\t\t\tdentry = ERR_PTR(status);\n\t\t}\n\t}\n\treturn dentry;\n}\n\n/*\n * force_reval_path - force revalidation of a dentry\n *\n * In some situations the path walking code will trust dentries without\n * revalidating them. This causes problems for filesystems that depend on\n * d_revalidate to handle file opens (e.g. NFSv4). When FS_REVAL_DOT is set\n * (which indicates that it's possible for the dentry to go stale), force\n * a d_revalidate call before proceeding.\n *\n * Returns 0 if the revalidation was successful. If the revalidation fails,\n * either return the error returned by d_revalidate or -ESTALE if the\n * revalidation it just returned 0. If d_revalidate returns 0, we attempt to\n * invalidate the dentry. It's up to the caller to handle putting references\n * to the path if necessary.\n */\nstatic int\nforce_reval_path(struct path *path, struct nameidata *nd)\n{\n\tint status;\n\tstruct dentry *dentry = path->dentry;\n\n\t/*\n\t * only check on filesystems where it's possible for the dentry to\n\t * become stale. It's assumed that if this flag is set then the\n\t * d_revalidate op will also be defined.\n\t */\n\tif (!(dentry->d_sb->s_type->fs_flags & FS_REVAL_DOT))\n\t\treturn 0;\n\n\tstatus = dentry->d_op->d_revalidate(dentry, nd);\n\tif (status > 0)\n\t\treturn 0;\n\n\tif (!status) {\n\t\td_invalidate(dentry);\n\t\tstatus = -ESTALE;\n\t}\n\treturn status;\n}\n\n/*\n * Short-cut version of permission(), for calling on directories\n * during pathname resolution.  Combines parts of permission()\n * and generic_permission(), and tests ONLY for MAY_EXEC permission.\n *\n * If appropriate, check DAC only.  If not appropriate, or\n * short-cut DAC fails, then call ->permission() to do more\n * complete permission check.\n */\nstatic int exec_permission(struct inode *inode)\n{\n\tint ret;\n\n\tif (inode->i_op->permission) {\n\t\tret = inode->i_op->permission(inode, MAY_EXEC);\n\t\tif (!ret)\n\t\t\tgoto ok;\n\t\treturn ret;\n\t}\n\tret = acl_permission_check(inode, MAY_EXEC, inode->i_op->check_acl);\n\tif (!ret)\n\t\tgoto ok;\n\n\tif (capable(CAP_DAC_OVERRIDE) || capable(CAP_DAC_READ_SEARCH))\n\t\tgoto ok;\n\n\treturn ret;\nok:\n\treturn security_inode_permission(inode, MAY_EXEC);\n}\n\nstatic __always_inline void set_root(struct nameidata *nd)\n{\n\tif (!nd->root.mnt) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tread_lock(&fs->lock);\n\t\tnd->root = fs->root;\n\t\tpath_get(&nd->root);\n\t\tread_unlock(&fs->lock);\n\t}\n}\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstatic __always_inline int __vfs_follow_link(struct nameidata *nd, const char *link)\n{\n\tint res = 0;\n\tchar *name;\n\tif (IS_ERR(link))\n\t\tgoto fail;\n\n\tif (*link == '/') {\n\t\tset_root(nd);\n\t\tpath_put(&nd->path);\n\t\tnd->path = nd->root;\n\t\tpath_get(&nd->root);\n\t}\n\n\tres = link_path_walk(link, nd);\n\tif (nd->depth || res || nd->last_type!=LAST_NORM)\n\t\treturn res;\n\t/*\n\t * If it is an iterative symlinks resolution in open_namei() we\n\t * have to copy the last component. And all that crap because of\n\t * bloody create() on broken symlinks. Furrfu...\n\t */\n\tname = __getname();\n\tif (unlikely(!name)) {\n\t\tpath_put(&nd->path);\n\t\treturn -ENOMEM;\n\t}\n\tstrcpy(name, nd->last.name);\n\tnd->last.name = name;\n\treturn 0;\nfail:\n\tpath_put(&nd->path);\n\treturn PTR_ERR(link);\n}\n\nstatic void path_put_conditional(struct path *path, struct nameidata *nd)\n{\n\tdput(path->dentry);\n\tif (path->mnt != nd->path.mnt)\n\t\tmntput(path->mnt);\n}\n\nstatic inline void path_to_nameidata(struct path *path, struct nameidata *nd)\n{\n\tdput(nd->path.dentry);\n\tif (nd->path.mnt != path->mnt)\n\t\tmntput(nd->path.mnt);\n\tnd->path.mnt = path->mnt;\n\tnd->path.dentry = path->dentry;\n}\n\nstatic __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n\t\tdget(dentry);\n\t}\n\tmntget(path->mnt);\n\tnd->last_type = LAST_BIND;\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(cookie);\n\tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}\n\n/*\n * This limits recursive symlink follows to 8, while\n * limiting consecutive symlinks to 40.\n *\n * Without that kind of total limit, nasty chains of consecutive\n * symlinks can cause almost arbitrarily long lookups. \n */\nstatic inline int do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint err = -ELOOP;\n\tif (current->link_count >= MAX_NESTED_LINKS)\n\t\tgoto loop;\n\tif (current->total_link_count >= 40)\n\t\tgoto loop;\n\tBUG_ON(nd->depth >= MAX_NESTED_LINKS);\n\tcond_resched();\n\terr = security_inode_follow_link(path->dentry, nd);\n\tif (err)\n\t\tgoto loop;\n\tcurrent->link_count++;\n\tcurrent->total_link_count++;\n\tnd->depth++;\n\terr = __do_follow_link(path, nd);\n\tpath_put(path);\n\tcurrent->link_count--;\n\tnd->depth--;\n\treturn err;\nloop:\n\tpath_put_conditional(path, nd);\n\tpath_put(&nd->path);\n\treturn err;\n}\n\nint follow_up(struct path *path)\n{\n\tstruct vfsmount *parent;\n\tstruct dentry *mountpoint;\n\tspin_lock(&vfsmount_lock);\n\tparent = path->mnt->mnt_parent;\n\tif (parent == path->mnt) {\n\t\tspin_unlock(&vfsmount_lock);\n\t\treturn 0;\n\t}\n\tmntget(parent);\n\tmountpoint = dget(path->mnt->mnt_mountpoint);\n\tspin_unlock(&vfsmount_lock);\n\tdput(path->dentry);\n\tpath->dentry = mountpoint;\n\tmntput(path->mnt);\n\tpath->mnt = parent;\n\treturn 1;\n}\n\n/* no need for dcache_lock, as serialization is taken care in\n * namespace.c\n */\nstatic int __follow_mount(struct path *path)\n{\n\tint res = 0;\n\twhile (d_mountpoint(path->dentry)) {\n\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tdput(path->dentry);\n\t\tif (res)\n\t\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\tres = 1;\n\t}\n\treturn res;\n}\n\nstatic void follow_mount(struct path *path)\n{\n\twhile (d_mountpoint(path->dentry)) {\n\t\tstruct vfsmount *mounted = lookup_mnt(path);\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t}\n}\n\n/* no need for dcache_lock, as serialization is taken care in\n * namespace.c\n */\nint follow_down(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic __always_inline void follow_dotdot(struct nameidata *nd)\n{\n\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct vfsmount *parent;\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tspin_lock(&dcache_lock);\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget(nd->path.dentry->d_parent);\n\t\t\tspin_unlock(&dcache_lock);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&dcache_lock);\n\t\tspin_lock(&vfsmount_lock);\n\t\tparent = nd->path.mnt->mnt_parent;\n\t\tif (parent == nd->path.mnt) {\n\t\t\tspin_unlock(&vfsmount_lock);\n\t\t\tbreak;\n\t\t}\n\t\tmntget(parent);\n\t\tnd->path.dentry = dget(nd->path.mnt->mnt_mountpoint);\n\t\tspin_unlock(&vfsmount_lock);\n\t\tdput(old);\n\t\tmntput(nd->path.mnt);\n\t\tnd->path.mnt = parent;\n\t}\n\tfollow_mount(&nd->path);\n}\n\n/*\n *  It's more convoluted than I'd like it to be, but... it's still fairly\n *  small and for now I'd prefer to have fast path as straight as possible.\n *  It _is_ time-critical.\n */\nstatic int do_lookup(struct nameidata *nd, struct qstr *name,\n\t\t     struct path *path)\n{\n\tstruct vfsmount *mnt = nd->path.mnt;\n\tstruct dentry *dentry, *parent;\n\tstruct inode *dir;\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (nd->path.dentry->d_op && nd->path.dentry->d_op->d_hash) {\n\t\tint err = nd->path.dentry->d_op->d_hash(nd->path.dentry, name);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tdentry = __d_lookup(nd->path.dentry, name);\n\tif (!dentry)\n\t\tgoto need_lookup;\n\tif (dentry->d_op && dentry->d_op->d_revalidate)\n\t\tgoto need_revalidate;\ndone:\n\tpath->mnt = mnt;\n\tpath->dentry = dentry;\n\t__follow_mount(path);\n\treturn 0;\n\nneed_lookup:\n\tparent = nd->path.dentry;\n\tdir = parent->d_inode;\n\n\tmutex_lock(&dir->i_mutex);\n\t/*\n\t * First re-do the cached lookup just in case it was created\n\t * while we waited for the directory semaphore..\n\t *\n\t * FIXME! This could use version numbering or similar to\n\t * avoid unnecessary cache lookups.\n\t *\n\t * The \"dcache_lock\" is purely to protect the RCU list walker\n\t * from concurrent renames at this point (we mustn't get false\n\t * negatives from the RCU list walk here, unlike the optimistic\n\t * fast walk).\n\t *\n\t * so doing d_lookup() (with seqlock), instead of lockfree __d_lookup\n\t */\n\tdentry = d_lookup(parent, name);\n\tif (!dentry) {\n\t\tstruct dentry *new;\n\n\t\t/* Don't create child dentry for a dead directory. */\n\t\tdentry = ERR_PTR(-ENOENT);\n\t\tif (IS_DEADDIR(dir))\n\t\t\tgoto out_unlock;\n\n\t\tnew = d_alloc(parent, name);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tif (new) {\n\t\t\tdentry = dir->i_op->lookup(dir, new, nd);\n\t\t\tif (dentry)\n\t\t\t\tdput(new);\n\t\t\telse\n\t\t\t\tdentry = new;\n\t\t}\nout_unlock:\n\t\tmutex_unlock(&dir->i_mutex);\n\t\tif (IS_ERR(dentry))\n\t\t\tgoto fail;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Uhhuh! Nasty case: the cache was re-populated while\n\t * we waited on the semaphore. Need to revalidate.\n\t */\n\tmutex_unlock(&dir->i_mutex);\n\tif (dentry->d_op && dentry->d_op->d_revalidate) {\n\t\tdentry = do_revalidate(dentry, nd);\n\t\tif (!dentry)\n\t\t\tdentry = ERR_PTR(-ENOENT);\n\t}\n\tif (IS_ERR(dentry))\n\t\tgoto fail;\n\tgoto done;\n\nneed_revalidate:\n\tdentry = do_revalidate(dentry, nd);\n\tif (!dentry)\n\t\tgoto need_lookup;\n\tif (IS_ERR(dentry))\n\t\tgoto fail;\n\tgoto done;\n\nfail:\n\treturn PTR_ERR(dentry);\n}\n\n/*\n * Name resolution.\n * This is the basic name resolution function, turning a pathname into\n * the final dentry. We expect 'base' to be positive and a directory.\n *\n * Returns 0 and nd will have valid dentry and mnt on success.\n * Returns error and drops reference to input namei data on failure.\n */\nstatic int link_path_walk(const char *name, struct nameidata *nd)\n{\n\tstruct path next;\n\tstruct inode *inode;\n\tint err;\n\tunsigned int lookup_flags = nd->flags;\n\t\n\twhile (*name=='/')\n\t\tname++;\n\tif (!*name)\n\t\tgoto return_reval;\n\n\tinode = nd->path.dentry->d_inode;\n\tif (nd->depth)\n\t\tlookup_flags = LOOKUP_FOLLOW | (nd->flags & LOOKUP_CONTINUE);\n\n\t/* At this point we know we have a real path component. */\n\tfor(;;) {\n\t\tunsigned long hash;\n\t\tstruct qstr this;\n\t\tunsigned int c;\n\n\t\tnd->flags |= LOOKUP_CONTINUE;\n\t\terr = exec_permission(inode);\n \t\tif (err)\n\t\t\tbreak;\n\n\t\tthis.name = name;\n\t\tc = *(const unsigned char *)name;\n\n\t\thash = init_name_hash();\n\t\tdo {\n\t\t\tname++;\n\t\t\thash = partial_name_hash(c, hash);\n\t\t\tc = *(const unsigned char *)name;\n\t\t} while (c && (c != '/'));\n\t\tthis.len = name - (const char *) this.name;\n\t\tthis.hash = end_name_hash(hash);\n\n\t\t/* remove trailing slashes? */\n\t\tif (!c)\n\t\t\tgoto last_component;\n\t\twhile (*++name == '/');\n\t\tif (!*name)\n\t\t\tgoto last_with_slashes;\n\n\t\t/*\n\t\t * \".\" and \"..\" are special - \"..\" especially so because it has\n\t\t * to be able to know about the current root directory and\n\t\t * parent relationships.\n\t\t */\n\t\tif (this.name[0] == '.') switch (this.len) {\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\tcase 2:\t\n\t\t\t\tif (this.name[1] != '.')\n\t\t\t\t\tbreak;\n\t\t\t\tfollow_dotdot(nd);\n\t\t\t\tinode = nd->path.dentry->d_inode;\n\t\t\t\t/* fallthrough */\n\t\t\tcase 1:\n\t\t\t\tcontinue;\n\t\t}\n\t\t/* This does the actual lookups.. */\n\t\terr = do_lookup(nd, &this, &next);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = -ENOENT;\n\t\tinode = next.dentry->d_inode;\n\t\tif (!inode)\n\t\t\tgoto out_dput;\n\n\t\tif (inode->i_op->follow_link) {\n\t\t\terr = do_follow_link(&next, nd);\n\t\t\tif (err)\n\t\t\t\tgoto return_err;\n\t\t\terr = -ENOENT;\n\t\t\tinode = nd->path.dentry->d_inode;\n\t\t\tif (!inode)\n\t\t\t\tbreak;\n\t\t} else\n\t\t\tpath_to_nameidata(&next, nd);\n\t\terr = -ENOTDIR; \n\t\tif (!inode->i_op->lookup)\n\t\t\tbreak;\n\t\tcontinue;\n\t\t/* here ends the main loop */\n\nlast_with_slashes:\n\t\tlookup_flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;\nlast_component:\n\t\t/* Clear LOOKUP_CONTINUE iff it was previously unset */\n\t\tnd->flags &= lookup_flags | ~LOOKUP_CONTINUE;\n\t\tif (lookup_flags & LOOKUP_PARENT)\n\t\t\tgoto lookup_parent;\n\t\tif (this.name[0] == '.') switch (this.len) {\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\tcase 2:\t\n\t\t\t\tif (this.name[1] != '.')\n\t\t\t\t\tbreak;\n\t\t\t\tfollow_dotdot(nd);\n\t\t\t\tinode = nd->path.dentry->d_inode;\n\t\t\t\t/* fallthrough */\n\t\t\tcase 1:\n\t\t\t\tgoto return_reval;\n\t\t}\n\t\terr = do_lookup(nd, &this, &next);\n\t\tif (err)\n\t\t\tbreak;\n\t\tinode = next.dentry->d_inode;\n\t\tif ((lookup_flags & LOOKUP_FOLLOW)\n\t\t    && inode && inode->i_op->follow_link) {\n\t\t\terr = do_follow_link(&next, nd);\n\t\t\tif (err)\n\t\t\t\tgoto return_err;\n\t\t\tinode = nd->path.dentry->d_inode;\n\t\t} else\n\t\t\tpath_to_nameidata(&next, nd);\n\t\terr = -ENOENT;\n\t\tif (!inode)\n\t\t\tbreak;\n\t\tif (lookup_flags & LOOKUP_DIRECTORY) {\n\t\t\terr = -ENOTDIR; \n\t\t\tif (!inode->i_op->lookup)\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto return_base;\nlookup_parent:\n\t\tnd->last = this;\n\t\tnd->last_type = LAST_NORM;\n\t\tif (this.name[0] != '.')\n\t\t\tgoto return_base;\n\t\tif (this.len == 1)\n\t\t\tnd->last_type = LAST_DOT;\n\t\telse if (this.len == 2 && this.name[1] == '.')\n\t\t\tnd->last_type = LAST_DOTDOT;\n\t\telse\n\t\t\tgoto return_base;\nreturn_reval:\n\t\t/*\n\t\t * We bypassed the ordinary revalidation routines.\n\t\t * We may need to check the cached dentry for staleness.\n\t\t */\n\t\tif (nd->path.dentry && nd->path.dentry->d_sb &&\n\t\t    (nd->path.dentry->d_sb->s_type->fs_flags & FS_REVAL_DOT)) {\n\t\t\terr = -ESTALE;\n\t\t\t/* Note: we do not d_invalidate() */\n\t\t\tif (!nd->path.dentry->d_op->d_revalidate(\n\t\t\t\t\tnd->path.dentry, nd))\n\t\t\t\tbreak;\n\t\t}\nreturn_base:\n\t\treturn 0;\nout_dput:\n\t\tpath_put_conditional(&next, nd);\n\t\tbreak;\n\t}\n\tpath_put(&nd->path);\nreturn_err:\n\treturn err;\n}\n\nstatic int path_walk(const char *name, struct nameidata *nd)\n{\n\tstruct path save = nd->path;\n\tint result;\n\n\tcurrent->total_link_count = 0;\n\n\t/* make sure the stuff we saved doesn't go away */\n\tpath_get(&save);\n\n\tresult = link_path_walk(name, nd);\n\tif (result == -ESTALE) {\n\t\t/* nd->path had been dropped */\n\t\tcurrent->total_link_count = 0;\n\t\tnd->path = save;\n\t\tpath_get(&nd->path);\n\t\tnd->flags |= LOOKUP_REVAL;\n\t\tresult = link_path_walk(name, nd);\n\t}\n\n\tpath_put(&save);\n\n\treturn result;\n}\n\nstatic int path_init(int dfd, const char *name, unsigned int flags, struct nameidata *nd)\n{\n\tint retval = 0;\n\tint fput_needed;\n\tstruct file *file;\n\n\tnd->last_type = LAST_ROOT; /* if there are only slashes... */\n\tnd->flags = flags;\n\tnd->depth = 0;\n\tnd->root.mnt = NULL;\n\n\tif (*name=='/') {\n\t\tset_root(nd);\n\t\tnd->path = nd->root;\n\t\tpath_get(&nd->root);\n\t} else if (dfd == AT_FDCWD) {\n\t\tstruct fs_struct *fs = current->fs;\n\t\tread_lock(&fs->lock);\n\t\tnd->path = fs->pwd;\n\t\tpath_get(&fs->pwd);\n\t\tread_unlock(&fs->lock);\n\t} else {\n\t\tstruct dentry *dentry;\n\n\t\tfile = fget_light(dfd, &fput_needed);\n\t\tretval = -EBADF;\n\t\tif (!file)\n\t\t\tgoto out_fail;\n\n\t\tdentry = file->f_path.dentry;\n\n\t\tretval = -ENOTDIR;\n\t\tif (!S_ISDIR(dentry->d_inode->i_mode))\n\t\t\tgoto fput_fail;\n\n\t\tretval = file_permission(file, MAY_EXEC);\n\t\tif (retval)\n\t\t\tgoto fput_fail;\n\n\t\tnd->path = file->f_path;\n\t\tpath_get(&file->f_path);\n\n\t\tfput_light(file, fput_needed);\n\t}\n\treturn 0;\n\nfput_fail:\n\tfput_light(file, fput_needed);\nout_fail:\n\treturn retval;\n}\n\n/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */\nstatic int do_path_lookup(int dfd, const char *name,\n\t\t\t\tunsigned int flags, struct nameidata *nd)\n{\n\tint retval = path_init(dfd, name, flags, nd);\n\tif (!retval)\n\t\tretval = path_walk(name, nd);\n\tif (unlikely(!retval && !audit_dummy_context() && nd->path.dentry &&\n\t\t\t\tnd->path.dentry->d_inode))\n\t\taudit_inode(name, nd->path.dentry);\n\tif (nd->root.mnt) {\n\t\tpath_put(&nd->root);\n\t\tnd->root.mnt = NULL;\n\t}\n\treturn retval;\n}\n\nint path_lookup(const char *name, unsigned int flags,\n\t\t\tstruct nameidata *nd)\n{\n\treturn do_path_lookup(AT_FDCWD, name, flags, nd);\n}\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}\n\n/**\n * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair\n * @dentry:  pointer to dentry of the base directory\n * @mnt: pointer to vfs mount of the base directory\n * @name: pointer to file name\n * @flags: lookup flags\n * @nd: pointer to nameidata\n */\nint vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt,\n\t\t    const char *name, unsigned int flags,\n\t\t    struct nameidata *nd)\n{\n\tint retval;\n\n\t/* same as do_path_lookup */\n\tnd->last_type = LAST_ROOT;\n\tnd->flags = flags;\n\tnd->depth = 0;\n\n\tnd->path.dentry = dentry;\n\tnd->path.mnt = mnt;\n\tpath_get(&nd->path);\n\tnd->root = nd->path;\n\tpath_get(&nd->root);\n\n\tretval = path_walk(name, nd);\n\tif (unlikely(!retval && !audit_dummy_context() && nd->path.dentry &&\n\t\t\t\tnd->path.dentry->d_inode))\n\t\taudit_inode(name, nd->path.dentry);\n\n\tpath_put(&nd->root);\n\tnd->root.mnt = NULL;\n\n\treturn retval;\n}\n\nstatic struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, struct nameidata *nd)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = base->d_inode;\n\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_op && base->d_op->d_hash) {\n\t\terr = base->d_op->d_hash(base, name);\n\t\tdentry = ERR_PTR(err);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tdentry = __d_lookup(base, name);\n\n\t/* lockess __d_lookup may fail due to concurrent d_move()\n\t * in some unrelated directory, so try with d_lookup\n\t */\n\tif (!dentry)\n\t\tdentry = d_lookup(base, name);\n\n\tif (dentry && dentry->d_op && dentry->d_op->d_revalidate)\n\t\tdentry = do_revalidate(dentry, nd);\n\n\tif (!dentry) {\n\t\tstruct dentry *new;\n\n\t\t/* Don't create child dentry for a dead directory. */\n\t\tdentry = ERR_PTR(-ENOENT);\n\t\tif (IS_DEADDIR(inode))\n\t\t\tgoto out;\n\n\t\tnew = d_alloc(base, name);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tif (!new)\n\t\t\tgoto out;\n\t\tdentry = inode->i_op->lookup(inode, new, nd);\n\t\tif (!dentry)\n\t\t\tdentry = new;\n\t\telse\n\t\t\tdput(new);\n\t}\nout:\n\treturn dentry;\n}\n\n/*\n * Restricted form of lookup. Doesn't follow links, single-component only,\n * needs parent already locked. Doesn't follow mounts.\n * SMP-safe.\n */\nstatic struct dentry *lookup_hash(struct nameidata *nd)\n{\n\tint err;\n\n\terr = exec_permission(nd->path.dentry->d_inode);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn __lookup_hash(&nd->last, nd->path.dentry, nd);\n}\n\nstatic int __lookup_one_len(const char *name, struct qstr *this,\n\t\tstruct dentry *base, int len)\n{\n\tunsigned long hash;\n\tunsigned int c;\n\n\tthis->name = name;\n\tthis->len = len;\n\tif (!len)\n\t\treturn -EACCES;\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn -EACCES;\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tthis->hash = end_name_hash(hash);\n\treturn 0;\n}\n\n/**\n * lookup_one_len - filesystem helper to lookup single pathname component\n * @name:\tpathname component to lookup\n * @base:\tbase directory to lookup from\n * @len:\tmaximum length @len should be interpreted to\n *\n * Note that this routine is purely a helper for filesystem usage and should\n * not be called by generic code.  Also note that by using this function the\n * nameidata argument is passed to the filesystem methods and a filesystem\n * using this helper needs to be prepared for that.\n */\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tint err;\n\tstruct qstr this;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\terr = __lookup_one_len(name, &this, base, len);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\terr = exec_permission(base->d_inode);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn __lookup_hash(&this, base, NULL);\n}\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\tstruct nameidata nd;\n\tchar *tmp = getname(name);\n\tint err = PTR_ERR(tmp);\n\tif (!IS_ERR(tmp)) {\n\n\t\tBUG_ON(flags & LOOKUP_PARENT);\n\n\t\terr = do_path_lookup(dfd, tmp, flags, &nd);\n\t\tputname(tmp);\n\t\tif (!err)\n\t\t\t*path = nd.path;\n\t}\n\treturn err;\n}\n\nstatic int user_path_parent(int dfd, const char __user *path,\n\t\t\tstruct nameidata *nd, char **name)\n{\n\tchar *s = getname(path);\n\tint error;\n\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\n\terror = do_path_lookup(dfd, s, LOOKUP_PARENT, nd);\n\tif (error)\n\t\tputname(s);\n\telse\n\t\t*name = s;\n\n\treturn error;\n}\n\n/*\n * It's inline, so penalty for filesystems that don't use sticky bit is\n * minimal.\n */\nstatic inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tuid_t fsuid = current_fsuid();\n\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (inode->i_uid == fsuid)\n\t\treturn 0;\n\tif (dir->i_uid == fsuid)\n\t\treturn 0;\n\treturn !capable(CAP_FOWNER);\n}\n\n/*\n *\tCheck whether we can remove a link victim from directory dir, check\n *  whether the type of victim is right.\n *  1. We can't do it if dir is read-only (done in permission())\n *  2. We should have write and exec permissions on dir\n *  3. We can't remove anything from append-only dir\n *  4. We can't do anything with immutable dir (done in permission())\n *  5. If the sticky bit on dir is set we should either\n *\ta. be owner of dir, or\n *\tb. be owner of victim, or\n *\tc. have CAP_FOWNER capability\n *  6. If the victim is append-only or immutable we can't do antyhing with\n *     links pointing to it.\n *  7. If we were asked to remove a directory and victim isn't one - ENOTDIR.\n *  8. If we were asked to remove a non-directory and victim isn't one - EISDIR.\n *  9. We can't remove a root or mountpoint.\n * 10. We don't allow removal of NFS sillyrenamed files; it's handled by\n *     nfs_async_unlink().\n */\nstatic int may_delete(struct inode *dir,struct dentry *victim,int isdir)\n{\n\tint error;\n\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(victim->d_name.name, victim, dir);\n\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!S_ISDIR(victim->d_inode->i_mode))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (S_ISDIR(victim->d_inode->i_mode))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n/*\tCheck whether we can create an object with dentry child in directory\n *  dir.\n *  1. We can't do it if child already exists (open has special treatment for\n *     this case, but since we are inlined it's OK)\n *  2. We can't do it if dir is read-only (done in permission())\n *  3. We should have write and exec permissions on dir\n *  4. We can't do it if dir is immutable (done in permission())\n */\nstatic inline int may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}\n\n/* \n * O_DIRECTORY translates into forcing a directory lookup.\n */\nstatic inline int lookup_flags(unsigned int f)\n{\n\tunsigned long retval = LOOKUP_FOLLOW;\n\n\tif (f & O_NOFOLLOW)\n\t\tretval &= ~LOOKUP_FOLLOW;\n\t\n\tif (f & O_DIRECTORY)\n\t\tretval |= LOOKUP_DIRECTORY;\n\n\treturn retval;\n}\n\n/*\n * p1 and p2 should be directories on the same fs.\n */\nstruct dentry *lock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tif (p1 == p2) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\n\tp = d_ancestor(p2, p1);\n\tif (p) {\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tp = d_ancestor(p1, p2);\n\tif (p) {\n\t\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\t\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\t\treturn p;\n\t}\n\n\tmutex_lock_nested(&p1->d_inode->i_mutex, I_MUTEX_PARENT);\n\tmutex_lock_nested(&p2->d_inode->i_mutex, I_MUTEX_CHILD);\n\treturn NULL;\n}\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}\n\nint vfs_create(struct inode *dir, struct dentry *dentry, int mode,\n\t\tstruct nameidata *nd)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->create)\n\t\treturn -EACCES;\t/* shouldn't it be ENOSYS? */\n\tmode &= S_IALLUGO;\n\tmode |= S_IFREG;\n\terror = security_inode_create(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\tvfs_dq_init(dir);\n\terror = dir->i_op->create(dir, dentry, mode, nd);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\n\nint may_open(struct path *path, int acc_mode, int flag)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFLNK:\n\t\treturn -ELOOP;\n\tcase S_IFDIR:\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\treturn -EISDIR;\n\t\tbreak;\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tif (path->mnt->mnt_flags & MNT_NODEV)\n\t\t\treturn -EACCES;\n\t\t/*FALLTHRU*/\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\tflag &= ~O_TRUNC;\n\t\tbreak;\n\t}\n\n\terror = inode_permission(inode, acc_mode);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * An append-only file must be opened in append mode for writing.\n\t */\n\tif (IS_APPEND(inode)) {\n\t\tif  ((flag & FMODE_WRITE) && !(flag & O_APPEND))\n\t\t\treturn -EPERM;\n\t\tif (flag & O_TRUNC)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* O_NOATIME can only be set by the owner or superuser */\n\tif (flag & O_NOATIME && !is_owner_or_cap(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * Ensure there are no outstanding leases on the file.\n\t */\n\treturn break_lease(inode, flag);\n}\n\nstatic int handle_truncate(struct path *path)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\tint error = get_write_access(inode);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * Refuse to truncate files with mandatory locks held on them.\n\t */\n\terror = locks_verify_locked(inode);\n\tif (!error)\n\t\terror = security_path_truncate(path, 0,\n\t\t\t\t       ATTR_MTIME|ATTR_CTIME|ATTR_OPEN);\n\tif (!error) {\n\t\terror = do_truncate(path->dentry, 0,\n\t\t\t\t    ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,\n\t\t\t\t    NULL);\n\t}\n\tput_write_access(inode);\n\treturn error;\n}\n\n/*\n * Be careful about ever adding any more callers of this\n * function.  Its flags must be in the namei format, not\n * what get passed to sys_open().\n */\nstatic int __open_namei_create(struct nameidata *nd, struct path *path,\n\t\t\t\tint flag, int mode)\n{\n\tint error;\n\tstruct dentry *dir = nd->path.dentry;\n\n\tif (!IS_POSIXACL(dir->d_inode))\n\t\tmode &= ~current_umask();\n\terror = security_path_mknod(&nd->path, path->dentry, mode, 0);\n\tif (error)\n\t\tgoto out_unlock;\n\terror = vfs_create(dir->d_inode, path->dentry, mode, nd);\nout_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(nd->path.dentry);\n\tnd->path.dentry = path->dentry;\n\tif (error)\n\t\treturn error;\n\t/* Don't check for write permission, don't truncate */\n\treturn may_open(&nd->path, 0, flag & ~O_TRUNC);\n}\n\n/*\n * Note that while the flag value (low two bits) for sys_open means:\n *\t00 - read-only\n *\t01 - write-only\n *\t10 - read-write\n *\t11 - special\n * it is changed into\n *\t00 - no permissions needed\n *\t01 - read-permission\n *\t10 - write-permission\n *\t11 - read-write\n * for the internal routines (ie open_namei()/follow_link() etc)\n * This is more logical, and also allows the 00 \"no perm needed\"\n * to be used for symlinks (where the permissions are checked\n * later).\n *\n*/\nstatic inline int open_to_namei_flags(int flag)\n{\n\tif ((flag+1) & O_ACCMODE)\n\t\tflag++;\n\treturn flag;\n}\n\nstatic int open_will_truncate(int flag, struct inode *inode)\n{\n\t/*\n\t * We'll never write to the fs underlying\n\t * a device file.\n\t */\n\tif (special_file(inode->i_mode))\n\t\treturn 0;\n\treturn (flag & O_TRUNC);\n}\n\n/*\n * Note that the low bits of the passed in \"open_flag\"\n * are not the same as in the local variable \"flag\". See\n * open_to_namei_flags() for more details.\n */\nstruct file *do_filp_open(int dfd, const char *pathname,\n\t\tint open_flag, int mode, int acc_mode)\n{\n\tstruct file *filp;\n\tstruct nameidata nd;\n\tint error;\n\tstruct path path, save;\n\tstruct dentry *dir;\n\tint count = 0;\n\tint will_truncate;\n\tint flag = open_to_namei_flags(open_flag);\n\n\t/*\n\t * O_SYNC is implemented as __O_SYNC|O_DSYNC.  As many places only\n\t * check for O_DSYNC if the need any syncing at all we enforce it's\n\t * always set instead of having to deal with possibly weird behaviour\n\t * for malicious applications setting only __O_SYNC.\n\t */\n\tif (open_flag & __O_SYNC)\n\t\topen_flag |= O_DSYNC;\n\n\tif (!acc_mode)\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flag);\n\n\t/* O_TRUNC implies we need access checks for write permissions */\n\tif (flag & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\n\t/* Allow the LSM permission hook to distinguish append \n\t   access from general write access. */\n\tif (flag & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\n\t/*\n\t * The simplest case - just a plain lookup.\n\t */\n\tif (!(flag & O_CREAT)) {\n\t\tfilp = get_empty_filp();\n\n\t\tif (filp == NULL)\n\t\t\treturn ERR_PTR(-ENFILE);\n\t\tnd.intent.open.file = filp;\n\t\tfilp->f_flags = open_flag;\n\t\tnd.intent.open.flags = flag;\n\t\tnd.intent.open.create_mode = 0;\n\t\terror = do_path_lookup(dfd, pathname,\n\t\t\t\t\tlookup_flags(flag)|LOOKUP_OPEN, &nd);\n\t\tif (IS_ERR(nd.intent.open.file)) {\n\t\t\tif (error == 0) {\n\t\t\t\terror = PTR_ERR(nd.intent.open.file);\n\t\t\t\tpath_put(&nd.path);\n\t\t\t}\n\t\t} else if (error)\n\t\t\trelease_open_intent(&nd);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t\tgoto ok;\n\t}\n\n\t/*\n\t * Create - we need to know the parent.\n\t */\n\terror = path_init(dfd, pathname, LOOKUP_PARENT, &nd);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\terror = path_walk(pathname, &nd);\n\tif (error) {\n\t\tif (nd.root.mnt)\n\t\t\tpath_put(&nd.root);\n\t\treturn ERR_PTR(error);\n\t}\n\tif (unlikely(!audit_dummy_context()))\n\t\taudit_inode(pathname, nd.path.dentry);\n\n\t/*\n\t * We have the parent and last component. First of all, check\n\t * that we are not asked to creat(2) an obvious directory - that\n\t * will not do.\n\t */\n\terror = -EISDIR;\n\tif (nd.last_type != LAST_NORM || nd.last.name[nd.last.len])\n\t\tgoto exit_parent;\n\n\terror = -ENFILE;\n\tfilp = get_empty_filp();\n\tif (filp == NULL)\n\t\tgoto exit_parent;\n\tnd.intent.open.file = filp;\n\tfilp->f_flags = open_flag;\n\tnd.intent.open.flags = flag;\n\tnd.intent.open.create_mode = mode;\n\tdir = nd.path.dentry;\n\tnd.flags &= ~LOOKUP_PARENT;\n\tnd.flags |= LOOKUP_CREATE | LOOKUP_OPEN;\n\tif (flag & O_EXCL)\n\t\tnd.flags |= LOOKUP_EXCL;\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tpath.dentry = lookup_hash(&nd);\n\tpath.mnt = nd.path.mnt;\n\ndo_last:\n\terror = PTR_ERR(path.dentry);\n\tif (IS_ERR(path.dentry)) {\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tgoto exit;\n\t}\n\n\tif (IS_ERR(nd.intent.open.file)) {\n\t\terror = PTR_ERR(nd.intent.open.file);\n\t\tgoto exit_mutex_unlock;\n\t}\n\n\t/* Negative dentry, just create the file */\n\tif (!path.dentry->d_inode) {\n\t\t/*\n\t\t * This write is needed to ensure that a\n\t\t * ro->rw transition does not occur between\n\t\t * the time when the file is created and when\n\t\t * a permanent write count is taken through\n\t\t * the 'struct file' in nameidata_to_filp().\n\t\t */\n\t\terror = mnt_want_write(nd.path.mnt);\n\t\tif (error)\n\t\t\tgoto exit_mutex_unlock;\n\t\terror = __open_namei_create(&nd, &path, flag, mode);\n\t\tif (error) {\n\t\t\tmnt_drop_write(nd.path.mnt);\n\t\t\tgoto exit;\n\t\t}\n\t\tfilp = nameidata_to_filp(&nd);\n\t\tmnt_drop_write(nd.path.mnt);\n\t\tif (nd.root.mnt)\n\t\t\tpath_put(&nd.root);\n\t\tif (!IS_ERR(filp)) {\n\t\t\terror = ima_path_check(&filp->f_path, filp->f_mode &\n\t\t\t\t       (MAY_READ | MAY_WRITE | MAY_EXEC));\n\t\t\tif (error) {\n\t\t\t\tfput(filp);\n\t\t\t\tfilp = ERR_PTR(error);\n\t\t\t}\n\t\t}\n\t\treturn filp;\n\t}\n\n\t/*\n\t * It already exists.\n\t */\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\taudit_inode(pathname, path.dentry);\n\n\terror = -EEXIST;\n\tif (flag & O_EXCL)\n\t\tgoto exit_dput;\n\n\tif (__follow_mount(&path)) {\n\t\terror = -ELOOP;\n\t\tif (flag & O_NOFOLLOW)\n\t\t\tgoto exit_dput;\n\t}\n\n\terror = -ENOENT;\n\tif (!path.dentry->d_inode)\n\t\tgoto exit_dput;\n\tif (path.dentry->d_inode->i_op->follow_link)\n\t\tgoto do_link;\n\n\tpath_to_nameidata(&path, &nd);\n\terror = -EISDIR;\n\tif (S_ISDIR(path.dentry->d_inode->i_mode))\n\t\tgoto exit;\nok:\n\t/*\n\t * Consider:\n\t * 1. may_open() truncates a file\n\t * 2. a rw->ro mount transition occurs\n\t * 3. nameidata_to_filp() fails due to\n\t *    the ro mount.\n\t * That would be inconsistent, and should\n\t * be avoided. Taking this mnt write here\n\t * ensures that (2) can not occur.\n\t */\n\twill_truncate = open_will_truncate(flag, nd.path.dentry->d_inode);\n\tif (will_truncate) {\n\t\terror = mnt_want_write(nd.path.mnt);\n\t\tif (error)\n\t\t\tgoto exit;\n\t}\n\terror = may_open(&nd.path, acc_mode, flag);\n\tif (error) {\n\t\tif (will_truncate)\n\t\t\tmnt_drop_write(nd.path.mnt);\n\t\tgoto exit;\n\t}\n\tfilp = nameidata_to_filp(&nd);\n\tif (!IS_ERR(filp)) {\n\t\terror = ima_path_check(&filp->f_path, filp->f_mode &\n\t\t\t       (MAY_READ | MAY_WRITE | MAY_EXEC));\n\t\tif (error) {\n\t\t\tfput(filp);\n\t\t\tfilp = ERR_PTR(error);\n\t\t}\n\t}\n\tif (!IS_ERR(filp)) {\n\t\tif (acc_mode & MAY_WRITE)\n\t\t\tvfs_dq_init(nd.path.dentry->d_inode);\n\n\t\tif (will_truncate) {\n\t\t\terror = handle_truncate(&nd.path);\n\t\t\tif (error) {\n\t\t\t\tfput(filp);\n\t\t\t\tfilp = ERR_PTR(error);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * It is now safe to drop the mnt write\n\t * because the filp has had a write taken\n\t * on its behalf.\n\t */\n\tif (will_truncate)\n\t\tmnt_drop_write(nd.path.mnt);\n\tif (nd.root.mnt)\n\t\tpath_put(&nd.root);\n\treturn filp;\n\nexit_mutex_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\nexit_dput:\n\tpath_put_conditional(&path, &nd);\nexit:\n\tif (!IS_ERR(nd.intent.open.file))\n\t\trelease_open_intent(&nd);\nexit_parent:\n\tif (nd.root.mnt)\n\t\tpath_put(&nd.root);\n\tpath_put(&nd.path);\n\treturn ERR_PTR(error);\n\ndo_link:\n\terror = -ELOOP;\n\tif (flag & O_NOFOLLOW)\n\t\tgoto exit_dput;\n\t/*\n\t * This is subtle. Instead of calling do_follow_link() we do the\n\t * thing by hands. The reason is that this way we have zero link_count\n\t * and path_walk() (called from ->follow_link) honoring LOOKUP_PARENT.\n\t * After that we have the parent and last component, i.e.\n\t * we are in the same situation as after the first path_walk().\n\t * Well, almost - if the last component is normal we get its copy\n\t * stored in nd->last.name and we will have to putname() it when we\n\t * are done. Procfs-like symlinks just set LAST_BIND.\n\t */\n\tnd.flags |= LOOKUP_PARENT;\n\terror = security_inode_follow_link(path.dentry, &nd);\n\tif (error)\n\t\tgoto exit_dput;\n\tsave = nd.path;\n\tpath_get(&save);\n\terror = __do_follow_link(&path, &nd);\n\tif (error == -ESTALE) {\n\t\t/* nd.path had been dropped */\n\t\tnd.path = save;\n\t\tpath_get(&nd.path);\n\t\tnd.flags |= LOOKUP_REVAL;\n\t\terror = __do_follow_link(&path, &nd);\n\t}\n\tpath_put(&save);\n\tpath_put(&path);\n\tif (error) {\n\t\t/* Does someone understand code flow here? Or it is only\n\t\t * me so stupid? Anathema to whoever designed this non-sense\n\t\t * with \"intent.open\".\n\t\t */\n\t\trelease_open_intent(&nd);\n\t\tif (nd.root.mnt)\n\t\t\tpath_put(&nd.root);\n\t\treturn ERR_PTR(error);\n\t}\n\tnd.flags &= ~LOOKUP_PARENT;\n\tif (nd.last_type == LAST_BIND)\n\t\tgoto ok;\n\terror = -EISDIR;\n\tif (nd.last_type != LAST_NORM)\n\t\tgoto exit;\n\tif (nd.last.name[nd.last.len]) {\n\t\t__putname(nd.last.name);\n\t\tgoto exit;\n\t}\n\terror = -ELOOP;\n\tif (count++==32) {\n\t\t__putname(nd.last.name);\n\t\tgoto exit;\n\t}\n\tdir = nd.path.dentry;\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tpath.dentry = lookup_hash(&nd);\n\tpath.mnt = nd.path.mnt;\n\t__putname(nd.last.name);\n\tgoto do_last;\n}\n\n/**\n * filp_open - open file and return file pointer\n *\n * @filename:\tpath to open\n * @flags:\topen flags as per the open(2) second argument\n * @mode:\tmode for the new file if O_CREAT is set, else ignored\n *\n * This is the helper to open a file from kernelspace if you really\n * have to.  But in generally you should not do this, so please move\n * along, nothing to see here..\n */\nstruct file *filp_open(const char *filename, int flags, int mode)\n{\n\treturn do_filp_open(AT_FDCWD, filename, flags, mode, 0);\n}\nEXPORT_SYMBOL(filp_open);\n\n/**\n * lookup_create - lookup a dentry, creating it if it doesn't exist\n * @nd: nameidata info\n * @is_dir: directory flag\n *\n * Simple function to lookup and return a dentry and create it\n * if it doesn't exist.  Is SMP-safe.\n *\n * Returns with nd->path.dentry->d_inode->i_mutex locked.\n */\nstruct dentry *lookup_create(struct nameidata *nd, int is_dir)\n{\n\tstruct dentry *dentry = ERR_PTR(-EEXIST);\n\n\tmutex_lock_nested(&nd->path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\t/*\n\t * Yucky last component or no last component at all?\n\t * (foo/., foo/.., /////)\n\t */\n\tif (nd->last_type != LAST_NORM)\n\t\tgoto fail;\n\tnd->flags &= ~LOOKUP_PARENT;\n\tnd->flags |= LOOKUP_CREATE | LOOKUP_EXCL;\n\tnd->intent.open.flags = O_EXCL;\n\n\t/*\n\t * Do the final lookup.\n\t */\n\tdentry = lookup_hash(nd);\n\tif (IS_ERR(dentry))\n\t\tgoto fail;\n\n\tif (dentry->d_inode)\n\t\tgoto eexist;\n\t/*\n\t * Special case - lookup gave negative, but... we had foo/bar/\n\t * From the vfs_mknod() POV we just have a negative dentry -\n\t * all is fine. Let's be bastards - you had / on the end, you've\n\t * been asking for (non-existent) directory. -ENOENT for you.\n\t */\n\tif (unlikely(!is_dir && nd->last.name[nd->last.len])) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-ENOENT);\n\t}\n\treturn dentry;\neexist:\n\tdput(dentry);\n\tdentry = ERR_PTR(-EEXIST);\nfail:\n\treturn dentry;\n}\nEXPORT_SYMBOL_GPL(lookup_create);\n\nint vfs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))\n\t\treturn -EPERM;\n\n\tif (!dir->i_op->mknod)\n\t\treturn -EPERM;\n\n\terror = devcgroup_inode_mknod(mode, dev);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_mknod(dir, dentry, mode, dev);\n\tif (error)\n\t\treturn error;\n\n\tvfs_dq_init(dir);\n\terror = dir->i_op->mknod(dir, dentry, mode, dev);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\n\nstatic int may_mknod(mode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\tcase 0: /* zero mode translates to S_IFREG */\n\t\treturn 0;\n\tcase S_IFDIR:\n\t\treturn -EPERM;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, int, mode,\n\t\tunsigned, dev)\n{\n\tint error;\n\tchar *tmp;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\tif (S_ISDIR(mode))\n\t\treturn -EPERM;\n\n\terror = user_path_parent(dfd, filename, &nd, &tmp);\n\tif (error)\n\t\treturn error;\n\n\tdentry = lookup_create(&nd, 0);\n\tif (IS_ERR(dentry)) {\n\t\terror = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tif (!IS_POSIXACL(nd.path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = may_mknod(mode);\n\tif (error)\n\t\tgoto out_dput;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_mknod(&nd.path, dentry, mode, dev);\n\tif (error)\n\t\tgoto out_drop_write;\n\tswitch (mode & S_IFMT) {\n\t\tcase 0: case S_IFREG:\n\t\t\terror = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);\n\t\t\tbreak;\n\t\tcase S_IFCHR: case S_IFBLK:\n\t\t\terror = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,\n\t\t\t\t\tnew_decode_dev(dev));\n\t\t\tbreak;\n\t\tcase S_IFIFO: case S_IFSOCK:\n\t\t\terror = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);\n\t\t\tbreak;\n\t}\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tpath_put(&nd.path);\n\tputname(tmp);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mknod, const char __user *, filename, int, mode, unsigned, dev)\n{\n\treturn sys_mknodat(AT_FDCWD, filename, mode, dev);\n}\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tvfs_dq_init(dir);\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, int, mode)\n{\n\tint error = 0;\n\tchar * tmp;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\terror = user_path_parent(dfd, pathname, &nd, &tmp);\n\tif (error)\n\t\tgoto out_err;\n\n\tdentry = lookup_create(&nd, 1);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\tif (!IS_POSIXACL(nd.path.dentry->d_inode))\n\t\tmode &= ~current_umask();\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_mkdir(&nd.path, dentry, mode);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tpath_put(&nd.path);\n\tputname(tmp);\nout_err:\n\treturn error;\n}\n\nSYSCALL_DEFINE2(mkdir, const char __user *, pathname, int, mode)\n{\n\treturn sys_mkdirat(AT_FDCWD, pathname, mode);\n}\n\n/*\n * We try to drop the dentry early: we should have\n * a usage count of 2 if we're the only user of this\n * dentry, and if that is true (possibly after pruning\n * the dcache), then we drop the dentry now.\n *\n * A low-level filesystem can, if it choses, legally\n * do a\n *\n *\tif (!d_unhashed(dentry))\n *\t\treturn -EBUSY;\n *\n * if it cannot handle the case of removing a directory\n * that is still in use by something else..\n */\nvoid dentry_unhash(struct dentry *dentry)\n{\n\tdget(dentry);\n\tshrink_dcache_parent(dentry);\n\tspin_lock(&dcache_lock);\n\tspin_lock(&dentry->d_lock);\n\tif (atomic_read(&dentry->d_count) == 2)\n\t\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dcache_lock);\n}\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tvfs_dq_init(dir);\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tdentry_unhash(dentry);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_rmdir(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = dir->i_op->rmdir(dir, dentry);\n\t\t\tif (!error)\n\t\t\t\tdentry->d_inode->i_flags |= S_DEAD;\n\t\t}\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error) {\n\t\td_delete(dentry);\n\t}\n\tdput(dentry);\n\n\treturn error;\n}\n\nstatic long do_rmdir(int dfd, const char __user *pathname)\n{\n\tint error = 0;\n\tchar * name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\terror = user_path_parent(dfd, pathname, &nd, &name);\n\tif (error)\n\t\treturn error;\n\n\tswitch(nd.last_type) {\n\tcase LAST_DOTDOT:\n\t\terror = -ENOTEMPTY;\n\t\tgoto exit1;\n\tcase LAST_DOT:\n\t\terror = -EINVAL;\n\t\tgoto exit1;\n\tcase LAST_ROOT:\n\t\terror = -EBUSY;\n\t\tgoto exit1;\n\t}\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto exit2;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto exit3;\n\terror = security_path_rmdir(&nd.path, dentry);\n\tif (error)\n\t\tgoto exit4;\n\terror = vfs_rmdir(nd.path.dentry->d_inode, dentry);\nexit4:\n\tmnt_drop_write(nd.path.mnt);\nexit3:\n\tdput(dentry);\nexit2:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\treturn error;\n}\n\nSYSCALL_DEFINE1(rmdir, const char __user *, pathname)\n{\n\treturn do_rmdir(AT_FDCWD, pathname);\n}\n\nint vfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tvfs_dq_init(dir);\n\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error)\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(dentry->d_inode);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}\n\n/*\n * Make sure that the actual truncation of the file will occur outside its\n * directory's i_mutex.  Truncate can take a long time if there is a lot of\n * writeout happening, and we don't want to prevent access to the directory\n * while waiting on the I/O.\n */\nstatic long do_unlinkat(int dfd, const char __user *pathname)\n{\n\tint error;\n\tchar *name;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\tstruct inode *inode = NULL;\n\n\terror = user_path_parent(dfd, pathname, &nd, &name);\n\tif (error)\n\t\treturn error;\n\n\terror = -EISDIR;\n\tif (nd.last_type != LAST_NORM)\n\t\tgoto exit1;\n\n\tnd.flags &= ~LOOKUP_PARENT;\n\n\tmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_hash(&nd);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\t\t/* Why not before? Because we want correct error value */\n\t\tif (nd.last.name[nd.last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (inode)\n\t\t\tatomic_inc(&inode->i_count);\n\t\terror = mnt_want_write(nd.path.mnt);\n\t\tif (error)\n\t\t\tgoto exit2;\n\t\terror = security_path_unlink(&nd.path, dentry);\n\t\tif (error)\n\t\t\tgoto exit3;\n\t\terror = vfs_unlink(nd.path.dentry->d_inode, dentry);\nexit3:\n\t\tmnt_drop_write(nd.path.mnt);\n\texit2:\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tif (inode)\n\t\tiput(inode);\t/* truncate the inode here */\nexit1:\n\tpath_put(&nd.path);\n\tputname(name);\n\treturn error;\n\nslashes:\n\terror = !dentry->d_inode ? -ENOENT :\n\t\tS_ISDIR(dentry->d_inode->i_mode) ? -EISDIR : -ENOTDIR;\n\tgoto exit2;\n}\n\nSYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)\n{\n\tif ((flag & ~AT_REMOVEDIR) != 0)\n\t\treturn -EINVAL;\n\n\tif (flag & AT_REMOVEDIR)\n\t\treturn do_rmdir(dfd, pathname);\n\n\treturn do_unlinkat(dfd, pathname);\n}\n\nSYSCALL_DEFINE1(unlink, const char __user *, pathname)\n{\n\treturn do_unlinkat(AT_FDCWD, pathname);\n}\n\nint vfs_symlink(struct inode *dir, struct dentry *dentry, const char *oldname)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->symlink)\n\t\treturn -EPERM;\n\n\terror = security_inode_symlink(dir, dentry, oldname);\n\tif (error)\n\t\treturn error;\n\n\tvfs_dq_init(dir);\n\terror = dir->i_op->symlink(dir, dentry, oldname);\n\tif (!error)\n\t\tfsnotify_create(dir, dentry);\n\treturn error;\n}\n\nSYSCALL_DEFINE3(symlinkat, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\tint error;\n\tchar *from;\n\tchar *to;\n\tstruct dentry *dentry;\n\tstruct nameidata nd;\n\n\tfrom = getname(oldname);\n\tif (IS_ERR(from))\n\t\treturn PTR_ERR(from);\n\n\terror = user_path_parent(newdfd, newname, &nd, &to);\n\tif (error)\n\t\tgoto out_putname;\n\n\tdentry = lookup_create(&nd, 0);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_symlink(&nd.path, dentry, from);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = vfs_symlink(nd.path.dentry->d_inode, dentry, from);\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\n\tpath_put(&nd.path);\n\tputname(to);\nout_putname:\n\tputname(from);\n\treturn error;\n}\n\nSYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_symlinkat(oldname, AT_FDCWD, newname);\n}\n\nint vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A link to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\tif (!dir->i_op->link)\n\t\treturn -EPERM;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EPERM;\n\n\terror = security_inode_link(old_dentry, dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tmutex_lock(&inode->i_mutex);\n\tvfs_dq_init(dir);\n\terror = dir->i_op->link(old_dentry, dir, new_dentry);\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_link(dir, inode, new_dentry);\n\treturn error;\n}\n\n/*\n * Hardlinks are often used in delicate situations.  We avoid\n * security-related surprises by not following symlinks on the\n * newname.  --KAB\n *\n * We don't follow them on the oldname either to be compatible\n * with linux 2.0, and to avoid hard-linking to directories\n * and other special files.  --ADM\n */\nSYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname, int, flags)\n{\n\tstruct dentry *new_dentry;\n\tstruct nameidata nd;\n\tstruct path old_path;\n\tint error;\n\tchar *to;\n\n\tif ((flags & ~AT_SYMLINK_FOLLOW) != 0)\n\t\treturn -EINVAL;\n\n\terror = user_path_at(olddfd, oldname,\n\t\t\t     flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,\n\t\t\t     &old_path);\n\tif (error)\n\t\treturn error;\n\n\terror = user_path_parent(newdfd, newname, &nd, &to);\n\tif (error)\n\t\tgoto out;\n\terror = -EXDEV;\n\tif (old_path.mnt != nd.path.mnt)\n\t\tgoto out_release;\n\tnew_dentry = lookup_create(&nd, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto out_unlock;\n\terror = mnt_want_write(nd.path.mnt);\n\tif (error)\n\t\tgoto out_dput;\n\terror = security_path_link(old_path.dentry, &nd.path, new_dentry);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = vfs_link(old_path.dentry, nd.path.dentry->d_inode, new_dentry);\nout_drop_write:\n\tmnt_drop_write(nd.path.mnt);\nout_dput:\n\tdput(new_dentry);\nout_unlock:\n\tmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\nout_release:\n\tpath_put(&nd.path);\n\tputname(to);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE2(link, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n\n/*\n * The worst of all namespace operations - renaming directory. \"Perverted\"\n * doesn't even start to describe it. Somebody in UCB had a heck of a trip...\n * Problems:\n *\ta) we can get into loop creation. Check is done in is_subdir().\n *\tb) race potential - two innocent renames can create a loop together.\n *\t   That's where 4.4 screws up. Current fix: serialization on\n *\t   sb->s_vfs_rename_mutex. We might be more accurate, but that's another\n *\t   story.\n *\tc) we have to lock _three_ objects - parents and victim (if it exists).\n *\t   And that - after we got ->i_mutex on parents (until then we don't know\n *\t   whether the target exists).  Solution: try to be smart with locking\n *\t   order for inodes.  We rely on the fact that tree topology may change\n *\t   only under ->s_vfs_rename_mutex _and_ that parent of the object we\n *\t   move will be locked.  Thus we can rank directories by the tree\n *\t   (ancestors first) and rank all non-directories after them.\n *\t   That works since everybody except rename does \"lock parent, lookup,\n *\t   lock child\" and rename is under ->s_vfs_rename_mutex.\n *\t   HOWEVER, it relies on the assumption that any object with ->lookup()\n *\t   has no more than 1 dentry.  If \"hybrid\" objects will ever appear,\n *\t   we'd better make sure that there's no link(2) for them.\n *\td) some filesystems don't support opened-but-unlinked directories,\n *\t   either because of layout or because they are not ready to deal with\n *\t   all cases correctly. The latter will be fixed (taking this sort of\n *\t   stuff into VFS), but the former is not going away. Solution: the same\n *\t   trick as in rmdir().\n *\te) conversion from fhandle to dentry may come in the wrong moment - when\n *\t   we are removing the target. Solution: we will have to grab ->i_mutex\n *\t   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on\n *\t   ->i_mutex on parents, which works but leads to some truely excessive\n *\t   locking].\n */\nstatic int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint error = 0;\n\tstruct inode *target;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\terror = inode_permission(old_dentry->d_inode, MAY_WRITE);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\ttarget = new_dentry->d_inode;\n\tif (target) {\n\t\tmutex_lock(&target->i_mutex);\n\t\tdentry_unhash(new_dentry);\n\t}\n\tif (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))\n\t\terror = -EBUSY;\n\telse \n\t\terror = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);\n\tif (target) {\n\t\tif (!error)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tmutex_unlock(&target->i_mutex);\n\t\tif (d_unhashed(new_dentry))\n\t\t\td_rehash(new_dentry);\n\t\tdput(new_dentry);\n\t}\n\tif (!error)\n\t\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))\n\t\t\td_move(old_dentry,new_dentry);\n\treturn error;\n}\n\nstatic int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t    struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct inode *target;\n\tint error;\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tdget(new_dentry);\n\ttarget = new_dentry->d_inode;\n\tif (target)\n\t\tmutex_lock(&target->i_mutex);\n\tif (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))\n\t\terror = -EBUSY;\n\telse\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);\n\tif (!error) {\n\t\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))\n\t\t\td_move(old_dentry, new_dentry);\n\t}\n\tif (target)\n\t\tmutex_unlock(&target->i_mutex);\n\tdput(new_dentry);\n\treturn error;\n}\n\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint error;\n\tint is_dir = S_ISDIR(old_dentry->d_inode->i_mode);\n\tconst char *old_name;\n\n\tif (old_dentry->d_inode == new_dentry->d_inode)\n \t\treturn 0;\n \n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!new_dentry->d_inode)\n\t\terror = may_create(new_dir, new_dentry);\n\telse\n\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\tvfs_dq_init(old_dir);\n\tvfs_dq_init(new_dir);\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\n\tif (is_dir)\n\t\terror = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);\n\telse\n\t\terror = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);\n\tif (!error) {\n\t\tconst char *new_name = old_dentry->d_name.name;\n\t\tfsnotify_move(old_dir, new_dir, old_name, new_name, is_dir,\n\t\t\t      new_dentry->d_inode, old_dentry);\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}\n\nSYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,\n\t\tint, newdfd, const char __user *, newname)\n{\n\tstruct dentry *old_dir, *new_dir;\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct nameidata oldnd, newnd;\n\tchar *from;\n\tchar *to;\n\tint error;\n\n\terror = user_path_parent(olddfd, oldname, &oldnd, &from);\n\tif (error)\n\t\tgoto exit;\n\n\terror = user_path_parent(newdfd, newname, &newnd, &to);\n\tif (error)\n\t\tgoto exit1;\n\n\terror = -EXDEV;\n\tif (oldnd.path.mnt != newnd.path.mnt)\n\t\tgoto exit2;\n\n\told_dir = oldnd.path.dentry;\n\terror = -EBUSY;\n\tif (oldnd.last_type != LAST_NORM)\n\t\tgoto exit2;\n\n\tnew_dir = newnd.path.dentry;\n\tif (newnd.last_type != LAST_NORM)\n\t\tgoto exit2;\n\n\toldnd.flags &= ~LOOKUP_PARENT;\n\tnewnd.flags &= ~LOOKUP_PARENT;\n\tnewnd.flags |= LOOKUP_RENAME_TARGET;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\n\told_dentry = lookup_hash(&oldnd);\n\terror = PTR_ERR(old_dentry);\n\tif (IS_ERR(old_dentry))\n\t\tgoto exit3;\n\t/* source must exist */\n\terror = -ENOENT;\n\tif (!old_dentry->d_inode)\n\t\tgoto exit4;\n\t/* unless the source is a directory trailing slashes give -ENOTDIR */\n\tif (!S_ISDIR(old_dentry->d_inode->i_mode)) {\n\t\terror = -ENOTDIR;\n\t\tif (oldnd.last.name[oldnd.last.len])\n\t\t\tgoto exit4;\n\t\tif (newnd.last.name[newnd.last.len])\n\t\t\tgoto exit4;\n\t}\n\t/* source should not be ancestor of target */\n\terror = -EINVAL;\n\tif (old_dentry == trap)\n\t\tgoto exit4;\n\tnew_dentry = lookup_hash(&newnd);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto exit4;\n\t/* target should not be an ancestor of source */\n\terror = -ENOTEMPTY;\n\tif (new_dentry == trap)\n\t\tgoto exit5;\n\n\terror = mnt_want_write(oldnd.path.mnt);\n\tif (error)\n\t\tgoto exit5;\n\terror = security_path_rename(&oldnd.path, old_dentry,\n\t\t\t\t     &newnd.path, new_dentry);\n\tif (error)\n\t\tgoto exit6;\n\terror = vfs_rename(old_dir->d_inode, old_dentry,\n\t\t\t\t   new_dir->d_inode, new_dentry);\nexit6:\n\tmnt_drop_write(oldnd.path.mnt);\nexit5:\n\tdput(new_dentry);\nexit4:\n\tdput(old_dentry);\nexit3:\n\tunlock_rename(new_dir, old_dir);\nexit2:\n\tpath_put(&newnd.path);\n\tputname(to);\nexit1:\n\tpath_put(&oldnd.path);\n\tputname(from);\nexit:\n\treturn error;\n}\n\nSYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n\treturn sys_renameat(AT_FDCWD, oldname, AT_FDCWD, newname);\n}\n\nint vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)\n{\n\tint len;\n\n\tlen = PTR_ERR(link);\n\tif (IS_ERR(link))\n\t\tgoto out;\n\n\tlen = strlen(link);\n\tif (len > (unsigned) buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, link, len))\n\t\tlen = -EFAULT;\nout:\n\treturn len;\n}\n\n/*\n * A helper for ->readlink().  This should be used *ONLY* for symlinks that\n * have ->follow_link() touching nd only in nd_set_link().  Using (or not\n * using) it for any given inode is up to filesystem.\n */\nint generic_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct nameidata nd;\n\tvoid *cookie;\n\tint res;\n\n\tnd.depth = 0;\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, &nd);\n\tif (IS_ERR(cookie))\n\t\treturn PTR_ERR(cookie);\n\n\tres = vfs_readlink(dentry, buffer, buflen, nd_get_link(&nd));\n\tif (dentry->d_inode->i_op->put_link)\n\t\tdentry->d_inode->i_op->put_link(dentry, &nd, cookie);\n\treturn res;\n}\n\nint vfs_follow_link(struct nameidata *nd, const char *link)\n{\n\treturn __vfs_follow_link(nd, link);\n}\n\n/* get the link contents into pagecache */\nstatic char *page_getlink(struct dentry * dentry, struct page **ppage)\n{\n\tchar *kaddr;\n\tstruct page *page;\n\tstruct address_space *mapping = dentry->d_inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\treturn (char*)page;\n\t*ppage = page;\n\tkaddr = kmap(page);\n\tnd_terminate_link(kaddr, dentry->d_inode->i_size, PAGE_SIZE - 1);\n\treturn kaddr;\n}\n\nint page_readlink(struct dentry *dentry, char __user *buffer, int buflen)\n{\n\tstruct page *page = NULL;\n\tchar *s = page_getlink(dentry, &page);\n\tint res = vfs_readlink(dentry,buffer,buflen,s);\n\tif (page) {\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t}\n\treturn res;\n}\n\nvoid *page_follow_link_light(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct page *page = NULL;\n\tnd_set_link(nd, page_getlink(dentry, &page));\n\treturn page;\n}\n\nvoid page_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)\n{\n\tstruct page *page = cookie;\n\n\tif (page) {\n\t\tkunmap(page);\n\t\tpage_cache_release(page);\n\t}\n}\n\n/*\n * The nofs argument instructs pagecache_write_begin to pass AOP_FLAG_NOFS\n */\nint __page_symlink(struct inode *inode, const char *symname, int len, int nofs)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\tchar *kaddr;\n\tunsigned int flags = AOP_FLAG_UNINTERRUPTIBLE;\n\tif (nofs)\n\t\tflags |= AOP_FLAG_NOFS;\n\nretry:\n\terr = pagecache_write_begin(NULL, mapping, 0, len-1,\n\t\t\t\tflags, &page, &fsdata);\n\tif (err)\n\t\tgoto fail;\n\n\tkaddr = kmap_atomic(page, KM_USER0);\n\tmemcpy(kaddr, symname, len-1);\n\tkunmap_atomic(kaddr, KM_USER0);\n\n\terr = pagecache_write_end(NULL, mapping, 0, len-1, len-1,\n\t\t\t\t\t\t\tpage, fsdata);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err < len-1)\n\t\tgoto retry;\n\n\tmark_inode_dirty(inode);\n\treturn 0;\nfail:\n\treturn err;\n}\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}\n\nconst struct inode_operations page_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n};\n\nEXPORT_SYMBOL(user_path_at);\nEXPORT_SYMBOL(follow_down);\nEXPORT_SYMBOL(follow_up);\nEXPORT_SYMBOL(get_write_access); /* binfmt_aout */\nEXPORT_SYMBOL(getname);\nEXPORT_SYMBOL(lock_rename);\nEXPORT_SYMBOL(lookup_one_len);\nEXPORT_SYMBOL(page_follow_link_light);\nEXPORT_SYMBOL(page_put_link);\nEXPORT_SYMBOL(page_readlink);\nEXPORT_SYMBOL(__page_symlink);\nEXPORT_SYMBOL(page_symlink);\nEXPORT_SYMBOL(page_symlink_inode_operations);\nEXPORT_SYMBOL(path_lookup);\nEXPORT_SYMBOL(kern_path);\nEXPORT_SYMBOL(vfs_path_lookup);\nEXPORT_SYMBOL(inode_permission);\nEXPORT_SYMBOL(file_permission);\nEXPORT_SYMBOL(unlock_rename);\nEXPORT_SYMBOL(vfs_create);\nEXPORT_SYMBOL(vfs_follow_link);\nEXPORT_SYMBOL(vfs_link);\nEXPORT_SYMBOL(vfs_mkdir);\nEXPORT_SYMBOL(vfs_mknod);\nEXPORT_SYMBOL(generic_permission);\nEXPORT_SYMBOL(vfs_readlink);\nEXPORT_SYMBOL(vfs_rename);\nEXPORT_SYMBOL(vfs_rmdir);\nEXPORT_SYMBOL(vfs_symlink);\nEXPORT_SYMBOL(vfs_unlink);\nEXPORT_SYMBOL(dentry_unhash);\nEXPORT_SYMBOL(generic_readlink);\n", "/*\n *  linux/fs/proc/base.c\n *\n *  Copyright (C) 1991, 1992 Linus Torvalds\n *\n *  proc base directory handling functions\n *\n *  1999, Al Viro. Rewritten. Now it covers the whole per-process part.\n *  Instead of using magical inumbers to determine the kind of object\n *  we allocate and fill in-core inodes upon lookup. They don't even\n *  go into icache. We cache the reference to task_struct upon lookup too.\n *  Eventually it should become a filesystem in its own. We don't use the\n *  rest of procfs anymore.\n *\n *\n *  Changelog:\n *  17-Jan-2005\n *  Allan Bezerra\n *  Bruna Moreira <bruna.moreira@indt.org.br>\n *  Edjard Mota <edjard.mota@indt.org.br>\n *  Ilias Biris <ilias.biris@indt.org.br>\n *  Mauricio Lin <mauricio.lin@indt.org.br>\n *\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *\n *  A new process specific entry (smaps) included in /proc. It shows the\n *  size of rss for each memory area. The maps entry lacks information\n *  about physical memory size (rss) for each mapped file, i.e.,\n *  rss information for executables and library files.\n *  This additional information is useful for any tools that need to know\n *  about physical memory consumption for a process specific library.\n *\n *  Changelog:\n *  21-Feb-2005\n *  Embedded Linux Lab - 10LE Instituto Nokia de Tecnologia - INdT\n *  Pud inclusion in the page table walking.\n *\n *  ChangeLog:\n *  10-Mar-2005\n *  10LE Instituto Nokia de Tecnologia - INdT:\n *  A better way to walks through the page table as suggested by Hugh Dickins.\n *\n *  Simo Piiroinen <simo.piiroinen@nokia.com>:\n *  Smaps information related to shared, private, clean and dirty pages.\n *\n *  Paul Mundt <paul.mundt@nokia.com>:\n *  Overall revision about smaps.\n */\n\n#include <asm/uaccess.h>\n\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/namei.h>\n#include <linux/mnt_namespace.h>\n#include <linux/mm.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/stacktrace.h>\n#include <linux/resource.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/tracehook.h>\n#include <linux/cgroup.h>\n#include <linux/cpuset.h>\n#include <linux/audit.h>\n#include <linux/poll.h>\n#include <linux/nsproxy.h>\n#include <linux/oom.h>\n#include <linux/elf.h>\n#include <linux/pid_namespace.h>\n#include <linux/fs_struct.h>\n#include \"internal.h\"\n\n/* NOTE:\n *\tImplementing inode permission operations in /proc is almost\n *\tcertainly an error.  Permission checks need to happen during\n *\teach system call not at open time.  The reason is that most of\n *\twhat we wish to check for permissions in /proc varies at runtime.\n *\n *\tThe classic example of a problem is opening file descriptors\n *\tin /proc for a task before it execs a suid executable.\n */\n\nstruct pid_entry {\n\tchar *name;\n\tint len;\n\tmode_t mode;\n\tconst struct inode_operations *iop;\n\tconst struct file_operations *fop;\n\tunion proc_op op;\n};\n\n#define NOD(NAME, MODE, IOP, FOP, OP) {\t\t\t\\\n\t.name = (NAME),\t\t\t\t\t\\\n\t.len  = sizeof(NAME) - 1,\t\t\t\\\n\t.mode = MODE,\t\t\t\t\t\\\n\t.iop  = IOP,\t\t\t\t\t\\\n\t.fop  = FOP,\t\t\t\t\t\\\n\t.op   = OP,\t\t\t\t\t\\\n}\n\n#define DIR(NAME, MODE, iops, fops)\t\\\n\tNOD(NAME, (S_IFDIR|(MODE)), &iops, &fops, {} )\n#define LNK(NAME, get_link)\t\t\t\t\t\\\n\tNOD(NAME, (S_IFLNK|S_IRWXUGO),\t\t\t\t\\\n\t\t&proc_pid_link_inode_operations, NULL,\t\t\\\n\t\t{ .proc_get_link = get_link } )\n#define REG(NAME, MODE, fops)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), NULL, &fops, {})\n#define INF(NAME, MODE, read)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_info_file_operations,\t\\\n\t\t{ .proc_read = read } )\n#define ONE(NAME, MODE, show)\t\t\t\t\\\n\tNOD(NAME, (S_IFREG|(MODE)), \t\t\t\\\n\t\tNULL, &proc_single_file_operations,\t\\\n\t\t{ .proc_show = show } )\n\n/*\n * Count the number of hardlinks for the pid_entry table, excluding the .\n * and .. links.\n */\nstatic unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}\n\nstatic int get_fs_path(struct task_struct *task, struct path *path, bool root)\n{\n\tstruct fs_struct *fs;\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tfs = task->fs;\n\tif (fs) {\n\t\tread_lock(&fs->lock);\n\t\t*path = root ? fs->root : fs->pwd;\n\t\tpath_get(path);\n\t\tread_unlock(&fs->lock);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}\n\nstatic int get_nr_threads(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\tint count = 0;\n\n\tif (lock_task_sighand(tsk, &flags)) {\n\t\tcount = atomic_read(&tsk->signal->count);\n\t\tunlock_task_sighand(tsk, &flags);\n\t}\n\treturn count;\n}\n\nstatic int proc_cwd_link(struct inode *inode, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_fs_path(task, path, 0);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\nstatic int proc_root_link(struct inode *inode, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_fs_path(task, path, 1);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}\n\n/*\n * Return zero if current may access user memory in @task, -error if not.\n */\nstatic int check_mem_permission(struct task_struct *task)\n{\n\t/*\n\t * A task can always look at itself, in case it chooses\n\t * to use system calls instead of load instructions.\n\t */\n\tif (task == current)\n\t\treturn 0;\n\n\t/*\n\t * If current is actively ptrace'ing, and would also be\n\t * permitted to freshly attach with ptrace now, permit it.\n\t */\n\tif (task_is_stopped_or_traced(task)) {\n\t\tint match;\n\t\trcu_read_lock();\n\t\tmatch = (tracehook_tracer_task(task) == current);\n\t\trcu_read_unlock();\n\t\tif (match && ptrace_may_access(task, PTRACE_MODE_ATTACH))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Noone else is allowed.\n\t */\n\treturn -EPERM;\n}\n\nstruct mm_struct *mm_for_maps(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\tif (mutex_lock_killable(&task->cred_guard_mutex))\n\t\treturn NULL;\n\n\tmm = get_task_mm(task);\n\tif (mm && mm != current->mm &&\n\t\t\t!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tmmput(mm);\n\t\tmm = NULL;\n\t}\n\tmutex_unlock(&task->cred_guard_mutex);\n\n\treturn mm;\n}\n\nstatic int proc_pid_cmdline(struct task_struct *task, char * buffer)\n{\n\tint res = 0;\n\tunsigned int len;\n\tstruct mm_struct *mm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out;\n\tif (!mm->arg_end)\n\t\tgoto out_mm;\t/* Shh! No looking before we're done */\n\n \tlen = mm->arg_end - mm->arg_start;\n \n\tif (len > PAGE_SIZE)\n\t\tlen = PAGE_SIZE;\n \n\tres = access_process_vm(task, mm->arg_start, buffer, len, 0);\n\n\t// If the nul at the end of args has been overwritten, then\n\t// assume application is using setproctitle(3).\n\tif (res > 0 && buffer[res-1] != '\\0' && len < PAGE_SIZE) {\n\t\tlen = strnlen(buffer, res);\n\t\tif (len < res) {\n\t\t    res = len;\n\t\t} else {\n\t\t\tlen = mm->env_end - mm->env_start;\n\t\t\tif (len > PAGE_SIZE - res)\n\t\t\t\tlen = PAGE_SIZE - res;\n\t\t\tres += access_process_vm(task, mm->env_start, buffer+res, len, 0);\n\t\t\tres = strnlen(buffer, res);\n\t\t}\n\t}\nout_mm:\n\tmmput(mm);\nout:\n\treturn res;\n}\n\nstatic int proc_pid_auxv(struct task_struct *task, char *buffer)\n{\n\tint res = 0;\n\tstruct mm_struct *mm = get_task_mm(task);\n\tif (mm) {\n\t\tunsigned int nwords = 0;\n\t\tdo {\n\t\t\tnwords += 2;\n\t\t} while (mm->saved_auxv[nwords - 2] != 0); /* AT_NULL */\n\t\tres = nwords * sizeof(mm->saved_auxv[0]);\n\t\tif (res > PAGE_SIZE)\n\t\t\tres = PAGE_SIZE;\n\t\tmemcpy(buffer, mm->saved_auxv, res);\n\t\tmmput(mm);\n\t}\n\treturn res;\n}\n\n\n#ifdef CONFIG_KALLSYMS\n/*\n * Provides a wchan file via kallsyms in a proper one-value-per-file format.\n * Returns the resolved symbol.  If that fails, simply return the address.\n */\nstatic int proc_pid_wchan(struct task_struct *task, char *buffer)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\n\twchan = get_wchan(task);\n\n\tif (lookup_symbol_name(wchan, symname) < 0)\n\t\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn sprintf(buffer, \"%lu\", wchan);\n\telse\n\t\treturn sprintf(buffer, \"%s\", symname);\n}\n#endif /* CONFIG_KALLSYMS */\n\n#ifdef CONFIG_STACKTRACE\n\n#define MAX_STACK_TRACE_DEPTH\t64\n\nstatic int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tstruct stack_trace trace;\n\tunsigned long *entries;\n\tint i;\n\n\tentries = kmalloc(MAX_STACK_TRACE_DEPTH * sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= MAX_STACK_TRACE_DEPTH;\n\ttrace.entries\t\t= entries;\n\ttrace.skip\t\t= 0;\n\tsave_stack_trace_tsk(task, &trace);\n\n\tfor (i = 0; i < trace.nr_entries; i++) {\n\t\tseq_printf(m, \"[<%p>] %pS\\n\",\n\t\t\t   (void *)entries[i], (void *)entries[i]);\n\t}\n\tkfree(entries);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n/*\n * Provides /proc/PID/schedstat\n */\nstatic int proc_pid_schedstat(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer, \"%llu %llu %lu\\n\",\n\t\t\t(unsigned long long)task->se.sum_exec_runtime,\n\t\t\t(unsigned long long)task->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}\n#endif\n\n#ifdef CONFIG_LATENCYTOP\nstatic int lstats_show_proc(struct seq_file *m, void *v)\n{\n\tint i;\n\tstruct inode *inode = m->private;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tif (task->latency_record[i].backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %li %li \",\n\t\t\t\ttask->latency_record[i].count,\n\t\t\t\ttask->latency_record[i].time,\n\t\t\t\ttask->latency_record[i].max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tchar sym[KSYM_SYMBOL_LEN];\n\t\t\t\tchar *c;\n\t\t\t\tif (!task->latency_record[i].backtrace[q])\n\t\t\t\t\tbreak;\n\t\t\t\tif (task->latency_record[i].backtrace[q] == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tsprint_symbol(sym, task->latency_record[i].backtrace[q]);\n\t\t\t\tc = strchr(sym, '+');\n\t\t\t\tif (c)\n\t\t\t\t\t*c = 0;\n\t\t\t\tseq_printf(m, \"%s \", sym);\n\t\t\t}\n\t\t\tseq_printf(m, \"\\n\");\n\t\t}\n\n\t}\n\tput_task_struct(task);\n\treturn 0;\n}\n\nstatic int lstats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lstats_show_proc, inode);\n}\n\nstatic ssize_t lstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tclear_all_latency_tracing(task);\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_lstats_operations = {\n\t.open\t\t= lstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= lstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\n/* The badness from the OOM killer */\nunsigned long badness(struct task_struct *p, unsigned long uptime);\nstatic int proc_oom_score(struct task_struct *task, char *buffer)\n{\n\tunsigned long points;\n\tstruct timespec uptime;\n\n\tdo_posix_clock_monotonic_gettime(&uptime);\n\tread_lock(&tasklist_lock);\n\tpoints = badness(task->group_leader, uptime.tv_sec);\n\tread_unlock(&tasklist_lock);\n\treturn sprintf(buffer, \"%lu\\n\", points);\n}\n\nstruct limit_names {\n\tchar *name;\n\tchar *unit;\n};\n\nstatic const struct limit_names lnames[RLIM_NLIMITS] = {\n\t[RLIMIT_CPU] = {\"Max cpu time\", \"seconds\"},\n\t[RLIMIT_FSIZE] = {\"Max file size\", \"bytes\"},\n\t[RLIMIT_DATA] = {\"Max data size\", \"bytes\"},\n\t[RLIMIT_STACK] = {\"Max stack size\", \"bytes\"},\n\t[RLIMIT_CORE] = {\"Max core file size\", \"bytes\"},\n\t[RLIMIT_RSS] = {\"Max resident set\", \"bytes\"},\n\t[RLIMIT_NPROC] = {\"Max processes\", \"processes\"},\n\t[RLIMIT_NOFILE] = {\"Max open files\", \"files\"},\n\t[RLIMIT_MEMLOCK] = {\"Max locked memory\", \"bytes\"},\n\t[RLIMIT_AS] = {\"Max address space\", \"bytes\"},\n\t[RLIMIT_LOCKS] = {\"Max file locks\", \"locks\"},\n\t[RLIMIT_SIGPENDING] = {\"Max pending signals\", \"signals\"},\n\t[RLIMIT_MSGQUEUE] = {\"Max msgqueue size\", \"bytes\"},\n\t[RLIMIT_NICE] = {\"Max nice priority\", NULL},\n\t[RLIMIT_RTPRIO] = {\"Max realtime priority\", NULL},\n\t[RLIMIT_RTTIME] = {\"Max realtime timeout\", \"us\"},\n};\n\n/* Display limits for a process */\nstatic int proc_pid_limits(struct task_struct *task, char *buffer)\n{\n\tunsigned int i;\n\tint count = 0;\n\tunsigned long flags;\n\tchar *bufptr = buffer;\n\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn 0;\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\n\t/*\n\t * print the file header\n\t */\n\tcount += sprintf(&bufptr[count], \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-20lu \",\n\t\t\t\t\t rlim[i].rlim_max);\n\n\t\tif (lnames[i].unit)\n\t\t\tcount += sprintf(&bufptr[count], \"%-10s\\n\",\n\t\t\t\t\t lnames[i].unit);\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"\\n\");\n\t}\n\n\treturn count;\n}\n\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\nstatic int proc_pid_syscall(struct task_struct *task, char *buffer)\n{\n\tlong nr;\n\tunsigned long args[6], sp, pc;\n\n\tif (task_current_syscall(task, &nr, args, 6, &sp, &pc))\n\t\treturn sprintf(buffer, \"running\\n\");\n\n\tif (nr < 0)\n\t\treturn sprintf(buffer, \"%ld 0x%lx 0x%lx\\n\", nr, sp, pc);\n\n\treturn sprintf(buffer,\n\t\t       \"%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t       nr,\n\t\t       args[0], args[1], args[2], args[3], args[4], args[5],\n\t\t       sp, pc);\n}\n#endif /* CONFIG_HAVE_ARCH_TRACEHOOK */\n\n/************************************************************************/\n/*                       Here the fs part begins                        */\n/************************************************************************/\n\n/* permission checks */\nstatic int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}\n\nstatic int proc_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (!error)\n\t\terror = inode_setattr(inode, attr);\n\treturn error;\n}\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      const struct seq_operations *op)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (task) {\n\t\trcu_read_lock();\n\t\tnsp = task_nsproxy(task);\n\t\tif (nsp) {\n\t\t\tns = nsp->mnt_ns;\n\t\t\tif (ns)\n\t\t\t\tget_mnt_ns(ns);\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (ns && get_fs_path(task, &root, 1) == 0)\n\t\t\tret = 0;\n\t\tput_task_struct(task);\n\t}\n\n\tif (!ns)\n\t\tgoto err;\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->m.private = p;\n\tp->ns = ns;\n\tp->root = root;\n\tp->event = ns->event;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}\n\nstatic int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release(inode, file);\n}\n\nstatic unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tstruct mnt_namespace *ns = p->ns;\n\tunsigned res = POLLIN | POLLRDNORM;\n\n\tpoll_wait(file, &ns->poll, wait);\n\n\tspin_lock(&vfsmount_lock);\n\tif (p->event != ns->event) {\n\t\tp->event = ns->event;\n\t\tres |= POLLERR | POLLPRI;\n\t}\n\tspin_unlock(&vfsmount_lock);\n\n\treturn res;\n}\n\nstatic int mounts_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mounts_op);\n}\n\nstatic const struct file_operations proc_mounts_operations = {\n\t.open\t\t= mounts_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nstatic int mountinfo_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mountinfo_op);\n}\n\nstatic const struct file_operations proc_mountinfo_operations = {\n\t.open\t\t= mountinfo_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n\t.poll\t\t= mounts_poll,\n};\n\nstatic int mountstats_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, &mountstats_op);\n}\n\nstatic const struct file_operations proc_mountstats_operations = {\n\t.open\t\t= mountstats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= mounts_release,\n};\n\n#define PROC_BLOCK_SIZE\t(3*1024)\t\t/* 4K page size but our output routines use some slack for overruns */\n\nstatic ssize_t proc_info_read(struct file * file, char __user * buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tunsigned long page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (count > PROC_BLOCK_SIZE)\n\t\tcount = PROC_BLOCK_SIZE;\n\n\tlength = -ENOMEM;\n\tif (!(page = __get_free_page(GFP_TEMPORARY)))\n\t\tgoto out;\n\n\tlength = PROC_I(inode)->op.proc_read(task, (char*)page);\n\n\tif (length >= 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, (char *)page, length);\n\tfree_page(page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_info_file_operations = {\n\t.read\t\t= proc_info_read,\n};\n\nstatic int proc_single_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tint ret;\n\n\tns = inode->i_sb->s_fs_info;\n\tpid = proc_pid(inode);\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = PROC_I(inode)->op.proc_show(m, ns, pid, task);\n\n\tput_task_struct(task);\n\treturn ret;\n}\n\nstatic int proc_single_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\tret = single_open(filp, proc_single_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_single_file_operations = {\n\t.open\t\t= proc_single_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int mem_open(struct inode* inode, struct file* file)\n{\n\tfile->private_data = (void*)((long)current->self_exec_id);\n\treturn 0;\n}\n\nstatic ssize_t mem_read(struct file * file, char __user * buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (check_mem_permission(task))\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tret = 0;\n \n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_free;\n\n\tret = -EIO;\n \n\tif (file->private_data != (void*)((long)current->self_exec_id))\n\t\tgoto out_put;\n\n\tret = 0;\n \n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tretval = access_process_vm(task, src, page, this_len, 0);\n\t\tif (!retval || check_mem_permission(task)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n \n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\nout_put:\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\n#define mem_write NULL\n\n#ifndef mem_write\n/* This is a security hazard */\nstatic ssize_t mem_write(struct file * file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint copied;\n\tchar *page;\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tunsigned long dst = *ppos;\n\n\tcopied = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (check_mem_permission(task))\n\t\tgoto out;\n\n\tcopied = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tcopied = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval;\n\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tif (copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tretval = access_process_vm(task, dst, page, this_len, 1);\n\t\tif (!retval) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += retval;\n\t\tbuf += retval;\n\t\tdst += retval;\n\t\tcount -= retval;\t\t\t\n\t}\n\t*ppos = dst;\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn copied;\n}\n#endif\n\nloff_t mem_lseek(struct file *file, loff_t offset, int orig)\n{\n\tswitch (orig) {\n\tcase 0:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tcase 1:\n\t\tfile->f_pos += offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tforce_successful_syscall_return();\n\treturn file->f_pos;\n}\n\nstatic const struct file_operations proc_mem_operations = {\n\t.llseek\t\t= mem_lseek,\n\t.read\t\t= mem_read,\n\t.write\t\t= mem_write,\n\t.open\t\t= mem_open,\n};\n\nstatic ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = -ESRCH;\n\tstruct mm_struct *mm;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\tgoto out;\n\n\tret = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tret = 0;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_free;\n\n\twhile (count > 0) {\n\t\tint this_len, retval, max_len;\n\n\t\tthis_len = mm->env_end - (mm->env_start + src);\n\n\t\tif (this_len <= 0)\n\t\t\tbreak;\n\n\t\tmax_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tthis_len = (this_len > max_len) ? max_len : this_len;\n\n\t\tretval = access_process_vm(task, (mm->env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\n\tmmput(mm);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_environ_operations = {\n\t.read\t\t= environ_read,\n};\n\nstatic ssize_t oom_adjust_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint oom_adjust = OOM_DISABLE;\n\tunsigned long flags;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_adjust = task->signal->oom_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", oom_adjust);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t oom_adjust_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tlong oom_adjust;\n\tunsigned long flags;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\terr = strict_strtol(strstrip(buffer), 0, &oom_adjust);\n\tif (err)\n\t\treturn -EINVAL;\n\tif ((oom_adjust < OOM_ADJUST_MIN || oom_adjust > OOM_ADJUST_MAX) &&\n\t     oom_adjust != OOM_DISABLE)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file->f_path.dentry->d_inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (!lock_task_sighand(task, &flags)) {\n\t\tput_task_struct(task);\n\t\treturn -ESRCH;\n\t}\n\n\tif (oom_adjust < task->signal->oom_adj && !capable(CAP_SYS_RESOURCE)) {\n\t\tunlock_task_sighand(task, &flags);\n\t\tput_task_struct(task);\n\t\treturn -EACCES;\n\t}\n\n\ttask->signal->oom_adj = oom_adjust;\n\n\tunlock_task_sighand(task, &flags);\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_oom_adjust_operations = {\n\t.read\t\t= oom_adjust_read,\n\t.write\t\t= oom_adjust_write,\n};\n\n#ifdef CONFIG_AUDITSYSCALL\n#define TMPBUFLEN 21\nstatic ssize_t proc_loginuid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_loginuid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic ssize_t proc_loginuid_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *page, *tmp;\n\tssize_t length;\n\tuid_t loginuid;\n\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\n\tif (current != pid_task(proc_pid(inode), PIDTYPE_PID))\n\t\treturn -EPERM;\n\n\tif (count >= PAGE_SIZE)\n\t\tcount = PAGE_SIZE - 1;\n\n\tif (*ppos != 0) {\n\t\t/* No partial writes. */\n\t\treturn -EINVAL;\n\t}\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free_page;\n\n\tpage[count] = '\\0';\n\tloginuid = simple_strtoul(page, &tmp, 10);\n\tif (tmp == page) {\n\t\tlength = -EINVAL;\n\t\tgoto out_free_page;\n\n\t}\n\tlength = audit_set_loginuid(current, loginuid);\n\tif (likely(length == 0))\n\t\tlength = count;\n\nout_free_page:\n\tfree_page((unsigned long) page);\n\treturn length;\n}\n\nstatic const struct file_operations proc_loginuid_operations = {\n\t.read\t\t= proc_loginuid_read,\n\t.write\t\t= proc_loginuid_write,\n};\n\nstatic ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n\nstatic const struct file_operations proc_sessionid_operations = {\n\t.read\t\t= proc_sessionid_read,\n};\n#endif\n\n#ifdef CONFIG_FAULT_INJECTION\nstatic ssize_t proc_fault_inject_read(struct file * file, char __user * buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint make_it_fail;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tmake_it_fail = task->make_it_fail;\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", make_it_fail);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}\n\nstatic ssize_t proc_fault_inject_write(struct file * file,\n\t\t\tconst char __user * buf, size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF], *end;\n\tint make_it_fail;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\tmake_it_fail = simple_strtol(strstrip(buffer), &end, 0);\n\tif (*end)\n\t\treturn -EINVAL;\n\ttask = get_proc_task(file->f_dentry->d_inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->make_it_fail = make_it_fail;\n\tput_task_struct(task);\n\n\treturn count;\n}\n\nstatic const struct file_operations proc_fault_inject_operations = {\n\t.read\t\t= proc_fault_inject_read,\n\t.write\t\t= proc_fault_inject_write,\n};\n#endif\n\n\n#ifdef CONFIG_SCHED_DEBUG\n/*\n * Print out various scheduling related per-task fields:\n */\nstatic int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic ssize_t\nsched_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_set_task(p);\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int sched_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, sched_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_sched_operations = {\n\t.open\t\t= sched_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= sched_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#endif\n\nstatic ssize_t comm_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tstruct task_struct *p;\n\tchar buffer[TASK_COMM_LEN];\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (same_thread_group(current, p))\n\t\tset_task_comm(p, buffer);\n\telse\n\t\tcount = -EINVAL;\n\n\tput_task_struct(p);\n\n\treturn count;\n}\n\nstatic int comm_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\ttask_lock(p);\n\tseq_printf(m, \"%s\\n\", p->comm);\n\ttask_unlock(p);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic int comm_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, comm_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}\n\nstatic const struct file_operations proc_pid_set_comm_operations = {\n\t.open\t\t= comm_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= comm_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n/*\n * We added or removed a vma mapping the executable. The vmas are only mapped\n * during exec and are not mapped with the mmap system call.\n * Callers must hold down_write() on the mm's mmap_sem for these\n */\nvoid added_exe_file_vma(struct mm_struct *mm)\n{\n\tmm->num_exe_file_vmas++;\n}\n\nvoid removed_exe_file_vma(struct mm_struct *mm)\n{\n\tmm->num_exe_file_vmas--;\n\tif ((mm->num_exe_file_vmas == 0) && mm->exe_file){\n\t\tfput(mm->exe_file);\n\t\tmm->exe_file = NULL;\n\t}\n\n}\n\nvoid set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)\n{\n\tif (new_exe_file)\n\t\tget_file(new_exe_file);\n\tif (mm->exe_file)\n\t\tfput(mm->exe_file);\n\tmm->exe_file = new_exe_file;\n\tmm->num_exe_file_vmas = 0;\n}\n\nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\t/* We need mmap_sem to protect against races with removal of\n\t * VM_EXECUTABLE vmas */\n\tdown_read(&mm->mmap_sem);\n\texe_file = mm->exe_file;\n\tif (exe_file)\n\t\tget_file(exe_file);\n\tup_read(&mm->mmap_sem);\n\treturn exe_file;\n}\n\nvoid dup_mm_exe_file(struct mm_struct *oldmm, struct mm_struct *newmm)\n{\n\t/* It's safe to write the exe_file pointer without exe_file_lock because\n\t * this is called during fork when the task is not yet in /proc */\n\tnewmm->exe_file = get_mm_exe_file(oldmm);\n}\n\nstatic int proc_exe_link(struct inode *inode, struct path *exe_path)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct file *exe_file;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ENOENT;\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -ENOENT;\n\texe_file = get_mm_exe_file(mm);\n\tmmput(mm);\n\tif (exe_file) {\n\t\t*exe_path = exe_file->f_path;\n\t\tpath_get(&exe_file->f_path);\n\t\tfput(exe_file);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}\n\nstatic void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\n\t/* We don't need a base pointer in the /proc filesystem */\n\tpath_put(&nd->path);\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\nout:\n\treturn ERR_PTR(error);\n}\n\nstatic int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}\n\nstatic int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path path;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_proc_readlink(&path, buffer, buflen);\n\tpath_put(&path);\nout:\n\treturn error;\n}\n\nstatic const struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.follow_link\t= proc_pid_follow_link,\n\t.setattr\t= proc_setattr,\n};\n\n\n/* building an inode */\n\nstatic int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif(dumpable == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\n\nstatic struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}\n\nstatic int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\n/* dentry stuff */\n\n/*\n *\tExceptional case: normally we are not allowed to unhash a busy\n * directory. In this case, however, we can do it - no aliasing problems\n * due to the way we treat inodes.\n *\n * Rewrite the inode's ownerships here because the owning task may have\n * performed a setuid(), etc.\n *\n * Before the /proc/pid/status file was created the only way to read\n * the effective uid of a /process was to stat /proc/pid.  Reading\n * /proc/pid/status is slow enough that procps and other packages\n * kept stating /proc/pid.  To keep the rules in /proc simple I have\n * made this apply to all per process world readable and executable\n * directories.\n */\nstatic int pid_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tconst struct cred *cred;\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = 0;\n\t\t\tinode->i_gid = 0;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic int pid_delete_dentry(struct dentry * dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn !proc_pid(dentry->d_inode)->tasks[PIDTYPE_PID].first;\n}\n\nstatic const struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\n/* Lookups */\n\ntypedef struct dentry *instantiate_t(struct inode *, struct dentry *,\n\t\t\t\tstruct task_struct *, const void *);\n\n/*\n * Fill a directory entry.\n *\n * If possible create the dcache entry and derive our inode number and\n * file type from dcache entry.\n *\n * Since all of the proc inode numbers are dynamically generated, the inode\n * numbers do not exist until the inode is cache.  This means creating the\n * the dcache entry in readdir is necessary to keep the inode numbers\n * reported by readdir in sync with the inode numbers reported\n * by stat.\n */\nstatic int proc_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tchar *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = filp->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = name;\n\tqname.len  = len;\n\tqname.hash = full_name_hash(name, len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tstruct dentry *new;\n\t\tnew = d_alloc(dir, &qname);\n\t\tif (new) {\n\t\t\tchild = instantiate(dir->d_inode, new, task, ptr);\n\t\t\tif (child)\n\t\t\t\tdput(new);\n\t\t\telse\n\t\t\t\tchild = new;\n\t\t}\n\t}\n\tif (!child || IS_ERR(child) || !child->d_inode)\n\t\tgoto end_instantiate;\n\tinode = child->d_inode;\n\tif (inode) {\n\t\tino = inode->i_ino;\n\t\ttype = inode->i_mode >> 12;\n\t}\n\tdput(child);\nend_instantiate:\n\tif (!ino)\n\t\tino = find_inode_number(dir, &qname);\n\tif (!ino)\n\t\tino = 1;\n\treturn filldir(dirent, name, len, filp->f_pos, ino, type);\n}\n\nstatic unsigned name_to_int(struct dentry *dentry)\n{\n\tconst char *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}\n\n#define PROC_FDINFO_MAX 64\n\nstatic int proc_fd_info(struct inode *inode, struct path *path, char *info)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct files_struct *files = NULL;\n\tstruct file *file;\n\tint fd = proc_fd(inode);\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tput_task_struct(task);\n\t}\n\tif (files) {\n\t\t/*\n\t\t * We are not taking a ref to the file structure, so we must\n\t\t * hold ->file_lock.\n\t\t */\n\t\tspin_lock(&files->file_lock);\n\t\tfile = fcheck_files(files, fd);\n\t\tif (file) {\n\t\t\tif (path) {\n\t\t\t\t*path = file->f_path;\n\t\t\t\tpath_get(&file->f_path);\n\t\t\t}\n\t\t\tif (info)\n\t\t\t\tsnprintf(info, PROC_FDINFO_MAX,\n\t\t\t\t\t \"pos:\\t%lli\\n\"\n\t\t\t\t\t \"flags:\\t0%o\\n\",\n\t\t\t\t\t (long long) file->f_pos,\n\t\t\t\t\t file->f_flags);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tput_files_struct(files);\n\t\t\treturn 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\treturn -ENOENT;\n}\n\nstatic int proc_fd_link(struct inode *inode, struct path *path)\n{\n\treturn proc_fd_info(inode, path, NULL);\n}\n\nstatic int tid_fd_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tint fd = proc_fd(inode);\n\tstruct files_struct *files;\n\tconst struct cred *cred;\n\n\tif (task) {\n\t\tfiles = get_files_struct(task);\n\t\tif (files) {\n\t\t\trcu_read_lock();\n\t\t\tif (fcheck_files(files, fd)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tput_files_struct(files);\n\t\t\t\tif (task_dumpable(task)) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tcred = __task_cred(task);\n\t\t\t\t\tinode->i_uid = cred->euid;\n\t\t\t\t\tinode->i_gid = cred->egid;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_uid = 0;\n\t\t\t\t\tinode->i_gid = 0;\n\t\t\t\t}\n\t\t\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\t\t\tsecurity_task_to_inode(task, inode);\n\t\t\t\tput_task_struct(task);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t\t}\n\t\tput_task_struct(task);\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic const struct dentry_operations tid_fd_dentry_operations =\n{\n\t.d_revalidate\t= tid_fd_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic struct dentry *proc_fd_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = *(const unsigned *)ptr;\n\tstruct file *file;\n\tstruct files_struct *files;\n \tstruct inode *inode;\n \tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\tfiles = get_files_struct(task);\n\tif (!files)\n\t\tgoto out_iput;\n\tinode->i_mode = S_IFLNK;\n\n\t/*\n\t * We are not taking a ref to the file structure, so we must\n\t * hold ->file_lock.\n\t */\n\tspin_lock(&files->file_lock);\n\tfile = fcheck_files(files, fd);\n\tif (!file)\n\t\tgoto out_unlock;\n\tif (file->f_mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR | S_IXUSR;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR | S_IXUSR;\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\n\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\tei->op.proc_get_link = proc_fd_link;\n\tdentry->d_op = &tid_fd_dentry_operations;\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, NULL))\n\t\terror = NULL;\n\n out:\n\treturn error;\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\nout_iput:\n\tiput(inode);\n\tgoto out;\n}\n\nstatic struct dentry *proc_lookupfd_common(struct inode *dir,\n\t\t\t\t\t   struct dentry *dentry,\n\t\t\t\t\t   instantiate_t instantiate)\n{\n\tstruct task_struct *task = get_proc_task(dir);\n\tunsigned fd = name_to_int(dentry);\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (fd == ~0U)\n\t\tgoto out;\n\n\tresult = instantiate(dir, dentry, task, &fd);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn result;\n}\n\nstatic int proc_readfd_common(struct file * filp, void * dirent,\n\t\t\t      filldir_t filldir, instantiate_t instantiate)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tunsigned int fd, ino;\n\tint retval;\n\tstruct files_struct * files;\n\n\tretval = -ENOENT;\n\tif (!p)\n\t\tgoto out_no_task;\n\tretval = 0;\n\n\tfd = filp->f_pos;\n\tswitch (fd) {\n\t\tcase 0:\n\t\t\tif (filldir(dirent, \".\", 1, 0, inode->i_ino, DT_DIR) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\tcase 1:\n\t\t\tino = parent_ino(dentry);\n\t\t\tif (filldir(dirent, \"..\", 2, 1, ino, DT_DIR) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\tdefault:\n\t\t\tfiles = get_files_struct(p);\n\t\t\tif (!files)\n\t\t\t\tgoto out;\n\t\t\trcu_read_lock();\n\t\t\tfor (fd = filp->f_pos-2;\n\t\t\t     fd < files_fdtable(files)->max_fds;\n\t\t\t     fd++, filp->f_pos++) {\n\t\t\t\tchar name[PROC_NUMBUF];\n\t\t\t\tint len;\n\n\t\t\t\tif (!fcheck_files(files, fd))\n\t\t\t\t\tcontinue;\n\t\t\t\trcu_read_unlock();\n\n\t\t\t\tlen = snprintf(name, sizeof(name), \"%d\", fd);\n\t\t\t\tif (proc_fill_cache(filp, dirent, filldir,\n\t\t\t\t\t\t    name, len, instantiate,\n\t\t\t\t\t\t    p, &fd) < 0) {\n\t\t\t\t\trcu_read_lock();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trcu_read_lock();\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tput_files_struct(files);\n\t}\nout:\n\tput_task_struct(p);\nout_no_task:\n\treturn retval;\n}\n\nstatic struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,\n\t\t\t\t    struct nameidata *nd)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fd_instantiate);\n}\n\nstatic int proc_readfd(struct file *filp, void *dirent, filldir_t filldir)\n{\n\treturn proc_readfd_common(filp, dirent, filldir, proc_fd_instantiate);\n}\n\nstatic ssize_t proc_fdinfo_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *ppos)\n{\n\tchar tmp[PROC_FDINFO_MAX];\n\tint err = proc_fd_info(file->f_path.dentry->d_inode, NULL, tmp);\n\tif (!err)\n\t\terr = simple_read_from_buffer(buf, len, ppos, tmp, strlen(tmp));\n\treturn err;\n}\n\nstatic const struct file_operations proc_fdinfo_file_operations = {\n\t.open\t\t= nonseekable_open,\n\t.read\t\t= proc_fdinfo_read,\n};\n\nstatic const struct file_operations proc_fd_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_readfd,\n};\n\n/*\n * /proc/pid/fd needs a special permission handler so that a process can still\n * access /proc/self/fd after it has executed a setuid().\n */\nstatic int proc_fd_permission(struct inode *inode, int mask)\n{\n\tint rv;\n\n\trv = generic_permission(inode, mask, NULL);\n\tif (rv == 0)\n\t\treturn 0;\n\tif (task_pid(current) == proc_pid(inode))\n\t\trv = 0;\n\treturn rv;\n}\n\n/*\n * proc directories can do almost nothing..\n */\nstatic const struct inode_operations proc_fd_inode_operations = {\n\t.lookup\t\t= proc_lookupfd,\n\t.permission\t= proc_fd_permission,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_fdinfo_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tunsigned fd = *(unsigned *)ptr;\n \tstruct inode *inode;\n \tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tei = PROC_I(inode);\n\tei->fd = fd;\n\tinode->i_mode = S_IFREG | S_IRUSR;\n\tinode->i_fop = &proc_fdinfo_file_operations;\n\tdentry->d_op = &tid_fd_dentry_operations;\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (tid_fd_revalidate(dentry, NULL))\n\t\terror = NULL;\n\n out:\n\treturn error;\n}\n\nstatic struct dentry *proc_lookupfdinfo(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tstruct nameidata *nd)\n{\n\treturn proc_lookupfd_common(dir, dentry, proc_fdinfo_instantiate);\n}\n\nstatic int proc_readfdinfo(struct file *filp, void *dirent, filldir_t filldir)\n{\n\treturn proc_readfd_common(filp, dirent, filldir,\n\t\t\t\t  proc_fdinfo_instantiate);\n}\n\nstatic const struct file_operations proc_fdinfo_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_readfdinfo,\n};\n\n/*\n * proc directories can do almost nothing..\n */\nstatic const struct inode_operations proc_fdinfo_inode_operations = {\n\t.lookup\t\t= proc_lookupfdinfo,\n\t.setattr\t= proc_setattr,\n};\n\n\nstatic struct dentry *proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_nlink = 2;\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}\n\nstatic int proc_pident_fill_cache(struct file *filp, void *dirent,\n\tfilldir_t filldir, struct task_struct *task, const struct pid_entry *p)\n{\n\treturn proc_fill_cache(filp, dirent, filldir, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p);\n}\n\nstatic int proc_pident_readdir(struct file *filp,\n\t\tvoid *dirent, filldir_t filldir,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tint i;\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tconst struct pid_entry *p, *last;\n\tino_t ino;\n\tint ret;\n\n\tret = -ENOENT;\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = 0;\n\ti = filp->f_pos;\n\tswitch (i) {\n\tcase 0:\n\t\tino = inode->i_ino;\n\t\tif (filldir(dirent, \".\", 1, i, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\ti++;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tcase 1:\n\t\tino = parent_ino(dentry);\n\t\tif (filldir(dirent, \"..\", 2, i, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\ti++;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tdefault:\n\t\ti -= 2;\n\t\tif (i >= nents) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tp = ents + i;\n\t\tlast = &ents[nents - 1];\n\t\twhile (p <= last) {\n\t\t\tif (proc_pident_fill_cache(filp, dirent, filldir, task, p) < 0)\n\t\t\t\tgoto out;\n\t\t\tfilp->f_pos++;\n\t\t\tp++;\n\t\t}\n\t}\n\n\tret = 1;\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ret;\n}\n\n#ifdef CONFIG_SECURITY\nstatic ssize_t proc_pid_attr_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *p = NULL;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tlength = security_getprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      &p);\n\tput_task_struct(task);\n\tif (length > 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, p, length);\n\tkfree(p);\n\treturn length;\n}\n\nstatic ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file->f_path.dentry->d_inode;\n\tchar *page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free;\n\n\t/* Guard against adverse ptrace interaction */\n\tlength = mutex_lock_interruptible(&task->cred_guard_mutex);\n\tif (length < 0)\n\t\tgoto out_free;\n\n\tlength = security_setprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      (void*)page, count);\n\tmutex_unlock(&task->cred_guard_mutex);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}\n\nstatic const struct file_operations proc_pid_attr_operations = {\n\t.read\t\t= proc_pid_attr_read,\n\t.write\t\t= proc_pid_attr_write,\n};\n\nstatic const struct pid_entry attr_dir_stuff[] = {\n\tREG(\"current\",    S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"prev\",       S_IRUGO,\t   proc_pid_attr_operations),\n\tREG(\"exec\",       S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"fscreate\",   S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"keycreate\",  S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n\tREG(\"sockcreate\", S_IRUGO|S_IWUGO, proc_pid_attr_operations),\n};\n\nstatic int proc_attr_dir_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   attr_dir_stuff,ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct file_operations proc_attr_dir_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_attr_dir_readdir,\n};\n\nstatic struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, struct nameidata *nd)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}\n\nstatic const struct inode_operations proc_attr_dir_inode_operations = {\n\t.lookup\t\t= proc_attr_dir_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\n#endif\n\n#ifdef CONFIG_ELF_CORE\nstatic ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_dentry->d_inode);\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint ret;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = 0;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tlen = snprintf(buffer, sizeof(buffer), \"%08lx\\n\",\n\t\t\t       ((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT));\n\t\tmmput(mm);\n\t\tret = simple_read_from_buffer(buf, count, ppos, buffer, len);\n\t}\n\n\tput_task_struct(task);\n\n\treturn ret;\n}\n\nstatic ssize_t proc_coredump_filter_write(struct file *file,\n\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t  size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF], *end;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\tunsigned long mask;\n\n\tret = -EFAULT;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\tgoto out_no_task;\n\n\tret = -EINVAL;\n\tval = (unsigned int)simple_strtoul(buffer, &end, 0);\n\tif (*end == '\\n')\n\t\tend++;\n\tif (end - buffer == 0)\n\t\tgoto out_no_task;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(file->f_dentry->d_inode);\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = end - buffer;\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_no_mm;\n\n\tfor (i = 0, mask = 1; i < MMF_DUMP_FILTER_BITS; i++, mask <<= 1) {\n\t\tif (val & mask)\n\t\t\tset_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t\telse\n\t\t\tclear_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t}\n\n\tmmput(mm);\n out_no_mm:\n\tput_task_struct(task);\n out_no_task:\n\treturn ret;\n}\n\nstatic const struct file_operations proc_coredump_filter_operations = {\n\t.read\t\t= proc_coredump_filter_read,\n\t.write\t\t= proc_coredump_filter_write,\n};\n#endif\n\n/*\n * /proc/self:\n */\nstatic int proc_self_readlink(struct dentry *dentry, char __user *buffer,\n\t\t\t      int buflen)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tchar tmp[PROC_NUMBUF];\n\tif (!tgid)\n\t\treturn -ENOENT;\n\tsprintf(tmp, \"%d\", tgid);\n\treturn vfs_readlink(dentry,buffer,buflen,tmp);\n}\n\nstatic void *proc_self_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\n\tpid_t tgid = task_tgid_nr_ns(current, ns);\n\tchar tmp[PROC_NUMBUF];\n\tif (!tgid)\n\t\treturn ERR_PTR(-ENOENT);\n\tsprintf(tmp, \"%d\", task_tgid_nr_ns(current, ns));\n\treturn ERR_PTR(vfs_follow_link(nd,tmp));\n}\n\nstatic const struct inode_operations proc_self_inode_operations = {\n\t.readlink\t= proc_self_readlink,\n\t.follow_link\t= proc_self_follow_link,\n};\n\n/*\n * proc base\n *\n * These are the directory entries in the root directory of /proc\n * that properly belong to the /proc filesystem, as they describe\n * describe something that is process related.\n */\nstatic const struct pid_entry proc_base_stuff[] = {\n\tNOD(\"self\", S_IFLNK|S_IRWXUGO,\n\t\t&proc_self_inode_operations, NULL, {}),\n};\n\n/*\n *\tExceptional case: normally we are not allowed to unhash a busy\n * directory. In this case, however, we can do it - no aliasing problems\n * due to the way we treat inodes.\n */\nstatic int proc_base_revalidate(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task = get_proc_task(inode);\n\tif (task) {\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\td_drop(dentry);\n\treturn 0;\n}\n\nstatic const struct dentry_operations proc_base_dentry_operations =\n{\n\t.d_revalidate\t= proc_base_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic struct dentry *proc_base_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\tstruct dentry *error = ERR_PTR(-EINVAL);\n\n\t/* Allocate the inode */\n\terror = ERR_PTR(-ENOMEM);\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Initialize the inode */\n\tei = PROC_I(inode);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\n\t/*\n\t * grab the reference to the task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_iput;\n\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tinode->i_nlink = 2;\n\tif (S_ISLNK(inode->i_mode))\n\t\tinode->i_size = 64;\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\tdentry->d_op = &proc_base_dentry_operations;\n\td_add(dentry, inode);\n\terror = NULL;\nout:\n\treturn error;\nout_iput:\n\tiput(inode);\n\tgoto out;\n}\n\nstatic struct dentry *proc_base_lookup(struct inode *dir, struct dentry *dentry)\n{\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = ERR_PTR(-ENOENT);\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/* Lookup the directory entry */\n\tlast = &proc_base_stuff[ARRAY_SIZE(proc_base_stuff) - 1];\n\tfor (p = proc_base_stuff; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_base_instantiate(dir, dentry, task, p);\n\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}\n\nstatic int proc_base_fill_cache(struct file *filp, void *dirent,\n\tfilldir_t filldir, struct task_struct *task, const struct pid_entry *p)\n{\n\treturn proc_fill_cache(filp, dirent, filldir, p->name, p->len,\n\t\t\t\tproc_base_instantiate, task, p);\n}\n\n#ifdef CONFIG_TASK_IO_ACCOUNTING\nstatic int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}\n\nstatic int proc_tid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn do_io_accounting(task, buffer, 0);\n}\n\nstatic int proc_tgid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn do_io_accounting(task, buffer, 1);\n}\n#endif /* CONFIG_TASK_IO_ACCOUNTING */\n\nstatic int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tseq_printf(m, \"%08x\\n\", task->personality);\n\treturn 0;\n}\n\n/*\n * Thread groups\n */\nstatic const struct file_operations proc_task_operations;\nstatic const struct inode_operations proc_task_inode_operations;\n\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tINF(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tINF(\"limits\",\t  S_IRUSR, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tINF(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tINF(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tINF(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tINF(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tREG(\"cpuset\",     S_IRUGO, proc_cpuset_operations),\n#endif\n#ifdef CONFIG_CGROUPS\n\tREG(\"cgroup\",  S_IRUGO, proc_cgroup_operations),\n#endif\n\tINF(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adjust_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tINF(\"io\",\tS_IRUGO, proc_tgid_io_accounting),\n#endif\n};\n\nstatic int proc_tgid_base_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   tgid_base_stuff,ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_tgid_base_readdir,\n};\n\nstatic struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}\n\nstatic const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\tshrink_dcache_parent(dentry);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\tshrink_dcache_parent(dentry);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}\n\n/**\n * proc_flush_task -  Remove dcache entries for @task from the /proc dcache.\n * @task: task that should be flushed.\n *\n * When flushing dentries from proc, one needs to flush them from global\n * proc (proc_mnt) and from all the namespaces' procs this task was seen\n * in. This call is supposed to do all of this job.\n *\n * Looks in the dcache for\n * /proc/@pid\n * /proc/@tgid/task/@pid\n * if either directory is present flushes it and all of it'ts children\n * from the dcache.\n *\n * It is safe and reasonable to cache /proc entries for a task until\n * that task exits.  After that they just clog up the dcache with\n * useless entries, possibly causing useful dcache entries to be\n * flushed instead.  This routine is proved to flush those useless\n * dcache entries at process exit time.\n *\n * NOTE: This routine is just an optimization so it does not guarantee\n *       that no dcache entries will exist at process exit time it\n *       just makes it very unlikely that any will persist.\n */\n\nvoid proc_flush_task(struct task_struct *task)\n{\n\tint i;\n\tstruct pid *pid, *tgid;\n\tstruct upid *upid;\n\n\tpid = task_pid(task);\n\ttgid = task_tgid(task);\n\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tupid = &pid->numbers[i];\n\t\tproc_flush_task_mnt(upid->ns->proc_mnt, upid->nr,\n\t\t\t\t\ttgid->numbers[i].nr);\n\t}\n\n\tupid = &pid->numbers[pid->level];\n\tif (upid->nr == 1)\n\t\tpid_ns_release_proc(upid->ns);\n}\n\nstatic struct dentry *proc_pid_instantiate(struct inode *dir,\n\t\t\t\t\t   struct dentry * dentry,\n\t\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tinode->i_nlink = 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\tARRAY_SIZE(tgid_base_stuff));\n\n\tdentry->d_op = &pid_dentry_operations;\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstruct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\tresult = proc_base_lookup(dir, dentry);\n\tif (!IS_ERR(result) || PTR_ERR(result) != -ENOENT)\n\t\tgoto out;\n\n\ttgid = name_to_int(dentry);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn result;\n}\n\n/*\n * Find the first task with tgid >= tgid\n *\n */\nstruct tgid_iter {\n\tunsigned int tgid;\n\tstruct task_struct *task;\n};\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}\n\n#define TGID_OFFSET (FIRST_PROCESS_ENTRY + ARRAY_SIZE(proc_base_stuff))\n\nstatic int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tstruct tgid_iter iter)\n{\n\tchar name[PROC_NUMBUF];\n\tint len = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\treturn proc_fill_cache(filp, dirent, filldir, name, len,\n\t\t\t\tproc_pid_instantiate, iter.task, NULL);\n}\n\n/* for the /proc/ directory itself, after non-process stuff has been done */\nint proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tunsigned int nr = filp->f_pos - FIRST_PROCESS_ENTRY;\n\tstruct task_struct *reaper = get_proc_task(filp->f_path.dentry->d_inode);\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns;\n\n\tif (!reaper)\n\t\tgoto out_no_task;\n\n\tfor (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) {\n\t\tconst struct pid_entry *p = &proc_base_stuff[nr];\n\t\tif (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0)\n\t\t\tgoto out;\n\t}\n\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\titer.task = NULL;\n\titer.tgid = filp->f_pos - TGID_OFFSET;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tfilp->f_pos = iter.tgid + TGID_OFFSET;\n\t\tif (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) {\n\t\t\tput_task_struct(iter.task);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfilp->f_pos = PID_MAX_LIMIT + TGID_OFFSET;\nout:\n\tput_task_struct(reaper);\nout_no_task:\n\treturn 0;\n}\n\n/*\n * Tasks\n */\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fd_operations),\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tINF(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tINF(\"limits\",\t S_IRUSR, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tINF(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tINF(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tINF(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tINF(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tREG(\"cpuset\",    S_IRUGO, proc_cpuset_operations),\n#endif\n#ifdef CONFIG_CGROUPS\n\tREG(\"cgroup\",  S_IRUGO, proc_cgroup_operations),\n#endif\n\tINF(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adjust_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUSR, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tINF(\"io\",\tS_IRUGO, proc_tid_io_accounting),\n#endif\n};\n\nstatic int proc_tid_base_readdir(struct file * filp,\n\t\t\t     void * dirent, filldir_t filldir)\n{\n\treturn proc_pident_readdir(filp,dirent,filldir,\n\t\t\t\t   tid_base_stuff,ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}\n\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_tid_base_readdir,\n};\n\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic struct dentry *proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tinode->i_nlink = 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\tARRAY_SIZE(tid_base_stuff));\n\n\tdentry->d_op = &pid_dentry_operations;\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}\n\nstatic struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, struct nameidata *nd)\n{\n\tstruct dentry *result = ERR_PTR(-ENOENT);\n\tstruct task_struct *task;\n\tstruct task_struct *leader = get_proc_task(dir);\n\tunsigned tid;\n\tstruct pid_namespace *ns;\n\n\tif (!leader)\n\t\tgoto out_no_task;\n\n\ttid = name_to_int(dentry);\n\tif (tid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\tif (!same_thread_group(leader, task))\n\t\tgoto out_drop_task;\n\n\tresult = proc_task_instantiate(dir, dentry, task, NULL);\nout_drop_task:\n\tput_task_struct(task);\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn result;\n}\n\n/*\n * Find the first tid of a thread group to return to user space.\n *\n * Usually this is just the thread group leader, but if the users\n * buffer was too small or there was a seek into the middle of the\n * directory we have more work todo.\n *\n * In the case of a short read we start with find_task_by_pid.\n *\n * In the case of a seek we start with the leader and walk nr\n * threads past it.\n */\nstatic struct task_struct *first_tid(struct task_struct *leader,\n\t\tint tid, int nr, struct pid_namespace *ns)\n{\n\tstruct task_struct *pos;\n\n\trcu_read_lock();\n\t/* Attempt to start with the pid of a thread */\n\tif (tid && (nr > 0)) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && (pos->group_leader == leader))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tpos = NULL;\n\tif (nr && nr >= get_nr_threads(leader))\n\t\tgoto out;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tfor (pos = leader; nr > 0; --nr) {\n\t\tpos = next_thread(pos);\n\t\tif (pos == leader) {\n\t\t\tpos = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}\n\n/*\n * Find the next thread in the thread list.\n * Return NULL if there is an error or no next thread.\n *\n * The reference to the input task_struct is released.\n */\nstatic struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}\n\nstatic int proc_task_fill_cache(struct file *filp, void *dirent, filldir_t filldir,\n\tstruct task_struct *task, int tid)\n{\n\tchar name[PROC_NUMBUF];\n\tint len = snprintf(name, sizeof(name), \"%d\", tid);\n\treturn proc_fill_cache(filp, dirent, filldir, name, len,\n\t\t\t\tproc_task_instantiate, task, NULL);\n}\n\n/* for the /proc/TGID/task/ directories */\nstatic int proc_task_readdir(struct file * filp, void * dirent, filldir_t filldir)\n{\n\tstruct dentry *dentry = filp->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *leader = NULL;\n\tstruct task_struct *task;\n\tint retval = -ENOENT;\n\tino_t ino;\n\tint tid;\n\tstruct pid_namespace *ns;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_no_task;\n\trcu_read_lock();\n\tif (pid_alive(task)) {\n\t\tleader = task->group_leader;\n\t\tget_task_struct(leader);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(task);\n\tif (!leader)\n\t\tgoto out_no_task;\n\tretval = 0;\n\n\tswitch ((unsigned long)filp->f_pos) {\n\tcase 0:\n\t\tino = inode->i_ino;\n\t\tif (filldir(dirent, \".\", 1, filp->f_pos, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\tcase 1:\n\t\tino = parent_ino(dentry);\n\t\tif (filldir(dirent, \"..\", 2, filp->f_pos, ino, DT_DIR) < 0)\n\t\t\tgoto out;\n\t\tfilp->f_pos++;\n\t\t/* fall through */\n\t}\n\n\t/* f_version caches the tgid value that the last readdir call couldn't\n\t * return. lseek aka telldir automagically resets f_version to 0.\n\t */\n\tns = filp->f_dentry->d_sb->s_fs_info;\n\ttid = (int)filp->f_version;\n\tfilp->f_version = 0;\n\tfor (task = first_tid(leader, tid, filp->f_pos - 2, ns);\n\t     task;\n\t     task = next_tid(task), filp->f_pos++) {\n\t\ttid = task_pid_nr_ns(task, ns);\n\t\tif (proc_task_fill_cache(filp, dirent, filldir, task, tid) < 0) {\n\t\t\t/* returning this tgid failed, save it as the first\n\t\t\t * pid for the next readir call */\n\t\t\tfilp->f_version = (u64)tid;\n\t\t\tput_task_struct(task);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn retval;\n}\n\nstatic int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tgeneric_fillattr(inode, stat);\n\n\tif (p) {\n\t\tstat->nlink += get_nr_threads(p);\n\t\tput_task_struct(p);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct inode_operations proc_task_inode_operations = {\n\t.lookup\t\t= proc_task_lookup,\n\t.getattr\t= proc_task_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic const struct file_operations proc_task_operations = {\n\t.read\t\t= generic_read_dir,\n\t.readdir\t= proc_task_readdir,\n};\n"], "filenames": ["fs/namei.c", "fs/proc/base.c"], "buggy_code_start_loc": [563, 1422], "buggy_code_end_loc": [563, 1423], "fixing_code_start_loc": [564, 1421], "fixing_code_end_loc": [565, 1421], "type": "CWE-416", "message": "The __do_follow_link function in fs/namei.c in the Linux kernel before 2.6.33 does not properly handle the last pathname component during use of certain filesystems, which allows local users to cause a denial of service (incorrect free operations and system crash) via an open system call.", "other": {"cve": {"id": "CVE-2014-0203", "sourceIdentifier": "secalert@redhat.com", "published": "2014-06-23T11:21:17.170", "lastModified": "2023-02-13T00:37:21.397", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The __do_follow_link function in fs/namei.c in the Linux kernel before 2.6.33 does not properly handle the last pathname component during use of certain filesystems, which allows local users to cause a denial of service (incorrect free operations and system crash) via an open system call."}, {"lang": "es", "value": "La funci\u00f3n __do_follow_link en fs/namei.c en el kernel de Linux anterior a 2.6.33 no maneja debidamente el componente de \u00faltimo nombre de ruta durante el uso de ciertos sistemas de ficheros, lo que permite a usuarios locales causar una denegaci\u00f3n de servicio (operaciones libres incorrectas y ca\u00edda del sistema) a trav\u00e9s de una llamada de sistema abierto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.33", "matchCriteriaId": "A01490AB-675E-4BA1-916D-F2A0D6CB27FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:5:-:*:*:*:*:*:*", "matchCriteriaId": "62A2AC02-A933-4E51-810E-5D040B476B7B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:-:*:*:*:*:*:*", "matchCriteriaId": "D7B037A8-72A6-4DFF-94B2-D688A5F6F876"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=86acdca1b63e6890540fa19495cfc708beff3d8b", "source": "secalert@redhat.com"}, {"url": "http://linux.oracle.com/errata/ELSA-2014-0771.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://linux.oracle.com/errata/ELSA-2014-3043.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/68125", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1094363", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b"}}