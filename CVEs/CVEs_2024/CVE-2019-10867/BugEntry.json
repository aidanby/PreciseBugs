{"buggy_code": ["<?php\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Enterprise License (PEL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PEL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\DataObject;\n\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\HttpFoundation\\JsonResponse;\nuse Pimcore\\Controller\\EventedControllerInterface;\nuse Pimcore\\Db;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\Logger;\nuse Pimcore\\Model;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\Document;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\FilterControllerEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\FilterResponseEvent;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\n/**\n * @Route(\"/class\")\n */\nclass ClassController extends AdminController implements EventedControllerInterface\n{\n    /**\n     * @Route(\"/get-document-types\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getDocumentTypesAction(Request $request)\n    {\n        $documentTypes = Document::getTypes();\n        $typeItems = [];\n        foreach ($documentTypes as $documentType) {\n            $typeItems[] = [\n                'text' => $documentType\n            ];\n        }\n\n        return $this->adminJson($typeItems);\n    }\n\n    /**\n     * @Route(\"/get-asset-types\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAssetTypesAction(Request $request)\n    {\n        $assetTypes = Asset::getTypes();\n        $typeItems = [];\n        foreach ($assetTypes as $assetType) {\n            $typeItems[] = [\n                'text' => $assetType\n            ];\n        }\n\n        return $this->adminJson($typeItems);\n    }\n\n    /**\n     * @Route(\"/get-tree\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getTreeAction(Request $request)\n    {\n        $defaultIcon = '/bundles/pimcoreadmin/img/flat-color-icons/timeline.svg';\n\n        $classesList = new DataObject\\ClassDefinition\\Listing();\n        $classesList->setOrderKey('name');\n        $classesList->setOrder('asc');\n        $classes = $classesList->load();\n\n        // filter classes\n        if ($request->get('createAllowed')) {\n            $tmpClasses = [];\n            foreach ($classes as $class) {\n                if ($this->getAdminUser()->isAllowed($class->getId(), 'class')) {\n                    $tmpClasses[] = $class;\n                }\n            }\n            $classes = $tmpClasses;\n        }\n\n        $withId = $request->get('withId');\n        $getClassConfig = function ($class) use ($defaultIcon, $withId) {\n            $text = $class->getname();\n            if ($withId) {\n                $text .= ' (' . $class->getId() . ')';\n            }\n\n            return [\n                'id' => $class->getId(),\n                'text' => $text,\n                'leaf' => true,\n                'icon' => $class->getIcon() ? $class->getIcon() : $defaultIcon,\n                'cls' => 'pimcore_class_icon',\n                'propertyVisibility' => $class->getPropertyVisibility()\n            ];\n        };\n\n        // build groups\n        $groups = [];\n        foreach ($classes as $class) {\n            if (!$class) {\n                continue;\n            }\n            if ($class->getGroup()) {\n                $type = 'manual';\n                $groupName = $class->getGroup();\n            } else {\n                $type = 'auto';\n                preg_match('@^([A-Za-z])([^A-Z]+)@', $class->getName(), $matches);\n                $groupName = $matches[0];\n\n                if (!$groupName) {\n                    // this is eg. the case when class name uses only capital letters\n                    $groupName = $class->getName();\n                }\n            }\n\n            $groupName = \\Pimcore\\Model\\Translation\\Admin::getByKeyLocalized($groupName, true, true);\n\n            if (!isset($groups[$groupName])) {\n                $groups[$groupName] = [\n                    'classes' => [],\n                    'type' => $type\n                ];\n            }\n            $groups[$groupName]['classes'][] = $class;\n        }\n\n        $treeNodes = [];\n\n        if (!$request->get('grouped')) {\n            // list output\n            foreach ($groups as $groupName => $groupData) {\n                foreach ($groupData['classes'] as $class) {\n                    $node = $getClassConfig($class);\n                    if (count($groupData['classes']) > 1 || $groupData['type'] == 'manual') {\n                        $node['group'] = $groupName;\n                    }\n                    $treeNodes[] = $node;\n                }\n            }\n        } else {\n            // create json output\n            foreach ($groups as $groupName => $groupData) {\n                if (count($groupData['classes']) === 1 && $groupData['type'] == 'auto') {\n                    // no group, only one child\n                    $node = $getClassConfig($groupData['classes'][0]);\n                } else {\n                    // group classes\n                    $node = [\n                        'id' => 'folder_' . $groupName,\n                        'text' => $groupName,\n                        'leaf' => false,\n                        'expandable' => true,\n                        'allowChildren' => true,\n                        'iconCls' => 'pimcore_icon_folder',\n                        'children' => []\n                    ];\n\n                    foreach ($groupData['classes'] as $class) {\n                        $node['children'][] = $getClassConfig($class);\n                    }\n                }\n\n                $treeNodes[] = $node;\n            }\n        }\n\n        return $this->adminJson($treeNodes);\n    }\n\n    /**\n     * @Route(\"/get\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        $class->setFieldDefinitions(null);\n\n        return $this->adminJson($class);\n    }\n\n    /**\n     * @Route(\"/get-custom-layout\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getCustomLayoutAction(Request $request)\n    {\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($request->get('id'));\n\n        return $this->adminJson(['success' => true, 'data' => $customLayout]);\n    }\n\n    /**\n     * @Route(\"/add\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addAction(Request $request)\n    {\n        $className = $request->get('className');\n        $className = $this->correctClassname($className);\n\n        $classId = $request->get('classIdentifier');\n        $existingClass = DataObject\\ClassDefinition::getById($classId);\n        if ($existingClass) {\n            throw new \\Exception('Class identifier already exists');\n        }\n\n        $class = DataObject\\ClassDefinition::create(\n            ['name' => $className,\n                'userOwner' => $this->getAdminUser()->getId()]\n        );\n\n        $class->setId($classId);\n\n        $class->save(true);\n\n        return $this->adminJson(['success' => true, 'id' => $class->getId()]);\n    }\n\n    /**\n     * @Route(\"/add-custom-layout\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addCustomLayoutAction(Request $request)\n    {\n        $layoutId = $request->get('layoutIdentifier');\n        $existingLayout = DataObject\\ClassDefinition\\CustomLayout::getById($layoutId);\n        if ($existingLayout) {\n            throw new \\Exception('Custom Layout identifier already exists');\n        }\n\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::create(\n            [\n                'name' => $request->get('layoutName'),\n                'userOwner' => $this->getAdminUser()->getId(),\n                'classId' => $request->get('classId')\n            ]\n        );\n\n        $customLayout->setId($layoutId);\n        $customLayout->save();\n\n        return $this->adminJson(['success' => true, 'id' => $customLayout->getId(), 'name' => $customLayout->getName(),\n                                 'data' => $customLayout]);\n    }\n\n    /**\n     * @Route(\"/delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function deleteAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        $class->delete();\n\n        return new Response();\n    }\n\n    /**\n     * @Route(\"/delete-custom-layout\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteCustomLayoutAction(Request $request)\n    {\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($request->get('id'));\n        if ($customLayout) {\n            $customLayout->delete();\n        }\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * @Route(\"/save-custom-layout\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function saveCustomLayoutAction(Request $request)\n    {\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($request->get('id'));\n        $class = DataObject\\ClassDefinition::getById($customLayout->getClassId());\n\n        $configuration = $this->decodeJson($request->get('configuration'));\n        $values = $this->decodeJson($request->get('values'));\n\n        $modificationDate = intval($values['modificationDate']);\n        if ($modificationDate < $customLayout->getModificationDate()) {\n            return $this->adminJson(['success' => false, 'msg' => 'custom_layout_changed']);\n        }\n\n        $configuration['datatype'] = 'layout';\n        $configuration['fieldtype'] = 'panel';\n        $configuration['name'] = 'pimcore_root';\n\n        try {\n            $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($configuration, true);\n            $customLayout->setLayoutDefinitions($layout);\n            $customLayout->setName($values['name']);\n            $customLayout->setDescription($values['description']);\n            $customLayout->setDefault($values['default']);\n            $customLayout->save();\n\n            return $this->adminJson(['success' => true, 'id' => $customLayout->getId(), 'data' => $customLayout]);\n        } catch (\\Exception $e) {\n            Logger::error($e->getMessage());\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @Route(\"/save\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function saveAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n\n        $configuration = $this->decodeJson($request->get('configuration'));\n        $values = $this->decodeJson($request->get('values'));\n\n        // check if the class was changed during editing in the frontend\n        if ($class->getModificationDate() != $values['modificationDate']) {\n            throw new \\Exception('The class was modified during editing, please reload the class and make your changes again');\n        }\n\n        if ($values['name'] != $class->getName()) {\n            $classByName = DataObject\\ClassDefinition::getByName($values['name']);\n            if ($classByName && $classByName->getId() != $class->getId()) {\n                throw new \\Exception('Class name already exists');\n            }\n\n            $values['name'] = $this->correctClassname($values['name']);\n            $class->rename($values['name']);\n        }\n\n        unset($values['creationDate']);\n        unset($values['userOwner']);\n        unset($values['layoutDefinitions']);\n        unset($values['fieldDefinitions']);\n\n        $configuration['datatype'] = 'layout';\n        $configuration['fieldtype'] = 'panel';\n        $configuration['name'] = 'pimcore_root';\n\n        $class->setValues($values);\n\n        try {\n            $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($configuration, true);\n\n            $class->setLayoutDefinitions($layout);\n\n            $class->setUserModification($this->getAdminUser()->getId());\n            $class->setModificationDate(time());\n\n            $propertyVisibility = [];\n            foreach ($values as $key => $value) {\n                if (preg_match('/propertyVisibility/i', $key)) {\n                    if (preg_match(\"/\\.grid\\./i\", $key)) {\n                        $propertyVisibility['grid'][preg_replace(\"/propertyVisibility\\.grid\\./i\", '', $key)] = (bool) $value;\n                    } elseif (preg_match(\"/\\.search\\./i\", $key)) {\n                        $propertyVisibility['search'][preg_replace(\"/propertyVisibility\\.search\\./i\", '', $key)] = (bool) $value;\n                    }\n                }\n            }\n            if (!empty($propertyVisibility)) {\n                $class->setPropertyVisibility($propertyVisibility);\n            }\n\n            $class->save();\n\n            // set the fielddefinitions to null because we don't need them in the response\n            $class->setFieldDefinitions(null);\n\n            return $this->adminJson(['success' => true, 'class' => $class]);\n        } catch (\\Exception $e) {\n            Logger::error($e->getMessage());\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @param $name\n     *\n     * @return mixed\n     */\n    protected function correctClassname($name)\n    {\n        $name = preg_replace('/[^a-zA-Z0-9]+/', '', $name);\n        $name = preg_replace('/^[0-9]+/', '', $name);\n\n        return $name;\n    }\n\n    /**\n     * @Route(\"/import-class\", methods={\"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function importClassAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        $json = file_get_contents($_FILES['Filedata']['tmp_name']);\n\n        $success = DataObject\\ClassDefinition\\Service::importClassDefinitionFromJson($class, $json, false, true);\n\n        $response = $this->adminJson([\n            'success' => $success\n        ]);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/import-custom-layout-definition\", methods={\"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function importCustomLayoutDefinitionAction(Request $request)\n    {\n        $success = false;\n        $json = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $importData = $this->decodeJson($json);\n\n        $customLayoutId = $request->get('id');\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($customLayoutId);\n        if ($customLayout) {\n            try {\n                $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($importData['layoutDefinitions'], true);\n                $customLayout->setLayoutDefinitions($layout);\n                $customLayout->setDescription($importData['description']);\n                $customLayout->save();\n                $success = true;\n            } catch (\\Exception $e) {\n                Logger::error($e->getMessage());\n            }\n        }\n\n        $response = $this->adminJson([\n            'success' => $success\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-custom-layout-definitions\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getCustomLayoutDefinitionsAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $list = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n\n        $list->setCondition('classId = ' . $list->quote($classId));\n        $list = $list->load();\n        $result = [];\n        /** @var $item DataObject\\ClassDefinition\\CustomLayout */\n        foreach ($list as $item) {\n            $result[] = [\n                'id' => $item->getId(),\n                'name' => $item->getName() . ' (ID: ' . $item->getId() . ')',\n                'default' => $item->getDefault() ?: 0,\n            ];\n        }\n\n        return $this->adminJson(['success' => true, 'data' => $result]);\n    }\n\n    /**\n     * @Route(\"/get-all-layouts\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAllLayoutsAction(Request $request)\n    {\n        // get all classes\n        $resultList = [];\n        $mapping = [];\n\n        $customLayouts = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n        $customLayouts->setOrder('ASC');\n        $customLayouts->setOrderKey('name');\n        $customLayouts = $customLayouts->load();\n        foreach ($customLayouts as $layout) {\n            $mapping[$layout->getClassId()][] = $layout;\n        }\n\n        $classList = new DataObject\\ClassDefinition\\Listing();\n        $classList->setOrder('ASC');\n        $classList->setOrderKey('name');\n        $classList = $classList->load();\n\n        foreach ($classList as $class) {\n            $classMapping = $mapping[$class->getId()];\n            if ($classMapping) {\n                $resultList[] = [\n                    'type' => 'master',\n                    'id' => $class->getId() . '_' . 0,\n                    'name' => $class->getName()\n                ];\n\n                foreach ($classMapping as $layout) {\n                    $resultList[] = [\n                        'type' => 'custom',\n                        'id' => $class->getId() . '_' . $layout->getId(),\n                        'name' => $class->getName() . ' - ' . $layout->getName()\n                    ];\n                }\n            }\n        }\n\n        return $this->adminJson(['data' => $resultList]);\n    }\n\n    /**\n     * @Route(\"/export-class\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportClassAction(Request $request)\n    {\n        $id = $request->get('id');\n        $class = DataObject\\ClassDefinition::getById($id);\n\n        if (!$class instanceof DataObject\\ClassDefinition) {\n            $errorMessage = ': Class with id [ ' . $id . ' not found. ]';\n            Logger::error($errorMessage);\n            echo $errorMessage;\n        } else {\n            $json = DataObject\\ClassDefinition\\Service::generateClassDefinitionJson($class);\n\n            $response = new Response($json);\n            $response->headers->set('Content-type', 'application/json');\n            $response->headers->set('Content-Disposition', 'attachment; filename=\"class_' . $class->getName() . '_export.json\"');\n\n            return $response;\n        }\n    }\n\n    /**\n     * @Route(\"/export-custom-layout-definition\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportCustomLayoutDefinitionAction(Request $request)\n    {\n        $id = $request->get('id');\n\n        if ($id) {\n            $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($id);\n            if ($customLayout) {\n                $name = $customLayout->getName();\n                unset($customLayout->id);\n                unset($customLayout->classId);\n                unset($customLayout->name);\n                unset($customLayout->creationDate);\n                unset($customLayout->modificationDate);\n                unset($customLayout->userOwner);\n                unset($customLayout->userModification);\n                unset($customLayout->fieldDefinitions);\n\n                $json = json_encode($customLayout, JSON_PRETTY_PRINT);\n\n                $response = new Response($json);\n                $response->headers->set('Content-type', 'application/json');\n                $response->headers->set('Content-Disposition', 'attachment; filename=\"custom_definition_' . $name . '_export.json\"');\n\n                return $response;\n            }\n        }\n\n        $errorMessage = ': Custom Layout with id [ ' . $id . ' not found. ]';\n        Logger::error($errorMessage);\n        echo $errorMessage;\n    }\n\n    /**\n     * FIELDCOLLECTIONS\n     */\n\n    /**\n     * @Route(\"/fieldcollection-get\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionGetAction(Request $request)\n    {\n        $fc = DataObject\\Fieldcollection\\Definition::getByKey($request->get('id'));\n\n        return $this->adminJson($fc);\n    }\n\n    /**\n     * @Route(\"/fieldcollection-update\", methods={\"PUT\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionUpdateAction(Request $request)\n    {\n        try {\n            $key = $request->get('key');\n            $title = $request->get('title');\n            $group = $request->get('group');\n\n            if ($request->get('task') == 'add') {\n                // check for existing fieldcollection with same name with different lower/upper cases\n                $list = new DataObject\\Fieldcollection\\Definition\\Listing();\n                $list = $list->load();\n\n                foreach ($list as $item) {\n                    if (strtolower($key) === strtolower($item->getKey())) {\n                        throw new \\Exception('FieldCollection with the same name already exists (lower/upper cases may be different)');\n                    }\n                }\n            }\n\n            $fc = new DataObject\\Fieldcollection\\Definition();\n            $fc->setKey($key);\n            $fc->setTitle($title);\n            $fc->setGroup($group);\n\n            if ($request->get('values')) {\n                $values = $this->decodeJson($request->get('values'));\n                $fc->setParentClass($values['parentClass']);\n            }\n\n            if ($request->get('configuration')) {\n                $configuration = $this->decodeJson($request->get('configuration'));\n\n                $configuration['datatype'] = 'layout';\n                $configuration['fieldtype'] = 'panel';\n\n                $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($configuration, true);\n                $fc->setLayoutDefinitions($layout);\n            }\n\n            $fc->save();\n\n            return $this->adminJson(['success' => true, 'id' => $fc->getKey()]);\n        } catch (\\Exception $e) {\n            Logger::error($e->getMessage());\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @Route(\"/import-fieldcollection\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function importFieldcollectionAction(Request $request)\n    {\n        $fieldCollection = DataObject\\Fieldcollection\\Definition::getByKey($request->get('id'));\n\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n\n        $success = DataObject\\ClassDefinition\\Service::importFieldCollectionFromJson($fieldCollection, $data);\n\n        $response = $this->adminJson([\n            'success' => $success\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/export-fieldcollection\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportFieldcollectionAction(Request $request)\n    {\n        $fieldCollection = DataObject\\Fieldcollection\\Definition::getByKey($request->get('id'));\n        $key = $fieldCollection->getKey();\n        if (!$fieldCollection instanceof DataObject\\Fieldcollection\\Definition) {\n            $errorMessage = ': Field-Collection with id [ ' . $request->get('id') . ' not found. ]';\n            Logger::error($errorMessage);\n            echo $errorMessage;\n        } else {\n            $json = DataObject\\ClassDefinition\\Service::generateFieldCollectionJson($fieldCollection);\n            $response = new Response($json);\n            $response->headers->set('Content-type', 'application/json');\n            $response->headers->set('Content-Disposition', 'attachment; filename=\"fieldcollection_' . $key . '_export.json\"');\n\n            return $response;\n        }\n    }\n\n    /**\n     * @Route(\"/fieldcollection-delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionDeleteAction(Request $request)\n    {\n        $fc = DataObject\\Fieldcollection\\Definition::getByKey($request->get('id'));\n        $fc->delete();\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * @Route(\"/fieldcollection-tree\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionTreeAction(Request $request)\n    {\n        $list = new DataObject\\Fieldcollection\\Definition\\Listing();\n        $list = $list->load();\n\n        $forObjectEditor = $request->get('forObjectEditor');\n\n        $layoutDefinitions = [];\n\n        $definitions = [];\n\n        $allowedTypes = null;\n        if ($request->query->has('allowedTypes')) {\n            $allowedTypes = explode(',', $request->get('allowedTypes'));\n        }\n        $object = DataObject\\AbstractObject::getById($request->get('object_id'));\n\n        $groups = [];\n        /** @var $item DataObject\\Fieldcollection\\Definition */\n        foreach ($list as $item) {\n            if ($allowedTypes && !in_array($item->getKey(), $allowedTypes)) {\n                continue;\n            }\n\n            if ($item->getGroup()) {\n                if (!$groups[$item->getGroup()]) {\n                    $groups[$item->getGroup()] = [\n                        'id' => 'group_' . $item->getKey(),\n                        'text' => $item->getGroup(),\n                        'expandable' => true,\n                        'leaf' => false,\n                        'allowChildren' => true,\n                        'iconCls' => 'pimcore_icon_folder',\n                        'group' => $item->getGroup(),\n                        'children' => []\n                    ];\n                }\n                if ($forObjectEditor) {\n                    $itemLayoutDefinitions = $item->getLayoutDefinitions();\n                    DataObject\\Service::enrichLayoutDefinition($itemLayoutDefinitions, $object);\n                    $layoutDefinitions[$item->getKey()] = $itemLayoutDefinitions;\n                }\n                $groups[$item->getGroup()]['children'][] =\n                    [\n                        'id' => $item->getKey(),\n                        'text' => $item->getKey(),\n                        'title' => $item->getTitle(),\n                        'key' => $item->getKey(),\n                        'leaf' => true,\n                        'iconCls' => 'pimcore_icon_fieldcollection'\n                    ];\n            } else {\n                if ($forObjectEditor) {\n                    $itemLayoutDefinitions = $item->getLayoutDefinitions();\n                    DataObject\\Service::enrichLayoutDefinition($itemLayoutDefinitions, $object);\n                    $layoutDefinitions[$item->getKey()] = $itemLayoutDefinitions;\n                }\n                $definitions[] = [\n                    'id' => $item->getKey(),\n                    'text' => $item->getKey(),\n                    'title' => $item->getTitle(),\n                    'key' => $item->getKey(),\n                    'leaf' => true,\n                    'iconCls' => 'pimcore_icon_fieldcollection'\n                ];\n            }\n        }\n\n        foreach ($groups as $group) {\n            $definitions[] = $group;\n        }\n\n        $event = new GenericEvent($this, [\n            'list' => $definitions,\n            'objectId' => $request->get('object_id')\n        ]);\n        \\Pimcore::getEventDispatcher()->dispatch(AdminEvents::CLASS_FIELDCOLLECTION_LIST_PRE_SEND_DATA, $event);\n        $definitions = $event->getArgument('list');\n\n        if ($forObjectEditor) {\n            return $this->adminJson(['fieldcollections' => $definitions, 'layoutDefinitions' => $layoutDefinitions]);\n        } else {\n            return $this->adminJson($definitions);\n        }\n    }\n\n    /**\n     * @Route(\"/fieldcollection-list\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionListAction(Request $request)\n    {\n        $user = \\Pimcore\\Tool\\Admin::getCurrentUser();\n        $currentLayoutId = $request->get('layoutId');\n\n        $list = new DataObject\\Fieldcollection\\Definition\\Listing();\n        $list = $list->load();\n\n        if ($request->query->has('allowedTypes')) {\n            $filteredList = [];\n            $allowedTypes = explode(',', $request->get('allowedTypes'));\n            /** @var $type DataObject\\Fieldcollection\\Definition */\n            foreach ($list as $type) {\n                if (in_array($type->getKey(), $allowedTypes)) {\n                    $filteredList[] = $type;\n\n                    // mainly for objects-meta data-type\n                    $layoutDefinitions = $type->getLayoutDefinitions();\n                    $context = [\n                        'containerType' => 'fieldcollection',\n                        'containerKey' => $type->getKey(),\n                        'outerFieldname' => $request->get('field_name')\n                    ];\n\n                    $object = DataObject\\AbstractObject::getById($request->get('object_id'));\n\n                    DataObject\\Service::enrichLayoutDefinition($layoutDefinitions, $object, $context);\n\n                    if ($currentLayoutId == -1 && $user->isAdmin()) {\n                        DataObject\\Service::createSuperLayout($layoutDefinitions);\n                    }\n                }\n            }\n\n            $list = $filteredList;\n        }\n\n        $event = new GenericEvent($this, [\n            'list' => $list,\n            'objectId' => $request->get('object_id')\n        ]);\n        \\Pimcore::getEventDispatcher()->dispatch(AdminEvents::CLASS_FIELDCOLLECTION_LIST_PRE_SEND_DATA, $event);\n        $list = $event->getArgument('list');\n\n        return $this->adminJson(['fieldcollections' => $list]);\n    }\n\n    /**\n     * @Route(\"/get-class-definition-for-column-config\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getClassDefinitionForColumnConfigAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        $objectId = intval($request->get('oid'));\n\n        $filteredDefinitions = DataObject\\Service::getCustomLayoutDefinitionForGridColumnConfig($class, $objectId);\n\n        $layoutDefinitions = isset($filteredDefinitions['layoutDefinition']) ? $filteredDefinitions['layoutDefinition'] : false;\n        $filteredFieldDefinition = isset($filteredDefinitions['fieldDefinition']) ? $filteredDefinitions['fieldDefinition'] : false;\n\n        $class->setFieldDefinitions(null);\n\n        $result = [];\n\n        $result['objectColumns']['childs'] = $layoutDefinitions->getChilds();\n        $result['objectColumns']['nodeLabel'] = 'object_columns';\n        $result['objectColumns']['nodeType'] = 'object';\n\n        // array(\"id\", \"fullpath\", \"published\", \"creationDate\", \"modificationDate\", \"filename\", \"classname\");\n        $systemColumnNames = DataObject\\Concrete::$systemColumnNames;\n        $systemColumns = [];\n        foreach ($systemColumnNames as $systemColumn) {\n            $systemColumns[] = ['title' => $systemColumn, 'name' => $systemColumn, 'datatype' => 'data', 'fieldtype' => 'system'];\n        }\n        $result['systemColumns']['nodeLabel'] = 'system_columns';\n        $result['systemColumns']['nodeType'] = 'system';\n        $result['systemColumns']['childs'] = $systemColumns;\n\n        $list = new DataObject\\Objectbrick\\Definition\\Listing();\n        $list = $list->load();\n\n        foreach ($list as $brickDefinition) {\n            $classDefs = $brickDefinition->getClassDefinitions();\n            if (!empty($classDefs)) {\n                foreach ($classDefs as $classDef) {\n                    if ($classDef['classname'] == $class->getName()) {\n                        $fieldName = $classDef['fieldname'];\n                        if ($filteredFieldDefinition && !$filteredFieldDefinition[$fieldName]) {\n                            continue;\n                        }\n\n                        $key = $brickDefinition->getKey();\n\n                        $result[$key]['nodeLabel'] = $key;\n                        $result[$key]['brickField'] = $fieldName;\n                        $result[$key]['nodeType'] = 'objectbricks';\n                        $result[$key]['childs'] = $brickDefinition->getLayoutdefinitions()->getChilds();\n                        break;\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * OBJECT BRICKS\n     */\n\n    /**\n     * @Route(\"/objectbrick-get\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickGetAction(Request $request)\n    {\n        $fc = DataObject\\Objectbrick\\Definition::getByKey($request->get('id'));\n\n        return $this->adminJson($fc);\n    }\n\n    /**\n     * @Route(\"/objectbrick-update\", methods={\"PUT\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickUpdateAction(Request $request)\n    {\n        try {\n            $key = $request->get('key');\n            $title = $request->get('title');\n            $group = $request->get('group');\n\n            if ($request->get('task') == 'add') {\n                // check for existing brick with same name with different lower/upper cases\n                $list = new DataObject\\Objectbrick\\Definition\\Listing();\n                $list = $list->load();\n\n                foreach ($list as $item) {\n                    if (strtolower($key) === strtolower($item->getKey())) {\n                        throw new \\Exception('Brick with the same name already exists (lower/upper cases may be different)');\n                    }\n                }\n            }\n\n            // now we create a new definition\n            $fc = new DataObject\\Objectbrick\\Definition();\n            $fc->setKey($key);\n            $fc->setTitle($title);\n            $fc->setGroup($group);\n\n            if ($request->get('values')) {\n                $values = $this->decodeJson($request->get('values'));\n\n                $fc->setParentClass($values['parentClass']);\n                $fc->setClassDefinitions($values['classDefinitions']);\n            }\n\n            if ($request->get('configuration')) {\n                $configuration = $this->decodeJson($request->get('configuration'));\n\n                $configuration['datatype'] = 'layout';\n                $configuration['fieldtype'] = 'panel';\n\n                $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($configuration, true);\n                $fc->setLayoutDefinitions($layout);\n            }\n\n            $fc->save();\n\n            return $this->adminJson(['success' => true, 'id' => $fc->getKey()]);\n        } catch (\\Exception $e) {\n            Logger::error($e->getMessage());\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @Route(\"/import-objectbrick\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importObjectbrickAction(Request $request)\n    {\n        $objectBrick = DataObject\\Objectbrick\\Definition::getByKey($request->get('id'));\n\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $success = DataObject\\ClassDefinition\\Service::importObjectBrickFromJson($objectBrick, $data);\n\n        $response = $this->adminJson([\n            'success' => $success\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/export-objectbrick\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportObjectbrickAction(Request $request)\n    {\n        $objectBrick = DataObject\\Objectbrick\\Definition::getByKey($request->get('id'));\n        $key = $objectBrick->getKey();\n        if (!$objectBrick instanceof DataObject\\Objectbrick\\Definition) {\n            $errorMessage = ': Object-Brick with id [ ' . $request->get('id') . ' not found. ]';\n            Logger::error($errorMessage);\n            echo $errorMessage;\n        } else {\n            $xml = DataObject\\ClassDefinition\\Service::generateObjectBrickJson($objectBrick);\n            $response = new Response($xml);\n            $response->headers->set('Content-type', 'application/json');\n            $response->headers->set('Content-Disposition', 'attachment; filename=\"objectbrick_' . $key . '_export.json\"');\n\n            return $response;\n        }\n    }\n\n    /**\n     * @Route(\"/objectbrick-delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickDeleteAction(Request $request)\n    {\n        $fc = DataObject\\Objectbrick\\Definition::getByKey($request->get('id'));\n        $fc->delete();\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * @Route(\"/objectbrick-tree\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickTreeAction(Request $request)\n    {\n        $list = new DataObject\\Objectbrick\\Definition\\Listing();\n        $list = $list->load();\n\n        $forObjectEditor = $request->get('forObjectEditor');\n\n        $layoutDefinitions = [];\n        $groups = [];\n        $definitions = [];\n\n        if ($request->query->has('class_id') && $request->query->has('field_name')) {\n            $classId = $request->get('class_id');\n            $fieldname = $request->get('field_name');\n            $classDefinition = DataObject\\ClassDefinition::getById($classId);\n            $className = $classDefinition->getName();\n        }\n\n        /** @var $item DataObject\\Objectbrick\\Definition */\n        foreach ($list as $item) {\n            if ($request->query->has('class_id') && $request->query->has('field_name')) {\n                $keep = false;\n                /** @var $type DataObject\\Objectbrick\\Definition */\n                $clsDefs = $item->getClassDefinitions();\n                if (!empty($clsDefs)) {\n                    foreach ($clsDefs as $cd) {\n                        if ($cd['classname'] == $className && $cd['fieldname'] == $fieldname) {\n                            $keep = true;\n                            continue;\n                        }\n                    }\n                }\n                if (!$keep) {\n                    continue;\n                }\n            }\n\n            if ($item->getGroup()) {\n                if (!$groups[$item->getGroup()]) {\n                    $groups[$item->getGroup()] = [\n                        'id' => 'group_' . $item->getKey(),\n                        'text' => $item->getGroup(),\n                        'expandable' => true,\n                        'leaf' => false,\n                        'allowChildren' => true,\n                        'iconCls' => 'pimcore_icon_folder',\n                        'group' => $item->getGroup(),\n                        'children' => []\n                    ];\n                }\n                if ($forObjectEditor) {\n                    $layoutDefinitions[$item->getKey()] = $item->getLayoutDefinitions();\n                }\n                $groups[$item->getGroup()]['children'][] =\n                    [\n                        'id' => $item->getKey(),\n                        'text' => $item->getKey(),\n                        'title' => $item->getTitle(),\n                        'key' => $item->getKey(),\n                        'leaf' => true,\n                        'iconCls' => 'pimcore_icon_objectbricks'\n                    ];\n            } else {\n                if ($forObjectEditor) {\n                    $layout = $item->getLayoutDefinitions();\n\n                    $currentLayoutId = $request->get('layoutId', null);\n\n                    $user = $this->getAdminUser();\n                    if ($currentLayoutId == -1 && $user->isAdmin()) {\n                        DataObject\\Service::createSuperLayout($layout);\n                        $objectData['layout'] = $layout;\n                    }\n\n                    $context = [\n                        'containerType' => 'objectbrick',\n                        'containerKey' => $item->getKey(),\n                        'outerFieldname' => $request->get('field_name')\n                    ];\n\n                    $object = DataObject\\AbstractObject::getById($request->get('object_id'));\n\n                    DataObject\\Service::enrichLayoutDefinition($layout, $object, $context);\n\n                    $layoutDefinitions[$item->getKey()] = $layout;\n                }\n                $definitions[] = [\n                    'id' => $item->getKey(),\n                    'text' => $item->getKey(),\n                    'title' => $item->getTitle(),\n                    'key' => $item->getKey(),\n                    'leaf' => true,\n                    'iconCls' => 'pimcore_icon_objectbricks'\n                ];\n            }\n        }\n\n        foreach ($groups as $group) {\n            $definitions[] = $group;\n        }\n\n        $event = new GenericEvent($this, [\n            'list' => $definitions,\n            'objectId' => $request->get('object_id')\n        ]);\n        \\Pimcore::getEventDispatcher()->dispatch(AdminEvents::CLASS_OBJECTBRICK_LIST_PRE_SEND_DATA, $event);\n        $definitions = $event->getArgument('list');\n\n        if ($forObjectEditor) {\n            return $this->adminJson(['objectbricks' => $definitions, 'layoutDefinitions' => $layoutDefinitions]);\n        } else {\n            return $this->adminJson($definitions);\n        }\n    }\n\n    /**\n     * @Route(\"/objectbrick-list\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickListAction(Request $request)\n    {\n        $list = new DataObject\\Objectbrick\\Definition\\Listing();\n        $list = $list->load();\n\n        if ($request->query->has('class_id') && $request->query->has('field_name')) {\n            $filteredList = [];\n            $classId = $request->get('class_id');\n            $fieldname = $request->get('field_name');\n            $classDefinition = DataObject\\ClassDefinition::getById($classId);\n            $className = $classDefinition->getName();\n\n            foreach ($list as $type) {\n                /** @var $type DataObject\\Objectbrick\\Definition */\n                $clsDefs = $type->getClassDefinitions();\n                if (!empty($clsDefs)) {\n                    foreach ($clsDefs as $cd) {\n                        if ($cd['classname'] == $className && $cd['fieldname'] == $fieldname) {\n                            $filteredList[] = $type;\n                            continue;\n                        }\n                    }\n                }\n\n                $layout = $type->getLayoutDefinitions();\n\n                $currentLayoutId = $request->get('layoutId', null);\n\n                $user = $this->getAdminUser();\n                if ($currentLayoutId == -1 && $user->isAdmin()) {\n                    DataObject\\Service::createSuperLayout($layout);\n                    $objectData['layout'] = $layout;\n                }\n\n                $context = [\n                    'containerType' => 'objectbrick',\n                    'containerKey' => $type->getKey(),\n                    'outerFieldname' => $request->get('field_name')\n                ];\n\n                $object = DataObject\\AbstractObject::getById($request->get('object_id'));\n\n                DataObject\\Service::enrichLayoutDefinition($layout, $object, $context);\n                $type->setLayoutDefinitions($layout);\n            }\n\n            $list = $filteredList;\n        }\n\n        $event = new GenericEvent($this, [\n            'list' => $list,\n            'objectId' => $request->get('object_id')\n        ]);\n        \\Pimcore::getEventDispatcher()->dispatch(AdminEvents::CLASS_OBJECTBRICK_LIST_PRE_SEND_DATA, $event);\n        $list = $event->getArgument('list');\n\n        return $this->adminJson(['objectbricks' => $list]);\n    }\n\n    /**\n     * See http://www.pimcore.org/issues/browse/PIMCORE-2358\n     * Add option to export/import all class definitions/brick definitions etc. at once\n     */\n\n    /**\n     * @Route(\"/bulk-import\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function bulkImportAction(Request $request)\n    {\n        $result = [];\n\n        $tmpName = $_FILES['Filedata']['tmp_name'];\n        $json = file_get_contents($tmpName);\n\n        $tmpName = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/bulk-import.tmp';\n        file_put_contents($tmpName, $json);\n\n        $json = json_decode($json, true);\n\n        foreach ($json as $groupName => $group) {\n            foreach ($group as $groupItem) {\n                $displayName = null;\n\n                if ($groupName == 'class') {\n                    $name = $groupItem['name'];\n                    $icon = 'class';\n                } elseif ($groupName == 'customlayout') {\n                    $className = $groupItem['className'];\n\n                    $layoutData = ['className' => $className, 'name' => $groupItem['name']];\n                    $name = serialize($layoutData);\n                    $displayName = $className . ' / ' . $groupItem['name'];\n                    $icon = 'database_lightning';\n                } else {\n                    if ($groupName == 'objectbrick') {\n                        $icon = 'objectbricks';\n                    } elseif ($groupName == 'fieldcollection') {\n                        $icon = 'fieldcollection';\n                    }\n                    $name = $groupItem['key'];\n                }\n\n                if (!$displayName) {\n                    $displayName = $name;\n                }\n                $result[] = ['icon' => $icon, 'checked' => true, 'type' => $groupName, 'name' => $name, 'displayName' => $displayName];\n            }\n        }\n\n        $response = $this->adminJson(['success' => true, 'filename' => $tmpName, 'data' => $result]);\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * See http://www.pimcore.org/issues/browse/PIMCORE-2358\n     * Add option to export/import all class definitions/brick definitions etc. at once\n     */\n\n    /**\n     * @Route(\"/bulk-commit\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function bulkCommitAction(Request $request)\n    {\n        $filename = $request->get('filename');\n        $data = json_decode($request->get('data'), true);\n\n        $json = @file_get_contents($filename);\n        $json = json_decode($json, true);\n\n        $type = $data['type'];\n        $name = $data['name'];\n        $list = $json[$type];\n\n        foreach ($list as $item) {\n            unset($item['creationDate']);\n            unset($item['modificationDate']);\n            unset($item['userOwner']);\n            unset($item['userModification']);\n\n            if ($type == 'class' && $item['name'] == $name) {\n                $class = DataObject\\ClassDefinition::getByName($name);\n                if (!$class) {\n                    $class = new DataObject\\ClassDefinition();\n                    $class->setName($name);\n                }\n                $success = DataObject\\ClassDefinition\\Service::importClassDefinitionFromJson($class, json_encode($item), true);\n\n                return $this->adminJson(['success' => $success !== false]);\n            } elseif ($type == 'objectbrick' && $item['key'] == $name) {\n                try {\n                    $brick = DataObject\\Objectbrick\\Definition::getByKey($name);\n                } catch (\\Exception $e) {\n                    $brick = new DataObject\\Objectbrick\\Definition();\n                    $brick->setKey($name);\n                }\n\n                $success = DataObject\\ClassDefinition\\Service::importObjectBrickFromJson($brick, json_encode($item), true);\n\n                return $this->adminJson(['success' => $success !== false]);\n            } elseif ($type == 'fieldcollection' && $item['key'] == $name) {\n                try {\n                    $fieldCollection = DataObject\\Fieldcollection\\Definition::getByKey($name);\n                } catch (\\Exception $e) {\n                    $fieldCollection = new DataObject\\Fieldcollection\\Definition();\n                    $fieldCollection->setKey($name);\n                }\n                $success = DataObject\\ClassDefinition\\Service::importFieldCollectionFromJson($fieldCollection, json_encode($item), true);\n\n                return $this->adminJson(['success' => $success !== false]);\n            } elseif ($type == 'customlayout') {\n                $layoutData = unserialize($data['name']);\n                $className = $layoutData['className'];\n                $layoutName = $layoutData['name'];\n\n                if ($item['name'] == $layoutName && $item['className'] == $className) {\n                    $class = DataObject\\ClassDefinition::getByName($className);\n                    if (!$class) {\n                        throw new \\Exception('Class does not exist');\n                    }\n\n                    $classId = $class->getId();\n\n                    $layoutList = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n                    $db = \\Pimcore\\Db::get();\n                    $layoutList->setCondition('name = ' . $db->quote($layoutName) . ' AND classId = ' . $classId);\n                    $layoutList = $layoutList->load();\n\n                    $layoutDefinition = null;\n                    if ($layoutList) {\n                        $layoutDefinition = $layoutList[0];\n                    }\n\n                    if (!$layoutDefinition) {\n                        $layoutDefinition = new DataObject\\ClassDefinition\\CustomLayout();\n                        $layoutDefinition->setName($layoutName);\n                        $layoutDefinition->setClassId($classId);\n                    }\n\n                    try {\n                        $layoutDefinition->setDescription($item['description']);\n                        $layoutDef = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($item['layoutDefinitions'], true);\n                        $layoutDefinition->setLayoutDefinitions($layoutDef);\n                        $layoutDefinition->save();\n                    } catch (\\Exception $e) {\n                        Logger::error($e->getMessage());\n\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * See http://www.pimcore.org/issues/browse/PIMCORE-2358\n     * Add option to export/import all class definitions/brick definitions etc. at once\n     */\n\n    /**\n     * @Route(\"/bulk-export\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function bulkExportAction(Request $request)\n    {\n        $result = [];\n\n        $fieldCollections = new DataObject\\Fieldcollection\\Definition\\Listing();\n        $fieldCollections = $fieldCollections->load();\n\n        foreach ($fieldCollections as $fieldCollection) {\n            $key = $fieldCollection->key;\n            $fieldCollectionJson = json_decode(DataObject\\ClassDefinition\\Service::generateFieldCollectionJson($fieldCollection));\n            $fieldCollectionJson->key = $key;\n            $result['fieldcollection'][] = $fieldCollectionJson;\n        }\n\n        $classes = new DataObject\\ClassDefinition\\Listing();\n        $classes->setOrder('ASC');\n        $classes->setOrderKey('id');\n        $classes = $classes->load();\n\n        foreach ($classes as $class) {\n            $data = Model\\Webservice\\Data\\Mapper::map($class, '\\\\Pimcore\\\\Model\\\\Webservice\\\\Data\\\\ClassDefinition\\\\Out', 'out');\n            unset($data->fieldDefinitions);\n            $result['class'][] = $data;\n        }\n\n        $objectBricks = new DataObject\\Objectbrick\\Definition\\Listing();\n        $objectBricks = $objectBricks->load();\n\n        foreach ($objectBricks as $objectBrick) {\n            $key = $objectBrick->key;\n            $objectBrickJson = json_decode(DataObject\\ClassDefinition\\Service::generateObjectBrickJson($objectBrick));\n            $objectBrickJson->key = $key;\n            $result['objectbrick'][] = $objectBrickJson;\n        }\n\n        $customLayouts = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n        $customLayouts = $customLayouts->load();\n        foreach ($customLayouts as $customLayout) {\n            /** @var $customLayout DataObject\\ClassDefinition\\CustomLayout */\n            $classId = $customLayout->getClassId();\n            $class = DataObject\\ClassDefinition::getById($classId);\n            $customLayout->className = $class->getName();\n            $result['customlayout'][] = $customLayout;\n        }\n\n        $result = json_encode($result, JSON_PRETTY_PRINT);\n        $response = new Response($result);\n        $response->headers->set('Content-type', 'application/json');\n        $response->headers->set('Content-Disposition', 'attachment; filename=\"bulk_export.json\"');\n\n        return $response;\n    }\n\n    /**\n     * @param FilterControllerEvent $event\n     */\n    public function onKernelController(FilterControllerEvent $event)\n    {\n        $isMasterRequest = $event->isMasterRequest();\n        if (!$isMasterRequest) {\n            return;\n        }\n\n        // check permissions\n        $unrestrictedActions = [\n            'getTreeAction', 'fieldcollectionListAction', 'fieldcollectionTreeAction', 'fieldcollectionGetAction',\n            'getClassDefinitionForColumnConfigAction', 'objectbrickListAction', 'objectbrickTreeAction', 'objectbrickGetAction'\n        ];\n\n        $this->checkActionPermission($event, 'classes', $unrestrictedActions);\n    }\n\n    /**\n     * @param FilterResponseEvent $event\n     */\n    public function onKernelResponse(FilterResponseEvent $event)\n    {\n        // nothing to do\n    }\n\n    /**\n     * @Route(\"/get-fieldcollection-usages\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function getFieldcollectionUsagesAction(Request $request)\n    {\n        $key = $request->get('key');\n        $result = [];\n\n        $classes = new DataObject\\ClassDefinition\\Listing();\n        $classes = $classes->load();\n        foreach ($classes as $class) {\n            $fieldDefs = $class->getFieldDefinitions();\n            foreach ($fieldDefs as $fieldDef) {\n                if ($fieldDef instanceof DataObject\\ClassDefinition\\Data\\Fieldcollections) {\n                    $allowedKeys = $fieldDef->getAllowedTypes();\n                    if (is_array($allowedKeys) && in_array($key, $allowedKeys)) {\n                        $result[] = [\n                            'class' => $class->getName(),\n                            'field' => $fieldDef->getName()\n                        ];\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/get-bricks-usages\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function getBrickUsagesAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $myclass = DataObject\\ClassDefinition::getById($classId);\n\n        $result = [];\n\n        $brickDefinitions = new DataObject\\Objectbrick\\Definition\\Listing();\n        $brickDefinitions = $brickDefinitions->load();\n        foreach ($brickDefinitions as $brickDefinition) {\n            $classes = $brickDefinition->getClassDefinitions();\n            foreach ($classes as $class) {\n                if ($myclass->getName() == $class['classname']) {\n                    $result[] = [\n                        'objectbrick' => $brickDefinition->getKey(),\n                        'field' => $class['fieldname']\n                    ];\n                }\n            }\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/suggest-class-identifier\")\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function suggestClassIdentifierAction()\n    {\n        $db = Db::get();\n        $maxId = $db->fetchOne('SELECT MAX(CAST(id AS SIGNED)) FROM classes;');\n\n        $existingIds = $db->fetchCol('select LOWER(id) from classes');\n\n        $result = [\n            'suggestedIdentifier' => $maxId ? $maxId + 1 : 1,\n            'existingIds' => $existingIds\n            ];\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/suggest-custom-layout-identifier\")\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function suggestCustomLayoutIdentifierAction(Request $request)\n    {\n        $classId = $request->get('classId');\n\n        $identifier = DataObject\\ClassDefinition\\CustomLayout::getIdentifier($classId);\n\n        $list = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n\n        $list = $list->load();\n        $existingIds = [];\n        $existingNames = [];\n\n        /** @var $item DataObject\\ClassDefinition\\CustomLayout */\n        foreach ($list as $item) {\n            $existingIds[] = $item->getId();\n            if ($item->getClassId() == $classId) {\n                $existingNames[] = $item->getName();\n            }\n        }\n\n        $result = [\n            'suggestedIdentifier' => $identifier,\n            'existingIds' => $existingIds,\n            'existingNames' => $existingNames\n            ];\n\n        return $this->adminJson($result);\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Enterprise License (PEL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PEL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\DataObject;\n\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\HttpFoundation\\JsonResponse;\nuse Pimcore\\Controller\\EventedControllerInterface;\nuse Pimcore\\Db;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\Logger;\nuse Pimcore\\Model;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\Document;\nuse Pimcore\\Tool\\Session;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\HttpKernel\\Event\\FilterControllerEvent;\nuse Symfony\\Component\\HttpKernel\\Event\\FilterResponseEvent;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\n/**\n * @Route(\"/class\")\n */\nclass ClassController extends AdminController implements EventedControllerInterface\n{\n    /**\n     * @Route(\"/get-document-types\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getDocumentTypesAction(Request $request)\n    {\n        $documentTypes = Document::getTypes();\n        $typeItems = [];\n        foreach ($documentTypes as $documentType) {\n            $typeItems[] = [\n                'text' => $documentType\n            ];\n        }\n\n        return $this->adminJson($typeItems);\n    }\n\n    /**\n     * @Route(\"/get-asset-types\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAssetTypesAction(Request $request)\n    {\n        $assetTypes = Asset::getTypes();\n        $typeItems = [];\n        foreach ($assetTypes as $assetType) {\n            $typeItems[] = [\n                'text' => $assetType\n            ];\n        }\n\n        return $this->adminJson($typeItems);\n    }\n\n    /**\n     * @Route(\"/get-tree\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getTreeAction(Request $request)\n    {\n        $defaultIcon = '/bundles/pimcoreadmin/img/flat-color-icons/timeline.svg';\n\n        $classesList = new DataObject\\ClassDefinition\\Listing();\n        $classesList->setOrderKey('name');\n        $classesList->setOrder('asc');\n        $classes = $classesList->load();\n\n        // filter classes\n        if ($request->get('createAllowed')) {\n            $tmpClasses = [];\n            foreach ($classes as $class) {\n                if ($this->getAdminUser()->isAllowed($class->getId(), 'class')) {\n                    $tmpClasses[] = $class;\n                }\n            }\n            $classes = $tmpClasses;\n        }\n\n        $withId = $request->get('withId');\n        $getClassConfig = function ($class) use ($defaultIcon, $withId) {\n            $text = $class->getname();\n            if ($withId) {\n                $text .= ' (' . $class->getId() . ')';\n            }\n\n            return [\n                'id' => $class->getId(),\n                'text' => $text,\n                'leaf' => true,\n                'icon' => $class->getIcon() ? $class->getIcon() : $defaultIcon,\n                'cls' => 'pimcore_class_icon',\n                'propertyVisibility' => $class->getPropertyVisibility()\n            ];\n        };\n\n        // build groups\n        $groups = [];\n        foreach ($classes as $class) {\n            if (!$class) {\n                continue;\n            }\n            if ($class->getGroup()) {\n                $type = 'manual';\n                $groupName = $class->getGroup();\n            } else {\n                $type = 'auto';\n                preg_match('@^([A-Za-z])([^A-Z]+)@', $class->getName(), $matches);\n                $groupName = $matches[0];\n\n                if (!$groupName) {\n                    // this is eg. the case when class name uses only capital letters\n                    $groupName = $class->getName();\n                }\n            }\n\n            $groupName = \\Pimcore\\Model\\Translation\\Admin::getByKeyLocalized($groupName, true, true);\n\n            if (!isset($groups[$groupName])) {\n                $groups[$groupName] = [\n                    'classes' => [],\n                    'type' => $type\n                ];\n            }\n            $groups[$groupName]['classes'][] = $class;\n        }\n\n        $treeNodes = [];\n\n        if (!$request->get('grouped')) {\n            // list output\n            foreach ($groups as $groupName => $groupData) {\n                foreach ($groupData['classes'] as $class) {\n                    $node = $getClassConfig($class);\n                    if (count($groupData['classes']) > 1 || $groupData['type'] == 'manual') {\n                        $node['group'] = $groupName;\n                    }\n                    $treeNodes[] = $node;\n                }\n            }\n        } else {\n            // create json output\n            foreach ($groups as $groupName => $groupData) {\n                if (count($groupData['classes']) === 1 && $groupData['type'] == 'auto') {\n                    // no group, only one child\n                    $node = $getClassConfig($groupData['classes'][0]);\n                } else {\n                    // group classes\n                    $node = [\n                        'id' => 'folder_' . $groupName,\n                        'text' => $groupName,\n                        'leaf' => false,\n                        'expandable' => true,\n                        'allowChildren' => true,\n                        'iconCls' => 'pimcore_icon_folder',\n                        'children' => []\n                    ];\n\n                    foreach ($groupData['classes'] as $class) {\n                        $node['children'][] = $getClassConfig($class);\n                    }\n                }\n\n                $treeNodes[] = $node;\n            }\n        }\n\n        return $this->adminJson($treeNodes);\n    }\n\n    /**\n     * @Route(\"/get\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        $class->setFieldDefinitions(null);\n\n        return $this->adminJson($class);\n    }\n\n    /**\n     * @Route(\"/get-custom-layout\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getCustomLayoutAction(Request $request)\n    {\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($request->get('id'));\n\n        return $this->adminJson(['success' => true, 'data' => $customLayout]);\n    }\n\n    /**\n     * @Route(\"/add\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addAction(Request $request)\n    {\n        $className = $request->get('className');\n        $className = $this->correctClassname($className);\n\n        $classId = $request->get('classIdentifier');\n        $existingClass = DataObject\\ClassDefinition::getById($classId);\n        if ($existingClass) {\n            throw new \\Exception('Class identifier already exists');\n        }\n\n        $class = DataObject\\ClassDefinition::create(\n            ['name' => $className,\n                'userOwner' => $this->getAdminUser()->getId()]\n        );\n\n        $class->setId($classId);\n\n        $class->save(true);\n\n        return $this->adminJson(['success' => true, 'id' => $class->getId()]);\n    }\n\n    /**\n     * @Route(\"/add-custom-layout\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addCustomLayoutAction(Request $request)\n    {\n        $layoutId = $request->get('layoutIdentifier');\n        $existingLayout = DataObject\\ClassDefinition\\CustomLayout::getById($layoutId);\n        if ($existingLayout) {\n            throw new \\Exception('Custom Layout identifier already exists');\n        }\n\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::create(\n            [\n                'name' => $request->get('layoutName'),\n                'userOwner' => $this->getAdminUser()->getId(),\n                'classId' => $request->get('classId')\n            ]\n        );\n\n        $customLayout->setId($layoutId);\n        $customLayout->save();\n\n        return $this->adminJson(['success' => true, 'id' => $customLayout->getId(), 'name' => $customLayout->getName(),\n                                 'data' => $customLayout]);\n    }\n\n    /**\n     * @Route(\"/delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function deleteAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        $class->delete();\n\n        return new Response();\n    }\n\n    /**\n     * @Route(\"/delete-custom-layout\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteCustomLayoutAction(Request $request)\n    {\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($request->get('id'));\n        if ($customLayout) {\n            $customLayout->delete();\n        }\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * @Route(\"/save-custom-layout\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function saveCustomLayoutAction(Request $request)\n    {\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($request->get('id'));\n        $class = DataObject\\ClassDefinition::getById($customLayout->getClassId());\n\n        $configuration = $this->decodeJson($request->get('configuration'));\n        $values = $this->decodeJson($request->get('values'));\n\n        $modificationDate = intval($values['modificationDate']);\n        if ($modificationDate < $customLayout->getModificationDate()) {\n            return $this->adminJson(['success' => false, 'msg' => 'custom_layout_changed']);\n        }\n\n        $configuration['datatype'] = 'layout';\n        $configuration['fieldtype'] = 'panel';\n        $configuration['name'] = 'pimcore_root';\n\n        try {\n            $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($configuration, true);\n            $customLayout->setLayoutDefinitions($layout);\n            $customLayout->setName($values['name']);\n            $customLayout->setDescription($values['description']);\n            $customLayout->setDefault($values['default']);\n            $customLayout->save();\n\n            return $this->adminJson(['success' => true, 'id' => $customLayout->getId(), 'data' => $customLayout]);\n        } catch (\\Exception $e) {\n            Logger::error($e->getMessage());\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @Route(\"/save\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function saveAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n\n        $configuration = $this->decodeJson($request->get('configuration'));\n        $values = $this->decodeJson($request->get('values'));\n\n        // check if the class was changed during editing in the frontend\n        if ($class->getModificationDate() != $values['modificationDate']) {\n            throw new \\Exception('The class was modified during editing, please reload the class and make your changes again');\n        }\n\n        if ($values['name'] != $class->getName()) {\n            $classByName = DataObject\\ClassDefinition::getByName($values['name']);\n            if ($classByName && $classByName->getId() != $class->getId()) {\n                throw new \\Exception('Class name already exists');\n            }\n\n            $values['name'] = $this->correctClassname($values['name']);\n            $class->rename($values['name']);\n        }\n\n        unset($values['creationDate']);\n        unset($values['userOwner']);\n        unset($values['layoutDefinitions']);\n        unset($values['fieldDefinitions']);\n\n        $configuration['datatype'] = 'layout';\n        $configuration['fieldtype'] = 'panel';\n        $configuration['name'] = 'pimcore_root';\n\n        $class->setValues($values);\n\n        try {\n            $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($configuration, true);\n\n            $class->setLayoutDefinitions($layout);\n\n            $class->setUserModification($this->getAdminUser()->getId());\n            $class->setModificationDate(time());\n\n            $propertyVisibility = [];\n            foreach ($values as $key => $value) {\n                if (preg_match('/propertyVisibility/i', $key)) {\n                    if (preg_match(\"/\\.grid\\./i\", $key)) {\n                        $propertyVisibility['grid'][preg_replace(\"/propertyVisibility\\.grid\\./i\", '', $key)] = (bool) $value;\n                    } elseif (preg_match(\"/\\.search\\./i\", $key)) {\n                        $propertyVisibility['search'][preg_replace(\"/propertyVisibility\\.search\\./i\", '', $key)] = (bool) $value;\n                    }\n                }\n            }\n            if (!empty($propertyVisibility)) {\n                $class->setPropertyVisibility($propertyVisibility);\n            }\n\n            $class->save();\n\n            // set the fielddefinitions to null because we don't need them in the response\n            $class->setFieldDefinitions(null);\n\n            return $this->adminJson(['success' => true, 'class' => $class]);\n        } catch (\\Exception $e) {\n            Logger::error($e->getMessage());\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @param $name\n     *\n     * @return mixed\n     */\n    protected function correctClassname($name)\n    {\n        $name = preg_replace('/[^a-zA-Z0-9]+/', '', $name);\n        $name = preg_replace('/^[0-9]+/', '', $name);\n\n        return $name;\n    }\n\n    /**\n     * @Route(\"/import-class\", methods={\"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function importClassAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        $json = file_get_contents($_FILES['Filedata']['tmp_name']);\n\n        $success = DataObject\\ClassDefinition\\Service::importClassDefinitionFromJson($class, $json, false, true);\n\n        $response = $this->adminJson([\n            'success' => $success\n        ]);\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/import-custom-layout-definition\", methods={\"POST\", \"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function importCustomLayoutDefinitionAction(Request $request)\n    {\n        $success = false;\n        $json = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $importData = $this->decodeJson($json);\n\n        $customLayoutId = $request->get('id');\n        $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($customLayoutId);\n        if ($customLayout) {\n            try {\n                $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($importData['layoutDefinitions'], true);\n                $customLayout->setLayoutDefinitions($layout);\n                $customLayout->setDescription($importData['description']);\n                $customLayout->save();\n                $success = true;\n            } catch (\\Exception $e) {\n                Logger::error($e->getMessage());\n            }\n        }\n\n        $response = $this->adminJson([\n            'success' => $success\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/get-custom-layout-definitions\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getCustomLayoutDefinitionsAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $list = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n\n        $list->setCondition('classId = ' . $list->quote($classId));\n        $list = $list->load();\n        $result = [];\n        /** @var $item DataObject\\ClassDefinition\\CustomLayout */\n        foreach ($list as $item) {\n            $result[] = [\n                'id' => $item->getId(),\n                'name' => $item->getName() . ' (ID: ' . $item->getId() . ')',\n                'default' => $item->getDefault() ?: 0,\n            ];\n        }\n\n        return $this->adminJson(['success' => true, 'data' => $result]);\n    }\n\n    /**\n     * @Route(\"/get-all-layouts\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAllLayoutsAction(Request $request)\n    {\n        // get all classes\n        $resultList = [];\n        $mapping = [];\n\n        $customLayouts = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n        $customLayouts->setOrder('ASC');\n        $customLayouts->setOrderKey('name');\n        $customLayouts = $customLayouts->load();\n        foreach ($customLayouts as $layout) {\n            $mapping[$layout->getClassId()][] = $layout;\n        }\n\n        $classList = new DataObject\\ClassDefinition\\Listing();\n        $classList->setOrder('ASC');\n        $classList->setOrderKey('name');\n        $classList = $classList->load();\n\n        foreach ($classList as $class) {\n            $classMapping = $mapping[$class->getId()];\n            if ($classMapping) {\n                $resultList[] = [\n                    'type' => 'master',\n                    'id' => $class->getId() . '_' . 0,\n                    'name' => $class->getName()\n                ];\n\n                foreach ($classMapping as $layout) {\n                    $resultList[] = [\n                        'type' => 'custom',\n                        'id' => $class->getId() . '_' . $layout->getId(),\n                        'name' => $class->getName() . ' - ' . $layout->getName()\n                    ];\n                }\n            }\n        }\n\n        return $this->adminJson(['data' => $resultList]);\n    }\n\n    /**\n     * @Route(\"/export-class\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportClassAction(Request $request)\n    {\n        $id = $request->get('id');\n        $class = DataObject\\ClassDefinition::getById($id);\n\n        if (!$class instanceof DataObject\\ClassDefinition) {\n            $errorMessage = ': Class with id [ ' . $id . ' not found. ]';\n            Logger::error($errorMessage);\n            echo $errorMessage;\n        } else {\n            $json = DataObject\\ClassDefinition\\Service::generateClassDefinitionJson($class);\n\n            $response = new Response($json);\n            $response->headers->set('Content-type', 'application/json');\n            $response->headers->set('Content-Disposition', 'attachment; filename=\"class_' . $class->getName() . '_export.json\"');\n\n            return $response;\n        }\n    }\n\n    /**\n     * @Route(\"/export-custom-layout-definition\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportCustomLayoutDefinitionAction(Request $request)\n    {\n        $id = $request->get('id');\n\n        if ($id) {\n            $customLayout = DataObject\\ClassDefinition\\CustomLayout::getById($id);\n            if ($customLayout) {\n                $name = $customLayout->getName();\n                unset($customLayout->id);\n                unset($customLayout->classId);\n                unset($customLayout->name);\n                unset($customLayout->creationDate);\n                unset($customLayout->modificationDate);\n                unset($customLayout->userOwner);\n                unset($customLayout->userModification);\n                unset($customLayout->fieldDefinitions);\n\n                $json = json_encode($customLayout, JSON_PRETTY_PRINT);\n\n                $response = new Response($json);\n                $response->headers->set('Content-type', 'application/json');\n                $response->headers->set('Content-Disposition', 'attachment; filename=\"custom_definition_' . $name . '_export.json\"');\n\n                return $response;\n            }\n        }\n\n        $errorMessage = ': Custom Layout with id [ ' . $id . ' not found. ]';\n        Logger::error($errorMessage);\n        echo $errorMessage;\n    }\n\n    /**\n     * FIELDCOLLECTIONS\n     */\n\n    /**\n     * @Route(\"/fieldcollection-get\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionGetAction(Request $request)\n    {\n        $fc = DataObject\\Fieldcollection\\Definition::getByKey($request->get('id'));\n\n        return $this->adminJson($fc);\n    }\n\n    /**\n     * @Route(\"/fieldcollection-update\", methods={\"PUT\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionUpdateAction(Request $request)\n    {\n        try {\n            $key = $request->get('key');\n            $title = $request->get('title');\n            $group = $request->get('group');\n\n            if ($request->get('task') == 'add') {\n                // check for existing fieldcollection with same name with different lower/upper cases\n                $list = new DataObject\\Fieldcollection\\Definition\\Listing();\n                $list = $list->load();\n\n                foreach ($list as $item) {\n                    if (strtolower($key) === strtolower($item->getKey())) {\n                        throw new \\Exception('FieldCollection with the same name already exists (lower/upper cases may be different)');\n                    }\n                }\n            }\n\n            $fc = new DataObject\\Fieldcollection\\Definition();\n            $fc->setKey($key);\n            $fc->setTitle($title);\n            $fc->setGroup($group);\n\n            if ($request->get('values')) {\n                $values = $this->decodeJson($request->get('values'));\n                $fc->setParentClass($values['parentClass']);\n            }\n\n            if ($request->get('configuration')) {\n                $configuration = $this->decodeJson($request->get('configuration'));\n\n                $configuration['datatype'] = 'layout';\n                $configuration['fieldtype'] = 'panel';\n\n                $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($configuration, true);\n                $fc->setLayoutDefinitions($layout);\n            }\n\n            $fc->save();\n\n            return $this->adminJson(['success' => true, 'id' => $fc->getKey()]);\n        } catch (\\Exception $e) {\n            Logger::error($e->getMessage());\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @Route(\"/import-fieldcollection\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function importFieldcollectionAction(Request $request)\n    {\n        $fieldCollection = DataObject\\Fieldcollection\\Definition::getByKey($request->get('id'));\n\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n\n        $success = DataObject\\ClassDefinition\\Service::importFieldCollectionFromJson($fieldCollection, $data);\n\n        $response = $this->adminJson([\n            'success' => $success\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/export-fieldcollection\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportFieldcollectionAction(Request $request)\n    {\n        $fieldCollection = DataObject\\Fieldcollection\\Definition::getByKey($request->get('id'));\n        $key = $fieldCollection->getKey();\n        if (!$fieldCollection instanceof DataObject\\Fieldcollection\\Definition) {\n            $errorMessage = ': Field-Collection with id [ ' . $request->get('id') . ' not found. ]';\n            Logger::error($errorMessage);\n            echo $errorMessage;\n        } else {\n            $json = DataObject\\ClassDefinition\\Service::generateFieldCollectionJson($fieldCollection);\n            $response = new Response($json);\n            $response->headers->set('Content-type', 'application/json');\n            $response->headers->set('Content-Disposition', 'attachment; filename=\"fieldcollection_' . $key . '_export.json\"');\n\n            return $response;\n        }\n    }\n\n    /**\n     * @Route(\"/fieldcollection-delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionDeleteAction(Request $request)\n    {\n        $fc = DataObject\\Fieldcollection\\Definition::getByKey($request->get('id'));\n        $fc->delete();\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * @Route(\"/fieldcollection-tree\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionTreeAction(Request $request)\n    {\n        $list = new DataObject\\Fieldcollection\\Definition\\Listing();\n        $list = $list->load();\n\n        $forObjectEditor = $request->get('forObjectEditor');\n\n        $layoutDefinitions = [];\n\n        $definitions = [];\n\n        $allowedTypes = null;\n        if ($request->query->has('allowedTypes')) {\n            $allowedTypes = explode(',', $request->get('allowedTypes'));\n        }\n        $object = DataObject\\AbstractObject::getById($request->get('object_id'));\n\n        $groups = [];\n        /** @var $item DataObject\\Fieldcollection\\Definition */\n        foreach ($list as $item) {\n            if ($allowedTypes && !in_array($item->getKey(), $allowedTypes)) {\n                continue;\n            }\n\n            if ($item->getGroup()) {\n                if (!$groups[$item->getGroup()]) {\n                    $groups[$item->getGroup()] = [\n                        'id' => 'group_' . $item->getKey(),\n                        'text' => $item->getGroup(),\n                        'expandable' => true,\n                        'leaf' => false,\n                        'allowChildren' => true,\n                        'iconCls' => 'pimcore_icon_folder',\n                        'group' => $item->getGroup(),\n                        'children' => []\n                    ];\n                }\n                if ($forObjectEditor) {\n                    $itemLayoutDefinitions = $item->getLayoutDefinitions();\n                    DataObject\\Service::enrichLayoutDefinition($itemLayoutDefinitions, $object);\n                    $layoutDefinitions[$item->getKey()] = $itemLayoutDefinitions;\n                }\n                $groups[$item->getGroup()]['children'][] =\n                    [\n                        'id' => $item->getKey(),\n                        'text' => $item->getKey(),\n                        'title' => $item->getTitle(),\n                        'key' => $item->getKey(),\n                        'leaf' => true,\n                        'iconCls' => 'pimcore_icon_fieldcollection'\n                    ];\n            } else {\n                if ($forObjectEditor) {\n                    $itemLayoutDefinitions = $item->getLayoutDefinitions();\n                    DataObject\\Service::enrichLayoutDefinition($itemLayoutDefinitions, $object);\n                    $layoutDefinitions[$item->getKey()] = $itemLayoutDefinitions;\n                }\n                $definitions[] = [\n                    'id' => $item->getKey(),\n                    'text' => $item->getKey(),\n                    'title' => $item->getTitle(),\n                    'key' => $item->getKey(),\n                    'leaf' => true,\n                    'iconCls' => 'pimcore_icon_fieldcollection'\n                ];\n            }\n        }\n\n        foreach ($groups as $group) {\n            $definitions[] = $group;\n        }\n\n        $event = new GenericEvent($this, [\n            'list' => $definitions,\n            'objectId' => $request->get('object_id')\n        ]);\n        \\Pimcore::getEventDispatcher()->dispatch(AdminEvents::CLASS_FIELDCOLLECTION_LIST_PRE_SEND_DATA, $event);\n        $definitions = $event->getArgument('list');\n\n        if ($forObjectEditor) {\n            return $this->adminJson(['fieldcollections' => $definitions, 'layoutDefinitions' => $layoutDefinitions]);\n        } else {\n            return $this->adminJson($definitions);\n        }\n    }\n\n    /**\n     * @Route(\"/fieldcollection-list\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function fieldcollectionListAction(Request $request)\n    {\n        $user = \\Pimcore\\Tool\\Admin::getCurrentUser();\n        $currentLayoutId = $request->get('layoutId');\n\n        $list = new DataObject\\Fieldcollection\\Definition\\Listing();\n        $list = $list->load();\n\n        if ($request->query->has('allowedTypes')) {\n            $filteredList = [];\n            $allowedTypes = explode(',', $request->get('allowedTypes'));\n            /** @var $type DataObject\\Fieldcollection\\Definition */\n            foreach ($list as $type) {\n                if (in_array($type->getKey(), $allowedTypes)) {\n                    $filteredList[] = $type;\n\n                    // mainly for objects-meta data-type\n                    $layoutDefinitions = $type->getLayoutDefinitions();\n                    $context = [\n                        'containerType' => 'fieldcollection',\n                        'containerKey' => $type->getKey(),\n                        'outerFieldname' => $request->get('field_name')\n                    ];\n\n                    $object = DataObject\\AbstractObject::getById($request->get('object_id'));\n\n                    DataObject\\Service::enrichLayoutDefinition($layoutDefinitions, $object, $context);\n\n                    if ($currentLayoutId == -1 && $user->isAdmin()) {\n                        DataObject\\Service::createSuperLayout($layoutDefinitions);\n                    }\n                }\n            }\n\n            $list = $filteredList;\n        }\n\n        $event = new GenericEvent($this, [\n            'list' => $list,\n            'objectId' => $request->get('object_id')\n        ]);\n        \\Pimcore::getEventDispatcher()->dispatch(AdminEvents::CLASS_FIELDCOLLECTION_LIST_PRE_SEND_DATA, $event);\n        $list = $event->getArgument('list');\n\n        return $this->adminJson(['fieldcollections' => $list]);\n    }\n\n    /**\n     * @Route(\"/get-class-definition-for-column-config\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getClassDefinitionForColumnConfigAction(Request $request)\n    {\n        $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        $objectId = intval($request->get('oid'));\n\n        $filteredDefinitions = DataObject\\Service::getCustomLayoutDefinitionForGridColumnConfig($class, $objectId);\n\n        $layoutDefinitions = isset($filteredDefinitions['layoutDefinition']) ? $filteredDefinitions['layoutDefinition'] : false;\n        $filteredFieldDefinition = isset($filteredDefinitions['fieldDefinition']) ? $filteredDefinitions['fieldDefinition'] : false;\n\n        $class->setFieldDefinitions(null);\n\n        $result = [];\n\n        $result['objectColumns']['childs'] = $layoutDefinitions->getChilds();\n        $result['objectColumns']['nodeLabel'] = 'object_columns';\n        $result['objectColumns']['nodeType'] = 'object';\n\n        // array(\"id\", \"fullpath\", \"published\", \"creationDate\", \"modificationDate\", \"filename\", \"classname\");\n        $systemColumnNames = DataObject\\Concrete::$systemColumnNames;\n        $systemColumns = [];\n        foreach ($systemColumnNames as $systemColumn) {\n            $systemColumns[] = ['title' => $systemColumn, 'name' => $systemColumn, 'datatype' => 'data', 'fieldtype' => 'system'];\n        }\n        $result['systemColumns']['nodeLabel'] = 'system_columns';\n        $result['systemColumns']['nodeType'] = 'system';\n        $result['systemColumns']['childs'] = $systemColumns;\n\n        $list = new DataObject\\Objectbrick\\Definition\\Listing();\n        $list = $list->load();\n\n        foreach ($list as $brickDefinition) {\n            $classDefs = $brickDefinition->getClassDefinitions();\n            if (!empty($classDefs)) {\n                foreach ($classDefs as $classDef) {\n                    if ($classDef['classname'] == $class->getName()) {\n                        $fieldName = $classDef['fieldname'];\n                        if ($filteredFieldDefinition && !$filteredFieldDefinition[$fieldName]) {\n                            continue;\n                        }\n\n                        $key = $brickDefinition->getKey();\n\n                        $result[$key]['nodeLabel'] = $key;\n                        $result[$key]['brickField'] = $fieldName;\n                        $result[$key]['nodeType'] = 'objectbricks';\n                        $result[$key]['childs'] = $brickDefinition->getLayoutdefinitions()->getChilds();\n                        break;\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * OBJECT BRICKS\n     */\n\n    /**\n     * @Route(\"/objectbrick-get\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickGetAction(Request $request)\n    {\n        $fc = DataObject\\Objectbrick\\Definition::getByKey($request->get('id'));\n\n        return $this->adminJson($fc);\n    }\n\n    /**\n     * @Route(\"/objectbrick-update\", methods={\"PUT\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickUpdateAction(Request $request)\n    {\n        try {\n            $key = $request->get('key');\n            $title = $request->get('title');\n            $group = $request->get('group');\n\n            if ($request->get('task') == 'add') {\n                // check for existing brick with same name with different lower/upper cases\n                $list = new DataObject\\Objectbrick\\Definition\\Listing();\n                $list = $list->load();\n\n                foreach ($list as $item) {\n                    if (strtolower($key) === strtolower($item->getKey())) {\n                        throw new \\Exception('Brick with the same name already exists (lower/upper cases may be different)');\n                    }\n                }\n            }\n\n            // now we create a new definition\n            $fc = new DataObject\\Objectbrick\\Definition();\n            $fc->setKey($key);\n            $fc->setTitle($title);\n            $fc->setGroup($group);\n\n            if ($request->get('values')) {\n                $values = $this->decodeJson($request->get('values'));\n\n                $fc->setParentClass($values['parentClass']);\n                $fc->setClassDefinitions($values['classDefinitions']);\n            }\n\n            if ($request->get('configuration')) {\n                $configuration = $this->decodeJson($request->get('configuration'));\n\n                $configuration['datatype'] = 'layout';\n                $configuration['fieldtype'] = 'panel';\n\n                $layout = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($configuration, true);\n                $fc->setLayoutDefinitions($layout);\n            }\n\n            $fc->save();\n\n            return $this->adminJson(['success' => true, 'id' => $fc->getKey()]);\n        } catch (\\Exception $e) {\n            Logger::error($e->getMessage());\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @Route(\"/import-objectbrick\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importObjectbrickAction(Request $request)\n    {\n        $objectBrick = DataObject\\Objectbrick\\Definition::getByKey($request->get('id'));\n\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $success = DataObject\\ClassDefinition\\Service::importObjectBrickFromJson($objectBrick, $data);\n\n        $response = $this->adminJson([\n            'success' => $success\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * @Route(\"/export-objectbrick\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function exportObjectbrickAction(Request $request)\n    {\n        $objectBrick = DataObject\\Objectbrick\\Definition::getByKey($request->get('id'));\n        $key = $objectBrick->getKey();\n        if (!$objectBrick instanceof DataObject\\Objectbrick\\Definition) {\n            $errorMessage = ': Object-Brick with id [ ' . $request->get('id') . ' not found. ]';\n            Logger::error($errorMessage);\n            echo $errorMessage;\n        } else {\n            $xml = DataObject\\ClassDefinition\\Service::generateObjectBrickJson($objectBrick);\n            $response = new Response($xml);\n            $response->headers->set('Content-type', 'application/json');\n            $response->headers->set('Content-Disposition', 'attachment; filename=\"objectbrick_' . $key . '_export.json\"');\n\n            return $response;\n        }\n    }\n\n    /**\n     * @Route(\"/objectbrick-delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickDeleteAction(Request $request)\n    {\n        $fc = DataObject\\Objectbrick\\Definition::getByKey($request->get('id'));\n        $fc->delete();\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * @Route(\"/objectbrick-tree\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickTreeAction(Request $request)\n    {\n        $list = new DataObject\\Objectbrick\\Definition\\Listing();\n        $list = $list->load();\n\n        $forObjectEditor = $request->get('forObjectEditor');\n\n        $layoutDefinitions = [];\n        $groups = [];\n        $definitions = [];\n\n        if ($request->query->has('class_id') && $request->query->has('field_name')) {\n            $classId = $request->get('class_id');\n            $fieldname = $request->get('field_name');\n            $classDefinition = DataObject\\ClassDefinition::getById($classId);\n            $className = $classDefinition->getName();\n        }\n\n        /** @var $item DataObject\\Objectbrick\\Definition */\n        foreach ($list as $item) {\n            if ($request->query->has('class_id') && $request->query->has('field_name')) {\n                $keep = false;\n                /** @var $type DataObject\\Objectbrick\\Definition */\n                $clsDefs = $item->getClassDefinitions();\n                if (!empty($clsDefs)) {\n                    foreach ($clsDefs as $cd) {\n                        if ($cd['classname'] == $className && $cd['fieldname'] == $fieldname) {\n                            $keep = true;\n                            continue;\n                        }\n                    }\n                }\n                if (!$keep) {\n                    continue;\n                }\n            }\n\n            if ($item->getGroup()) {\n                if (!$groups[$item->getGroup()]) {\n                    $groups[$item->getGroup()] = [\n                        'id' => 'group_' . $item->getKey(),\n                        'text' => $item->getGroup(),\n                        'expandable' => true,\n                        'leaf' => false,\n                        'allowChildren' => true,\n                        'iconCls' => 'pimcore_icon_folder',\n                        'group' => $item->getGroup(),\n                        'children' => []\n                    ];\n                }\n                if ($forObjectEditor) {\n                    $layoutDefinitions[$item->getKey()] = $item->getLayoutDefinitions();\n                }\n                $groups[$item->getGroup()]['children'][] =\n                    [\n                        'id' => $item->getKey(),\n                        'text' => $item->getKey(),\n                        'title' => $item->getTitle(),\n                        'key' => $item->getKey(),\n                        'leaf' => true,\n                        'iconCls' => 'pimcore_icon_objectbricks'\n                    ];\n            } else {\n                if ($forObjectEditor) {\n                    $layout = $item->getLayoutDefinitions();\n\n                    $currentLayoutId = $request->get('layoutId', null);\n\n                    $user = $this->getAdminUser();\n                    if ($currentLayoutId == -1 && $user->isAdmin()) {\n                        DataObject\\Service::createSuperLayout($layout);\n                        $objectData['layout'] = $layout;\n                    }\n\n                    $context = [\n                        'containerType' => 'objectbrick',\n                        'containerKey' => $item->getKey(),\n                        'outerFieldname' => $request->get('field_name')\n                    ];\n\n                    $object = DataObject\\AbstractObject::getById($request->get('object_id'));\n\n                    DataObject\\Service::enrichLayoutDefinition($layout, $object, $context);\n\n                    $layoutDefinitions[$item->getKey()] = $layout;\n                }\n                $definitions[] = [\n                    'id' => $item->getKey(),\n                    'text' => $item->getKey(),\n                    'title' => $item->getTitle(),\n                    'key' => $item->getKey(),\n                    'leaf' => true,\n                    'iconCls' => 'pimcore_icon_objectbricks'\n                ];\n            }\n        }\n\n        foreach ($groups as $group) {\n            $definitions[] = $group;\n        }\n\n        $event = new GenericEvent($this, [\n            'list' => $definitions,\n            'objectId' => $request->get('object_id')\n        ]);\n        \\Pimcore::getEventDispatcher()->dispatch(AdminEvents::CLASS_OBJECTBRICK_LIST_PRE_SEND_DATA, $event);\n        $definitions = $event->getArgument('list');\n\n        if ($forObjectEditor) {\n            return $this->adminJson(['objectbricks' => $definitions, 'layoutDefinitions' => $layoutDefinitions]);\n        } else {\n            return $this->adminJson($definitions);\n        }\n    }\n\n    /**\n     * @Route(\"/objectbrick-list\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function objectbrickListAction(Request $request)\n    {\n        $list = new DataObject\\Objectbrick\\Definition\\Listing();\n        $list = $list->load();\n\n        if ($request->query->has('class_id') && $request->query->has('field_name')) {\n            $filteredList = [];\n            $classId = $request->get('class_id');\n            $fieldname = $request->get('field_name');\n            $classDefinition = DataObject\\ClassDefinition::getById($classId);\n            $className = $classDefinition->getName();\n\n            foreach ($list as $type) {\n                /** @var $type DataObject\\Objectbrick\\Definition */\n                $clsDefs = $type->getClassDefinitions();\n                if (!empty($clsDefs)) {\n                    foreach ($clsDefs as $cd) {\n                        if ($cd['classname'] == $className && $cd['fieldname'] == $fieldname) {\n                            $filteredList[] = $type;\n                            continue;\n                        }\n                    }\n                }\n\n                $layout = $type->getLayoutDefinitions();\n\n                $currentLayoutId = $request->get('layoutId', null);\n\n                $user = $this->getAdminUser();\n                if ($currentLayoutId == -1 && $user->isAdmin()) {\n                    DataObject\\Service::createSuperLayout($layout);\n                    $objectData['layout'] = $layout;\n                }\n\n                $context = [\n                    'containerType' => 'objectbrick',\n                    'containerKey' => $type->getKey(),\n                    'outerFieldname' => $request->get('field_name')\n                ];\n\n                $object = DataObject\\AbstractObject::getById($request->get('object_id'));\n\n                DataObject\\Service::enrichLayoutDefinition($layout, $object, $context);\n                $type->setLayoutDefinitions($layout);\n            }\n\n            $list = $filteredList;\n        }\n\n        $event = new GenericEvent($this, [\n            'list' => $list,\n            'objectId' => $request->get('object_id')\n        ]);\n        \\Pimcore::getEventDispatcher()->dispatch(AdminEvents::CLASS_OBJECTBRICK_LIST_PRE_SEND_DATA, $event);\n        $list = $event->getArgument('list');\n\n        return $this->adminJson(['objectbricks' => $list]);\n    }\n\n    /**\n     * See http://www.pimcore.org/issues/browse/PIMCORE-2358\n     * Add option to export/import all class definitions/brick definitions etc. at once\n     */\n\n    /**\n     * @Route(\"/bulk-import\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function bulkImportAction(Request $request)\n    {\n        $result = [];\n\n        $tmpName = $_FILES['Filedata']['tmp_name'];\n        $json = file_get_contents($tmpName);\n\n        $tmpName = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/bulk-import-' . uniqid() . '.tmp';\n        file_put_contents($tmpName, $json);\n\n        Session::useSession(function (AttributeBagInterface $session) use ($tmpName) {\n            $session->set('class_bulk_import_file', $tmpName);\n        }, 'pimcore_objects');\n\n        $json = json_decode($json, true);\n\n        foreach ($json as $groupName => $group) {\n            foreach ($group as $groupItem) {\n                $displayName = null;\n\n                if ($groupName == 'class') {\n                    $name = $groupItem['name'];\n                    $icon = 'class';\n                } elseif ($groupName == 'customlayout') {\n                    $className = $groupItem['className'];\n\n                    $layoutData = ['className' => $className, 'name' => $groupItem['name']];\n                    $name = json_encode($layoutData);\n                    $displayName = $className . ' / ' . $groupItem['name'];\n                    $icon = 'database_lightning';\n                } else {\n                    if ($groupName == 'objectbrick') {\n                        $icon = 'objectbricks';\n                    } elseif ($groupName == 'fieldcollection') {\n                        $icon = 'fieldcollection';\n                    }\n                    $name = $groupItem['key'];\n                }\n\n                if (!$displayName) {\n                    $displayName = $name;\n                }\n                $result[] = ['icon' => $icon, 'checked' => true, 'type' => $groupName, 'name' => $name, 'displayName' => $displayName];\n            }\n        }\n\n        $response = $this->adminJson(['success' => true, 'data' => $result]);\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    /**\n     * See http://www.pimcore.org/issues/browse/PIMCORE-2358\n     * Add option to export/import all class definitions/brick definitions etc. at once\n     */\n\n    /**\n     * @Route(\"/bulk-commit\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function bulkCommitAction(Request $request)\n    {\n        $data = json_decode($request->get('data'), true);\n\n        $session = Session::get('pimcore_objects');\n        $filename = $session->get('class_bulk_import_file');\n        $json = @file_get_contents($filename);\n        $json = json_decode($json, true);\n\n        $type = $data['type'];\n        $name = $data['name'];\n        $list = $json[$type];\n\n        foreach ($list as $item) {\n            unset($item['creationDate']);\n            unset($item['modificationDate']);\n            unset($item['userOwner']);\n            unset($item['userModification']);\n\n            if ($type == 'class' && $item['name'] == $name) {\n                $class = DataObject\\ClassDefinition::getByName($name);\n                if (!$class) {\n                    $class = new DataObject\\ClassDefinition();\n                    $class->setName($name);\n                }\n                $success = DataObject\\ClassDefinition\\Service::importClassDefinitionFromJson($class, json_encode($item), true);\n\n                return $this->adminJson(['success' => $success !== false]);\n            } elseif ($type == 'objectbrick' && $item['key'] == $name) {\n                try {\n                    $brick = DataObject\\Objectbrick\\Definition::getByKey($name);\n                } catch (\\Exception $e) {\n                    $brick = new DataObject\\Objectbrick\\Definition();\n                    $brick->setKey($name);\n                }\n\n                $success = DataObject\\ClassDefinition\\Service::importObjectBrickFromJson($brick, json_encode($item), true);\n\n                return $this->adminJson(['success' => $success !== false]);\n            } elseif ($type == 'fieldcollection' && $item['key'] == $name) {\n                try {\n                    $fieldCollection = DataObject\\Fieldcollection\\Definition::getByKey($name);\n                } catch (\\Exception $e) {\n                    $fieldCollection = new DataObject\\Fieldcollection\\Definition();\n                    $fieldCollection->setKey($name);\n                }\n                $success = DataObject\\ClassDefinition\\Service::importFieldCollectionFromJson($fieldCollection, json_encode($item), true);\n\n                return $this->adminJson(['success' => $success !== false]);\n            } elseif ($type == 'customlayout') {\n                $layoutData = json_decode($data['name'], true);\n                $className = $layoutData['className'];\n                $layoutName = $layoutData['name'];\n\n                if ($item['name'] == $layoutName && $item['className'] == $className) {\n                    $class = DataObject\\ClassDefinition::getByName($className);\n                    if (!$class) {\n                        throw new \\Exception('Class does not exist');\n                    }\n\n                    $classId = $class->getId();\n\n                    $layoutList = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n                    $db = \\Pimcore\\Db::get();\n                    $layoutList->setCondition('name = ' . $db->quote($layoutName) . ' AND classId = ' . $classId);\n                    $layoutList = $layoutList->load();\n\n                    $layoutDefinition = null;\n                    if ($layoutList) {\n                        $layoutDefinition = $layoutList[0];\n                    }\n\n                    if (!$layoutDefinition) {\n                        $layoutDefinition = new DataObject\\ClassDefinition\\CustomLayout();\n                        $layoutDefinition->setName($layoutName);\n                        $layoutDefinition->setClassId($classId);\n                    }\n\n                    try {\n                        $layoutDefinition->setDescription($item['description']);\n                        $layoutDef = DataObject\\ClassDefinition\\Service::generateLayoutTreeFromArray($item['layoutDefinitions'], true);\n                        $layoutDefinition->setLayoutDefinitions($layoutDef);\n                        $layoutDefinition->save();\n                    } catch (\\Exception $e) {\n                        Logger::error($e->getMessage());\n\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    /**\n     * See http://www.pimcore.org/issues/browse/PIMCORE-2358\n     * Add option to export/import all class definitions/brick definitions etc. at once\n     */\n\n    /**\n     * @Route(\"/bulk-export\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function bulkExportAction(Request $request)\n    {\n        $result = [];\n\n        $fieldCollections = new DataObject\\Fieldcollection\\Definition\\Listing();\n        $fieldCollections = $fieldCollections->load();\n\n        foreach ($fieldCollections as $fieldCollection) {\n            $key = $fieldCollection->key;\n            $fieldCollectionJson = json_decode(DataObject\\ClassDefinition\\Service::generateFieldCollectionJson($fieldCollection));\n            $fieldCollectionJson->key = $key;\n            $result['fieldcollection'][] = $fieldCollectionJson;\n        }\n\n        $classes = new DataObject\\ClassDefinition\\Listing();\n        $classes->setOrder('ASC');\n        $classes->setOrderKey('id');\n        $classes = $classes->load();\n\n        foreach ($classes as $class) {\n            $data = Model\\Webservice\\Data\\Mapper::map($class, '\\\\Pimcore\\\\Model\\\\Webservice\\\\Data\\\\ClassDefinition\\\\Out', 'out');\n            unset($data->fieldDefinitions);\n            $result['class'][] = $data;\n        }\n\n        $objectBricks = new DataObject\\Objectbrick\\Definition\\Listing();\n        $objectBricks = $objectBricks->load();\n\n        foreach ($objectBricks as $objectBrick) {\n            $key = $objectBrick->key;\n            $objectBrickJson = json_decode(DataObject\\ClassDefinition\\Service::generateObjectBrickJson($objectBrick));\n            $objectBrickJson->key = $key;\n            $result['objectbrick'][] = $objectBrickJson;\n        }\n\n        $customLayouts = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n        $customLayouts = $customLayouts->load();\n        foreach ($customLayouts as $customLayout) {\n            /** @var $customLayout DataObject\\ClassDefinition\\CustomLayout */\n            $classId = $customLayout->getClassId();\n            $class = DataObject\\ClassDefinition::getById($classId);\n            $customLayout->className = $class->getName();\n            $result['customlayout'][] = $customLayout;\n        }\n\n        $result = json_encode($result, JSON_PRETTY_PRINT);\n        $response = new Response($result);\n        $response->headers->set('Content-type', 'application/json');\n        $response->headers->set('Content-Disposition', 'attachment; filename=\"bulk_export.json\"');\n\n        return $response;\n    }\n\n    /**\n     * @param FilterControllerEvent $event\n     */\n    public function onKernelController(FilterControllerEvent $event)\n    {\n        $isMasterRequest = $event->isMasterRequest();\n        if (!$isMasterRequest) {\n            return;\n        }\n\n        // check permissions\n        $unrestrictedActions = [\n            'getTreeAction', 'fieldcollectionListAction', 'fieldcollectionTreeAction', 'fieldcollectionGetAction',\n            'getClassDefinitionForColumnConfigAction', 'objectbrickListAction', 'objectbrickTreeAction', 'objectbrickGetAction'\n        ];\n\n        $this->checkActionPermission($event, 'classes', $unrestrictedActions);\n    }\n\n    /**\n     * @param FilterResponseEvent $event\n     */\n    public function onKernelResponse(FilterResponseEvent $event)\n    {\n        // nothing to do\n    }\n\n    /**\n     * @Route(\"/get-fieldcollection-usages\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function getFieldcollectionUsagesAction(Request $request)\n    {\n        $key = $request->get('key');\n        $result = [];\n\n        $classes = new DataObject\\ClassDefinition\\Listing();\n        $classes = $classes->load();\n        foreach ($classes as $class) {\n            $fieldDefs = $class->getFieldDefinitions();\n            foreach ($fieldDefs as $fieldDef) {\n                if ($fieldDef instanceof DataObject\\ClassDefinition\\Data\\Fieldcollections) {\n                    $allowedKeys = $fieldDef->getAllowedTypes();\n                    if (is_array($allowedKeys) && in_array($key, $allowedKeys)) {\n                        $result[] = [\n                            'class' => $class->getName(),\n                            'field' => $fieldDef->getName()\n                        ];\n                    }\n                }\n            }\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/get-bricks-usages\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function getBrickUsagesAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $myclass = DataObject\\ClassDefinition::getById($classId);\n\n        $result = [];\n\n        $brickDefinitions = new DataObject\\Objectbrick\\Definition\\Listing();\n        $brickDefinitions = $brickDefinitions->load();\n        foreach ($brickDefinitions as $brickDefinition) {\n            $classes = $brickDefinition->getClassDefinitions();\n            foreach ($classes as $class) {\n                if ($myclass->getName() == $class['classname']) {\n                    $result[] = [\n                        'objectbrick' => $brickDefinition->getKey(),\n                        'field' => $class['fieldname']\n                    ];\n                }\n            }\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/suggest-class-identifier\")\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function suggestClassIdentifierAction()\n    {\n        $db = Db::get();\n        $maxId = $db->fetchOne('SELECT MAX(CAST(id AS SIGNED)) FROM classes;');\n\n        $existingIds = $db->fetchCol('select LOWER(id) from classes');\n\n        $result = [\n            'suggestedIdentifier' => $maxId ? $maxId + 1 : 1,\n            'existingIds' => $existingIds\n            ];\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/suggest-custom-layout-identifier\")\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function suggestCustomLayoutIdentifierAction(Request $request)\n    {\n        $classId = $request->get('classId');\n\n        $identifier = DataObject\\ClassDefinition\\CustomLayout::getIdentifier($classId);\n\n        $list = new DataObject\\ClassDefinition\\CustomLayout\\Listing();\n\n        $list = $list->load();\n        $existingIds = [];\n        $existingNames = [];\n\n        /** @var $item DataObject\\ClassDefinition\\CustomLayout */\n        foreach ($list as $item) {\n            $existingIds[] = $item->getId();\n            if ($item->getClassId() == $classId) {\n                $existingNames[] = $item->getName();\n            }\n        }\n\n        $result = [\n            'suggestedIdentifier' => $identifier,\n            'existingIds' => $existingIds,\n            'existingNames' => $existingNames\n            ];\n\n        return $this->adminJson($result);\n    }\n}\n"], "filenames": ["bundles/AdminBundle/Controller/Admin/DataObject/ClassController.php"], "buggy_code_start_loc": [26], "buggy_code_end_loc": [1455], "fixing_code_start_loc": [27], "fixing_code_end_loc": [1462], "type": "CWE-502", "message": "An issue was discovered in Pimcore before 5.7.1. An attacker with classes permission can send a POST request to /admin/class/bulk-commit, which will make it possible to exploit the unserialize function when passing untrusted values in the data parameter to bundles/AdminBundle/Controller/Admin/DataObject/ClassController.php.", "other": {"cve": {"id": "CVE-2019-10867", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-04T18:29:00.713", "lastModified": "2020-03-18T19:15:13.450", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in Pimcore before 5.7.1. An attacker with classes permission can send a POST request to /admin/class/bulk-commit, which will make it possible to exploit the unserialize function when passing untrusted values in the data parameter to bundles/AdminBundle/Controller/Admin/DataObject/ClassController.php."}, {"lang": "es", "value": "Se ha descubierto un problema en Pimcore en versiones anteriores a la 5.7.1. Un atacante con permiso de clases puede enviar una petici\u00f3n POST a admin/class/bulk-commit, que hace que sea posible explotar la funci\u00f3n \"unserialize\" a la hora de pasar valores no fiables en el par\u00e1metro \"data\" en bundles/AdminBundle/Controller/Admin/DataObject/ClassController.php."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.1", "matchCriteriaId": "543607DF-96CD-415B-BEED-DC71B4619632"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/152667/Pimcore-Unserialize-Remote-Code-Execution.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.rapid7.com/db/modules/exploit/multi/http/pimcore_unserialize_rce", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://blog.certimetergroup.com/it/articolo/security/polyglot_phar_deserialization_to_rce", "source": "cve@mitre.org"}, {"url": "https://github.com/pimcore/pimcore/commit/38a29e2f4f5f060a73974626952501cee05fda73", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-PHP-PIMCOREPIMCORE-173998", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/46783/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/38a29e2f4f5f060a73974626952501cee05fda73"}}