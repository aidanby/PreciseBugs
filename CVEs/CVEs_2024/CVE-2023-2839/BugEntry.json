{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / NALU (AVC, HEVC, VVC)  reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n#include <gpac/internal/media_dev.h>\n//for oinf stuff\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n#define CTS_POC_OFFSET_SAFETY\t1000\n\nGF_Err gf_bs_set_logger(GF_BitStream *bs, void (*on_bs_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3), void *udta);\n\n\nenum\n{\n\tDVMODE_NONE=0,\n\tDVMODE_AUTO,\n\tDVMODE_FORCE,\n\tDVMODE_CLEAN,\n\tDVMODE_SINGLE,\n};\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n\tu32 roll_count;\n} NALUIdx;\n\n\ntypedef struct\n{\n\tu32 layer_id_plus_one;\n\tu32 min_temporal_id, max_temporal_id;\n} LHVCLayerInfo;\n\nenum {\n\tSTRICT_POC_OFF = 0,\n\tSTRICT_POC_ON,\n\tSTRICT_POC_ERROR,\n};\n\ntypedef struct\n{\n\t//filter args\n\tGF_Fraction fps;\n\tDouble index;\n\tBool explicit, force_sync, nosei, importer, subsamples, nosvc, novpsext, deps, seirw, audelim, analyze, notime;\n\tu32 nal_length;\n\tu32 strict_poc;\n\tu32 bsdbg;\n\tGF_Fraction dur;\n\tu32 dv_mode, dv_profile, dv_compatid;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\t//read bitstream for AVC/HEVC parsing\n\tGF_BitStream *bs_r;\n\t//write bitstream for nalus size length rewrite\n\tGF_BitStream *bs_w;\n\t//current CTS/DTS of the stream, may be overridden by input packet if not file (eg TS PES)\n\tu64 cts, dts, prev_dts, prev_cts;\n\tu32 pck_duration;\n\t//basic config stored here: with, height CRC of base and enh layer decoder config, sample aspect ratio\n\t//when changing, a new pid config will be emitted\n\tu32 width, height;\n\tu32 crc_cfg, crc_cfg_enh;\n\tGF_Fraction sar;\n\tGF_Fraction cur_fps;\n\n\t//duration of the file if known\n\tGF_Fraction64 duration;\n\t//playback start range\n\tDouble start_range;\n\t//indicates we are in seek, packets before start range should be marked\n\tBool in_seek;\n\tu32 seek_gdr_count;\n\tBool first_gdr;\n\t//set once we play something\n\tBool is_playing;\n\t//is a file, is a file fully loaded on disk (local or download done)\n\tBool is_file, file_loaded;\n\t//initial PLAY command found\n\tBool initial_play_done;\n\n\t//list of RAP entry points\n\tNALUIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\t//timescale of the input pid if any, 0 otherwise\n\tu32 timescale;\n\t//framing flag of input packet when input pid has timing (eg is not a file)\n\tBool input_is_au_start;\n\n\tGF_FilterPacket *src_pck;\n\n\tBool full_au_source;\n\n\t//total delay in frames between decode and presentation\n\ts32 max_total_delay;\n\t//max size codable with our nal_length setting\n\tu32 max_nalu_size_allowed;\n\n\t//position in input packet from which we resume parsing\n\tu32 resume_from;\n\t//prevents message about possible NAL size optimizaion at finalization\n\tBool nal_adjusted;\n\n\t//avc/hevc switch\n\tu32 codecid;\n\t//name of the logger\n\tconst char *log_name;\n\n\t//list of packet (in decode order !!) not yet dispatched.\n\t//Dispatch depends on the mode:\n\t//strict_poc=0: we wait after each IDR until we find a stable poc diff between pictures, controled by poc_probe_done\n\t//strict_poc>=1: we dispatch only after IDR or at the end (huge delay)\n\tGF_List *pck_queue;\n\t//dts of the last IDR found\n\tu64 dts_last_IDR;\n\t//max size of NALUs in the bitstream\n\tu32 max_nalu_size;\n\n\n\tu8 *nal_store;\n\tu32 nal_store_size, nal_store_alloc;\n\n\t//list of param sets found\n\tGF_List *sps, *pps, *vps, *sps_ext, *pps_svc, *vvc_aps_pre, *vvc_dci, *vvc_opi;\n\t//set to true if one of the PS has been modified, will potentially trigger a PID reconfigure\n\tBool ps_modified;\n\n\t//stats\n\tu32 nb_idr, nb_i, nb_p, nb_b, nb_sp, nb_si, nb_sei, nb_nalus, nb_aud, nb_cra;\n\n\t//frame has intra slice\n\tBool has_islice;\n\t//AU is rap\n\tGF_FilterSAPType au_sap;\n\t//number of slices in frame\n\tu32 nb_slices_in_au;\n\t//frame first slice\n\tBool au_sap2_poc_reset;\n\t//paff used - NEED FURTHER CHECKING\n\tBool is_paff;\n\tBool bottom_field_flag;\n\t//SEI recovery count - if 0 and I slice only frame, openGOP detection (avc)\n\ts32 sei_recovery_frame_count;\n\tu32 use_opengop_gdr;\n\t//poc compute variables\n\ts32 last_poc, max_last_poc, max_last_b_poc, poc_diff, prev_last_poc, min_poc, poc_shift;\n\t//set to TRUE once 3 frames with same min poc diff are found, enabling dispatch of the frames\n\tBool poc_probe_done;\n\t//pointer to the first packet of the current frame (the one holding timing info)\n\t//this packet is in the packet queue\n\tGF_FilterPacket *first_pck_in_au;\n\t//frame has slices used as reference\n\tBool has_ref_slices;\n\t//frame has redundant coding\n\tBool has_redundant;\n\n\tBool last_frame_is_idr;\n\n\t//buffer to store SEI messages\n\t//for AVC: we have to rewrite the SEI to remove some of the messages according to the spec\n\t//for HEVC: we store prefix SEI here and dispatch them once the first VCL is found\n\tchar *sei_buffer;\n\tu32 sei_buffer_size, sei_buffer_alloc;\n\n\t//subsample buffer, only used for SVC for now\n\tu32 subsamp_buffer_alloc, subsamp_buffer_size, subs_mapped_bytes;\n\tchar *subsamp_buffer;\n\n\t//AVC specific\n\t//avc bitstream state\n\tAVCState *avc_state;\n\n\t//SVC specific\n\tchar *svc_prefix_buffer;\n\tu32 svc_prefix_buffer_size, svc_prefix_buffer_alloc;\n\tu32 svc_nalu_prefix_reserved;\n\tu8 svc_nalu_prefix_priority;\n\n\t//HEVC specific\n\tHEVCState *hevc_state;\n\t//shvc stats\n\tu32 nb_e_idr, nb_e_i, nb_e_p, nb_e_b;\n\tBool vvc_no_stats;\n\n\tLHVCLayerInfo linf[64];\n\tu8 max_temporal_id[64];\n\tu8 min_layer_id;\n\n\t//VVC specific\n\tVVCState *vvc_state;\n\n\tBool has_initial_aud;\n\tchar init_aud[3];\n\n\tBool interlaced;\n\n\tBool is_mvc;\n\n\tu32 bitrate;\n\tu32 nb_frames;\n\n\t//layer and temporal ID of last VCL nal\n\tu8 last_layer_id, last_temporal_id;\n\n\tu32 clli_crc, mdcv_crc;\n\n\tu32 nb_dv_rpu, nb_dv_el;\n\n\tu32 valid_ps_flags;\n\n\tBool check_prev_sap2;\n\ts32 prev_sap2_poc;\n\tGF_FilterPacket *prev_sap;\n} GF_NALUDmxCtx;\n\nstatic void naludmx_enqueue_or_dispatch(GF_NALUDmxCtx *ctx, GF_FilterPacket *n_pck, Bool flush_ref);\nstatic void naludmx_finalize_au_flags(GF_NALUDmxCtx *ctx);\nstatic void naludmx_reset_param_sets(GF_NALUDmxCtx *ctx, Bool do_free);\nstatic void naludmx_set_dolby_vision(GF_NALUDmxCtx *ctx);\n\n\nGF_Err naludmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tu32 old_codecid;\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) {\n\t\tctx->timescale = p->value.uint;\n\t\tctx->cur_fps.den = 0;\n\t\tctx->cur_fps.num = ctx->timescale;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\tif (p) {\n\t\t\tctx->cur_fps = p->value.frac;\n\t\t}\n\t}\n\n\told_codecid = ctx->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tswitch (p->value.uint) {\n\t\tcase GF_CODECID_HEVC:\n\t\tcase GF_CODECID_LHVC:\n\t\t\tctx->codecid = GF_CODECID_HEVC;\n\t\t\tbreak;\n\t\tcase GF_CODECID_VVC:\n\t\t\tctx->codecid = GF_CODECID_VVC;\n\t\t\tbreak;\n\t\tcase GF_CODECID_AVC:\n\t\tcase GF_CODECID_AVC_PS:\n\t\tcase GF_CODECID_SVC:\n\t\tcase GF_CODECID_MVC:\n\t\t\tctx->codecid = GF_CODECID_AVC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\telse {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MIME);\n\t\tif (p && p->value.string && (\n\t\t\tstrstr(p->value.string, \"hvc\")\n\t\t\t|| strstr(p->value.string, \"hevc\")\n\t\t\t|| strstr(p->value.string, \"265\")\n\t\t\t|| strstr(p->value.string, \"shvc\")\n\t\t\t|| strstr(p->value.string, \"mhvc\")\n\t\t\t|| strstr(p->value.string, \"lhvc\")\n\t\t) )\n\t\t\tctx->codecid = GF_CODECID_HEVC;\n\t\telse if (p && p->value.string && (\n\t\t\tstrstr(p->value.string, \"vvc\")\n\t\t) )\n\t\t\tctx->codecid = GF_CODECID_VVC;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p && p->value.string && (\n\t\t\t\t strstr(p->value.string, \"hvc\")\n\t\t\t\t || strstr(p->value.string, \"hevc\")\n\t\t\t\t || strstr(p->value.string, \"265\")\n\t\t\t\t || strstr(p->value.string, \"shvc\")\n\t\t\t\t || strstr(p->value.string, \"mhvc\")\n\t\t\t\t || strstr(p->value.string, \"lhvc\")\n\t\t\t ) )\n\t\t\t\tctx->codecid = GF_CODECID_HEVC;\n\t\t\telse if (p && p->value.string && (\n\t\t\t\t strstr(p->value.string, \"vvc\")\n\t\t\t\t || strstr(p->value.string, \"266\")\n\t\t\t\t || strstr(p->value.string, \"lvvc\")\n\t\t\t ) )\n\t\t\t\tctx->codecid = GF_CODECID_VVC;\n\t\t\telse\n\t\t\t\tctx->codecid = GF_CODECID_AVC;\n\t\t}\n\t}\n\n\tif (old_codecid && (old_codecid != ctx->codecid)) {\n\t\tnaludmx_reset_param_sets(ctx, GF_FALSE);\n\t}\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tctx->log_name = \"HEVC\";\n\t\tif (ctx->avc_state) { gf_free(ctx->avc_state); ctx->avc_state = NULL; }\n\t\tif (ctx->vvc_state) { gf_free(ctx->vvc_state); ctx->vvc_state = NULL; }\n\t\tif (!ctx->hevc_state) GF_SAFEALLOC(ctx->hevc_state, HEVCState);\n\t\tctx->min_layer_id = 0xFF;\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tctx->log_name = \"VVC\";\n\t\tif (ctx->hevc_state) { gf_free(ctx->hevc_state); ctx->hevc_state = NULL; }\n\t\tif (ctx->avc_state) { gf_free(ctx->avc_state); ctx->avc_state = NULL; }\n\t\tif (!ctx->vvc_state) GF_SAFEALLOC(ctx->vvc_state, VVCState);\n\t} else {\n\t\tctx->log_name = \"AVC|H264\";\n\t\tif (ctx->hevc_state) { gf_free(ctx->hevc_state); ctx->hevc_state = NULL; }\n\t\tif (ctx->vvc_state) { gf_free(ctx->vvc_state); ctx->vvc_state = NULL; }\n\t\tif (!ctx->avc_state) GF_SAFEALLOC(ctx->avc_state, AVCState);\n\t}\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tctx->nb_slices_in_au = 0;\n\t}\n\tctx->full_au_source = GF_FALSE;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_UNFRAMED_FULL_AU);\n\tif (p && p->value.boolean) {\n\t\tGF_FilterEvent fevt;\n\t\t//this is a reframer used after an encoder, we want to make sure we have enough frames to compute POC otherwise we might block the chain\n\t\t//by holding input packets - ask 1s by default\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_BUFFER_REQ, ctx->ipid);\n\t\tfevt.buffer_req.pid_only = GF_TRUE;\n\t\tfevt.buffer_req.max_buffer_us = 1000000;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\tctx->full_au_source = GF_TRUE;\n\t}\n\n\t//if source has no timescale, recompute time\n\tif (!ctx->timescale) ctx->notime = GF_TRUE;\n\n\t//copy properties at init or reconfig\n\tif (ctx->opid) {\n\t\tif (ctx->poc_probe_done) {\n\t\t\t//full frame mode, flush everything before signaling discontinuity\n\t\t\t//for other modes discontinuity we signal discontinuity before the current AU being reconstructed\n\t\t\tif (ctx->full_au_source && ctx->first_pck_in_au)\n\t\t\t\tnaludmx_finalize_au_flags(ctx);\n\n\t\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\t\t}\n\t\tctx->nal_store_size = 0;\n\n\t\tif (ctx->timescale != 0)\n\t\t\tctx->resume_from = 0;\n\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\t//don't change codec type if reframing an ES (for HLS SAES)\n\t\tif (!ctx->timescale)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid));\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED_FULL_AU, NULL);\n\t\tif (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_ID))\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(1));\n\n\t\tctx->ps_modified = GF_TRUE;\n\t\tctx->crc_cfg = ctx->crc_cfg_enh = 0;\n\t}\n\n\treturn GF_OK;\n}\n\nstatic u64 naludmx_next_start_code(GF_BitStream *bs, u64 offset, u64 fsize, u32 *sc_size)\n{\n\tu32 pos=0, nb_zeros=0;\n\twhile (offset+pos<fsize) {\n\t\tu8 b = gf_bs_read_u8(bs);\n\t\tpos++;\n\t\tswitch (b) {\n\t\tcase 1:\n\t\t\t//break at first 0xXX000001 or 0x00000001\n\t\t\tif (nb_zeros>=2) {\n\t\t\t\t*sc_size = (nb_zeros==2) ? 3 : 4;\n\t\t\t\treturn offset+pos;\n\t\t\t}\n\t\t\tnb_zeros = 0;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnb_zeros++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnb_zeros=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//eof\n\treturn 0;\n}\n\nvoid naludmx_probe_recovery_sei(GF_BitStream *bs, AVCState *avc)\n{\n\t/*parse SEI*/\n\twhile (gf_bs_available(bs)) {\n\t\tu32 ptype, psize;\n\n\t\tptype = 0;\n\t\twhile (1) {\n\t\t\tu8 v = gf_bs_read_int(bs, 8);\n\t\t\tptype += v;\n\t\t\tif (v != 0xFF) break;\n\t\t}\n\n\t\tpsize = 0;\n\t\twhile (1) {\n\t\t\tu8 v = gf_bs_read_int(bs, 8);\n\t\t\tpsize += v;\n\t\t\tif (v != 0xFF) break;\n\t\t}\n\n\t\tif (ptype==6) {\n\t\t\tavc->sei.recovery_point.frame_cnt = gf_bs_read_ue(bs);\n\t\t\tavc->sei.recovery_point.valid = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, psize);\n\n\t\tptype = gf_bs_peek_bits(bs, 8, 0);\n\t\tif (ptype == 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void naludmx_check_dur(GF_Filter *filter, GF_NALUDmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tu64 duration, cur_dur, nal_start, filesize;\n\tu32 probe_size=0, start_code_size;\n\tAVCState *avc_state = NULL;\n\tHEVCState *hevc_state = NULL;\n\tVVCState *vvc_state = NULL;\n\tBool first_slice_in_pic = GF_TRUE;\n\tconst GF_PropertyValue *p;\n\tconst char *filepath = NULL;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tfilepath = p->value.string;\n\tctx->is_file = GF_TRUE;\n\n\tif (ctx->index<0) {\n\t\tif (gf_opts_get_bool(\"temp\", \"force_indexing\")) {\n\t\t\tctx->index = 1.0;\n\t\t} else {\n\t\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\t\t\tif (!p || (p->value.longuint > 20000000)) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Source file larger than 20M, skipping indexing\\n\", ctx->log_name));\n\t\t\t\tif (!gf_sys_is_test_mode())\n\t\t\t\t\tprobe_size = 20000000;\n\t\t\t} else {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t}\n\t\t}\n\t}\n\tif ((ctx->index<=0) && !probe_size) {\n\t\tctx->duration.num = 1;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tGF_SAFEALLOC(hevc_state, HEVCState);\n\t\tif (!hevc_state) return;\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tGF_SAFEALLOC(vvc_state, VVCState);\n\t\tif (!vvc_state) return;\n\t} else {\n\t\tGF_SAFEALLOC(avc_state, AVCState);\n\t\tif (!avc_state) return;\n\t}\n\n\tstream = gf_fopen_ex(filepath, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (hevc_state) gf_free(hevc_state);\n\t\tif (vvc_state) gf_free(vvc_state);\n\t\tif (avc_state) gf_free(avc_state);\n\t\tif (gf_fileio_is_main_thread(filepath)) {\n\t\t\tctx->duration.num = 1;\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\t}\n\t\treturn;\n\t}\n\tctx->index_size = 0;\n\tduration = 0;\n\tcur_dur = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tfilesize = gf_bs_available(bs);\n\n\tnal_start = naludmx_next_start_code(bs, 0, filesize, &start_code_size);\n\tif (!nal_start) {\n\t\tif (hevc_state) gf_free(hevc_state);\n\t\tif (avc_state) gf_free(avc_state);\n\t\tgf_bs_del(bs);\n\t\tgf_fclose(stream);\n\t\tctx->duration.num = 1;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\twhile (1) {\n\t\ts32 res;\n\t\tu32 gdr_frame_count = 0;\n\t\tBool is_rap = GF_FALSE;\n\t\tBool is_slice = GF_FALSE;\n\n\t\t//parse directly from current pos (next byte is first byte of nal hdr)\n\t\tif (hevc_state) {\n\t\t\tu8 temporal_id, layer_id, nal_type;\n\n\t\t\tres = gf_hevc_parse_nalu_bs(bs, hevc_state, &nal_type, &temporal_id, &layer_id);\n\t\t\tif (res>0) first_slice_in_pic = GF_TRUE;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//also mark first slice in gdr as valid seek point\n\t\t\tif (is_slice && hevc_state->sei.recovery_point.valid) {\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\thevc_state->sei.recovery_point.valid = GF_FALSE;\n\t\t\t\tgdr_frame_count = hevc_state->sei.recovery_point.frame_cnt;\n\t\t\t}\n\t\t} else if (vvc_state) {\n\n\t\t\tu8 temporal_id, layer_id, nal_type;\n\n\t\t\tres = gf_vvc_parse_nalu_bs(bs, vvc_state, &nal_type, &temporal_id, &layer_id);\n\t\t\tif (res>0) first_slice_in_pic = GF_TRUE;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_VVC_NALU_SLICE_TRAIL:\n\t\t\tcase GF_VVC_NALU_SLICE_STSA:\n\t\t\tcase GF_VVC_NALU_SLICE_RADL:\n\t\t\tcase GF_VVC_NALU_SLICE_RASL:\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\t\t\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_VVC_NALU_SLICE_CRA:\n\t\t\tcase GF_VVC_NALU_SLICE_GDR:\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tif (vvc_state->s_info.gdr_pic)\n\t\t\t\t\tgdr_frame_count = vvc_state->s_info.gdr_recovery_count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 nal_type;\n\t\t\tres = gf_avc_parse_nalu(bs, avc_state);\n\t\t\tif (res>0) first_slice_in_pic = GF_TRUE;\n\n\t\t\tnal_type = avc_state->last_nal_type_parsed;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_IDR_SLICE:\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\t\t\tcase GF_AVC_NALU_DP_A_SLICE:\n\t\t\tcase GF_AVC_NALU_DP_B_SLICE:\n\t\t\tcase GF_AVC_NALU_DP_C_SLICE:\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_SEI:\n\t\t\t\tnaludmx_probe_recovery_sei(bs, avc_state);\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\t//also mark open GOP or first slice in gdr as valid seek point\n\t\t\tif (is_slice && avc_state->sei.recovery_point.valid) {\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\tavc_state->sei.recovery_point.valid = GF_FALSE;\n\t\t\t\tgdr_frame_count = avc_state->sei.recovery_point.frame_cnt;\n\t\t\t}\n\t\t}\n\n\t\tif (probe_size && (nal_start>probe_size) && is_rap) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!probe_size && is_rap && first_slice_in_pic && (cur_dur >= ctx->index * ctx->cur_fps.num) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(NALUIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = nal_start - start_code_size;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= ctx->cur_fps.num;\n\t\t\tctx->indexes[ctx->index_size].roll_count = gdr_frame_count;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tif (is_slice && first_slice_in_pic) {\n\t\t\tduration += ctx->cur_fps.den;\n\t\t\tcur_dur += ctx->cur_fps.den;\n\t\t\tfirst_slice_in_pic = GF_FALSE;\n\t\t}\n\n\t\t//align since some NAL parsing may stop anywhere\n\t\tgf_bs_align(bs);\n\t\tnal_start = naludmx_next_start_code(bs, gf_bs_get_position(bs), filesize, &start_code_size);\n\t\tif (!nal_start)\n\t\t\tbreak;\n\t}\n\tif (probe_size)\n\t\tprobe_size = (u32) gf_bs_get_position(bs);\n\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\tif (hevc_state) gf_free(hevc_state);\n\tif (vvc_state) gf_free(vvc_state);\n\tif (avc_state) gf_free(avc_state);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * ctx->cur_fps.num != duration * ctx->duration.den)) {\n\t\tif (probe_size) {\n\t\t\tduration *= filesize/probe_size;\n\t\t}\n\t\tctx->duration.num = (s32) duration;\n\t\tif (probe_size) ctx->duration.num = -ctx->duration.num;\n\t\tctx->duration.den = ctx->cur_fps.num;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && (!gf_sys_is_test_mode() || gf_opts_get_bool(\"temp\", \"force_indexing\"))) {\n\t\t\tfilesize *= 8 * ctx->duration.den;\n\t\t\tfilesize /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) filesize;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\n\nstatic void naludmx_enqueue_or_dispatch(GF_NALUDmxCtx *ctx, GF_FilterPacket *n_pck, Bool flush_ref)\n{\n\t//TODO: we are dispatching frames in \"negctts mode\", ie we may have DTS>CTS\n\t//need to signal this for consumers using DTS (eg MPEG-2 TS)\n\tif (flush_ref && ctx->pck_queue && ctx->poc_diff) {\n\t\tu32 dts_inc=0;\n\t\ts32 last_poc = 0;\n\t\tBool patch_missing_frame = GF_FALSE;\n\t\t//send all reference packet queued\n\t\tif (ctx->strict_poc==STRICT_POC_ERROR) {\n\t\t\tu32 i;\n\t\t\tu32 nb_bframes = 0;\n\t\t\tfor (i=0; i<gf_list_count(ctx->pck_queue); i++) {\n\t\t\t\ts32 poc;\n\t\t\t\tu64 poc_ts, dts;\n\t\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, i);\n\n\t\t\t\tif (q_pck == ctx->first_pck_in_au) break;\n\n\t\t\t\tdts = gf_filter_pck_get_dts(q_pck);\n\t\t\t\tif (dts == GF_FILTER_NO_TS) continue;\n\t\t\t\tpoc_ts = gf_filter_pck_get_cts(q_pck);\n\t\t\t\tassert(poc_ts != GF_FILTER_NO_TS);\n\t\t\t\tpoc = (s32) ((s64) poc_ts - CTS_POC_OFFSET_SAFETY);\n\n\t\t\t\tif (i) {\n\t\t\t\t\tif (last_poc>poc) nb_bframes ++;\n\t\t\t\t\telse if (last_poc + ctx->poc_diff<poc)\n\t\t\t\t\t\tpatch_missing_frame = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tlast_poc = poc;\n\t\t\t}\n\t\t\tif (nb_bframes>1)\n\t\t\t\tpatch_missing_frame = GF_FALSE;\n\t\t\telse if (nb_bframes)\n\t\t\t\tpatch_missing_frame = GF_TRUE;\n\t\t}\n\t\tlast_poc = GF_INT_MIN;\n\n\t\twhile (gf_list_count(ctx->pck_queue) ) {\n\t\t\tu64 dts;\n\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, 0);\n\n\t\t\tif (q_pck == ctx->first_pck_in_au) break;\n\n\t\t\tdts = gf_filter_pck_get_dts(q_pck);\n\t\t\tif (dts != GF_FILTER_NO_TS) {\n\t\t\t\ts32 poc;\n\t\t\t\tu64 poc_ts, cts;\n\t\t\t\tu8 carousel_info = gf_filter_pck_get_carousel_version(q_pck);\n\n\t\t\t\t//we reused timing from source packets\n\t\t\t\tif (!carousel_info) {\n\t\t\t\t\tassert(ctx->timescale);\n\t\t\t\t\tgf_list_rem(ctx->pck_queue, 0);\n\t\t\t\t\tgf_filter_pck_send(q_pck);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_set_carousel_version(q_pck, 0);\n\n\n\t\t\t\tpoc_ts = gf_filter_pck_get_cts(q_pck);\n\t\t\t\tassert(poc_ts != GF_FILTER_NO_TS);\n\t\t\t\tpoc = (s32) ((s64) poc_ts - CTS_POC_OFFSET_SAFETY);\n\n\t\t\t\tif (patch_missing_frame) {\n\t\t\t\t\tif (last_poc!=GF_INT_MIN) {\n\t\t\t\t\t\t//check if we missed an IDR (poc reset)\n\t\t\t\t\t\tif (poc && (last_poc > poc) ) {\n\t\t\t\t\t\t\tlast_poc = 0;\n\t\t\t\t\t\t\tdts_inc += ctx->cur_fps.den;\n\t\t\t\t\t\t\tctx->dts_last_IDR = dts;\n\t\t\t\t\t\t\tctx->dts += ctx->cur_fps.den;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//check if we miss a frame\n\t\t\t\t\t\twhile (last_poc + ctx->poc_diff < poc) {\n\t\t\t\t\t\t\tlast_poc += ctx->poc_diff;\n\t\t\t\t\t\t\tdts_inc += ctx->cur_fps.den;\n\t\t\t\t\t\t\tctx->dts += ctx->cur_fps.den;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlast_poc = poc;\n\t\t\t\t\tdts += dts_inc;\n\t\t\t\t}\n\t\t\t\t//poc is stored as diff since last IDR which has min_poc\n\t\t\t\tcts = ( (ctx->min_poc + (s32) poc) * ctx->cur_fps.den ) / ctx->poc_diff + ctx->dts_last_IDR;\n\n\t\t\t\t/*if PAFF, 2 pictures (eg poc) <=> 1 aggregated frame (eg sample), divide by 2*/\n\t\t\t\tif (ctx->is_paff) {\n\t\t\t\t\tcts /= 2;\n\t\t\t\t\t/*in some cases the poc is not on the top field - if that is the case, round up*/\n\t\t\t\t\tif (cts % ctx->cur_fps.den) {\n\t\t\t\t\t\tcts = ((cts/ctx->cur_fps.den)+1) * ctx->cur_fps.den;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[%s] Frame timestamps computed dts \"LLU\" cts \"LLU\" (poc %d min poc %d poc_diff %d last IDR DTS \"LLU\")\\n\", ctx->log_name, dts, cts, poc, ctx->min_poc, ctx->poc_diff, ctx->dts_last_IDR));\n\n\t\t\t\tif (ctx->importer && ctx->cur_fps.den) {\n\t\t\t\t\tpoc = (s32) ( (s64) cts - (s64) dts);\n\t\t\t\t\tif (poc<0) poc = -poc;\n\t\t\t\t\tpoc /= ctx->cur_fps.den;\n\t\t\t\t\tif (poc > ctx->max_total_delay)\n\t\t\t\t\t\tctx->max_total_delay = poc;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_rem(ctx->pck_queue, 0);\n\t\t\tgf_filter_pck_send(q_pck);\n\t\t}\n\t}\n\tif (!n_pck) return;\n\n\tif (!ctx->pck_queue) ctx->pck_queue = gf_list_new();\n\tgf_list_add(ctx->pck_queue, n_pck);\n}\n\nstatic void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)\n{\n\tGF_NALUFFParamArray *pa = NULL;\n\tu32 i, count;\n\tcount = gf_list_count(param_list);\n\tfor (i=0; i<count; i++) {\n\t\tpa = gf_list_get(param_list, i);\n\t\tif (pa->type == nal_type) break;\n\t\tpa = NULL;\n\t}\n\tif (!pa) {\n\t\tGF_SAFEALLOC(pa, GF_NALUFFParamArray);\n\t\tif (!pa) return;\n\n\t\tpa->array_completeness = 1;\n\t\tpa->type = nal_type;\n\t\tpa->nalus = gf_list_new();\n\t\tgf_list_add(param_list, pa);\n\t}\n\tgf_list_add(pa->nalus, sl);\n}\n\nstatic void naludmx_hevc_set_parall_type(GF_NALUDmxCtx *ctx, GF_HEVCConfig *hevc_cfg)\n{\n\tu32 use_tiles, use_wpp, nb_pps, i, count;\n\tHEVCState hevc;\n\n\tcount = gf_list_count(ctx->pps);\n\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\n\tuse_tiles = 0;\n\tuse_wpp = 0;\n\tnb_pps = 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *slc = (GF_NALUFFParam*)gf_list_get(ctx->pps, i);\n\t\ts32 idx = gf_hevc_read_pps(slc->data, slc->size, &hevc);\n\n\t\tif (idx>=0) {\n\t\t\tHEVC_PPS *pps;\n\t\t\tnb_pps++;\n\t\t\tpps = &hevc.pps[idx];\n\t\t\tif (!pps->entropy_coding_sync_enabled_flag && pps->tiles_enabled_flag)\n\t\t\t\tuse_tiles++;\n\t\t\telse if (pps->entropy_coding_sync_enabled_flag && !pps->tiles_enabled_flag)\n\t\t\t\tuse_wpp++;\n\t\t}\n\t}\n\tif (!use_tiles && !use_wpp) hevc_cfg->parallelismType = 1;\n\telse if (!use_wpp && (use_tiles==nb_pps) ) hevc_cfg->parallelismType = 2;\n\telse if (!use_tiles && (use_wpp==nb_pps) ) hevc_cfg->parallelismType = 3;\n\telse hevc_cfg->parallelismType = 0;\n}\n\nGF_Err naludmx_set_hevc_oinf(GF_NALUDmxCtx *ctx, u8 *max_temporal_id)\n{\n#ifndef GPAC_DISABLE_ISOM\n\tGF_OperatingPointsInformation *oinf;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tu32 data_size;\n\tu32 i;\n\tHEVC_VPS *vps;\n\tGF_NALUFFParam *vps_sl = gf_list_get(ctx->vps, 0);\n\tif (!vps_sl) return GF_SERVICE_ERROR;\n\n\tvps = &ctx->hevc_state->vps[vps_sl->id];\n\n\tif (!vps->vps_extension_found) return GF_OK;\n\tif (vps->max_layers<2) return GF_OK;\n\n\toinf = gf_isom_oinf_new_entry();\n\tif (!oinf) return GF_OUT_OF_MEM;\n\n\toinf->scalability_mask = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tif (vps->scalability_mask[i])\n\t\t\toinf->scalability_mask |= 1 << i;\n\t}\n\n\tfor (i = 0; i < vps->num_profile_tier_level; i++) {\n\t\tHEVC_ProfileTierLevel ptl = (i == 0) ? vps->ptl : vps->ext_ptl[i-1];\n\t\tLHEVC_ProfileTierLevel *lhevc_ptl;\n\t\tGF_SAFEALLOC(lhevc_ptl, LHEVC_ProfileTierLevel);\n\t\tif (!lhevc_ptl) return GF_OUT_OF_MEM;\n\n\t\tlhevc_ptl->general_profile_space = ptl.profile_space;\n\t\tlhevc_ptl->general_tier_flag = ptl.tier_flag;\n\t\tlhevc_ptl->general_profile_idc = ptl.profile_idc;\n\t\tlhevc_ptl->general_profile_compatibility_flags = ptl.profile_compatibility_flag;\n\t\tlhevc_ptl->general_constraint_indicator_flags = 0;\n\t\tif (ptl.general_progressive_source_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 47;\n\t\tif (ptl.general_interlaced_source_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 46;\n\t\tif (ptl.general_non_packed_constraint_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 45;\n\t\tif (ptl.general_frame_only_constraint_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 44;\n\t\tlhevc_ptl->general_constraint_indicator_flags |= ptl.general_reserved_44bits;\n\t\tlhevc_ptl->general_level_idc = ptl.level_idc;\n\t\tgf_list_add(oinf->profile_tier_levels, lhevc_ptl);\n\t}\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tu32 j;\n\t\tu16 minPicWidth, minPicHeight, maxPicWidth, maxPicHeight;\n\t\tu8 maxChromaFormat, maxBitDepth;\n\t\tu8 maxTemporalId;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\n\t\top->output_layer_set_idx = i;\n\t\top->layer_count = vps->num_necessary_layers[i];\n\t\tminPicWidth = minPicHeight = maxPicWidth = maxPicHeight = maxTemporalId = 0;\n\t\tmaxChromaFormat = maxBitDepth = 0;\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\tu32 format_idx;\n\t\t\tu32 bitDepth;\n\t\t\top->layers_info[j].ptl_idx = vps->profile_tier_level_idx[i][j];\n\t\t\top->layers_info[j].layer_id = j;\n\t\t\top->layers_info[j].is_outputlayer = vps->output_layer_flag[i][j];\n\t\t\t//FIXME: we consider that this flag is never set\n\t\t\top->layers_info[j].is_alternate_outputlayer = GF_FALSE;\n\n\t\t\tif (max_temporal_id) {\n\t\t\t\tif (!maxTemporalId || (maxTemporalId < max_temporal_id[op->layers_info[j].layer_id]))\n\t\t\t\t\tmaxTemporalId = max_temporal_id[op->layers_info[j].layer_id];\n\t\t\t} else {\n\t\t\t\tmaxTemporalId = vps->max_sub_layers;\n\t\t\t}\n\n\t\t\tformat_idx = vps->rep_format_idx[op->layers_info[j].layer_id];\n\t\t\tif (!minPicWidth || (minPicWidth > vps->rep_formats[format_idx].pic_width_luma_samples))\n\t\t\t\tminPicWidth = vps->rep_formats[format_idx].pic_width_luma_samples;\n\t\t\tif (!minPicHeight || (minPicHeight > vps->rep_formats[format_idx].pic_height_luma_samples))\n\t\t\t\tminPicHeight = vps->rep_formats[format_idx].pic_height_luma_samples;\n\t\t\tif (!maxPicWidth || (maxPicWidth < vps->rep_formats[format_idx].pic_width_luma_samples))\n\t\t\t\tmaxPicWidth = vps->rep_formats[format_idx].pic_width_luma_samples;\n\t\t\tif (!maxPicHeight || (maxPicHeight < vps->rep_formats[format_idx].pic_height_luma_samples))\n\t\t\t\tmaxPicHeight = vps->rep_formats[format_idx].pic_height_luma_samples;\n\t\t\tif (!maxChromaFormat || (maxChromaFormat < vps->rep_formats[format_idx].chroma_format_idc))\n\t\t\t\tmaxChromaFormat = vps->rep_formats[format_idx].chroma_format_idc;\n\t\t\tbitDepth = vps->rep_formats[format_idx].bit_depth_chroma > vps->rep_formats[format_idx].bit_depth_luma ? vps->rep_formats[format_idx].bit_depth_chroma : vps->rep_formats[format_idx].bit_depth_luma;\n\t\t\tif (!maxChromaFormat || (maxChromaFormat < bitDepth))\n\t\t\t\tmaxChromaFormat = bitDepth;\n\t\t}\n\t\top->max_temporal_id = maxTemporalId;\n\t\top->minPicWidth = minPicWidth;\n\t\top->minPicHeight = minPicHeight;\n\t\top->maxPicWidth = maxPicWidth;\n\t\top->maxPicHeight = maxPicHeight;\n\t\top->maxChromaFormat = maxChromaFormat;\n\t\top->maxBitDepth = maxBitDepth;\n\t\top->frame_rate_info_flag = GF_FALSE; //FIXME: should fetch this info from VUI\n\t\top->bit_rate_info_flag = GF_FALSE; //we don't use it\n\t\tgf_list_add(oinf->operating_points, op);\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tu32 j, k;\n\t\tif (i==MAX_LHVC_LAYERS) break;\n\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\n\t\tdep->dependent_layerID = vps->layer_id_in_nuh[i];\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tif (j==MAX_LHVC_LAYERS) break;\n\n\t\t\tif (vps->direct_dependency_flag[dep->dependent_layerID][j]) {\n\t\t\t\tdep->dependent_on_layerID[dep->num_layers_dependent_on] = j;\n\t\t\t\tdep->num_layers_dependent_on ++;\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (oinf->scalability_mask & (1 << j)) {\n\t\t\t\tdep->dimension_identifier[j] = vps->dimension_id[i][k];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tgf_list_add(oinf->dependency_layers, dep);\n\t}\n\n\t//write Operating Points Information Sample Group\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_oinf_write_entry(oinf, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tgf_isom_oinf_del_entry(oinf);\n\n\tgf_filter_pid_set_info_str(ctx->opid, \"hevc:oinf\", &PROP_DATA_NO_COPY(data, data_size) );\n#endif\n\treturn GF_OK;\n}\n\nstatic void naludmx_set_hevc_linf(GF_NALUDmxCtx *ctx)\n{\n\tu32 i, nb_layers=0, nb_sublayers=0;\n\tu8 *data;\n\tu32 data_size;\n\tGF_BitStream *bs;\n\n\tfor (i=0; i<64; i++) {\n\t\tif (ctx->linf[i].layer_id_plus_one) nb_layers++;\n\t\tif (ctx->linf[i].min_temporal_id != ctx->linf[i].max_temporal_id) nb_sublayers++;\n\t}\n\tif (!nb_layers && !nb_sublayers)\n\t\treturn;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_bs_write_int(bs, 0, 2);\n\tgf_bs_write_int(bs, nb_layers, 6);\n\tfor (i=0; i<nb_layers; i++) {\n\t\tif (! ctx->linf[i].layer_id_plus_one) continue;\n\t\tgf_bs_write_int(bs, 0, 4);\n\t\tgf_bs_write_int(bs, ctx->linf[i].layer_id_plus_one - 1, 6);\n\t\tgf_bs_write_int(bs, ctx->linf[i].min_temporal_id, 3);\n\t\tgf_bs_write_int(bs, ctx->linf[i].max_temporal_id, 3);\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, 0xFF, 7);\n\n\t}\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tgf_filter_pid_set_info_str(ctx->opid, \"hevc:linf\", &PROP_DATA_NO_COPY(data, data_size) );\n}\n\nstatic Bool naludmx_create_hevc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar, Bool *has_hevc_base)\n{\n\tu32 i, count;\n\tu8 layer_id;\n\tBool first = GF_TRUE;\n\tBool first_lhvc = GF_TRUE;\n\tGF_HEVCConfig *cfg;\n\tGF_HEVCConfig *hvcc;\n\tGF_HEVCConfig *lvcc;\n\tu32 max_w, max_h, max_ew, max_eh;\n\n\t*has_hevc_base = GF_FALSE;\n\n\n\tmax_w = max_h = 0;\n\tmax_ew = max_eh = 0;\n\tsar->num = sar->den = 0;\n\n\t//check we have one pps or sps in base layer\n\tcount = gf_list_count(ctx->sps);\n\tif (!count && !ctx->analyze) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) {\n\t\t\t*has_hevc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcount = gf_list_count(ctx->pps);\n\tif (!count && !ctx->analyze) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) {\n\t\t\t*has_hevc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thvcc = gf_odf_hevc_cfg_new();\n\tlvcc = gf_odf_hevc_cfg_new();\n\thvcc->nal_unit_size = ctx->nal_length;\n\tlvcc->nal_unit_size = ctx->nal_length;\n\tlvcc->is_lhvc = GF_TRUE;\n\n\t//assign vps first so that they are serialized first\n\tcount = gf_list_count(ctx->vps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vps, i);\n\t\tHEVC_VPS *vps = &ctx->hevc_state->vps[sl->id];\n\n\t\tif (!i) {\n\t\t\thvcc->avgFrameRate = lvcc->avgFrameRate = vps->rates[0].avg_pic_rate;\n\t\t\thvcc->constantFrameRate = lvcc->constantFrameRate = vps->rates[0].constant_pic_rate_idc;\n\t\t\thvcc->numTemporalLayers = lvcc->numTemporalLayers = vps->max_sub_layers;\n\t\t\thvcc->temporalIdNested = lvcc->temporalIdNested = vps->temporal_id_nesting;\n\t\t}\n\t\t//TODO set scalability mask\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu((ctx->explicit || ! (*has_hevc_base) ) ? lvcc->param_array : hvcc->param_array, sl, GF_HEVC_NALU_VID_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->sps);\n\tfor (i=0; i<count; i++) {\n\t\tBool is_lhvc = GF_FALSE;\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tHEVC_SPS *sps = &ctx->hevc_state->sps[sl->id];\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) *has_hevc_base = GF_TRUE;\n\n\t\tif (ctx->explicit || layer_id) {\n\t\t\tcfg = lvcc;\n\t\t\tis_lhvc = GF_TRUE;\n\t\t} else {\n\t\t\tcfg = hvcc;\n\t\t}\n\n\t\tif (first || (is_lhvc && first_lhvc) ) {\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_space = sps->ptl.profile_space;\n\t\t\tcfg->tier_flag = sps->ptl.tier_flag;\n\t\t\tcfg->profile_idc = sps->ptl.profile_idc;\n\t\t\tcfg->general_profile_compatibility_flags = sps->ptl.profile_compatibility_flag;\n\t\t\tcfg->progressive_source_flag = sps->ptl.general_progressive_source_flag;\n\t\t\tcfg->interlaced_source_flag = sps->ptl.general_interlaced_source_flag;\n\t\t\tcfg->non_packed_constraint_flag = sps->ptl.general_non_packed_constraint_flag;\n\t\t\tcfg->frame_only_constraint_flag = sps->ptl.general_frame_only_constraint_flag;\n\t\t\tcfg->constraint_indicator_flags = sps->ptl.general_reserved_44bits;\n\t\t\tcfg->level_idc = sps->ptl.level_idc;\n\t\t\tcfg->chromaFormat = sps->chroma_format_idc;\n\t\t\tcfg->luma_bit_depth = sps->bit_depth_luma;\n\t\t\tcfg->chroma_bit_depth = sps->bit_depth_chroma;\n\t\t\tctx->interlaced = cfg->interlaced_source_flag ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (sps->aspect_ratio_info_present_flag && sps->sar_width && sps->sar_height) {\n\t\t\t\tsar->num = sps->sar_width;\n\t\t\t\tsar->den = sps->sar_height;\n\t\t\t}\n\n\t\t\t/*disable frame rate scan, most bitstreams have wrong values there*/\n\t\t\tif (ctx->notime && first && (!ctx->fps.num || !ctx->fps.den) && sps->has_timing_info\n\t\t\t\t/*if detected FPS is greater than 1000, assume wrong timing info*/\n\t\t\t\t&& (sps->time_scale <= 1000*sps->num_units_in_tick)\n\t\t\t) {\n\t\t\t\tctx->cur_fps.num = sps->time_scale;\n\t\t\t\tctx->cur_fps.den = sps->num_units_in_tick;\n\n\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_lhvc) {\n\t\t\tfirst_lhvc = GF_FALSE;\n\t\t\tif (sps->width > max_ew) max_ew = sps->width;\n\t\t\tif (sps->height > max_eh) max_eh = sps->height;\n\t\t} else {\n\t\t\tif (sps->width > max_w) max_w = sps->width;\n\t\t\tif (sps->height > max_h) max_h = sps->height;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_HEVC_NALU_SEQ_PARAM);\n\t}\n\n\tcfg = ctx->explicit ? lvcc : hvcc;\n\tcount = gf_list_count(ctx->pps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) *has_hevc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(layer_id ? lvcc->param_array : cfg->param_array, sl, GF_HEVC_NALU_PIC_PARAM);\n\t}\n\n\t*dsi = *dsi_enh = NULL;\n\t*dsi_size = *dsi_enh_size = 0;\n\n\tif (ctx->explicit || ! (*has_hevc_base) ) {\n\t\tnaludmx_hevc_set_parall_type(ctx, lvcc);\n\t\tgf_odf_hevc_cfg_write(lvcc, dsi, dsi_size);\n\t\t*max_width = *max_enh_width = max_ew;\n\t\t*max_height = *max_enh_height = max_eh;\n\t} else {\n\t\tnaludmx_hevc_set_parall_type(ctx, hvcc);\n\t\tgf_odf_hevc_cfg_write(hvcc, dsi, dsi_size);\n\t\tif (gf_list_count(lvcc->param_array) ) {\n\t\t\tnaludmx_hevc_set_parall_type(ctx, lvcc);\n\t\t\tgf_odf_hevc_cfg_write(lvcc, dsi_enh, dsi_enh_size);\n\t\t}\n\t\t*max_width = max_w;\n\t\t*max_height = max_h;\n\t\t*max_enh_width = max_ew;\n\t\t*max_enh_height = max_eh;\n\t}\n\tcount = gf_list_count(hvcc->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(hvcc->param_array, i);\n\t\tgf_list_reset(pa->nalus);\n\t}\n\tcount = gf_list_count(lvcc->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(lvcc->param_array, i);\n\t\tgf_list_reset(pa->nalus);\n\t}\n\tgf_odf_hevc_cfg_del(hvcc);\n\tgf_odf_hevc_cfg_del(lvcc);\n\treturn GF_TRUE;\n}\n\n\nstatic Bool naludmx_create_vvc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar, Bool *has_vvc_base)\n{\n\tu32 i, count;\n\tu8 layer_id;\n\tBool first = GF_TRUE;\n\tBool first_lvvc = GF_TRUE;\n\tGF_VVCConfig *cfg;\n\tu32 max_w, max_h, max_ew, max_eh;\n\n\t*has_vvc_base = GF_FALSE;\n\n\tmax_w = max_h = 0;\n\tmax_ew = max_eh = 0;\n\tsar->num = sar->den = 0;\n\n\t//check we have one pps or sps in base layer\n\tcount = gf_list_count(ctx->sps);\n\tif (!count && !ctx->analyze) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tlayer_id = (sl->data[0] & 0x3f);\n\t\t//todo, base is not always 0 !\n\t\tif (!layer_id) {\n\t\t\t*has_vvc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcount = gf_list_count(ctx->pps);\n\tif (!count && !ctx->analyze) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = (sl->data[0] & 0x3f);\n\t\t//todo, base is not always 0 !\n\t\tif (!layer_id) {\n\t\t\t*has_vvc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcfg = gf_odf_vvc_cfg_new();\n\tcfg->nal_unit_size = ctx->nal_length;\n\n\n\t//assign vps first so that they are serialized first\n\tcount = gf_list_count(ctx->vps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vps, i);\n\t\tVVC_VPS *vps = &ctx->vvc_state->vps[sl->id];\n\n\t\tif (!i) {\n\t\t\tcfg->avgFrameRate = vps->rates[0].avg_pic_rate;\n\t\t\tcfg->constantFrameRate = vps->rates[0].constant_pic_rate_idc;\n\t\t\tcfg->numTemporalLayers = vps->max_sub_layers;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_VID_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->sps);\n\tfor (i=0; i<count; i++) {\n\t\tBool is_lvvc = GF_FALSE;\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tVVC_SPS *sps = &ctx->vvc_state->sps[sl->id];\n\t\tlayer_id = sl->data[0] & 0x3f;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\n\t\tif (ctx->explicit || layer_id) {\n\t\t\tis_lvvc = GF_TRUE;\n\t\t}\n\n\t\tif (first || (is_lvvc && first_lvvc) ) {\n\t\t\tVVC_VPS *vps = &ctx->vvc_state->vps[sps->vps_id];\n\t\t\tcfg->avgFrameRate = 0;\n\t\t\tcfg->constantFrameRate = 1;\n\t\t\tcfg->numTemporalLayers = sps->max_sublayers;\n\t\t\tcfg->nal_unit_size = ctx->nal_length;\n\t\t\tcfg->ptl_present = vps->num_ptl ? 1 : 0;\n\n\t\t\tif (vps->num_ptl) {\n\t\t\t\tcfg->num_constraint_info = vps->ptl[0].gci_present ? 1 : 12;\n\t\t\t\tcfg->general_profile_idc = vps->ptl[0].general_profile_idc;\n\t\t\t\tcfg->general_tier_flag = vps->ptl[0].general_tier_flag;\n\t\t\t\tcfg->general_level_idc = vps->ptl[0].general_level_idc;\n\t\t\t\tcfg->ptl_frame_only_constraint = vps->ptl[0].frame_only_constraint;\n\t\t\t\tcfg->ptl_multilayer_enabled = vps->ptl[0].multilayer_enabled;\n\n\t\t\t\tcfg->general_constraint_info = gf_malloc(sizeof(u8) * cfg-> num_constraint_info);\n\t\t\t\tif (cfg->general_constraint_info)\n\t\t\t\t\tmemcpy(cfg->general_constraint_info, vps->ptl[0].gci, cfg->num_constraint_info);\n\n\t\t\t\t//todo set temporal sublayers\n\t\t\t\tcfg->ptl_sublayer_present_mask = 0;\n\t\t\t\tcfg->num_sub_profiles = 0;\n\t\t\t\tcfg->ols_idx = 0;\n\t\t\t}\n\t\t\tcfg->chroma_format = sps->chroma_format_idc;\n\t\t\tcfg->bit_depth = sps->bitdepth;\n\t\t\tcfg->maxPictureWidth = sps->width;\n\t\t\tcfg->maxPictureHeight = sps->height;\n\n\t\t\tif (sps->aspect_ratio_info_present_flag && sps->sar_width && sps->sar_height) {\n\t\t\t\tsar->num = sps->sar_width;\n\t\t\t\tsar->den = sps->sar_height;\n\t\t\t}\n\n\t\t\t/*disable frame rate scan, most bitstreams have wrong values there*/\n\t\t\tif (ctx->notime && first && (!ctx->fps.num || !ctx->fps.den) && sps->has_timing_info\n\t\t\t\t/*if detected FPS is greater than 1000, assume wrong timing info*/\n\t\t\t\t&& (sps->time_scale <= 1000*sps->num_units_in_tick)\n\t\t\t) {\n\t\t\t\tctx->cur_fps.num = sps->time_scale;\n\t\t\t\tctx->cur_fps.den = sps->num_units_in_tick;\n\t\t\t\tgf_media_get_reduced_frame_rate(&ctx->cur_fps.num, &ctx->cur_fps.den);\n\n\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_lvvc) {\n\t\t\tfirst_lvvc = GF_FALSE;\n\t\t\tif (sps->width > max_ew) max_ew = sps->width;\n\t\t\tif (sps->height > max_eh) max_eh = sps->height;\n\t\t} else {\n\t\t\tif (sps->width > max_w) max_w = sps->width;\n\t\t\tif (sps->height > max_h) max_h = sps->height;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_SEQ_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->pps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = sl->data[0] & 0x3F;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_PIC_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->vvc_dci);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vvc_dci, i);\n\t\tlayer_id = sl->data[0] & 0x3F;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_DEC_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->vvc_opi);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vvc_opi, i);\n\t\tlayer_id = sl->data[0] & 0x3F;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_OPI);\n\t}\n\n\tcount = gf_list_count(ctx->vvc_aps_pre);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vvc_aps_pre, i);\n\t\tlayer_id = sl->data[0] & 0x3F;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_APS_PREFIX);\n\t}\n\n\t*dsi = *dsi_enh = NULL;\n\t*dsi_size = *dsi_enh_size = 0;\n\n\tgf_odf_vvc_cfg_write(cfg, dsi, dsi_size);\n\t*max_width = max_w;\n\t*max_height = max_h;\n\t*max_enh_width = max_ew;\n\t*max_enh_height = max_eh;\n\n\tcount = gf_list_count(cfg->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(cfg->param_array, i);\n\t\tgf_list_reset(pa->nalus);\n\t}\n\tgf_odf_vvc_cfg_del(cfg);\n\treturn GF_TRUE;\n}\n\nBool naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar)\n{\n\tu32 i, count;\n\tBool first = GF_TRUE;\n\tBool first_svc = GF_TRUE;\n\tGF_AVCConfig *cfg;\n\tGF_AVCConfig *avcc;\n\tGF_AVCConfig *svcc;\n\tu32 max_w, max_h, max_ew, max_eh;\n\n\n\tmax_w = max_h = max_ew = max_eh = 0;\n\tsar->num = sar->den = 0;\n\n\tif (!ctx->analyze && (!gf_list_count(ctx->sps) || !gf_list_count(ctx->pps)))\n\t\treturn GF_FALSE;\n\n\tavcc = gf_odf_avc_cfg_new();\n\tsvcc = gf_odf_avc_cfg_new();\n\tavcc->nal_unit_size = ctx->nal_length;\n\tsvcc->nal_unit_size = ctx->nal_length;\n\n\tctx->is_mvc = GF_FALSE;\n\tcount = gf_list_count(ctx->sps);\n\tfor (i=0; i<count; i++) {\n\t\tBool is_svc = GF_FALSE;\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tAVC_SPS *sps = &ctx->avc_state->sps[sl->id];\n\t\tu32 nal_type = sl->data[0] & 0x1F;\n\n\t\tif ((sps->profile_idc == 118) || (sps->profile_idc == 128)) {\n\t\t\tctx->is_mvc = GF_TRUE;\n\t\t}\n\n\t\tif (ctx->explicit) {\n\t\t\tcfg = svcc;\n\t\t} else if (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) {\n\t\t\tcfg = svcc;\n\t\t\tis_svc = GF_TRUE;\n\t\t} else {\n\t\t\tcfg = avcc;\n\t\t}\n\n\t\tif (first || (is_svc && first_svc) ) {\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_compatibility = sps->prof_compat;\n\t\t\tcfg->AVCProfileIndication = sps->profile_idc;\n\t\t\tcfg->AVCLevelIndication = sps->level_idc;\n\t\t\tcfg->chroma_format = sps->chroma_format;\n\t\t\tcfg->luma_bit_depth = 8 + sps->luma_bit_depth_m8;\n\t\t\tcfg->chroma_bit_depth = 8 + sps->chroma_bit_depth_m8;\n\t\t\t/*try to patch ?*/\n\t\t\tif (!gf_avcc_use_extensions(cfg->AVCProfileIndication)\n\t\t\t\t&& ((cfg->chroma_format>1) || (cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8))\n\t\t\t) {\n\t\t\t\tif ((cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) {\n\t\t\t\t\tcfg->AVCProfileIndication = 110;\n\t\t\t\t} else {\n\t\t\t\t\tcfg->AVCProfileIndication = (cfg->chroma_format==3) ? 244 : 122;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->vui_parameters_present_flag && sps->vui.par_num && sps->vui.par_den) {\n\t\t\t\tsar->num = sps->vui.par_num;\n\t\t\t\tsar->den = sps->vui.par_den;\n\t\t\t}\n\t\t\tctx->interlaced = sps->frame_mbs_only_flag ? GF_FALSE : GF_TRUE;\n\n\n\t\t\t/*disable frame rate scan, most bitstreams have wrong values there*/\n\t\t\tif (first && (!ctx->fps.num || !ctx->fps.den) && sps->vui.timing_info_present_flag\n\t\t\t\t/*if detected FPS is greater than 1000, assume wrong timing info*/\n\t\t\t\t&& (sps->vui.time_scale <= 1000*sps->vui.num_units_in_tick)\n\t\t\t) {\n\t\t\t\t/*ISO/IEC 14496-10 n11084 Table E-6*/\n\t\t\t\t/* not used :\t\t\t\tu8 DeltaTfiDivisorTable[] = {1,1,1,2,2,2,2,3,3,4,6}; */\n\t\t\t\tu8 DeltaTfiDivisorIdx;\n\t\t\t\tif (!sps->vui.pic_struct_present_flag) {\n\t\t\t\t\tDeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag);\n\t\t\t\t} else {\n\t\t\t\t\tif (!ctx->avc_state->sei.pic_timing.pic_struct)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 2;\n\t\t\t\t\telse if (ctx->avc_state->sei.pic_timing.pic_struct == 8)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 6;\n\t\t\t\t\telse\n\t\t\t\t\t\tDeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;\n\t\t\t\t}\n\t\t\t\tif (ctx->notime && sps->vui.time_scale && sps->vui.num_units_in_tick) {\n\t\t\t\t\tctx->cur_fps.num = 2 * sps->vui.time_scale;\n\t\t\t\t\tctx->cur_fps.den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;\n\n\t\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t\t}\n\t\t\t\tif (! sps->vui.fixed_frame_rate_flag)\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Possible Variable Frame Rate: VUI \\\"fixed_frame_rate_flag\\\" absent\\n\", ctx->log_name));\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_svc) {\n\t\t\tfirst_svc = GF_FALSE;\n\t\t\tif (sps->width > max_ew) max_ew = sps->width;\n\t\t\tif (sps->height > max_eh) max_eh = sps->height;\n\t\t} else {\n\t\t\tif (sps->width > max_w) max_w = sps->width;\n\t\t\tif (sps->height > max_h) max_h = sps->height;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->sequenceParameterSets, sl);\n\t}\n\n\tcfg = ctx->explicit ? svcc : avcc;\n\tcount = gf_list_count(ctx->sps_ext);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps_ext, i);\n\t\tif (!cfg->sequenceParameterSetExtensions) cfg->sequenceParameterSetExtensions = gf_list_new();\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->sequenceParameterSetExtensions, sl);\n\t}\n\n\tcfg = ctx->explicit ? svcc : avcc;\n\tcount = gf_list_count(ctx->pps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t}\n\n\tcfg = svcc;\n\tcount = gf_list_count(ctx->pps_svc);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps_svc, i);\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t}\n\n\t*dsi = *dsi_enh = NULL;\n\t*dsi_size = *dsi_enh_size = 0;\n\n\tif (ctx->explicit) {\n\t\tgf_odf_avc_cfg_write(svcc, dsi, dsi_size);\n\t} else {\n\t\tgf_odf_avc_cfg_write(avcc, dsi, dsi_size);\n\t\tif (gf_list_count(svcc->sequenceParameterSets) || svcc->sequenceParameterSetExtensions) {\n\t\t\tgf_odf_avc_cfg_write(svcc, dsi_enh, dsi_enh_size);\n\t\t}\n\t}\n\tgf_list_reset(avcc->sequenceParameterSets);\n\tgf_list_reset(avcc->sequenceParameterSetExtensions);\n\tgf_list_reset(avcc->pictureParameterSets);\n\tgf_list_reset(svcc->sequenceParameterSets);\n\tgf_list_reset(svcc->sequenceParameterSetExtensions);\n\tgf_list_reset(svcc->pictureParameterSets);\n\tgf_odf_avc_cfg_del(avcc);\n\tgf_odf_avc_cfg_del(svcc);\n\t*max_width = max_w;\n\t*max_height = max_h;\n\t*max_enh_width = max_ew;\n\t*max_enh_height = max_eh;\n\treturn GF_TRUE;\n}\n\nstatic void naludmx_end_access_unit(GF_NALUDmxCtx *ctx)\n{\n\t//finalize current fram flags - we will flush(send) later on\n\tnaludmx_finalize_au_flags(ctx);\n\n\tctx->has_islice = GF_FALSE;\n\tctx->nb_slices_in_au = 0;\n\tctx->sei_recovery_frame_count = -1;\n\tctx->au_sap = GF_FILTER_SAP_NONE;\n\tctx->au_sap2_poc_reset = GF_FALSE;\n\tctx->bottom_field_flag = GF_FALSE;\n}\n\nstatic void naludmx_update_clli_mdcv(GF_NALUDmxCtx *ctx, Bool reset_crc)\n{\n\tif (!ctx->opid) return;\n\n\tif (reset_crc)\n\t\tctx->clli_crc = 0;\n\tif ((ctx->hevc_state && ctx->hevc_state->clli_valid)\n\t\t|| (ctx->vvc_state && ctx->vvc_state->clli_valid)\n\t) {\n\t\tu8 *clli = ctx->hevc_state ? ctx->hevc_state->clli_data : ctx->vvc_state->clli_data;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(clli, 4));\n\t\tctx->clli_crc = gf_crc_32(clli, 4);\n\t}\n\tif (reset_crc)\n\t\tctx->mdcv_crc = 0;\n\n\tif ((ctx->hevc_state && ctx->hevc_state->mdcv_valid)\n\t\t|| (ctx->vvc_state && ctx->vvc_state->mdcv_valid)\n\t) {\n\t\tu8 *mdcv = ctx->hevc_state ? ctx->hevc_state->mdcv_data : ctx->vvc_state->mdcv_data;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_MASTER_DISPLAY_COLOUR, &PROP_DATA(mdcv, 24));\n\t\tctx->mdcv_crc = gf_crc_32(mdcv, 24);\n\t}\n}\n\nstatic void naludmx_set_dolby_vision(GF_NALUDmxCtx *ctx)\n{\n\tu8 dv_cfg[24];\n\tif (!ctx->opid)\n\t\treturn;\n\n\tswitch (ctx->dv_mode) {\n\tcase DVMODE_NONE:\n\tcase DVMODE_CLEAN:\n\t\treturn;\n\t//auto mode, wait until we have RPU or EL to signal profile\n\tcase DVMODE_AUTO:\n\t\tif (!ctx->nb_dv_rpu && !ctx->nb_dv_el) return;\n\t\tbreak;\n\t}\n\n\tu32 dv_level = gf_dolby_vision_level(ctx->width, ctx->height, ctx->cur_fps.num, ctx->cur_fps.den, ctx->codecid);\n\n\tif (ctx->dv_profile==8) {\n\t\tif (ctx->dv_compatid<2) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] DV profile 8 used but dv_compatid not set, defaulting to bt709 (=2)\\n\", ctx->log_name));\n\t\t\tctx->dv_compatid = 3;\n\t\t}\n\t}\n\tu32 dv_ccid = ctx->dv_compatid ? (ctx->dv_compatid-1) : 0;\n\tu32 dv_profile_id = ctx->dv_profile;\n\n\n\t//auto-detect DV profile, check  range, color primaries, EOTF, matrix, and chroma sample location type\n\tif (!ctx->dv_profile) {\n\t\tBool vui_present = GF_FALSE;\n\t\tBool has_non_def = GF_FALSE;\n\t\tu32 luma_bit_depth=8;\n\t\tu32 fr = 0;\n\t\tu32 cp = 2;\n\t\tu32 tc = 2;\n\t\tu32 mx = 2;\n\t\tu32 cl = 0;\n\t\tif (ctx->avc_state && (ctx->avc_state->last_sps_idx>=0)) {\n\t\t\tAVC_SPS *sps = &ctx->avc_state->sps[ctx->avc_state->last_sps_idx];\n\t\t\tluma_bit_depth = sps->luma_bit_depth_m8+8;\n\t\t\tif (sps->vui_parameters_present_flag) {\n\t\t\t\tvui_present = GF_TRUE;\n\t\t\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\t\t\tfr = sps->vui.video_full_range_flag;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (sps->vui.chroma_location_info_present_flag) {\n\t\t\t\t\tcl = (sps->chroma_format==1) ?  sps->vui.chroma_sample_loc_type_top_field : 2;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\t\tcp = sps->vui.colour_primaries;\n\t\t\t\t\ttc = sps->vui.transfer_characteristics;\n\t\t\t\t\tmx = sps->vui.matrix_coefficients;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ctx->hevc_state && (ctx->hevc_state->last_parsed_sps_id>=0)) {\n\t\t\tHEVC_SPS *sps = &ctx->hevc_state->sps[ctx->hevc_state->last_parsed_sps_id];\n\t\t\tluma_bit_depth = sps->bit_depth_luma;\n\t\t\tif (sps->vui_parameters_present_flag) {\n\t\t\t\tvui_present = GF_TRUE;\n\t\t\t\tif (sps->chroma_loc_info_present_flag)\n\t\t\t\t\tcl = (sps->chroma_format_idc==1) ?  sps->chroma_sample_loc_type_top_field : 2;\n\n\t\t\t\t//check profile compat:  range, color primaries, EOTF, matrix, and chroma sample location type\n\t\t\t\tif (sps->video_signal_type_present_flag) {\n\t\t\t\t\tfr = sps->video_full_range_flag;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (sps->colour_description_present_flag) {\n\t\t\t\t\tcp = sps->colour_primaries;\n\t\t\t\t\ttc = sps->transfer_characteristic;\n\t\t\t\t\tmx = sps->matrix_coeffs;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((fr==1) && (cp==2) && (tc==2) && (mx==2) && (cl==0)) dv_ccid=0;\n\t\telse if ((fr==0) && (cp==9) && (tc==16) && (mx==9) && (cl==0)) dv_ccid=1;\n\t\telse if ((fr==0) && (cp==1) && (tc==1) && (mx==1) && (cl==0)) dv_ccid=2;\n\t\telse if ((fr==0) && (cp==9) && (tc==18) && (mx==9) && (cl==2)) dv_ccid=4;\n\t\telse if ((fr==0) && (cp==9) && (tc==14) && (mx==9) && (cl==0)) dv_ccid=4;\n\t\telse if ((fr==0) && (cp==9) && (tc==16) && (mx==9) && (cl==2)) dv_ccid=6;\n\n\t\t//we consider that if no VUI but an EL is present, this will be profile 4 compat SRD\n\t\tif (!vui_present && ctx->nb_dv_el)\n\t\t\tdv_ccid = 2;\n\n\n\t\tif (dv_ccid==2) {\n\t\t\tif (ctx->nb_dv_el) dv_profile_id = 4;\n\t\t\telse if (luma_bit_depth==8) dv_profile_id = 9;\n\t\t\telse dv_profile_id = 8; //or 4\n\t\t}\n\t\t//DV spec: \"Note: H.265 (2018-02) requires top-left chroma siting (VUI = 2), if the decoded video is intended for interpretation\n\t\t// according to ITU-R BT.2020-2 or ITU-R BT.2100-1. Previously, H.265 (2016-12) described the default chroma siting as center left (VUI = 0).\"\n\t\t//we consider that dv_ccid=6 is allowed for profile 8 ( DV without EL) - this is not clearly written in the spec but matches deployed bitstreams\n\t\telse if (dv_ccid==6) {\n\t\t\tdv_profile_id = ctx->nb_dv_el ? 7 : 8;\n\t\t}\n\t\telse if ((dv_ccid==1) || (dv_ccid==4)) dv_profile_id = 8;\n\t\t//default to 5 if no EL, 4 if EL\n\t\telse dv_profile_id = ctx->nb_dv_el ? 4 : 5;\n\n\t\t//DV spec: \"Note: As of the effective date of this specification, all commercially produced profile 4 and profile 5 Dolby Vision bitstreams\n\t\t// have used center-left siting during chroma downsampling, and are distributed without the VUI value for chroma sample location type.\n\t\t// Those bitstreams are compliant with this specification.\"\n\t\t//we treat bitstreams not explicitly signaling vui info as valid and assign the CCID according to DV spec\n\t\tif (!has_non_def) {\n\t\t\tif (dv_profile_id == 4) dv_ccid = 2;\n\t\t\telse if (dv_profile_id == 5) dv_ccid = 0;\n\t\t}\n\t}\n\t//not in auto mode, restore value\n\tif (ctx->dv_compatid)\n\t\tdv_ccid = ctx->dv_compatid-1;\n\n\tmemset(dv_cfg, 0, sizeof(u8)*24);\n\tGF_BitStream *bs = gf_bs_new(dv_cfg, 24, GF_BITSTREAM_WRITE);\n\tgf_bs_write_u8(bs, 1); //version major\n\tgf_bs_write_u8(bs, 0); //version minor\n\tgf_bs_write_int(bs, dv_profile_id, 7);\n\tgf_bs_write_int(bs, dv_level, 6);\n\tgf_bs_write_int(bs, ctx->nb_dv_rpu ? 1 : 0, 1); //rpu present\n\tgf_bs_write_int(bs, ctx->nb_dv_el ? 1 : 0, 1); //el present\n\tgf_bs_write_int(bs, 1, 1); //bl_present_flag always true, we don't split streams\n\tgf_bs_write_int(bs, dv_ccid, 4);\n\t//the rest is zero-reserved\n\tgf_bs_write_int(bs, 0, 28);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_del(bs);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOLBY_VISION, &PROP_DATA(dv_cfg, 24));\n}\n\nstatic void naludmx_check_pid(GF_Filter *filter, GF_NALUDmxCtx *ctx, Bool force_au_flush)\n{\n\tu32 w, h, ew, eh;\n\tu8 *dsi, *dsi_enh;\n\tu32 dsi_size, dsi_enh_size;\n\tu32 crc_cfg, crc_cfg_enh;\n\tGF_Fraction sar;\n\tBool has_hevc_base = GF_TRUE;\n\tBool has_colr_info = GF_FALSE;\n\tBool res;\n\n\tif (ctx->analyze) {\n\t\tif (ctx->opid && !ctx->ps_modified) return;\n\t} else {\n\t\tif (!ctx->ps_modified) return;\n\t\tif (ctx->opid && (!gf_list_count(ctx->sps) || !gf_list_count(ctx->pps)))\n\t\t\treturn;\n\t}\n\tctx->ps_modified = GF_FALSE;\n\n\tdsi = dsi_enh = NULL;\n\n\tif (ctx->notime) {\n\t\tctx->cur_fps = ctx->fps;\n\t\tif (!ctx->cur_fps.num || !ctx->cur_fps.den) {\n\t\t\tctx->cur_fps.num = 25000;\n\t\t\tctx->cur_fps.den = 1000;\n\t\t}\n\t}\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tres = naludmx_create_hevc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar, &has_hevc_base);\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tres = naludmx_create_vvc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar, &has_hevc_base);\n\t} else {\n\t\tres = naludmx_create_avc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar);\n\t}\n\tif (!res) return;\n\n\tcrc_cfg = crc_cfg_enh = 0;\n\tif (dsi) crc_cfg = gf_crc_32(dsi, dsi_size);\n\tif (dsi_enh) crc_cfg_enh = gf_crc_32(dsi_enh, dsi_enh_size);\n\n\tif (!ctx->analyze && (!w || !h)) {\n\t\tif (dsi) gf_free(dsi);\n\t\tif (dsi_enh) gf_free(dsi_enh);\n\t\treturn;\n\t}\n\n\tif (!ctx->opid) {\n\t\tu32 slice_in_au = ctx->nb_slices_in_au;\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\t\tnaludmx_check_dur(filter, ctx);\n\t\tctx->nb_slices_in_au = slice_in_au;\n\t}\n\n\tif ((ctx->crc_cfg == crc_cfg) && (ctx->crc_cfg_enh == crc_cfg_enh)\n\t\t&& (ctx->width==w) && (ctx->height==h)\n\t\t&& (ctx->sar.num * sar.den == ctx->sar.den * sar.num)\n\t) {\n\t\tif (dsi) gf_free(dsi);\n\t\tif (dsi_enh) gf_free(dsi_enh);\n\t\treturn;\n\t}\n\n\tif (force_au_flush) {\n\t\tnaludmx_end_access_unit(ctx);\n\t}\n\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\tif (!ctx->analyze && (gf_list_count(ctx->pck_queue)>1))  {\n\t\tGF_LOG(dsi_enh ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] xPS changed but could not flush frames before signaling state change %s\\n\", ctx->log_name, dsi_enh ? \"- likely scalable xPS update\" : \"!\"));\n\t}\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\n\t//don't change codec type if reframing an ES (for HLS SAES)\n\tif (!ctx->timescale)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\tif (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_ID))\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(1));\n\n\tctx->width = w;\n\tctx->height = h;\n\tctx->sar = sar;\n\tctx->crc_cfg = crc_cfg;\n\tctx->crc_cfg_enh = crc_cfg_enh;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT( ctx->width));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT( ctx->height));\n\tif (ew && eh) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH_MAX, & PROP_UINT( ew ));\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT_MAX, & PROP_UINT( eh ));\n\t}\n\tif (ctx->sar.den)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, & PROP_FRAC(ctx->sar));\n\telse\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, NULL);\n\n\t//if we have a FPS prop, use it\n\tif (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FPS))\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->cur_fps.num));\n\n\tif (ctx->explicit || !has_hevc_base) {\n\t\tu32 enh_cid = GF_CODECID_SVC;\n\t\tif (ctx->codecid==GF_CODECID_HEVC) enh_cid = GF_CODECID_LHVC;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(enh_cid));\n\t\tif (dsi) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) );\n\t} else {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid));\n\t\tif (dsi) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) );\n\t\tif (dsi_enh) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, &PROP_DATA_NO_COPY(dsi_enh, dsi_enh_size) );\n\t}\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tif ((ctx->codecid==GF_CODECID_HEVC) && gf_list_count(ctx->vps) ) {\n\t\tGF_Err e = naludmx_set_hevc_oinf(ctx, NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] Failed to create OINF chunk\\n\", ctx->log_name));\n\t\t}\n\t\tnaludmx_set_hevc_linf(ctx);\n\t}\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\tif (ctx->is_file /* && ctx->index*/) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\t//set interlaced or remove interlaced property\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_INTERLACED, ctx->interlaced ? & PROP_UINT(GF_TRUE) : NULL);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tHEVC_SPS *sps = &ctx->hevc_state->sps[ctx->hevc_state->sps_active_idx];\n\t\tif (sps->colour_description_present_flag) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(sps->colour_primaries) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(sps->transfer_characteristic) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(sps->matrix_coeffs) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(sps->video_full_range_flag) );\n\t\t\thas_colr_info = GF_TRUE;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t} else {\n\t\t/*use the last active SPS*/\n\t\tif (ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui_parameters_present_flag\n\t\t&& ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui.colour_description_present_flag) {\n\t\t\tAVC_VUI *vui = &ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui;\n\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(vui->colour_primaries) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(vui->transfer_characteristics) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(vui->matrix_coefficients) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(vui->video_full_range_flag) );\n\t\t\thas_colr_info = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!has_colr_info) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, NULL);\n\t}\n\n\tnaludmx_update_clli_mdcv(ctx, GF_TRUE);\n\n\tnaludmx_set_dolby_vision(ctx);\n\n}\n\nstatic Bool naludmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tu64 file_pos = 0;\n\tGF_FilterEvent fevt;\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = ctx->dts = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (!ctx->initial_play_done) {\n\t\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t\tif (evt->play.start_range<0.1)\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t\tctx->resume_from = 0;\n\t\t\tctx->nal_store_size = 0;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tif (ctx->start_range && (ctx->index<0)) {\n\t\t\tctx->index = -ctx->index;\n\t\t\tctx->file_loaded = GF_FALSE;\n\t\t\tctx->duration.den = ctx->duration.num = 0;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Play request from %d, building index\\n\", ctx->log_name, ctx->start_range));\n\t\t\tnaludmx_check_dur(filter, ctx);\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\n\t\tif (ctx->start_range) {\n\t\t\tctx->nb_nalus = ctx->nb_i = ctx->nb_p = ctx->nb_b = ctx->nb_sp = ctx->nb_si = ctx->nb_sei = ctx->nb_idr = ctx->nb_cra = 0;\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->cur_fps.num);\n\t\t\t\t\tctx->dts = ctx->dts_last_IDR = ctx->cts;\n\t\t\t\t\tfile_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tctx->seek_gdr_count = ctx->indexes[i-1].roll_count;\n\t\t\t\t\tif (ctx->seek_gdr_count) ctx->first_gdr = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!file_pos) {\n\t\t\t\t//very short streams, input is done before we get notified for play and everything stored in memory: flush\n\t\t\t\tif (gf_filter_pid_is_eos(ctx->ipid) && (ctx->nal_store_size)) {\n\t\t\t\t\tgf_filter_post_process_task(filter);\n\t\t\t\t}\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tctx->nb_frames = 0;\n\t\tctx->nb_nalus = 0;\n\t\tctx->resume_from = 0;\n\t\tctx->nal_store_size = 0;\n\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\tctx->nal_store_size = 0;\n\t\tctx->resume_from = 0;\n\t\tctx->cts = 0;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void naludmx_update_time(GF_NALUDmxCtx *ctx)\n{\n\tassert(ctx->cur_fps.num);\n\n\tif (!ctx->notime) {\n\t\t//very first frame, no dts diff, assume 3000/90k. It should only hurt if we have several frames packet in the first packet sent\n\t\tu64 dts_inc = ctx->cur_fps.den ? ctx->cur_fps.den : 3000;\n\t\tctx->cts += dts_inc;\n\t\tctx->dts += dts_inc;\n\t} else {\n\t\tassert(ctx->cur_fps.den);\n\t\tctx->cts += ctx->cur_fps.den;\n\t\tctx->dts += ctx->cur_fps.den;\n\t}\n}\n\nstatic void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id, u32 tid, u32 lid)\n{\n\tGF_List *list = NULL, *alt_list = NULL;\n\tGF_NALUFFParam *sl;\n\tu32 i, count, crc;\n\tBool flush_au = GF_FALSE;\n\n\tif (!size) return;\n\tcrc = gf_crc_32(data, size);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tflush_au = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tflush_au = GF_TRUE;\n\t\t\tctx->valid_ps_flags |= 1;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tctx->valid_ps_flags |= 1<<1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tflush_au = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tflush_au = GF_TRUE;\n\t\t\tctx->valid_ps_flags |= 1;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tctx->valid_ps_flags |= 1<<1;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tif (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();\n\t\t\tlist = ctx->vvc_dci;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_OPI:\n\t\t\tif (!ctx->vvc_opi) ctx->vvc_opi = gf_list_new();\n\t\t\tlist = ctx->vvc_opi;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tif (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();\n\t\t\tlist = ctx->vvc_aps_pre;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (ps_type) {\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tctx->valid_ps_flags |= 1;\n\t\t\tflush_au = GF_TRUE;\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\tctx->valid_ps_flags |= 1<<1;\n\t\t\tlist = ctx->pps;\n\t\t\talt_list = ctx->pps_svc;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tif (!ctx->sps_ext) ctx->sps_ext = gf_list_new();\n\t\t\tlist = ctx->sps_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tsl = NULL;\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (sl->id != ps_id) {\n\t\t\tsl = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t//same ID, same CRC, we don't change our state\n\t\tif (sl->crc == crc) return;\n\t\tbreak;\n\t}\n\t//handle alt PPS list for SVC\n\tif (!sl && alt_list) {\n\t\tcount = gf_list_count(alt_list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsl = gf_list_get(alt_list, i);\n\t\t\tif (sl->id != ps_id) {\n\t\t\t\tsl = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//same ID, same CRC, we don't change our state\n\t\t\tif (sl->crc == crc) return;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (lid || tid) flush_au = GF_FALSE;\n\n\tif (sl) {\n\t\t//otherwise we keep this new param set\n\t\tsl->data = gf_realloc(sl->data, size);\n\t\tmemcpy(sl->data, data, size);\n\t\tsl->size = size;\n\t\tsl->crc = crc;\n\t\tctx->ps_modified = GF_TRUE;\n\t\t//flush AU if we have a slice\n\t\tif (ctx->opid && flush_au && ctx->first_pck_in_au && ctx->nb_slices_in_au) {\n\t\t\tnaludmx_end_access_unit(ctx);\n\t\t}\n\t\treturn;\n\t}\n\t//TODO we might want to purge the list after a while !!\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char) * size);\n\tif (!sl->data) {\n\t\tgf_free(sl);\n\t\treturn;\n\t}\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tsl->crc = crc;\n\n\tctx->ps_modified = GF_TRUE;\n\t//flush AU if we have a slice\n\tif (ctx->opid && flush_au && ctx->first_pck_in_au && ctx->nb_slices_in_au) {\n\t\tnaludmx_end_access_unit(ctx);\n\t}\n\tgf_list_add(list, sl);\n}\n\nstatic void naludmx_finalize_au_flags(GF_NALUDmxCtx *ctx)\n{\n\tu64 ts;\n\tBool is_rap = GF_FALSE;\n\n\tif (!ctx->first_pck_in_au)\n\t\treturn;\n\tif (ctx->au_sap) {\n\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, ctx->au_sap);\n\t\tif ((ctx->au_sap == GF_FILTER_SAP_1) || ctx->au_sap2_poc_reset) {\n\t\t\tctx->dts_last_IDR = gf_filter_pck_get_dts(ctx->first_pck_in_au);\n\t\t\tif (ctx->is_paff)\n\t\t\t\tctx->dts_last_IDR *= 2;\n\t\t}\n\t\tif (ctx->au_sap <= GF_FILTER_SAP_3) {\n\t\t\tis_rap = GF_TRUE;\n\t\t}\n\t}\n\telse if (ctx->has_islice && ctx->force_sync && (ctx->sei_recovery_frame_count==0)) {\n\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, GF_FILTER_SAP_1);\n\t\tif (!ctx->use_opengop_gdr) {\n\t\t\tctx->use_opengop_gdr = 1;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] Forcing non-IDR samples with I slices to be marked as sync points - resulting file will not be ISOBMFF compliant\\n\", ctx->log_name));\n\t\t}\n\t\tis_rap = GF_TRUE;\n\t}\n\t/*set roll info sampleGroups info*/\n\telse if (!ctx->au_sap && ( (ctx->sei_recovery_frame_count >= 0) || ctx->has_islice) ) {\n\t\t/*generic GDR*/\n\t\tif (ctx->sei_recovery_frame_count > 0) {\n\t\t\tif (!ctx->use_opengop_gdr) ctx->use_opengop_gdr = 1;\n\t\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, GF_FILTER_SAP_4);\n\t\t\tgf_filter_pck_set_roll_info(ctx->first_pck_in_au, ctx->sei_recovery_frame_count);\n\t\t}\n\t\t/*open-GOP*/\n\t\telse if ((ctx->sei_recovery_frame_count == 0) && ctx->has_islice) {\n\t\t\tif (!ctx->use_opengop_gdr) ctx->use_opengop_gdr = 2;\n\t\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, GF_FILTER_SAP_3);\n\t\t\tis_rap = GF_TRUE;\n\t\t}\n\t}\n\tif (ctx->is_paff) {\n\t\tgf_filter_pck_set_interlaced(ctx->first_pck_in_au, ctx->bottom_field_flag ? 2 : 1);\n\t}\n\n\t//if TS is set, the packet was the first in AU in the input timed packet (eg PES), we reuse the input timing\n\tts = gf_filter_pck_get_cts(ctx->first_pck_in_au);\n\tif (ts == GF_FILTER_NO_TS) {\n\t\t/*we store the POC (last POC minus the poc shift) as the CTS offset and re-update the CTS when dispatching*/\n\t\tassert(ctx->last_poc >= ctx->poc_shift);\n\t\tgf_filter_pck_set_cts(ctx->first_pck_in_au, CTS_POC_OFFSET_SAFETY + ctx->last_poc - ctx->poc_shift);\n\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\tgf_filter_pck_set_carousel_version(ctx->first_pck_in_au, 1);\n\t}\n\n\tif (ctx->subsamp_buffer_size) {\n\t\tgf_filter_pck_set_property(ctx->first_pck_in_au, GF_PROP_PCK_SUBS, &PROP_DATA(ctx->subsamp_buffer, ctx->subsamp_buffer_size) );\n\t\tctx->subsamp_buffer_size = 0;\n\t\tctx->subs_mapped_bytes = 0;\n\t}\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = (is_rap) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->has_ref_slices ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \tflags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(ctx->first_pck_in_au, flags);\n\t}\n\tctx->has_ref_slices = GF_FALSE;\n\tctx->has_redundant = GF_FALSE;\n\n\tif ((ctx->hevc_state && ctx->hevc_state->clli_valid)\n\t\t|| (ctx->vvc_state && ctx->vvc_state->clli_valid)\n\t) {\n\t\tu8 *clli = ctx->hevc_state ? ctx->hevc_state->clli_data : ctx->vvc_state->clli_data;\n\t\tu32 crc = gf_crc_32(clli, 4);\n\t\tif (!ctx->clli_crc) {\n\t\t\tnaludmx_update_clli_mdcv(ctx, GF_FALSE);\n\t\t}\n\n\t\tif (crc != ctx->clli_crc) {\n\t\t\tgf_filter_pck_set_property(ctx->first_pck_in_au, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(clli, 4));\n\t\t}\n\t}\n\tif ((ctx->hevc_state && ctx->hevc_state->mdcv_valid)\n\t\t|| (ctx->vvc_state && ctx->vvc_state->mdcv_valid)\n\t) {\n\t\tu8 *mdcv = ctx->hevc_state ? ctx->hevc_state->mdcv_data : ctx->vvc_state->mdcv_data;\n\t\tu32 crc = gf_crc_32(mdcv, 24);\n\t\tif (!ctx->mdcv_crc) {\n\t\t\tnaludmx_update_clli_mdcv(ctx, GF_FALSE);\n\t\t}\n\t\tif (crc != ctx->mdcv_crc) {\n\t\t\tgf_filter_pck_set_property(ctx->first_pck_in_au, GF_PROP_PID_MASTER_DISPLAY_COLOUR, &PROP_DATA(mdcv, 24));\n\t\t}\n\t}\n\tif (ctx->hevc_state)\n\t\tctx->hevc_state->clli_valid = ctx->hevc_state->mdcv_valid = 0;\n\tif (ctx->vvc_state)\n\t\tctx->vvc_state->clli_valid = ctx->vvc_state->mdcv_valid = 0;\n\n\n\t//if we reuse input packets timing, we can dispatch asap.\n\t//otherwise if poc probe is done (we know the min_poc_diff between images) and we are not in strict mode, dispatch asap\n\t//otherwise we will need to wait for the next ref frame to make sure we know all pocs ...\n\tif (!ctx->notime || (!ctx->strict_poc && ctx->poc_probe_done) )\n\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\n\tctx->first_pck_in_au = NULL;\n}\n\nstatic void naludmx_update_nalu_maxsize(GF_NALUDmxCtx *ctx, u32 size)\n{\n\tif (ctx->max_nalu_size < size) {\n\t\tctx->max_nalu_size = size;\n\t\tif (size > ctx->max_nalu_size_allowed) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] nal size %d larger than max allowed size %d - change import settings\\n\", ctx->log_name, size, ctx->max_nalu_size_allowed ));\n\t\t}\n\t}\n}\n\n\nGF_FilterPacket *naludmx_start_nalu(GF_NALUDmxCtx *ctx, u32 nal_size, Bool skip_nal_field, Bool *au_start, u8 **pck_data)\n{\n\tGF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(ctx->opid, nal_size + (skip_nal_field ? 0 : ctx->nal_length), pck_data);\n\tif (!dst_pck) return NULL;\n\n\tif (!skip_nal_field) {\n\t\tif (!ctx->bs_w) ctx->bs_w = gf_bs_new(*pck_data, ctx->nal_length, GF_BITSTREAM_WRITE);\n\t\telse gf_bs_reassign_buffer(ctx->bs_w, *pck_data, ctx->nal_length);\n\t\tgf_bs_write_int(ctx->bs_w, nal_size, 8*ctx->nal_length);\n\t}\n\n\tif (*au_start) {\n\t\tctx->first_pck_in_au = dst_pck;\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);\n\t\t//we reuse the timing of the input packet for the first nal of the first frame starting in this packet\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t} else {\n\t\t\t//we don't set the CTS, it will be set once we detect frame end\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\t}\n\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\tgf_filter_pck_set_carousel_version(dst_pck, ctx->notime ? 1 : 0);\n\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->pck_duration ? ctx->pck_duration : ctx->cur_fps.den);\n\t\tif (ctx->in_seek) {\n\t\t\tgf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\t\tif (ctx->first_gdr) {\n\t\t\t\tctx->first_gdr = GF_FALSE;\n\t\t\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, GF_FILTER_SAP_4);\n\t\t\t}\n\t\t}\n\n\t\tnaludmx_update_time(ctx);\n\t\t*au_start = GF_FALSE;\n\t\tctx->nb_frames++;\n\t} else {\n\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t}\n\tnaludmx_update_nalu_maxsize(ctx, nal_size);\n\n\tnaludmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE);\n\n\treturn dst_pck;\n}\n\nvoid naludmx_add_subsample(GF_NALUDmxCtx *ctx, u32 subs_size, u8 subs_priority, u32 subs_reserved)\n{\n\tif (ctx->subsamp_buffer_alloc < ctx->subsamp_buffer_size+14 ) {\n\t\tctx->subsamp_buffer_alloc = ctx->subsamp_buffer_size+14;\n\t\tctx->subsamp_buffer = gf_realloc(ctx->subsamp_buffer, ctx->subsamp_buffer_alloc);\n\t}\n\tassert(ctx->subsamp_buffer);\n\tgf_bs_reassign_buffer(ctx->bs_w, ctx->subsamp_buffer + ctx->subsamp_buffer_size, 14);\n\tgf_bs_write_u32(ctx->bs_w, 0); //flags\n\tgf_bs_write_u32(ctx->bs_w, subs_size + ctx->nal_length);\n\tgf_bs_write_u32(ctx->bs_w, subs_reserved); //reserved\n\tgf_bs_write_u8(ctx->bs_w, subs_priority); //priority\n\tgf_bs_write_u8(ctx->bs_w, 0); //discardable - todo\n\tctx->subsamp_buffer_size += 14;\n\tctx->subs_mapped_bytes += subs_size + ctx->nal_length;\n}\n\nstatic void naludmx_push_prefix(GF_NALUDmxCtx *ctx, u8 *data, u32 size, Bool avc_sei_rewrite)\n{\n\tif (ctx->sei_buffer_alloc < ctx->sei_buffer_size + size + ctx->nal_length) {\n\t\tctx->sei_buffer_alloc = ctx->sei_buffer_size + size + ctx->nal_length;\n\t\tctx->sei_buffer = gf_realloc(ctx->sei_buffer, ctx->sei_buffer_alloc);\n\t}\n\n\tif (!ctx->bs_w) ctx->bs_w = gf_bs_new(ctx->sei_buffer + ctx->sei_buffer_size, ctx->nal_length + size, GF_BITSTREAM_WRITE);\n\telse gf_bs_reassign_buffer(ctx->bs_w, ctx->sei_buffer + ctx->sei_buffer_size, ctx->nal_length + size);\n\tgf_bs_write_int(ctx->bs_w, size, 8*ctx->nal_length);\n\tmemcpy(ctx->sei_buffer + ctx->sei_buffer_size + ctx->nal_length, data, size);\n\n\tif (avc_sei_rewrite) {\n\t\tu32 rw_sei_size = gf_avc_reformat_sei(ctx->sei_buffer + ctx->sei_buffer_size + ctx->nal_length, size, ctx->seirw, ctx->avc_state);\n\t\tif (rw_sei_size < size) {\n\t\t\tgf_bs_seek(ctx->bs_w, 0);\n\t\t\tgf_bs_write_int(ctx->bs_w, rw_sei_size, 8*ctx->nal_length);\n\t\t\tsize = rw_sei_size;\n\t\t}\n\t}\n\tctx->sei_buffer_size += size + ctx->nal_length;\n}\n\nstatic s32 naludmx_parse_nal_hevc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool *skip_nal, Bool *is_slice, Bool *is_islice)\n{\n\ts32 ps_idx = 0;\n\ts32 res;\n\tu8 nal_unit_type, temporal_id, layer_id;\n\t*skip_nal = GF_FALSE;\n\n\tif (size<2) return -1;\n\n\tgf_bs_reassign_buffer(ctx->bs_r, data, size);\n\tres = gf_hevc_parse_nalu_bs(ctx->bs_r, ctx->hevc_state, &nal_unit_type, &temporal_id, &layer_id);\n\tctx->nb_nalus++;\n\n\tif (res < 0) {\n\t\tif (res == -1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_unit_type));\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t}\n\n\tif (layer_id && ctx->nosvc) {\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\t}\n\n\tswitch (nal_unit_type) {\n\tcase GF_HEVC_NALU_VID_PARAM:\n\t\tif (ctx->novpsext) {\n\t\t\t//this may modify nal_size, but we don't use it for bitstream reading\n\t\t\tps_idx = gf_hevc_read_vps_ex(data, &size, ctx->hevc_state, GF_TRUE);\n\t\t} else {\n\t\t\tps_idx = ctx->hevc_state->last_parsed_vps_id;\n\t\t}\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Video Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_HEVC_NALU_VID_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\tps_idx = ctx->hevc_state->last_parsed_sps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_HEVC_NALU_SEQ_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\tps_idx = ctx->hevc_state->last_parsed_pps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Picture Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_HEVC_NALU_PIC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEI_PREFIX:\n\t\tgf_hevc_parse_sei(data, size, ctx->hevc_state);\n\t\tif (!ctx->nosei) {\n\t\t\tctx->nb_sei++;\n\t\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t} else {\n\t\t\tctx->nb_nalus--;\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEI_SUFFIX:\n\t\tif (! ctx->is_playing) return 0;\n\t\tif (ctx->nosei) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t\tctx->nb_nalus--;\n\t\t} else {\n\t\t\tctx->nb_sei++;\n\t\t}\n\t\tbreak;\n\n\t/*slice_segment_layer_rbsp*/\n\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tif (! ctx->is_playing) return 0;\n\t\t*is_slice = GF_TRUE;\n\t\tctx->last_layer_id = layer_id;\n\t\tctx->last_temporal_id = temporal_id;\n\t\tif (! *skip_nal) {\n\t\t\tswitch (ctx->hevc_state->s_info.slice_type) {\n\t\t\tcase GF_HEVC_SLICE_TYPE_P:\n\t\t\t\tif (layer_id) ctx->nb_e_p++;\n\t\t\t\telse ctx->nb_p++;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_SLICE_TYPE_I:\n\t\t\t\tif (layer_id) ctx->nb_e_i++;\n\t\t\t\telse ctx->nb_i++;\n\t\t\t\t*is_islice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_SLICE_TYPE_B:\n\t\t\t\tif (layer_id) ctx->nb_e_b++;\n\t\t\t\telse ctx->nb_b++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\tctx->nb_aud++;\n\t\tif (!ctx->audelim) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else if (!ctx->opid) {\n\t\t\tctx->has_initial_aud = GF_TRUE;\n\t\t\tmemcpy(ctx->init_aud, data, 3);\n\t\t}\n\t\tbreak;\n\t/*remove*/\n\tcase GF_HEVC_NALU_FILLER_DATA:\n\tcase GF_HEVC_NALU_END_OF_SEQ:\n\tcase GF_HEVC_NALU_END_OF_STREAM:\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\n\t//parsing is partial, see https://github.com/DolbyLaboratories/dlb_mp4base/blob/70a2e1d4d99a8439b7b8087bf50dd503eeea2291/src/esparser/parser_hevc.c#L1233\n\tcase GF_HEVC_NALU_DV_RPU:\n\t\tif (ctx->dv_mode==DVMODE_CLEAN) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_rpu ++;\n\t\t\tif (ctx->nb_dv_rpu==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\tcase GF_HEVC_NALU_DV_EL:\n\t\tif ((ctx->dv_mode==DVMODE_CLEAN) || (ctx->dv_mode==DVMODE_SINGLE)) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_el ++;\n\t\t\tif (ctx->nb_dv_el==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (! ctx->is_playing) return 0;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] NAL Unit type %d not handled - adding\\n\", ctx->log_name, nal_unit_type));\n\t\tbreak;\n\t}\n\tif (*skip_nal) return res;\n\n\tctx->linf[layer_id].layer_id_plus_one = layer_id + 1;\n\tif (! ctx->linf[layer_id].max_temporal_id ) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].max_temporal_id < temporal_id) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\n\tif (! ctx->linf[layer_id].min_temporal_id ) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].min_temporal_id > temporal_id) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\n\tif (ctx->max_temporal_id[layer_id] < temporal_id)\n\t\tctx->max_temporal_id[layer_id] = temporal_id;\n\tif (ctx->min_layer_id > layer_id) ctx->min_layer_id = layer_id;\n\treturn res;\n}\n\n\nstatic s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool *skip_nal, Bool *is_slice, Bool *is_islice)\n{\n\ts32 ps_idx = 0;\n\ts32 res;\n\tu8 nal_unit_type, temporal_id, layer_id;\n\t*skip_nal = GF_FALSE;\n\n\tif (size<2) return -1;\n\tgf_bs_reassign_buffer(ctx->bs_r, data, size);\n\tres = gf_vvc_parse_nalu_bs(ctx->bs_r, ctx->vvc_state, &nal_unit_type, &temporal_id, &layer_id);\n\tctx->nb_nalus++;\n\n\tif (res < 0) {\n\t\tif (res == -1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_unit_type));\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t}\n\n\tif (layer_id && ctx->nosvc) {\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\t}\n\n\tswitch (nal_unit_type) {\n\tcase GF_VVC_NALU_VID_PARAM:\n\t\tif (ctx->novpsext) {\n\t\t\t//this may modify nal_size, but we don't use it for bitstream reading\n//\t\t\tps_idx = gf_hevc_read_vps_ex(data, &size, ctx->hevc_state, GF_TRUE);\n\t\t\tps_idx = ctx->vvc_state->last_parsed_vps_id;\n\t\t} else {\n\t\t\tps_idx = ctx->vvc_state->last_parsed_vps_id;\n\t\t}\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Video Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_VID_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\tps_idx = ctx->vvc_state->last_parsed_sps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_SEQ_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_PIC_PARAM:\n\t\tps_idx = ctx->vvc_state->last_parsed_pps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Picture Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_PIC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_DEC_PARAM:\n\t\tps_idx = 0;\n\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_DEC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_OPI:\n\t\tps_idx = 0;\n\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_OPI, ps_idx, temporal_id, layer_id);\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t//for now we keep APS in the stream\n#if 0\n\t\tps_idx = ctx->vvc_state->last_parsed_aps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Decoder Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_APS_PREFIX, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n#else\n\t\t//same logic as SEI\n\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t*skip_nal = GF_TRUE;\n#endif\n\t\tbreak;\n\tcase GF_VVC_NALU_SEI_PREFIX:\n\t\tgf_vvc_parse_sei(data, size, ctx->vvc_state);\n\t\tif (!ctx->nosei) {\n\t\t\tctx->nb_sei++;\n\n\t\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t} else {\n\t\t\tctx->nb_nalus--;\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_SEI_SUFFIX:\n\t\tif (! ctx->is_playing) return 0;\n\t\tgf_vvc_parse_sei(data, size, ctx->vvc_state);\n\t\tif (ctx->nosei) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t\tctx->nb_nalus--;\n\t\t} else {\n\t\t\tctx->nb_sei++;\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_PIC_HEADER:\n\t\tif (! ctx->is_playing) return 0;\n\t\tbreak;\n\n\t/*slice_segment_layer_rbsp*/\n\tcase GF_VVC_NALU_SLICE_TRAIL:\n\tcase GF_VVC_NALU_SLICE_STSA:\n\tcase GF_VVC_NALU_SLICE_RADL:\n\tcase GF_VVC_NALU_SLICE_RASL:\n\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_VVC_NALU_SLICE_CRA:\n\tcase GF_VVC_NALU_SLICE_GDR:\n\t\tif (! ctx->is_playing) return 0;\n\t\t*is_slice = GF_TRUE;\n\t\tctx->last_layer_id = layer_id;\n\t\tctx->last_temporal_id = temporal_id;\n\t\tif (! *skip_nal) {\n\t\t\tswitch (ctx->vvc_state->s_info.slice_type) {\n\t\t\tcase GF_VVC_SLICE_TYPE_P:\n\t\t\t\tif (layer_id) ctx->nb_e_p++;\n\t\t\t\telse ctx->nb_p++;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_I:\n\t\t\t\tif (layer_id) ctx->nb_e_i++;\n\t\t\t\telse ctx->nb_i++;\n\t\t\t\t*is_islice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_B:\n\t\t\t\tif (layer_id) ctx->nb_e_b++;\n\t\t\t\telse ctx->nb_b++;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_UNKNOWN:\n\t\t\t\tctx->vvc_no_stats = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_ACCESS_UNIT:\n\t\tctx->nb_aud++;\n\t\t//no skip AUD in VVC\n\n\t\tif (!ctx->opid) {\n\t\t\tctx->has_initial_aud = GF_TRUE;\n\t\t\tmemcpy(ctx->init_aud, data, 3);\n\t\t}\n\t\tbreak;\n\t/*remove*/\n\tcase GF_VVC_NALU_FILLER_DATA:\n\tcase GF_VVC_NALU_END_OF_SEQ:\n\tcase GF_VVC_NALU_END_OF_STREAM:\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\n\tdefault:\n\t\tif (! ctx->is_playing) return 0;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] NAL Unit type %d not handled - adding\\n\", ctx->log_name, nal_unit_type));\n\t\tbreak;\n\t}\n\tif (*skip_nal) return res;\n\n\tctx->linf[layer_id].layer_id_plus_one = layer_id + 1;\n\tif (! ctx->linf[layer_id].max_temporal_id ) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].max_temporal_id < temporal_id) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\n\tif (! ctx->linf[layer_id].min_temporal_id ) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].min_temporal_id > temporal_id) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\n\tif (ctx->max_temporal_id[layer_id] < temporal_id)\n\t\tctx->max_temporal_id[layer_id] = temporal_id;\n\tif (ctx->min_layer_id > layer_id) ctx->min_layer_id = layer_id;\n\treturn res;\n}\n\nstatic s32 naludmx_parse_nal_avc(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 nal_type, Bool *skip_nal, Bool *is_slice, Bool *is_islice)\n{\n\ts32 ps_idx = 0;\n\ts32 res = 0;\n\n\tif (!size) return -1;\n\tgf_bs_reassign_buffer(ctx->bs_r, data, size);\n\t*skip_nal = GF_FALSE;\n\tres = gf_avc_parse_nalu(ctx->bs_r, ctx->avc_state);\n\tif (res < 0) {\n\t\tif (res == -1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_type));\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t}\n\tctx->nb_nalus++;\n\n\tswitch (nal_type) {\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tps_idx = ctx->avc_state->last_ps_idx;\n\t\tif (ps_idx<0) {\n\t\t\tif (ctx->avc_state->sps[0].profile_idc) {\n\t\t\t\tGF_LOG(ctx->avc_state->sps[0].profile_idc ? GF_LOG_WARNING : GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set\\n\", ctx->log_name));\n\t\t\t}\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM, ps_idx, 0, 0);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tps_idx = ctx->avc_state->last_ps_idx;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Picture Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_PIC_PARAM, ps_idx, 0, 0);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tps_idx = ctx->avc_state->last_ps_idx;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set Extension\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM_EXT, ps_idx, 0, 0);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEI:\n\t\tif (ctx->avc_state->sps_active_idx != -1) {\n\t\t\tnaludmx_push_prefix(ctx, data, size, GF_TRUE);\n\n\t\t\t*skip_nal = GF_TRUE;\n\n\t\t\tif (ctx->nosei) {\n\t\t\t\tctx->sei_buffer_size = 0;\n\t\t\t} else {\n\t\t\t\tctx->nb_sei++;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\tctx->nb_aud++;\n\t\tif (!ctx->audelim) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else if (!ctx->opid) {\n\t\t\tctx->has_initial_aud = GF_TRUE;\n\t\t\tmemcpy(ctx->init_aud, data, 2);\n\t\t}\n\t\treturn 1;\n\t/*remove*/\n\tcase GF_AVC_NALU_FILLER_DATA:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\t//update stats\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\tcase GF_AVC_NALU_IDR_SLICE:\n\t\t*is_slice = GF_TRUE;\n\t\tswitch (ctx->avc_state->s_info.slice_type) {\n\t\tcase GF_AVC_TYPE_P:\n\t\tcase GF_AVC_TYPE2_P:\n\t\t\tctx->nb_p++;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_I:\n\t\tcase GF_AVC_TYPE2_I:\n\t\t\tctx->nb_i++;\n\t\t\t*is_islice = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_B:\n\t\tcase GF_AVC_TYPE2_B:\n\t\t\tctx->nb_b++;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_SP:\n\t\tcase GF_AVC_TYPE2_SP:\n\t\t\tctx->nb_sp++;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_SI:\n\t\tcase GF_AVC_TYPE2_SI:\n\t\t\tctx->nb_si++;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tif (!ctx->explicit) {\n\t\t\tu32 i;\n\t\t\tfor (i = 0; i < gf_list_count(ctx->pps); i ++) {\n\t\t\t\tGF_NALUFFParam *slc = (GF_NALUFFParam*)gf_list_get(ctx->pps, i);\n\t\t\t\tif (ctx->avc_state->s_info.pps && ctx->avc_state->s_info.pps->id == slc->id) {\n\t\t\t\t\t/* This PPS is used by an SVC NAL unit, it should be moved to the SVC Config Record) */\n\t\t\t\t\tgf_list_rem(ctx->pps, i);\n\t\t\t\t\ti--;\n\t\t\t\t\tif (!ctx->pps_svc) ctx->pps_svc = gf_list_new();\n\t\t\t\t\tgf_list_add(ctx->pps_svc, slc);\n\t\t\t\t\tctx->ps_modified = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*is_slice = GF_TRUE;\n\t\t//we disable temporal scalability when parsing mvc - never used and many encoders screw up POC in enhancemen\n\t\tif (ctx->is_mvc && (res>=0)) {\n\t\t\tres=0;\n\t\t\tctx->avc_state->s_info.poc = ctx->last_poc;\n\t\t}\n        if (ctx->avc_state->s_info.sps) {\n            switch (ctx->avc_state->s_info.slice_type) {\n            case GF_AVC_TYPE_P:\n            case GF_AVC_TYPE2_P:\n                ctx->avc_state->s_info.sps->nb_ep++;\n                break;\n            case GF_AVC_TYPE_I:\n            case GF_AVC_TYPE2_I:\n                ctx->avc_state->s_info.sps->nb_ei++;\n                break;\n            case GF_AVC_TYPE_B:\n            case GF_AVC_TYPE2_B:\n                ctx->avc_state->s_info.sps->nb_eb++;\n                break;\n            }\n        }\n        break;\n\tcase GF_AVC_NALU_SLICE_AUX:\n\t\t*is_slice = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_DV_RPU:\n\t\tif (ctx->dv_mode==DVMODE_CLEAN) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_rpu ++;\n\t\t\tif (ctx->nb_dv_rpu==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_DV_EL:\n\t\tif ((ctx->dv_mode==DVMODE_CLEAN) || (ctx->dv_mode==DVMODE_SINGLE)) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_el ++;\n\t\t\tif (ctx->nb_dv_el==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nstatic void naldmx_switch_timestamps(GF_NALUDmxCtx *ctx, GF_FilterPacket *pck)\n{\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->notime) {\n\t\tBool cts_swap=GF_FALSE;\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tctx->prev_cts = ctx->cts;\n\t\t\tctx->cts = ts;\n\t\t\tcts_swap=GF_TRUE;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (ctx->full_au_source) {\n\t\t\t\tctx->prev_dts = ctx->dts;\n\t\t\t\tctx->dts = ts;\n\t\t\t} else {\n\t\t\t\tGF_FilterClockType ck_type = gf_filter_pid_get_clock_info(ctx->ipid, NULL, NULL);\n\t\t\t\tif (ck_type==GF_FILTER_CLOCK_PCR_DISC)\n\t\t\t\t\tctx->dts = ts;\n\t\t\t\telse if (ctx->dts<ts)\n\t\t\t\t\tctx->dts=ts;\n\n\t\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\t\tu64 diff = ts;\n\t\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\t\tif (!ctx->cur_fps.den) {\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\t\t//we initialized wiith 3000, patch back\n\t\t\t\t\t\tif (ctx->dts && (ctx->dts!=ts)) {\n\t\t\t\t\t\t\tctx->dts -= 3000;\n\t\t\t\t\t\t\tctx->dts += diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx->prev_cts && cts_swap) {\n\t\t\t\t\t\t\tctx->prev_cts -= 3000;\n\t\t\t\t\t\t\tctx->prev_cts += diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ctx->cur_fps.den > diff)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\n\t\t\t\t\tctx->prev_dts = ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->pck_duration = gf_filter_pck_get_duration(pck);\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t//store framing flags. If input_is_au_start, the first NAL of the first frame beginning in this packet will\n\t\t//use the DTS/CTS of the input packet, otherwise we will use our internal POC recompute\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, NULL);\n\t}\n}\n\nstatic void naldmx_check_timestamp_switch(GF_NALUDmxCtx *ctx, u32 *nalu_store_before, u32 bytes_drop, Bool *drop_packet, GF_FilterPacket *pck)\n{\n\tif (*nalu_store_before) {\n\t\tif (*nalu_store_before > bytes_drop) {\n\t\t\t*nalu_store_before -= bytes_drop;\n\t\t} else {\n\t\t\t//all data from previous frame consumed, update timestamps with info from current packet\n\t\t\t*nalu_store_before = 0;\n\t\t\tnaldmx_switch_timestamps(ctx, pck);\n\t\t\tif (*drop_packet) {\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t*drop_packet = GF_FALSE;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void naldmx_bs_log(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3)\n{\n\tGF_NALUDmxCtx *ctx = (GF_NALUDmxCtx *) udta;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\" %s\", field_name));\n\tif (idx1>=0) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"_%d\", idx1));\n\t\tif (idx2>=0) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"_%d\", idx2));\n\t\t\tif (idx3>=0) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"_%d\", idx3));\n\t\t\t}\n\t\t}\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"=\\\"\"LLD, field_val));\n\tif ((ctx->bsdbg==2) && ((s32) nb_bits > 1) )\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"(%u)\", nb_bits));\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"\\\" \"));\n}\n\n\nGF_Err naludmx_process(GF_Filter *filter)\n{\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu8 *start;\n\tu32 nalu_before, nalu_store_before;\n\ts32 remain;\n\tBool is_eos, drop_packet;\n\tu64 byte_offset;\n\nrestart:\n\n\tnalu_store_before = 0;\n\tis_eos = GF_FALSE;\n\tdrop_packet = GF_FALSE;\n\tbyte_offset = GF_FILTER_NO_BO;\n\tnalu_before = ctx->nb_nalus;\n\n\t//always reparse duration\n\tif (!ctx->file_loaded)\n\t\tnaludmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!ctx->resume_from && !pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (ctx->nal_store_size) {\n\t\t\t\tif (!ctx->is_playing)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tstart = ctx->nal_store;\n\t\t\t\tremain = ctx->nal_store_size;\n\t\t\t\tis_eos = GF_TRUE;\n\t\t\t\tgoto naldmx_flush;\n\t\t\t}\n\t\t\tif (ctx->first_pck_in_au) {\n\t\t\t\tnaludmx_finalize_au_flags(ctx);\n\t\t\t}\n\t\t\t//single-frame stream\n\t\t\tif (!ctx->poc_diff) ctx->poc_diff = 1;\n\t\t\tctx->strict_poc = STRICT_POC_OFF;\n\t\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\tif (!ctx->opid) return GF_EOS;\n\n\t\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_MAX_NALU_SIZE, &PROP_UINT(ctx->max_nalu_size) );\n\t\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\t\tnaludmx_set_hevc_oinf(ctx, ctx->max_temporal_id);\n\t\t\t\tnaludmx_set_hevc_linf(ctx);\n\t\t\t\tgf_filter_pid_set_info_str(ctx->opid, \"hevc:min_lid\", &PROP_UINT(ctx->min_layer_id) );\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\n\t\t\tif ((ctx->valid_ps_flags & 0x03) != 0x03) {\n\t\t\t\tctx->nb_nalus = 0;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tif (ctx->nb_nalus && !(ctx->nb_i|ctx->nb_p|ctx->nb_b|ctx->nb_idr|ctx->nb_si|ctx->nb_sp|ctx->nb_cra)) {\n\t\t\t\tctx->nb_nalus = 0;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing && ctx->opid)\n\t\treturn GF_OK;\n\n\t//if we have bytes from previous packet in the header, we cannot switch timing until we know what these bytes are\n\tif (!ctx->nal_store_size)\n\t\tnaldmx_switch_timestamps(ctx, pck);\n\n\tnalu_store_before = ctx->nal_store_size;\n\tif (!ctx->resume_from && pck) {\n\t\tu32 pck_size;\n\t\tconst u8 *data = gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (ctx->nal_store_alloc < ctx->nal_store_size + pck_size) {\n\t\t\tctx->nal_store_alloc = ctx->nal_store_size + pck_size;\n\t\t\tctx->nal_store = gf_realloc(ctx->nal_store, sizeof(char)*ctx->nal_store_alloc);\n\t\t\tif (!ctx->nal_store) {\n\t\t\t\tctx->nal_store_alloc = 0;\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\tif (byte_offset != GF_FILTER_NO_BO)\n\t\t\tbyte_offset -= ctx->nal_store_size;\n\t\tmemcpy(ctx->nal_store + ctx->nal_store_size, data, sizeof(char)*pck_size);\n\t\tctx->nal_store_size += pck_size;\n\t\tdrop_packet = GF_TRUE;\n\t}\n\tstart = ctx->nal_store;\n\tremain = ctx->nal_store_size;\n\n\tif (ctx->resume_from) {\n\t\tif (ctx->opid && gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\tassert(ctx->resume_from < ctx->nal_store_size);\n\t\tstart += ctx->resume_from;\n\t\tremain -= ctx->resume_from;\n\t\tctx->resume_from = 0;\n\n\t\tif (!pck && gf_filter_pid_is_eos(ctx->ipid))\n\t\t\tis_eos = GF_TRUE;\n\t}\n\nnaldmx_flush:\n\tif (!ctx->bs_r) {\n\t\tctx->bs_r = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\n#ifndef GPAC_DISABLE_LOG\n\t\tif (ctx->bsdbg && gf_log_tool_level_on(GF_LOG_MEDIA, GF_LOG_DEBUG))\n\t\t\tgf_bs_set_logger(ctx->bs_r, naldmx_bs_log, ctx);\n#endif\n\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs_r, start, remain);\n\t}\n\n    assert(remain>=0);\n\n\twhile (remain) {\n\t\tu8 *pck_data;\n\t\tu8 *nal_data;\n\t\tu32 nal_size;\n\t\ts32 current;\n\t\tBool skip_nal = GF_FALSE;\n\t\tu32 sc_size=0;\n\t\tu32 nal_type = 0;\n\t\tu32 nal_ref_idc = 0;\n\t\ts32 next=0;\n\t\tu32 next_sc_size=0;\n\t\ts32 nal_parse_result;\n\t\tBool slice_is_idr, slice_force_ref;\n\t\tBool is_slice = GF_FALSE;\n\t\tBool is_islice = GF_FALSE;\n\t\tBool bottom_field_flag = GF_FALSE;\n\t\tBool au_start;\n\t\tu32 avc_svc_subs_reserved = 0;\n\t\tu8 avc_svc_subs_priority = 0;\n\t\tBool recovery_point_valid = GF_FALSE;\n\t\tu32 recovery_point_frame_cnt = 0;\n\t\tBool bIntraSlice = GF_FALSE;\n\t\tGF_FilterSAPType au_sap_type = GF_FILTER_SAP_NONE;\n\t\tBool slice_is_b = GF_FALSE;\n\t\tBool check_dep = GF_FALSE;\n\t\tBool force_au_flush = GF_FALSE;\n\t\ts32 slice_poc = 0;\n\n\t\t//not enough bytes to parse start code + nal hdr\n\t\tif (!is_eos && (remain<6)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//locate next start code\n\t\tcurrent = gf_media_nalu_next_start_code(start, remain, &sc_size);\n\t\tif (current == remain)\n\t\t\tcurrent = -1;\n\n\t\t//no start code, gontinue gathering data\n\t\tif (current<0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//unknown data before start of nal, may happen when tuning in, discard\n\t\tif (current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t\tnaldmx_check_timestamp_switch(ctx, &nalu_store_before, current, &drop_packet, pck);\n\t\t}\n\n\t\tif (!remain)\n\t\t\tbreak;\n\n\t\t//not enough bytes to parse start code + nal hdr\n\t\tif (!is_eos && (remain<6)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tnal_data = start + sc_size;\n\t\tnal_size = remain - sc_size;\n\n\t\t//figure out which nal we need to completely load\n\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\tif (is_eos && (nal_size<2)) break;\n\t\t\tnal_type = nal_data[0];\n\t\t\tnal_type = (nal_type & 0x7E) >> 1;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tforce_au_flush = GF_TRUE;\n\t\t\tcase GF_HEVC_NALU_SEI_PREFIX:\n\t\t\tcase GF_HEVC_NALU_SEI_SUFFIX:\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RSV_VCL_N10:\n\t\t\tcase GF_HEVC_NALU_SLICE_RSV_VCL_N12:\n\t\t\tcase GF_HEVC_NALU_SLICE_RSV_VCL_N14:\n\t\t\t\tcheck_dep = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (nal_type<GF_HEVC_NALU_VID_PARAM)\n\t\t\t\t\tnal_ref_idc = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//check if VPS/SPS/PPS lid/tid are greater than last seen VCL. If not, force a picture flush\n\t\t\t//not doing so could lead in dispatching the config changed before the current AU is sent\n\t\t\tif (force_au_flush) {\n\t\t\t\tif (!ctx->first_pck_in_au) {\n\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t} else {\n\t\t\t\t\tu8 layer_id = nal_data[0] & 1;\n\t\t\t\t\tlayer_id<<=5;\n\t\t\t\t\tlayer_id |= (nal_data[1] & 0xF8) >> 3;\n\t\t\t\t\tu8 temporal_id = nal_data[2] & 0x7;\n\t\t\t\t\tif (ctx->last_layer_id < layer_id)\n\t\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t\telse if (ctx->last_layer_id == layer_id) {\n\t\t\t\t\t\tif (ctx->last_temporal_id < temporal_id)\n\t\t\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\tif (is_eos && (nal_size<2)) break;\n\t\t\tnal_type = nal_data[1]>>3;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_VVC_NALU_OPI:\n\t\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\t\tforce_au_flush = GF_TRUE;\n\t\t\tcase GF_VVC_NALU_SEI_PREFIX:\n\t\t\tcase GF_VVC_NALU_SEI_SUFFIX:\n\t\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tcase GF_VVC_NALU_APS_SUFFIX:\n\t\t\tcase GF_VVC_NALU_PIC_HEADER:\n\t\t\t\tbreak;\n\n\t\t\tcase GF_VVC_NALU_SLICE_TRAIL:\n\t\t\tcase GF_VVC_NALU_SLICE_STSA:\n\t\t\tcase GF_VVC_NALU_SLICE_RADL:\n\t\t\tcase GF_VVC_NALU_SLICE_RASL:\n\t\t\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\t\t\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_VVC_NALU_SLICE_CRA:\n\t\t\tcase GF_VVC_NALU_SLICE_GDR:\n\t\t\t\tif (ctx->deps) {\n\t\t\t\t\tcheck_dep = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (nal_type<GF_HEVC_NALU_VID_PARAM)\n\t\t\t\t\tnal_ref_idc = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check if VPS/SPS/PPS/OPI/DEC lid/tid are greater than last seen VCL. If not, force a picture flush\n\t\t\t//not doing so could lead in dispatching the config changed before the current AU is sent\n\t\t\tif (force_au_flush) {\n\t\t\t\tif (!ctx->first_pck_in_au) {\n\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t} else {\n\t\t\t\t\tu8 layer_id = nal_data[0] & 0x3f;\n\t\t\t\t\tu8 temporal_id = (nal_data[1] & 0x7);\n\t\t\t\t\tif (ctx->last_layer_id < layer_id)\n\t\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t\telse if (ctx->last_layer_id == layer_id) {\n\t\t\t\t\t\tif (ctx->last_temporal_id < temporal_id)\n\t\t\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_eos && (nal_size<1)) break;\n\t\t\tnal_type = nal_data[0] & 0x1F;\n\t\t\tnal_ref_idc = (nal_data[0] & 0x60) >> 5;\n\t\t}\n\n\t\t//locate next NAL start\n\t\tnext = gf_media_nalu_next_start_code(nal_data, nal_size, &next_sc_size);\n\t\tif (!is_eos && (next == nal_size) && !ctx->full_au_source) {\n\t\t\tnext = -1;\n\t\t}\n\n\t\t//next nal start not found, wait\n\t\tif (next<0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//this is our exact NAL size, without start code\n\t\tnal_size = next;\n\n\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\tnal_parse_result = naludmx_parse_nal_hevc(ctx, nal_data, nal_size, &skip_nal, &is_slice, &is_islice);\n\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\tnal_parse_result = naludmx_parse_nal_vvc(ctx, nal_data, nal_size, &skip_nal, &is_slice, &is_islice);\n\t\t} else {\n\t\t\tnal_parse_result = naludmx_parse_nal_avc(ctx, nal_data, nal_size, nal_type, &skip_nal, &is_slice, &is_islice);\n\t\t}\n\n\t\t//dispatch right away if analyze\n\t\tif (ctx->analyze) {\n\t\t\tskip_nal = GF_FALSE;\n\t\t\tctx->sei_buffer_size = 0;\n\t\t}\n\n\t\t//new frame - if no slices, we detected the new frame on AU delimiter, don't flush new frame !\n\t\tif ((nal_parse_result>0) && ctx->nb_slices_in_au) {\n\t\t\tnaludmx_end_access_unit(ctx);\n\t\t}\n\n\t\tnaludmx_check_pid(filter, ctx, force_au_flush);\n\t\tif (!ctx->opid) skip_nal = GF_TRUE;\n\n\t\tif (skip_nal) {\n\t\t\tnal_size += sc_size;\n\t\t\tassert((u32) remain >= nal_size);\n\t\t\tstart += nal_size;\n\t\t\tremain -= nal_size;\n\t\t\tnaldmx_check_timestamp_switch(ctx, &nalu_store_before, nal_size, &drop_packet, pck);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) (start - ctx->nal_store);\n            assert(ctx->resume_from<=ctx->nal_store_size);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[%s] not yet playing\\n\", ctx->log_name));\n\n\t\t\tif (drop_packet)\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tif (ctx->seek_gdr_count)\n\t\t\t\t\tctx->seek_gdr_count--;\n\t\t\t\telse\n\t\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (nal_parse_result<0) {\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tu64 bo = byte_offset;\n\t\t\t\tbo += (start - ctx->nal_store);\n\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL Unit %d (byte offset \"LLU\" size %d type %d frame %d last POC %d) - skipping\\n\", ctx->log_name, ctx->nb_nalus, bo, nal_size, nal_type, ctx->nb_frames, ctx->last_poc));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL Unit %d (size %d type %d frame %d last POC %d) - skipping\\n\", ctx->log_name, ctx->nb_nalus, nal_size, nal_type, ctx->nb_frames, ctx->last_poc));\n\t\t\t}\n\t\t\tnal_size += sc_size;\n\t\t\tassert((u32) remain >= nal_size);\n\t\t\tstart += nal_size;\n\t\t\tremain -= nal_size;\n\t\t\tnaldmx_check_timestamp_switch(ctx, &nalu_store_before, nal_size, &drop_packet, pck);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (check_dep) {\n\t\t\tif ((ctx->codecid==GF_CODECID_HEVC) && ctx->hevc_state->s_info.sps) {\n\t\t\t\tHEVC_VPS *vps;\n\t\t\t\tu32 temporal_id = nal_data[1] & 0x7;\n\t\t\t\tvps = & ctx->hevc_state->vps[ctx->hevc_state->s_info.sps->vps_id];\n\t\t\t\tif (temporal_id + 1 < vps->max_sub_layers) {\n\t\t\t\t\tnal_ref_idc = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\t\tif (ctx->vvc_state->s_info.non_ref_pic) {\n\t\t\t\t\tnal_ref_idc = GF_FALSE;\n\t\t\t\t} else {\n\t\t\t\t\t//todo\n\t\t\t\t\tnal_ref_idc = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (is_islice) ctx->has_islice = GF_TRUE;\n\n\t\t//store all variables needed to compute POC/CTS and sample SAP and recovery info\n\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\tslice_is_idr = gf_hevc_slice_is_IDR(ctx->hevc_state);\n\n\t\t\trecovery_point_valid = ctx->hevc_state->sei.recovery_point.valid;\n\t\t\trecovery_point_frame_cnt = ctx->hevc_state->sei.recovery_point.frame_cnt;\n\t\t\tbIntraSlice = gf_hevc_slice_is_intra(ctx->hevc_state);\n\n\t\t\tau_sap_type = GF_FILTER_SAP_NONE;\n\t\t\tif (gf_hevc_slice_is_IDR(ctx->hevc_state)) {\n\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\tswitch (ctx->hevc_state->s_info.nal_unit_type) {\n\t\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswitch (ctx->hevc_state->s_info.nal_unit_type) {\n\t\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tslice_poc = ctx->hevc_state->s_info.poc;\n\n\t\t\t/*need to store TS offsets*/\n\t\t\tswitch (ctx->hevc_state->s_info.slice_type) {\n\t\t\tcase GF_AVC_TYPE_B:\n\t\t\tcase GF_AVC_TYPE2_B:\n\t\t\t\tslice_is_b = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\tslice_is_idr = gf_vvc_slice_is_ref(ctx->vvc_state);\n\t\t\trecovery_point_valid = ctx->vvc_state->s_info.recovery_point_valid;\n\t\t\trecovery_point_frame_cnt = ctx->vvc_state->s_info.gdr_recovery_count;\n\n//\t\t\tcommented, set below\n//\t\t\tif (ctx->vvc_state->s_info.irap_or_gdr_pic && !ctx->vvc_state->s_info.gdr_pic)\n//\t\t\t\tbIntraSlice = GF_TRUE; //gf_hevc_slice_is_intra(ctx->hevc_state);\n\n\t\t\tau_sap_type = GF_FILTER_SAP_NONE;\n\t\t\tif (ctx->vvc_state->s_info.irap_or_gdr_pic && !ctx->vvc_state->s_info.gdr_pic) {\n\t\t\t\tbIntraSlice = GF_TRUE;\n\n\t\t\t\tswitch (ctx->vvc_state->s_info.nal_unit_type) {\n\t\t\t\tcase GF_VVC_NALU_SLICE_CRA:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\tslice_is_idr = GF_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_2;\n\t\t\t\t\tslice_is_idr = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (ctx->vvc_state->s_info.nal_unit_type) {\n\t\t\t\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\tslice_is_idr = GF_TRUE;\n\t\t\t\t\tbIntraSlice = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_VVC_NALU_SLICE_CRA:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\tbIntraSlice = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\t\t\t\t\tbIntraSlice = GF_TRUE;\n\t\t\t\t\tif (ctx->vvc_state->s_info.gdr_pic) {\n\t\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\t\tslice_is_idr = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tslice_poc = ctx->vvc_state->s_info.poc;\n\n\t\t\t/*need to store TS offsets*/\n\t\t\tswitch (ctx->vvc_state->s_info.slice_type) {\n\t\t\tcase GF_AVC_TYPE_B:\n\t\t\tcase GF_AVC_TYPE2_B:\n\t\t\t\tslice_is_b = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\n\t\t\t/*fixme - we need finer grain for priority*/\n\t\t\tif ((nal_type==GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE)) {\n\t\t\t\tif (!ctx->is_mvc) {\n\t\t\t\t\tunsigned char *p = (unsigned char *) start;\n\t\t\t\t\t// RefPicFlag\n\t\t\t\t\tavc_svc_subs_reserved |= (p[0] & 0x60) ? 0x80000000 : 0;\n\t\t\t\t\t// RedPicFlag TODO: not supported, would require to parse NAL unit payload\n\t\t\t\t\tavc_svc_subs_reserved |= (0) ? 0x40000000 : 0;\n\t\t\t\t\t// VclNALUnitFlag\n\t\t\t\t\tavc_svc_subs_reserved |= (1<=nal_type && nal_type<=5) || (nal_type==GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE) ? 0x20000000 : 0;\n\t\t\t\t\t// use values of IdrFlag and PriorityId directly from SVC extension header\n\t\t\t\t\tavc_svc_subs_reserved |= p[1] << 16;\n\t\t\t\t\t// use values of DependencyId and QualityId directly from SVC extension header\n\t\t\t\t\tavc_svc_subs_reserved |= p[2] << 8;\n\t\t\t\t\t// use values of TemporalId and UseRefBasePicFlag directly from SVC extension header\n\t\t\t\t\tavc_svc_subs_reserved |= p[3] & 0xFC;\n\t\t\t\t\t// StoreBaseRepFlag TODO: SVC FF mentions a store_base_rep_flag which cannot be found in SVC spec\n\t\t\t\t\tavc_svc_subs_reserved |= (0) ? 0x00000002 : 0;\n\n\t\t\t\t\t// priority_id (6 bits) in SVC has inverse meaning -> lower value means higher priority - invert it and scale it to 8 bits\n\t\t\t\t\tavc_svc_subs_priority = (63 - (p[1] & 0x3F)) << 2;\n\t\t\t\t}\n\t\t\t\tif (nal_type==GF_AVC_NALU_SVC_PREFIX_NALU) {\n                    if (ctx->svc_prefix_buffer_size) {\n                        GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] broken bitstream, two consecutive SVC prefix NALU without SVC slice in-between\\n\", ctx->log_name));\n                        ctx->svc_prefix_buffer_size = 0;\n                    }\n\n\t\t\t\t\t/* remember reserved and priority value */\n\t\t\t\t\tctx->svc_nalu_prefix_reserved = avc_svc_subs_reserved;\n\t\t\t\t\tctx->svc_nalu_prefix_priority = avc_svc_subs_priority;\n\n\t\t\t\t\tctx->svc_prefix_buffer_size = nal_size;\n\t\t\t\t\tif (ctx->svc_prefix_buffer_size > ctx->svc_prefix_buffer_alloc) {\n\t\t\t\t\t\tctx->svc_prefix_buffer_alloc = ctx->svc_prefix_buffer_size;\n\t\t\t\t\t\tctx->svc_prefix_buffer = gf_realloc(ctx->svc_prefix_buffer, ctx->svc_prefix_buffer_size);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(ctx->svc_prefix_buffer, start+sc_size, ctx->svc_prefix_buffer_size);\n\n\t\t\t\t\tassert( (u32) remain >= sc_size + nal_size);\n\t\t\t\t\tstart += sc_size + nal_size;\n\t\t\t\t\tremain -= sc_size + nal_size;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (is_slice) {\n\t\t\t\t// RefPicFlag\n\t\t\t\tavc_svc_subs_reserved |= (start[0] & 0x60) ? 0x80000000 : 0;\n\t\t\t\t// VclNALUnitFlag\n\t\t\t\tavc_svc_subs_reserved |= (1<=nal_type && nal_type<=5) || (nal_type==GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE) ? 0x20000000 : 0;\n\t\t\t\tavc_svc_subs_priority = 0;\n\t\t\t}\n\n\t\t\tif (is_slice && ctx->avc_state->s_info.field_pic_flag) {\n\t\t\t\tctx->is_paff = GF_TRUE;\n\t\t\t\tbottom_field_flag = ctx->avc_state->s_info.bottom_field_flag;\n\t\t\t}\n\n\t\t\tslice_is_idr = (ctx->avc_state->s_info.nal_unit_type==GF_AVC_NALU_IDR_SLICE) ? GF_TRUE : GF_FALSE;\n\n\t\t\trecovery_point_valid = ctx->avc_state->sei.recovery_point.valid;\n\t\t\trecovery_point_frame_cnt = ctx->avc_state->sei.recovery_point.frame_cnt;\n\t\t\tbIntraSlice = gf_avc_slice_is_intra(ctx->avc_state);\n\n\t\t\tau_sap_type = GF_FILTER_SAP_NONE;\n\t\t\tif (ctx->avc_state->s_info.nal_unit_type == GF_AVC_NALU_IDR_SLICE)\n\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\n\t\t\tslice_poc = ctx->avc_state->s_info.poc;\n\t\t\t/*need to store TS offsets*/\n\t\t\tswitch (ctx->avc_state->s_info.slice_type) {\n\t\t\tcase GF_AVC_TYPE_B:\n\t\t\tcase GF_AVC_TYPE2_B:\n\t\t\t\tslice_is_b = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (is_slice) {\n\t\t\tBool first_in_au = (ctx->nb_slices_in_au==0) ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (slice_is_idr)\n\t\t\t\tctx->nb_idr++;\n\n\t\t\tif (au_sap_type==GF_FILTER_SAP_3)\n\t\t\t\tctx->nb_cra++;\n\n\t\t\tslice_force_ref = GF_FALSE;\n\t\t\tctx->nb_slices_in_au++;\n\n\t\t\t/*we only indicate TRUE IDRs for sync samples (cf AVC file format spec).\n\t\t\tSEI recovery should be used to build sampleToGroup & RollRecovery tables*/\n\t\t\tif (first_in_au) {\n\t\t\t\tif (recovery_point_valid) {\n\t\t\t\t\tctx->sei_recovery_frame_count = recovery_point_frame_cnt;\n\n\t\t\t\t\t/*we allow to mark I-frames as sync on open-GOPs (with sei_recovery_frame_count=0) when forcing sync even when the SEI RP is not available*/\n\t\t\t\t\tif (!recovery_point_frame_cnt && bIntraSlice) {\n\t\t\t\t\t\tctx->has_islice = 1;\n\t\t\t\t\t\tif (ctx->use_opengop_gdr == 1) {\n\t\t\t\t\t\t\tctx->use_opengop_gdr = 2; /*avoid message flooding*/\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] No valid SEI Recovery Point found although needed - forcing\\n\", ctx->log_name));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\t\t\t\tctx->hevc_state->sei.recovery_point.valid = 0;\n\t\t\t\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\t\t\t\tctx->vvc_state->s_info.recovery_point_valid = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx->avc_state->sei.recovery_point.valid = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (bIntraSlice && ctx->force_sync && (ctx->sei_recovery_frame_count==0))\n\t\t\t\t\t\tslice_force_ref = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tctx->bottom_field_flag = bottom_field_flag;\n\n\t\t\t\tif (ctx->check_prev_sap2) {\n\t\t\t\t\tif ((ctx->prev_sap2_poc > slice_poc) && ctx->prev_sap && (gf_list_find(ctx->pck_queue, ctx->prev_sap)>=0)) {\n\t\t\t\t\t\tgf_filter_pck_set_sap(ctx->prev_sap, GF_FILTER_SAP_2);\n\t\t\t\t\t}\n\t\t\t\t\tctx->check_prev_sap2 = GF_FALSE;\n\t\t\t\t\tctx->prev_sap = NULL;\n\t\t\t\t}\n\t\t\t\t//move all sap2 to sap1 and check POC of next frame\n\t\t\t\t//we do this because many encoders use IDR+Decodable leading pic NAL types (eg SAP2)\n\t\t\t\t//when encoding for IDR without DLP (eg SAP1)...\n\t\t\t\tif (au_sap_type==GF_FILTER_SAP_2) {\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\tctx->check_prev_sap2 = GF_TRUE;\n\t\t\t\t\tctx->prev_sap2_poc = slice_poc;\n\t\t\t\t}\n\n\t\t\t\tctx->au_sap = au_sap_type;\n\t\t\t}\n\n\t\t\tif (slice_poc < ctx->poc_shift) {\n\t\t\t\tu32 i, count = gf_list_count(ctx->pck_queue);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tu64 dts, cts;\n\t\t\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, i);\n\t\t\t\t\tassert(q_pck);\n\t\t\t\t\tdts = gf_filter_pck_get_dts(q_pck);\n\t\t\t\t\tif (dts == GF_FILTER_NO_TS) continue;\n\t\t\t\t\tcts = gf_filter_pck_get_cts(q_pck);\n\t\t\t\t\t//cts may be unset at this point (nal in middle of AU)\n\t\t\t\t\tif (cts == GF_FILTER_NO_TS) continue;\n\t\t\t\t\tcts += ctx->poc_shift;\n\t\t\t\t\tcts -= slice_poc;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t}\n\n\t\t\t\tctx->poc_shift = slice_poc;\n\t\t\t}\n\n\t\t\t/*if #pics, compute smallest POC increase*/\n\t\t\tif (slice_poc != ctx->last_poc) {\n\t\t\t\ts32 pdiff = ABS(ctx->last_poc - slice_poc);\n\n\t\t\t\tif ((slice_poc < 0) && !ctx->last_poc)\n\t\t\t\t\tctx->poc_diff = 0;\n\t\t\t\telse if ((slice_poc < 0) && (-slice_poc < ctx->poc_diff)) {\n\t\t\t\t\tpdiff = -slice_poc;\n\t\t\t\t\tctx->poc_diff = 0;\n\t\t\t\t}\n\n\t\t\t\tif (!ctx->poc_diff || (ctx->poc_diff > (s32) pdiff ) ) {\n\t\t\t\t\tctx->poc_diff = pdiff;\n\t\t\t\t\tctx->poc_probe_done = GF_FALSE;\n\t\t\t\t} else if (first_in_au) {\n\t\t\t\t\t//second frame with the same poc diff, we should be able to properly recompute CTSs\n\t\t\t\t\tctx->poc_probe_done = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tctx->last_poc = slice_poc;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[%s] POC is %d - min poc diff %d - slice is IDR %d (SAP %d)\\n\", ctx->log_name, slice_poc, ctx->poc_diff, slice_is_idr, au_sap_type));\n\n\t\t\t/*ref slice, reset poc*/\n\t\t\tif (slice_is_idr) {\n\t\t\t\tif (first_in_au) {\n\t\t\t\t\tBool temp_poc_diff = GF_FALSE;\n\t\t\t\t\t//two consecutive IDRs, force poc_diff to 1 if 0 (when we have intra-only) to force frame dispatch\n\t\t\t\t\tif (ctx->last_frame_is_idr && !ctx->poc_diff) {\n\t\t\t\t\t\ttemp_poc_diff = GF_TRUE;\n\t\t\t\t\t\tctx->poc_diff = 1;\n\t\t\t\t\t}\n\t\t\t\t\t//new ref frame, dispatch all pending packets\n\t\t\t\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\n\t\t\t\t\t//if IDR with DLP (sap2), only reset poc probing if the poc is below current max poc\n\t\t\t\t\t//otherwise assume no diff in poc\n\t\t\t\t\tif ((au_sap_type == GF_FILTER_SAP_2) && (ctx->max_last_poc >= ctx->last_poc) ){\n\t\t\t\t\t\tctx->au_sap2_poc_reset = GF_TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((au_sap_type == GF_FILTER_SAP_1) || ctx->au_sap2_poc_reset) {\n\t\t\t\t\t\tif (!ctx->au_sap2_poc_reset)\n\t\t\t\t\t\t\tctx->last_poc = 0;\n\n\t\t\t\t\t\tctx->max_last_poc = ctx->last_poc;\n\t\t\t\t\t\tctx->max_last_b_poc = ctx->last_poc;\n\t\t\t\t\t\tctx->poc_shift = 0;\n\t\t\t\t\t\t//force probing of POC diff, this will prevent dispatching frames with wrong CTS until we have a clue of min poc_diff used\n\t\t\t\t\t\tctx->poc_probe_done = 0;\n\t\t\t\t\t}\n\t\t\t\t\tctx->last_frame_is_idr = GF_TRUE;\n\t\t\t\t\tif (temp_poc_diff)\n\t\t\t\t\t\tctx->poc_diff = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*forced ref slice*/\n\t\t\telse if (slice_force_ref) {\n\t\t\t\tctx->last_frame_is_idr = GF_FALSE;\n\t\t\t\tif (first_in_au) {\n\t\t\t\t\t//new ref frame, dispatch all pending packets\n\t\t\t\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\n\t\t\t\t\t/*adjust POC shift as sample will now be marked as sync, so we must store poc as if IDR (eg POC=0) for our CTS offset computing to be correct*/\n\t\t\t\t\tctx->poc_shift = slice_poc;\n\n\t\t\t\t\t//force probing of POC diff, this will prevent dispatching frames with wrong CTS until we have a clue of min poc_diff used\n\t\t\t\t\tctx->poc_probe_done = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*strictly less - this is a new P slice*/\n\t\t\telse if (ctx->max_last_poc < ctx->last_poc) {\n\t\t\t\tctx->max_last_b_poc = 0;\n\t\t\t\tctx->max_last_poc = ctx->last_poc;\n\t\t\t\tctx->last_frame_is_idr = GF_FALSE;\n\t\t\t}\n\t\t\t/*stricly greater*/\n\t\t\telse if (slice_is_b && (ctx->max_last_poc > ctx->last_poc)) {\n\t\t\t\tctx->last_frame_is_idr = GF_FALSE;\n\t\t\t\tif (!ctx->max_last_b_poc) {\n\t\t\t\t\tctx->max_last_b_poc = ctx->last_poc;\n\t\t\t\t}\n\t\t\t\t/*if same poc than last max, this is a B-slice*/\n\t\t\t\telse if (ctx->last_poc > ctx->max_last_b_poc) {\n\t\t\t\t\tctx->max_last_b_poc = ctx->last_poc;\n\t\t\t\t}\n\t\t\t\t/*otherwise we had a B-slice reference: do nothing*/\n\t\t\t} else {\n\t\t\t\tctx->last_frame_is_idr = GF_FALSE;\n\t\t\t}\n\n\n\t\t\tif (ctx->deps) {\n\t\t\t\tif (nal_ref_idc) {\n\t\t\t\t\tctx->has_ref_slices = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif ((ctx->codecid==GF_CODECID_AVC) && (ctx->avc_state->s_info.redundant_pic_cnt) ) {\n\t\t\t\t\tctx->has_redundant = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tau_start = ctx->first_pck_in_au ? GF_FALSE : GF_TRUE;\n\n\t\tif (ctx->has_initial_aud) {\n\t\t\tu32 audelim_size = (ctx->codecid!=GF_CODECID_AVC) ? 3 : 2;\n\t\t\t/*dst_pck = */naludmx_start_nalu(ctx, audelim_size, GF_FALSE, &au_start, &pck_data);\n\t\t\tmemcpy(pck_data + ctx->nal_length , ctx->init_aud, audelim_size);\n\t\t\tctx->has_initial_aud = GF_FALSE;\n\t\t\tif (ctx->subsamples) {\n\t\t\t\tnaludmx_add_subsample(ctx, audelim_size, avc_svc_subs_priority, avc_svc_subs_reserved);\n\t\t\t}\n\t\t}\n\t\tif (ctx->sei_buffer_size) {\n\t\t\t//sei buffer is already nal size prefixed\n\t\t\t/*dst_pck = */naludmx_start_nalu(ctx, ctx->sei_buffer_size, GF_TRUE, &au_start, &pck_data);\n\t\t\tmemcpy(pck_data, ctx->sei_buffer, ctx->sei_buffer_size);\n\t\t\tif (ctx->subsamples) {\n\t\t\t\tnaludmx_add_subsample(ctx, ctx->sei_buffer_size - ctx->nal_length, avc_svc_subs_priority, avc_svc_subs_reserved);\n\t\t\t}\n\t\t\tctx->sei_buffer_size = 0;\n\t\t}\n\n\t\tif (ctx->svc_prefix_buffer_size) {\n\t\t\t/*dst_pck = */naludmx_start_nalu(ctx, ctx->svc_prefix_buffer_size, GF_FALSE, &au_start, &pck_data);\n\t\t\tmemcpy(pck_data + ctx->nal_length, ctx->svc_prefix_buffer, ctx->svc_prefix_buffer_size);\n\t\t\tif (ctx->subsamples) {\n\t\t\t\tnaludmx_add_subsample(ctx, ctx->svc_prefix_buffer_size, ctx->svc_nalu_prefix_priority, ctx->svc_nalu_prefix_reserved);\n\t\t\t}\n\t\t\tctx->svc_prefix_buffer_size = 0;\n\t\t}\n\n\t\t//nalu size field\n\t\t/*dst_pck = */naludmx_start_nalu(ctx, (u32) nal_size, GF_FALSE, &au_start, &pck_data);\n\t\tpck_data += ctx->nal_length;\n\n\t\t//add subsample info before touching the size\n\t\tif (ctx->subsamples) {\n\t\t\tnaludmx_add_subsample(ctx, (u32) nal_size, avc_svc_subs_priority, avc_svc_subs_reserved);\n\t\t}\n\n\n\t\t//bytes only come from the data packet\n\t\tmemcpy(pck_data, nal_data, (size_t) nal_size);\n\n\t\tif ((ctx->nb_slices_in_au==1) && ctx->check_prev_sap2) {\n\t\t\tctx->prev_sap = ctx->first_pck_in_au;\n\t\t}\n\n\n\t\tnal_size += sc_size;\n\t\tstart += nal_size;\n\t\tremain -= nal_size;\n\t\tnaldmx_check_timestamp_switch(ctx, &nalu_store_before, nal_size, &drop_packet, pck);\n\n\t\t//don't demux too much of input, abort when we would block. This avoid dispatching\n\t\t//a huge number of frames in a single call\n\t\tif (remain && gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->resume_from = (u32) (start - ctx->nal_store);\n\t\t\tassert(ctx->resume_from <= ctx->nal_store_size);\n\t\t\tassert(ctx->resume_from == ctx->nal_store_size - remain);\n\t\t\tif (drop_packet)\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (remain) {\n\t\tif (is_eos && (remain == ctx->nal_store_size)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] Incomplete last NAL and eos, discarding\\n\", ctx->log_name));\n\t\t\tremain = 0;\n\t\t} else {\n\t\t\tassert((u32) remain<=ctx->nal_store_size);\n\t\t\tmemmove(ctx->nal_store, start, remain);\n\t\t}\n\t}\n\tctx->nal_store_size = remain;\n\n\tif (drop_packet)\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (is_eos) {\n\t\t//avoid recursive call\n\t\tgoto restart;\n\t}\n\n\tif ((ctx->nb_nalus>nalu_before) && gf_filter_reporting_enabled(filter)) {\n\t\tchar szStatus[1024];\n\n\t\tsprintf(szStatus, \"%s %dx%d % 10d NALU % 8d I % 8d P % 8d B % 8d SEI\", ctx->log_name, ctx->width, ctx->height, ctx->nb_nalus, ctx->nb_i, ctx->nb_p, ctx->nb_b, ctx->nb_sei);\n\t\tgf_filter_update_status(filter, -1, szStatus);\n\t}\n\tif (ctx->full_au_source && ctx->poc_probe_done) {\n\t\tif (ctx->first_pck_in_au)\n\t\t\tnaludmx_finalize_au_flags(ctx);\n\n\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err naludmx_initialize(GF_Filter *filter)\n{\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->sps = gf_list_new();\n\tctx->pps = gf_list_new();\n\tswitch (ctx->nal_length) {\n\tcase 1:\n\t\tctx->max_nalu_size_allowed = 0xFF;\n\t\tbreak;\n\tcase 2:\n\t\tctx->max_nalu_size_allowed = 0xFFFF;\n\t\tbreak;\n\tcase 4:\n\t\tctx->max_nalu_size_allowed = 0xFFFFFFFF;\n\t\tbreak;\n\tcase 0:\n\t\tctx->max_nalu_size_allowed = 0xFFFFFFFF;\n\t\tctx->nal_length = 4;\n\t\tctx->nal_adjusted = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] NAL size length %d is not allowed, defaulting to 4 bytes\\n\", ctx->log_name));\n\t\tctx->max_nalu_size_allowed = 0xFFFFFFFF;\n\t\tctx->nal_length = 4;\n\t\tbreak;\n\t}\n\n\t//if profile is forced and comapt_id is in auto mode, fail\n\tif (!ctx->dv_compatid) {\n\t\tif (ctx->dv_profile) {\n\t\t\tctx->dv_compatid=1;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] DV profile forced but compatID in auto mode, using no compatibility\\n\", ctx->log_name));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic void naludmx_del_param_list(GF_List *ps, Bool do_free)\n{\n\tif (!ps) return;\n\twhile (gf_list_count(ps)) {\n\t\tGF_NALUFFParam *sl = gf_list_pop_back(ps);\n\t\tif (sl->data) gf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n\n\tif (do_free)\n\t\tgf_list_del(ps);\n}\n\nstatic void naludmx_log_stats(GF_NALUDmxCtx *ctx)\n{\n\tu32 i, count;\n\tconst char *msg_import;\n\tu32 nb_frames = 0;\n\tif (ctx->cur_fps.den)\n\t\tnb_frames = (u32) (ctx->dts / ctx->cur_fps.den);\n\n\tif (ctx->dur.den && ctx->dur.num) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s duration specified at import time, may have parsed more frames than imported\\n\", ctx->log_name));\n\t\tmsg_import = \"parsed\";\n\t} else {\n\t\tmsg_import = \"Import results:\";\n\t}\n\n\tif (ctx->nb_si || ctx->nb_sp) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s %d frames (%d NALUs) - Slices: %d I %d P %d B %d SP %d SI - %d SEI - %d IDR\\n\", ctx->log_name, msg_import, nb_frames, ctx->nb_nalus, ctx->nb_i, ctx->nb_p, ctx->nb_b, ctx->nb_sp, ctx->nb_si, ctx->nb_sei, ctx->nb_idr ));\n\t} else if (ctx->vvc_no_stats) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s %d samples (%d NALUs) - %d SEI - %d IDR - %d CRA\\n\",\n\t\t\t                  ctx->log_name, msg_import, nb_frames, ctx->nb_nalus, ctx->nb_sei, ctx->nb_idr, ctx->nb_cra));\n\t} else {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s %d samples (%d NALUs) - Slices: %d I %d P %d B - %d SEI - %d IDR - %d CRA\\n\",\n\t\t\t                  ctx->log_name, msg_import, nb_frames, ctx->nb_nalus, ctx->nb_i, ctx->nb_p, ctx->nb_b, ctx->nb_sei, ctx->nb_idr, ctx->nb_cra));\n\t}\n\n\tif (ctx->codecid==GF_CODECID_AVC) {\n\t\tcount = gf_list_count(ctx->sps);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tAVC_SPS *sps;\n\t\t\tGF_NALUFFParam *svcc = (GF_NALUFFParam*)gf_list_get(ctx->sps, i);\n\t\t\tsps = & ctx->avc_state->sps[svcc->id];\n\t\t\tif (sps->nb_ei || sps->nb_ep) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s SVC (SSPS ID %d, %dx%d) %s Slices: %d I %d P %d B\\n\", ctx->log_name, svcc->id - GF_SVC_SSPS_ID_SHIFT, sps->width, sps->height, msg_import, sps->nb_ei, sps->nb_ep, sps->nb_eb ));\n\t\t\t}\n\t\t}\n\t} else if (ctx->nb_e_i || ctx->nb_e_p || ctx->nb_e_b) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s L-HEVC %s Slices: %d I %d P %d B\\n\", ctx->log_name, msg_import, ctx->nb_e_i, ctx->nb_e_p, ctx->nb_e_b ));\n\t}\n\n\tif (ctx->max_total_delay>1) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s Stream uses forward prediction - stream CTS offset: %d frames\\n\", ctx->log_name, ctx->max_total_delay));\n\t}\n\n\tif (!ctx->nal_adjusted) {\n\t\tif ((ctx->max_nalu_size < 0xFF) && (ctx->nal_length>1) ){\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s Max NALU size is %d - stream could be optimized by setting nal_length=1\\n\", ctx->log_name, ctx->max_nalu_size));\n\t\t} else if ((ctx->max_nalu_size < 0xFFFF) && (ctx->nal_length>2) ){\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s Max NALU size is %d - stream could be optimized by setting nal_length=2\\n\", ctx->log_name, ctx->max_nalu_size));\n\t\t}\n\t}\n}\n\nstatic void naludmx_reset_param_sets(GF_NALUDmxCtx *ctx, Bool do_free)\n{\n\tnaludmx_del_param_list(ctx->sps, do_free);\n\tnaludmx_del_param_list(ctx->pps, do_free);\n\tnaludmx_del_param_list(ctx->vps, do_free);\n\tnaludmx_del_param_list(ctx->sps_ext, do_free);\n\tnaludmx_del_param_list(ctx->pps_svc, do_free);\n\tnaludmx_del_param_list(ctx->vvc_aps_pre, do_free);\n\tnaludmx_del_param_list(ctx->vvc_dci, do_free);\n\tnaludmx_del_param_list(ctx->vvc_opi, do_free);\n}\n\nstatic void naludmx_finalize(GF_Filter *filter)\n{\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (ctx->importer) naludmx_log_stats(ctx);\n\n\tif (ctx->bs_r) gf_bs_del(ctx->bs_r);\n\tif (ctx->bs_w) gf_bs_del(ctx->bs_w);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->nal_store) gf_free(ctx->nal_store);\n\tif (ctx->pck_queue) {\n\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_back(ctx->pck_queue);\n\t\t\tgf_filter_pck_discard(pck);\n\t\t}\n\t\tgf_list_del(ctx->pck_queue);\n\t}\n\tif (ctx->sei_buffer) gf_free(ctx->sei_buffer);\n\tif (ctx->svc_prefix_buffer) gf_free(ctx->svc_prefix_buffer);\n\tif (ctx->subsamp_buffer) gf_free(ctx->subsamp_buffer);\n\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\tctx->src_pck = NULL;\n\n\tnaludmx_reset_param_sets(ctx, GF_TRUE);\n\n\tif (ctx->avc_state) gf_free(ctx->avc_state);\n\tif (ctx->hevc_state) gf_free(ctx->hevc_state);\n\tif (ctx->vvc_state) gf_free(ctx->vvc_state);\n}\n\n\nstatic const char *naludmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tu32 sc, sc_size;\n\tu32 not_hevc=0;\n\tu32 not_avc=0;\n\tu32 not_vvc=0;\n\tu32 nb_hevc=0;\n\tu32 nb_avc=0;\n\tu32 nb_vvc=0;\n\t//u32 nb_nalus=0;\n\tu32 nb_hevc_zero=0;\n\tu32 nb_avc_zero=0;\n\tu32 nb_vvc_zero=0;\n\tu32 nb_sps_hevc=0,nb_pps_hevc=0,nb_vps_hevc=0;\n\tu32 nb_sps_avc=0,nb_pps_avc=0;\n\tu32 nb_sps_vvc=0,nb_pps_vvc=0; //,nb_vps_vvc=0;\n\n\twhile (size>3) {\n\t\tu32 nal_type=0;\n\t\tsc_size = 0;\n\t\tsc = gf_media_nalu_next_start_code(data, size, &sc_size);\n\t\tif (!sc_size) break;\n\n\t\tdata += sc + sc_size;\n\t\tif (size <= sc + sc_size) break;\n\t\tsize -= sc + sc_size;\n\n\t\tif (data[0] & 0x80) {\n\t\t\tnot_avc++;\n\t\t\tnot_hevc++;\n\t\t\tnot_vvc++;\n\t\t\tcontinue;\n\t\t}\n\t\t//nb_nalus++;\n\n\t\tnal_type = (data[0] & 0x7E) >> 1;\n\t\tif (nal_type<=40) {\n\t\t\tnb_hevc++;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tif (nb_sps_hevc)\n\t\t\t\t\tnb_pps_hevc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\tnb_sps_hevc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\tnb_vps_hevc++;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tnb_hevc_zero++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((nal_type!=GF_HEVC_NALU_DV_RPU) && (nal_type!=GF_HEVC_NALU_DV_EL))\n\t\t\t\tnot_hevc++;\n\t\t}\n\n\t\tnal_type = data[0] & 0x1F;\n\t\tif (nal_type && nal_type<=24) {\n\t\t\tnb_avc++;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\tif (nb_sps_avc)\n\t\t\t\t\tnb_pps_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\t\tnb_sps_avc++;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tnb_avc_zero++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((nal_type!=GF_AVC_NALU_DV_RPU) && (nal_type!=GF_AVC_NALU_DV_EL))\n\t\t\t\tnot_avc++;\n\t\t}\n\n\t\t//check vvc - 2nd bit reserved to 0\n\t\tif (data[0] & 0x40) {\n\t\t\tnot_vvc++;\n\t\t\tcontinue;\n\t\t}\n\t\tnal_type = data[1] >> 3;\n\t\tif (nal_type>31) {\n\t\t\tnot_vvc++;\n\t\t\tcontinue;\n\t\t}\n\t\tnb_vvc++;\n\t\tswitch (nal_type) {\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tif (nb_sps_vvc)\n\t\t\t\tnb_pps_vvc++;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tnb_sps_vvc++;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\t//nb_vps_vvc++;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_ACCESS_UNIT:\n\t\t\t//to detect files without VPS correctly\n\t\t\t//nb_vps_vvc++;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnb_vvc_zero++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nb_sps_avc || !nb_pps_avc) nb_avc=0;\n\tif (!nb_sps_hevc || !nb_pps_hevc || !nb_vps_hevc) nb_hevc=0;\n\t//VPS is optional in VVC, don't check for its presence\n\tif (!nb_sps_vvc || !nb_pps_vvc) nb_vvc=0;\n\tif (not_avc) nb_avc=0;\n\tif (not_hevc) nb_hevc=0;\n\tif (not_vvc) nb_vvc=0;\n\n\tif (not_avc && not_hevc && not_vvc) return NULL;\n\tif (nb_avc==nb_avc_zero) nb_avc=0;\n\tif (nb_hevc==nb_hevc_zero) nb_hevc=0;\n\tif (nb_vvc==nb_vvc_zero) nb_vvc=0;\n\n\tif (!nb_hevc && !nb_avc && !nb_vvc) return NULL;\n\t*score = GF_FPROBE_SUPPORTED;\n\tif (!nb_hevc) return (nb_vvc>nb_avc) ? \"video/vvc\" : \"video/avc\";\n\tif (!nb_avc) return (nb_vvc>nb_hevc) ? \"video/vvc\" : \"video/hevc\";\n\tif (!nb_vvc) return (nb_avc>nb_hevc) ? \"video/avc\" : \"video/hevc\";\n\n\tif ((nb_hevc>nb_avc) && (nb_hevc>nb_vvc)) return \"video/hevc\";\n\tif ((nb_vvc>nb_avc) && (nb_vvc>nb_hevc)) return \"video/vvc\";\n\treturn \"video/avc\";\n}\n\nstatic const GF_FilterCapability NALUDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"264|h264|26l|h26l|avc|svc|mvc|hevc|hvc|265|h265|lhvc|shvc|mhvc|266|h266|vvc|lvvc\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"video/avc|video/h264|video/svc|video/mvc|video/hevc|video/lhvc|video/shvc|video/mhvc|video/vvc\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AVC_PS),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_SVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_HEVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_LHVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_VVC),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_TILE_BASE, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AVC_PS),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_HEVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_LHVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_VVC),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_TILE_BASE, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n\t{0},\n\t//for HLS-SAES\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_ENCRYPTED),\n\tCAP_4CC(GF_CAPS_INPUT,GF_PROP_PID_PROTECTION_SCHEME_TYPE, GF_HLS_SAMPLE_AES_SCHEME),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AVC),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_TILE_BASE, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_NALUDmxCtx, _n)\nstatic const GF_FilterArgs NALUDmxArgs[] =\n{\n\t{ OFFS(fps), \"import frame rate (0 default to FPS from bitstream or 25 Hz)\", GF_PROP_FRACTION, \"0/1000\", NULL, 0},\n\t{ OFFS(index), \"indexing window length. If 0, bitstream is not probed for duration. A negative value skips the indexing if the source file is larger than 20M (slows down importers) unless a play with start range > 0 is issued\", GF_PROP_DOUBLE, \"-1.0\", NULL, 0},\n\t{ OFFS(explicit), \"use explicit layered (SVC/LHVC) import\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(strict_poc), \"delay frame output of an entire GOP to ensure CTS info is correct when POC suddenly changes\\n\"\n\t\t\"- off: disable GOP buffering\\n\"\n\t\t\"- on: enable GOP buffering, assuming no error in POC\\n\"\n\t\t\"- error: enable GOP buffering and try to detect lost frames\", GF_PROP_UINT, \"off\", \"off|on|error\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(nosei), \"remove all sei messages\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(nosvc), \"remove all SVC/MVC/LHVC data\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(novpsext), \"remove all VPS extensions\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import results\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dur), \"compatibility with old importer to log imported frames only\", GF_PROP_FRACTION, \"0\", NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(nal_length), \"set number of bytes used to code length field: 1, 2 or 4\", GF_PROP_UINT, \"4\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(subsamples), \"import subsamples information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(deps), \"import sample dependency information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(seirw), \"rewrite AVC sei messages for ISOBMFF constraints\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(audelim), \"keep Access Unit delimiter in payload\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(analyze), \"skip reformat of decoder config and SEI and dispatch all NAL in input order - shall only be used with inspect filter analyze mode!\", GF_PROP_UINT, \"off\", \"off|on|bs|full\", GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(notime), \"ignore input timestamps, rebuild from 0\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\n\t{ OFFS(dv_mode), \"signaling for DolbyVision\\n\"\n\t\"- none: never signal DV profile\\n\"\n\t\"- auto: signal DV profile if RPU or EL are found\\n\"\n\t\"- clean: do not signal and remove RPU and EL NAL units\\n\"\n\t\"- single: signal DV profile if RPU are found and remove EL NAL units\"\n\t, GF_PROP_UINT, \"auto\", \"none|auto|clean|single\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dv_profile), \"profile for DolbyVision (currently defined profiles are 4, 5, 7, 8, 9), 0 for auto-detect\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dv_compatid), \"cross-compatibility ID for DolbyVision\\n\"\n\t\t\"- auto: auto-detect\\n\"\n\t\t\"- none: no cross-compatibility\\n\"\n\t\t\"- hdr10: CTA HDR10, as specified by EBU TR 03\\n\"\n\t\t\"- bt709: SDR BT.709\\n\"\n\t\t\"- hlg709: HLG BT.709 gamut in ITU-R BT.2020\\n\"\n\t\t\"- hlg2100: HLG BT.2100 gamut in ITU-R BT.2020\\n\"\n\t\t\"- bt2020: SDR BT.2020\\n\"\n\t\t\"- brd: Ultra HD Blu-ray Disc HDR\", GF_PROP_UINT, \"auto\", \"auto|none|hdr10|bt709|hlg709|hlg2100|bt2020|brd\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(bsdbg), \"debug NAL parsing in `parser@debug` logs\\n\"\n\t\t\"- off: not enabled\\n\"\n\t\t\"- on: enabled\\n\"\n\t\t\"- full: enable with number of bits dumped\", GF_PROP_UINT, \"off\", \"off|on|full\", GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister NALUDmxRegister = {\n\t.name = \"rfnalu\",\n\tGF_FS_SET_DESCRIPTION(\"AVC/HEVC reframer\")\n\tGF_FS_SET_HELP(\"This filter parses AVC|H264 and HEVC files/data and outputs corresponding video PID and frames.\\n\"\n\t\"This filter produces ISOBMFF-compatible output: start codes are removed, NALU length field added and avcC/hvcC config created.\\n\"\n\t\"Note: The filter uses negative CTS offsets: CTS is correct, but some frames may have DTS greater than CTS.\")\n\t.private_size = sizeof(GF_NALUDmxCtx),\n\t.args = NALUDmxArgs,\n\t.initialize = naludmx_initialize,\n\t.finalize = naludmx_finalize,\n\tSETCAPS(NALUDmxCaps),\n\t.configure_pid = naludmx_configure_pid,\n\t.process = naludmx_process,\n\t.process_event = naludmx_process_event,\n\t.probe_data = naludmx_probe_data,\n};\n\n\nconst GF_FilterRegister *rfnalu_register(GF_FilterSession *session)\n{\n\treturn &NALUDmxRegister;\n}\n\n#else\nconst GF_FilterRegister *rfnalu_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif //GPAC_DISABLE_AV_PARSERS\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / NALU (AVC, HEVC, VVC)  reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n#include <gpac/internal/media_dev.h>\n//for oinf stuff\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\n#define CTS_POC_OFFSET_SAFETY\t1000\n\nGF_Err gf_bs_set_logger(GF_BitStream *bs, void (*on_bs_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3), void *udta);\n\n\nenum\n{\n\tDVMODE_NONE=0,\n\tDVMODE_AUTO,\n\tDVMODE_FORCE,\n\tDVMODE_CLEAN,\n\tDVMODE_SINGLE,\n};\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n\tu32 roll_count;\n} NALUIdx;\n\n\ntypedef struct\n{\n\tu32 layer_id_plus_one;\n\tu32 min_temporal_id, max_temporal_id;\n} LHVCLayerInfo;\n\nenum {\n\tSTRICT_POC_OFF = 0,\n\tSTRICT_POC_ON,\n\tSTRICT_POC_ERROR,\n};\n\ntypedef struct\n{\n\t//filter args\n\tGF_Fraction fps;\n\tDouble index;\n\tBool explicit, force_sync, nosei, importer, subsamples, nosvc, novpsext, deps, seirw, audelim, analyze, notime;\n\tu32 nal_length;\n\tu32 strict_poc;\n\tu32 bsdbg;\n\tGF_Fraction dur;\n\tu32 dv_mode, dv_profile, dv_compatid;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\t//read bitstream for AVC/HEVC parsing\n\tGF_BitStream *bs_r;\n\t//write bitstream for nalus size length rewrite\n\tGF_BitStream *bs_w;\n\t//current CTS/DTS of the stream, may be overridden by input packet if not file (eg TS PES)\n\tu64 cts, dts, prev_dts, prev_cts;\n\tu32 pck_duration;\n\t//basic config stored here: with, height CRC of base and enh layer decoder config, sample aspect ratio\n\t//when changing, a new pid config will be emitted\n\tu32 width, height;\n\tu32 crc_cfg, crc_cfg_enh;\n\tGF_Fraction sar;\n\tGF_Fraction cur_fps;\n\n\t//duration of the file if known\n\tGF_Fraction64 duration;\n\t//playback start range\n\tDouble start_range;\n\t//indicates we are in seek, packets before start range should be marked\n\tBool in_seek;\n\tu32 seek_gdr_count;\n\tBool first_gdr;\n\t//set once we play something\n\tBool is_playing;\n\t//is a file, is a file fully loaded on disk (local or download done)\n\tBool is_file, file_loaded;\n\t//initial PLAY command found\n\tBool initial_play_done;\n\n\t//list of RAP entry points\n\tNALUIdx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\t//timescale of the input pid if any, 0 otherwise\n\tu32 timescale;\n\t//framing flag of input packet when input pid has timing (eg is not a file)\n\tBool input_is_au_start;\n\n\tGF_FilterPacket *src_pck;\n\n\tBool full_au_source;\n\n\t//total delay in frames between decode and presentation\n\ts32 max_total_delay;\n\t//max size codable with our nal_length setting\n\tu32 max_nalu_size_allowed;\n\n\t//position in input packet from which we resume parsing\n\tu32 resume_from;\n\t//prevents message about possible NAL size optimizaion at finalization\n\tBool nal_adjusted;\n\n\t//avc/hevc switch\n\tu32 codecid;\n\t//name of the logger\n\tconst char *log_name;\n\n\t//list of packet (in decode order !!) not yet dispatched.\n\t//Dispatch depends on the mode:\n\t//strict_poc=0: we wait after each IDR until we find a stable poc diff between pictures, controled by poc_probe_done\n\t//strict_poc>=1: we dispatch only after IDR or at the end (huge delay)\n\tGF_List *pck_queue;\n\t//dts of the last IDR found\n\tu64 dts_last_IDR;\n\t//max size of NALUs in the bitstream\n\tu32 max_nalu_size;\n\n\n\tu8 *nal_store;\n\tu32 nal_store_size, nal_store_alloc;\n\n\t//list of param sets found\n\tGF_List *sps, *pps, *vps, *sps_ext, *pps_svc, *vvc_aps_pre, *vvc_dci, *vvc_opi;\n\t//set to true if one of the PS has been modified, will potentially trigger a PID reconfigure\n\tBool ps_modified;\n\n\t//stats\n\tu32 nb_idr, nb_i, nb_p, nb_b, nb_sp, nb_si, nb_sei, nb_nalus, nb_aud, nb_cra;\n\n\t//frame has intra slice\n\tBool has_islice;\n\t//AU is rap\n\tGF_FilterSAPType au_sap;\n\t//number of slices in frame\n\tu32 nb_slices_in_au;\n\t//frame first slice\n\tBool au_sap2_poc_reset;\n\t//paff used - NEED FURTHER CHECKING\n\tBool is_paff;\n\tBool bottom_field_flag;\n\t//SEI recovery count - if 0 and I slice only frame, openGOP detection (avc)\n\ts32 sei_recovery_frame_count;\n\tu32 use_opengop_gdr;\n\t//poc compute variables\n\ts32 last_poc, max_last_poc, max_last_b_poc, poc_diff, prev_last_poc, min_poc, poc_shift;\n\t//set to TRUE once 3 frames with same min poc diff are found, enabling dispatch of the frames\n\tBool poc_probe_done;\n\t//pointer to the first packet of the current frame (the one holding timing info)\n\t//this packet is in the packet queue\n\tGF_FilterPacket *first_pck_in_au;\n\t//frame has slices used as reference\n\tBool has_ref_slices;\n\t//frame has redundant coding\n\tBool has_redundant;\n\n\tBool last_frame_is_idr;\n\n\t//buffer to store SEI messages\n\t//for AVC: we have to rewrite the SEI to remove some of the messages according to the spec\n\t//for HEVC: we store prefix SEI here and dispatch them once the first VCL is found\n\tchar *sei_buffer;\n\tu32 sei_buffer_size, sei_buffer_alloc;\n\n\t//subsample buffer, only used for SVC for now\n\tu32 subsamp_buffer_alloc, subsamp_buffer_size, subs_mapped_bytes;\n\tchar *subsamp_buffer;\n\n\t//AVC specific\n\t//avc bitstream state\n\tAVCState *avc_state;\n\n\t//SVC specific\n\tchar *svc_prefix_buffer;\n\tu32 svc_prefix_buffer_size, svc_prefix_buffer_alloc;\n\tu32 svc_nalu_prefix_reserved;\n\tu8 svc_nalu_prefix_priority;\n\n\t//HEVC specific\n\tHEVCState *hevc_state;\n\t//shvc stats\n\tu32 nb_e_idr, nb_e_i, nb_e_p, nb_e_b;\n\tBool vvc_no_stats;\n\n\tLHVCLayerInfo linf[64];\n\tu8 max_temporal_id[64];\n\tu8 min_layer_id;\n\n\t//VVC specific\n\tVVCState *vvc_state;\n\n\tBool has_initial_aud;\n\tchar init_aud[3];\n\n\tBool interlaced;\n\n\tBool is_mvc;\n\n\tu32 bitrate;\n\tu32 nb_frames;\n\n\t//layer and temporal ID of last VCL nal\n\tu8 last_layer_id, last_temporal_id;\n\n\tu32 clli_crc, mdcv_crc;\n\n\tu32 nb_dv_rpu, nb_dv_el;\n\n\tu32 valid_ps_flags;\n\n\tBool check_prev_sap2;\n\ts32 prev_sap2_poc;\n\tGF_FilterPacket *prev_sap;\n} GF_NALUDmxCtx;\n\nstatic void naludmx_enqueue_or_dispatch(GF_NALUDmxCtx *ctx, GF_FilterPacket *n_pck, Bool flush_ref);\nstatic void naludmx_finalize_au_flags(GF_NALUDmxCtx *ctx);\nstatic void naludmx_reset_param_sets(GF_NALUDmxCtx *ctx, Bool do_free);\nstatic void naludmx_set_dolby_vision(GF_NALUDmxCtx *ctx);\n\n\nGF_Err naludmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tu32 old_codecid;\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) {\n\t\tctx->timescale = p->value.uint;\n\t\tctx->cur_fps.den = 0;\n\t\tctx->cur_fps.num = ctx->timescale;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\tif (p) {\n\t\t\tctx->cur_fps = p->value.frac;\n\t\t}\n\t}\n\n\told_codecid = ctx->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tswitch (p->value.uint) {\n\t\tcase GF_CODECID_HEVC:\n\t\tcase GF_CODECID_LHVC:\n\t\t\tctx->codecid = GF_CODECID_HEVC;\n\t\t\tbreak;\n\t\tcase GF_CODECID_VVC:\n\t\t\tctx->codecid = GF_CODECID_VVC;\n\t\t\tbreak;\n\t\tcase GF_CODECID_AVC:\n\t\tcase GF_CODECID_AVC_PS:\n\t\tcase GF_CODECID_SVC:\n\t\tcase GF_CODECID_MVC:\n\t\t\tctx->codecid = GF_CODECID_AVC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\telse {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MIME);\n\t\tif (p && p->value.string && (\n\t\t\tstrstr(p->value.string, \"hvc\")\n\t\t\t|| strstr(p->value.string, \"hevc\")\n\t\t\t|| strstr(p->value.string, \"265\")\n\t\t\t|| strstr(p->value.string, \"shvc\")\n\t\t\t|| strstr(p->value.string, \"mhvc\")\n\t\t\t|| strstr(p->value.string, \"lhvc\")\n\t\t) )\n\t\t\tctx->codecid = GF_CODECID_HEVC;\n\t\telse if (p && p->value.string && (\n\t\t\tstrstr(p->value.string, \"vvc\")\n\t\t) )\n\t\t\tctx->codecid = GF_CODECID_VVC;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p && p->value.string && (\n\t\t\t\t strstr(p->value.string, \"hvc\")\n\t\t\t\t || strstr(p->value.string, \"hevc\")\n\t\t\t\t || strstr(p->value.string, \"265\")\n\t\t\t\t || strstr(p->value.string, \"shvc\")\n\t\t\t\t || strstr(p->value.string, \"mhvc\")\n\t\t\t\t || strstr(p->value.string, \"lhvc\")\n\t\t\t ) )\n\t\t\t\tctx->codecid = GF_CODECID_HEVC;\n\t\t\telse if (p && p->value.string && (\n\t\t\t\t strstr(p->value.string, \"vvc\")\n\t\t\t\t || strstr(p->value.string, \"266\")\n\t\t\t\t || strstr(p->value.string, \"lvvc\")\n\t\t\t ) )\n\t\t\t\tctx->codecid = GF_CODECID_VVC;\n\t\t\telse\n\t\t\t\tctx->codecid = GF_CODECID_AVC;\n\t\t}\n\t}\n\n\tif (old_codecid && (old_codecid != ctx->codecid)) {\n\t\tnaludmx_reset_param_sets(ctx, GF_FALSE);\n\t}\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tctx->log_name = \"HEVC\";\n\t\tif (ctx->avc_state) { gf_free(ctx->avc_state); ctx->avc_state = NULL; }\n\t\tif (ctx->vvc_state) { gf_free(ctx->vvc_state); ctx->vvc_state = NULL; }\n\t\tif (!ctx->hevc_state) GF_SAFEALLOC(ctx->hevc_state, HEVCState);\n\t\tctx->min_layer_id = 0xFF;\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tctx->log_name = \"VVC\";\n\t\tif (ctx->hevc_state) { gf_free(ctx->hevc_state); ctx->hevc_state = NULL; }\n\t\tif (ctx->avc_state) { gf_free(ctx->avc_state); ctx->avc_state = NULL; }\n\t\tif (!ctx->vvc_state) GF_SAFEALLOC(ctx->vvc_state, VVCState);\n\t} else {\n\t\tctx->log_name = \"AVC|H264\";\n\t\tif (ctx->hevc_state) { gf_free(ctx->hevc_state); ctx->hevc_state = NULL; }\n\t\tif (ctx->vvc_state) { gf_free(ctx->vvc_state); ctx->vvc_state = NULL; }\n\t\tif (!ctx->avc_state) GF_SAFEALLOC(ctx->avc_state, AVCState);\n\t}\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tctx->nb_slices_in_au = 0;\n\t}\n\tctx->full_au_source = GF_FALSE;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_UNFRAMED_FULL_AU);\n\tif (p && p->value.boolean) {\n\t\tGF_FilterEvent fevt;\n\t\t//this is a reframer used after an encoder, we want to make sure we have enough frames to compute POC otherwise we might block the chain\n\t\t//by holding input packets - ask 1s by default\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_BUFFER_REQ, ctx->ipid);\n\t\tfevt.buffer_req.pid_only = GF_TRUE;\n\t\tfevt.buffer_req.max_buffer_us = 1000000;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\tctx->full_au_source = GF_TRUE;\n\t}\n\n\t//if source has no timescale, recompute time\n\tif (!ctx->timescale) ctx->notime = GF_TRUE;\n\n\t//copy properties at init or reconfig\n\tif (ctx->opid) {\n\t\tif (ctx->poc_probe_done) {\n\t\t\t//full frame mode, flush everything before signaling discontinuity\n\t\t\t//for other modes discontinuity we signal discontinuity before the current AU being reconstructed\n\t\t\tif (ctx->full_au_source && ctx->first_pck_in_au)\n\t\t\t\tnaludmx_finalize_au_flags(ctx);\n\n\t\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\t\t}\n\t\tctx->nal_store_size = 0;\n\n\t\tif (ctx->timescale != 0)\n\t\t\tctx->resume_from = 0;\n\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\t//don't change codec type if reframing an ES (for HLS SAES)\n\t\tif (!ctx->timescale)\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid));\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED_FULL_AU, NULL);\n\t\tif (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_ID))\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(1));\n\n\t\tctx->ps_modified = GF_TRUE;\n\t\tctx->crc_cfg = ctx->crc_cfg_enh = 0;\n\t}\n\n\treturn GF_OK;\n}\n\nstatic u64 naludmx_next_start_code(GF_BitStream *bs, u64 offset, u64 fsize, u32 *sc_size)\n{\n\tu32 pos=0, nb_zeros=0;\n\twhile (offset+pos<fsize) {\n\t\tu8 b = gf_bs_read_u8(bs);\n\t\tpos++;\n\t\tswitch (b) {\n\t\tcase 1:\n\t\t\t//break at first 0xXX000001 or 0x00000001\n\t\t\tif (nb_zeros>=2) {\n\t\t\t\t*sc_size = (nb_zeros==2) ? 3 : 4;\n\t\t\t\treturn offset+pos;\n\t\t\t}\n\t\t\tnb_zeros = 0;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnb_zeros++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnb_zeros=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//eof\n\treturn 0;\n}\n\nvoid naludmx_probe_recovery_sei(GF_BitStream *bs, AVCState *avc)\n{\n\t/*parse SEI*/\n\twhile (gf_bs_available(bs)) {\n\t\tu32 ptype, psize;\n\n\t\tptype = 0;\n\t\twhile (1) {\n\t\t\tu8 v = gf_bs_read_int(bs, 8);\n\t\t\tptype += v;\n\t\t\tif (v != 0xFF) break;\n\t\t}\n\n\t\tpsize = 0;\n\t\twhile (1) {\n\t\t\tu8 v = gf_bs_read_int(bs, 8);\n\t\t\tpsize += v;\n\t\t\tif (v != 0xFF) break;\n\t\t}\n\n\t\tif (ptype==6) {\n\t\t\tavc->sei.recovery_point.frame_cnt = gf_bs_read_ue(bs);\n\t\t\tavc->sei.recovery_point.valid = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tgf_bs_skip_bytes(bs, psize);\n\n\t\tptype = gf_bs_peek_bits(bs, 8, 0);\n\t\tif (ptype == 0x80) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void naludmx_check_dur(GF_Filter *filter, GF_NALUDmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_BitStream *bs;\n\tu64 duration, cur_dur, nal_start, filesize;\n\tu32 probe_size=0, start_code_size;\n\tAVCState *avc_state = NULL;\n\tHEVCState *hevc_state = NULL;\n\tVVCState *vvc_state = NULL;\n\tBool first_slice_in_pic = GF_TRUE;\n\tconst GF_PropertyValue *p;\n\tconst char *filepath = NULL;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tfilepath = p->value.string;\n\tctx->is_file = GF_TRUE;\n\n\tif (ctx->index<0) {\n\t\tif (gf_opts_get_bool(\"temp\", \"force_indexing\")) {\n\t\t\tctx->index = 1.0;\n\t\t} else {\n\t\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\t\t\tif (!p || (p->value.longuint > 20000000)) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Source file larger than 20M, skipping indexing\\n\", ctx->log_name));\n\t\t\t\tif (!gf_sys_is_test_mode())\n\t\t\t\t\tprobe_size = 20000000;\n\t\t\t} else {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t}\n\t\t}\n\t}\n\tif ((ctx->index<=0) && !probe_size) {\n\t\tctx->duration.num = 1;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tGF_SAFEALLOC(hevc_state, HEVCState);\n\t\tif (!hevc_state) return;\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tGF_SAFEALLOC(vvc_state, VVCState);\n\t\tif (!vvc_state) return;\n\t} else {\n\t\tGF_SAFEALLOC(avc_state, AVCState);\n\t\tif (!avc_state) return;\n\t}\n\n\tstream = gf_fopen_ex(filepath, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (hevc_state) gf_free(hevc_state);\n\t\tif (vvc_state) gf_free(vvc_state);\n\t\tif (avc_state) gf_free(avc_state);\n\t\tif (gf_fileio_is_main_thread(filepath)) {\n\t\t\tctx->duration.num = 1;\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\t}\n\t\treturn;\n\t}\n\tctx->index_size = 0;\n\tduration = 0;\n\tcur_dur = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tfilesize = gf_bs_available(bs);\n\n\tnal_start = naludmx_next_start_code(bs, 0, filesize, &start_code_size);\n\tif (!nal_start) {\n\t\tif (hevc_state) gf_free(hevc_state);\n\t\tif (avc_state) gf_free(avc_state);\n\t\tgf_bs_del(bs);\n\t\tgf_fclose(stream);\n\t\tctx->duration.num = 1;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\twhile (1) {\n\t\ts32 res;\n\t\tu32 gdr_frame_count = 0;\n\t\tBool is_rap = GF_FALSE;\n\t\tBool is_slice = GF_FALSE;\n\n\t\t//parse directly from current pos (next byte is first byte of nal hdr)\n\t\tif (hevc_state) {\n\t\t\tu8 temporal_id, layer_id, nal_type;\n\n\t\t\tres = gf_hevc_parse_nalu_bs(bs, hevc_state, &nal_type, &temporal_id, &layer_id);\n\t\t\tif (res>0) first_slice_in_pic = GF_TRUE;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//also mark first slice in gdr as valid seek point\n\t\t\tif (is_slice && hevc_state->sei.recovery_point.valid) {\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\thevc_state->sei.recovery_point.valid = GF_FALSE;\n\t\t\t\tgdr_frame_count = hevc_state->sei.recovery_point.frame_cnt;\n\t\t\t}\n\t\t} else if (vvc_state) {\n\n\t\t\tu8 temporal_id, layer_id, nal_type;\n\n\t\t\tres = gf_vvc_parse_nalu_bs(bs, vvc_state, &nal_type, &temporal_id, &layer_id);\n\t\t\tif (res>0) first_slice_in_pic = GF_TRUE;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_VVC_NALU_SLICE_TRAIL:\n\t\t\tcase GF_VVC_NALU_SLICE_STSA:\n\t\t\tcase GF_VVC_NALU_SLICE_RADL:\n\t\t\tcase GF_VVC_NALU_SLICE_RASL:\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\t\t\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_VVC_NALU_SLICE_CRA:\n\t\t\tcase GF_VVC_NALU_SLICE_GDR:\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tif (vvc_state->s_info.gdr_pic)\n\t\t\t\t\tgdr_frame_count = vvc_state->s_info.gdr_recovery_count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tu32 nal_type;\n\t\t\tres = gf_avc_parse_nalu(bs, avc_state);\n\t\t\tif (res>0) first_slice_in_pic = GF_TRUE;\n\n\t\t\tnal_type = avc_state->last_nal_type_parsed;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_IDR_SLICE:\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\t\t\tcase GF_AVC_NALU_DP_A_SLICE:\n\t\t\tcase GF_AVC_NALU_DP_B_SLICE:\n\t\t\tcase GF_AVC_NALU_DP_C_SLICE:\n\t\t\t\tis_slice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_SEI:\n\t\t\t\tnaludmx_probe_recovery_sei(bs, avc_state);\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\t//also mark open GOP or first slice in gdr as valid seek point\n\t\t\tif (is_slice && avc_state->sei.recovery_point.valid) {\n\t\t\t\tis_rap = GF_TRUE;\n\t\t\t\tavc_state->sei.recovery_point.valid = GF_FALSE;\n\t\t\t\tgdr_frame_count = avc_state->sei.recovery_point.frame_cnt;\n\t\t\t}\n\t\t}\n\n\t\tif (probe_size && (nal_start>probe_size) && is_rap) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!probe_size && is_rap && first_slice_in_pic && (cur_dur >= ctx->index * ctx->cur_fps.num) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(NALUIdx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = nal_start - start_code_size;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= ctx->cur_fps.num;\n\t\t\tctx->indexes[ctx->index_size].roll_count = gdr_frame_count;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tif (is_slice && first_slice_in_pic) {\n\t\t\tduration += ctx->cur_fps.den;\n\t\t\tcur_dur += ctx->cur_fps.den;\n\t\t\tfirst_slice_in_pic = GF_FALSE;\n\t\t}\n\n\t\t//align since some NAL parsing may stop anywhere\n\t\tgf_bs_align(bs);\n\t\tnal_start = naludmx_next_start_code(bs, gf_bs_get_position(bs), filesize, &start_code_size);\n\t\tif (!nal_start)\n\t\t\tbreak;\n\t}\n\tif (probe_size)\n\t\tprobe_size = (u32) gf_bs_get_position(bs);\n\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\tif (hevc_state) gf_free(hevc_state);\n\tif (vvc_state) gf_free(vvc_state);\n\tif (avc_state) gf_free(avc_state);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * ctx->cur_fps.num != duration * ctx->duration.den)) {\n\t\tif (probe_size) {\n\t\t\tduration *= filesize/probe_size;\n\t\t}\n\t\tctx->duration.num = (s32) duration;\n\t\tif (probe_size) ctx->duration.num = -ctx->duration.num;\n\t\tctx->duration.den = ctx->cur_fps.num;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && (!gf_sys_is_test_mode() || gf_opts_get_bool(\"temp\", \"force_indexing\"))) {\n\t\t\tfilesize *= 8 * ctx->duration.den;\n\t\t\tfilesize /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) filesize;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\n\nstatic void naludmx_enqueue_or_dispatch(GF_NALUDmxCtx *ctx, GF_FilterPacket *n_pck, Bool flush_ref)\n{\n\t//TODO: we are dispatching frames in \"negctts mode\", ie we may have DTS>CTS\n\t//need to signal this for consumers using DTS (eg MPEG-2 TS)\n\tif (flush_ref && ctx->pck_queue && ctx->poc_diff) {\n\t\tu32 dts_inc=0;\n\t\ts32 last_poc = 0;\n\t\tBool patch_missing_frame = GF_FALSE;\n\t\t//send all reference packet queued\n\t\tif (ctx->strict_poc==STRICT_POC_ERROR) {\n\t\t\tu32 i;\n\t\t\tu32 nb_bframes = 0;\n\t\t\tfor (i=0; i<gf_list_count(ctx->pck_queue); i++) {\n\t\t\t\ts32 poc;\n\t\t\t\tu64 poc_ts, dts;\n\t\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, i);\n\n\t\t\t\tif (q_pck == ctx->first_pck_in_au) break;\n\n\t\t\t\tdts = gf_filter_pck_get_dts(q_pck);\n\t\t\t\tif (dts == GF_FILTER_NO_TS) continue;\n\t\t\t\tpoc_ts = gf_filter_pck_get_cts(q_pck);\n\t\t\t\tassert(poc_ts != GF_FILTER_NO_TS);\n\t\t\t\tpoc = (s32) ((s64) poc_ts - CTS_POC_OFFSET_SAFETY);\n\n\t\t\t\tif (i) {\n\t\t\t\t\tif (last_poc>poc) nb_bframes ++;\n\t\t\t\t\telse if (last_poc + ctx->poc_diff<poc)\n\t\t\t\t\t\tpatch_missing_frame = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tlast_poc = poc;\n\t\t\t}\n\t\t\tif (nb_bframes>1)\n\t\t\t\tpatch_missing_frame = GF_FALSE;\n\t\t\telse if (nb_bframes)\n\t\t\t\tpatch_missing_frame = GF_TRUE;\n\t\t}\n\t\tlast_poc = GF_INT_MIN;\n\n\t\twhile (gf_list_count(ctx->pck_queue) ) {\n\t\t\tu64 dts;\n\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, 0);\n\n\t\t\tif (q_pck == ctx->first_pck_in_au) break;\n\n\t\t\tdts = gf_filter_pck_get_dts(q_pck);\n\t\t\tif (dts != GF_FILTER_NO_TS) {\n\t\t\t\ts32 poc;\n\t\t\t\tu64 poc_ts, cts;\n\t\t\t\tu8 carousel_info = gf_filter_pck_get_carousel_version(q_pck);\n\n\t\t\t\t//we reused timing from source packets\n\t\t\t\tif (!carousel_info) {\n\t\t\t\t\tassert(ctx->timescale);\n\t\t\t\t\tgf_list_rem(ctx->pck_queue, 0);\n\t\t\t\t\tgf_filter_pck_send(q_pck);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_set_carousel_version(q_pck, 0);\n\n\n\t\t\t\tpoc_ts = gf_filter_pck_get_cts(q_pck);\n\t\t\t\tassert(poc_ts != GF_FILTER_NO_TS);\n\t\t\t\tpoc = (s32) ((s64) poc_ts - CTS_POC_OFFSET_SAFETY);\n\n\t\t\t\tif (patch_missing_frame) {\n\t\t\t\t\tif (last_poc!=GF_INT_MIN) {\n\t\t\t\t\t\t//check if we missed an IDR (poc reset)\n\t\t\t\t\t\tif (poc && (last_poc > poc) ) {\n\t\t\t\t\t\t\tlast_poc = 0;\n\t\t\t\t\t\t\tdts_inc += ctx->cur_fps.den;\n\t\t\t\t\t\t\tctx->dts_last_IDR = dts;\n\t\t\t\t\t\t\tctx->dts += ctx->cur_fps.den;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//check if we miss a frame\n\t\t\t\t\t\twhile (last_poc + ctx->poc_diff < poc) {\n\t\t\t\t\t\t\tlast_poc += ctx->poc_diff;\n\t\t\t\t\t\t\tdts_inc += ctx->cur_fps.den;\n\t\t\t\t\t\t\tctx->dts += ctx->cur_fps.den;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlast_poc = poc;\n\t\t\t\t\tdts += dts_inc;\n\t\t\t\t}\n\t\t\t\t//poc is stored as diff since last IDR which has min_poc\n\t\t\t\tcts = ( (ctx->min_poc + (s32) poc) * ctx->cur_fps.den ) / ctx->poc_diff + ctx->dts_last_IDR;\n\n\t\t\t\t/*if PAFF, 2 pictures (eg poc) <=> 1 aggregated frame (eg sample), divide by 2*/\n\t\t\t\tif (ctx->is_paff) {\n\t\t\t\t\tcts /= 2;\n\t\t\t\t\t/*in some cases the poc is not on the top field - if that is the case, round up*/\n\t\t\t\t\tif (cts % ctx->cur_fps.den) {\n\t\t\t\t\t\tcts = ((cts/ctx->cur_fps.den)+1) * ctx->cur_fps.den;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[%s] Frame timestamps computed dts \"LLU\" cts \"LLU\" (poc %d min poc %d poc_diff %d last IDR DTS \"LLU\")\\n\", ctx->log_name, dts, cts, poc, ctx->min_poc, ctx->poc_diff, ctx->dts_last_IDR));\n\n\t\t\t\tif (ctx->importer && ctx->cur_fps.den) {\n\t\t\t\t\tpoc = (s32) ( (s64) cts - (s64) dts);\n\t\t\t\t\tif (poc<0) poc = -poc;\n\t\t\t\t\tpoc /= ctx->cur_fps.den;\n\t\t\t\t\tif (poc > ctx->max_total_delay)\n\t\t\t\t\t\tctx->max_total_delay = poc;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_rem(ctx->pck_queue, 0);\n\t\t\tgf_filter_pck_send(q_pck);\n\t\t}\n\t}\n\tif (!n_pck) return;\n\n\tif (!ctx->pck_queue) ctx->pck_queue = gf_list_new();\n\tgf_list_add(ctx->pck_queue, n_pck);\n}\n\nstatic void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)\n{\n\tGF_NALUFFParamArray *pa = NULL;\n\tu32 i, count;\n\tcount = gf_list_count(param_list);\n\tfor (i=0; i<count; i++) {\n\t\tpa = gf_list_get(param_list, i);\n\t\tif (pa->type == nal_type) break;\n\t\tpa = NULL;\n\t}\n\tif (!pa) {\n\t\tGF_SAFEALLOC(pa, GF_NALUFFParamArray);\n\t\tif (!pa) return;\n\n\t\tpa->array_completeness = 1;\n\t\tpa->type = nal_type;\n\t\tpa->nalus = gf_list_new();\n\t\tgf_list_add(param_list, pa);\n\t}\n\tgf_list_add(pa->nalus, sl);\n}\n\nstatic void naludmx_hevc_set_parall_type(GF_NALUDmxCtx *ctx, GF_HEVCConfig *hevc_cfg)\n{\n\tu32 use_tiles, use_wpp, nb_pps, i, count;\n\tHEVCState hevc;\n\n\tcount = gf_list_count(ctx->pps);\n\n\tmemset(&hevc, 0, sizeof(HEVCState));\n\thevc.sps_active_idx = -1;\n\n\tuse_tiles = 0;\n\tuse_wpp = 0;\n\tnb_pps = 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *slc = (GF_NALUFFParam*)gf_list_get(ctx->pps, i);\n\t\ts32 idx = gf_hevc_read_pps(slc->data, slc->size, &hevc);\n\n\t\tif (idx>=0) {\n\t\t\tHEVC_PPS *pps;\n\t\t\tnb_pps++;\n\t\t\tpps = &hevc.pps[idx];\n\t\t\tif (!pps->entropy_coding_sync_enabled_flag && pps->tiles_enabled_flag)\n\t\t\t\tuse_tiles++;\n\t\t\telse if (pps->entropy_coding_sync_enabled_flag && !pps->tiles_enabled_flag)\n\t\t\t\tuse_wpp++;\n\t\t}\n\t}\n\tif (!use_tiles && !use_wpp) hevc_cfg->parallelismType = 1;\n\telse if (!use_wpp && (use_tiles==nb_pps) ) hevc_cfg->parallelismType = 2;\n\telse if (!use_tiles && (use_wpp==nb_pps) ) hevc_cfg->parallelismType = 3;\n\telse hevc_cfg->parallelismType = 0;\n}\n\nGF_Err naludmx_set_hevc_oinf(GF_NALUDmxCtx *ctx, u8 *max_temporal_id)\n{\n#ifndef GPAC_DISABLE_ISOM\n\tGF_OperatingPointsInformation *oinf;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tu32 data_size;\n\tu32 i;\n\tHEVC_VPS *vps;\n\tGF_NALUFFParam *vps_sl = gf_list_get(ctx->vps, 0);\n\tif (!vps_sl) return GF_SERVICE_ERROR;\n\n\tvps = &ctx->hevc_state->vps[vps_sl->id];\n\n\tif (!vps->vps_extension_found) return GF_OK;\n\tif (vps->max_layers<2) return GF_OK;\n\n\toinf = gf_isom_oinf_new_entry();\n\tif (!oinf) return GF_OUT_OF_MEM;\n\n\toinf->scalability_mask = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tif (vps->scalability_mask[i])\n\t\t\toinf->scalability_mask |= 1 << i;\n\t}\n\n\tfor (i = 0; i < vps->num_profile_tier_level; i++) {\n\t\tHEVC_ProfileTierLevel ptl = (i == 0) ? vps->ptl : vps->ext_ptl[i-1];\n\t\tLHEVC_ProfileTierLevel *lhevc_ptl;\n\t\tGF_SAFEALLOC(lhevc_ptl, LHEVC_ProfileTierLevel);\n\t\tif (!lhevc_ptl) return GF_OUT_OF_MEM;\n\n\t\tlhevc_ptl->general_profile_space = ptl.profile_space;\n\t\tlhevc_ptl->general_tier_flag = ptl.tier_flag;\n\t\tlhevc_ptl->general_profile_idc = ptl.profile_idc;\n\t\tlhevc_ptl->general_profile_compatibility_flags = ptl.profile_compatibility_flag;\n\t\tlhevc_ptl->general_constraint_indicator_flags = 0;\n\t\tif (ptl.general_progressive_source_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 47;\n\t\tif (ptl.general_interlaced_source_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 46;\n\t\tif (ptl.general_non_packed_constraint_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 45;\n\t\tif (ptl.general_frame_only_constraint_flag)\n\t\t\tlhevc_ptl->general_constraint_indicator_flags |= ((u64)1) << 44;\n\t\tlhevc_ptl->general_constraint_indicator_flags |= ptl.general_reserved_44bits;\n\t\tlhevc_ptl->general_level_idc = ptl.level_idc;\n\t\tgf_list_add(oinf->profile_tier_levels, lhevc_ptl);\n\t}\n\n\tfor (i = 0; i < vps->num_output_layer_sets; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tu32 j;\n\t\tu16 minPicWidth, minPicHeight, maxPicWidth, maxPicHeight;\n\t\tu8 maxChromaFormat, maxBitDepth;\n\t\tu8 maxTemporalId;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\n\t\top->output_layer_set_idx = i;\n\t\top->layer_count = vps->num_necessary_layers[i];\n\t\tminPicWidth = minPicHeight = maxPicWidth = maxPicHeight = maxTemporalId = 0;\n\t\tmaxChromaFormat = maxBitDepth = 0;\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\tu32 format_idx;\n\t\t\tu32 bitDepth;\n\t\t\top->layers_info[j].ptl_idx = vps->profile_tier_level_idx[i][j];\n\t\t\top->layers_info[j].layer_id = j;\n\t\t\top->layers_info[j].is_outputlayer = vps->output_layer_flag[i][j];\n\t\t\t//FIXME: we consider that this flag is never set\n\t\t\top->layers_info[j].is_alternate_outputlayer = GF_FALSE;\n\n\t\t\tif (max_temporal_id) {\n\t\t\t\tif (!maxTemporalId || (maxTemporalId < max_temporal_id[op->layers_info[j].layer_id]))\n\t\t\t\t\tmaxTemporalId = max_temporal_id[op->layers_info[j].layer_id];\n\t\t\t} else {\n\t\t\t\tmaxTemporalId = vps->max_sub_layers;\n\t\t\t}\n\n\t\t\tformat_idx = vps->rep_format_idx[op->layers_info[j].layer_id];\n\t\t\tif (!minPicWidth || (minPicWidth > vps->rep_formats[format_idx].pic_width_luma_samples))\n\t\t\t\tminPicWidth = vps->rep_formats[format_idx].pic_width_luma_samples;\n\t\t\tif (!minPicHeight || (minPicHeight > vps->rep_formats[format_idx].pic_height_luma_samples))\n\t\t\t\tminPicHeight = vps->rep_formats[format_idx].pic_height_luma_samples;\n\t\t\tif (!maxPicWidth || (maxPicWidth < vps->rep_formats[format_idx].pic_width_luma_samples))\n\t\t\t\tmaxPicWidth = vps->rep_formats[format_idx].pic_width_luma_samples;\n\t\t\tif (!maxPicHeight || (maxPicHeight < vps->rep_formats[format_idx].pic_height_luma_samples))\n\t\t\t\tmaxPicHeight = vps->rep_formats[format_idx].pic_height_luma_samples;\n\t\t\tif (!maxChromaFormat || (maxChromaFormat < vps->rep_formats[format_idx].chroma_format_idc))\n\t\t\t\tmaxChromaFormat = vps->rep_formats[format_idx].chroma_format_idc;\n\t\t\tbitDepth = vps->rep_formats[format_idx].bit_depth_chroma > vps->rep_formats[format_idx].bit_depth_luma ? vps->rep_formats[format_idx].bit_depth_chroma : vps->rep_formats[format_idx].bit_depth_luma;\n\t\t\tif (!maxChromaFormat || (maxChromaFormat < bitDepth))\n\t\t\t\tmaxChromaFormat = bitDepth;\n\t\t}\n\t\top->max_temporal_id = maxTemporalId;\n\t\top->minPicWidth = minPicWidth;\n\t\top->minPicHeight = minPicHeight;\n\t\top->maxPicWidth = maxPicWidth;\n\t\top->maxPicHeight = maxPicHeight;\n\t\top->maxChromaFormat = maxChromaFormat;\n\t\top->maxBitDepth = maxBitDepth;\n\t\top->frame_rate_info_flag = GF_FALSE; //FIXME: should fetch this info from VUI\n\t\top->bit_rate_info_flag = GF_FALSE; //we don't use it\n\t\tgf_list_add(oinf->operating_points, op);\n\t}\n\n\tfor (i = 0; i < vps->max_layers; i++) {\n\t\tLHEVC_DependentLayer *dep;\n\t\tu32 j, k;\n\t\tif (i==MAX_LHVC_LAYERS) break;\n\n\t\tGF_SAFEALLOC(dep, LHEVC_DependentLayer);\n\t\tif (!dep) return GF_OUT_OF_MEM;\n\n\t\tdep->dependent_layerID = vps->layer_id_in_nuh[i];\n\t\tfor (j = 0; j < vps->max_layers; j++) {\n\t\t\tif (j==MAX_LHVC_LAYERS) break;\n\n\t\t\tif (vps->direct_dependency_flag[dep->dependent_layerID][j]) {\n\t\t\t\tdep->dependent_on_layerID[dep->num_layers_dependent_on] = j;\n\t\t\t\tdep->num_layers_dependent_on ++;\n\t\t\t}\n\t\t}\n\t\tk = 0;\n\t\tfor (j = 0; j < 16; j++) {\n\t\t\tif (oinf->scalability_mask & (1 << j)) {\n\t\t\t\tdep->dimension_identifier[j] = vps->dimension_id[i][k];\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tgf_list_add(oinf->dependency_layers, dep);\n\t}\n\n\t//write Operating Points Information Sample Group\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_oinf_write_entry(oinf, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tgf_isom_oinf_del_entry(oinf);\n\n\tgf_filter_pid_set_info_str(ctx->opid, \"hevc:oinf\", &PROP_DATA_NO_COPY(data, data_size) );\n#endif\n\treturn GF_OK;\n}\n\nstatic void naludmx_set_hevc_linf(GF_NALUDmxCtx *ctx)\n{\n\tu32 i, nb_layers=0, nb_sublayers=0;\n\tu8 *data;\n\tu32 data_size;\n\tGF_BitStream *bs;\n\n\tfor (i=0; i<64; i++) {\n\t\tif (ctx->linf[i].layer_id_plus_one) nb_layers++;\n\t\tif (ctx->linf[i].min_temporal_id != ctx->linf[i].max_temporal_id) nb_sublayers++;\n\t}\n\tif (!nb_layers && !nb_sublayers)\n\t\treturn;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_bs_write_int(bs, 0, 2);\n\tgf_bs_write_int(bs, nb_layers, 6);\n\tfor (i=0; i<nb_layers; i++) {\n\t\tif (! ctx->linf[i].layer_id_plus_one) continue;\n\t\tgf_bs_write_int(bs, 0, 4);\n\t\tgf_bs_write_int(bs, ctx->linf[i].layer_id_plus_one - 1, 6);\n\t\tgf_bs_write_int(bs, ctx->linf[i].min_temporal_id, 3);\n\t\tgf_bs_write_int(bs, ctx->linf[i].max_temporal_id, 3);\n\t\tgf_bs_write_int(bs, 0, 1);\n\t\tgf_bs_write_int(bs, 0xFF, 7);\n\n\t}\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tgf_filter_pid_set_info_str(ctx->opid, \"hevc:linf\", &PROP_DATA_NO_COPY(data, data_size) );\n}\n\nstatic Bool naludmx_create_hevc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar, Bool *has_hevc_base)\n{\n\tu32 i, count;\n\tu8 layer_id;\n\tBool first = GF_TRUE;\n\tBool first_lhvc = GF_TRUE;\n\tGF_HEVCConfig *cfg;\n\tGF_HEVCConfig *hvcc;\n\tGF_HEVCConfig *lvcc;\n\tu32 max_w, max_h, max_ew, max_eh;\n\n\t*has_hevc_base = GF_FALSE;\n\n\n\tmax_w = max_h = 0;\n\tmax_ew = max_eh = 0;\n\tsar->num = sar->den = 0;\n\n\t//check we have one pps or sps in base layer\n\tcount = gf_list_count(ctx->sps);\n\tif (!count && !ctx->analyze) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) {\n\t\t\t*has_hevc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcount = gf_list_count(ctx->pps);\n\tif (!count && !ctx->analyze) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) {\n\t\t\t*has_hevc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thvcc = gf_odf_hevc_cfg_new();\n\tlvcc = gf_odf_hevc_cfg_new();\n\thvcc->nal_unit_size = ctx->nal_length;\n\tlvcc->nal_unit_size = ctx->nal_length;\n\tlvcc->is_lhvc = GF_TRUE;\n\n\t//assign vps first so that they are serialized first\n\tcount = gf_list_count(ctx->vps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vps, i);\n\t\tHEVC_VPS *vps = &ctx->hevc_state->vps[sl->id];\n\n\t\tif (!i) {\n\t\t\thvcc->avgFrameRate = lvcc->avgFrameRate = vps->rates[0].avg_pic_rate;\n\t\t\thvcc->constantFrameRate = lvcc->constantFrameRate = vps->rates[0].constant_pic_rate_idc;\n\t\t\thvcc->numTemporalLayers = lvcc->numTemporalLayers = vps->max_sub_layers;\n\t\t\thvcc->temporalIdNested = lvcc->temporalIdNested = vps->temporal_id_nesting;\n\t\t}\n\t\t//TODO set scalability mask\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu((ctx->explicit || ! (*has_hevc_base) ) ? lvcc->param_array : hvcc->param_array, sl, GF_HEVC_NALU_VID_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->sps);\n\tfor (i=0; i<count; i++) {\n\t\tBool is_lhvc = GF_FALSE;\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tHEVC_SPS *sps = &ctx->hevc_state->sps[sl->id];\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) *has_hevc_base = GF_TRUE;\n\n\t\tif (ctx->explicit || layer_id) {\n\t\t\tcfg = lvcc;\n\t\t\tis_lhvc = GF_TRUE;\n\t\t} else {\n\t\t\tcfg = hvcc;\n\t\t}\n\n\t\tif (first || (is_lhvc && first_lhvc) ) {\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_space = sps->ptl.profile_space;\n\t\t\tcfg->tier_flag = sps->ptl.tier_flag;\n\t\t\tcfg->profile_idc = sps->ptl.profile_idc;\n\t\t\tcfg->general_profile_compatibility_flags = sps->ptl.profile_compatibility_flag;\n\t\t\tcfg->progressive_source_flag = sps->ptl.general_progressive_source_flag;\n\t\t\tcfg->interlaced_source_flag = sps->ptl.general_interlaced_source_flag;\n\t\t\tcfg->non_packed_constraint_flag = sps->ptl.general_non_packed_constraint_flag;\n\t\t\tcfg->frame_only_constraint_flag = sps->ptl.general_frame_only_constraint_flag;\n\t\t\tcfg->constraint_indicator_flags = sps->ptl.general_reserved_44bits;\n\t\t\tcfg->level_idc = sps->ptl.level_idc;\n\t\t\tcfg->chromaFormat = sps->chroma_format_idc;\n\t\t\tcfg->luma_bit_depth = sps->bit_depth_luma;\n\t\t\tcfg->chroma_bit_depth = sps->bit_depth_chroma;\n\t\t\tctx->interlaced = cfg->interlaced_source_flag ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (sps->aspect_ratio_info_present_flag && sps->sar_width && sps->sar_height) {\n\t\t\t\tsar->num = sps->sar_width;\n\t\t\t\tsar->den = sps->sar_height;\n\t\t\t}\n\n\t\t\t/*disable frame rate scan, most bitstreams have wrong values there*/\n\t\t\tif (ctx->notime && first && (!ctx->fps.num || !ctx->fps.den) && sps->has_timing_info\n\t\t\t\t/*if detected FPS is greater than 1000, assume wrong timing info*/\n\t\t\t\t&& (sps->time_scale <= 1000*sps->num_units_in_tick)\n\t\t\t) {\n\t\t\t\tctx->cur_fps.num = sps->time_scale;\n\t\t\t\tctx->cur_fps.den = sps->num_units_in_tick;\n\n\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_lhvc) {\n\t\t\tfirst_lhvc = GF_FALSE;\n\t\t\tif (sps->width > max_ew) max_ew = sps->width;\n\t\t\tif (sps->height > max_eh) max_eh = sps->height;\n\t\t} else {\n\t\t\tif (sps->width > max_w) max_w = sps->width;\n\t\t\tif (sps->height > max_h) max_h = sps->height;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_HEVC_NALU_SEQ_PARAM);\n\t}\n\n\tcfg = ctx->explicit ? lvcc : hvcc;\n\tcount = gf_list_count(ctx->pps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3);\n\t\tif (!layer_id) *has_hevc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(layer_id ? lvcc->param_array : cfg->param_array, sl, GF_HEVC_NALU_PIC_PARAM);\n\t}\n\n\t*dsi = *dsi_enh = NULL;\n\t*dsi_size = *dsi_enh_size = 0;\n\n\tif (ctx->explicit || ! (*has_hevc_base) ) {\n\t\tnaludmx_hevc_set_parall_type(ctx, lvcc);\n\t\tgf_odf_hevc_cfg_write(lvcc, dsi, dsi_size);\n\t\t*max_width = *max_enh_width = max_ew;\n\t\t*max_height = *max_enh_height = max_eh;\n\t} else {\n\t\tnaludmx_hevc_set_parall_type(ctx, hvcc);\n\t\tgf_odf_hevc_cfg_write(hvcc, dsi, dsi_size);\n\t\tif (gf_list_count(lvcc->param_array) ) {\n\t\t\tnaludmx_hevc_set_parall_type(ctx, lvcc);\n\t\t\tgf_odf_hevc_cfg_write(lvcc, dsi_enh, dsi_enh_size);\n\t\t}\n\t\t*max_width = max_w;\n\t\t*max_height = max_h;\n\t\t*max_enh_width = max_ew;\n\t\t*max_enh_height = max_eh;\n\t}\n\tcount = gf_list_count(hvcc->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(hvcc->param_array, i);\n\t\tgf_list_reset(pa->nalus);\n\t}\n\tcount = gf_list_count(lvcc->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(lvcc->param_array, i);\n\t\tgf_list_reset(pa->nalus);\n\t}\n\tgf_odf_hevc_cfg_del(hvcc);\n\tgf_odf_hevc_cfg_del(lvcc);\n\treturn GF_TRUE;\n}\n\n\nstatic Bool naludmx_create_vvc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar, Bool *has_vvc_base)\n{\n\tu32 i, count;\n\tu8 layer_id;\n\tBool first = GF_TRUE;\n\tBool first_lvvc = GF_TRUE;\n\tGF_VVCConfig *cfg;\n\tu32 max_w, max_h, max_ew, max_eh;\n\n\t*has_vvc_base = GF_FALSE;\n\n\tmax_w = max_h = 0;\n\tmax_ew = max_eh = 0;\n\tsar->num = sar->den = 0;\n\n\t//check we have one pps or sps in base layer\n\tcount = gf_list_count(ctx->sps);\n\tif (!count && !ctx->analyze) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tlayer_id = (sl->data[0] & 0x3f);\n\t\t//todo, base is not always 0 !\n\t\tif (!layer_id) {\n\t\t\t*has_vvc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcount = gf_list_count(ctx->pps);\n\tif (!count && !ctx->analyze) return GF_FALSE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = (sl->data[0] & 0x3f);\n\t\t//todo, base is not always 0 !\n\t\tif (!layer_id) {\n\t\t\t*has_vvc_base = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcfg = gf_odf_vvc_cfg_new();\n\tcfg->nal_unit_size = ctx->nal_length;\n\n\n\t//assign vps first so that they are serialized first\n\tcount = gf_list_count(ctx->vps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vps, i);\n\t\tVVC_VPS *vps = &ctx->vvc_state->vps[sl->id];\n\n\t\tif (!i) {\n\t\t\tcfg->avgFrameRate = vps->rates[0].avg_pic_rate;\n\t\t\tcfg->constantFrameRate = vps->rates[0].constant_pic_rate_idc;\n\t\t\tcfg->numTemporalLayers = vps->max_sub_layers;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_VID_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->sps);\n\tfor (i=0; i<count; i++) {\n\t\tBool is_lvvc = GF_FALSE;\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tVVC_SPS *sps = &ctx->vvc_state->sps[sl->id];\n\t\tlayer_id = sl->data[0] & 0x3f;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\n\t\tif (ctx->explicit || layer_id) {\n\t\t\tis_lvvc = GF_TRUE;\n\t\t}\n\n\t\tif (first || (is_lvvc && first_lvvc) ) {\n\t\t\tVVC_VPS *vps = &ctx->vvc_state->vps[sps->vps_id];\n\t\t\tcfg->avgFrameRate = 0;\n\t\t\tcfg->constantFrameRate = 1;\n\t\t\tcfg->numTemporalLayers = sps->max_sublayers;\n\t\t\tcfg->nal_unit_size = ctx->nal_length;\n\t\t\tcfg->ptl_present = vps->num_ptl ? 1 : 0;\n\n\t\t\tif (vps->num_ptl) {\n\t\t\t\tcfg->num_constraint_info = vps->ptl[0].gci_present ? 1 : 12;\n\t\t\t\tcfg->general_profile_idc = vps->ptl[0].general_profile_idc;\n\t\t\t\tcfg->general_tier_flag = vps->ptl[0].general_tier_flag;\n\t\t\t\tcfg->general_level_idc = vps->ptl[0].general_level_idc;\n\t\t\t\tcfg->ptl_frame_only_constraint = vps->ptl[0].frame_only_constraint;\n\t\t\t\tcfg->ptl_multilayer_enabled = vps->ptl[0].multilayer_enabled;\n\n\t\t\t\tcfg->general_constraint_info = gf_malloc(sizeof(u8) * cfg-> num_constraint_info);\n\t\t\t\tif (cfg->general_constraint_info)\n\t\t\t\t\tmemcpy(cfg->general_constraint_info, vps->ptl[0].gci, cfg->num_constraint_info);\n\n\t\t\t\t//todo set temporal sublayers\n\t\t\t\tcfg->ptl_sublayer_present_mask = 0;\n\t\t\t\tcfg->num_sub_profiles = 0;\n\t\t\t\tcfg->ols_idx = 0;\n\t\t\t}\n\t\t\tcfg->chroma_format = sps->chroma_format_idc;\n\t\t\tcfg->bit_depth = sps->bitdepth;\n\t\t\tcfg->maxPictureWidth = sps->width;\n\t\t\tcfg->maxPictureHeight = sps->height;\n\n\t\t\tif (sps->aspect_ratio_info_present_flag && sps->sar_width && sps->sar_height) {\n\t\t\t\tsar->num = sps->sar_width;\n\t\t\t\tsar->den = sps->sar_height;\n\t\t\t}\n\n\t\t\t/*disable frame rate scan, most bitstreams have wrong values there*/\n\t\t\tif (ctx->notime && first && (!ctx->fps.num || !ctx->fps.den) && sps->has_timing_info\n\t\t\t\t/*if detected FPS is greater than 1000, assume wrong timing info*/\n\t\t\t\t&& (sps->time_scale <= 1000*sps->num_units_in_tick)\n\t\t\t) {\n\t\t\t\tctx->cur_fps.num = sps->time_scale;\n\t\t\t\tctx->cur_fps.den = sps->num_units_in_tick;\n\t\t\t\tgf_media_get_reduced_frame_rate(&ctx->cur_fps.num, &ctx->cur_fps.den);\n\n\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_lvvc) {\n\t\t\tfirst_lvvc = GF_FALSE;\n\t\t\tif (sps->width > max_ew) max_ew = sps->width;\n\t\t\tif (sps->height > max_eh) max_eh = sps->height;\n\t\t} else {\n\t\t\tif (sps->width > max_w) max_w = sps->width;\n\t\t\tif (sps->height > max_h) max_h = sps->height;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_SEQ_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->pps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tlayer_id = sl->data[0] & 0x3F;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_PIC_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->vvc_dci);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vvc_dci, i);\n\t\tlayer_id = sl->data[0] & 0x3F;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_DEC_PARAM);\n\t}\n\n\tcount = gf_list_count(ctx->vvc_opi);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vvc_opi, i);\n\t\tlayer_id = sl->data[0] & 0x3F;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_OPI);\n\t}\n\n\tcount = gf_list_count(ctx->vvc_aps_pre);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->vvc_aps_pre, i);\n\t\tlayer_id = sl->data[0] & 0x3F;\n\t\tif (!layer_id) *has_vvc_base = GF_TRUE;\n\t\tif (!ctx->analyze)\n\t\t\tnaludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_APS_PREFIX);\n\t}\n\n\t*dsi = *dsi_enh = NULL;\n\t*dsi_size = *dsi_enh_size = 0;\n\n\tgf_odf_vvc_cfg_write(cfg, dsi, dsi_size);\n\t*max_width = max_w;\n\t*max_height = max_h;\n\t*max_enh_width = max_ew;\n\t*max_enh_height = max_eh;\n\n\tcount = gf_list_count(cfg->param_array);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(cfg->param_array, i);\n\t\tgf_list_reset(pa->nalus);\n\t}\n\tgf_odf_vvc_cfg_del(cfg);\n\treturn GF_TRUE;\n}\n\nBool naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar)\n{\n\tu32 i, count;\n\tBool first = GF_TRUE;\n\tBool first_svc = GF_TRUE;\n\tGF_AVCConfig *cfg;\n\tGF_AVCConfig *avcc;\n\tGF_AVCConfig *svcc;\n\tu32 max_w, max_h, max_ew, max_eh;\n\n\n\tmax_w = max_h = max_ew = max_eh = 0;\n\tsar->num = sar->den = 0;\n\n\tif (!ctx->analyze && (!gf_list_count(ctx->sps) || !gf_list_count(ctx->pps)))\n\t\treturn GF_FALSE;\n\n\tavcc = gf_odf_avc_cfg_new();\n\tsvcc = gf_odf_avc_cfg_new();\n\tavcc->nal_unit_size = ctx->nal_length;\n\tsvcc->nal_unit_size = ctx->nal_length;\n\n\tctx->is_mvc = GF_FALSE;\n\tcount = gf_list_count(ctx->sps);\n\tfor (i=0; i<count; i++) {\n\t\tBool is_svc = GF_FALSE;\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps, i);\n\t\tAVC_SPS *sps = &ctx->avc_state->sps[sl->id];\n\t\tu32 nal_type = sl->data[0] & 0x1F;\n\n\t\tif ((sps->profile_idc == 118) || (sps->profile_idc == 128)) {\n\t\t\tctx->is_mvc = GF_TRUE;\n\t\t}\n\n\t\tif (ctx->explicit) {\n\t\t\tcfg = svcc;\n\t\t} else if (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) {\n\t\t\tcfg = svcc;\n\t\t\tis_svc = GF_TRUE;\n\t\t} else {\n\t\t\tcfg = avcc;\n\t\t}\n\n\t\tif (first || (is_svc && first_svc) ) {\n\t\t\tcfg->configurationVersion = 1;\n\t\t\tcfg->profile_compatibility = sps->prof_compat;\n\t\t\tcfg->AVCProfileIndication = sps->profile_idc;\n\t\t\tcfg->AVCLevelIndication = sps->level_idc;\n\t\t\tcfg->chroma_format = sps->chroma_format;\n\t\t\tcfg->luma_bit_depth = 8 + sps->luma_bit_depth_m8;\n\t\t\tcfg->chroma_bit_depth = 8 + sps->chroma_bit_depth_m8;\n\t\t\t/*try to patch ?*/\n\t\t\tif (!gf_avcc_use_extensions(cfg->AVCProfileIndication)\n\t\t\t\t&& ((cfg->chroma_format>1) || (cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8))\n\t\t\t) {\n\t\t\t\tif ((cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) {\n\t\t\t\t\tcfg->AVCProfileIndication = 110;\n\t\t\t\t} else {\n\t\t\t\t\tcfg->AVCProfileIndication = (cfg->chroma_format==3) ? 244 : 122;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sps->vui_parameters_present_flag && sps->vui.par_num && sps->vui.par_den) {\n\t\t\t\tsar->num = sps->vui.par_num;\n\t\t\t\tsar->den = sps->vui.par_den;\n\t\t\t}\n\t\t\tctx->interlaced = sps->frame_mbs_only_flag ? GF_FALSE : GF_TRUE;\n\n\n\t\t\t/*disable frame rate scan, most bitstreams have wrong values there*/\n\t\t\tif (first && (!ctx->fps.num || !ctx->fps.den) && sps->vui.timing_info_present_flag\n\t\t\t\t/*if detected FPS is greater than 1000, assume wrong timing info*/\n\t\t\t\t&& (sps->vui.time_scale <= 1000*sps->vui.num_units_in_tick)\n\t\t\t) {\n\t\t\t\t/*ISO/IEC 14496-10 n11084 Table E-6*/\n\t\t\t\t/* not used :\t\t\t\tu8 DeltaTfiDivisorTable[] = {1,1,1,2,2,2,2,3,3,4,6}; */\n\t\t\t\tu8 DeltaTfiDivisorIdx;\n\t\t\t\tif (!sps->vui.pic_struct_present_flag) {\n\t\t\t\t\tDeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag);\n\t\t\t\t} else {\n\t\t\t\t\tif (!ctx->avc_state->sei.pic_timing.pic_struct)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 2;\n\t\t\t\t\telse if (ctx->avc_state->sei.pic_timing.pic_struct == 8)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 6;\n\t\t\t\t\telse\n\t\t\t\t\t\tDeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;\n\t\t\t\t}\n\t\t\t\tif (ctx->notime) {\n\t\t\t\t\tu32 fps_num = 2 * sps->vui.time_scale;\n\t\t\t\t\tu32 fps_den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;\n\t\t\t\t\tif (fps_num && fps_den) {\n\t\t\t\t\t\tctx->cur_fps.num = fps_num;\n\t\t\t\t\t\tctx->cur_fps.den = fps_den;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t\t}\n\t\t\t\tif (! sps->vui.fixed_frame_rate_flag)\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Possible Variable Frame Rate: VUI \\\"fixed_frame_rate_flag\\\" absent\\n\", ctx->log_name));\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_svc) {\n\t\t\tfirst_svc = GF_FALSE;\n\t\t\tif (sps->width > max_ew) max_ew = sps->width;\n\t\t\tif (sps->height > max_eh) max_eh = sps->height;\n\t\t} else {\n\t\t\tif (sps->width > max_w) max_w = sps->width;\n\t\t\tif (sps->height > max_h) max_h = sps->height;\n\t\t}\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->sequenceParameterSets, sl);\n\t}\n\n\tcfg = ctx->explicit ? svcc : avcc;\n\tcount = gf_list_count(ctx->sps_ext);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->sps_ext, i);\n\t\tif (!cfg->sequenceParameterSetExtensions) cfg->sequenceParameterSetExtensions = gf_list_new();\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->sequenceParameterSetExtensions, sl);\n\t}\n\n\tcfg = ctx->explicit ? svcc : avcc;\n\tcount = gf_list_count(ctx->pps);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps, i);\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t}\n\n\tcfg = svcc;\n\tcount = gf_list_count(ctx->pps_svc);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(ctx->pps_svc, i);\n\t\tif (!ctx->analyze)\n\t\t\tgf_list_add(cfg->pictureParameterSets, sl);\n\t}\n\n\t*dsi = *dsi_enh = NULL;\n\t*dsi_size = *dsi_enh_size = 0;\n\n\tif (ctx->explicit) {\n\t\tgf_odf_avc_cfg_write(svcc, dsi, dsi_size);\n\t} else {\n\t\tgf_odf_avc_cfg_write(avcc, dsi, dsi_size);\n\t\tif (gf_list_count(svcc->sequenceParameterSets) || svcc->sequenceParameterSetExtensions) {\n\t\t\tgf_odf_avc_cfg_write(svcc, dsi_enh, dsi_enh_size);\n\t\t}\n\t}\n\tgf_list_reset(avcc->sequenceParameterSets);\n\tgf_list_reset(avcc->sequenceParameterSetExtensions);\n\tgf_list_reset(avcc->pictureParameterSets);\n\tgf_list_reset(svcc->sequenceParameterSets);\n\tgf_list_reset(svcc->sequenceParameterSetExtensions);\n\tgf_list_reset(svcc->pictureParameterSets);\n\tgf_odf_avc_cfg_del(avcc);\n\tgf_odf_avc_cfg_del(svcc);\n\t*max_width = max_w;\n\t*max_height = max_h;\n\t*max_enh_width = max_ew;\n\t*max_enh_height = max_eh;\n\treturn GF_TRUE;\n}\n\nstatic void naludmx_end_access_unit(GF_NALUDmxCtx *ctx)\n{\n\t//finalize current fram flags - we will flush(send) later on\n\tnaludmx_finalize_au_flags(ctx);\n\n\tctx->has_islice = GF_FALSE;\n\tctx->nb_slices_in_au = 0;\n\tctx->sei_recovery_frame_count = -1;\n\tctx->au_sap = GF_FILTER_SAP_NONE;\n\tctx->au_sap2_poc_reset = GF_FALSE;\n\tctx->bottom_field_flag = GF_FALSE;\n}\n\nstatic void naludmx_update_clli_mdcv(GF_NALUDmxCtx *ctx, Bool reset_crc)\n{\n\tif (!ctx->opid) return;\n\n\tif (reset_crc)\n\t\tctx->clli_crc = 0;\n\tif ((ctx->hevc_state && ctx->hevc_state->clli_valid)\n\t\t|| (ctx->vvc_state && ctx->vvc_state->clli_valid)\n\t) {\n\t\tu8 *clli = ctx->hevc_state ? ctx->hevc_state->clli_data : ctx->vvc_state->clli_data;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(clli, 4));\n\t\tctx->clli_crc = gf_crc_32(clli, 4);\n\t}\n\tif (reset_crc)\n\t\tctx->mdcv_crc = 0;\n\n\tif ((ctx->hevc_state && ctx->hevc_state->mdcv_valid)\n\t\t|| (ctx->vvc_state && ctx->vvc_state->mdcv_valid)\n\t) {\n\t\tu8 *mdcv = ctx->hevc_state ? ctx->hevc_state->mdcv_data : ctx->vvc_state->mdcv_data;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_MASTER_DISPLAY_COLOUR, &PROP_DATA(mdcv, 24));\n\t\tctx->mdcv_crc = gf_crc_32(mdcv, 24);\n\t}\n}\n\nstatic void naludmx_set_dolby_vision(GF_NALUDmxCtx *ctx)\n{\n\tu8 dv_cfg[24];\n\tif (!ctx->opid)\n\t\treturn;\n\n\tswitch (ctx->dv_mode) {\n\tcase DVMODE_NONE:\n\tcase DVMODE_CLEAN:\n\t\treturn;\n\t//auto mode, wait until we have RPU or EL to signal profile\n\tcase DVMODE_AUTO:\n\t\tif (!ctx->nb_dv_rpu && !ctx->nb_dv_el) return;\n\t\tbreak;\n\t}\n\n\tu32 dv_level = gf_dolby_vision_level(ctx->width, ctx->height, ctx->cur_fps.num, ctx->cur_fps.den, ctx->codecid);\n\n\tif (ctx->dv_profile==8) {\n\t\tif (ctx->dv_compatid<2) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] DV profile 8 used but dv_compatid not set, defaulting to bt709 (=2)\\n\", ctx->log_name));\n\t\t\tctx->dv_compatid = 3;\n\t\t}\n\t}\n\tu32 dv_ccid = ctx->dv_compatid ? (ctx->dv_compatid-1) : 0;\n\tu32 dv_profile_id = ctx->dv_profile;\n\n\n\t//auto-detect DV profile, check  range, color primaries, EOTF, matrix, and chroma sample location type\n\tif (!ctx->dv_profile) {\n\t\tBool vui_present = GF_FALSE;\n\t\tBool has_non_def = GF_FALSE;\n\t\tu32 luma_bit_depth=8;\n\t\tu32 fr = 0;\n\t\tu32 cp = 2;\n\t\tu32 tc = 2;\n\t\tu32 mx = 2;\n\t\tu32 cl = 0;\n\t\tif (ctx->avc_state && (ctx->avc_state->last_sps_idx>=0)) {\n\t\t\tAVC_SPS *sps = &ctx->avc_state->sps[ctx->avc_state->last_sps_idx];\n\t\t\tluma_bit_depth = sps->luma_bit_depth_m8+8;\n\t\t\tif (sps->vui_parameters_present_flag) {\n\t\t\t\tvui_present = GF_TRUE;\n\t\t\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\t\t\tfr = sps->vui.video_full_range_flag;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (sps->vui.chroma_location_info_present_flag) {\n\t\t\t\t\tcl = (sps->chroma_format==1) ?  sps->vui.chroma_sample_loc_type_top_field : 2;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\t\tcp = sps->vui.colour_primaries;\n\t\t\t\t\ttc = sps->vui.transfer_characteristics;\n\t\t\t\t\tmx = sps->vui.matrix_coefficients;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ctx->hevc_state && (ctx->hevc_state->last_parsed_sps_id>=0)) {\n\t\t\tHEVC_SPS *sps = &ctx->hevc_state->sps[ctx->hevc_state->last_parsed_sps_id];\n\t\t\tluma_bit_depth = sps->bit_depth_luma;\n\t\t\tif (sps->vui_parameters_present_flag) {\n\t\t\t\tvui_present = GF_TRUE;\n\t\t\t\tif (sps->chroma_loc_info_present_flag)\n\t\t\t\t\tcl = (sps->chroma_format_idc==1) ?  sps->chroma_sample_loc_type_top_field : 2;\n\n\t\t\t\t//check profile compat:  range, color primaries, EOTF, matrix, and chroma sample location type\n\t\t\t\tif (sps->video_signal_type_present_flag) {\n\t\t\t\t\tfr = sps->video_full_range_flag;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (sps->colour_description_present_flag) {\n\t\t\t\t\tcp = sps->colour_primaries;\n\t\t\t\t\ttc = sps->transfer_characteristic;\n\t\t\t\t\tmx = sps->matrix_coeffs;\n\t\t\t\t\thas_non_def = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((fr==1) && (cp==2) && (tc==2) && (mx==2) && (cl==0)) dv_ccid=0;\n\t\telse if ((fr==0) && (cp==9) && (tc==16) && (mx==9) && (cl==0)) dv_ccid=1;\n\t\telse if ((fr==0) && (cp==1) && (tc==1) && (mx==1) && (cl==0)) dv_ccid=2;\n\t\telse if ((fr==0) && (cp==9) && (tc==18) && (mx==9) && (cl==2)) dv_ccid=4;\n\t\telse if ((fr==0) && (cp==9) && (tc==14) && (mx==9) && (cl==0)) dv_ccid=4;\n\t\telse if ((fr==0) && (cp==9) && (tc==16) && (mx==9) && (cl==2)) dv_ccid=6;\n\n\t\t//we consider that if no VUI but an EL is present, this will be profile 4 compat SRD\n\t\tif (!vui_present && ctx->nb_dv_el)\n\t\t\tdv_ccid = 2;\n\n\n\t\tif (dv_ccid==2) {\n\t\t\tif (ctx->nb_dv_el) dv_profile_id = 4;\n\t\t\telse if (luma_bit_depth==8) dv_profile_id = 9;\n\t\t\telse dv_profile_id = 8; //or 4\n\t\t}\n\t\t//DV spec: \"Note: H.265 (2018-02) requires top-left chroma siting (VUI = 2), if the decoded video is intended for interpretation\n\t\t// according to ITU-R BT.2020-2 or ITU-R BT.2100-1. Previously, H.265 (2016-12) described the default chroma siting as center left (VUI = 0).\"\n\t\t//we consider that dv_ccid=6 is allowed for profile 8 ( DV without EL) - this is not clearly written in the spec but matches deployed bitstreams\n\t\telse if (dv_ccid==6) {\n\t\t\tdv_profile_id = ctx->nb_dv_el ? 7 : 8;\n\t\t}\n\t\telse if ((dv_ccid==1) || (dv_ccid==4)) dv_profile_id = 8;\n\t\t//default to 5 if no EL, 4 if EL\n\t\telse dv_profile_id = ctx->nb_dv_el ? 4 : 5;\n\n\t\t//DV spec: \"Note: As of the effective date of this specification, all commercially produced profile 4 and profile 5 Dolby Vision bitstreams\n\t\t// have used center-left siting during chroma downsampling, and are distributed without the VUI value for chroma sample location type.\n\t\t// Those bitstreams are compliant with this specification.\"\n\t\t//we treat bitstreams not explicitly signaling vui info as valid and assign the CCID according to DV spec\n\t\tif (!has_non_def) {\n\t\t\tif (dv_profile_id == 4) dv_ccid = 2;\n\t\t\telse if (dv_profile_id == 5) dv_ccid = 0;\n\t\t}\n\t}\n\t//not in auto mode, restore value\n\tif (ctx->dv_compatid)\n\t\tdv_ccid = ctx->dv_compatid-1;\n\n\tmemset(dv_cfg, 0, sizeof(u8)*24);\n\tGF_BitStream *bs = gf_bs_new(dv_cfg, 24, GF_BITSTREAM_WRITE);\n\tgf_bs_write_u8(bs, 1); //version major\n\tgf_bs_write_u8(bs, 0); //version minor\n\tgf_bs_write_int(bs, dv_profile_id, 7);\n\tgf_bs_write_int(bs, dv_level, 6);\n\tgf_bs_write_int(bs, ctx->nb_dv_rpu ? 1 : 0, 1); //rpu present\n\tgf_bs_write_int(bs, ctx->nb_dv_el ? 1 : 0, 1); //el present\n\tgf_bs_write_int(bs, 1, 1); //bl_present_flag always true, we don't split streams\n\tgf_bs_write_int(bs, dv_ccid, 4);\n\t//the rest is zero-reserved\n\tgf_bs_write_int(bs, 0, 28);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_write_u32(bs, 0);\n\tgf_bs_del(bs);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOLBY_VISION, &PROP_DATA(dv_cfg, 24));\n}\n\nstatic void naludmx_check_pid(GF_Filter *filter, GF_NALUDmxCtx *ctx, Bool force_au_flush)\n{\n\tu32 w, h, ew, eh;\n\tu8 *dsi, *dsi_enh;\n\tu32 dsi_size, dsi_enh_size;\n\tu32 crc_cfg, crc_cfg_enh;\n\tGF_Fraction sar;\n\tBool has_hevc_base = GF_TRUE;\n\tBool has_colr_info = GF_FALSE;\n\tBool res;\n\n\tif (ctx->analyze) {\n\t\tif (ctx->opid && !ctx->ps_modified) return;\n\t} else {\n\t\tif (!ctx->ps_modified) return;\n\t\tif (ctx->opid && (!gf_list_count(ctx->sps) || !gf_list_count(ctx->pps)))\n\t\t\treturn;\n\t}\n\tctx->ps_modified = GF_FALSE;\n\n\tdsi = dsi_enh = NULL;\n\n\tif (ctx->notime) {\n\t\tctx->cur_fps = ctx->fps;\n\t\tif (!ctx->cur_fps.num || !ctx->cur_fps.den) {\n\t\t\tctx->cur_fps.num = 25000;\n\t\t\tctx->cur_fps.den = 1000;\n\t\t}\n\t}\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tres = naludmx_create_hevc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar, &has_hevc_base);\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tres = naludmx_create_vvc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar, &has_hevc_base);\n\t} else {\n\t\tres = naludmx_create_avc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar);\n\t}\n\tif (!res) return;\n\n\tcrc_cfg = crc_cfg_enh = 0;\n\tif (dsi) crc_cfg = gf_crc_32(dsi, dsi_size);\n\tif (dsi_enh) crc_cfg_enh = gf_crc_32(dsi_enh, dsi_enh_size);\n\n\tif (!ctx->analyze && (!w || !h)) {\n\t\tif (dsi) gf_free(dsi);\n\t\tif (dsi_enh) gf_free(dsi_enh);\n\t\treturn;\n\t}\n\n\tif (!ctx->opid) {\n\t\tu32 slice_in_au = ctx->nb_slices_in_au;\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\t\tnaludmx_check_dur(filter, ctx);\n\t\tctx->nb_slices_in_au = slice_in_au;\n\t}\n\n\tif ((ctx->crc_cfg == crc_cfg) && (ctx->crc_cfg_enh == crc_cfg_enh)\n\t\t&& (ctx->width==w) && (ctx->height==h)\n\t\t&& (ctx->sar.num * sar.den == ctx->sar.den * sar.num)\n\t) {\n\t\tif (dsi) gf_free(dsi);\n\t\tif (dsi_enh) gf_free(dsi_enh);\n\t\treturn;\n\t}\n\n\tif (force_au_flush) {\n\t\tnaludmx_end_access_unit(ctx);\n\t}\n\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\tif (!ctx->analyze && (gf_list_count(ctx->pck_queue)>1))  {\n\t\tGF_LOG(dsi_enh ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] xPS changed but could not flush frames before signaling state change %s\\n\", ctx->log_name, dsi_enh ? \"- likely scalable xPS update\" : \"!\"));\n\t}\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\n\t//don't change codec type if reframing an ES (for HLS SAES)\n\tif (!ctx->timescale)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\tif (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_ID))\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(1));\n\n\tctx->width = w;\n\tctx->height = h;\n\tctx->sar = sar;\n\tctx->crc_cfg = crc_cfg;\n\tctx->crc_cfg_enh = crc_cfg_enh;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT( ctx->width));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT( ctx->height));\n\tif (ew && eh) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH_MAX, & PROP_UINT( ew ));\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT_MAX, & PROP_UINT( eh ));\n\t}\n\tif (ctx->sar.den)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, & PROP_FRAC(ctx->sar));\n\telse\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, NULL);\n\n\t//if we have a FPS prop, use it\n\tif (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FPS))\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->cur_fps.num));\n\n\tif (ctx->explicit || !has_hevc_base) {\n\t\tu32 enh_cid = GF_CODECID_SVC;\n\t\tif (ctx->codecid==GF_CODECID_HEVC) enh_cid = GF_CODECID_LHVC;\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(enh_cid));\n\t\tif (dsi) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) );\n\t} else {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid));\n\t\tif (dsi) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) );\n\t\tif (dsi_enh) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, &PROP_DATA_NO_COPY(dsi_enh, dsi_enh_size) );\n\t}\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tif ((ctx->codecid==GF_CODECID_HEVC) && gf_list_count(ctx->vps) ) {\n\t\tGF_Err e = naludmx_set_hevc_oinf(ctx, NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] Failed to create OINF chunk\\n\", ctx->log_name));\n\t\t}\n\t\tnaludmx_set_hevc_linf(ctx);\n\t}\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\tif (ctx->is_file /* && ctx->index*/) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\t//set interlaced or remove interlaced property\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_INTERLACED, ctx->interlaced ? & PROP_UINT(GF_TRUE) : NULL);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tHEVC_SPS *sps = &ctx->hevc_state->sps[ctx->hevc_state->sps_active_idx];\n\t\tif (sps->colour_description_present_flag) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(sps->colour_primaries) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(sps->transfer_characteristic) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(sps->matrix_coeffs) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(sps->video_full_range_flag) );\n\t\t\thas_colr_info = GF_TRUE;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t} else {\n\t\t/*use the last active SPS*/\n\t\tif (ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui_parameters_present_flag\n\t\t&& ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui.colour_description_present_flag) {\n\t\t\tAVC_VUI *vui = &ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui;\n\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(vui->colour_primaries) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(vui->transfer_characteristics) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(vui->matrix_coefficients) );\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(vui->video_full_range_flag) );\n\t\t\thas_colr_info = GF_TRUE;\n\t\t}\n\t}\n\n\tif (!has_colr_info) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, NULL);\n\t}\n\n\tnaludmx_update_clli_mdcv(ctx, GF_TRUE);\n\n\tnaludmx_set_dolby_vision(ctx);\n\n}\n\nstatic Bool naludmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tu64 file_pos = 0;\n\tGF_FilterEvent fevt;\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = ctx->dts = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (!ctx->initial_play_done) {\n\t\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t\tif (evt->play.start_range<0.1)\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t\tctx->resume_from = 0;\n\t\t\tctx->nal_store_size = 0;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tif (ctx->start_range && (ctx->index<0)) {\n\t\t\tctx->index = -ctx->index;\n\t\t\tctx->file_loaded = GF_FALSE;\n\t\t\tctx->duration.den = ctx->duration.num = 0;\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Play request from %d, building index\\n\", ctx->log_name, ctx->start_range));\n\t\t\tnaludmx_check_dur(filter, ctx);\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\n\t\tif (ctx->start_range) {\n\t\t\tctx->nb_nalus = ctx->nb_i = ctx->nb_p = ctx->nb_b = ctx->nb_sp = ctx->nb_si = ctx->nb_sei = ctx->nb_idr = ctx->nb_cra = 0;\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->cur_fps.num);\n\t\t\t\t\tctx->dts = ctx->dts_last_IDR = ctx->cts;\n\t\t\t\t\tfile_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tctx->seek_gdr_count = ctx->indexes[i-1].roll_count;\n\t\t\t\t\tif (ctx->seek_gdr_count) ctx->first_gdr = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!file_pos) {\n\t\t\t\t//very short streams, input is done before we get notified for play and everything stored in memory: flush\n\t\t\t\tif (gf_filter_pid_is_eos(ctx->ipid) && (ctx->nal_store_size)) {\n\t\t\t\t\tgf_filter_post_process_task(filter);\n\t\t\t\t}\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tctx->nb_frames = 0;\n\t\tctx->nb_nalus = 0;\n\t\tctx->resume_from = 0;\n\t\tctx->nal_store_size = 0;\n\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\tctx->nal_store_size = 0;\n\t\tctx->resume_from = 0;\n\t\tctx->cts = 0;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void naludmx_update_time(GF_NALUDmxCtx *ctx)\n{\n\tassert(ctx->cur_fps.num);\n\n\tif (!ctx->notime) {\n\t\t//very first frame, no dts diff, assume 3000/90k. It should only hurt if we have several frames packet in the first packet sent\n\t\tu64 dts_inc = ctx->cur_fps.den ? ctx->cur_fps.den : 3000;\n\t\tctx->cts += dts_inc;\n\t\tctx->dts += dts_inc;\n\t} else {\n\t\tassert(ctx->cur_fps.den);\n\t\tctx->cts += ctx->cur_fps.den;\n\t\tctx->dts += ctx->cur_fps.den;\n\t}\n}\n\nstatic void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id, u32 tid, u32 lid)\n{\n\tGF_List *list = NULL, *alt_list = NULL;\n\tGF_NALUFFParam *sl;\n\tu32 i, count, crc;\n\tBool flush_au = GF_FALSE;\n\n\tif (!size) return;\n\tcrc = gf_crc_32(data, size);\n\n\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tflush_au = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tflush_au = GF_TRUE;\n\t\t\tctx->valid_ps_flags |= 1;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tctx->valid_ps_flags |= 1<<1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\tswitch (ps_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tif (!ctx->vps) ctx->vps = gf_list_new();\n\t\t\tlist = ctx->vps;\n\t\t\tflush_au = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tflush_au = GF_TRUE;\n\t\t\tctx->valid_ps_flags |= 1;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tlist = ctx->pps;\n\t\t\tctx->valid_ps_flags |= 1<<1;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tif (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new();\n\t\t\tlist = ctx->vvc_dci;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_OPI:\n\t\t\tif (!ctx->vvc_opi) ctx->vvc_opi = gf_list_new();\n\t\t\tlist = ctx->vvc_opi;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tif (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new();\n\t\t\tlist = ctx->vvc_aps_pre;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tswitch (ps_type) {\n\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tctx->valid_ps_flags |= 1;\n\t\t\tflush_au = GF_TRUE;\n\t\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\t\t\tlist = ctx->sps;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\tctx->valid_ps_flags |= 1<<1;\n\t\t\tlist = ctx->pps;\n\t\t\talt_list = ctx->pps_svc;\n\t\t\tbreak;\n\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tif (!ctx->sps_ext) ctx->sps_ext = gf_list_new();\n\t\t\tlist = ctx->sps_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tsl = NULL;\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (sl->id != ps_id) {\n\t\t\tsl = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t//same ID, same CRC, we don't change our state\n\t\tif (sl->crc == crc) return;\n\t\tbreak;\n\t}\n\t//handle alt PPS list for SVC\n\tif (!sl && alt_list) {\n\t\tcount = gf_list_count(alt_list);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsl = gf_list_get(alt_list, i);\n\t\t\tif (sl->id != ps_id) {\n\t\t\t\tsl = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//same ID, same CRC, we don't change our state\n\t\t\tif (sl->crc == crc) return;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (lid || tid) flush_au = GF_FALSE;\n\n\tif (sl) {\n\t\t//otherwise we keep this new param set\n\t\tsl->data = gf_realloc(sl->data, size);\n\t\tmemcpy(sl->data, data, size);\n\t\tsl->size = size;\n\t\tsl->crc = crc;\n\t\tctx->ps_modified = GF_TRUE;\n\t\t//flush AU if we have a slice\n\t\tif (ctx->opid && flush_au && ctx->first_pck_in_au && ctx->nb_slices_in_au) {\n\t\t\tnaludmx_end_access_unit(ctx);\n\t\t}\n\t\treturn;\n\t}\n\t//TODO we might want to purge the list after a while !!\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char) * size);\n\tif (!sl->data) {\n\t\tgf_free(sl);\n\t\treturn;\n\t}\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tsl->crc = crc;\n\n\tctx->ps_modified = GF_TRUE;\n\t//flush AU if we have a slice\n\tif (ctx->opid && flush_au && ctx->first_pck_in_au && ctx->nb_slices_in_au) {\n\t\tnaludmx_end_access_unit(ctx);\n\t}\n\tgf_list_add(list, sl);\n}\n\nstatic void naludmx_finalize_au_flags(GF_NALUDmxCtx *ctx)\n{\n\tu64 ts;\n\tBool is_rap = GF_FALSE;\n\n\tif (!ctx->first_pck_in_au)\n\t\treturn;\n\tif (ctx->au_sap) {\n\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, ctx->au_sap);\n\t\tif ((ctx->au_sap == GF_FILTER_SAP_1) || ctx->au_sap2_poc_reset) {\n\t\t\tctx->dts_last_IDR = gf_filter_pck_get_dts(ctx->first_pck_in_au);\n\t\t\tif (ctx->is_paff)\n\t\t\t\tctx->dts_last_IDR *= 2;\n\t\t}\n\t\tif (ctx->au_sap <= GF_FILTER_SAP_3) {\n\t\t\tis_rap = GF_TRUE;\n\t\t}\n\t}\n\telse if (ctx->has_islice && ctx->force_sync && (ctx->sei_recovery_frame_count==0)) {\n\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, GF_FILTER_SAP_1);\n\t\tif (!ctx->use_opengop_gdr) {\n\t\t\tctx->use_opengop_gdr = 1;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] Forcing non-IDR samples with I slices to be marked as sync points - resulting file will not be ISOBMFF compliant\\n\", ctx->log_name));\n\t\t}\n\t\tis_rap = GF_TRUE;\n\t}\n\t/*set roll info sampleGroups info*/\n\telse if (!ctx->au_sap && ( (ctx->sei_recovery_frame_count >= 0) || ctx->has_islice) ) {\n\t\t/*generic GDR*/\n\t\tif (ctx->sei_recovery_frame_count > 0) {\n\t\t\tif (!ctx->use_opengop_gdr) ctx->use_opengop_gdr = 1;\n\t\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, GF_FILTER_SAP_4);\n\t\t\tgf_filter_pck_set_roll_info(ctx->first_pck_in_au, ctx->sei_recovery_frame_count);\n\t\t}\n\t\t/*open-GOP*/\n\t\telse if ((ctx->sei_recovery_frame_count == 0) && ctx->has_islice) {\n\t\t\tif (!ctx->use_opengop_gdr) ctx->use_opengop_gdr = 2;\n\t\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, GF_FILTER_SAP_3);\n\t\t\tis_rap = GF_TRUE;\n\t\t}\n\t}\n\tif (ctx->is_paff) {\n\t\tgf_filter_pck_set_interlaced(ctx->first_pck_in_au, ctx->bottom_field_flag ? 2 : 1);\n\t}\n\n\t//if TS is set, the packet was the first in AU in the input timed packet (eg PES), we reuse the input timing\n\tts = gf_filter_pck_get_cts(ctx->first_pck_in_au);\n\tif (ts == GF_FILTER_NO_TS) {\n\t\t/*we store the POC (last POC minus the poc shift) as the CTS offset and re-update the CTS when dispatching*/\n\t\tassert(ctx->last_poc >= ctx->poc_shift);\n\t\tgf_filter_pck_set_cts(ctx->first_pck_in_au, CTS_POC_OFFSET_SAFETY + ctx->last_poc - ctx->poc_shift);\n\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\tgf_filter_pck_set_carousel_version(ctx->first_pck_in_au, 1);\n\t}\n\n\tif (ctx->subsamp_buffer_size) {\n\t\tgf_filter_pck_set_property(ctx->first_pck_in_au, GF_PROP_PCK_SUBS, &PROP_DATA(ctx->subsamp_buffer, ctx->subsamp_buffer_size) );\n\t\tctx->subsamp_buffer_size = 0;\n\t\tctx->subs_mapped_bytes = 0;\n\t}\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = (is_rap) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->has_ref_slices ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \tflags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(ctx->first_pck_in_au, flags);\n\t}\n\tctx->has_ref_slices = GF_FALSE;\n\tctx->has_redundant = GF_FALSE;\n\n\tif ((ctx->hevc_state && ctx->hevc_state->clli_valid)\n\t\t|| (ctx->vvc_state && ctx->vvc_state->clli_valid)\n\t) {\n\t\tu8 *clli = ctx->hevc_state ? ctx->hevc_state->clli_data : ctx->vvc_state->clli_data;\n\t\tu32 crc = gf_crc_32(clli, 4);\n\t\tif (!ctx->clli_crc) {\n\t\t\tnaludmx_update_clli_mdcv(ctx, GF_FALSE);\n\t\t}\n\n\t\tif (crc != ctx->clli_crc) {\n\t\t\tgf_filter_pck_set_property(ctx->first_pck_in_au, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(clli, 4));\n\t\t}\n\t}\n\tif ((ctx->hevc_state && ctx->hevc_state->mdcv_valid)\n\t\t|| (ctx->vvc_state && ctx->vvc_state->mdcv_valid)\n\t) {\n\t\tu8 *mdcv = ctx->hevc_state ? ctx->hevc_state->mdcv_data : ctx->vvc_state->mdcv_data;\n\t\tu32 crc = gf_crc_32(mdcv, 24);\n\t\tif (!ctx->mdcv_crc) {\n\t\t\tnaludmx_update_clli_mdcv(ctx, GF_FALSE);\n\t\t}\n\t\tif (crc != ctx->mdcv_crc) {\n\t\t\tgf_filter_pck_set_property(ctx->first_pck_in_au, GF_PROP_PID_MASTER_DISPLAY_COLOUR, &PROP_DATA(mdcv, 24));\n\t\t}\n\t}\n\tif (ctx->hevc_state)\n\t\tctx->hevc_state->clli_valid = ctx->hevc_state->mdcv_valid = 0;\n\tif (ctx->vvc_state)\n\t\tctx->vvc_state->clli_valid = ctx->vvc_state->mdcv_valid = 0;\n\n\n\t//if we reuse input packets timing, we can dispatch asap.\n\t//otherwise if poc probe is done (we know the min_poc_diff between images) and we are not in strict mode, dispatch asap\n\t//otherwise we will need to wait for the next ref frame to make sure we know all pocs ...\n\tif (!ctx->notime || (!ctx->strict_poc && ctx->poc_probe_done) )\n\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\n\tctx->first_pck_in_au = NULL;\n}\n\nstatic void naludmx_update_nalu_maxsize(GF_NALUDmxCtx *ctx, u32 size)\n{\n\tif (ctx->max_nalu_size < size) {\n\t\tctx->max_nalu_size = size;\n\t\tif (size > ctx->max_nalu_size_allowed) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] nal size %d larger than max allowed size %d - change import settings\\n\", ctx->log_name, size, ctx->max_nalu_size_allowed ));\n\t\t}\n\t}\n}\n\n\nGF_FilterPacket *naludmx_start_nalu(GF_NALUDmxCtx *ctx, u32 nal_size, Bool skip_nal_field, Bool *au_start, u8 **pck_data)\n{\n\tGF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(ctx->opid, nal_size + (skip_nal_field ? 0 : ctx->nal_length), pck_data);\n\tif (!dst_pck) return NULL;\n\n\tif (!skip_nal_field) {\n\t\tif (!ctx->bs_w) ctx->bs_w = gf_bs_new(*pck_data, ctx->nal_length, GF_BITSTREAM_WRITE);\n\t\telse gf_bs_reassign_buffer(ctx->bs_w, *pck_data, ctx->nal_length);\n\t\tgf_bs_write_int(ctx->bs_w, nal_size, 8*ctx->nal_length);\n\t}\n\n\tif (*au_start) {\n\t\tctx->first_pck_in_au = dst_pck;\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);\n\t\t//we reuse the timing of the input packet for the first nal of the first frame starting in this packet\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t} else {\n\t\t\t//we don't set the CTS, it will be set once we detect frame end\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\t}\n\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\tgf_filter_pck_set_carousel_version(dst_pck, ctx->notime ? 1 : 0);\n\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->pck_duration ? ctx->pck_duration : ctx->cur_fps.den);\n\t\tif (ctx->in_seek) {\n\t\t\tgf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\t\tif (ctx->first_gdr) {\n\t\t\t\tctx->first_gdr = GF_FALSE;\n\t\t\t\tgf_filter_pck_set_sap(ctx->first_pck_in_au, GF_FILTER_SAP_4);\n\t\t\t}\n\t\t}\n\n\t\tnaludmx_update_time(ctx);\n\t\t*au_start = GF_FALSE;\n\t\tctx->nb_frames++;\n\t} else {\n\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t}\n\tnaludmx_update_nalu_maxsize(ctx, nal_size);\n\n\tnaludmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE);\n\n\treturn dst_pck;\n}\n\nvoid naludmx_add_subsample(GF_NALUDmxCtx *ctx, u32 subs_size, u8 subs_priority, u32 subs_reserved)\n{\n\tif (ctx->subsamp_buffer_alloc < ctx->subsamp_buffer_size+14 ) {\n\t\tctx->subsamp_buffer_alloc = ctx->subsamp_buffer_size+14;\n\t\tctx->subsamp_buffer = gf_realloc(ctx->subsamp_buffer, ctx->subsamp_buffer_alloc);\n\t}\n\tassert(ctx->subsamp_buffer);\n\tgf_bs_reassign_buffer(ctx->bs_w, ctx->subsamp_buffer + ctx->subsamp_buffer_size, 14);\n\tgf_bs_write_u32(ctx->bs_w, 0); //flags\n\tgf_bs_write_u32(ctx->bs_w, subs_size + ctx->nal_length);\n\tgf_bs_write_u32(ctx->bs_w, subs_reserved); //reserved\n\tgf_bs_write_u8(ctx->bs_w, subs_priority); //priority\n\tgf_bs_write_u8(ctx->bs_w, 0); //discardable - todo\n\tctx->subsamp_buffer_size += 14;\n\tctx->subs_mapped_bytes += subs_size + ctx->nal_length;\n}\n\nstatic void naludmx_push_prefix(GF_NALUDmxCtx *ctx, u8 *data, u32 size, Bool avc_sei_rewrite)\n{\n\tif (ctx->sei_buffer_alloc < ctx->sei_buffer_size + size + ctx->nal_length) {\n\t\tctx->sei_buffer_alloc = ctx->sei_buffer_size + size + ctx->nal_length;\n\t\tctx->sei_buffer = gf_realloc(ctx->sei_buffer, ctx->sei_buffer_alloc);\n\t}\n\n\tif (!ctx->bs_w) ctx->bs_w = gf_bs_new(ctx->sei_buffer + ctx->sei_buffer_size, ctx->nal_length + size, GF_BITSTREAM_WRITE);\n\telse gf_bs_reassign_buffer(ctx->bs_w, ctx->sei_buffer + ctx->sei_buffer_size, ctx->nal_length + size);\n\tgf_bs_write_int(ctx->bs_w, size, 8*ctx->nal_length);\n\tmemcpy(ctx->sei_buffer + ctx->sei_buffer_size + ctx->nal_length, data, size);\n\n\tif (avc_sei_rewrite) {\n\t\tu32 rw_sei_size = gf_avc_reformat_sei(ctx->sei_buffer + ctx->sei_buffer_size + ctx->nal_length, size, ctx->seirw, ctx->avc_state);\n\t\tif (rw_sei_size < size) {\n\t\t\tgf_bs_seek(ctx->bs_w, 0);\n\t\t\tgf_bs_write_int(ctx->bs_w, rw_sei_size, 8*ctx->nal_length);\n\t\t\tsize = rw_sei_size;\n\t\t}\n\t}\n\tctx->sei_buffer_size += size + ctx->nal_length;\n}\n\nstatic s32 naludmx_parse_nal_hevc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool *skip_nal, Bool *is_slice, Bool *is_islice)\n{\n\ts32 ps_idx = 0;\n\ts32 res;\n\tu8 nal_unit_type, temporal_id, layer_id;\n\t*skip_nal = GF_FALSE;\n\n\tif (size<2) return -1;\n\n\tgf_bs_reassign_buffer(ctx->bs_r, data, size);\n\tres = gf_hevc_parse_nalu_bs(ctx->bs_r, ctx->hevc_state, &nal_unit_type, &temporal_id, &layer_id);\n\tctx->nb_nalus++;\n\n\tif (res < 0) {\n\t\tif (res == -1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_unit_type));\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t}\n\n\tif (layer_id && ctx->nosvc) {\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\t}\n\n\tswitch (nal_unit_type) {\n\tcase GF_HEVC_NALU_VID_PARAM:\n\t\tif (ctx->novpsext) {\n\t\t\t//this may modify nal_size, but we don't use it for bitstream reading\n\t\t\tps_idx = gf_hevc_read_vps_ex(data, &size, ctx->hevc_state, GF_TRUE);\n\t\t} else {\n\t\t\tps_idx = ctx->hevc_state->last_parsed_vps_id;\n\t\t}\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Video Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_HEVC_NALU_VID_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\tps_idx = ctx->hevc_state->last_parsed_sps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_HEVC_NALU_SEQ_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\tps_idx = ctx->hevc_state->last_parsed_pps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Picture Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_HEVC_NALU_PIC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEI_PREFIX:\n\t\tgf_hevc_parse_sei(data, size, ctx->hevc_state);\n\t\tif (!ctx->nosei) {\n\t\t\tctx->nb_sei++;\n\t\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t} else {\n\t\t\tctx->nb_nalus--;\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEI_SUFFIX:\n\t\tif (! ctx->is_playing) return 0;\n\t\tif (ctx->nosei) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t\tctx->nb_nalus--;\n\t\t} else {\n\t\t\tctx->nb_sei++;\n\t\t}\n\t\tbreak;\n\n\t/*slice_segment_layer_rbsp*/\n\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\tcase GF_HEVC_NALU_SLICE_STSA_R:\n\tcase GF_HEVC_NALU_SLICE_RADL_R:\n\tcase GF_HEVC_NALU_SLICE_RASL_R:\n\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\tcase GF_HEVC_NALU_SLICE_TRAIL_R:\n\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\tcase GF_HEVC_NALU_SLICE_TSA_R:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\tcase GF_HEVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\tif (! ctx->is_playing) return 0;\n\t\t*is_slice = GF_TRUE;\n\t\tctx->last_layer_id = layer_id;\n\t\tctx->last_temporal_id = temporal_id;\n\t\tif (! *skip_nal) {\n\t\t\tswitch (ctx->hevc_state->s_info.slice_type) {\n\t\t\tcase GF_HEVC_SLICE_TYPE_P:\n\t\t\t\tif (layer_id) ctx->nb_e_p++;\n\t\t\t\telse ctx->nb_p++;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_SLICE_TYPE_I:\n\t\t\t\tif (layer_id) ctx->nb_e_i++;\n\t\t\t\telse ctx->nb_i++;\n\t\t\t\t*is_islice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_SLICE_TYPE_B:\n\t\t\t\tif (layer_id) ctx->nb_e_b++;\n\t\t\t\telse ctx->nb_b++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_HEVC_NALU_ACCESS_UNIT:\n\t\tctx->nb_aud++;\n\t\tif (!ctx->audelim) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else if (!ctx->opid) {\n\t\t\tctx->has_initial_aud = GF_TRUE;\n\t\t\tmemcpy(ctx->init_aud, data, 3);\n\t\t}\n\t\tbreak;\n\t/*remove*/\n\tcase GF_HEVC_NALU_FILLER_DATA:\n\tcase GF_HEVC_NALU_END_OF_SEQ:\n\tcase GF_HEVC_NALU_END_OF_STREAM:\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\n\t//parsing is partial, see https://github.com/DolbyLaboratories/dlb_mp4base/blob/70a2e1d4d99a8439b7b8087bf50dd503eeea2291/src/esparser/parser_hevc.c#L1233\n\tcase GF_HEVC_NALU_DV_RPU:\n\t\tif (ctx->dv_mode==DVMODE_CLEAN) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_rpu ++;\n\t\t\tif (ctx->nb_dv_rpu==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\tcase GF_HEVC_NALU_DV_EL:\n\t\tif ((ctx->dv_mode==DVMODE_CLEAN) || (ctx->dv_mode==DVMODE_SINGLE)) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_el ++;\n\t\t\tif (ctx->nb_dv_el==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (! ctx->is_playing) return 0;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] NAL Unit type %d not handled - adding\\n\", ctx->log_name, nal_unit_type));\n\t\tbreak;\n\t}\n\tif (*skip_nal) return res;\n\n\tctx->linf[layer_id].layer_id_plus_one = layer_id + 1;\n\tif (! ctx->linf[layer_id].max_temporal_id ) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].max_temporal_id < temporal_id) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\n\tif (! ctx->linf[layer_id].min_temporal_id ) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].min_temporal_id > temporal_id) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\n\tif (ctx->max_temporal_id[layer_id] < temporal_id)\n\t\tctx->max_temporal_id[layer_id] = temporal_id;\n\tif (ctx->min_layer_id > layer_id) ctx->min_layer_id = layer_id;\n\treturn res;\n}\n\n\nstatic s32 naludmx_parse_nal_vvc(GF_NALUDmxCtx *ctx, char *data, u32 size, Bool *skip_nal, Bool *is_slice, Bool *is_islice)\n{\n\ts32 ps_idx = 0;\n\ts32 res;\n\tu8 nal_unit_type, temporal_id, layer_id;\n\t*skip_nal = GF_FALSE;\n\n\tif (size<2) return -1;\n\tgf_bs_reassign_buffer(ctx->bs_r, data, size);\n\tres = gf_vvc_parse_nalu_bs(ctx->bs_r, ctx->vvc_state, &nal_unit_type, &temporal_id, &layer_id);\n\tctx->nb_nalus++;\n\n\tif (res < 0) {\n\t\tif (res == -1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_unit_type));\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t}\n\n\tif (layer_id && ctx->nosvc) {\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\t}\n\n\tswitch (nal_unit_type) {\n\tcase GF_VVC_NALU_VID_PARAM:\n\t\tif (ctx->novpsext) {\n\t\t\t//this may modify nal_size, but we don't use it for bitstream reading\n//\t\t\tps_idx = gf_hevc_read_vps_ex(data, &size, ctx->hevc_state, GF_TRUE);\n\t\t\tps_idx = ctx->vvc_state->last_parsed_vps_id;\n\t\t} else {\n\t\t\tps_idx = ctx->vvc_state->last_parsed_vps_id;\n\t\t}\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Video Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_VID_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\tps_idx = ctx->vvc_state->last_parsed_sps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_SEQ_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_PIC_PARAM:\n\t\tps_idx = ctx->vvc_state->last_parsed_pps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Picture Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_PIC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_DEC_PARAM:\n\t\tps_idx = 0;\n\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_DEC_PARAM, ps_idx, temporal_id, layer_id);\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_OPI:\n\t\tps_idx = 0;\n\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_OPI, ps_idx, temporal_id, layer_id);\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t//for now we keep APS in the stream\n#if 0\n\t\tps_idx = ctx->vvc_state->last_parsed_aps_id;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Decoder Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_VVC_NALU_APS_PREFIX, ps_idx, temporal_id, layer_id);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n#else\n\t\t//same logic as SEI\n\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t*skip_nal = GF_TRUE;\n#endif\n\t\tbreak;\n\tcase GF_VVC_NALU_SEI_PREFIX:\n\t\tgf_vvc_parse_sei(data, size, ctx->vvc_state);\n\t\tif (!ctx->nosei) {\n\t\t\tctx->nb_sei++;\n\n\t\t\tnaludmx_push_prefix(ctx, data, size, GF_FALSE);\n\t\t} else {\n\t\t\tctx->nb_nalus--;\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\tcase GF_VVC_NALU_SEI_SUFFIX:\n\t\tif (! ctx->is_playing) return 0;\n\t\tgf_vvc_parse_sei(data, size, ctx->vvc_state);\n\t\tif (ctx->nosei) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t\tctx->nb_nalus--;\n\t\t} else {\n\t\t\tctx->nb_sei++;\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_PIC_HEADER:\n\t\tif (! ctx->is_playing) return 0;\n\t\tbreak;\n\n\t/*slice_segment_layer_rbsp*/\n\tcase GF_VVC_NALU_SLICE_TRAIL:\n\tcase GF_VVC_NALU_SLICE_STSA:\n\tcase GF_VVC_NALU_SLICE_RADL:\n\tcase GF_VVC_NALU_SLICE_RASL:\n\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\tcase GF_VVC_NALU_SLICE_CRA:\n\tcase GF_VVC_NALU_SLICE_GDR:\n\t\tif (! ctx->is_playing) return 0;\n\t\t*is_slice = GF_TRUE;\n\t\tctx->last_layer_id = layer_id;\n\t\tctx->last_temporal_id = temporal_id;\n\t\tif (! *skip_nal) {\n\t\t\tswitch (ctx->vvc_state->s_info.slice_type) {\n\t\t\tcase GF_VVC_SLICE_TYPE_P:\n\t\t\t\tif (layer_id) ctx->nb_e_p++;\n\t\t\t\telse ctx->nb_p++;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_I:\n\t\t\t\tif (layer_id) ctx->nb_e_i++;\n\t\t\t\telse ctx->nb_i++;\n\t\t\t\t*is_islice = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_B:\n\t\t\t\tif (layer_id) ctx->nb_e_b++;\n\t\t\t\telse ctx->nb_b++;\n\t\t\t\tbreak;\n\t\t\tcase GF_VVC_SLICE_TYPE_UNKNOWN:\n\t\t\t\tctx->vvc_no_stats = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_VVC_NALU_ACCESS_UNIT:\n\t\tctx->nb_aud++;\n\t\t//no skip AUD in VVC\n\n\t\tif (!ctx->opid) {\n\t\t\tctx->has_initial_aud = GF_TRUE;\n\t\t\tmemcpy(ctx->init_aud, data, 3);\n\t\t}\n\t\tbreak;\n\t/*remove*/\n\tcase GF_VVC_NALU_FILLER_DATA:\n\tcase GF_VVC_NALU_END_OF_SEQ:\n\tcase GF_VVC_NALU_END_OF_STREAM:\n\t\t*skip_nal = GF_TRUE;\n\t\tbreak;\n\n\tdefault:\n\t\tif (! ctx->is_playing) return 0;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] NAL Unit type %d not handled - adding\\n\", ctx->log_name, nal_unit_type));\n\t\tbreak;\n\t}\n\tif (*skip_nal) return res;\n\n\tctx->linf[layer_id].layer_id_plus_one = layer_id + 1;\n\tif (! ctx->linf[layer_id].max_temporal_id ) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].max_temporal_id < temporal_id) ctx->linf[layer_id].max_temporal_id = temporal_id;\n\n\tif (! ctx->linf[layer_id].min_temporal_id ) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\telse if (ctx->linf[layer_id].min_temporal_id > temporal_id) ctx->linf[layer_id].min_temporal_id = temporal_id;\n\n\tif (ctx->max_temporal_id[layer_id] < temporal_id)\n\t\tctx->max_temporal_id[layer_id] = temporal_id;\n\tif (ctx->min_layer_id > layer_id) ctx->min_layer_id = layer_id;\n\treturn res;\n}\n\nstatic s32 naludmx_parse_nal_avc(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 nal_type, Bool *skip_nal, Bool *is_slice, Bool *is_islice)\n{\n\ts32 ps_idx = 0;\n\ts32 res = 0;\n\n\tif (!size) return -1;\n\tgf_bs_reassign_buffer(ctx->bs_r, data, size);\n\t*skip_nal = GF_FALSE;\n\tres = gf_avc_parse_nalu(ctx->bs_r, ctx->avc_state);\n\tif (res < 0) {\n\t\tif (res == -1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL unit type %u\\n\", ctx->log_name, nal_type));\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t}\n\tctx->nb_nalus++;\n\n\tswitch (nal_type) {\n\tcase GF_AVC_NALU_SVC_SUBSEQ_PARAM:\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tps_idx = ctx->avc_state->last_ps_idx;\n\t\tif (ps_idx<0) {\n\t\t\tif (ctx->avc_state->sps[0].profile_idc) {\n\t\t\t\tGF_LOG(ctx->avc_state->sps[0].profile_idc ? GF_LOG_WARNING : GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set\\n\", ctx->log_name));\n\t\t\t}\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM, ps_idx, 0, 0);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tps_idx = ctx->avc_state->last_ps_idx;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Picture Param Set\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_PIC_PARAM, ps_idx, 0, 0);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\tps_idx = ctx->avc_state->last_ps_idx;\n\t\tif (ps_idx<0) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing Sequence Param Set Extension\\n\", ctx->log_name));\n\t\t} else {\n\t\t\tnaludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM_EXT, ps_idx, 0, 0);\n\t\t}\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_SEI:\n\t\tif (ctx->avc_state->sps_active_idx != -1) {\n\t\t\tnaludmx_push_prefix(ctx, data, size, GF_TRUE);\n\n\t\t\t*skip_nal = GF_TRUE;\n\n\t\t\tif (ctx->nosei) {\n\t\t\t\tctx->sei_buffer_size = 0;\n\t\t\t} else {\n\t\t\t\tctx->nb_sei++;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase GF_AVC_NALU_ACCESS_UNIT:\n\t\tctx->nb_aud++;\n\t\tif (!ctx->audelim) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else if (!ctx->opid) {\n\t\t\tctx->has_initial_aud = GF_TRUE;\n\t\t\tmemcpy(ctx->init_aud, data, 2);\n\t\t}\n\t\treturn 1;\n\t/*remove*/\n\tcase GF_AVC_NALU_FILLER_DATA:\n\tcase GF_AVC_NALU_END_OF_SEQ:\n\tcase GF_AVC_NALU_END_OF_STREAM:\n\t\t*skip_nal = GF_TRUE;\n\t\treturn 0;\n\n\t//update stats\n\tcase GF_AVC_NALU_NON_IDR_SLICE:\n\tcase GF_AVC_NALU_DP_A_SLICE:\n\tcase GF_AVC_NALU_DP_B_SLICE:\n\tcase GF_AVC_NALU_DP_C_SLICE:\n\tcase GF_AVC_NALU_IDR_SLICE:\n\t\t*is_slice = GF_TRUE;\n\t\tswitch (ctx->avc_state->s_info.slice_type) {\n\t\tcase GF_AVC_TYPE_P:\n\t\tcase GF_AVC_TYPE2_P:\n\t\t\tctx->nb_p++;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_I:\n\t\tcase GF_AVC_TYPE2_I:\n\t\t\tctx->nb_i++;\n\t\t\t*is_islice = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_B:\n\t\tcase GF_AVC_TYPE2_B:\n\t\t\tctx->nb_b++;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_SP:\n\t\tcase GF_AVC_TYPE2_SP:\n\t\t\tctx->nb_sp++;\n\t\t\tbreak;\n\t\tcase GF_AVC_TYPE_SI:\n\t\tcase GF_AVC_TYPE2_SI:\n\t\t\tctx->nb_si++;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase GF_AVC_NALU_SVC_SLICE:\n\t\tif (!ctx->explicit) {\n\t\t\tu32 i;\n\t\t\tfor (i = 0; i < gf_list_count(ctx->pps); i ++) {\n\t\t\t\tGF_NALUFFParam *slc = (GF_NALUFFParam*)gf_list_get(ctx->pps, i);\n\t\t\t\tif (ctx->avc_state->s_info.pps && ctx->avc_state->s_info.pps->id == slc->id) {\n\t\t\t\t\t/* This PPS is used by an SVC NAL unit, it should be moved to the SVC Config Record) */\n\t\t\t\t\tgf_list_rem(ctx->pps, i);\n\t\t\t\t\ti--;\n\t\t\t\t\tif (!ctx->pps_svc) ctx->pps_svc = gf_list_new();\n\t\t\t\t\tgf_list_add(ctx->pps_svc, slc);\n\t\t\t\t\tctx->ps_modified = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*is_slice = GF_TRUE;\n\t\t//we disable temporal scalability when parsing mvc - never used and many encoders screw up POC in enhancemen\n\t\tif (ctx->is_mvc && (res>=0)) {\n\t\t\tres=0;\n\t\t\tctx->avc_state->s_info.poc = ctx->last_poc;\n\t\t}\n        if (ctx->avc_state->s_info.sps) {\n            switch (ctx->avc_state->s_info.slice_type) {\n            case GF_AVC_TYPE_P:\n            case GF_AVC_TYPE2_P:\n                ctx->avc_state->s_info.sps->nb_ep++;\n                break;\n            case GF_AVC_TYPE_I:\n            case GF_AVC_TYPE2_I:\n                ctx->avc_state->s_info.sps->nb_ei++;\n                break;\n            case GF_AVC_TYPE_B:\n            case GF_AVC_TYPE2_B:\n                ctx->avc_state->s_info.sps->nb_eb++;\n                break;\n            }\n        }\n        break;\n\tcase GF_AVC_NALU_SLICE_AUX:\n\t\t*is_slice = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_AVC_NALU_DV_RPU:\n\t\tif (ctx->dv_mode==DVMODE_CLEAN) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_rpu ++;\n\t\t\tif (ctx->nb_dv_rpu==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\tcase GF_AVC_NALU_DV_EL:\n\t\tif ((ctx->dv_mode==DVMODE_CLEAN) || (ctx->dv_mode==DVMODE_SINGLE)) {\n\t\t\t*skip_nal = GF_TRUE;\n\t\t} else {\n\t\t\tctx->nb_dv_el ++;\n\t\t\tif (ctx->nb_dv_el==1)\n\t\t\t\tnaludmx_set_dolby_vision(ctx);\n\t\t}\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nstatic void naldmx_switch_timestamps(GF_NALUDmxCtx *ctx, GF_FilterPacket *pck)\n{\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->notime) {\n\t\tBool cts_swap=GF_FALSE;\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tctx->prev_cts = ctx->cts;\n\t\t\tctx->cts = ts;\n\t\t\tcts_swap=GF_TRUE;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (ctx->full_au_source) {\n\t\t\t\tctx->prev_dts = ctx->dts;\n\t\t\t\tctx->dts = ts;\n\t\t\t} else {\n\t\t\t\tGF_FilterClockType ck_type = gf_filter_pid_get_clock_info(ctx->ipid, NULL, NULL);\n\t\t\t\tif (ck_type==GF_FILTER_CLOCK_PCR_DISC)\n\t\t\t\t\tctx->dts = ts;\n\t\t\t\telse if (ctx->dts<ts)\n\t\t\t\t\tctx->dts=ts;\n\n\t\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\t\tu64 diff = ts;\n\t\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\t\tif (!ctx->cur_fps.den) {\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\t\t//we initialized wiith 3000, patch back\n\t\t\t\t\t\tif (ctx->dts && (ctx->dts!=ts)) {\n\t\t\t\t\t\t\tctx->dts -= 3000;\n\t\t\t\t\t\t\tctx->dts += diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx->prev_cts && cts_swap) {\n\t\t\t\t\t\t\tctx->prev_cts -= 3000;\n\t\t\t\t\t\t\tctx->prev_cts += diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ctx->cur_fps.den > diff)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\n\t\t\t\t\tctx->prev_dts = ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->pck_duration = gf_filter_pck_get_duration(pck);\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t//store framing flags. If input_is_au_start, the first NAL of the first frame beginning in this packet will\n\t\t//use the DTS/CTS of the input packet, otherwise we will use our internal POC recompute\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, NULL);\n\t}\n}\n\nstatic void naldmx_check_timestamp_switch(GF_NALUDmxCtx *ctx, u32 *nalu_store_before, u32 bytes_drop, Bool *drop_packet, GF_FilterPacket *pck)\n{\n\tif (*nalu_store_before) {\n\t\tif (*nalu_store_before > bytes_drop) {\n\t\t\t*nalu_store_before -= bytes_drop;\n\t\t} else {\n\t\t\t//all data from previous frame consumed, update timestamps with info from current packet\n\t\t\t*nalu_store_before = 0;\n\t\t\tnaldmx_switch_timestamps(ctx, pck);\n\t\t\tif (*drop_packet) {\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t*drop_packet = GF_FALSE;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void naldmx_bs_log(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3)\n{\n\tGF_NALUDmxCtx *ctx = (GF_NALUDmxCtx *) udta;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\" %s\", field_name));\n\tif (idx1>=0) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"_%d\", idx1));\n\t\tif (idx2>=0) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"_%d\", idx2));\n\t\t\tif (idx3>=0) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"_%d\", idx3));\n\t\t\t}\n\t\t}\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"=\\\"\"LLD, field_val));\n\tif ((ctx->bsdbg==2) && ((s32) nb_bits > 1) )\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"(%u)\", nb_bits));\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"\\\" \"));\n}\n\n\nGF_Err naludmx_process(GF_Filter *filter)\n{\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu8 *start;\n\tu32 nalu_before, nalu_store_before;\n\ts32 remain;\n\tBool is_eos, drop_packet;\n\tu64 byte_offset;\n\nrestart:\n\n\tnalu_store_before = 0;\n\tis_eos = GF_FALSE;\n\tdrop_packet = GF_FALSE;\n\tbyte_offset = GF_FILTER_NO_BO;\n\tnalu_before = ctx->nb_nalus;\n\n\t//always reparse duration\n\tif (!ctx->file_loaded)\n\t\tnaludmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!ctx->resume_from && !pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (ctx->nal_store_size) {\n\t\t\t\tif (!ctx->is_playing)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tstart = ctx->nal_store;\n\t\t\t\tremain = ctx->nal_store_size;\n\t\t\t\tis_eos = GF_TRUE;\n\t\t\t\tgoto naldmx_flush;\n\t\t\t}\n\t\t\tif (ctx->first_pck_in_au) {\n\t\t\t\tnaludmx_finalize_au_flags(ctx);\n\t\t\t}\n\t\t\t//single-frame stream\n\t\t\tif (!ctx->poc_diff) ctx->poc_diff = 1;\n\t\t\tctx->strict_poc = STRICT_POC_OFF;\n\t\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\tif (!ctx->opid) return GF_EOS;\n\n\t\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_MAX_NALU_SIZE, &PROP_UINT(ctx->max_nalu_size) );\n\t\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\t\tnaludmx_set_hevc_oinf(ctx, ctx->max_temporal_id);\n\t\t\t\tnaludmx_set_hevc_linf(ctx);\n\t\t\t\tgf_filter_pid_set_info_str(ctx->opid, \"hevc:min_lid\", &PROP_UINT(ctx->min_layer_id) );\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\n\t\t\tif ((ctx->valid_ps_flags & 0x03) != 0x03) {\n\t\t\t\tctx->nb_nalus = 0;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tif (ctx->nb_nalus && !(ctx->nb_i|ctx->nb_p|ctx->nb_b|ctx->nb_idr|ctx->nb_si|ctx->nb_sp|ctx->nb_cra)) {\n\t\t\t\tctx->nb_nalus = 0;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing && ctx->opid)\n\t\treturn GF_OK;\n\n\t//if we have bytes from previous packet in the header, we cannot switch timing until we know what these bytes are\n\tif (!ctx->nal_store_size)\n\t\tnaldmx_switch_timestamps(ctx, pck);\n\n\tnalu_store_before = ctx->nal_store_size;\n\tif (!ctx->resume_from && pck) {\n\t\tu32 pck_size;\n\t\tconst u8 *data = gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (ctx->nal_store_alloc < ctx->nal_store_size + pck_size) {\n\t\t\tctx->nal_store_alloc = ctx->nal_store_size + pck_size;\n\t\t\tctx->nal_store = gf_realloc(ctx->nal_store, sizeof(char)*ctx->nal_store_alloc);\n\t\t\tif (!ctx->nal_store) {\n\t\t\t\tctx->nal_store_alloc = 0;\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\tif (byte_offset != GF_FILTER_NO_BO)\n\t\t\tbyte_offset -= ctx->nal_store_size;\n\t\tmemcpy(ctx->nal_store + ctx->nal_store_size, data, sizeof(char)*pck_size);\n\t\tctx->nal_store_size += pck_size;\n\t\tdrop_packet = GF_TRUE;\n\t}\n\tstart = ctx->nal_store;\n\tremain = ctx->nal_store_size;\n\n\tif (ctx->resume_from) {\n\t\tif (ctx->opid && gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\tassert(ctx->resume_from < ctx->nal_store_size);\n\t\tstart += ctx->resume_from;\n\t\tremain -= ctx->resume_from;\n\t\tctx->resume_from = 0;\n\n\t\tif (!pck && gf_filter_pid_is_eos(ctx->ipid))\n\t\t\tis_eos = GF_TRUE;\n\t}\n\nnaldmx_flush:\n\tif (!ctx->bs_r) {\n\t\tctx->bs_r = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\n#ifndef GPAC_DISABLE_LOG\n\t\tif (ctx->bsdbg && gf_log_tool_level_on(GF_LOG_MEDIA, GF_LOG_DEBUG))\n\t\t\tgf_bs_set_logger(ctx->bs_r, naldmx_bs_log, ctx);\n#endif\n\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs_r, start, remain);\n\t}\n\n    assert(remain>=0);\n\n\twhile (remain) {\n\t\tu8 *pck_data;\n\t\tu8 *nal_data;\n\t\tu32 nal_size;\n\t\ts32 current;\n\t\tBool skip_nal = GF_FALSE;\n\t\tu32 sc_size=0;\n\t\tu32 nal_type = 0;\n\t\tu32 nal_ref_idc = 0;\n\t\ts32 next=0;\n\t\tu32 next_sc_size=0;\n\t\ts32 nal_parse_result;\n\t\tBool slice_is_idr, slice_force_ref;\n\t\tBool is_slice = GF_FALSE;\n\t\tBool is_islice = GF_FALSE;\n\t\tBool bottom_field_flag = GF_FALSE;\n\t\tBool au_start;\n\t\tu32 avc_svc_subs_reserved = 0;\n\t\tu8 avc_svc_subs_priority = 0;\n\t\tBool recovery_point_valid = GF_FALSE;\n\t\tu32 recovery_point_frame_cnt = 0;\n\t\tBool bIntraSlice = GF_FALSE;\n\t\tGF_FilterSAPType au_sap_type = GF_FILTER_SAP_NONE;\n\t\tBool slice_is_b = GF_FALSE;\n\t\tBool check_dep = GF_FALSE;\n\t\tBool force_au_flush = GF_FALSE;\n\t\ts32 slice_poc = 0;\n\n\t\t//not enough bytes to parse start code + nal hdr\n\t\tif (!is_eos && (remain<6)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//locate next start code\n\t\tcurrent = gf_media_nalu_next_start_code(start, remain, &sc_size);\n\t\tif (current == remain)\n\t\t\tcurrent = -1;\n\n\t\t//no start code, gontinue gathering data\n\t\tif (current<0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//unknown data before start of nal, may happen when tuning in, discard\n\t\tif (current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t\tnaldmx_check_timestamp_switch(ctx, &nalu_store_before, current, &drop_packet, pck);\n\t\t}\n\n\t\tif (!remain)\n\t\t\tbreak;\n\n\t\t//not enough bytes to parse start code + nal hdr\n\t\tif (!is_eos && (remain<6)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tnal_data = start + sc_size;\n\t\tnal_size = remain - sc_size;\n\n\t\t//figure out which nal we need to completely load\n\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\tif (is_eos && (nal_size<2)) break;\n\t\t\tnal_type = nal_data[0];\n\t\t\tnal_type = (nal_type & 0x7E) >> 1;\n\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tforce_au_flush = GF_TRUE;\n\t\t\tcase GF_HEVC_NALU_SEI_PREFIX:\n\t\t\tcase GF_HEVC_NALU_SEI_SUFFIX:\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SLICE_TRAIL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_TSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_STSA_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RADL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RASL_N:\n\t\t\tcase GF_HEVC_NALU_SLICE_RSV_VCL_N10:\n\t\t\tcase GF_HEVC_NALU_SLICE_RSV_VCL_N12:\n\t\t\tcase GF_HEVC_NALU_SLICE_RSV_VCL_N14:\n\t\t\t\tcheck_dep = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (nal_type<GF_HEVC_NALU_VID_PARAM)\n\t\t\t\t\tnal_ref_idc = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//check if VPS/SPS/PPS lid/tid are greater than last seen VCL. If not, force a picture flush\n\t\t\t//not doing so could lead in dispatching the config changed before the current AU is sent\n\t\t\tif (force_au_flush) {\n\t\t\t\tif (!ctx->first_pck_in_au) {\n\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t} else {\n\t\t\t\t\tu8 layer_id = nal_data[0] & 1;\n\t\t\t\t\tlayer_id<<=5;\n\t\t\t\t\tlayer_id |= (nal_data[1] & 0xF8) >> 3;\n\t\t\t\t\tu8 temporal_id = nal_data[2] & 0x7;\n\t\t\t\t\tif (ctx->last_layer_id < layer_id)\n\t\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t\telse if (ctx->last_layer_id == layer_id) {\n\t\t\t\t\t\tif (ctx->last_temporal_id < temporal_id)\n\t\t\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\tif (is_eos && (nal_size<2)) break;\n\t\t\tnal_type = nal_data[1]>>3;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_VVC_NALU_OPI:\n\t\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\t\tforce_au_flush = GF_TRUE;\n\t\t\tcase GF_VVC_NALU_SEI_PREFIX:\n\t\t\tcase GF_VVC_NALU_SEI_SUFFIX:\n\t\t\tcase GF_VVC_NALU_APS_PREFIX:\n\t\t\tcase GF_VVC_NALU_APS_SUFFIX:\n\t\t\tcase GF_VVC_NALU_PIC_HEADER:\n\t\t\t\tbreak;\n\n\t\t\tcase GF_VVC_NALU_SLICE_TRAIL:\n\t\t\tcase GF_VVC_NALU_SLICE_STSA:\n\t\t\tcase GF_VVC_NALU_SLICE_RADL:\n\t\t\tcase GF_VVC_NALU_SLICE_RASL:\n\t\t\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\t\t\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\t\tcase GF_VVC_NALU_SLICE_CRA:\n\t\t\tcase GF_VVC_NALU_SLICE_GDR:\n\t\t\t\tif (ctx->deps) {\n\t\t\t\t\tcheck_dep = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (nal_type<GF_HEVC_NALU_VID_PARAM)\n\t\t\t\t\tnal_ref_idc = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//check if VPS/SPS/PPS/OPI/DEC lid/tid are greater than last seen VCL. If not, force a picture flush\n\t\t\t//not doing so could lead in dispatching the config changed before the current AU is sent\n\t\t\tif (force_au_flush) {\n\t\t\t\tif (!ctx->first_pck_in_au) {\n\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t} else {\n\t\t\t\t\tu8 layer_id = nal_data[0] & 0x3f;\n\t\t\t\t\tu8 temporal_id = (nal_data[1] & 0x7);\n\t\t\t\t\tif (ctx->last_layer_id < layer_id)\n\t\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t\telse if (ctx->last_layer_id == layer_id) {\n\t\t\t\t\t\tif (ctx->last_temporal_id < temporal_id)\n\t\t\t\t\t\t\tforce_au_flush = GF_FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (is_eos && (nal_size<1)) break;\n\t\t\tnal_type = nal_data[0] & 0x1F;\n\t\t\tnal_ref_idc = (nal_data[0] & 0x60) >> 5;\n\t\t}\n\n\t\t//locate next NAL start\n\t\tnext = gf_media_nalu_next_start_code(nal_data, nal_size, &next_sc_size);\n\t\tif (!is_eos && (next == nal_size) && !ctx->full_au_source) {\n\t\t\tnext = -1;\n\t\t}\n\n\t\t//next nal start not found, wait\n\t\tif (next<0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//this is our exact NAL size, without start code\n\t\tnal_size = next;\n\n\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\tnal_parse_result = naludmx_parse_nal_hevc(ctx, nal_data, nal_size, &skip_nal, &is_slice, &is_islice);\n\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\tnal_parse_result = naludmx_parse_nal_vvc(ctx, nal_data, nal_size, &skip_nal, &is_slice, &is_islice);\n\t\t} else {\n\t\t\tnal_parse_result = naludmx_parse_nal_avc(ctx, nal_data, nal_size, nal_type, &skip_nal, &is_slice, &is_islice);\n\t\t}\n\n\t\t//dispatch right away if analyze\n\t\tif (ctx->analyze) {\n\t\t\tskip_nal = GF_FALSE;\n\t\t\tctx->sei_buffer_size = 0;\n\t\t}\n\n\t\t//new frame - if no slices, we detected the new frame on AU delimiter, don't flush new frame !\n\t\tif ((nal_parse_result>0) && ctx->nb_slices_in_au) {\n\t\t\tnaludmx_end_access_unit(ctx);\n\t\t}\n\n\t\tnaludmx_check_pid(filter, ctx, force_au_flush);\n\t\tif (!ctx->opid) skip_nal = GF_TRUE;\n\n\t\tif (skip_nal) {\n\t\t\tnal_size += sc_size;\n\t\t\tassert((u32) remain >= nal_size);\n\t\t\tstart += nal_size;\n\t\t\tremain -= nal_size;\n\t\t\tnaldmx_check_timestamp_switch(ctx, &nalu_store_before, nal_size, &drop_packet, pck);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) (start - ctx->nal_store);\n            assert(ctx->resume_from<=ctx->nal_store_size);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[%s] not yet playing\\n\", ctx->log_name));\n\n\t\t\tif (drop_packet)\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tif (ctx->seek_gdr_count)\n\t\t\t\t\tctx->seek_gdr_count--;\n\t\t\t\telse\n\t\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (nal_parse_result<0) {\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tu64 bo = byte_offset;\n\t\t\t\tbo += (start - ctx->nal_store);\n\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL Unit %d (byte offset \"LLU\" size %d type %d frame %d last POC %d) - skipping\\n\", ctx->log_name, ctx->nb_nalus, bo, nal_size, nal_type, ctx->nb_frames, ctx->last_poc));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] Error parsing NAL Unit %d (size %d type %d frame %d last POC %d) - skipping\\n\", ctx->log_name, ctx->nb_nalus, nal_size, nal_type, ctx->nb_frames, ctx->last_poc));\n\t\t\t}\n\t\t\tnal_size += sc_size;\n\t\t\tassert((u32) remain >= nal_size);\n\t\t\tstart += nal_size;\n\t\t\tremain -= nal_size;\n\t\t\tnaldmx_check_timestamp_switch(ctx, &nalu_store_before, nal_size, &drop_packet, pck);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (check_dep) {\n\t\t\tif ((ctx->codecid==GF_CODECID_HEVC) && ctx->hevc_state->s_info.sps) {\n\t\t\t\tHEVC_VPS *vps;\n\t\t\t\tu32 temporal_id = nal_data[1] & 0x7;\n\t\t\t\tvps = & ctx->hevc_state->vps[ctx->hevc_state->s_info.sps->vps_id];\n\t\t\t\tif (temporal_id + 1 < vps->max_sub_layers) {\n\t\t\t\t\tnal_ref_idc = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\t\tif (ctx->vvc_state->s_info.non_ref_pic) {\n\t\t\t\t\tnal_ref_idc = GF_FALSE;\n\t\t\t\t} else {\n\t\t\t\t\t//todo\n\t\t\t\t\tnal_ref_idc = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (is_islice) ctx->has_islice = GF_TRUE;\n\n\t\t//store all variables needed to compute POC/CTS and sample SAP and recovery info\n\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\tslice_is_idr = gf_hevc_slice_is_IDR(ctx->hevc_state);\n\n\t\t\trecovery_point_valid = ctx->hevc_state->sei.recovery_point.valid;\n\t\t\trecovery_point_frame_cnt = ctx->hevc_state->sei.recovery_point.frame_cnt;\n\t\t\tbIntraSlice = gf_hevc_slice_is_intra(ctx->hevc_state);\n\n\t\t\tau_sap_type = GF_FILTER_SAP_NONE;\n\t\t\tif (gf_hevc_slice_is_IDR(ctx->hevc_state)) {\n\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\tswitch (ctx->hevc_state->s_info.nal_unit_type) {\n\t\t\t\tcase GF_HEVC_NALU_SLICE_IDR_W_DLP:\n\t\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_DLP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswitch (ctx->hevc_state->s_info.nal_unit_type) {\n\t\t\t\tcase GF_HEVC_NALU_SLICE_BLA_W_LP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_HEVC_NALU_SLICE_BLA_N_LP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_HEVC_NALU_SLICE_CRA:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tslice_poc = ctx->hevc_state->s_info.poc;\n\n\t\t\t/*need to store TS offsets*/\n\t\t\tswitch (ctx->hevc_state->s_info.slice_type) {\n\t\t\tcase GF_AVC_TYPE_B:\n\t\t\tcase GF_AVC_TYPE2_B:\n\t\t\t\tslice_is_b = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\tslice_is_idr = gf_vvc_slice_is_ref(ctx->vvc_state);\n\t\t\trecovery_point_valid = ctx->vvc_state->s_info.recovery_point_valid;\n\t\t\trecovery_point_frame_cnt = ctx->vvc_state->s_info.gdr_recovery_count;\n\n//\t\t\tcommented, set below\n//\t\t\tif (ctx->vvc_state->s_info.irap_or_gdr_pic && !ctx->vvc_state->s_info.gdr_pic)\n//\t\t\t\tbIntraSlice = GF_TRUE; //gf_hevc_slice_is_intra(ctx->hevc_state);\n\n\t\t\tau_sap_type = GF_FILTER_SAP_NONE;\n\t\t\tif (ctx->vvc_state->s_info.irap_or_gdr_pic && !ctx->vvc_state->s_info.gdr_pic) {\n\t\t\t\tbIntraSlice = GF_TRUE;\n\n\t\t\t\tswitch (ctx->vvc_state->s_info.nal_unit_type) {\n\t\t\t\tcase GF_VVC_NALU_SLICE_CRA:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\tslice_is_idr = GF_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_2;\n\t\t\t\t\tslice_is_idr = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (ctx->vvc_state->s_info.nal_unit_type) {\n\t\t\t\tcase GF_VVC_NALU_SLICE_IDR_N_LP:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\tslice_is_idr = GF_TRUE;\n\t\t\t\t\tbIntraSlice = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_VVC_NALU_SLICE_CRA:\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\tbIntraSlice = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_VVC_NALU_SLICE_IDR_W_RADL:\n\t\t\t\t\tbIntraSlice = GF_TRUE;\n\t\t\t\t\tif (ctx->vvc_state->s_info.gdr_pic) {\n\t\t\t\t\t\tau_sap_type = GF_FILTER_SAP_3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\t\tslice_is_idr = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tslice_poc = ctx->vvc_state->s_info.poc;\n\n\t\t\t/*need to store TS offsets*/\n\t\t\tswitch (ctx->vvc_state->s_info.slice_type) {\n\t\t\tcase GF_AVC_TYPE_B:\n\t\t\tcase GF_AVC_TYPE2_B:\n\t\t\t\tslice_is_b = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\n\t\t\t/*fixme - we need finer grain for priority*/\n\t\t\tif ((nal_type==GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE)) {\n\t\t\t\tif (!ctx->is_mvc) {\n\t\t\t\t\tunsigned char *p = (unsigned char *) start;\n\t\t\t\t\t// RefPicFlag\n\t\t\t\t\tavc_svc_subs_reserved |= (p[0] & 0x60) ? 0x80000000 : 0;\n\t\t\t\t\t// RedPicFlag TODO: not supported, would require to parse NAL unit payload\n\t\t\t\t\tavc_svc_subs_reserved |= (0) ? 0x40000000 : 0;\n\t\t\t\t\t// VclNALUnitFlag\n\t\t\t\t\tavc_svc_subs_reserved |= (1<=nal_type && nal_type<=5) || (nal_type==GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE) ? 0x20000000 : 0;\n\t\t\t\t\t// use values of IdrFlag and PriorityId directly from SVC extension header\n\t\t\t\t\tavc_svc_subs_reserved |= p[1] << 16;\n\t\t\t\t\t// use values of DependencyId and QualityId directly from SVC extension header\n\t\t\t\t\tavc_svc_subs_reserved |= p[2] << 8;\n\t\t\t\t\t// use values of TemporalId and UseRefBasePicFlag directly from SVC extension header\n\t\t\t\t\tavc_svc_subs_reserved |= p[3] & 0xFC;\n\t\t\t\t\t// StoreBaseRepFlag TODO: SVC FF mentions a store_base_rep_flag which cannot be found in SVC spec\n\t\t\t\t\tavc_svc_subs_reserved |= (0) ? 0x00000002 : 0;\n\n\t\t\t\t\t// priority_id (6 bits) in SVC has inverse meaning -> lower value means higher priority - invert it and scale it to 8 bits\n\t\t\t\t\tavc_svc_subs_priority = (63 - (p[1] & 0x3F)) << 2;\n\t\t\t\t}\n\t\t\t\tif (nal_type==GF_AVC_NALU_SVC_PREFIX_NALU) {\n                    if (ctx->svc_prefix_buffer_size) {\n                        GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] broken bitstream, two consecutive SVC prefix NALU without SVC slice in-between\\n\", ctx->log_name));\n                        ctx->svc_prefix_buffer_size = 0;\n                    }\n\n\t\t\t\t\t/* remember reserved and priority value */\n\t\t\t\t\tctx->svc_nalu_prefix_reserved = avc_svc_subs_reserved;\n\t\t\t\t\tctx->svc_nalu_prefix_priority = avc_svc_subs_priority;\n\n\t\t\t\t\tctx->svc_prefix_buffer_size = nal_size;\n\t\t\t\t\tif (ctx->svc_prefix_buffer_size > ctx->svc_prefix_buffer_alloc) {\n\t\t\t\t\t\tctx->svc_prefix_buffer_alloc = ctx->svc_prefix_buffer_size;\n\t\t\t\t\t\tctx->svc_prefix_buffer = gf_realloc(ctx->svc_prefix_buffer, ctx->svc_prefix_buffer_size);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(ctx->svc_prefix_buffer, start+sc_size, ctx->svc_prefix_buffer_size);\n\n\t\t\t\t\tassert( (u32) remain >= sc_size + nal_size);\n\t\t\t\t\tstart += sc_size + nal_size;\n\t\t\t\t\tremain -= sc_size + nal_size;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (is_slice) {\n\t\t\t\t// RefPicFlag\n\t\t\t\tavc_svc_subs_reserved |= (start[0] & 0x60) ? 0x80000000 : 0;\n\t\t\t\t// VclNALUnitFlag\n\t\t\t\tavc_svc_subs_reserved |= (1<=nal_type && nal_type<=5) || (nal_type==GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE) ? 0x20000000 : 0;\n\t\t\t\tavc_svc_subs_priority = 0;\n\t\t\t}\n\n\t\t\tif (is_slice && ctx->avc_state->s_info.field_pic_flag) {\n\t\t\t\tctx->is_paff = GF_TRUE;\n\t\t\t\tbottom_field_flag = ctx->avc_state->s_info.bottom_field_flag;\n\t\t\t}\n\n\t\t\tslice_is_idr = (ctx->avc_state->s_info.nal_unit_type==GF_AVC_NALU_IDR_SLICE) ? GF_TRUE : GF_FALSE;\n\n\t\t\trecovery_point_valid = ctx->avc_state->sei.recovery_point.valid;\n\t\t\trecovery_point_frame_cnt = ctx->avc_state->sei.recovery_point.frame_cnt;\n\t\t\tbIntraSlice = gf_avc_slice_is_intra(ctx->avc_state);\n\n\t\t\tau_sap_type = GF_FILTER_SAP_NONE;\n\t\t\tif (ctx->avc_state->s_info.nal_unit_type == GF_AVC_NALU_IDR_SLICE)\n\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\n\t\t\tslice_poc = ctx->avc_state->s_info.poc;\n\t\t\t/*need to store TS offsets*/\n\t\t\tswitch (ctx->avc_state->s_info.slice_type) {\n\t\t\tcase GF_AVC_TYPE_B:\n\t\t\tcase GF_AVC_TYPE2_B:\n\t\t\t\tslice_is_b = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (is_slice) {\n\t\t\tBool first_in_au = (ctx->nb_slices_in_au==0) ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (slice_is_idr)\n\t\t\t\tctx->nb_idr++;\n\n\t\t\tif (au_sap_type==GF_FILTER_SAP_3)\n\t\t\t\tctx->nb_cra++;\n\n\t\t\tslice_force_ref = GF_FALSE;\n\t\t\tctx->nb_slices_in_au++;\n\n\t\t\t/*we only indicate TRUE IDRs for sync samples (cf AVC file format spec).\n\t\t\tSEI recovery should be used to build sampleToGroup & RollRecovery tables*/\n\t\t\tif (first_in_au) {\n\t\t\t\tif (recovery_point_valid) {\n\t\t\t\t\tctx->sei_recovery_frame_count = recovery_point_frame_cnt;\n\n\t\t\t\t\t/*we allow to mark I-frames as sync on open-GOPs (with sei_recovery_frame_count=0) when forcing sync even when the SEI RP is not available*/\n\t\t\t\t\tif (!recovery_point_frame_cnt && bIntraSlice) {\n\t\t\t\t\t\tctx->has_islice = 1;\n\t\t\t\t\t\tif (ctx->use_opengop_gdr == 1) {\n\t\t\t\t\t\t\tctx->use_opengop_gdr = 2; /*avoid message flooding*/\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] No valid SEI Recovery Point found although needed - forcing\\n\", ctx->log_name));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx->codecid==GF_CODECID_HEVC) {\n\t\t\t\t\t\tctx->hevc_state->sei.recovery_point.valid = 0;\n\t\t\t\t\t} else if (ctx->codecid==GF_CODECID_VVC) {\n\t\t\t\t\t\tctx->vvc_state->s_info.recovery_point_valid = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx->avc_state->sei.recovery_point.valid = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (bIntraSlice && ctx->force_sync && (ctx->sei_recovery_frame_count==0))\n\t\t\t\t\t\tslice_force_ref = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tctx->bottom_field_flag = bottom_field_flag;\n\n\t\t\t\tif (ctx->check_prev_sap2) {\n\t\t\t\t\tif ((ctx->prev_sap2_poc > slice_poc) && ctx->prev_sap && (gf_list_find(ctx->pck_queue, ctx->prev_sap)>=0)) {\n\t\t\t\t\t\tgf_filter_pck_set_sap(ctx->prev_sap, GF_FILTER_SAP_2);\n\t\t\t\t\t}\n\t\t\t\t\tctx->check_prev_sap2 = GF_FALSE;\n\t\t\t\t\tctx->prev_sap = NULL;\n\t\t\t\t}\n\t\t\t\t//move all sap2 to sap1 and check POC of next frame\n\t\t\t\t//we do this because many encoders use IDR+Decodable leading pic NAL types (eg SAP2)\n\t\t\t\t//when encoding for IDR without DLP (eg SAP1)...\n\t\t\t\tif (au_sap_type==GF_FILTER_SAP_2) {\n\t\t\t\t\tau_sap_type = GF_FILTER_SAP_1;\n\t\t\t\t\tctx->check_prev_sap2 = GF_TRUE;\n\t\t\t\t\tctx->prev_sap2_poc = slice_poc;\n\t\t\t\t}\n\n\t\t\t\tctx->au_sap = au_sap_type;\n\t\t\t}\n\n\t\t\tif (slice_poc < ctx->poc_shift) {\n\t\t\t\tu32 i, count = gf_list_count(ctx->pck_queue);\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tu64 dts, cts;\n\t\t\t\t\tGF_FilterPacket *q_pck = gf_list_get(ctx->pck_queue, i);\n\t\t\t\t\tassert(q_pck);\n\t\t\t\t\tdts = gf_filter_pck_get_dts(q_pck);\n\t\t\t\t\tif (dts == GF_FILTER_NO_TS) continue;\n\t\t\t\t\tcts = gf_filter_pck_get_cts(q_pck);\n\t\t\t\t\t//cts may be unset at this point (nal in middle of AU)\n\t\t\t\t\tif (cts == GF_FILTER_NO_TS) continue;\n\t\t\t\t\tcts += ctx->poc_shift;\n\t\t\t\t\tcts -= slice_poc;\n\t\t\t\t\tgf_filter_pck_set_cts(q_pck, cts);\n\t\t\t\t}\n\n\t\t\t\tctx->poc_shift = slice_poc;\n\t\t\t}\n\n\t\t\t/*if #pics, compute smallest POC increase*/\n\t\t\tif (slice_poc != ctx->last_poc) {\n\t\t\t\ts32 pdiff = ABS(ctx->last_poc - slice_poc);\n\n\t\t\t\tif ((slice_poc < 0) && !ctx->last_poc)\n\t\t\t\t\tctx->poc_diff = 0;\n\t\t\t\telse if ((slice_poc < 0) && (-slice_poc < ctx->poc_diff)) {\n\t\t\t\t\tpdiff = -slice_poc;\n\t\t\t\t\tctx->poc_diff = 0;\n\t\t\t\t}\n\n\t\t\t\tif (!ctx->poc_diff || (ctx->poc_diff > (s32) pdiff ) ) {\n\t\t\t\t\tctx->poc_diff = pdiff;\n\t\t\t\t\tctx->poc_probe_done = GF_FALSE;\n\t\t\t\t} else if (first_in_au) {\n\t\t\t\t\t//second frame with the same poc diff, we should be able to properly recompute CTSs\n\t\t\t\t\tctx->poc_probe_done = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tctx->last_poc = slice_poc;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[%s] POC is %d - min poc diff %d - slice is IDR %d (SAP %d)\\n\", ctx->log_name, slice_poc, ctx->poc_diff, slice_is_idr, au_sap_type));\n\n\t\t\t/*ref slice, reset poc*/\n\t\t\tif (slice_is_idr) {\n\t\t\t\tif (first_in_au) {\n\t\t\t\t\tBool temp_poc_diff = GF_FALSE;\n\t\t\t\t\t//two consecutive IDRs, force poc_diff to 1 if 0 (when we have intra-only) to force frame dispatch\n\t\t\t\t\tif (ctx->last_frame_is_idr && !ctx->poc_diff) {\n\t\t\t\t\t\ttemp_poc_diff = GF_TRUE;\n\t\t\t\t\t\tctx->poc_diff = 1;\n\t\t\t\t\t}\n\t\t\t\t\t//new ref frame, dispatch all pending packets\n\t\t\t\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\n\t\t\t\t\t//if IDR with DLP (sap2), only reset poc probing if the poc is below current max poc\n\t\t\t\t\t//otherwise assume no diff in poc\n\t\t\t\t\tif ((au_sap_type == GF_FILTER_SAP_2) && (ctx->max_last_poc >= ctx->last_poc) ){\n\t\t\t\t\t\tctx->au_sap2_poc_reset = GF_TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((au_sap_type == GF_FILTER_SAP_1) || ctx->au_sap2_poc_reset) {\n\t\t\t\t\t\tif (!ctx->au_sap2_poc_reset)\n\t\t\t\t\t\t\tctx->last_poc = 0;\n\n\t\t\t\t\t\tctx->max_last_poc = ctx->last_poc;\n\t\t\t\t\t\tctx->max_last_b_poc = ctx->last_poc;\n\t\t\t\t\t\tctx->poc_shift = 0;\n\t\t\t\t\t\t//force probing of POC diff, this will prevent dispatching frames with wrong CTS until we have a clue of min poc_diff used\n\t\t\t\t\t\tctx->poc_probe_done = 0;\n\t\t\t\t\t}\n\t\t\t\t\tctx->last_frame_is_idr = GF_TRUE;\n\t\t\t\t\tif (temp_poc_diff)\n\t\t\t\t\t\tctx->poc_diff = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*forced ref slice*/\n\t\t\telse if (slice_force_ref) {\n\t\t\t\tctx->last_frame_is_idr = GF_FALSE;\n\t\t\t\tif (first_in_au) {\n\t\t\t\t\t//new ref frame, dispatch all pending packets\n\t\t\t\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\n\t\t\t\t\t/*adjust POC shift as sample will now be marked as sync, so we must store poc as if IDR (eg POC=0) for our CTS offset computing to be correct*/\n\t\t\t\t\tctx->poc_shift = slice_poc;\n\n\t\t\t\t\t//force probing of POC diff, this will prevent dispatching frames with wrong CTS until we have a clue of min poc_diff used\n\t\t\t\t\tctx->poc_probe_done = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*strictly less - this is a new P slice*/\n\t\t\telse if (ctx->max_last_poc < ctx->last_poc) {\n\t\t\t\tctx->max_last_b_poc = 0;\n\t\t\t\tctx->max_last_poc = ctx->last_poc;\n\t\t\t\tctx->last_frame_is_idr = GF_FALSE;\n\t\t\t}\n\t\t\t/*stricly greater*/\n\t\t\telse if (slice_is_b && (ctx->max_last_poc > ctx->last_poc)) {\n\t\t\t\tctx->last_frame_is_idr = GF_FALSE;\n\t\t\t\tif (!ctx->max_last_b_poc) {\n\t\t\t\t\tctx->max_last_b_poc = ctx->last_poc;\n\t\t\t\t}\n\t\t\t\t/*if same poc than last max, this is a B-slice*/\n\t\t\t\telse if (ctx->last_poc > ctx->max_last_b_poc) {\n\t\t\t\t\tctx->max_last_b_poc = ctx->last_poc;\n\t\t\t\t}\n\t\t\t\t/*otherwise we had a B-slice reference: do nothing*/\n\t\t\t} else {\n\t\t\t\tctx->last_frame_is_idr = GF_FALSE;\n\t\t\t}\n\n\n\t\t\tif (ctx->deps) {\n\t\t\t\tif (nal_ref_idc) {\n\t\t\t\t\tctx->has_ref_slices = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif ((ctx->codecid==GF_CODECID_AVC) && (ctx->avc_state->s_info.redundant_pic_cnt) ) {\n\t\t\t\t\tctx->has_redundant = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tau_start = ctx->first_pck_in_au ? GF_FALSE : GF_TRUE;\n\n\t\tif (ctx->has_initial_aud) {\n\t\t\tu32 audelim_size = (ctx->codecid!=GF_CODECID_AVC) ? 3 : 2;\n\t\t\t/*dst_pck = */naludmx_start_nalu(ctx, audelim_size, GF_FALSE, &au_start, &pck_data);\n\t\t\tmemcpy(pck_data + ctx->nal_length , ctx->init_aud, audelim_size);\n\t\t\tctx->has_initial_aud = GF_FALSE;\n\t\t\tif (ctx->subsamples) {\n\t\t\t\tnaludmx_add_subsample(ctx, audelim_size, avc_svc_subs_priority, avc_svc_subs_reserved);\n\t\t\t}\n\t\t}\n\t\tif (ctx->sei_buffer_size) {\n\t\t\t//sei buffer is already nal size prefixed\n\t\t\t/*dst_pck = */naludmx_start_nalu(ctx, ctx->sei_buffer_size, GF_TRUE, &au_start, &pck_data);\n\t\t\tmemcpy(pck_data, ctx->sei_buffer, ctx->sei_buffer_size);\n\t\t\tif (ctx->subsamples) {\n\t\t\t\tnaludmx_add_subsample(ctx, ctx->sei_buffer_size - ctx->nal_length, avc_svc_subs_priority, avc_svc_subs_reserved);\n\t\t\t}\n\t\t\tctx->sei_buffer_size = 0;\n\t\t}\n\n\t\tif (ctx->svc_prefix_buffer_size) {\n\t\t\t/*dst_pck = */naludmx_start_nalu(ctx, ctx->svc_prefix_buffer_size, GF_FALSE, &au_start, &pck_data);\n\t\t\tmemcpy(pck_data + ctx->nal_length, ctx->svc_prefix_buffer, ctx->svc_prefix_buffer_size);\n\t\t\tif (ctx->subsamples) {\n\t\t\t\tnaludmx_add_subsample(ctx, ctx->svc_prefix_buffer_size, ctx->svc_nalu_prefix_priority, ctx->svc_nalu_prefix_reserved);\n\t\t\t}\n\t\t\tctx->svc_prefix_buffer_size = 0;\n\t\t}\n\n\t\t//nalu size field\n\t\t/*dst_pck = */naludmx_start_nalu(ctx, (u32) nal_size, GF_FALSE, &au_start, &pck_data);\n\t\tpck_data += ctx->nal_length;\n\n\t\t//add subsample info before touching the size\n\t\tif (ctx->subsamples) {\n\t\t\tnaludmx_add_subsample(ctx, (u32) nal_size, avc_svc_subs_priority, avc_svc_subs_reserved);\n\t\t}\n\n\n\t\t//bytes only come from the data packet\n\t\tmemcpy(pck_data, nal_data, (size_t) nal_size);\n\n\t\tif ((ctx->nb_slices_in_au==1) && ctx->check_prev_sap2) {\n\t\t\tctx->prev_sap = ctx->first_pck_in_au;\n\t\t}\n\n\n\t\tnal_size += sc_size;\n\t\tstart += nal_size;\n\t\tremain -= nal_size;\n\t\tnaldmx_check_timestamp_switch(ctx, &nalu_store_before, nal_size, &drop_packet, pck);\n\n\t\t//don't demux too much of input, abort when we would block. This avoid dispatching\n\t\t//a huge number of frames in a single call\n\t\tif (remain && gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->resume_from = (u32) (start - ctx->nal_store);\n\t\t\tassert(ctx->resume_from <= ctx->nal_store_size);\n\t\t\tassert(ctx->resume_from == ctx->nal_store_size - remain);\n\t\t\tif (drop_packet)\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (remain) {\n\t\tif (is_eos && (remain == ctx->nal_store_size)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] Incomplete last NAL and eos, discarding\\n\", ctx->log_name));\n\t\t\tremain = 0;\n\t\t} else {\n\t\t\tassert((u32) remain<=ctx->nal_store_size);\n\t\t\tmemmove(ctx->nal_store, start, remain);\n\t\t}\n\t}\n\tctx->nal_store_size = remain;\n\n\tif (drop_packet)\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (is_eos) {\n\t\t//avoid recursive call\n\t\tgoto restart;\n\t}\n\n\tif ((ctx->nb_nalus>nalu_before) && gf_filter_reporting_enabled(filter)) {\n\t\tchar szStatus[1024];\n\n\t\tsprintf(szStatus, \"%s %dx%d % 10d NALU % 8d I % 8d P % 8d B % 8d SEI\", ctx->log_name, ctx->width, ctx->height, ctx->nb_nalus, ctx->nb_i, ctx->nb_p, ctx->nb_b, ctx->nb_sei);\n\t\tgf_filter_update_status(filter, -1, szStatus);\n\t}\n\tif (ctx->full_au_source && ctx->poc_probe_done) {\n\t\tif (ctx->first_pck_in_au)\n\t\t\tnaludmx_finalize_au_flags(ctx);\n\n\t\tnaludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE);\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err naludmx_initialize(GF_Filter *filter)\n{\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->sps = gf_list_new();\n\tctx->pps = gf_list_new();\n\tswitch (ctx->nal_length) {\n\tcase 1:\n\t\tctx->max_nalu_size_allowed = 0xFF;\n\t\tbreak;\n\tcase 2:\n\t\tctx->max_nalu_size_allowed = 0xFFFF;\n\t\tbreak;\n\tcase 4:\n\t\tctx->max_nalu_size_allowed = 0xFFFFFFFF;\n\t\tbreak;\n\tcase 0:\n\t\tctx->max_nalu_size_allowed = 0xFFFFFFFF;\n\t\tctx->nal_length = 4;\n\t\tctx->nal_adjusted = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] NAL size length %d is not allowed, defaulting to 4 bytes\\n\", ctx->log_name));\n\t\tctx->max_nalu_size_allowed = 0xFFFFFFFF;\n\t\tctx->nal_length = 4;\n\t\tbreak;\n\t}\n\n\t//if profile is forced and comapt_id is in auto mode, fail\n\tif (!ctx->dv_compatid) {\n\t\tif (ctx->dv_profile) {\n\t\t\tctx->dv_compatid=1;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[%s] DV profile forced but compatID in auto mode, using no compatibility\\n\", ctx->log_name));\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic void naludmx_del_param_list(GF_List *ps, Bool do_free)\n{\n\tif (!ps) return;\n\twhile (gf_list_count(ps)) {\n\t\tGF_NALUFFParam *sl = gf_list_pop_back(ps);\n\t\tif (sl->data) gf_free(sl->data);\n\t\tgf_free(sl);\n\t}\n\n\tif (do_free)\n\t\tgf_list_del(ps);\n}\n\nstatic void naludmx_log_stats(GF_NALUDmxCtx *ctx)\n{\n\tu32 i, count;\n\tconst char *msg_import;\n\tu32 nb_frames = 0;\n\tif (ctx->cur_fps.den)\n\t\tnb_frames = (u32) (ctx->dts / ctx->cur_fps.den);\n\n\tif (ctx->dur.den && ctx->dur.num) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s duration specified at import time, may have parsed more frames than imported\\n\", ctx->log_name));\n\t\tmsg_import = \"parsed\";\n\t} else {\n\t\tmsg_import = \"Import results:\";\n\t}\n\n\tif (ctx->nb_si || ctx->nb_sp) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s %d frames (%d NALUs) - Slices: %d I %d P %d B %d SP %d SI - %d SEI - %d IDR\\n\", ctx->log_name, msg_import, nb_frames, ctx->nb_nalus, ctx->nb_i, ctx->nb_p, ctx->nb_b, ctx->nb_sp, ctx->nb_si, ctx->nb_sei, ctx->nb_idr ));\n\t} else if (ctx->vvc_no_stats) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s %d samples (%d NALUs) - %d SEI - %d IDR - %d CRA\\n\",\n\t\t\t                  ctx->log_name, msg_import, nb_frames, ctx->nb_nalus, ctx->nb_sei, ctx->nb_idr, ctx->nb_cra));\n\t} else {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s %d samples (%d NALUs) - Slices: %d I %d P %d B - %d SEI - %d IDR - %d CRA\\n\",\n\t\t\t                  ctx->log_name, msg_import, nb_frames, ctx->nb_nalus, ctx->nb_i, ctx->nb_p, ctx->nb_b, ctx->nb_sei, ctx->nb_idr, ctx->nb_cra));\n\t}\n\n\tif (ctx->codecid==GF_CODECID_AVC) {\n\t\tcount = gf_list_count(ctx->sps);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tAVC_SPS *sps;\n\t\t\tGF_NALUFFParam *svcc = (GF_NALUFFParam*)gf_list_get(ctx->sps, i);\n\t\t\tsps = & ctx->avc_state->sps[svcc->id];\n\t\t\tif (sps->nb_ei || sps->nb_ep) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s SVC (SSPS ID %d, %dx%d) %s Slices: %d I %d P %d B\\n\", ctx->log_name, svcc->id - GF_SVC_SSPS_ID_SHIFT, sps->width, sps->height, msg_import, sps->nb_ei, sps->nb_ep, sps->nb_eb ));\n\t\t\t}\n\t\t}\n\t} else if (ctx->nb_e_i || ctx->nb_e_p || ctx->nb_e_b) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s L-HEVC %s Slices: %d I %d P %d B\\n\", ctx->log_name, msg_import, ctx->nb_e_i, ctx->nb_e_p, ctx->nb_e_b ));\n\t}\n\n\tif (ctx->max_total_delay>1) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s Stream uses forward prediction - stream CTS offset: %d frames\\n\", ctx->log_name, ctx->max_total_delay));\n\t}\n\n\tif (!ctx->nal_adjusted) {\n\t\tif ((ctx->max_nalu_size < 0xFF) && (ctx->nal_length>1) ){\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s Max NALU size is %d - stream could be optimized by setting nal_length=1\\n\", ctx->log_name, ctx->max_nalu_size));\n\t\t} else if ((ctx->max_nalu_size < 0xFFFF) && (ctx->nal_length>2) ){\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s Max NALU size is %d - stream could be optimized by setting nal_length=2\\n\", ctx->log_name, ctx->max_nalu_size));\n\t\t}\n\t}\n}\n\nstatic void naludmx_reset_param_sets(GF_NALUDmxCtx *ctx, Bool do_free)\n{\n\tnaludmx_del_param_list(ctx->sps, do_free);\n\tnaludmx_del_param_list(ctx->pps, do_free);\n\tnaludmx_del_param_list(ctx->vps, do_free);\n\tnaludmx_del_param_list(ctx->sps_ext, do_free);\n\tnaludmx_del_param_list(ctx->pps_svc, do_free);\n\tnaludmx_del_param_list(ctx->vvc_aps_pre, do_free);\n\tnaludmx_del_param_list(ctx->vvc_dci, do_free);\n\tnaludmx_del_param_list(ctx->vvc_opi, do_free);\n}\n\nstatic void naludmx_finalize(GF_Filter *filter)\n{\n\tGF_NALUDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (ctx->importer) naludmx_log_stats(ctx);\n\n\tif (ctx->bs_r) gf_bs_del(ctx->bs_r);\n\tif (ctx->bs_w) gf_bs_del(ctx->bs_w);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->nal_store) gf_free(ctx->nal_store);\n\tif (ctx->pck_queue) {\n\t\twhile (gf_list_count(ctx->pck_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_back(ctx->pck_queue);\n\t\t\tgf_filter_pck_discard(pck);\n\t\t}\n\t\tgf_list_del(ctx->pck_queue);\n\t}\n\tif (ctx->sei_buffer) gf_free(ctx->sei_buffer);\n\tif (ctx->svc_prefix_buffer) gf_free(ctx->svc_prefix_buffer);\n\tif (ctx->subsamp_buffer) gf_free(ctx->subsamp_buffer);\n\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\tctx->src_pck = NULL;\n\n\tnaludmx_reset_param_sets(ctx, GF_TRUE);\n\n\tif (ctx->avc_state) gf_free(ctx->avc_state);\n\tif (ctx->hevc_state) gf_free(ctx->hevc_state);\n\tif (ctx->vvc_state) gf_free(ctx->vvc_state);\n}\n\n\nstatic const char *naludmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tu32 sc, sc_size;\n\tu32 not_hevc=0;\n\tu32 not_avc=0;\n\tu32 not_vvc=0;\n\tu32 nb_hevc=0;\n\tu32 nb_avc=0;\n\tu32 nb_vvc=0;\n\t//u32 nb_nalus=0;\n\tu32 nb_hevc_zero=0;\n\tu32 nb_avc_zero=0;\n\tu32 nb_vvc_zero=0;\n\tu32 nb_sps_hevc=0,nb_pps_hevc=0,nb_vps_hevc=0;\n\tu32 nb_sps_avc=0,nb_pps_avc=0;\n\tu32 nb_sps_vvc=0,nb_pps_vvc=0; //,nb_vps_vvc=0;\n\n\twhile (size>3) {\n\t\tu32 nal_type=0;\n\t\tsc_size = 0;\n\t\tsc = gf_media_nalu_next_start_code(data, size, &sc_size);\n\t\tif (!sc_size) break;\n\n\t\tdata += sc + sc_size;\n\t\tif (size <= sc + sc_size) break;\n\t\tsize -= sc + sc_size;\n\n\t\tif (data[0] & 0x80) {\n\t\t\tnot_avc++;\n\t\t\tnot_hevc++;\n\t\t\tnot_vvc++;\n\t\t\tcontinue;\n\t\t}\n\t\t//nb_nalus++;\n\n\t\tnal_type = (data[0] & 0x7E) >> 1;\n\t\tif (nal_type<=40) {\n\t\t\tnb_hevc++;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\tif (nb_sps_hevc)\n\t\t\t\t\tnb_pps_hevc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\t\tnb_sps_hevc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\t\tnb_vps_hevc++;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tnb_hevc_zero++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((nal_type!=GF_HEVC_NALU_DV_RPU) && (nal_type!=GF_HEVC_NALU_DV_EL))\n\t\t\t\tnot_hevc++;\n\t\t}\n\n\t\tnal_type = data[0] & 0x1F;\n\t\tif (nal_type && nal_type<=24) {\n\t\t\tnb_avc++;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\tif (nb_sps_avc)\n\t\t\t\t\tnb_pps_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\t\tnb_sps_avc++;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tnb_avc_zero++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((nal_type!=GF_AVC_NALU_DV_RPU) && (nal_type!=GF_AVC_NALU_DV_EL))\n\t\t\t\tnot_avc++;\n\t\t}\n\n\t\t//check vvc - 2nd bit reserved to 0\n\t\tif (data[0] & 0x40) {\n\t\t\tnot_vvc++;\n\t\t\tcontinue;\n\t\t}\n\t\tnal_type = data[1] >> 3;\n\t\tif (nal_type>31) {\n\t\t\tnot_vvc++;\n\t\t\tcontinue;\n\t\t}\n\t\tnb_vvc++;\n\t\tswitch (nal_type) {\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tif (nb_sps_vvc)\n\t\t\t\tnb_pps_vvc++;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tnb_sps_vvc++;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\t//nb_vps_vvc++;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_ACCESS_UNIT:\n\t\t\t//to detect files without VPS correctly\n\t\t\t//nb_vps_vvc++;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnb_vvc_zero++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!nb_sps_avc || !nb_pps_avc) nb_avc=0;\n\tif (!nb_sps_hevc || !nb_pps_hevc || !nb_vps_hevc) nb_hevc=0;\n\t//VPS is optional in VVC, don't check for its presence\n\tif (!nb_sps_vvc || !nb_pps_vvc) nb_vvc=0;\n\tif (not_avc) nb_avc=0;\n\tif (not_hevc) nb_hevc=0;\n\tif (not_vvc) nb_vvc=0;\n\n\tif (not_avc && not_hevc && not_vvc) return NULL;\n\tif (nb_avc==nb_avc_zero) nb_avc=0;\n\tif (nb_hevc==nb_hevc_zero) nb_hevc=0;\n\tif (nb_vvc==nb_vvc_zero) nb_vvc=0;\n\n\tif (!nb_hevc && !nb_avc && !nb_vvc) return NULL;\n\t*score = GF_FPROBE_SUPPORTED;\n\tif (!nb_hevc) return (nb_vvc>nb_avc) ? \"video/vvc\" : \"video/avc\";\n\tif (!nb_avc) return (nb_vvc>nb_hevc) ? \"video/vvc\" : \"video/hevc\";\n\tif (!nb_vvc) return (nb_avc>nb_hevc) ? \"video/avc\" : \"video/hevc\";\n\n\tif ((nb_hevc>nb_avc) && (nb_hevc>nb_vvc)) return \"video/hevc\";\n\tif ((nb_vvc>nb_avc) && (nb_vvc>nb_hevc)) return \"video/vvc\";\n\treturn \"video/avc\";\n}\n\nstatic const GF_FilterCapability NALUDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"264|h264|26l|h26l|avc|svc|mvc|hevc|hvc|265|h265|lhvc|shvc|mhvc|266|h266|vvc|lvvc\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"video/avc|video/h264|video/svc|video/mvc|video/hevc|video/lhvc|video/shvc|video/mhvc|video/vvc\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AVC_PS),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_SVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_MVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_HEVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_LHVC),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_VVC),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_TILE_BASE, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AVC_PS),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_SVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_MVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_HEVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_LHVC),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_VVC),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_TILE_BASE, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n\t{0},\n\t//for HLS-SAES\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_ENCRYPTED),\n\tCAP_4CC(GF_CAPS_INPUT,GF_PROP_PID_PROTECTION_SCHEME_TYPE, GF_HLS_SAMPLE_AES_SCHEME),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AVC),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_TILE_BASE, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_NALUDmxCtx, _n)\nstatic const GF_FilterArgs NALUDmxArgs[] =\n{\n\t{ OFFS(fps), \"import frame rate (0 default to FPS from bitstream or 25 Hz)\", GF_PROP_FRACTION, \"0/1000\", NULL, 0},\n\t{ OFFS(index), \"indexing window length. If 0, bitstream is not probed for duration. A negative value skips the indexing if the source file is larger than 20M (slows down importers) unless a play with start range > 0 is issued\", GF_PROP_DOUBLE, \"-1.0\", NULL, 0},\n\t{ OFFS(explicit), \"use explicit layered (SVC/LHVC) import\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(strict_poc), \"delay frame output of an entire GOP to ensure CTS info is correct when POC suddenly changes\\n\"\n\t\t\"- off: disable GOP buffering\\n\"\n\t\t\"- on: enable GOP buffering, assuming no error in POC\\n\"\n\t\t\"- error: enable GOP buffering and try to detect lost frames\", GF_PROP_UINT, \"off\", \"off|on|error\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(nosei), \"remove all sei messages\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(nosvc), \"remove all SVC/MVC/LHVC data\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(novpsext), \"remove all VPS extensions\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import results\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dur), \"compatibility with old importer to log imported frames only\", GF_PROP_FRACTION, \"0\", NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(nal_length), \"set number of bytes used to code length field: 1, 2 or 4\", GF_PROP_UINT, \"4\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(subsamples), \"import subsamples information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(deps), \"import sample dependency information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(seirw), \"rewrite AVC sei messages for ISOBMFF constraints\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(audelim), \"keep Access Unit delimiter in payload\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(analyze), \"skip reformat of decoder config and SEI and dispatch all NAL in input order - shall only be used with inspect filter analyze mode!\", GF_PROP_UINT, \"off\", \"off|on|bs|full\", GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(notime), \"ignore input timestamps, rebuild from 0\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\n\t{ OFFS(dv_mode), \"signaling for DolbyVision\\n\"\n\t\"- none: never signal DV profile\\n\"\n\t\"- auto: signal DV profile if RPU or EL are found\\n\"\n\t\"- clean: do not signal and remove RPU and EL NAL units\\n\"\n\t\"- single: signal DV profile if RPU are found and remove EL NAL units\"\n\t, GF_PROP_UINT, \"auto\", \"none|auto|clean|single\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dv_profile), \"profile for DolbyVision (currently defined profiles are 4, 5, 7, 8, 9), 0 for auto-detect\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dv_compatid), \"cross-compatibility ID for DolbyVision\\n\"\n\t\t\"- auto: auto-detect\\n\"\n\t\t\"- none: no cross-compatibility\\n\"\n\t\t\"- hdr10: CTA HDR10, as specified by EBU TR 03\\n\"\n\t\t\"- bt709: SDR BT.709\\n\"\n\t\t\"- hlg709: HLG BT.709 gamut in ITU-R BT.2020\\n\"\n\t\t\"- hlg2100: HLG BT.2100 gamut in ITU-R BT.2020\\n\"\n\t\t\"- bt2020: SDR BT.2020\\n\"\n\t\t\"- brd: Ultra HD Blu-ray Disc HDR\", GF_PROP_UINT, \"auto\", \"auto|none|hdr10|bt709|hlg709|hlg2100|bt2020|brd\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(bsdbg), \"debug NAL parsing in `parser@debug` logs\\n\"\n\t\t\"- off: not enabled\\n\"\n\t\t\"- on: enabled\\n\"\n\t\t\"- full: enable with number of bits dumped\", GF_PROP_UINT, \"off\", \"off|on|full\", GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister NALUDmxRegister = {\n\t.name = \"rfnalu\",\n\tGF_FS_SET_DESCRIPTION(\"AVC/HEVC reframer\")\n\tGF_FS_SET_HELP(\"This filter parses AVC|H264 and HEVC files/data and outputs corresponding video PID and frames.\\n\"\n\t\"This filter produces ISOBMFF-compatible output: start codes are removed, NALU length field added and avcC/hvcC config created.\\n\"\n\t\"Note: The filter uses negative CTS offsets: CTS is correct, but some frames may have DTS greater than CTS.\")\n\t.private_size = sizeof(GF_NALUDmxCtx),\n\t.args = NALUDmxArgs,\n\t.initialize = naludmx_initialize,\n\t.finalize = naludmx_finalize,\n\tSETCAPS(NALUDmxCaps),\n\t.configure_pid = naludmx_configure_pid,\n\t.process = naludmx_process,\n\t.process_event = naludmx_process_event,\n\t.probe_data = naludmx_probe_data,\n};\n\n\nconst GF_FilterRegister *rfnalu_register(GF_FilterSession *session)\n{\n\treturn &NALUDmxRegister;\n}\n\n#else\nconst GF_FilterRegister *rfnalu_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif //GPAC_DISABLE_AV_PARSERS\n"], "filenames": ["src/filters/reframe_nalu.c"], "buggy_code_start_loc": [1512], "buggy_code_end_loc": [1516], "fixing_code_start_loc": [1512], "fixing_code_end_loc": [1519], "type": "CWE-369", "message": "Divide By Zero in GitHub repository gpac/gpac prior to 2.2.2.", "other": {"cve": {"id": "CVE-2023-2839", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-22T18:15:09.360", "lastModified": "2023-05-27T04:15:25.153", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Divide By Zero in GitHub repository gpac/gpac prior to 2.2.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 4.2}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.2", "matchCriteriaId": "DBF31B7B-F4C7-40C0-9245-09FECA1A8164"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/047f96fb39e6bf70cb9f344093f5886e51dce0ac", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/42dce889-f63d-4ea9-970f-1f20fc573d5f", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/047f96fb39e6bf70cb9f344093f5886e51dce0ac"}}