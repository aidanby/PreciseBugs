{"buggy_code": ["/*\n * Copyright (C) 2015-2019 DiffPlug\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.diffplug.gradle;\n\n\nimport com.diffplug.common.base.Errors;\nimport com.diffplug.common.base.StringPrinter;\nimport com.diffplug.common.base.Throwing;\nimport com.diffplug.common.io.ByteSink;\nimport com.diffplug.common.io.ByteSource;\nimport com.diffplug.common.io.ByteStreams;\nimport com.diffplug.common.io.Files;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Enumeration;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\nimport org.apache.commons.io.IOUtils;\n\n/** Utilities for mucking with zip files. */\npublic class ZipMisc {\n\t/**\n\t * Reads the given entry from the zip.\n\t * \n\t * @param input\t\ta zip file\n\t * @param toRead\ta path within that zip file\n\t * @param reader\twill be called with an InputStream containing the contents of that entry in the zip file\n\t */\n\tpublic static void read(File input, String toRead, Throwing.Specific.Consumer<InputStream, IOException> reader) throws IOException {\n\t\ttry (\n\t\t\t\tZipFile file = new ZipFile(input);\n\t\t\t\tInputStream stream = file.getInputStream(file.getEntry(toRead));) {\n\t\t\treader.accept(stream);\n\t\t} catch (NullPointerException e) {\n\t\t\tif (e.getMessage().equals(\"entry\")) {\n\t\t\t\tSystem.err.println(\"No such entry: \" + toRead);\n\t\t\t\ttry (ZipFile file = new ZipFile(input)) {\n\t\t\t\t\tEnumeration<? extends ZipEntry> entries = file.entries();\n\t\t\t\t\twhile (entries.hasMoreElements()) {\n\t\t\t\t\t\tZipEntry entry = entries.nextElement();\n\t\t\t\t\t\tSystem.err.println(\"  available: \" + entry.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Reads the given entry from the zip.\n\t * \n\t * @param input\t\ta zip file\n\t * @param toRead\ta path within that zip file\n\t * @return the given path within the zip file decoded as a UTF8 string, with only unix newlines.\n\t */\n\tpublic static String read(File input, String toRead) throws IOException {\n\t\tString raw = StringPrinter.buildString(Errors.rethrow().wrap(printer -> {\n\t\t\tread(input, toRead, inputStream -> {\n\t\t\t\tcopy(inputStream, printer.toOutputStream(StandardCharsets.UTF_8));\n\t\t\t});\n\t\t}));\n\t\treturn FileMisc.toUnixNewline(raw);\n\t}\n\n\t/**\n\t * Modifies only the specified entries in a zip file. \n\t *\n\t * @param input \t\ta source from a zip file\n\t * @param output\t\tan output to a zip file\n\t * @param toModify\t\ta map from path to an input stream for the entries you'd like to change\n\t * @param toOmit\t\ta set of entries you'd like to leave out of the zip\n\t * @throws IOException\n\t */\n\tpublic static void modify(ByteSource input, ByteSink output, Map<String, Function<byte[], byte[]>> toModify, Predicate<String> toOmit) throws IOException {\n\t\ttry (ZipInputStream zipInput = new ZipInputStream(input.openBufferedStream());\n\t\t\t\tZipOutputStream zipOutput = new ZipOutputStream(output.openBufferedStream())) {\n\t\t\twhile (true) {\n\t\t\t\t// read the next entry\n\t\t\t\tZipEntry entry = zipInput.getNextEntry();\n\t\t\t\tif (entry == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tFunction<byte[], byte[]> replacement = toModify.get(entry.getName());\n\t\t\t\tif (replacement != null) {\n\t\t\t\t\tbyte[] clean = ByteStreams.toByteArray(zipInput);\n\t\t\t\t\tbyte[] modified = replacement.apply(clean);\n\t\t\t\t\t// if it's the entry being modified, enter the modified stuff\n\t\t\t\t\ttry (InputStream replacementStream = new ByteArrayInputStream(modified)) {\n\t\t\t\t\t\tZipEntry newEntry = new ZipEntry(entry.getName());\n\t\t\t\t\t\tnewEntry.setComment(entry.getComment());\n\t\t\t\t\t\tnewEntry.setExtra(entry.getExtra());\n\t\t\t\t\t\tnewEntry.setMethod(entry.getMethod());\n\t\t\t\t\t\tnewEntry.setTime(entry.getTime());\n\n\t\t\t\t\t\tzipOutput.putNextEntry(newEntry);\n\t\t\t\t\t\tcopy(replacementStream, zipOutput);\n\t\t\t\t\t}\n\t\t\t\t} else if (!toOmit.test(entry.getName())) {\n\t\t\t\t\t// if it isn't being modified, just copy the file stream straight-up\n\t\t\t\t\tZipEntry newEntry = new ZipEntry(entry);\n\t\t\t\t\tnewEntry.setCompressedSize(-1);\n\t\t\t\t\tzipOutput.putNextEntry(newEntry);\n\t\t\t\t\tcopy(zipInput, zipOutput);\n\t\t\t\t}\n\n\t\t\t\t// close the entries\n\t\t\t\tzipInput.closeEntry();\n\t\t\t\tzipOutput.closeEntry();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Modifies a file in-place. */\n\tpublic static void modify(File file, Map<String, Function<byte[], byte[]>> toModify, Predicate<String> toOmit) throws IOException {\n\t\tbyte[] allContent = Files.asByteSource(file).read();\n\t\tByteSource source = ByteSource.wrap(allContent);\n\t\tByteSink sink = Files.asByteSink(file);\n\t\tmodify(source, sink, toModify, toOmit);\n\t}\n\n\t/**\n\t * Creates a single-entry zip file.\n\t * \n\t * @param input\t\t\t\t\tan uncompressed file\n\t * @param pathWithinArchive\t\tthe path within the archive\n\t * @param output\t\t\t\tthe new zip file it will be compressed into\n\t */\n\tpublic static void zip(File input, String pathWithinArchive, File output) throws IOException {\n\t\ttry (ZipOutputStream zipStream = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(output)))) {\n\t\t\tzipStream.setMethod(ZipOutputStream.DEFLATED);\n\t\t\tzipStream.setLevel(9);\n\t\t\tzipStream.putNextEntry(new ZipEntry(pathWithinArchive));\n\t\t\ttry (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(input))) {\n\t\t\t\tcopy(inputStream, zipStream);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Copies one stream into the other. */\n\tprivate static void copy(InputStream input, OutputStream output) throws IOException {\n\t\tIOUtils.copy(input, output);\n\t}\n\n\t/**\n\t * Unzips a directory to a folder.\n\t *\n\t * @param input\t\t\t\ta zip file\n\t * @param destinationDir\twhere the zip will be extracted to\n\t */\n\tpublic static void unzip(File input, File destinationDir) throws IOException {\n\t\ttry (ZipInputStream zipInput = new ZipInputStream(new BufferedInputStream(new FileInputStream(input)))) {\n\t\t\tZipEntry entry;\n\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\tFile dest = new File(destinationDir, entry.getName());\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\tFileMisc.mkdirs(dest);\n\t\t\t\t} else {\n\t\t\t\t\tFileMisc.mkdirs(dest.getParentFile());\n\t\t\t\t\ttry (OutputStream output = new BufferedOutputStream(new FileOutputStream(dest))) {\n\t\t\t\t\t\tcopy(zipInput, output);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2015-2019 DiffPlug\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.diffplug.gradle;\n\n\nimport com.diffplug.common.base.Errors;\nimport com.diffplug.common.base.StringPrinter;\nimport com.diffplug.common.base.Throwing;\nimport com.diffplug.common.io.ByteSink;\nimport com.diffplug.common.io.ByteSource;\nimport com.diffplug.common.io.ByteStreams;\nimport com.diffplug.common.io.Files;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Enumeration;\nimport java.util.Map;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\nimport org.apache.commons.io.IOUtils;\n\n/** Utilities for mucking with zip files. */\npublic class ZipMisc {\n\t/**\n\t * Reads the given entry from the zip.\n\t * \n\t * @param input\t\ta zip file\n\t * @param toRead\ta path within that zip file\n\t * @param reader\twill be called with an InputStream containing the contents of that entry in the zip file\n\t */\n\tpublic static void read(File input, String toRead, Throwing.Specific.Consumer<InputStream, IOException> reader) throws IOException {\n\t\ttry (\n\t\t\t\tZipFile file = new ZipFile(input);\n\t\t\t\tInputStream stream = file.getInputStream(file.getEntry(toRead));) {\n\t\t\treader.accept(stream);\n\t\t} catch (NullPointerException e) {\n\t\t\tif (e.getMessage().equals(\"entry\")) {\n\t\t\t\tSystem.err.println(\"No such entry: \" + toRead);\n\t\t\t\ttry (ZipFile file = new ZipFile(input)) {\n\t\t\t\t\tEnumeration<? extends ZipEntry> entries = file.entries();\n\t\t\t\t\twhile (entries.hasMoreElements()) {\n\t\t\t\t\t\tZipEntry entry = entries.nextElement();\n\t\t\t\t\t\tSystem.err.println(\"  available: \" + entry.getName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Reads the given entry from the zip.\n\t * \n\t * @param input\t\ta zip file\n\t * @param toRead\ta path within that zip file\n\t * @return the given path within the zip file decoded as a UTF8 string, with only unix newlines.\n\t */\n\tpublic static String read(File input, String toRead) throws IOException {\n\t\tString raw = StringPrinter.buildString(Errors.rethrow().wrap(printer -> {\n\t\t\tread(input, toRead, inputStream -> {\n\t\t\t\tcopy(inputStream, printer.toOutputStream(StandardCharsets.UTF_8));\n\t\t\t});\n\t\t}));\n\t\treturn FileMisc.toUnixNewline(raw);\n\t}\n\n\t/**\n\t * Modifies only the specified entries in a zip file. \n\t *\n\t * @param input \t\ta source from a zip file\n\t * @param output\t\tan output to a zip file\n\t * @param toModify\t\ta map from path to an input stream for the entries you'd like to change\n\t * @param toOmit\t\ta set of entries you'd like to leave out of the zip\n\t * @throws IOException\n\t */\n\tpublic static void modify(ByteSource input, ByteSink output, Map<String, Function<byte[], byte[]>> toModify, Predicate<String> toOmit) throws IOException {\n\t\ttry (ZipInputStream zipInput = new ZipInputStream(input.openBufferedStream());\n\t\t\t\tZipOutputStream zipOutput = new ZipOutputStream(output.openBufferedStream())) {\n\t\t\twhile (true) {\n\t\t\t\t// read the next entry\n\t\t\t\tZipEntry entry = zipInput.getNextEntry();\n\t\t\t\tif (entry == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tFunction<byte[], byte[]> replacement = toModify.get(entry.getName());\n\t\t\t\tif (replacement != null) {\n\t\t\t\t\tbyte[] clean = ByteStreams.toByteArray(zipInput);\n\t\t\t\t\tbyte[] modified = replacement.apply(clean);\n\t\t\t\t\t// if it's the entry being modified, enter the modified stuff\n\t\t\t\t\ttry (InputStream replacementStream = new ByteArrayInputStream(modified)) {\n\t\t\t\t\t\tZipEntry newEntry = new ZipEntry(entry.getName());\n\t\t\t\t\t\tnewEntry.setComment(entry.getComment());\n\t\t\t\t\t\tnewEntry.setExtra(entry.getExtra());\n\t\t\t\t\t\tnewEntry.setMethod(entry.getMethod());\n\t\t\t\t\t\tnewEntry.setTime(entry.getTime());\n\n\t\t\t\t\t\tzipOutput.putNextEntry(newEntry);\n\t\t\t\t\t\tcopy(replacementStream, zipOutput);\n\t\t\t\t\t}\n\t\t\t\t} else if (!toOmit.test(entry.getName())) {\n\t\t\t\t\t// if it isn't being modified, just copy the file stream straight-up\n\t\t\t\t\tZipEntry newEntry = new ZipEntry(entry);\n\t\t\t\t\tnewEntry.setCompressedSize(-1);\n\t\t\t\t\tzipOutput.putNextEntry(newEntry);\n\t\t\t\t\tcopy(zipInput, zipOutput);\n\t\t\t\t}\n\n\t\t\t\t// close the entries\n\t\t\t\tzipInput.closeEntry();\n\t\t\t\tzipOutput.closeEntry();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Modifies a file in-place. */\n\tpublic static void modify(File file, Map<String, Function<byte[], byte[]>> toModify, Predicate<String> toOmit) throws IOException {\n\t\tbyte[] allContent = Files.asByteSource(file).read();\n\t\tByteSource source = ByteSource.wrap(allContent);\n\t\tByteSink sink = Files.asByteSink(file);\n\t\tmodify(source, sink, toModify, toOmit);\n\t}\n\n\t/**\n\t * Creates a single-entry zip file.\n\t * \n\t * @param input\t\t\t\t\tan uncompressed file\n\t * @param pathWithinArchive\t\tthe path within the archive\n\t * @param output\t\t\t\tthe new zip file it will be compressed into\n\t */\n\tpublic static void zip(File input, String pathWithinArchive, File output) throws IOException {\n\t\ttry (ZipOutputStream zipStream = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(output)))) {\n\t\t\tzipStream.setMethod(ZipOutputStream.DEFLATED);\n\t\t\tzipStream.setLevel(9);\n\t\t\tzipStream.putNextEntry(new ZipEntry(pathWithinArchive));\n\t\t\ttry (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(input))) {\n\t\t\t\tcopy(inputStream, zipStream);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Copies one stream into the other. */\n\tprivate static void copy(InputStream input, OutputStream output) throws IOException {\n\t\tIOUtils.copy(input, output);\n\t}\n\n\t/**\n\t * Unzips a directory to a folder.\n\t *\n\t * @param input\t\t\t\ta zip file\n\t * @param destinationDir\twhere the zip will be extracted to\n\t */\n\tpublic static void unzip(File input, File destinationDir) throws IOException {\n\t\ttry (ZipInputStream zipInput = new ZipInputStream(new BufferedInputStream(new FileInputStream(input)))) {\n\t\t\tZipEntry entry;\n\t\t\twhile ((entry = zipInput.getNextEntry()) != null) {\n\t\t\t\tFile dest = new File(destinationDir, entry.getName());\n\t\t\t\tif (!dest.toPath().normalize().startsWith(destinationDir.toPath().normalize())) {\n\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n\t\t\t\t}\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\tFileMisc.mkdirs(dest);\n\t\t\t\t} else {\n\t\t\t\t\tFileMisc.mkdirs(dest.getParentFile());\n\t\t\t\t\ttry (OutputStream output = new BufferedOutputStream(new FileOutputStream(dest))) {\n\t\t\t\t\t\tcopy(zipInput, output);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"], "filenames": ["src/main/java/com/diffplug/gradle/ZipMisc.java"], "buggy_code_start_loc": [180], "buggy_code_end_loc": [180], "fixing_code_start_loc": [181], "fixing_code_end_loc": [184], "type": "CWE-22", "message": "This affects the package com.diffplug.gradle:goomph before 3.37.2. It allows a malicious zip file to potentially break out of the expected destination directory, writing contents into arbitrary locations on the file system. Overwriting certain files/directories could allow an attacker to achieve remote code execution on a target system by exploiting this vulnerability. **Note:** This could have allowed a malicious zip file to extract itself into an arbitrary directory. The only file that Goomph extracts is the p2 bootstrapper and eclipse metadata files hosted at eclipse.org, which are not malicious, so the only way this vulnerability could have affected you is if you had set a custom bootstrap zip, and that zip was malicious.", "other": {"cve": {"id": "CVE-2022-26049", "sourceIdentifier": "report@snyk.io", "published": "2022-09-11T14:15:08.887", "lastModified": "2022-09-16T02:28:24.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package com.diffplug.gradle:goomph before 3.37.2. It allows a malicious zip file to potentially break out of the expected destination directory, writing contents into arbitrary locations on the file system. Overwriting certain files/directories could allow an attacker to achieve remote code execution on a target system by exploiting this vulnerability. **Note:** This could have allowed a malicious zip file to extract itself into an arbitrary directory. The only file that Goomph extracts is the p2 bootstrapper and eclipse metadata files hosted at eclipse.org, which are not malicious, so the only way this vulnerability could have affected you is if you had set a custom bootstrap zip, and that zip was malicious."}, {"lang": "es", "value": "Esto afecta al paquete com.diffplug.gradle:goomph versiones anteriores a 3.37.2. Permite que un archivo zip malicioso salga del directorio de destino esperado, escribiendo el contenido en ubicaciones arbitrarias del sistema de archivos. La sobreescritura de determinados archivos/directorios podr\u00eda permitir a un atacante lograr una ejecuci\u00f3n de c\u00f3digo remota en un sistema de destino al explotar esta vulnerabilidad. **Nota:** Esto podr\u00eda haber permitido que un archivo zip malicioso sea extra\u00eddo en un directorio arbitrario. El \u00fanico archivo que Goomph extrae es el p2 bootstrapper y los archivos de metadatos de eclipse alojados en eclipse.org, que no son maliciosos, por lo que la \u00fanica forma en que esta vulnerabilidad podr\u00eda haberle afectado es si hubiera establecido un zip de arranque personalizado, y ese zip fuera malicioso"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:diffplug:goomph:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.37.2", "matchCriteriaId": "E0FBC837-494B-4F0A-9BF7-F70321A7EE62"}]}]}], "references": [{"url": "https://github.com/diffplug/goomph/commit/25f04f67ba62d9a14104bee13a0a0f2517afb8c8", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/diffplug/goomph/pull/198", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JAVA-COMDIFFPLUGGRADLE-2981040", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/diffplug/goomph/commit/25f04f67ba62d9a14104bee13a0a0f2517afb8c8"}}