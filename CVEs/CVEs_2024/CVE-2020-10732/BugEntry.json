{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * linux/fs/binfmt_elf.c\n *\n * These are the functions used to load ELF format executables as used\n * on SVr4 machines.  Information on the format may be found in the book\n * \"UNIX SYSTEM V RELEASE 4 Programmers Guide: Ansi C and Programming Support\n * Tools\".\n *\n * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/binfmts.h>\n#include <linux/string.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/personality.h>\n#include <linux/elfcore.h>\n#include <linux/init.h>\n#include <linux/highuid.h>\n#include <linux/compiler.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/random.h>\n#include <linux/elf.h>\n#include <linux/elf-randomize.h>\n#include <linux/utsname.h>\n#include <linux/coredump.h>\n#include <linux/sched.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/cred.h>\n#include <linux/dax.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <asm/page.h>\n\n#ifndef user_long_t\n#define user_long_t long\n#endif\n#ifndef user_siginfo_t\n#define user_siginfo_t siginfo_t\n#endif\n\n/* That's for binfmt_elf_fdpic to deal with */\n#ifndef elf_check_fdpic\n#define elf_check_fdpic(ex) false\n#endif\n\nstatic int load_elf_binary(struct linux_binprm *bprm);\n\n#ifdef CONFIG_USELIB\nstatic int load_elf_library(struct file *);\n#else\n#define load_elf_library NULL\n#endif\n\n/*\n * If we don't support core dumping, then supply a NULL so we\n * don't even try.\n */\n#ifdef CONFIG_ELF_CORE\nstatic int elf_core_dump(struct coredump_params *cprm);\n#else\n#define elf_core_dump\tNULL\n#endif\n\n#if ELF_EXEC_PAGESIZE > PAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n#else\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#endif\n\n#ifndef ELF_CORE_EFLAGS\n#define ELF_CORE_EFLAGS\t0\n#endif\n\n#define ELF_PAGESTART(_v) ((_v) & ~(unsigned long)(ELF_MIN_ALIGN-1))\n#define ELF_PAGEOFFSET(_v) ((_v) & (ELF_MIN_ALIGN-1))\n#define ELF_PAGEALIGN(_v) (((_v) + ELF_MIN_ALIGN - 1) & ~(ELF_MIN_ALIGN - 1))\n\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\n#define BAD_ADDR(x) (unlikely((unsigned long)(x) >= TASK_SIZE))\n\nstatic int set_brk(unsigned long start, unsigned long end, int prot)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\t/*\n\t\t * Map the last of the bss segment.\n\t\t * If the header is requesting these pages to be\n\t\t * executable, honour that (ppc32 needs this).\n\t\t */\n\t\tint error = vm_brk_flags(start, end - start,\n\t\t\t\tprot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}\n\n/* We need to explicitly zero any fractional pages\n   after the data section (i.e. bss).  This would\n   contain the junk from the file that should not\n   be in memory\n */\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/* Let's use some macros to make this stack manipulation a little clearer */\n#ifdef CONFIG_STACK_GROWSUP\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) + (items))\n#define STACK_ROUND(sp, items) \\\n\t((15 + (unsigned long) ((sp) + (items))) &~ 15UL)\n#define STACK_ALLOC(sp, len) ({ \\\n\telf_addr_t __user *old_sp = (elf_addr_t __user *)sp; sp += len; \\\n\told_sp; })\n#else\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) - (items))\n#define STACK_ROUND(sp, items) \\\n\t(((unsigned long) (sp - items)) &~ 15UL)\n#define STACK_ALLOC(sp, len) ({ sp -= len ; sp; })\n#endif\n\n#ifndef ELF_BASE_PLATFORM\n/*\n * AT_BASE_PLATFORM indicates the \"real\" hardware/microarchitecture.\n * If the arch defines ELF_BASE_PLATFORM (in asm/elf.h), the value\n * will be copied to the user stack in the same manner as AT_PLATFORM.\n */\n#define ELF_BASE_PLATFORM NULL\n#endif\n\nstatic int\ncreate_elf_tables(struct linux_binprm *bprm, const struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr,\n\t\tunsigned long e_entry)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\t*elf_info++ = id; \\\n\t\t*elf_info++ = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE, bprm->secureexec);\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(elf_info, 0, (char *)mm->saved_auxv +\n\t\t\tsizeof(mm->saved_auxv) - (char *)elf_info);\n\n\t/* And advance past the AT_NULL entry.  */\n\telf_info += 2;\n\n\tei_index = elf_info - (elf_addr_t *)mm->saved_auxv;\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\n\t/* Populate list of argv pointers back to argv strings. */\n\tp = mm->arg_end = mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tmm->arg_end = p;\n\n\t/* Populate list of envp pointers back to envp strings. */\n\tmm->env_end = mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tmm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tif (copy_to_user(sp, mm->saved_auxv, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tconst struct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\tif ((type & MAP_FIXED_NOREPLACE) &&\n\t    PTR_ERR((void *)map_addr) == -EEXIST)\n\t\tpr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\",\n\t\t\ttask_pid_nr(current), current->comm, (void *)addr);\n\n\treturn(map_addr);\n}\n\nstatic unsigned long total_mapping_size(const struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}\n\nstatic int elf_read(struct file *file, void *buf, size_t len, loff_t pos)\n{\n\tssize_t rv;\n\n\trv = kernel_read(file, buf, len, &pos);\n\tif (unlikely(rv != len)) {\n\t\treturn (rv < 0) ? rv : -EIO;\n\t}\n\treturn 0;\n}\n\n/**\n * load_elf_phdrs() - load ELF program headers\n * @elf_ex:   ELF header of the binary whose program headers should be loaded\n * @elf_file: the opened ELF binary file\n *\n * Loads ELF program headers from the binary file elf_file, which has the ELF\n * header pointed to by elf_ex, into a newly allocated array. The caller is\n * responsible for freeing the allocated data. Returns an ERR_PTR upon failure.\n */\nstatic struct elf_phdr *load_elf_phdrs(const struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, err = -1;\n\tunsigned int size;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size == 0 || size > 65536 || size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = elf_read(elf_file, elf_phdata, size, elf_ex->e_phoff);\n\tif (retval < 0) {\n\t\terr = retval;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}\n\n#ifndef CONFIG_ARCH_BINFMT_ELF_STATE\n\n/**\n * struct arch_elf_state - arch-specific ELF loading state\n *\n * This structure is used to preserve architecture specific data during\n * the loading of an ELF file, throughout the checking of architecture\n * specific ELF headers & through to the point where the ELF load is\n * known to be proceeding (ie. SET_PERSONALITY).\n *\n * This implementation is a dummy for architectures which require no\n * specific state.\n */\nstruct arch_elf_state {\n};\n\n#define INIT_ARCH_ELF_STATE {}\n\n/**\n * arch_elf_pt_proc() - check a PT_LOPROC..PT_HIPROC ELF program header\n * @ehdr:\tThe main ELF header\n * @phdr:\tThe program header to check\n * @elf:\tThe open ELF file\n * @is_interp:\tTrue if the phdr is from the interpreter of the ELF being\n *\t\tloaded, else false.\n * @state:\tArchitecture-specific state preserved throughout the process\n *\t\tof loading the ELF.\n *\n * Inspects the program header phdr to validate its correctness and/or\n * suitability for the system. Called once per ELF program header in the\n * range PT_LOPROC to PT_HIPROC, for both the ELF being loaded and its\n * interpreter.\n *\n * Return: Zero to proceed with the ELF load, non-zero to fail the ELF load\n *         with that return code.\n */\nstatic inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}\n\n/**\n * arch_check_elf() - check an ELF executable\n * @ehdr:\tThe main ELF header\n * @has_interp:\tTrue if the ELF has an interpreter, else false.\n * @interp_ehdr: The interpreter's ELF header\n * @state:\tArchitecture-specific state preserved throughout the process\n *\t\tof loading the ELF.\n *\n * Provides a final opportunity for architecture code to reject the loading\n * of the ELF & cause an exec syscall to return an error. This is called after\n * all program headers to be checked by arch_elf_pt_proc have been.\n *\n * Return: Zero to proceed with the ELF load, non-zero to fail the ELF load\n *         with that return code.\n */\nstatic inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct elfhdr *interp_ehdr,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}\n\n#endif /* !CONFIG_ARCH_BINFMT_ELF_STATE */\n\nstatic inline int make_prot(u32 p_flags)\n{\n\tint prot = 0;\n\n\tif (p_flags & PF_R)\n\t\tprot |= PROT_READ;\n\tif (p_flags & PF_W)\n\t\tprot |= PROT_WRITE;\n\tif (p_flags & PF_X)\n\t\tprot |= PROT_EXEC;\n\treturn prot;\n}\n\n/* This is much more generalized than the library routine read function,\n   so we keep this separate.  Technically the library read function\n   is only provided so that we can read a.out libraries that have\n   an ELF header */\n\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tint bss_prot = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex) ||\n\t    elf_check_fdpic(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = make_prot(eppnt->p_flags);\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED_NOREPLACE;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_memsz;\n\t\t\tif (k > last_bss) {\n\t\t\t\tlast_bss = k;\n\t\t\t\tbss_prot = elf_prot;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now fill out the bss section: first pad the last page from\n\t * the file up to the page boundary, and zero it from elf_bss\n\t * up to the end of the page.\n\t */\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\t/*\n\t * Next, align both the file and mem bss up to the page size,\n\t * since this is where elf_bss was just zeroed up to, and where\n\t * last_bss will end after the vm_brk_flags() below.\n\t */\n\telf_bss = ELF_PAGEALIGN(elf_bss);\n\tlast_bss = ELF_PAGEALIGN(last_bss);\n\t/* Finally, if there is still more bss to allocate, do it. */\n\tif (last_bss > elf_bss) {\n\t\terror = vm_brk_flags(elf_bss, last_bss - elf_bss,\n\t\t\t\tbss_prot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}\n\n/*\n * These are the functions used to load ELF style executables and shared\n * libraries.  There is no binary dependent code anywhere else.\n */\n\nstatic int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint bss_prot = 0;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long e_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct elfhdr *elf_ex = (struct elfhdr *)bprm->buf;\n\tstruct elfhdr *interp_elf_ex = NULL;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\tstruct mm_struct *mm;\n\tstruct pt_regs *regs;\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(elf_ex->e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (elf_ex->e_type != ET_EXEC && elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(elf_ex))\n\t\tgoto out;\n\tif (elf_check_fdpic(elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < elf_ex->e_phnum; i++, elf_ppnt++) {\n\t\tchar *elf_interpreter;\n\n\t\tif (elf_ppnt->p_type != PT_INTERP)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This is the program interpreter used for shared libraries -\n\t\t * for now assume that this is an a.out format binary.\n\t\t */\n\t\tretval = -ENOEXEC;\n\t\tif (elf_ppnt->p_filesz > PATH_MAX || elf_ppnt->p_filesz < 2)\n\t\t\tgoto out_free_ph;\n\n\t\tretval = -ENOMEM;\n\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz, GFP_KERNEL);\n\t\tif (!elf_interpreter)\n\t\t\tgoto out_free_ph;\n\n\t\tretval = elf_read(bprm->file, elf_interpreter, elf_ppnt->p_filesz,\n\t\t\t\t  elf_ppnt->p_offset);\n\t\tif (retval < 0)\n\t\t\tgoto out_free_interp;\n\t\t/* make sure path is NULL terminated */\n\t\tretval = -ENOEXEC;\n\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\tgoto out_free_interp;\n\n\t\tinterpreter = open_exec(elf_interpreter);\n\t\tkfree(elf_interpreter);\n\t\tretval = PTR_ERR(interpreter);\n\t\tif (IS_ERR(interpreter))\n\t\t\tgoto out_free_ph;\n\n\t\t/*\n\t\t * If the binary is not readable then enforce mm->dumpable = 0\n\t\t * regardless of the interpreter's permissions.\n\t\t */\n\t\twould_dump(bprm, interpreter);\n\n\t\tinterp_elf_ex = kmalloc(sizeof(*interp_elf_ex), GFP_KERNEL);\n\t\tif (!interp_elf_ex) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_free_ph;\n\t\t}\n\n\t\t/* Get the exec headers */\n\t\tretval = elf_read(interpreter, interp_elf_ex,\n\t\t\t\t  sizeof(*interp_elf_ex), 0);\n\t\tif (retval < 0)\n\t\t\tgoto out_free_dentry;\n\n\t\tbreak;\n\nout_free_interp:\n\t\tkfree(elf_interpreter);\n\t\tgoto out_free_ph;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < elf_ex->e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(interp_elf_ex->e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(interp_elf_ex) ||\n\t\t    elf_check_fdpic(interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(elf_ex,\n\t\t\t\t!!interpreter, interp_elf_ex,\n\t\t\t\t&arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(*elf_ex, &arch_state);\n\tif (elf_read_implies_exec(*elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\tinstall_exec_creds(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < elf_ex->e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot, elf_flags;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias,\n\t\t\t\t\t bss_prot);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telf_prot = make_prot(elf_ppnt->p_flags);\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\t/*\n\t\t * If we are loading ET_EXEC or we have already performed\n\t\t * the ET_DYN load_addr calculations, proceed normally.\n\t\t */\n\t\tif (elf_ex->e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (elf_ex->e_type == ET_DYN) {\n\t\t\t/*\n\t\t\t * This logic is run once for the first LOAD Program\n\t\t\t * Header for ET_DYN binaries to calculate the\n\t\t\t * randomization (load_bias) for all the LOAD\n\t\t\t * Program Headers, and to calculate the entire\n\t\t\t * size of the ELF mapping (total_size). (Note that\n\t\t\t * load_addr_set is set to true later once the\n\t\t\t * initial mapping is performed.)\n\t\t\t *\n\t\t\t * There are effectively two types of ET_DYN\n\t\t\t * binaries: programs (i.e. PIE: ET_DYN with INTERP)\n\t\t\t * and loaders (ET_DYN without INTERP, since they\n\t\t\t * _are_ the ELF interpreter). The loaders must\n\t\t\t * be loaded away from programs since the program\n\t\t\t * may otherwise collide with the loader (especially\n\t\t\t * for ET_EXEC which does not have a randomized\n\t\t\t * position). For example to handle invocations of\n\t\t\t * \"./ld.so someprog\" to test out a new version of\n\t\t\t * the loader, the subsequent program that the\n\t\t\t * loader loads must avoid the loader itself, so\n\t\t\t * they cannot share the same load range. Sufficient\n\t\t\t * room for the brk must be allocated with the\n\t\t\t * loader as well, since brk must be available with\n\t\t\t * the loader.\n\t\t\t *\n\t\t\t * Therefore, programs are loaded offset from\n\t\t\t * ELF_ET_DYN_BASE and loaders are loaded into the\n\t\t\t * independently randomized mmap region (0 load_bias\n\t\t\t * without MAP_FIXED).\n\t\t\t */\n\t\t\tif (interpreter) {\n\t\t\t\tload_bias = ELF_ET_DYN_BASE;\n\t\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\t\tload_bias += arch_mmap_rnd();\n\t\t\t\telf_flags |= MAP_FIXED;\n\t\t\t} else\n\t\t\t\tload_bias = 0;\n\n\t\t\t/*\n\t\t\t * Since load_bias is used for all subsequent loading\n\t\t\t * calculations, we must lower it by the first vaddr\n\t\t\t * so that the remaining calculations based on the\n\t\t\t * ELF vaddrs will be correctly offset. The result\n\t\t\t * is then page aligned.\n\t\t\t */\n\t\t\tload_bias = ELF_PAGESTART(load_bias - vaddr);\n\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\telf_ex->e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif ((elf_ppnt->p_flags & PF_X) && k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk) {\n\t\t\tbss_prot = elf_prot;\n\t\t\telf_brk = k;\n\t\t}\n\t}\n\n\te_entry = elf_ex->e_entry + load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk, bss_prot);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (interpreter) {\n\t\telf_entry = load_elf_interp(interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += interp_elf_ex->e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\n\t\tkfree(interp_elf_ex);\n\t\tkfree(interp_elf_phdata);\n\t} else {\n\t\telf_entry = e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tretval = create_elf_tables(bprm, elf_ex,\n\t\t\t  load_addr, interp_load_addr, e_entry);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tmm = current->mm;\n\tmm->end_code = end_code;\n\tmm->start_code = start_code;\n\tmm->start_data = start_data;\n\tmm->end_data = end_data;\n\tmm->start_stack = bprm->p;\n\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\t/*\n\t\t * For architectures with ELF randomization, when executing\n\t\t * a loader directly (i.e. no interpreter listed in ELF\n\t\t * headers), move the brk area out of the mmap region\n\t\t * (since it grows up, and may collide early with the stack\n\t\t * growing down), and into the unused ELF_ET_DYN_BASE region.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_ARCH_HAS_ELF_RANDOMIZE) &&\n\t\t    elf_ex->e_type == ET_DYN && !interpreter) {\n\t\t\tmm->brk = mm->start_brk = ELF_ET_DYN_BASE;\n\t\t}\n\n\t\tmm->brk = mm->start_brk = arch_randomize_brk(mm);\n#ifdef compat_brk_randomized\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n\tregs = current_pt_regs();\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tfinalize_exec(bprm);\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_ex);\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}\n\n#ifdef CONFIG_USELIB\n/* This is really simpleminded and specialized - we are loading an\n   a.out library that is given an ELF header. */\nstatic int load_elf_library(struct file *file)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long elf_bss, bss, len;\n\tint retval, error, i, j;\n\tstruct elfhdr elf_ex;\n\n\terror = -ENOEXEC;\n\tretval = elf_read(file, &elf_ex, sizeof(elf_ex), 0);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* First of all, some simple consistency checks */\n\tif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\n\t    !elf_check_arch(&elf_ex) || !file->f_op->mmap)\n\t\tgoto out;\n\tif (elf_check_fdpic(&elf_ex))\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\n\tj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\n\t/* j < ELF_MIN_ALIGN because elf_ex.e_phnum <= 2 */\n\n\terror = -ENOMEM;\n\telf_phdata = kmalloc(j, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\teppnt = elf_phdata;\n\terror = -ENOEXEC;\n\tretval = elf_read(file, eppnt, j, elf_ex.e_phoff);\n\tif (retval < 0)\n\t\tgoto out_free_ph;\n\n\tfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\n\t\tif ((eppnt + i)->p_type == PT_LOAD)\n\t\t\tj++;\n\tif (j != 1)\n\t\tgoto out_free_ph;\n\n\twhile (eppnt->p_type != PT_LOAD)\n\t\teppnt++;\n\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file,\n\t\t\tELF_PAGESTART(eppnt->p_vaddr),\n\t\t\t(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)),\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED_NOREPLACE | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\t(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)));\n\tif (error != ELF_PAGESTART(eppnt->p_vaddr))\n\t\tgoto out_free_ph;\n\n\telf_bss = eppnt->p_vaddr + eppnt->p_filesz;\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free_ph;\n\t}\n\n\tlen = ELF_PAGEALIGN(eppnt->p_filesz + eppnt->p_vaddr);\n\tbss = ELF_PAGEALIGN(eppnt->p_memsz + eppnt->p_vaddr);\n\tif (bss > len) {\n\t\terror = vm_brk(len, bss - len);\n\t\tif (error)\n\t\t\tgoto out_free_ph;\n\t}\n\terror = 0;\n\nout_free_ph:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}\n#endif /* #ifdef CONFIG_USELIB */\n\n#ifdef CONFIG_ELF_CORE\n/*\n * ELF core dumper\n *\n * Modelled on fs/exec.c:aout_core_dump()\n * Jeremy Fitzhardinge <jeremy@sw.oz.au>\n */\n\n/*\n * The purpose of always_dump_vma() is to make sure that special kernel mappings\n * that are useful for post-mortem analysis are included in every core dump.\n * In that way we ensure that the core dump is fully interpretable later\n * without matching up the same kernel and hardware config to see what PC values\n * meant. These special mappings include - vDSO, vsyscall, and other\n * architecture specific mappings\n */\nstatic bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * Decide what to dump of a segment, part, all or none.\n */\nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(DAX_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(DAX_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Hugetlb memory check */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}\n\n/* An ELF note in memory */\nstruct memelfnote\n{\n\tconst char *name;\n\tint type;\n\tunsigned int datasz;\n\tvoid *data;\n};\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n}\n\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n}\n\nstatic void fill_note(struct memelfnote *note, const char *name, int type, \n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n}\n\n/*\n * fill up all the fields in prstatus from the given task struct, except\n * registers which need to be filled up separately.\n */\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_kernel_old_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_kernel_old_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_kernel_old_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_kernel_old_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_kernel_old_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_kernel_old_timeval(p->signal->cstime);\n}\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}\n\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst kernel_siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}\n\n#define MAX_FILE_NOTE_SIZE (4*1024*1024)\n/*\n * Format of NT_FILE note:\n *\n * long count     -- how many files are mapped\n * long page_size -- units for file_ofs\n * array of [COUNT] elements of\n *   long start\n *   long end\n *   long file_ofs\n * followed by COUNT filenames in ASCII: \"FILE1\" NUL \"FILE2\" NUL...\n */\nstatic int fill_files_note(struct memelfnote *note)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = mm->map_count;\n\tif (count > UINT_MAX / 64)\n\t\treturn -EINVAL;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\t/*\n\t * \"size\" can be 0 here legitimately.\n\t * Let it ENOMEM and omit NT_FILE section which will be empty anyway.\n\t */\n\tdata = kvmalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(data))\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = file_path(file, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tkvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* file_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}\n\n#ifdef CORE_DUMP_USE_REGSET\n#include <linux/regset.h>\n\nstruct elf_thread_core_info {\n\tstruct elf_thread_core_info *next;\n\tstruct task_struct *task;\n\tstruct elf_prstatus prstatus;\n\tstruct memelfnote notes[0];\n};\n\nstruct elf_note_info {\n\tstruct elf_thread_core_info *thread;\n\tstruct memelfnote psinfo;\n\tstruct memelfnote signote;\n\tstruct memelfnote auxv;\n\tstruct memelfnote files;\n\tuser_siginfo_t csigdata;\n\tsize_t size;\n\tint thread_notes;\n};\n\n/*\n * When a regset has a writeback hook, we call it on each thread before\n * dumping user memory.  On register window machines, this makes sure the\n * user memory backing the register data is up to date before we read it.\n */\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}\n\n#ifndef PRSTATUS_SIZE\n#define PRSTATUS_SIZE(S, R) sizeof(S)\n#endif\n\n#ifndef SET_PR_FPVALID\n#define SET_PR_FPVALID(S, V, R) ((S)->pr_fpvalid = (V))\n#endif\n\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tunsigned int regset0_size = regset_size(t->task, &view->regsets[0]);\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0], 0, regset0_size,\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset) > 0)) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset_size(t->task, regset);\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus,\n\t\t\t\t\t\t\t1, regset0_size);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct task_struct *dump_task = current;\n\tconst struct user_regset_view *view = task_user_regset_view(dump_task);\n\tstruct elf_thread_core_info *t;\n\tstruct elf_prpsinfo *psinfo;\n\tstruct core_thread *ct;\n\tunsigned int i;\n\n\tinfo->size = 0;\n\tinfo->thread = NULL;\n\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (psinfo == NULL) {\n\t\tinfo->psinfo.data = NULL; /* So we don't free this wrongly */\n\t\treturn 0;\n\t}\n\n\tfill_note(&info->psinfo, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\t/*\n\t * Figure out how many notes we're going to need for each thread.\n\t */\n\tinfo->thread_notes = 0;\n\tfor (i = 0; i < view->n; ++i)\n\t\tif (view->regsets[i].core_note_type != 0)\n\t\t\t++info->thread_notes;\n\n\t/*\n\t * Sanity check.  We rely on regset 0 being in NT_PRSTATUS,\n\t * since it is our one special case.\n\t */\n\tif (unlikely(info->thread_notes == 0) ||\n\t    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Initialize the ELF file header.\n\t */\n\tfill_elf_header(elf, phdrs,\n\t\t\tview->e_machine, view->e_flags);\n\n\t/*\n\t * Allocate a structure for each thread.\n\t */\n\tfor (ct = &dump_task->mm->core_state->dumper; ct; ct = ct->next) {\n\t\tt = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(!t))\n\t\t\treturn 0;\n\n\t\tt->task = ct->task;\n\t\tif (ct->task == dump_task || !info->thread) {\n\t\t\tt->next = info->thread;\n\t\t\tinfo->thread = t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure to keep the original task at\n\t\t\t * the head of the list.\n\t\t\t */\n\t\t\tt->next = info->thread->next;\n\t\t\tinfo->thread->next = t;\n\t\t}\n\t}\n\n\t/*\n\t * Now fill in each thread's information.\n\t */\n\tfor (t = info->thread; t != NULL; t = t->next)\n\t\tif (!fill_thread_core_info(t, view, siginfo->si_signo, &info->size))\n\t\t\treturn 0;\n\n\t/*\n\t * Fill in the two process-wide notes.\n\t */\n\tfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\n\tinfo->size += notesize(&info->psinfo);\n\n\tfill_siginfo_note(&info->signote, &info->csigdata, siginfo);\n\tinfo->size += notesize(&info->signote);\n\n\tfill_auxv_note(&info->auxv, current->mm);\n\tinfo->size += notesize(&info->auxv);\n\n\tif (fill_files_note(&info->files) == 0)\n\t\tinfo->size += notesize(&info->files);\n\n\treturn 1;\n}\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\treturn info->size;\n}\n\n/*\n * Write all the notes for each thread.  When writing the first thread, the\n * process-wide notes are interleaved after the first thread-specific note.\n */\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tbool first = true;\n\tstruct elf_thread_core_info *t = info->thread;\n\n\tdo {\n\t\tint i;\n\n\t\tif (!writenote(&t->notes[0], cprm))\n\t\t\treturn 0;\n\n\t\tif (first && !writenote(&info->psinfo, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->signote, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->auxv, cprm))\n\t\t\treturn 0;\n\t\tif (first && info->files.data &&\n\t\t\t\t!writenote(&info->files, cprm))\n\t\t\treturn 0;\n\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tif (t->notes[i].data &&\n\t\t\t    !writenote(&t->notes[i], cprm))\n\t\t\t\treturn 0;\n\n\t\tfirst = false;\n\t\tt = t->next;\n\t} while (t);\n\n\treturn 1;\n}\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n\tkvfree(info->files.data);\n}\n\n#else\n\n/* Here is the structure in which status of each thread is captured. */\nstruct elf_thread_status\n{\n\tstruct list_head list;\n\tstruct elf_prstatus prstatus;\t/* NT_PRSTATUS */\n\telf_fpregset_t fpu;\t\t/* NT_PRFPREG */\n\tstruct task_struct *thread;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t xfpu;\t\t/* ELF_CORE_XFPREG_TYPE */\n#endif\n\tstruct memelfnote notes[3];\n\tint num_notes;\n};\n\n/*\n * In order to add the specific thread information for the elf file format,\n * we need to keep a linked list of every threads pr_status and then create\n * a single section for them in the final core file.\n */\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}\n\nstruct elf_note_info {\n\tstruct memelfnote *notes;\n\tstruct memelfnote *notes_files;\n\tstruct elf_prstatus *prstatus;\t/* NT_PRSTATUS */\n\tstruct elf_prpsinfo *psinfo;\t/* NT_PRPSINFO */\n\tstruct list_head thread_list;\n\telf_fpregset_t *fpu;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t *xfpu;\n#endif\n\tuser_siginfo_t csigdata;\n\tint thread_status_size;\n\tint numnote;\n};\n\nstatic int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc_array(8, sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each_entry(ets, &info->thread_list, list) {\n\t\tint sz;\n\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tstruct elf_thread_status *ets;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each_entry(ets, &info->thread_list, list) {\n\t\tfor (i = 0; i < ets->num_notes; i++)\n\t\t\tif (!writenote(&ets->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tkvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}\n\n#endif\n\nstatic struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}\n/*\n * Helper function for iterating across a vma list.  It ensures that the caller\n * will visit `gate_vma' prior to terminating the search.\n */\nstatic struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}\n\n/*\n * Actual dumper\n *\n * This is a two-pass process; first we find the offsets of the bits,\n * and then they are actually written out.  If we run out of core limit\n * we just truncate.\n */\nstatic int elf_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs, i;\n\tsize_t vma_data_size = 0;\n\tstruct vm_area_struct *vma, *gate_vma;\n\tstruct elfhdr elf;\n\tloff_t offset = 0, dataoff;\n\tstruct elf_note_info info = { };\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\telf_addr_t *vma_filesz = NULL;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t * \n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n  \n\t/*\n\t * The number of segs are recored into ELF header as 16bit value.\n\t * Please check DEFAULT_MAX_MAP_COUNT definition when you modify here.\n\t */\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\tgate_vma = get_gate_vma(current->mm);\n\tif (gate_vma != NULL)\n\t\tsegs++;\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/*\n\t * Collect all the non-memory information about the process for the\n\t * notes.  This also sets up the file header.\n\t */\n\tif (!fill_note_info(&elf, e_phnum, &info, cprm->siginfo, cprm->regs))\n\t\tgoto cleanup;\n\n\thas_dumped = 1;\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\n\t/* Write notes phdr entry */\n\t{\n\t\tsize_t sz = get_note_info_size(&info);\n\n\t\tsz += elf_coredump_extra_notes_size();\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\t/*\n\t * Zero vma process will get ZERO_SIZE_PTR here.\n\t * Let coredump continue for register state at least.\n\t */\n\tvma_filesz = kvmalloc(array_size(sizeof(*vma_filesz), (segs - 1)),\n\t\t\t      GFP_KERNEL);\n\tif (!vma_filesz)\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long dump_size;\n\n\t\tdump_size = vma_dump_size(vma, cprm->mm_flags);\n\t\tvma_filesz[i++] = dump_size;\n\t\tvma_data_size += dump_size;\n\t}\n\n\toffset += vma_data_size;\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(&elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, &elf, sizeof(elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* Write program headers for segments dump */\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tstruct elf_phdr phdr;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = vma_filesz[i++];\n\t\tphdr.p_memsz = vma->vm_end - vma->vm_start;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tif (!write_note_info(&info, cprm))\n\t\tgoto end_coredump;\n\n\tif (elf_coredump_extra_notes_write(cprm))\n\t\tgoto end_coredump;\n\n\t/* Align to page */\n\tif (!dump_skip(cprm, dataoff - cprm->pos))\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long addr;\n\t\tunsigned long end;\n\n\t\tend = vma->vm_start + vma_filesz[i++];\n\n\t\tfor (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {\n\t\t\tstruct page *page;\n\t\t\tint stop;\n\n\t\t\tpage = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tstop = !dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tput_page(page);\n\t\t\t} else\n\t\t\t\tstop = !dump_skip(cprm, PAGE_SIZE);\n\t\t\tif (stop)\n\t\t\t\tgoto end_coredump;\n\t\t}\n\t}\n\tdump_truncate(cprm);\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\tfree_note_info(&info);\n\tkfree(shdr4extnum);\n\tkvfree(vma_filesz);\n\tkfree(phdr4note);\n\treturn has_dumped;\n}\n\n#endif\t\t/* CONFIG_ELF_CORE */\n\nstatic int __init init_elf_binfmt(void)\n{\n\tregister_binfmt(&elf_format);\n\treturn 0;\n}\n\nstatic void __exit exit_elf_binfmt(void)\n{\n\t/* Remove the COFF and ELF loaders. */\n\tunregister_binfmt(&elf_format);\n}\n\ncore_initcall(init_elf_binfmt);\nmodule_exit(exit_elf_binfmt);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * linux/fs/binfmt_elf.c\n *\n * These are the functions used to load ELF format executables as used\n * on SVr4 machines.  Information on the format may be found in the book\n * \"UNIX SYSTEM V RELEASE 4 Programmers Guide: Ansi C and Programming Support\n * Tools\".\n *\n * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).\n */\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/binfmts.h>\n#include <linux/string.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/personality.h>\n#include <linux/elfcore.h>\n#include <linux/init.h>\n#include <linux/highuid.h>\n#include <linux/compiler.h>\n#include <linux/highmem.h>\n#include <linux/hugetlb.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/random.h>\n#include <linux/elf.h>\n#include <linux/elf-randomize.h>\n#include <linux/utsname.h>\n#include <linux/coredump.h>\n#include <linux/sched.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/cred.h>\n#include <linux/dax.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <asm/page.h>\n\n#ifndef user_long_t\n#define user_long_t long\n#endif\n#ifndef user_siginfo_t\n#define user_siginfo_t siginfo_t\n#endif\n\n/* That's for binfmt_elf_fdpic to deal with */\n#ifndef elf_check_fdpic\n#define elf_check_fdpic(ex) false\n#endif\n\nstatic int load_elf_binary(struct linux_binprm *bprm);\n\n#ifdef CONFIG_USELIB\nstatic int load_elf_library(struct file *);\n#else\n#define load_elf_library NULL\n#endif\n\n/*\n * If we don't support core dumping, then supply a NULL so we\n * don't even try.\n */\n#ifdef CONFIG_ELF_CORE\nstatic int elf_core_dump(struct coredump_params *cprm);\n#else\n#define elf_core_dump\tNULL\n#endif\n\n#if ELF_EXEC_PAGESIZE > PAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n#else\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#endif\n\n#ifndef ELF_CORE_EFLAGS\n#define ELF_CORE_EFLAGS\t0\n#endif\n\n#define ELF_PAGESTART(_v) ((_v) & ~(unsigned long)(ELF_MIN_ALIGN-1))\n#define ELF_PAGEOFFSET(_v) ((_v) & (ELF_MIN_ALIGN-1))\n#define ELF_PAGEALIGN(_v) (((_v) + ELF_MIN_ALIGN - 1) & ~(ELF_MIN_ALIGN - 1))\n\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\n#define BAD_ADDR(x) (unlikely((unsigned long)(x) >= TASK_SIZE))\n\nstatic int set_brk(unsigned long start, unsigned long end, int prot)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\t/*\n\t\t * Map the last of the bss segment.\n\t\t * If the header is requesting these pages to be\n\t\t * executable, honour that (ppc32 needs this).\n\t\t */\n\t\tint error = vm_brk_flags(start, end - start,\n\t\t\t\tprot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}\n\n/* We need to explicitly zero any fractional pages\n   after the data section (i.e. bss).  This would\n   contain the junk from the file that should not\n   be in memory\n */\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n/* Let's use some macros to make this stack manipulation a little clearer */\n#ifdef CONFIG_STACK_GROWSUP\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) + (items))\n#define STACK_ROUND(sp, items) \\\n\t((15 + (unsigned long) ((sp) + (items))) &~ 15UL)\n#define STACK_ALLOC(sp, len) ({ \\\n\telf_addr_t __user *old_sp = (elf_addr_t __user *)sp; sp += len; \\\n\told_sp; })\n#else\n#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) - (items))\n#define STACK_ROUND(sp, items) \\\n\t(((unsigned long) (sp - items)) &~ 15UL)\n#define STACK_ALLOC(sp, len) ({ sp -= len ; sp; })\n#endif\n\n#ifndef ELF_BASE_PLATFORM\n/*\n * AT_BASE_PLATFORM indicates the \"real\" hardware/microarchitecture.\n * If the arch defines ELF_BASE_PLATFORM (in asm/elf.h), the value\n * will be copied to the user stack in the same manner as AT_PLATFORM.\n */\n#define ELF_BASE_PLATFORM NULL\n#endif\n\nstatic int\ncreate_elf_tables(struct linux_binprm *bprm, const struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr,\n\t\tunsigned long e_entry)\n{\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\t*elf_info++ = id; \\\n\t\t*elf_info++ = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n\tNEW_AUX_ENT(AT_SECURE, bprm->secureexec);\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(elf_info, 0, (char *)mm->saved_auxv +\n\t\t\tsizeof(mm->saved_auxv) - (char *)elf_info);\n\n\t/* And advance past the AT_NULL entry.  */\n\telf_info += 2;\n\n\tei_index = elf_info - (elf_addr_t *)mm->saved_auxv;\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\n\t/* Populate list of argv pointers back to argv strings. */\n\tp = mm->arg_end = mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tmm->arg_end = p;\n\n\t/* Populate list of envp pointers back to envp strings. */\n\tmm->env_end = mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, sp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, sp++))\n\t\treturn -EFAULT;\n\tmm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tif (copy_to_user(sp, mm->saved_auxv, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tconst struct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\tif ((type & MAP_FIXED_NOREPLACE) &&\n\t    PTR_ERR((void *)map_addr) == -EEXIST)\n\t\tpr_info(\"%d (%s): Uhuuh, elf segment at %px requested but the memory is mapped already\\n\",\n\t\t\ttask_pid_nr(current), current->comm, (void *)addr);\n\n\treturn(map_addr);\n}\n\nstatic unsigned long total_mapping_size(const struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}\n\nstatic int elf_read(struct file *file, void *buf, size_t len, loff_t pos)\n{\n\tssize_t rv;\n\n\trv = kernel_read(file, buf, len, &pos);\n\tif (unlikely(rv != len)) {\n\t\treturn (rv < 0) ? rv : -EIO;\n\t}\n\treturn 0;\n}\n\n/**\n * load_elf_phdrs() - load ELF program headers\n * @elf_ex:   ELF header of the binary whose program headers should be loaded\n * @elf_file: the opened ELF binary file\n *\n * Loads ELF program headers from the binary file elf_file, which has the ELF\n * header pointed to by elf_ex, into a newly allocated array. The caller is\n * responsible for freeing the allocated data. Returns an ERR_PTR upon failure.\n */\nstatic struct elf_phdr *load_elf_phdrs(const struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, err = -1;\n\tunsigned int size;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size == 0 || size > 65536 || size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = elf_read(elf_file, elf_phdata, size, elf_ex->e_phoff);\n\tif (retval < 0) {\n\t\terr = retval;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}\n\n#ifndef CONFIG_ARCH_BINFMT_ELF_STATE\n\n/**\n * struct arch_elf_state - arch-specific ELF loading state\n *\n * This structure is used to preserve architecture specific data during\n * the loading of an ELF file, throughout the checking of architecture\n * specific ELF headers & through to the point where the ELF load is\n * known to be proceeding (ie. SET_PERSONALITY).\n *\n * This implementation is a dummy for architectures which require no\n * specific state.\n */\nstruct arch_elf_state {\n};\n\n#define INIT_ARCH_ELF_STATE {}\n\n/**\n * arch_elf_pt_proc() - check a PT_LOPROC..PT_HIPROC ELF program header\n * @ehdr:\tThe main ELF header\n * @phdr:\tThe program header to check\n * @elf:\tThe open ELF file\n * @is_interp:\tTrue if the phdr is from the interpreter of the ELF being\n *\t\tloaded, else false.\n * @state:\tArchitecture-specific state preserved throughout the process\n *\t\tof loading the ELF.\n *\n * Inspects the program header phdr to validate its correctness and/or\n * suitability for the system. Called once per ELF program header in the\n * range PT_LOPROC to PT_HIPROC, for both the ELF being loaded and its\n * interpreter.\n *\n * Return: Zero to proceed with the ELF load, non-zero to fail the ELF load\n *         with that return code.\n */\nstatic inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}\n\n/**\n * arch_check_elf() - check an ELF executable\n * @ehdr:\tThe main ELF header\n * @has_interp:\tTrue if the ELF has an interpreter, else false.\n * @interp_ehdr: The interpreter's ELF header\n * @state:\tArchitecture-specific state preserved throughout the process\n *\t\tof loading the ELF.\n *\n * Provides a final opportunity for architecture code to reject the loading\n * of the ELF & cause an exec syscall to return an error. This is called after\n * all program headers to be checked by arch_elf_pt_proc have been.\n *\n * Return: Zero to proceed with the ELF load, non-zero to fail the ELF load\n *         with that return code.\n */\nstatic inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct elfhdr *interp_ehdr,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}\n\n#endif /* !CONFIG_ARCH_BINFMT_ELF_STATE */\n\nstatic inline int make_prot(u32 p_flags)\n{\n\tint prot = 0;\n\n\tif (p_flags & PF_R)\n\t\tprot |= PROT_READ;\n\tif (p_flags & PF_W)\n\t\tprot |= PROT_WRITE;\n\tif (p_flags & PF_X)\n\t\tprot |= PROT_EXEC;\n\treturn prot;\n}\n\n/* This is much more generalized than the library routine read function,\n   so we keep this separate.  Technically the library read function\n   is only provided so that we can read a.out libraries that have\n   an ELF header */\n\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tint bss_prot = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex) ||\n\t    elf_check_fdpic(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = make_prot(eppnt->p_flags);\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED_NOREPLACE;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_memsz;\n\t\t\tif (k > last_bss) {\n\t\t\t\tlast_bss = k;\n\t\t\t\tbss_prot = elf_prot;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now fill out the bss section: first pad the last page from\n\t * the file up to the page boundary, and zero it from elf_bss\n\t * up to the end of the page.\n\t */\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out;\n\t}\n\t/*\n\t * Next, align both the file and mem bss up to the page size,\n\t * since this is where elf_bss was just zeroed up to, and where\n\t * last_bss will end after the vm_brk_flags() below.\n\t */\n\telf_bss = ELF_PAGEALIGN(elf_bss);\n\tlast_bss = ELF_PAGEALIGN(last_bss);\n\t/* Finally, if there is still more bss to allocate, do it. */\n\tif (last_bss > elf_bss) {\n\t\terror = vm_brk_flags(elf_bss, last_bss - elf_bss,\n\t\t\t\tbss_prot & PROT_EXEC ? VM_EXEC : 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}\n\n/*\n * These are the functions used to load ELF style executables and shared\n * libraries.  There is no binary dependent code anywhere else.\n */\n\nstatic int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint bss_prot = 0;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long e_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct elfhdr *elf_ex = (struct elfhdr *)bprm->buf;\n\tstruct elfhdr *interp_elf_ex = NULL;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\tstruct mm_struct *mm;\n\tstruct pt_regs *regs;\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(elf_ex->e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (elf_ex->e_type != ET_EXEC && elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(elf_ex))\n\t\tgoto out;\n\tif (elf_check_fdpic(elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < elf_ex->e_phnum; i++, elf_ppnt++) {\n\t\tchar *elf_interpreter;\n\n\t\tif (elf_ppnt->p_type != PT_INTERP)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This is the program interpreter used for shared libraries -\n\t\t * for now assume that this is an a.out format binary.\n\t\t */\n\t\tretval = -ENOEXEC;\n\t\tif (elf_ppnt->p_filesz > PATH_MAX || elf_ppnt->p_filesz < 2)\n\t\t\tgoto out_free_ph;\n\n\t\tretval = -ENOMEM;\n\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz, GFP_KERNEL);\n\t\tif (!elf_interpreter)\n\t\t\tgoto out_free_ph;\n\n\t\tretval = elf_read(bprm->file, elf_interpreter, elf_ppnt->p_filesz,\n\t\t\t\t  elf_ppnt->p_offset);\n\t\tif (retval < 0)\n\t\t\tgoto out_free_interp;\n\t\t/* make sure path is NULL terminated */\n\t\tretval = -ENOEXEC;\n\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\tgoto out_free_interp;\n\n\t\tinterpreter = open_exec(elf_interpreter);\n\t\tkfree(elf_interpreter);\n\t\tretval = PTR_ERR(interpreter);\n\t\tif (IS_ERR(interpreter))\n\t\t\tgoto out_free_ph;\n\n\t\t/*\n\t\t * If the binary is not readable then enforce mm->dumpable = 0\n\t\t * regardless of the interpreter's permissions.\n\t\t */\n\t\twould_dump(bprm, interpreter);\n\n\t\tinterp_elf_ex = kmalloc(sizeof(*interp_elf_ex), GFP_KERNEL);\n\t\tif (!interp_elf_ex) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_free_ph;\n\t\t}\n\n\t\t/* Get the exec headers */\n\t\tretval = elf_read(interpreter, interp_elf_ex,\n\t\t\t\t  sizeof(*interp_elf_ex), 0);\n\t\tif (retval < 0)\n\t\t\tgoto out_free_dentry;\n\n\t\tbreak;\n\nout_free_interp:\n\t\tkfree(elf_interpreter);\n\t\tgoto out_free_ph;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < elf_ex->e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(interp_elf_ex->e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(interp_elf_ex) ||\n\t\t    elf_check_fdpic(interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(elf_ex,\n\t\t\t\t!!interpreter, interp_elf_ex,\n\t\t\t\t&arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(*elf_ex, &arch_state);\n\tif (elf_read_implies_exec(*elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\tinstall_exec_creds(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < elf_ex->e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot, elf_flags;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias,\n\t\t\t\t\t bss_prot);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telf_prot = make_prot(elf_ppnt->p_flags);\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\t/*\n\t\t * If we are loading ET_EXEC or we have already performed\n\t\t * the ET_DYN load_addr calculations, proceed normally.\n\t\t */\n\t\tif (elf_ex->e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (elf_ex->e_type == ET_DYN) {\n\t\t\t/*\n\t\t\t * This logic is run once for the first LOAD Program\n\t\t\t * Header for ET_DYN binaries to calculate the\n\t\t\t * randomization (load_bias) for all the LOAD\n\t\t\t * Program Headers, and to calculate the entire\n\t\t\t * size of the ELF mapping (total_size). (Note that\n\t\t\t * load_addr_set is set to true later once the\n\t\t\t * initial mapping is performed.)\n\t\t\t *\n\t\t\t * There are effectively two types of ET_DYN\n\t\t\t * binaries: programs (i.e. PIE: ET_DYN with INTERP)\n\t\t\t * and loaders (ET_DYN without INTERP, since they\n\t\t\t * _are_ the ELF interpreter). The loaders must\n\t\t\t * be loaded away from programs since the program\n\t\t\t * may otherwise collide with the loader (especially\n\t\t\t * for ET_EXEC which does not have a randomized\n\t\t\t * position). For example to handle invocations of\n\t\t\t * \"./ld.so someprog\" to test out a new version of\n\t\t\t * the loader, the subsequent program that the\n\t\t\t * loader loads must avoid the loader itself, so\n\t\t\t * they cannot share the same load range. Sufficient\n\t\t\t * room for the brk must be allocated with the\n\t\t\t * loader as well, since brk must be available with\n\t\t\t * the loader.\n\t\t\t *\n\t\t\t * Therefore, programs are loaded offset from\n\t\t\t * ELF_ET_DYN_BASE and loaders are loaded into the\n\t\t\t * independently randomized mmap region (0 load_bias\n\t\t\t * without MAP_FIXED).\n\t\t\t */\n\t\t\tif (interpreter) {\n\t\t\t\tload_bias = ELF_ET_DYN_BASE;\n\t\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\t\tload_bias += arch_mmap_rnd();\n\t\t\t\telf_flags |= MAP_FIXED;\n\t\t\t} else\n\t\t\t\tload_bias = 0;\n\n\t\t\t/*\n\t\t\t * Since load_bias is used for all subsequent loading\n\t\t\t * calculations, we must lower it by the first vaddr\n\t\t\t * so that the remaining calculations based on the\n\t\t\t * ELF vaddrs will be correctly offset. The result\n\t\t\t * is then page aligned.\n\t\t\t */\n\t\t\tload_bias = ELF_PAGESTART(load_bias - vaddr);\n\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\telf_ex->e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif ((elf_ppnt->p_flags & PF_X) && k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk) {\n\t\t\tbss_prot = elf_prot;\n\t\t\telf_brk = k;\n\t\t}\n\t}\n\n\te_entry = elf_ex->e_entry + load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk, bss_prot);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (interpreter) {\n\t\telf_entry = load_elf_interp(interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += interp_elf_ex->e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\n\t\tkfree(interp_elf_ex);\n\t\tkfree(interp_elf_phdata);\n\t} else {\n\t\telf_entry = e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tretval = create_elf_tables(bprm, elf_ex,\n\t\t\t  load_addr, interp_load_addr, e_entry);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tmm = current->mm;\n\tmm->end_code = end_code;\n\tmm->start_code = start_code;\n\tmm->start_data = start_data;\n\tmm->end_data = end_data;\n\tmm->start_stack = bprm->p;\n\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\t/*\n\t\t * For architectures with ELF randomization, when executing\n\t\t * a loader directly (i.e. no interpreter listed in ELF\n\t\t * headers), move the brk area out of the mmap region\n\t\t * (since it grows up, and may collide early with the stack\n\t\t * growing down), and into the unused ELF_ET_DYN_BASE region.\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_ARCH_HAS_ELF_RANDOMIZE) &&\n\t\t    elf_ex->e_type == ET_DYN && !interpreter) {\n\t\t\tmm->brk = mm->start_brk = ELF_ET_DYN_BASE;\n\t\t}\n\n\t\tmm->brk = mm->start_brk = arch_randomize_brk(mm);\n#ifdef compat_brk_randomized\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n\tregs = current_pt_regs();\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tfinalize_exec(bprm);\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_ex);\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}\n\n#ifdef CONFIG_USELIB\n/* This is really simpleminded and specialized - we are loading an\n   a.out library that is given an ELF header. */\nstatic int load_elf_library(struct file *file)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long elf_bss, bss, len;\n\tint retval, error, i, j;\n\tstruct elfhdr elf_ex;\n\n\terror = -ENOEXEC;\n\tretval = elf_read(file, &elf_ex, sizeof(elf_ex), 0);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* First of all, some simple consistency checks */\n\tif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\n\t    !elf_check_arch(&elf_ex) || !file->f_op->mmap)\n\t\tgoto out;\n\tif (elf_check_fdpic(&elf_ex))\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\n\tj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\n\t/* j < ELF_MIN_ALIGN because elf_ex.e_phnum <= 2 */\n\n\terror = -ENOMEM;\n\telf_phdata = kmalloc(j, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\teppnt = elf_phdata;\n\terror = -ENOEXEC;\n\tretval = elf_read(file, eppnt, j, elf_ex.e_phoff);\n\tif (retval < 0)\n\t\tgoto out_free_ph;\n\n\tfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\n\t\tif ((eppnt + i)->p_type == PT_LOAD)\n\t\t\tj++;\n\tif (j != 1)\n\t\tgoto out_free_ph;\n\n\twhile (eppnt->p_type != PT_LOAD)\n\t\teppnt++;\n\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file,\n\t\t\tELF_PAGESTART(eppnt->p_vaddr),\n\t\t\t(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)),\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED_NOREPLACE | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\t(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)));\n\tif (error != ELF_PAGESTART(eppnt->p_vaddr))\n\t\tgoto out_free_ph;\n\n\telf_bss = eppnt->p_vaddr + eppnt->p_filesz;\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free_ph;\n\t}\n\n\tlen = ELF_PAGEALIGN(eppnt->p_filesz + eppnt->p_vaddr);\n\tbss = ELF_PAGEALIGN(eppnt->p_memsz + eppnt->p_vaddr);\n\tif (bss > len) {\n\t\terror = vm_brk(len, bss - len);\n\t\tif (error)\n\t\t\tgoto out_free_ph;\n\t}\n\terror = 0;\n\nout_free_ph:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}\n#endif /* #ifdef CONFIG_USELIB */\n\n#ifdef CONFIG_ELF_CORE\n/*\n * ELF core dumper\n *\n * Modelled on fs/exec.c:aout_core_dump()\n * Jeremy Fitzhardinge <jeremy@sw.oz.au>\n */\n\n/*\n * The purpose of always_dump_vma() is to make sure that special kernel mappings\n * that are useful for post-mortem analysis are included in every core dump.\n * In that way we ensure that the core dump is fully interpretable later\n * without matching up the same kernel and hardware config to see what PC values\n * meant. These special mappings include - vDSO, vsyscall, and other\n * architecture specific mappings\n */\nstatic bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * Decide what to dump of a segment, part, all or none.\n */\nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* support for DAX */\n\tif (vma_is_dax(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(DAX_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(DAX_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Hugetlb memory check */\n\tif (is_vm_hugetlb_page(vma)) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}\n\n/* An ELF note in memory */\nstruct memelfnote\n{\n\tconst char *name;\n\tint type;\n\tunsigned int datasz;\n\tvoid *data;\n};\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n}\n\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n}\n\nstatic void fill_note(struct memelfnote *note, const char *name, int type, \n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n}\n\n/*\n * fill up all the fields in prstatus from the given task struct, except\n * registers which need to be filled up separately.\n */\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tprstatus->pr_utime = ns_to_kernel_old_timeval(cputime.utime);\n\t\tprstatus->pr_stime = ns_to_kernel_old_timeval(cputime.stime);\n\t} else {\n\t\tu64 utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tprstatus->pr_utime = ns_to_kernel_old_timeval(utime);\n\t\tprstatus->pr_stime = ns_to_kernel_old_timeval(stime);\n\t}\n\n\tprstatus->pr_cutime = ns_to_kernel_old_timeval(p->signal->cutime);\n\tprstatus->pr_cstime = ns_to_kernel_old_timeval(p->signal->cstime);\n}\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}\n\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst kernel_siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}\n\n#define MAX_FILE_NOTE_SIZE (4*1024*1024)\n/*\n * Format of NT_FILE note:\n *\n * long count     -- how many files are mapped\n * long page_size -- units for file_ofs\n * array of [COUNT] elements of\n *   long start\n *   long end\n *   long file_ofs\n * followed by COUNT filenames in ASCII: \"FILE1\" NUL \"FILE2\" NUL...\n */\nstatic int fill_files_note(struct memelfnote *note)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = mm->map_count;\n\tif (count > UINT_MAX / 64)\n\t\treturn -EINVAL;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\t/*\n\t * \"size\" can be 0 here legitimately.\n\t * Let it ENOMEM and omit NT_FILE section which will be empty anyway.\n\t */\n\tdata = kvmalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(data))\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = file_path(file, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tkvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* file_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}\n\n#ifdef CORE_DUMP_USE_REGSET\n#include <linux/regset.h>\n\nstruct elf_thread_core_info {\n\tstruct elf_thread_core_info *next;\n\tstruct task_struct *task;\n\tstruct elf_prstatus prstatus;\n\tstruct memelfnote notes[0];\n};\n\nstruct elf_note_info {\n\tstruct elf_thread_core_info *thread;\n\tstruct memelfnote psinfo;\n\tstruct memelfnote signote;\n\tstruct memelfnote auxv;\n\tstruct memelfnote files;\n\tuser_siginfo_t csigdata;\n\tsize_t size;\n\tint thread_notes;\n};\n\n/*\n * When a regset has a writeback hook, we call it on each thread before\n * dumping user memory.  On register window machines, this makes sure the\n * user memory backing the register data is up to date before we read it.\n */\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}\n\n#ifndef PRSTATUS_SIZE\n#define PRSTATUS_SIZE(S, R) sizeof(S)\n#endif\n\n#ifndef SET_PR_FPVALID\n#define SET_PR_FPVALID(S, V, R) ((S)->pr_fpvalid = (V))\n#endif\n\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tunsigned int regset0_size = regset_size(t->task, &view->regsets[0]);\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0], 0, regset0_size,\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset) > 0)) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset_size(t->task, regset);\n\t\t\tvoid *data = kzalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus,\n\t\t\t\t\t\t\t1, regset0_size);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct task_struct *dump_task = current;\n\tconst struct user_regset_view *view = task_user_regset_view(dump_task);\n\tstruct elf_thread_core_info *t;\n\tstruct elf_prpsinfo *psinfo;\n\tstruct core_thread *ct;\n\tunsigned int i;\n\n\tinfo->size = 0;\n\tinfo->thread = NULL;\n\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (psinfo == NULL) {\n\t\tinfo->psinfo.data = NULL; /* So we don't free this wrongly */\n\t\treturn 0;\n\t}\n\n\tfill_note(&info->psinfo, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\t/*\n\t * Figure out how many notes we're going to need for each thread.\n\t */\n\tinfo->thread_notes = 0;\n\tfor (i = 0; i < view->n; ++i)\n\t\tif (view->regsets[i].core_note_type != 0)\n\t\t\t++info->thread_notes;\n\n\t/*\n\t * Sanity check.  We rely on regset 0 being in NT_PRSTATUS,\n\t * since it is our one special case.\n\t */\n\tif (unlikely(info->thread_notes == 0) ||\n\t    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Initialize the ELF file header.\n\t */\n\tfill_elf_header(elf, phdrs,\n\t\t\tview->e_machine, view->e_flags);\n\n\t/*\n\t * Allocate a structure for each thread.\n\t */\n\tfor (ct = &dump_task->mm->core_state->dumper; ct; ct = ct->next) {\n\t\tt = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(!t))\n\t\t\treturn 0;\n\n\t\tt->task = ct->task;\n\t\tif (ct->task == dump_task || !info->thread) {\n\t\t\tt->next = info->thread;\n\t\t\tinfo->thread = t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure to keep the original task at\n\t\t\t * the head of the list.\n\t\t\t */\n\t\t\tt->next = info->thread->next;\n\t\t\tinfo->thread->next = t;\n\t\t}\n\t}\n\n\t/*\n\t * Now fill in each thread's information.\n\t */\n\tfor (t = info->thread; t != NULL; t = t->next)\n\t\tif (!fill_thread_core_info(t, view, siginfo->si_signo, &info->size))\n\t\t\treturn 0;\n\n\t/*\n\t * Fill in the two process-wide notes.\n\t */\n\tfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\n\tinfo->size += notesize(&info->psinfo);\n\n\tfill_siginfo_note(&info->signote, &info->csigdata, siginfo);\n\tinfo->size += notesize(&info->signote);\n\n\tfill_auxv_note(&info->auxv, current->mm);\n\tinfo->size += notesize(&info->auxv);\n\n\tif (fill_files_note(&info->files) == 0)\n\t\tinfo->size += notesize(&info->files);\n\n\treturn 1;\n}\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\treturn info->size;\n}\n\n/*\n * Write all the notes for each thread.  When writing the first thread, the\n * process-wide notes are interleaved after the first thread-specific note.\n */\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tbool first = true;\n\tstruct elf_thread_core_info *t = info->thread;\n\n\tdo {\n\t\tint i;\n\n\t\tif (!writenote(&t->notes[0], cprm))\n\t\t\treturn 0;\n\n\t\tif (first && !writenote(&info->psinfo, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->signote, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->auxv, cprm))\n\t\t\treturn 0;\n\t\tif (first && info->files.data &&\n\t\t\t\t!writenote(&info->files, cprm))\n\t\t\treturn 0;\n\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tif (t->notes[i].data &&\n\t\t\t    !writenote(&t->notes[i], cprm))\n\t\t\t\treturn 0;\n\n\t\tfirst = false;\n\t\tt = t->next;\n\t} while (t);\n\n\treturn 1;\n}\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n\tkvfree(info->files.data);\n}\n\n#else\n\n/* Here is the structure in which status of each thread is captured. */\nstruct elf_thread_status\n{\n\tstruct list_head list;\n\tstruct elf_prstatus prstatus;\t/* NT_PRSTATUS */\n\telf_fpregset_t fpu;\t\t/* NT_PRFPREG */\n\tstruct task_struct *thread;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t xfpu;\t\t/* ELF_CORE_XFPREG_TYPE */\n#endif\n\tstruct memelfnote notes[3];\n\tint num_notes;\n};\n\n/*\n * In order to add the specific thread information for the elf file format,\n * we need to keep a linked list of every threads pr_status and then create\n * a single section for them in the final core file.\n */\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}\n\nstruct elf_note_info {\n\tstruct memelfnote *notes;\n\tstruct memelfnote *notes_files;\n\tstruct elf_prstatus *prstatus;\t/* NT_PRSTATUS */\n\tstruct elf_prpsinfo *psinfo;\t/* NT_PRPSINFO */\n\tstruct list_head thread_list;\n\telf_fpregset_t *fpu;\n#ifdef ELF_CORE_COPY_XFPREGS\n\telf_fpxregset_t *xfpu;\n#endif\n\tuser_siginfo_t csigdata;\n\tint thread_status_size;\n\tint numnote;\n};\n\nstatic int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc_array(8, sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const kernel_siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each_entry(ets, &info->thread_list, list) {\n\t\tint sz;\n\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tstruct elf_thread_status *ets;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each_entry(ets, &info->thread_list, list) {\n\t\tfor (i = 0; i < ets->num_notes; i++)\n\t\t\tif (!writenote(&ets->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tkvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}\n\n#endif\n\nstatic struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}\n/*\n * Helper function for iterating across a vma list.  It ensures that the caller\n * will visit `gate_vma' prior to terminating the search.\n */\nstatic struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}\n\n/*\n * Actual dumper\n *\n * This is a two-pass process; first we find the offsets of the bits,\n * and then they are actually written out.  If we run out of core limit\n * we just truncate.\n */\nstatic int elf_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs, i;\n\tsize_t vma_data_size = 0;\n\tstruct vm_area_struct *vma, *gate_vma;\n\tstruct elfhdr elf;\n\tloff_t offset = 0, dataoff;\n\tstruct elf_note_info info = { };\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\telf_addr_t *vma_filesz = NULL;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t * \n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n  \n\t/*\n\t * The number of segs are recored into ELF header as 16bit value.\n\t * Please check DEFAULT_MAX_MAP_COUNT definition when you modify here.\n\t */\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\tgate_vma = get_gate_vma(current->mm);\n\tif (gate_vma != NULL)\n\t\tsegs++;\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/*\n\t * Collect all the non-memory information about the process for the\n\t * notes.  This also sets up the file header.\n\t */\n\tif (!fill_note_info(&elf, e_phnum, &info, cprm->siginfo, cprm->regs))\n\t\tgoto cleanup;\n\n\thas_dumped = 1;\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\n\t/* Write notes phdr entry */\n\t{\n\t\tsize_t sz = get_note_info_size(&info);\n\n\t\tsz += elf_coredump_extra_notes_size();\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\t/*\n\t * Zero vma process will get ZERO_SIZE_PTR here.\n\t * Let coredump continue for register state at least.\n\t */\n\tvma_filesz = kvmalloc(array_size(sizeof(*vma_filesz), (segs - 1)),\n\t\t\t      GFP_KERNEL);\n\tif (!vma_filesz)\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long dump_size;\n\n\t\tdump_size = vma_dump_size(vma, cprm->mm_flags);\n\t\tvma_filesz[i++] = dump_size;\n\t\tvma_data_size += dump_size;\n\t}\n\n\toffset += vma_data_size;\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(&elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, &elf, sizeof(elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* Write program headers for segments dump */\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tstruct elf_phdr phdr;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = vma_filesz[i++];\n\t\tphdr.p_memsz = vma->vm_end - vma->vm_start;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tif (!write_note_info(&info, cprm))\n\t\tgoto end_coredump;\n\n\tif (elf_coredump_extra_notes_write(cprm))\n\t\tgoto end_coredump;\n\n\t/* Align to page */\n\tif (!dump_skip(cprm, dataoff - cprm->pos))\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long addr;\n\t\tunsigned long end;\n\n\t\tend = vma->vm_start + vma_filesz[i++];\n\n\t\tfor (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {\n\t\t\tstruct page *page;\n\t\t\tint stop;\n\n\t\t\tpage = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tstop = !dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tput_page(page);\n\t\t\t} else\n\t\t\t\tstop = !dump_skip(cprm, PAGE_SIZE);\n\t\t\tif (stop)\n\t\t\t\tgoto end_coredump;\n\t\t}\n\t}\n\tdump_truncate(cprm);\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\tfree_note_info(&info);\n\tkfree(shdr4extnum);\n\tkvfree(vma_filesz);\n\tkfree(phdr4note);\n\treturn has_dumped;\n}\n\n#endif\t\t/* CONFIG_ELF_CORE */\n\nstatic int __init init_elf_binfmt(void)\n{\n\tregister_binfmt(&elf_format);\n\treturn 0;\n}\n\nstatic void __exit exit_elf_binfmt(void)\n{\n\t/* Remove the COFF and ELF loaders. */\n\tunregister_binfmt(&elf_format);\n}\n\ncore_initcall(init_elf_binfmt);\nmodule_exit(exit_elf_binfmt);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["fs/binfmt_elf.c"], "buggy_code_start_loc": [1732], "buggy_code_end_loc": [1733], "fixing_code_start_loc": [1732], "fixing_code_end_loc": [1733], "type": "CWE-908", "message": "A flaw was found in the Linux kernel's implementation of Userspace core dumps. This flaw allows an attacker with a local account to crash a trivial program and exfiltrate private kernel data.", "other": {"cve": {"id": "CVE-2020-10732", "sourceIdentifier": "secalert@redhat.com", "published": "2020-06-12T14:15:11.277", "lastModified": "2023-06-06T13:46:20.090", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the Linux kernel's implementation of Userspace core dumps. This flaw allows an attacker with a local account to crash a trivial program and exfiltrate private kernel data."}, {"lang": "es", "value": "Se encontr\u00f3 un fallo en la implementaci\u00f3n de los volcados de n\u00facleo del Userspace del kernel de Linux. Este fallo permite a un atacante con una cuenta local bloquear un programa trivial y exfiltrar datos privados del kernel"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.16.85", "matchCriteriaId": "4F9567FB-F394-443B-9A95-1DA060A9CCA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4", "versionEndExcluding": "4.4.226", "matchCriteriaId": "73253D32-56D4-437F-A88C-25D7A631AA5C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.9", "versionEndExcluding": "4.9.226", "matchCriteriaId": "C08B096E-3683-410F-8B4F-B4A9C9A1A57E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14", "versionEndExcluding": "4.14.183", "matchCriteriaId": "05BF7F52-27D8-4903-8006-5890E8F01ECE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.19", "versionEndExcluding": "4.19.126", "matchCriteriaId": "8A296354-CF5F-4631-8F36-7C4C8F3452C6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4", "versionEndExcluding": "5.4.44", "matchCriteriaId": "381D2366-9899-4AFC-A83A-A2883EE78FA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.6", "versionEndExcluding": "5.6.16", "matchCriteriaId": "FA20E67F-6725-42A2-92B6-498AFAC5CD22"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:*:*:*:*:*:vmware_vsphere:*:*", "versionStartIncluding": "9.5", "matchCriteriaId": "0CB28AF5-5AF0-4475-A7B6-12E1795FFDCB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:aff_a700_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D951E97B-FA55-4F47-86DD-856A71C66379"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:aff_a700:-:*:*:*:*:*:*:*", "matchCriteriaId": "51DCEEBB-A1E0-4BE8-B5DB-5CD0E125C79D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:aff_8300_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "CA79D39A-A5F2-4C44-A805-5113065F8C25"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:aff_8300:-:*:*:*:*:*:*:*", "matchCriteriaId": "4CA55FBD-6EBA-49C8-92BA-2B1BCCB18A3A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:aff_8700_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "70ECC434-DF20-49A6-B4CF-D5CCA480E57D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:aff_8700:-:*:*:*:*:*:*:*", "matchCriteriaId": "232DC609-8023-41F9-8CE3-1B31CE2F2D93"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:aff_a400_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56FD9B9A-BBE5-4CA5-B9F9-B16E1FE738C8"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:aff_a400:-:*:*:*:*:*:*:*", "matchCriteriaId": "F3E70A56-DBA8-45C7-8C49-1A036501156F"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-06/msg00022.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00008.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2020-10732", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?id=aca969cacf07f41070d788ce2b8ca71f09d5207d", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/google/kmsan/issues/76", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ruscur/linux/commit/a95cdec9fa0c08e6eeb410d461c03af8fd1fef0a", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/lkml/CAG_fn=VZZ7yUxtOGzuTLkr7wmfXWtKK9BHHYawj=rt9XWnCYvg%40mail.gmail.com/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210129-0005/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://twitter.com/grsecurity/status/1252558055629299712", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4411-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4427-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4439-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4440-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4485-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ruscur/linux/commit/a95cdec9fa0c08e6eeb410d461c03af8fd1fef0a"}}