{"buggy_code": ["'use strict'\n\nconst Router = require('express').Router\nconst formidable = require('formidable')\nconst path = require('path')\nconst fs = require('fs')\nconst os = require('os')\nconst rimraf = require('rimraf')\nconst isSvg = require('is-svg')\n\nconst config = require('../../config')\nconst logger = require('../../logger')\nconst errors = require('../../errors')\n\nconst imageRouter = (module.exports = Router())\n\nasync function checkUploadType (filePath) {\n  const extension = path.extname(filePath).toLowerCase()\n  const FileType = await import('file-type')\n  let typeFromMagic = await FileType.fileTypeFromFile(filePath)\n  if (extension === '.svg' && (typeFromMagic === undefined || typeFromMagic.mime === 'application/xml')) {\n    const fileContent = fs.readFileSync(filePath)\n    if (isSvg(fileContent)) {\n      typeFromMagic = {\n        ext: 'svg',\n        mime: 'image/svg+xml'\n      }\n    }\n  }\n  if (typeFromMagic === undefined) {\n    logger.error('Image upload error: Could not determine MIME-type')\n    return false\n  }\n  // .jpeg, .jfif, .jpe files are identified by FileType to have the extension jpg\n  if (['.jpeg', '.jfif', '.jpe'].includes(extension) && typeFromMagic.ext === 'jpg') {\n    typeFromMagic.ext = extension.substr(1)\n  }\n  if (extension !== '.' + typeFromMagic.ext) {\n    logger.error(\n      'Image upload error: Provided file extension does not match MIME-type'\n    )\n    return false\n  }\n  if (!config.allowedUploadMimeTypes.includes(typeFromMagic.mime)) {\n    logger.error(\n      `Image upload error: MIME-type \"${\n        typeFromMagic.mime\n      }\" of uploaded file not allowed, only \"${config.allowedUploadMimeTypes.join(\n        ', '\n      )}\" are allowed`\n    )\n    return false\n  }\n  return true\n}\n\n// upload image\nimageRouter.post('/uploadimage', function (req, res) {\n  if (\n    !req.isAuthenticated() &&\n    !config.allowAnonymous &&\n    !config.allowAnonymousEdits\n  ) {\n    logger.error(\n      'Image upload error: Anonymous edits and therefore uploads are not allowed'\n    )\n    return errors.errorForbidden(res)\n  }\n\n  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'hedgedoc-'))\n  const form = formidable({\n    keepExtensions: true,\n    uploadDir: tmpDir\n  })\n\n  form.parse(req, async function (err, fields, files) {\n    if (err) {\n      logger.error(`Image upload error: formidable error: ${err}`)\n      rimraf(tmpDir)\n      return errors.errorForbidden(res)\n    } else if (!files.image || !files.image.filepath) {\n      logger.error(\"Image upload error: Upload didn't contain file)\")\n      rimraf.sync(tmpDir)\n      return errors.errorBadRequest(res)\n    } else if (!(await checkUploadType(files.image.filepath))) {\n      rimraf.sync(tmpDir)\n      return errors.errorBadRequest(res)\n    } else {\n      logger.debug(\n        `SERVER received uploadimage: ${JSON.stringify(files.image)}`\n      )\n\n      const uploadProvider = require('./' + config.imageUploadType)\n      logger.debug(\n        `imageRouter: Uploading ${files.image.filepath} using ${config.imageUploadType}`\n      )\n      uploadProvider.uploadImage(files.image.filepath, function (err, url) {\n        rimraf.sync(tmpDir)\n        if (err !== null) {\n          logger.error(err)\n          return res.status(500).end('upload image error')\n        }\n        logger.debug(`SERVER sending ${url} to client`)\n        res.send({\n          link: url\n        })\n      })\n    }\n  })\n})\n"], "fixing_code": ["'use strict'\n\nconst Router = require('express').Router\nconst formidable = require('formidable')\nconst path = require('path')\nconst fs = require('fs')\nconst { v4: uuidv4 } = require('uuid');\nconst os = require('os')\nconst rimraf = require('rimraf')\nconst isSvg = require('is-svg')\n\nconst config = require('../../config')\nconst logger = require('../../logger')\nconst errors = require('../../errors')\n\nconst imageRouter = (module.exports = Router())\n\nasync function checkUploadType (filePath) {\n  const extension = path.extname(filePath).toLowerCase()\n  const FileType = await import('file-type')\n  let typeFromMagic = await FileType.fileTypeFromFile(filePath)\n  if (extension === '.svg' && (typeFromMagic === undefined || typeFromMagic.mime === 'application/xml')) {\n    const fileContent = fs.readFileSync(filePath)\n    if (isSvg(fileContent)) {\n      typeFromMagic = {\n        ext: 'svg',\n        mime: 'image/svg+xml'\n      }\n    }\n  }\n  if (typeFromMagic === undefined) {\n    logger.error('Image upload error: Could not determine MIME-type')\n    return false\n  }\n  // .jpeg, .jfif, .jpe files are identified by FileType to have the extension jpg\n  if (['.jpeg', '.jfif', '.jpe'].includes(extension) && typeFromMagic.ext === 'jpg') {\n    typeFromMagic.ext = extension.substr(1)\n  }\n  if (extension !== '.' + typeFromMagic.ext) {\n    logger.error(\n      'Image upload error: Provided file extension does not match MIME-type'\n    )\n    return false\n  }\n  if (!config.allowedUploadMimeTypes.includes(typeFromMagic.mime)) {\n    logger.error(\n      `Image upload error: MIME-type \"${\n        typeFromMagic.mime\n      }\" of uploaded file not allowed, only \"${config.allowedUploadMimeTypes.join(\n        ', '\n      )}\" are allowed`\n    )\n    return false\n  }\n  return true\n}\n\n// upload image\nimageRouter.post('/uploadimage', function (req, res) {\n  if (\n    !req.isAuthenticated() &&\n    !config.allowAnonymous &&\n    !config.allowAnonymousEdits\n  ) {\n    logger.error(\n      'Image upload error: Anonymous edits and therefore uploads are not allowed'\n    )\n    return errors.errorForbidden(res)\n  }\n\n  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'hedgedoc-'))\n  const form = formidable({\n    keepExtensions: true,\n    uploadDir: tmpDir,\n    filename: function(filename, ext) {\n        if (typeof ext !== \"string\") {\n            ext = \".invalid\"\n        }\n        return uuidv4() + ext\n    }\n  })\n\n  form.parse(req, async function (err, fields, files) {\n    if (err) {\n      logger.error(`Image upload error: formidable error: ${err}`)\n      rimraf(tmpDir)\n      return errors.errorForbidden(res)\n    } else if (!files.image || !files.image.filepath) {\n      logger.error(\"Image upload error: Upload didn't contain file)\")\n      rimraf.sync(tmpDir)\n      return errors.errorBadRequest(res)\n    } else if (!(await checkUploadType(files.image.filepath))) {\n      rimraf.sync(tmpDir)\n      return errors.errorBadRequest(res)\n    } else {\n      logger.debug(\n        `SERVER received uploadimage: ${JSON.stringify(files.image)}`\n      )\n\n      const uploadProvider = require('./' + config.imageUploadType)\n      logger.debug(\n        `imageRouter: Uploading ${files.image.filepath} using ${config.imageUploadType}`\n      )\n      uploadProvider.uploadImage(files.image.filepath, function (err, url) {\n        rimraf.sync(tmpDir)\n        if (err !== null) {\n          logger.error(err)\n          return res.status(500).end('upload image error')\n        }\n        logger.debug(`SERVER sending ${url} to client`)\n        res.send({\n          link: url\n        })\n      })\n    }\n  })\n})\n"], "filenames": ["lib/web/imageRouter/index.js"], "buggy_code_start_loc": [6], "buggy_code_end_loc": [74], "fixing_code_start_loc": [7], "fixing_code_end_loc": [81], "type": "CWE-434", "message": "HedgeDoc is an open-source, web-based, self-hosted, collaborative markdown editor. Images uploaded with HedgeDoc version 1.9.1 and later have an enumerable filename after the upload, resulting in potential information leakage of uploaded documents. This is especially relevant for private notes and affects all upload backends, except Lutim and imgur. This issue is patched in version 1.9.3 by replacing the filename generation with UUIDv4. If you cannot upgrade to HedgeDoc 1.9.3, it is possible to block POST requests to `/uploadimage`, which will disable future uploads.", "other": {"cve": {"id": "CVE-2022-24837", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-11T21:15:08.703", "lastModified": "2022-04-19T15:30:34.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HedgeDoc is an open-source, web-based, self-hosted, collaborative markdown editor. Images uploaded with HedgeDoc version 1.9.1 and later have an enumerable filename after the upload, resulting in potential information leakage of uploaded documents. This is especially relevant for private notes and affects all upload backends, except Lutim and imgur. This issue is patched in version 1.9.3 by replacing the filename generation with UUIDv4. If you cannot upgrade to HedgeDoc 1.9.3, it is possible to block POST requests to `/uploadimage`, which will disable future uploads."}, {"lang": "es", "value": "HedgeDoc es un editor de c\u00f3digo abierto, basado en la web, auto-alojado y colaborativo. Las im\u00e1genes subidas con HedgeDoc versiones 1.9.1 y posteriores, presentan un nombre de archivo enumerable despu\u00e9s de la subida, resultando en un potencial filtrado de informaci\u00f3n de los documentos subidos. Esto es especialmente relevante para las notas privadas y afecta a todos los backends de subida, excepto Lutim e imgur. Este problema ha sido corregido en versi\u00f3n 1.9.3, al sustituir la generaci\u00f3n de nombres de archivo por UUIDv4. Si no puedes actualizar a HedgeDoc versi\u00f3n 1.9.3, es posible bloquear las peticiones POST a \"/uploadimage\", lo que deshabilitar\u00e1 futuras subidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hedgedoc:hedgedoc:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.9.1", "versionEndExcluding": "1.9.3", "matchCriteriaId": "5ED58E51-742B-41E3-8526-5CA73D46E4FE"}]}]}], "references": [{"url": "https://github.com/hedgedoc/hedgedoc/commit/9e2f9e21e904c4a319e84265da7ef03b0a8e343a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hedgedoc/hedgedoc/security/advisories/GHSA-q6vv-2q26-j7rx", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/node-formidable/formidable/issues/808", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hedgedoc/hedgedoc/commit/9e2f9e21e904c4a319e84265da7ef03b0a8e343a"}}