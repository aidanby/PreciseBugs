{"buggy_code": ["local utils = require 'mp.utils'\nlocal msg = require 'mp.msg'\nlocal options = require 'mp.options'\n\nlocal o = {\n    exclude = \"\",\n    try_ytdl_first = false\n}\noptions.read_options(o)\n\nlocal ytdl = {\n    path = \"youtube-dl\",\n    searched = false,\n    blacklisted = {}\n}\n\nlocal chapter_list = {}\n\nlocal function exec(args)\n    local ret = utils.subprocess({args = args})\n    return ret.status, ret.stdout, ret\nend\n\n-- return true if it was explicitly set on the command line\nlocal function option_was_set(name)\n    return mp.get_property_bool(\"option-info/\" ..name.. \"/set-from-commandline\",\n                                false)\nend\n\n-- return true if the option was set locally\nlocal function option_was_set_locally(name)\n    return mp.get_property_bool(\"option-info/\" ..name.. \"/set-locally\", false)\nend\n\n-- youtube-dl may set special http headers for some sites (user-agent, cookies)\nlocal function set_http_headers(http_headers)\n    if not http_headers then\n        return\n    end\n    local headers = {}\n    local useragent = http_headers[\"User-Agent\"]\n    if useragent and not option_was_set(\"user-agent\") then\n        mp.set_property(\"file-local-options/user-agent\", useragent)\n    end\n    local additional_fields = {\"Cookie\", \"Referer\", \"X-Forwarded-For\"}\n    for idx, item in pairs(additional_fields) do\n        local field_value = http_headers[item]\n        if field_value then\n            headers[#headers + 1] = item .. \": \" .. field_value\n        end\n    end\n    if #headers > 0 and not option_was_set(\"http-header-fields\") then\n        mp.set_property_native(\"file-local-options/http-header-fields\", headers)\n    end\nend\n\nlocal function append_rtmp_prop(props, name, value)\n    if not name or not value then\n        return props\n    end\n\n    if props and props ~= \"\" then\n        props = props..\",\"\n    else\n        props = \"\"\n    end\n\n    return props..name..\"=\\\"\"..value..\"\\\"\"\nend\n\nlocal function edl_escape(url)\n    return \"%\" .. string.len(url) .. \"%\" .. url\nend\n\nlocal function time_to_secs(time_string)\n    local ret\n\n    local a, b, c = time_string:match(\"(%d+):(%d%d?):(%d%d)\")\n    if a ~= nil then\n        ret = (a*3600 + b*60 + c)\n    else\n        a, b = time_string:match(\"(%d%d?):(%d%d)\")\n        if a ~= nil then\n            ret = (a*60 + b)\n        end\n    end\n\n    return ret\nend\n\nlocal function extract_chapters(data, video_length)\n    local ret = {}\n\n    for line in data:gmatch(\"[^\\r\\n]+\") do\n        local time = time_to_secs(line)\n        if time and (time < video_length) then\n            table.insert(ret, {time = time, title = line})\n        end\n    end\n    table.sort(ret, function(a, b) return a.time < b.time end)\n    return ret\nend\n\nlocal function is_blacklisted(url)\n    if o.exclude == \"\" then return false end\n    if #ytdl.blacklisted == 0 then\n        local joined = o.exclude\n        while joined:match('%|?[^|]+') do\n            local _, e, substring = joined:find('%|?([^|]+)')\n            table.insert(ytdl.blacklisted, substring)\n            joined = joined:sub(e+1)\n        end\n    end\n    if #ytdl.blacklisted > 0 then\n        url = url:match('https?://(.+)')\n        for _, exclude in ipairs(ytdl.blacklisted) do\n            if url:match(exclude) then\n                msg.verbose('URL matches excluded substring. Skipping.')\n                return true\n            end\n        end\n    end\n    return false\nend\n\nlocal function make_absolute_url(base_url, url)\n    if url:find(\"https?://\") == 1 then return url end\n\n    local proto, domain, rest =\n        base_url:match(\"(https?://)([^/]+/)(.*)/?\")\n    local segs = {}\n    rest:gsub(\"([^/]+)\", function(c) table.insert(segs, c) end)\n    url:gsub(\"([^/]+)\", function(c) table.insert(segs, c) end)\n    local resolved_url = {}\n    for i, v in ipairs(segs) do\n        if v == \"..\" then\n            table.remove(resolved_url)\n        elseif v ~= \".\" then\n            table.insert(resolved_url, v)\n        end\n    end\n    return proto .. domain ..\n        table.concat(resolved_url, \"/\")\nend\n\nlocal function join_url(base_url, fragment)\n    local res = \"\"\n    if base_url and fragment.path then\n        res = make_absolute_url(base_url, fragment.path)\n    elseif fragment.url then\n        res = fragment.url\n    end\n    return res\nend\n\nlocal function edl_track_joined(fragments, protocol, is_live, base)\n    if not (type(fragments) == \"table\") or not fragments[1] then\n        msg.debug(\"No fragments to join into EDL\")\n        return nil\n    end\n\n    local edl = \"edl://\"\n    local offset = 1\n    local parts = {}\n\n    if (protocol == \"http_dash_segments\") and\n        not fragments[1].duration and not is_live then\n        -- assume MP4 DASH initialization segment\n        table.insert(parts,\n            \"!mp4_dash,init=\" .. edl_escape(join_url(base, fragments[1])))\n        offset = 2\n\n        -- Check remaining fragments for duration;\n        -- if not available in all, give up.\n        for i = offset, #fragments do\n            if not fragments[i].duration then\n                msg.error(\"EDL doesn't support fragments\" ..\n                         \"without duration with MP4 DASH\")\n                return nil\n            end\n        end\n    end\n\n    for i = offset, #fragments do\n        local fragment = fragments[i]\n        table.insert(parts, edl_escape(join_url(base, fragment)))\n        if fragment.duration then\n            parts[#parts] =\n                parts[#parts] .. \",length=\"..fragment.duration\n        end\n    end\n    return edl .. table.concat(parts, \";\") .. \";\"\nend\n\nlocal function has_native_dash_demuxer()\n    local demuxers = mp.get_property_native(\"demuxer-lavf-list\")\n    for _,v in ipairs(demuxers) do\n        if v == \"dash\" then\n            return true\n        end\n    end\n    return false\nend\n\nlocal function proto_is_dash(json)\n    local reqfmts = json[\"requested_formats\"]\n    return (reqfmts ~= nil and reqfmts[1][\"protocol\"] == \"http_dash_segments\")\n           or json[\"protocol\"] == \"http_dash_segments\"\nend\n\nlocal function add_single_video(json)\n    local streamurl = \"\"\n    local max_bitrate = 0\n\n    if has_native_dash_demuxer() and proto_is_dash(json) then\n        local mpd_url = json[\"requested_formats\"][1][\"manifest_url\"] or\n            json[\"manifest_url\"]\n        if not mpd_url then\n            msg.error(\"No manifest URL found in JSON data.\")\n            return\n        end\n\n        streamurl = mpd_url\n\n        if json.requested_formats then\n            for _, track in pairs(json.requested_formats) do\n                max_bitrate = track.tbr > max_bitrate and\n                    track.tbr or max_bitrate\n            end\n        elseif json.tbr then\n            max_bitrate = json.tbr > max_bitrate and json.tbr or max_bitrate\n        end\n\n    -- DASH/split tracks\n    elseif not (json[\"requested_formats\"] == nil) then\n        for _, track in pairs(json.requested_formats) do\n            local edl_track = nil\n            edl_track = edl_track_joined(track.fragments,\n                track.protocol, json.is_live,\n                track.fragment_base_url)\n            if track.acodec and track.acodec ~= \"none\" then\n                -- audio track\n                mp.commandv(\"audio-add\",\n                    edl_track or track.url, \"auto\",\n                    track.format_note or \"\")\n            elseif track.vcodec and track.vcodec ~= \"none\" then\n                -- video track\n                streamurl = edl_track or track.url\n            end\n        end\n\n    elseif not (json.url == nil) then\n        local edl_track = nil\n        edl_track = edl_track_joined(json.fragments, json.protocol,\n            json.is_live, json.fragment_base_url)\n\n        -- normal video or single track\n        streamurl = edl_track or json.url\n        set_http_headers(json.http_headers)\n    else\n        msg.error(\"No URL found in JSON data.\")\n        return\n    end\n\n    msg.debug(\"streamurl: \" .. streamurl)\n\n    mp.set_property(\"stream-open-filename\", streamurl:gsub(\"^data:\", \"data://\", 1))\n\n    mp.set_property(\"file-local-options/force-media-title\", json.title)\n\n    -- set hls-bitrate for dash track selection\n    if max_bitrate > 0 and\n        not option_was_set(\"hls-bitrate\") and\n        not option_was_set_locally(\"hls-bitrate\") then\n        mp.set_property_native('file-local-options/hls-bitrate', max_bitrate*1000)\n    end\n\n    -- add subtitles\n    if not (json.requested_subtitles == nil) then\n        for lang, sub_info in pairs(json.requested_subtitles) do\n            msg.verbose(\"adding subtitle [\"..lang..\"]\")\n\n            local sub = nil\n\n            if not (sub_info.data == nil) then\n                sub = \"memory://\"..sub_info.data\n            elseif not (sub_info.url == nil) then\n                sub = sub_info.url\n            end\n\n            if not (sub == nil) then\n                mp.commandv(\"sub-add\", sub,\n                    \"auto\", sub_info.ext, lang)\n            else\n                msg.verbose(\"No subtitle data/url for [\"..lang..\"]\")\n            end\n        end\n    end\n\n    -- add chapters\n    if json.chapters then\n        msg.debug(\"Adding pre-parsed chapters\")\n        for i = 1, #json.chapters do\n            local chapter = json.chapters[i]\n            local title = chapter.title or \"\"\n            if title == \"\" then\n                title = string.format('Chapter %02d', i)\n            end\n            table.insert(chapter_list, {time=chapter.start_time, title=title})\n        end\n    elseif not (json.description == nil) and not (json.duration == nil) then\n        chapter_list = extract_chapters(json.description, json.duration)\n    end\n\n    -- set start time\n    if not (json.start_time == nil) and\n        not option_was_set(\"start\") and\n        not option_was_set_locally(\"start\") then\n        msg.debug(\"Setting start to: \" .. json.start_time .. \" secs\")\n        mp.set_property(\"file-local-options/start\", json.start_time)\n    end\n\n    -- set aspect ratio for anamorphic video\n    if not (json.stretched_ratio == nil) and\n        not option_was_set(\"video-aspect\") then\n        mp.set_property('file-local-options/video-aspect', json.stretched_ratio)\n    end\n\n    -- for rtmp\n    if (json.protocol == \"rtmp\") then\n        local rtmp_prop = append_rtmp_prop(nil,\n            \"rtmp_tcurl\", streamurl)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_pageurl\", json.page_url)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_playpath\", json.play_path)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_swfverify\", json.player_url)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_swfurl\", json.player_url)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_app\", json.app)\n\n        mp.set_property(\"file-local-options/stream-lavf-o\", rtmp_prop)\n    end\nend\n\nmp.add_hook(o.try_ytdl_first and \"on_load\" or \"on_load_fail\", 10, function ()\n    local url = mp.get_property(\"stream-open-filename\")\n    local start_time = os.clock()\n    if (url:find(\"ytdl://\") == 1) or\n        ((url:find(\"https?://\") == 1) and not is_blacklisted(url)) then\n\n        -- check for youtube-dl in mpv's config dir\n        if not (ytdl.searched) then\n            local exesuf = (package.config:sub(1,1) == '\\\\') and '.exe' or ''\n            local ytdl_mcd = mp.find_config_file(\"youtube-dl\" .. exesuf)\n            if not (ytdl_mcd == nil) then\n                msg.verbose(\"found youtube-dl at: \" .. ytdl_mcd)\n                ytdl.path = ytdl_mcd\n            end\n            ytdl.searched = true\n        end\n\n        -- strip ytdl://\n        if (url:find(\"ytdl://\") == 1) then\n            url = url:sub(8)\n        end\n\n        local format = mp.get_property(\"options/ytdl-format\")\n        local raw_options = mp.get_property_native(\"options/ytdl-raw-options\")\n        local allsubs = true\n\n        local command = {\n            ytdl.path, \"--no-warnings\", \"-J\", \"--flat-playlist\",\n            \"--sub-format\", \"ass/srt/best\", \"--no-playlist\"\n        }\n\n        -- Checks if video option is \"no\", change format accordingly,\n        -- but only if user didn't explicitly set one\n        if (mp.get_property(\"options/vid\") == \"no\")\n            and not option_was_set(\"ytdl-format\") then\n\n            format = \"bestaudio/best\"\n            msg.verbose(\"Video disabled. Only using audio\")\n        end\n\n        if (format == \"\") then\n            format = \"bestvideo+bestaudio/best\"\n        end\n        table.insert(command, \"--format\")\n        table.insert(command, format)\n\n        for param, arg in pairs(raw_options) do\n            table.insert(command, \"--\" .. param)\n            if (arg ~= \"\") then\n                table.insert(command, arg)\n            end\n            if (param == \"sub-lang\") and (arg ~= \"\") then\n                allsubs = false\n            end\n        end\n\n        if (allsubs == true) then\n            table.insert(command, \"--all-subs\")\n        end\n        table.insert(command, \"--\")\n        table.insert(command, url)\n        msg.debug(\"Running: \" .. table.concat(command,' '))\n        local es, json, result = exec(command)\n\n        if (es < 0) or (json == nil) or (json == \"\") then\n            local err = \"youtube-dl failed: \"\n            if result.error and result.error == \"init\" then\n                err = err .. \"not found or not enough permissions\"\n            elseif not result.killed_by_us then\n                err = err .. \"unexpected error ocurred\"\n            else\n                err = string.format(\"%s returned '%d'\", err, es)\n            end\n            msg.error(err)\n            return\n        end\n\n        local json, err = utils.parse_json(json)\n\n        if (json == nil) then\n            msg.error(\"failed to parse JSON data: \" .. err)\n            return\n        end\n\n        msg.verbose(\"youtube-dl succeeded!\")\n        msg.debug('ytdl parsing took '..os.clock()-start_time..' seconds')\n\n        -- what did we get?\n        if not (json[\"direct\"] == nil) and (json[\"direct\"] == true) then\n            -- direct URL, nothing to do\n            msg.verbose(\"Got direct URL\")\n            return\n        elseif not (json[\"_type\"] == nil)\n            and ((json[\"_type\"] == \"playlist\")\n            or (json[\"_type\"] == \"multi_video\")) then\n            -- a playlist\n\n            if (#json.entries == 0) then\n                msg.warn(\"Got empty playlist, nothing to play.\")\n                return\n            end\n\n            local self_redirecting_url =\n                json.entries[1][\"_type\"] ~= \"url_transparent\" and\n                json.entries[1][\"webpage_url\"] and\n                json.entries[1][\"webpage_url\"] == json[\"webpage_url\"]\n\n\n            -- some funky guessing to detect multi-arc videos\n            if self_redirecting_url and #json.entries > 1\n                and json.entries[1].protocol == \"m3u8_native\"\n                and json.entries[1].url then\n                msg.verbose(\"multi-arc video detected, building EDL\")\n\n                local playlist = edl_track_joined(json.entries)\n\n                msg.debug(\"EDL: \" .. playlist)\n\n                -- can't change the http headers for each entry, so use the 1st\n                if json.entries[1] then\n                    set_http_headers(json.entries[1].http_headers)\n                end\n\n                mp.set_property(\"stream-open-filename\", playlist)\n                if not (json.title == nil) then\n                    mp.set_property(\"file-local-options/force-media-title\",\n                        json.title)\n                end\n\n                -- there might not be subs for the first segment\n                local entry_wsubs = nil\n                for i, entry in pairs(json.entries) do\n                    if not (entry.requested_subtitles == nil) then\n                        entry_wsubs = i\n                        break\n                    end\n                end\n\n                if not (entry_wsubs == nil) and\n                    not (json.entries[entry_wsubs].duration == nil) then\n                    for j, req in pairs(json.entries[entry_wsubs].requested_subtitles) do\n                        local subfile = \"edl://\"\n                        for i, entry in pairs(json.entries) do\n                            if not (entry.requested_subtitles == nil) and\n                                not (entry.requested_subtitles[j] == nil) then\n                                subfile = subfile..edl_escape(entry.requested_subtitles[j].url)\n                            else\n                                subfile = subfile..edl_escape(\"memory://WEBVTT\")\n                            end\n                            subfile = subfile..\",length=\"..entry.duration..\";\"\n                        end\n                        msg.debug(j..\" sub EDL: \"..subfile)\n                        mp.commandv(\"sub-add\", subfile, \"auto\", req.ext, j)\n                    end\n                end\n\n            elseif self_redirecting_url and #json.entries == 1 then\n                msg.verbose(\"Playlist with single entry detected.\")\n                add_single_video(json.entries[1])\n            else\n                local playlist = {\"#EXTM3U\"}\n                for i, entry in pairs(json.entries) do\n                    local site = entry.url\n                    local title = entry.title\n\n                    if not (title == nil) then\n                        title = string.gsub(title, '%s+', ' ')\n                        table.insert(playlist, \"#EXTINF:0,\" .. title)\n                    end\n\n                    --[[ some extractors will still return the full info for\n                         all clips in the playlist and the URL will point\n                         directly to the file in that case, which we don't\n                         want so get the webpage URL instead, which is what\n                         we want, but only if we aren't going to trigger an\n                         infinite loop\n                    --]]\n                    if entry[\"webpage_url\"] and not self_redirecting_url then\n                        site = entry[\"webpage_url\"]\n                    end\n\n                    if not (site:find(\"https?://\") == 1) then\n                        site = \"ytdl://\" .. site\n                    end\n                    table.insert(playlist, site)\n\n                end\n\n                mp.set_property(\"stream-open-filename\", \"memory://\" .. table.concat(playlist, \"\\n\"))\n            end\n\n        else -- probably a video\n            add_single_video(json)\n        end\n    end\n    msg.debug('script running time: '..os.clock()-start_time..' seconds')\nend)\n\n\nmp.add_hook(\"on_preloaded\", 10, function ()\n    if next(chapter_list) ~= nil then\n        msg.verbose(\"Setting chapters\")\n\n        mp.set_property_native(\"chapter-list\", chapter_list)\n        chapter_list = {}\n    end\nend)\n"], "fixing_code": ["local utils = require 'mp.utils'\nlocal msg = require 'mp.msg'\nlocal options = require 'mp.options'\n\nlocal o = {\n    exclude = \"\",\n    try_ytdl_first = false\n}\noptions.read_options(o)\n\nlocal ytdl = {\n    path = \"youtube-dl\",\n    searched = false,\n    blacklisted = {}\n}\n\nlocal chapter_list = {}\n\nfunction Set (t)\n    local set = {}\n    for _, v in pairs(t) do set[v] = true end\n    return set\nend\n\nlocal safe_protos = Set {\n    \"http\", \"https\", \"ftp\", \"ftps\",\n    \"rtmp\", \"rtmps\", \"rtmpe\", \"rtmpt\", \"rtmpts\", \"rtmpte\",\n    \"data\"\n}\n\nlocal function exec(args)\n    local ret = utils.subprocess({args = args})\n    return ret.status, ret.stdout, ret\nend\n\n-- return true if it was explicitly set on the command line\nlocal function option_was_set(name)\n    return mp.get_property_bool(\"option-info/\" ..name.. \"/set-from-commandline\",\n                                false)\nend\n\n-- return true if the option was set locally\nlocal function option_was_set_locally(name)\n    return mp.get_property_bool(\"option-info/\" ..name.. \"/set-locally\", false)\nend\n\n-- youtube-dl may set special http headers for some sites (user-agent, cookies)\nlocal function set_http_headers(http_headers)\n    if not http_headers then\n        return\n    end\n    local headers = {}\n    local useragent = http_headers[\"User-Agent\"]\n    if useragent and not option_was_set(\"user-agent\") then\n        mp.set_property(\"file-local-options/user-agent\", useragent)\n    end\n    local additional_fields = {\"Cookie\", \"Referer\", \"X-Forwarded-For\"}\n    for idx, item in pairs(additional_fields) do\n        local field_value = http_headers[item]\n        if field_value then\n            headers[#headers + 1] = item .. \": \" .. field_value\n        end\n    end\n    if #headers > 0 and not option_was_set(\"http-header-fields\") then\n        mp.set_property_native(\"file-local-options/http-header-fields\", headers)\n    end\nend\n\nlocal function append_rtmp_prop(props, name, value)\n    if not name or not value then\n        return props\n    end\n\n    if props and props ~= \"\" then\n        props = props..\",\"\n    else\n        props = \"\"\n    end\n\n    return props..name..\"=\\\"\"..value..\"\\\"\"\nend\n\nlocal function edl_escape(url)\n    return \"%\" .. string.len(url) .. \"%\" .. url\nend\n\nlocal function time_to_secs(time_string)\n    local ret\n\n    local a, b, c = time_string:match(\"(%d+):(%d%d?):(%d%d)\")\n    if a ~= nil then\n        ret = (a*3600 + b*60 + c)\n    else\n        a, b = time_string:match(\"(%d%d?):(%d%d)\")\n        if a ~= nil then\n            ret = (a*60 + b)\n        end\n    end\n\n    return ret\nend\n\nlocal function extract_chapters(data, video_length)\n    local ret = {}\n\n    for line in data:gmatch(\"[^\\r\\n]+\") do\n        local time = time_to_secs(line)\n        if time and (time < video_length) then\n            table.insert(ret, {time = time, title = line})\n        end\n    end\n    table.sort(ret, function(a, b) return a.time < b.time end)\n    return ret\nend\n\nlocal function is_blacklisted(url)\n    if o.exclude == \"\" then return false end\n    if #ytdl.blacklisted == 0 then\n        local joined = o.exclude\n        while joined:match('%|?[^|]+') do\n            local _, e, substring = joined:find('%|?([^|]+)')\n            table.insert(ytdl.blacklisted, substring)\n            joined = joined:sub(e+1)\n        end\n    end\n    if #ytdl.blacklisted > 0 then\n        url = url:match('https?://(.+)')\n        for _, exclude in ipairs(ytdl.blacklisted) do\n            if url:match(exclude) then\n                msg.verbose('URL matches excluded substring. Skipping.')\n                return true\n            end\n        end\n    end\n    return false\nend\n\nlocal function make_absolute_url(base_url, url)\n    if url:find(\"https?://\") == 1 then return url end\n\n    local proto, domain, rest =\n        base_url:match(\"(https?://)([^/]+/)(.*)/?\")\n    local segs = {}\n    rest:gsub(\"([^/]+)\", function(c) table.insert(segs, c) end)\n    url:gsub(\"([^/]+)\", function(c) table.insert(segs, c) end)\n    local resolved_url = {}\n    for i, v in ipairs(segs) do\n        if v == \"..\" then\n            table.remove(resolved_url)\n        elseif v ~= \".\" then\n            table.insert(resolved_url, v)\n        end\n    end\n    return proto .. domain ..\n        table.concat(resolved_url, \"/\")\nend\n\nlocal function join_url(base_url, fragment)\n    local res = \"\"\n    if base_url and fragment.path then\n        res = make_absolute_url(base_url, fragment.path)\n    elseif fragment.url then\n        res = fragment.url\n    end\n    return res\nend\n\nlocal function edl_track_joined(fragments, protocol, is_live, base)\n    if not (type(fragments) == \"table\") or not fragments[1] then\n        msg.debug(\"No fragments to join into EDL\")\n        return nil\n    end\n\n    local edl = \"edl://\"\n    local offset = 1\n    local parts = {}\n\n    if (protocol == \"http_dash_segments\") and\n        not fragments[1].duration and not is_live then\n        -- assume MP4 DASH initialization segment\n        table.insert(parts,\n            \"!mp4_dash,init=\" .. edl_escape(join_url(base, fragments[1])))\n        offset = 2\n\n        -- Check remaining fragments for duration;\n        -- if not available in all, give up.\n        for i = offset, #fragments do\n            if not fragments[i].duration then\n                msg.error(\"EDL doesn't support fragments\" ..\n                         \"without duration with MP4 DASH\")\n                return nil\n            end\n        end\n    end\n\n    for i = offset, #fragments do\n        local fragment = fragments[i]\n        if not url_is_safe(join_url(base, fragment)) then\n            return nil\n        end\n        table.insert(parts, edl_escape(join_url(base, fragment)))\n        if fragment.duration then\n            parts[#parts] =\n                parts[#parts] .. \",length=\"..fragment.duration\n        end\n    end\n    return edl .. table.concat(parts, \";\") .. \";\"\nend\n\nlocal function has_native_dash_demuxer()\n    local demuxers = mp.get_property_native(\"demuxer-lavf-list\")\n    for _,v in ipairs(demuxers) do\n        if v == \"dash\" then\n            return true\n        end\n    end\n    return false\nend\n\nlocal function proto_is_dash(json)\n    local reqfmts = json[\"requested_formats\"]\n    return (reqfmts ~= nil and reqfmts[1][\"protocol\"] == \"http_dash_segments\")\n           or json[\"protocol\"] == \"http_dash_segments\"\nend\n\nlocal function url_is_safe(url)\n    local proto = type(url) == \"string\" and url:match(\"^(.+)://\") or nil\n    local safe = proto and safe_protos[proto]\n    if not safe then\n        msg.error((\"Ignoring potentially unsafe url: '%s'\"):format(url))\n    end\n    return safe\nend\n\nlocal function add_single_video(json)\n    local streamurl = \"\"\n    local max_bitrate = 0\n\n    if has_native_dash_demuxer() and proto_is_dash(json) then\n        local mpd_url = json[\"requested_formats\"][1][\"manifest_url\"] or\n            json[\"manifest_url\"]\n        if not mpd_url then\n            msg.error(\"No manifest URL found in JSON data.\")\n            return\n        elseif not url_is_safe(mpd_url) then\n            return\n        end\n\n        streamurl = mpd_url\n\n        if json.requested_formats then\n            for _, track in pairs(json.requested_formats) do\n                max_bitrate = track.tbr > max_bitrate and\n                    track.tbr or max_bitrate\n            end\n        elseif json.tbr then\n            max_bitrate = json.tbr > max_bitrate and json.tbr or max_bitrate\n        end\n\n    -- DASH/split tracks\n    elseif not (json[\"requested_formats\"] == nil) then\n        for _, track in pairs(json.requested_formats) do\n            local edl_track = nil\n            edl_track = edl_track_joined(track.fragments,\n                track.protocol, json.is_live,\n                track.fragment_base_url)\n            local url = edl_track or track.url\n            if not url_is_safe(url) then\n                return\n            end\n            if track.acodec and track.acodec ~= \"none\" then\n                -- audio track\n                mp.commandv(\"audio-add\",\n                    url, \"auto\",\n                    track.format_note or \"\")\n            elseif track.vcodec and track.vcodec ~= \"none\" then\n                -- video track\n                streamurl = url\n            end\n        end\n\n    elseif not (json.url == nil) then\n        local edl_track = nil\n        edl_track = edl_track_joined(json.fragments, json.protocol,\n            json.is_live, json.fragment_base_url)\n\n        -- normal video or single track\n        streamurl = edl_track or json.url\n        set_http_headers(json.http_headers)\n    else\n        msg.error(\"No URL found in JSON data.\")\n        return\n    end\n\n    msg.debug(\"streamurl: \" .. streamurl)\n\n    streamurl = streamurl:gsub(\"^data:\", \"data://\", 1)\n\n    if not url_is_safe(streamurl) then\n        return\n    end\n\n    mp.set_property(\"stream-open-filename\", streamurl)\n\n    mp.set_property(\"file-local-options/force-media-title\", json.title)\n\n    -- set hls-bitrate for dash track selection\n    if max_bitrate > 0 and\n        not option_was_set(\"hls-bitrate\") and\n        not option_was_set_locally(\"hls-bitrate\") then\n        mp.set_property_native('file-local-options/hls-bitrate', max_bitrate*1000)\n    end\n\n    -- add subtitles\n    if not (json.requested_subtitles == nil) then\n        for lang, sub_info in pairs(json.requested_subtitles) do\n            msg.verbose(\"adding subtitle [\"..lang..\"]\")\n\n            local sub = nil\n\n            if not (sub_info.data == nil) then\n                sub = \"memory://\"..sub_info.data\n            elseif not (sub_info.url == nil) then\n                sub = sub_info.url\n            end\n\n            if not (sub == nil) then\n                mp.commandv(\"sub-add\", sub,\n                    \"auto\", sub_info.ext, lang)\n            else\n                msg.verbose(\"No subtitle data/url for [\"..lang..\"]\")\n            end\n        end\n    end\n\n    -- add chapters\n    if json.chapters then\n        msg.debug(\"Adding pre-parsed chapters\")\n        for i = 1, #json.chapters do\n            local chapter = json.chapters[i]\n            local title = chapter.title or \"\"\n            if title == \"\" then\n                title = string.format('Chapter %02d', i)\n            end\n            table.insert(chapter_list, {time=chapter.start_time, title=title})\n        end\n    elseif not (json.description == nil) and not (json.duration == nil) then\n        chapter_list = extract_chapters(json.description, json.duration)\n    end\n\n    -- set start time\n    if not (json.start_time == nil) and\n        not option_was_set(\"start\") and\n        not option_was_set_locally(\"start\") then\n        msg.debug(\"Setting start to: \" .. json.start_time .. \" secs\")\n        mp.set_property(\"file-local-options/start\", json.start_time)\n    end\n\n    -- set aspect ratio for anamorphic video\n    if not (json.stretched_ratio == nil) and\n        not option_was_set(\"video-aspect\") then\n        mp.set_property('file-local-options/video-aspect', json.stretched_ratio)\n    end\n\n    -- for rtmp\n    if (json.protocol == \"rtmp\") then\n        local rtmp_prop = append_rtmp_prop(nil,\n            \"rtmp_tcurl\", streamurl)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_pageurl\", json.page_url)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_playpath\", json.play_path)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_swfverify\", json.player_url)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_swfurl\", json.player_url)\n        rtmp_prop = append_rtmp_prop(rtmp_prop,\n            \"rtmp_app\", json.app)\n\n        mp.set_property(\"file-local-options/stream-lavf-o\", rtmp_prop)\n    end\nend\n\nmp.add_hook(o.try_ytdl_first and \"on_load\" or \"on_load_fail\", 10, function ()\n    local url = mp.get_property(\"stream-open-filename\")\n    local start_time = os.clock()\n    if (url:find(\"ytdl://\") == 1) or\n        ((url:find(\"https?://\") == 1) and not is_blacklisted(url)) then\n\n        -- check for youtube-dl in mpv's config dir\n        if not (ytdl.searched) then\n            local exesuf = (package.config:sub(1,1) == '\\\\') and '.exe' or ''\n            local ytdl_mcd = mp.find_config_file(\"youtube-dl\" .. exesuf)\n            if not (ytdl_mcd == nil) then\n                msg.verbose(\"found youtube-dl at: \" .. ytdl_mcd)\n                ytdl.path = ytdl_mcd\n            end\n            ytdl.searched = true\n        end\n\n        -- strip ytdl://\n        if (url:find(\"ytdl://\") == 1) then\n            url = url:sub(8)\n        end\n\n        local format = mp.get_property(\"options/ytdl-format\")\n        local raw_options = mp.get_property_native(\"options/ytdl-raw-options\")\n        local allsubs = true\n\n        local command = {\n            ytdl.path, \"--no-warnings\", \"-J\", \"--flat-playlist\",\n            \"--sub-format\", \"ass/srt/best\", \"--no-playlist\"\n        }\n\n        -- Checks if video option is \"no\", change format accordingly,\n        -- but only if user didn't explicitly set one\n        if (mp.get_property(\"options/vid\") == \"no\")\n            and not option_was_set(\"ytdl-format\") then\n\n            format = \"bestaudio/best\"\n            msg.verbose(\"Video disabled. Only using audio\")\n        end\n\n        if (format == \"\") then\n            format = \"bestvideo+bestaudio/best\"\n        end\n        table.insert(command, \"--format\")\n        table.insert(command, format)\n\n        for param, arg in pairs(raw_options) do\n            table.insert(command, \"--\" .. param)\n            if (arg ~= \"\") then\n                table.insert(command, arg)\n            end\n            if (param == \"sub-lang\") and (arg ~= \"\") then\n                allsubs = false\n            end\n        end\n\n        if (allsubs == true) then\n            table.insert(command, \"--all-subs\")\n        end\n        table.insert(command, \"--\")\n        table.insert(command, url)\n        msg.debug(\"Running: \" .. table.concat(command,' '))\n        local es, json, result = exec(command)\n\n        if (es < 0) or (json == nil) or (json == \"\") then\n            local err = \"youtube-dl failed: \"\n            if result.error and result.error == \"init\" then\n                err = err .. \"not found or not enough permissions\"\n            elseif not result.killed_by_us then\n                err = err .. \"unexpected error ocurred\"\n            else\n                err = string.format(\"%s returned '%d'\", err, es)\n            end\n            msg.error(err)\n            return\n        end\n\n        local json, err = utils.parse_json(json)\n\n        if (json == nil) then\n            msg.error(\"failed to parse JSON data: \" .. err)\n            return\n        end\n\n        msg.verbose(\"youtube-dl succeeded!\")\n        msg.debug('ytdl parsing took '..os.clock()-start_time..' seconds')\n\n        -- what did we get?\n        if not (json[\"direct\"] == nil) and (json[\"direct\"] == true) then\n            -- direct URL, nothing to do\n            msg.verbose(\"Got direct URL\")\n            return\n        elseif not (json[\"_type\"] == nil)\n            and ((json[\"_type\"] == \"playlist\")\n            or (json[\"_type\"] == \"multi_video\")) then\n            -- a playlist\n\n            if (#json.entries == 0) then\n                msg.warn(\"Got empty playlist, nothing to play.\")\n                return\n            end\n\n            local self_redirecting_url =\n                json.entries[1][\"_type\"] ~= \"url_transparent\" and\n                json.entries[1][\"webpage_url\"] and\n                json.entries[1][\"webpage_url\"] == json[\"webpage_url\"]\n\n\n            -- some funky guessing to detect multi-arc videos\n            if self_redirecting_url and #json.entries > 1\n                and json.entries[1].protocol == \"m3u8_native\"\n                and json.entries[1].url then\n                msg.verbose(\"multi-arc video detected, building EDL\")\n\n                local playlist = edl_track_joined(json.entries)\n\n                msg.debug(\"EDL: \" .. playlist)\n\n                -- can't change the http headers for each entry, so use the 1st\n                if json.entries[1] then\n                    set_http_headers(json.entries[1].http_headers)\n                end\n\n                mp.set_property(\"stream-open-filename\", playlist)\n                if not (json.title == nil) then\n                    mp.set_property(\"file-local-options/force-media-title\",\n                        json.title)\n                end\n\n                -- there might not be subs for the first segment\n                local entry_wsubs = nil\n                for i, entry in pairs(json.entries) do\n                    if not (entry.requested_subtitles == nil) then\n                        entry_wsubs = i\n                        break\n                    end\n                end\n\n                if not (entry_wsubs == nil) and\n                    not (json.entries[entry_wsubs].duration == nil) then\n                    for j, req in pairs(json.entries[entry_wsubs].requested_subtitles) do\n                        local subfile = \"edl://\"\n                        for i, entry in pairs(json.entries) do\n                            if not (entry.requested_subtitles == nil) and\n                                not (entry.requested_subtitles[j] == nil) then\n                                subfile = subfile..edl_escape(entry.requested_subtitles[j].url)\n                            else\n                                subfile = subfile..edl_escape(\"memory://WEBVTT\")\n                            end\n                            subfile = subfile..\",length=\"..entry.duration..\";\"\n                        end\n                        msg.debug(j..\" sub EDL: \"..subfile)\n                        mp.commandv(\"sub-add\", subfile, \"auto\", req.ext, j)\n                    end\n                end\n\n            elseif self_redirecting_url and #json.entries == 1 then\n                msg.verbose(\"Playlist with single entry detected.\")\n                add_single_video(json.entries[1])\n            else\n                local playlist = {\"#EXTM3U\"}\n                for i, entry in pairs(json.entries) do\n                    local site = entry.url\n                    local title = entry.title\n\n                    if not (title == nil) then\n                        title = string.gsub(title, '%s+', ' ')\n                        table.insert(playlist, \"#EXTINF:0,\" .. title)\n                    end\n\n                    --[[ some extractors will still return the full info for\n                         all clips in the playlist and the URL will point\n                         directly to the file in that case, which we don't\n                         want so get the webpage URL instead, which is what\n                         we want, but only if we aren't going to trigger an\n                         infinite loop\n                    --]]\n                    if entry[\"webpage_url\"] and not self_redirecting_url then\n                        site = entry[\"webpage_url\"]\n                    end\n\n                    -- links with only youtube id as returned by --flat-playlist\n                    if not site:find(\"://\") then\n                        table.insert(playlist, \"ytdl://\" .. site)\n                    elseif url_is_safe(site) then\n                        table.insert(playlist, site)\n                    end\n\n                end\n\n                if #playlist > 0 then\n                    mp.set_property(\"stream-open-filename\", \"memory://\" .. table.concat(playlist, \"\\n\"))\n                end\n            end\n\n        else -- probably a video\n            add_single_video(json)\n        end\n    end\n    msg.debug('script running time: '..os.clock()-start_time..' seconds')\nend)\n\n\nmp.add_hook(\"on_preloaded\", 10, function ()\n    if next(chapter_list) ~= nil then\n        msg.verbose(\"Setting chapters\")\n\n        mp.set_property_native(\"chapter-list\", chapter_list)\n        chapter_list = {}\n    end\nend)\n"], "filenames": ["player/lua/ytdl_hook.lua"], "buggy_code_start_loc": [17], "buggy_code_end_loc": [537], "fixing_code_start_loc": [18], "fixing_code_end_loc": [577], "type": "CWE-20", "message": "mpv through 0.28.0 allows remote attackers to execute arbitrary code via a crafted web site, because it reads HTML documents containing VIDEO elements, and accepts arbitrary URLs in a src attribute without a protocol whitelist in player/lua/ytdl_hook.lua. For example, an av://lavfi:ladspa=file= URL signifies that the product should call dlopen on a shared object file located at an arbitrary local pathname. The issue exists because the product does not consider that youtube-dl can provide a potentially unsafe URL.", "other": {"cve": {"id": "CVE-2018-6360", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-28T02:29:01.503", "lastModified": "2019-03-01T23:25:38.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mpv through 0.28.0 allows remote attackers to execute arbitrary code via a crafted web site, because it reads HTML documents containing VIDEO elements, and accepts arbitrary URLs in a src attribute without a protocol whitelist in player/lua/ytdl_hook.lua. For example, an av://lavfi:ladspa=file= URL signifies that the product should call dlopen on a shared object file located at an arbitrary local pathname. The issue exists because the product does not consider that youtube-dl can provide a potentially unsafe URL."}, {"lang": "es", "value": "mpv hasta la versi\u00f3n 0.28.0 permite que atacantes remotos ejecuten c\u00f3digo arbitrario mediante un sitio web manipulado, ya que lee documentos HTML que contienen elementos VIDEO y aceptan URL arbitrarias en un atributo src sin una lista blanca de protocolos en player/lua/ytdl_hook.lua. Por ejemplo, una URL av://lavfi:ladspa=file= significa que el producto deber\u00eda llamar a dlopen en un objeto compartido ubicado en un nombre de ruta local arbitraria. El problema existe debido a que el producto no considera que youtube-dl pueda proporcionar una URL potencialmente insegura."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mpv:mpv:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.28.0", "matchCriteriaId": "E983652B-C1F4-449D-8098-6C4EBAEA7C0B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/mpv-player/mpv/commit/e6e6b0dcc7e9b0dbf35154a179b3dc1fcfcaff43", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mpv-player/mpv/issues/5456", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201805-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4105", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mpv-player/mpv/commit/e6e6b0dcc7e9b0dbf35154a179b3dc1fcfcaff43"}}