{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * Copyright (c) 2013 Red Hat, Inc.\n * All Rights Reserved.\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_log.h\"\n\n\n/*\n * xfs_attr_leaf.c\n *\n * Routines to implement leaf blocks of attributes as Btrees of hashed names.\n */\n\n/*========================================================================\n * Function prototypes for the kernel.\n *========================================================================*/\n\n/*\n * Routines used for growing the Btree.\n */\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nSTATIC int xfs_attr3_leaf_add_work(struct xfs_buf *leaf_buffer,\n\t\t\t\t   struct xfs_attr3_icleaf_hdr *ichdr,\n\t\t\t\t   struct xfs_da_args *args, int freemap_index);\nSTATIC void xfs_attr3_leaf_compact(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_attr3_icleaf_hdr *ichdr,\n\t\t\t\t   struct xfs_buf *leaf_buffer);\nSTATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);\nSTATIC int xfs_attr3_leaf_figure_balance(xfs_da_state_t *state,\n\t\t\txfs_da_state_blk_t *leaf_blk_1,\n\t\t\tstruct xfs_attr3_icleaf_hdr *ichdr1,\n\t\t\txfs_da_state_blk_t *leaf_blk_2,\n\t\t\tstruct xfs_attr3_icleaf_hdr *ichdr2,\n\t\t\tint *number_entries_in_blk1,\n\t\t\tint *number_usedbytes_in_blk1);\n\n/*\n * Utility routines.\n */\nSTATIC void xfs_attr3_leaf_moveents(struct xfs_da_args *args,\n\t\t\tstruct xfs_attr_leafblock *src_leaf,\n\t\t\tstruct xfs_attr3_icleaf_hdr *src_ichdr, int src_start,\n\t\t\tstruct xfs_attr_leafblock *dst_leaf,\n\t\t\tstruct xfs_attr3_icleaf_hdr *dst_ichdr, int dst_start,\n\t\t\tint move_count);\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\n/*\n * attr3 block 'firstused' conversion helpers.\n *\n * firstused refers to the offset of the first used byte of the nameval region\n * of an attr leaf block. The region starts at the tail of the block and expands\n * backwards towards the middle. As such, firstused is initialized to the block\n * size for an empty leaf block and is reduced from there.\n *\n * The attr3 block size is pegged to the fsb size and the maximum fsb is 64k.\n * The in-core firstused field is 32-bit and thus supports the maximum fsb size.\n * The on-disk field is only 16-bit, however, and overflows at 64k. Since this\n * only occurs at exactly 64k, we use zero as a magic on-disk value to represent\n * the attr block size. The following helpers manage the conversion between the\n * in-core and on-disk formats.\n */\n\nstatic void\nxfs_attr3_leaf_firstused_from_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tstruct xfs_attr3_leaf_hdr\t*hdr3;\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\thdr3 = (struct xfs_attr3_leaf_hdr *) from;\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t} else {\n\t\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\t}\n\n\t/*\n\t * Convert from the magic fsb size value to actual blocksize. This\n\t * should only occur for empty blocks when the block size overflows\n\t * 16-bits.\n\t */\n\tif (to->firstused == XFS_ATTR3_LEAF_NULLOFF) {\n\t\tASSERT(!to->count && !to->usedbytes);\n\t\tASSERT(geo->blksize > USHRT_MAX);\n\t\tto->firstused = geo->blksize;\n\t}\n}\n\nstatic void\nxfs_attr3_leaf_firstused_to_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tstruct xfs_attr3_leaf_hdr\t*hdr3;\n\tuint32_t\t\t\tfirstused;\n\n\t/* magic value should only be seen on disk */\n\tASSERT(from->firstused != XFS_ATTR3_LEAF_NULLOFF);\n\n\t/*\n\t * Scale down the 32-bit in-core firstused value to the 16-bit on-disk\n\t * value. This only overflows at the max supported value of 64k. Use the\n\t * magic on-disk value to represent block size in this case.\n\t */\n\tfirstused = from->firstused;\n\tif (firstused > USHRT_MAX) {\n\t\tASSERT(from->firstused == geo->blksize);\n\t\tfirstused = XFS_ATTR3_LEAF_NULLOFF;\n\t}\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\thdr3 = (struct xfs_attr3_leaf_hdr *) to;\n\t\thdr3->firstused = cpu_to_be16(firstused);\n\t} else {\n\t\tto->hdr.firstused = cpu_to_be16(firstused);\n\t}\n}\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\txfs_attr3_leaf_firstused_from_disk(geo, to, from);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\txfs_attr3_leaf_firstused_from_disk(geo, to, from);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\t\t\t\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\txfs_attr3_leaf_firstused_to_disk(geo, to, from);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\txfs_attr3_leaf_firstused_to_disk(geo, to, from);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}\n\nstatic xfs_failaddr_t\nxfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t\t*bp)\n{\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_mount\t\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock\t*leaf = bp->b_addr;\n\tstruct xfs_perag\t\t*pag = bp->b_pag;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn __this_address;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp, be64_to_cpu(hdr3->info.lsn)))\n\t\t\treturn __this_address;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn __this_address;\n\t}\n\t/*\n\t * In recovery there is a transient state where count == 0 is valid\n\t * because we may have transitioned an empty shortform attr to a leaf\n\t * if the attr didn't fit in shortform.\n\t */\n\tif (pag && pag->pagf_init && ichdr.count == 0)\n\t\treturn __this_address;\n\n\t/*\n\t * firstused is the block offset of the first name info structure.\n\t * Make sure it doesn't go off the block or crash into the header.\n\t */\n\tif (ichdr.firstused > mp->m_attr_geo->blksize)\n\t\treturn __this_address;\n\tif (ichdr.firstused < xfs_attr3_leaf_hdr_size(leaf))\n\t\treturn __this_address;\n\n\t/* Make sure the entries array doesn't crash into the name info. */\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif ((char *)&entries[ichdr.count] >\n\t    (char *)bp->b_addr + ichdr.firstused)\n\t\treturn __this_address;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn NULL;\n}\n\nstatic void\nxfs_attr3_leaf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tstruct xfs_attr3_leaf_hdr *hdr3 = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_attr3_leaf_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF);\n}\n\n/*\n * leaf/node format detection on trees is sketchy, so a node read can be done on\n * leaf level blocks when detection identifies the tree as a node format tree\n * incorrectly. In this case, we need to swap the verifier to match the correct\n * format of the block being read.\n */\nstatic void\nxfs_attr3_leaf_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\txfs_failaddr_t\t\tfa;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_attr3_leaf_verify(bp);\n\t\tif (fa)\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n}\n\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.name = \"xfs_attr3_leaf\",\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n\t.verify_struct = xfs_attr3_leaf_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp && *bpp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}\n\n/*========================================================================\n * Namespace helper routines\n *========================================================================*/\n\n/*\n * If namespace bits don't match return 0.\n * If all match then return 1.\n */\nSTATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}\n\n\n/*========================================================================\n * External routines when attribute fork size < XFS_LITINO(mp).\n *========================================================================*/\n\n/*\n * Query whether the requested number of additional bytes of extended\n * attribute space will be able to fit inline.\n *\n * Returns zero if not, else the di_forkoff fork offset to be used in the\n * literal area for attribute data once the new bytes have been added.\n *\n * di_forkoff must be 8 byte aligned, hence is stored as a >>3 value;\n * special case for dev/uuid inodes, they have fixed size data forks.\n */\nint\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_DEV) {\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = max(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}\n\n/*\n * Switch on the ATTR2 superblock bit (implies also FEATURES2)\n */\nSTATIC void\nxfs_sbversion_add_attr2(xfs_mount_t *mp, xfs_trans_t *tp)\n{\n\tif ((mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    !(xfs_sb_version_hasattr2(&mp->m_sb))) {\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t\t\txfs_log_sb(tp);\n\t\t} else\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t}\n}\n\n/*\n * Create the initial contents of a shortform attribute list.\n */\nvoid\nxfs_attr_shortform_create(xfs_da_args_t *args)\n{\n\txfs_attr_sf_hdr_t *hdr;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_create(args);\n\n\tdp = args->dp;\n\tASSERT(dp != NULL);\n\tifp = dp->i_afp;\n\tASSERT(ifp != NULL);\n\tASSERT(ifp->if_bytes == 0);\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) {\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_aformat = XFS_DINODE_FMT_LOCAL;\n\t\tifp->if_flags |= XFS_IFINLINE;\n\t} else {\n\t\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t}\n\txfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\n\thdr = (xfs_attr_sf_hdr_t *)ifp->if_u1.if_data;\n\thdr->count = 0;\n\thdr->totsize = cpu_to_be16(sizeof(*hdr));\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n}\n\n/*\n * Add a name/value pair to the shortform attribute list.\n * Overflow from the inode has already been checked for.\n */\nvoid\nxfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i, offset, size;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_add(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_d.di_forkoff = forkoff;\n\n\tifp = dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n#ifdef DEBUG\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tASSERT(0);\n#endif\n\t}\n\n\toffset = (char *)sfe - (char *)sf;\n\tsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\n\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n}\n\n/*\n * After the last attribute is removed revert to original inode format,\n * making all literal area available to the data fork once more.\n */\nvoid\nxfs_attr_fork_remove(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}\n\n/*\n * Remove an attribute from the shortform attribute list structure.\n */\nint\nxfs_attr_shortform_remove(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint base, size=0, end, totsize, i;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\n\ttrace_xfs_attr_sf_remove(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tbase = sizeof(xfs_attr_sf_hdr_t);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tend = sf->hdr.count;\n\tfor (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),\n\t\t\t\t\tbase += size, i++) {\n\t\tsize = XFS_ATTR_SF_ENTSIZE(sfe);\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(sfe->nameval, args->name, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (i == end)\n\t\treturn -ENOATTR;\n\n\t/*\n\t * Fix up the attribute fork data, covering the hole\n\t */\n\tend = base + size;\n\ttotsize = be16_to_cpu(sf->hdr.totsize);\n\tif (end != totsize)\n\t\tmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\n\tsf->hdr.count--;\n\tbe16_add_cpu(&sf->hdr.totsize, -size);\n\n\t/*\n\t * Fix up the start offset of the attribute fork\n\t */\n\ttotsize -= size;\n\tif (totsize == sizeof(xfs_attr_sf_hdr_t) &&\n\t    (mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    !(args->op_flags & XFS_DA_OP_ADDNAME)) {\n\t\txfs_attr_fork_remove(dp, args->trans);\n\t} else {\n\t\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\t\tdp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\n\t\tASSERT(dp->i_d.di_forkoff);\n\t\tASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!(mp->m_flags & XFS_MOUNT_ATTR2) ||\n\t\t\t\tdp->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\t\txfs_trans_log_inode(args->trans, dp,\n\t\t\t\t\tXFS_ILOG_CORE | XFS_ILOG_ADATA);\n\t}\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n\n\treturn 0;\n}\n\n/*\n * Look up a name in a shortform attribute list structure.\n */\n/*ARGSUSED*/\nint\nxfs_attr_shortform_lookup(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_lookup(args);\n\n\tifp = args->dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}\n\n/*\n * Look up a name in a shortform attribute list structure.\n */\n/*ARGSUSED*/\nint\nxfs_attr_shortform_getvalue(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\n\tASSERT(args->dp->i_afp->if_flags == XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)args->dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (args->valuelen < sfe->valuelen) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = sfe->valuelen;\n\t\tmemcpy(args->value, &sfe->nameval[args->namelen],\n\t\t\t\t\t\t    args->valuelen);\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}\n\n/*\n * Convert from using the shortform to the leaf.  On success, return the\n * buffer so that we can keep it locked until we're totally done with it.\n */\nint\nxfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}\n\n/*\n * Check a leaf attribute block to see if all the entries would fit into\n * a shortform attribute list.\n */\nint\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}\n\n/* Verify the consistency of an inline attribute fork. */\nxfs_failaddr_t\nxfs_attr_shortform_verify(\n\tstruct xfs_inode\t\t*ip)\n{\n\tstruct xfs_attr_shortform\t*sfp;\n\tstruct xfs_attr_sf_entry\t*sfep;\n\tstruct xfs_attr_sf_entry\t*next_sfep;\n\tchar\t\t\t\t*endp;\n\tstruct xfs_ifork\t\t*ifp;\n\tint\t\t\t\ti;\n\tint\t\t\t\tsize;\n\n\tASSERT(ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL);\n\tifp = XFS_IFORK_PTR(ip, XFS_ATTR_FORK);\n\tsfp = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tsize = ifp->if_bytes;\n\n\t/*\n\t * Give up if the attribute is way too short.\n\t */\n\tif (size < sizeof(struct xfs_attr_sf_hdr))\n\t\treturn __this_address;\n\n\tendp = (char *)sfp + size;\n\n\t/* Check all reported entries */\n\tsfep = &sfp->list[0];\n\tfor (i = 0; i < sfp->hdr.count; i++) {\n\t\t/*\n\t\t * struct xfs_attr_sf_entry has a variable length.\n\t\t * Check the fixed-offset parts of the structure are\n\t\t * within the data buffer.\n\t\t */\n\t\tif (((char *)sfep + sizeof(*sfep)) >= endp)\n\t\t\treturn __this_address;\n\n\t\t/* Don't allow names with known bad length. */\n\t\tif (sfep->namelen == 0)\n\t\t\treturn __this_address;\n\n\t\t/*\n\t\t * Check that the variable-length part of the structure is\n\t\t * within the data buffer.  The next entry starts after the\n\t\t * name component, so nextentry is an acceptable test.\n\t\t */\n\t\tnext_sfep = XFS_ATTR_SF_NEXTENTRY(sfep);\n\t\tif ((char *)next_sfep > endp)\n\t\t\treturn __this_address;\n\n\t\t/*\n\t\t * Check for unknown flags.  Short form doesn't support\n\t\t * the incomplete or local bits, so we can use the namespace\n\t\t * mask here.\n\t\t */\n\t\tif (sfep->flags & ~XFS_ATTR_NSP_ONDISK_MASK)\n\t\t\treturn __this_address;\n\n\t\t/*\n\t\t * Check for invalid namespace combinations.  We only allow\n\t\t * one namespace flag per xattr, so we can just count the\n\t\t * bits (i.e. hweight) here.\n\t\t */\n\t\tif (hweight8(sfep->flags & XFS_ATTR_NSP_ONDISK_MASK) > 1)\n\t\t\treturn __this_address;\n\n\t\tsfep = next_sfep;\n\t}\n\tif ((void *)sfep != (void *)endp)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\n/*\n * Convert a leaf attribute list to shortform attribute list\n */\nint\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_remove(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}\n\n/*\n * Convert from using a single leaf to a root node and a leaf.\n */\nint\nxfs_attr3_leaf_to_node(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr icleafhdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr icnodehdr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp1 = NULL;\n\tstruct xfs_buf\t\t*bp2 = NULL;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_to_node(args);\n\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\terror = xfs_attr3_leaf_read(args->trans, dp, 0, -1, &bp1);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_da_get_buf(args->trans, dp, blkno, -1, &bp2, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\n\t/* copy leaf to new buffer, update identifiers */\n\txfs_trans_buf_set_type(args->trans, bp2, XFS_BLFT_ATTR_LEAF_BUF);\n\tbp2->b_ops = bp1->b_ops;\n\tmemcpy(bp2->b_addr, bp1->b_addr, args->geo->blksize);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp2->b_addr;\n\t\thdr3->blkno = cpu_to_be64(bp2->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, bp2, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\tnode = bp1->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&icnodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tleaf = bp2->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &icleafhdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\t/* both on-disk, don't endian-flip twice */\n\tbtree[0].hashval = entries[icleafhdr.count - 1].hashval;\n\tbtree[0].before = cpu_to_be32(blkno);\n\ticnodehdr.count = 1;\n\tdp->d_ops->node_hdr_to_disk(node, &icnodehdr);\n\txfs_trans_log_buf(args->trans, bp1, 0, args->geo->blksize - 1);\n\terror = 0;\nout:\n\treturn error;\n}\n\n/*========================================================================\n * Routines used for growing the Btree.\n *========================================================================*/\n\n/*\n * Create the initial contents of a leaf attribute list\n * or a leaf in a node attribute list.\n */\nSTATIC int\nxfs_attr3_leaf_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_create(args);\n\n\terror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp,\n\t\t\t\t\t    XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\txfs_trans_buf_set_type(args->trans, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\tleaf = bp->b_addr;\n\tmemset(leaf, 0, args->geo->blksize);\n\n\tmemset(&ichdr, 0, sizeof(ichdr));\n\tichdr.firstused = args->geo->blksize;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_ATTR3_LEAF_MAGIC;\n\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_meta_uuid);\n\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr3_leaf_hdr);\n\t} else {\n\t\tichdr.magic = XFS_ATTR_LEAF_MAGIC;\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr_leaf_hdr);\n\t}\n\tichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;\n\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);\n\n\t*bpp = bp;\n\treturn 0;\n}\n\n/*\n * Split the leaf node, rebalance, then add the new entry.\n */\nint\nxfs_attr3_leaf_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\txfs_dablk_t blkno;\n\tint error;\n\n\ttrace_xfs_attr_leaf_split(state->args);\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\tASSERT(oldblk->magic == XFS_ATTR_LEAF_MAGIC);\n\terror = xfs_da_grow_inode(state->args, &blkno);\n\tif (error)\n\t\treturn error;\n\terror = xfs_attr3_leaf_create(state->args, blkno, &newblk->bp);\n\tif (error)\n\t\treturn error;\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_ATTR_LEAF_MAGIC;\n\n\t/*\n\t * Rebalance the entries across the two leaves.\n\t * NOTE: rebalance() currently depends on the 2nd block being empty.\n\t */\n\txfs_attr3_leaf_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Save info on \"old\" attribute for \"atomic rename\" ops, leaf_add()\n\t * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the\n\t * \"new\" attrs info.  Will need the \"old\" info to remove it later.\n\t *\n\t * Insert the \"new\" entry in the correct block.\n\t */\n\tif (state->inleaf) {\n\t\ttrace_xfs_attr_leaf_add_old(state->args);\n\t\terror = xfs_attr3_leaf_add(oldblk->bp, state->args);\n\t} else {\n\t\ttrace_xfs_attr_leaf_add_new(state->args);\n\t\terror = xfs_attr3_leaf_add(newblk->bp, state->args);\n\t}\n\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_attr_leaf_lasthash(oldblk->bp, NULL);\n\tnewblk->hashval = xfs_attr_leaf_lasthash(newblk->bp, NULL);\n\treturn error;\n}\n\n/*\n * Add a name to the leaf attribute list structure.\n */\nint\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}\n\n/*\n * Add a name to a leaf attribute list structure.\n */\nSTATIC int\nxfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -= xfs_attr_leaf_newentsize(args, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n\t\tname_rmt->valueblk = 0;\n\t\targs->rmtblkno = 1;\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\targs->rmtvaluelen = args->valuelen;\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}\n\n/*\n * Garbage collect a leaf attribute list block by copying it to a new buffer.\n */\nSTATIC void\nxfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}\n\n/*\n * Compare two leaf blocks \"order\".\n * Return 0 unless leaf2 should go before leaf1.\n */\nstatic int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint\nxfs_attr_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_buf\t*leaf2_bp)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_mount *mp = leaf1_bp->b_target->bt_mount;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr1, leaf1_bp->b_addr);\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr2, leaf2_bp->b_addr);\n\treturn xfs_attr3_leaf_order(leaf1_bp, &ichdr1, leaf2_bp, &ichdr2);\n}\n\n/*\n * Redistribute the attribute list entries between two leaf nodes,\n * taking into account the size of the new entry.\n *\n * NOTE: if new block is empty, then it will get the upper half of the\n * old block.  At present, all (one) callers pass in an empty second block.\n *\n * This code adjusts the args->index/blkno and args->index2/blkno2 fields\n * to match what it is doing in splitting the attribute leaf block.  Those\n * values are used in \"atomic rename\" operations on attributes.  Note that\n * the \"new\" and \"old\" values can end up in different blocks.\n */\nSTATIC void\nxfs_attr3_leaf_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\tint\t\t\tcount;\n\tint\t\t\ttotallen;\n\tint\t\t\tmax;\n\tint\t\t\tspace;\n\tint\t\t\tswap;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(blk1->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(blk2->magic == XFS_ATTR_LEAF_MAGIC);\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr1, leaf1);\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr2, leaf2);\n\tASSERT(ichdr2.count == 0);\n\targs = state->args;\n\n\ttrace_xfs_attr_leaf_rebalance(args);\n\n\t/*\n\t * Check ordering of blocks, reverse if it makes things simpler.\n\t *\n\t * NOTE: Given that all (current) callers pass in an empty\n\t * second block, this code should never set \"swap\".\n\t */\n\tswap = 0;\n\tif (xfs_attr3_leaf_order(blk1->bp, &ichdr1, blk2->bp, &ichdr2)) {\n\t\tstruct xfs_da_state_blk\t*tmp_blk;\n\t\tstruct xfs_attr3_icleaf_hdr tmp_ichdr;\n\n\t\ttmp_blk = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp_blk;\n\n\t\t/* struct copies to swap them rather than reconverting */\n\t\ttmp_ichdr = ichdr1;\n\t\tichdr1 = ichdr2;\n\t\tichdr2 = tmp_ichdr;\n\n\t\tleaf1 = blk1->bp->b_addr;\n\t\tleaf2 = blk2->bp->b_addr;\n\t\tswap = 1;\n\t}\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.  Then get\n\t * the direction to copy and the number of elements to move.\n\t *\n\t * \"inleaf\" is true if the new entry should be inserted into blk1.\n\t * If \"swap\" is also true, then reverse the sense of \"inleaf\".\n\t */\n\tstate->inleaf = xfs_attr3_leaf_figure_balance(state, blk1, &ichdr1,\n\t\t\t\t\t\t      blk2, &ichdr2,\n\t\t\t\t\t\t      &count, &totallen);\n\tif (swap)\n\t\tstate->inleaf = !state->inleaf;\n\n\t/*\n\t * Move any entries required from leaf to leaf:\n\t */\n\tif (count < ichdr1.count) {\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount = ichdr1.count - count;\n\t\tspace  = ichdr1.usedbytes - totallen;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf2 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr2.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr2.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr2, blk2->bp);\n\n\t\t/*\n\t\t * Move high entries from leaf1 to low end of leaf2.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf1, &ichdr1,\n\t\t\t\tichdr1.count - count, leaf2, &ichdr2, 0, count);\n\n\t} else if (count > ichdr1.count) {\n\t\t/*\n\t\t * I assert that since all callers pass in an empty\n\t\t * second buffer, this code should never execute.\n\t\t */\n\t\tASSERT(0);\n\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount -= ichdr1.count;\n\t\tspace  = totallen - ichdr1.usedbytes;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf1 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr1.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr1.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr1, blk1->bp);\n\n\t\t/*\n\t\t * Move low entries from leaf2 to high end of leaf1.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf2, &ichdr2, 0, leaf1, &ichdr1,\n\t\t\t\t\tichdr1.count, count);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(state->args->geo, leaf1, &ichdr1);\n\txfs_attr3_leaf_hdr_to_disk(state->args->geo, leaf2, &ichdr2);\n\txfs_trans_log_buf(args->trans, blk1->bp, 0, args->geo->blksize - 1);\n\txfs_trans_log_buf(args->trans, blk2->bp, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentries1 = xfs_attr3_leaf_entryp(leaf1);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2);\n\tblk1->hashval = be32_to_cpu(entries1[ichdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(entries2[ichdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t * NOTE: this code depends on the (current) situation that the\n\t * second block was originally empty.\n\t *\n\t * If the insertion point moved to the 2nd block, we must adjust\n\t * the index.  We must also track the entry just following the\n\t * new entry for use in an \"atomic rename\" operation, that entry\n\t * is always the \"old\" entry and the \"new\" entry is what we are\n\t * inserting.  The index/blkno fields refer to the \"old\" entry,\n\t * while the index2/blkno2 fields refer to the \"new\" entry.\n\t */\n\tif (blk1->index > ichdr1.count) {\n\t\tASSERT(state->inleaf == 0);\n\t\tblk2->index = blk1->index - ichdr1.count;\n\t\targs->index = args->index2 = blk2->index;\n\t\targs->blkno = args->blkno2 = blk2->blkno;\n\t} else if (blk1->index == ichdr1.count) {\n\t\tif (state->inleaf) {\n\t\t\targs->index = blk1->index;\n\t\t\targs->blkno = blk1->blkno;\n\t\t\targs->index2 = 0;\n\t\t\targs->blkno2 = blk2->blkno;\n\t\t} else {\n\t\t\t/*\n\t\t\t * On a double leaf split, the original attr location\n\t\t\t * is already stored in blkno2/index2, so don't\n\t\t\t * overwrite it overwise we corrupt the tree.\n\t\t\t */\n\t\t\tblk2->index = blk1->index - ichdr1.count;\n\t\t\targs->index = blk2->index;\n\t\t\targs->blkno = blk2->blkno;\n\t\t\tif (!state->extravalid) {\n\t\t\t\t/*\n\t\t\t\t * set the new attr location to match the old\n\t\t\t\t * one and let the higher level split code\n\t\t\t\t * decide where in the leaf to place it.\n\t\t\t\t */\n\t\t\t\targs->index2 = blk2->index;\n\t\t\t\targs->blkno2 = blk2->blkno;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tASSERT(state->inleaf == 1);\n\t\targs->index = args->index2 = blk1->index;\n\t\targs->blkno = args->blkno2 = blk1->blkno;\n\t}\n}\n\n/*\n * Examine entries until we reduce the absolute difference in\n * byte usage between the two blocks to a minimum.\n * GROT: Is this really necessary?  With other than a 512 byte blocksize,\n * GROT: there will always be enough room in either block for a new entry.\n * GROT: Do a double-split for this case?\n */\nSTATIC int\nxfs_attr3_leaf_figure_balance(\n\tstruct xfs_da_state\t\t*state,\n\tstruct xfs_da_state_blk\t\t*blk1,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr1,\n\tstruct xfs_da_state_blk\t\t*blk2,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr2,\n\tint\t\t\t\t*countarg,\n\tint\t\t\t\t*usedbytesarg)\n{\n\tstruct xfs_attr_leafblock\t*leaf1 = blk1->bp->b_addr;\n\tstruct xfs_attr_leafblock\t*leaf2 = blk2->bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tcount;\n\tint\t\t\t\tmax;\n\tint\t\t\t\tindex;\n\tint\t\t\t\ttotallen = 0;\n\tint\t\t\t\thalf;\n\tint\t\t\t\tlastdelta;\n\tint\t\t\t\tfoundit = 0;\n\tint\t\t\t\ttmp;\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.\n\t */\n\tmax = ichdr1->count + ichdr2->count;\n\thalf = (max + 1) * sizeof(*entry);\n\thalf += ichdr1->usedbytes + ichdr2->usedbytes +\n\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\thalf /= 2;\n\tlastdelta = state->args->geo->blksize;\n\tentry = xfs_attr3_leaf_entryp(leaf1);\n\tfor (count = index = 0; count < max; entry++, index++, count++) {\n\n#define XFS_ATTR_ABS(A)\t(((A) < 0) ? -(A) : (A))\n\t\t/*\n\t\t * The new entry is in the first block, account for it.\n\t\t */\n\t\tif (count == blk1->index) {\n\t\t\ttmp = totallen + sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\t\tbreak;\n\t\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\t\ttotallen = tmp;\n\t\t\tfoundit = 1;\n\t\t}\n\n\t\t/*\n\t\t * Wrap around into the second block if necessary.\n\t\t */\n\t\tif (count == ichdr1->count) {\n\t\t\tleaf1 = leaf2;\n\t\t\tentry = xfs_attr3_leaf_entryp(leaf1);\n\t\t\tindex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Figure out if next leaf entry would be too much.\n\t\t */\n\t\ttmp = totallen + sizeof(*entry) + xfs_attr_leaf_entsize(leaf1,\n\t\t\t\t\t\t\t\t\tindex);\n\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\tbreak;\n\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\ttotallen = tmp;\n#undef XFS_ATTR_ABS\n\t}\n\n\t/*\n\t * Calculate the number of usedbytes that will end up in lower block.\n\t * If new entry not in lower block, fix up the count.\n\t */\n\ttotallen -= count * sizeof(*entry);\n\tif (foundit) {\n\t\ttotallen -= sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t}\n\n\t*countarg = count;\n\t*usedbytesarg = totallen;\n\treturn foundit;\n}\n\n/*========================================================================\n * Routines used for shrinking the Btree.\n *========================================================================*/\n\n/*\n * Check a leaf block and its neighbors to see if the block should be\n * collapsed into one or the other neighbor.  Always keep the block\n * with the smaller block number.\n * If the current block is over 50% full, don't try to join it, return 0.\n * If the block is empty, fill in the state structure and return 2.\n * If it can be collapsed, fill in the state structure and return 1.\n * If nothing can be done, return 0.\n *\n * GROT: allow for INCOMPLETE entries in calculation.\n */\nint\nxfs_attr3_leaf_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tbytes;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tleaf = blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr, leaf);\n\tbytes = xfs_attr3_leaf_hdr_size(leaf) +\n\t\tichdr.count * sizeof(xfs_attr_leaf_entry_t) +\n\t\tichdr.usedbytes;\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (ichdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (ichdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink an attribute list over time.\n\t */\n\t/* start with smaller blk num */\n\tforward = ichdr.forw < ichdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\t\tif (forward)\n\t\t\tblkno = ichdr.forw;\n\t\telse\n\t\t\tblkno = ichdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_attr3_leaf_read(state->args->trans, state->args->dp,\n\t\t\t\t\tblkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr2, bp->b_addr);\n\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2) -\n\t\t\tichdr.usedbytes - ichdr2.usedbytes -\n\t\t\t((ichdr.count + ichdr2.count) *\n\t\t\t\t\tsizeof(xfs_attr_leaf_entry_t)) -\n\t\t\txfs_attr3_leaf_hdr_size(leaf);\n\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t\tif (bytes >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t} else {\n\t\t*action = 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Remove a name from the leaf attribute list structure.\n *\n * Return 1 if leaf is less than 37% full, 0 if >= 37% full.\n * If two leaves are 37% full, when combined they will leave 25% free.\n */\nint\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tASSERT(ichdr.firstused != 0);\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}\n\n/*\n * Move all the attribute list entries from drop_leaf into save_leaf.\n */\nvoid\nxfs_attr3_leaf_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_attr_leafblock *drop_leaf = drop_blk->bp->b_addr;\n\tstruct xfs_attr_leafblock *save_leaf = save_blk->bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr drophdr;\n\tstruct xfs_attr3_icleaf_hdr savehdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\n\ttrace_xfs_attr_leaf_unbalance(state->args);\n\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &drophdr, drop_leaf);\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &savehdr, save_leaf);\n\tentry = xfs_attr3_leaf_entryp(drop_leaf);\n\n\t/*\n\t * Save last hashval from dying block for later Btree fixup.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(entry[drophdr.count - 1].hashval);\n\n\t/*\n\t * Check if we need a temp buffer, or can we do it in place.\n\t * Note that we don't check \"leaf\" for holes because we will\n\t * always be dropping it, toosmall() decided that for us already.\n\t */\n\tif (savehdr.holes == 0) {\n\t\t/*\n\t\t * dest leaf has no holes, so we add there.  May need\n\t\t * to make some room in the entry array.\n\t\t */\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr,\n\t\t\t\t\t\tsavehdr.count, drophdr.count);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Destination has holes, so we make a temporary copy\n\t\t * of the leaf and add them both to that.\n\t\t */\n\t\tstruct xfs_attr_leafblock *tmp_leaf;\n\t\tstruct xfs_attr3_icleaf_hdr tmphdr;\n\n\t\ttmp_leaf = kmem_zalloc(state->args->geo->blksize, KM_SLEEP);\n\n\t\t/*\n\t\t * Copy the header into the temp leaf so that all the stuff\n\t\t * not in the incore header is present and gets copied back in\n\t\t * once we've moved all the entries.\n\t\t */\n\t\tmemcpy(tmp_leaf, save_leaf, xfs_attr3_leaf_hdr_size(save_leaf));\n\n\t\tmemset(&tmphdr, 0, sizeof(tmphdr));\n\t\ttmphdr.magic = savehdr.magic;\n\t\ttmphdr.forw = savehdr.forw;\n\t\ttmphdr.back = savehdr.back;\n\t\ttmphdr.firstused = state->args->geo->blksize;\n\n\t\t/* write the header to the temp buffer to initialise it */\n\t\txfs_attr3_leaf_hdr_to_disk(state->args->geo, tmp_leaf, &tmphdr);\n\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tsavehdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tsavehdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tdrophdr.count);\n\t\t}\n\t\tmemcpy(save_leaf, tmp_leaf, state->args->geo->blksize);\n\t\tsavehdr = tmphdr; /* struct copy */\n\t\tkmem_free(tmp_leaf);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(state->args->geo, save_leaf, &savehdr);\n\txfs_trans_log_buf(state->args->trans, save_blk->bp, 0,\n\t\t\t\t\t   state->args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentry = xfs_attr3_leaf_entryp(save_leaf);\n\tsave_blk->hashval = be32_to_cpu(entry[savehdr.count - 1].hashval);\n}\n\n/*========================================================================\n * Routines used for finding things in the Btree.\n *========================================================================*/\n\n/*\n * Look up a name in a leaf attribute list structure.\n * This is the internal routine, it uses the caller's buffer.\n *\n * Note that duplicate keys are allowed, but only check within the\n * current leaf node.  The Btree code must check in adjacent leaf nodes.\n *\n * Return in args->index the index into the entry[] array of either\n * the found entry, or where the entry should have been (insert before\n * that entry).\n *\n * Don't change the args->value unless we find the attribute.\n */\nint\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (ichdr.count >= args->geo->blksize / 8)\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!(probe >= 0 && (!ichdr.count || probe < ichdr.count)))\n\t\treturn -EFSCORRUPTED;\n\tif (!(span <= 4 || be32_to_cpu(entry->hashval) == hashval))\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}\n\n/*\n * Get the value associated with an attribute name from a leaf attribute\n * list structure.\n */\nint\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}\n\n/*========================================================================\n * Utility routines.\n *========================================================================*/\n\n/*\n * Move the indicated entries from one leaf to another.\n * NOTE: this routine modifies both source and destination leaves.\n */\n/*ARGSUSED*/\nSTATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll_inode(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll_inode(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll_inode(&args->trans, args->dp);\n\n\treturn error;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2000-2005 Silicon Graphics, Inc.\n * Copyright (c) 2013 Red Hat, Inc.\n * All Rights Reserved.\n */\n#include \"xfs.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_format.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_log.h\"\n\n\n/*\n * xfs_attr_leaf.c\n *\n * Routines to implement leaf blocks of attributes as Btrees of hashed names.\n */\n\n/*========================================================================\n * Function prototypes for the kernel.\n *========================================================================*/\n\n/*\n * Routines used for growing the Btree.\n */\nSTATIC int xfs_attr3_leaf_create(struct xfs_da_args *args,\n\t\t\t\t xfs_dablk_t which_block, struct xfs_buf **bpp);\nSTATIC int xfs_attr3_leaf_add_work(struct xfs_buf *leaf_buffer,\n\t\t\t\t   struct xfs_attr3_icleaf_hdr *ichdr,\n\t\t\t\t   struct xfs_da_args *args, int freemap_index);\nSTATIC void xfs_attr3_leaf_compact(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_attr3_icleaf_hdr *ichdr,\n\t\t\t\t   struct xfs_buf *leaf_buffer);\nSTATIC void xfs_attr3_leaf_rebalance(xfs_da_state_t *state,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk1,\n\t\t\t\t\t\t   xfs_da_state_blk_t *blk2);\nSTATIC int xfs_attr3_leaf_figure_balance(xfs_da_state_t *state,\n\t\t\txfs_da_state_blk_t *leaf_blk_1,\n\t\t\tstruct xfs_attr3_icleaf_hdr *ichdr1,\n\t\t\txfs_da_state_blk_t *leaf_blk_2,\n\t\t\tstruct xfs_attr3_icleaf_hdr *ichdr2,\n\t\t\tint *number_entries_in_blk1,\n\t\t\tint *number_usedbytes_in_blk1);\n\n/*\n * Utility routines.\n */\nSTATIC void xfs_attr3_leaf_moveents(struct xfs_da_args *args,\n\t\t\tstruct xfs_attr_leafblock *src_leaf,\n\t\t\tstruct xfs_attr3_icleaf_hdr *src_ichdr, int src_start,\n\t\t\tstruct xfs_attr_leafblock *dst_leaf,\n\t\t\tstruct xfs_attr3_icleaf_hdr *dst_ichdr, int dst_start,\n\t\t\tint move_count);\nSTATIC int xfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index);\n\n/*\n * attr3 block 'firstused' conversion helpers.\n *\n * firstused refers to the offset of the first used byte of the nameval region\n * of an attr leaf block. The region starts at the tail of the block and expands\n * backwards towards the middle. As such, firstused is initialized to the block\n * size for an empty leaf block and is reduced from there.\n *\n * The attr3 block size is pegged to the fsb size and the maximum fsb is 64k.\n * The in-core firstused field is 32-bit and thus supports the maximum fsb size.\n * The on-disk field is only 16-bit, however, and overflows at 64k. Since this\n * only occurs at exactly 64k, we use zero as a magic on-disk value to represent\n * the attr block size. The following helpers manage the conversion between the\n * in-core and on-disk formats.\n */\n\nstatic void\nxfs_attr3_leaf_firstused_from_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tstruct xfs_attr3_leaf_hdr\t*hdr3;\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\thdr3 = (struct xfs_attr3_leaf_hdr *) from;\n\t\tto->firstused = be16_to_cpu(hdr3->firstused);\n\t} else {\n\t\tto->firstused = be16_to_cpu(from->hdr.firstused);\n\t}\n\n\t/*\n\t * Convert from the magic fsb size value to actual blocksize. This\n\t * should only occur for empty blocks when the block size overflows\n\t * 16-bits.\n\t */\n\tif (to->firstused == XFS_ATTR3_LEAF_NULLOFF) {\n\t\tASSERT(!to->count && !to->usedbytes);\n\t\tASSERT(geo->blksize > USHRT_MAX);\n\t\tto->firstused = geo->blksize;\n\t}\n}\n\nstatic void\nxfs_attr3_leaf_firstused_to_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tstruct xfs_attr3_leaf_hdr\t*hdr3;\n\tuint32_t\t\t\tfirstused;\n\n\t/* magic value should only be seen on disk */\n\tASSERT(from->firstused != XFS_ATTR3_LEAF_NULLOFF);\n\n\t/*\n\t * Scale down the 32-bit in-core firstused value to the 16-bit on-disk\n\t * value. This only overflows at the max supported value of 64k. Use the\n\t * magic on-disk value to represent block size in this case.\n\t */\n\tfirstused = from->firstused;\n\tif (firstused > USHRT_MAX) {\n\t\tASSERT(from->firstused == geo->blksize);\n\t\tfirstused = XFS_ATTR3_LEAF_NULLOFF;\n\t}\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\thdr3 = (struct xfs_attr3_leaf_hdr *) to;\n\t\thdr3->firstused = cpu_to_be16(firstused);\n\t} else {\n\t\tto->hdr.firstused = cpu_to_be16(firstused);\n\t}\n}\n\nvoid\nxfs_attr3_leaf_hdr_from_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr3_icleaf_hdr\t*to,\n\tstruct xfs_attr_leafblock\t*from)\n{\n\tint\ti;\n\n\tASSERT(from->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t       from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\tif (from->hdr.info.magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC)) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)from;\n\n\t\tto->forw = be32_to_cpu(hdr3->info.hdr.forw);\n\t\tto->back = be32_to_cpu(hdr3->info.hdr.back);\n\t\tto->magic = be16_to_cpu(hdr3->info.hdr.magic);\n\t\tto->count = be16_to_cpu(hdr3->count);\n\t\tto->usedbytes = be16_to_cpu(hdr3->usedbytes);\n\t\txfs_attr3_leaf_firstused_from_disk(geo, to, from);\n\t\tto->holes = hdr3->holes;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\tto->freemap[i].base = be16_to_cpu(hdr3->freemap[i].base);\n\t\t\tto->freemap[i].size = be16_to_cpu(hdr3->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->forw = be32_to_cpu(from->hdr.info.forw);\n\tto->back = be32_to_cpu(from->hdr.info.back);\n\tto->magic = be16_to_cpu(from->hdr.info.magic);\n\tto->count = be16_to_cpu(from->hdr.count);\n\tto->usedbytes = be16_to_cpu(from->hdr.usedbytes);\n\txfs_attr3_leaf_firstused_from_disk(geo, to, from);\n\tto->holes = from->hdr.holes;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->freemap[i].base = be16_to_cpu(from->hdr.freemap[i].base);\n\t\tto->freemap[i].size = be16_to_cpu(from->hdr.freemap[i].size);\n\t}\n}\n\nvoid\nxfs_attr3_leaf_hdr_to_disk(\n\tstruct xfs_da_geometry\t\t*geo,\n\tstruct xfs_attr_leafblock\t*to,\n\tstruct xfs_attr3_icleaf_hdr\t*from)\n{\n\tint\t\t\t\ti;\n\n\tASSERT(from->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       from->magic == XFS_ATTR3_LEAF_MAGIC);\n\n\tif (from->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\tstruct xfs_attr3_leaf_hdr *hdr3 = (struct xfs_attr3_leaf_hdr *)to;\n\n\t\thdr3->info.hdr.forw = cpu_to_be32(from->forw);\n\t\thdr3->info.hdr.back = cpu_to_be32(from->back);\n\t\thdr3->info.hdr.magic = cpu_to_be16(from->magic);\n\t\thdr3->count = cpu_to_be16(from->count);\n\t\thdr3->usedbytes = cpu_to_be16(from->usedbytes);\n\t\txfs_attr3_leaf_firstused_to_disk(geo, to, from);\n\t\thdr3->holes = from->holes;\n\t\thdr3->pad1 = 0;\n\n\t\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\t\thdr3->freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\t\thdr3->freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t\t}\n\t\treturn;\n\t}\n\tto->hdr.info.forw = cpu_to_be32(from->forw);\n\tto->hdr.info.back = cpu_to_be32(from->back);\n\tto->hdr.info.magic = cpu_to_be16(from->magic);\n\tto->hdr.count = cpu_to_be16(from->count);\n\tto->hdr.usedbytes = cpu_to_be16(from->usedbytes);\n\txfs_attr3_leaf_firstused_to_disk(geo, to, from);\n\tto->hdr.holes = from->holes;\n\tto->hdr.pad1 = 0;\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tto->hdr.freemap[i].base = cpu_to_be16(from->freemap[i].base);\n\t\tto->hdr.freemap[i].size = cpu_to_be16(from->freemap[i].size);\n\t}\n}\n\nstatic xfs_failaddr_t\nxfs_attr3_leaf_verify(\n\tstruct xfs_buf\t\t\t*bp)\n{\n\tstruct xfs_attr3_icleaf_hdr\tichdr;\n\tstruct xfs_mount\t\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_attr_leafblock\t*leaf = bp->b_addr;\n\tstruct xfs_perag\t\t*pag = bp->b_pag;\n\tstruct xfs_attr_leaf_entry\t*entries;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, leaf);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_node_hdr *hdr3 = bp->b_addr;\n\n\t\tif (ichdr.magic != XFS_ATTR3_LEAF_MAGIC)\n\t\t\treturn __this_address;\n\n\t\tif (!uuid_equal(&hdr3->info.uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (be64_to_cpu(hdr3->info.blkno) != bp->b_bn)\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp, be64_to_cpu(hdr3->info.lsn)))\n\t\t\treturn __this_address;\n\t} else {\n\t\tif (ichdr.magic != XFS_ATTR_LEAF_MAGIC)\n\t\t\treturn __this_address;\n\t}\n\t/*\n\t * In recovery there is a transient state where count == 0 is valid\n\t * because we may have transitioned an empty shortform attr to a leaf\n\t * if the attr didn't fit in shortform.\n\t */\n\tif (pag && pag->pagf_init && ichdr.count == 0)\n\t\treturn __this_address;\n\n\t/*\n\t * firstused is the block offset of the first name info structure.\n\t * Make sure it doesn't go off the block or crash into the header.\n\t */\n\tif (ichdr.firstused > mp->m_attr_geo->blksize)\n\t\treturn __this_address;\n\tif (ichdr.firstused < xfs_attr3_leaf_hdr_size(leaf))\n\t\treturn __this_address;\n\n\t/* Make sure the entries array doesn't crash into the name info. */\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif ((char *)&entries[ichdr.count] >\n\t    (char *)bp->b_addr + ichdr.firstused)\n\t\treturn __this_address;\n\n\t/* XXX: need to range check rest of attr header values */\n\t/* XXX: hash order check? */\n\n\treturn NULL;\n}\n\nstatic void\nxfs_attr3_leaf_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_log_item;\n\tstruct xfs_attr3_leaf_hdr *hdr3 = bp->b_addr;\n\txfs_failaddr_t\t\tfa;\n\n\tfa = xfs_attr3_leaf_verify(bp);\n\tif (fa) {\n\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->info.lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF);\n}\n\n/*\n * leaf/node format detection on trees is sketchy, so a node read can be done on\n * leaf level blocks when detection identifies the tree as a node format tree\n * incorrectly. In this case, we need to swap the verifier to match the correct\n * format of the block being read.\n */\nstatic void\nxfs_attr3_leaf_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\txfs_failaddr_t\t\tfa;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_buf_verify_cksum(bp, XFS_ATTR3_LEAF_CRC_OFF))\n\t\txfs_verifier_error(bp, -EFSBADCRC, __this_address);\n\telse {\n\t\tfa = xfs_attr3_leaf_verify(bp);\n\t\tif (fa)\n\t\t\txfs_verifier_error(bp, -EFSCORRUPTED, fa);\n\t}\n}\n\nconst struct xfs_buf_ops xfs_attr3_leaf_buf_ops = {\n\t.name = \"xfs_attr3_leaf\",\n\t.verify_read = xfs_attr3_leaf_read_verify,\n\t.verify_write = xfs_attr3_leaf_write_verify,\n\t.verify_struct = xfs_attr3_leaf_verify,\n};\n\nint\nxfs_attr3_leaf_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\n\t\t\t\tXFS_ATTR_FORK, &xfs_attr3_leaf_buf_ops);\n\tif (!err && tp && *bpp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_ATTR_LEAF_BUF);\n\treturn err;\n}\n\n/*========================================================================\n * Namespace helper routines\n *========================================================================*/\n\n/*\n * If namespace bits don't match return 0.\n * If all match then return 1.\n */\nSTATIC int\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\n{\n\treturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\n}\n\n\n/*========================================================================\n * External routines when attribute fork size < XFS_LITINO(mp).\n *========================================================================*/\n\n/*\n * Query whether the requested number of additional bytes of extended\n * attribute space will be able to fit inline.\n *\n * Returns zero if not, else the di_forkoff fork offset to be used in the\n * literal area for attribute data once the new bytes have been added.\n *\n * di_forkoff must be 8 byte aligned, hence is stored as a >>3 value;\n * special case for dev/uuid inodes, they have fixed size data forks.\n */\nint\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_DEV) {\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = max(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}\n\n/*\n * Switch on the ATTR2 superblock bit (implies also FEATURES2)\n */\nSTATIC void\nxfs_sbversion_add_attr2(xfs_mount_t *mp, xfs_trans_t *tp)\n{\n\tif ((mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    !(xfs_sb_version_hasattr2(&mp->m_sb))) {\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t\t\txfs_log_sb(tp);\n\t\t} else\n\t\t\tspin_unlock(&mp->m_sb_lock);\n\t}\n}\n\n/*\n * Create the initial contents of a shortform attribute list.\n */\nvoid\nxfs_attr_shortform_create(xfs_da_args_t *args)\n{\n\txfs_attr_sf_hdr_t *hdr;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_create(args);\n\n\tdp = args->dp;\n\tASSERT(dp != NULL);\n\tifp = dp->i_afp;\n\tASSERT(ifp != NULL);\n\tASSERT(ifp->if_bytes == 0);\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) {\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\t/* just in case */\n\t\tdp->i_d.di_aformat = XFS_DINODE_FMT_LOCAL;\n\t\tifp->if_flags |= XFS_IFINLINE;\n\t} else {\n\t\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t}\n\txfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\n\thdr = (xfs_attr_sf_hdr_t *)ifp->if_u1.if_data;\n\thdr->count = 0;\n\thdr->totsize = cpu_to_be16(sizeof(*hdr));\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n}\n\n/*\n * Add a name/value pair to the shortform attribute list.\n * Overflow from the inode has already been checked for.\n */\nvoid\nxfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i, offset, size;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_add(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_d.di_forkoff = forkoff;\n\n\tifp = dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n#ifdef DEBUG\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tASSERT(0);\n#endif\n\t}\n\n\toffset = (char *)sfe - (char *)sf;\n\tsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\n\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n}\n\n/*\n * After the last attribute is removed revert to original inode format,\n * making all literal area available to the data fork once more.\n */\nvoid\nxfs_attr_fork_remove(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}\n\n/*\n * Remove an attribute from the shortform attribute list structure.\n */\nint\nxfs_attr_shortform_remove(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint base, size=0, end, totsize, i;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\n\ttrace_xfs_attr_sf_remove(args);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tbase = sizeof(xfs_attr_sf_hdr_t);\n\tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tend = sf->hdr.count;\n\tfor (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),\n\t\t\t\t\tbase += size, i++) {\n\t\tsize = XFS_ATTR_SF_ENTSIZE(sfe);\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(sfe->nameval, args->name, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (i == end)\n\t\treturn -ENOATTR;\n\n\t/*\n\t * Fix up the attribute fork data, covering the hole\n\t */\n\tend = base + size;\n\ttotsize = be16_to_cpu(sf->hdr.totsize);\n\tif (end != totsize)\n\t\tmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\n\tsf->hdr.count--;\n\tbe16_add_cpu(&sf->hdr.totsize, -size);\n\n\t/*\n\t * Fix up the start offset of the attribute fork\n\t */\n\ttotsize -= size;\n\tif (totsize == sizeof(xfs_attr_sf_hdr_t) &&\n\t    (mp->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    !(args->op_flags & XFS_DA_OP_ADDNAME)) {\n\t\txfs_attr_fork_remove(dp, args->trans);\n\t} else {\n\t\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\t\tdp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\n\t\tASSERT(dp->i_d.di_forkoff);\n\t\tASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\n\t\t\t\t(args->op_flags & XFS_DA_OP_ADDNAME) ||\n\t\t\t\t!(mp->m_flags & XFS_MOUNT_ATTR2) ||\n\t\t\t\tdp->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\t\txfs_trans_log_inode(args->trans, dp,\n\t\t\t\t\tXFS_ILOG_CORE | XFS_ILOG_ADATA);\n\t}\n\n\txfs_sbversion_add_attr2(mp, args->trans);\n\n\treturn 0;\n}\n\n/*\n * Look up a name in a shortform attribute list structure.\n */\n/*ARGSUSED*/\nint\nxfs_attr_shortform_lookup(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_lookup(args);\n\n\tifp = args->dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}\n\n/*\n * Look up a name in a shortform attribute list structure.\n */\n/*ARGSUSED*/\nint\nxfs_attr_shortform_getvalue(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\n\tASSERT(args->dp->i_afp->if_flags == XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)args->dp->i_afp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (args->valuelen < sfe->valuelen) {\n\t\t\targs->valuelen = sfe->valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = sfe->valuelen;\n\t\tmemcpy(args->value, &sfe->nameval[args->namelen],\n\t\t\t\t\t\t    args->valuelen);\n\t\treturn -EEXIST;\n\t}\n\treturn -ENOATTR;\n}\n\n/*\n * Convert from using the shortform to the leaf.  On success, return the\n * buffer so that we can keep it locked until we're totally done with it.\n */\nint\nxfs_attr_shortform_to_leaf(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t**leaf_bp)\n{\n\txfs_inode_t *dp;\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\txfs_da_args_t nargs;\n\tchar *tmpbuffer;\n\tint error, i, size;\n\txfs_dablk_t blkno;\n\tstruct xfs_buf *bp;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_to_leaf(args);\n\n\tdp = args->dp;\n\tifp = dp->i_afp;\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsize = be16_to_cpu(sf->hdr.totsize);\n\ttmpbuffer = kmem_alloc(size, KM_SLEEP);\n\tASSERT(tmpbuffer != NULL);\n\tmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\n\tsf = (xfs_attr_shortform_t *)tmpbuffer;\n\n\txfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_ATTR_FORK);\n\n\tbp = NULL;\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\t/*\n\t\t * If we hit an IO error middle of the transaction inside\n\t\t * grow_inode(), we may have inconsistent data. Bail out.\n\t\t */\n\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\t/* xfs_attr3_leaf_create may not have instantiated a block */\n\t\tif (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; i++) {\n\t\tnargs.name = sfe->nameval;\n\t\tnargs.namelen = sfe->namelen;\n\t\tnargs.value = &sfe->nameval[nargs.namelen];\n\t\tnargs.valuelen = sfe->valuelen;\n\t\tnargs.hashval = xfs_da_hashname(sfe->nameval,\n\t\t\t\t\t\tsfe->namelen);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\n\t\terror = xfs_attr3_leaf_lookup_int(bp, &nargs); /* set a->index */\n\t\tASSERT(error == -ENOATTR);\n\t\terror = xfs_attr3_leaf_add(bp, &nargs);\n\t\tASSERT(error != -ENOSPC);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\n\t}\n\terror = 0;\n\t*leaf_bp = bp;\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}\n\n/*\n * Check a leaf attribute block to see if all the entries would fit into\n * a shortform attribute list.\n */\nint\nxfs_attr_shortform_allfit(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tstruct xfs_attr3_icleaf_hdr leafhdr;\n\tint\t\t\tbytes;\n\tint\t\t\ti;\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &leafhdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\tbytes = sizeof(struct xfs_attr_sf_hdr);\n\tfor (i = 0; i < leafhdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t\t/* don't copy partial entries */\n\t\tif (!(entry->flags & XFS_ATTR_LOCAL))\n\t\t\treturn 0;\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\t\treturn 0;\n\t\tbytes += sizeof(struct xfs_attr_sf_entry) - 1\n\t\t\t\t+ name_loc->namelen\n\t\t\t\t+ be16_to_cpu(name_loc->valuelen);\n\t}\n\tif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\n\t    (dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\n\t    (bytes == sizeof(struct xfs_attr_sf_hdr)))\n\t\treturn -1;\n\treturn xfs_attr_shortform_bytesfit(dp, bytes);\n}\n\n/* Verify the consistency of an inline attribute fork. */\nxfs_failaddr_t\nxfs_attr_shortform_verify(\n\tstruct xfs_inode\t\t*ip)\n{\n\tstruct xfs_attr_shortform\t*sfp;\n\tstruct xfs_attr_sf_entry\t*sfep;\n\tstruct xfs_attr_sf_entry\t*next_sfep;\n\tchar\t\t\t\t*endp;\n\tstruct xfs_ifork\t\t*ifp;\n\tint\t\t\t\ti;\n\tint\t\t\t\tsize;\n\n\tASSERT(ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL);\n\tifp = XFS_IFORK_PTR(ip, XFS_ATTR_FORK);\n\tsfp = (struct xfs_attr_shortform *)ifp->if_u1.if_data;\n\tsize = ifp->if_bytes;\n\n\t/*\n\t * Give up if the attribute is way too short.\n\t */\n\tif (size < sizeof(struct xfs_attr_sf_hdr))\n\t\treturn __this_address;\n\n\tendp = (char *)sfp + size;\n\n\t/* Check all reported entries */\n\tsfep = &sfp->list[0];\n\tfor (i = 0; i < sfp->hdr.count; i++) {\n\t\t/*\n\t\t * struct xfs_attr_sf_entry has a variable length.\n\t\t * Check the fixed-offset parts of the structure are\n\t\t * within the data buffer.\n\t\t */\n\t\tif (((char *)sfep + sizeof(*sfep)) >= endp)\n\t\t\treturn __this_address;\n\n\t\t/* Don't allow names with known bad length. */\n\t\tif (sfep->namelen == 0)\n\t\t\treturn __this_address;\n\n\t\t/*\n\t\t * Check that the variable-length part of the structure is\n\t\t * within the data buffer.  The next entry starts after the\n\t\t * name component, so nextentry is an acceptable test.\n\t\t */\n\t\tnext_sfep = XFS_ATTR_SF_NEXTENTRY(sfep);\n\t\tif ((char *)next_sfep > endp)\n\t\t\treturn __this_address;\n\n\t\t/*\n\t\t * Check for unknown flags.  Short form doesn't support\n\t\t * the incomplete or local bits, so we can use the namespace\n\t\t * mask here.\n\t\t */\n\t\tif (sfep->flags & ~XFS_ATTR_NSP_ONDISK_MASK)\n\t\t\treturn __this_address;\n\n\t\t/*\n\t\t * Check for invalid namespace combinations.  We only allow\n\t\t * one namespace flag per xattr, so we can just count the\n\t\t * bits (i.e. hweight) here.\n\t\t */\n\t\tif (hweight8(sfep->flags & XFS_ATTR_NSP_ONDISK_MASK) > 1)\n\t\t\treturn __this_address;\n\n\t\tsfep = next_sfep;\n\t}\n\tif ((void *)sfep != (void *)endp)\n\t\treturn __this_address;\n\n\treturn NULL;\n}\n\n/*\n * Convert a leaf attribute list to shortform attribute list\n */\nint\nxfs_attr3_leaf_to_shortform(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tforkoff)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_da_args\tnargs;\n\tstruct xfs_inode\t*dp = args->dp;\n\tchar\t\t\t*tmpbuffer;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_to_sf(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tif (!tmpbuffer)\n\t\treturn -ENOMEM;\n\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\n\tleaf = (xfs_attr_leafblock_t *)tmpbuffer;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\n\t/* XXX (dgc): buffer is about to be marked stale - why zero it? */\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\n\t/*\n\t * Clean out the prior contents of the attribute list.\n\t */\n\terror = xfs_da_shrink_inode(args, 0, bp);\n\tif (error)\n\t\tgoto out;\n\n\tif (forkoff == -1) {\n\t\tASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\n\t\tASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\n\t\txfs_attr_fork_remove(dp, args->trans);\n\t\tgoto out;\n\t}\n\n\txfs_attr_shortform_create(args);\n\n\t/*\n\t * Copy the attributes\n\t */\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.geo = args->geo;\n\tnargs.dp = dp;\n\tnargs.firstblock = args->firstblock;\n\tnargs.dfops = args->dfops;\n\tnargs.total = args->total;\n\tnargs.whichfork = XFS_ATTR_FORK;\n\tnargs.trans = args->trans;\n\tnargs.op_flags = XFS_DA_OP_OKNOENT;\n\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (entry->flags & XFS_ATTR_INCOMPLETE)\n\t\t\tcontinue;\t/* don't copy partial entries */\n\t\tif (!entry->nameidx)\n\t\t\tcontinue;\n\t\tASSERT(entry->flags & XFS_ATTR_LOCAL);\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, i);\n\t\tnargs.name = name_loc->nameval;\n\t\tnargs.namelen = name_loc->namelen;\n\t\tnargs.value = &name_loc->nameval[nargs.namelen];\n\t\tnargs.valuelen = be16_to_cpu(name_loc->valuelen);\n\t\tnargs.hashval = be32_to_cpu(entry->hashval);\n\t\tnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\n\t\txfs_attr_shortform_add(&nargs, forkoff);\n\t}\n\terror = 0;\n\nout:\n\tkmem_free(tmpbuffer);\n\treturn error;\n}\n\n/*\n * Convert from using a single leaf to a root node and a leaf.\n */\nint\nxfs_attr3_leaf_to_node(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr icleafhdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr icnodehdr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp1 = NULL;\n\tstruct xfs_buf\t\t*bp2 = NULL;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_to_node(args);\n\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error)\n\t\tgoto out;\n\terror = xfs_attr3_leaf_read(args->trans, dp, 0, -1, &bp1);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_da_get_buf(args->trans, dp, blkno, -1, &bp2, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\n\t/* copy leaf to new buffer, update identifiers */\n\txfs_trans_buf_set_type(args->trans, bp2, XFS_BLFT_ATTR_LEAF_BUF);\n\tbp2->b_ops = bp1->b_ops;\n\tmemcpy(bp2->b_addr, bp1->b_addr, args->geo->blksize);\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp2->b_addr;\n\t\thdr3->blkno = cpu_to_be64(bp2->b_bn);\n\t}\n\txfs_trans_log_buf(args->trans, bp2, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Set up the new root node.\n\t */\n\terror = xfs_da3_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\n\tif (error)\n\t\tgoto out;\n\tnode = bp1->b_addr;\n\tdp->d_ops->node_hdr_from_disk(&icnodehdr, node);\n\tbtree = dp->d_ops->node_tree_p(node);\n\n\tleaf = bp2->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &icleafhdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\n\t/* both on-disk, don't endian-flip twice */\n\tbtree[0].hashval = entries[icleafhdr.count - 1].hashval;\n\tbtree[0].before = cpu_to_be32(blkno);\n\ticnodehdr.count = 1;\n\tdp->d_ops->node_hdr_to_disk(node, &icnodehdr);\n\txfs_trans_log_buf(args->trans, bp1, 0, args->geo->blksize - 1);\n\terror = 0;\nout:\n\treturn error;\n}\n\n/*========================================================================\n * Routines used for growing the Btree.\n *========================================================================*/\n\n/*\n * Create the initial contents of a leaf attribute list\n * or a leaf in a node attribute list.\n */\nSTATIC int\nxfs_attr3_leaf_create(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\tblkno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\ttrace_xfs_attr_leaf_create(args);\n\n\terror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp,\n\t\t\t\t\t    XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_attr3_leaf_buf_ops;\n\txfs_trans_buf_set_type(args->trans, bp, XFS_BLFT_ATTR_LEAF_BUF);\n\tleaf = bp->b_addr;\n\tmemset(leaf, 0, args->geo->blksize);\n\n\tmemset(&ichdr, 0, sizeof(ichdr));\n\tichdr.firstused = args->geo->blksize;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_da3_blkinfo *hdr3 = bp->b_addr;\n\n\t\tichdr.magic = XFS_ATTR3_LEAF_MAGIC;\n\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_meta_uuid);\n\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr3_leaf_hdr);\n\t} else {\n\t\tichdr.magic = XFS_ATTR_LEAF_MAGIC;\n\t\tichdr.freemap[0].base = sizeof(struct xfs_attr_leaf_hdr);\n\t}\n\tichdr.freemap[0].size = ichdr.firstused - ichdr.freemap[0].base;\n\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp, 0, args->geo->blksize - 1);\n\n\t*bpp = bp;\n\treturn 0;\n}\n\n/*\n * Split the leaf node, rebalance, then add the new entry.\n */\nint\nxfs_attr3_leaf_split(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*oldblk,\n\tstruct xfs_da_state_blk\t*newblk)\n{\n\txfs_dablk_t blkno;\n\tint error;\n\n\ttrace_xfs_attr_leaf_split(state->args);\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\tASSERT(oldblk->magic == XFS_ATTR_LEAF_MAGIC);\n\terror = xfs_da_grow_inode(state->args, &blkno);\n\tif (error)\n\t\treturn error;\n\terror = xfs_attr3_leaf_create(state->args, blkno, &newblk->bp);\n\tif (error)\n\t\treturn error;\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_ATTR_LEAF_MAGIC;\n\n\t/*\n\t * Rebalance the entries across the two leaves.\n\t * NOTE: rebalance() currently depends on the 2nd block being empty.\n\t */\n\txfs_attr3_leaf_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Save info on \"old\" attribute for \"atomic rename\" ops, leaf_add()\n\t * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the\n\t * \"new\" attrs info.  Will need the \"old\" info to remove it later.\n\t *\n\t * Insert the \"new\" entry in the correct block.\n\t */\n\tif (state->inleaf) {\n\t\ttrace_xfs_attr_leaf_add_old(state->args);\n\t\terror = xfs_attr3_leaf_add(oldblk->bp, state->args);\n\t} else {\n\t\ttrace_xfs_attr_leaf_add_new(state->args);\n\t\terror = xfs_attr3_leaf_add(newblk->bp, state->args);\n\t}\n\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_attr_leaf_lasthash(oldblk->bp, NULL);\n\tnewblk->hashval = xfs_attr_leaf_lasthash(newblk->bp, NULL);\n\treturn error;\n}\n\n/*\n * Add a name to the leaf attribute list structure.\n */\nint\nxfs_attr3_leaf_add(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tint\t\t\ttablesize;\n\tint\t\t\tentsize;\n\tint\t\t\tsum;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index >= 0 && args->index <= ichdr.count);\n\tentsize = xfs_attr_leaf_newentsize(args, NULL);\n\n\t/*\n\t * Search through freemap for first-fit on new name length.\n\t * (may need to figure in size of entry struct too)\n\t */\n\ttablesize = (ichdr.count + 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\tfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE - 1; i >= 0; i--) {\n\t\tif (tablesize > ichdr.firstused) {\n\t\t\tsum += ichdr.freemap[i].size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ichdr.freemap[i].size)\n\t\t\tcontinue;\t/* no space in this map */\n\t\ttmp = entsize;\n\t\tif (ichdr.freemap[i].base < ichdr.firstused)\n\t\t\ttmp += sizeof(xfs_attr_leaf_entry_t);\n\t\tif (ichdr.freemap[i].size >= tmp) {\n\t\t\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, i);\n\t\t\tgoto out_log_hdr;\n\t\t}\n\t\tsum += ichdr.freemap[i].size;\n\t}\n\n\t/*\n\t * If there are no holes in the address space of the block,\n\t * and we don't have enough freespace, then compaction will do us\n\t * no good and we should just give up.\n\t */\n\tif (!ichdr.holes && sum < entsize)\n\t\treturn -ENOSPC;\n\n\t/*\n\t * Compact the entries to coalesce free space.\n\t * This may change the hdr->count via dropping INCOMPLETE entries.\n\t */\n\txfs_attr3_leaf_compact(args, &ichdr, bp);\n\n\t/*\n\t * After compaction, the block is guaranteed to have only one\n\t * free region, in freemap[0].  If it is not big enough, give up.\n\t */\n\tif (ichdr.freemap[0].size < (entsize + sizeof(xfs_attr_leaf_entry_t))) {\n\t\ttmp = -ENOSPC;\n\t\tgoto out_log_hdr;\n\t}\n\n\ttmp = xfs_attr3_leaf_add_work(bp, &ichdr, args, 0);\n\nout_log_hdr:\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\tXFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\txfs_attr3_leaf_hdr_size(leaf)));\n\treturn tmp;\n}\n\n/*\n * Add a name to a leaf attribute list structure.\n */\nSTATIC int\nxfs_attr3_leaf_add_work(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_attr3_icleaf_hdr *ichdr,\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tmapindex)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_mount\t*mp;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_add_work(args);\n\n\tleaf = bp->b_addr;\n\tASSERT(mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE);\n\tASSERT(args->index >= 0 && args->index <= ichdr->count);\n\n\t/*\n\t * Force open some space in the entry array and fill it in.\n\t */\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (args->index < ichdr->count) {\n\t\ttmp  = ichdr->count - args->index;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tmemmove(entry + 1, entry, tmp);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\n\t}\n\tichdr->count++;\n\n\t/*\n\t * Allocate space for the new string (at the end of the run).\n\t */\n\tmp = args->trans->t_mountp;\n\tASSERT(ichdr->freemap[mapindex].base < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].base & 0x3) == 0);\n\tASSERT(ichdr->freemap[mapindex].size >=\n\t\txfs_attr_leaf_newentsize(args, NULL));\n\tASSERT(ichdr->freemap[mapindex].size < args->geo->blksize);\n\tASSERT((ichdr->freemap[mapindex].size & 0x3) == 0);\n\n\tichdr->freemap[mapindex].size -= xfs_attr_leaf_newentsize(args, &tmp);\n\n\tentry->nameidx = cpu_to_be16(ichdr->freemap[mapindex].base +\n\t\t\t\t     ichdr->freemap[mapindex].size);\n\tentry->hashval = cpu_to_be32(args->hashval);\n\tentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\n\tentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tif (args->op_flags & XFS_DA_OP_RENAME) {\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\tif ((args->blkno2 == args->blkno) &&\n\t\t    (args->index2 <= args->index)) {\n\t\t\targs->index2++;\n\t\t}\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tASSERT((args->index == 0) ||\n\t       (be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\n\tASSERT((args->index == ichdr->count - 1) ||\n\t       (be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\n\n\t/*\n\t * For \"remote\" attribute values, simply note that we need to\n\t * allocate space for the \"remote\" value.  We can't actually\n\t * allocate the extents in this transaction, and we can't decide\n\t * which blocks they should be as we might allocate more blocks\n\t * as part of this transaction (a split operation for example).\n\t */\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tname_loc->namelen = args->namelen;\n\t\tname_loc->valuelen = cpu_to_be16(args->valuelen);\n\t\tmemcpy((char *)name_loc->nameval, args->name, args->namelen);\n\t\tmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\n\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->namelen = args->namelen;\n\t\tmemcpy((char *)name_rmt->name, args->name, args->namelen);\n\t\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\t\t/* just in case */\n\t\tname_rmt->valuelen = 0;\n\t\tname_rmt->valueblk = 0;\n\t\targs->rmtblkno = 1;\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\t\targs->rmtvaluelen = args->valuelen;\n\t}\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   xfs_attr_leaf_entsize(leaf, args->index)));\n\n\t/*\n\t * Update the control info for this leaf node\n\t */\n\tif (be16_to_cpu(entry->nameidx) < ichdr->firstused)\n\t\tichdr->firstused = be16_to_cpu(entry->nameidx);\n\n\tASSERT(ichdr->firstused >= ichdr->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf));\n\ttmp = (ichdr->count - 1) * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tif (ichdr->freemap[i].base == tmp) {\n\t\t\tichdr->freemap[i].base += sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr->freemap[i].size -= sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\t}\n\tichdr->usedbytes += xfs_attr_leaf_entsize(leaf, args->index);\n\treturn 0;\n}\n\n/*\n * Garbage collect a leaf attribute list block by copying it to a new buffer.\n */\nSTATIC void\nxfs_attr3_leaf_compact(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_attr3_icleaf_hdr *ichdr_dst,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf_src;\n\tstruct xfs_attr_leafblock *leaf_dst;\n\tstruct xfs_attr3_icleaf_hdr ichdr_src;\n\tstruct xfs_trans\t*trans = args->trans;\n\tchar\t\t\t*tmpbuffer;\n\n\ttrace_xfs_attr_leaf_compact(args);\n\n\ttmpbuffer = kmem_alloc(args->geo->blksize, KM_SLEEP);\n\tmemcpy(tmpbuffer, bp->b_addr, args->geo->blksize);\n\tmemset(bp->b_addr, 0, args->geo->blksize);\n\tleaf_src = (xfs_attr_leafblock_t *)tmpbuffer;\n\tleaf_dst = bp->b_addr;\n\n\t/*\n\t * Copy the on-disk header back into the destination buffer to ensure\n\t * all the information in the header that is not part of the incore\n\t * header structure is preserved.\n\t */\n\tmemcpy(bp->b_addr, tmpbuffer, xfs_attr3_leaf_hdr_size(leaf_src));\n\n\t/* Initialise the incore headers */\n\tichdr_src = *ichdr_dst;\t/* struct copy */\n\tichdr_dst->firstused = args->geo->blksize;\n\tichdr_dst->usedbytes = 0;\n\tichdr_dst->count = 0;\n\tichdr_dst->holes = 0;\n\tichdr_dst->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_src);\n\tichdr_dst->freemap[0].size = ichdr_dst->firstused -\n\t\t\t\t\t\tichdr_dst->freemap[0].base;\n\n\t/* write the header back to initialise the underlying buffer */\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf_dst, ichdr_dst);\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate name/value pairs packed and in sequence.\n\t */\n\txfs_attr3_leaf_moveents(args, leaf_src, &ichdr_src, 0,\n\t\t\t\tleaf_dst, ichdr_dst, 0, ichdr_src.count);\n\t/*\n\t * this logs the entire buffer, but the caller must write the header\n\t * back to the buffer when it is finished modifying it.\n\t */\n\txfs_trans_log_buf(trans, bp, 0, args->geo->blksize - 1);\n\n\tkmem_free(tmpbuffer);\n}\n\n/*\n * Compare two leaf blocks \"order\".\n * Return 0 unless leaf2 should go before leaf1.\n */\nstatic int\nxfs_attr3_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf1hdr,\n\tstruct xfs_buf\t*leaf2_bp,\n\tstruct xfs_attr3_icleaf_hdr *leaf2hdr)\n{\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\n\tentries1 = xfs_attr3_leaf_entryp(leaf1_bp->b_addr);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2_bp->b_addr);\n\tif (leaf1hdr->count > 0 && leaf2hdr->count > 0 &&\n\t    ((be32_to_cpu(entries2[0].hashval) <\n\t      be32_to_cpu(entries1[0].hashval)) ||\n\t     (be32_to_cpu(entries2[leaf2hdr->count - 1].hashval) <\n\t      be32_to_cpu(entries1[leaf1hdr->count - 1].hashval)))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint\nxfs_attr_leaf_order(\n\tstruct xfs_buf\t*leaf1_bp,\n\tstruct xfs_buf\t*leaf2_bp)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_mount *mp = leaf1_bp->b_target->bt_mount;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr1, leaf1_bp->b_addr);\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr2, leaf2_bp->b_addr);\n\treturn xfs_attr3_leaf_order(leaf1_bp, &ichdr1, leaf2_bp, &ichdr2);\n}\n\n/*\n * Redistribute the attribute list entries between two leaf nodes,\n * taking into account the size of the new entry.\n *\n * NOTE: if new block is empty, then it will get the upper half of the\n * old block.  At present, all (one) callers pass in an empty second block.\n *\n * This code adjusts the args->index/blkno and args->index2/blkno2 fields\n * to match what it is doing in splitting the attribute leaf block.  Those\n * values are used in \"atomic rename\" operations on attributes.  Note that\n * the \"new\" and \"old\" values can end up in different blocks.\n */\nSTATIC void\nxfs_attr3_leaf_rebalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*blk1,\n\tstruct xfs_da_state_blk\t*blk2)\n{\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\tstruct xfs_attr_leaf_entry *entries1;\n\tstruct xfs_attr_leaf_entry *entries2;\n\tint\t\t\tcount;\n\tint\t\t\ttotallen;\n\tint\t\t\tmax;\n\tint\t\t\tspace;\n\tint\t\t\tswap;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(blk1->magic == XFS_ATTR_LEAF_MAGIC);\n\tASSERT(blk2->magic == XFS_ATTR_LEAF_MAGIC);\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr1, leaf1);\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr2, leaf2);\n\tASSERT(ichdr2.count == 0);\n\targs = state->args;\n\n\ttrace_xfs_attr_leaf_rebalance(args);\n\n\t/*\n\t * Check ordering of blocks, reverse if it makes things simpler.\n\t *\n\t * NOTE: Given that all (current) callers pass in an empty\n\t * second block, this code should never set \"swap\".\n\t */\n\tswap = 0;\n\tif (xfs_attr3_leaf_order(blk1->bp, &ichdr1, blk2->bp, &ichdr2)) {\n\t\tstruct xfs_da_state_blk\t*tmp_blk;\n\t\tstruct xfs_attr3_icleaf_hdr tmp_ichdr;\n\n\t\ttmp_blk = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp_blk;\n\n\t\t/* struct copies to swap them rather than reconverting */\n\t\ttmp_ichdr = ichdr1;\n\t\tichdr1 = ichdr2;\n\t\tichdr2 = tmp_ichdr;\n\n\t\tleaf1 = blk1->bp->b_addr;\n\t\tleaf2 = blk2->bp->b_addr;\n\t\tswap = 1;\n\t}\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.  Then get\n\t * the direction to copy and the number of elements to move.\n\t *\n\t * \"inleaf\" is true if the new entry should be inserted into blk1.\n\t * If \"swap\" is also true, then reverse the sense of \"inleaf\".\n\t */\n\tstate->inleaf = xfs_attr3_leaf_figure_balance(state, blk1, &ichdr1,\n\t\t\t\t\t\t      blk2, &ichdr2,\n\t\t\t\t\t\t      &count, &totallen);\n\tif (swap)\n\t\tstate->inleaf = !state->inleaf;\n\n\t/*\n\t * Move any entries required from leaf to leaf:\n\t */\n\tif (count < ichdr1.count) {\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount = ichdr1.count - count;\n\t\tspace  = ichdr1.usedbytes - totallen;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf2 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr2.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr2.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr2, blk2->bp);\n\n\t\t/*\n\t\t * Move high entries from leaf1 to low end of leaf2.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf1, &ichdr1,\n\t\t\t\tichdr1.count - count, leaf2, &ichdr2, 0, count);\n\n\t} else if (count > ichdr1.count) {\n\t\t/*\n\t\t * I assert that since all callers pass in an empty\n\t\t * second buffer, this code should never execute.\n\t\t */\n\t\tASSERT(0);\n\n\t\t/*\n\t\t * Figure the total bytes to be added to the destination leaf.\n\t\t */\n\t\t/* number entries being moved */\n\t\tcount -= ichdr1.count;\n\t\tspace  = totallen - ichdr1.usedbytes;\n\t\tspace += count * sizeof(xfs_attr_leaf_entry_t);\n\n\t\t/*\n\t\t * leaf1 is the destination, compact it if it looks tight.\n\t\t */\n\t\tmax  = ichdr1.firstused - xfs_attr3_leaf_hdr_size(leaf1);\n\t\tmax -= ichdr1.count * sizeof(xfs_attr_leaf_entry_t);\n\t\tif (space > max)\n\t\t\txfs_attr3_leaf_compact(args, &ichdr1, blk1->bp);\n\n\t\t/*\n\t\t * Move low entries from leaf2 to high end of leaf1.\n\t\t */\n\t\txfs_attr3_leaf_moveents(args, leaf2, &ichdr2, 0, leaf1, &ichdr1,\n\t\t\t\t\tichdr1.count, count);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(state->args->geo, leaf1, &ichdr1);\n\txfs_attr3_leaf_hdr_to_disk(state->args->geo, leaf2, &ichdr2);\n\txfs_trans_log_buf(args->trans, blk1->bp, 0, args->geo->blksize - 1);\n\txfs_trans_log_buf(args->trans, blk2->bp, 0, args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentries1 = xfs_attr3_leaf_entryp(leaf1);\n\tentries2 = xfs_attr3_leaf_entryp(leaf2);\n\tblk1->hashval = be32_to_cpu(entries1[ichdr1.count - 1].hashval);\n\tblk2->hashval = be32_to_cpu(entries2[ichdr2.count - 1].hashval);\n\n\t/*\n\t * Adjust the expected index for insertion.\n\t * NOTE: this code depends on the (current) situation that the\n\t * second block was originally empty.\n\t *\n\t * If the insertion point moved to the 2nd block, we must adjust\n\t * the index.  We must also track the entry just following the\n\t * new entry for use in an \"atomic rename\" operation, that entry\n\t * is always the \"old\" entry and the \"new\" entry is what we are\n\t * inserting.  The index/blkno fields refer to the \"old\" entry,\n\t * while the index2/blkno2 fields refer to the \"new\" entry.\n\t */\n\tif (blk1->index > ichdr1.count) {\n\t\tASSERT(state->inleaf == 0);\n\t\tblk2->index = blk1->index - ichdr1.count;\n\t\targs->index = args->index2 = blk2->index;\n\t\targs->blkno = args->blkno2 = blk2->blkno;\n\t} else if (blk1->index == ichdr1.count) {\n\t\tif (state->inleaf) {\n\t\t\targs->index = blk1->index;\n\t\t\targs->blkno = blk1->blkno;\n\t\t\targs->index2 = 0;\n\t\t\targs->blkno2 = blk2->blkno;\n\t\t} else {\n\t\t\t/*\n\t\t\t * On a double leaf split, the original attr location\n\t\t\t * is already stored in blkno2/index2, so don't\n\t\t\t * overwrite it overwise we corrupt the tree.\n\t\t\t */\n\t\t\tblk2->index = blk1->index - ichdr1.count;\n\t\t\targs->index = blk2->index;\n\t\t\targs->blkno = blk2->blkno;\n\t\t\tif (!state->extravalid) {\n\t\t\t\t/*\n\t\t\t\t * set the new attr location to match the old\n\t\t\t\t * one and let the higher level split code\n\t\t\t\t * decide where in the leaf to place it.\n\t\t\t\t */\n\t\t\t\targs->index2 = blk2->index;\n\t\t\t\targs->blkno2 = blk2->blkno;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tASSERT(state->inleaf == 1);\n\t\targs->index = args->index2 = blk1->index;\n\t\targs->blkno = args->blkno2 = blk1->blkno;\n\t}\n}\n\n/*\n * Examine entries until we reduce the absolute difference in\n * byte usage between the two blocks to a minimum.\n * GROT: Is this really necessary?  With other than a 512 byte blocksize,\n * GROT: there will always be enough room in either block for a new entry.\n * GROT: Do a double-split for this case?\n */\nSTATIC int\nxfs_attr3_leaf_figure_balance(\n\tstruct xfs_da_state\t\t*state,\n\tstruct xfs_da_state_blk\t\t*blk1,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr1,\n\tstruct xfs_da_state_blk\t\t*blk2,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr2,\n\tint\t\t\t\t*countarg,\n\tint\t\t\t\t*usedbytesarg)\n{\n\tstruct xfs_attr_leafblock\t*leaf1 = blk1->bp->b_addr;\n\tstruct xfs_attr_leafblock\t*leaf2 = blk2->bp->b_addr;\n\tstruct xfs_attr_leaf_entry\t*entry;\n\tint\t\t\t\tcount;\n\tint\t\t\t\tmax;\n\tint\t\t\t\tindex;\n\tint\t\t\t\ttotallen = 0;\n\tint\t\t\t\thalf;\n\tint\t\t\t\tlastdelta;\n\tint\t\t\t\tfoundit = 0;\n\tint\t\t\t\ttmp;\n\n\t/*\n\t * Examine entries until we reduce the absolute difference in\n\t * byte usage between the two blocks to a minimum.\n\t */\n\tmax = ichdr1->count + ichdr2->count;\n\thalf = (max + 1) * sizeof(*entry);\n\thalf += ichdr1->usedbytes + ichdr2->usedbytes +\n\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\thalf /= 2;\n\tlastdelta = state->args->geo->blksize;\n\tentry = xfs_attr3_leaf_entryp(leaf1);\n\tfor (count = index = 0; count < max; entry++, index++, count++) {\n\n#define XFS_ATTR_ABS(A)\t(((A) < 0) ? -(A) : (A))\n\t\t/*\n\t\t * The new entry is in the first block, account for it.\n\t\t */\n\t\tif (count == blk1->index) {\n\t\t\ttmp = totallen + sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\t\tbreak;\n\t\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\t\ttotallen = tmp;\n\t\t\tfoundit = 1;\n\t\t}\n\n\t\t/*\n\t\t * Wrap around into the second block if necessary.\n\t\t */\n\t\tif (count == ichdr1->count) {\n\t\t\tleaf1 = leaf2;\n\t\t\tentry = xfs_attr3_leaf_entryp(leaf1);\n\t\t\tindex = 0;\n\t\t}\n\n\t\t/*\n\t\t * Figure out if next leaf entry would be too much.\n\t\t */\n\t\ttmp = totallen + sizeof(*entry) + xfs_attr_leaf_entsize(leaf1,\n\t\t\t\t\t\t\t\t\tindex);\n\t\tif (XFS_ATTR_ABS(half - tmp) > lastdelta)\n\t\t\tbreak;\n\t\tlastdelta = XFS_ATTR_ABS(half - tmp);\n\t\ttotallen = tmp;\n#undef XFS_ATTR_ABS\n\t}\n\n\t/*\n\t * Calculate the number of usedbytes that will end up in lower block.\n\t * If new entry not in lower block, fix up the count.\n\t */\n\ttotallen -= count * sizeof(*entry);\n\tif (foundit) {\n\t\ttotallen -= sizeof(*entry) +\n\t\t\t\txfs_attr_leaf_newentsize(state->args, NULL);\n\t}\n\n\t*countarg = count;\n\t*usedbytesarg = totallen;\n\treturn foundit;\n}\n\n/*========================================================================\n * Routines used for shrinking the Btree.\n *========================================================================*/\n\n/*\n * Check a leaf block and its neighbors to see if the block should be\n * collapsed into one or the other neighbor.  Always keep the block\n * with the smaller block number.\n * If the current block is over 50% full, don't try to join it, return 0.\n * If the block is empty, fill in the state structure and return 2.\n * If it can be collapsed, fill in the state structure and return 1.\n * If nothing can be done, return 0.\n *\n * GROT: allow for INCOMPLETE entries in calculation.\n */\nint\nxfs_attr3_leaf_toosmall(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*action)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tblkno;\n\tint\t\t\tbytes;\n\tint\t\t\tforward;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_toosmall(state->args);\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[ state->path.active-1 ];\n\tleaf = blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr, leaf);\n\tbytes = xfs_attr3_leaf_hdr_size(leaf) +\n\t\tichdr.count * sizeof(xfs_attr_leaf_entry_t) +\n\t\tichdr.usedbytes;\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t*action = 0;\t/* blk over 50%, don't try to join */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (ichdr.count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (ichdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (retval) {\n\t\t\t*action = 0;\n\t\t} else {\n\t\t\t*action = 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink an attribute list over time.\n\t */\n\t/* start with smaller blk num */\n\tforward = ichdr.forw < ichdr.back;\n\tfor (i = 0; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\t\tif (forward)\n\t\t\tblkno = ichdr.forw;\n\t\telse\n\t\t\tblkno = ichdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\terror = xfs_attr3_leaf_read(state->args->trans, state->args->dp,\n\t\t\t\t\tblkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &ichdr2, bp->b_addr);\n\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2) -\n\t\t\tichdr.usedbytes - ichdr2.usedbytes -\n\t\t\t((ichdr.count + ichdr2.count) *\n\t\t\t\t\tsizeof(xfs_attr_leaf_entry_t)) -\n\t\t\txfs_attr3_leaf_hdr_size(leaf);\n\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t\tif (bytes >= 0)\n\t\t\tbreak;\t/* fits with at least 25% to spare */\n\t}\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno) {\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward,\n\t\t\t\t\t\t 0, &retval);\n\t} else {\n\t\terror = xfs_da3_path_shift(state, &state->path, forward,\n\t\t\t\t\t\t 0, &retval);\n\t}\n\tif (error)\n\t\treturn error;\n\tif (retval) {\n\t\t*action = 0;\n\t} else {\n\t\t*action = 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Remove a name from the leaf attribute list structure.\n *\n * Return 1 if leaf is less than 37% full, 0 if >= 37% full.\n * If two leaves are 37% full, when combined they will leave 25% free.\n */\nint\nxfs_attr3_leaf_remove(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tint\t\t\tbefore;\n\tint\t\t\tafter;\n\tint\t\t\tsmallest;\n\tint\t\t\tentsize;\n\tint\t\t\ttablesize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\n\ttrace_xfs_attr_leaf_remove(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\n\tASSERT(ichdr.count > 0 && ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index >= 0 && args->index < ichdr.count);\n\tASSERT(ichdr.firstused >= ichdr.count * sizeof(*entry) +\n\t\t\t\t\txfs_attr3_leaf_hdr_size(leaf));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t/*\n\t * Scan through free region table:\n\t *    check for adjacency of free'd entry with an existing one,\n\t *    find smallest free region in case we need to replace it,\n\t *    adjust any map that borders the entry table,\n\t */\n\ttablesize = ichdr.count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf);\n\ttmp = ichdr.freemap[0].size;\n\tbefore = after = -1;\n\tsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\n\tentsize = xfs_attr_leaf_entsize(leaf, args->index);\n\tfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; i++) {\n\t\tASSERT(ichdr.freemap[i].base < args->geo->blksize);\n\t\tASSERT(ichdr.freemap[i].size < args->geo->blksize);\n\t\tif (ichdr.freemap[i].base == tablesize) {\n\t\t\tichdr.freemap[i].base -= sizeof(xfs_attr_leaf_entry_t);\n\t\t\tichdr.freemap[i].size += sizeof(xfs_attr_leaf_entry_t);\n\t\t}\n\n\t\tif (ichdr.freemap[i].base + ichdr.freemap[i].size ==\n\t\t\t\tbe16_to_cpu(entry->nameidx)) {\n\t\t\tbefore = i;\n\t\t} else if (ichdr.freemap[i].base ==\n\t\t\t\t(be16_to_cpu(entry->nameidx) + entsize)) {\n\t\t\tafter = i;\n\t\t} else if (ichdr.freemap[i].size < tmp) {\n\t\t\ttmp = ichdr.freemap[i].size;\n\t\t\tsmallest = i;\n\t\t}\n\t}\n\n\t/*\n\t * Coalesce adjacent freemap regions,\n\t * or replace the smallest region.\n\t */\n\tif ((before >= 0) || (after >= 0)) {\n\t\tif ((before >= 0) && (after >= 0)) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t\tichdr.freemap[before].size += ichdr.freemap[after].size;\n\t\t\tichdr.freemap[after].base = 0;\n\t\t\tichdr.freemap[after].size = 0;\n\t\t} else if (before >= 0) {\n\t\t\tichdr.freemap[before].size += entsize;\n\t\t} else {\n\t\t\tichdr.freemap[after].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[after].size += entsize;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Replace smallest region (if it is smaller than free'd entry)\n\t\t */\n\t\tif (ichdr.freemap[smallest].size < entsize) {\n\t\t\tichdr.freemap[smallest].base = be16_to_cpu(entry->nameidx);\n\t\t\tichdr.freemap[smallest].size = entsize;\n\t\t}\n\t}\n\n\t/*\n\t * Did we remove the first entry?\n\t */\n\tif (be16_to_cpu(entry->nameidx) == ichdr.firstused)\n\t\tsmallest = 1;\n\telse\n\t\tsmallest = 0;\n\n\t/*\n\t * Compress the remaining entries and zero out the removed stuff.\n\t */\n\tmemset(xfs_attr3_leaf_name(leaf, args->index), 0, entsize);\n\tichdr.usedbytes -= entsize;\n\txfs_trans_log_buf(args->trans, bp,\n\t     XFS_DA_LOGRANGE(leaf, xfs_attr3_leaf_name(leaf, args->index),\n\t\t\t\t   entsize));\n\n\ttmp = (ichdr.count - args->index) * sizeof(xfs_attr_leaf_entry_t);\n\tmemmove(entry, entry + 1, tmp);\n\tichdr.count--;\n\txfs_trans_log_buf(args->trans, bp,\n\t    XFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(xfs_attr_leaf_entry_t)));\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[ichdr.count];\n\tmemset(entry, 0, sizeof(xfs_attr_leaf_entry_t));\n\n\t/*\n\t * If we removed the first entry, re-find the first used byte\n\t * in the name area.  Note that if the entry was the \"firstused\",\n\t * then we don't have a \"hole\" in our block resulting from\n\t * removing the name.\n\t */\n\tif (smallest) {\n\t\ttmp = args->geo->blksize;\n\t\tentry = xfs_attr3_leaf_entryp(leaf);\n\t\tfor (i = ichdr.count - 1; i >= 0; entry++, i--) {\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) >= ichdr.firstused);\n\t\t\tASSERT(be16_to_cpu(entry->nameidx) < args->geo->blksize);\n\n\t\t\tif (be16_to_cpu(entry->nameidx) < tmp)\n\t\t\t\ttmp = be16_to_cpu(entry->nameidx);\n\t\t}\n\t\tichdr.firstused = tmp;\n\t\tASSERT(ichdr.firstused != 0);\n\t} else {\n\t\tichdr.holes = 1;\t/* mark as needing compaction */\n\t}\n\txfs_attr3_leaf_hdr_to_disk(args->geo, leaf, &ichdr);\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  XFS_DA_LOGRANGE(leaf, &leaf->hdr,\n\t\t\t\t\t  xfs_attr3_leaf_hdr_size(leaf)));\n\n\t/*\n\t * Check if leaf is less than 50% full, caller may want to\n\t * \"join\" the leaf with a sibling if so.\n\t */\n\ttmp = ichdr.usedbytes + xfs_attr3_leaf_hdr_size(leaf) +\n\t      ichdr.count * sizeof(xfs_attr_leaf_entry_t);\n\n\treturn tmp < args->geo->magicpct; /* leaf is < 37% full */\n}\n\n/*\n * Move all the attribute list entries from drop_leaf into save_leaf.\n */\nvoid\nxfs_attr3_leaf_unbalance(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*drop_blk,\n\tstruct xfs_da_state_blk\t*save_blk)\n{\n\tstruct xfs_attr_leafblock *drop_leaf = drop_blk->bp->b_addr;\n\tstruct xfs_attr_leafblock *save_leaf = save_blk->bp->b_addr;\n\tstruct xfs_attr3_icleaf_hdr drophdr;\n\tstruct xfs_attr3_icleaf_hdr savehdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\n\ttrace_xfs_attr_leaf_unbalance(state->args);\n\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &drophdr, drop_leaf);\n\txfs_attr3_leaf_hdr_from_disk(state->args->geo, &savehdr, save_leaf);\n\tentry = xfs_attr3_leaf_entryp(drop_leaf);\n\n\t/*\n\t * Save last hashval from dying block for later Btree fixup.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(entry[drophdr.count - 1].hashval);\n\n\t/*\n\t * Check if we need a temp buffer, or can we do it in place.\n\t * Note that we don't check \"leaf\" for holes because we will\n\t * always be dropping it, toosmall() decided that for us already.\n\t */\n\tif (savehdr.holes == 0) {\n\t\t/*\n\t\t * dest leaf has no holes, so we add there.  May need\n\t\t * to make some room in the entry array.\n\t\t */\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\tsave_leaf, &savehdr,\n\t\t\t\t\t\tsavehdr.count, drophdr.count);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Destination has holes, so we make a temporary copy\n\t\t * of the leaf and add them both to that.\n\t\t */\n\t\tstruct xfs_attr_leafblock *tmp_leaf;\n\t\tstruct xfs_attr3_icleaf_hdr tmphdr;\n\n\t\ttmp_leaf = kmem_zalloc(state->args->geo->blksize, KM_SLEEP);\n\n\t\t/*\n\t\t * Copy the header into the temp leaf so that all the stuff\n\t\t * not in the incore header is present and gets copied back in\n\t\t * once we've moved all the entries.\n\t\t */\n\t\tmemcpy(tmp_leaf, save_leaf, xfs_attr3_leaf_hdr_size(save_leaf));\n\n\t\tmemset(&tmphdr, 0, sizeof(tmphdr));\n\t\ttmphdr.magic = savehdr.magic;\n\t\ttmphdr.forw = savehdr.forw;\n\t\ttmphdr.back = savehdr.back;\n\t\ttmphdr.firstused = state->args->geo->blksize;\n\n\t\t/* write the header to the temp buffer to initialise it */\n\t\txfs_attr3_leaf_hdr_to_disk(state->args->geo, tmp_leaf, &tmphdr);\n\n\t\tif (xfs_attr3_leaf_order(save_blk->bp, &savehdr,\n\t\t\t\t\t drop_blk->bp, &drophdr)) {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tdrophdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tsavehdr.count);\n\t\t} else {\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tsave_leaf, &savehdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, 0,\n\t\t\t\t\t\tsavehdr.count);\n\t\t\txfs_attr3_leaf_moveents(state->args,\n\t\t\t\t\t\tdrop_leaf, &drophdr, 0,\n\t\t\t\t\t\ttmp_leaf, &tmphdr, tmphdr.count,\n\t\t\t\t\t\tdrophdr.count);\n\t\t}\n\t\tmemcpy(save_leaf, tmp_leaf, state->args->geo->blksize);\n\t\tsavehdr = tmphdr; /* struct copy */\n\t\tkmem_free(tmp_leaf);\n\t}\n\n\txfs_attr3_leaf_hdr_to_disk(state->args->geo, save_leaf, &savehdr);\n\txfs_trans_log_buf(state->args->trans, save_blk->bp, 0,\n\t\t\t\t\t   state->args->geo->blksize - 1);\n\n\t/*\n\t * Copy out last hashval in each block for B-tree code.\n\t */\n\tentry = xfs_attr3_leaf_entryp(save_leaf);\n\tsave_blk->hashval = be32_to_cpu(entry[savehdr.count - 1].hashval);\n}\n\n/*========================================================================\n * Routines used for finding things in the Btree.\n *========================================================================*/\n\n/*\n * Look up a name in a leaf attribute list structure.\n * This is the internal routine, it uses the caller's buffer.\n *\n * Note that duplicate keys are allowed, but only check within the\n * current leaf node.  The Btree code must check in adjacent leaf nodes.\n *\n * Return in args->index the index into the entry[] array of either\n * the found entry, or where the entry should have been (insert before\n * that entry).\n *\n * Don't change the args->value unless we find the attribute.\n */\nint\nxfs_attr3_leaf_lookup_int(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\txfs_dahash_t\t\thashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\n\ttrace_xfs_attr_leaf_lookup(args);\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (ichdr.count >= args->geo->blksize / 8)\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * Binary search.  (note: small blocks will skip this loop)\n\t */\n\thashval = args->hashval;\n\tprobe = span = ichdr.count / 2;\n\tfor (entry = &entries[probe]; span > 4; entry = &entries[probe]) {\n\t\tspan /= 2;\n\t\tif (be32_to_cpu(entry->hashval) < hashval)\n\t\t\tprobe += span;\n\t\telse if (be32_to_cpu(entry->hashval) > hashval)\n\t\t\tprobe -= span;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!(probe >= 0 && (!ichdr.count || probe < ichdr.count)))\n\t\treturn -EFSCORRUPTED;\n\tif (!(span <= 4 || be32_to_cpu(entry->hashval) == hashval))\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * Since we may have duplicate hashval's, find the first matching\n\t * hashval in the leaf.\n\t */\n\twhile (probe > 0 && be32_to_cpu(entry->hashval) >= hashval) {\n\t\tentry--;\n\t\tprobe--;\n\t}\n\twhile (probe < ichdr.count &&\n\t       be32_to_cpu(entry->hashval) < hashval) {\n\t\tentry++;\n\t\tprobe++;\n\t}\n\tif (probe == ichdr.count || be32_to_cpu(entry->hashval) != hashval) {\n\t\targs->index = probe;\n\t\treturn -ENOATTR;\n\t}\n\n\t/*\n\t * Duplicate keys may be present, so search all of them for a match.\n\t */\n\tfor (; probe < ichdr.count && (be32_to_cpu(entry->hashval) == hashval);\n\t\t\tentry++, probe++) {\n/*\n * GROT: Add code to remove incomplete entries.\n */\n\t\t/*\n\t\t * If we are looking for INCOMPLETE entries, show only those.\n\t\t * If we are looking for complete entries, show only those.\n\t\t */\n\t\tif ((args->flags & XFS_ATTR_INCOMPLETE) !=\n\t\t    (entry->flags & XFS_ATTR_INCOMPLETE)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\t\tname_loc = xfs_attr3_leaf_name_local(leaf, probe);\n\t\t\tif (name_loc->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_loc->nameval,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, probe);\n\t\t\tif (name_rmt->namelen != args->namelen)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(args->name, name_rmt->name,\n\t\t\t\t\t\t\targs->namelen) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!xfs_attr_namesp_match(args->flags, entry->flags))\n\t\t\t\tcontinue;\n\t\t\targs->index = probe;\n\t\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(\n\t\t\t\t\t\t\targs->dp->i_mount,\n\t\t\t\t\t\t\targs->rmtvaluelen);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\targs->index = probe;\n\treturn -ENOATTR;\n}\n\n/*\n * Get the value associated with an attribute name from a leaf attribute\n * list structure.\n */\nint\nxfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(ichdr.count < args->geo->blksize / 8);\n\tASSERT(args->index < ichdr.count);\n\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn -ERANGE;\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}\n\n/*========================================================================\n * Utility routines.\n *========================================================================*/\n\n/*\n * Move the indicated entries from one leaf to another.\n * NOTE: this routine modifies both source and destination leaves.\n */\n/*ARGSUSED*/\nSTATIC void\nxfs_attr3_leaf_moveents(\n\tstruct xfs_da_args\t\t*args,\n\tstruct xfs_attr_leafblock\t*leaf_s,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_s,\n\tint\t\t\t\tstart_s,\n\tstruct xfs_attr_leafblock\t*leaf_d,\n\tstruct xfs_attr3_icleaf_hdr\t*ichdr_d,\n\tint\t\t\t\tstart_d,\n\tint\t\t\t\tcount)\n{\n\tstruct xfs_attr_leaf_entry\t*entry_s;\n\tstruct xfs_attr_leaf_entry\t*entry_d;\n\tint\t\t\t\tdesti;\n\tint\t\t\t\ttmp;\n\tint\t\t\t\ti;\n\n\t/*\n\t * Check for nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * Set up environment.\n\t */\n\tASSERT(ichdr_s->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       ichdr_s->magic == XFS_ATTR3_LEAF_MAGIC);\n\tASSERT(ichdr_s->magic == ichdr_d->magic);\n\tASSERT(ichdr_s->count > 0 && ichdr_s->count < args->geo->blksize / 8);\n\tASSERT(ichdr_s->firstused >= (ichdr_s->count * sizeof(*entry_s))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_s));\n\tASSERT(ichdr_d->count < args->geo->blksize / 8);\n\tASSERT(ichdr_d->firstused >= (ichdr_d->count * sizeof(*entry_d))\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d));\n\n\tASSERT(start_s < ichdr_s->count);\n\tASSERT(start_d <= ichdr_d->count);\n\tASSERT(count <= ichdr_s->count);\n\n\n\t/*\n\t * Move the entries in the destination leaf up to make a hole?\n\t */\n\tif (start_d < ichdr_d->count) {\n\t\ttmp  = ichdr_d->count - start_d;\n\t\ttmp *= sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d + count];\n\t\tmemmove(entry_d, entry_s, tmp);\n\t}\n\n\t/*\n\t * Copy all entry's in the same (sorted) order,\n\t * but allocate attribute info packed and in sequence.\n\t */\n\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\tentry_d = &xfs_attr3_leaf_entryp(leaf_d)[start_d];\n\tdesti = start_d;\n\tfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\n\t\tASSERT(be16_to_cpu(entry_s->nameidx) >= ichdr_s->firstused);\n\t\ttmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\n#ifdef GROT\n\t\t/*\n\t\t * Code to drop INCOMPLETE entries.  Difficult to use as we\n\t\t * may also need to change the insertion index.  Code turned\n\t\t * off for 6.2, should be revisited later.\n\t\t */\n\t\tif (entry_s->flags & XFS_ATTR_INCOMPLETE) { /* skip partials? */\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tentry_d--;\t/* to compensate for ++ in loop hdr */\n\t\t\tdesti--;\n\t\t\tif ((start_s + i) < offset)\n\t\t\t\tresult++;\t/* insertion index adjustment */\n\t\t} else {\n#endif /* GROT */\n\t\t\tichdr_d->firstused -= tmp;\n\t\t\t/* both on-disk, don't endian flip twice */\n\t\t\tentry_d->hashval = entry_s->hashval;\n\t\t\tentry_d->nameidx = cpu_to_be16(ichdr_d->firstused);\n\t\t\tentry_d->flags = entry_s->flags;\n\t\t\tASSERT(be16_to_cpu(entry_d->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemmove(xfs_attr3_leaf_name(leaf_d, desti),\n\t\t\t\txfs_attr3_leaf_name(leaf_s, start_s + i), tmp);\n\t\t\tASSERT(be16_to_cpu(entry_s->nameidx) + tmp\n\t\t\t\t\t\t\t<= args->geo->blksize);\n\t\t\tmemset(xfs_attr3_leaf_name(leaf_s, start_s + i), 0, tmp);\n\t\t\tichdr_s->usedbytes -= tmp;\n\t\t\tichdr_d->usedbytes += tmp;\n\t\t\tichdr_s->count -= 1;\n\t\t\tichdr_d->count += 1;\n\t\t\ttmp = ichdr_d->count * sizeof(xfs_attr_leaf_entry_t)\n\t\t\t\t\t+ xfs_attr3_leaf_hdr_size(leaf_d);\n\t\t\tASSERT(ichdr_d->firstused >= tmp);\n#ifdef GROT\n\t\t}\n#endif /* GROT */\n\t}\n\n\t/*\n\t * Zero out the entries we just copied.\n\t */\n\tif (start_s == ichdr_s->count) {\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t} else {\n\t\t/*\n\t\t * Move the remaining entries down to fill the hole,\n\t\t * then zero the entries at the top.\n\t\t */\n\t\ttmp  = (ichdr_s->count - count) * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[start_s + count];\n\t\tentry_d = &xfs_attr3_leaf_entryp(leaf_s)[start_s];\n\t\tmemmove(entry_d, entry_s, tmp);\n\n\t\ttmp = count * sizeof(xfs_attr_leaf_entry_t);\n\t\tentry_s = &xfs_attr3_leaf_entryp(leaf_s)[ichdr_s->count];\n\t\tASSERT(((char *)entry_s + tmp) <=\n\t\t       ((char *)leaf_s + args->geo->blksize));\n\t\tmemset(entry_s, 0, tmp);\n\t}\n\n\t/*\n\t * Fill in the freemap information\n\t */\n\tichdr_d->freemap[0].base = xfs_attr3_leaf_hdr_size(leaf_d);\n\tichdr_d->freemap[0].base += ichdr_d->count * sizeof(xfs_attr_leaf_entry_t);\n\tichdr_d->freemap[0].size = ichdr_d->firstused - ichdr_d->freemap[0].base;\n\tichdr_d->freemap[1].base = 0;\n\tichdr_d->freemap[2].base = 0;\n\tichdr_d->freemap[1].size = 0;\n\tichdr_d->freemap[2].size = 0;\n\tichdr_s->holes = 1;\t/* leaf may not be compact */\n}\n\n/*\n * Pick up the last hashvalue from a leaf block.\n */\nxfs_dahash_t\nxfs_attr_leaf_lasthash(\n\tstruct xfs_buf\t*bp,\n\tint\t\t*count)\n{\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entries;\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_attr3_leaf_hdr_from_disk(mp->m_attr_geo, &ichdr, bp->b_addr);\n\tentries = xfs_attr3_leaf_entryp(bp->b_addr);\n\tif (count)\n\t\t*count = ichdr.count;\n\tif (!ichdr.count)\n\t\treturn 0;\n\treturn be32_to_cpu(entries[ichdr.count - 1].hashval);\n}\n\n/*\n * Calculate the number of bytes used to store the indicated attribute\n * (whether local or remote only calculate bytes in this block).\n */\nSTATIC int\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\n{\n\tstruct xfs_attr_leaf_entry *entries;\n\txfs_attr_leaf_name_local_t *name_loc;\n\txfs_attr_leaf_name_remote_t *name_rmt;\n\tint size;\n\n\tentries = xfs_attr3_leaf_entryp(leaf);\n\tif (entries[index].flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\n\t\t\t\t\t\t   be16_to_cpu(name_loc->valuelen));\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, index);\n\t\tsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\n\t}\n\treturn size;\n}\n\n/*\n * Calculate the number of bytes that would be required to store the new\n * attribute (whether local or remote only calculate bytes in this block).\n * This routine decides as a side effect whether the attribute will be\n * a \"local\" or a \"remote\" attribute.\n */\nint\nxfs_attr_leaf_newentsize(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*local)\n{\n\tint\t\t\tsize;\n\n\tsize = xfs_attr_leaf_entsize_local(args->namelen, args->valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(args->geo->blksize)) {\n\t\tif (local)\n\t\t\t*local = 1;\n\t\treturn size;\n\t}\n\tif (local)\n\t\t*local = 0;\n\treturn xfs_attr_leaf_entsize_remote(args->namelen);\n}\n\n\n/*========================================================================\n * Manage the INCOMPLETE flag in a leaf entry\n *========================================================================*/\n\n/*\n * Clear the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_clearflag(args);\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif /* DEBUG */\n\n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll_inode(&args->trans, args->dp);\n}\n\n/*\n * Set the INCOMPLETE flag on an entry in a leaf block.\n */\nint\nxfs_attr3_leaf_setflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n#endif\n\n\ttrace_xfs_attr_leaf_setflag(args);\n\n\t/*\n\t * Set up the operation.\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn error;\n\n\tleaf = bp->b_addr;\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n#endif\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\n\tASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\n\tentry->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\tXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\treturn xfs_trans_roll_inode(&args->trans, args->dp);\n}\n\n/*\n * In a single transaction, clear the INCOMPLETE flag on the leaf entry\n * given by args->blkno/index and set the INCOMPLETE flag on the leaf\n * entry given by args->blkno2/index2.\n *\n * Note that they could be in different blocks, or in the same block.\n */\nint\nxfs_attr3_leaf_flipflags(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf1;\n\tstruct xfs_attr_leafblock *leaf2;\n\tstruct xfs_attr_leaf_entry *entry1;\n\tstruct xfs_attr_leaf_entry *entry2;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp1;\n\tstruct xfs_buf\t\t*bp2;\n\tint error;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr1;\n\tstruct xfs_attr3_icleaf_hdr ichdr2;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen1, namelen2;\n\tchar *name1, *name2;\n#endif /* DEBUG */\n\n\ttrace_xfs_attr_leaf_flipflags(args);\n\n\t/*\n\t * Read the block containing the \"old\" attr\n\t */\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Read the block containing the \"new\" attr, if it is different\n\t */\n\tif (args->blkno2 != args->blkno) {\n\t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,\n\t\t\t\t\t   -1, &bp2);\n\t\tif (error)\n\t\t\treturn error;\n\t} else {\n\t\tbp2 = bp1;\n\t}\n\n\tleaf1 = bp1->b_addr;\n\tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];\n\n\tleaf2 = bp2->b_addr;\n\tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];\n\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr1, leaf1);\n\tASSERT(args->index < ichdr1.count);\n\tASSERT(args->index >= 0);\n\n\txfs_attr3_leaf_hdr_from_disk(args->geo, &ichdr2, leaf2);\n\tASSERT(args->index2 < ichdr2.count);\n\tASSERT(args->index2 >= 0);\n\n\tif (entry1->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);\n\t\tnamelen1 = name_loc->namelen;\n\t\tname1 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tnamelen1 = name_rmt->namelen;\n\t\tname1 = (char *)name_rmt->name;\n\t}\n\tif (entry2->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);\n\t\tnamelen2 = name_loc->namelen;\n\t\tname2 = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tnamelen2 = name_rmt->namelen;\n\t\tname2 = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\n\tASSERT(namelen1 == namelen2);\n\tASSERT(memcmp(name1, name2, namelen1) == 0);\n#endif /* DEBUG */\n\n\tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\n\tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\n\n\tentry1->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);\n\t\txfs_trans_log_buf(args->trans, bp1,\n\t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\tentry2->flags |= XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\n\tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);\n\t\tname_rmt->valueblk = 0;\n\t\tname_rmt->valuelen = 0;\n\t\txfs_trans_log_buf(args->trans, bp2,\n\t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\n\t}\n\n\t/*\n\t * Commit the flag value change and start the next trans in series.\n\t */\n\terror = xfs_trans_roll_inode(&args->trans, args->dp);\n\n\treturn error;\n}\n"], "filenames": ["fs/xfs/libxfs/xfs_attr_leaf.c"], "buggy_code_start_loc": [794], "buggy_code_end_loc": [797], "fixing_code_start_loc": [794], "fixing_code_end_loc": [796], "type": "CWE-476", "message": "An issue was discovered in fs/xfs/libxfs/xfs_attr_leaf.c in the Linux kernel through 4.17.3. An OOPS may occur for a corrupted xfs image after xfs_da_shrink_inode() is called with a NULL bp.", "other": {"cve": {"id": "CVE-2018-13094", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-03T10:29:00.287", "lastModified": "2019-04-23T17:29:01.083", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in fs/xfs/libxfs/xfs_attr_leaf.c in the Linux kernel through 4.17.3. An OOPS may occur for a corrupted xfs image after xfs_da_shrink_inode() is called with a NULL bp."}, {"lang": "es", "value": "Se ha descubierto un problema en fs/xfs/libxfs/xfs_attr_leaf.c en el kernel de Linux hasta la versi\u00f3n 4.17.3. Puede ocurrir un OOPS para una imagen xfs corrupta despu\u00e9s de que se llame a xfs_da_shrink_inode() con un bp NULL."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.17.3", "matchCriteriaId": "C6ECF5D0-AFCC-470A-9D01-4A372C09556D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:0831", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2029", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2043", "source": "cve@mitre.org"}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=199969", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/fs/xfs/xfs-linux.git/commit/?h=for-next&id=bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3752-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3752-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3753-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3753-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a"}}