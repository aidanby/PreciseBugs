{"buggy_code": ["/*\n misc.c : irssi\n\n    Copyright (C) 1999 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include \"misc.h\"\n#include \"commands.h\"\n\ntypedef struct {\n\tint condition;\n\tGInputFunction function;\n        void *data;\n} IRSSI_INPUT_REC;\n\nstatic int irssi_io_invoke(GIOChannel *source, GIOCondition condition,\n\t\t\t   void *data)\n{\n\tIRSSI_INPUT_REC *rec = data;\n\tint icond = 0;\n\n\tif (condition & (G_IO_ERR | G_IO_HUP | G_IO_NVAL)) {\n\t\t/* error, we have to call the function.. */\n\t\tif (rec->condition & G_IO_IN)\n\t\t\ticond |= G_INPUT_READ;\n\t\telse\n\t\t\ticond |= G_INPUT_WRITE;\n\t}\n\n\tif (condition & (G_IO_IN | G_IO_PRI))\n\t\ticond |= G_INPUT_READ;\n\tif (condition & G_IO_OUT)\n\t\ticond |= G_INPUT_WRITE;\n\n\tif (rec->condition & icond)\n\t\trec->function(rec->data, source, icond);\n\n\treturn TRUE;\n}\n\nint g_input_add_full(GIOChannel *source, int priority, int condition,\n\t\t     GInputFunction function, void *data)\n{\n        IRSSI_INPUT_REC *rec;\n\tunsigned int result;\n\tGIOCondition cond;\n\n\trec = g_new(IRSSI_INPUT_REC, 1);\n\trec->condition = condition;\n\trec->function = function;\n\trec->data = data;\n\n\tcond = (GIOCondition) (G_IO_ERR|G_IO_HUP|G_IO_NVAL);\n\tif (condition & G_INPUT_READ)\n\t\tcond |= G_IO_IN|G_IO_PRI;\n\tif (condition & G_INPUT_WRITE)\n\t\tcond |= G_IO_OUT;\n\n\tresult = g_io_add_watch_full(source, priority, cond,\n\t\t\t\t     irssi_io_invoke, rec, g_free);\n\n\treturn result;\n}\n\nint g_input_add(GIOChannel *source, int condition,\n\t\tGInputFunction function, void *data)\n{\n\treturn g_input_add_full(source, G_PRIORITY_DEFAULT, condition,\n\t\t\t\tfunction, data);\n}\n\n/* easy way to bypass glib polling of io channel internal buffer */\nint g_input_add_poll(int fd, int priority, int condition,\n\t\t     GInputFunction function, void *data)\n{\n\tGIOChannel *source = g_io_channel_unix_new(fd);\n\tint ret = g_input_add_full(source, priority, condition, function, data);\n\tg_io_channel_unref(source);\n\treturn ret;\n}\n\nint g_timeval_cmp(const GTimeVal *tv1, const GTimeVal *tv2)\n{\n\tif (tv1->tv_sec < tv2->tv_sec)\n\t\treturn -1;\n\tif (tv1->tv_sec > tv2->tv_sec)\n\t\treturn 1;\n\n\treturn tv1->tv_usec < tv2->tv_usec ? -1 :\n\t\ttv1->tv_usec > tv2->tv_usec ? 1 : 0;\n}\n\nlong get_timeval_diff(const GTimeVal *tv1, const GTimeVal *tv2)\n{\n\tlong secs, usecs;\n\n\tsecs = tv1->tv_sec - tv2->tv_sec;\n\tusecs = tv1->tv_usec - tv2->tv_usec;\n\tif (usecs < 0) {\n\t\tusecs += 1000000;\n\t\tsecs--;\n\t}\n\tusecs = usecs/1000 + secs * 1000;\n\n\treturn usecs;\n}\n\nint find_substr(const char *list, const char *item)\n{\n\tconst char *ptr;\n\n\tg_return_val_if_fail(list != NULL, FALSE);\n\tg_return_val_if_fail(item != NULL, FALSE);\n\n\tif (*item == '\\0')\n\t\treturn FALSE;\n\n\tfor (;;) {\n\t\twhile (i_isspace(*list)) list++;\n\t\tif (*list == '\\0') break;\n\n\t\tptr = strchr(list, ' ');\n\t\tif (ptr == NULL) ptr = list+strlen(list);\n\n\t\tif (g_ascii_strncasecmp(list, item, ptr-list) == 0 &&\n\t\t    item[ptr-list] == '\\0')\n\t\t\treturn TRUE;\n\n\t\tlist = ptr;\n\t}\n\n\treturn FALSE;\n}\n\nint strarray_find(char **array, const char *item)\n{\n\tchar **tmp;\n\tint index;\n\n\tg_return_val_if_fail(array != NULL, -1);\n\tg_return_val_if_fail(item != NULL, -1);\n\n\tindex = 0;\n\tfor (tmp = array; *tmp != NULL; tmp++, index++) {\n\t\tif (g_ascii_strcasecmp(*tmp, item) == 0)\n\t\t\treturn index;\n\t}\n\n\treturn -1;\n}\n\nGSList *gslist_find_string(GSList *list, const char *key)\n{\n\tfor (; list != NULL; list = list->next)\n\t\tif (g_strcmp0(list->data, key) == 0) return list;\n\n\treturn NULL;\n}\n\nGSList *gslist_find_icase_string(GSList *list, const char *key)\n{\n\tfor (; list != NULL; list = list->next)\n\t\tif (g_ascii_strcasecmp(list->data, key) == 0) return list;\n\n\treturn NULL;\n}\n\nvoid *gslist_foreach_find(GSList *list, FOREACH_FIND_FUNC func, const void *data)\n{\n\tvoid *ret;\n\n\twhile (list != NULL) {\n\t\tret = func(list->data, (void *) data);\n                if (ret != NULL) return ret;\n\n\t\tlist = list->next;\n\t}\n\n\treturn NULL;\n}\n\nvoid gslist_free_full (GSList *list, GDestroyNotify free_func)\n{\n\tGSList *tmp;\n\n\tif (list == NULL)\n\t\treturn;\n\n\tfor (tmp = list; tmp != NULL; tmp = tmp->next)\n\t\tfree_func(tmp->data);\n\n\tg_slist_free(list);\n}\n\nGSList *gslist_remove_string (GSList *list, const char *str)\n{\n\tGSList *l;\n\n\tl = g_slist_find_custom(list, str, (GCompareFunc) g_strcmp0);\n\tif (l != NULL)\n\t\treturn g_slist_remove_link(list, l);\n\n\treturn list;\n}\n\n/* `list' contains pointer to structure with a char* to string. */\nchar *gslistptr_to_string(GSList *list, int offset, const char *delimiter)\n{\n\tGString *str;\n\tchar **data, *ret;\n\n\tstr = g_string_new(NULL);\n\twhile (list != NULL) {\n\t\tdata = G_STRUCT_MEMBER_P(list->data, offset);\n\n\t\tif (str->len != 0) g_string_append(str, delimiter);\n\t\tg_string_append(str, *data);\n\t\tlist = list->next;\n\t}\n\n        ret = str->str;\n\tg_string_free(str, FALSE);\n\treturn ret;\n}\n\n/* `list' contains char* */\nchar *gslist_to_string(GSList *list, const char *delimiter)\n{\n\tGString *str;\n\tchar *ret;\n\n\tstr = g_string_new(NULL);\n\twhile (list != NULL) {\n\t\tif (str->len != 0) g_string_append(str, delimiter);\n\t\tg_string_append(str, list->data);\n\n\t\tlist = list->next;\n\t}\n\n        ret = str->str;\n\tg_string_free(str, FALSE);\n\treturn ret;\n}\n\nvoid hash_save_key(char *key, void *value, GSList **list)\n{\n        *list = g_slist_append(*list, key);\n}\n\n/* remove all the options from the optlist hash table that are valid for the\n * command cmd */\nGList *optlist_remove_known(const char *cmd, GHashTable *optlist)\n{\n\tGList *list, *tmp, *next;\n\n\tlist = g_hash_table_get_keys(optlist);\n\tif (cmd != NULL && list != NULL) {\n\t\tfor (tmp = list; tmp != NULL; tmp = next) {\n\t\t\tchar *option = tmp->data;\n\t\t\tnext = tmp->next;\n\n\t\t\tif (command_have_option(cmd, option))\n\t\t\t\tlist = g_list_remove(list, option);\n\t\t}\n\t}\n\n\treturn list;\n}\n\nGList *glist_find_string(GList *list, const char *key)\n{\n\tfor (; list != NULL; list = list->next)\n\t\tif (g_strcmp0(list->data, key) == 0) return list;\n\n\treturn NULL;\n}\n\nGList *glist_find_icase_string(GList *list, const char *key)\n{\n\tfor (; list != NULL; list = list->next)\n\t\tif (g_ascii_strcasecmp(list->data, key) == 0) return list;\n\n\treturn NULL;\n}\n\nchar *stristr(const char *data, const char *key)\n{\n\tconst char *max;\n\tint keylen, datalen, pos;\n\n\tkeylen = strlen(key);\n\tdatalen = strlen(data);\n\n\tif (keylen > datalen)\n\t\treturn NULL;\n\tif (keylen == 0)\n\t\treturn (char *) data;\n\n\tmax = data+datalen-keylen;\n\tpos = 0;\n\twhile (data <= max) {\n\t\tif (key[pos] == '\\0')\n                        return (char *) data;\n\n\t\tif (i_toupper(data[pos]) == i_toupper(key[pos]))\n\t\t\tpos++;\n\t\telse {\n\t\t\tdata++;\n                        pos = 0;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#define isbound(c) \\\n\t((unsigned char) (c) < 128 && \\\n\t(i_isspace(c) || i_ispunct(c)))\n\nstatic char *strstr_full_case(const char *data, const char *key, int icase)\n{\n\tconst char *start, *max;\n\tint keylen, datalen, pos, match;\n\n\tkeylen = strlen(key);\n\tdatalen = strlen(data);\n\n\tif (keylen > datalen)\n\t\treturn NULL;\n\tif (keylen == 0)\n\t\treturn (char *) data;\n\n\tmax = data+datalen-keylen;\n\tstart = data; pos = 0;\n\twhile (data <= max) {\n\t\tif (key[pos] == '\\0') {\n\t\t\tif (data[pos] != '\\0' && !isbound(data[pos])) {\n\t\t\t\tdata++;\n\t\t\t\tpos = 0;\n                                continue;\n\t\t\t}\n\t\t\treturn (char *) data;\n\t\t}\n\n\t\tmatch = icase ? (i_toupper(data[pos]) == i_toupper(key[pos])) :\n\t\t\t\t data[pos] == key[pos];\n\n\t\tif (match && (pos != 0 || data == start || isbound(data[-1])))\n\t\t\tpos++;\n\t\telse {\n\t\t\tdata++;\n                        pos = 0;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nchar *strstr_full(const char *data, const char *key)\n{\n        return strstr_full_case(data, key, FALSE);\n}\n\nchar *stristr_full(const char *data, const char *key)\n{\n        return strstr_full_case(data, key, TRUE);\n}\n\n/* convert ~/ to $HOME */\nchar *convert_home(const char *path)\n{\n\tconst char *home;\n\n\tif (*path == '~' && (*(path+1) == '/' || *(path+1) == '\\0')) {\n\t\thome = g_get_home_dir();\n\t\tif (home == NULL)\n\t\t\thome = \".\";\n\n\t\treturn g_strconcat(home, path+1, NULL);\n\t} else {\n\t\treturn g_strdup(path);\n\t}\n}\n\nint g_istr_equal(gconstpointer v, gconstpointer v2)\n{\n\treturn g_ascii_strcasecmp((const char *) v, (const char *) v2) == 0;\n}\n\nint g_istr_cmp(gconstpointer v, gconstpointer v2)\n{\n\treturn g_ascii_strcasecmp((const char *) v, (const char *) v2);\n}\n\nguint g_istr_hash(gconstpointer v)\n{\n\tconst signed char *p;\n\tguint32 h = 5381;\n\n\tfor (p = v; *p != '\\0'; p++)\n\t\th = (h << 5) + h + g_ascii_toupper(*p);\n\n\treturn h;\n}\n\n/* Find `mask' from `data', you can use * and ? wildcards. */\nint match_wildcards(const char *cmask, const char *data)\n{\n\tchar *mask, *newmask, *p1, *p2;\n\tint ret;\n\n\tnewmask = mask = g_strdup(cmask);\n\tfor (; *mask != '\\0' && *data != '\\0'; mask++) {\n\t\tif (*mask != '*') {\n\t\t\tif (*mask != '?' && i_toupper(*mask) != i_toupper(*data))\n\t\t\t\tbreak;\n\n\t\t\tdata++;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*mask == '?' || *mask == '*') mask++;\n\t\tif (*mask == '\\0') {\n\t\t\tdata += strlen(data);\n\t\t\tbreak;\n\t\t}\n\n\t\tp1 = strchr(mask, '*');\n\t\tp2 = strchr(mask, '?');\n\t\tif (p1 == NULL || (p2 < p1 && p2 != NULL)) p1 = p2;\n\n\t\tif (p1 != NULL) *p1 = '\\0';\n\n\t\tdata = stristr(data, mask);\n\t\tif (data == NULL) break;\n\n\t\tdata += strlen(mask);\n\t\tmask += strlen(mask)-1;\n\n\t\tif (p1 != NULL) *p1 = p1 == p2 ? '?' : '*';\n\t}\n\n\twhile (*mask == '*') mask++;\n\n\tret = data != NULL && *data == '\\0' && *mask == '\\0';\n\tg_free(newmask);\n\n\treturn ret;\n}\n\n/* Return TRUE if all characters in `str' are numbers.\n   Stop when `end_char' is found from string. */\nint is_numeric(const char *str, char end_char)\n{\n\tg_return_val_if_fail(str != NULL, FALSE);\n\n\tif (*str == '\\0' || *str == end_char)\n\t\treturn FALSE;\n\n\twhile (*str != '\\0' && *str != end_char) {\n\t\tif (!i_isdigit(*str)) return FALSE;\n\t\tstr++;\n\t}\n\n\treturn TRUE;\n}\n\n/* replace all `from' chars in string to `to' chars. returns `str' */\nchar *replace_chars(char *str, char from, char to)\n{\n\tchar *p;\n\n\tfor (p = str; *p != '\\0'; p++) {\n\t\tif (*p == from) *p = to;\n\t}\n\treturn str;\n}\n\nint octal2dec(int octal)\n{\n\tint dec, n;\n\n\tdec = 0; n = 1;\n\twhile (octal != 0) {\n\t\tdec += n*(octal%10);\n\t\toctal /= 10; n *= 8;\n\t}\n\n\treturn dec;\n}\n\nint dec2octal(int decimal)\n{\n\tint octal, pos;\n\n\toctal = 0; pos = 0;\n\twhile (decimal > 0) {\n\t\toctal += (decimal & 7)*(pos == 0 ? 1 : pos);\n\t\tdecimal /= 8;\n\t\tpos += 10;\n\t}\n\n\treturn octal;\n}\n\n/* string -> uoff_t */\nuoff_t str_to_uofft(const char *str)\n{\n#ifdef UOFF_T_LONG_LONG\n\treturn (uoff_t)strtoull(str, NULL, 10);\n#else\n\treturn (uoff_t)strtoul(str, NULL, 10);\n#endif\n}\n\n/* convert all low-ascii (<32) to ^<A..> combinations */\nchar *show_lowascii(const char *str)\n{\n\tchar *ret, *p;\n\n\tret = p = g_malloc(strlen(str)*2+1);\n\twhile (*str != '\\0') {\n\t\tif ((unsigned char) *str >= 32)\n\t\t\t*p++ = *str;\n\t\telse {\n\t\t\t*p++ = '^';\n\t\t\t*p++ = *str + 'A'-1;\n\t\t}\n\t\tstr++;\n\t}\n\t*p = '\\0';\n\n\treturn ret;\n}\n\n/* Get time in human readable form with localtime() + asctime() */\nchar *my_asctime(time_t t)\n{\n\tstruct tm *tm;\n\tchar *str;\n        int len;\n\n\ttm = localtime(&t);\n\tstr = g_strdup(asctime(tm));\n\n\tlen = strlen(str);\n\tif (len > 0) str[len-1] = '\\0';\n        return str;\n}\n\n/* Returns number of columns needed to print items.\n   save_column_widths is filled with length of each column. */\nint get_max_column_count(GSList *items, COLUMN_LEN_FUNC len_func,\n\t\t\t int max_width, int max_columns,\n\t\t\t int item_extra, int item_min_size,\n\t\t\t int **save_column_widths, int *rows)\n{\n        GSList *tmp;\n\tint **columns, *columns_width, *columns_rows;\n\tint item_pos, items_count;\n\tint ret, len, max_len, n, col;\n\n\titems_count = g_slist_length(items);\n\tif (items_count == 0) {\n\t\t*save_column_widths = NULL;\n                *rows = 0;\n\t\treturn 0;\n\t}\n\n\tlen = max_width/(item_extra+item_min_size);\n        if (len <= 0) len = 1;\n\tif (max_columns <= 0 || len < max_columns)\n                max_columns = len;\n\n\tcolumns = g_new0(int *, max_columns);\n\tcolumns_width = g_new0(int, max_columns);\n\tcolumns_rows = g_new0(int, max_columns);\n\n\tfor (n = 1; n < max_columns; n++) {\n\t\tcolumns[n] = g_new0(int, n+1);\n\t\tcolumns_rows[n] = items_count <= n+1 ? 1 :\n                        (items_count+n)/(n+1);\n\t}\n\n\t/* for each possible column count, save the column widths and\n\t   find the biggest column count that fits to screen. */\n        item_pos = 0; max_len = 0;\n\tfor (tmp = items; tmp != NULL; tmp = tmp->next) {\n\t\tlen = item_extra+len_func(tmp->data);\n\t\tif (max_len < len)\n\t\t\tmax_len = len;\n\n\t\tfor (n = 1; n < max_columns; n++) {\n\t\t\tif (columns_width[n] > max_width)\n\t\t\t\tcontinue; /* too wide */\n\n\t\t\tcol = item_pos/columns_rows[n];\n\t\t\tif (columns[n][col] < len) {\n\t\t\t\tcolumns_width[n] += len-columns[n][col];\n                                columns[n][col] = len;\n\t\t\t}\n\t\t}\n\n                item_pos++;\n\t}\n\n\tfor (n = max_columns-1; n >= 1; n--) {\n\t\tif (columns_width[n] <= max_width &&\n\t\t    columns[n][n] > 0)\n                        break;\n\t}\n        ret = n+1;\n\n\t*save_column_widths = g_new(int, ret);\n\tif (ret == 1) {\n                **save_column_widths = max_len;\n                *rows = 1;\n\t} else {\n\t\tmemcpy(*save_column_widths, columns[ret-1], sizeof(int)*ret);\n\t\t*rows = columns_rows[ret-1];\n\t}\n\n\tfor (n = 1; n < max_columns; n++)\n                g_free(columns[n]);\n\tg_free(columns_width);\n\tg_free(columns_rows);\n\tg_free(columns);\n\n        return ret;\n}\n\n/* Return a column sorted copy of a list. */\nGSList *columns_sort_list(GSList *list, int rows)\n{\n        GSList *tmp, *sorted;\n\tint row, skip;\n\n\tif (list == NULL || rows == 0)\n                return list;\n\n\tsorted = NULL;\n\n\tfor (row = 0; row < rows; row++) {\n                tmp = g_slist_nth(list, row);\n                skip = 1;\n\t\tfor (; tmp != NULL; tmp = tmp->next) {\n\t\t\tif (--skip == 0) {\n                                skip = rows;\n\t\t\t\tsorted = g_slist_append(sorted, tmp->data);\n\t\t\t}\n\t\t}\n\t}\n\n\tg_return_val_if_fail(g_slist_length(sorted) ==\n\t\t\t     g_slist_length(list), sorted);\n        return sorted;\n}\n\n/* Expand escape string, the first character in data should be the\n   one after '\\'. Returns the expanded character or -1 if error. */\nint expand_escape(const char **data)\n{\n        char digit[4];\n\n\tswitch (**data) {\n\tcase 't':\n\t\treturn '\\t';\n\tcase 'r':\n\t\treturn '\\r';\n\tcase 'n':\n\t\treturn '\\n';\n\tcase 'e':\n\t\treturn 27; /* ESC */\n\tcase '\\\\':\n\t\treturn '\\\\';\n\n\tcase 'x':\n                /* hex digit */\n\t\tif (!i_isxdigit((*data)[1]) || !i_isxdigit((*data)[2]))\n\t\t\treturn -1;\n\n\t\tdigit[0] = (*data)[1];\n\t\tdigit[1] = (*data)[2];\n                digit[2] = '\\0';\n\t\t*data += 2;\n\t\treturn strtol(digit, NULL, 16);\n\tcase 'c':\n                /* control character (\\cA = ^A) */\n                (*data)++;\n\t\treturn i_toupper(**data) - 64;\n\tcase '0': case '1': case '2': case '3':\n\tcase '4': case '5': case '6': case '7':\n                /* octal */\n\t\tdigit[1] = digit[2] = digit[3] = '\\0';\n                digit[0] = (*data)[0];\n\t\tif ((*data)[1] >= '0' && (*data)[1] <= '7') {\n\t\t\t++*data;\n\t\t\tdigit[1] = **data;\n\t\t\tif ((*data)[1] >= '0' && (*data)[1] <= '7') {\n\t\t\t\t++*data;\n\t\t\t\tdigit[2] = **data;\n\t\t\t}\n\t\t}\n\t\treturn strtol(digit, NULL, 8);\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n/* Escape all '\"', \"'\" and '\\' chars with '\\' */\nchar *escape_string(const char *str)\n{\n\tchar *ret, *p;\n\n\tp = ret = g_malloc(strlen(str)*2+1);\n\twhile (*str != '\\0') {\n\t\tif (*str == '\"' || *str == '\\'' || *str == '\\\\')\n\t\t\t*p++ = '\\\\';\n\t\t*p++ = *str++;\n\t}\n\t*p = '\\0';\n\n\treturn ret;\n}\n\nint nearest_power(int num)\n{\n\tint n = 1;\n\n\twhile (n < num) n <<= 1;\n\treturn n;\n}\n\n/* Parses unsigned integers from strings with decent error checking.\n * Returns true on success, false otherwise (overflow, no valid number, etc)\n * There's a 31 bit limit so the output can be assigned to signed positive ints */\nint parse_uint(const char *nptr, char **endptr, int base, guint *number)\n{\n\tchar *endptr_;\n\tgulong parsed;\n\n\t/* strtoul accepts whitespace and plus/minus signs, for some reason */\n\tif (!i_isdigit(*nptr)) {\n\t\treturn FALSE;\n\t}\n\n\terrno = 0;\n\tparsed = strtoul(nptr, &endptr_, base);\n\n\tif (errno || endptr_ == nptr || parsed >= (1U << 31)) {\n\t\treturn FALSE;\n\t}\n\n\tif (endptr) {\n\t\t*endptr = endptr_;\n\t}\n\n\tif (number) {\n\t\t*number = (guint) parsed;\n\t}\n\n\treturn TRUE;\n}\n\nstatic int parse_number_sign(const char *input, char **endptr, int *sign)\n{\n\tint sign_ = 1;\n\n\twhile (i_isspace(*input))\n\t\tinput++;\n\n\tif (*input == '-') {\n\t\tsign_ = -sign_;\n\t\tinput++;\n\t}\n\n\t*sign = sign_;\n\t*endptr = (char *) input;\n\treturn TRUE;\n}\n\nstatic int parse_time_interval_uint(const char *time, guint *msecs)\n{\n\tconst char *desc;\n\tguint number;\n\tint len, ret, digits;\n\n\t*msecs = 0;\n\n\t/* max. return value is around 24 days */\n\tnumber = 0; ret = TRUE; digits = FALSE;\n\twhile (i_isspace(*time))\n\t\ttime++;\n\tfor (;;) {\n\t\tif (i_isdigit(*time)) {\n\t\t\tchar *endptr;\n\t\t\tif (!parse_uint(time, &endptr, 10, &number)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\ttime = endptr;\n\t\t\tdigits = TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!digits)\n\t\t\treturn FALSE;\n\n\t\t/* skip punctuation */\n\t\twhile (*time != '\\0' && i_ispunct(*time) && *time != '-')\n\t\t\ttime++;\n\n\t\t/* get description */\n\t\tfor (len = 0, desc = time; i_isalpha(*time); time++)\n\t\t\tlen++;\n\n\t\twhile (i_isspace(*time))\n\t\t\ttime++;\n\n\t\tif (len == 0) {\n\t\t\tif (*time != '\\0')\n\t\t\t\treturn FALSE;\n\t\t\t*msecs += number * 1000; /* assume seconds */\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tif (g_ascii_strncasecmp(desc, \"days\", len) == 0) {\n\t\t\tif (number > 24) {\n\t\t\t\t/* would overflow */\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t*msecs += number * 1000*3600*24;\n\t\t} else if (g_ascii_strncasecmp(desc, \"hours\", len) == 0)\n\t\t\t*msecs += number * 1000*3600;\n\t\telse if (g_ascii_strncasecmp(desc, \"minutes\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"mins\", len) == 0)\n\t\t\t*msecs += number * 1000*60;\n\t\telse if (g_ascii_strncasecmp(desc, \"seconds\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"secs\", len) == 0)\n\t\t\t*msecs += number * 1000;\n\t\telse if (g_ascii_strncasecmp(desc, \"milliseconds\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"millisecs\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"mseconds\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"msecs\", len) == 0)\n\t\t\t*msecs += number;\n\t\telse {\n\t\t\tret = FALSE;\n\t\t}\n\n\t\t/* skip punctuation */\n\t\twhile (*time != '\\0' && i_ispunct(*time) && *time != '-')\n\t\t\ttime++;\n\n\t\tif (*time == '\\0')\n\t\t\tbreak;\n\n\t\tnumber = 0;\n\t\tdigits = FALSE;\n\t}\n\n\treturn ret;\n}\n\nstatic int parse_size_uint(const char *size, guint *bytes)\n{\n\tconst char *desc;\n\tguint number, multiplier, limit;\n\tint len;\n\n\t*bytes = 0;\n\n\t/* max. return value is about 1.6 years */\n\tnumber = 0;\n\twhile (*size != '\\0') {\n\t\tif (i_isdigit(*size)) {\n\t\t\tchar *endptr;\n\t\t\tif (!parse_uint(size, &endptr, 10, &number)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tsize = endptr;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* skip punctuation */\n\t\twhile (*size != '\\0' && i_ispunct(*size))\n\t\t\tsize++;\n\n\t\t/* get description */\n\t\tfor (len = 0, desc = size; i_isalpha(*size); size++)\n\t\t\tlen++;\n\n\t\tif (len == 0) {\n\t\t\tif (number == 0) {\n\t\t\t\t/* \"0\" - allow it */\n\t\t\t\treturn TRUE;\n\t\t\t}\n\n\t\t\t*bytes += number*1024; /* assume kilobytes */\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tmultiplier = 0;\n\t\tlimit = 0;\n\n\t\tif (g_ascii_strncasecmp(desc, \"gbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 30;\n\t\t\tlimit = 2U << 0;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"mbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 20;\n\t\t\tlimit = 2U << 10;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"kbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 10;\n\t\t\tlimit = 2U << 20;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"bytes\", len) == 0) {\n\t\t\tmultiplier = 1;\n\t\t\tlimit = 2U << 30;\n\t\t}\n\n\t\tif (limit && number > limit) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t*bytes += number * multiplier;\n\n\t\t/* skip punctuation */\n\t\twhile (*size != '\\0' && i_ispunct(*size))\n\t\t\tsize++;\n\t}\n\n\treturn TRUE;\n}\n\nint parse_size(const char *size, int *bytes)\n{\n\tguint bytes_;\n\tint ret;\n\n\tret = parse_size_uint(size, &bytes_);\n\n\tif (bytes_ > (1U << 31)) {\n\t\treturn FALSE;\n\t}\n\n\t*bytes = bytes_;\n\treturn ret;\n}\n\nint parse_time_interval(const char *time, int *msecs)\n{\n\tguint msecs_;\n\tchar *number;\n\tint ret, sign;\n\n\tparse_number_sign(time, &number, &sign);\n\n\tret = parse_time_interval_uint(number, &msecs_);\n\n\tif (msecs_ > (1U << 31)) {\n\t\treturn FALSE;\n\t}\n\n\t*msecs = msecs_ * sign;\n\treturn ret;\n}\n\n\nchar *ascii_strup(char *str)\n{\n\tchar *s;\n\n\tfor (s = str; *s; s++)\n\t\t*s = g_ascii_toupper (*s);\n\treturn str;\n}\n\nchar *ascii_strdown(char *str)\n{\n\tchar *s;\n\n\tfor (s = str; *s; s++)\n\t\t*s = g_ascii_tolower (*s);\n\treturn str;\n}\n\nchar **strsplit_len(const char *str, int len, gboolean onspace)\n{\n\tchar **ret = g_new(char *, 1);\n\tint n;\n\tint offset;\n\n\tfor (n = 0; *str != '\\0'; n++, str += offset) {\n\t\toffset = MIN(len, strlen(str));\n\t\tif (onspace && strlen(str) > len) {\n\t\t\t/*\n\t\t\t * Try to find a space to split on and leave\n\t\t\t * the space on the previous line.\n\t\t\t */\n\t\t\tint i;\n\t\t\tfor (i = len - 1; i > 0; i--) {\n\t\t\t\tif (str[i] == ' ') {\n\t\t\t\t\toffset = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret[n] = g_strndup(str, offset);\n\t\tret = g_renew(char *, ret, n + 2);\n\t}\n\tret[n] = NULL;\n\n\treturn ret;\n}\n\nchar *binary_to_hex(unsigned char *buffer, size_t size)\n{\n\tstatic const char hex[] = \"0123456789ABCDEF\";\n\tchar *result = NULL;\n\tint i;\n\n\tif (buffer == NULL || size == 0)\n\t\treturn NULL;\n\n\tresult = g_malloc(3 * size);\n\n\tfor (i = 0; i < size; i++) {\n\t\tresult[i * 3 + 0] = hex[(buffer[i] >> 4) & 0xf];\n\t\tresult[i * 3 + 1] = hex[(buffer[i] >> 0) & 0xf];\n\t\tresult[i * 3 + 2] = i == size - 1 ? '\\0' : ':';\n\t}\n\n\treturn result;\n}\n", "/*\n nicklist.c : irssi\n\n    Copyright (C) 1999-2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include \"signals.h\"\n#include \"misc.h\"\n\n#include \"servers.h\"\n#include \"channels.h\"\n#include \"nicklist.h\"\n#include \"masks.h\"\n\n#define isalnumhigh(a) \\\n        (i_isalnum(a) || (unsigned char) (a) >= 128)\n\nstatic void nick_hash_add(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tNICK_REC *list;\n\n\tnick->next = NULL;\n\n\tlist = g_hash_table_lookup(channel->nicks, nick->nick);\n        if (list == NULL)\n\t\tg_hash_table_insert(channel->nicks, nick->nick, nick);\n\telse {\n                /* multiple nicks with same name */\n\t\twhile (list->next != NULL)\n\t\t\tlist = list->next;\n\t\tlist->next = nick;\n\t}\n\n\tif (nick == channel->ownnick) {\n                /* move our own nick to beginning of the nick list.. */\n\t\tnicklist_set_own(channel, nick);\n\t}\n}\n\nstatic void nick_hash_remove(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tNICK_REC *list;\n\n\tlist = g_hash_table_lookup(channel->nicks, nick->nick);\n\tif (list == NULL)\n\t\treturn;\n\n\tif (list == nick || list->next == NULL) {\n\t\tg_hash_table_remove(channel->nicks, nick->nick);\n\t\tif (list->next != NULL) {\n\t\t\tg_hash_table_insert(channel->nicks, nick->next->nick,\n\t\t\t\t\t    nick->next);\n\t\t}\n\t} else {\n\t\twhile (list->next != nick)\n\t\t\tlist = list->next;\n\t\tlist->next = nick->next;\n\t}\n}\n\n/* Add new nick to list */\nvoid nicklist_insert(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\t/*MODULE_DATA_INIT(nick);*/\n\n\tnick->type = module_get_uniq_id(\"NICK\", 0);\n        nick->chat_type = channel->chat_type;\n\n        nick_hash_add(channel, nick);\n\tsignal_emit(\"nicklist new\", 2, channel, nick);\n}\n\n/* Set host address for nick */\nvoid nicklist_set_host(CHANNEL_REC *channel, NICK_REC *nick, const char *host)\n{\n        g_return_if_fail(channel != NULL);\n        g_return_if_fail(nick != NULL);\n\tg_return_if_fail(host != NULL);\n\n        g_free_not_null(nick->host);\n\tnick->host = g_strdup(host);\n\n        signal_emit(\"nicklist host changed\", 2, channel, nick);\n}\n\nstatic void nicklist_destroy(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tsignal_emit(\"nicklist remove\", 2, channel, nick);\n\n\tif (channel->ownnick == nick)\n                channel->ownnick = NULL;\n\n        /*MODULE_DATA_DEINIT(nick);*/\n\tg_free(nick->nick);\n\tg_free_not_null(nick->realname);\n\tg_free_not_null(nick->host);\n\tg_free(nick);\n}\n\n/* Remove nick from list */\nvoid nicklist_remove(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tg_return_if_fail(IS_CHANNEL(channel));\n\tg_return_if_fail(nick != NULL);\n\n        nick_hash_remove(channel, nick);\n\tnicklist_destroy(channel, nick);\n}\n\nstatic void nicklist_rename_list(SERVER_REC *server, void *new_nick_id,\n\t\t\t\t const char *old_nick, const char *new_nick,\n\t\t\t\t GSList *nicks)\n{\n\tCHANNEL_REC *channel;\n\tNICK_REC *nickrec;\n\tGSList *tmp;\n\n\tfor (tmp = nicks; tmp != NULL; tmp = tmp->next->next) {\n\t\tchannel = tmp->data;\n\t\tnickrec = tmp->next->data;\n\n\t\t/* remove old nick from hash table */\n                nick_hash_remove(channel, nickrec);\n\n\t\tif (new_nick_id != NULL)\n\t\t\tnickrec->unique_id = new_nick_id;\n\n\t\tg_free(nickrec->nick);\n\t\tnickrec->nick = g_strdup(new_nick);\n\n\t\t/* add new nick to hash table */\n                nick_hash_add(channel, nickrec);\n\n\t\tsignal_emit(\"nicklist changed\", 3, channel, nickrec, old_nick);\n\t}\n\tg_slist_free(nicks);\n}\n\nvoid nicklist_rename(SERVER_REC *server, const char *old_nick,\n\t\t     const char *new_nick)\n{\n\tnicklist_rename_list(server, NULL, old_nick, new_nick,\n\t\t\t     nicklist_get_same(server, old_nick));\n}\n\nvoid nicklist_rename_unique(SERVER_REC *server,\n\t\t\t    void *old_nick_id, const char *old_nick,\n\t\t\t    void *new_nick_id, const char *new_nick)\n{\n\tnicklist_rename_list(server, new_nick_id, old_nick, new_nick,\n\t\t\t     nicklist_get_same_unique(server, old_nick_id));\n}\n\nstatic NICK_REC *nicklist_find_wildcards(CHANNEL_REC *channel,\n\t\t\t\t\t const char *mask)\n{\n\tNICK_REC *nick;\n\tGHashTableIter iter;\n\n\tg_hash_table_iter_init(&iter, channel->nicks);\n\twhile (g_hash_table_iter_next(&iter, NULL, (void*)&nick)) {\n\t\tfor (; nick != NULL; nick = nick->next) {\n\t\t\tif (mask_match_address(channel->server, mask,\n\t\t\t\t\t       nick->nick, nick->host))\n\t\t\t\treturn nick;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nGSList *nicklist_find_multiple(CHANNEL_REC *channel, const char *mask)\n{\n\tGSList *nicks;\n\tNICK_REC *nick;\n\tGHashTableIter iter;\n\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\tg_return_val_if_fail(mask != NULL, NULL);\n\n\tnicks = NULL;\n\n\tg_hash_table_iter_init(&iter, channel->nicks);\n\twhile (g_hash_table_iter_next(&iter, NULL, (void*)&nick)) {\n\t\tfor (; nick != NULL; nick = nick->next) {\n\t\t\tif (mask_match_address(channel->server, mask,\n\t\t\t\t\t       nick->nick, nick->host))\n\t\t\t\tnicks = g_slist_prepend(nicks, nick);\n\t\t}\n\t}\n\n\treturn nicks;\n}\n\n/* Find nick */\nNICK_REC *nicklist_find(CHANNEL_REC *channel, const char *nick)\n{\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\tg_return_val_if_fail(nick != NULL, NULL);\n\n\treturn g_hash_table_lookup(channel->nicks, nick);\n}\n\nNICK_REC *nicklist_find_unique(CHANNEL_REC *channel, const char *nick,\n\t\t\t       void *id)\n{\n\tNICK_REC *rec;\n\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\tg_return_val_if_fail(nick != NULL, NULL);\n\n\trec = g_hash_table_lookup(channel->nicks, nick);\n\twhile (rec != NULL && rec->unique_id != id)\n                rec = rec->next;\n\n        return rec;\n}\n\n/* Find nick mask, wildcards allowed */\nNICK_REC *nicklist_find_mask(CHANNEL_REC *channel, const char *mask)\n{\n\tNICK_REC *nickrec;\n\tchar *nick, *host;\n\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\tg_return_val_if_fail(mask != NULL, NULL);\n\n\tnick = g_strdup(mask);\n\thost = strchr(nick, '!');\n\tif (host != NULL) *host++ = '\\0';\n\n\tif (strchr(nick, '*') || strchr(nick, '?')) {\n\t\tg_free(nick);\n\t\treturn nicklist_find_wildcards(channel, mask);\n\t}\n\n\tnickrec = g_hash_table_lookup(channel->nicks, nick);\n\n\tif (host != NULL) {\n\t\twhile (nickrec != NULL) {\n\t\t\tif (nickrec->host != NULL &&\n\t\t\t    match_wildcards(host, nickrec->host))\n\t\t\t\tbreak; /* match */\n\t\t\tnickrec = nickrec->next;\n\t\t}\n\t}\n\tg_free(nick);\n\treturn nickrec;\n}\n\nstatic void get_nicks_hash(gpointer key, NICK_REC *rec, GSList **list)\n{\n\twhile (rec != NULL) {\n\t\t*list = g_slist_prepend(*list, rec);\n\t\trec = rec->next;\n\t}\n}\n\n/* Get list of nicks */\nGSList *nicklist_getnicks(CHANNEL_REC *channel)\n{\n\tGSList *list;\n\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\n\tlist = NULL;\n\tg_hash_table_foreach(channel->nicks, (GHFunc) get_nicks_hash, &list);\n\treturn list;\n}\n\nGSList *nicklist_get_same(SERVER_REC *server, const char *nick)\n{\n\tGSList *tmp;\n\tGSList *list = NULL;\n\n\tg_return_val_if_fail(IS_SERVER(server), NULL);\n\n\tfor (tmp = server->channels; tmp != NULL; tmp = tmp->next) {\n\t\tNICK_REC *nick_rec;\n\t\tCHANNEL_REC *channel = tmp->data;\n\n\t\tfor (nick_rec = g_hash_table_lookup(channel->nicks, nick);\n\t\t     nick_rec != NULL;\n\t\t     nick_rec = nick_rec->next) {\n\t\t\tlist = g_slist_append(list, channel);\n\t\t\tlist = g_slist_append(list, nick_rec);\n\t\t}\n\t}\n\n\treturn list;\n}\n\ntypedef struct {\n\tCHANNEL_REC *channel;\n        void *id;\n\tGSList *list;\n} NICKLIST_GET_SAME_UNIQUE_REC;\n\nstatic void get_nicks_same_hash_unique(gpointer key, NICK_REC *nick,\n\t\t\t\t       NICKLIST_GET_SAME_UNIQUE_REC *rec)\n{\n\twhile (nick != NULL) {\n\t\tif (nick->unique_id == rec->id) {\n\t\t\trec->list = g_slist_append(rec->list, rec->channel);\n\t\t\trec->list = g_slist_append(rec->list, nick);\n                        break;\n\t\t}\n\n                nick = nick->next;\n\t}\n}\n\nGSList *nicklist_get_same_unique(SERVER_REC *server, void *id)\n{\n\tNICKLIST_GET_SAME_UNIQUE_REC rec;\n\tGSList *tmp;\n\n\tg_return_val_if_fail(IS_SERVER(server), NULL);\n\tg_return_val_if_fail(id != NULL, NULL);\n\n        rec.id = id;\n\trec.list = NULL;\n\tfor (tmp = server->channels; tmp != NULL; tmp = tmp->next) {\n\t\trec.channel = tmp->data;\n\t\tg_hash_table_foreach(rec.channel->nicks,\n\t\t\t\t     (GHFunc) get_nicks_same_hash_unique,\n\t\t\t\t     &rec);\n\t}\n\treturn rec.list;\n}\n\n/* nick record comparison for sort functions */\nint nicklist_compare(NICK_REC *p1, NICK_REC *p2, const char *nick_prefix)\n{\n\tint i;\n\n\tif (p1 == NULL) return -1;\n\tif (p2 == NULL) return 1;\n\n\tif (p1->prefixes[0] == p2->prefixes[0])\n\t\treturn g_ascii_strcasecmp(p1->nick, p2->nick);\n\n\tif (!p1->prefixes[0])\n\t\treturn 1;\n\tif (!p2->prefixes[0])\n\t\treturn -1;\n\n\t/* They aren't equal.  We've taken care of that already.\n\t * The first one we encounter in this list is the greater.\n\t */\n\n\tfor (i = 0; nick_prefix[i] != '\\0'; i++) {\n\t\tif (p1->prefixes[0] == nick_prefix[i])\n\t\t\treturn -1;\n\t\tif (p2->prefixes[0] == nick_prefix[i])\n\t\t\treturn 1;\n\t}\n\n\t/* we should never have gotten here... */\n\treturn g_ascii_strcasecmp(p1->nick, p2->nick);\n}\n\nstatic void nicklist_update_flags_list(SERVER_REC *server, int gone,\n\t\t\t\t       int serverop, GSList *nicks)\n{\n\tGSList *tmp;\n\tCHANNEL_REC *channel;\n\tNICK_REC *rec;\n\n\tg_return_if_fail(IS_SERVER(server));\n\n\tfor (tmp = nicks; tmp != NULL; tmp = tmp->next->next) {\n\t\tchannel = tmp->data;\n\t\trec = tmp->next->data;\n\n\t\trec->last_check = time(NULL);\n\n\t\tif (gone != -1 && (int)rec->gone != gone) {\n\t\t\trec->gone = gone;\n\t\t\tsignal_emit(\"nicklist gone changed\", 2, channel, rec);\n\t\t}\n\n\t\tif (serverop != -1 && (int)rec->serverop != serverop) {\n\t\t\trec->serverop = serverop;\n\t\t\tsignal_emit(\"nicklist serverop changed\", 2, channel, rec);\n\t\t}\n\t}\n\tg_slist_free(nicks);\n}\n\nvoid nicklist_update_flags(SERVER_REC *server, const char *nick,\n\t\t\t   int gone, int serverop)\n{\n\tnicklist_update_flags_list(server, gone, serverop,\n\t\t\t\t   nicklist_get_same(server, nick));\n}\n\nvoid nicklist_update_flags_unique(SERVER_REC *server, void *id,\n\t\t\t\t  int gone, int serverop)\n{\n\tnicklist_update_flags_list(server, gone, serverop,\n\t\t\t\t   nicklist_get_same_unique(server, id));\n}\n\n/* Specify which nick in channel is ours */\nvoid nicklist_set_own(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tNICK_REC *first, *next;\n\n        channel->ownnick = nick;\n\n\t/* move our nick in the list to first, makes some things easier\n\t   (like handling multiple identical nicks in fe-messages.c) */\n\tfirst = g_hash_table_lookup(channel->nicks, nick->nick);\n\tif (first->next == NULL)\n\t\treturn;\n\n\tnext = nick->next;\n\tnick->next = first;\n\n\twhile (first->next != nick)\n                first = first->next;\n\tfirst->next = next;\n\n        g_hash_table_insert(channel->nicks, nick->nick, nick);\n}\n\nstatic void sig_channel_created(CHANNEL_REC *channel)\n{\n\tg_return_if_fail(IS_CHANNEL(channel));\n\n\tchannel->nicks = g_hash_table_new((GHashFunc) g_istr_hash,\n\t\t\t\t\t  (GCompareFunc) g_istr_equal);\n}\n\nstatic void nicklist_remove_hash(gpointer key, NICK_REC *nick,\n\t\t\t\t CHANNEL_REC *channel)\n{\n\tNICK_REC *next;\n\n\twhile (nick != NULL) {\n                next = nick->next;\n\t\tnicklist_destroy(channel, nick);\n                nick = next;\n\t}\n}\n\nstatic void sig_channel_destroyed(CHANNEL_REC *channel)\n{\n\tg_return_if_fail(IS_CHANNEL(channel));\n\n\tg_hash_table_foreach(channel->nicks,\n\t\t\t     (GHFunc) nicklist_remove_hash, channel);\n\tg_hash_table_destroy(channel->nicks);\n}\n\nstatic NICK_REC *nick_nfind(CHANNEL_REC *channel, const char *nick, int len)\n{\n        NICK_REC *rec;\n\tchar *tmpnick;\n\n\ttmpnick = g_strndup(nick, len);\n\trec = g_hash_table_lookup(channel->nicks, tmpnick);\n\n\tif (rec != NULL) {\n\t\t/* if there's multiple, get the one with identical case */\n\t\twhile (rec->next != NULL) {\n\t\t\tif (g_strcmp0(rec->nick, tmpnick) == 0)\n\t\t\t\tbreak;\n                        rec = rec->next;\n\t\t}\n\t}\n\n        g_free(tmpnick);\n\treturn rec;\n}\n\n/* Check is `msg' is meant for `nick'. */\nint nick_match_msg(CHANNEL_REC *channel, const char *msg, const char *nick)\n{\n\tconst char *msgstart, *orignick;\n\tint len, fullmatch;\n\n\tg_return_val_if_fail(nick != NULL, FALSE);\n\tg_return_val_if_fail(msg != NULL, FALSE);\n\n\tif (channel != NULL && channel->server->nick_match_msg != NULL)\n\t\treturn channel->server->nick_match_msg(msg, nick);\n\n\t/* first check for identical match */\n\tlen = strlen(nick);\n\tif (g_ascii_strncasecmp(msg, nick, len) == 0 &&\n\t    !isalnumhigh((int) msg[len]))\n\t\treturn TRUE;\n\n\torignick = nick;\n\tfor (;;) {\n\t\tnick = orignick;\n\t\tmsgstart = msg;\n                fullmatch = TRUE;\n\n\t\t/* check if it matches for alphanumeric parts of nick */\n\t\twhile (*nick != '\\0' && *msg != '\\0') {\n\t\t\tif (i_toupper(*nick) == i_toupper(*msg)) {\n\t\t\t\t/* total match */\n\t\t\t\tmsg++;\n\t\t\t} else if (i_isalnum(*msg) && !i_isalnum(*nick)) {\n\t\t\t\t/* some strange char in your nick, pass it */\n                                fullmatch = FALSE;\n\t\t\t} else\n\t\t\t\tbreak;\n\n\t\t\tnick++;\n\t\t}\n\n\t\tif (msg != msgstart && !isalnumhigh(*msg)) {\n\t\t\t/* at least some of the chars in line matched the\n\t\t\t   nick, and msg continue with non-alphanum character,\n\t\t\t   this might be for us.. */\n\t\t\tif (*nick != '\\0') {\n\t\t\t\t/* remove the rest of the non-alphanum chars\n\t\t\t\t   from nick and check if it then matches. */\n                                fullmatch = FALSE;\n\t\t\t\twhile (*nick != '\\0' && !i_isalnum(*nick))\n\t\t\t\t\tnick++;\n\t\t\t}\n\n\t\t\tif (*nick == '\\0') {\n\t\t\t\t/* yes, match! */\n                                break;\n\t\t\t}\n\t\t}\n\n\t\t/* no match. check if this is a message to multiple people\n\t\t   (like nick1,nick2: text) */\n\t\twhile (*msg != '\\0' && *msg != ' ' && *msg != ',') msg++;\n\n\t\tif (*msg != ',') {\n                        nick = orignick;\n\t\t\tbreak;\n\t\t}\n\n                msg++;\n\t}\n\n\tif (*nick != '\\0')\n\t\treturn FALSE; /* didn't match */\n\n\tif (fullmatch)\n\t\treturn TRUE; /* matched without fuzzyness */\n\n\tif (channel != NULL) {\n\t\t/* matched with some fuzzyness .. check if there's an exact match\n\t\t   for some other nick in the same channel. */\n\t\treturn nick_nfind(channel, msgstart, (int) (msg-msgstart)) == NULL;\n\t} else {\n\t\treturn TRUE;\n\t}\n}\n\nint nick_match_msg_everywhere(CHANNEL_REC *channel, const char *msg, const char *nick)\n{\n\tg_return_val_if_fail(nick != NULL, FALSE);\n\tg_return_val_if_fail(msg != NULL, FALSE);\n\n\treturn stristr_full(msg, nick) != NULL;\n}\n\nvoid nicklist_init(void)\n{\n\tsignal_add_first(\"channel created\", (SIGNAL_FUNC) sig_channel_created);\n\tsignal_add(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);\n}\n\nvoid nicklist_deinit(void)\n{\n\tsignal_remove(\"channel created\", (SIGNAL_FUNC) sig_channel_created);\n\tsignal_remove(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);\n\n\tmodule_uniq_destroy(\"NICK\");\n}\n"], "fixing_code": ["/*\n misc.c : irssi\n\n    Copyright (C) 1999 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include \"misc.h\"\n#include \"commands.h\"\n\ntypedef struct {\n\tint condition;\n\tGInputFunction function;\n        void *data;\n} IRSSI_INPUT_REC;\n\nstatic int irssi_io_invoke(GIOChannel *source, GIOCondition condition,\n\t\t\t   void *data)\n{\n\tIRSSI_INPUT_REC *rec = data;\n\tint icond = 0;\n\n\tif (condition & (G_IO_ERR | G_IO_HUP | G_IO_NVAL)) {\n\t\t/* error, we have to call the function.. */\n\t\tif (rec->condition & G_IO_IN)\n\t\t\ticond |= G_INPUT_READ;\n\t\telse\n\t\t\ticond |= G_INPUT_WRITE;\n\t}\n\n\tif (condition & (G_IO_IN | G_IO_PRI))\n\t\ticond |= G_INPUT_READ;\n\tif (condition & G_IO_OUT)\n\t\ticond |= G_INPUT_WRITE;\n\n\tif (rec->condition & icond)\n\t\trec->function(rec->data, source, icond);\n\n\treturn TRUE;\n}\n\nint g_input_add_full(GIOChannel *source, int priority, int condition,\n\t\t     GInputFunction function, void *data)\n{\n        IRSSI_INPUT_REC *rec;\n\tunsigned int result;\n\tGIOCondition cond;\n\n\trec = g_new(IRSSI_INPUT_REC, 1);\n\trec->condition = condition;\n\trec->function = function;\n\trec->data = data;\n\n\tcond = (GIOCondition) (G_IO_ERR|G_IO_HUP|G_IO_NVAL);\n\tif (condition & G_INPUT_READ)\n\t\tcond |= G_IO_IN|G_IO_PRI;\n\tif (condition & G_INPUT_WRITE)\n\t\tcond |= G_IO_OUT;\n\n\tresult = g_io_add_watch_full(source, priority, cond,\n\t\t\t\t     irssi_io_invoke, rec, g_free);\n\n\treturn result;\n}\n\nint g_input_add(GIOChannel *source, int condition,\n\t\tGInputFunction function, void *data)\n{\n\treturn g_input_add_full(source, G_PRIORITY_DEFAULT, condition,\n\t\t\t\tfunction, data);\n}\n\n/* easy way to bypass glib polling of io channel internal buffer */\nint g_input_add_poll(int fd, int priority, int condition,\n\t\t     GInputFunction function, void *data)\n{\n\tGIOChannel *source = g_io_channel_unix_new(fd);\n\tint ret = g_input_add_full(source, priority, condition, function, data);\n\tg_io_channel_unref(source);\n\treturn ret;\n}\n\nint g_timeval_cmp(const GTimeVal *tv1, const GTimeVal *tv2)\n{\n\tif (tv1->tv_sec < tv2->tv_sec)\n\t\treturn -1;\n\tif (tv1->tv_sec > tv2->tv_sec)\n\t\treturn 1;\n\n\treturn tv1->tv_usec < tv2->tv_usec ? -1 :\n\t\ttv1->tv_usec > tv2->tv_usec ? 1 : 0;\n}\n\nlong get_timeval_diff(const GTimeVal *tv1, const GTimeVal *tv2)\n{\n\tlong secs, usecs;\n\n\tsecs = tv1->tv_sec - tv2->tv_sec;\n\tusecs = tv1->tv_usec - tv2->tv_usec;\n\tif (usecs < 0) {\n\t\tusecs += 1000000;\n\t\tsecs--;\n\t}\n\tusecs = usecs/1000 + secs * 1000;\n\n\treturn usecs;\n}\n\nint find_substr(const char *list, const char *item)\n{\n\tconst char *ptr;\n\n\tg_return_val_if_fail(list != NULL, FALSE);\n\tg_return_val_if_fail(item != NULL, FALSE);\n\n\tif (*item == '\\0')\n\t\treturn FALSE;\n\n\tfor (;;) {\n\t\twhile (i_isspace(*list)) list++;\n\t\tif (*list == '\\0') break;\n\n\t\tptr = strchr(list, ' ');\n\t\tif (ptr == NULL) ptr = list+strlen(list);\n\n\t\tif (g_ascii_strncasecmp(list, item, ptr-list) == 0 &&\n\t\t    item[ptr-list] == '\\0')\n\t\t\treturn TRUE;\n\n\t\tlist = ptr;\n\t}\n\n\treturn FALSE;\n}\n\nint strarray_find(char **array, const char *item)\n{\n\tchar **tmp;\n\tint index;\n\n\tg_return_val_if_fail(array != NULL, -1);\n\tg_return_val_if_fail(item != NULL, -1);\n\n\tindex = 0;\n\tfor (tmp = array; *tmp != NULL; tmp++, index++) {\n\t\tif (g_ascii_strcasecmp(*tmp, item) == 0)\n\t\t\treturn index;\n\t}\n\n\treturn -1;\n}\n\nGSList *gslist_find_string(GSList *list, const char *key)\n{\n\tfor (; list != NULL; list = list->next)\n\t\tif (g_strcmp0(list->data, key) == 0) return list;\n\n\treturn NULL;\n}\n\nGSList *gslist_find_icase_string(GSList *list, const char *key)\n{\n\tfor (; list != NULL; list = list->next)\n\t\tif (g_ascii_strcasecmp(list->data, key) == 0) return list;\n\n\treturn NULL;\n}\n\nvoid *gslist_foreach_find(GSList *list, FOREACH_FIND_FUNC func, const void *data)\n{\n\tvoid *ret;\n\n\twhile (list != NULL) {\n\t\tret = func(list->data, (void *) data);\n                if (ret != NULL) return ret;\n\n\t\tlist = list->next;\n\t}\n\n\treturn NULL;\n}\n\nvoid gslist_free_full (GSList *list, GDestroyNotify free_func)\n{\n\tGSList *tmp;\n\n\tif (list == NULL)\n\t\treturn;\n\n\tfor (tmp = list; tmp != NULL; tmp = tmp->next)\n\t\tfree_func(tmp->data);\n\n\tg_slist_free(list);\n}\n\nGSList *gslist_remove_string (GSList *list, const char *str)\n{\n\tGSList *l;\n\n\tl = g_slist_find_custom(list, str, (GCompareFunc) g_strcmp0);\n\tif (l != NULL)\n\t\treturn g_slist_remove_link(list, l);\n\n\treturn list;\n}\n\n/* `list' contains pointer to structure with a char* to string. */\nchar *gslistptr_to_string(GSList *list, int offset, const char *delimiter)\n{\n\tGString *str;\n\tchar **data, *ret;\n\n\tstr = g_string_new(NULL);\n\twhile (list != NULL) {\n\t\tdata = G_STRUCT_MEMBER_P(list->data, offset);\n\n\t\tif (str->len != 0) g_string_append(str, delimiter);\n\t\tg_string_append(str, *data);\n\t\tlist = list->next;\n\t}\n\n        ret = str->str;\n\tg_string_free(str, FALSE);\n\treturn ret;\n}\n\n/* `list' contains char* */\nchar *gslist_to_string(GSList *list, const char *delimiter)\n{\n\tGString *str;\n\tchar *ret;\n\n\tstr = g_string_new(NULL);\n\twhile (list != NULL) {\n\t\tif (str->len != 0) g_string_append(str, delimiter);\n\t\tg_string_append(str, list->data);\n\n\t\tlist = list->next;\n\t}\n\n        ret = str->str;\n\tg_string_free(str, FALSE);\n\treturn ret;\n}\n\nvoid hash_save_key(char *key, void *value, GSList **list)\n{\n        *list = g_slist_append(*list, key);\n}\n\n/* remove all the options from the optlist hash table that are valid for the\n * command cmd */\nGList *optlist_remove_known(const char *cmd, GHashTable *optlist)\n{\n\tGList *list, *tmp, *next;\n\n\tlist = g_hash_table_get_keys(optlist);\n\tif (cmd != NULL && list != NULL) {\n\t\tfor (tmp = list; tmp != NULL; tmp = next) {\n\t\t\tchar *option = tmp->data;\n\t\t\tnext = tmp->next;\n\n\t\t\tif (command_have_option(cmd, option))\n\t\t\t\tlist = g_list_remove(list, option);\n\t\t}\n\t}\n\n\treturn list;\n}\n\nGList *glist_find_string(GList *list, const char *key)\n{\n\tfor (; list != NULL; list = list->next)\n\t\tif (g_strcmp0(list->data, key) == 0) return list;\n\n\treturn NULL;\n}\n\nGList *glist_find_icase_string(GList *list, const char *key)\n{\n\tfor (; list != NULL; list = list->next)\n\t\tif (g_ascii_strcasecmp(list->data, key) == 0) return list;\n\n\treturn NULL;\n}\n\nchar *stristr(const char *data, const char *key)\n{\n\tconst char *max;\n\tint keylen, datalen, pos;\n\n\tkeylen = strlen(key);\n\tdatalen = strlen(data);\n\n\tif (keylen > datalen)\n\t\treturn NULL;\n\tif (keylen == 0)\n\t\treturn (char *) data;\n\n\tmax = data+datalen-keylen;\n\tpos = 0;\n\twhile (data <= max) {\n\t\tif (key[pos] == '\\0')\n                        return (char *) data;\n\n\t\tif (i_toupper(data[pos]) == i_toupper(key[pos]))\n\t\t\tpos++;\n\t\telse {\n\t\t\tdata++;\n                        pos = 0;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#define isbound(c) \\\n\t((unsigned char) (c) < 128 && \\\n\t(i_isspace(c) || i_ispunct(c)))\n\nstatic char *strstr_full_case(const char *data, const char *key, int icase)\n{\n\tconst char *start, *max;\n\tint keylen, datalen, pos, match;\n\n\tkeylen = strlen(key);\n\tdatalen = strlen(data);\n\n\tif (keylen > datalen)\n\t\treturn NULL;\n\tif (keylen == 0)\n\t\treturn (char *) data;\n\n\tmax = data+datalen-keylen;\n\tstart = data; pos = 0;\n\twhile (data <= max) {\n\t\tif (key[pos] == '\\0') {\n\t\t\tif (data[pos] != '\\0' && !isbound(data[pos])) {\n\t\t\t\tdata++;\n\t\t\t\tpos = 0;\n                                continue;\n\t\t\t}\n\t\t\treturn (char *) data;\n\t\t}\n\n\t\tmatch = icase ? (i_toupper(data[pos]) == i_toupper(key[pos])) :\n\t\t\t\t data[pos] == key[pos];\n\n\t\tif (match && (pos != 0 || data == start || isbound(data[-1])))\n\t\t\tpos++;\n\t\telse {\n\t\t\tdata++;\n                        pos = 0;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nchar *strstr_full(const char *data, const char *key)\n{\n        return strstr_full_case(data, key, FALSE);\n}\n\nchar *stristr_full(const char *data, const char *key)\n{\n        return strstr_full_case(data, key, TRUE);\n}\n\n/* convert ~/ to $HOME */\nchar *convert_home(const char *path)\n{\n\tconst char *home;\n\n\tif (*path == '~' && (*(path+1) == '/' || *(path+1) == '\\0')) {\n\t\thome = g_get_home_dir();\n\t\tif (home == NULL)\n\t\t\thome = \".\";\n\n\t\treturn g_strconcat(home, path+1, NULL);\n\t} else {\n\t\treturn g_strdup(path);\n\t}\n}\n\nint g_istr_equal(gconstpointer v, gconstpointer v2)\n{\n\treturn g_ascii_strcasecmp((const char *) v, (const char *) v2) == 0;\n}\n\nint g_istr_cmp(gconstpointer v, gconstpointer v2)\n{\n\treturn g_ascii_strcasecmp((const char *) v, (const char *) v2);\n}\n\nguint g_istr_hash(gconstpointer v)\n{\n\tconst signed char *p;\n\tguint32 h = 5381;\n\n\tfor (p = v; *p != '\\0'; p++)\n\t\th = (h << 5) + h + g_ascii_toupper(*p);\n\n\treturn h;\n}\n\n/* Find `mask' from `data', you can use * and ? wildcards. */\nint match_wildcards(const char *cmask, const char *data)\n{\n\tchar *mask, *newmask, *p1, *p2;\n\tint ret;\n\n\tnewmask = mask = g_strdup(cmask);\n\tfor (; *mask != '\\0' && *data != '\\0'; mask++) {\n\t\tif (*mask != '*') {\n\t\t\tif (*mask != '?' && i_toupper(*mask) != i_toupper(*data))\n\t\t\t\tbreak;\n\n\t\t\tdata++;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (*mask == '?' || *mask == '*') mask++;\n\t\tif (*mask == '\\0') {\n\t\t\tdata += strlen(data);\n\t\t\tbreak;\n\t\t}\n\n\t\tp1 = strchr(mask, '*');\n\t\tp2 = strchr(mask, '?');\n\t\tif (p1 == NULL || (p2 < p1 && p2 != NULL)) p1 = p2;\n\n\t\tif (p1 != NULL) *p1 = '\\0';\n\n\t\tdata = stristr(data, mask);\n\t\tif (data == NULL) break;\n\n\t\tdata += strlen(mask);\n\t\tmask += strlen(mask)-1;\n\n\t\tif (p1 != NULL) *p1 = p1 == p2 ? '?' : '*';\n\t}\n\n\twhile (*mask == '*') mask++;\n\n\tret = data != NULL && *data == '\\0' && *mask == '\\0';\n\tg_free(newmask);\n\n\treturn ret;\n}\n\n/* Return TRUE if all characters in `str' are numbers.\n   Stop when `end_char' is found from string. */\nint is_numeric(const char *str, char end_char)\n{\n\tg_return_val_if_fail(str != NULL, FALSE);\n\n\tif (*str == '\\0' || *str == end_char)\n\t\treturn FALSE;\n\n\twhile (*str != '\\0' && *str != end_char) {\n\t\tif (!i_isdigit(*str)) return FALSE;\n\t\tstr++;\n\t}\n\n\treturn TRUE;\n}\n\n/* replace all `from' chars in string to `to' chars. returns `str' */\nchar *replace_chars(char *str, char from, char to)\n{\n\tchar *p;\n\n\tfor (p = str; *p != '\\0'; p++) {\n\t\tif (*p == from) *p = to;\n\t}\n\treturn str;\n}\n\nint octal2dec(int octal)\n{\n\tint dec, n;\n\n\tdec = 0; n = 1;\n\twhile (octal != 0) {\n\t\tdec += n*(octal%10);\n\t\toctal /= 10; n *= 8;\n\t}\n\n\treturn dec;\n}\n\nint dec2octal(int decimal)\n{\n\tint octal, pos;\n\n\toctal = 0; pos = 0;\n\twhile (decimal > 0) {\n\t\toctal += (decimal & 7)*(pos == 0 ? 1 : pos);\n\t\tdecimal /= 8;\n\t\tpos += 10;\n\t}\n\n\treturn octal;\n}\n\n/* string -> uoff_t */\nuoff_t str_to_uofft(const char *str)\n{\n#ifdef UOFF_T_LONG_LONG\n\treturn (uoff_t)strtoull(str, NULL, 10);\n#else\n\treturn (uoff_t)strtoul(str, NULL, 10);\n#endif\n}\n\n/* convert all low-ascii (<32) to ^<A..> combinations */\nchar *show_lowascii(const char *str)\n{\n\tchar *ret, *p;\n\n\tret = p = g_malloc(strlen(str)*2+1);\n\twhile (*str != '\\0') {\n\t\tif ((unsigned char) *str >= 32)\n\t\t\t*p++ = *str;\n\t\telse {\n\t\t\t*p++ = '^';\n\t\t\t*p++ = *str + 'A'-1;\n\t\t}\n\t\tstr++;\n\t}\n\t*p = '\\0';\n\n\treturn ret;\n}\n\n/* Get time in human readable form with localtime() + asctime() */\nchar *my_asctime(time_t t)\n{\n\tstruct tm *tm;\n\tchar *str;\n        int len;\n\n\ttm = localtime(&t);\n\tif (tm == NULL)\n\t    return g_strdup(\"???\");\n\n\tstr = g_strdup(asctime(tm));\n\n\tlen = strlen(str);\n\tif (len > 0) str[len-1] = '\\0';\n        return str;\n}\n\n/* Returns number of columns needed to print items.\n   save_column_widths is filled with length of each column. */\nint get_max_column_count(GSList *items, COLUMN_LEN_FUNC len_func,\n\t\t\t int max_width, int max_columns,\n\t\t\t int item_extra, int item_min_size,\n\t\t\t int **save_column_widths, int *rows)\n{\n        GSList *tmp;\n\tint **columns, *columns_width, *columns_rows;\n\tint item_pos, items_count;\n\tint ret, len, max_len, n, col;\n\n\titems_count = g_slist_length(items);\n\tif (items_count == 0) {\n\t\t*save_column_widths = NULL;\n                *rows = 0;\n\t\treturn 0;\n\t}\n\n\tlen = max_width/(item_extra+item_min_size);\n        if (len <= 0) len = 1;\n\tif (max_columns <= 0 || len < max_columns)\n                max_columns = len;\n\n\tcolumns = g_new0(int *, max_columns);\n\tcolumns_width = g_new0(int, max_columns);\n\tcolumns_rows = g_new0(int, max_columns);\n\n\tfor (n = 1; n < max_columns; n++) {\n\t\tcolumns[n] = g_new0(int, n+1);\n\t\tcolumns_rows[n] = items_count <= n+1 ? 1 :\n                        (items_count+n)/(n+1);\n\t}\n\n\t/* for each possible column count, save the column widths and\n\t   find the biggest column count that fits to screen. */\n        item_pos = 0; max_len = 0;\n\tfor (tmp = items; tmp != NULL; tmp = tmp->next) {\n\t\tlen = item_extra+len_func(tmp->data);\n\t\tif (max_len < len)\n\t\t\tmax_len = len;\n\n\t\tfor (n = 1; n < max_columns; n++) {\n\t\t\tif (columns_width[n] > max_width)\n\t\t\t\tcontinue; /* too wide */\n\n\t\t\tcol = item_pos/columns_rows[n];\n\t\t\tif (columns[n][col] < len) {\n\t\t\t\tcolumns_width[n] += len-columns[n][col];\n                                columns[n][col] = len;\n\t\t\t}\n\t\t}\n\n                item_pos++;\n\t}\n\n\tfor (n = max_columns-1; n >= 1; n--) {\n\t\tif (columns_width[n] <= max_width &&\n\t\t    columns[n][n] > 0)\n                        break;\n\t}\n        ret = n+1;\n\n\t*save_column_widths = g_new(int, ret);\n\tif (ret == 1) {\n                **save_column_widths = max_len;\n                *rows = 1;\n\t} else {\n\t\tmemcpy(*save_column_widths, columns[ret-1], sizeof(int)*ret);\n\t\t*rows = columns_rows[ret-1];\n\t}\n\n\tfor (n = 1; n < max_columns; n++)\n                g_free(columns[n]);\n\tg_free(columns_width);\n\tg_free(columns_rows);\n\tg_free(columns);\n\n        return ret;\n}\n\n/* Return a column sorted copy of a list. */\nGSList *columns_sort_list(GSList *list, int rows)\n{\n        GSList *tmp, *sorted;\n\tint row, skip;\n\n\tif (list == NULL || rows == 0)\n                return list;\n\n\tsorted = NULL;\n\n\tfor (row = 0; row < rows; row++) {\n                tmp = g_slist_nth(list, row);\n                skip = 1;\n\t\tfor (; tmp != NULL; tmp = tmp->next) {\n\t\t\tif (--skip == 0) {\n                                skip = rows;\n\t\t\t\tsorted = g_slist_append(sorted, tmp->data);\n\t\t\t}\n\t\t}\n\t}\n\n\tg_return_val_if_fail(g_slist_length(sorted) ==\n\t\t\t     g_slist_length(list), sorted);\n        return sorted;\n}\n\n/* Expand escape string, the first character in data should be the\n   one after '\\'. Returns the expanded character or -1 if error. */\nint expand_escape(const char **data)\n{\n        char digit[4];\n\n\tswitch (**data) {\n\tcase 't':\n\t\treturn '\\t';\n\tcase 'r':\n\t\treturn '\\r';\n\tcase 'n':\n\t\treturn '\\n';\n\tcase 'e':\n\t\treturn 27; /* ESC */\n\tcase '\\\\':\n\t\treturn '\\\\';\n\n\tcase 'x':\n                /* hex digit */\n\t\tif (!i_isxdigit((*data)[1]) || !i_isxdigit((*data)[2]))\n\t\t\treturn -1;\n\n\t\tdigit[0] = (*data)[1];\n\t\tdigit[1] = (*data)[2];\n                digit[2] = '\\0';\n\t\t*data += 2;\n\t\treturn strtol(digit, NULL, 16);\n\tcase 'c':\n                /* control character (\\cA = ^A) */\n                (*data)++;\n\t\treturn i_toupper(**data) - 64;\n\tcase '0': case '1': case '2': case '3':\n\tcase '4': case '5': case '6': case '7':\n                /* octal */\n\t\tdigit[1] = digit[2] = digit[3] = '\\0';\n                digit[0] = (*data)[0];\n\t\tif ((*data)[1] >= '0' && (*data)[1] <= '7') {\n\t\t\t++*data;\n\t\t\tdigit[1] = **data;\n\t\t\tif ((*data)[1] >= '0' && (*data)[1] <= '7') {\n\t\t\t\t++*data;\n\t\t\t\tdigit[2] = **data;\n\t\t\t}\n\t\t}\n\t\treturn strtol(digit, NULL, 8);\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n/* Escape all '\"', \"'\" and '\\' chars with '\\' */\nchar *escape_string(const char *str)\n{\n\tchar *ret, *p;\n\n\tp = ret = g_malloc(strlen(str)*2+1);\n\twhile (*str != '\\0') {\n\t\tif (*str == '\"' || *str == '\\'' || *str == '\\\\')\n\t\t\t*p++ = '\\\\';\n\t\t*p++ = *str++;\n\t}\n\t*p = '\\0';\n\n\treturn ret;\n}\n\nint nearest_power(int num)\n{\n\tint n = 1;\n\n\twhile (n < num) n <<= 1;\n\treturn n;\n}\n\n/* Parses unsigned integers from strings with decent error checking.\n * Returns true on success, false otherwise (overflow, no valid number, etc)\n * There's a 31 bit limit so the output can be assigned to signed positive ints */\nint parse_uint(const char *nptr, char **endptr, int base, guint *number)\n{\n\tchar *endptr_;\n\tgulong parsed;\n\n\t/* strtoul accepts whitespace and plus/minus signs, for some reason */\n\tif (!i_isdigit(*nptr)) {\n\t\treturn FALSE;\n\t}\n\n\terrno = 0;\n\tparsed = strtoul(nptr, &endptr_, base);\n\n\tif (errno || endptr_ == nptr || parsed >= (1U << 31)) {\n\t\treturn FALSE;\n\t}\n\n\tif (endptr) {\n\t\t*endptr = endptr_;\n\t}\n\n\tif (number) {\n\t\t*number = (guint) parsed;\n\t}\n\n\treturn TRUE;\n}\n\nstatic int parse_number_sign(const char *input, char **endptr, int *sign)\n{\n\tint sign_ = 1;\n\n\twhile (i_isspace(*input))\n\t\tinput++;\n\n\tif (*input == '-') {\n\t\tsign_ = -sign_;\n\t\tinput++;\n\t}\n\n\t*sign = sign_;\n\t*endptr = (char *) input;\n\treturn TRUE;\n}\n\nstatic int parse_time_interval_uint(const char *time, guint *msecs)\n{\n\tconst char *desc;\n\tguint number;\n\tint len, ret, digits;\n\n\t*msecs = 0;\n\n\t/* max. return value is around 24 days */\n\tnumber = 0; ret = TRUE; digits = FALSE;\n\twhile (i_isspace(*time))\n\t\ttime++;\n\tfor (;;) {\n\t\tif (i_isdigit(*time)) {\n\t\t\tchar *endptr;\n\t\t\tif (!parse_uint(time, &endptr, 10, &number)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\ttime = endptr;\n\t\t\tdigits = TRUE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!digits)\n\t\t\treturn FALSE;\n\n\t\t/* skip punctuation */\n\t\twhile (*time != '\\0' && i_ispunct(*time) && *time != '-')\n\t\t\ttime++;\n\n\t\t/* get description */\n\t\tfor (len = 0, desc = time; i_isalpha(*time); time++)\n\t\t\tlen++;\n\n\t\twhile (i_isspace(*time))\n\t\t\ttime++;\n\n\t\tif (len == 0) {\n\t\t\tif (*time != '\\0')\n\t\t\t\treturn FALSE;\n\t\t\t*msecs += number * 1000; /* assume seconds */\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tif (g_ascii_strncasecmp(desc, \"days\", len) == 0) {\n\t\t\tif (number > 24) {\n\t\t\t\t/* would overflow */\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t*msecs += number * 1000*3600*24;\n\t\t} else if (g_ascii_strncasecmp(desc, \"hours\", len) == 0)\n\t\t\t*msecs += number * 1000*3600;\n\t\telse if (g_ascii_strncasecmp(desc, \"minutes\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"mins\", len) == 0)\n\t\t\t*msecs += number * 1000*60;\n\t\telse if (g_ascii_strncasecmp(desc, \"seconds\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"secs\", len) == 0)\n\t\t\t*msecs += number * 1000;\n\t\telse if (g_ascii_strncasecmp(desc, \"milliseconds\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"millisecs\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"mseconds\", len) == 0 ||\n\t\t\t g_ascii_strncasecmp(desc, \"msecs\", len) == 0)\n\t\t\t*msecs += number;\n\t\telse {\n\t\t\tret = FALSE;\n\t\t}\n\n\t\t/* skip punctuation */\n\t\twhile (*time != '\\0' && i_ispunct(*time) && *time != '-')\n\t\t\ttime++;\n\n\t\tif (*time == '\\0')\n\t\t\tbreak;\n\n\t\tnumber = 0;\n\t\tdigits = FALSE;\n\t}\n\n\treturn ret;\n}\n\nstatic int parse_size_uint(const char *size, guint *bytes)\n{\n\tconst char *desc;\n\tguint number, multiplier, limit;\n\tint len;\n\n\t*bytes = 0;\n\n\t/* max. return value is about 1.6 years */\n\tnumber = 0;\n\twhile (*size != '\\0') {\n\t\tif (i_isdigit(*size)) {\n\t\t\tchar *endptr;\n\t\t\tif (!parse_uint(size, &endptr, 10, &number)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tsize = endptr;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* skip punctuation */\n\t\twhile (*size != '\\0' && i_ispunct(*size))\n\t\t\tsize++;\n\n\t\t/* get description */\n\t\tfor (len = 0, desc = size; i_isalpha(*size); size++)\n\t\t\tlen++;\n\n\t\tif (len == 0) {\n\t\t\tif (number == 0) {\n\t\t\t\t/* \"0\" - allow it */\n\t\t\t\treturn TRUE;\n\t\t\t}\n\n\t\t\t*bytes += number*1024; /* assume kilobytes */\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tmultiplier = 0;\n\t\tlimit = 0;\n\n\t\tif (g_ascii_strncasecmp(desc, \"gbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 30;\n\t\t\tlimit = 2U << 0;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"mbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 20;\n\t\t\tlimit = 2U << 10;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"kbytes\", len) == 0) {\n\t\t\tmultiplier = 1U << 10;\n\t\t\tlimit = 2U << 20;\n\t\t}\n\t\tif (g_ascii_strncasecmp(desc, \"bytes\", len) == 0) {\n\t\t\tmultiplier = 1;\n\t\t\tlimit = 2U << 30;\n\t\t}\n\n\t\tif (limit && number > limit) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t*bytes += number * multiplier;\n\n\t\t/* skip punctuation */\n\t\twhile (*size != '\\0' && i_ispunct(*size))\n\t\t\tsize++;\n\t}\n\n\treturn TRUE;\n}\n\nint parse_size(const char *size, int *bytes)\n{\n\tguint bytes_;\n\tint ret;\n\n\tret = parse_size_uint(size, &bytes_);\n\n\tif (bytes_ > (1U << 31)) {\n\t\treturn FALSE;\n\t}\n\n\t*bytes = bytes_;\n\treturn ret;\n}\n\nint parse_time_interval(const char *time, int *msecs)\n{\n\tguint msecs_;\n\tchar *number;\n\tint ret, sign;\n\n\tparse_number_sign(time, &number, &sign);\n\n\tret = parse_time_interval_uint(number, &msecs_);\n\n\tif (msecs_ > (1U << 31)) {\n\t\treturn FALSE;\n\t}\n\n\t*msecs = msecs_ * sign;\n\treturn ret;\n}\n\n\nchar *ascii_strup(char *str)\n{\n\tchar *s;\n\n\tfor (s = str; *s; s++)\n\t\t*s = g_ascii_toupper (*s);\n\treturn str;\n}\n\nchar *ascii_strdown(char *str)\n{\n\tchar *s;\n\n\tfor (s = str; *s; s++)\n\t\t*s = g_ascii_tolower (*s);\n\treturn str;\n}\n\nchar **strsplit_len(const char *str, int len, gboolean onspace)\n{\n\tchar **ret = g_new(char *, 1);\n\tint n;\n\tint offset;\n\n\tfor (n = 0; *str != '\\0'; n++, str += offset) {\n\t\toffset = MIN(len, strlen(str));\n\t\tif (onspace && strlen(str) > len) {\n\t\t\t/*\n\t\t\t * Try to find a space to split on and leave\n\t\t\t * the space on the previous line.\n\t\t\t */\n\t\t\tint i;\n\t\t\tfor (i = len - 1; i > 0; i--) {\n\t\t\t\tif (str[i] == ' ') {\n\t\t\t\t\toffset = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret[n] = g_strndup(str, offset);\n\t\tret = g_renew(char *, ret, n + 2);\n\t}\n\tret[n] = NULL;\n\n\treturn ret;\n}\n\nchar *binary_to_hex(unsigned char *buffer, size_t size)\n{\n\tstatic const char hex[] = \"0123456789ABCDEF\";\n\tchar *result = NULL;\n\tint i;\n\n\tif (buffer == NULL || size == 0)\n\t\treturn NULL;\n\n\tresult = g_malloc(3 * size);\n\n\tfor (i = 0; i < size; i++) {\n\t\tresult[i * 3 + 0] = hex[(buffer[i] >> 4) & 0xf];\n\t\tresult[i * 3 + 1] = hex[(buffer[i] >> 0) & 0xf];\n\t\tresult[i * 3 + 2] = i == size - 1 ? '\\0' : ':';\n\t}\n\n\treturn result;\n}\n", "/*\n nicklist.c : irssi\n\n    Copyright (C) 1999-2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include \"signals.h\"\n#include \"misc.h\"\n\n#include \"servers.h\"\n#include \"channels.h\"\n#include \"nicklist.h\"\n#include \"masks.h\"\n\n#define isalnumhigh(a) \\\n        (i_isalnum(a) || (unsigned char) (a) >= 128)\n\nstatic void nick_hash_add(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tNICK_REC *list;\n\n\tnick->next = NULL;\n\n\tlist = g_hash_table_lookup(channel->nicks, nick->nick);\n        if (list == NULL)\n\t\tg_hash_table_insert(channel->nicks, nick->nick, nick);\n\telse {\n                /* multiple nicks with same name */\n\t\twhile (list->next != NULL)\n\t\t\tlist = list->next;\n\t\tlist->next = nick;\n\t}\n\n\tif (nick == channel->ownnick) {\n                /* move our own nick to beginning of the nick list.. */\n\t\tnicklist_set_own(channel, nick);\n\t}\n}\n\nstatic void nick_hash_remove(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tNICK_REC *list, *newlist;\n\n\tlist = g_hash_table_lookup(channel->nicks, nick->nick);\n\tif (list == NULL)\n\t\treturn;\n\n\tif (list == nick) {\n\t\tnewlist = nick->next;\n\t} else {\n\t\tnewlist = list;\n\t\twhile (list->next != nick)\n\t\t\tlist = list->next;\n\t\tlist->next = nick->next;\n\t}\n\n\tg_hash_table_remove(channel->nicks, nick->nick);\n\tif (newlist != NULL) {\n\t\tg_hash_table_insert(channel->nicks, newlist->nick,\n\t\t\t\t    newlist);\n\t}\n}\n\n/* Add new nick to list */\nvoid nicklist_insert(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\t/*MODULE_DATA_INIT(nick);*/\n\n\tnick->type = module_get_uniq_id(\"NICK\", 0);\n        nick->chat_type = channel->chat_type;\n\n        nick_hash_add(channel, nick);\n\tsignal_emit(\"nicklist new\", 2, channel, nick);\n}\n\n/* Set host address for nick */\nvoid nicklist_set_host(CHANNEL_REC *channel, NICK_REC *nick, const char *host)\n{\n        g_return_if_fail(channel != NULL);\n        g_return_if_fail(nick != NULL);\n\tg_return_if_fail(host != NULL);\n\n        g_free_not_null(nick->host);\n\tnick->host = g_strdup(host);\n\n        signal_emit(\"nicklist host changed\", 2, channel, nick);\n}\n\nstatic void nicklist_destroy(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tsignal_emit(\"nicklist remove\", 2, channel, nick);\n\n\tif (channel->ownnick == nick)\n                channel->ownnick = NULL;\n\n        /*MODULE_DATA_DEINIT(nick);*/\n\tg_free(nick->nick);\n\tg_free_not_null(nick->realname);\n\tg_free_not_null(nick->host);\n\tg_free(nick);\n}\n\n/* Remove nick from list */\nvoid nicklist_remove(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tg_return_if_fail(IS_CHANNEL(channel));\n\tg_return_if_fail(nick != NULL);\n\n        nick_hash_remove(channel, nick);\n\tnicklist_destroy(channel, nick);\n}\n\nstatic void nicklist_rename_list(SERVER_REC *server, void *new_nick_id,\n\t\t\t\t const char *old_nick, const char *new_nick,\n\t\t\t\t GSList *nicks)\n{\n\tCHANNEL_REC *channel;\n\tNICK_REC *nickrec;\n\tGSList *tmp;\n\n\tfor (tmp = nicks; tmp != NULL; tmp = tmp->next->next) {\n\t\tchannel = tmp->data;\n\t\tnickrec = tmp->next->data;\n\n\t\t/* remove old nick from hash table */\n                nick_hash_remove(channel, nickrec);\n\n\t\tif (new_nick_id != NULL)\n\t\t\tnickrec->unique_id = new_nick_id;\n\n\t\tg_free(nickrec->nick);\n\t\tnickrec->nick = g_strdup(new_nick);\n\n\t\t/* add new nick to hash table */\n                nick_hash_add(channel, nickrec);\n\n\t\tsignal_emit(\"nicklist changed\", 3, channel, nickrec, old_nick);\n\t}\n\tg_slist_free(nicks);\n}\n\nvoid nicklist_rename(SERVER_REC *server, const char *old_nick,\n\t\t     const char *new_nick)\n{\n\tnicklist_rename_list(server, NULL, old_nick, new_nick,\n\t\t\t     nicklist_get_same(server, old_nick));\n}\n\nvoid nicklist_rename_unique(SERVER_REC *server,\n\t\t\t    void *old_nick_id, const char *old_nick,\n\t\t\t    void *new_nick_id, const char *new_nick)\n{\n\tnicklist_rename_list(server, new_nick_id, old_nick, new_nick,\n\t\t\t     nicklist_get_same_unique(server, old_nick_id));\n}\n\nstatic NICK_REC *nicklist_find_wildcards(CHANNEL_REC *channel,\n\t\t\t\t\t const char *mask)\n{\n\tNICK_REC *nick;\n\tGHashTableIter iter;\n\n\tg_hash_table_iter_init(&iter, channel->nicks);\n\twhile (g_hash_table_iter_next(&iter, NULL, (void*)&nick)) {\n\t\tfor (; nick != NULL; nick = nick->next) {\n\t\t\tif (mask_match_address(channel->server, mask,\n\t\t\t\t\t       nick->nick, nick->host))\n\t\t\t\treturn nick;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nGSList *nicklist_find_multiple(CHANNEL_REC *channel, const char *mask)\n{\n\tGSList *nicks;\n\tNICK_REC *nick;\n\tGHashTableIter iter;\n\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\tg_return_val_if_fail(mask != NULL, NULL);\n\n\tnicks = NULL;\n\n\tg_hash_table_iter_init(&iter, channel->nicks);\n\twhile (g_hash_table_iter_next(&iter, NULL, (void*)&nick)) {\n\t\tfor (; nick != NULL; nick = nick->next) {\n\t\t\tif (mask_match_address(channel->server, mask,\n\t\t\t\t\t       nick->nick, nick->host))\n\t\t\t\tnicks = g_slist_prepend(nicks, nick);\n\t\t}\n\t}\n\n\treturn nicks;\n}\n\n/* Find nick */\nNICK_REC *nicklist_find(CHANNEL_REC *channel, const char *nick)\n{\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\tg_return_val_if_fail(nick != NULL, NULL);\n\n\treturn g_hash_table_lookup(channel->nicks, nick);\n}\n\nNICK_REC *nicklist_find_unique(CHANNEL_REC *channel, const char *nick,\n\t\t\t       void *id)\n{\n\tNICK_REC *rec;\n\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\tg_return_val_if_fail(nick != NULL, NULL);\n\n\trec = g_hash_table_lookup(channel->nicks, nick);\n\twhile (rec != NULL && rec->unique_id != id)\n                rec = rec->next;\n\n        return rec;\n}\n\n/* Find nick mask, wildcards allowed */\nNICK_REC *nicklist_find_mask(CHANNEL_REC *channel, const char *mask)\n{\n\tNICK_REC *nickrec;\n\tchar *nick, *host;\n\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\tg_return_val_if_fail(mask != NULL, NULL);\n\n\tnick = g_strdup(mask);\n\thost = strchr(nick, '!');\n\tif (host != NULL) *host++ = '\\0';\n\n\tif (strchr(nick, '*') || strchr(nick, '?')) {\n\t\tg_free(nick);\n\t\treturn nicklist_find_wildcards(channel, mask);\n\t}\n\n\tnickrec = g_hash_table_lookup(channel->nicks, nick);\n\n\tif (host != NULL) {\n\t\twhile (nickrec != NULL) {\n\t\t\tif (nickrec->host != NULL &&\n\t\t\t    match_wildcards(host, nickrec->host))\n\t\t\t\tbreak; /* match */\n\t\t\tnickrec = nickrec->next;\n\t\t}\n\t}\n\tg_free(nick);\n\treturn nickrec;\n}\n\nstatic void get_nicks_hash(gpointer key, NICK_REC *rec, GSList **list)\n{\n\twhile (rec != NULL) {\n\t\t*list = g_slist_prepend(*list, rec);\n\t\trec = rec->next;\n\t}\n}\n\n/* Get list of nicks */\nGSList *nicklist_getnicks(CHANNEL_REC *channel)\n{\n\tGSList *list;\n\n\tg_return_val_if_fail(IS_CHANNEL(channel), NULL);\n\n\tlist = NULL;\n\tg_hash_table_foreach(channel->nicks, (GHFunc) get_nicks_hash, &list);\n\treturn list;\n}\n\nGSList *nicklist_get_same(SERVER_REC *server, const char *nick)\n{\n\tGSList *tmp;\n\tGSList *list = NULL;\n\n\tg_return_val_if_fail(IS_SERVER(server), NULL);\n\n\tfor (tmp = server->channels; tmp != NULL; tmp = tmp->next) {\n\t\tNICK_REC *nick_rec;\n\t\tCHANNEL_REC *channel = tmp->data;\n\n\t\tfor (nick_rec = g_hash_table_lookup(channel->nicks, nick);\n\t\t     nick_rec != NULL;\n\t\t     nick_rec = nick_rec->next) {\n\t\t\tlist = g_slist_append(list, channel);\n\t\t\tlist = g_slist_append(list, nick_rec);\n\t\t}\n\t}\n\n\treturn list;\n}\n\ntypedef struct {\n\tCHANNEL_REC *channel;\n        void *id;\n\tGSList *list;\n} NICKLIST_GET_SAME_UNIQUE_REC;\n\nstatic void get_nicks_same_hash_unique(gpointer key, NICK_REC *nick,\n\t\t\t\t       NICKLIST_GET_SAME_UNIQUE_REC *rec)\n{\n\twhile (nick != NULL) {\n\t\tif (nick->unique_id == rec->id) {\n\t\t\trec->list = g_slist_append(rec->list, rec->channel);\n\t\t\trec->list = g_slist_append(rec->list, nick);\n                        break;\n\t\t}\n\n                nick = nick->next;\n\t}\n}\n\nGSList *nicklist_get_same_unique(SERVER_REC *server, void *id)\n{\n\tNICKLIST_GET_SAME_UNIQUE_REC rec;\n\tGSList *tmp;\n\n\tg_return_val_if_fail(IS_SERVER(server), NULL);\n\tg_return_val_if_fail(id != NULL, NULL);\n\n        rec.id = id;\n\trec.list = NULL;\n\tfor (tmp = server->channels; tmp != NULL; tmp = tmp->next) {\n\t\trec.channel = tmp->data;\n\t\tg_hash_table_foreach(rec.channel->nicks,\n\t\t\t\t     (GHFunc) get_nicks_same_hash_unique,\n\t\t\t\t     &rec);\n\t}\n\treturn rec.list;\n}\n\n/* nick record comparison for sort functions */\nint nicklist_compare(NICK_REC *p1, NICK_REC *p2, const char *nick_prefix)\n{\n\tint i;\n\n\tif (p1 == NULL) return -1;\n\tif (p2 == NULL) return 1;\n\n\tif (p1->prefixes[0] == p2->prefixes[0])\n\t\treturn g_ascii_strcasecmp(p1->nick, p2->nick);\n\n\tif (!p1->prefixes[0])\n\t\treturn 1;\n\tif (!p2->prefixes[0])\n\t\treturn -1;\n\n\t/* They aren't equal.  We've taken care of that already.\n\t * The first one we encounter in this list is the greater.\n\t */\n\n\tfor (i = 0; nick_prefix[i] != '\\0'; i++) {\n\t\tif (p1->prefixes[0] == nick_prefix[i])\n\t\t\treturn -1;\n\t\tif (p2->prefixes[0] == nick_prefix[i])\n\t\t\treturn 1;\n\t}\n\n\t/* we should never have gotten here... */\n\treturn g_ascii_strcasecmp(p1->nick, p2->nick);\n}\n\nstatic void nicklist_update_flags_list(SERVER_REC *server, int gone,\n\t\t\t\t       int serverop, GSList *nicks)\n{\n\tGSList *tmp;\n\tCHANNEL_REC *channel;\n\tNICK_REC *rec;\n\n\tg_return_if_fail(IS_SERVER(server));\n\n\tfor (tmp = nicks; tmp != NULL; tmp = tmp->next->next) {\n\t\tchannel = tmp->data;\n\t\trec = tmp->next->data;\n\n\t\trec->last_check = time(NULL);\n\n\t\tif (gone != -1 && (int)rec->gone != gone) {\n\t\t\trec->gone = gone;\n\t\t\tsignal_emit(\"nicklist gone changed\", 2, channel, rec);\n\t\t}\n\n\t\tif (serverop != -1 && (int)rec->serverop != serverop) {\n\t\t\trec->serverop = serverop;\n\t\t\tsignal_emit(\"nicklist serverop changed\", 2, channel, rec);\n\t\t}\n\t}\n\tg_slist_free(nicks);\n}\n\nvoid nicklist_update_flags(SERVER_REC *server, const char *nick,\n\t\t\t   int gone, int serverop)\n{\n\tnicklist_update_flags_list(server, gone, serverop,\n\t\t\t\t   nicklist_get_same(server, nick));\n}\n\nvoid nicklist_update_flags_unique(SERVER_REC *server, void *id,\n\t\t\t\t  int gone, int serverop)\n{\n\tnicklist_update_flags_list(server, gone, serverop,\n\t\t\t\t   nicklist_get_same_unique(server, id));\n}\n\n/* Specify which nick in channel is ours */\nvoid nicklist_set_own(CHANNEL_REC *channel, NICK_REC *nick)\n{\n\tNICK_REC *first, *next;\n\n        channel->ownnick = nick;\n\n\t/* move our nick in the list to first, makes some things easier\n\t   (like handling multiple identical nicks in fe-messages.c) */\n\tfirst = g_hash_table_lookup(channel->nicks, nick->nick);\n\tif (first->next == NULL)\n\t\treturn;\n\n\tnext = nick->next;\n\tnick->next = first;\n\n\twhile (first->next != nick)\n                first = first->next;\n\tfirst->next = next;\n\n        g_hash_table_insert(channel->nicks, nick->nick, nick);\n}\n\nstatic void sig_channel_created(CHANNEL_REC *channel)\n{\n\tg_return_if_fail(IS_CHANNEL(channel));\n\n\tchannel->nicks = g_hash_table_new((GHashFunc) g_istr_hash,\n\t\t\t\t\t  (GCompareFunc) g_istr_equal);\n}\n\nstatic void nicklist_remove_hash(gpointer key, NICK_REC *nick,\n\t\t\t\t CHANNEL_REC *channel)\n{\n\tNICK_REC *next;\n\n\twhile (nick != NULL) {\n                next = nick->next;\n\t\tnicklist_destroy(channel, nick);\n                nick = next;\n\t}\n}\n\nstatic void sig_channel_destroyed(CHANNEL_REC *channel)\n{\n\tg_return_if_fail(IS_CHANNEL(channel));\n\n\tg_hash_table_foreach(channel->nicks,\n\t\t\t     (GHFunc) nicklist_remove_hash, channel);\n\tg_hash_table_destroy(channel->nicks);\n}\n\nstatic NICK_REC *nick_nfind(CHANNEL_REC *channel, const char *nick, int len)\n{\n        NICK_REC *rec;\n\tchar *tmpnick;\n\n\ttmpnick = g_strndup(nick, len);\n\trec = g_hash_table_lookup(channel->nicks, tmpnick);\n\n\tif (rec != NULL) {\n\t\t/* if there's multiple, get the one with identical case */\n\t\twhile (rec->next != NULL) {\n\t\t\tif (g_strcmp0(rec->nick, tmpnick) == 0)\n\t\t\t\tbreak;\n                        rec = rec->next;\n\t\t}\n\t}\n\n        g_free(tmpnick);\n\treturn rec;\n}\n\n/* Check is `msg' is meant for `nick'. */\nint nick_match_msg(CHANNEL_REC *channel, const char *msg, const char *nick)\n{\n\tconst char *msgstart, *orignick;\n\tint len, fullmatch;\n\n\tg_return_val_if_fail(nick != NULL, FALSE);\n\tg_return_val_if_fail(msg != NULL, FALSE);\n\n\tif (channel != NULL && channel->server->nick_match_msg != NULL)\n\t\treturn channel->server->nick_match_msg(msg, nick);\n\n\t/* first check for identical match */\n\tlen = strlen(nick);\n\tif (g_ascii_strncasecmp(msg, nick, len) == 0 &&\n\t    !isalnumhigh((int) msg[len]))\n\t\treturn TRUE;\n\n\torignick = nick;\n\tfor (;;) {\n\t\tnick = orignick;\n\t\tmsgstart = msg;\n                fullmatch = TRUE;\n\n\t\t/* check if it matches for alphanumeric parts of nick */\n\t\twhile (*nick != '\\0' && *msg != '\\0') {\n\t\t\tif (i_toupper(*nick) == i_toupper(*msg)) {\n\t\t\t\t/* total match */\n\t\t\t\tmsg++;\n\t\t\t} else if (i_isalnum(*msg) && !i_isalnum(*nick)) {\n\t\t\t\t/* some strange char in your nick, pass it */\n                                fullmatch = FALSE;\n\t\t\t} else\n\t\t\t\tbreak;\n\n\t\t\tnick++;\n\t\t}\n\n\t\tif (msg != msgstart && !isalnumhigh(*msg)) {\n\t\t\t/* at least some of the chars in line matched the\n\t\t\t   nick, and msg continue with non-alphanum character,\n\t\t\t   this might be for us.. */\n\t\t\tif (*nick != '\\0') {\n\t\t\t\t/* remove the rest of the non-alphanum chars\n\t\t\t\t   from nick and check if it then matches. */\n                                fullmatch = FALSE;\n\t\t\t\twhile (*nick != '\\0' && !i_isalnum(*nick))\n\t\t\t\t\tnick++;\n\t\t\t}\n\n\t\t\tif (*nick == '\\0') {\n\t\t\t\t/* yes, match! */\n                                break;\n\t\t\t}\n\t\t}\n\n\t\t/* no match. check if this is a message to multiple people\n\t\t   (like nick1,nick2: text) */\n\t\twhile (*msg != '\\0' && *msg != ' ' && *msg != ',') msg++;\n\n\t\tif (*msg != ',') {\n                        nick = orignick;\n\t\t\tbreak;\n\t\t}\n\n                msg++;\n\t}\n\n\tif (*nick != '\\0')\n\t\treturn FALSE; /* didn't match */\n\n\tif (fullmatch)\n\t\treturn TRUE; /* matched without fuzzyness */\n\n\tif (channel != NULL) {\n\t\t/* matched with some fuzzyness .. check if there's an exact match\n\t\t   for some other nick in the same channel. */\n\t\treturn nick_nfind(channel, msgstart, (int) (msg-msgstart)) == NULL;\n\t} else {\n\t\treturn TRUE;\n\t}\n}\n\nint nick_match_msg_everywhere(CHANNEL_REC *channel, const char *msg, const char *nick)\n{\n\tg_return_val_if_fail(nick != NULL, FALSE);\n\tg_return_val_if_fail(msg != NULL, FALSE);\n\n\treturn stristr_full(msg, nick) != NULL;\n}\n\nvoid nicklist_init(void)\n{\n\tsignal_add_first(\"channel created\", (SIGNAL_FUNC) sig_channel_created);\n\tsignal_add(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);\n}\n\nvoid nicklist_deinit(void)\n{\n\tsignal_remove(\"channel created\", (SIGNAL_FUNC) sig_channel_created);\n\tsignal_remove(\"channel destroyed\", (SIGNAL_FUNC) sig_channel_destroyed);\n\n\tmodule_uniq_destroy(\"NICK\");\n}\n"], "filenames": ["src/core/misc.c", "src/core/nicklist.c"], "buggy_code_start_loc": [558, 57], "buggy_code_end_loc": [558, 72], "fixing_code_start_loc": [559, 57], "fixing_code_end_loc": [562, 76], "type": "CWE-416", "message": "An issue was discovered in Irssi before 1.0.4. While updating the internal nick list, Irssi could incorrectly use the GHashTable interface and free the nick while updating it. This would then result in use-after-free conditions on each access of the hash table.", "other": {"cve": {"id": "CVE-2017-10966", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-07T14:29:00.360", "lastModified": "2017-11-05T01:29:00.473", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in Irssi before 1.0.4. While updating the internal nick list, Irssi could incorrectly use the GHashTable interface and free the nick while updating it. This would then result in use-after-free conditions on each access of the hash table."}, {"lang": "es", "value": "Se detect\u00f3 un problema en Irssi anterior a versi\u00f3n 1.0.4. Al actualizar la lista de nick interna, Irssi podr\u00eda usar incorrectamente la interfaz de GHashTable y liberar el nick al actualizarlo. Esto resultar\u00eda luego en condiciones de uso de memoria previamente liberada en cada acceso de la tabla de hash."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:irssi:irssi:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.3", "matchCriteriaId": "EE14BB61-3A65-4C86-9F07-238F5849277F"}]}]}], "references": [{"url": "https://github.com/irssi/irssi/commit/5e26325317c72a04c1610ad952974e206384d291", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://irssi.org/security/irssi_sa_2017_07.txt", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-4016", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/irssi/irssi/commit/5e26325317c72a04c1610ad952974e206384d291"}}