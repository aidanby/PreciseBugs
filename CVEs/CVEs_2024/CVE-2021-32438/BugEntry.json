{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/mpegts.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\n#ifndef GPAC_DISABLE_AVILIB\n#include <gpac/internal/avilib.h>\n#endif\n\n#ifndef GPAC_DISABLE_OGG\n#include <gpac/internal/ogg.h>\n#endif\n\n#ifndef GPAC_DISABLE_VOBSUB\n#include <gpac/internal/vobsub.h>\n#endif\n\n#ifndef GPAC_DISABLE_ZLIB\n#include <zlib.h>\n#endif\n\nstatic GF_Err gf_export_message(GF_MediaExporter *dumper, GF_Err e, char *format, ...)\n{\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) return e;\n\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_AUTHOR, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {\n\t\tva_list args;\n\t\tchar szMsg[1024];\n\t\tva_start(args, format);\n\t\tvsnprintf(szMsg, 1024, format, args);\n\t\tva_end(args);\n\t\tGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_AUTHOR, (\"%s\\n\", szMsg) );\n\t}\n#endif\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n/*that's very very crude, we only support vorbis & theora in MP4 - this will need cleanup as soon as possible*/\nstatic GF_Err gf_dump_to_ogg(GF_MediaExporter *dumper, char *szName, u32 track)\n{\n#ifdef GPAC_DISABLE_OGG\n\treturn GF_NOT_SUPPORTED;\n#else\n\tFILE *out;\n\togg_stream_state os;\n\togg_packet op;\n\togg_page og;\n\tu32 count, i, di, theora_kgs, nb_i, nb_p;\n\tBool flush_first = GF_TRUE;\n\tGF_BitStream *bs;\n\tGF_ISOSample *samp;\n\tGF_ESD *esd = gf_isom_get_esd(dumper->file, track, 1);\n\n\n\tmemset(&os, 0, sizeof(ogg_stream_state));\n\tmemset(&og, 0, sizeof(ogg_page));\n\tmemset(&op, 0, sizeof(ogg_packet));\n\n\tif (gf_sys_is_test_mode()) {\n\t\togg_stream_init(&os, 1);\n\t} else {\n\t\tgf_rand_init(GF_TRUE);\n\t\togg_stream_init(&os, gf_rand());\n\t}\n\n\tout = szName ? gf_fopen(szName, \"wb\") : stdout;\n\tif (!out) return gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\n\ttheora_kgs = 0;\n\tbs = gf_bs_new(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, GF_BITSTREAM_READ);\n\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_OPUS) {\n\t\tGF_BitStream *bs_out;\n\t\tGF_OpusSpecificBox *dops = (GF_OpusSpecificBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_DOPS);\n\t\tdops->size = gf_bs_read_u32(bs);\n\t\tgf_bs_read_u32(bs);\n\t\tgf_isom_box_read((GF_Box *)dops, bs);\n\t\tbs_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(bs_out, \"OpusHead\", 8);\n\t\tgf_bs_write_u8(bs_out, 1);//version\n\t\tgf_bs_write_u8(bs_out, dops->OutputChannelCount);\n\t\tgf_bs_write_u16_le(bs_out, dops->PreSkip);\n\t\tgf_bs_write_u32_le(bs_out, dops->InputSampleRate);\n\t\tgf_bs_write_u16_le(bs_out, dops->OutputGain);\n\t\tgf_bs_write_u8(bs_out, dops->ChannelMappingFamily);\n\t\tif (dops->ChannelMappingFamily) {\n\t\t\tgf_bs_write_u8(bs_out, dops->StreamCount);\n\t\t\tgf_bs_write_u8(bs_out, dops->CoupledCount);\n\t\t\tgf_bs_write_data(bs, (char *) dops->ChannelMapping, dops->OutputChannelCount);\n\t\t}\n\t\tgf_isom_box_del((GF_Box*)dops);\n\n\t\tgf_bs_get_content(bs_out, &op.packet, &op.bytes);\n\t\tgf_bs_del(bs_out);\n\t\togg_stream_packetin(&os, &op);\n\t\tgf_free(op.packet);\n\t\top.packetno ++;\n\n\t} else {\n\t\twhile (gf_bs_available(bs)) {\n\t\t\top.bytes = gf_bs_read_u16(bs);\n\t\t\top.packet = (unsigned char*)gf_malloc(sizeof(char) * op.bytes);\n\t\t\tgf_bs_read_data(bs, (char*)op.packet, op.bytes);\n\t\t\togg_stream_packetin(&os, &op);\n\n\t\t\tif (flush_first) {\n\t\t\t\togg_stream_pageout(&os, &og);\n\t\t\t\tgf_fwrite(og.header, og.header_len, out);\n\t\t\t\tgf_fwrite(og.body, og.body_len, out);\n\t\t\t\tflush_first = 0;\n\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {\n\t\t\t\t\tu32 kff;\n\t\t\t\t\tGF_BitStream *vbs = gf_bs_new((char*)op.packet, op.bytes, GF_BITSTREAM_READ);\n\t\t\t\t\tgf_bs_skip_bytes(vbs, 40);\n\t\t\t\t\tgf_bs_read_int(vbs, 6); /* quality */\n\t\t\t\t\tkff = 1 << gf_bs_read_int(vbs, 5);\n\t\t\t\t\tgf_bs_del(vbs);\n\n\t\t\t\t\ttheora_kgs = 0;\n\t\t\t\t\tkff--;\n\t\t\t\t\twhile (kff) {\n\t\t\t\t\t\ttheora_kgs ++;\n\t\t\t\t\t\tkff >>= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_free(op.packet);\n\t\t\top.packetno ++;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tgf_odf_desc_del((GF_Descriptor *)esd);\n\n\twhile (ogg_stream_pageout(&os, &og)>0) {\n\t\tgf_fwrite(og.header, og.header_len, out);\n\t\tgf_fwrite(og.body, og.body_len, out);\n\t}\n\n\top.granulepos = -1;\n\n\tcount = gf_isom_get_sample_count(dumper->file, track);\n\n\tnb_i = nb_p = 0;\n\tsamp = gf_isom_get_sample(dumper->file, track, 1, &di);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ISOSample *next_samp = gf_isom_get_sample(dumper->file, track, i+2, &di);\n\t\tif (!samp) break;\n\t\top.bytes = samp->dataLength;\n\t\top.packet = (unsigned char*)samp->data;\n\t\top.packetno ++;\n\n\t\tif (theora_kgs) {\n\t\t\tif (samp->IsRAP) {\n\t\t\t\tif (i) nb_i+=nb_p+1;\n\t\t\t\tnb_p = 0;\n\t\t\t} else {\n\t\t\t\tnb_p++;\n\t\t\t}\n\t\t\top.granulepos = nb_i;\n\t\t\top.granulepos <<= theora_kgs;\n\t\t\top.granulepos |= nb_p;\n\t\t} else {\n\t\t\tif (next_samp) op.granulepos = next_samp->DTS;\n\t\t}\n\t\tif (!next_samp) op.e_o_s = 1;\n\n\t\togg_stream_packetin(&os, &op);\n\n\t\tgf_isom_sample_del(&samp);\n\t\tsamp = next_samp;\n\t\tnext_samp = NULL;\n\t\tgf_set_progress(\"OGG Export\", i+1, count);\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) break;\n\n\t\twhile (ogg_stream_pageout(&os, &og)>0) {\n\t\t\tgf_fwrite(og.header, og.header_len, out);\n\t\t\tgf_fwrite(og.body, og.body_len, out);\n\t\t}\n\t}\n\tif (samp) gf_isom_sample_del(&samp);\n\n\twhile (ogg_stream_flush(&os, &og)>0) {\n\t\tgf_fwrite(og.header, og.header_len, out);\n\t\tgf_fwrite(og.body, og.body_len, out);\n\t}\n\togg_stream_clear(&os);\n\tif (szName) gf_fclose(out);\n\treturn GF_OK;\n#endif\n}\n#endif\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nstatic GF_Err gf_dump_to_vobsub(GF_MediaExporter *dumper, char *szName, u32 track, char *dsi, u32 dsiSize)\n{\n#ifndef GPAC_DISABLE_VOBSUB\n\tFILE *fidx, *fsub;\n\tu32 width, height, i, count, di;\n\tGF_ISOSample *samp;\n\tchar *lang = NULL;\n\n\tif (!szName) {\n\t\tszName = gf_file_basename(gf_isom_get_filename(dumper->file));\n\t\tif (!szName) return GF_BAD_PARAM;\n\t}\n\t/* Check decoder specific information (palette) size - should be 64 */\n\tif (!dsi || (dsiSize != 64)) {\n\t\treturn gf_export_message(dumper, GF_CORRUPTED_DATA, \"Invalid decoder specific info size - must be 64 but is %d\", dsiSize);\n\t}\n\n\t/* Create an idx file */\n\tif (!gf_file_ext_start(szName)) {\n\t\tchar szPath[GF_MAX_PATH];\n\t\tstrcpy(szPath, szName);\n\t\tstrcat(szPath, \".idx\");\n\t\tfidx = gf_fopen(szPath, \"wb\");\n\t } else {\n\t\tfidx = gf_fopen(szName, \"wb\");\n\t}\n\tif (!fidx) {\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\t}\n\n\t/* Create a sub file */\n\tchar *ext = gf_file_ext_start(szName);\n\tif (ext && (!stricmp(ext, \".idx\") || !stricmp(ext, \".sub\")) ) {\n\t\text[0] = 0;\n\t}\n\tszName = strcat(szName, \".sub\");\n\tfsub = gf_fopen(szName, \"wb\");\n\tif (!fsub) {\n\t\tgf_fclose(fidx);\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\t}\n\n\t/* Retrieve original subpicture resolution */\n\tgf_isom_get_track_layout_info(dumper->file, track, &width, &height, NULL, NULL, NULL);\n\n\t/* Write header */\n\tgf_fputs(\"# VobSub index file, v7 (do not modify this line!)\\n#\\n\", fidx);\n\n\t/* Write original subpicture resolution */\n\tgf_fprintf(fidx, \"size: %ux%u\\n\", width, height);\n\n\t/* Write palette */\n\tgf_fputs(\"palette:\", fidx);\n\tfor (i = 0; i < 16; i++) {\n\t\ts32 y, u, v, r, g, b;\n\n\t\ty = (s32)(u8)dsi[(i<<2)+1] - 0x10;\n\t\tu = (s32)(u8)dsi[(i<<2)+3] - 0x80;\n\t\tv = (s32)(u8)dsi[(i<<2)+2] - 0x80;\n\t\tr = (298 * y           + 409 * v + 128) >> 8;\n\t\tg = (298 * y - 100 * u - 208 * v + 128) >> 8;\n\t\tb = (298 * y + 516 * u           + 128) >> 8;\n\n\t\tif (i) gf_fputc(',', fidx);\n\n#define CLIP(x) (((x) >= 0) ? (((x) < 256) ? (x) : 255) : 0)\n\t\tgf_fprintf(fidx, \" %02x%02x%02x\", CLIP(r), CLIP(g), CLIP(b));\n#undef CLIP\n\t}\n\tgf_fputc('\\n', fidx);\n\n\t/* Write some other useful values */\n\tgf_fputs(\"# ON: displays only forced subtitles, OFF: shows everything\\n\", fidx);\n\tgf_fputs(\"forced subs: OFF\\n\\n\", fidx);\n\n\t/* Write current language index */\n\tgf_fputs(\"# Language index in use\\nlangidx: 0\\n\", fidx);\n\n\t/* Write language header */\n\tgf_isom_get_media_language(dumper->file, track, &lang);\n\tgf_fprintf(fidx, \"id: %s, index: 0\\n\", vobsub_lang_id(lang));\n\tgf_free(lang);\n\n\t/* Retrieve sample count */\n\tcount = gf_isom_get_sample_count(dumper->file, track);\n\n\t/* Process samples (skip first - because it is special) */\n\tfor (i = 2; i <= count; i++)\n\t{\n\t\tu64 dts;\n\t\tu32 hh, mm, ss, ms;\n\n\t\tsamp = gf_isom_get_sample(dumper->file, track, i, &di);\n\t\tif (!samp) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdts = samp->DTS / 90;\n\t\tms  = (u32)(dts % 1000);\n\t\tdts = dts / 1000;\n\t\tss  = (u32)(dts % 60);\n\t\tdts = dts / 60;\n\t\tmm  = (u32)(dts % 60);\n\t\thh  = (u32)(dts / 60);\n\t\tgf_fprintf(fidx, \"timestamp: %02u:%02u:%02u:%03u, filepos: %09\"LLX_SUF\"\\n\", hh, mm, ss, ms, gf_ftell(fsub));\n\t\tif (vobsub_packetize_subpicture(fsub, samp->DTS, samp->data, samp->dataLength) != GF_OK) {\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tgf_fclose(fsub);\n\t\t\tgf_fclose(fidx);\n\t\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Unable packetize subpicture into file %s\\n\", szName);\n\t\t}\n\n\t\tgf_isom_sample_del(&samp);\n\t\tgf_set_progress(\"VobSub Export\", i + 1, count);\n\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Delete sample if any */\n\tif (samp) {\n\t\tgf_isom_sample_del(&samp);\n\t}\n\n\tgf_fclose(fsub);\n\tgf_fclose(fidx);\n\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n#endif // GPAC_DISABLE_AV_PARSERS\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic GF_Err gf_export_isom_copy_track(GF_MediaExporter *dumper, GF_ISOFile *infile, u32 inTrackNum, GF_ISOFile *outfile, Bool ResetDependencies, Bool AddToIOD)\n{\n\tGF_ESD *esd;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_ISOTrackID TrackID;\n\tu32 newTk, descIndex, i, ts, rate, pos, di, count, msubtype;\n\tu64 dur;\n\tGF_ISOSample *samp;\n\n\tif (!inTrackNum) {\n\t\tif (gf_isom_get_track_count(infile) != 1) return gf_export_message(dumper, GF_BAD_PARAM, \"Please specify trackID to export\");\n\t\tinTrackNum = 1;\n\t}\n\t//check the ID is available\n\tTrackID = gf_isom_get_track_id(infile, inTrackNum);\n\tnewTk = gf_isom_get_track_by_id(outfile, TrackID);\n\tif (newTk) TrackID = 0;\n\n\t//get the ESD and remove dependencies\n\tesd = NULL;\n\tmsubtype = gf_isom_get_media_subtype(infile, inTrackNum, 1);\n\n\tif (msubtype == GF_ISOM_SUBTYPE_MPEG4) {\n\t\tesd = gf_isom_get_esd(infile, inTrackNum, 1);\n\t\tif (esd && ResetDependencies) {\n\t\t\tesd->dependsOnESID = 0;\n\t\t\tesd->OCRESID = 0;\n\t\t}\n\t}\n\n\tnewTk = gf_isom_new_track(outfile, TrackID, gf_isom_get_media_type(infile, inTrackNum), gf_isom_get_media_timescale(infile, inTrackNum));\n\tgf_isom_set_track_enabled(outfile, newTk, GF_TRUE);\n\n\tif (gf_isom_has_keep_utc_times(infile)) {\n\t\tu64 cdate, mdate;\n\t\tgf_isom_get_track_creation_time(infile, inTrackNum, &cdate, &mdate);\n\t\tgf_isom_set_track_creation_time(outfile, newTk, cdate, mdate);\n\t}\n\n\tif (esd) {\n\t\tgf_isom_new_mpeg4_description(outfile, newTk, esd, NULL, NULL, &descIndex);\n\t\tif ((esd->decoderConfig->streamType == GF_STREAM_VISUAL) || (esd->decoderConfig->streamType == GF_STREAM_SCENE)) {\n\t\t\tu32 w, h;\n\t\t\tgf_isom_get_visual_info(infile, inTrackNum, 1, &w, &h);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t/*this is because so many files have reserved values of 320x240 from v1 ... */\n\t\t\tif (esd->decoderConfig->objectTypeIndication == GF_CODECID_MPEG4_PART2) {\n\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\tw = dsi.width;\n\t\t\t\th = dsi.height;\n\t\t\t}\n#endif\n\t\t\tgf_isom_set_visual_info(outfile, newTk, 1, w, h);\n\t\t}\n\t\telse if ((esd->decoderConfig->streamType == GF_STREAM_TEXT) && (esd->decoderConfig->objectTypeIndication == GF_CODECID_SUBPIC)) {\n\t\t\tu32 w, h;\n\t\t\ts32 trans_x, trans_y;\n\t\t\ts16 layer;\n\t\t\tgf_isom_get_track_layout_info(infile, inTrackNum, &w, &h, &trans_x, &trans_y, &layer);\n\t\t\tgf_isom_set_track_layout_info(outfile, newTk, w << 16, h << 16, trans_x, trans_y, layer);\n\t\t}\n\t\tesd->decoderConfig->avgBitrate = 0;\n\t\tesd->decoderConfig->maxBitrate = 0;\n\t} else {\n\t\tgf_isom_clone_sample_description(outfile, newTk, infile, inTrackNum, 1, NULL, NULL, &descIndex);\n\t}\n\n\tpos = 0;\n\trate = 0;\n\tts = gf_isom_get_media_timescale(infile, inTrackNum);\n\tcount = gf_isom_get_sample_count(infile, inTrackNum);\n\tfor (i=0; i<count; i++) {\n\t\tsamp = gf_isom_get_sample(infile, inTrackNum, i+1, &di);\n\t\tgf_isom_add_sample(outfile, newTk, descIndex, samp);\n\t\tif (esd) {\n\t\t\trate += samp->dataLength;\n\t\t\tesd->decoderConfig->avgBitrate += samp->dataLength;\n\t\t\tif (esd->decoderConfig->bufferSizeDB<samp->dataLength) esd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\tif (samp->DTS - pos > ts) {\n\t\t\t\tif (esd->decoderConfig->maxBitrate<rate) esd->decoderConfig->maxBitrate = rate;\n\t\t\t\trate = 0;\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t}\n\t\tgf_isom_sample_del(&samp);\n\t\tgf_set_progress(\"ISO File Export\", i, count);\n\t}\n\tgf_set_progress(\"ISO File Export\", count, count);\n\n\tif (msubtype == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\tesd = gf_isom_get_esd(infile, inTrackNum, 1);\n\t} else if ((msubtype == GF_ISOM_SUBTYPE_AVC_H264)\n\t           || (msubtype == GF_ISOM_SUBTYPE_AVC2_H264)\n\t           || (msubtype == GF_ISOM_SUBTYPE_AVC3_H264)\n\t           || (msubtype == GF_ISOM_SUBTYPE_AVC4_H264)\n\t          ) {\n\t\treturn gf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, 0x0F);\n\t}\n\t/*likely 3gp or any non-MPEG-4 isomedia file*/\n\telse if (!esd) return gf_isom_remove_root_od(outfile);\n\n\tdur = gf_isom_get_media_duration(outfile, newTk);\n\tif (!dur) dur = ts;\n\tesd->decoderConfig->maxBitrate *= 8;\n\tesd->decoderConfig->avgBitrate = (u32) (esd->decoderConfig->avgBitrate * 8 * ts / dur);\n\tgf_isom_change_mpeg4_description(outfile, newTk, 1, esd);\n\n\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(infile);\n\tswitch (esd->decoderConfig->streamType) {\n\tcase GF_STREAM_SCENE:\n\t\tif (iod && (iod->tag==GF_ODF_IOD_TAG)) {\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_SCENE, iod->scene_profileAndLevel);\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_GRAPHICS, iod->graphics_profileAndLevel);\n\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n\t\t\tgf_export_message(dumper, GF_OK, \"Warning: Scene PLs not found in original MP4 - defaulting to No Profile Specified\");\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_SCENE, 0xFE);\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_GRAPHICS, 0xFE);\n\t\t}\n\t\tbreak;\n\tcase GF_STREAM_VISUAL:\n\t\tif (iod && (iod->tag==GF_ODF_IOD_TAG)) {\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, iod->visual_profileAndLevel);\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, dsi.VideoPL);\n\t\t}\n#endif\n\t\telse {\n\t\t\tgf_export_message(dumper, GF_OK, \"Warning: Visual PLs not found in original MP4 - defaulting to No Profile Specified\");\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, 0xFE);\n\t\t}\n\t\tbreak;\n\tcase GF_STREAM_AUDIO:\n\t\tif (iod && (iod->tag==GF_ODF_IOD_TAG)) {\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_AUDIO, iod->audio_profileAndLevel);\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) {\n\t\t\tGF_M4ADecSpecInfo cfg;\n\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &cfg);\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_AUDIO, cfg.audioPL);\n\t\t}\n#endif\n\t\telse {\n\t\t\tgf_export_message(dumper, GF_OK, \"Warning: Audio PLs not found in original MP4 - defaulting to No Profile Specified\");\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_AUDIO, 0xFE);\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tif (iod) gf_odf_desc_del((GF_Descriptor *) iod);\n\tgf_odf_desc_del((GF_Descriptor *)esd);\n\n\tif (AddToIOD) gf_isom_add_track_to_root_od(outfile, newTk);\n\n\treturn GF_OK;\n}\n\n\nGF_Err gf_media_export_isom(GF_MediaExporter *dumper)\n{\n\tGF_ISOFile *outfile;\n\tGF_Err e;\n\tBool add_to_iod, is_stdout;\n\tchar szName[1000];\n\tu32 track;\n\tGF_ISOOpenMode mode;\n\n\tif (!(track = gf_isom_get_track_by_id(dumper->file, dumper->trackID))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"Wrong track ID %d for file %s \\n\", dumper->trackID, gf_isom_get_filename(dumper->file)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (gf_isom_get_media_type(dumper->file, dumper->trackID)==GF_ISOM_MEDIA_OD) {\n\t\treturn gf_export_message(dumper, GF_BAD_PARAM, \"Cannot extract OD track, result is  meaningless\");\n\t}\n\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) {\n\t\tdumper->flags |= GF_EXPORT_MERGE;\n\t\treturn GF_OK;\n\t}\n\tif (dumper->out_name && gf_file_ext_start(dumper->out_name)) {\n\t\tstrcpy(szName, dumper->out_name);\n\t} else {\n\t\tchar *ext = (char *) gf_isom_get_filename(dumper->file);\n\t\tif (ext) ext = gf_file_ext_start(ext);\n\t\tsprintf(szName, \"%s%s\", dumper->out_name, ext ? ext : \".mp4\");\n\t}\n\tis_stdout = (dumper->out_name && !strcmp(dumper->out_name, \"std\")) ? 1 : 0;\n\tadd_to_iod = 1;\n\tmode = GF_ISOM_WRITE_EDIT;\n\tif (!is_stdout && (dumper->flags & GF_EXPORT_MERGE)) {\n\t\tFILE *t = gf_fopen(szName, \"rb\");\n\t\tif (t) {\n\t\t\tadd_to_iod = 0;\n\t\t\tmode = GF_ISOM_OPEN_EDIT;\n\t\t\tgf_fclose(t);\n\t\t}\n\t}\n\toutfile = gf_isom_open(is_stdout ? \"std\" : szName, mode, NULL);\n\n\tif (mode == GF_ISOM_WRITE_EDIT) {\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_AUDIO, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_GRAPHICS, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_SCENE, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_OD, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_MPEGJ, 0xFF);\n\t}\n\tif (gf_isom_has_keep_utc_times(dumper->file)) {\n\t\tu64 cdate, mdate;\n\t\tgf_isom_get_creation_time(dumper->file, &cdate, &mdate);\n\t\tgf_isom_set_creation_time(outfile, cdate, mdate);\n\t}\n\n\te = gf_export_isom_copy_track(dumper, dumper->file, track, outfile, 1, add_to_iod);\n\tif (!add_to_iod) {\n\t\tu32 i;\n\t\tfor (i=0; i<gf_isom_get_track_count(outfile); i++) {\n\t\t\tgf_isom_remove_track_from_root_od(outfile, i+1);\n\t\t}\n\t}\n\n\tif (gf_isom_has_keep_utc_times(dumper->file))\n\t\tgf_isom_keep_utc_times(outfile, GF_TRUE);\n\n\tif (e) gf_isom_delete(outfile);\n\telse gf_isom_close(outfile);\n\n\treturn e;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* Required for base64 encoding of DecoderSpecificInfo */\n#include <gpac/base_coding.h>\n\n#ifndef GPAC_DISABLE_VTT\n\n/* Required for timestamp generation */\n#include <gpac/webvtt.h>\n\nGF_Err gf_media_export_webvtt_metadata(GF_MediaExporter *dumper)\n{\n\tGF_ESD *esd;\n\tchar szName[1000], szMedia[1000];\n\tFILE *med, *vtt;\n\tu32 w, h;\n\tu32 track, i, di, count, pos;\n\tu32 mtype, mstype;\n\tBool isText;\n\tchar *mime = NULL;\n\tBool useBase64 = GF_FALSE;\n\tu32 headerLength = 0;\n\n\tif (!(track = gf_isom_get_track_by_id(dumper->file, dumper->trackID))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"Wrong track ID %d for file %s \\n\", dumper->trackID, gf_isom_get_filename(dumper->file)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (!track) return gf_export_message(dumper, GF_BAD_PARAM, \"Invalid track ID %d\", dumper->trackID);\n\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) {\n\t\treturn GF_OK;\n\t}\n\tesd = gf_isom_get_esd(dumper->file, track, 1);\n\tmed = NULL;\n\tif (dumper->flags & GF_EXPORT_WEBVTT_META_EMBEDDED) {\n\t} else {\n\t\tsprintf(szMedia, \"%s.media\", dumper->out_name);\n\t\tmed = gf_fopen(szMedia, \"wb\");\n\t\tif (!med) {\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szMedia);\n\t\t}\n\t}\n\n\tsprintf(szName, \"%s.vtt\", dumper->out_name);\n\tvtt = gf_fopen(szName, \"wt\");\n\tif (!vtt) {\n\t\tgf_fclose(med);\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\t}\n\n\tmtype = gf_isom_get_media_type(dumper->file, track);\n\tif (mtype==GF_ISOM_MEDIA_TEXT || mtype == GF_ISOM_MEDIA_MPEG_SUBT || mtype == GF_ISOM_MEDIA_SUBT) {\n\t\tisText = GF_TRUE;\n\t} else {\n\t\tisText = GF_FALSE;\n\t}\n\tmstype = gf_isom_get_media_subtype(dumper->file, track, 1);\n\n\t/*write header*/\n\tgf_fprintf(vtt, \"WEBVTT Metadata track generated by GPAC MP4Box %s\\n\", gf_sys_is_test_mode() ? \"\" : gf_gpac_version());\n\n\tgf_fprintf(vtt, \"kind:metadata\\n\");\n\t{\n\t\tchar *lang;\n\t\tgf_isom_get_media_language(dumper->file, track, &lang);\n\t\tgf_fprintf(vtt, \"language:%s\\n\", lang);\n\t\tgf_free(lang);\n\t}\n\t{\n\t\tconst char *handler;\n\t\tgf_isom_get_handler_name(dumper->file, track, &handler);\n\t\tgf_fprintf(vtt, \"label: %s\\n\", handler);\n\t}\n\tif (gf_isom_is_track_in_root_od(dumper->file, track)) gf_fprintf(vtt, \"inRootOD: yes\\n\");\n\tgf_fprintf(vtt, \"trackID: %d\\n\", dumper->trackID);\n\tif (med) {\n\t\tgf_fprintf(vtt, \"baseMediaFile: %s\\n\", gf_file_basename(szMedia));\n\t}\n\tif (esd) {\n\t\t/* TODO: export the MPEG-4 Stream type only if it is not a GPAC internal value */\n\t\tgf_fprintf(vtt, \"MPEG-4-streamType: %d\\n\", esd->decoderConfig->streamType);\n\t\t/* TODO: export the MPEG-4 Object Type Indication only if it is not a GPAC internal value */\n\t\tgf_fprintf(vtt, \"MPEG-4-objectTypeIndication: %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tgf_isom_get_visual_info(dumper->file, track, 1, &w, &h);\n\t\t\tgf_fprintf(vtt, \"width:%d\\n\", w);\n\t\t\tgf_fprintf(vtt, \"height:%d\\n\", h);\n\t\t}\n\t\telse if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tu32 sr, nb_ch, bps;\n\t\t\tgf_isom_get_audio_info(dumper->file, track, 1, &sr, &nb_ch, &bps);\n\t\t\tgf_fprintf(vtt, \"sampleRate: %d\\n\", sr);\n\t\t\tgf_fprintf(vtt, \"numChannels: %d\\n\", nb_ch);\n\t\t} else if (isText) {\n\t\t\ts32 tx, ty;\n\t\t\ts16 layer;\n\t\t\tgf_isom_get_track_layout_info(dumper->file, track, &w, &h, &tx, &ty, &layer);\n\t\t\tgf_fprintf(vtt, \"width:%d\\n\", w);\n\t\t\tgf_fprintf(vtt, \"height:%d\\n\", h);\n\t\t\tif (tx || ty) gf_fprintf(vtt, \"translation:%d,%d\\n\", tx, ty);\n\t\t\tif (layer) gf_fprintf(vtt, \"layer:%d\\n\", layer);\n\t\t}\n\t\tif (esd->decoderConfig->decoderSpecificInfo  && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (isText) {\n\t\t\t\tif (mstype == GF_ISOM_SUBTYPE_WVTT) {\n\t\t\t\t\t/* Warning: Just use -raw export */\n\t\t\t\t\tmime = \"text/vtt\";\n\t\t\t\t} else if (mstype == GF_ISOM_SUBTYPE_STXT) {\n\t\t\t\t\t/* TODO: find the mime type from the ESD, assume SVG for now */\n\t\t\t\t\tmime = \"image/svg+xml\";\n\t\t\t\t} else if (mstype == GF_ISOM_SUBTYPE_STPP) {\n\t\t\t\t\t/* TODO: find the mime type from the ESD, assume TTML for now */\n\t\t\t\t\tmime = \"application/ttml+xml\";\n\t\t\t\t}\n\t\t\t\tif (dumper->flags & GF_EXPORT_WEBVTT_META_EMBEDDED) {\n\t\t\t\t\tif (mstype == GF_ISOM_SUBTYPE_STXT) {\n\t\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo->dataLength) {\n\t\t\t\t\t\t\tgf_fprintf(vtt, \"text-header: \\n\");\n\t\t\t\t\t\t\tgf_webvtt_dump_header_boxed(vtt, esd->decoderConfig->decoderSpecificInfo->data+4, esd->decoderConfig->decoderSpecificInfo->dataLength, &headerLength);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_webvtt_dump_header_boxed(med, esd->decoderConfig->decoderSpecificInfo->data+4, esd->decoderConfig->decoderSpecificInfo->dataLength, &headerLength);\n\t\t\t\t\tgf_fprintf(vtt, \"text-header-length: %d\\n\", headerLength);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchar b64[200];\n\t\t\t\tu32 size = gf_base64_encode(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, b64, 200);\n\t\t\t\tuseBase64 = GF_TRUE;\n\t\t\t\tif (size != (u32)-1 && size != 0) {\n\t\t\t\t\tb64[size] = 0;\n\t\t\t\t\tgf_fprintf(vtt, \"MPEG-4-DecoderSpecificInfo: %s\\n\", b64);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t} else {\n\t\tGF_GenericSampleDescription *sdesc = gf_isom_get_generic_sample_description(dumper->file, track, 1);\n\t\tgf_fprintf(vtt, \"mediaType: %s\\n\", gf_4cc_to_str(mtype));\n\t\tgf_fprintf(vtt, \"mediaSubType: %s\\n\", gf_4cc_to_str(mstype ));\n\t\tif (sdesc) {\n\t\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\t\tgf_fprintf(vtt, \"codecVendor: %s\\n\", gf_4cc_to_str(sdesc->vendor_code));\n\t\t\t\tgf_fprintf(vtt, \"codecVersion: %d\\n\", sdesc->version);\n\t\t\t\tgf_fprintf(vtt, \"codecRevision: %d\\n\", sdesc->revision);\n\t\t\t\tgf_fprintf(vtt, \"width: %d\\n\", sdesc->width);\n\t\t\t\tgf_fprintf(vtt, \"height: %d\\n\", sdesc->height);\n\t\t\t\tgf_fprintf(vtt, \"compressorName: %s\\n\", sdesc->compressor_name);\n\t\t\t\tgf_fprintf(vtt, \"temporalQuality: %d\\n\", sdesc->temporal_quality);\n\t\t\t\tgf_fprintf(vtt, \"spatialQuality: %d\\n\", sdesc->spatial_quality);\n\t\t\t\tgf_fprintf(vtt, \"horizontalResolution: %d\\n\", sdesc->h_res);\n\t\t\t\tgf_fprintf(vtt, \"verticalResolution: %d\\n\", sdesc->v_res);\n\t\t\t\tgf_fprintf(vtt, \"bitDepth: %d\\n\", sdesc->depth);\n\t\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\t\tgf_fprintf(vtt, \"codecVendor: %s\\n\", gf_4cc_to_str(sdesc->vendor_code));\n\t\t\t\tgf_fprintf(vtt, \"codecVersion: %d\\n\", sdesc->version);\n\t\t\t\tgf_fprintf(vtt, \"codecRevision: %d\\n\", sdesc->revision);\n\t\t\t\tgf_fprintf(vtt, \"sampleRate: %d\\n\", sdesc->samplerate);\n\t\t\t\tgf_fprintf(vtt, \"numChannels: %d\\n\", sdesc->nb_channels);\n\t\t\t\tgf_fprintf(vtt, \"bitsPerSample: %d\\n\", sdesc->bits_per_sample);\n\t\t\t}\n\t\t\tif (sdesc->extension_buf) {\n\t\t\t\tchar b64[200];\n\t\t\t\tu32 size = gf_base64_encode(sdesc->extension_buf, sdesc->extension_buf_size, b64, 200);\n\t\t\t\tuseBase64 = GF_TRUE;\n\t\t\t\tif (size != (u32)-1) {\n\t\t\t\t\tb64[size] = 0;\n\t\t\t\t\tgf_fprintf(vtt, \"specificInfo: %s\\n\", b64);\n\t\t\t\t\tgf_free(sdesc->extension_buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_free(sdesc);\n\t\t}\n\t}\n\tgf_fprintf(vtt, \"inBandMetadataTrackDispatchType: %s\\n\", (mime ? mime : (isText? \"text/plain\" : \"application/octet-stream\")));\n\tif (useBase64) gf_fprintf(vtt, \"encoding: base64\\n\");\n\n\tgf_fprintf(vtt, \"\\n\");\n\n\tpos = 0;\n\tcount = gf_isom_get_sample_count(dumper->file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ISOSample *samp = gf_isom_get_sample(dumper->file, track, i+1, &di);\n\t\tif (!samp) break;\n\n\t\t{\n\t\t\tGF_WebVTTTimestamp start, end;\n\t\t\tu64 dur = gf_isom_get_sample_duration(dumper->file, track, i+1);\n\t\t\tgf_webvtt_timestamp_set(&start, samp->DTS);\n\t\t\tgf_webvtt_timestamp_set(&end, samp->DTS+dur);\n\t\t\tgf_webvtt_timestamp_dump(&start, vtt, GF_TRUE);\n\t\t\tgf_fprintf(vtt, \" --> \");\n\t\t\tgf_webvtt_timestamp_dump(&end, vtt, GF_TRUE);\n\t\t\tgf_fprintf(vtt, \" \");\n\t\t\tif (med) {\n\t\t\t\tgf_fprintf(vtt, \"mediaOffset:%d \", pos+headerLength);\n\t\t\t\tgf_fprintf(vtt, \"dataLength:%d \", samp->dataLength);\n\t\t\t}\n\t\t\tif (samp->CTS_Offset) gf_fprintf(vtt, \"CTS: \"LLD\"\", samp->DTS+samp->CTS_Offset);\n\t\t\tif (samp->IsRAP==RAP) gf_fprintf(vtt, \"isRAP:true \");\n\t\t\telse if (samp->IsRAP==RAP_REDUNDANT) gf_fprintf(vtt, \"isSyncShadow: true \");\n\t\t\telse gf_fprintf(vtt, \"isRAP:false \");\n\t\t\tgf_fprintf(vtt, \"\\n\");\n\t\t}\n\t\tif (med) {\n\t\t\tgf_fwrite(samp->data, samp->dataLength, med);\n\t\t} else if (dumper->flags & GF_EXPORT_WEBVTT_META_EMBEDDED) {\n\t\t\tif (isText) {\n\t\t\t\tsamp->data = (char *)gf_realloc(samp->data, samp->dataLength+1);\n\t\t\t\tsamp->data[samp->dataLength] = 0;\n\t\t\t\tgf_fprintf(vtt, \"%s\\n\", samp->data);\n\t\t\t} else {\n\t\t\t\tu32 b64_size;\n\t\t\t\tchar *b64;\n\t\t\t\tb64 = (char *)gf_malloc(samp->dataLength*3);\n\t\t\t\tb64_size = gf_base64_encode(samp->data, samp->dataLength, b64, samp->dataLength*3);\n\t\t\t\tif (b64_size != (u32)-1) {\n\t\t\t\t\tb64[b64_size] = 0;\n\t\t\t\t\tgf_fprintf(vtt, \"%s\\n\", b64);\n\t\t\t\t}\n\t\t\t\tgf_free(b64);\n\t\t\t}\n\t\t}\n\t\tgf_fprintf(vtt, \"\\n\");\n\n\t\tpos += samp->dataLength;\n\t\tgf_isom_sample_del(&samp);\n\t\tgf_set_progress(\"WebVTT metadata Export\", i+1, count);\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) break;\n\t}\n\tif (med) gf_fclose(med);\n\tgf_fclose(vtt);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\n/* Experimental Streaming Instructions XML export */\nGF_Err gf_media_export_six(GF_MediaExporter *dumper)\n{\n\tGF_ESD *esd;\n\tchar szName[1000], szMedia[1000];\n\tFILE *media, *six;\n\tu32 track, i, di, count, pos, header_size;\n\t//u32 mtype;\n#if !defined(GPAC_DISABLE_TTXT) && !defined(GPAC_DISABLE_VTT)\n\tu32 mstype;\n#endif\n\tconst char *szRootName;\n\t//Bool isText;\n\n\tif (!(track = gf_isom_get_track_by_id(dumper->file, dumper->trackID))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"Wrong track ID %d for file %s \\n\", dumper->trackID, gf_isom_get_filename(dumper->file)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (!track) return gf_export_message(dumper, GF_BAD_PARAM, \"Invalid track ID %d\", dumper->trackID);\n\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) {\n\t\tdumper->flags |= GF_EXPORT_NHML_FULL;\n\t\treturn GF_OK;\n\t}\n\tesd = gf_isom_get_esd(dumper->file, track, 1);\n\n\tsprintf(szMedia, \"%s.media\", dumper->out_name);\n\tmedia = gf_fopen(szMedia, \"wb\");\n\tif (!media) {\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szMedia);\n\t}\n\n\tsprintf(szName, \"%s.six\", dumper->out_name);\n\tszRootName = \"stream\";\n\n\tsix = gf_fopen(szName, \"wt\");\n\tif (!six) {\n\t\tgf_fclose(media);\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\t}\n\t/*\n\t\tmtype = gf_isom_get_media_type(dumper->file, track);\n\t\tif (mtype==GF_ISOM_MEDIA_TEXT || mtype == GF_ISOM_MEDIA_SUBM || mtype == GF_ISOM_MEDIA_SUBT) {\n\t\t\tisText = GF_TRUE;\n\t\t} else {\n\t\t\tisText = GF_FALSE;\n\t\t}\n\t*/\n#if !defined(GPAC_DISABLE_TTXT) && !defined(GPAC_DISABLE_VTT)\n\tmstype = gf_isom_get_media_subtype(dumper->file, track, 1);\n#endif\n\n\t/*write header*/\n\tgf_fprintf(six, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\tgf_fprintf(six, \"<%s timescale=\\\"%d\\\" \", szRootName, gf_isom_get_media_timescale(dumper->file, track) );\n\tgf_fprintf(six, \"file=\\\"%s\\\" \", szMedia);\n\tgf_fprintf(six, \">\\n\");\n\theader_size = 0;\n\tif (esd) {\n\t\tif (esd->decoderConfig->decoderSpecificInfo  && esd->decoderConfig->decoderSpecificInfo->data) {\n#if !defined(GPAC_DISABLE_TTXT) && !defined(GPAC_DISABLE_VTT)\n\t\t\tif (mstype == GF_ISOM_SUBTYPE_WVTT || mstype == GF_ISOM_SUBTYPE_STXT) {\n\t\t\t\tgf_webvtt_dump_header_boxed(media,\n\t\t\t\t                            esd->decoderConfig->decoderSpecificInfo->data+4,\n\t\t\t\t                            esd->decoderConfig->decoderSpecificInfo->dataLength,\n\t\t\t\t                            &header_size);\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tgf_fwrite(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, media);\n\t\t\t\theader_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t} else {\n\t\tGF_GenericSampleDescription *sdesc = gf_isom_get_generic_sample_description(dumper->file, track, 1);\n\t\tif (sdesc) {\n\t\t\theader_size = sdesc->extension_buf_size;\n\t\t\tgf_free(sdesc);\n\t\t}\n\t}\n\tgf_fprintf(six, \"<header range-begin=\\\"0\\\" range-end=\\\"%d\\\"/>\\n\", header_size-1);\n\n\tpos = header_size;\n\tcount = gf_isom_get_sample_count(dumper->file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ISOSample *samp = gf_isom_get_sample(dumper->file, track, i+1, &di);\n\t\tif (!samp) break;\n\n\t\tif (media) {\n\t\t\tgf_fwrite(samp->data, samp->dataLength, media);\n\t\t}\n\n\t\tgf_fprintf(six, \"<unit time=\\\"\"LLU\"\\\" \", samp->DTS);\n\t\tif (samp->IsRAP==RAP) gf_fprintf(six, \"rap=\\\"1\\\" \");\n\t\telse if (samp->IsRAP==RAP_NO) gf_fprintf(six, \"rap=\\\"0\\\" \");\n\t\tgf_fprintf(six, \"range-begin=\\\"%d\\\" \", pos);\n\t\tgf_fprintf(six, \"range-end=\\\"%d\\\" \", pos+samp->dataLength-1);\n\t\tgf_fprintf(six, \"/>\\n\");\n\n\t\tpos += samp->dataLength;\n\t\tgf_isom_sample_del(&samp);\n\t\tgf_set_progress(\"SIX Export\", i+1, count);\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) break;\n\t}\n\tgf_fprintf(six, \"</%s>\\n\", szRootName);\n\tif (media) gf_fclose(media);\n\tgf_fclose(six);\n\treturn GF_OK;\n\n}\n\ntypedef struct\n{\n\tu32 track_num, stream_id, last_sample, nb_samp;\n} SAFInfo;\n\nGF_Err gf_media_export_saf(GF_MediaExporter *dumper)\n{\n#ifndef GPAC_DISABLE_SAF\n\tu32 count, i, s_count, di, tot_samp, samp_done;\n\tchar out_file[GF_MAX_PATH];\n\tGF_SAFMuxer *mux;\n\tu8 *data;\n\tu32 size;\n\tBool is_stdout = 0;\n\tFILE *saf_f;\n\tSAFInfo safs[1024];\n\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) return GF_OK;\n\n\ts_count = tot_samp = 0;\n\n\tmux = gf_saf_mux_new();\n\tcount = gf_isom_get_track_count(dumper->file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 time_scale, mtype, stream_id;\n\t\tGF_ESD *esd;\n\t\tmtype = gf_isom_get_media_type(dumper->file, i+1);\n\t\tif (mtype==GF_ISOM_MEDIA_OD) continue;\n\t\tif (mtype==GF_ISOM_MEDIA_HINT) continue;\n\n\t\ttime_scale = gf_isom_get_media_timescale(dumper->file, i+1);\n\t\tesd = gf_isom_get_esd(dumper->file, i+1, 1);\n\t\tif (esd) {\n\t\t\tstream_id = gf_isom_find_od_id_for_track(dumper->file, i+1);\n\t\t\tif (!stream_id) stream_id = esd->ESID;\n\n\t\t\t/*translate OD IDs to ESIDs !!*/\n\t\t\tif (esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\tgf_saf_mux_stream_add(mux, stream_id, time_scale, esd->decoderConfig->bufferSizeDB, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, NULL, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, esd->URLString);\n\t\t\t} else {\n\t\t\t\tgf_saf_mux_stream_add(mux, stream_id, time_scale, esd->decoderConfig->bufferSizeDB, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, NULL, NULL, 0, esd->URLString);\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t} else {\n\t\t\tchar *mime = NULL;\n\t\t\tswitch (gf_isom_get_media_subtype(dumper->file, i+1, 1)) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tmime = \"video/h263\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\t\tmime = \"audio/amr\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tmime = \"audio/amr-wb\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tmime = \"audio/evrc\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tmime = \"audio/qcelp\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tmime = \"audio/smv\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!mime) continue;\n\t\t\tstream_id = gf_isom_get_track_id(dumper->file, i+1);\n\t\t\tgf_saf_mux_stream_add(mux, stream_id, time_scale, 0, 0xFF, 0xFF, mime, NULL, 0, NULL);\n\t\t}\n\n\t\tsafs[s_count].track_num = i+1;\n\t\tsafs[s_count].stream_id = stream_id;\n\t\tsafs[s_count].nb_samp = gf_isom_get_sample_count(dumper->file, i+1);\n\t\tsafs[s_count].last_sample = 0;\n\n\t\ttot_samp += safs[s_count].nb_samp;\n\n\t\ts_count++;\n\t}\n\n\tif (!s_count) {\n\t\tgf_export_message(dumper, GF_OK, \"No tracks available for SAF muxing\");\n\t\tgf_saf_mux_del(mux);\n\t\treturn GF_OK;\n\t}\n\tgf_export_message(dumper, GF_OK, \"SAF: Multiplexing %d tracks\", s_count);\n\n\tif (dumper->out_name && !strcmp(dumper->out_name, \"std\"))\n\t\tis_stdout = 1;\n\tstrcpy(out_file, dumper->out_name ? dumper->out_name : \"\");\n\tstrcat(out_file, \".saf\");\n\tsaf_f = is_stdout ? stdout : gf_fopen(out_file, \"wb\");\n\n\tsamp_done = 0;\n\twhile (samp_done<tot_samp) {\n\t\tfor (i=0; i<s_count; i++) {\n\t\t\tGF_ISOSample *samp;\n\t\t\tif (safs[i].last_sample==safs[i].nb_samp) continue;\n\t\t\tsamp = gf_isom_get_sample(dumper->file, safs[i].track_num, safs[i].last_sample + 1, &di);\n\t\t\tgf_saf_mux_add_au(mux, safs[i].stream_id, (u32) (samp->DTS+samp->CTS_Offset), samp->data, samp->dataLength, (samp->IsRAP==RAP) ? 1 : 0);\n\t\t\t/*data is kept by muxer!!*/\n\t\t\tgf_free(samp);\n\t\t\tsafs[i].last_sample++;\n\t\t\tsamp_done ++;\n\t\t}\n\t\twhile (1) {\n\t\t\tgf_saf_mux_for_time(mux, (u32) -1, 0, &data, &size);\n\t\t\tif (!data) break;\n\t\t\tgf_fwrite(data, size, saf_f);\n\t\t\tgf_free(data);\n\t\t}\n\t\tgf_set_progress(\"SAF Export\", samp_done, tot_samp);\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) break;\n\t}\n\tgf_saf_mux_for_time(mux, (u32) -1, 1, &data, &size);\n\tif (data) {\n\t\tgf_fwrite(data, size, saf_f);\n\t\tgf_free(data);\n\t}\n\tif (!is_stdout)\n\t\tgf_fclose(saf_f);\n\n\tgf_saf_mux_del(mux);\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\nstatic GF_Err gf_media_export_filters(GF_MediaExporter *dumper)\n{\n\tchar *args, szSubArgs[1024], szExt[30];\n\tGF_Filter *file_out, *reframer, *remux=NULL, *src_filter;\n\tGF_FilterSession *fsess;\n\tGF_Err e = GF_OK;\n\tu32 codec_id=0;\n\tu32 sample_count=0;\n\tBool skip_write_filter = GF_FALSE;\n\tBool ext_forced = GF_FALSE;\n\tBool use_dynext = GF_FALSE;\n\n\targs = NULL;\n\tstrcpy(szExt, \"\");\n\tif (dumper->trackID && dumper->file) {\n\t\tu32 msubtype = 0;\n\t\tu32 mtype = 0;\n\t\tu32 afmt = 0;\n\t\tGF_PixelFormat pfmt = 0;\n\t\tGF_ESD *esd;\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tu32 track_num = gf_isom_get_track_by_id(dumper->file, dumper->trackID);\n\t\tif (!track_num) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] No tracks with ID %d in file\\n\", dumper->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tesd = gf_media_map_esd(dumper->file, track_num, 0);\n\t\tsample_count = gf_isom_get_sample_count(dumper->file, dumper->trackID);\n\t\tif (esd) {\n\t\t\tif (esd->decoderConfig->objectTypeIndication<GF_CODECID_LAST_MPEG4_MAPPING) {\n\t\t\t\tcodec_id = gf_codecid_from_oti(esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (codec_id==GF_CODECID_AAC_MPEG4)) {\n\t\t\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &acfg);\n\t\t\t\t\tif (acfg.base_object_type == GF_M4A_USAC)\n\t\t\t\t\t\tcodec_id = GF_CODECID_USAC;\n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tcodec_id = esd->decoderConfig->objectTypeIndication;\n\t\t\t}\n\t\t}\n\t\tif (!codec_id) {\n\t\t\tmsubtype = gf_isom_get_media_subtype(dumper->file, track_num, 1);\n\t\t\tcodec_id = gf_codec_id_from_isobmf(msubtype);\n\t\t}\n\t\tmtype = gf_isom_get_media_type(dumper->file, track_num);\n\t\tif (!codec_id) {\n\t\t\tpfmt = gf_pixel_fmt_from_qt_type(msubtype);\n\t\t\tif (pfmt) codec_id = GF_CODECID_RAW;\n\t\t}\n\n\t\tif (!codec_id) {\n\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\text_forced = GF_TRUE;\n\t\t} else if (codec_id==GF_CODECID_RAW) {\n\t\t\tswitch (mtype) {\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (pfmt)\n\t\t\t\t\tstrcpy(szExt, gf_pixel_fmt_sname(pfmt));\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tafmt = gf_audio_fmt_from_isobmf(msubtype);\n\t\t\t\tif (afmt)\n\t\t\t\t\tstrcpy(szExt, gf_audio_fmt_name(afmt));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *sname = gf_codecid_file_ext(codec_id);\n\t\t\tif (export_ext && strstr(sname, export_ext+1)) {\n\t\t\t\tszExt[0]=0;\n\t\t\t} else {\n\t\t\t\tchar *sep;\n\t\t\t\tstrncpy(szExt, sname, 29);\n\t\t\t\tszExt[29]=0;\n\t\t\t\tsep = strchr(szExt, '|');\n\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t}\n\t\t}\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tskip_write_filter = codec_id ? GF_TRUE : GF_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (codec_id) {\n\t\t\tcase GF_CODECID_WEBVTT:\n\t\t\t\tskip_write_filter = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_META_TEXT:\n\t\t\tcase GF_CODECID_META_XML:\n\t\t\tcase GF_CODECID_SUBS_TEXT:\n\t\t\tcase GF_CODECID_SUBS_XML:\n\t\t\tcase GF_CODECID_SIMPLE_TEXT:\n\t\t\t\t//use dynamic extension\n\t\t\t\tszExt[0] = 0;\n\t\t\t\tuse_dynext = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//TODO, move these two to filters one of these days\n\t\tif ((codec_id==GF_CODECID_VORBIS) || (codec_id==GF_CODECID_THEORA) || (codec_id==GF_CODECID_OPUS)) {\n\t\t\tchar *outname = dumper->out_name;\n\t\t\tif (outname && !strcmp(outname, \"std\")) outname=NULL;\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\treturn gf_dump_to_ogg(dumper, outname, track_num);\n#else\n\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t\t}\n\t\tif (codec_id==GF_CODECID_SUBPIC) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tchar *dsi = NULL;\n\t\t\tu32 dsi_size = 0;\n\t\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\tdsi = esd->decoderConfig->decoderSpecificInfo->data;\n\t\t\t\tdsi_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t}\n\t\t\te = gf_dump_to_vobsub(dumper, dumper->out_name, track_num, dsi, dsi_size);\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\treturn e;\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t} else {\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tskip_write_filter = GF_TRUE;\n\t\tif (!export_ext)\n\t\t\tuse_dynext = GF_TRUE;\n\t}\n\n\tfsess = gf_fs_new_defaults(0);\n\tif (!fsess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Failed to create filter session\\n\"));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tfile_out = NULL;\n\targs = NULL;\n\n\tif (dumper->flags & GF_EXPORT_REMUX) {\n\t\tfile_out = gf_fs_load_destination(fsess, dumper->out_name, NULL, NULL, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot open destination %s\\n\", dumper->out_name));\n\t\t\treturn e;\n\t\t}\n\t}\n\t//except in nhml inband file dump, create a sink filter\n\telse if (!dumper->dump_file) {\n\t\tBool no_ext = (dumper->flags & GF_EXPORT_NO_FILE_EXT) ? GF_TRUE : GF_FALSE;\n\t\tchar *ext = gf_file_ext_start(dumper->out_name);\n\t\t//mux args, for now we only dump to file\n\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\n\t\tif (dumper->flags & GF_EXPORT_NHNT) {\n\t\t\tstrcpy(szExt, \"nhnt\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->flags & GF_EXPORT_NHML) {\n\t\t\tstrcpy(szExt, \"nhml\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\n\t\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\t\tif (!dumper->sample_num) {\n\n\t\t\t\text = gf_file_ext_start(args);\n\t\t\t\tif (ext) ext[0] = 0;\n\t\t\t\tif (sample_count>=1000) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%08d$\", NULL);\n\t\t\t\t} else if (sample_count) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%03d$\", NULL);\n\t\t\t\t} else {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num$\", NULL);\n\t\t\t\t}\n\t\t\t\text = gf_file_ext_start(dumper->out_name);\n\t\t\t\tif (ext) e |= gf_dynstrcat(&args, ext, NULL);\n\t\t\t}\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->trackID && strlen(szExt) ) {\n\t\t\tif (!no_ext && !gf_file_ext_start(dumper->out_name)) {\n\t\t\t\tif (args) gf_free(args);\n\t\t\t\targs=NULL;\n\t\t\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, \".\");\n\t\t\t} else {\n\t\t\t\te |= gf_dynstrcat(&args, \":ext=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t\t}\n\t\t} else if ((dumper->trackID || dumper->track_type) && use_dynext) {\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load arguments for output file dumper\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\tgf_fs_del(fsess);\n\t\t\treturn e;\n\t\t}\n\n\t\tfile_out = gf_fs_load_filter(fsess, args, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load output file dumper\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//raw sample frame, force loading filter generic write in frame mode\n\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\te = gf_dynstrcat(&args, \"writegen:frame\", NULL);\n\t\tif (dumper->sample_num) {\n\t\t\tsprintf(szSubArgs, \":sstart=%d:send=%d\", dumper->sample_num, dumper->sample_num);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHNT) {\n\t\tremux = gf_fs_load_filter(fsess, \"nhntw:exporter\", &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHNT write filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHML) {\n\t\te = gf_dynstrcat(&args, \"nhmlw:exporter:name=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\tif (dumper->flags & GF_EXPORT_NHML_FULL)\n\t\t\te |= gf_dynstrcat(&args, \":pckp\", NULL);\n\t\tif (dumper->dump_file) {\n\t\t\tsprintf(szSubArgs, \":nhmlonly:filep=%p\", dumper->dump_file);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHML write filter\\n\"));\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t} else if (!skip_write_filter) {\n\t\te = gf_dynstrcat(&args, \"writegen:exporter\", NULL);\n\t\t//extension has been forced, override ext at output of writegen\n\t\tif (ext_forced) {\n\t\t\te |= gf_dynstrcat(&args, \":#Extension=\", NULL);\n\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t}\n\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//force a reframer filter, connected to our input\n\te = gf_dynstrcat(&args, \"reframer:SID=1\", NULL);\n\tif (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"#PID=%d\", dumper->trackID);\n\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t}\n\te |= gf_dynstrcat(&args, \":exporter\", NULL);\n\tif (dumper->flags & GF_EXPORT_SVC_LAYER)\n\t\te |= gf_dynstrcat(&args, \":extract=layer\", NULL);\n\tif (dumper->flags & GF_EXPORT_WEBVTT_NOMERGE)\n\t\te |= gf_dynstrcat(&args, \":merge\", NULL);\n\n\treframer = gf_fs_load_filter(fsess, args, &e);\n\tif (!reframer || e) {\n\t\tgf_fs_del(fsess);\n\t\tif (args) gf_free(args);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load reframer filter\\n\"));\n\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//we already have the file loaded, directly load the mp4dmx filter with this file\n\tif (dumper->file) {\n\t\t//we want to expose every track\n\t\te = gf_dynstrcat(&args, \"mp4dmx:FID=1:noedit:alltk:allt\", NULL);\n\t\tif (!e) {\n\t\t\tsprintf(szSubArgs, \":mov=%p\", dumper->file);\n\t\t\te = gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\t\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_filter(fsess, args, &e);\n\n\t\tgf_free(args);\n\t\targs = NULL;\n\t} else {\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_source(fsess, dumper->in_name, \"FID=1:noedit:alltk:allt\", NULL, &e);\n\t}\n\n\tif (!src_filter || e) {\n\t\tgf_fs_del(fsess);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load filter for input file \\\"%s\\\": %s\\n\", dumper->in_name, gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\n\tif (dumper->track_type) {\n\t\tconst char *mtype = (dumper->track_type==1) ? \"video\" : \"audio\";\n\t\tif (dumper->trackID) {\n\t\t\tsprintf(szSubArgs, \"%s%d\", mtype, dumper->trackID);\n\t\t} else {\n\t\t\tsprintf(szSubArgs, \"%s\", mtype);\n\t\t}\n\t}\n\telse if (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"PID=%d\", dumper->trackID);\n\t}\n\tif (remux) {\n\t\tgf_filter_set_source(file_out, remux, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t\tgf_filter_set_source(remux, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t} else {\n\t\tgf_filter_set_source(file_out, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t}\n\n\te = gf_fs_run(fsess);\n\tif (e>GF_OK) e = GF_OK;\n\tif (!e) e = gf_fs_get_last_connect_error(fsess);\n\tif (!e) e = gf_fs_get_last_process_error(fsess);\n\n\tif (!e) {\n\t\tif (dumper->file)\n\t\t\tgf_fs_print_unused_args(fsess, NULL);\n\t\telse\n\t\t\tgf_fs_print_unused_args(fsess, \"alltk,allt,noedit\");\n\t}\n\tgf_fs_print_non_connected(fsess);\n\tif (dumper->print_stats_graph & 1) gf_fs_print_stats(fsess);\n\tif (dumper->print_stats_graph & 2) gf_fs_print_connections(fsess);\n\tgf_fs_del(fsess);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_media_export(GF_MediaExporter *dumper)\n{\n\tif (!dumper) return GF_BAD_PARAM;\n\tif (!dumper->out_name && !(dumper->flags & GF_EXPORT_PROBE_ONLY) && !dumper->dump_file) return GF_BAD_PARAM;\n\n\t//internal export not using filters\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (dumper->flags & GF_EXPORT_MP4) return gf_media_export_isom(dumper);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n#ifndef GPAC_DISABLE_VTT\n\telse if (dumper->flags & GF_EXPORT_WEBVTT_META) return gf_media_export_webvtt_metadata(dumper);\n#endif\n\telse if (dumper->flags & GF_EXPORT_SIX) return gf_media_export_six(dumper);\n\n\t//the following ones should be moved to muxing filters\n\telse if (dumper->flags & GF_EXPORT_SAF) return gf_media_export_saf(dumper);\n\n\t//the rest is handled by the generic exporter\n\treturn gf_media_export_filters(dumper);\n}\n\n#endif /*GPAC_DISABLE_MEDIA_EXPORT*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/mpegts.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\n#ifndef GPAC_DISABLE_AVILIB\n#include <gpac/internal/avilib.h>\n#endif\n\n#ifndef GPAC_DISABLE_OGG\n#include <gpac/internal/ogg.h>\n#endif\n\n#ifndef GPAC_DISABLE_VOBSUB\n#include <gpac/internal/vobsub.h>\n#endif\n\n#ifndef GPAC_DISABLE_ZLIB\n#include <zlib.h>\n#endif\n\nstatic GF_Err gf_export_message(GF_MediaExporter *dumper, GF_Err e, char *format, ...)\n{\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) return e;\n\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_AUTHOR, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {\n\t\tva_list args;\n\t\tchar szMsg[1024];\n\t\tva_start(args, format);\n\t\tvsnprintf(szMsg, 1024, format, args);\n\t\tva_end(args);\n\t\tGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_AUTHOR, (\"%s\\n\", szMsg) );\n\t}\n#endif\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n/*that's very very crude, we only support vorbis & theora in MP4 - this will need cleanup as soon as possible*/\nstatic GF_Err gf_dump_to_ogg(GF_MediaExporter *dumper, char *szName, u32 track)\n{\n#ifdef GPAC_DISABLE_OGG\n\treturn GF_NOT_SUPPORTED;\n#else\n\tFILE *out;\n\togg_stream_state os;\n\togg_packet op;\n\togg_page og;\n\tu32 count, i, di, theora_kgs, nb_i, nb_p;\n\tBool flush_first = GF_TRUE;\n\tGF_BitStream *bs;\n\tGF_ISOSample *samp;\n\tGF_ESD *esd = gf_isom_get_esd(dumper->file, track, 1);\n\n\n\tmemset(&os, 0, sizeof(ogg_stream_state));\n\tmemset(&og, 0, sizeof(ogg_page));\n\tmemset(&op, 0, sizeof(ogg_packet));\n\n\tif (gf_sys_is_test_mode()) {\n\t\togg_stream_init(&os, 1);\n\t} else {\n\t\tgf_rand_init(GF_TRUE);\n\t\togg_stream_init(&os, gf_rand());\n\t}\n\n\tout = szName ? gf_fopen(szName, \"wb\") : stdout;\n\tif (!out) return gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\n\ttheora_kgs = 0;\n\tbs = gf_bs_new(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, GF_BITSTREAM_READ);\n\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_OPUS) {\n\t\tGF_BitStream *bs_out;\n\t\tGF_OpusSpecificBox *dops = (GF_OpusSpecificBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_DOPS);\n\t\tdops->size = gf_bs_read_u32(bs);\n\t\tgf_bs_read_u32(bs);\n\t\tgf_isom_box_read((GF_Box *)dops, bs);\n\t\tbs_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(bs_out, \"OpusHead\", 8);\n\t\tgf_bs_write_u8(bs_out, 1);//version\n\t\tgf_bs_write_u8(bs_out, dops->OutputChannelCount);\n\t\tgf_bs_write_u16_le(bs_out, dops->PreSkip);\n\t\tgf_bs_write_u32_le(bs_out, dops->InputSampleRate);\n\t\tgf_bs_write_u16_le(bs_out, dops->OutputGain);\n\t\tgf_bs_write_u8(bs_out, dops->ChannelMappingFamily);\n\t\tif (dops->ChannelMappingFamily) {\n\t\t\tgf_bs_write_u8(bs_out, dops->StreamCount);\n\t\t\tgf_bs_write_u8(bs_out, dops->CoupledCount);\n\t\t\tgf_bs_write_data(bs, (char *) dops->ChannelMapping, dops->OutputChannelCount);\n\t\t}\n\t\tgf_isom_box_del((GF_Box*)dops);\n\n\t\tgf_bs_get_content(bs_out, &op.packet, &op.bytes);\n\t\tgf_bs_del(bs_out);\n\t\togg_stream_packetin(&os, &op);\n\t\tgf_free(op.packet);\n\t\top.packetno ++;\n\n\t} else {\n\t\twhile (gf_bs_available(bs)) {\n\t\t\top.bytes = gf_bs_read_u16(bs);\n\t\t\top.packet = (unsigned char*)gf_malloc(sizeof(char) * op.bytes);\n\t\t\tgf_bs_read_data(bs, (char*)op.packet, op.bytes);\n\t\t\togg_stream_packetin(&os, &op);\n\n\t\t\tif (flush_first) {\n\t\t\t\togg_stream_pageout(&os, &og);\n\t\t\t\tgf_fwrite(og.header, og.header_len, out);\n\t\t\t\tgf_fwrite(og.body, og.body_len, out);\n\t\t\t\tflush_first = 0;\n\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {\n\t\t\t\t\tu32 kff;\n\t\t\t\t\tGF_BitStream *vbs = gf_bs_new((char*)op.packet, op.bytes, GF_BITSTREAM_READ);\n\t\t\t\t\tgf_bs_skip_bytes(vbs, 40);\n\t\t\t\t\tgf_bs_read_int(vbs, 6); /* quality */\n\t\t\t\t\tkff = 1 << gf_bs_read_int(vbs, 5);\n\t\t\t\t\tgf_bs_del(vbs);\n\n\t\t\t\t\ttheora_kgs = 0;\n\t\t\t\t\tkff--;\n\t\t\t\t\twhile (kff) {\n\t\t\t\t\t\ttheora_kgs ++;\n\t\t\t\t\t\tkff >>= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_free(op.packet);\n\t\t\top.packetno ++;\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\tgf_odf_desc_del((GF_Descriptor *)esd);\n\n\twhile (ogg_stream_pageout(&os, &og)>0) {\n\t\tgf_fwrite(og.header, og.header_len, out);\n\t\tgf_fwrite(og.body, og.body_len, out);\n\t}\n\n\top.granulepos = -1;\n\n\tcount = gf_isom_get_sample_count(dumper->file, track);\n\n\tnb_i = nb_p = 0;\n\tsamp = gf_isom_get_sample(dumper->file, track, 1, &di);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ISOSample *next_samp = gf_isom_get_sample(dumper->file, track, i+2, &di);\n\t\tif (!samp) break;\n\t\top.bytes = samp->dataLength;\n\t\top.packet = (unsigned char*)samp->data;\n\t\top.packetno ++;\n\n\t\tif (theora_kgs) {\n\t\t\tif (samp->IsRAP) {\n\t\t\t\tif (i) nb_i+=nb_p+1;\n\t\t\t\tnb_p = 0;\n\t\t\t} else {\n\t\t\t\tnb_p++;\n\t\t\t}\n\t\t\top.granulepos = nb_i;\n\t\t\top.granulepos <<= theora_kgs;\n\t\t\top.granulepos |= nb_p;\n\t\t} else {\n\t\t\tif (next_samp) op.granulepos = next_samp->DTS;\n\t\t}\n\t\tif (!next_samp) op.e_o_s = 1;\n\n\t\togg_stream_packetin(&os, &op);\n\n\t\tgf_isom_sample_del(&samp);\n\t\tsamp = next_samp;\n\t\tnext_samp = NULL;\n\t\tgf_set_progress(\"OGG Export\", i+1, count);\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) break;\n\n\t\twhile (ogg_stream_pageout(&os, &og)>0) {\n\t\t\tgf_fwrite(og.header, og.header_len, out);\n\t\t\tgf_fwrite(og.body, og.body_len, out);\n\t\t}\n\t}\n\tif (samp) gf_isom_sample_del(&samp);\n\n\twhile (ogg_stream_flush(&os, &og)>0) {\n\t\tgf_fwrite(og.header, og.header_len, out);\n\t\tgf_fwrite(og.body, og.body_len, out);\n\t}\n\togg_stream_clear(&os);\n\tif (szName) gf_fclose(out);\n\treturn GF_OK;\n#endif\n}\n#endif\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nstatic GF_Err gf_dump_to_vobsub(GF_MediaExporter *dumper, char *szName, u32 track, char *dsi, u32 dsiSize)\n{\n#ifndef GPAC_DISABLE_VOBSUB\n\tFILE *fidx, *fsub;\n\tu32 width, height, i, count, di;\n\tGF_ISOSample *samp;\n\tchar *lang = NULL;\n\n\tif (!szName) {\n\t\tszName = gf_file_basename(gf_isom_get_filename(dumper->file));\n\t\tif (!szName) return GF_BAD_PARAM;\n\t}\n\t/* Check decoder specific information (palette) size - should be 64 */\n\tif (!dsi || (dsiSize != 64)) {\n\t\treturn gf_export_message(dumper, GF_CORRUPTED_DATA, \"Invalid decoder specific info size - must be 64 but is %d\", dsiSize);\n\t}\n\n\t/* Create an idx file */\n\tif (!gf_file_ext_start(szName)) {\n\t\tchar szPath[GF_MAX_PATH];\n\t\tstrcpy(szPath, szName);\n\t\tstrcat(szPath, \".idx\");\n\t\tfidx = gf_fopen(szPath, \"wb\");\n\t } else {\n\t\tfidx = gf_fopen(szName, \"wb\");\n\t}\n\tif (!fidx) {\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\t}\n\n\t/* Create a sub file */\n\tchar *ext = gf_file_ext_start(szName);\n\tif (ext && (!stricmp(ext, \".idx\") || !stricmp(ext, \".sub\")) ) {\n\t\text[0] = 0;\n\t}\n\tszName = strcat(szName, \".sub\");\n\tfsub = gf_fopen(szName, \"wb\");\n\tif (!fsub) {\n\t\tgf_fclose(fidx);\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\t}\n\n\t/* Retrieve original subpicture resolution */\n\tgf_isom_get_track_layout_info(dumper->file, track, &width, &height, NULL, NULL, NULL);\n\n\t/* Write header */\n\tgf_fputs(\"# VobSub index file, v7 (do not modify this line!)\\n#\\n\", fidx);\n\n\t/* Write original subpicture resolution */\n\tgf_fprintf(fidx, \"size: %ux%u\\n\", width, height);\n\n\t/* Write palette */\n\tgf_fputs(\"palette:\", fidx);\n\tfor (i = 0; i < 16; i++) {\n\t\ts32 y, u, v, r, g, b;\n\n\t\ty = (s32)(u8)dsi[(i<<2)+1] - 0x10;\n\t\tu = (s32)(u8)dsi[(i<<2)+3] - 0x80;\n\t\tv = (s32)(u8)dsi[(i<<2)+2] - 0x80;\n\t\tr = (298 * y           + 409 * v + 128) >> 8;\n\t\tg = (298 * y - 100 * u - 208 * v + 128) >> 8;\n\t\tb = (298 * y + 516 * u           + 128) >> 8;\n\n\t\tif (i) gf_fputc(',', fidx);\n\n#define CLIP(x) (((x) >= 0) ? (((x) < 256) ? (x) : 255) : 0)\n\t\tgf_fprintf(fidx, \" %02x%02x%02x\", CLIP(r), CLIP(g), CLIP(b));\n#undef CLIP\n\t}\n\tgf_fputc('\\n', fidx);\n\n\t/* Write some other useful values */\n\tgf_fputs(\"# ON: displays only forced subtitles, OFF: shows everything\\n\", fidx);\n\tgf_fputs(\"forced subs: OFF\\n\\n\", fidx);\n\n\t/* Write current language index */\n\tgf_fputs(\"# Language index in use\\nlangidx: 0\\n\", fidx);\n\n\t/* Write language header */\n\tgf_isom_get_media_language(dumper->file, track, &lang);\n\tgf_fprintf(fidx, \"id: %s, index: 0\\n\", vobsub_lang_id(lang));\n\tgf_free(lang);\n\n\t/* Retrieve sample count */\n\tcount = gf_isom_get_sample_count(dumper->file, track);\n\n\t/* Process samples (skip first - because it is special) */\n\tfor (i = 2; i <= count; i++)\n\t{\n\t\tu64 dts;\n\t\tu32 hh, mm, ss, ms;\n\n\t\tsamp = gf_isom_get_sample(dumper->file, track, i, &di);\n\t\tif (!samp) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdts = samp->DTS / 90;\n\t\tms  = (u32)(dts % 1000);\n\t\tdts = dts / 1000;\n\t\tss  = (u32)(dts % 60);\n\t\tdts = dts / 60;\n\t\tmm  = (u32)(dts % 60);\n\t\thh  = (u32)(dts / 60);\n\t\tgf_fprintf(fidx, \"timestamp: %02u:%02u:%02u:%03u, filepos: %09\"LLX_SUF\"\\n\", hh, mm, ss, ms, gf_ftell(fsub));\n\t\tif (vobsub_packetize_subpicture(fsub, samp->DTS, samp->data, samp->dataLength) != GF_OK) {\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tgf_fclose(fsub);\n\t\t\tgf_fclose(fidx);\n\t\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Unable packetize subpicture into file %s\\n\", szName);\n\t\t}\n\n\t\tgf_isom_sample_del(&samp);\n\t\tgf_set_progress(\"VobSub Export\", i + 1, count);\n\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Delete sample if any */\n\tif (samp) {\n\t\tgf_isom_sample_del(&samp);\n\t}\n\n\tgf_fclose(fsub);\n\tgf_fclose(fidx);\n\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n#endif // GPAC_DISABLE_AV_PARSERS\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic GF_Err gf_export_isom_copy_track(GF_MediaExporter *dumper, GF_ISOFile *infile, u32 inTrackNum, GF_ISOFile *outfile, Bool ResetDependencies, Bool AddToIOD)\n{\n\tGF_ESD *esd;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_ISOTrackID TrackID;\n\tu32 newTk, descIndex, i, ts, rate, pos, di, count, msubtype;\n\tu64 dur;\n\tGF_ISOSample *samp;\n\n\tif (!inTrackNum) {\n\t\tif (gf_isom_get_track_count(infile) != 1) return gf_export_message(dumper, GF_BAD_PARAM, \"Please specify trackID to export\");\n\t\tinTrackNum = 1;\n\t}\n\t//check the ID is available\n\tTrackID = gf_isom_get_track_id(infile, inTrackNum);\n\tnewTk = gf_isom_get_track_by_id(outfile, TrackID);\n\tif (newTk) TrackID = 0;\n\n\t//get the ESD and remove dependencies\n\tesd = NULL;\n\tmsubtype = gf_isom_get_media_subtype(infile, inTrackNum, 1);\n\n\tif (msubtype == GF_ISOM_SUBTYPE_MPEG4) {\n\t\tesd = gf_isom_get_esd(infile, inTrackNum, 1);\n\t\tif (esd && ResetDependencies) {\n\t\t\tesd->dependsOnESID = 0;\n\t\t\tesd->OCRESID = 0;\n\t\t}\n\t}\n\n\tnewTk = gf_isom_new_track(outfile, TrackID, gf_isom_get_media_type(infile, inTrackNum), gf_isom_get_media_timescale(infile, inTrackNum));\n\tgf_isom_set_track_enabled(outfile, newTk, GF_TRUE);\n\n\tif (gf_isom_has_keep_utc_times(infile)) {\n\t\tu64 cdate, mdate;\n\t\tgf_isom_get_track_creation_time(infile, inTrackNum, &cdate, &mdate);\n\t\tgf_isom_set_track_creation_time(outfile, newTk, cdate, mdate);\n\t}\n\n\tif (esd) {\n\t\tgf_isom_new_mpeg4_description(outfile, newTk, esd, NULL, NULL, &descIndex);\n\t\tif ((esd->decoderConfig->streamType == GF_STREAM_VISUAL) || (esd->decoderConfig->streamType == GF_STREAM_SCENE)) {\n\t\t\tu32 w, h;\n\t\t\tgf_isom_get_visual_info(infile, inTrackNum, 1, &w, &h);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t/*this is because so many files have reserved values of 320x240 from v1 ... */\n\t\t\tif (esd->decoderConfig->objectTypeIndication == GF_CODECID_MPEG4_PART2) {\n\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\tw = dsi.width;\n\t\t\t\th = dsi.height;\n\t\t\t}\n#endif\n\t\t\tgf_isom_set_visual_info(outfile, newTk, 1, w, h);\n\t\t}\n\t\telse if ((esd->decoderConfig->streamType == GF_STREAM_TEXT) && (esd->decoderConfig->objectTypeIndication == GF_CODECID_SUBPIC)) {\n\t\t\tu32 w, h;\n\t\t\ts32 trans_x, trans_y;\n\t\t\ts16 layer;\n\t\t\tgf_isom_get_track_layout_info(infile, inTrackNum, &w, &h, &trans_x, &trans_y, &layer);\n\t\t\tgf_isom_set_track_layout_info(outfile, newTk, w << 16, h << 16, trans_x, trans_y, layer);\n\t\t}\n\t\tesd->decoderConfig->avgBitrate = 0;\n\t\tesd->decoderConfig->maxBitrate = 0;\n\t} else {\n\t\tgf_isom_clone_sample_description(outfile, newTk, infile, inTrackNum, 1, NULL, NULL, &descIndex);\n\t}\n\n\tpos = 0;\n\trate = 0;\n\tts = gf_isom_get_media_timescale(infile, inTrackNum);\n\tcount = gf_isom_get_sample_count(infile, inTrackNum);\n\tfor (i=0; i<count; i++) {\n\t\tsamp = gf_isom_get_sample(infile, inTrackNum, i+1, &di);\n\t\tgf_isom_add_sample(outfile, newTk, descIndex, samp);\n\t\tif (esd) {\n\t\t\trate += samp->dataLength;\n\t\t\tesd->decoderConfig->avgBitrate += samp->dataLength;\n\t\t\tif (esd->decoderConfig->bufferSizeDB<samp->dataLength) esd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\tif (samp->DTS - pos > ts) {\n\t\t\t\tif (esd->decoderConfig->maxBitrate<rate) esd->decoderConfig->maxBitrate = rate;\n\t\t\t\trate = 0;\n\t\t\t\tpos = 0;\n\t\t\t}\n\t\t}\n\t\tgf_isom_sample_del(&samp);\n\t\tgf_set_progress(\"ISO File Export\", i, count);\n\t}\n\tgf_set_progress(\"ISO File Export\", count, count);\n\n\tif (msubtype == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n\t\tesd = gf_isom_get_esd(infile, inTrackNum, 1);\n\t} else if ((msubtype == GF_ISOM_SUBTYPE_AVC_H264)\n\t           || (msubtype == GF_ISOM_SUBTYPE_AVC2_H264)\n\t           || (msubtype == GF_ISOM_SUBTYPE_AVC3_H264)\n\t           || (msubtype == GF_ISOM_SUBTYPE_AVC4_H264)\n\t          ) {\n\t\treturn gf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, 0x0F);\n\t}\n\t/*likely 3gp or any non-MPEG-4 isomedia file*/\n\telse if (!esd) return gf_isom_remove_root_od(outfile);\n\n\tdur = gf_isom_get_media_duration(outfile, newTk);\n\tif (!dur) dur = ts;\n\tesd->decoderConfig->maxBitrate *= 8;\n\tesd->decoderConfig->avgBitrate = (u32) (esd->decoderConfig->avgBitrate * 8 * ts / dur);\n\tgf_isom_change_mpeg4_description(outfile, newTk, 1, esd);\n\n\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(infile);\n\tswitch (esd->decoderConfig->streamType) {\n\tcase GF_STREAM_SCENE:\n\t\tif (iod && (iod->tag==GF_ODF_IOD_TAG)) {\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_SCENE, iod->scene_profileAndLevel);\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_GRAPHICS, iod->graphics_profileAndLevel);\n\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n\t\t\tgf_export_message(dumper, GF_OK, \"Warning: Scene PLs not found in original MP4 - defaulting to No Profile Specified\");\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_SCENE, 0xFE);\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_GRAPHICS, 0xFE);\n\t\t}\n\t\tbreak;\n\tcase GF_STREAM_VISUAL:\n\t\tif (iod && (iod->tag==GF_ODF_IOD_TAG)) {\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, iod->visual_profileAndLevel);\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, dsi.VideoPL);\n\t\t}\n#endif\n\t\telse {\n\t\t\tgf_export_message(dumper, GF_OK, \"Warning: Visual PLs not found in original MP4 - defaulting to No Profile Specified\");\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, 0xFE);\n\t\t}\n\t\tbreak;\n\tcase GF_STREAM_AUDIO:\n\t\tif (iod && (iod->tag==GF_ODF_IOD_TAG)) {\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_AUDIO, iod->audio_profileAndLevel);\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) {\n\t\t\tGF_M4ADecSpecInfo cfg;\n\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &cfg);\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_AUDIO, cfg.audioPL);\n\t\t}\n#endif\n\t\telse {\n\t\t\tgf_export_message(dumper, GF_OK, \"Warning: Audio PLs not found in original MP4 - defaulting to No Profile Specified\");\n\t\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_AUDIO, 0xFE);\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tif (iod) gf_odf_desc_del((GF_Descriptor *) iod);\n\tgf_odf_desc_del((GF_Descriptor *)esd);\n\n\tif (AddToIOD) gf_isom_add_track_to_root_od(outfile, newTk);\n\n\treturn GF_OK;\n}\n\n\nGF_Err gf_media_export_isom(GF_MediaExporter *dumper)\n{\n\tGF_ISOFile *outfile;\n\tGF_Err e;\n\tBool add_to_iod, is_stdout;\n\tchar szName[1000];\n\tu32 track;\n\tGF_ISOOpenMode mode;\n\n\tif (!(track = gf_isom_get_track_by_id(dumper->file, dumper->trackID))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"Wrong track ID %d for file %s \\n\", dumper->trackID, gf_isom_get_filename(dumper->file)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (gf_isom_get_media_type(dumper->file, dumper->trackID)==GF_ISOM_MEDIA_OD) {\n\t\treturn gf_export_message(dumper, GF_BAD_PARAM, \"Cannot extract OD track, result is  meaningless\");\n\t}\n\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) {\n\t\tdumper->flags |= GF_EXPORT_MERGE;\n\t\treturn GF_OK;\n\t}\n\tif (dumper->out_name && gf_file_ext_start(dumper->out_name)) {\n\t\tstrcpy(szName, dumper->out_name);\n\t} else {\n\t\tchar *ext = (char *) gf_isom_get_filename(dumper->file);\n\t\tif (ext) ext = gf_file_ext_start(ext);\n\t\tsprintf(szName, \"%s%s\", dumper->out_name, ext ? ext : \".mp4\");\n\t}\n\tis_stdout = (dumper->out_name && !strcmp(dumper->out_name, \"std\")) ? 1 : 0;\n\tadd_to_iod = 1;\n\tmode = GF_ISOM_WRITE_EDIT;\n\tif (!is_stdout && (dumper->flags & GF_EXPORT_MERGE)) {\n\t\tFILE *t = gf_fopen(szName, \"rb\");\n\t\tif (t) {\n\t\t\tadd_to_iod = 0;\n\t\t\tmode = GF_ISOM_OPEN_EDIT;\n\t\t\tgf_fclose(t);\n\t\t}\n\t}\n\toutfile = gf_isom_open(is_stdout ? \"std\" : szName, mode, NULL);\n\n\tif (mode == GF_ISOM_WRITE_EDIT) {\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_AUDIO, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_VISUAL, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_GRAPHICS, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_SCENE, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_OD, 0xFF);\n\t\tgf_isom_set_pl_indication(outfile, GF_ISOM_PL_MPEGJ, 0xFF);\n\t}\n\tif (gf_isom_has_keep_utc_times(dumper->file)) {\n\t\tu64 cdate, mdate;\n\t\tgf_isom_get_creation_time(dumper->file, &cdate, &mdate);\n\t\tgf_isom_set_creation_time(outfile, cdate, mdate);\n\t}\n\n\te = gf_export_isom_copy_track(dumper, dumper->file, track, outfile, 1, add_to_iod);\n\tif (!add_to_iod) {\n\t\tu32 i;\n\t\tfor (i=0; i<gf_isom_get_track_count(outfile); i++) {\n\t\t\tgf_isom_remove_track_from_root_od(outfile, i+1);\n\t\t}\n\t}\n\n\tif (gf_isom_has_keep_utc_times(dumper->file))\n\t\tgf_isom_keep_utc_times(outfile, GF_TRUE);\n\n\tif (e) gf_isom_delete(outfile);\n\telse gf_isom_close(outfile);\n\n\treturn e;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* Required for base64 encoding of DecoderSpecificInfo */\n#include <gpac/base_coding.h>\n\n#ifndef GPAC_DISABLE_VTT\n\n/* Required for timestamp generation */\n#include <gpac/webvtt.h>\n\nGF_Err gf_media_export_webvtt_metadata(GF_MediaExporter *dumper)\n{\n\tGF_ESD *esd;\n\tchar szName[1000], szMedia[1000];\n\tFILE *med, *vtt;\n\tu32 w, h;\n\tu32 track, i, di, count, pos;\n\tu32 mtype, mstype;\n\tBool isText;\n\tchar *mime = NULL;\n\tBool useBase64 = GF_FALSE;\n\tu32 headerLength = 0;\n\n\tif (!(track = gf_isom_get_track_by_id(dumper->file, dumper->trackID))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"Wrong track ID %d for file %s \\n\", dumper->trackID, gf_isom_get_filename(dumper->file)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (!track) return gf_export_message(dumper, GF_BAD_PARAM, \"Invalid track ID %d\", dumper->trackID);\n\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) {\n\t\treturn GF_OK;\n\t}\n\tesd = gf_isom_get_esd(dumper->file, track, 1);\n\tmed = NULL;\n\tif (dumper->flags & GF_EXPORT_WEBVTT_META_EMBEDDED) {\n\t} else {\n\t\tsprintf(szMedia, \"%s.media\", dumper->out_name);\n\t\tmed = gf_fopen(szMedia, \"wb\");\n\t\tif (!med) {\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szMedia);\n\t\t}\n\t}\n\n\tsprintf(szName, \"%s.vtt\", dumper->out_name);\n\tvtt = gf_fopen(szName, \"wt\");\n\tif (!vtt) {\n\t\tgf_fclose(med);\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\t}\n\n\tmtype = gf_isom_get_media_type(dumper->file, track);\n\tif (mtype==GF_ISOM_MEDIA_TEXT || mtype == GF_ISOM_MEDIA_MPEG_SUBT || mtype == GF_ISOM_MEDIA_SUBT) {\n\t\tisText = GF_TRUE;\n\t} else {\n\t\tisText = GF_FALSE;\n\t}\n\tmstype = gf_isom_get_media_subtype(dumper->file, track, 1);\n\n\t/*write header*/\n\tgf_fprintf(vtt, \"WEBVTT Metadata track generated by GPAC MP4Box %s\\n\", gf_sys_is_test_mode() ? \"\" : gf_gpac_version());\n\n\tgf_fprintf(vtt, \"kind:metadata\\n\");\n\t{\n\t\tchar *lang;\n\t\tgf_isom_get_media_language(dumper->file, track, &lang);\n\t\tgf_fprintf(vtt, \"language:%s\\n\", lang);\n\t\tgf_free(lang);\n\t}\n\t{\n\t\tconst char *handler;\n\t\tgf_isom_get_handler_name(dumper->file, track, &handler);\n\t\tgf_fprintf(vtt, \"label: %s\\n\", handler);\n\t}\n\tif (gf_isom_is_track_in_root_od(dumper->file, track)) gf_fprintf(vtt, \"inRootOD: yes\\n\");\n\tgf_fprintf(vtt, \"trackID: %d\\n\", dumper->trackID);\n\tif (med) {\n\t\tgf_fprintf(vtt, \"baseMediaFile: %s\\n\", gf_file_basename(szMedia));\n\t}\n\tif (esd) {\n\t\t/* TODO: export the MPEG-4 Stream type only if it is not a GPAC internal value */\n\t\tgf_fprintf(vtt, \"MPEG-4-streamType: %d\\n\", esd->decoderConfig->streamType);\n\t\t/* TODO: export the MPEG-4 Object Type Indication only if it is not a GPAC internal value */\n\t\tgf_fprintf(vtt, \"MPEG-4-objectTypeIndication: %d\\n\", esd->decoderConfig->objectTypeIndication);\n\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tgf_isom_get_visual_info(dumper->file, track, 1, &w, &h);\n\t\t\tgf_fprintf(vtt, \"width:%d\\n\", w);\n\t\t\tgf_fprintf(vtt, \"height:%d\\n\", h);\n\t\t}\n\t\telse if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\tu32 sr, nb_ch, bps;\n\t\t\tgf_isom_get_audio_info(dumper->file, track, 1, &sr, &nb_ch, &bps);\n\t\t\tgf_fprintf(vtt, \"sampleRate: %d\\n\", sr);\n\t\t\tgf_fprintf(vtt, \"numChannels: %d\\n\", nb_ch);\n\t\t} else if (isText) {\n\t\t\ts32 tx, ty;\n\t\t\ts16 layer;\n\t\t\tgf_isom_get_track_layout_info(dumper->file, track, &w, &h, &tx, &ty, &layer);\n\t\t\tgf_fprintf(vtt, \"width:%d\\n\", w);\n\t\t\tgf_fprintf(vtt, \"height:%d\\n\", h);\n\t\t\tif (tx || ty) gf_fprintf(vtt, \"translation:%d,%d\\n\", tx, ty);\n\t\t\tif (layer) gf_fprintf(vtt, \"layer:%d\\n\", layer);\n\t\t}\n\t\tif (esd->decoderConfig->decoderSpecificInfo  && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tif (isText) {\n\t\t\t\tif (mstype == GF_ISOM_SUBTYPE_WVTT) {\n\t\t\t\t\t/* Warning: Just use -raw export */\n\t\t\t\t\tmime = \"text/vtt\";\n\t\t\t\t} else if (mstype == GF_ISOM_SUBTYPE_STXT) {\n\t\t\t\t\t/* TODO: find the mime type from the ESD, assume SVG for now */\n\t\t\t\t\tmime = \"image/svg+xml\";\n\t\t\t\t} else if (mstype == GF_ISOM_SUBTYPE_STPP) {\n\t\t\t\t\t/* TODO: find the mime type from the ESD, assume TTML for now */\n\t\t\t\t\tmime = \"application/ttml+xml\";\n\t\t\t\t}\n\t\t\t\tif (dumper->flags & GF_EXPORT_WEBVTT_META_EMBEDDED) {\n\t\t\t\t\tif (mstype == GF_ISOM_SUBTYPE_STXT) {\n\t\t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo->dataLength) {\n\t\t\t\t\t\t\tgf_fprintf(vtt, \"text-header: \\n\");\n\t\t\t\t\t\t\tgf_webvtt_dump_header_boxed(vtt, esd->decoderConfig->decoderSpecificInfo->data+4, esd->decoderConfig->decoderSpecificInfo->dataLength, &headerLength);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_webvtt_dump_header_boxed(med, esd->decoderConfig->decoderSpecificInfo->data+4, esd->decoderConfig->decoderSpecificInfo->dataLength, &headerLength);\n\t\t\t\t\tgf_fprintf(vtt, \"text-header-length: %d\\n\", headerLength);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchar b64[200];\n\t\t\t\tu32 size = gf_base64_encode(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, b64, 200);\n\t\t\t\tuseBase64 = GF_TRUE;\n\t\t\t\tif (size != (u32)-1 && size != 0) {\n\t\t\t\t\tb64[size] = 0;\n\t\t\t\t\tgf_fprintf(vtt, \"MPEG-4-DecoderSpecificInfo: %s\\n\", b64);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t} else {\n\t\tGF_GenericSampleDescription *sdesc = gf_isom_get_generic_sample_description(dumper->file, track, 1);\n\t\tgf_fprintf(vtt, \"mediaType: %s\\n\", gf_4cc_to_str(mtype));\n\t\tgf_fprintf(vtt, \"mediaSubType: %s\\n\", gf_4cc_to_str(mstype ));\n\t\tif (sdesc) {\n\t\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\t\t\tgf_fprintf(vtt, \"codecVendor: %s\\n\", gf_4cc_to_str(sdesc->vendor_code));\n\t\t\t\tgf_fprintf(vtt, \"codecVersion: %d\\n\", sdesc->version);\n\t\t\t\tgf_fprintf(vtt, \"codecRevision: %d\\n\", sdesc->revision);\n\t\t\t\tgf_fprintf(vtt, \"width: %d\\n\", sdesc->width);\n\t\t\t\tgf_fprintf(vtt, \"height: %d\\n\", sdesc->height);\n\t\t\t\tgf_fprintf(vtt, \"compressorName: %s\\n\", sdesc->compressor_name);\n\t\t\t\tgf_fprintf(vtt, \"temporalQuality: %d\\n\", sdesc->temporal_quality);\n\t\t\t\tgf_fprintf(vtt, \"spatialQuality: %d\\n\", sdesc->spatial_quality);\n\t\t\t\tgf_fprintf(vtt, \"horizontalResolution: %d\\n\", sdesc->h_res);\n\t\t\t\tgf_fprintf(vtt, \"verticalResolution: %d\\n\", sdesc->v_res);\n\t\t\t\tgf_fprintf(vtt, \"bitDepth: %d\\n\", sdesc->depth);\n\t\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n\t\t\t\tgf_fprintf(vtt, \"codecVendor: %s\\n\", gf_4cc_to_str(sdesc->vendor_code));\n\t\t\t\tgf_fprintf(vtt, \"codecVersion: %d\\n\", sdesc->version);\n\t\t\t\tgf_fprintf(vtt, \"codecRevision: %d\\n\", sdesc->revision);\n\t\t\t\tgf_fprintf(vtt, \"sampleRate: %d\\n\", sdesc->samplerate);\n\t\t\t\tgf_fprintf(vtt, \"numChannels: %d\\n\", sdesc->nb_channels);\n\t\t\t\tgf_fprintf(vtt, \"bitsPerSample: %d\\n\", sdesc->bits_per_sample);\n\t\t\t}\n\t\t\tif (sdesc->extension_buf) {\n\t\t\t\tchar b64[200];\n\t\t\t\tu32 size = gf_base64_encode(sdesc->extension_buf, sdesc->extension_buf_size, b64, 200);\n\t\t\t\tuseBase64 = GF_TRUE;\n\t\t\t\tif (size != (u32)-1) {\n\t\t\t\t\tb64[size] = 0;\n\t\t\t\t\tgf_fprintf(vtt, \"specificInfo: %s\\n\", b64);\n\t\t\t\t\tgf_free(sdesc->extension_buf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_free(sdesc);\n\t\t}\n\t}\n\tgf_fprintf(vtt, \"inBandMetadataTrackDispatchType: %s\\n\", (mime ? mime : (isText? \"text/plain\" : \"application/octet-stream\")));\n\tif (useBase64) gf_fprintf(vtt, \"encoding: base64\\n\");\n\n\tgf_fprintf(vtt, \"\\n\");\n\n\tpos = 0;\n\tcount = gf_isom_get_sample_count(dumper->file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ISOSample *samp = gf_isom_get_sample(dumper->file, track, i+1, &di);\n\t\tif (!samp) break;\n\n\t\t{\n\t\t\tGF_WebVTTTimestamp start, end;\n\t\t\tu64 dur = gf_isom_get_sample_duration(dumper->file, track, i+1);\n\t\t\tgf_webvtt_timestamp_set(&start, samp->DTS);\n\t\t\tgf_webvtt_timestamp_set(&end, samp->DTS+dur);\n\t\t\tgf_webvtt_timestamp_dump(&start, vtt, GF_TRUE);\n\t\t\tgf_fprintf(vtt, \" --> \");\n\t\t\tgf_webvtt_timestamp_dump(&end, vtt, GF_TRUE);\n\t\t\tgf_fprintf(vtt, \" \");\n\t\t\tif (med) {\n\t\t\t\tgf_fprintf(vtt, \"mediaOffset:%d \", pos+headerLength);\n\t\t\t\tgf_fprintf(vtt, \"dataLength:%d \", samp->dataLength);\n\t\t\t}\n\t\t\tif (samp->CTS_Offset) gf_fprintf(vtt, \"CTS: \"LLD\"\", samp->DTS+samp->CTS_Offset);\n\t\t\tif (samp->IsRAP==RAP) gf_fprintf(vtt, \"isRAP:true \");\n\t\t\telse if (samp->IsRAP==RAP_REDUNDANT) gf_fprintf(vtt, \"isSyncShadow: true \");\n\t\t\telse gf_fprintf(vtt, \"isRAP:false \");\n\t\t\tgf_fprintf(vtt, \"\\n\");\n\t\t}\n\t\tif (med) {\n\t\t\tgf_fwrite(samp->data, samp->dataLength, med);\n\t\t} else if (dumper->flags & GF_EXPORT_WEBVTT_META_EMBEDDED) {\n\t\t\tif (isText) {\n\t\t\t\tsamp->data = (char *)gf_realloc(samp->data, samp->dataLength+1);\n\t\t\t\tsamp->data[samp->dataLength] = 0;\n\t\t\t\tgf_fprintf(vtt, \"%s\\n\", samp->data);\n\t\t\t} else {\n\t\t\t\tu32 b64_size;\n\t\t\t\tchar *b64;\n\t\t\t\tb64 = (char *)gf_malloc(samp->dataLength*3);\n\t\t\t\tb64_size = gf_base64_encode(samp->data, samp->dataLength, b64, samp->dataLength*3);\n\t\t\t\tif (b64_size != (u32)-1) {\n\t\t\t\t\tb64[b64_size] = 0;\n\t\t\t\t\tgf_fprintf(vtt, \"%s\\n\", b64);\n\t\t\t\t}\n\t\t\t\tgf_free(b64);\n\t\t\t}\n\t\t}\n\t\tgf_fprintf(vtt, \"\\n\");\n\n\t\tpos += samp->dataLength;\n\t\tgf_isom_sample_del(&samp);\n\t\tgf_set_progress(\"WebVTT metadata Export\", i+1, count);\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) break;\n\t}\n\tif (med) gf_fclose(med);\n\tgf_fclose(vtt);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\n/* Experimental Streaming Instructions XML export */\nGF_Err gf_media_export_six(GF_MediaExporter *dumper)\n{\n\tGF_ESD *esd;\n\tchar szName[1000], szMedia[1000];\n\tFILE *media, *six;\n\tu32 track, i, di, count, pos, header_size;\n\t//u32 mtype;\n#if !defined(GPAC_DISABLE_TTXT) && !defined(GPAC_DISABLE_VTT)\n\tu32 mstype;\n#endif\n\tconst char *szRootName;\n\t//Bool isText;\n\n\tif (!(track = gf_isom_get_track_by_id(dumper->file, dumper->trackID))) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"Wrong track ID %d for file %s \\n\", dumper->trackID, gf_isom_get_filename(dumper->file)));\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (!track) return gf_export_message(dumper, GF_BAD_PARAM, \"Invalid track ID %d\", dumper->trackID);\n\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) {\n\t\tdumper->flags |= GF_EXPORT_NHML_FULL;\n\t\treturn GF_OK;\n\t}\n\tesd = gf_isom_get_esd(dumper->file, track, 1);\n\n\tsprintf(szMedia, \"%s.media\", dumper->out_name);\n\tmedia = gf_fopen(szMedia, \"wb\");\n\tif (!media) {\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szMedia);\n\t}\n\n\tsprintf(szName, \"%s.six\", dumper->out_name);\n\tszRootName = \"stream\";\n\n\tsix = gf_fopen(szName, \"wt\");\n\tif (!six) {\n\t\tgf_fclose(media);\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\treturn gf_export_message(dumper, GF_IO_ERR, \"Error opening %s for writing - check disk access & permissions\", szName);\n\t}\n\t/*\n\t\tmtype = gf_isom_get_media_type(dumper->file, track);\n\t\tif (mtype==GF_ISOM_MEDIA_TEXT || mtype == GF_ISOM_MEDIA_SUBM || mtype == GF_ISOM_MEDIA_SUBT) {\n\t\t\tisText = GF_TRUE;\n\t\t} else {\n\t\t\tisText = GF_FALSE;\n\t\t}\n\t*/\n#if !defined(GPAC_DISABLE_TTXT) && !defined(GPAC_DISABLE_VTT)\n\tmstype = gf_isom_get_media_subtype(dumper->file, track, 1);\n#endif\n\n\t/*write header*/\n\tgf_fprintf(six, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n\tgf_fprintf(six, \"<%s timescale=\\\"%d\\\" \", szRootName, gf_isom_get_media_timescale(dumper->file, track) );\n\tgf_fprintf(six, \"file=\\\"%s\\\" \", szMedia);\n\tgf_fprintf(six, \">\\n\");\n\theader_size = 0;\n\tif (esd) {\n\t\tif (esd->decoderConfig->decoderSpecificInfo  && esd->decoderConfig->decoderSpecificInfo->data) {\n#if !defined(GPAC_DISABLE_TTXT) && !defined(GPAC_DISABLE_VTT)\n\t\t\tif (mstype == GF_ISOM_SUBTYPE_WVTT || mstype == GF_ISOM_SUBTYPE_STXT) {\n\t\t\t\tgf_webvtt_dump_header_boxed(media,\n\t\t\t\t                            esd->decoderConfig->decoderSpecificInfo->data+4,\n\t\t\t\t                            esd->decoderConfig->decoderSpecificInfo->dataLength,\n\t\t\t\t                            &header_size);\n\t\t\t} else\n#endif\n\t\t\t{\n\t\t\t\tgf_fwrite(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, media);\n\t\t\t\theader_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t} else {\n\t\tGF_GenericSampleDescription *sdesc = gf_isom_get_generic_sample_description(dumper->file, track, 1);\n\t\tif (sdesc) {\n\t\t\theader_size = sdesc->extension_buf_size;\n\t\t\tgf_free(sdesc);\n\t\t}\n\t}\n\tgf_fprintf(six, \"<header range-begin=\\\"0\\\" range-end=\\\"%d\\\"/>\\n\", header_size-1);\n\n\tpos = header_size;\n\tcount = gf_isom_get_sample_count(dumper->file, track);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ISOSample *samp = gf_isom_get_sample(dumper->file, track, i+1, &di);\n\t\tif (!samp) break;\n\n\t\tif (media) {\n\t\t\tgf_fwrite(samp->data, samp->dataLength, media);\n\t\t}\n\n\t\tgf_fprintf(six, \"<unit time=\\\"\"LLU\"\\\" \", samp->DTS);\n\t\tif (samp->IsRAP==RAP) gf_fprintf(six, \"rap=\\\"1\\\" \");\n\t\telse if (samp->IsRAP==RAP_NO) gf_fprintf(six, \"rap=\\\"0\\\" \");\n\t\tgf_fprintf(six, \"range-begin=\\\"%d\\\" \", pos);\n\t\tgf_fprintf(six, \"range-end=\\\"%d\\\" \", pos+samp->dataLength-1);\n\t\tgf_fprintf(six, \"/>\\n\");\n\n\t\tpos += samp->dataLength;\n\t\tgf_isom_sample_del(&samp);\n\t\tgf_set_progress(\"SIX Export\", i+1, count);\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) break;\n\t}\n\tgf_fprintf(six, \"</%s>\\n\", szRootName);\n\tif (media) gf_fclose(media);\n\tgf_fclose(six);\n\treturn GF_OK;\n\n}\n\ntypedef struct\n{\n\tu32 track_num, stream_id, last_sample, nb_samp;\n} SAFInfo;\n\nGF_Err gf_media_export_saf(GF_MediaExporter *dumper)\n{\n#ifndef GPAC_DISABLE_SAF\n\tu32 count, i, s_count, di, tot_samp, samp_done;\n\tchar out_file[GF_MAX_PATH];\n\tGF_SAFMuxer *mux;\n\tu8 *data;\n\tu32 size;\n\tBool is_stdout = 0;\n\tFILE *saf_f;\n\tSAFInfo safs[1024];\n\n\tif (dumper->flags & GF_EXPORT_PROBE_ONLY) return GF_OK;\n\n\ts_count = tot_samp = 0;\n\n\tmux = gf_saf_mux_new();\n\tcount = gf_isom_get_track_count(dumper->file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 time_scale, mtype, stream_id;\n\t\tGF_ESD *esd;\n\t\tmtype = gf_isom_get_media_type(dumper->file, i+1);\n\t\tif (mtype==GF_ISOM_MEDIA_OD) continue;\n\t\tif (mtype==GF_ISOM_MEDIA_HINT) continue;\n\n\t\ttime_scale = gf_isom_get_media_timescale(dumper->file, i+1);\n\t\tesd = gf_isom_get_esd(dumper->file, i+1, 1);\n\t\tif (esd) {\n\t\t\tstream_id = gf_isom_find_od_id_for_track(dumper->file, i+1);\n\t\t\tif (!stream_id) stream_id = esd->ESID;\n\n\t\t\t/*translate OD IDs to ESIDs !!*/\n\t\t\tif (esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\tgf_saf_mux_stream_add(mux, stream_id, time_scale, esd->decoderConfig->bufferSizeDB, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, NULL, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, esd->URLString);\n\t\t\t} else {\n\t\t\t\tgf_saf_mux_stream_add(mux, stream_id, time_scale, esd->decoderConfig->bufferSizeDB, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, NULL, NULL, 0, esd->URLString);\n\t\t\t}\n\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t} else {\n\t\t\tchar *mime = NULL;\n\t\t\tswitch (gf_isom_get_media_subtype(dumper->file, i+1, 1)) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tmime = \"video/h263\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\t\tmime = \"audio/amr\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tmime = \"audio/amr-wb\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tmime = \"audio/evrc\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tmime = \"audio/qcelp\";\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tmime = \"audio/smv\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!mime) continue;\n\t\t\tstream_id = gf_isom_get_track_id(dumper->file, i+1);\n\t\t\tgf_saf_mux_stream_add(mux, stream_id, time_scale, 0, 0xFF, 0xFF, mime, NULL, 0, NULL);\n\t\t}\n\n\t\tsafs[s_count].track_num = i+1;\n\t\tsafs[s_count].stream_id = stream_id;\n\t\tsafs[s_count].nb_samp = gf_isom_get_sample_count(dumper->file, i+1);\n\t\tsafs[s_count].last_sample = 0;\n\n\t\ttot_samp += safs[s_count].nb_samp;\n\n\t\ts_count++;\n\t}\n\n\tif (!s_count) {\n\t\tgf_export_message(dumper, GF_OK, \"No tracks available for SAF muxing\");\n\t\tgf_saf_mux_del(mux);\n\t\treturn GF_OK;\n\t}\n\tgf_export_message(dumper, GF_OK, \"SAF: Multiplexing %d tracks\", s_count);\n\n\tif (dumper->out_name && !strcmp(dumper->out_name, \"std\"))\n\t\tis_stdout = 1;\n\tstrcpy(out_file, dumper->out_name ? dumper->out_name : \"\");\n\tstrcat(out_file, \".saf\");\n\tsaf_f = is_stdout ? stdout : gf_fopen(out_file, \"wb\");\n\n\tsamp_done = 0;\n\twhile (samp_done<tot_samp) {\n\t\tfor (i=0; i<s_count; i++) {\n\t\t\tGF_ISOSample *samp;\n\t\t\tif (safs[i].last_sample==safs[i].nb_samp) continue;\n\t\t\tsamp = gf_isom_get_sample(dumper->file, safs[i].track_num, safs[i].last_sample + 1, &di);\n\t\t\tgf_saf_mux_add_au(mux, safs[i].stream_id, (u32) (samp->DTS+samp->CTS_Offset), samp->data, samp->dataLength, (samp->IsRAP==RAP) ? 1 : 0);\n\t\t\t/*data is kept by muxer!!*/\n\t\t\tgf_free(samp);\n\t\t\tsafs[i].last_sample++;\n\t\t\tsamp_done ++;\n\t\t}\n\t\twhile (1) {\n\t\t\tgf_saf_mux_for_time(mux, (u32) -1, 0, &data, &size);\n\t\t\tif (!data) break;\n\t\t\tgf_fwrite(data, size, saf_f);\n\t\t\tgf_free(data);\n\t\t}\n\t\tgf_set_progress(\"SAF Export\", samp_done, tot_samp);\n\t\tif (dumper->flags & GF_EXPORT_DO_ABORT) break;\n\t}\n\tgf_saf_mux_for_time(mux, (u32) -1, 1, &data, &size);\n\tif (data) {\n\t\tgf_fwrite(data, size, saf_f);\n\t\tgf_free(data);\n\t}\n\tif (!is_stdout)\n\t\tgf_fclose(saf_f);\n\n\tgf_saf_mux_del(mux);\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\nstatic GF_Err gf_media_export_filters(GF_MediaExporter *dumper)\n{\n\tchar *args, szSubArgs[1024], szExt[30];\n\tGF_Filter *file_out, *reframer, *remux=NULL, *src_filter;\n\tGF_FilterSession *fsess;\n\tGF_Err e = GF_OK;\n\tu32 codec_id=0;\n\tu32 sample_count=0;\n\tBool skip_write_filter = GF_FALSE;\n\tBool ext_forced = GF_FALSE;\n\tBool use_dynext = GF_FALSE;\n\n\targs = NULL;\n\tstrcpy(szExt, \"\");\n\tif (dumper->trackID && dumper->file) {\n\t\tu32 msubtype = 0;\n\t\tu32 mtype = 0;\n\t\tu32 afmt = 0;\n\t\tGF_PixelFormat pfmt = 0;\n\t\tGF_ESD *esd;\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tu32 track_num = gf_isom_get_track_by_id(dumper->file, dumper->trackID);\n\t\tif (!track_num) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] No tracks with ID %d in file\\n\", dumper->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tesd = gf_media_map_esd(dumper->file, track_num, 0);\n\t\tsample_count = gf_isom_get_sample_count(dumper->file, dumper->trackID);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tif (esd->decoderConfig->objectTypeIndication<GF_CODECID_LAST_MPEG4_MAPPING) {\n\t\t\t\tcodec_id = gf_codecid_from_oti(esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (codec_id==GF_CODECID_AAC_MPEG4)) {\n\t\t\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &acfg);\n\t\t\t\t\tif (acfg.base_object_type == GF_M4A_USAC)\n\t\t\t\t\t\tcodec_id = GF_CODECID_USAC;\n\t\t\t\t}\n#endif\n\t\t\t} else {\n\t\t\t\tcodec_id = esd->decoderConfig->objectTypeIndication;\n\t\t\t}\n\t\t}\n\t\tif (!codec_id) {\n\t\t\tmsubtype = gf_isom_get_media_subtype(dumper->file, track_num, 1);\n\t\t\tcodec_id = gf_codec_id_from_isobmf(msubtype);\n\t\t}\n\t\tmtype = gf_isom_get_media_type(dumper->file, track_num);\n\t\tif (!codec_id) {\n\t\t\tpfmt = gf_pixel_fmt_from_qt_type(msubtype);\n\t\t\tif (pfmt) codec_id = GF_CODECID_RAW;\n\t\t}\n\n\t\tif (!codec_id) {\n\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\text_forced = GF_TRUE;\n\t\t} else if (codec_id==GF_CODECID_RAW) {\n\t\t\tswitch (mtype) {\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tif (pfmt)\n\t\t\t\t\tstrcpy(szExt, gf_pixel_fmt_sname(pfmt));\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\t\tafmt = gf_audio_fmt_from_isobmf(msubtype);\n\t\t\t\tif (afmt)\n\t\t\t\t\tstrcpy(szExt, gf_audio_fmt_name(afmt));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstrcpy(szExt, gf_4cc_to_str(msubtype));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *sname = gf_codecid_file_ext(codec_id);\n\t\t\tif (export_ext && strstr(sname, export_ext+1)) {\n\t\t\t\tszExt[0]=0;\n\t\t\t} else {\n\t\t\t\tchar *sep;\n\t\t\t\tstrncpy(szExt, sname, 29);\n\t\t\t\tszExt[29]=0;\n\t\t\t\tsep = strchr(szExt, '|');\n\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t}\n\t\t}\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tskip_write_filter = codec_id ? GF_TRUE : GF_FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (codec_id) {\n\t\t\tcase GF_CODECID_WEBVTT:\n\t\t\t\tskip_write_filter = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_META_TEXT:\n\t\t\tcase GF_CODECID_META_XML:\n\t\t\tcase GF_CODECID_SUBS_TEXT:\n\t\t\tcase GF_CODECID_SUBS_XML:\n\t\t\tcase GF_CODECID_SIMPLE_TEXT:\n\t\t\t\t//use dynamic extension\n\t\t\t\tszExt[0] = 0;\n\t\t\t\tuse_dynext = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//TODO, move these two to filters one of these days\n\t\tif ((codec_id==GF_CODECID_VORBIS) || (codec_id==GF_CODECID_THEORA) || (codec_id==GF_CODECID_OPUS)) {\n\t\t\tchar *outname = dumper->out_name;\n\t\t\tif (outname && !strcmp(outname, \"std\")) outname=NULL;\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\treturn gf_dump_to_ogg(dumper, outname, track_num);\n#else\n\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t\t}\n\t\tif (codec_id==GF_CODECID_SUBPIC) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tchar *dsi = NULL;\n\t\t\tu32 dsi_size = 0;\n\t\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\tdsi = esd->decoderConfig->decoderSpecificInfo->data;\n\t\t\t\tdsi_size = esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\t}\n\t\t\te = gf_dump_to_vobsub(dumper, dumper->out_name, track_num, dsi, dsi_size);\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\treturn e;\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\t} else {\n\t\tconst char *export_ext = dumper->out_name ? gf_file_ext_start(dumper->out_name) : NULL;\n\t\tskip_write_filter = GF_TRUE;\n\t\tif (!export_ext)\n\t\t\tuse_dynext = GF_TRUE;\n\t}\n\n\tfsess = gf_fs_new_defaults(0);\n\tif (!fsess) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Failed to create filter session\\n\"));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tfile_out = NULL;\n\targs = NULL;\n\n\tif (dumper->flags & GF_EXPORT_REMUX) {\n\t\tfile_out = gf_fs_load_destination(fsess, dumper->out_name, NULL, NULL, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot open destination %s\\n\", dumper->out_name));\n\t\t\treturn e;\n\t\t}\n\t}\n\t//except in nhml inband file dump, create a sink filter\n\telse if (!dumper->dump_file) {\n\t\tBool no_ext = (dumper->flags & GF_EXPORT_NO_FILE_EXT) ? GF_TRUE : GF_FALSE;\n\t\tchar *ext = gf_file_ext_start(dumper->out_name);\n\t\t//mux args, for now we only dump to file\n\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\n\t\tif (dumper->flags & GF_EXPORT_NHNT) {\n\t\t\tstrcpy(szExt, \"nhnt\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->flags & GF_EXPORT_NHML) {\n\t\t\tstrcpy(szExt, \"nhml\");\n\t\t\te |= gf_dynstrcat(&args, \":clone\", NULL);\n\t\t\tno_ext = GF_TRUE;\n\t\t\tif (!ext)\n\t\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\n\t\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\t\tif (!dumper->sample_num) {\n\n\t\t\t\text = gf_file_ext_start(args);\n\t\t\t\tif (ext) ext[0] = 0;\n\t\t\t\tif (sample_count>=1000) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%08d$\", NULL);\n\t\t\t\t} else if (sample_count) {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num%03d$\", NULL);\n\t\t\t\t} else {\n\t\t\t\t\te |= gf_dynstrcat(&args, \"_$num$\", NULL);\n\t\t\t\t}\n\t\t\t\text = gf_file_ext_start(dumper->out_name);\n\t\t\t\tif (ext) e |= gf_dynstrcat(&args, ext, NULL);\n\t\t\t}\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t} else if (dumper->trackID && strlen(szExt) ) {\n\t\t\tif (!no_ext && !gf_file_ext_start(dumper->out_name)) {\n\t\t\t\tif (args) gf_free(args);\n\t\t\t\targs=NULL;\n\t\t\t\te = gf_dynstrcat(&args, \"fout:dst=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, \".\");\n\t\t\t} else {\n\t\t\t\te |= gf_dynstrcat(&args, \":ext=\", NULL);\n\t\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t\t}\n\t\t} else if ((dumper->trackID || dumper->track_type) && use_dynext) {\n\t\t\te |= gf_dynstrcat(&args, \":dynext\", NULL);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load arguments for output file dumper\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\tgf_fs_del(fsess);\n\t\t\treturn e;\n\t\t}\n\n\t\tfile_out = gf_fs_load_filter(fsess, args, &e);\n\t\tif (!file_out) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load output file dumper\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//raw sample frame, force loading filter generic write in frame mode\n\tif (dumper->flags & GF_EXPORT_RAW_SAMPLES) {\n\t\te = gf_dynstrcat(&args, \"writegen:frame\", NULL);\n\t\tif (dumper->sample_num) {\n\t\t\tsprintf(szSubArgs, \":sstart=%d:send=%d\", dumper->sample_num, dumper->sample_num);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\tif (args) gf_free(args);\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHNT) {\n\t\tremux = gf_fs_load_filter(fsess, \"nhntw:exporter\", &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHNT write filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\telse if (dumper->flags & GF_EXPORT_NHML) {\n\t\te = gf_dynstrcat(&args, \"nhmlw:exporter:name=\", NULL);\n\t\te |= gf_dynstrcat(&args, dumper->out_name, NULL);\n\t\tif (dumper->flags & GF_EXPORT_NHML_FULL)\n\t\t\te |= gf_dynstrcat(&args, \":pckp\", NULL);\n\t\tif (dumper->dump_file) {\n\t\t\tsprintf(szSubArgs, \":nhmlonly:filep=%p\", dumper->dump_file);\n\t\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux || e) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load NHML write filter\\n\"));\n\t\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t\t}\n\t} else if (!skip_write_filter) {\n\t\te = gf_dynstrcat(&args, \"writegen:exporter\", NULL);\n\t\t//extension has been forced, override ext at output of writegen\n\t\tif (ext_forced) {\n\t\t\te |= gf_dynstrcat(&args, \":#Extension=\", NULL);\n\t\t\te |= gf_dynstrcat(&args, szExt, NULL);\n\t\t}\n\n\t\tremux = e ? NULL : gf_fs_load_filter(fsess, args, &e);\n\t\tif (!remux) {\n\t\t\tgf_fs_del(fsess);\n\t\t\tif (args) gf_free(args);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load stream->file filter\\n\"));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//force a reframer filter, connected to our input\n\te = gf_dynstrcat(&args, \"reframer:SID=1\", NULL);\n\tif (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"#PID=%d\", dumper->trackID);\n\t\te |= gf_dynstrcat(&args, szSubArgs, NULL);\n\t}\n\te |= gf_dynstrcat(&args, \":exporter\", NULL);\n\tif (dumper->flags & GF_EXPORT_SVC_LAYER)\n\t\te |= gf_dynstrcat(&args, \":extract=layer\", NULL);\n\tif (dumper->flags & GF_EXPORT_WEBVTT_NOMERGE)\n\t\te |= gf_dynstrcat(&args, \":merge\", NULL);\n\n\treframer = gf_fs_load_filter(fsess, args, &e);\n\tif (!reframer || e) {\n\t\tgf_fs_del(fsess);\n\t\tif (args) gf_free(args);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load reframer filter\\n\"));\n\t\treturn e ? e : GF_FILTER_NOT_FOUND;\n\t}\n\tif (args) gf_free(args);\n\targs = NULL;\n\n\t//we already have the file loaded, directly load the mp4dmx filter with this file\n\tif (dumper->file) {\n\t\t//we want to expose every track\n\t\te = gf_dynstrcat(&args, \"mp4dmx:FID=1:noedit:alltk:allt\", NULL);\n\t\tif (!e) {\n\t\t\tsprintf(szSubArgs, \":mov=%p\", dumper->file);\n\t\t\te = gf_dynstrcat(&args, szSubArgs, NULL);\n\t\t}\n\t\t\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_filter(fsess, args, &e);\n\n\t\tgf_free(args);\n\t\targs = NULL;\n\t} else {\n\t\t//we want to expose every track\n\t\tsrc_filter = gf_fs_load_source(fsess, dumper->in_name, \"FID=1:noedit:alltk:allt\", NULL, &e);\n\t}\n\n\tif (!src_filter || e) {\n\t\tgf_fs_del(fsess);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[Exporter] Cannot load filter for input file \\\"%s\\\": %s\\n\", dumper->in_name, gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\n\tif (dumper->track_type) {\n\t\tconst char *mtype = (dumper->track_type==1) ? \"video\" : \"audio\";\n\t\tif (dumper->trackID) {\n\t\t\tsprintf(szSubArgs, \"%s%d\", mtype, dumper->trackID);\n\t\t} else {\n\t\t\tsprintf(szSubArgs, \"%s\", mtype);\n\t\t}\n\t}\n\telse if (dumper->trackID) {\n\t\tsprintf(szSubArgs, \"PID=%d\", dumper->trackID);\n\t}\n\tif (remux) {\n\t\tgf_filter_set_source(file_out, remux, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t\tgf_filter_set_source(remux, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t} else {\n\t\tgf_filter_set_source(file_out, reframer, (dumper->trackID || dumper->track_type) ? szSubArgs : NULL);\n\t}\n\n\te = gf_fs_run(fsess);\n\tif (e>GF_OK) e = GF_OK;\n\tif (!e) e = gf_fs_get_last_connect_error(fsess);\n\tif (!e) e = gf_fs_get_last_process_error(fsess);\n\n\tif (!e) {\n\t\tif (dumper->file)\n\t\t\tgf_fs_print_unused_args(fsess, NULL);\n\t\telse\n\t\t\tgf_fs_print_unused_args(fsess, \"alltk,allt,noedit\");\n\t}\n\tgf_fs_print_non_connected(fsess);\n\tif (dumper->print_stats_graph & 1) gf_fs_print_stats(fsess);\n\tif (dumper->print_stats_graph & 2) gf_fs_print_connections(fsess);\n\tgf_fs_del(fsess);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_media_export(GF_MediaExporter *dumper)\n{\n\tif (!dumper) return GF_BAD_PARAM;\n\tif (!dumper->out_name && !(dumper->flags & GF_EXPORT_PROBE_ONLY) && !dumper->dump_file) return GF_BAD_PARAM;\n\n\t//internal export not using filters\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (dumper->flags & GF_EXPORT_MP4) return gf_media_export_isom(dumper);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n#ifndef GPAC_DISABLE_VTT\n\telse if (dumper->flags & GF_EXPORT_WEBVTT_META) return gf_media_export_webvtt_metadata(dumper);\n#endif\n\telse if (dumper->flags & GF_EXPORT_SIX) return gf_media_export_six(dumper);\n\n\t//the following ones should be moved to muxing filters\n\telse if (dumper->flags & GF_EXPORT_SAF) return gf_media_export_saf(dumper);\n\n\t//the rest is handled by the generic exporter\n\treturn gf_media_export_filters(dumper);\n}\n\n#endif /*GPAC_DISABLE_MEDIA_EXPORT*/\n"], "filenames": ["src/media_tools/media_export.c"], "buggy_code_start_loc": [1111], "buggy_code_end_loc": [1112], "fixing_code_start_loc": [1111], "fixing_code_end_loc": [1112], "type": "CWE-476", "message": "The gf_media_export_filters function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "other": {"cve": {"id": "CVE-2021-32438", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-11T20:15:08.977", "lastModified": "2021-08-16T17:34:14.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The gf_media_export_filters function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command."}, {"lang": "es", "value": "La funci\u00f3n gf_media_export_filters en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio (desreferencia del puntero NULL) por medio de un archivo dise\u00f1ado en el comando MP4Box"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/00194f5fe462123f70b0bae7987317b52898b868", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1769", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/00194f5fe462123f70b0bae7987317b52898b868"}}