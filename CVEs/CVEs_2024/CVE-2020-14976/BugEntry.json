{"buggy_code": ["\n/*-------------------------------------------------------------------------*/\n/**\n   @file    iniparser.c\n   @author  N. Devillard\n   @brief   Parser for ini files.\n*/\n/*--------------------------------------------------------------------------*/\n/*---------------------------- Includes ------------------------------------*/\n#include <ctype.h>\n#include \"iniparser.h\"\n\n/*---------------------------- Defines -------------------------------------*/\n#define ASCIILINESZ         (1024)\n#define INI_INVALID_KEY     ((char*)-1)\n\n/*---------------------------------------------------------------------------\n                        Private to this module\n ---------------------------------------------------------------------------*/\n/**\n * This enum stores the status for each parsed line (internal use only).\n */\ntypedef enum _line_status_ {\n    LINE_UNPROCESSED,\n    LINE_ERROR,\n    LINE_EMPTY,\n    LINE_COMMENT,\n    LINE_SECTION,\n    LINE_VALUE\n} line_status ;\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Convert a string to lowercase.\n  @param    in   String to convert.\n  @param    out Output buffer.\n  @param    len Size of the out buffer.\n  @return   ptr to the out buffer or NULL if an error occured.\n\n  This function convert a string into lowercase.\n  At most len - 1 elements of the input string will be converted.\n */\n/*--------------------------------------------------------------------------*/\nstatic const char * strlwc(const char * in, char *out, unsigned len)\n{\n    unsigned i ;\n\n    if (in==NULL || out == NULL || len==0) return NULL ;\n    i=0 ;\n    while (in[i] != '\\0' && i < len-1) {\n        out[i] = (char)tolower((int)in[i]);\n        i++ ;\n    }\n    out[i] = '\\0';\n    return out ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Copy string in a newly mallocced area\n  @param    str  String to copy.\n  @return   str  Copied version of the given string allocated with malloc\n\n  Original strdup is not portable, need to implement our own\n */\n/*--------------------------------------------------------------------------*/\nstatic char * _strdup(const char *s)\n{\n    char * copy = (char*) malloc(strlen(s));\n    strcpy(copy, s);\n    return copy ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Remove blanks at the beginning and the end of a string.\n  @param    str  String to parse and alter.\n  @return   unsigned New size of the string.\n */\n/*--------------------------------------------------------------------------*/\nunsigned strstrip(char * s)\n{\n    char *last = NULL ;\n    char *dest = s;\n\n    if (s==NULL) return 0;\n\n    last = s + strlen(s);\n    while (isspace((int)*s) && *s) s++;\n    while (last > s) {\n        if (!isspace((int)*(last-1)))\n            break ;\n        last -- ;\n    }\n    *last = (char)0;\n\n    memmove(dest,s,last - s + 1);\n    return last - s;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get number of sections in a dictionary\n  @param    d   Dictionary to examine\n  @return   int Number of sections found in dictionary\n\n  This function returns the number of sections found in a dictionary.\n  The test to recognize sections is done on the string stored in the\n  dictionary: a section name is given as \"section\" whereas a key is\n  stored as \"section:key\", thus the test looks for entries that do not\n  contain a colon.\n\n  This clearly fails in the case a section name contains a colon, but\n  this should simply be avoided.\n\n  This function returns -1 in case of error.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getnsec(const dictionary * d)\n{\n    int i ;\n    int nsec ;\n\n    if (d==NULL) return -1 ;\n    nsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (strchr(d->key[i], ':')==NULL) {\n            nsec ++ ;\n        }\n    }\n    return nsec ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get name for section n in a dictionary.\n  @param    d   Dictionary to examine\n  @param    n   Section number (from 0 to nsec-1).\n  @return   Pointer to char string\n\n  This function locates the n-th section in a dictionary and returns\n  its name as a pointer to a string statically allocated inside the\n  dictionary. Do not free or modify the returned string!\n\n  This function returns NULL in case of error.\n */\n/*--------------------------------------------------------------------------*/\nconst char * iniparser_getsecname(const dictionary * d, int n)\n{\n    int i ;\n    int foundsec ;\n\n    if (d==NULL || n<0) return NULL ;\n    foundsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (strchr(d->key[i], ':')==NULL) {\n            foundsec++ ;\n            if (foundsec>n)\n                break ;\n        }\n    }\n    if (foundsec<=n) {\n        return NULL ;\n    }\n    return d->key[i] ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Dump a dictionary to an opened file pointer.\n  @param    d   Dictionary to dump.\n  @param    f   Opened file pointer to dump to.\n  @return   void\n\n  This function prints out the contents of a dictionary, one element by\n  line, onto the provided file pointer. It is OK to specify @c stderr\n  or @c stdout as output files. This function is meant for debugging\n  purposes mostly.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_dump(const dictionary * d, FILE * f)\n{\n    int     i ;\n\n    if (d==NULL || f==NULL) return ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (d->val[i]!=NULL) {\n            fprintf(f, \"[%s]=[%s]\\n\", d->key[i], d->val[i]);\n        } else {\n            fprintf(f, \"[%s]=UNDEF\\n\", d->key[i]);\n        }\n    }\n    return ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given dictionary into a loadable ini file.\n  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_dump_ini(const dictionary * d, FILE * f)\n{\n    int          i ;\n    int          nsec ;\n    const char * secname ;\n\n    if (d==NULL || f==NULL) return ;\n\n    nsec = iniparser_getnsec(d);\n    if (nsec<1) {\n        /* No section in file: dump all keys as they are */\n        for (i=0 ; i<d->size ; i++) {\n            if (d->key[i]==NULL)\n                continue ;\n            fprintf(f, \"%s = %s\\n\", d->key[i], d->val[i]);\n        }\n        return ;\n    }\n    for (i=0 ; i<nsec ; i++) {\n        secname = iniparser_getsecname(d, i) ;\n        iniparser_dumpsection_ini(d, secname, f);\n    }\n    fprintf(f, \"\\n\");\n    return ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary section to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    s   Section name of dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given section of a given dictionary into a loadable ini\n  file.  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_dumpsection_ini(const dictionary * d, const char * s, FILE * f)\n{\n    int     j ;\n    char    keym[ASCIILINESZ+1];\n    int     seclen ;\n\n    if (d==NULL || f==NULL) return ;\n    if (! iniparser_find_entry(d, s)) return ;\n\n    seclen  = (int)strlen(s);\n    fprintf(f, \"\\n[%s]\\n\", s);\n    sprintf(keym, \"%s:\", s);\n    for (j=0 ; j<d->size ; j++) {\n        if (d->key[j]==NULL)\n            continue ;\n        if (!strncmp(d->key[j], keym, seclen+1)) {\n            fprintf(f,\n                    \"%-30s = %s\\n\",\n                    d->key[j]+seclen+1,\n                    d->val[j] ? d->val[j] : \"\");\n        }\n    }\n    fprintf(f, \"\\n\");\n    return ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d   Dictionary to examine\n  @param    s   Section name of dictionary to examine\n  @return   Number of keys in section\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getsecnkeys(const dictionary * d, const char * s)\n{\n    int     seclen, nkeys ;\n    char    keym[ASCIILINESZ+1];\n    int j ;\n\n    nkeys = 0;\n\n    if (d==NULL) return nkeys;\n    if (! iniparser_find_entry(d, s)) return nkeys;\n\n    seclen  = (int)strlen(s);\n    sprintf(keym, \"%s:\", s);\n\n    for (j=0 ; j<d->size ; j++) {\n        if (d->key[j]==NULL)\n            continue ;\n        if (!strncmp(d->key[j], keym, seclen+1))\n            nkeys++;\n    }\n\n    return nkeys;\n\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d    Dictionary to examine\n  @param    s    Section name of dictionary to examine\n  @param    keys Already allocated array to store the keys in\n  @return   The pointer passed as `keys` argument or NULL in case of error\n\n  This function queries a dictionary and finds all keys in a given section.\n  The keys argument should be an array of pointers which size has been\n  determined by calling `iniparser_getsecnkeys` function prior to this one.\n\n  Each pointer in the returned char pointer-to-pointer is pointing to\n  a string allocated in the dictionary; do not free or modify them.\n */\n/*--------------------------------------------------------------------------*/\nconst char ** iniparser_getseckeys(const dictionary * d, const char * s, const char ** keys)\n{\n    int i, j, seclen ;\n    char keym[ASCIILINESZ+1];\n\n    if (d==NULL || keys==NULL) return NULL;\n    if (! iniparser_find_entry(d, s)) return NULL;\n\n    seclen  = (int)strlen(s);\n    sprintf(keym, \"%s:\", s);\n\n    i = 0;\n\n    for (j=0 ; j<d->size ; j++) {\n        if (d->key[j]==NULL)\n            continue ;\n        if (!strncmp(d->key[j], keym, seclen+1)) {\n            keys[i] = d->key[j];\n            i++;\n        }\n    }\n\n    return keys;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key\n  @param    d       Dictionary to search\n  @param    key     Key string to look for\n  @param    def     Default value to return if key not found.\n  @return   pointer to statically allocated character string\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the pointer passed as 'def' is returned.\n  The returned char pointer is pointing to a string allocated in\n  the dictionary, do not free or modify it.\n */\n/*--------------------------------------------------------------------------*/\nconst char * iniparser_getstring(const dictionary * d, const char * key, const char * def)\n{\n    const char * lc_key ;\n    const char * sval ;\n    char tmp_str[ASCIILINESZ+1];\n\n    if (d==NULL || key==NULL)\n        return def ;\n\n    lc_key = strlwc(key, tmp_str, sizeof(tmp_str));\n    sval = dictionary_get(d, lc_key, def);\n    return sval ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to an int\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   integer\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n\n  Supported values for integers include the usual C notation\n  so decimal, octal (starting with 0) and hexadecimal (starting with 0x)\n  are supported. Examples:\n\n  \"42\"      ->  42\n  \"042\"     ->  34 (octal -> decimal)\n  \"0x42\"    ->  66 (hexa  -> decimal)\n\n  Warning: the conversion may overflow in various ways. Conversion is\n  totally outsourced to strtol(), see the associated man page for overflow\n  handling.\n\n  Credits: Thanks to A. Becker for suggesting strtol()\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getint(const dictionary * d, const char * key, int notfound)\n{\n    const char * str ;\n\n    str = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (str==INI_INVALID_KEY) return notfound ;\n    return (int)strtol(str, NULL, 0);\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a double\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   double\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n */\n/*--------------------------------------------------------------------------*/\ndouble iniparser_getdouble(const dictionary * d, const char * key, double notfound)\n{\n    const char * str ;\n\n    str = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (str==INI_INVALID_KEY) return notfound ;\n    return atof(str);\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a boolean\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   integer\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n\n  A true boolean is found if one of the following is matched:\n\n  - A string starting with 'y'\n  - A string starting with 'Y'\n  - A string starting with 't'\n  - A string starting with 'T'\n  - A string starting with '1'\n\n  A false boolean is found if one of the following is matched:\n\n  - A string starting with 'n'\n  - A string starting with 'N'\n  - A string starting with 'f'\n  - A string starting with 'F'\n  - A string starting with '0'\n\n  The notfound value returned if no boolean is identified, does not\n  necessarily have to be 0 or 1.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getboolean(const dictionary * d, const char * key, int notfound)\n{\n    int          ret ;\n    const char * c ;\n\n    c = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (c==INI_INVALID_KEY) return notfound ;\n    if (c[0]=='y' || c[0]=='Y' || c[0]=='1' || c[0]=='t' || c[0]=='T') {\n        ret = 1 ;\n    } else if (c[0]=='n' || c[0]=='N' || c[0]=='0' || c[0]=='f' || c[0]=='F') {\n        ret = 0 ;\n    } else {\n        ret = notfound ;\n    }\n    return ret;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Finds out if a given entry exists in a dictionary\n  @param    ini     Dictionary to search\n  @param    entry   Name of the entry to look for\n  @return   integer 1 if entry exists, 0 otherwise\n\n  Finds out if a given entry exists in the dictionary. Since sections\n  are stored as keys with NULL associated values, this is the only way\n  of querying for the presence of sections in a dictionary.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_find_entry(const dictionary * ini, const char * entry)\n{\n    int found=0 ;\n    if (iniparser_getstring(ini, entry, INI_INVALID_KEY)!=INI_INVALID_KEY) {\n        found = 1 ;\n    }\n    return found ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Set an entry in a dictionary.\n  @param    ini     Dictionary to modify.\n  @param    entry   Entry to modify (entry name)\n  @param    val     New value to associate to the entry.\n  @return   int 0 if Ok, -1 otherwise.\n\n  If the given entry can be found in the dictionary, it is modified to\n  contain the provided value. If it cannot be found, the entry is created.\n  It is Ok to set val to NULL.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_set(dictionary * ini, const char * entry, const char * val)\n{\n    char tmp_str[ASCIILINESZ+1];\n    return dictionary_set(ini, strlwc(entry, tmp_str, sizeof(tmp_str)), val) ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Delete an entry in a dictionary\n  @param    ini     Dictionary to modify\n  @param    entry   Entry to delete (entry name)\n  @return   void\n\n  If the given entry can be found, it is deleted from the dictionary.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_unset(dictionary * ini, const char * entry)\n{\n    char tmp_str[ASCIILINESZ+1];\n    dictionary_unset(ini, strlwc(entry, tmp_str, sizeof(tmp_str)));\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Load a single line from an INI file\n  @param    input_line  Input line, may be concatenated multi-line input\n  @param    section     Output space to store section\n  @param    key         Output space to store key\n  @param    value       Output space to store value\n  @return   line_status value\n */\n/*--------------------------------------------------------------------------*/\nstatic line_status iniparser_line(\n    const char * input_line,\n    char * section,\n    char * key,\n    char * value)\n{\n    line_status sta ;\n    char * line = NULL;\n    size_t      len ;\n\n    line = _strdup(input_line);\n    len = strstrip(line);\n\n    sta = LINE_UNPROCESSED ;\n    if (len<1) {\n        /* Empty line */\n        sta = LINE_EMPTY ;\n    } else if (line[0]=='#' || line[0]==';') {\n        /* Comment line */\n        sta = LINE_COMMENT ;\n    } else if (line[0]=='[' && line[len-1]==']') {\n        /* Section name */\n        sscanf(line, \"[%[^]]\", section);\n        strstrip(section);\n        strlwc(section, section, len);\n        sta = LINE_SECTION ;\n    } else if (sscanf (line, \"%[^=] = \\\"%[^\\\"]\\\"\", key, value) == 2\n           ||  sscanf (line, \"%[^=] = '%[^\\']'\",   key, value) == 2\n           ||  sscanf (line, \"%[^=] = %[^;#]\",     key, value) == 2) {\n        /* Usual key=value, with or without comments */\n        strstrip(key);\n        strlwc(key, key, len);\n        strstrip(value);\n        /*\n         * sscanf cannot handle '' or \"\" as empty values\n         * this is done here\n         */\n        if (!strcmp(value, \"\\\"\\\"\") || (!strcmp(value, \"''\"))) {\n            value[0]=0 ;\n        }\n        sta = LINE_VALUE ;\n    } else if (sscanf(line, \"%[^=] = %[;#]\", key, value)==2\n           ||  sscanf(line, \"%[^=] %[=]\", key, value) == 2) {\n        /*\n         * Special cases:\n         * key=\n         * key=;\n         * key=#\n         */\n        strstrip(key);\n        strlwc(key, key, len);\n        value[0]=0 ;\n        sta = LINE_VALUE ;\n    } else {\n        /* Generate syntax error */\n        sta = LINE_ERROR ;\n    }\n\n    free(line);\n    return sta ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Parse an ini file and return an allocated dictionary object\n  @param    ininame Name of the ini file to read.\n  @return   Pointer to newly allocated dictionary\n\n  This is the parser for ini files. This function is called, providing\n  the name of the file to be read. It returns a dictionary object that\n  should not be accessed directly, but through accessor functions\n  instead.\n\n  The returned dictionary must be freed using iniparser_freedict().\n */\n/*--------------------------------------------------------------------------*/\ndictionary * iniparser_load(const char * ininame)\n{\n    FILE * in ;\n\n    char line    [ASCIILINESZ+1] ;\n    char section [ASCIILINESZ+1] ;\n    char key     [ASCIILINESZ+1] ;\n    char tmp     [(ASCIILINESZ * 2) + 1] ;\n    char val     [ASCIILINESZ+1] ;\n\n    int  last=0 ;\n    int  len ;\n    int  lineno=0 ;\n    int  errs=0;\n\n    dictionary * dict ;\n\n    if ((in=fopen(ininame, \"r\"))==NULL) {\n        fprintf(stderr, \"iniparser: cannot open %s\\n\", ininame);\n        return NULL ;\n    }\n\n    dict = dictionary_new(0) ;\n    if (!dict) {\n        fclose(in);\n        return NULL ;\n    }\n\n    memset(line,    0, ASCIILINESZ);\n    memset(section, 0, ASCIILINESZ);\n    memset(key,     0, ASCIILINESZ);\n    memset(val,     0, ASCIILINESZ);\n    last=0 ;\n\n    while (fgets(line+last, ASCIILINESZ-last, in)!=NULL) {\n        lineno++ ;\n        len = (int)strlen(line)-1;\n        if (len==0)\n            continue;\n        /* Safety check against buffer overflows */\n        if (line[len]!='\\n' && !feof(in)) {\n            fprintf(stderr,\n                    \"iniparser: input line too long in %s (%d)\\n\",\n                    ininame,\n                    lineno);\n            dictionary_del(dict);\n            fclose(in);\n            return NULL ;\n        }\n        /* Get rid of \\n and spaces at end of line */\n        while ((len>=0) &&\n                ((line[len]=='\\n') || (isspace(line[len])))) {\n            line[len]=0 ;\n            len-- ;\n        }\n        if (len < 0) { /* Line was entirely \\n and/or spaces */\n            len = 0;\n        }\n        /* Detect multi-line */\n        if (line[len]=='\\\\') {\n            /* Multi-line value */\n            last=len ;\n            continue ;\n        } else {\n            last=0 ;\n        }\n        switch (iniparser_line(line, section, key, val)) {\n            case LINE_EMPTY:\n            case LINE_COMMENT:\n            break ;\n\n            case LINE_SECTION:\n            errs = dictionary_set(dict, section, NULL);\n            break ;\n\n            case LINE_VALUE:\n            sprintf(tmp, \"%s:%s\", section, key);\n            errs = dictionary_set(dict, tmp, val) ;\n            break ;\n\n            case LINE_ERROR:\n            fprintf(stderr, \"iniparser: syntax error in %s (%d):\\n\",\n                    ininame,\n                    lineno);\n            fprintf(stderr, \"-> %s\\n\", line);\n            errs++ ;\n            break;\n\n            default:\n            break ;\n        }\n        memset(line, 0, ASCIILINESZ);\n        last=0;\n        if (errs<0) {\n            fprintf(stderr, \"iniparser: memory allocation failure\\n\");\n            break ;\n        }\n    }\n    if (errs) {\n        dictionary_del(dict);\n        dict = NULL ;\n    }\n    fclose(in);\n    return dict ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Free all memory associated to an ini dictionary\n  @param    d Dictionary to free\n  @return   void\n\n  Free all memory associated to an ini dictionary.\n  It is mandatory to call this function before the dictionary object\n  gets out of the current context.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_freedict(dictionary * d)\n{\n    dictionary_del(d);\n}\n", "\n/*-------------------------------------------------------------------------*/\n/**\n   @file    iniparser.h\n   @author  N. Devillard\n   @brief   Parser for ini files.\n*/\n/*--------------------------------------------------------------------------*/\n\n#ifndef _INIPARSER_H_\n#define _INIPARSER_H_\n\n/*---------------------------------------------------------------------------\n                                Includes\n ---------------------------------------------------------------------------*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * The following #include is necessary on many Unixes but not Linux.\n * It is not needed for Windows platforms.\n * Uncomment it if needed.\n */\n/* #include <unistd.h> */\n\n#include \"dictionary.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get number of sections in a dictionary\n  @param    d   Dictionary to examine\n  @return   int Number of sections found in dictionary\n\n  This function returns the number of sections found in a dictionary.\n  The test to recognize sections is done on the string stored in the\n  dictionary: a section name is given as \"section\" whereas a key is\n  stored as \"section:key\", thus the test looks for entries that do not\n  contain a colon.\n\n  This clearly fails in the case a section name contains a colon, but\n  this should simply be avoided.\n\n  This function returns -1 in case of error.\n */\n/*--------------------------------------------------------------------------*/\n\nint iniparser_getnsec(const dictionary * d);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get name for section n in a dictionary.\n  @param    d   Dictionary to examine\n  @param    n   Section number (from 0 to nsec-1).\n  @return   Pointer to char string\n\n  This function locates the n-th section in a dictionary and returns\n  its name as a pointer to a string statically allocated inside the\n  dictionary. Do not free or modify the returned string!\n\n  This function returns NULL in case of error.\n */\n/*--------------------------------------------------------------------------*/\n\nconst char * iniparser_getsecname(const dictionary * d, int n);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given dictionary into a loadable ini file.\n  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\n\nvoid iniparser_dump_ini(const dictionary * d, FILE * f);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary section to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    s   Section name of dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given section of a given dictionary into a loadable ini\n  file.  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\n\nvoid iniparser_dumpsection_ini(const dictionary * d, const char * s, FILE * f);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Dump a dictionary to an opened file pointer.\n  @param    d   Dictionary to dump.\n  @param    f   Opened file pointer to dump to.\n  @return   void\n\n  This function prints out the contents of a dictionary, one element by\n  line, onto the provided file pointer. It is OK to specify @c stderr\n  or @c stdout as output files. This function is meant for debugging\n  purposes mostly.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_dump(const dictionary * d, FILE * f);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d   Dictionary to examine\n  @param    s   Section name of dictionary to examine\n  @return   Number of keys in section\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getsecnkeys(const dictionary * d, const char * s);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d    Dictionary to examine\n  @param    s    Section name of dictionary to examine\n  @param    keys Already allocated array to store the keys in\n  @return   The pointer passed as `keys` argument or NULL in case of error\n\n  This function queries a dictionary and finds all keys in a given section.\n  The keys argument should be an array of pointers which size has been\n  determined by calling `iniparser_getsecnkeys` function prior to this one.\n\n  Each pointer in the returned char pointer-to-pointer is pointing to\n  a string allocated in the dictionary; do not free or modify them.\n */\n/*--------------------------------------------------------------------------*/\nconst char ** iniparser_getseckeys(const dictionary * d, const char * s, const char ** keys);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key\n  @param    d       Dictionary to search\n  @param    key     Key string to look for\n  @param    def     Default value to return if key not found.\n  @return   pointer to statically allocated character string\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the pointer passed as 'def' is returned.\n  The returned char pointer is pointing to a string allocated in\n  the dictionary, do not free or modify it.\n */\n/*--------------------------------------------------------------------------*/\nconst char * iniparser_getstring(const dictionary * d, const char * key, const char * def);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to an int\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   integer\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n\n  Supported values for integers include the usual C notation\n  so decimal, octal (starting with 0) and hexadecimal (starting with 0x)\n  are supported. Examples:\n\n  - \"42\"      ->  42\n  - \"042\"     ->  34 (octal -> decimal)\n  - \"0x42\"    ->  66 (hexa  -> decimal)\n\n  Warning: the conversion may overflow in various ways. Conversion is\n  totally outsourced to strtol(), see the associated man page for overflow\n  handling.\n\n  Credits: Thanks to A. Becker for suggesting strtol()\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getint(const dictionary * d, const char * key, int notfound);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a double\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   double\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n */\n/*--------------------------------------------------------------------------*/\ndouble iniparser_getdouble(const dictionary * d, const char * key, double notfound);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a boolean\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   integer\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n\n  A true boolean is found if one of the following is matched:\n\n  - A string starting with 'y'\n  - A string starting with 'Y'\n  - A string starting with 't'\n  - A string starting with 'T'\n  - A string starting with '1'\n\n  A false boolean is found if one of the following is matched:\n\n  - A string starting with 'n'\n  - A string starting with 'N'\n  - A string starting with 'f'\n  - A string starting with 'F'\n  - A string starting with '0'\n\n  The notfound value returned if no boolean is identified, does not\n  necessarily have to be 0 or 1.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getboolean(const dictionary * d, const char * key, int notfound);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Set an entry in a dictionary.\n  @param    ini     Dictionary to modify.\n  @param    entry   Entry to modify (entry name)\n  @param    val     New value to associate to the entry.\n  @return   int     0 if Ok, -1 otherwise.\n\n  If the given entry can be found in the dictionary, it is modified to\n  contain the provided value. If it cannot be found, the entry is created.\n  It is Ok to set val to NULL.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_set(dictionary * ini, const char * entry, const char * val);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Delete an entry in a dictionary\n  @param    ini     Dictionary to modify\n  @param    entry   Entry to delete (entry name)\n  @return   void\n\n  If the given entry can be found, it is deleted from the dictionary.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_unset(dictionary * ini, const char * entry);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Finds out if a given entry exists in a dictionary\n  @param    ini     Dictionary to search\n  @param    entry   Name of the entry to look for\n  @return   integer 1 if entry exists, 0 otherwise\n\n  Finds out if a given entry exists in the dictionary. Since sections\n  are stored as keys with NULL associated values, this is the only way\n  of querying for the presence of sections in a dictionary.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_find_entry(const dictionary * ini, const char * entry) ;\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Parse an ini file and return an allocated dictionary object\n  @param    ininame Name of the ini file to read.\n  @return   Pointer to newly allocated dictionary\n\n  This is the parser for ini files. This function is called, providing\n  the name of the file to be read. It returns a dictionary object that\n  should not be accessed directly, but through accessor functions\n  instead.\n\n  The returned dictionary must be freed using iniparser_freedict().\n */\n/*--------------------------------------------------------------------------*/\ndictionary * iniparser_load(const char * ininame);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Free all memory associated to an ini dictionary\n  @param    d Dictionary to free\n  @return   void\n\n  Free all memory associated to an ini dictionary.\n  It is mandatory to call this function before the dictionary object\n  gets out of the current context.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_freedict(dictionary * d);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n *   This file is part of ubridge, a program to bridge network interfaces\n *   to UDP tunnels.\n *\n *   Copyright (C) 2015 GNS3 Technologies Inc.\n *\n *   ubridge is free software: you can redistribute it and/or modify it\n *   under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   ubridge is distributed in the hope that it will be useful, but\n *   WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"parse.h\"\n#include \"nio_udp.h\"\n#include \"nio_unix.h\"\n#include \"nio_ethernet.h\"\n#include \"nio_tap.h\"\n#include \"pcap_capture.h\"\n#include \"pcap_filter.h\"\n\n#ifdef LINUX_RAW\n#include \"nio_linux_raw.h\"\n#endif\n\n#ifdef __APPLE__\n#include \"nio_fusion_vmnet.h\"\n#endif\n\nstatic nio_t *create_udp_tunnel(const char *params)\n{\n  nio_t *nio;\n  char *local_port;\n  char *remote_host;\n  char *remote_port;\n\n  printf(\"Creating UDP tunnel %s\\n\", params);\n  local_port = strtok((char *)params, \":\");\n  remote_host = strtok(NULL, \":\");\n  remote_port = strtok(NULL, \":\");\n  if (local_port == NULL || remote_host == NULL || remote_port == NULL) {\n     fprintf(stderr, \"invalid UDP tunnel syntax\\n\");\n     return NULL;\n  }\n\n  nio = create_nio_udp(atoi(local_port), remote_host, atoi(remote_port));\n  if (!nio)\n    fprintf(stderr, \"unable to create UDP NIO\\n\");\n  return nio;\n}\n\nstatic nio_t *create_unix_socket(const char *params)\n{\n  nio_t *nio;\n  char *local;\n  char *remote;\n\n  printf(\"Creating UNIX domain socket %s\\n\", params);\n  local = strtok((char *)params, \":\");\n  remote = strtok(NULL, \":\");\n  if (local == NULL || remote == NULL) {\n     fprintf(stderr, \"invalid UNIX domain socket syntax\\n\");\n     return NULL;\n  }\n  nio = create_nio_unix(local, remote);\n  if (!nio)\n    fprintf(stderr, \"unable to create UNIX NIO\\n\");\n  return nio;\n}\n\nstatic nio_t *open_ethernet_device(const char *dev_name)\n{\n  nio_t *nio;\n\n  printf(\"Opening Ethernet device %s\\n\", dev_name);\n  nio = create_nio_ethernet((char *)dev_name);\n  if (!nio)\n    fprintf(stderr, \"unable to open Ethernet device\\n\");\n  return nio;\n}\n\nstatic nio_t *open_tap_device(const char *dev_name)\n{\n  nio_t *nio;\n\n  printf(\"Opening TAP device %s\\n\", dev_name);\n  nio = create_nio_tap((char *)dev_name);\n  if (!nio)\n    fprintf(stderr, \"unable to open TAP device\\n\");\n  return nio;\n}\n\n#ifdef LINUX_RAW\nstatic nio_t *open_linux_raw(const char *dev_name)\n{\n  nio_t *nio;\n\n  printf(\"Opening Linux RAW device %s\\n\", dev_name);\n  nio = create_nio_linux_raw((char *)dev_name);\n  if (!nio)\n    fprintf(stderr, \"unable to open RAW device\\n\");\n  return nio;\n}\n#endif\n\n#ifdef __APPLE__\nstatic nio_t *open_fusion_vmnet(const char *vmnet_name)\n{\n  nio_t *nio;\n\n  printf(\"Opening Fusion VMnet %s\\n\", vmnet_name);\n  nio = create_nio_fusion_vmnet((char *)vmnet_name);\n  if (!nio)\n    fprintf(stderr, \"unable to open Fusion VMnet interface\\n\");\n  return nio;\n}\n\n#endif\n\nstatic int getstr(dictionary *ubridge_config, const char *section, const char *entry, const char **value)\n{\n    char key[MAX_KEY_SIZE];\n\n    snprintf(key, MAX_KEY_SIZE, \"%s:%s\", section, entry);\n    *value = iniparser_getstring(ubridge_config, key, NULL);\n    if (*value)\n      return TRUE;\n    return FALSE;\n}\n\nstatic bridge_t *add_bridge(bridge_t **head)\n{\n   bridge_t *bridge;\n\n   if ((bridge = malloc(sizeof(*bridge))) != NULL) {\n      memset(bridge, 0, sizeof(*bridge));\n      bridge->next = *head;\n      *head = bridge;\n   }\n   return bridge;\n}\n\nstatic void parse_capture(dictionary *ubridge_config, const char *bridge_name, bridge_t *bridge)\n{\n    const char *pcap_file = NULL;\n    const char *pcap_linktype = \"EN10MB\";\n\n    getstr(ubridge_config, bridge_name, \"pcap_protocol\", &pcap_linktype);\n    if (getstr(ubridge_config, bridge_name, \"pcap_file\", &pcap_file)) {\n        printf(\"Starting packet capture to %s with protocol %s\\n\", pcap_file, pcap_linktype);\n        bridge->capture = create_pcap_capture(pcap_file, pcap_linktype);\n    }\n}\n\nstatic void parse_filter(dictionary *ubridge_config, const char *bridge_name, bridge_t *bridge)\n{\n    const char *pcap_filter = NULL;\n\n    if (getstr(ubridge_config, bridge_name, \"pcap_filter\", &pcap_filter)) {\n        printf(\"Applying PCAP filter '%s'\\n\", pcap_filter);\n        if (bridge->source_nio->type == NIO_TYPE_ETHERNET) {\n            if (set_pcap_filter(bridge->source_nio->dptr, pcap_filter) < 0)\n               fprintf(stderr, \"unable to apply filter to source NIO\\n\");\n        }\n        else if (bridge->destination_nio->type == NIO_TYPE_ETHERNET) {\n            if (set_pcap_filter(bridge->destination_nio->dptr, pcap_filter) < 0)\n               fprintf(stderr, \"unable to apply filter to destination NIO\\n\");\n        }\n    }\n}\n\nint parse_config(char *filename, bridge_t **bridges)\n{\n    dictionary *ubridge_config = NULL;\n    const char *value;\n    const char *bridge_name;\n    int i, nsec;\n\n    if ((ubridge_config = iniparser_load(filename)) == NULL) {\n       return FALSE;\n    }\n\n    nsec = iniparser_getnsec(ubridge_config);\n    for (i = 0; i < nsec; i++) {\n        bridge_t *bridge;\n        nio_t *source_nio = NULL;\n        nio_t *destination_nio = NULL;\n\n        bridge_name = iniparser_getsecname(ubridge_config, i);\n        printf(\"Parsing %s\\n\", bridge_name);\n        if (getstr(ubridge_config, bridge_name, \"source_udp\", &value))\n           source_nio = create_udp_tunnel(value);\n        else if (getstr(ubridge_config, bridge_name, \"source_unix\", &value))\n           source_nio = create_unix_socket(value);\n        else if (getstr(ubridge_config, bridge_name, \"source_ethernet\", &value))\n           source_nio = open_ethernet_device(value);\n        else if (getstr(ubridge_config, bridge_name, \"source_tap\", &value))\n           source_nio = open_tap_device(value);\n#ifdef LINUX_RAW\n        else if (getstr(ubridge_config, bridge_name, \"source_linux_raw\", &value))\n           source_nio = open_linux_raw(value);\n#endif\n#ifdef __APPLE__\n        else if (getstr(ubridge_config, bridge_name, \"source_fusion_vmnet\", &value))\n           source_nio = open_fusion_vmnet(value);\n#endif\n        else\n           fprintf(stderr, \"source NIO not found\\n\");\n\n        if (getstr(ubridge_config, bridge_name, \"destination_udp\", &value))\n           destination_nio = create_udp_tunnel(value);\n        else if (getstr(ubridge_config, bridge_name, \"destination_unix\", &value))\n           destination_nio = create_unix_socket(value);\n        else if (getstr(ubridge_config, bridge_name, \"destination_ethernet\", &value))\n           destination_nio = open_ethernet_device(value);\n        else if (getstr(ubridge_config, bridge_name, \"destination_tap\", &value))\n           destination_nio = open_tap_device(value);\n#ifdef LINUX_RAW\n        else if (getstr(ubridge_config, bridge_name, \"destination_linux_raw\", &value))\n           source_nio = open_linux_raw(value);\n#endif\n#ifdef __APPLE__\n        else if (getstr(ubridge_config, bridge_name, \"destination_fusion_vmnet\", &value))\n           destination_nio = open_fusion_vmnet(value);\n#endif\n        else\n           fprintf(stderr, \"destination NIO not found\\n\");\n\n        if (source_nio && destination_nio) {\n           bridge = add_bridge(bridges);\n           bridge->source_nio = source_nio;\n           bridge->destination_nio = destination_nio;\n           if (!(bridge->name = strdup(bridge_name))) {\n              fprintf(stderr, \"bridge creation: insufficient memory\\n\");\n              return FALSE;\n           }\n           parse_capture(ubridge_config, bridge_name, bridge);\n           parse_filter(ubridge_config, bridge_name, bridge);\n        }\n        else if (source_nio != NULL)\n           free_nio(source_nio);\n        else if (destination_nio != NULL)\n           free_nio(destination_nio);\n    }\n    iniparser_freedict(ubridge_config);\n    return TRUE;\n}\n"], "fixing_code": ["\n/*-------------------------------------------------------------------------*/\n/**\n   @file    iniparser.c\n   @author  N. Devillard\n   @brief   Parser for ini files.\n*/\n/*--------------------------------------------------------------------------*/\n/*---------------------------- Includes ------------------------------------*/\n#include <ctype.h>\n#include \"iniparser.h\"\n\n/*---------------------------- Defines -------------------------------------*/\n#define ASCIILINESZ         (1024)\n#define INI_INVALID_KEY     ((char*)-1)\n\n/*---------------------------------------------------------------------------\n                        Private to this module\n ---------------------------------------------------------------------------*/\n/**\n * This enum stores the status for each parsed line (internal use only).\n */\ntypedef enum _line_status_ {\n    LINE_UNPROCESSED,\n    LINE_ERROR,\n    LINE_EMPTY,\n    LINE_COMMENT,\n    LINE_SECTION,\n    LINE_VALUE\n} line_status ;\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Convert a string to lowercase.\n  @param    in   String to convert.\n  @param    out Output buffer.\n  @param    len Size of the out buffer.\n  @return   ptr to the out buffer or NULL if an error occured.\n\n  This function convert a string into lowercase.\n  At most len - 1 elements of the input string will be converted.\n */\n/*--------------------------------------------------------------------------*/\nstatic const char * strlwc(const char * in, char *out, unsigned len)\n{\n    unsigned i ;\n\n    if (in==NULL || out == NULL || len==0) return NULL ;\n    i=0 ;\n    while (in[i] != '\\0' && i < len-1) {\n        out[i] = (char)tolower((int)in[i]);\n        i++ ;\n    }\n    out[i] = '\\0';\n    return out ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Copy string in a newly mallocced area\n  @param    str  String to copy.\n  @return   str  Copied version of the given string allocated with malloc\n\n  Original strdup is not portable, need to implement our own\n */\n/*--------------------------------------------------------------------------*/\nstatic char * _strdup(const char *s)\n{\n    char * copy = (char*) malloc(strlen(s));\n    strcpy(copy, s);\n    return copy ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Remove blanks at the beginning and the end of a string.\n  @param    str  String to parse and alter.\n  @return   unsigned New size of the string.\n */\n/*--------------------------------------------------------------------------*/\nunsigned strstrip(char * s)\n{\n    char *last = NULL ;\n    char *dest = s;\n\n    if (s==NULL) return 0;\n\n    last = s + strlen(s);\n    while (isspace((int)*s) && *s) s++;\n    while (last > s) {\n        if (!isspace((int)*(last-1)))\n            break ;\n        last -- ;\n    }\n    *last = (char)0;\n\n    memmove(dest,s,last - s + 1);\n    return last - s;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get number of sections in a dictionary\n  @param    d   Dictionary to examine\n  @return   int Number of sections found in dictionary\n\n  This function returns the number of sections found in a dictionary.\n  The test to recognize sections is done on the string stored in the\n  dictionary: a section name is given as \"section\" whereas a key is\n  stored as \"section:key\", thus the test looks for entries that do not\n  contain a colon.\n\n  This clearly fails in the case a section name contains a colon, but\n  this should simply be avoided.\n\n  This function returns -1 in case of error.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getnsec(const dictionary * d)\n{\n    int i ;\n    int nsec ;\n\n    if (d==NULL) return -1 ;\n    nsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (strchr(d->key[i], ':')==NULL) {\n            nsec ++ ;\n        }\n    }\n    return nsec ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get name for section n in a dictionary.\n  @param    d   Dictionary to examine\n  @param    n   Section number (from 0 to nsec-1).\n  @return   Pointer to char string\n\n  This function locates the n-th section in a dictionary and returns\n  its name as a pointer to a string statically allocated inside the\n  dictionary. Do not free or modify the returned string!\n\n  This function returns NULL in case of error.\n */\n/*--------------------------------------------------------------------------*/\nconst char * iniparser_getsecname(const dictionary * d, int n)\n{\n    int i ;\n    int foundsec ;\n\n    if (d==NULL || n<0) return NULL ;\n    foundsec=0 ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (strchr(d->key[i], ':')==NULL) {\n            foundsec++ ;\n            if (foundsec>n)\n                break ;\n        }\n    }\n    if (foundsec<=n) {\n        return NULL ;\n    }\n    return d->key[i] ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Dump a dictionary to an opened file pointer.\n  @param    d   Dictionary to dump.\n  @param    f   Opened file pointer to dump to.\n  @return   void\n\n  This function prints out the contents of a dictionary, one element by\n  line, onto the provided file pointer. It is OK to specify @c stderr\n  or @c stdout as output files. This function is meant for debugging\n  purposes mostly.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_dump(const dictionary * d, FILE * f)\n{\n    int     i ;\n\n    if (d==NULL || f==NULL) return ;\n    for (i=0 ; i<d->size ; i++) {\n        if (d->key[i]==NULL)\n            continue ;\n        if (d->val[i]!=NULL) {\n            fprintf(f, \"[%s]=[%s]\\n\", d->key[i], d->val[i]);\n        } else {\n            fprintf(f, \"[%s]=UNDEF\\n\", d->key[i]);\n        }\n    }\n    return ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given dictionary into a loadable ini file.\n  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_dump_ini(const dictionary * d, FILE * f)\n{\n    int          i ;\n    int          nsec ;\n    const char * secname ;\n\n    if (d==NULL || f==NULL) return ;\n\n    nsec = iniparser_getnsec(d);\n    if (nsec<1) {\n        /* No section in file: dump all keys as they are */\n        for (i=0 ; i<d->size ; i++) {\n            if (d->key[i]==NULL)\n                continue ;\n            fprintf(f, \"%s = %s\\n\", d->key[i], d->val[i]);\n        }\n        return ;\n    }\n    for (i=0 ; i<nsec ; i++) {\n        secname = iniparser_getsecname(d, i) ;\n        iniparser_dumpsection_ini(d, secname, f);\n    }\n    fprintf(f, \"\\n\");\n    return ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary section to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    s   Section name of dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given section of a given dictionary into a loadable ini\n  file.  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_dumpsection_ini(const dictionary * d, const char * s, FILE * f)\n{\n    int     j ;\n    char    keym[ASCIILINESZ+1];\n    int     seclen ;\n\n    if (d==NULL || f==NULL) return ;\n    if (! iniparser_find_entry(d, s)) return ;\n\n    seclen  = (int)strlen(s);\n    fprintf(f, \"\\n[%s]\\n\", s);\n    sprintf(keym, \"%s:\", s);\n    for (j=0 ; j<d->size ; j++) {\n        if (d->key[j]==NULL)\n            continue ;\n        if (!strncmp(d->key[j], keym, seclen+1)) {\n            fprintf(f,\n                    \"%-30s = %s\\n\",\n                    d->key[j]+seclen+1,\n                    d->val[j] ? d->val[j] : \"\");\n        }\n    }\n    fprintf(f, \"\\n\");\n    return ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d   Dictionary to examine\n  @param    s   Section name of dictionary to examine\n  @return   Number of keys in section\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getsecnkeys(const dictionary * d, const char * s)\n{\n    int     seclen, nkeys ;\n    char    keym[ASCIILINESZ+1];\n    int j ;\n\n    nkeys = 0;\n\n    if (d==NULL) return nkeys;\n    if (! iniparser_find_entry(d, s)) return nkeys;\n\n    seclen  = (int)strlen(s);\n    sprintf(keym, \"%s:\", s);\n\n    for (j=0 ; j<d->size ; j++) {\n        if (d->key[j]==NULL)\n            continue ;\n        if (!strncmp(d->key[j], keym, seclen+1))\n            nkeys++;\n    }\n\n    return nkeys;\n\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d    Dictionary to examine\n  @param    s    Section name of dictionary to examine\n  @param    keys Already allocated array to store the keys in\n  @return   The pointer passed as `keys` argument or NULL in case of error\n\n  This function queries a dictionary and finds all keys in a given section.\n  The keys argument should be an array of pointers which size has been\n  determined by calling `iniparser_getsecnkeys` function prior to this one.\n\n  Each pointer in the returned char pointer-to-pointer is pointing to\n  a string allocated in the dictionary; do not free or modify them.\n */\n/*--------------------------------------------------------------------------*/\nconst char ** iniparser_getseckeys(const dictionary * d, const char * s, const char ** keys)\n{\n    int i, j, seclen ;\n    char keym[ASCIILINESZ+1];\n\n    if (d==NULL || keys==NULL) return NULL;\n    if (! iniparser_find_entry(d, s)) return NULL;\n\n    seclen  = (int)strlen(s);\n    sprintf(keym, \"%s:\", s);\n\n    i = 0;\n\n    for (j=0 ; j<d->size ; j++) {\n        if (d->key[j]==NULL)\n            continue ;\n        if (!strncmp(d->key[j], keym, seclen+1)) {\n            keys[i] = d->key[j];\n            i++;\n        }\n    }\n\n    return keys;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key\n  @param    d       Dictionary to search\n  @param    key     Key string to look for\n  @param    def     Default value to return if key not found.\n  @return   pointer to statically allocated character string\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the pointer passed as 'def' is returned.\n  The returned char pointer is pointing to a string allocated in\n  the dictionary, do not free or modify it.\n */\n/*--------------------------------------------------------------------------*/\nconst char * iniparser_getstring(const dictionary * d, const char * key, const char * def)\n{\n    const char * lc_key ;\n    const char * sval ;\n    char tmp_str[ASCIILINESZ+1];\n\n    if (d==NULL || key==NULL)\n        return def ;\n\n    lc_key = strlwc(key, tmp_str, sizeof(tmp_str));\n    sval = dictionary_get(d, lc_key, def);\n    return sval ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to an int\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   integer\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n\n  Supported values for integers include the usual C notation\n  so decimal, octal (starting with 0) and hexadecimal (starting with 0x)\n  are supported. Examples:\n\n  \"42\"      ->  42\n  \"042\"     ->  34 (octal -> decimal)\n  \"0x42\"    ->  66 (hexa  -> decimal)\n\n  Warning: the conversion may overflow in various ways. Conversion is\n  totally outsourced to strtol(), see the associated man page for overflow\n  handling.\n\n  Credits: Thanks to A. Becker for suggesting strtol()\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getint(const dictionary * d, const char * key, int notfound)\n{\n    const char * str ;\n\n    str = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (str==INI_INVALID_KEY) return notfound ;\n    return (int)strtol(str, NULL, 0);\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a double\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   double\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n */\n/*--------------------------------------------------------------------------*/\ndouble iniparser_getdouble(const dictionary * d, const char * key, double notfound)\n{\n    const char * str ;\n\n    str = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (str==INI_INVALID_KEY) return notfound ;\n    return atof(str);\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a boolean\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   integer\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n\n  A true boolean is found if one of the following is matched:\n\n  - A string starting with 'y'\n  - A string starting with 'Y'\n  - A string starting with 't'\n  - A string starting with 'T'\n  - A string starting with '1'\n\n  A false boolean is found if one of the following is matched:\n\n  - A string starting with 'n'\n  - A string starting with 'N'\n  - A string starting with 'f'\n  - A string starting with 'F'\n  - A string starting with '0'\n\n  The notfound value returned if no boolean is identified, does not\n  necessarily have to be 0 or 1.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getboolean(const dictionary * d, const char * key, int notfound)\n{\n    int          ret ;\n    const char * c ;\n\n    c = iniparser_getstring(d, key, INI_INVALID_KEY);\n    if (c==INI_INVALID_KEY) return notfound ;\n    if (c[0]=='y' || c[0]=='Y' || c[0]=='1' || c[0]=='t' || c[0]=='T') {\n        ret = 1 ;\n    } else if (c[0]=='n' || c[0]=='N' || c[0]=='0' || c[0]=='f' || c[0]=='F') {\n        ret = 0 ;\n    } else {\n        ret = notfound ;\n    }\n    return ret;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Finds out if a given entry exists in a dictionary\n  @param    ini     Dictionary to search\n  @param    entry   Name of the entry to look for\n  @return   integer 1 if entry exists, 0 otherwise\n\n  Finds out if a given entry exists in the dictionary. Since sections\n  are stored as keys with NULL associated values, this is the only way\n  of querying for the presence of sections in a dictionary.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_find_entry(const dictionary * ini, const char * entry)\n{\n    int found=0 ;\n    if (iniparser_getstring(ini, entry, INI_INVALID_KEY)!=INI_INVALID_KEY) {\n        found = 1 ;\n    }\n    return found ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Set an entry in a dictionary.\n  @param    ini     Dictionary to modify.\n  @param    entry   Entry to modify (entry name)\n  @param    val     New value to associate to the entry.\n  @return   int 0 if Ok, -1 otherwise.\n\n  If the given entry can be found in the dictionary, it is modified to\n  contain the provided value. If it cannot be found, the entry is created.\n  It is Ok to set val to NULL.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_set(dictionary * ini, const char * entry, const char * val)\n{\n    char tmp_str[ASCIILINESZ+1];\n    return dictionary_set(ini, strlwc(entry, tmp_str, sizeof(tmp_str)), val) ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Delete an entry in a dictionary\n  @param    ini     Dictionary to modify\n  @param    entry   Entry to delete (entry name)\n  @return   void\n\n  If the given entry can be found, it is deleted from the dictionary.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_unset(dictionary * ini, const char * entry)\n{\n    char tmp_str[ASCIILINESZ+1];\n    dictionary_unset(ini, strlwc(entry, tmp_str, sizeof(tmp_str)));\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Load a single line from an INI file\n  @param    input_line  Input line, may be concatenated multi-line input\n  @param    section     Output space to store section\n  @param    key         Output space to store key\n  @param    value       Output space to store value\n  @return   line_status value\n */\n/*--------------------------------------------------------------------------*/\nstatic line_status iniparser_line(\n    const char * input_line,\n    char * section,\n    char * key,\n    char * value)\n{\n    line_status sta ;\n    char * line = NULL;\n    size_t      len ;\n\n    line = _strdup(input_line);\n    len = strstrip(line);\n\n    sta = LINE_UNPROCESSED ;\n    if (len<1) {\n        /* Empty line */\n        sta = LINE_EMPTY ;\n    } else if (line[0]=='#' || line[0]==';') {\n        /* Comment line */\n        sta = LINE_COMMENT ;\n    } else if (line[0]=='[' && line[len-1]==']') {\n        /* Section name */\n        sscanf(line, \"[%[^]]\", section);\n        strstrip(section);\n        strlwc(section, section, len);\n        sta = LINE_SECTION ;\n    } else if (sscanf (line, \"%[^=] = \\\"%[^\\\"]\\\"\", key, value) == 2\n           ||  sscanf (line, \"%[^=] = '%[^\\']'\",   key, value) == 2\n           ||  sscanf (line, \"%[^=] = %[^;#]\",     key, value) == 2) {\n        /* Usual key=value, with or without comments */\n        strstrip(key);\n        strlwc(key, key, len);\n        strstrip(value);\n        /*\n         * sscanf cannot handle '' or \"\" as empty values\n         * this is done here\n         */\n        if (!strcmp(value, \"\\\"\\\"\") || (!strcmp(value, \"''\"))) {\n            value[0]=0 ;\n        }\n        sta = LINE_VALUE ;\n    } else if (sscanf(line, \"%[^=] = %[;#]\", key, value)==2\n           ||  sscanf(line, \"%[^=] %[=]\", key, value) == 2) {\n        /*\n         * Special cases:\n         * key=\n         * key=;\n         * key=#\n         */\n        strstrip(key);\n        strlwc(key, key, len);\n        value[0]=0 ;\n        sta = LINE_VALUE ;\n    } else {\n        /* Generate syntax error */\n        sta = LINE_ERROR ;\n    }\n\n    free(line);\n    return sta ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Parse an ini file and return an allocated dictionary object\n  @param    ininame Name of the ini file to read.\n  @return   Pointer to newly allocated dictionary\n\n  This is the parser for ini files. This function is called, providing\n  the name of the file to be read. It returns a dictionary object that\n  should not be accessed directly, but through accessor functions\n  instead.\n\n  The returned dictionary must be freed using iniparser_freedict().\n */\n/*--------------------------------------------------------------------------*/\ndictionary * iniparser_load(const char * ininame, load_options options)\n{\n    FILE * in ;\n\n    char line    [ASCIILINESZ+1] ;\n    char section [ASCIILINESZ+1] ;\n    char key     [ASCIILINESZ+1] ;\n    char tmp     [(ASCIILINESZ * 2) + 1] ;\n    char val     [ASCIILINESZ+1] ;\n\n    int  last=0 ;\n    int  len ;\n    int  lineno=0 ;\n    int  errs=0;\n\n    dictionary * dict ;\n\n    if ((in=fopen(ininame, \"r\"))==NULL) {\n        fprintf(stderr, \"iniparser: cannot open %s\\n\", ininame);\n        return NULL ;\n    }\n\n    dict = dictionary_new(0) ;\n    if (!dict) {\n        fclose(in);\n        return NULL ;\n    }\n\n    memset(line,    0, ASCIILINESZ);\n    memset(section, 0, ASCIILINESZ);\n    memset(key,     0, ASCIILINESZ);\n    memset(val,     0, ASCIILINESZ);\n    last=0 ;\n\n    while (fgets(line+last, ASCIILINESZ-last, in)!=NULL) {\n        lineno++ ;\n        len = (int)strlen(line)-1;\n        if (len==0)\n            continue;\n        /* Safety check against buffer overflows */\n        if (line[len]!='\\n' && !feof(in)) {\n            fprintf(stderr,\n                    \"iniparser: input line too long in %s (%d)\\n\",\n                    ininame,\n                    lineno);\n            dictionary_del(dict);\n            fclose(in);\n            return NULL ;\n        }\n        /* Get rid of \\n and spaces at end of line */\n        while ((len>=0) &&\n                ((line[len]=='\\n') || (isspace(line[len])))) {\n            line[len]=0 ;\n            len-- ;\n        }\n        if (len < 0) { /* Line was entirely \\n and/or spaces */\n            len = 0;\n        }\n        /* Detect multi-line */\n        if (line[len]=='\\\\') {\n            /* Multi-line value */\n            last=len ;\n            continue ;\n        } else {\n            last=0 ;\n        }\n        switch (iniparser_line(line, section, key, val)) {\n            case LINE_EMPTY:\n            case LINE_COMMENT:\n            break ;\n\n            case LINE_SECTION:\n            errs = dictionary_set(dict, section, NULL);\n            break ;\n\n            case LINE_VALUE:\n            sprintf(tmp, \"%s:%s\", section, key);\n            errs = dictionary_set(dict, tmp, val) ;\n            break ;\n\n            case LINE_ERROR:\n\n            if(options & HIDE_ERRORED_LINE_CONTENT) {\n              fprintf(stderr, \"iniparser: syntax error in %s (%d)\\n\",\n                      ininame,\n                      lineno);\n            }\n            else {\n              fprintf(stderr, \"iniparser: syntax error in %s (%d):\\n\",\n                      ininame,\n                      lineno);\n              fprintf(stderr, \"-> %s\\n\", line);\n            }\n            errs++ ;\n            break;\n\n            default:\n            break ;\n        }\n        memset(line, 0, ASCIILINESZ);\n        last=0;\n        if (errs<0) {\n            fprintf(stderr, \"iniparser: memory allocation failure\\n\");\n            break ;\n        }\n    }\n    if (errs) {\n        dictionary_del(dict);\n        dict = NULL ;\n    }\n    fclose(in);\n    return dict ;\n}\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Free all memory associated to an ini dictionary\n  @param    d Dictionary to free\n  @return   void\n\n  Free all memory associated to an ini dictionary.\n  It is mandatory to call this function before the dictionary object\n  gets out of the current context.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_freedict(dictionary * d)\n{\n    dictionary_del(d);\n}\n", "\n/*-------------------------------------------------------------------------*/\n/**\n   @file    iniparser.h\n   @author  N. Devillard\n   @brief   Parser for ini files.\n*/\n/*--------------------------------------------------------------------------*/\n\n#ifndef _INIPARSER_H_\n#define _INIPARSER_H_\n\n/*---------------------------------------------------------------------------\n                                Includes\n ---------------------------------------------------------------------------*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * The following #include is necessary on many Unixes but not Linux.\n * It is not needed for Windows platforms.\n * Uncomment it if needed.\n */\n/* #include <unistd.h> */\n\n#include \"dictionary.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n  HIDE_ERRORED_LINE_CONTENT = (1<<0)\n} load_options;\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get number of sections in a dictionary\n  @param    d   Dictionary to examine\n  @return   int Number of sections found in dictionary\n\n  This function returns the number of sections found in a dictionary.\n  The test to recognize sections is done on the string stored in the\n  dictionary: a section name is given as \"section\" whereas a key is\n  stored as \"section:key\", thus the test looks for entries that do not\n  contain a colon.\n\n  This clearly fails in the case a section name contains a colon, but\n  this should simply be avoided.\n\n  This function returns -1 in case of error.\n */\n/*--------------------------------------------------------------------------*/\n\nint iniparser_getnsec(const dictionary * d);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get name for section n in a dictionary.\n  @param    d   Dictionary to examine\n  @param    n   Section number (from 0 to nsec-1).\n  @return   Pointer to char string\n\n  This function locates the n-th section in a dictionary and returns\n  its name as a pointer to a string statically allocated inside the\n  dictionary. Do not free or modify the returned string!\n\n  This function returns NULL in case of error.\n */\n/*--------------------------------------------------------------------------*/\n\nconst char * iniparser_getsecname(const dictionary * d, int n);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given dictionary into a loadable ini file.\n  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\n\nvoid iniparser_dump_ini(const dictionary * d, FILE * f);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Save a dictionary section to a loadable ini file\n  @param    d   Dictionary to dump\n  @param    s   Section name of dictionary to dump\n  @param    f   Opened file pointer to dump to\n  @return   void\n\n  This function dumps a given section of a given dictionary into a loadable ini\n  file.  It is Ok to specify @c stderr or @c stdout as output files.\n */\n/*--------------------------------------------------------------------------*/\n\nvoid iniparser_dumpsection_ini(const dictionary * d, const char * s, FILE * f);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Dump a dictionary to an opened file pointer.\n  @param    d   Dictionary to dump.\n  @param    f   Opened file pointer to dump to.\n  @return   void\n\n  This function prints out the contents of a dictionary, one element by\n  line, onto the provided file pointer. It is OK to specify @c stderr\n  or @c stdout as output files. This function is meant for debugging\n  purposes mostly.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_dump(const dictionary * d, FILE * f);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d   Dictionary to examine\n  @param    s   Section name of dictionary to examine\n  @return   Number of keys in section\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getsecnkeys(const dictionary * d, const char * s);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the number of keys in a section of a dictionary.\n  @param    d    Dictionary to examine\n  @param    s    Section name of dictionary to examine\n  @param    keys Already allocated array to store the keys in\n  @return   The pointer passed as `keys` argument or NULL in case of error\n\n  This function queries a dictionary and finds all keys in a given section.\n  The keys argument should be an array of pointers which size has been\n  determined by calling `iniparser_getsecnkeys` function prior to this one.\n\n  Each pointer in the returned char pointer-to-pointer is pointing to\n  a string allocated in the dictionary; do not free or modify them.\n */\n/*--------------------------------------------------------------------------*/\nconst char ** iniparser_getseckeys(const dictionary * d, const char * s, const char ** keys);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key\n  @param    d       Dictionary to search\n  @param    key     Key string to look for\n  @param    def     Default value to return if key not found.\n  @return   pointer to statically allocated character string\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the pointer passed as 'def' is returned.\n  The returned char pointer is pointing to a string allocated in\n  the dictionary, do not free or modify it.\n */\n/*--------------------------------------------------------------------------*/\nconst char * iniparser_getstring(const dictionary * d, const char * key, const char * def);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to an int\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   integer\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n\n  Supported values for integers include the usual C notation\n  so decimal, octal (starting with 0) and hexadecimal (starting with 0x)\n  are supported. Examples:\n\n  - \"42\"      ->  42\n  - \"042\"     ->  34 (octal -> decimal)\n  - \"0x42\"    ->  66 (hexa  -> decimal)\n\n  Warning: the conversion may overflow in various ways. Conversion is\n  totally outsourced to strtol(), see the associated man page for overflow\n  handling.\n\n  Credits: Thanks to A. Becker for suggesting strtol()\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getint(const dictionary * d, const char * key, int notfound);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a double\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   double\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n */\n/*--------------------------------------------------------------------------*/\ndouble iniparser_getdouble(const dictionary * d, const char * key, double notfound);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Get the string associated to a key, convert to a boolean\n  @param    d Dictionary to search\n  @param    key Key string to look for\n  @param    notfound Value to return in case of error\n  @return   integer\n\n  This function queries a dictionary for a key. A key as read from an\n  ini file is given as \"section:key\". If the key cannot be found,\n  the notfound value is returned.\n\n  A true boolean is found if one of the following is matched:\n\n  - A string starting with 'y'\n  - A string starting with 'Y'\n  - A string starting with 't'\n  - A string starting with 'T'\n  - A string starting with '1'\n\n  A false boolean is found if one of the following is matched:\n\n  - A string starting with 'n'\n  - A string starting with 'N'\n  - A string starting with 'f'\n  - A string starting with 'F'\n  - A string starting with '0'\n\n  The notfound value returned if no boolean is identified, does not\n  necessarily have to be 0 or 1.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_getboolean(const dictionary * d, const char * key, int notfound);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Set an entry in a dictionary.\n  @param    ini     Dictionary to modify.\n  @param    entry   Entry to modify (entry name)\n  @param    val     New value to associate to the entry.\n  @return   int     0 if Ok, -1 otherwise.\n\n  If the given entry can be found in the dictionary, it is modified to\n  contain the provided value. If it cannot be found, the entry is created.\n  It is Ok to set val to NULL.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_set(dictionary * ini, const char * entry, const char * val);\n\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Delete an entry in a dictionary\n  @param    ini     Dictionary to modify\n  @param    entry   Entry to delete (entry name)\n  @return   void\n\n  If the given entry can be found, it is deleted from the dictionary.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_unset(dictionary * ini, const char * entry);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Finds out if a given entry exists in a dictionary\n  @param    ini     Dictionary to search\n  @param    entry   Name of the entry to look for\n  @return   integer 1 if entry exists, 0 otherwise\n\n  Finds out if a given entry exists in the dictionary. Since sections\n  are stored as keys with NULL associated values, this is the only way\n  of querying for the presence of sections in a dictionary.\n */\n/*--------------------------------------------------------------------------*/\nint iniparser_find_entry(const dictionary * ini, const char * entry) ;\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Parse an ini file and return an allocated dictionary object\n  @param    ininame Name of the ini file to read.\n  @param    options Name of the ini file to read.\n  @return   Pointer to newly allocated dictionary\n\n  This is the parser for ini files. This function is called, providing\n  the name of the file to be read. It returns a dictionary object that\n  should not be accessed directly, but through accessor functions\n  instead.\n\n  The returned dictionary must be freed using iniparser_freedict().\n */\n/*--------------------------------------------------------------------------*/\ndictionary * iniparser_load(const char * ininame, load_options options);\n\n/*-------------------------------------------------------------------------*/\n/**\n  @brief    Free all memory associated to an ini dictionary\n  @param    d Dictionary to free\n  @return   void\n\n  Free all memory associated to an ini dictionary.\n  It is mandatory to call this function before the dictionary object\n  gets out of the current context.\n */\n/*--------------------------------------------------------------------------*/\nvoid iniparser_freedict(dictionary * d);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*\n *   This file is part of ubridge, a program to bridge network interfaces\n *   to UDP tunnels.\n *\n *   Copyright (C) 2015 GNS3 Technologies Inc.\n *\n *   ubridge is free software: you can redistribute it and/or modify it\n *   under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, either version 3 of the License, or\n *   (at your option) any later version.\n *\n *   ubridge is distributed in the hope that it will be useful, but\n *   WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"parse.h\"\n#include \"nio_udp.h\"\n#include \"nio_unix.h\"\n#include \"nio_ethernet.h\"\n#include \"nio_tap.h\"\n#include \"pcap_capture.h\"\n#include \"pcap_filter.h\"\n\n#ifdef LINUX_RAW\n#include \"nio_linux_raw.h\"\n#endif\n\n#ifdef __APPLE__\n#include \"nio_fusion_vmnet.h\"\n#endif\n\nstatic nio_t *create_udp_tunnel(const char *params)\n{\n  nio_t *nio;\n  char *local_port;\n  char *remote_host;\n  char *remote_port;\n\n  printf(\"Creating UDP tunnel %s\\n\", params);\n  local_port = strtok((char *)params, \":\");\n  remote_host = strtok(NULL, \":\");\n  remote_port = strtok(NULL, \":\");\n  if (local_port == NULL || remote_host == NULL || remote_port == NULL) {\n     fprintf(stderr, \"invalid UDP tunnel syntax\\n\");\n     return NULL;\n  }\n\n  nio = create_nio_udp(atoi(local_port), remote_host, atoi(remote_port));\n  if (!nio)\n    fprintf(stderr, \"unable to create UDP NIO\\n\");\n  return nio;\n}\n\nstatic nio_t *create_unix_socket(const char *params)\n{\n  nio_t *nio;\n  char *local;\n  char *remote;\n\n  printf(\"Creating UNIX domain socket %s\\n\", params);\n  local = strtok((char *)params, \":\");\n  remote = strtok(NULL, \":\");\n  if (local == NULL || remote == NULL) {\n     fprintf(stderr, \"invalid UNIX domain socket syntax\\n\");\n     return NULL;\n  }\n  nio = create_nio_unix(local, remote);\n  if (!nio)\n    fprintf(stderr, \"unable to create UNIX NIO\\n\");\n  return nio;\n}\n\nstatic nio_t *open_ethernet_device(const char *dev_name)\n{\n  nio_t *nio;\n\n  printf(\"Opening Ethernet device %s\\n\", dev_name);\n  nio = create_nio_ethernet((char *)dev_name);\n  if (!nio)\n    fprintf(stderr, \"unable to open Ethernet device\\n\");\n  return nio;\n}\n\nstatic nio_t *open_tap_device(const char *dev_name)\n{\n  nio_t *nio;\n\n  printf(\"Opening TAP device %s\\n\", dev_name);\n  nio = create_nio_tap((char *)dev_name);\n  if (!nio)\n    fprintf(stderr, \"unable to open TAP device\\n\");\n  return nio;\n}\n\n#ifdef LINUX_RAW\nstatic nio_t *open_linux_raw(const char *dev_name)\n{\n  nio_t *nio;\n\n  printf(\"Opening Linux RAW device %s\\n\", dev_name);\n  nio = create_nio_linux_raw((char *)dev_name);\n  if (!nio)\n    fprintf(stderr, \"unable to open RAW device\\n\");\n  return nio;\n}\n#endif\n\n#ifdef __APPLE__\nstatic nio_t *open_fusion_vmnet(const char *vmnet_name)\n{\n  nio_t *nio;\n\n  printf(\"Opening Fusion VMnet %s\\n\", vmnet_name);\n  nio = create_nio_fusion_vmnet((char *)vmnet_name);\n  if (!nio)\n    fprintf(stderr, \"unable to open Fusion VMnet interface\\n\");\n  return nio;\n}\n\n#endif\n\nstatic int getstr(dictionary *ubridge_config, const char *section, const char *entry, const char **value)\n{\n    char key[MAX_KEY_SIZE];\n\n    snprintf(key, MAX_KEY_SIZE, \"%s:%s\", section, entry);\n    *value = iniparser_getstring(ubridge_config, key, NULL);\n    if (*value)\n      return TRUE;\n    return FALSE;\n}\n\nstatic bridge_t *add_bridge(bridge_t **head)\n{\n   bridge_t *bridge;\n\n   if ((bridge = malloc(sizeof(*bridge))) != NULL) {\n      memset(bridge, 0, sizeof(*bridge));\n      bridge->next = *head;\n      *head = bridge;\n   }\n   return bridge;\n}\n\nstatic void parse_capture(dictionary *ubridge_config, const char *bridge_name, bridge_t *bridge)\n{\n    const char *pcap_file = NULL;\n    const char *pcap_linktype = \"EN10MB\";\n\n    getstr(ubridge_config, bridge_name, \"pcap_protocol\", &pcap_linktype);\n    if (getstr(ubridge_config, bridge_name, \"pcap_file\", &pcap_file)) {\n        printf(\"Starting packet capture to %s with protocol %s\\n\", pcap_file, pcap_linktype);\n        bridge->capture = create_pcap_capture(pcap_file, pcap_linktype);\n    }\n}\n\nstatic void parse_filter(dictionary *ubridge_config, const char *bridge_name, bridge_t *bridge)\n{\n    const char *pcap_filter = NULL;\n\n    if (getstr(ubridge_config, bridge_name, \"pcap_filter\", &pcap_filter)) {\n        printf(\"Applying PCAP filter '%s'\\n\", pcap_filter);\n        if (bridge->source_nio->type == NIO_TYPE_ETHERNET) {\n            if (set_pcap_filter(bridge->source_nio->dptr, pcap_filter) < 0)\n               fprintf(stderr, \"unable to apply filter to source NIO\\n\");\n        }\n        else if (bridge->destination_nio->type == NIO_TYPE_ETHERNET) {\n            if (set_pcap_filter(bridge->destination_nio->dptr, pcap_filter) < 0)\n               fprintf(stderr, \"unable to apply filter to destination NIO\\n\");\n        }\n    }\n}\n\nint parse_config(char *filename, bridge_t **bridges)\n{\n    dictionary *ubridge_config = NULL;\n    const char *value;\n    const char *bridge_name;\n    int i, nsec;\n\n    if ((ubridge_config = iniparser_load(filename, HIDE_ERRORED_LINE_CONTENT)) == NULL) {\n       return FALSE;\n    }\n\n    nsec = iniparser_getnsec(ubridge_config);\n    for (i = 0; i < nsec; i++) {\n        bridge_t *bridge;\n        nio_t *source_nio = NULL;\n        nio_t *destination_nio = NULL;\n\n        bridge_name = iniparser_getsecname(ubridge_config, i);\n        printf(\"Parsing %s\\n\", bridge_name);\n        if (getstr(ubridge_config, bridge_name, \"source_udp\", &value))\n           source_nio = create_udp_tunnel(value);\n        else if (getstr(ubridge_config, bridge_name, \"source_unix\", &value))\n           source_nio = create_unix_socket(value);\n        else if (getstr(ubridge_config, bridge_name, \"source_ethernet\", &value))\n           source_nio = open_ethernet_device(value);\n        else if (getstr(ubridge_config, bridge_name, \"source_tap\", &value))\n           source_nio = open_tap_device(value);\n#ifdef LINUX_RAW\n        else if (getstr(ubridge_config, bridge_name, \"source_linux_raw\", &value))\n           source_nio = open_linux_raw(value);\n#endif\n#ifdef __APPLE__\n        else if (getstr(ubridge_config, bridge_name, \"source_fusion_vmnet\", &value))\n           source_nio = open_fusion_vmnet(value);\n#endif\n        else\n           fprintf(stderr, \"source NIO not found\\n\");\n\n        if (getstr(ubridge_config, bridge_name, \"destination_udp\", &value))\n           destination_nio = create_udp_tunnel(value);\n        else if (getstr(ubridge_config, bridge_name, \"destination_unix\", &value))\n           destination_nio = create_unix_socket(value);\n        else if (getstr(ubridge_config, bridge_name, \"destination_ethernet\", &value))\n           destination_nio = open_ethernet_device(value);\n        else if (getstr(ubridge_config, bridge_name, \"destination_tap\", &value))\n           destination_nio = open_tap_device(value);\n#ifdef LINUX_RAW\n        else if (getstr(ubridge_config, bridge_name, \"destination_linux_raw\", &value))\n           source_nio = open_linux_raw(value);\n#endif\n#ifdef __APPLE__\n        else if (getstr(ubridge_config, bridge_name, \"destination_fusion_vmnet\", &value))\n           destination_nio = open_fusion_vmnet(value);\n#endif\n        else\n           fprintf(stderr, \"destination NIO not found\\n\");\n\n        if (source_nio && destination_nio) {\n           bridge = add_bridge(bridges);\n           bridge->source_nio = source_nio;\n           bridge->destination_nio = destination_nio;\n           if (!(bridge->name = strdup(bridge_name))) {\n              fprintf(stderr, \"bridge creation: insufficient memory\\n\");\n              return FALSE;\n           }\n           parse_capture(ubridge_config, bridge_name, bridge);\n           parse_filter(ubridge_config, bridge_name, bridge);\n        }\n        else if (source_nio != NULL)\n           free_nio(source_nio);\n        else if (destination_nio != NULL)\n           free_nio(destination_nio);\n    }\n    iniparser_freedict(ubridge_config);\n    return TRUE;\n}\n"], "filenames": ["src/iniparser/iniparser.c", "src/iniparser/iniparser.h", "src/parse.c"], "buggy_code_start_loc": [629, 32, 189], "buggy_code_end_loc": [714, 300, 190], "fixing_code_start_loc": [629, 33, 189], "fixing_code_end_loc": [722, 305, 190], "type": "CWE-269", "message": "GNS3 ubridge through 0.9.18 on macOS, as used in GNS3 server before 2.1.17, allows a local attacker to read arbitrary files because it handles configuration-file errors by printing the configuration file while executing in a setuid root context.", "other": {"cve": {"id": "CVE-2020-14976", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-23T20:15:12.927", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GNS3 ubridge through 0.9.18 on macOS, as used in GNS3 server before 2.1.17, allows a local attacker to read arbitrary files because it handles configuration-file errors by printing the configuration file while executing in a setuid root context."}, {"lang": "es", "value": "GNS3 ubridge versiones hasta 0.9.18 en macOS, como es usado en el servidor GNS3 anterior a 2.1.17, permite a un atacante local leer archivos arbitrarios porque maneja los errores del archivo de configuraci\u00f3n al imprimir el archivo de configuraci\u00f3n mientras se ejecuta en un contexto root setuid"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gns3:ubridge:*:*:*:*:*:macos:*:*", "versionEndIncluding": "0.9.18", "matchCriteriaId": "AC12F845-737F-4705-BB59-10DE517FFF7D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:gns3:gns3:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.17", "matchCriteriaId": "B0191C9C-7BAD-4FAE-A6F5-9F0815F37963"}]}]}], "references": [{"url": "https://github.com/GNS3/gns3-server/releases/tag/v2.1.17", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/GNS3/ubridge/commit/2eb0d1dab6a6de76cf3556130a2d52af101077db", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://theevilbit.github.io/posts/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.gns3.com/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/GNS3/ubridge/commit/2eb0d1dab6a6de76cf3556130a2d52af101077db"}}