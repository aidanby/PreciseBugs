{"buggy_code": ["package jsonpatch\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\teRaw = iota\n\teDoc\n\teAry\n)\n\ntype lazyNode struct {\n\traw   *json.RawMessage\n\tdoc   partialDoc\n\tary   partialArray\n\twhich int\n}\n\ntype operation map[string]*json.RawMessage\n\n// Patch is an ordered collection of operations.\ntype Patch []operation\n\ntype partialDoc map[string]*lazyNode\ntype partialArray []*lazyNode\n\ntype container interface {\n\tget(key string) (*lazyNode, error)\n\tset(key string, val *lazyNode) error\n\tadd(key string, val *lazyNode) error\n\tremove(key string) error\n}\n\nfunc newLazyNode(raw *json.RawMessage) *lazyNode {\n\treturn &lazyNode{raw: raw, doc: nil, ary: nil, which: eRaw}\n}\n\nfunc (n *lazyNode) MarshalJSON() ([]byte, error) {\n\tswitch n.which {\n\tcase eRaw:\n\t\treturn json.Marshal(n.raw)\n\tcase eDoc:\n\t\treturn json.Marshal(n.doc)\n\tcase eAry:\n\t\treturn json.Marshal(n.ary)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Unknown type\")\n\t}\n}\n\nfunc (n *lazyNode) UnmarshalJSON(data []byte) error {\n\tdest := make(json.RawMessage, len(data))\n\tcopy(dest, data)\n\tn.raw = &dest\n\tn.which = eRaw\n\treturn nil\n}\n\nfunc (n *lazyNode) intoDoc() (*partialDoc, error) {\n\tif n.which == eDoc {\n\t\treturn &n.doc, nil\n\t}\n\n\tif n.raw == nil {\n\t\treturn nil, fmt.Errorf(\"Unable to unmarshal nil pointer as partial document\")\n\t}\n\n\terr := json.Unmarshal(*n.raw, &n.doc)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tn.which = eDoc\n\treturn &n.doc, nil\n}\n\nfunc (n *lazyNode) intoAry() (*partialArray, error) {\n\tif n.which == eAry {\n\t\treturn &n.ary, nil\n\t}\n\n\tif n.raw == nil {\n\t\treturn nil, fmt.Errorf(\"Unable to unmarshal nil pointer as partial array\")\n\t}\n\n\terr := json.Unmarshal(*n.raw, &n.ary)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tn.which = eAry\n\treturn &n.ary, nil\n}\n\nfunc (n *lazyNode) compact() []byte {\n\tbuf := &bytes.Buffer{}\n\n\tif n.raw == nil {\n\t\treturn nil\n\t}\n\n\terr := json.Compact(buf, *n.raw)\n\n\tif err != nil {\n\t\treturn *n.raw\n\t}\n\n\treturn buf.Bytes()\n}\n\nfunc (n *lazyNode) tryDoc() bool {\n\tif n.raw == nil {\n\t\treturn false\n\t}\n\n\terr := json.Unmarshal(*n.raw, &n.doc)\n\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tn.which = eDoc\n\treturn true\n}\n\nfunc (n *lazyNode) tryAry() bool {\n\tif n.raw == nil {\n\t\treturn false\n\t}\n\n\terr := json.Unmarshal(*n.raw, &n.ary)\n\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tn.which = eAry\n\treturn true\n}\n\nfunc (n *lazyNode) equal(o *lazyNode) bool {\n\tif n.which == eRaw {\n\t\tif !n.tryDoc() && !n.tryAry() {\n\t\t\tif o.which != eRaw {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\treturn bytes.Equal(n.compact(), o.compact())\n\t\t}\n\t}\n\n\tif n.which == eDoc {\n\t\tif o.which == eRaw {\n\t\t\tif !o.tryDoc() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tif o.which != eDoc {\n\t\t\treturn false\n\t\t}\n\n\t\tfor k, v := range n.doc {\n\t\t\tov, ok := o.doc[k]\n\n\t\t\tif !ok {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tif v == nil && ov == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !v.equal(ov) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\tif o.which != eAry && !o.tryAry() {\n\t\treturn false\n\t}\n\n\tif len(n.ary) != len(o.ary) {\n\t\treturn false\n\t}\n\n\tfor idx, val := range n.ary {\n\t\tif !val.equal(o.ary[idx]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (o operation) kind() string {\n\tif obj, ok := o[\"op\"]; ok {\n\t\tvar op string\n\n\t\terr := json.Unmarshal(*obj, &op)\n\n\t\tif err != nil {\n\t\t\treturn \"unknown\"\n\t\t}\n\n\t\treturn op\n\t}\n\n\treturn \"unknown\"\n}\n\nfunc (o operation) path() string {\n\tif obj, ok := o[\"path\"]; ok {\n\t\tvar op string\n\n\t\terr := json.Unmarshal(*obj, &op)\n\n\t\tif err != nil {\n\t\t\treturn \"unknown\"\n\t\t}\n\n\t\treturn op\n\t}\n\n\treturn \"unknown\"\n}\n\nfunc (o operation) from() string {\n\tif obj, ok := o[\"from\"]; ok {\n\t\tvar op string\n\n\t\terr := json.Unmarshal(*obj, &op)\n\n\t\tif err != nil {\n\t\t\treturn \"unknown\"\n\t\t}\n\n\t\treturn op\n\t}\n\n\treturn \"unknown\"\n}\n\nfunc (o operation) value() *lazyNode {\n\tif obj, ok := o[\"value\"]; ok {\n\t\treturn newLazyNode(obj)\n\t}\n\n\treturn nil\n}\n\nfunc isArray(buf []byte) bool {\nLoop:\n\tfor _, c := range buf {\n\t\tswitch c {\n\t\tcase ' ':\n\t\tcase '\\n':\n\t\tcase '\\t':\n\t\t\tcontinue\n\t\tcase '[':\n\t\t\treturn true\n\t\tdefault:\n\t\t\tbreak Loop\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc findObject(pd *container, path string) (container, string) {\n\tdoc := *pd\n\n\tsplit := strings.Split(path, \"/\")\n\n\tif len(split) < 2 {\n\t\treturn nil, \"\"\n\t}\n\n\tparts := split[1 : len(split)-1]\n\n\tkey := split[len(split)-1]\n\n\tvar err error\n\n\tfor _, part := range parts {\n\n\t\tnext, ok := doc.get(decodePatchKey(part))\n\n\t\tif next == nil || ok != nil {\n\t\t\treturn nil, \"\"\n\t\t}\n\n\t\tif isArray(*next.raw) {\n\t\t\tdoc, err = next.intoAry()\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\"\n\t\t\t}\n\t\t} else {\n\t\t\tdoc, err = next.intoDoc()\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\"\n\t\t\t}\n\t\t}\n\t}\n\n\treturn doc, decodePatchKey(key)\n}\n\nfunc (d *partialDoc) set(key string, val *lazyNode) error {\n\t(*d)[key] = val\n\treturn nil\n}\n\nfunc (d *partialDoc) add(key string, val *lazyNode) error {\n\t(*d)[key] = val\n\treturn nil\n}\n\nfunc (d *partialDoc) get(key string) (*lazyNode, error) {\n\treturn (*d)[key], nil\n}\n\nfunc (d *partialDoc) remove(key string) error {\n\t_, ok := (*d)[key]\n\tif !ok {\n\t\treturn fmt.Errorf(\"Unable to remove nonexistent key: %s\", key)\n\t}\n\n\tdelete(*d, key)\n\treturn nil\n}\n\nfunc (d *partialArray) set(key string, val *lazyNode) error {\n\tif key == \"-\" {\n\t\t*d = append(*d, val)\n\t\treturn nil\n\t}\n\n\tidx, err := strconv.Atoi(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsz := len(*d)\n\tif idx+1 > sz {\n\t\tsz = idx + 1\n\t}\n\n\tary := make([]*lazyNode, sz)\n\n\tcur := *d\n\n\tcopy(ary, cur)\n\n\tif idx >= len(ary) {\n\t\treturn fmt.Errorf(\"Unable to access invalid index: %d\", idx)\n\t}\n\n\tary[idx] = val\n\n\t*d = ary\n\treturn nil\n}\n\nfunc (d *partialArray) add(key string, val *lazyNode) error {\n\tif key == \"-\" {\n\t\t*d = append(*d, val)\n\t\treturn nil\n\t}\n\n\tidx, err := strconv.Atoi(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tary := make([]*lazyNode, len(*d)+1)\n\n\tcur := *d\n\n\tif idx < 0 {\n\t\tidx *= -1\n\n\t\tif idx > len(ary) {\n\t\t\treturn fmt.Errorf(\"Unable to access invalid index: %d\", idx)\n\t\t}\n\t\tidx = len(ary) - idx\n\t}\n\n\tcopy(ary[0:idx], cur[0:idx])\n\tary[idx] = val\n\tcopy(ary[idx+1:], cur[idx:])\n\n\t*d = ary\n\treturn nil\n}\n\nfunc (d *partialArray) get(key string) (*lazyNode, error) {\n\tidx, err := strconv.Atoi(key)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif idx >= len(*d) {\n\t\treturn nil, fmt.Errorf(\"Unable to access invalid index: %d\", idx)\n\t}\n\n\treturn (*d)[idx], nil\n}\n\nfunc (d *partialArray) remove(key string) error {\n\tidx, err := strconv.Atoi(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcur := *d\n\n\tif idx >= len(cur) {\n\t\treturn fmt.Errorf(\"Unable to remove invalid index: %d\", idx)\n\t}\n\n\tary := make([]*lazyNode, len(cur)-1)\n\n\tcopy(ary[0:idx], cur[0:idx])\n\tcopy(ary[idx:], cur[idx+1:])\n\n\t*d = ary\n\treturn nil\n\n}\n\nfunc (p Patch) add(doc *container, op operation) error {\n\tpath := op.path()\n\n\tcon, key := findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch add operation does not apply: doc is missing path: %s\", path)\n\t}\n\n\treturn con.add(key, op.value())\n}\n\nfunc (p Patch) remove(doc *container, op operation) error {\n\tpath := op.path()\n\n\tcon, key := findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch remove operation does not apply: doc is missing path: %s\", path)\n\t}\n\n\treturn con.remove(key)\n}\n\nfunc (p Patch) replace(doc *container, op operation) error {\n\tpath := op.path()\n\n\tcon, key := findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch replace operation does not apply: doc is missing path: %s\", path)\n\t}\n\n\tval, ok := con.get(key)\n\tif val == nil || ok != nil {\n\t\treturn fmt.Errorf(\"jsonpatch replace operation does not apply: doc is missing key: %s\", path)\n\t}\n\n\treturn con.set(key, op.value())\n}\n\nfunc (p Patch) move(doc *container, op operation) error {\n\tfrom := op.from()\n\n\tcon, key := findObject(doc, from)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch move operation does not apply: doc is missing from path: %s\", from)\n\t}\n\n\tval, err := con.get(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = con.remove(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpath := op.path()\n\n\tcon, key = findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch move operation does not apply: doc is missing destination path: %s\", path)\n\t}\n\n\treturn con.set(key, val)\n}\n\nfunc (p Patch) test(doc *container, op operation) error {\n\tpath := op.path()\n\n\tcon, key := findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch test operation does not apply: is missing path: %s\", path)\n\t}\n\n\tval, err := con.get(key)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif val == nil {\n\t\tif op.value().raw == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"Testing value %s failed\", path)\n\t}\n\n\tif val.equal(op.value()) {\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"Testing value %s failed\", path)\n}\n\nfunc (p Patch) copy(doc *container, op operation) error {\n\tfrom := op.from()\n\n\tcon, key := findObject(doc, from)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch copy operation does not apply: doc is missing from path: %s\", from)\n\t}\n\n\tval, err := con.get(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpath := op.path()\n\n\tcon, key = findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch copy operation does not apply: doc is missing destination path: %s\", path)\n\t}\n\n\treturn con.set(key, val)\n}\n\n// Equal indicates if 2 JSON documents have the same structural equality.\nfunc Equal(a, b []byte) bool {\n\tra := make(json.RawMessage, len(a))\n\tcopy(ra, a)\n\tla := newLazyNode(&ra)\n\n\trb := make(json.RawMessage, len(b))\n\tcopy(rb, b)\n\tlb := newLazyNode(&rb)\n\n\treturn la.equal(lb)\n}\n\n// DecodePatch decodes the passed JSON document as an RFC 6902 patch.\nfunc DecodePatch(buf []byte) (Patch, error) {\n\tvar p Patch\n\n\terr := json.Unmarshal(buf, &p)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn p, nil\n}\n\n// Apply mutates a JSON document according to the patch, and returns the new\n// document.\nfunc (p Patch) Apply(doc []byte) ([]byte, error) {\n\treturn p.ApplyIndent(doc, \"\")\n}\n\n// ApplyIndent mutates a JSON document according to the patch, and returns the new\n// document indented.\nfunc (p Patch) ApplyIndent(doc []byte, indent string) ([]byte, error) {\n\tvar pd container\n\tif doc[0] == '[' {\n\t\tpd = &partialArray{}\n\t} else {\n\t\tpd = &partialDoc{}\n\t}\n\n\terr := json.Unmarshal(doc, pd)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = nil\n\n\tfor _, op := range p {\n\t\tswitch op.kind() {\n\t\tcase \"add\":\n\t\t\terr = p.add(&pd, op)\n\t\tcase \"remove\":\n\t\t\terr = p.remove(&pd, op)\n\t\tcase \"replace\":\n\t\t\terr = p.replace(&pd, op)\n\t\tcase \"move\":\n\t\t\terr = p.move(&pd, op)\n\t\tcase \"test\":\n\t\t\terr = p.test(&pd, op)\n\t\tcase \"copy\":\n\t\t\terr = p.copy(&pd, op)\n\t\tdefault:\n\t\t\terr = fmt.Errorf(\"Unexpected kind: %s\", op.kind())\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif indent != \"\" {\n\t\treturn json.MarshalIndent(pd, \"\", indent)\n\t}\n\n\treturn json.Marshal(pd)\n}\n\n// From http://tools.ietf.org/html/rfc6901#section-4 :\n//\n// Evaluation of each reference token begins by decoding any escaped\n// character sequence.  This is performed by first transforming any\n// occurrence of the sequence '~1' to '/', and then transforming any\n// occurrence of the sequence '~0' to '~'.\n\nvar (\n\trfc6901Decoder = strings.NewReplacer(\"~1\", \"/\", \"~0\", \"~\")\n)\n\nfunc decodePatchKey(k string) string {\n\treturn rfc6901Decoder.Replace(k)\n}\n", "package jsonpatch\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc reformatJSON(j string) string {\n\tbuf := new(bytes.Buffer)\n\n\tjson.Indent(buf, []byte(j), \"\", \"  \")\n\n\treturn buf.String()\n}\n\nfunc compareJSON(a, b string) bool {\n\t// return Equal([]byte(a), []byte(b))\n\n\tvar objA, objB map[string]interface{}\n\tjson.Unmarshal([]byte(a), &objA)\n\tjson.Unmarshal([]byte(b), &objB)\n\n\t// fmt.Printf(\"Comparing %#v\\nagainst %#v\\n\", objA, objB)\n\treturn reflect.DeepEqual(objA, objB)\n}\n\nfunc applyPatch(doc, patch string) (string, error) {\n\tobj, err := DecodePatch([]byte(patch))\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tout, err := obj.Apply([]byte(doc))\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(out), nil\n}\n\ntype Case struct {\n\tdoc, patch, result string\n}\n\nvar Cases = []Case{\n\t{\n\t\t`{ \"foo\": \"bar\"}`,\n\t\t`[\n         { \"op\": \"add\", \"path\": \"/baz\", \"value\": \"qux\" }\n     ]`,\n\t\t`{\n       \"baz\": \"qux\",\n       \"foo\": \"bar\"\n     }`,\n\t},\n\t{\n\t\t`{ \"foo\": [ \"bar\", \"baz\" ] }`,\n\t\t`[\n     { \"op\": \"add\", \"path\": \"/foo/1\", \"value\": \"qux\" }\n    ]`,\n\t\t`{ \"foo\": [ \"bar\", \"qux\", \"baz\" ] }`,\n\t},\n\t{\n\t\t`{ \"foo\": [ \"bar\", \"baz\" ] }`,\n\t\t`[\n     { \"op\": \"add\", \"path\": \"/foo/-1\", \"value\": \"qux\" }\n    ]`,\n\t\t`{ \"foo\": [ \"bar\", \"baz\", \"qux\" ] }`,\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\", \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/baz\" } ]`,\n\t\t`{ \"foo\": \"bar\" }`,\n\t},\n\t{\n\t\t`{ \"foo\": [ \"bar\", \"qux\", \"baz\" ] }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/foo/1\" } ]`,\n\t\t`{ \"foo\": [ \"bar\", \"baz\" ] }`,\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\", \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" } ]`,\n\t\t`{ \"baz\": \"boo\", \"foo\": \"bar\" }`,\n\t},\n\t{\n\t\t`{\n     \"foo\": {\n       \"bar\": \"baz\",\n       \"waldo\": \"fred\"\n     },\n     \"qux\": {\n       \"corge\": \"grault\"\n     }\n   }`,\n\t\t`[ { \"op\": \"move\", \"from\": \"/foo/waldo\", \"path\": \"/qux/thud\" } ]`,\n\t\t`{\n     \"foo\": {\n       \"bar\": \"baz\"\n     },\n     \"qux\": {\n       \"corge\": \"grault\",\n       \"thud\": \"fred\"\n     }\n   }`,\n\t},\n\t{\n\t\t`{ \"foo\": [ \"all\", \"grass\", \"cows\", \"eat\" ] }`,\n\t\t`[ { \"op\": \"move\", \"from\": \"/foo/1\", \"path\": \"/foo/3\" } ]`,\n\t\t`{ \"foo\": [ \"all\", \"cows\", \"eat\", \"grass\" ] }`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/child\", \"value\": { \"grandchild\": { } } } ]`,\n\t\t`{ \"foo\": \"bar\", \"child\": { \"grandchild\": { } } }`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\"] }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/foo/-\", \"value\": [\"abc\", \"def\"] } ]`,\n\t\t`{ \"foo\": [\"bar\", [\"abc\", \"def\"]] }`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\", \"qux\": { \"baz\": 1, \"bar\": null } }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/qux/bar\" } ]`,\n\t\t`{ \"foo\": \"bar\", \"qux\": { \"baz\": 1 } }`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/baz\", \"value\": null } ]`,\n\t\t`{ \"baz\": null, \"foo\": \"bar\" }`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\"]}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/0\", \"value\": \"baz\"}]`,\n\t\t`{ \"foo\": [\"baz\"]}`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\",\"baz\"]}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/0\", \"value\": \"bum\"}]`,\n\t\t`{ \"foo\": [\"bum\",\"baz\"]}`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\",\"qux\",\"baz\"]}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/1\", \"value\": \"bum\"}]`,\n\t\t`{ \"foo\": [\"bar\", \"bum\",\"baz\"]}`,\n\t},\n\t{\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"]}]`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/0/foo/0\", \"value\": \"bum\"}]`,\n\t\t`[ {\"foo\": [\"bum\",\"qux\",\"baz\"]}]`,\n\t},\n\t{\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"], \"bar\": [\"qux\",\"baz\"]}]`,\n\t\t`[ { \"op\": \"copy\", \"from\": \"/0/foo/0\", \"path\": \"/0/bar/0\"}]`,\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"], \"bar\": [\"bar\", \"baz\"]}]`,\n\t},\n\t{\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"], \"bar\": [\"qux\",\"baz\"]}]`,\n\t\t`[ { \"op\": \"copy\", \"from\": \"/0/foo/0\", \"path\": \"/0/bar\"}]`,\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"], \"bar\": [\"bar\", \"qux\", \"baz\"]}]`,\n\t},\n\t{\n\t\t`[ { \"foo\": {\"bar\": [\"qux\",\"baz\"]}, \"baz\": {\"qux\": \"bum\"}}]`,\n\t\t`[ { \"op\": \"copy\", \"from\": \"/0/foo/bar\", \"path\": \"/0/baz/bar\"}]`,\n\t\t`[ { \"baz\": {\"bar\": [\"qux\",\"baz\"], \"qux\":\"bum\"}, \"foo\": {\"bar\": [\"qux\",\"baz\"]}}]`,\n\t},\n}\n\ntype BadCase struct {\n\tdoc, patch string\n}\n\nvar MutationTestCases = []BadCase{\n\t{\n\t\t`{ \"foo\": \"bar\", \"qux\": { \"baz\": 1, \"bar\": null } }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/qux/bar\" } ]`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\", \"qux\": { \"baz\": 1, \"bar\": null } }`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/qux/baz\", \"value\": null } ]`,\n\t},\n}\n\nvar BadCases = []BadCase{\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/baz/bat\", \"value\": \"qux\" } ]`,\n\t},\n\t{\n\t\t`{ \"a\": { \"b\": { \"d\": 1 } } }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/a/b/c\" } ]`,\n\t},\n\t{\n\t\t`{ \"a\": { \"b\": { \"d\": 1 } } }`,\n\t\t`[ { \"op\": \"move\", \"from\": \"/a/b/c\", \"path\": \"/a/b/e\" } ]`,\n\t},\n\t{\n\t\t`{ \"a\": { \"b\": [1] } }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/a/b/1\" } ]`,\n\t},\n\t{\n\t\t`{ \"a\": { \"b\": [1] } }`,\n\t\t`[ { \"op\": \"move\", \"from\": \"/a/b/1\", \"path\": \"/a/b/2\" } ]`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"pathz\": \"/baz\", \"value\": \"qux\" } ]`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"\", \"value\": \"qux\" } ]`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\",\"baz\"]}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/2\", \"value\": \"bum\"}]`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\",\"baz\"]}`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/foo/-4\", \"value\": \"bum\"}]`,\n\t},\n\n\t{\n\t\t`{ \"name\":{ \"foo\": \"bat\", \"qux\": \"bum\"}}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/bar\", \"value\":\"baz\"}]`,\n\t},\n}\n\nfunc TestAllCases(t *testing.T) {\n\tfor _, c := range Cases {\n\t\tout, err := applyPatch(c.doc, c.patch)\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unable to apply patch: %s\", err)\n\t\t}\n\n\t\tif !compareJSON(out, c.result) {\n\t\t\tt.Errorf(\"Patch did not apply. Expected:\\n%s\\n\\nActual:\\n%s\",\n\t\t\t\treformatJSON(c.result), reformatJSON(out))\n\t\t}\n\t}\n\n\tfor _, c := range MutationTestCases {\n\t\tout, err := applyPatch(c.doc, c.patch)\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unable to apply patch: %s\", err)\n\t\t}\n\n\t\tif compareJSON(out, c.doc) {\n\t\t\tt.Errorf(\"Patch did not apply. Original:\\n%s\\n\\nPatched:\\n%s\",\n\t\t\t\treformatJSON(c.doc), reformatJSON(out))\n\t\t}\n\t}\n\n\tfor _, c := range BadCases {\n\t\t_, err := applyPatch(c.doc, c.patch)\n\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Patch should have failed to apply but it did not\")\n\t\t}\n\t}\n}\n\ntype TestCase struct {\n\tdoc, patch string\n\tresult     bool\n\tfailedPath string\n}\n\nvar TestCases = []TestCase{\n\t{\n\t\t`{\n      \"baz\": \"qux\",\n      \"foo\": [ \"a\", 2, \"c\" ]\n    }`,\n\t\t`[\n      { \"op\": \"test\", \"path\": \"/baz\", \"value\": \"qux\" },\n      { \"op\": \"test\", \"path\": \"/foo/1\", \"value\": 2 }\n    ]`,\n\t\ttrue,\n\t\t\"\",\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\" }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/baz\", \"value\": \"bar\" } ]`,\n\t\tfalse,\n\t\t\"/baz\",\n\t},\n\t{\n\t\t`{\n      \"baz\": \"qux\",\n      \"foo\": [\"a\", 2, \"c\"]\n    }`,\n\t\t`[\n      { \"op\": \"test\", \"path\": \"/baz\", \"value\": \"qux\" },\n      { \"op\": \"test\", \"path\": \"/foo/1\", \"value\": \"c\" }\n    ]`,\n\t\tfalse,\n\t\t\"/foo/1\",\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\" }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": 42 } ]`,\n\t\tfalse,\n\t\t\"/foo\",\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\" }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": null } ]`,\n\t\ttrue,\n\t\t\"\",\n\t},\n\t{\n\t\t`{ \"foo\": null }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": null } ]`,\n\t\ttrue,\n\t\t\"\",\n\t},\n\t{\n\t\t`{ \"foo\": {} }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": null } ]`,\n\t\tfalse,\n\t\t\"/foo\",\n\t},\n\t{\n\t\t`{ \"foo\": [] }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": null } ]`,\n\t\tfalse,\n\t\t\"/foo\",\n\t},\n\t{\n\t\t`{ \"baz/foo\": \"qux\" }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/baz~1foo\", \"value\": \"qux\"} ]`,\n\t\ttrue,\n\t\t\"\",\n\t},\n}\n\nfunc TestAllTest(t *testing.T) {\n\tfor _, c := range TestCases {\n\t\t_, err := applyPatch(c.doc, c.patch)\n\n\t\tif c.result && err != nil {\n\t\t\tt.Errorf(\"Testing failed when it should have passed: %s\", err)\n\t\t} else if !c.result && err == nil {\n\t\t\tt.Errorf(\"Testing passed when it should have faild: %s\", err)\n\t\t} else if !c.result {\n\t\t\texpected := fmt.Sprintf(\"Testing value %s failed\", c.failedPath)\n\t\t\tif err.Error() != expected {\n\t\t\t\tt.Errorf(\"Testing failed as expected but invalid message: expected [%s], got [%s]\", expected, err)\n\t\t\t}\n\t\t}\n\t}\n}\n"], "fixing_code": ["package jsonpatch\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\teRaw = iota\n\teDoc\n\teAry\n)\n\ntype lazyNode struct {\n\traw   *json.RawMessage\n\tdoc   partialDoc\n\tary   partialArray\n\twhich int\n}\n\ntype operation map[string]*json.RawMessage\n\n// Patch is an ordered collection of operations.\ntype Patch []operation\n\ntype partialDoc map[string]*lazyNode\ntype partialArray []*lazyNode\n\ntype container interface {\n\tget(key string) (*lazyNode, error)\n\tset(key string, val *lazyNode) error\n\tadd(key string, val *lazyNode) error\n\tremove(key string) error\n}\n\nfunc newLazyNode(raw *json.RawMessage) *lazyNode {\n\treturn &lazyNode{raw: raw, doc: nil, ary: nil, which: eRaw}\n}\n\nfunc (n *lazyNode) MarshalJSON() ([]byte, error) {\n\tswitch n.which {\n\tcase eRaw:\n\t\treturn json.Marshal(n.raw)\n\tcase eDoc:\n\t\treturn json.Marshal(n.doc)\n\tcase eAry:\n\t\treturn json.Marshal(n.ary)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Unknown type\")\n\t}\n}\n\nfunc (n *lazyNode) UnmarshalJSON(data []byte) error {\n\tdest := make(json.RawMessage, len(data))\n\tcopy(dest, data)\n\tn.raw = &dest\n\tn.which = eRaw\n\treturn nil\n}\n\nfunc (n *lazyNode) intoDoc() (*partialDoc, error) {\n\tif n.which == eDoc {\n\t\treturn &n.doc, nil\n\t}\n\n\tif n.raw == nil {\n\t\treturn nil, fmt.Errorf(\"Unable to unmarshal nil pointer as partial document\")\n\t}\n\n\terr := json.Unmarshal(*n.raw, &n.doc)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tn.which = eDoc\n\treturn &n.doc, nil\n}\n\nfunc (n *lazyNode) intoAry() (*partialArray, error) {\n\tif n.which == eAry {\n\t\treturn &n.ary, nil\n\t}\n\n\tif n.raw == nil {\n\t\treturn nil, fmt.Errorf(\"Unable to unmarshal nil pointer as partial array\")\n\t}\n\n\terr := json.Unmarshal(*n.raw, &n.ary)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tn.which = eAry\n\treturn &n.ary, nil\n}\n\nfunc (n *lazyNode) compact() []byte {\n\tbuf := &bytes.Buffer{}\n\n\tif n.raw == nil {\n\t\treturn nil\n\t}\n\n\terr := json.Compact(buf, *n.raw)\n\n\tif err != nil {\n\t\treturn *n.raw\n\t}\n\n\treturn buf.Bytes()\n}\n\nfunc (n *lazyNode) tryDoc() bool {\n\tif n.raw == nil {\n\t\treturn false\n\t}\n\n\terr := json.Unmarshal(*n.raw, &n.doc)\n\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tn.which = eDoc\n\treturn true\n}\n\nfunc (n *lazyNode) tryAry() bool {\n\tif n.raw == nil {\n\t\treturn false\n\t}\n\n\terr := json.Unmarshal(*n.raw, &n.ary)\n\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tn.which = eAry\n\treturn true\n}\n\nfunc (n *lazyNode) equal(o *lazyNode) bool {\n\tif n.which == eRaw {\n\t\tif !n.tryDoc() && !n.tryAry() {\n\t\t\tif o.which != eRaw {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\treturn bytes.Equal(n.compact(), o.compact())\n\t\t}\n\t}\n\n\tif n.which == eDoc {\n\t\tif o.which == eRaw {\n\t\t\tif !o.tryDoc() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tif o.which != eDoc {\n\t\t\treturn false\n\t\t}\n\n\t\tfor k, v := range n.doc {\n\t\t\tov, ok := o.doc[k]\n\n\t\t\tif !ok {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tif v == nil && ov == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !v.equal(ov) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\tif o.which != eAry && !o.tryAry() {\n\t\treturn false\n\t}\n\n\tif len(n.ary) != len(o.ary) {\n\t\treturn false\n\t}\n\n\tfor idx, val := range n.ary {\n\t\tif !val.equal(o.ary[idx]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (o operation) kind() string {\n\tif obj, ok := o[\"op\"]; ok {\n\t\tvar op string\n\n\t\terr := json.Unmarshal(*obj, &op)\n\n\t\tif err != nil {\n\t\t\treturn \"unknown\"\n\t\t}\n\n\t\treturn op\n\t}\n\n\treturn \"unknown\"\n}\n\nfunc (o operation) path() string {\n\tif obj, ok := o[\"path\"]; ok {\n\t\tvar op string\n\n\t\terr := json.Unmarshal(*obj, &op)\n\n\t\tif err != nil {\n\t\t\treturn \"unknown\"\n\t\t}\n\n\t\treturn op\n\t}\n\n\treturn \"unknown\"\n}\n\nfunc (o operation) from() string {\n\tif obj, ok := o[\"from\"]; ok {\n\t\tvar op string\n\n\t\terr := json.Unmarshal(*obj, &op)\n\n\t\tif err != nil {\n\t\t\treturn \"unknown\"\n\t\t}\n\n\t\treturn op\n\t}\n\n\treturn \"unknown\"\n}\n\nfunc (o operation) value() *lazyNode {\n\tif obj, ok := o[\"value\"]; ok {\n\t\treturn newLazyNode(obj)\n\t}\n\n\treturn nil\n}\n\nfunc isArray(buf []byte) bool {\nLoop:\n\tfor _, c := range buf {\n\t\tswitch c {\n\t\tcase ' ':\n\t\tcase '\\n':\n\t\tcase '\\t':\n\t\t\tcontinue\n\t\tcase '[':\n\t\t\treturn true\n\t\tdefault:\n\t\t\tbreak Loop\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc findObject(pd *container, path string) (container, string) {\n\tdoc := *pd\n\n\tsplit := strings.Split(path, \"/\")\n\n\tif len(split) < 2 {\n\t\treturn nil, \"\"\n\t}\n\n\tparts := split[1 : len(split)-1]\n\n\tkey := split[len(split)-1]\n\n\tvar err error\n\n\tfor _, part := range parts {\n\n\t\tnext, ok := doc.get(decodePatchKey(part))\n\n\t\tif next == nil || ok != nil {\n\t\t\treturn nil, \"\"\n\t\t}\n\n\t\tif isArray(*next.raw) {\n\t\t\tdoc, err = next.intoAry()\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\"\n\t\t\t}\n\t\t} else {\n\t\t\tdoc, err = next.intoDoc()\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, \"\"\n\t\t\t}\n\t\t}\n\t}\n\n\treturn doc, decodePatchKey(key)\n}\n\nfunc (d *partialDoc) set(key string, val *lazyNode) error {\n\t(*d)[key] = val\n\treturn nil\n}\n\nfunc (d *partialDoc) add(key string, val *lazyNode) error {\n\t(*d)[key] = val\n\treturn nil\n}\n\nfunc (d *partialDoc) get(key string) (*lazyNode, error) {\n\treturn (*d)[key], nil\n}\n\nfunc (d *partialDoc) remove(key string) error {\n\t_, ok := (*d)[key]\n\tif !ok {\n\t\treturn fmt.Errorf(\"Unable to remove nonexistent key: %s\", key)\n\t}\n\n\tdelete(*d, key)\n\treturn nil\n}\n\nfunc (d *partialArray) set(key string, val *lazyNode) error {\n\tif key == \"-\" {\n\t\t*d = append(*d, val)\n\t\treturn nil\n\t}\n\n\tidx, err := strconv.Atoi(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsz := len(*d)\n\tif idx+1 > sz {\n\t\tsz = idx + 1\n\t}\n\n\tary := make([]*lazyNode, sz)\n\n\tcur := *d\n\n\tcopy(ary, cur)\n\n\tif idx >= len(ary) {\n\t\treturn fmt.Errorf(\"Unable to access invalid index: %d\", idx)\n\t}\n\n\tary[idx] = val\n\n\t*d = ary\n\treturn nil\n}\n\nfunc (d *partialArray) add(key string, val *lazyNode) error {\n\tif key == \"-\" {\n\t\t*d = append(*d, val)\n\t\treturn nil\n\t}\n\n\tidx, err := strconv.Atoi(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tary := make([]*lazyNode, len(*d)+1)\n\n\tcur := *d\n\n\tif idx < 0 {\n\t\tidx *= -1\n\n\t\tif idx > len(ary) {\n\t\t\treturn fmt.Errorf(\"Unable to access invalid index: %d\", idx)\n\t\t}\n\t\tidx = len(ary) - idx\n\t}\n\tif idx < 0 || idx >= len(ary) || idx > len(cur) {\n\t\treturn fmt.Errorf(\"Unable to access invalid index: %d\", idx)\n\t}\n\tcopy(ary[0:idx], cur[0:idx])\n\tary[idx] = val\n\tcopy(ary[idx+1:], cur[idx:])\n\n\t*d = ary\n\treturn nil\n}\n\nfunc (d *partialArray) get(key string) (*lazyNode, error) {\n\tidx, err := strconv.Atoi(key)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif idx >= len(*d) {\n\t\treturn nil, fmt.Errorf(\"Unable to access invalid index: %d\", idx)\n\t}\n\n\treturn (*d)[idx], nil\n}\n\nfunc (d *partialArray) remove(key string) error {\n\tidx, err := strconv.Atoi(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcur := *d\n\n\tif idx >= len(cur) {\n\t\treturn fmt.Errorf(\"Unable to remove invalid index: %d\", idx)\n\t}\n\n\tary := make([]*lazyNode, len(cur)-1)\n\n\tcopy(ary[0:idx], cur[0:idx])\n\tcopy(ary[idx:], cur[idx+1:])\n\n\t*d = ary\n\treturn nil\n\n}\n\nfunc (p Patch) add(doc *container, op operation) error {\n\tpath := op.path()\n\n\tcon, key := findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch add operation does not apply: doc is missing path: %s\", path)\n\t}\n\n\treturn con.add(key, op.value())\n}\n\nfunc (p Patch) remove(doc *container, op operation) error {\n\tpath := op.path()\n\n\tcon, key := findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch remove operation does not apply: doc is missing path: %s\", path)\n\t}\n\n\treturn con.remove(key)\n}\n\nfunc (p Patch) replace(doc *container, op operation) error {\n\tpath := op.path()\n\n\tcon, key := findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch replace operation does not apply: doc is missing path: %s\", path)\n\t}\n\n\tval, ok := con.get(key)\n\tif val == nil || ok != nil {\n\t\treturn fmt.Errorf(\"jsonpatch replace operation does not apply: doc is missing key: %s\", path)\n\t}\n\n\treturn con.set(key, op.value())\n}\n\nfunc (p Patch) move(doc *container, op operation) error {\n\tfrom := op.from()\n\n\tcon, key := findObject(doc, from)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch move operation does not apply: doc is missing from path: %s\", from)\n\t}\n\n\tval, err := con.get(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = con.remove(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpath := op.path()\n\n\tcon, key = findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch move operation does not apply: doc is missing destination path: %s\", path)\n\t}\n\n\treturn con.set(key, val)\n}\n\nfunc (p Patch) test(doc *container, op operation) error {\n\tpath := op.path()\n\n\tcon, key := findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch test operation does not apply: is missing path: %s\", path)\n\t}\n\n\tval, err := con.get(key)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif val == nil {\n\t\tif op.value().raw == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"Testing value %s failed\", path)\n\t}\n\n\tif val.equal(op.value()) {\n\t\treturn nil\n\t}\n\n\treturn fmt.Errorf(\"Testing value %s failed\", path)\n}\n\nfunc (p Patch) copy(doc *container, op operation) error {\n\tfrom := op.from()\n\n\tcon, key := findObject(doc, from)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch copy operation does not apply: doc is missing from path: %s\", from)\n\t}\n\n\tval, err := con.get(key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpath := op.path()\n\n\tcon, key = findObject(doc, path)\n\n\tif con == nil {\n\t\treturn fmt.Errorf(\"jsonpatch copy operation does not apply: doc is missing destination path: %s\", path)\n\t}\n\n\treturn con.set(key, val)\n}\n\n// Equal indicates if 2 JSON documents have the same structural equality.\nfunc Equal(a, b []byte) bool {\n\tra := make(json.RawMessage, len(a))\n\tcopy(ra, a)\n\tla := newLazyNode(&ra)\n\n\trb := make(json.RawMessage, len(b))\n\tcopy(rb, b)\n\tlb := newLazyNode(&rb)\n\n\treturn la.equal(lb)\n}\n\n// DecodePatch decodes the passed JSON document as an RFC 6902 patch.\nfunc DecodePatch(buf []byte) (Patch, error) {\n\tvar p Patch\n\n\terr := json.Unmarshal(buf, &p)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn p, nil\n}\n\n// Apply mutates a JSON document according to the patch, and returns the new\n// document.\nfunc (p Patch) Apply(doc []byte) ([]byte, error) {\n\treturn p.ApplyIndent(doc, \"\")\n}\n\n// ApplyIndent mutates a JSON document according to the patch, and returns the new\n// document indented.\nfunc (p Patch) ApplyIndent(doc []byte, indent string) ([]byte, error) {\n\tvar pd container\n\tif doc[0] == '[' {\n\t\tpd = &partialArray{}\n\t} else {\n\t\tpd = &partialDoc{}\n\t}\n\n\terr := json.Unmarshal(doc, pd)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = nil\n\n\tfor _, op := range p {\n\t\tswitch op.kind() {\n\t\tcase \"add\":\n\t\t\terr = p.add(&pd, op)\n\t\tcase \"remove\":\n\t\t\terr = p.remove(&pd, op)\n\t\tcase \"replace\":\n\t\t\terr = p.replace(&pd, op)\n\t\tcase \"move\":\n\t\t\terr = p.move(&pd, op)\n\t\tcase \"test\":\n\t\t\terr = p.test(&pd, op)\n\t\tcase \"copy\":\n\t\t\terr = p.copy(&pd, op)\n\t\tdefault:\n\t\t\terr = fmt.Errorf(\"Unexpected kind: %s\", op.kind())\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif indent != \"\" {\n\t\treturn json.MarshalIndent(pd, \"\", indent)\n\t}\n\n\treturn json.Marshal(pd)\n}\n\n// From http://tools.ietf.org/html/rfc6901#section-4 :\n//\n// Evaluation of each reference token begins by decoding any escaped\n// character sequence.  This is performed by first transforming any\n// occurrence of the sequence '~1' to '/', and then transforming any\n// occurrence of the sequence '~0' to '~'.\n\nvar (\n\trfc6901Decoder = strings.NewReplacer(\"~1\", \"/\", \"~0\", \"~\")\n)\n\nfunc decodePatchKey(k string) string {\n\treturn rfc6901Decoder.Replace(k)\n}\n", "package jsonpatch\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc reformatJSON(j string) string {\n\tbuf := new(bytes.Buffer)\n\n\tjson.Indent(buf, []byte(j), \"\", \"  \")\n\n\treturn buf.String()\n}\n\nfunc compareJSON(a, b string) bool {\n\t// return Equal([]byte(a), []byte(b))\n\n\tvar objA, objB map[string]interface{}\n\tjson.Unmarshal([]byte(a), &objA)\n\tjson.Unmarshal([]byte(b), &objB)\n\n\t// fmt.Printf(\"Comparing %#v\\nagainst %#v\\n\", objA, objB)\n\treturn reflect.DeepEqual(objA, objB)\n}\n\nfunc applyPatch(doc, patch string) (string, error) {\n\tobj, err := DecodePatch([]byte(patch))\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tout, err := obj.Apply([]byte(doc))\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(out), nil\n}\n\ntype Case struct {\n\tdoc, patch, result string\n}\n\nvar Cases = []Case{\n\t{\n\t\t`{ \"foo\": \"bar\"}`,\n\t\t`[\n         { \"op\": \"add\", \"path\": \"/baz\", \"value\": \"qux\" }\n     ]`,\n\t\t`{\n       \"baz\": \"qux\",\n       \"foo\": \"bar\"\n     }`,\n\t},\n\t{\n\t\t`{ \"foo\": [ \"bar\", \"baz\" ] }`,\n\t\t`[\n     { \"op\": \"add\", \"path\": \"/foo/1\", \"value\": \"qux\" }\n    ]`,\n\t\t`{ \"foo\": [ \"bar\", \"qux\", \"baz\" ] }`,\n\t},\n\t{\n\t\t`{ \"foo\": [ \"bar\", \"baz\" ] }`,\n\t\t`[\n     { \"op\": \"add\", \"path\": \"/foo/-1\", \"value\": \"qux\" }\n    ]`,\n\t\t`{ \"foo\": [ \"bar\", \"baz\", \"qux\" ] }`,\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\", \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/baz\" } ]`,\n\t\t`{ \"foo\": \"bar\" }`,\n\t},\n\t{\n\t\t`{ \"foo\": [ \"bar\", \"qux\", \"baz\" ] }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/foo/1\" } ]`,\n\t\t`{ \"foo\": [ \"bar\", \"baz\" ] }`,\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\", \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" } ]`,\n\t\t`{ \"baz\": \"boo\", \"foo\": \"bar\" }`,\n\t},\n\t{\n\t\t`{\n     \"foo\": {\n       \"bar\": \"baz\",\n       \"waldo\": \"fred\"\n     },\n     \"qux\": {\n       \"corge\": \"grault\"\n     }\n   }`,\n\t\t`[ { \"op\": \"move\", \"from\": \"/foo/waldo\", \"path\": \"/qux/thud\" } ]`,\n\t\t`{\n     \"foo\": {\n       \"bar\": \"baz\"\n     },\n     \"qux\": {\n       \"corge\": \"grault\",\n       \"thud\": \"fred\"\n     }\n   }`,\n\t},\n\t{\n\t\t`{ \"foo\": [ \"all\", \"grass\", \"cows\", \"eat\" ] }`,\n\t\t`[ { \"op\": \"move\", \"from\": \"/foo/1\", \"path\": \"/foo/3\" } ]`,\n\t\t`{ \"foo\": [ \"all\", \"cows\", \"eat\", \"grass\" ] }`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/child\", \"value\": { \"grandchild\": { } } } ]`,\n\t\t`{ \"foo\": \"bar\", \"child\": { \"grandchild\": { } } }`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\"] }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/foo/-\", \"value\": [\"abc\", \"def\"] } ]`,\n\t\t`{ \"foo\": [\"bar\", [\"abc\", \"def\"]] }`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\", \"qux\": { \"baz\": 1, \"bar\": null } }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/qux/bar\" } ]`,\n\t\t`{ \"foo\": \"bar\", \"qux\": { \"baz\": 1 } }`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/baz\", \"value\": null } ]`,\n\t\t`{ \"baz\": null, \"foo\": \"bar\" }`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\"]}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/0\", \"value\": \"baz\"}]`,\n\t\t`{ \"foo\": [\"baz\"]}`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\",\"baz\"]}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/0\", \"value\": \"bum\"}]`,\n\t\t`{ \"foo\": [\"bum\",\"baz\"]}`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\",\"qux\",\"baz\"]}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/1\", \"value\": \"bum\"}]`,\n\t\t`{ \"foo\": [\"bar\", \"bum\",\"baz\"]}`,\n\t},\n\t{\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"]}]`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/0/foo/0\", \"value\": \"bum\"}]`,\n\t\t`[ {\"foo\": [\"bum\",\"qux\",\"baz\"]}]`,\n\t},\n\t{\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"], \"bar\": [\"qux\",\"baz\"]}]`,\n\t\t`[ { \"op\": \"copy\", \"from\": \"/0/foo/0\", \"path\": \"/0/bar/0\"}]`,\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"], \"bar\": [\"bar\", \"baz\"]}]`,\n\t},\n\t{\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"], \"bar\": [\"qux\",\"baz\"]}]`,\n\t\t`[ { \"op\": \"copy\", \"from\": \"/0/foo/0\", \"path\": \"/0/bar\"}]`,\n\t\t`[ {\"foo\": [\"bar\",\"qux\",\"baz\"], \"bar\": [\"bar\", \"qux\", \"baz\"]}]`,\n\t},\n\t{\n\t\t`[ { \"foo\": {\"bar\": [\"qux\",\"baz\"]}, \"baz\": {\"qux\": \"bum\"}}]`,\n\t\t`[ { \"op\": \"copy\", \"from\": \"/0/foo/bar\", \"path\": \"/0/baz/bar\"}]`,\n\t\t`[ { \"baz\": {\"bar\": [\"qux\",\"baz\"], \"qux\":\"bum\"}, \"foo\": {\"bar\": [\"qux\",\"baz\"]}}]`,\n\t},\n}\n\ntype BadCase struct {\n\tdoc, patch string\n}\n\nvar MutationTestCases = []BadCase{\n\t{\n\t\t`{ \"foo\": \"bar\", \"qux\": { \"baz\": 1, \"bar\": null } }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/qux/bar\" } ]`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\", \"qux\": { \"baz\": 1, \"bar\": null } }`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/qux/baz\", \"value\": null } ]`,\n\t},\n}\n\nvar BadCases = []BadCase{\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/baz/bat\", \"value\": \"qux\" } ]`,\n\t},\n\t{\n\t\t`{ \"a\": { \"b\": { \"d\": 1 } } }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/a/b/c\" } ]`,\n\t},\n\t{\n\t\t`{ \"a\": { \"b\": { \"d\": 1 } } }`,\n\t\t`[ { \"op\": \"move\", \"from\": \"/a/b/c\", \"path\": \"/a/b/e\" } ]`,\n\t},\n\t{\n\t\t`{ \"a\": { \"b\": [1] } }`,\n\t\t`[ { \"op\": \"remove\", \"path\": \"/a/b/1\" } ]`,\n\t},\n\t{\n\t\t`{ \"a\": { \"b\": [1] } }`,\n\t\t`[ { \"op\": \"move\", \"from\": \"/a/b/1\", \"path\": \"/a/b/2\" } ]`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"pathz\": \"/baz\", \"value\": \"qux\" } ]`,\n\t},\n\t{\n\t\t`{ \"foo\": \"bar\" }`,\n\t\t`[ { \"op\": \"add\", \"path\": \"\", \"value\": \"qux\" } ]`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\",\"baz\"]}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/2\", \"value\": \"bum\"}]`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\",\"baz\"]}`,\n\t\t`[ { \"op\": \"add\", \"path\": \"/foo/-4\", \"value\": \"bum\"}]`,\n\t},\n\n\t{\n\t\t`{ \"name\":{ \"foo\": \"bat\", \"qux\": \"bum\"}}`,\n\t\t`[ { \"op\": \"replace\", \"path\": \"/foo/bar\", \"value\":\"baz\"}]`,\n\t},\n\t{\n\t\t`{ \"foo\": [\"bar\"]}`,\n\t\t`[ {\"op\": \"add\", \"path\": \"/foo/2\", \"value\": \"bum\"}]`,\n\t},\n}\n\nfunc TestAllCases(t *testing.T) {\n\tfor _, c := range Cases {\n\t\tout, err := applyPatch(c.doc, c.patch)\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unable to apply patch: %s\", err)\n\t\t}\n\n\t\tif !compareJSON(out, c.result) {\n\t\t\tt.Errorf(\"Patch did not apply. Expected:\\n%s\\n\\nActual:\\n%s\",\n\t\t\t\treformatJSON(c.result), reformatJSON(out))\n\t\t}\n\t}\n\n\tfor _, c := range MutationTestCases {\n\t\tout, err := applyPatch(c.doc, c.patch)\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unable to apply patch: %s\", err)\n\t\t}\n\n\t\tif compareJSON(out, c.doc) {\n\t\t\tt.Errorf(\"Patch did not apply. Original:\\n%s\\n\\nPatched:\\n%s\",\n\t\t\t\treformatJSON(c.doc), reformatJSON(out))\n\t\t}\n\t}\n\n\tfor _, c := range BadCases {\n\t\t_, err := applyPatch(c.doc, c.patch)\n\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Patch should have failed to apply but it did not\")\n\t\t}\n\t}\n}\n\ntype TestCase struct {\n\tdoc, patch string\n\tresult     bool\n\tfailedPath string\n}\n\nvar TestCases = []TestCase{\n\t{\n\t\t`{\n      \"baz\": \"qux\",\n      \"foo\": [ \"a\", 2, \"c\" ]\n    }`,\n\t\t`[\n      { \"op\": \"test\", \"path\": \"/baz\", \"value\": \"qux\" },\n      { \"op\": \"test\", \"path\": \"/foo/1\", \"value\": 2 }\n    ]`,\n\t\ttrue,\n\t\t\"\",\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\" }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/baz\", \"value\": \"bar\" } ]`,\n\t\tfalse,\n\t\t\"/baz\",\n\t},\n\t{\n\t\t`{\n      \"baz\": \"qux\",\n      \"foo\": [\"a\", 2, \"c\"]\n    }`,\n\t\t`[\n      { \"op\": \"test\", \"path\": \"/baz\", \"value\": \"qux\" },\n      { \"op\": \"test\", \"path\": \"/foo/1\", \"value\": \"c\" }\n    ]`,\n\t\tfalse,\n\t\t\"/foo/1\",\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\" }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": 42 } ]`,\n\t\tfalse,\n\t\t\"/foo\",\n\t},\n\t{\n\t\t`{ \"baz\": \"qux\" }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": null } ]`,\n\t\ttrue,\n\t\t\"\",\n\t},\n\t{\n\t\t`{ \"foo\": null }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": null } ]`,\n\t\ttrue,\n\t\t\"\",\n\t},\n\t{\n\t\t`{ \"foo\": {} }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": null } ]`,\n\t\tfalse,\n\t\t\"/foo\",\n\t},\n\t{\n\t\t`{ \"foo\": [] }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/foo\", \"value\": null } ]`,\n\t\tfalse,\n\t\t\"/foo\",\n\t},\n\t{\n\t\t`{ \"baz/foo\": \"qux\" }`,\n\t\t`[ { \"op\": \"test\", \"path\": \"/baz~1foo\", \"value\": \"qux\"} ]`,\n\t\ttrue,\n\t\t\"\",\n\t},\n}\n\nfunc TestAllTest(t *testing.T) {\n\tfor _, c := range TestCases {\n\t\t_, err := applyPatch(c.doc, c.patch)\n\n\t\tif c.result && err != nil {\n\t\t\tt.Errorf(\"Testing failed when it should have passed: %s\", err)\n\t\t} else if !c.result && err == nil {\n\t\t\tt.Errorf(\"Testing passed when it should have faild: %s\", err)\n\t\t} else if !c.result {\n\t\t\texpected := fmt.Sprintf(\"Testing value %s failed\", c.failedPath)\n\t\t\tif err.Error() != expected {\n\t\t\t\tt.Errorf(\"Testing failed as expected but invalid message: expected [%s], got [%s]\", expected, err)\n\t\t\t}\n\t\t}\n\t}\n}\n"], "filenames": ["patch.go", "patch_test.go"], "buggy_code_start_loc": [400, 229], "buggy_code_end_loc": [401, 229], "fixing_code_start_loc": [400, 230], "fixing_code_end_loc": [403, 234], "type": "CWE-787", "message": "An out of bound write can occur when patching an Openshift object using the 'oc patch' functionality in OpenShift Container Platform before 3.7. An attacker can use this flaw to cause a denial of service attack on the Openshift master api service which provides cluster management.", "other": {"cve": {"id": "CVE-2018-14632", "sourceIdentifier": "secalert@redhat.com", "published": "2018-09-06T14:29:00.587", "lastModified": "2023-02-07T22:18:46.403", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An out of bound write can occur when patching an Openshift object using the 'oc patch' functionality in OpenShift Container Platform before 3.7. An attacker can use this flaw to cause a denial of service attack on the Openshift master api service which provides cluster management."}, {"lang": "es", "value": "Puede ocurrir una escritura fuera de l\u00edmites al parchear un objeto Openshift mediante la funcionalidad \"oc patch\" en OpenShift Container Platform, en versiones anteriores a la 3.7. Un atacante puede emplear este error para provocar un ataque de denegaci\u00f3n de servicio (DoS) en el servicio de la API maestra de Openshift que gestiona los cl\u00fasteres."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.7", "matchCriteriaId": "1B5E2DD9-2F3F-45CB-BFED-BC50DB915FA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:3.9:*:*:*:*:*:*:*", "matchCriteriaId": "309CB6F8-F178-454C-BE97-787F78647C28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:3.10:*:*:*:*:*:*:*", "matchCriteriaId": "4DBCD38F-BBE8-488C-A8C3-5782F191D915"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "2F87326E-0B56-4356-A889-73D026DB1D4B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:starcounter-jack:json-patch:-:*:*:*:*:*:*:*", "matchCriteriaId": "8627819A-DD2C-49CE-BA40-CA5FCFD9C2AD"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHBA-2018:2652", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2654", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2709", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2906", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2908", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2018-14632", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/evanphx/json-patch/commit/4c9aadca8f89e349c999f04e28199e96e81aba03#diff-65c563bba473be9d94ce4d033f74810e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/evanphx/json-patch/commit/4c9aadca8f89e349c999f04e28199e96e81aba03#diff-65c563bba473be9d94ce4d033f74810e"}}