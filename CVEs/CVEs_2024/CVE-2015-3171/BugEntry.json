{"buggy_code": ["\"\"\"\nGather information about a system and report it using plugins\nsupplied for application-specific information\n\"\"\"\n# sosreport.py\n# gather information about a system and report it\n\n# Copyright (C) 2006 Steve Conklin <sconklin@redhat.com>\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\nimport sys\nimport traceback\nimport os\nimport errno\nimport logging\nfrom optparse import OptionParser, Option\nfrom sos.plugins import import_plugin\nfrom sos.utilities import ImporterHelper\nfrom stat import ST_UID, ST_GID, ST_MODE, ST_CTIME, ST_ATIME, ST_MTIME, S_IMODE\nfrom time import strftime, localtime\nfrom collections import deque\nimport tempfile\n\nfrom sos import _sos as _\nfrom sos import __version__\nimport sos.policies\nfrom sos.archive import TarFileArchive, ZipFileArchive\nfrom sos.reporting import (Report, Section, Command, CopiedFile, CreatedFile,\n                           Alert, Note, PlainTextReport)\n\n# PYCOMPAT\nimport six\nfrom six.moves import zip, input\nif six.PY3:\n    from configparser import ConfigParser\nelse:\n    from ConfigParser import ConfigParser\nfrom six import print_\n\n# file system errors that should terminate a run\nfatal_fs_errors = (errno.ENOSPC, errno.EROFS)\n\n\ndef _format_list(first_line, items, indent=False):\n    lines = []\n    line = first_line\n    if indent:\n        newline = len(first_line) * ' '\n    else:\n        newline = \"\"\n    for item in items:\n        if len(line) + len(item) + 2 > 72:\n            lines.append(line)\n            line = newline\n        line = line + item + ', '\n    if line[-2:] == ', ':\n        line = line[:-2]\n    lines.append(line)\n    return lines\n\n\nclass TempFileUtil(object):\n\n    def __init__(self, tmp_dir):\n        self.tmp_dir = tmp_dir\n        self.files = []\n\n    def new(self):\n        fd, fname = tempfile.mkstemp(dir=self.tmp_dir)\n        fobj = open(fname, 'w')\n        self.files.append((fname, fobj))\n        return fobj\n\n    def clean(self):\n        for fname, f in self.files:\n            try:\n                f.flush()\n                f.close()\n            except Exception:\n                pass\n            try:\n                os.unlink(fname)\n            except Exception:\n                pass\n        self.files = []\n\n\nclass OptionParserExtended(OptionParser):\n    \"\"\" Show examples \"\"\"\n    def print_help(self, out=sys.stdout):\n        \"\"\" Prints help content including examples \"\"\"\n        OptionParser.print_help(self, out)\n        print_()\n        print_(\"Some examples:\")\n        print_()\n        print_(\" enable cluster plugin only and collect dlm lockdumps:\")\n        print_(\"   # sosreport -o cluster -k cluster.lockdump\")\n        print_()\n        print_(\" disable memory and samba plugins, turn off rpm -Va \"\n               \"collection:\")\n        print_(\"   # sosreport -n memory,samba -k rpm.rpmva=off\")\n        print_()\n\n\nclass SosOption(Option):\n    \"\"\"Allow to specify comma delimited list of plugins\"\"\"\n    ACTIONS = Option.ACTIONS + (\"extend\",)\n    STORE_ACTIONS = Option.STORE_ACTIONS + (\"extend\",)\n    TYPED_ACTIONS = Option.TYPED_ACTIONS + (\"extend\",)\n\n    def take_action(self, action, dest, opt, value, values, parser):\n        \"\"\" Performs list extension on plugins \"\"\"\n        if action == \"extend\":\n            try:\n                lvalue = value.split(\",\")\n            except:\n                pass\n            else:\n                values.ensure_value(dest, deque()).extend(lvalue)\n        else:\n            Option.take_action(self, action, dest, opt, value, values, parser)\n\n\nclass XmlReport(object):\n    \"\"\" Report build class \"\"\"\n\n    def __init__(self):\n        try:\n            import libxml2\n        except ImportError:\n            self.enabled = False\n            return\n        else:\n            self.enabled = False\n            return\n        self.doc = libxml2.newDoc(\"1.0\")\n        self.root = self.doc.newChild(None, \"sos\", None)\n        self.commands = self.root.newChild(None, \"commands\", None)\n        self.files = self.root.newChild(None, \"files\", None)\n\n    def add_command(self, cmdline, exitcode, stdout=None, stderr=None,\n                    f_stdout=None, f_stderr=None, runtime=None):\n        \"\"\" Appends command run into report \"\"\"\n        if not self.enabled:\n            return\n\n        cmd = self.commands.newChild(None, \"cmd\", None)\n\n        cmd.setNsProp(None, \"cmdline\", cmdline)\n\n        cmdchild = cmd.newChild(None, \"exitcode\", str(exitcode))\n\n        if runtime:\n            cmd.newChild(None, \"runtime\", str(runtime))\n\n        if stdout or f_stdout:\n            cmdchild = cmd.newChild(None, \"stdout\", stdout)\n            if f_stdout:\n                cmdchild.setNsProp(None, \"file\", f_stdout)\n\n        if stderr or f_stderr:\n            cmdchild = cmd.newChild(None, \"stderr\", stderr)\n            if f_stderr:\n                cmdchild.setNsProp(None, \"file\", f_stderr)\n\n    def add_file(self, fname, stats):\n        \"\"\" Appends file(s) added to report \"\"\"\n        if not self.enabled:\n            return\n\n        cfile = self.files.newChild(None, \"file\", None)\n\n        cfile.setNsProp(None, \"fname\", fname)\n\n        cchild = cfile.newChild(None, \"uid\", str(stats[ST_UID]))\n        cchild = cfile.newChild(None, \"gid\", str(stats[ST_GID]))\n        cfile.newChild(None, \"mode\", str(oct(S_IMODE(stats[ST_MODE]))))\n        cchild = cfile.newChild(None, \"ctime\",\n                                strftime('%a %b %d %H:%M:%S %Y',\n                                         localtime(stats[ST_CTIME])))\n        cchild.setNsProp(None, \"tstamp\", str(stats[ST_CTIME]))\n        cchild = cfile.newChild(None, \"atime\",\n                                strftime('%a %b %d %H:%M:%S %Y',\n                                         localtime(stats[ST_ATIME])))\n        cchild.setNsProp(None, \"tstamp\", str(stats[ST_ATIME]))\n        cchild = cfile.newChild(None, \"mtime\",\n                                strftime('%a %b %d %H:%M:%S %Y',\n                                         localtime(stats[ST_MTIME])))\n        cchild.setNsProp(None, \"tstamp\", str(stats[ST_MTIME]))\n\n    def serialize(self):\n        \"\"\" Serializes xml \"\"\"\n        if not self.enabled:\n            return\n\n        self.ui_log.info(self.doc.serialize(None,  1))\n\n    def serialize_to_file(self, fname):\n        \"\"\" Serializes to file \"\"\"\n        if not self.enabled:\n            return\n\n        outf = tempfile.NamedTemporaryFile()\n        outf.write(self.doc.serialize(None, 1))\n        outf.flush()\n        self.archive.add_file(outf.name, dest=fname)\n        outf.close()\n\n\nclass SoSOptions(object):\n    _list_plugins = False\n    _noplugins = []\n    _enableplugins = []\n    _onlyplugins = []\n    _plugopts = []\n    _usealloptions = False\n    _all_logs = False\n    _log_size = 10\n    _batch = False\n    _build = False\n    _verbosity = 0\n    _verify = False\n    _quiet = False\n    _debug = False\n    _case_id = \"\"\n    _customer_name = \"\"\n    _profiles = deque()\n    _list_profiles = False\n    _config_file = \"\"\n    _tmp_dir = \"\"\n    _report = True\n    _compression_type = 'auto'\n\n    _options = None\n\n    def __init__(self, args=None):\n        if args:\n            self._options = self._parse_args(args)\n        else:\n            self._options = None\n\n    def _check_options_initialized(self):\n        if self._options is not None:\n            raise ValueError(\"SoSOptions object already initialized \"\n                             + \"from command line\")\n\n    @property\n    def list_plugins(self):\n        if self._options is not None:\n            return self._options.list_plugins\n        return self._list_plugins\n\n    @list_plugins.setter\n    def list_plugins(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.list_plugins expects a boolean\")\n        self._list_plugins = value\n\n    @property\n    def noplugins(self):\n        if self._options is not None:\n            return self._options.noplugins\n        return self._noplugins\n\n    @noplugins.setter\n    def noplugins(self, value):\n        self._check_options_initialized()\n        self._noplugins = value\n\n    @property\n    def enableplugins(self):\n        if self._options is not None:\n            return self._options.enableplugins\n        return self._enableplugins\n\n    @enableplugins.setter\n    def enableplugins(self, value):\n        self._check_options_initialized()\n        self._enableplugins = value\n\n    @property\n    def onlyplugins(self):\n        if self._options is not None:\n            return self._options.onlyplugins\n        return self._onlyplugins\n\n    @onlyplugins.setter\n    def onlyplugins(self, value):\n        self._check_options_initialized()\n        self._onlyplugins = value\n\n    @property\n    def plugopts(self):\n        if self._options is not None:\n            return self._options.plugopts\n        return self._plugopts\n\n    @plugopts.setter\n    def plugopts(self, value):\n        # If we check for anything it should be itterability.\n        # if not isinstance(value, list):\n        #    raise TypeError(\"SoSOptions.plugopts expects a list\")\n        self._plugopts = value\n\n    @property\n    def usealloptions(self):\n        if self._options is not None:\n            return self._options.usealloptions\n        return self._usealloptions\n\n    @usealloptions.setter\n    def usealloptions(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.usealloptions expects a boolean\")\n        self._usealloptions = value\n\n    @property\n    def all_logs(self):\n        if self._options is not None:\n            return self._options.all_logs\n        return self._all_logs\n\n    @all_logs.setter\n    def all_logs(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.all_logs expects a boolean\")\n        self._all_logs = value\n\n    @property\n    def log_size(self):\n        if self._options is not None:\n            return self._options.log_size\n        return self._log_size\n\n    @log_size.setter\n    def log_size(self, value):\n        self._check_options_initialized()\n        if value < 0:\n            raise ValueError(\"SoSOptions.log_size expects a value greater \"\n                             \"than zero\")\n        self._log_size = value\n\n    @property\n    def batch(self):\n        if self._options is not None:\n            return self._options.batch\n        return self._batch\n\n    @batch.setter\n    def batch(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.batch expects a boolean\")\n        self._batch = value\n\n    @property\n    def build(self):\n        if self._options is not None:\n            return self._options.build\n        return self._build\n\n    @build.setter\n    def build(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.build expects a boolean\")\n        self._build = value\n\n    @property\n    def verbosity(self):\n        if self._options is not None:\n            return self._options.verbosity\n        return self._verbosity\n\n    @verbosity.setter\n    def verbosity(self, value):\n        self._check_options_initialized()\n        if value < 0 or value > 3:\n            raise ValueError(\"SoSOptions.verbosity expects a value [0..3]\")\n        self._verbosity = value\n\n    @property\n    def verify(self):\n        if self._options is not None:\n            return self._options.verify\n        return self._verify\n\n    @verify.setter\n    def verify(self, value):\n        self._check_options_initialized()\n        if value < 0 or value > 3:\n            raise ValueError(\"SoSOptions.verify expects a value [0..3]\")\n        self._verify = value\n\n    @property\n    def quiet(self):\n        if self._options is not None:\n            return self._options.quiet\n        return self._quiet\n\n    @quiet.setter\n    def quiet(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.quiet expects a boolean\")\n        self._quiet = value\n\n    @property\n    def debug(self):\n        if self._options is not None:\n            return self._options.debug\n        return self._debug\n\n    @debug.setter\n    def debug(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.debug expects a boolean\")\n        self._debug = value\n\n    @property\n    def case_id(self):\n        if self._options is not None:\n            return self._options.case_id\n        return self._case_id\n\n    @case_id.setter\n    def case_id(self, value):\n        self._check_options_initialized()\n        self._case_id = value\n\n    @property\n    def customer_name(self):\n        if self._options is not None:\n            return self._options.customer_name\n        return self._customer_name\n\n    @customer_name.setter\n    def customer_name(self, value):\n        self._check_options_initialized()\n        self._customer_name = value\n\n    @property\n    def profiles(self):\n        if self._options is not None:\n            return self._options.profiles\n        return self._profiles\n\n    @profiles.setter\n    def profiles(self, value):\n        self._check_options_initialized()\n        self._profiles = value\n\n    @property\n    def list_profiles(self):\n        if self._options is not None:\n            return self._options.list_profiles\n        return self._list_profiles\n\n    @list_profiles.setter\n    def list_profiles(self, value):\n        self._check_options_initialized()\n        self._list_profiles = value\n\n    @property\n    def config_file(self):\n        if self._options is not None:\n            return self._options.config_file\n        return self._config_file\n\n    @config_file.setter\n    def config_file(self, value):\n        self._check_options_initialized()\n        self._config_file = value\n\n    @property\n    def tmp_dir(self):\n        if self._options is not None:\n            return self._options.tmp_dir\n        return self._tmp_dir\n\n    @tmp_dir.setter\n    def tmp_dir(self, value):\n        self._check_options_initialized()\n        self._tmp_dir = value\n\n    @property\n    def report(self):\n        if self._options is not None:\n            return self._options.report\n        return self._report\n\n    @report.setter\n    def report(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.report expects a boolean\")\n        self._report = value\n\n    @property\n    def compression_type(self):\n        if self._options is not None:\n            return self._options.compression_type\n        return self._compression_type\n\n    @compression_type.setter\n    def compression_type(self, value):\n        self._check_options_initialized()\n        self._compression_type = value\n\n    def _parse_args(self, args):\n        \"\"\" Parse command line options and arguments\"\"\"\n\n        self.parser = parser = OptionParserExtended(option_class=SosOption)\n        parser.add_option(\"-l\", \"--list-plugins\", action=\"store_true\",\n                          dest=\"list_plugins\", default=False,\n                          help=\"list plugins and available plugin options\")\n        parser.add_option(\"-n\", \"--skip-plugins\", action=\"extend\",\n                          dest=\"noplugins\", type=\"string\",\n                          help=\"disable these plugins\", default=deque())\n        parser.add_option(\"-e\", \"--enable-plugins\", action=\"extend\",\n                          dest=\"enableplugins\", type=\"string\",\n                          help=\"enable these plugins\", default=deque())\n        parser.add_option(\"-o\", \"--only-plugins\", action=\"extend\",\n                          dest=\"onlyplugins\", type=\"string\",\n                          help=\"enable these plugins only\", default=deque())\n        parser.add_option(\"-k\", \"--plugin-option\", action=\"extend\",\n                          dest=\"plugopts\", type=\"string\",\n                          help=\"plugin options in plugname.option=value \"\n                               \"format (see -l)\",\n                          default=deque())\n        parser.add_option(\"--log-size\", action=\"store\",\n                          dest=\"log_size\", default=10, type=\"int\",\n                          help=\"set a limit on the size of collected logs\")\n        parser.add_option(\"-a\", \"--alloptions\", action=\"store_true\",\n                          dest=\"usealloptions\", default=False,\n                          help=\"enable all options for loaded plugins\")\n        parser.add_option(\"--all-logs\", action=\"store_true\",\n                          dest=\"all_logs\", default=False,\n                          help=\"collect all available logs regardless of size\")\n        parser.add_option(\"--batch\", action=\"store_true\",\n                          dest=\"batch\", default=False,\n                          help=\"batch mode - do not prompt interactively\")\n        parser.add_option(\"--build\", action=\"store_true\",\n                          dest=\"build\", default=False,\n                          help=\"preserve the temporary directory and do not \"\n                               \"package results\")\n        parser.add_option(\"-v\", \"--verbose\", action=\"count\",\n                          dest=\"verbosity\",\n                          help=\"increase verbosity\")\n        parser.add_option(\"\", \"--verify\", action=\"store_true\",\n                          dest=\"verify\", default=False,\n                          help=\"perform data verification during collection\")\n        parser.add_option(\"\", \"--quiet\", action=\"store_true\",\n                          dest=\"quiet\", default=False,\n                          help=\"only print fatal errors\")\n        parser.add_option(\"--debug\", action=\"count\",\n                          dest=\"debug\",\n                          help=\"enable interactive debugging using the python \"\n                               \"debugger\")\n        parser.add_option(\"--ticket-number\", action=\"store\",\n                          dest=\"case_id\",\n                          help=\"specify ticket number\")\n        parser.add_option(\"--case-id\", action=\"store\",\n                          dest=\"case_id\",\n                          help=\"specify case identifier\")\n        parser.add_option(\"-p\", \"--profile\", action=\"extend\",\n                          dest=\"profiles\", type=\"string\", default=deque(),\n                          help=\"enable plugins selected by the given profiles\")\n        parser.add_option(\"--list-profiles\", action=\"store_true\",\n                          dest=\"list_profiles\", default=False)\n        parser.add_option(\"--name\", action=\"store\",\n                          dest=\"customer_name\",\n                          help=\"specify report name\")\n        parser.add_option(\"--config-file\", action=\"store\",\n                          dest=\"config_file\",\n                          help=\"specify alternate configuration file\")\n        parser.add_option(\"--tmp-dir\", action=\"store\",\n                          dest=\"tmp_dir\",\n                          help=\"specify alternate temporary directory\",\n                          default=None)\n        parser.add_option(\"--no-report\", action=\"store_true\",\n                          dest=\"report\",\n                          help=\"Disable HTML/XML reporting\", default=False)\n        parser.add_option(\"-z\", \"--compression-type\", dest=\"compression_type\",\n                          help=\"compression technology to use [auto, zip, \"\n                               \"gzip, bzip2, xz] (default=auto)\",\n                          default=\"auto\")\n\n        return parser.parse_args(args)[0]\n\n\nclass SoSReport(object):\n    \"\"\"The main sosreport class\"\"\"\n\n    def __init__(self, args):\n        self.loaded_plugins = deque()\n        self.skipped_plugins = deque()\n        self.all_options = deque()\n        self.xml_report = XmlReport()\n        self.global_plugin_options = {}\n        self.archive = None\n        self.tempfile_util = None\n        self._args = args\n\n        try:\n            import signal\n            signal.signal(signal.SIGTERM, self.get_exit_handler())\n        except Exception:\n            pass  # not available in java, but we don't care\n\n        self.opts = SoSOptions(args)\n        self._set_debug()\n        self._read_config()\n\n        try:\n            self.policy = sos.policies.load()\n        except KeyboardInterrupt:\n            self._exit(0)\n\n        self._is_root = self.policy.is_root()\n\n        self.tmpdir = os.path.abspath(\n            self.policy.get_tmp_dir(self.opts.tmp_dir))\n        if not os.path.isdir(self.tmpdir) \\\n                or not os.access(self.tmpdir, os.W_OK):\n            # write directly to stderr as logging is not initialised yet\n            sys.stderr.write(\"temporary directory %s \" % self.tmpdir\n                             + \"does not exist or is not writable\\n\")\n            self._exit(1)\n        self.tempfile_util = TempFileUtil(self.tmpdir)\n        self._set_directories()\n\n    def print_header(self):\n        self.ui_log.info(\"\\n%s\\n\" % _(\"sosreport (version %s)\" %\n                         (__version__,)))\n\n    def get_commons(self):\n        return {\n            'cmddir': self.cmddir,\n            'logdir': self.logdir,\n            'rptdir': self.rptdir,\n            'tmpdir': self.tmpdir,\n            'soslog': self.soslog,\n            'policy': self.policy,\n            'verbosity': self.opts.verbosity,\n            'xmlreport': self.xml_report,\n            'cmdlineopts': self.opts,\n            'config': self.config,\n            'global_plugin_options': self.global_plugin_options,\n            }\n\n    def get_temp_file(self):\n        return self.tempfile_util.new()\n\n    def _set_archive(self):\n        archive_name = os.path.join(self.tmpdir,\n                                    self.policy.get_archive_name())\n        if self.opts.compression_type == 'auto':\n            auto_archive = self.policy.get_preferred_archive()\n            self.archive = auto_archive(archive_name, self.tmpdir)\n        elif self.opts.compression_type == 'zip':\n            self.archive = ZipFileArchive(archive_name, self.tmpdir)\n        else:\n            self.archive = TarFileArchive(archive_name, self.tmpdir)\n        self.archive.set_debug(True if self.opts.debug else False)\n\n    def _make_archive_paths(self):\n        self.archive.makedirs(self.cmddir, 0o755)\n        self.archive.makedirs(self.logdir, 0o755)\n        self.archive.makedirs(self.rptdir, 0o755)\n\n    def _set_directories(self):\n        self.cmddir = 'sos_commands'\n        self.logdir = 'sos_logs'\n        self.rptdir = 'sos_reports'\n\n    def _set_debug(self):\n        if self.opts.debug:\n            sys.excepthook = self._exception\n            self.raise_plugins = True\n        else:\n            self.raise_plugins = False\n\n    @staticmethod\n    def _exception(etype, eval_, etrace):\n        \"\"\" Wrap exception in debugger if not in tty \"\"\"\n        if hasattr(sys, 'ps1') or not sys.stderr.isatty():\n            # we are in interactive mode or we don't have a tty-like\n            # device, so we call the default hook\n            sys.__excepthook__(etype, eval_, etrace)\n        else:\n            import pdb\n            # we are NOT in interactive mode, print the exception...\n            traceback.print_exception(etype, eval_, etrace, limit=2,\n                                      file=sys.stdout)\n            print_()\n            # ...then start the debugger in post-mortem mode.\n            pdb.pm()\n\n    def _exit(self, error=0):\n        raise SystemExit()\n#        sys.exit(error)\n\n    def get_exit_handler(self):\n        def exit_handler(signum, frame):\n            self._exit()\n        return exit_handler\n\n    def _read_config(self):\n        self.config = ConfigParser()\n        if self.opts.config_file:\n            config_file = self.opts.config_file\n        else:\n            config_file = '/etc/sos.conf'\n        try:\n            self.config.readfp(open(config_file))\n        except IOError:\n            pass\n\n    def _setup_logging(self):\n        # main soslog\n        self.soslog = logging.getLogger('sos')\n        self.soslog.setLevel(logging.DEBUG)\n        self.sos_log_file = self.get_temp_file()\n        self.sos_log_file.close()\n        flog = logging.FileHandler(self.sos_log_file.name)\n        flog.setFormatter(logging.Formatter(\n            '%(asctime)s %(levelname)s: %(message)s'))\n        flog.setLevel(logging.INFO)\n        self.soslog.addHandler(flog)\n\n        if not self.opts.quiet:\n            console = logging.StreamHandler(sys.stderr)\n            console.setFormatter(logging.Formatter('%(message)s'))\n            if self.opts.verbosity and self.opts.verbosity > 1:\n                console.setLevel(logging.DEBUG)\n                flog.setLevel(logging.DEBUG)\n            elif self.opts.verbosity and self.opts.verbosity > 0:\n                console.setLevel(logging.INFO)\n                flog.setLevel(logging.DEBUG)\n            else:\n                console.setLevel(logging.WARNING)\n            self.soslog.addHandler(console)\n\n        # ui log\n        self.ui_log = logging.getLogger('sos_ui')\n        self.ui_log.setLevel(logging.INFO)\n        self.sos_ui_log_file = self.get_temp_file()\n        self.sos_ui_log_file.close()\n        ui_fhandler = logging.FileHandler(self.sos_ui_log_file.name)\n        ui_fhandler.setFormatter(logging.Formatter(\n            '%(asctime)s %(levelname)s: %(message)s'))\n\n        self.ui_log.addHandler(ui_fhandler)\n\n        if not self.opts.quiet:\n            ui_console = logging.StreamHandler(sys.stdout)\n            ui_console.setFormatter(logging.Formatter('%(message)s'))\n            ui_console.setLevel(logging.INFO)\n            self.ui_log.addHandler(ui_console)\n\n    def _finish_logging(self):\n        logging.shutdown()\n\n        # Make sure the log files are added before we remove the log\n        # handlers. This prevents \"No handlers could be found..\" messages\n        # from leaking to the console when running in --quiet mode when\n        # Archive classes attempt to acess the log API.\n        if getattr(self, \"sos_log_file\", None):\n            self.archive.add_file(self.sos_log_file.name,\n                                  dest=os.path.join('sos_logs', 'sos.log'))\n        if getattr(self, \"sos_ui_log_file\", None):\n            self.archive.add_file(self.sos_ui_log_file.name,\n                                  dest=os.path.join('sos_logs', 'ui.log'))\n\n    def _get_disabled_plugins(self):\n        disabled = []\n        if self.config.has_option(\"plugins\", \"disable\"):\n            disabled = [plugin.strip() for plugin in\n                        self.config.get(\"plugins\", \"disable\").split(',')]\n        return disabled\n\n    def _is_in_profile(self, plugin_class):\n        onlyplugins = self.opts.onlyplugins\n        if not len(self.opts.profiles):\n            return True\n        if not hasattr(plugin_class, \"profiles\"):\n            return False\n        if onlyplugins and not self._is_not_specified(plugin_class.name()):\n            return True\n        return any([p in self.opts.profiles for p in plugin_class.profiles])\n\n    def _is_skipped(self, plugin_name):\n        return (plugin_name in self.opts.noplugins or\n                plugin_name in self._get_disabled_plugins())\n\n    def _is_inactive(self, plugin_name, pluginClass):\n        return (not pluginClass(self.get_commons()).check_enabled() and\n                plugin_name not in self.opts.enableplugins and\n                plugin_name not in self.opts.onlyplugins)\n\n    def _is_not_default(self, plugin_name, pluginClass):\n        return (not pluginClass(self.get_commons()).default_enabled() and\n                plugin_name not in self.opts.enableplugins and\n                plugin_name not in self.opts.onlyplugins)\n\n    def _is_not_specified(self, plugin_name):\n        return (self.opts.onlyplugins and\n                plugin_name not in self.opts.onlyplugins)\n\n    def _skip(self, plugin_class, reason=\"unknown\"):\n        self.skipped_plugins.append((\n            plugin_class.name(),\n            plugin_class(self.get_commons()),\n            reason\n        ))\n\n    def _load(self, plugin_class):\n        self.loaded_plugins.append((\n            plugin_class.name(),\n            plugin_class(self.get_commons())\n        ))\n\n    def load_plugins(self):\n\n        import sos.plugins\n        helper = ImporterHelper(sos.plugins)\n        plugins = helper.get_modules()\n        self.plugin_names = deque()\n        self.profiles = set()\n        using_profiles = len(self.opts.profiles)\n        # validate and load plugins\n        for plug in plugins:\n            plugbase, ext = os.path.splitext(plug)\n            try:\n                plugin_classes = import_plugin(\n                    plugbase, tuple(self.policy.valid_subclasses))\n                if not len(plugin_classes):\n                    # no valid plugin classes for this policy\n                    continue\n\n                plugin_class = self.policy.match_plugin(plugin_classes)\n                if not self.policy.validate_plugin(plugin_class):\n                    self.soslog.warning(\n                        _(\"plugin %s does not validate, skipping\") % plug)\n                    if self.opts.verbosity > 0:\n                        self._skip(plugin_class, _(\"does not validate\"))\n                        continue\n\n                if plugin_class.requires_root and not self._is_root:\n                    self.soslog.info(_(\"plugin %s requires root permissions\"\n                                       \"to execute, skipping\") % plug)\n                    self._skip(plugin_class, _(\"requires root\"))\n                    continue\n\n                # plug-in is valid, let's decide whether run it or not\n                self.plugin_names.append(plugbase)\n                if hasattr(plugin_class, \"profiles\"):\n                    self.profiles.update(plugin_class.profiles)\n\n                in_profile = self._is_in_profile(plugin_class)\n                if not in_profile:\n                    self._skip(plugin_class, _(\"excluded\"))\n                    continue\n\n                if self._is_skipped(plugbase):\n                    self._skip(plugin_class, _(\"skipped\"))\n                    continue\n\n                if self._is_inactive(plugbase, plugin_class):\n                    self._skip(plugin_class, _(\"inactive\"))\n                    continue\n\n                if self._is_not_default(plugbase, plugin_class):\n                    self._skip(plugin_class, _(\"optional\"))\n                    continue\n\n                # true when the null (empty) profile is active\n                default_profile = not using_profiles and in_profile\n                if self._is_not_specified(plugbase) and default_profile:\n                    self._skip(plugin_class, _(\"not specified\"))\n                    continue\n\n                self._load(plugin_class)\n            except Exception as e:\n                self.soslog.warning(_(\"plugin %s does not install, \"\n                                    \"skipping: %s\") % (plug, e))\n                if self.raise_plugins:\n                    raise\n\n    def _set_all_options(self):\n        if self.opts.usealloptions:\n            for plugname, plug in self.loaded_plugins:\n                for name, parms in zip(plug.opt_names, plug.opt_parms):\n                    if type(parms[\"enabled\"]) == bool:\n                        parms[\"enabled\"] = True\n\n    def _set_tunables(self):\n        if self.config.has_section(\"tunables\"):\n            if not self.opts.plugopts:\n                self.opts.plugopts = deque()\n\n            for opt, val in self.config.items(\"tunables\"):\n                if not opt.split('.')[0] in self._get_disabled_plugins():\n                    self.opts.plugopts.append(opt + \"=\" + val)\n        if self.opts.plugopts:\n            opts = {}\n            for opt in self.opts.plugopts:\n                # split up \"general.syslogsize=5\"\n                try:\n                    opt, val = opt.split(\"=\")\n                except:\n                    val = True\n                else:\n                    if val.lower() in [\"off\", \"disable\", \"disabled\", \"false\"]:\n                        val = False\n                    else:\n                        # try to convert string \"val\" to int()\n                        try:\n                            val = int(val)\n                        except:\n                            pass\n\n                # split up \"general.syslogsize\"\n                try:\n                    plug, opt = opt.split(\".\")\n                except:\n                    plug = opt\n                    opt = True\n\n                try:\n                    opts[plug]\n                except KeyError:\n                    opts[plug] = deque()\n                opts[plug].append((opt, val))\n\n            for plugname, plug in self.loaded_plugins:\n                if plugname in opts:\n                    for opt, val in opts[plugname]:\n                        if not plug.set_option(opt, val):\n                            self.soslog.error('no such option \"%s\" for plugin '\n                                              '(%s)' % (opt, plugname))\n                            self._exit(1)\n                    del opts[plugname]\n            for plugname in opts.keys():\n                self.soslog.error('unable to set option for disabled or '\n                                  'non-existing plugin (%s)' % (plugname))\n\n    def _check_for_unknown_plugins(self):\n        import itertools\n        for plugin in itertools.chain(self.opts.onlyplugins,\n                                      self.opts.noplugins,\n                                      self.opts.enableplugins):\n            plugin_name = plugin.split(\".\")[0]\n            if plugin_name not in self.plugin_names:\n                self.soslog.fatal('a non-existing plugin (%s) was specified '\n                                  'in the command line' % (plugin_name))\n                self._exit(1)\n\n    def _set_plugin_options(self):\n        for plugin_name, plugin in self.loaded_plugins:\n            names, parms = plugin.get_all_options()\n            for optname, optparm in zip(names, parms):\n                self.all_options.append((plugin, plugin_name, optname,\n                                         optparm))\n\n    def list_plugins(self):\n        if not self.loaded_plugins and not self.skipped_plugins:\n            self.soslog.fatal(_(\"no valid plugins found\"))\n            return\n\n        if self.loaded_plugins:\n            self.ui_log.info(_(\"The following plugins are currently enabled:\"))\n            self.ui_log.info(\"\")\n            for (plugname, plug) in self.loaded_plugins:\n                self.ui_log.info(\" %-20s %s\" % (plugname,\n                                                plug.get_description()))\n        else:\n            self.ui_log.info(_(\"No plugin enabled.\"))\n        self.ui_log.info(\"\")\n\n        if self.skipped_plugins:\n            self.ui_log.info(_(\"The following plugins are currently \"\n                             \"disabled:\"))\n            self.ui_log.info(\"\")\n            for (plugname, plugclass, reason) in self.skipped_plugins:\n                self.ui_log.info(\" %-20s %-14s %s\" % (\n                    plugname,\n                    reason,\n                    plugclass.get_description()))\n        self.ui_log.info(\"\")\n\n        if self.all_options:\n            self.ui_log.info(_(\"The following plugin options are available:\"))\n            self.ui_log.info(\"\")\n            for (plug, plugname, optname, optparm) in self.all_options:\n                # format option value based on its type (int or bool)\n                if type(optparm[\"enabled\"]) == bool:\n                    if optparm[\"enabled\"] is True:\n                        tmpopt = \"on\"\n                    else:\n                        tmpopt = \"off\"\n                else:\n                    tmpopt = optparm[\"enabled\"]\n\n                self.ui_log.info(\" %-25s %-15s %s\" % (\n                    plugname + \".\" + optname, tmpopt, optparm[\"desc\"]))\n        else:\n            self.ui_log.info(_(\"No plugin options available.\"))\n\n        self.ui_log.info(\"\")\n        profiles = list(self.profiles)\n        profiles.sort()\n        lines = _format_list(\"Profiles: \", profiles, indent=True)\n        for line in lines:\n            self.ui_log.info(\" %s\" % line)\n        self.ui_log.info(\"\")\n        self.ui_log.info(\" %d profiles, %d plugins\"\n                         % (len(self.profiles), len(self.loaded_plugins)))\n        self.ui_log.info(\"\")\n\n    def list_profiles(self):\n        if not self.profiles:\n            self.soslog.fatal(_(\"no valid profiles found\"))\n            return\n        self.ui_log.info(_(\"The following profiles are available:\"))\n        self.ui_log.info(\"\")\n\n        def _has_prof(c):\n            return hasattr(c, \"profiles\")\n\n        profiles = list(self.profiles)\n        profiles.sort()\n        for profile in profiles:\n            plugins = []\n            for name, plugin in self.loaded_plugins:\n                if _has_prof(plugin) and profile in plugin.profiles:\n                    plugins.append(name)\n            lines = _format_list(\"%-15s \" % profile, plugins, indent=True)\n            for line in lines:\n                self.ui_log.info(\" %s\" % line)\n        self.ui_log.info(\"\")\n        self.ui_log.info(\" %d profiles, %d plugins\"\n                         % (len(profiles), len(self.loaded_plugins)))\n        self.ui_log.info(\"\")\n\n    def batch(self):\n        if self.opts.batch:\n            self.ui_log.info(self.policy.get_msg())\n        else:\n            msg = self.policy.get_msg()\n            msg += _(\"Press ENTER to continue, or CTRL-C to quit.\\n\")\n            try:\n                input(msg)\n            except:\n                self.ui_log.info(\"\")\n                self._exit()\n\n    def _log_plugin_exception(self, plugin_name):\n        self.soslog.error(\"%s\\n%s\" % (plugin_name, traceback.format_exc()))\n\n    def prework(self):\n        self.policy.pre_work()\n        try:\n            self.ui_log.info(_(\" Setting up archive ...\"))\n            compression_methods = ('auto', 'zip', 'bzip2', 'gzip', 'xz')\n            method = self.opts.compression_type\n            if method not in compression_methods:\n                compression_list = ', '.join(compression_methods)\n                self.ui_log.error(\"\")\n                self.ui_log.error(\"Invalid compression specified: \" + method)\n                self.ui_log.error(\"Valid types are: \" + compression_list)\n                self.ui_log.error(\"\")\n                self._exit(1)\n            self._set_archive()\n            self._make_archive_paths()\n            return\n        except (OSError, IOError) as e:\n            if e.errno in fatal_fs_errors:\n                self.ui_log.error(\"\")\n                self.ui_log.error(\" %s while setting up archive\" % e.strerror)\n                self.ui_log.error(\"\")\n            else:\n                raise e\n        except Exception as e:\n            import traceback\n            self.ui_log.error(\"\")\n            self.ui_log.error(\" Unexpected exception setting up archive:\")\n            traceback.print_exc(e)\n            self.ui_log.error(e)\n        self._exit(1)\n\n    def setup(self):\n        msg = \"[%s:%s] executing 'sosreport %s'\"\n        self.soslog.info(msg % (__name__, \"setup\", \" \".join(self._args)))\n        self.ui_log.info(_(\" Setting up plugins ...\"))\n        for plugname, plug in self.loaded_plugins:\n            try:\n                plug.archive = self.archive\n                plug.setup()\n            except KeyboardInterrupt:\n                raise\n            except (OSError, IOError) as e:\n                if e.errno in fatal_fs_errors:\n                    self.ui_log.error(\"\")\n                    self.ui_log.error(\" %s while setting up plugins\"\n                                      % e.strerror)\n                    self.ui_log.error(\"\")\n                    self._exit(1)\n            except:\n                if self.raise_plugins:\n                    raise\n                else:\n                    self._log_plugin_exception(plugname)\n\n    def version(self):\n        \"\"\"Fetch version information from all plugins and store in the report\n        version file\"\"\"\n\n        versions = []\n        versions.append(\"sosreport: %s\" % __version__)\n        for plugname, plug in self.loaded_plugins:\n            versions.append(\"%s: %s\" % (plugname, plug.version))\n        self.archive.add_string(content=\"\\n\".join(versions),\n                                dest='version.txt')\n\n    def collect(self):\n        self.ui_log.info(_(\" Running plugins. Please wait ...\"))\n        self.ui_log.info(\"\")\n\n        plugruncount = 0\n        for i in zip(self.loaded_plugins):\n            plugruncount += 1\n            plugname, plug = i[0]\n            status_line = (\"  Running %d/%d: %s...        \"\n                           % (plugruncount, len(self.loaded_plugins),\n                              plugname))\n            if self.opts.verbosity == 0:\n                status_line = \"\\r%s\" % status_line\n            else:\n                status_line = \"%s\\n\" % status_line\n            if not self.opts.quiet:\n                sys.stdout.write(status_line)\n                sys.stdout.flush()\n            try:\n                plug.collect()\n            except KeyboardInterrupt:\n                raise\n            except (OSError, IOError) as e:\n                if e.errno in fatal_fs_errors:\n                    self.ui_log.error(\"\")\n                    self.ui_log.error(\" %s while collecting plugin data\"\n                                      % e.strerror)\n                    self.ui_log.error(\"\")\n                    self._exit(1)\n            except:\n                if self.raise_plugins:\n                    raise\n                else:\n                    self._log_plugin_exception(plugname)\n        self.ui_log.info(\"\")\n\n    def report(self):\n        for plugname, plug in self.loaded_plugins:\n            for oneFile in plug.copied_files:\n                try:\n                    self.xml_report.add_file(oneFile[\"srcpath\"],\n                                             os.stat(oneFile[\"srcpath\"]))\n                except:\n                    pass\n        try:\n            self.xml_report.serialize_to_file(os.path.join(self.rptdir,\n                                                           \"sosreport.xml\"))\n        except (OSError, IOError) as e:\n            if e.errno in fatal_fs_errors:\n                self.ui_log.error(\"\")\n                self.ui_log.error(\" %s while writing report data\"\n                                  % e.strerror)\n                self.ui_log.error(\"\")\n                self._exit(1)\n\n    def plain_report(self):\n        report = Report()\n\n        for plugname, plug in self.loaded_plugins:\n            section = Section(name=plugname)\n\n            for alert in plug.alerts:\n                section.add(Alert(alert))\n\n            if plug.custom_text:\n                section.add(Note(plug.custom_text))\n\n            for f in plug.copied_files:\n                section.add(CopiedFile(name=f['srcpath'],\n                            href=\"..\" + f['dstpath']))\n\n            for cmd in plug.executed_commands:\n                section.add(Command(name=cmd['exe'], return_code=0,\n                            href=\"../\" + cmd['file']))\n\n            for content, f in plug.copy_strings:\n                section.add(CreatedFile(name=f))\n\n            report.add(section)\n        try:\n            fd = self.get_temp_file()\n            fd.write(str(PlainTextReport(report)))\n            fd.flush()\n            self.archive.add_file(fd.name, dest=os.path.join('sos_reports',\n                                                             'sos.txt'))\n        except (OSError, IOError) as e:\n            if e.errno in fatal_fs_errors:\n                self.ui_log.error(\"\")\n                self.ui_log.error(\" %s while writing text report\"\n                                  % e.strerror)\n                self.ui_log.error(\"\")\n                self._exit(1)\n\n    def html_report(self):\n        try:\n            self._html_report()\n        except (OSError, IOError) as e:\n            if e.errno in fatal_fs_errors:\n                self.ui_log.error(\"\")\n                self.ui_log.error(\" %s while writing HTML report\"\n                                  % e.strerror)\n                self.ui_log.error(\"\")\n                self._exit(1)\n\n    def _html_report(self):\n        # Generate the header for the html output file\n        rfd = self.get_temp_file()\n        rfd.write(\"\"\"\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n         \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n        <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n        <head>\n            <link rel=\"stylesheet\" type=\"text/css\" media=\"screen\"\n                  href=\"donot.css\" />\n            <meta http-equiv=\"Content-Type\" content=\"text/html;\n                  charset=utf-8\" />\n            <title>Sos System Report</title>\n        </head>\n        <body>\n        \"\"\")\n\n        # Make a pass to gather Alerts and a list of module names\n        allAlerts = deque()\n        plugNames = deque()\n        for plugname, plug in self.loaded_plugins:\n            for alert in plug.alerts:\n                allAlerts.append('<a href=\"#%s\">%s</a>: %s' % (plugname,\n                                                               plugname,\n                                                               alert))\n            plugNames.append(plugname)\n\n        # Create a table of links to the module info\n        rfd.write(\"<hr/><h3>Loaded Plugins:</h3>\")\n        rfd.write(\"<table><tr>\\n\")\n        rr = 0\n        for i in range(len(plugNames)):\n            rfd.write('<td><a href=\"#%s\">%s</a></td>\\n' % (plugNames[i],\n                                                           plugNames[i]))\n            rr = divmod(i, 4)[1]\n            if (rr == 3):\n                rfd.write('</tr>')\n        if not (rr == 3):\n            rfd.write('</tr>')\n        rfd.write('</table>\\n')\n\n        rfd.write('<hr/><h3>Alerts:</h3>')\n        rfd.write('<ul>')\n        for alert in allAlerts:\n            rfd.write('<li>%s</li>' % alert)\n        rfd.write('</ul>')\n\n        # Call the report method for each plugin\n        for plugname, plug in self.loaded_plugins:\n            try:\n                html = plug.report()\n            except:\n                if self.raise_plugins:\n                    raise\n            else:\n                rfd.write(html)\n        rfd.write(\"</body></html>\")\n        rfd.flush()\n        self.archive.add_file(rfd.name, dest=os.path.join('sos_reports',\n                                                          'sos.html'))\n\n    def postproc(self):\n        for plugname, plug in self.loaded_plugins:\n            try:\n                plug.postproc()\n            except (OSError, IOError) as e:\n                if e.errno in fatal_fs_errors:\n                    self.ui_log.error(\"\")\n                    self.ui_log.error(\" %s while post-processing plugin data\"\n                                      % e.strerror)\n                    self.ui_log.error(\"\")\n                    self._exit(1)\n            except:\n                if self.raise_plugins:\n                    raise\n\n    def final_work(self):\n        # this must come before archive creation to ensure that log\n        # files are closed and cleaned up at exit.\n        self._finish_logging()\n        # package up the results for the support organization\n        if not self.opts.build:\n            if not self.opts.quiet:\n                print(_(\"Creating compressed archive...\"))\n            # compression could fail for a number of reasons\n            try:\n                final_filename = self.archive.finalize(\n                    self.opts.compression_type)\n            except (OSError, IOError) as e:\n                if e.errno in fatal_fs_errors:\n                    self.ui_log.error(\"\")\n                    self.ui_log.error(\" %s while finalizing archive\"\n                                      % e.strerror)\n                    self.ui_log.error(\"\")\n                    self._exit(1)\n            except:\n                if self.opts.debug:\n                    raise\n                else:\n                    return False\n        else:\n            final_filename = self.archive.get_archive_path()\n        self.policy.display_results(final_filename, build=self.opts.build)\n        self.tempfile_util.clean()\n        return True\n\n    def verify_plugins(self):\n        if not self.loaded_plugins:\n            self.soslog.error(_(\"no valid plugins were enabled\"))\n            return False\n        return True\n\n    def set_global_plugin_option(self, key, value):\n        self.global_plugin_options[key] = value\n\n    def execute(self):\n        try:\n            self._setup_logging()\n            self.policy.set_commons(self.get_commons())\n            self.print_header()\n            self.load_plugins()\n            self._set_all_options()\n            self._set_tunables()\n            self._check_for_unknown_plugins()\n            self._set_plugin_options()\n\n            if self.opts.list_plugins:\n                self.list_plugins()\n                return True\n            if self.opts.list_profiles:\n                self.list_profiles()\n                return True\n\n            # verify that at least one plug-in is enabled\n            if not self.verify_plugins():\n                return False\n\n            self.batch()\n            self.prework()\n            self.setup()\n            self.collect()\n            if not self.opts.report:\n                self.report()\n                self.html_report()\n                self.plain_report()\n            self.postproc()\n            self.version()\n\n            return self.final_work()\n        except (SystemExit, KeyboardInterrupt):\n            if self.archive:\n                self.archive.cleanup()\n            if self.tempfile_util:\n                self.tempfile_util.clean()\n            return False\n\n\ndef main(args):\n    \"\"\"The main entry point\"\"\"\n    sos = SoSReport(args)\n    sos.execute()\n\n# vim: et ts=4 sw=4\n"], "fixing_code": ["\"\"\"\nGather information about a system and report it using plugins\nsupplied for application-specific information\n\"\"\"\n# sosreport.py\n# gather information about a system and report it\n\n# Copyright (C) 2006 Steve Conklin <sconklin@redhat.com>\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\nimport sys\nimport traceback\nimport os\nimport errno\nimport logging\nfrom optparse import OptionParser, Option\nfrom sos.plugins import import_plugin\nfrom sos.utilities import ImporterHelper\nfrom stat import ST_UID, ST_GID, ST_MODE, ST_CTIME, ST_ATIME, ST_MTIME, S_IMODE\nfrom time import strftime, localtime\nfrom collections import deque\nimport tempfile\n\nfrom sos import _sos as _\nfrom sos import __version__\nimport sos.policies\nfrom sos.archive import TarFileArchive, ZipFileArchive\nfrom sos.reporting import (Report, Section, Command, CopiedFile, CreatedFile,\n                           Alert, Note, PlainTextReport)\n\n# PYCOMPAT\nimport six\nfrom six.moves import zip, input\nif six.PY3:\n    from configparser import ConfigParser\nelse:\n    from ConfigParser import ConfigParser\nfrom six import print_\n\n# file system errors that should terminate a run\nfatal_fs_errors = (errno.ENOSPC, errno.EROFS)\n\n\ndef _format_list(first_line, items, indent=False):\n    lines = []\n    line = first_line\n    if indent:\n        newline = len(first_line) * ' '\n    else:\n        newline = \"\"\n    for item in items:\n        if len(line) + len(item) + 2 > 72:\n            lines.append(line)\n            line = newline\n        line = line + item + ', '\n    if line[-2:] == ', ':\n        line = line[:-2]\n    lines.append(line)\n    return lines\n\n\nclass TempFileUtil(object):\n\n    def __init__(self, tmp_dir):\n        self.tmp_dir = tmp_dir\n        self.files = []\n\n    def new(self):\n        fd, fname = tempfile.mkstemp(dir=self.tmp_dir)\n        fobj = open(fname, 'w')\n        self.files.append((fname, fobj))\n        return fobj\n\n    def clean(self):\n        for fname, f in self.files:\n            try:\n                f.flush()\n                f.close()\n            except Exception:\n                pass\n            try:\n                os.unlink(fname)\n            except Exception:\n                pass\n        self.files = []\n\n\nclass OptionParserExtended(OptionParser):\n    \"\"\" Show examples \"\"\"\n    def print_help(self, out=sys.stdout):\n        \"\"\" Prints help content including examples \"\"\"\n        OptionParser.print_help(self, out)\n        print_()\n        print_(\"Some examples:\")\n        print_()\n        print_(\" enable cluster plugin only and collect dlm lockdumps:\")\n        print_(\"   # sosreport -o cluster -k cluster.lockdump\")\n        print_()\n        print_(\" disable memory and samba plugins, turn off rpm -Va \"\n               \"collection:\")\n        print_(\"   # sosreport -n memory,samba -k rpm.rpmva=off\")\n        print_()\n\n\nclass SosOption(Option):\n    \"\"\"Allow to specify comma delimited list of plugins\"\"\"\n    ACTIONS = Option.ACTIONS + (\"extend\",)\n    STORE_ACTIONS = Option.STORE_ACTIONS + (\"extend\",)\n    TYPED_ACTIONS = Option.TYPED_ACTIONS + (\"extend\",)\n\n    def take_action(self, action, dest, opt, value, values, parser):\n        \"\"\" Performs list extension on plugins \"\"\"\n        if action == \"extend\":\n            try:\n                lvalue = value.split(\",\")\n            except:\n                pass\n            else:\n                values.ensure_value(dest, deque()).extend(lvalue)\n        else:\n            Option.take_action(self, action, dest, opt, value, values, parser)\n\n\nclass XmlReport(object):\n    \"\"\" Report build class \"\"\"\n\n    def __init__(self):\n        try:\n            import libxml2\n        except ImportError:\n            self.enabled = False\n            return\n        else:\n            self.enabled = False\n            return\n        self.doc = libxml2.newDoc(\"1.0\")\n        self.root = self.doc.newChild(None, \"sos\", None)\n        self.commands = self.root.newChild(None, \"commands\", None)\n        self.files = self.root.newChild(None, \"files\", None)\n\n    def add_command(self, cmdline, exitcode, stdout=None, stderr=None,\n                    f_stdout=None, f_stderr=None, runtime=None):\n        \"\"\" Appends command run into report \"\"\"\n        if not self.enabled:\n            return\n\n        cmd = self.commands.newChild(None, \"cmd\", None)\n\n        cmd.setNsProp(None, \"cmdline\", cmdline)\n\n        cmdchild = cmd.newChild(None, \"exitcode\", str(exitcode))\n\n        if runtime:\n            cmd.newChild(None, \"runtime\", str(runtime))\n\n        if stdout or f_stdout:\n            cmdchild = cmd.newChild(None, \"stdout\", stdout)\n            if f_stdout:\n                cmdchild.setNsProp(None, \"file\", f_stdout)\n\n        if stderr or f_stderr:\n            cmdchild = cmd.newChild(None, \"stderr\", stderr)\n            if f_stderr:\n                cmdchild.setNsProp(None, \"file\", f_stderr)\n\n    def add_file(self, fname, stats):\n        \"\"\" Appends file(s) added to report \"\"\"\n        if not self.enabled:\n            return\n\n        cfile = self.files.newChild(None, \"file\", None)\n\n        cfile.setNsProp(None, \"fname\", fname)\n\n        cchild = cfile.newChild(None, \"uid\", str(stats[ST_UID]))\n        cchild = cfile.newChild(None, \"gid\", str(stats[ST_GID]))\n        cfile.newChild(None, \"mode\", str(oct(S_IMODE(stats[ST_MODE]))))\n        cchild = cfile.newChild(None, \"ctime\",\n                                strftime('%a %b %d %H:%M:%S %Y',\n                                         localtime(stats[ST_CTIME])))\n        cchild.setNsProp(None, \"tstamp\", str(stats[ST_CTIME]))\n        cchild = cfile.newChild(None, \"atime\",\n                                strftime('%a %b %d %H:%M:%S %Y',\n                                         localtime(stats[ST_ATIME])))\n        cchild.setNsProp(None, \"tstamp\", str(stats[ST_ATIME]))\n        cchild = cfile.newChild(None, \"mtime\",\n                                strftime('%a %b %d %H:%M:%S %Y',\n                                         localtime(stats[ST_MTIME])))\n        cchild.setNsProp(None, \"tstamp\", str(stats[ST_MTIME]))\n\n    def serialize(self):\n        \"\"\" Serializes xml \"\"\"\n        if not self.enabled:\n            return\n\n        self.ui_log.info(self.doc.serialize(None,  1))\n\n    def serialize_to_file(self, fname):\n        \"\"\" Serializes to file \"\"\"\n        if not self.enabled:\n            return\n\n        outf = tempfile.NamedTemporaryFile()\n        outf.write(self.doc.serialize(None, 1))\n        outf.flush()\n        self.archive.add_file(outf.name, dest=fname)\n        outf.close()\n\n\nclass SoSOptions(object):\n    _list_plugins = False\n    _noplugins = []\n    _enableplugins = []\n    _onlyplugins = []\n    _plugopts = []\n    _usealloptions = False\n    _all_logs = False\n    _log_size = 10\n    _batch = False\n    _build = False\n    _verbosity = 0\n    _verify = False\n    _quiet = False\n    _debug = False\n    _case_id = \"\"\n    _customer_name = \"\"\n    _profiles = deque()\n    _list_profiles = False\n    _config_file = \"\"\n    _tmp_dir = \"\"\n    _report = True\n    _compression_type = 'auto'\n\n    _options = None\n\n    def __init__(self, args=None):\n        if args:\n            self._options = self._parse_args(args)\n        else:\n            self._options = None\n\n    def _check_options_initialized(self):\n        if self._options is not None:\n            raise ValueError(\"SoSOptions object already initialized \"\n                             + \"from command line\")\n\n    @property\n    def list_plugins(self):\n        if self._options is not None:\n            return self._options.list_plugins\n        return self._list_plugins\n\n    @list_plugins.setter\n    def list_plugins(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.list_plugins expects a boolean\")\n        self._list_plugins = value\n\n    @property\n    def noplugins(self):\n        if self._options is not None:\n            return self._options.noplugins\n        return self._noplugins\n\n    @noplugins.setter\n    def noplugins(self, value):\n        self._check_options_initialized()\n        self._noplugins = value\n\n    @property\n    def enableplugins(self):\n        if self._options is not None:\n            return self._options.enableplugins\n        return self._enableplugins\n\n    @enableplugins.setter\n    def enableplugins(self, value):\n        self._check_options_initialized()\n        self._enableplugins = value\n\n    @property\n    def onlyplugins(self):\n        if self._options is not None:\n            return self._options.onlyplugins\n        return self._onlyplugins\n\n    @onlyplugins.setter\n    def onlyplugins(self, value):\n        self._check_options_initialized()\n        self._onlyplugins = value\n\n    @property\n    def plugopts(self):\n        if self._options is not None:\n            return self._options.plugopts\n        return self._plugopts\n\n    @plugopts.setter\n    def plugopts(self, value):\n        # If we check for anything it should be itterability.\n        # if not isinstance(value, list):\n        #    raise TypeError(\"SoSOptions.plugopts expects a list\")\n        self._plugopts = value\n\n    @property\n    def usealloptions(self):\n        if self._options is not None:\n            return self._options.usealloptions\n        return self._usealloptions\n\n    @usealloptions.setter\n    def usealloptions(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.usealloptions expects a boolean\")\n        self._usealloptions = value\n\n    @property\n    def all_logs(self):\n        if self._options is not None:\n            return self._options.all_logs\n        return self._all_logs\n\n    @all_logs.setter\n    def all_logs(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.all_logs expects a boolean\")\n        self._all_logs = value\n\n    @property\n    def log_size(self):\n        if self._options is not None:\n            return self._options.log_size\n        return self._log_size\n\n    @log_size.setter\n    def log_size(self, value):\n        self._check_options_initialized()\n        if value < 0:\n            raise ValueError(\"SoSOptions.log_size expects a value greater \"\n                             \"than zero\")\n        self._log_size = value\n\n    @property\n    def batch(self):\n        if self._options is not None:\n            return self._options.batch\n        return self._batch\n\n    @batch.setter\n    def batch(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.batch expects a boolean\")\n        self._batch = value\n\n    @property\n    def build(self):\n        if self._options is not None:\n            return self._options.build\n        return self._build\n\n    @build.setter\n    def build(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.build expects a boolean\")\n        self._build = value\n\n    @property\n    def verbosity(self):\n        if self._options is not None:\n            return self._options.verbosity\n        return self._verbosity\n\n    @verbosity.setter\n    def verbosity(self, value):\n        self._check_options_initialized()\n        if value < 0 or value > 3:\n            raise ValueError(\"SoSOptions.verbosity expects a value [0..3]\")\n        self._verbosity = value\n\n    @property\n    def verify(self):\n        if self._options is not None:\n            return self._options.verify\n        return self._verify\n\n    @verify.setter\n    def verify(self, value):\n        self._check_options_initialized()\n        if value < 0 or value > 3:\n            raise ValueError(\"SoSOptions.verify expects a value [0..3]\")\n        self._verify = value\n\n    @property\n    def quiet(self):\n        if self._options is not None:\n            return self._options.quiet\n        return self._quiet\n\n    @quiet.setter\n    def quiet(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.quiet expects a boolean\")\n        self._quiet = value\n\n    @property\n    def debug(self):\n        if self._options is not None:\n            return self._options.debug\n        return self._debug\n\n    @debug.setter\n    def debug(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.debug expects a boolean\")\n        self._debug = value\n\n    @property\n    def case_id(self):\n        if self._options is not None:\n            return self._options.case_id\n        return self._case_id\n\n    @case_id.setter\n    def case_id(self, value):\n        self._check_options_initialized()\n        self._case_id = value\n\n    @property\n    def customer_name(self):\n        if self._options is not None:\n            return self._options.customer_name\n        return self._customer_name\n\n    @customer_name.setter\n    def customer_name(self, value):\n        self._check_options_initialized()\n        self._customer_name = value\n\n    @property\n    def profiles(self):\n        if self._options is not None:\n            return self._options.profiles\n        return self._profiles\n\n    @profiles.setter\n    def profiles(self, value):\n        self._check_options_initialized()\n        self._profiles = value\n\n    @property\n    def list_profiles(self):\n        if self._options is not None:\n            return self._options.list_profiles\n        return self._list_profiles\n\n    @list_profiles.setter\n    def list_profiles(self, value):\n        self._check_options_initialized()\n        self._list_profiles = value\n\n    @property\n    def config_file(self):\n        if self._options is not None:\n            return self._options.config_file\n        return self._config_file\n\n    @config_file.setter\n    def config_file(self, value):\n        self._check_options_initialized()\n        self._config_file = value\n\n    @property\n    def tmp_dir(self):\n        if self._options is not None:\n            return self._options.tmp_dir\n        return self._tmp_dir\n\n    @tmp_dir.setter\n    def tmp_dir(self, value):\n        self._check_options_initialized()\n        self._tmp_dir = value\n\n    @property\n    def report(self):\n        if self._options is not None:\n            return self._options.report\n        return self._report\n\n    @report.setter\n    def report(self, value):\n        self._check_options_initialized()\n        if not isinstance(value, bool):\n            raise TypeError(\"SoSOptions.report expects a boolean\")\n        self._report = value\n\n    @property\n    def compression_type(self):\n        if self._options is not None:\n            return self._options.compression_type\n        return self._compression_type\n\n    @compression_type.setter\n    def compression_type(self, value):\n        self._check_options_initialized()\n        self._compression_type = value\n\n    def _parse_args(self, args):\n        \"\"\" Parse command line options and arguments\"\"\"\n\n        self.parser = parser = OptionParserExtended(option_class=SosOption)\n        parser.add_option(\"-l\", \"--list-plugins\", action=\"store_true\",\n                          dest=\"list_plugins\", default=False,\n                          help=\"list plugins and available plugin options\")\n        parser.add_option(\"-n\", \"--skip-plugins\", action=\"extend\",\n                          dest=\"noplugins\", type=\"string\",\n                          help=\"disable these plugins\", default=deque())\n        parser.add_option(\"-e\", \"--enable-plugins\", action=\"extend\",\n                          dest=\"enableplugins\", type=\"string\",\n                          help=\"enable these plugins\", default=deque())\n        parser.add_option(\"-o\", \"--only-plugins\", action=\"extend\",\n                          dest=\"onlyplugins\", type=\"string\",\n                          help=\"enable these plugins only\", default=deque())\n        parser.add_option(\"-k\", \"--plugin-option\", action=\"extend\",\n                          dest=\"plugopts\", type=\"string\",\n                          help=\"plugin options in plugname.option=value \"\n                               \"format (see -l)\",\n                          default=deque())\n        parser.add_option(\"--log-size\", action=\"store\",\n                          dest=\"log_size\", default=10, type=\"int\",\n                          help=\"set a limit on the size of collected logs\")\n        parser.add_option(\"-a\", \"--alloptions\", action=\"store_true\",\n                          dest=\"usealloptions\", default=False,\n                          help=\"enable all options for loaded plugins\")\n        parser.add_option(\"--all-logs\", action=\"store_true\",\n                          dest=\"all_logs\", default=False,\n                          help=\"collect all available logs regardless of size\")\n        parser.add_option(\"--batch\", action=\"store_true\",\n                          dest=\"batch\", default=False,\n                          help=\"batch mode - do not prompt interactively\")\n        parser.add_option(\"--build\", action=\"store_true\",\n                          dest=\"build\", default=False,\n                          help=\"preserve the temporary directory and do not \"\n                               \"package results\")\n        parser.add_option(\"-v\", \"--verbose\", action=\"count\",\n                          dest=\"verbosity\",\n                          help=\"increase verbosity\")\n        parser.add_option(\"\", \"--verify\", action=\"store_true\",\n                          dest=\"verify\", default=False,\n                          help=\"perform data verification during collection\")\n        parser.add_option(\"\", \"--quiet\", action=\"store_true\",\n                          dest=\"quiet\", default=False,\n                          help=\"only print fatal errors\")\n        parser.add_option(\"--debug\", action=\"count\",\n                          dest=\"debug\",\n                          help=\"enable interactive debugging using the python \"\n                               \"debugger\")\n        parser.add_option(\"--ticket-number\", action=\"store\",\n                          dest=\"case_id\",\n                          help=\"specify ticket number\")\n        parser.add_option(\"--case-id\", action=\"store\",\n                          dest=\"case_id\",\n                          help=\"specify case identifier\")\n        parser.add_option(\"-p\", \"--profile\", action=\"extend\",\n                          dest=\"profiles\", type=\"string\", default=deque(),\n                          help=\"enable plugins selected by the given profiles\")\n        parser.add_option(\"--list-profiles\", action=\"store_true\",\n                          dest=\"list_profiles\", default=False)\n        parser.add_option(\"--name\", action=\"store\",\n                          dest=\"customer_name\",\n                          help=\"specify report name\")\n        parser.add_option(\"--config-file\", action=\"store\",\n                          dest=\"config_file\",\n                          help=\"specify alternate configuration file\")\n        parser.add_option(\"--tmp-dir\", action=\"store\",\n                          dest=\"tmp_dir\",\n                          help=\"specify alternate temporary directory\",\n                          default=None)\n        parser.add_option(\"--no-report\", action=\"store_true\",\n                          dest=\"report\",\n                          help=\"Disable HTML/XML reporting\", default=False)\n        parser.add_option(\"-z\", \"--compression-type\", dest=\"compression_type\",\n                          help=\"compression technology to use [auto, zip, \"\n                               \"gzip, bzip2, xz] (default=auto)\",\n                          default=\"auto\")\n\n        return parser.parse_args(args)[0]\n\n\nclass SoSReport(object):\n    \"\"\"The main sosreport class\"\"\"\n\n    def __init__(self, args):\n        self.loaded_plugins = deque()\n        self.skipped_plugins = deque()\n        self.all_options = deque()\n        self.xml_report = XmlReport()\n        self.global_plugin_options = {}\n        self.archive = None\n        self.tempfile_util = None\n        self._args = args\n\n        try:\n            import signal\n            signal.signal(signal.SIGTERM, self.get_exit_handler())\n        except Exception:\n            pass  # not available in java, but we don't care\n\n        self.opts = SoSOptions(args)\n        self._set_debug()\n        self._read_config()\n\n        try:\n            self.policy = sos.policies.load()\n        except KeyboardInterrupt:\n            self._exit(0)\n\n        self._is_root = self.policy.is_root()\n\n        self.tmpdir = os.path.abspath(\n            self.policy.get_tmp_dir(self.opts.tmp_dir))\n        if not os.path.isdir(self.tmpdir) \\\n                or not os.access(self.tmpdir, os.W_OK):\n            # write directly to stderr as logging is not initialised yet\n            sys.stderr.write(\"temporary directory %s \" % self.tmpdir\n                             + \"does not exist or is not writable\\n\")\n            self._exit(1)\n        self.tempfile_util = TempFileUtil(self.tmpdir)\n        self._set_directories()\n\n    def print_header(self):\n        self.ui_log.info(\"\\n%s\\n\" % _(\"sosreport (version %s)\" %\n                         (__version__,)))\n\n    def get_commons(self):\n        return {\n            'cmddir': self.cmddir,\n            'logdir': self.logdir,\n            'rptdir': self.rptdir,\n            'tmpdir': self.tmpdir,\n            'soslog': self.soslog,\n            'policy': self.policy,\n            'verbosity': self.opts.verbosity,\n            'xmlreport': self.xml_report,\n            'cmdlineopts': self.opts,\n            'config': self.config,\n            'global_plugin_options': self.global_plugin_options,\n            }\n\n    def get_temp_file(self):\n        return self.tempfile_util.new()\n\n    def _set_archive(self):\n        archive_name = os.path.join(self.tmpdir,\n                                    self.policy.get_archive_name())\n        if self.opts.compression_type == 'auto':\n            auto_archive = self.policy.get_preferred_archive()\n            self.archive = auto_archive(archive_name, self.tmpdir)\n        elif self.opts.compression_type == 'zip':\n            self.archive = ZipFileArchive(archive_name, self.tmpdir)\n        else:\n            self.archive = TarFileArchive(archive_name, self.tmpdir)\n        self.archive.set_debug(True if self.opts.debug else False)\n\n    def _make_archive_paths(self):\n        self.archive.makedirs(self.cmddir, 0o755)\n        self.archive.makedirs(self.logdir, 0o755)\n        self.archive.makedirs(self.rptdir, 0o755)\n\n    def _set_directories(self):\n        self.cmddir = 'sos_commands'\n        self.logdir = 'sos_logs'\n        self.rptdir = 'sos_reports'\n\n    def _set_debug(self):\n        if self.opts.debug:\n            sys.excepthook = self._exception\n            self.raise_plugins = True\n        else:\n            self.raise_plugins = False\n\n    @staticmethod\n    def _exception(etype, eval_, etrace):\n        \"\"\" Wrap exception in debugger if not in tty \"\"\"\n        if hasattr(sys, 'ps1') or not sys.stderr.isatty():\n            # we are in interactive mode or we don't have a tty-like\n            # device, so we call the default hook\n            sys.__excepthook__(etype, eval_, etrace)\n        else:\n            import pdb\n            # we are NOT in interactive mode, print the exception...\n            traceback.print_exception(etype, eval_, etrace, limit=2,\n                                      file=sys.stdout)\n            print_()\n            # ...then start the debugger in post-mortem mode.\n            pdb.pm()\n\n    def _exit(self, error=0):\n        raise SystemExit()\n#        sys.exit(error)\n\n    def get_exit_handler(self):\n        def exit_handler(signum, frame):\n            self._exit()\n        return exit_handler\n\n    def _read_config(self):\n        self.config = ConfigParser()\n        if self.opts.config_file:\n            config_file = self.opts.config_file\n        else:\n            config_file = '/etc/sos.conf'\n        try:\n            self.config.readfp(open(config_file))\n        except IOError:\n            pass\n\n    def _setup_logging(self):\n        # main soslog\n        self.soslog = logging.getLogger('sos')\n        self.soslog.setLevel(logging.DEBUG)\n        self.sos_log_file = self.get_temp_file()\n        self.sos_log_file.close()\n        flog = logging.FileHandler(self.sos_log_file.name)\n        flog.setFormatter(logging.Formatter(\n            '%(asctime)s %(levelname)s: %(message)s'))\n        flog.setLevel(logging.INFO)\n        self.soslog.addHandler(flog)\n\n        if not self.opts.quiet:\n            console = logging.StreamHandler(sys.stderr)\n            console.setFormatter(logging.Formatter('%(message)s'))\n            if self.opts.verbosity and self.opts.verbosity > 1:\n                console.setLevel(logging.DEBUG)\n                flog.setLevel(logging.DEBUG)\n            elif self.opts.verbosity and self.opts.verbosity > 0:\n                console.setLevel(logging.INFO)\n                flog.setLevel(logging.DEBUG)\n            else:\n                console.setLevel(logging.WARNING)\n            self.soslog.addHandler(console)\n\n        # ui log\n        self.ui_log = logging.getLogger('sos_ui')\n        self.ui_log.setLevel(logging.INFO)\n        self.sos_ui_log_file = self.get_temp_file()\n        self.sos_ui_log_file.close()\n        ui_fhandler = logging.FileHandler(self.sos_ui_log_file.name)\n        ui_fhandler.setFormatter(logging.Formatter(\n            '%(asctime)s %(levelname)s: %(message)s'))\n\n        self.ui_log.addHandler(ui_fhandler)\n\n        if not self.opts.quiet:\n            ui_console = logging.StreamHandler(sys.stdout)\n            ui_console.setFormatter(logging.Formatter('%(message)s'))\n            ui_console.setLevel(logging.INFO)\n            self.ui_log.addHandler(ui_console)\n\n    def _finish_logging(self):\n        logging.shutdown()\n\n        # Make sure the log files are added before we remove the log\n        # handlers. This prevents \"No handlers could be found..\" messages\n        # from leaking to the console when running in --quiet mode when\n        # Archive classes attempt to acess the log API.\n        if getattr(self, \"sos_log_file\", None):\n            self.archive.add_file(self.sos_log_file.name,\n                                  dest=os.path.join('sos_logs', 'sos.log'))\n        if getattr(self, \"sos_ui_log_file\", None):\n            self.archive.add_file(self.sos_ui_log_file.name,\n                                  dest=os.path.join('sos_logs', 'ui.log'))\n\n    def _get_disabled_plugins(self):\n        disabled = []\n        if self.config.has_option(\"plugins\", \"disable\"):\n            disabled = [plugin.strip() for plugin in\n                        self.config.get(\"plugins\", \"disable\").split(',')]\n        return disabled\n\n    def _is_in_profile(self, plugin_class):\n        onlyplugins = self.opts.onlyplugins\n        if not len(self.opts.profiles):\n            return True\n        if not hasattr(plugin_class, \"profiles\"):\n            return False\n        if onlyplugins and not self._is_not_specified(plugin_class.name()):\n            return True\n        return any([p in self.opts.profiles for p in plugin_class.profiles])\n\n    def _is_skipped(self, plugin_name):\n        return (plugin_name in self.opts.noplugins or\n                plugin_name in self._get_disabled_plugins())\n\n    def _is_inactive(self, plugin_name, pluginClass):\n        return (not pluginClass(self.get_commons()).check_enabled() and\n                plugin_name not in self.opts.enableplugins and\n                plugin_name not in self.opts.onlyplugins)\n\n    def _is_not_default(self, plugin_name, pluginClass):\n        return (not pluginClass(self.get_commons()).default_enabled() and\n                plugin_name not in self.opts.enableplugins and\n                plugin_name not in self.opts.onlyplugins)\n\n    def _is_not_specified(self, plugin_name):\n        return (self.opts.onlyplugins and\n                plugin_name not in self.opts.onlyplugins)\n\n    def _skip(self, plugin_class, reason=\"unknown\"):\n        self.skipped_plugins.append((\n            plugin_class.name(),\n            plugin_class(self.get_commons()),\n            reason\n        ))\n\n    def _load(self, plugin_class):\n        self.loaded_plugins.append((\n            plugin_class.name(),\n            plugin_class(self.get_commons())\n        ))\n\n    def load_plugins(self):\n\n        import sos.plugins\n        helper = ImporterHelper(sos.plugins)\n        plugins = helper.get_modules()\n        self.plugin_names = deque()\n        self.profiles = set()\n        using_profiles = len(self.opts.profiles)\n        # validate and load plugins\n        for plug in plugins:\n            plugbase, ext = os.path.splitext(plug)\n            try:\n                plugin_classes = import_plugin(\n                    plugbase, tuple(self.policy.valid_subclasses))\n                if not len(plugin_classes):\n                    # no valid plugin classes for this policy\n                    continue\n\n                plugin_class = self.policy.match_plugin(plugin_classes)\n                if not self.policy.validate_plugin(plugin_class):\n                    self.soslog.warning(\n                        _(\"plugin %s does not validate, skipping\") % plug)\n                    if self.opts.verbosity > 0:\n                        self._skip(plugin_class, _(\"does not validate\"))\n                        continue\n\n                if plugin_class.requires_root and not self._is_root:\n                    self.soslog.info(_(\"plugin %s requires root permissions\"\n                                       \"to execute, skipping\") % plug)\n                    self._skip(plugin_class, _(\"requires root\"))\n                    continue\n\n                # plug-in is valid, let's decide whether run it or not\n                self.plugin_names.append(plugbase)\n                if hasattr(plugin_class, \"profiles\"):\n                    self.profiles.update(plugin_class.profiles)\n\n                in_profile = self._is_in_profile(plugin_class)\n                if not in_profile:\n                    self._skip(plugin_class, _(\"excluded\"))\n                    continue\n\n                if self._is_skipped(plugbase):\n                    self._skip(plugin_class, _(\"skipped\"))\n                    continue\n\n                if self._is_inactive(plugbase, plugin_class):\n                    self._skip(plugin_class, _(\"inactive\"))\n                    continue\n\n                if self._is_not_default(plugbase, plugin_class):\n                    self._skip(plugin_class, _(\"optional\"))\n                    continue\n\n                # true when the null (empty) profile is active\n                default_profile = not using_profiles and in_profile\n                if self._is_not_specified(plugbase) and default_profile:\n                    self._skip(plugin_class, _(\"not specified\"))\n                    continue\n\n                self._load(plugin_class)\n            except Exception as e:\n                self.soslog.warning(_(\"plugin %s does not install, \"\n                                    \"skipping: %s\") % (plug, e))\n                if self.raise_plugins:\n                    raise\n\n    def _set_all_options(self):\n        if self.opts.usealloptions:\n            for plugname, plug in self.loaded_plugins:\n                for name, parms in zip(plug.opt_names, plug.opt_parms):\n                    if type(parms[\"enabled\"]) == bool:\n                        parms[\"enabled\"] = True\n\n    def _set_tunables(self):\n        if self.config.has_section(\"tunables\"):\n            if not self.opts.plugopts:\n                self.opts.plugopts = deque()\n\n            for opt, val in self.config.items(\"tunables\"):\n                if not opt.split('.')[0] in self._get_disabled_plugins():\n                    self.opts.plugopts.append(opt + \"=\" + val)\n        if self.opts.plugopts:\n            opts = {}\n            for opt in self.opts.plugopts:\n                # split up \"general.syslogsize=5\"\n                try:\n                    opt, val = opt.split(\"=\")\n                except:\n                    val = True\n                else:\n                    if val.lower() in [\"off\", \"disable\", \"disabled\", \"false\"]:\n                        val = False\n                    else:\n                        # try to convert string \"val\" to int()\n                        try:\n                            val = int(val)\n                        except:\n                            pass\n\n                # split up \"general.syslogsize\"\n                try:\n                    plug, opt = opt.split(\".\")\n                except:\n                    plug = opt\n                    opt = True\n\n                try:\n                    opts[plug]\n                except KeyError:\n                    opts[plug] = deque()\n                opts[plug].append((opt, val))\n\n            for plugname, plug in self.loaded_plugins:\n                if plugname in opts:\n                    for opt, val in opts[plugname]:\n                        if not plug.set_option(opt, val):\n                            self.soslog.error('no such option \"%s\" for plugin '\n                                              '(%s)' % (opt, plugname))\n                            self._exit(1)\n                    del opts[plugname]\n            for plugname in opts.keys():\n                self.soslog.error('unable to set option for disabled or '\n                                  'non-existing plugin (%s)' % (plugname))\n\n    def _check_for_unknown_plugins(self):\n        import itertools\n        for plugin in itertools.chain(self.opts.onlyplugins,\n                                      self.opts.noplugins,\n                                      self.opts.enableplugins):\n            plugin_name = plugin.split(\".\")[0]\n            if plugin_name not in self.plugin_names:\n                self.soslog.fatal('a non-existing plugin (%s) was specified '\n                                  'in the command line' % (plugin_name))\n                self._exit(1)\n\n    def _set_plugin_options(self):\n        for plugin_name, plugin in self.loaded_plugins:\n            names, parms = plugin.get_all_options()\n            for optname, optparm in zip(names, parms):\n                self.all_options.append((plugin, plugin_name, optname,\n                                         optparm))\n\n    def list_plugins(self):\n        if not self.loaded_plugins and not self.skipped_plugins:\n            self.soslog.fatal(_(\"no valid plugins found\"))\n            return\n\n        if self.loaded_plugins:\n            self.ui_log.info(_(\"The following plugins are currently enabled:\"))\n            self.ui_log.info(\"\")\n            for (plugname, plug) in self.loaded_plugins:\n                self.ui_log.info(\" %-20s %s\" % (plugname,\n                                                plug.get_description()))\n        else:\n            self.ui_log.info(_(\"No plugin enabled.\"))\n        self.ui_log.info(\"\")\n\n        if self.skipped_plugins:\n            self.ui_log.info(_(\"The following plugins are currently \"\n                             \"disabled:\"))\n            self.ui_log.info(\"\")\n            for (plugname, plugclass, reason) in self.skipped_plugins:\n                self.ui_log.info(\" %-20s %-14s %s\" % (\n                    plugname,\n                    reason,\n                    plugclass.get_description()))\n        self.ui_log.info(\"\")\n\n        if self.all_options:\n            self.ui_log.info(_(\"The following plugin options are available:\"))\n            self.ui_log.info(\"\")\n            for (plug, plugname, optname, optparm) in self.all_options:\n                # format option value based on its type (int or bool)\n                if type(optparm[\"enabled\"]) == bool:\n                    if optparm[\"enabled\"] is True:\n                        tmpopt = \"on\"\n                    else:\n                        tmpopt = \"off\"\n                else:\n                    tmpopt = optparm[\"enabled\"]\n\n                self.ui_log.info(\" %-25s %-15s %s\" % (\n                    plugname + \".\" + optname, tmpopt, optparm[\"desc\"]))\n        else:\n            self.ui_log.info(_(\"No plugin options available.\"))\n\n        self.ui_log.info(\"\")\n        profiles = list(self.profiles)\n        profiles.sort()\n        lines = _format_list(\"Profiles: \", profiles, indent=True)\n        for line in lines:\n            self.ui_log.info(\" %s\" % line)\n        self.ui_log.info(\"\")\n        self.ui_log.info(\" %d profiles, %d plugins\"\n                         % (len(self.profiles), len(self.loaded_plugins)))\n        self.ui_log.info(\"\")\n\n    def list_profiles(self):\n        if not self.profiles:\n            self.soslog.fatal(_(\"no valid profiles found\"))\n            return\n        self.ui_log.info(_(\"The following profiles are available:\"))\n        self.ui_log.info(\"\")\n\n        def _has_prof(c):\n            return hasattr(c, \"profiles\")\n\n        profiles = list(self.profiles)\n        profiles.sort()\n        for profile in profiles:\n            plugins = []\n            for name, plugin in self.loaded_plugins:\n                if _has_prof(plugin) and profile in plugin.profiles:\n                    plugins.append(name)\n            lines = _format_list(\"%-15s \" % profile, plugins, indent=True)\n            for line in lines:\n                self.ui_log.info(\" %s\" % line)\n        self.ui_log.info(\"\")\n        self.ui_log.info(\" %d profiles, %d plugins\"\n                         % (len(profiles), len(self.loaded_plugins)))\n        self.ui_log.info(\"\")\n\n    def batch(self):\n        if self.opts.batch:\n            self.ui_log.info(self.policy.get_msg())\n        else:\n            msg = self.policy.get_msg()\n            msg += _(\"Press ENTER to continue, or CTRL-C to quit.\\n\")\n            try:\n                input(msg)\n            except:\n                self.ui_log.info(\"\")\n                self._exit()\n\n    def _log_plugin_exception(self, plugin_name):\n        self.soslog.error(\"%s\\n%s\" % (plugin_name, traceback.format_exc()))\n\n    def prework(self):\n        self.policy.pre_work()\n        try:\n            self.ui_log.info(_(\" Setting up archive ...\"))\n            compression_methods = ('auto', 'zip', 'bzip2', 'gzip', 'xz')\n            method = self.opts.compression_type\n            if method not in compression_methods:\n                compression_list = ', '.join(compression_methods)\n                self.ui_log.error(\"\")\n                self.ui_log.error(\"Invalid compression specified: \" + method)\n                self.ui_log.error(\"Valid types are: \" + compression_list)\n                self.ui_log.error(\"\")\n                self._exit(1)\n            self._set_archive()\n            self._make_archive_paths()\n            return\n        except (OSError, IOError) as e:\n            if e.errno in fatal_fs_errors:\n                self.ui_log.error(\"\")\n                self.ui_log.error(\" %s while setting up archive\" % e.strerror)\n                self.ui_log.error(\"\")\n            else:\n                raise e\n        except Exception as e:\n            import traceback\n            self.ui_log.error(\"\")\n            self.ui_log.error(\" Unexpected exception setting up archive:\")\n            traceback.print_exc(e)\n            self.ui_log.error(e)\n        self._exit(1)\n\n    def setup(self):\n        msg = \"[%s:%s] executing 'sosreport %s'\"\n        self.soslog.info(msg % (__name__, \"setup\", \" \".join(self._args)))\n        self.ui_log.info(_(\" Setting up plugins ...\"))\n        for plugname, plug in self.loaded_plugins:\n            try:\n                plug.archive = self.archive\n                plug.setup()\n            except KeyboardInterrupt:\n                raise\n            except (OSError, IOError) as e:\n                if e.errno in fatal_fs_errors:\n                    self.ui_log.error(\"\")\n                    self.ui_log.error(\" %s while setting up plugins\"\n                                      % e.strerror)\n                    self.ui_log.error(\"\")\n                    self._exit(1)\n            except:\n                if self.raise_plugins:\n                    raise\n                else:\n                    self._log_plugin_exception(plugname)\n\n    def version(self):\n        \"\"\"Fetch version information from all plugins and store in the report\n        version file\"\"\"\n\n        versions = []\n        versions.append(\"sosreport: %s\" % __version__)\n        for plugname, plug in self.loaded_plugins:\n            versions.append(\"%s: %s\" % (plugname, plug.version))\n        self.archive.add_string(content=\"\\n\".join(versions),\n                                dest='version.txt')\n\n    def collect(self):\n        self.ui_log.info(_(\" Running plugins. Please wait ...\"))\n        self.ui_log.info(\"\")\n\n        plugruncount = 0\n        for i in zip(self.loaded_plugins):\n            plugruncount += 1\n            plugname, plug = i[0]\n            status_line = (\"  Running %d/%d: %s...        \"\n                           % (plugruncount, len(self.loaded_plugins),\n                              plugname))\n            if self.opts.verbosity == 0:\n                status_line = \"\\r%s\" % status_line\n            else:\n                status_line = \"%s\\n\" % status_line\n            if not self.opts.quiet:\n                sys.stdout.write(status_line)\n                sys.stdout.flush()\n            try:\n                plug.collect()\n            except KeyboardInterrupt:\n                raise\n            except (OSError, IOError) as e:\n                if e.errno in fatal_fs_errors:\n                    self.ui_log.error(\"\")\n                    self.ui_log.error(\" %s while collecting plugin data\"\n                                      % e.strerror)\n                    self.ui_log.error(\"\")\n                    self._exit(1)\n            except:\n                if self.raise_plugins:\n                    raise\n                else:\n                    self._log_plugin_exception(plugname)\n        self.ui_log.info(\"\")\n\n    def report(self):\n        for plugname, plug in self.loaded_plugins:\n            for oneFile in plug.copied_files:\n                try:\n                    self.xml_report.add_file(oneFile[\"srcpath\"],\n                                             os.stat(oneFile[\"srcpath\"]))\n                except:\n                    pass\n        try:\n            self.xml_report.serialize_to_file(os.path.join(self.rptdir,\n                                                           \"sosreport.xml\"))\n        except (OSError, IOError) as e:\n            if e.errno in fatal_fs_errors:\n                self.ui_log.error(\"\")\n                self.ui_log.error(\" %s while writing report data\"\n                                  % e.strerror)\n                self.ui_log.error(\"\")\n                self._exit(1)\n\n    def plain_report(self):\n        report = Report()\n\n        for plugname, plug in self.loaded_plugins:\n            section = Section(name=plugname)\n\n            for alert in plug.alerts:\n                section.add(Alert(alert))\n\n            if plug.custom_text:\n                section.add(Note(plug.custom_text))\n\n            for f in plug.copied_files:\n                section.add(CopiedFile(name=f['srcpath'],\n                            href=\"..\" + f['dstpath']))\n\n            for cmd in plug.executed_commands:\n                section.add(Command(name=cmd['exe'], return_code=0,\n                            href=\"../\" + cmd['file']))\n\n            for content, f in plug.copy_strings:\n                section.add(CreatedFile(name=f))\n\n            report.add(section)\n        try:\n            fd = self.get_temp_file()\n            fd.write(str(PlainTextReport(report)))\n            fd.flush()\n            self.archive.add_file(fd.name, dest=os.path.join('sos_reports',\n                                                             'sos.txt'))\n        except (OSError, IOError) as e:\n            if e.errno in fatal_fs_errors:\n                self.ui_log.error(\"\")\n                self.ui_log.error(\" %s while writing text report\"\n                                  % e.strerror)\n                self.ui_log.error(\"\")\n                self._exit(1)\n\n    def html_report(self):\n        try:\n            self._html_report()\n        except (OSError, IOError) as e:\n            if e.errno in fatal_fs_errors:\n                self.ui_log.error(\"\")\n                self.ui_log.error(\" %s while writing HTML report\"\n                                  % e.strerror)\n                self.ui_log.error(\"\")\n                self._exit(1)\n\n    def _html_report(self):\n        # Generate the header for the html output file\n        rfd = self.get_temp_file()\n        rfd.write(\"\"\"\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n         \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n        <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n        <head>\n            <link rel=\"stylesheet\" type=\"text/css\" media=\"screen\"\n                  href=\"donot.css\" />\n            <meta http-equiv=\"Content-Type\" content=\"text/html;\n                  charset=utf-8\" />\n            <title>Sos System Report</title>\n        </head>\n        <body>\n        \"\"\")\n\n        # Make a pass to gather Alerts and a list of module names\n        allAlerts = deque()\n        plugNames = deque()\n        for plugname, plug in self.loaded_plugins:\n            for alert in plug.alerts:\n                allAlerts.append('<a href=\"#%s\">%s</a>: %s' % (plugname,\n                                                               plugname,\n                                                               alert))\n            plugNames.append(plugname)\n\n        # Create a table of links to the module info\n        rfd.write(\"<hr/><h3>Loaded Plugins:</h3>\")\n        rfd.write(\"<table><tr>\\n\")\n        rr = 0\n        for i in range(len(plugNames)):\n            rfd.write('<td><a href=\"#%s\">%s</a></td>\\n' % (plugNames[i],\n                                                           plugNames[i]))\n            rr = divmod(i, 4)[1]\n            if (rr == 3):\n                rfd.write('</tr>')\n        if not (rr == 3):\n            rfd.write('</tr>')\n        rfd.write('</table>\\n')\n\n        rfd.write('<hr/><h3>Alerts:</h3>')\n        rfd.write('<ul>')\n        for alert in allAlerts:\n            rfd.write('<li>%s</li>' % alert)\n        rfd.write('</ul>')\n\n        # Call the report method for each plugin\n        for plugname, plug in self.loaded_plugins:\n            try:\n                html = plug.report()\n            except:\n                if self.raise_plugins:\n                    raise\n            else:\n                rfd.write(html)\n        rfd.write(\"</body></html>\")\n        rfd.flush()\n        self.archive.add_file(rfd.name, dest=os.path.join('sos_reports',\n                                                          'sos.html'))\n\n    def postproc(self):\n        for plugname, plug in self.loaded_plugins:\n            try:\n                plug.postproc()\n            except (OSError, IOError) as e:\n                if e.errno in fatal_fs_errors:\n                    self.ui_log.error(\"\")\n                    self.ui_log.error(\" %s while post-processing plugin data\"\n                                      % e.strerror)\n                    self.ui_log.error(\"\")\n                    self._exit(1)\n            except:\n                if self.raise_plugins:\n                    raise\n\n    def final_work(self):\n        # this must come before archive creation to ensure that log\n        # files are closed and cleaned up at exit.\n        self._finish_logging()\n        # package up the results for the support organization\n        if not self.opts.build:\n            old_umask = os.umask(0o077)\n            if not self.opts.quiet:\n                print(_(\"Creating compressed archive...\"))\n            # compression could fail for a number of reasons\n            try:\n                final_filename = self.archive.finalize(\n                    self.opts.compression_type)\n            except (OSError, IOError) as e:\n                if e.errno in fatal_fs_errors:\n                    self.ui_log.error(\"\")\n                    self.ui_log.error(\" %s while finalizing archive\"\n                                      % e.strerror)\n                    self.ui_log.error(\"\")\n                    self._exit(1)\n            except:\n                if self.opts.debug:\n                    raise\n                else:\n                    return False\n            finally:\n                os.umask(old_umask)\n        else:\n            final_filename = self.archive.get_archive_path()\n        self.policy.display_results(final_filename, build=self.opts.build)\n        self.tempfile_util.clean()\n        return True\n\n    def verify_plugins(self):\n        if not self.loaded_plugins:\n            self.soslog.error(_(\"no valid plugins were enabled\"))\n            return False\n        return True\n\n    def set_global_plugin_option(self, key, value):\n        self.global_plugin_options[key] = value\n\n    def execute(self):\n        try:\n            self._setup_logging()\n            self.policy.set_commons(self.get_commons())\n            self.print_header()\n            self.load_plugins()\n            self._set_all_options()\n            self._set_tunables()\n            self._check_for_unknown_plugins()\n            self._set_plugin_options()\n\n            if self.opts.list_plugins:\n                self.list_plugins()\n                return True\n            if self.opts.list_profiles:\n                self.list_profiles()\n                return True\n\n            # verify that at least one plug-in is enabled\n            if not self.verify_plugins():\n                return False\n\n            self.batch()\n            self.prework()\n            self.setup()\n            self.collect()\n            if not self.opts.report:\n                self.report()\n                self.html_report()\n                self.plain_report()\n            self.postproc()\n            self.version()\n\n            return self.final_work()\n        except (SystemExit, KeyboardInterrupt):\n            if self.archive:\n                self.archive.cleanup()\n            if self.tempfile_util:\n                self.tempfile_util.clean()\n            return False\n\n\ndef main(args):\n    \"\"\"The main entry point\"\"\"\n    sos = SoSReport(args)\n    sos.execute()\n\n# vim: et ts=4 sw=4\n"], "filenames": ["sos/sosreport.py"], "buggy_code_start_loc": [1329], "buggy_code_end_loc": [1347], "fixing_code_start_loc": [1330], "fixing_code_end_loc": [1351], "type": "CWE-200", "message": "sosreport 3.2 uses weak permissions for generated sosreport archives, which allows local users with access to /var/tmp/ to obtain sensitive information by reading the contents of the archive.", "other": {"cve": {"id": "CVE-2015-3171", "sourceIdentifier": "secalert@redhat.com", "published": "2017-07-25T18:29:00.417", "lastModified": "2019-12-11T20:59:57.143", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "sosreport 3.2 uses weak permissions for generated sosreport archives, which allows local users with access to /var/tmp/ to obtain sensitive information by reading the contents of the archive."}, {"lang": "es", "value": "sosreport versi\u00f3n 3.2, utiliza permisos d\u00e9biles para los archivos de sosreport generados, lo que permite a los usuarios locales con acceso a /var/tmp/ obtener informaci\u00f3n confidencial mediante la lectura del contenido del archivo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sos_project:sos:3.2:-:*:*:*:*:*:*", "matchCriteriaId": "B133A5FC-FC48-413B-82C0-36E646143E54"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1218658", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/sosreport/sos/commit/d7759d3ddae5fe99a340c88a1d370d65cfa73fd6", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sosreport/sos/commit/d7759d3ddae5fe99a340c88a1d370d65cfa73fd6"}}