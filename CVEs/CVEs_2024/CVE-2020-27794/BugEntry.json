{"buggy_code": ["/* radare2 - LGPL - Copyright 2009-2020 - pancake */\n\n#include <r_core.h>\n#include <r_socket.h>\n#include <config.h>\n#include <r_util.h>\n#if __UNIX__\n#include <signal.h>\n#endif\n\n#define DB core->sdb\n\nR_LIB_VERSION(r_core);\n\nstatic ut64 letter_divs[R_CORE_ASMQJMPS_LEN_LETTERS - 1] = {\n\tR_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS,\n\tR_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS,\n\tR_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS,\n\tR_CORE_ASMQJMPS_LETTERS\n};\n\nextern bool r_core_is_project (RCore *core, const char *name);\n\nstatic int on_fcn_new(RAnal *_anal, void* _user, RAnalFunction *fcn) {\n\tRCore *core = (RCore*)_user;\n\tconst char *cmd = r_config_get (core->config, \"cmd.fcn.new\");\n\tif (cmd && *cmd) {\n\t\tut64 oaddr = core->offset;\n\t\tut64 addr = fcn->addr;\n\t\tr_core_seek (core, addr, 1);\n\t\tr_core_cmd0 (core, cmd);\n\t\tr_core_seek (core, oaddr, 1);\n\t}\n\treturn 0;\n}\n\nstatic int on_fcn_delete (RAnal *_anal, void* _user, RAnalFunction *fcn) {\n\tRCore *core = (RCore*)_user;\n\tconst char *cmd = r_config_get (core->config, \"cmd.fcn.delete\");\n\tif (cmd && *cmd) {\n\t\tut64 oaddr = core->offset;\n\t\tut64 addr = fcn->addr;\n\t\tr_core_seek (core, addr, 1);\n\t\tr_core_cmd0 (core, cmd);\n\t\tr_core_seek (core, oaddr, 1);\n\t}\n\treturn 0;\n}\n\nstatic int on_fcn_rename(RAnal *_anal, void* _user, RAnalFunction *fcn, const char *oname) {\n\tRCore *core = (RCore*)_user;\n\tconst char *cmd = r_config_get (core->config, \"cmd.fcn.rename\");\n\tif (cmd && *cmd) {\n\t\t// XXX: wat do with old name here?\n\t\tut64 oaddr = core->offset;\n\t\tut64 addr = fcn->addr;\n\t\tr_core_seek (core, addr, 1);\n\t\tr_core_cmd0 (core, cmd);\n\t\tr_core_seek (core, oaddr, 1);\n\t}\n\treturn 0;\n}\n\nstatic void r_core_debug_breakpoint_hit(RCore *core, RBreakpointItem *bpi) {\n\tconst char *cmdbp = r_config_get (core->config, \"cmd.bp\");\n\tconst bool cmdbp_exists = (cmdbp && *cmdbp);\n\tconst bool bpcmd_exists = (bpi->data && bpi->data[0]);\n\tconst bool may_output = (cmdbp_exists || bpcmd_exists);\n\tif (may_output) {\n\t\tr_cons_push ();\n\t}\n\tif (cmdbp_exists) {\n\t\tr_core_cmd0 (core, cmdbp);\n\t}\n\tif (bpcmd_exists) {\n\t\tr_core_cmd0 (core, bpi->data);\n\t}\n\tif (may_output) {\n\t\tr_cons_flush ();\n\t\tr_cons_pop ();\n\t}\n}\n\nstatic void r_core_debug_syscall_hit(RCore *core) {\n\tconst char *cmdhit = r_config_get (core->config, \"cmd.onsyscall\");\n\n\tif (cmdhit && cmdhit[0] != 0) {\n\t\tr_core_cmd0 (core, cmdhit);\n\t\tr_cons_flush ();\n\t}\n}\n\nstruct getreloc_t {\n        ut64 vaddr;\n        int size;\n};\n\nstatic int getreloc_tree(const void *user, const RBNode *n, void *user2) {\n        struct getreloc_t *gr = (struct getreloc_t *)user;\n        const RBinReloc *r = container_of (n, const RBinReloc, vrb);\n        if ((r->vaddr >= gr->vaddr) && (r->vaddr < (gr->vaddr + gr->size))) {\n                return 0;\n        }\n\n        if (gr->vaddr > r->vaddr) {\n                return 1;\n        }\n        if (gr->vaddr < r->vaddr) {\n                return -1;\n        }\n        return 0;\n}\n\n// TODO: Use sdb in rbin to accelerate this\n// we shuold use aligned reloc addresses instead of iterating all of them\nR_API RBinReloc *r_core_getreloc(RCore *core, ut64 addr, int size) {\n        if (size < 1 || addr == UT64_MAX) {\n                return NULL;\n        }\n        RBNode *relocs = r_bin_get_relocs (core->bin);\n        if (!relocs) {\n                return NULL;\n        }\n        struct getreloc_t gr = { .vaddr = addr, .size = size };\n        RBNode *res = r_rbtree_find (relocs, &gr, getreloc_tree, NULL);\n        return res? container_of (res, RBinReloc, vrb): NULL;\n}\n\n/* returns the address of a jmp/call given a shortcut by the user or UT64_MAX\n * if there's no valid shortcut. When is_asmqjmps_letter is true, the string\n * should be of the form XYZWu, where XYZW are uppercase letters and u is a\n * lowercase one. If is_asmqjmps_letter is false, the string should be a number\n * between 1 and 9 included. */\nR_API ut64 r_core_get_asmqjmps(RCore *core, const char *str) {\n\tif (!core->asmqjmps) {\n\t\treturn UT64_MAX;\n\t}\n\tif (core->is_asmqjmps_letter) {\n\t\tint i, pos = 0;\n\t\tint len = strlen (str);\n\t\tfor (i = 0; i < len - 1; i++) {\n\t\t\tif (!isupper ((ut8)str[i])) {\n\t\t\t\treturn UT64_MAX;\n\t\t\t}\n\t\t\tpos *= R_CORE_ASMQJMPS_LETTERS;\n\t\t\tpos += str[i] - 'A' + 1;\n\t\t}\n\t\tif (!islower ((ut8)str[i])) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tpos *= R_CORE_ASMQJMPS_LETTERS;\n\t\tpos += str[i] - 'a';\n\t\tif (pos < core->asmqjmps_count) {\n\t\t\treturn core->asmqjmps[pos + 1];\n\t\t}\n\t} else if (str[0] > '0' && str[1] <= '9') {\n\t\tint pos = str[0] - '0';\n\t\tif (pos <= core->asmqjmps_count) {\n\t\t\treturn core->asmqjmps[pos];\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\n/**\n * Takes addr and returns already saved shortcut or a new one\n * The returned buffer needs to be freed\n */\nR_API char* r_core_add_asmqjmp(RCore *core, ut64 addr) {\n\tbool found = false;\n\tif (!core->asmqjmps) {\n\t\treturn NULL;\n\t}\n\tif (core->is_asmqjmps_letter) {\n\t\tif (core->asmqjmps_count >= R_CORE_ASMQJMPS_MAX_LETTERS) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (core->asmqjmps_count >= core->asmqjmps_size - 2) {\n\t\t\tcore->asmqjmps = realloc (core->asmqjmps, core->asmqjmps_size * 2 * sizeof (ut64));\n\t\t\tif (!core->asmqjmps) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcore->asmqjmps_size *= 2;\n\t\t}\n\t}\n\tif (core->asmqjmps_count < core->asmqjmps_size - 1) {\n\t\tint i = 0;\n\t\tchar t[R_CORE_ASMQJMPS_LEN_LETTERS + 1] = {0};\n\t\tfor (i = 0; i < core->asmqjmps_count + 1; i++) {\n\t\t\tif (core->asmqjmps[i] == addr) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\ti = ++core->asmqjmps_count;\n\t\t\tcore->asmqjmps[i] = addr;\n\t\t}\n\t\t// This check makes pos never be <1, thefor not fill 't' with trash\n\t\tif (i < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_core_set_asmqjmps (core, t, sizeof (t), i);\n\t\treturn strdup (t);\n\t}\n\treturn NULL;\n}\n\n/* returns in str a string that represents the shortcut to access the asmqjmp\n * at position pos. When is_asmqjmps_letter is true, pos is converted into a\n * multiletter shortcut of the form XYWZu and returned (see r_core_get_asmqjmps\n * for more info). Otherwise, the shortcut is the string representation of pos. */\nR_API void r_core_set_asmqjmps(RCore *core, char *str, size_t len, int pos) {\n\tif (core->is_asmqjmps_letter) {\n\t\tint i, j = 0;\n\t\t// if (pos > 0) {\n\t\t\tpos --;\n\t\t////  }\n\t\tfor (i = 0; i < R_CORE_ASMQJMPS_LEN_LETTERS - 1; i++) {\n\t\t\tint div = pos / letter_divs[i];\n\t\t\tpos %= letter_divs[i];\n\t\t\tif (div > 0 && j < len) {\n\t\t\t\tstr[j++] = 'A' + div - 1;\n\t\t\t}\n\t\t}\n\t\tif (j < len) {\n\t\t\tint div = pos % R_CORE_ASMQJMPS_LETTERS;\n\t\t\tstr[j++] = 'a' + div;\n\t\t}\n\t\tstr[j] = '\\0';\n\t} else {\n\t\tsnprintf (str, len, \"%d\", pos);\n\t}\n}\n\nstatic void setab(RCore *core, const char *arch, int bits) {\n\tif (arch) {\n\t\tr_config_set (core->config, \"asm.arch\", arch);\n\t}\n\tif (bits > 0) {\n\t\tr_config_set_i (core->config, \"asm.bits\", bits);\n\t}\n}\n\nstatic const char *getName(RCore *core, ut64 addr) {\n\tRFlagItem *item = r_flag_get_i (core->flags, addr);\n\tif (item) {\n\t\tif (core->flags->realnames) {\n\t\t\treturn item->realname\n\t\t\t\t? item->realname: item->name;\n\t\t}\n\t\treturn item->name;\n\t}\n\treturn NULL;\n}\n\nstatic char *getNameDelta(RCore *core, ut64 addr) {\n\tRFlagItem *item = r_flag_get_at (core->flags, addr, true);\n\tif (item) {\n\t\tif (item->offset != addr) {\n\t\t\treturn r_str_newf (\"%s + %d\", item->name, (int)(addr - item->offset));\n\t\t}\n\t\treturn strdup (item->name);\n\t}\n\treturn NULL;\n}\n\nstatic void archbits(RCore *core, ut64 addr) {\n\tr_core_seek_arch_bits (core, addr);\n}\n\nstatic int cfggeti(RCore *core, const char *k) {\n\treturn r_config_get_i (core->config, k);\n}\n\nstatic const char *cfgget(RCore *core, const char *k) {\n\treturn r_config_get (core->config, k);\n}\n\nstatic ut64 numget(RCore *core, const char *k) {\n\treturn r_num_math (core->num, k);\n}\n\nstatic bool __isMapped(RCore *core, ut64 addr, int perm) {\n\tif (r_config_get_i (core->config, \"cfg.debug\")) {\n\t\t// RList *maps = core->dbg->maps;\n\t\tRDebugMap *map = NULL;\n\t\tRListIter *iter = NULL;\n\n\t\tr_list_foreach (core->dbg->maps, iter, map) {\n\t\t\tif (addr >= map->addr && addr < map->addr_end) {\n\t\t\t\tif (perm > 0) {\n\t\t\t\t\tif (map->perm & perm) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn r_io_map_is_mapped (core->io, addr);\n}\n\nstatic bool __syncDebugMaps(RCore *core) {\n\tif (r_config_get_i (core->config, \"cfg.debug\")) {\n\t\treturn r_debug_map_sync (core->dbg);\n\t}\n\treturn false;\n}\n\nR_API int r_core_bind(RCore *core, RCoreBind *bnd) {\n\tbnd->core = core;\n\tbnd->bphit = (RCoreDebugBpHit)r_core_debug_breakpoint_hit;\n\tbnd->syshit = (RCoreDebugSyscallHit)r_core_debug_syscall_hit;\n\tbnd->cmd = (RCoreCmd)r_core_cmd0;\n\tbnd->cmdf = (RCoreCmdF)r_core_cmdf;\n\tbnd->cmdstr = (RCoreCmdStr)r_core_cmd_str;\n\tbnd->cmdstrf = (RCoreCmdStrF)r_core_cmd_strf;\n\tbnd->puts = (RCorePuts)r_cons_strcat;\n\tbnd->setab = (RCoreSetArchBits)setab;\n\tbnd->getName = (RCoreGetName)getName;\n\tbnd->getNameDelta = (RCoreGetNameDelta)getNameDelta;\n\tbnd->archbits = (RCoreSeekArchBits)archbits;\n\tbnd->cfggeti = (RCoreConfigGetI)cfggeti;\n\tbnd->cfgGet = (RCoreConfigGet)cfgget;\n\tbnd->numGet = (RCoreNumGet)numget;\n\tbnd->isMapped = (RCoreIsMapped)__isMapped;\n\tbnd->syncDebugMaps = (RCoreDebugMapsSync)__syncDebugMaps;\n\treturn true;\n}\n\nR_API RCore *r_core_ncast(ut64 p) {\n\treturn (RCore*)(size_t)p;\n}\n\nR_API RCore *r_core_cast(void *p) {\n\treturn (RCore*)p;\n}\n\nstatic void core_post_write_callback(void *user, ut64 maddr, ut8 *bytes, int cnt) {\n\tRCore *core = (RCore *)user;\n\tRBinSection *sec;\n\tut64 vaddr;\n\n\tif (!r_config_get_i (core->config, \"asm.cmt.patch\")) {\n\t\treturn;\n\t}\n\n\tchar *hex_pairs = r_hex_bin2strdup (bytes, cnt);\n\tif (!hex_pairs) {\n\t\teprintf (\"core_post_write_callback: Cannot obtain hex pairs\\n\");\n\t\treturn;\n\t}\n\n\tchar *comment = r_str_newf (\"patch: %d byte(s) (%s)\", cnt, hex_pairs);\n\tfree (hex_pairs);\n\tif (!comment) {\n\t\teprintf (\"core_post_write_callback: Cannot create comment\\n\");\n\t\treturn;\n\t}\n\n\tif ((sec = r_bin_get_section_at (r_bin_cur_object (core->bin), maddr, false))) {\n\t\tvaddr = maddr + sec->vaddr - sec->paddr;\n\t} else {\n\t\tvaddr = maddr;\n\t}\n\n\tr_meta_add (core->anal, R_META_TYPE_COMMENT, vaddr, vaddr, comment);\n\tfree (comment);\n}\n\nstatic int core_cmd_callback (void *user, const char *cmd) {\n    RCore *core = (RCore *)user;\n    return r_core_cmd0 (core, cmd);\n}\n\nstatic char *core_cmdstr_callback (void *user, const char *cmd) {\n\tRCore *core = (RCore *)user;\n\treturn r_core_cmd_str (core, cmd);\n}\n\nstatic ut64 getref (RCore *core, int n, char t, int type) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\tRListIter *iter;\n\tRAnalRef *r;\n\tRList *list;\n\tint i = 0;\n\tif (!fcn) {\n\t\treturn UT64_MAX;\n\t}\n#if FCN_OLD\n\tif (t == 'r') {\n\t\tlist = r_anal_function_get_refs (fcn);\n\t} else {\n\t\tlist = r_anal_function_get_xrefs (fcn);\n\t}\n\tr_list_foreach (list, iter, r) {\n\t\tif (r->type == type) {\n\t\t\tif (i == n) {\n\t\t\t\tut64 addr = r->addr;\n\t\t\t\tr_list_free (list);\n\t\t\t\treturn addr;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tr_list_free (list);\n#else\n#warning implement getref() using sdb\n#endif\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbInstructions(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->ninstr;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbBegin(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->addr;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbJump(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->jump;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbFail(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->fail;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbSize(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->size;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const char *str_callback(RNum *user, ut64 off, int *ok) {\n\tRFlag *f = (RFlag*)user;\n\tif (ok) {\n\t\t*ok = 0;\n\t}\n\tif (f) {\n\t\tRFlagItem *item = r_flag_get_i (f, off);\n\t\tif (item) {\n\t\t\tif (ok) {\n\t\t\t\t*ok = true;\n\t\t\t}\n\t\t\treturn item->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut64 num_callback(RNum *userptr, const char *str, int *ok) {\n\tRCore *core = (RCore *)userptr; // XXX ?\n\tRAnalFunction *fcn;\n\tchar *ptr, *bptr, *out = NULL;\n\tRFlagItem *flag;\n\tRBinSection *s;\n\tRAnalOp op;\n\tut64 ret = 0;\n\n\tif (ok) {\n\t\t*ok = false;\n\t}\n\tswitch (*str) {\n\tcase '.':\n\t\tif (str[1] == '.') {\n\t\t\tif (ok) {\n\t\t\t\t*ok = true;\n\t\t\t}\n\t\t\treturn r_num_tail (core->num, core->offset, str + 2);\n\t\t}\n\t\tif (core->num->nc.curr_tok == '+') {\n\t\t\tut64 off = core->num->nc.number_value.n;\n\t\t\tif (!off) {\n\t\t\t\toff = core->offset;\n\t\t\t}\n\t\t\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, off);\n\t\t\tif (fcn) {\n\t\t\t\tif (ok) {\n\t\t\t\t\t*ok = true;\n\t\t\t\t}\n\t\t\t\tut64 dst = r_anal_fcn_label_get (core->anal, fcn, str + 1);\n\t\t\t\tif (dst == UT64_MAX) {\n\t\t\t\t\tdst = fcn->addr;\n\t\t\t\t}\n\t\t\t\tst64 delta = dst - off;\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\tcore->num->nc.curr_tok = '-';\n\t\t\t\t\tdelta = off - dst;\n\t\t\t\t}\n\t\t\t\treturn delta;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '[':\n{\n\t\tut64 n = 0LL;\n\t\tint refsz = core->assembler->bits / 8;\n\t\tconst char *p = NULL;\n\t\tif (strlen (str) > 5) {\n\t\t\tp = strchr (str + 5, ':');\n\t\t}\n\t\tif (p) {\n\t\t\trefsz = atoi (str + 1);\n\t\t\tstr = p;\n\t\t}\n\t\t// push state\n\t\tif (str[0] && str[1]) {\n\t\t\tconst char *q;\n\t\t\tchar *o = strdup (str + 1);\n\t\t\tif (o) {\n\t\t\t\tq = r_num_calc_index (core->num, NULL);\n\t\t\t\tif (q) {\n\t\t\t\t\tif (r_str_replace_char (o, ']', 0)>0) {\n\t\t\t\t\t\tn = r_num_math (core->num, o);\n\t\t\t\t\t\tif (core->num->nc.errors) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_num_calc_index (core->num, q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (o);\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// pop state\n\t\tif (ok) {\n\t\t\t*ok = 1;\n\t\t}\n\t\tut8 buf[sizeof (ut64)] = R_EMPTY;\n\t\t(void)r_io_read_at (core->io, n, buf, R_MIN (sizeof (buf), refsz));\n\t\tswitch (refsz) {\n\t\tcase 8:\n\t\t\treturn r_read_ble64 (buf, core->print->big_endian);\n\t\tcase 4:\n\t\t\treturn r_read_ble32 (buf, core->print->big_endian);\n\t\tcase 2:\n\t\t\treturn r_read_ble16 (buf, core->print->big_endian);\n\t\tcase 1:\n\t\t\treturn r_read_ble8 (buf);\n\t\tdefault:\n\t\t\teprintf (\"Invalid reference size: %d (%s)\\n\", refsz, str);\n\t\t\treturn 0LL;\n\t\t}\n}\n\t\tbreak;\n\tcase '$':\n\t\tif (ok) {\n\t\t\t*ok = 1;\n\t\t}\n\t\t// TODO: group analop-dependant vars after a char, so i can filter\n\t\tr_anal_op (core->anal, &op, core->offset, core->block, core->blocksize, R_ANAL_OP_MASK_BASIC);\n\t\tr_anal_op_fini (&op); // we don't need strings or pointers, just values, which are not nullified in fini\n\t\tswitch (str[1]) {\n\t\tcase '.': // can use pc, sp, a0, a1, ...\n\t\t\treturn r_debug_reg_get (core->dbg, str + 2);\n\t\tcase 'k': // $k{kv}\n\t\t\tif (str[2] != '{') {\n\t\t\t\teprintf (\"Expected '{' after 'k'.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbptr = strdup (str + 3);\n\t\t\tptr = strchr (bptr, '}');\n\t\t\tif (!ptr) {\n\t\t\t\t// invalid json\n\t\t\t\tfree (bptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr = '\\0';\n\t\t\tret = 0LL;\n\t\t\tout = sdb_querys (core->sdb, NULL, 0, bptr);\n\t\t\tif (out && *out) {\n\t\t\t\tif (strstr (out, \"$k{\")) {\n\t\t\t\t\teprintf (\"Recursivity is not permitted here\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tret = r_num_math (core->num, out);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (bptr);\n\t\t\tfree (out);\n\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase '{': // ${ev} eval var\n\t\t\tbptr = strdup (str + 2);\n\t\t\tptr = strchr (bptr, '}');\n\t\t\tif (ptr) {\n\t\t\t\tptr[0] = '\\0';\n\t\t\t\tut64 ret = r_config_get_i (core->config, bptr);\n\t\t\t\tfree (bptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t// take flag here\n\t\t\tfree (bptr);\n\t\t\tbreak;\n\t\tcase 'c': // $c console width\n\t\t\treturn r_cons_get_size (NULL);\n\t\tcase 'r': // $r\n\t\t\tif (str[2] == '{') {\n\t\t\t\tbptr = strdup (str + 3);\n\t\t\t\tptr = strchr (bptr, '}');\n\t\t\t\tif (!ptr) {\n\t\t\t\t\tfree (bptr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*ptr = 0;\n\t\t\t\tif (r_config_get_i (core->config, \"cfg.debug\")) {\n\t\t\t\t\tif (r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false)) {\n\t\t\t\t\t\tRRegItem *r = r_reg_get (core->dbg->reg, bptr, -1);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\tfree (bptr);\n\t\t\t\t\t\t\treturn r_reg_get_value (core->dbg->reg, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRRegItem *r = r_reg_get (core->anal->reg, bptr, -1);\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tfree (bptr);\n\t\t\t\t\t\treturn r_reg_get_value (core->anal->reg, r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (bptr);\n\t\t\t\treturn 0; // UT64_MAX;\n\t\t\t} else {\n\t\t\t\tint rows;\n\t\t\t\t(void)r_cons_get_size (&rows);\n\t\t\t\treturn rows;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'e': // $e\n\t\t\tif (str[2] == '{') { // $e{flag} flag off + size\n\t\t\t\tchar *flagName = strdup (str + 3);\n\t\t\t\tint flagLength = strlen (flagName);\n\t\t\t\tif (flagLength > 0) {\n\t\t\t\t\tflagName[flagLength - 1] = 0;\n\t\t\t\t}\n\t\t\t\tRFlagItem *flag = r_flag_get (core->flags, flagName);\n\t\t\t\tfree (flagName);\n\t\t\t\tif (flag) {\n\t\t\t\t\treturn flag->offset + flag->size;\n\t\t\t\t}\n\t\t\t\treturn UT64_MAX;\n\t\t\t}\n\t\t\treturn r_anal_op_is_eob (&op);\n\t\tcase 'j': // $j jump address\n\t\t\treturn op.jump;\n\t\tcase 'p': // $p\n\t\t\treturn r_sys_getpid ();\n\t\tcase 'P': // $P\n\t\t\treturn core->dbg->pid > 0 ? core->dbg->pid : 0;\n\t\tcase 'f': // $f jump fail address\n\t\t\tif (str[2] == 'l') { // $fl flag length\n\t\t\t\tRFlagItem *fi = r_flag_get_i (core->flags, core->offset);\n\t\t\t\tif (fi) {\n\t\t\t\t\treturn fi->size;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn op.fail;\n\t\tcase 'm': // $m memref\n\t\t\treturn op.ptr;\n\t\tcase 'B': // $B base address\n\t\tcase 'M': { // $M map address\n\t\t\t\tut64 lower = UT64_MAX;\n\t\t\t\tut64 size = 0LL;\n\t\t\t\tRIOMap *map = r_io_map_get (core->io, core->offset);\n\t\t\t\tif (map) {\n\t\t\t\t\tlower = r_itv_begin (map->itv);\n\t\t\t\t\tsize = r_itv_size (map->itv);\n\t\t\t\t}\n\n\t\t\t\tif (str[1] == 'B') {\n\t\t\t\t\t/* clear lower bits of the lowest map address to define the base address */\n\t\t\t\t\tconst int clear_bits = 16;\n\t\t\t\t\tlower >>= clear_bits;\n\t\t\t\t\tlower <<= clear_bits;\n\t\t\t\t}\n\t\t\t\tif (str[2] == 'M') {\n\t\t\t\t\treturn size;\n\t\t\t\t}\n\t\t\t\treturn (lower == UT64_MAX)? 0LL: lower;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v': // $v immediate value\n\t\t\treturn op.val;\n\t\tcase 'l': // $l opcode length\n\t\t\treturn op.size;\n\t\tcase 'b': // $b\n\t\t\treturn core->blocksize;\n\t\tcase 's': // $s file size\n\t\t\tif (str[2] == '{') { // $s{flag} flag size\n\t\t\t\tbptr = strdup (str + 3);\n\t\t\t\tptr = strchr (bptr, '}');\n\t\t\t\tif (!ptr) {\n\t\t\t\t\t// invalid json\n\t\t\t\t\tfree (bptr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tRFlagItem *flag = r_flag_get (core->flags, bptr);\n\t\t\t\tret = flag? flag->size: 0LL; // flag\n\t\t\t\tfree (bptr);\n\t\t\t\tfree (out);\n\t\t\t\treturn ret;\n\t\t\t} else if (core->file) {\n\t\t\t\treturn r_io_fd_size (core->io, core->file->fd);\n\t\t\t}\n\t\t\treturn 0LL;\n\t\tcase 'w': // $w word size\n\t\t\treturn r_config_get_i (core->config, \"asm.bits\") / 8;\n\t\tcase 'S': // $S section offset\n\t\t\t{\n\t\t\t\tRBinObject *bo = r_bin_cur_object (core->bin);\n\t\t\t\tif (bo && (s = r_bin_get_section_at (bo, core->offset, true))) {\n\t\t\t\t\treturn (str[2] == 'S'? s->size: s->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0LL;\n\t\tcase 'D': // $D\n\t\t\tif (str[2] == 'B') { // $DD\n\t\t\t\treturn r_debug_get_baddr (core->dbg, NULL);\n\t\t\t} else if (IS_DIGIT (str[2])) {\n\t\t\t\treturn getref (core, atoi (str + 2), 'r', R_ANAL_REF_TYPE_DATA);\n\t\t\t} else {\n\t\t\t\tRDebugMap *map;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (core->dbg->maps, iter, map) {\n\t\t\t\t\tif (core->offset >= map->addr && core->offset < map->addr_end) {\n\t\t\t\t\t\treturn (str[2] == 'D')? map->size: map->addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0LL; // maybe // return UT64_MAX;\n\t\tcase '?': // $?\n\t\t\treturn core->num->value; // rc;\n\t\tcase '$': // $$ offset\n\t\t\treturn str[2] == '$' ? core->prompt_offset : core->offset;\n\t\tcase 'o': { // $o\n\t\t\tRBinSection *s = r_bin_get_section_at (r_bin_cur_object (core->bin), core->offset, true);\n\t\t\treturn s ? core->offset - s->vaddr + s->paddr : core->offset;\n\t\t\tbreak;\n\t\t}\n\t\tcase 'O': // $O\n\t\t\t  if (core->print->cur_enabled) {\n\t\t\t\t  return core->offset + core->print->cur;\n\t\t\t  }\n\t\t\t  return core->offset;\n\t\tcase 'C': // $C nth call\n\t\t\treturn getref (core, atoi (str + 2), 'r', R_ANAL_REF_TYPE_CALL);\n\t\tcase 'J': // $J nth jump\n\t\t\treturn getref (core, atoi (str + 2), 'r', R_ANAL_REF_TYPE_CODE);\n\t\tcase 'X': // $X nth xref\n\t\t\treturn getref (core, atoi (str + 2), 'x', R_ANAL_REF_TYPE_CALL);\n\t\tcase 'F': // $F function size\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tif (fcn) {\n\t\t\t\tswitch (str[2]) {\n\t\t\t\t/* function bounds (uppercase) */\n\t\t\t\tcase 'B': return fcn->addr; // begin\n\t\t\t\tcase 'E': return r_anal_function_max_addr (fcn); // end\n\t\t\t\tcase 'S': return (str[3]=='S') ? r_anal_function_realsize (fcn) : r_anal_function_linear_size (fcn);\n\t\t\t\tcase 'I': return fcn->ninstr;\n\t\t\t\t/* basic blocks (lowercase) */\n\t\t\t\tcase 'b': return bbBegin (fcn, core->offset);\n\t\t\t\tcase 'e': return bbBegin (fcn, core->offset) + bbSize (fcn, core->offset);\n\t\t\t\tcase 'i': return bbInstructions (fcn, core->offset);\n\t\t\t\tcase 's': return bbSize (fcn, core->offset);\n\t\t\t\tcase 'j': return bbJump (fcn, core->offset); // jump\n\t\t\t\tcase 'f': return bbFail (fcn, core->offset); // fail\n\t\t\t\t}\n\t\t\t\treturn fcn->addr;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (*str >= 'A') {\n\t\t\t// NOTE: functions override flags\n\t\t\tRAnalFunction *fcn = r_anal_get_function_byname (core->anal, str);\n\t\t\tif (fcn) {\n\t\t\t\tif (ok) {\n\t\t\t\t\t*ok = true;\n\t\t\t\t}\n\t\t\t\treturn fcn->addr;\n\t\t\t}\n#if 0\n\t\t\tut64 addr = r_anal_fcn_label_get (core->anal, core->offset, str);\n\t\t\tif (addr != 0) {\n\t\t\t\tret = addr;\n\t\t\t} else {\n\t\t\t\t...\n\t\t\t}\n#endif\n\t\t\tif ((flag = r_flag_get (core->flags, str))) {\n\t\t\t\tret = flag->offset;\n\t\t\t\tif (ok) {\n\t\t\t\t\t*ok = true;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// check for reg alias\n\t\t\tstruct r_reg_item_t *r = r_reg_get (core->dbg->reg, str, -1);\n\t\t\tif (!r) {\n\t\t\t\tint role = r_reg_get_name_idx (str);\n\t\t\t\tif (role != -1) {\n\t\t\t\t\tconst char *alias = r_reg_get_name (core->dbg->reg, role);\n\t\t\t\t\tif (alias) {\n\t\t\t\t\t\tr = r_reg_get (core->dbg->reg, alias, -1);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\t\t*ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = r_reg_get_value (core->dbg->reg, r);\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ok) {\n\t\t\t\t\t*ok = true;\n\t\t\t\t}\n\t\t\t\tret = r_reg_get_value (core->dbg->reg, r);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nR_API RCore *r_core_new() {\n\tRCore *c = R_NEW0 (RCore);\n\tif (c) {\n\t\tr_core_init (c);\n\t}\n\treturn c;\n}\n\n/*-----------------------------------*/\n#define radare_argc (sizeof (radare_argv) / sizeof(const char*) - 1)\n#define ms_argc (sizeof (ms_argv) / sizeof (const char*) - 1)\nstatic const char *ms_argv[] = {\n\t\"?\", \"!\", \"ls\", \"cd\", \"cat\", \"get\", \"mount\", \"help\", \"q\", \"exit\", NULL\n};\n\nstatic const char *radare_argv[] = {\n\t\"whereis\", \"which\", \"ls\", \"rm\", \"mkdir\", \"pwd\", \"cat\", \"sort\", \"uniq\", \"join\", \"less\", \"exit\", \"quit\",\n\t\"#?\", \"#!\", \"#sha1\", \"#crc32\", \"#pcprint\", \"#sha256\", \"#sha512\", \"#md4\", \"#md5\",\n\t\"#!python\", \"#!vala\", \"#!pipe\",\n\t\"*?\", \"*\", \"$\",\n\t\"(\", \"(*\", \"(-\", \"()\", \".?\", \".\", \"..\", \"...\", \".:\", \".--\", \".-\", \".!\", \".(\", \"./\", \".*\",\n\t\"_?\", \"_\",\n\t\"=?\", \"=\", \"=<\", \"=!\", \"=+\", \"=-\", \"==\", \"=!=\", \"!=!\", \"=:\", \"=&:\",\n\t\"=g?\", \"=g\", \"=g!\", \"=h?\", \"=h\", \"=h-\", \"=h--\", \"=h*\", \"=h&\", \"=H?\", \"=H\", \"=H&\",\n\t\"<\",\n\t\"/?\", \"/\", \"/j\", \"/j!\", \"/j!x\", \"/+\", \"//\", \"/a\", \"/a1\", \"/ab\", \"/ad\", \"/aa\", \"/as\", \"/asl\", \"/at\", \"/atl\", \"/af\", \"/afl\", \"/ae\", \"/aej\", \"/ai\", \"/aij\",\n\t\"/c\", \"/ca\", \"/car\", \"/d\", \"/e\", \"/E\", \"/f\", \"/F\", \"/g\", \"/gg\", \"/h\", \"/ht\", \"/i\", \"/m\", \"/mb\", \"/mm\",\n\t\"/o\", \"/O\", \"/p\", \"/P\", \"/s\", \"/s*\", \"/r?\", \"/r\", \"/ra\", \"/rc\", \"/re\", \"/rr\", \"/rw\", \"/rc\",\n\t\"/R\",\n\t\"/v?\", \"/v\", \"/v1\", \"/v2\", \"/v4\", \"/v8\",\n\t\"/V?\", \"/V\", \"/V1\", \"/V2\", \"/V4\", \"/V8\",\n\t\"/w\", \"/wi\", \"/x\", \"/z\",\n\t\"!?\", \"!\", \"!!\", \"!!!\", \"!!!-\", \"!-\", \"!-*\", \"!=!\",\n\t\"a?\", \"a\", \"aa\", \"aa*\",\n\t\"aaa\", \"aab\", \"aac\", \"aac*\", \"aad\", \"aae\", \"aaf\", \"aaF\", \"aaFa\", \"aai\", \"aaij\", \"aan\", \"aang\", \"aao\", \"aap\",\n\t\"aar?\", \"aar\", \"aar*\", \"aarj\", \"aas\", \"aat\", \"aaT\", \"aau\", \"aav\",\n\t\"a8\", \"ab\", \"abb\",\n\t\"acl\", \"acll\", \"aclj\", \"acl*\", \"ac?\", \"ac\", \"ac-\", \"acn\", \"acv\", \"acvf\", \"acv-\", \"acb\", \"acb-\", \"acm\", \"acm-\", \"acmn\",\n\t\"aC?\", \"aC\", \"aCe\", \"ad\", \"ad4\", \"ad8\", \"adf\", \"adfg\", \"adt\", \"adk\",\n\t\"ae?\", \"ae??\", \"ae\", \"aea\", \"aeA\", \"aeaf\", \"aeAf\", \"aeC\", \"aec?\", \"aec\", \"aecs\", \"aecc\", \"aecu\", \"aecue\",\n\t\"aef\", \"aefa\",\n\t\"aei\", \"aeim\", \"aeip\", \"aek\", \"aek-\", \"aeli\", \"aelir\", \"aep?\", \"aep\", \"aep-\", \"aepc\",\n\t\"aer\", \"aets?\", \"aets\", \"aets+\", \"aes\", \"aesp\", \"aesb\", \"aeso\", \"aesou\", \"aess\", \"aesu\", \"aesue\", \"aetr\", \"aex\",\n\t\"af?\", \"af\", \"afr\", \"af+\", \"af-\",\n\t\"afa\", \"afan\",\n\t\"afb?\", \"afb\", \"afb.\", \"afb+\", \"afbb\", \"afbr\", \"afbi\", \"afbj\", \"afbe\", \"afB\", \"afbc\", \"afb=\",\n\t\"afB\", \"afC\", \"afCl\", \"afCc\", \"afc?\", \"afc\", \"afc=\", \"afcr\", \"afcrj\", \"afca\", \"afcf\", \"afcfj\",\n\t\"afck\", \"afcl\", \"afco\", \"afcR\",\n\t\"afd\", \"aff\", \"afF\", \"afi\",\n\t\"afl?\", \"afl\", \"afl+\", \"aflc\", \"aflj\", \"afll\", \"afllj\", \"aflm\", \"aflq\", \"aflqj\", \"afls\",\n\t\"afm\", \"afM\", \"afn?\", \"afna\", \"afns\", \"afnsj\", \"afl=\",\n\t\"afo\", \"afs\", \"afS\", \"aft?\", \"aft\", \"afu\",\n\t\"afv?\", \"afv\", \"afvr?\", \"afvr\", \"afvr*\", \"afvrj\", \"afvr-\", \"afvrg\", \"afvrs\",\n\t\"afvb?\", \"afvb\", \"afvbj\", \"afvb-\", \"afvbg\", \"afvbs\",\n\t\"afvs?\", \"afvs\", \"afvs*\", \"afvsj\", \"afvs-\", \"afvsg\", \"afvss\",\n\t\"afv*\", \"afvR\", \"afvW\", \"afva\", \"afvd\", \"afvn\", \"afvt\", \"afv-\", \"af*\", \"afx\",\n\t\"aF\",\n\t\"ag?\", \"ag\", \"aga\", \"agA\", \"agc\", \"agC\", \"agd\", \"agf\", \"agi\", \"agr\", \"agR\", \"agx\", \"agg\", \"ag-\",\n\t\"agn?\", \"agn\", \"agn-\", \"age?\", \"age\", \"age-\",\n\t\"agl\", \"agfl\",\n\t\"ah?\", \"ah\", \"ah.\", \"ah-\", \"ah*\", \"aha\", \"ahb\", \"ahc\", \"ahe\", \"ahf\", \"ahh\", \"ahi?\", \"ahi\", \"ahj\", \"aho\",\n\t\"ahp\", \"ahr\", \"ahs\", \"ahS\", \"aht\",\n\t\"ai\", \"aL\", \"an\",\n\t\"ao?\", \"ao\", \"aoj\", \"aoe\", \"aor\", \"aos\", \"aom\", \"aod\", \"aoda\", \"aoc\", \"ao*\",\n\t\"aO\", \"ap\",\n\t\"ar?\", \"ar\", \"ar0\", \"ara?\", \"ara\", \"ara+\", \"ara-\", \"aras\", \"arA\", \"arC\", \"arr\", \"arrj\", \"ar=\",\n\t\"arb\", \"arc\", \"ard\", \"arn\", \"aro\", \"arp?\", \"arp\", \"arpi\", \"arp.\", \"arpj\", \"arps\",\n\t\"ars\", \"art\", \"arw\",\n\t\"as?\", \"as\", \"asc\", \"asca\", \"asf\", \"asj\", \"asl\", \"ask\",\n\t\"av?\", \"av\", \"avj\", \"av*\", \"avr\", \"avra\", \"avraj\", \"avrr\", \"avrD\",\n\t\"at\",\n\t\"ax?\", \"ax\", \"ax*\", \"ax-\", \"ax-*\", \"axc\", \"axC\", \"axg\", \"axg*\", \"axgj\", \"axd\", \"axw\", \"axj\", \"axF\",\n\t\"axt\", \"axf\", \"ax.\", \"axff\", \"axffj\", \"axs\",\n\t\"b?\", \"b\", \"b+\", \"b-\", \"bf\", \"bm\",\n\t\"c?\", \"c\", \"c1\", \"c2\", \"c4\", \"c8\", \"cc\", \"ccd\", \"cf\", \"cg?\", \"cg\", \"cgf\", \"cgff\", \"cgfc\", \"cgfn\", \"cgo\",\n\t\"cu?\", \"cu\", \"cu1\", \"cu2\", \"cu4\", \"cu8\", \"cud\",\n\t\"cv\", \"cv1\", \"cv2\", \"cv4\", \"cv8\",\n\t\"cV\", \"cV1\", \"cV2\", \"cV4\", \"cV8\",\n\t\"cw?\", \"cw\", \"cw*\", \"cwr\", \"cwu\",\n\t\"cx\", \"cx*\", \"cX\",\n\t\"cl\", \"cls\", \"clear\",\n\t\"d?\", \"db \", \"db-\", \"db-*\", \"db.\", \"dbj\", \"dbc\", \"dbC\", \"dbd\", \"dbe\", \"dbs\", \"dbf\", \"dbm\", \"dbn\",\n\t\"db?\", \"dbi\", \"dbi.\", \"dbix\", \"dbic\", \"dbie\", \"dbid\", \"dbis\", \"dbite\", \"dbitd\", \"dbits\", \"dbh\", \"dbh-\",\n\t\"dbt\", \"dbt*\", \"dbt=\", \"dbtv\", \"dbtj\", \"dbta\", \"dbte\", \"dbtd\", \"dbts\", \"dbx\", \"dbw\",\n\t\"dc?\", \"dc\", \"dca\", \"dcb\", \"dcc\", \"dccu\", \"dcf\", \"dck\", \"dcp\", \"dcr\", \"dcs\", \"dcs*\", \"dct\", \"dcu\", \"dcu.\",\n\t\"dd?\", \"dd\", \"dd-\", \"dd*\", \"dds\", \"ddd\", \"ddr\", \"ddw\",\n\t\"de\",\n\t\"dg\",\n\t\"dH\",\n\t\"di?\", \"di\", \"di*\", \"diq\", \"dij\",\n\t\"dk?\", \"dk\", \"dko\", \"dkj\",\n\t\"dL?\", \"dL\", \"dLq\", \"dLj\",\n\t\"dm?\", \"dm\", \"dm=\", \"dm.\", \"dm*\", \"dm-\", \"dmd\",\n\t\"dmh?\", \"dmh\", \"dmha\", \"dmhb\", \"dmhbg\", \"dmhc\", \"dmhf\", \"dmhg\", \"dmhi\", \"dmhm\", \"dmht\",\n\t\"dmi?\", \"dmi\", \"dmi*\", \"dmi.\", \"dmiv\",\n\t\"dmj\",\n\t\"dml?\", \"dml\",\n\t\"dmm?\", \"dmm\", \"dmm*\", \"dmm.\", \"dmmj\",\n\t\"dmp?\", \"dmp\",\n\t\"dms?\", \"dms\", \"dmsj\", \"dms*\", \"dms-\", \"dmsA\", \"dmsC\", \"dmsd\", \"dmsw\", \"dmsa\", \"dmsf\", \"dmst\",\n\t\"dmS\", \"dmS*\",\n\t\"do?\", \"do\", \"dor\", \"doo\",\n\t\"dp?\", \"dp\", \"dpj\", \"dpl\", \"dplj\", \"dp-\", \"dp=\", \"dpa\", \"dpc\", \"dpc*\", \"dpe\", \"dpf\", \"dpk\", \"dpn\", \"dptn\", \"dpt\",\n\t\"dr?\", \"dr\", \"drps\", \"drpj\", \"drr\", \"drrj\", \"drs\", \"drs+\", \"drs-\", \"drt\", \"drt*\", \"drtj\", \"drw\", \"drx\", \"drx-\",\n\t\".dr*\", \".dr-\",\n\t\"ds?\", \"ds\", \"dsb\", \"dsf\", \"dsi\", \"dsl\", \"dso\", \"dsp\", \"dss\", \"dsu\", \"dsui\", \"dsuo\", \"dsue\", \"dsuf\",\n\t\"dt?\", \"dt\", \"dt%\", \"dt*\", \"dt+\", \"dt-\", \"dt=\", \"dtD\", \"dta\", \"dtc\", \"dtd\", \"dte\", \"dte-*\", \"dtei\", \"dtek\",\n\t\"dtg\", \"dtg*\", \"dtgi\",\n\t\"dtr\",\n\t\"dts?\", \"dts\", \"dts+\", \"dts-\", \"dtsf\", \"dtst\", \"dtsC\", \"dtt\",\n\t\"dw\",\n\t\"dx?\", \"dx\", \"dxa\", \"dxe\", \"dxr\", \"dxs\",\n\t\"e?\", \"e\", \"e-\", \"e*\", \"e!\", \"ec\", \"ee?\", \"ee\", \"?ed\", \"ed\", \"ej\", \"env\", \"er\", \"es\" \"et\", \"ev\", \"evj\",\n\t\"ec?\", \"ec\", \"ec*\", \"ecd\", \"ecr\", \"ecs\", \"ecj\", \"ecc\", \"eco\", \"ecp\", \"ecn\",\n\t\"ecH?\", \"ecH\", \"ecHi\", \"ecHw\", \"ecH-\",\n\t\"f?\", \"f\", \"f.\", \"f*\", \"f-\", \"f--\", \"f+\", \"f=\", \"fa\", \"fb\", \"fc?\", \"fc\", \"fC\", \"fd\", \"fe-\", \"fe\",\n\t\"ff\", \"fi\", \"fg\", \"fj\",\n\t\"fl\", \"fla\", \"fm\", \"fn\", \"fnj\", \"fo\", \"fO\", \"fr\", \"fR\", \"fR?\",\n\t\"fs?\", \"fs\", \"fs*\", \"fsj\", \"fs-\", \"fs+\", \"fs-.\", \"fsq\", \"fsm\", \"fss\", \"fss*\", \"fssj\", \"fsr\",\n\t\"ft?\", \"ft\", \"ftn\", \"fV\", \"fx\", \"fq\",\n\t\"fz?\", \"fz\", \"fz-\", \"fz.\", \"fz:\", \"fz*\",\n\t\"g?\", \"g\", \"gw\", \"gc\", \"gl?\", \"gl\", \"gs\", \"gi\", \"gp\", \"ge\", \"gr\", \"gS\",\n\t\"i?\", \"i\", \"ij\", \"iA\", \"ia\", \"ib\", \"ic\", \"icc\", \"iC\",\n\t\"id?\", \"id\", \"idp\", \"idpi\", \"idpi*\", \"idpd\", \"iD\", \"ie\", \"iee\", \"iE\", \"iE.\",\n\t\"ih\", \"iHH\", \"ii\", \"iI\", \"ik\", \"il\", \"iL\", \"im\", \"iM\", \"io\", \"iO?\", \"iO\",\n\t\"ir\", \"iR\", \"is\", \"is.\", \"iS\", \"iS.\", \"iS=\", \"iSS\",\n\t\"it\", \"iV\", \"iX\", \"iz\", \"izj\", \"izz\", \"izzz\", \"iz-\", \"iZ\",\n\t\"k?\", \"k\", \"ko\", \"kd\", \"ks\", \"kj\",\n\t\"l\",\n\t\"L?\", \"L\", \"L-\", \"Ll\", \"LL\", \"La\", \"Lc\", \"Ld\", \"Lh\", \"Li\", \"Lo\",\n\t\"m?\", \"m\", \"m*\", \"ml\", \"m-\", \"md\", \"mf?\", \"mf\", \"mg\", \"mo\", \"mi\", \"mp\", \"ms\", \"my\",\n\t\"o?\", \"o\", \"o-\", \"o--\", \"o+\", \"oa\", \"oa-\", \"oq\", \"o*\", \"o.\", \"o=\",\n\t\"ob?\", \"ob\", \"ob*\", \"obo\", \"obb\", \"oba\", \"obf\", \"obj\", \"obr\", \"ob-\", \"ob-*\",\n\t\"oc\", \"of\", \"oi\", \"oj\", \"oL\", \"om\", \"on\",\n\t\"oo?\", \"oo\", \"oo+\", \"oob\", \"ood\", \"oom\", \"oon\", \"oon+\", \"oonn\", \"oonn+\",\n\t\"op\",  \"ox\",\n\t\"p?\", \"p-\", \"p=\", \"p2\", \"p3\", \"p6?\", \"p6\", \"p6d\", \"p6e\", \"p8?\", \"p8\", \"p8f\", \"p8j\",\n\t\"pa?\", \"paD\", \"pad\", \"pade\", \"pae\", \"pA\",\n\t\"pb?\", \"pb\", \"pB\", \"pxb\", \"pB?\",\n\t\"pc?\", \"pc\", \"pc*\", \"pca\", \"pcA\", \"pcd\", \"pch\", \"pcj\", \"pcp\", \"pcs\", \"pcS\", \"pcw\",\n\t\"pC?\", \"pC\", \"pCa\", \"pCA\", \"pCc\", \"pCd\", \"pCD\", \"pCx\", \"pCw\",\n\t\"pd?\", \"pd\", \"pd--\", \"pD\", \"pda\", \"pdb\", \"pdc\", \"pdC\", \"pdf\", \"pdi\", \"pdj\", \"pdJ\",\n\t\"pdk\", \"pdl\", \"pdp\", \"pdr\", \"pdr.\", \"pdR\", \"pds?\", \"pds\", \"pdsb\", \"pdsf\", \"pdt\",\n\t\"pD\",\n\t\"pf?\", \"pf\", \"pf??\", \"pf???\", \"pf.\", \"pfj\", \"pfj.\", \"pf*\", \"pf*.\", \"pfd\", \"pfd.\",\n\t\"pfo\", \"pfq\", \"pfv\", \"pfv.\", \"pfs\", \"pfs.\",\n\t\"pF?\", \"pF\", \"pFa\", \"pFaq\", \"pFo\", \"pFp\", \"pFx\",\n\t\"pg?\", \"pg\", \"pg*\", \"pg-*\",\n\t\"ph?\", \"ph\", \"ph=\",\n\t\"pi?\", \"pi\", \"pia\", \"pib\", \"pid\", \"pie\", \"pif?\", \"pif\", \"pifc\", \"pifcj\", \"pifj\", \"pij\", \"pir\",\n\t\"pI?\", \"pI\", \"pIa\", \"pIb\", \"pId\", \"pIe\", \"pIf?\", \"pIf\", \"pIfc\", \"pIfcj\", \"pIfj\", \"pIj\",\t\"pIr\",\n\t\"pj?\", \"pj\", \"pj.\", \"pj..\",\n\t\"pk?\", \"pk\", \"pK?\", \"pK\",\n\t\"pm?\", \"pm\",\n\t\"pq?\", \"pq\", \"pqi\", \"pqz\",\n\t\"pr?\", \"pr\", \"prc\", \"prl\", \"prx\", \"prg?\", \"prg\", \"prgi\", \"prgo\", \"prz\",\n\t\"ps?\", \"ps\", \"psb\", \"psi\", \"psj\", \"psp\", \"pss\", \"psu\", \"psw\", \"psW\", \"psx\", \"psz\", \"ps+\",\n\t\"pt?\", \"pt\", \"pt.\", \"ptd\", \"pth\", \"ptn\",\n\t\"pu?\", \"pu\", \"puw\", \"pU\",\n\t\"pv?\", \"pv\", \"pv1\", \"pv2\", \"pv4\", \"pv8\", \"pvz\", \"pvj\", \"pvh\", \"pv1j\", \"pv2j\", \"pv4j\", \"pv8j\",\n\t\"pv1h\", \"pv2h\", \"pv4h\", \"pv8h\",\n\t\"px?\", \"px\", \"px/\", \"px0\", \"pxa\", \"pxA?\", \"pxA\", \"pxb\", \"pxc\", \"pxd?\", \"pxd\", \"pxd2\", \"pxd4\", \"pxd8\",\n\t\"pxe\", \"pxf\", \"pxh\", \"pxH\", \"pxi\", \"pxl\", \"pxo\", \"pxq\", \"pxq\", \"pxQ\", \"pxQq\", \"pxr\", \"pxrj\",\n\t\"pxs\", \"pxt\", \"pxt*\", \"pxt.\", \"pxw\", \"pxW\", \"pxWq\", \"pxx\", \"pxX\",\n\t\"pz?\", \"pz\", \"pzp\", \"pzf\", \"pzs\", \"pz0\", \"pzF\", \"pze\", \"pzh\",\n\t\"P?\", \"P\", \"Pc\", \"Pd\", \"Pi\", \"Pn\", \"Pnj\", \"Po\", \"Ps\", \"PS\", \"P-\",\n\t\"q?\", \"q\", \"q!\", \"q!!\", \"q!!!\", \"qy\", \"qn\", \"qyy\", \"qyn\", \"qny\", \"qnn\",\n\t\"r?\", \"r\", \"r-\", \"r+\", \"rh\",\n\t\"s?\", \"s\", \"s:\", \"s-\", \"s-*\", \"s--\", \"s+\", \"s++\", \"sj\", \"s*\", \"s=\", \"s!\", \"s/\", \"s/x\", \"s.\", \"sa\", \"sb\",\n\t\"sC?\", \"sC\", \"sC*\",\n\t\"sf\", \"sf.\", \"sg\", \"sG\", \"sl?\", \"sl\", \"sl+\", \"sl-\", \"slc\", \"sll\", \"sn\", \"sp\", \"so\", \"sr\", \"ss\",\n\t\"t?\", \"t\", \"tj\", \"t*\", \"t-\", \"t-*\", \"ta\", \"tb\", \"tc\", \"te?\", \"te\", \"tej\", \"teb\", \"tec\",\n\t\"td?\", \"td\", \"td-\", \"tf\", \"tk\", \"tl\", \"tn\", \"to\", \"tos\", \"tp\", \"tpx\", \"ts?\", \"ts\", \"tsj\", \"ts*\", \"tsc\", \"tss\",\n\t\"tu?\", \"tu\", \"tuj\", \"tu*\", \"tuc\", \"tt?\", \"tt\", \"ttj\", \"ttc\",\n\t\"T?\", \"T\", \"T*\", \"T-\", \"Tl\", \"Tj\", \"Tm\", \"Ts\", \"TT\", \"T=\", \"T=.\", \"T=&\",\n\t\"u?\", \"u\", \"uw\", \"us\", \"uc\",\n\t\"v\", \"V\", \"v!\", \"vv\", \"vV\", \"vVV\", \"VV\",\n\t\"w?\", \"w\", \"w1+\", \"w1-\", \"w2+\", \"w2-\", \"w4+\", \"w4-\", \"w8+\", \"w8-\",\n\t\"w0\", \"w\", \"w6\", \"w6d\", \"w6e\", \"wa\", \"wa*\", \"waf\", \"wao?\", \"wao\",\n\t\"wA?\", \"wA\", \"wB\", \"wB-\", \"wc\", \"wcj\", \"wc-\", \"wc+\", \"wc*\", \"wcr\", \"wci\", \"wcp\", \"wcp*\", \"wcpi\",\n\t\"wd\", \"we?\", \"we\", \"wen\", \"weN\", \"wes\", \"wex\", \"weX\",\n\t\"wf?\", \"wf\", \"wff\", \"wfs\", \"wF\", \"wh\", \"wm\",\n\t\"wo?\", \"wo\", \"wo2\", \"wo4\", \"woa\", \"woA\", \"wod\", \"woD\", \"woe\", \"woE\", \"wol\", \"wom\", \"woo\",\n\t\"wop?\", \"wop\", \"wopD\", \"wopD*\", \"wopO\",\n\t\"wp?\", \"wp\", \"wr\", \"ws\",\n\t\"wt?\", \"wt\", \"wta\", \"wtf\", \"wtf!\", \"wtff\", \"wts\",\n\t\"wu\",\n\t\"wv?\", \"wv\", \"wv1\", \"wv2\",  \"wv4\", \"wv8\",\n\t\"ww\",\n\t\"wx?\", \"wx\", \"wxf\", \"wxs\",\n\t\"wz\",\n\t\"x?\", \"x\", \"x/\", \"x0\", \"xa\", \"xA?\", \"xA\", \"xb\", \"xc\", \"xd?\", \"xd\", \"xd2\", \"xd4\", \"xd8\",\n\t\"xe\", \"xf\", \"xh\", \"xH\", \"xi\", \"xl\", \"xo\", \"xq\", \"xq\", \"xQ\", \"xQq\", \"xr\", \"xrj\",\n\t\"xs\", \"xt\", \"xt*\", \"xt.\", \"xw\", \"xW\", \"xWq\", \"xx\", \"xX\",\n\t\"y?\", \"y\", \"yz\", \"yp\", \"yx\", \"ys\", \"yt\", \"ytf\", \"yf\", \"yfa\", \"yfx\", \"yw\", \"ywx\", \"yy\",\n\t\"z?\", \"z\", \"z*\", \"zj\", \"z-\", \"z-*\",\n\t\"za?\", \"za??\", \"za\", \"zaf\", \"zaF\", \"zg\",\n\t\"zo?\", \"zo\", \"zoz\", \"zos\",\n\t\"zf?\", \"zfd\", \"zfs\", \"zfz\",\n\t\"z/?\", \"z/\", \"z/*\",\n\t\"zc\",\n\t\"zs?\", \"zs\", \"zs-\", \"zs-*\", \"zs+\", \"zsr\",\n\t\"zi\",\n\t\"?\", \"?v\", \"?$?\", \"?@?\", \"?>?\",\n\tNULL\n};\n\nstatic void autocomplete_mount_point (RLineCompletion *completion, RCore *core, const char *path) {\n\tRFSRoot *r;\n\tRListIter *iter;\n\tr_list_foreach (core->fs->roots, iter, r) {\n\t\tchar *base = strdup (r->path);\n\t\tchar *ls = (char *) r_str_lchr (base, '/');\n\t\tif (ls) {\n\t\t\tls++;\n\t\t\t*ls = 0;\n\t\t}\n\t\tif (!strcmp (path, base)) {\n\t\t\tr_line_completion_push (completion, r->path);\n\t\t}\n\t\tfree (base);\n\t}\n}\n\nstatic void autocomplete_ms_path(RLineCompletion *completion, RCore *core, const char *str, const char *path) {\n\tchar *lpath = NULL, *dirname = NULL , *basename = NULL;\n\tchar *p = NULL;\n\tchar *pwd = (core->rfs && *(core->rfs->cwd)) ? *(core->rfs->cwd): \".\";\n\tint n = 0;\n\tRList *list;\n\tRListIter *iter;\n\tRFSFile *file;\n\tr_return_if_fail (path);\n\tlpath = r_str_new (path);\n\tp = (char *)r_str_last (lpath, R_SYS_DIR);\n\tif (p) {\n\t\t*p = 0;\n\t\tif (p == lpath) { // /xxx\n\t\t\tdirname  = r_str_new (\"/\");\n\t\t} else if (lpath[0] == '.') { // ./xxx/yyy\n\t\t\tdirname = r_str_newf (\"%s%s\", pwd, R_SYS_DIR);\n\t\t} else if (lpath[0] == '/') { // /xxx/yyy\n      \t\t\tdirname = r_str_newf (\"%s%s\", lpath, R_SYS_DIR);\n    \t\t} else { // xxx/yyy\n      \t\t\tif (strlen (pwd) == 1) { // if pwd is root\n        \t\t\tdirname = r_str_newf (\"%s%s%s\", R_SYS_DIR, lpath, R_SYS_DIR);\n      \t\t\t} else {\n\t\t\t\tdirname = r_str_newf (\"%s%s%s%s\", pwd, R_SYS_DIR, lpath, R_SYS_DIR);\n      \t\t\t}\n\t\t}\n\t\tbasename = r_str_new (p + 1);\n\t} else { // xxx\n    \t\tif (strlen (pwd) == 1) {\n      \t\t\tdirname = r_str_newf (\"%s\", R_SYS_DIR);\n    \t\t} else {\n      \t\t\tdirname = r_str_newf (\"%s%s\", pwd, R_SYS_DIR);\n    \t\t}\n\t\tbasename = r_str_new (lpath);\n\t}\n\n\tif (!dirname || !basename) {\n\t\tgoto out;\n\t}\n\tlist= r_fs_dir (core->fs, dirname);\n\tn = strlen (basename);\n\tbool chgdir = !strncmp (str, \"cd  \", 3);\n\tif (list) {\n\t\tr_list_foreach (list, iter, file) {\n\t\t\tif (!file) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!basename[0] || !strncmp (file->name, basename, n))  {\n\t\t\t\tchar *tmpstring = r_str_newf (\"%s%s\", dirname, file->name);\n\t\t\t\tif (r_file_is_directory (tmpstring)) {\n\t\t\t\t\tchar *s = r_str_newf (\"%s/\", tmpstring);\n\t\t\t\t\tr_line_completion_push (completion, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t} else if (!chgdir) {\n\t\t\t\t\tr_line_completion_push (completion, tmpstring);\n\t\t\t\t}\n\t\t\t\tfree (tmpstring);\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\n\tautocomplete_mount_point (completion, core, path);\nout:\n\tfree (lpath);\n\tfree (dirname);\n\tfree (basename);\n}\n\nstatic void autocomplete_process_path(RLineCompletion *completion, const char *str, const char *path) {\n\tchar *lpath = NULL, *dirname = NULL , *basename = NULL;\n\tchar *home = NULL, *filename = NULL, *p = NULL;\n\tint n = 0;\n\tRList *list;\n\tRListIter *iter;\n\n\tif (!path) {\n\t\tgoto out;\n\t}\n\n\tlpath = r_str_new (path);\n#if __WINDOWS__\n\tr_str_replace_ch (lpath, '/', '\\\\', true);\n#endif\n\tp = (char *)r_str_last (lpath, R_SYS_DIR);\n\tif (p) {\n\t\t*p = 0;\n\t\tif (p == lpath) { // /xxx\n#if __WINDOWS__\n\t\t\tdirname = strdup (\"\\\\.\\\\\");\n#else\n\t\t\tdirname = r_str_new (R_SYS_DIR);\n#endif\n\t\t} else if (lpath[0] == '~' && lpath[1]) { // ~/xxx/yyy\n\t\t\tdirname = r_str_home (lpath + 2);\n\t\t} else if (lpath[0] == '~') { // ~/xxx\n\t\t\tif (!(home = r_str_home (NULL))) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdirname = r_str_newf (\"%s%s\", home, R_SYS_DIR);\n\t\t\tfree (home);\n\t\t} else if (lpath[0] == '.' || lpath[0] == R_SYS_DIR[0] ) { // ./xxx/yyy || /xxx/yyy\n\t\t\tdirname = r_str_newf (\"%s%s\", lpath, R_SYS_DIR);\n\t\t} else { // xxx/yyy\n\t\t\tchar *fmt = \".%s%s%s\";\n#if __WINDOWS__\n\t\t\tif (strchr (path, ':')) {\n\t\t\t\tfmt = \"%.0s%s%s\";\n\t\t\t}\n#endif\n\t\t\tdirname = r_str_newf (fmt, R_SYS_DIR, lpath, R_SYS_DIR);\n\t\t}\n\t\tbasename = r_str_new (p + 1);\n\t} else { // xxx\n\t\tdirname = r_str_newf (\".%s\", R_SYS_DIR);\n\t\tbasename = r_str_new (lpath);\n\t}\n\n\tif (!dirname || !basename) {\n\t\tgoto out;\n\t}\n\n\tlist= r_sys_dir (dirname);\n\tn = strlen (basename);\n\tbool chgdir = !strncmp (str, \"cd \", 3);\n\tif (list) {\n\t\tr_list_foreach (list, iter, filename) {\n\t\t\tif (*filename == '.') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!basename[0] || !strncmp (filename, basename, n))  {\n\t\t\t\tchar *tmpstring = r_str_newf (\"%s%s\", dirname, filename);\n\t\t\t\tif (r_file_is_directory (tmpstring)) {\n\t\t\t\t\tchar *s = r_str_newf (\"%s%s\", tmpstring, R_SYS_DIR);\n\t\t\t\t\tr_line_completion_push (completion, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t} else if (!chgdir) {\n\t\t\t\t\tr_line_completion_push (completion, tmpstring);\n\t\t\t\t}\n\t\t\t\tfree (tmpstring);\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\nout:\n\tfree (lpath);\n\tfree (dirname);\n\tfree (basename);\n}\n\nstatic void autocompleteFilename(RLineCompletion *completion, RLineBuffer *buf, char **extra_paths, int narg) {\n\tchar *args = NULL, *input = NULL;\n\tint n = 0, i = 0;\n\tchar *pipe = strchr (buf->data, '>');\n\tif (pipe) {\n\t\targs = r_str_new (pipe + 1);\n\t} else {\n\t\targs = r_str_new (buf->data);\n\t}\n\tif (!args) {\n\t\tgoto out;\n\t}\n\n\tn = r_str_word_set0 (args);\n\tif (n < narg) {\n\t\tgoto out;\n\t}\n\n\tinput = r_str_new (r_str_word_get0 (args, narg));\n\tif (!input) {\n\t\tgoto out;\n\t}\n\tconst char *tinput = r_str_trim_head_ro (input);\n\n\tautocomplete_process_path (completion, buf->data, tinput);\n\n\tif (input[0] == '/' || input[0] == '.' || !extra_paths) {\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; extra_paths[i]; i ++) {\n\t\tchar *s = r_str_newf (\"%s%s%s\", extra_paths[i], R_SYS_DIR, tinput);\n\t\tif (!s) {\n\t\t\tbreak;\n\t\t}\n\t\tautocomplete_process_path (completion, buf->data, s);\n\t\tfree (s);\n\t}\nout:\n\tfree (args);\n\tfree (input);\n}\n\n//TODO: make it recursive to handle nested struct\nstatic int autocomplete_pfele (RCore *core, RLineCompletion *completion, char *key, char *pfx, int idx, char *ptr) {\n\tint i, ret = 0;\n\tint len = strlen (ptr);\n\tchar* fmt = sdb_get (core->print->formats, key, NULL);\n\tif (fmt) {\n\t\tint nargs = r_str_word_set0_stack (fmt);\n\t\tif (nargs > 1) {\n\t\t\tfor (i = 1; i < nargs; i++) {\n\t\t\t\tconst char *arg = r_str_word_get0 (fmt, i);\n\t\t\t\tchar *p = strchr (arg, '(');\n\t\t\t\tchar *p2 = strchr (arg, ')');\n\t\t\t\t// remove '(' and ')' from fmt\n\t\t\t\tif (p && p2) {\n\t\t\t\t\targ = p + 1;\n\t\t\t\t\t*p2 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!len || !strncmp (ptr, arg, len)) {\n\t\t\t\t\tchar *s = r_str_newf (\"pf%s.%s.%s\", pfx, key, arg);\n\t\t\t\t\tr_line_completion_push (completion, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (fmt);\n\treturn ret;\n}\n\n#define ADDARG(x) if (!strncmp (buf->data+chr, x, strlen (buf->data+chr))) { r_line_completion_push (completion, x); }\n\nstatic void autocomplete_default(R_NULLABLE RCore *core, RLineCompletion *completion, RLineBuffer *buf) {\n\tRCoreAutocomplete *a = core ? core->autocomplete : NULL;\n\tint i;\n\tif (a) {\n\t\tfor (i = 0; i < a->n_subcmds; i++) {\n\t\t\tif (buf->data[0] == 0 || !strncmp (a->subcmds[i]->cmd, buf->data, a->subcmds[i]->length)) {\n\t\t\t\tr_line_completion_push (completion, a->subcmds[i]->cmd);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < radare_argc && radare_argv[i]; i++) {\n\t\t\tint length = strlen (radare_argv[i]);\n\t\t\tif (!strncmp (radare_argv[i], buf->data, length)) {\n\t\t\t\tr_line_completion_push (completion, radare_argv[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void autocomplete_evals(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tRConfigNode *bt;\n\tRListIter *iter;\n\tchar *tmp = strrchr (str, ' ');\n\tif (tmp) {\n\t\tstr = tmp + 1;\n\t}\n\tint n = strlen (str);\n\tif (n < 1) {\n\t\treturn;\n\t}\n\tr_list_foreach (core->config->nodes, iter, bt) {\n\t\tif (!strncmp (bt->name, str, n)) {\n\t\t\tr_line_completion_push (completion, bt->name);\n\t\t}\n\t}\n}\n\nstatic void autocomplete_project(RCore *core, RLineCompletion *completion, const char* str) {\n\tr_return_if_fail (str);\n\tchar *foo, *projects_path = r_file_abspath (r_config_get (core->config, \"dir.projects\"));\n\tRList *list = r_sys_dir (projects_path);\n\tRListIter *iter;\n\tint n = strlen (str);\n\tif (projects_path) {\n\t\tr_list_foreach (list, iter, foo) {\n\t\t\tif (r_core_is_project (core, foo)) {\n\t\t\t\tif (!strncmp (foo, str, n)) {\n\t\t\t\t\tr_line_completion_push (completion, foo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (projects_path);\n\t\tr_list_free (list);\n\t}\n}\n\nstatic void autocomplete_minus(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tint count;\n\tint length = strlen (str);\n\tchar **keys = r_cmd_alias_keys(core->rcmd, &count);\n\tif (!keys) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; i < count; i++) {\n\t\tif (!strncmp (keys[i], str, length)) {\n\t\t\tr_line_completion_push (completion, keys[i]);\n\t\t}\n\t}\n}\n\nstatic void autocomplete_breakpoints(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tRListIter *iter;\n\tRBreakpoint *bp = core->dbg->bp;\n\tRBreakpointItem *b;\n\tint n = strlen (str);\n\tr_list_foreach (bp->bps, iter, b) {\n\t\tchar *addr = r_str_newf (\"0x%\"PFMT64x\"\", b->addr);\n\t\tif (!strncmp (addr, str, n)) {\n\t\t\tr_line_completion_push (completion, addr);\n\t\t}\n\t\tfree (addr);\n\t}\n}\n\nstatic bool add_argv(RFlagItem *fi, void *user) {\n\tRLineCompletion *completion = user;\n\tr_line_completion_push (completion, fi->name);\n\treturn true;\n}\n\nstatic void autocomplete_flags(RCore *core, RLineCompletion *completion, const char* str) {\n\tr_return_if_fail (str);\n\tint n = strlen (str);\n\tr_flag_foreach_prefix (core->flags, str, n, add_argv, completion);\n}\n\n// TODO: Should be refactored\nstatic void autocomplete_sdb (RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (core && completion && str);\n\tchar *pipe = strchr (str, '>');\n\tSdb *sdb = core->sdb;\n\tchar *lpath = NULL, *p1 = NULL, *out = NULL, *p2 = NULL;\n\tchar *cur_pos = NULL, *cur_cmd = NULL, *next_cmd = NULL;\n\tchar *temp_cmd = NULL, *temp_pos = NULL, *key = NULL;\n\tif (pipe) {\n\t\tstr = r_str_trim_head_ro (pipe + 1);\n\t}\n\tlpath = r_str_new (str);\n\tp1 = strchr (lpath, '/');\n\tif (p1) {\n\t\t*p1 = 0;\n\t\tchar *ns = p1 + 1;\n\t\tp2 = strchr (ns, '/');\n\t\tif (!p2) { // anal/m\n\t\t\tchar *tmp = p1 + 1;\n\t\t\tint n = strlen (tmp);\n\t\t\tout = sdb_querys (sdb, NULL, 0, \"anal/**\");\n\t\t\tif (!out) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (*out) {\n\t\t\t\tcur_pos = strchr (out, '\\n');\n\t\t\t\tif (!cur_pos) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n\t\t\t\tif (!strncmp (tmp, cur_cmd, n)) {\n\t\t\t\t\tchar *cmplt = r_str_newf (\"anal/%s/\", cur_cmd);\n\t\t\t\t\tr_line_completion_push (completion, cmplt);\n\t\t\t\t\tfree (cmplt);\n\t\t\t\t}\n\t\t\t\tout += cur_pos - out + 1;\n\t\t\t}\n\n\t\t} else { // anal/meta/*\n\t\t\tchar *tmp = p2 + 1;\n\t\t\tint n = strlen (tmp);\n\t\t\tchar *spltr = strchr (ns, '/');\n\t\t\t*spltr = 0;\n\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", ns);\n\t\t\tout = sdb_querys (sdb, NULL, 0, next_cmd);\n\t\t\tif (!out) {\n\t\t\t\tfree (lpath);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (*out) {\n\t\t\t\ttemp_pos = strchr (out, '\\n');\n\t\t\t\tif (!temp_pos) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttemp_cmd = r_str_ndup (out, temp_pos - out); // contains the key=value pair\n\t\t\t\tkey = strchr (temp_cmd, '=');\n\t\t\t\t*key = 0;\n\t\t\t\tif (!strncmp (tmp, temp_cmd, n)) {\n\t\t\t\t\tchar *cmplt = r_str_newf (\"anal/%s/%s\", ns, temp_cmd);\n\t\t\t\t\tr_line_completion_push (completion, cmplt);\n\t\t\t\t\tfree (cmplt);\n\t\t\t\t}\n\t\t\t\tout += temp_pos - out + 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint n = strlen (lpath);\n\t\tif (!strncmp (lpath, \"anal\", n)) {\n\t\t\tr_line_completion_push (completion, \"anal/\");\n\t\t}\n\t}\n}\n\nstatic void autocomplete_zignatures(RCore *core, RLineCompletion *completion, const char* msg) {\n\tr_return_if_fail (msg);\n\tint length = strlen (msg);\n\tRSpaces *zs = &core->anal->zign_spaces;\n\tRSpace *s;\n\tRSpaceIter it;\n\n\tr_spaces_foreach (zs, it, s) {\n\t\tif (!strncmp (msg, s->name, length)) {\n\t\t\tr_line_completion_push (completion, s->name);\n\t\t}\n\t}\n\n\tif (strlen (msg) == 0) {\n\t\tr_line_completion_push (completion, \"*\");\n\t}\n}\n\nstatic void autocomplete_flagspaces(RCore *core, RLineCompletion *completion, const char* msg) {\n\tr_return_if_fail (msg);\n\tint length = strlen (msg);\n\tRFlag *flag = core->flags;\n\tRSpaceIter it;\n\tRSpace *s;\n\tr_flag_space_foreach (flag, it, s) {\n\t\tif (!strncmp (msg, s->name, length)) {\n\t\t\tr_line_completion_push (completion, s->name);\n\t\t}\n\t}\n\n\tif (strlen (msg) == 0) {\n\t\tr_line_completion_push (completion, \"*\");\n\t}\n}\n\nstatic void autocomplete_functions (RCore *core, RLineCompletion *completion, const char* str) {\n\tr_return_if_fail (str);\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tint n = strlen (str);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tchar *name = r_core_anal_fcn_name (core, fcn);\n\t\tif (!strncmp (name, str, n)) {\n\t\t\tr_line_completion_push (completion, name);\n\t\t}\n\t\tfree (name);\n\t}\n}\n\nstatic void autocomplete_macro(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tRCmdMacroItem *item;\n\tRListIter *iter;\n\tchar buf[1024];\n\tint n = strlen(str);\n\tr_list_foreach (core->rcmd->macro.macros, iter, item) {\n\t\tchar *p = item->name;\n\t\tif (!*str || !strncmp (str, p, n)) {\n\t\t\tsnprintf (buf, sizeof (buf), \"%s%s)\", str, p);\n\t\t\tr_line_completion_push (completion, buf);\n\t\t}\n\t}\n}\n\nstatic void autocomplete_file(RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tchar *pipe = strchr (str, '>');\n\n\tif (pipe) {\n\t\tstr = r_str_trim_head_ro (pipe + 1);\n\t}\n\tif (str && !*str) {\n\t\tautocomplete_process_path (completion, str, \"./\");\n\t} else {\n\t\tautocomplete_process_path (completion, str, str);\n\t}\n\n}\n\nstatic void autocomplete_ms_file(RCore* core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tchar *pipe = strchr (str, '>');\n\tchar *path = (core->rfs && *(core->rfs->cwd)) ? *(core->rfs->cwd): \"/\";\n\tif (pipe) {\n\t\tstr = r_str_trim_head_ro (pipe + 1);\n\t}\n\tif (str && !*str) {\n\t\tautocomplete_ms_path (completion, core, str, path);\n\t} else {\n\t\tautocomplete_ms_path (completion, core, str, str);\n\t}\n}\n\nstatic void autocomplete_theme(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tint len = strlen (str);\n\tchar *theme;\n\tRListIter *iter;\n\tRList *themes = r_core_list_themes (core);\n\tr_list_foreach (themes, iter, theme) {\n\t\tif (!len || !strncmp (str, theme, len)) {\n\t\t\tr_line_completion_push (completion, theme);\n\t\t}\n\t}\n\tr_list_free (themes);\n}\n\nstatic bool find_e_opts(RCore *core, RLineCompletion *completion, RLineBuffer *buf) {\n\tconst char *pattern = \"e (.*)=\";\n\tRRegex *rx = r_regex_new (pattern, \"e\");\n\tconst size_t nmatch = 2;\n\tRRegexMatch pmatch[2];\n\tbool ret = false;\n\n\t// required to get the new list of items to autocomplete for cmd.pdc at least\n\tr_core_config_update (core);\n\n\tif (r_regex_exec (rx, buf->data, nmatch, pmatch, 1)) {\n\t\tgoto out;\n\t}\n\tint i;\n\tchar *str = NULL, *sp;\n\tfor (i = pmatch[1].rm_so; i < pmatch[1].rm_eo; i++) {\n\t\tstr = r_str_appendch (str, buf->data[i]);\n\t}\n\tif (!str) {\n\t\tgoto out;\n\t}\n\tif ((sp = strchr (str, ' '))) {\n\t\t// if the name contains a space, just null\n\t\t*sp = 0;\n\t}\n\tRConfigNode *node = r_config_node_get (core->config, str);\n\tif (sp) {\n\t\t// if nulled, then restore.\n\t\t*sp = ' ';\n\t}\n\tif (!node) {\n\t\treturn false;\n\t}\n\tRListIter *iter;\n\tchar *option;\n\tchar *p = (char *) strchr (buf->data, '=');\n\tp = r_str_ichr (p + 1, ' ');\n\tint n = strlen (p);\n\tr_list_foreach (node->options, iter, option) {\n\t\tif (!strncmp (option, p, n)) {\n\t\t\tr_line_completion_push (completion, option);\n\t\t}\n\t}\n\tcompletion->opt = true;\n\tret = true;\n\n out:\n\tr_regex_free (rx);\n\treturn ret;\n}\n\nstatic bool find_autocomplete(RCore *core, RLineCompletion *completion, RLineBuffer *buf) {\n\tRCoreAutocomplete* child = NULL;\n\tRCoreAutocomplete* parent = core->autocomplete;\n\tconst char* p = buf->data;\n\tif (!*p) {\n\t\treturn false;\n\t}\n\tchar arg[256];\n\targ[0] = 0;\n\twhile (*p) {\n\t\tconst char* e = r_str_trim_head_wp (p);\n\t\tif (!e || (e - p) >= 256 || e == p) {\n\t\t\treturn false;\n\t\t}\n\t\tmemcpy (arg, p, e - p);\n\t\targ[e - p] = 0;\n\t\tchild = r_core_autocomplete_find (parent, arg, false);\n\t\tif (child && child->length < buf->length && p[child->length] == ' ') {\n\t\t\t// if is spaced then i can provide the\n\t\t\t// next subtree as suggestion..\n\t\t\tp = r_str_trim_head_ro (p + child->length);\n\t\t\tif (child->type == R_CORE_AUTOCMPLT_OPTN) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparent = child;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tint i;\n\t/* if something went wrong this will prevent bad behavior */\n\tr_line_completion_clear (completion);\n\tswitch (parent->type) {\n\tcase R_CORE_AUTOCMPLT_SEEK:\n\t\tautocomplete_functions (core, completion, p);\n\tcase R_CORE_AUTOCMPLT_FLAG:\n\t\tautocomplete_flags (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_FLSP:\n\t\tautocomplete_flagspaces (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_FCN:\n\t\tautocomplete_functions (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_ZIGN:\n\t\tautocomplete_zignatures (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_EVAL:\n\t\tautocomplete_evals (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_PRJT:\n\t\tautocomplete_project (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_MINS:\n\t\tautocomplete_minus (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_BRKP:\n\t\tautocomplete_breakpoints (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_MACR:\n\t\tautocomplete_macro (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_MS:\n\t\tautocomplete_ms_file(core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_FILE:\n\t\tautocomplete_file (completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_THME:\n\t\tautocomplete_theme (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_SDB:\n\t\tautocomplete_sdb (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_OPTN:\n\t\t// handled before\n\t\tbreak;\n\tdefault:\n\t\tif (r_config_get_i (core->config, \"cfg.newtab\")) {\n\t\t\tRCmdDescriptor *desc = &core->root_cmd_descriptor;\n\t\t\tfor (i = 0; arg[i] && desc; i++) {\n\t\t\t\tut8 c = arg[i];\n\t\t\t\tdesc = c < R_ARRAY_SIZE (desc->sub) ? desc->sub[c] : NULL;\n\t\t\t}\n\t\t\tif (desc && desc->help_msg) {\n\t\t\t\tr_core_cmd_help (core, desc->help_msg);\n\t\t\t\tr_cons_flush ();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// fallback to command listing\n\t\t}\n\t\tint length = strlen (arg);\n\t\tfor (i = 0; i < parent->n_subcmds; i++) {\n\t\t\tif (!strncmp (arg, parent->subcmds[i]->cmd, length)) {\n\t\t\t\tr_line_completion_push (completion, parent->subcmds[i]->cmd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API void r_core_autocomplete(R_NULLABLE RCore *core, RLineCompletion *completion, RLineBuffer *buf, RLinePromptType prompt_type) {\n\tif (!core) {\n\t\tautocomplete_default (core, completion, buf);\n\t\treturn;\n\t}\n\tr_line_completion_clear (completion);\n\tchar *pipe = strchr (buf->data, '>');\n\tchar *ptr = strchr (buf->data, '@');\n\tif (pipe && strchr (pipe + 1, ' ') && buf->data + buf->index >= pipe) {\n\t\tautocompleteFilename (completion, buf, NULL, 1);\n\t} else if (ptr && strchr (ptr + 1, ' ') && buf->data + buf->index >= ptr) {\n\t\tint sdelta, n;\n\t\tptr = (char *)r_str_trim_head_ro (ptr + 1);\n\t\tn = strlen (ptr);//(buf->data+sdelta);\n\t\tsdelta = (int)(size_t)(ptr - buf->data);\n\t\tr_flag_foreach_prefix (core->flags, buf->data + sdelta, n, add_argv, completion);\n\t} else if (!strncmp (buf->data, \"#!pipe \", 7)) {\n\t\tif (strchr (buf->data + 7, ' ')) {\n\t\t\tautocompleteFilename (completion, buf, NULL, 2);\n\t\t} else {\n\t\t\tint chr = 7;\n\t\t\tADDARG (\"node\");\n\t\t\tADDARG (\"vala\");\n\t\t\tADDARG (\"ruby\");\n\t\t\tADDARG (\"newlisp\");\n\t\t\tADDARG (\"perl\");\n\t\t\tADDARG (\"python\");\n\t\t}\n\t} else if (!strncmp (buf->data, \"ec \", 3)) {\n\t\tif (strchr (buf->data + 3, ' ')) {\n\t\t\tautocompleteFilename (completion, buf, NULL, 2);\n\t\t} else {\n\t\t\tint chr = 3;\n\t\t\tADDARG(\"comment\")\n\t\t\tADDARG(\"usrcmt\")\n\t\t\tADDARG(\"args\")\n\t\t\tADDARG(\"fname\")\n\t\t\tADDARG(\"floc\")\n\t\t\tADDARG(\"fline\")\n\t\t\tADDARG(\"flag\")\n\t\t\tADDARG(\"label\")\n\t\t\tADDARG(\"help\")\n\t\t\tADDARG(\"flow\")\n\t\t\tADDARG(\"prompt\")\n\t\t\tADDARG(\"offset\")\n\t\t\tADDARG(\"input\")\n\t\t\tADDARG(\"invalid\")\n\t\t\tADDARG(\"other\")\n\t\t\tADDARG(\"b0x00\")\n\t\t\tADDARG(\"b0x7f\")\n\t\t\tADDARG(\"b0xff\")\n\t\t\tADDARG(\"math\")\n\t\t\tADDARG(\"bin\")\n\t\t\tADDARG(\"btext\")\n\t\t\tADDARG(\"push\")\n\t\t\tADDARG(\"pop\")\n\t\t\tADDARG(\"crypto\")\n\t\t\tADDARG(\"jmp\")\n\t\t\tADDARG(\"cjmp\")\n\t\t\tADDARG(\"call\")\n\t\t\tADDARG(\"nop\")\n\t\t\tADDARG(\"ret\")\n\t\t\tADDARG(\"trap\")\n\t\t\tADDARG(\"swi\")\n\t\t\tADDARG(\"cmp\")\n\t\t\tADDARG(\"reg\")\n\t\t\tADDARG(\"creg\")\n\t\t\tADDARG(\"num\")\n\t\t\tADDARG(\"mov\")\n\t\t\tADDARG(\"func_var\")\n\t\t\tADDARG(\"func_var_type\")\n\t\t\tADDARG(\"func_var_addr\")\n\t\t\tADDARG(\"widget_bg\")\n\t\t\tADDARG(\"widget_sel\")\n\t\t\tADDARG(\"ai.read\")\n\t\t\tADDARG(\"ai.write\")\n\t\t\tADDARG(\"ai.exec\")\n\t\t\tADDARG(\"ai.seq\")\n\t\t\tADDARG(\"ai.ascii\")\n\t\t\tADDARG(\"ai.unmap\")\n\t\t\tADDARG(\"graph.box\")\n\t\t\tADDARG(\"graph.box2\")\n\t\t\tADDARG(\"graph.box3\")\n\t\t\tADDARG(\"graph.box4\")\n\t\t\tADDARG(\"graph.true\")\n\t\t\tADDARG(\"graph.false\")\n\t\t\tADDARG(\"graph.trufae\")\n\t\t\tADDARG(\"graph.current\")\n\t\t\tADDARG(\"graph.traced\")\n\t\t\tADDARG(\"gui.cflow\")\n\t\t\tADDARG(\"gui.dataoffset\")\n\t\t\tADDARG(\"gui.background\")\n\t\t\tADDARG(\"gui.alt_background\")\n\t\t\tADDARG(\"gui.border\")\n\t\t}\n\t} else if (!strncmp (buf->data, \"pf.\", 3)\n\t|| !strncmp (buf->data, \"pf*.\", 4)\n\t|| !strncmp (buf->data, \"pfd.\", 4)\n\t|| !strncmp (buf->data, \"pfv.\", 4)\n\t|| !strncmp (buf->data, \"pfj.\", 4)) {\n\t\tchar pfx[2];\n\t\tint chr = (buf->data[2]=='.')? 3: 4;\n\t\tif (chr == 4) {\n\t\t\tpfx[0] = buf->data[2];\n\t\t\tpfx[1] = 0;\n\t\t} else {\n\t\t\t*pfx = 0;\n\t\t}\n\t\tSdbList *sls = sdb_foreach_list (core->print->formats, false);\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tint j = 0;\n\t\tls_foreach (sls, iter, kv) {\n\t\t\tint len = strlen (buf->data + chr);\n\t\t\tint minlen = R_MIN (len,  strlen (sdbkv_key (kv)));\n\t\t\tif (!len || !strncmp (buf->data + chr, sdbkv_key (kv), minlen)) {\n\t\t\t\tchar *p = strchr (buf->data + chr, '.');\n\t\t\t\tif (p) {\n\t\t\t\t\tj += autocomplete_pfele (core, completion, sdbkv_key (kv), pfx, j, p + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = r_str_newf (\"pf%s.%s\", pfx, sdbkv_key (kv));\n\t\t\t\t\tr_line_completion_push (completion, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if ((!strncmp (buf->data, \"afvn \", 5))\n\t|| (!strncmp (buf->data, \"afan \", 5))) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tRList *vars;\n\t\tif (!strncmp (buf->data, \"afvn \", 5)) {\n\t\t\tvars = r_anal_var_list (core->anal, fcn, R_ANAL_VAR_KIND_BPV);\n\t\t} else {\n\t\t\tvars = r_anal_var_list (core->anal, fcn, R_ANAL_VAR_KIND_ARG);\n\t\t}\n\t\tconst char *f_ptr, *l_ptr;\n\t\tRAnalVar *var;\n\t\tint len = strlen (buf->data);\n\n\t\tf_ptr = r_sub_str_lchr (buf->data, 0, buf->index, ' ');\n\t\tf_ptr = f_ptr != NULL ? f_ptr + 1 : buf->data;\n\t\tl_ptr = r_sub_str_rchr (buf->data, buf->index, len, ' ');\n\t\tif (!l_ptr) {\n\t\t\tl_ptr = buf->data + len;\n\t\t}\n\t\tRListIter *iter;\n\t\tr_list_foreach (vars, iter, var) {\n\t\t\tif (!strncmp (f_ptr, var->name, l_ptr - f_ptr)) {\n\t\t\t\tr_line_completion_push (completion, var->name);\n\t\t\t}\n\t\t}\n\t\tr_list_free (vars);\n\t} else if (!strncmp (buf->data, \"t \", 2)\n\t|| !strncmp (buf->data, \"t- \", 3)) {\n\t\tSdbList *l = sdb_foreach_list (core->anal->sdb_types, true);\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tint chr = (buf->data[1] == ' ')? 2: 3;\n\t\tls_foreach (l, iter, kv) {\n\t\t\tint len = strlen (buf->data + chr);\n\t\t\tif (!len || !strncmp (buf->data + chr, sdbkv_key (kv), len)) {\n\t\t\t\tif (!strcmp (sdbkv_value (kv), \"type\") || !strcmp (sdbkv_value (kv), \"enum\")\n\t\t\t\t|| !strcmp (sdbkv_value (kv), \"struct\")) {\n\t\t\t\t\tr_line_completion_push (completion, sdbkv_key (kv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls_free (l);\n\t} else if ((!strncmp (buf->data, \"te \", 3))) {\n\t\tSdbList *l = sdb_foreach_list (core->anal->sdb_types, true);\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tint chr = 3;\n\t\tls_foreach (l, iter, kv) {\n\t\t\tint len = strlen (buf->data + chr);\n\t\t\tif (!len || !strncmp (buf->data + chr, sdbkv_key (kv), len)) {\n\t\t\t\tif (!strcmp (sdbkv_value (kv), \"enum\")) {\n\t\t\t\t\tr_line_completion_push (completion, sdbkv_key (kv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls_free (l);\n\t} else if (!strncmp (buf->data, \"$\", 1)) {\n\t\tint i;\n\t\tfor (i = 0; i < core->rcmd->aliases.count; i++) {\n\t\t\tconst char *key = core->rcmd->aliases.keys[i];\n\t\t\tint len = strlen (buf->data);\n\t\t\tif (!len || !strncmp (buf->data, key, len)) {\n\t\t\t\tr_line_completion_push (completion, key);\n\t\t\t}\n\t\t}\n\t} else if (!strncmp (buf->data, \"ts \", 3)\n\t|| !strncmp (buf->data, \"ta \", 3)\n\t|| !strncmp (buf->data, \"tp \", 3)\n\t|| !strncmp (buf->data, \"tl \", 3)\n\t|| !strncmp (buf->data, \"tpx \", 4)\n\t|| !strncmp (buf->data, \"tss \", 4)\n\t|| !strncmp (buf->data, \"ts* \", 4)) {\n\t\tSdbList *l = sdb_foreach_list (core->anal->sdb_types, true);\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tint chr = (buf->data[2] == ' ')? 3: 4;\n\t\tls_foreach (l, iter, kv) {\n\t\t\tint len = strlen (buf->data + chr);\n\t\t\tconst char *key = sdbkv_key (kv);\n\t\t\tif (!len || !strncmp (buf->data + chr, key, len)) {\n\t\t\t\tif (!strncmp (sdbkv_value (kv), \"struct\", strlen (\"struct\") + 1)) {\n\t\t\t\t\tr_line_completion_push (completion, key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls_free (l);\n\t} else if (!strncmp (buf->data, \"zo \", 3)\n\t|| !strncmp (buf->data, \"zoz \", 4)) {\n\t\tif (core->anal->zign_path && core->anal->zign_path[0]) {\n\t\t\tchar *zignpath = r_file_abspath (core->anal->zign_path);\n\t\t\tchar *paths[2] = { zignpath, NULL };\n\t\t\tautocompleteFilename (completion, buf, paths, 1);\n\t\t\tfree (zignpath);\n\t\t} else {\n\t\t\tautocompleteFilename (completion, buf, NULL, 1);\n\t\t}\n\t} else if (find_e_opts (core, completion, buf)) {\n\t\treturn;\n\t} else if (prompt_type == R_LINE_PROMPT_OFFSET) {\n\t\tautocomplete_flags (core, completion, buf->data);\n\t} else if (prompt_type == R_LINE_PROMPT_FILE) {\n\t\tautocomplete_file (completion, buf->data);\n\t} else if (!find_autocomplete (core, completion, buf)) {\n\t\tautocomplete_default (core, completion, buf);\n\t}\n}\n\nstatic int autocomplete(RLineCompletion *completion, RLineBuffer *buf, RLinePromptType prompt_type, void *user) {\n\tRCore *core = user;\n\tr_core_autocomplete (core, completion, buf, prompt_type);\n\treturn true;\n}\n\nR_API int r_core_fgets(char *buf, int len) {\n\tconst char *ptr;\n\tRLine *rli = r_line_singleton ();\n\tbuf[0] = '\\0';\n\tr_line_completion_set (&rli->completion, radare_argc, radare_argv);\n \trli->completion.run = autocomplete;\n \trli->completion.run_user = rli->user;\n\tptr = r_line_readline ();\n\tif (!ptr) {\n\t\treturn -1;\n\t}\n\tstrncpy (buf, ptr, len - 1);\n\tbuf[len - 1] = 0;\n\treturn strlen (buf);\n}\n\nstatic const char *r_core_print_offname(void *p, ut64 addr) {\n\tRCore *c = (RCore*)p;\n\tRFlagItem *item = r_flag_get_i (c->flags, addr);\n\treturn item ? item->name : NULL;\n}\n\nstatic int r_core_print_offsize(void *p, ut64 addr) {\n\tRCore *c = (RCore*)p;\n\tRFlagItem *item = r_flag_get_i (c->flags, addr);\n\treturn item ? item->size: -1;\n}\n\n/**\n * Disassemble one instruction at specified address.\n */\nstatic int __disasm(void *_core, ut64 addr) {\n\tRCore *core = _core;\n\tut64 prevaddr = core->offset;\n\n\tr_core_seek (core, addr, true);\n\tint len = r_core_print_disasm_instructions (core, 0, 1);\n\tr_core_seek (core, prevaddr, true);\n\n\treturn len;\n}\n\nstatic void update_sdb(RCore *core) {\n\tSdb *d;\n\tRBinObject *o;\n\tif (!core) {\n\t\treturn;\n\t}\n\t//SDB// anal/\n\tif (core->anal && core->anal->sdb) {\n\t\tsdb_ns_set (DB, \"anal\", core->anal->sdb);\n\t}\n\t//SDB// bin/\n\tif (core->bin && core->bin->sdb) {\n\t\tsdb_ns_set (DB, \"bin\", core->bin->sdb);\n\t}\n\t//SDB// bin/info\n\to = r_bin_cur_object (core->bin);\n\tif (o) {\n\t\tsdb_ns_set (sdb_ns (DB, \"bin\", 1), \"info\", o->kv);\n\t}\n\t//sdb_ns_set (core->sdb, \"flags\", core->flags->sdb);\n\t//sdb_ns_set (core->sdb, \"bin\", core->bin->sdb);\n\t//SDB// syscall/\n\tif (core->assembler && core->assembler->syscall && core->assembler->syscall->db) {\n\t\tcore->assembler->syscall->db->refs++;\n\t\tsdb_ns_set (DB, \"syscall\", core->assembler->syscall->db);\n\t}\n\td = sdb_ns (DB, \"debug\", 1);\n\tif (core->dbg->sgnls) {\n\t\tcore->dbg->sgnls->refs++;\n\t\tsdb_ns_set (d, \"signals\", core->dbg->sgnls);\n\t}\n}\n\n#define MINLEN 1\nstatic int is_string (const ut8 *buf, int size, int *len) {\n\tint i;\n\tif (size < 1) {\n\t\treturn 0;\n\t}\n\tif (size > 3 && buf[0] && !buf[1] && buf[2] && !buf[3]) {\n\t\t*len = 1; // XXX: TODO: Measure wide string length\n\t\treturn 2; // is wide\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\tif (!buf[i] && i > MINLEN) {\n\t\t\t*len = i;\n\t\t\treturn 1;\n\t\t}\n\t\tif (buf[i] == 10|| buf[i] == 13|| buf[i] == 9) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] < 32 || buf[i] > 127) {\n\t\t\t// not ascii text\n\t\t\treturn 0;\n\t\t}\n\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t*len = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*len = i;\n\treturn 1;\n}\n\nstatic char *r_core_anal_hasrefs_to_depth(RCore *core, ut64 value, int depth);\nR_API char *r_core_anal_hasrefs(RCore *core, ut64 value, bool verbose) {\n\tif (verbose) {\n\t\tconst int hex_depth = r_config_get_i (core->config, \"hex.depth\");\n\t\treturn r_core_anal_hasrefs_to_depth (core, value, hex_depth);\n\t}\n\tRFlagItem *fi = r_flag_get_i (core->flags, value);\n\treturn fi? strdup (fi->name): NULL;\n}\n\nstatic char *r_core_anal_hasrefs_to_depth(RCore *core, ut64 value, int depth) {\n\tr_return_val_if_fail (core, NULL);\n\tif (depth < 1 || value == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRStrBuf *s = r_strbuf_new (NULL);\n\tchar *mapname = NULL;\n\tRFlagItem *fi = r_flag_get_i (core->flags, value);\n\tut64 type = r_core_anal_address (core, value);\n\tif (value && value != UT64_MAX) {\n\t\tRDebugMap *map = r_debug_map_get (core->dbg, value);\n\t\tif (map && map->name && map->name[0]) {\n\t\t\tmapname = strdup (map->name);\n\t\t}\n\t}\n\tif (mapname) {\n\t\tr_strbuf_appendf (s, \" (%s)\", mapname);\n\t\tR_FREE (mapname);\n\t}\n\tint bits = core->assembler->bits;\n\tswitch (bits) {\n\tcase 16: // umf, not in sync with pxr\n\t\t{\n\t\t\tst16 v = (st16)(value & UT16_MAX);\n\t\t\tst16 h = UT16_MAX / 0x100;\n\t\t\tif (v > -h && v < h) {\n\t\t\t\tr_strbuf_appendf (s,\" %hd\", v);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\t{\n\t\t\tst32 v = (st32)(value & 0xffffffff);\n\t\t\tst32 h = UT32_MAX / 0x10000;\n\t\t\tif (v > -h && v < h) {\n\t\t\t\tr_strbuf_appendf (s,\" %d\", v);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 64:\n\t\t{\n\t\t\tst64 v = (st64)(value);\n\t\t\tst64 h = UT64_MAX / 0x1000000;\n\t\t\tif (v > -h && v < h) {\n\t\t\t\tr_strbuf_appendf (s,\" %\"PFMT64d, v);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tRBinSection *sect = value? r_bin_get_section_at (r_bin_cur_object (core->bin), value, true): NULL;\n\tif(! ((type&R_ANAL_ADDR_TYPE_HEAP)||(type&R_ANAL_ADDR_TYPE_STACK)) ) {\n\t\t// Do not repeat \"stack\" or \"heap\" words unnecessarily.\n\t\tif (sect && sect->name[0]) {\n\t\t\tr_strbuf_appendf (s,\" (%s)\", sect->name);\n\t\t}\n\t}\n\tif (fi) {\n\t\tRRegItem *r = r_reg_get (core->dbg->reg, fi->name, -1);\n\t\tif (!r) {\n\t\t\tr_strbuf_appendf (s, \" %s\", fi->name);\n\t\t}\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, value, 0);\n\tif (fcn) {\n\t\tr_strbuf_appendf (s, \" %s\", fcn->name);\n\t}\n\tif (type) {\n\t\tconst char *c = r_core_anal_optype_colorfor (core, value, true);\n\t\tconst char *cend = (c && *c) ? Color_RESET: \"\";\n\t\tif (!c) {\n\t\t\tc = \"\";\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP) {\n\t\t\tr_strbuf_appendf (s, \" %sheap%s\", c, cend);\n\t\t} else if (type & R_ANAL_ADDR_TYPE_STACK) {\n\t\t\tr_strbuf_appendf (s, \" %sstack%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM) {\n\t\t\tr_strbuf_appendf (s, \" %sprogram%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY) {\n\t\t\tr_strbuf_appendf (s, \" %slibrary%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII) {\n\t\t\tr_strbuf_appendf (s, \" %sascii%s ('%c')\", c, cend, value);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE) {\n\t\t\tr_strbuf_appendf (s, \" %ssequence%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_READ) {\n\t\t\tr_strbuf_appendf (s, \" %sR%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE) {\n\t\t\tr_strbuf_appendf (s, \" %sW%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC) {\n\t\t\tRAsmOp op;\n\t\t\tut8 buf[32];\n\t\t\tr_strbuf_appendf (s, \" %sX%s\", c, cend);\n\t\t\t/* instruction disassembly */\n\t\t\tr_io_read_at (core->io, value, buf, sizeof (buf));\n\t\t\tr_asm_set_pc (core->assembler, value);\n\t\t\tr_asm_disassemble (core->assembler, &op, buf, sizeof (buf));\n\t\t\tr_strbuf_appendf (s, \" '%s'\", r_asm_op_get_asm (&op));\n\t\t\t/* get library name */\n\t\t\t{ // NOTE: dup for mapname?\n\t\t\t\tRDebugMap *map;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (core->dbg->maps, iter, map) {\n\t\t\t\t\tif ((value >= map->addr) &&\n\t\t\t\t\t\t(value<map->addr_end)) {\n\t\t\t\t\t\tconst char *lastslash = r_str_lchr (map->name, '/');\n\t\t\t\t\t\tr_strbuf_appendf (s, \" '%s'\", lastslash?\n\t\t\t\t\t\t\tlastslash+1:map->name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type & R_ANAL_ADDR_TYPE_READ) {\n\t\t\tut8 buf[32];\n\t\t\tut32 *n32 = (ut32 *)buf;\n\t\t\tut64 *n64 = (ut64*)buf;\n\t\t\tr_io_read_at (core->io, value, buf, sizeof (buf));\n\t\t\tut64 n = (core->assembler->bits == 64)? *n64: *n32;\n\t\t\tr_strbuf_appendf (s, \" 0x%\"PFMT64x, n);\n\t\t}\n\t}\n\t{\n\t\tut8 buf[128], widebuf[256];\n\t\tconst char *c = r_config_get_i (core->config, \"scr.color\")? core->cons->context->pal.ai_ascii: \"\";\n\t\tconst char *cend = (c && *c) ? Color_RESET: \"\";\n\t\tint len, r;\n\t\tif (r_io_read_at (core->io, value, buf, sizeof (buf))) {\n\t\t\tbuf[sizeof (buf) - 1] = 0;\n\t\t\tswitch (is_string (buf, sizeof(buf), &len)) {\n\t\t\tcase 1:\n\t\t\t\tr_strbuf_appendf (s, \" (%s%s%s)\", c, buf, cend);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tr = r_utf8_encode_str ((const RRune *)buf, widebuf,\n\t\t\t\t\t\t       sizeof (widebuf) - 1);\n\t\t\t\tif (r == -1) {\n\t\t\t\t\teprintf (\"Something was wrong with refs\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (s, \" (%s%s%s)\", c, widebuf, cend);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\tif ((type & R_ANAL_ADDR_TYPE_READ) && !(type & R_ANAL_ADDR_TYPE_EXEC) && depth) {\n\t\t// Try to telescope further, but only several levels deep.\n\t\tut8 buf[32];\n\t\tut32 *n32 = (ut32 *)buf;\n\t\tut64 *n64 = (ut64*)buf;\n\t\tr_io_read_at (core->io, value, buf, sizeof (buf));\n\t\tut64 n = (core->assembler->bits == 64)? *n64: *n32;\n\t\tif(n != value) {\n\t\t\tchar* rrstr = r_core_anal_hasrefs_to_depth (core, n, depth-1);\n\t\t\tif (rrstr) {\n\t\t\t\tif (rrstr[0]) {\n\t\t\t\t\tr_strbuf_appendf (s, \" --> %s\", rrstr);\n\t\t\t\t}\n\t\t\t\tfree (rrstr);\n\t\t\t}\n\t\t}\n\t}\n\tfree (mapname);\n\treturn r_strbuf_drain (s);\n}\n\nR_API char *r_core_anal_get_comments(RCore *core, ut64 addr) {\n\tif (core) {\n\t\tchar *type = r_meta_get_string (core->anal, R_META_TYPE_VARTYPE, addr);\n\t\tchar *cmt = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\tif (type && cmt) {\n\t\t\tchar *ret = r_str_newf (\"%s %s\", type, cmt);\n\t\t\tfree (type);\n\t\t\tfree (cmt);\n\t\t\treturn ret;\n\t\t} else if (type) {\n\t\t\treturn type;\n\t\t} else if (cmt) {\n\t\t\treturn cmt;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_core_anal_optype_colorfor(RCore *core, ut64 addr, bool verbose) {\n\tut64 type;\n\tif (!(core->print->flags & R_PRINT_FLAGS_COLOR)) {\n\t\treturn NULL;\n\t}\n\tif (!r_config_get_i (core->config, \"scr.color\")) {\n\t\treturn NULL;\n\t}\n\ttype = r_core_anal_address (core, addr);\n\tif (type & R_ANAL_ADDR_TYPE_EXEC) {\n\t\treturn core->cons->context->pal.ai_exec; //Color_RED;\n\t}\n\tif (type & R_ANAL_ADDR_TYPE_WRITE) {\n\t\treturn core->cons->context->pal.ai_write; //Color_BLUE;\n\t}\n\tif (type & R_ANAL_ADDR_TYPE_READ) {\n\t\treturn core->cons->context->pal.ai_read; //Color_GREEN;\n\t}\n\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE) {\n\t\treturn core->cons->context->pal.ai_seq; //Color_MAGENTA;\n\t}\n\tif (type & R_ANAL_ADDR_TYPE_ASCII) {\n\t\treturn core->cons->context->pal.ai_ascii; //Color_YELLOW;\n\t}\n\treturn NULL;\n}\n\nstatic void r_core_setenv (RCore *core) {\n\tchar *e = r_sys_getenv (\"PATH\");\n\tchar *h = r_str_home (R2_HOME_BIN);\n\tchar *n = r_str_newf (\"%s%s%s\", h, R_SYS_ENVSEP, e);\n\tr_sys_setenv (\"PATH\", n);\n\tfree (n);\n\tfree (h);\n\tfree (e);\n}\n\nstatic int mywrite(const ut8 *buf, int len) {\n\treturn r_cons_memcat ((const char *)buf, len);\n}\n\nstatic bool exists_var(RPrint *print, ut64 func_addr, char *str) {\n\tchar *name_key = sdb_fmt (\"var.0x%\"PFMT64x \".%d.%s\", func_addr, 1, str);\n\tif (sdb_const_get_len (((RCore*)(print->user))->anal->sdb_fcns, name_key, NULL, 0)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool r_core_anal_log(struct r_anal_t *anal, const char *msg) {\n\tRCore *core = anal->user;\n\tif (core->cfglog) {\n\t\tr_core_log_add (core, msg);\n\t}\n\treturn true;\n}\n\nstatic bool r_core_anal_read_at(struct r_anal_t *anal, ut64 addr, ut8 *buf, int len) {\n\treturn r_io_read_at (anal->iob.io, addr, buf, len);\n}\n\nstatic void r_core_break (RCore *core) {\n}\n\nstatic void *r_core_sleep_begin (RCore *core) {\n\tRCoreTask *task = r_core_task_self (&core->tasks);\n\tif (task) {\n\t\tr_core_task_sleep_begin (task);\n\t}\n\treturn task;\n}\n\nstatic void r_core_sleep_end (RCore *core, void *user) {\n\tRCoreTask *task = (RCoreTask *)user;\n\tif (task) {\n\t\tr_core_task_sleep_end (task);\n\t}\n}\n\nstatic void __foreach(RCore *core, const char **cmds, int type) {\n\tint i;\n\tfor (i = 0; cmds[i]; i++) {\n\t\tr_core_autocomplete_add (core->autocomplete, cmds[i], type, true);\n\t}\n}\n\nstatic void __init_autocomplete_default (RCore* core) {\n\tconst char *fcns[] = {\n\t\t\"afi\", \"afcf\", \"afn\", NULL\n\t};\n\tconst char *seeks[] = {\n\t\t\"s\", NULL\n\t};\n\tconst char *flags[] = {\n\t\t\"*\", \"s\", \"s+\", \"b\", \"f\", \"fg\", \"?\", \"?v\", \"ad\", \"bf\", \"c1\", \"db\", \"dbw\",\n\t\t\"f-\", \"fr\", \"tf\", \"/a\", \"/v\", \"/r\", \"/re\", \"aav\", \"aep\", \"aef\", \"afb\",\n\t\t\"afc\", \"axg\", \"axt\", \"axf\", \"dcu\", \"ag\", \"agfl\", \"aecu\", \"aesu\", \"aeim\", NULL\n\t};\n\tconst char *evals[] = {\n\t\t\"e\", \"ee\", \"et\", \"e?\", \"e!\", \"ev\", \"evj\", NULL\n\t};\n\tconst char *breaks[] = {\n\t\t\"db-\", \"dbc\", \"dbC\", \"dbd\", \"dbe\", \"dbs\", \"dbi\", \"dbte\", \"dbtd\", \"dbts\", NULL\n\t};\n\tconst char *files[] = {\n\t\t\".\", \"..\", \".*\", \"/F\", \"/m\", \"!\", \"!!\", \"#!c\", \"#!v\", \"#!cpipe\", \"#!vala\",\n\t\t\"#!rust\", \"#!zig\", \"#!pipe\", \"#!python\", \"aeli\", \"arp\", \"dmd\", \"drp\", \"o\",\n\t\t\"idp\", \"idpi\", \"L\", \"obf\", \"o+\", \"oc\", \"r2\", \"rabin2\", \"rasm2\", \"rahash2\", \"rax2\",\n\t\t\"rafind2\", \"cd\", \"on\", \"op\", \"wf\", \"rm\", \"wF\", \"wp\", \"Sd\", \"Sl\", \"to\", \"pm\",\n\t\t\"/m\", \"zos\", \"zfd\", \"zfs\", \"zfz\", \"cat\", \"wta\", \"wtf\", \"wxf\", \"dml\", \"vi\",\n\t\t\"less\", \"head\", \"tail\", NULL\n\t};\n\tconst char *projs[] = {\n\t\t\"Pc\", \"Pd\", \"Pi\", \"Po\", \"Ps\", \"P-\", NULL\n\t};\n\tconst char *mounts[] = {\n\t\t\"md\", \"mg\", \"mo\", \"ms\", \"mc\", \"mi\", \"mw\", NULL\n\t};\n\t__foreach (core, flags, R_CORE_AUTOCMPLT_FLAG);\n\t__foreach (core, seeks, R_CORE_AUTOCMPLT_SEEK);\n\t__foreach (core, fcns, R_CORE_AUTOCMPLT_FCN);\n\t__foreach (core, evals, R_CORE_AUTOCMPLT_EVAL);\n\t__foreach (core, breaks, R_CORE_AUTOCMPLT_BRKP);\n\t__foreach (core, files, R_CORE_AUTOCMPLT_FILE);\n\t__foreach (core, projs, R_CORE_AUTOCMPLT_PRJT);\n\t__foreach (core, mounts, R_CORE_AUTOCMPLT_MS);\n\n\tr_core_autocomplete_add (core->autocomplete, \"-\", R_CORE_AUTOCMPLT_MINS, true);\n\tr_core_autocomplete_add (core->autocomplete, \"zs\", R_CORE_AUTOCMPLT_ZIGN, true);\n\tr_core_autocomplete_add (core->autocomplete, \"fs\", R_CORE_AUTOCMPLT_FLSP, true);\n\tr_core_autocomplete_add (\n\t\tr_core_autocomplete_add (core->autocomplete, \"ls\", R_CORE_AUTOCMPLT_DFLT, true),\n\t\t\"-l\", R_CORE_AUTOCMPLT_FILE, true);\n\tr_core_autocomplete_add (core->autocomplete, \"eco\", R_CORE_AUTOCMPLT_THME, true);\n\tr_core_autocomplete_add (core->autocomplete, \"k\", R_CORE_AUTOCMPLT_SDB, true);\n\t/* macros */\n\tr_core_autocomplete_add (core->autocomplete, \".(\", R_CORE_AUTOCMPLT_MACR, true);\n\tr_core_autocomplete_add (core->autocomplete, \"(-\", R_CORE_AUTOCMPLT_MACR, true);\n\t/* just for hints */\n\tint i;\n\tfor (i = 0; i < radare_argc && radare_argv[i]; i++) {\n\t\tif (!r_core_autocomplete_find (core->autocomplete, radare_argv[i], true)) {\n\t\t\tr_core_autocomplete_add (core->autocomplete, radare_argv[i], R_CORE_AUTOCMPLT_DFLT, true);\n\t\t}\n\t}\n}\n\nstatic void __init_autocomplete (RCore* core) {\n\tint i;\n\tcore->autocomplete = R_NEW0 (RCoreAutocomplete);\n\tif (core->autocomplete_type == AUTOCOMPLETE_DEFAULT) {\n\t\t__init_autocomplete_default (core);\n\t} else if (core->autocomplete_type == AUTOCOMPLETE_MS) {\n\t\tr_core_autocomplete_add (core->autocomplete, \"ls\", R_CORE_AUTOCMPLT_MS, true);\n\t\tr_core_autocomplete_add (core->autocomplete, \"cd\", R_CORE_AUTOCMPLT_MS, true);\n\t\tr_core_autocomplete_add (core->autocomplete, \"cat\", R_CORE_AUTOCMPLT_MS, true);\n\t\tr_core_autocomplete_add (core->autocomplete, \"get\", R_CORE_AUTOCMPLT_MS, true);\n\t\tr_core_autocomplete_add (core->autocomplete, \"mount\", R_CORE_AUTOCMPLT_MS, true);\n\t\tfor (i = 0; i < ms_argc && ms_argv[i]; i++) {\n\t\t\tif (!r_core_autocomplete_find (core->autocomplete, ms_argv[i], true)) {\n\t\t\t\tr_core_autocomplete_add (core->autocomplete, ms_argv[i], R_CORE_AUTOCMPLT_MS, true);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const char *colorfor_cb(void *user, ut64 addr, bool verbose) {\n\treturn r_core_anal_optype_colorfor ((RCore *)user, addr, verbose);\n}\n\nstatic char *hasrefs_cb(void *user, ut64 addr, bool verbose) {\n\treturn r_core_anal_hasrefs ((RCore *)user, addr, verbose);\n}\n\nstatic const char *get_section_name(void *user, ut64 addr) {\n\treturn r_core_get_section_name ((RCore *)user, addr);\n}\n\nstatic char *get_comments_cb(void *user, ut64 addr) {\n\treturn r_core_anal_get_comments ((RCore *)user, addr);\n}\n\nstatic void cb_event_handler(REvent *ev, int event_type, void *user, void *data) {\n\tRCore *core = (RCore *)ev->user;\n\tif (!core->log_events) {\n\t\treturn;\n\t}\n\tREventMeta *rems = data;\n\tchar *str = r_base64_encode_dyn (rems->string, -1);\n\tswitch (event_type) {\n\tcase R_EVENT_META_SET:\n\t\tswitch (rems->type) {\n\t\tcase 'C':\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":add-comment 0x%08\"PFMT64x\" %s\\n\", rems->addr, str? str: \"\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase R_EVENT_META_DEL:\n\t\tswitch (rems->type) {\n\t\tcase 'C':\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":del-comment 0x%08\"PFMT64x, rems->addr));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":del-comment 0x%08\"PFMT64x, rems->addr));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase R_EVENT_META_CLEAR:\n\t\tswitch (rems->type) {\n\t\tcase 'C':\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":clear-comments 0x%08\"PFMT64x, rems->addr));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":clear-comments 0x%08\"PFMT64x, rems->addr));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t// TODO\n\t\tbreak;\n\t}\n\tfree (str);\n}\n\nstatic RFlagItem *core_flg_class_set(RFlag *f, const char *name, ut64 addr, ut32 size) {\n\tr_flag_space_push (f, R_FLAGS_FS_CLASSES);\n\tRFlagItem *res = r_flag_set (f, name, addr, size);\n\tr_flag_space_pop (f);\n\treturn res;\n}\n\nstatic RFlagItem *core_flg_class_get(RFlag *f, const char *name) {\n\tr_flag_space_push (f, R_FLAGS_FS_CLASSES);\n\tRFlagItem *res = r_flag_get (f, name);\n\tr_flag_space_pop (f);\n\treturn res;\n}\n\nstatic RFlagItem *core_flg_fcn_set(RFlag *f, const char *name, ut64 addr, ut32 size) {\n\tr_flag_space_push (f, R_FLAGS_FS_FUNCTIONS);\n\tRFlagItem *res = r_flag_set (f, name, addr, size);\n\tr_flag_space_pop (f);\n\treturn res;\n}\n\nR_API void r_core_autocomplete_reload (RCore *core) {\n\tr_return_if_fail (core);\n\tr_core_autocomplete_free (core->autocomplete);\n\t__init_autocomplete (core);\n}\n\nR_API RFlagItem *r_core_flag_get_by_spaces(RFlag *f, ut64 off) {\n\treturn r_flag_get_by_spaces (f, off,\n\t\tR_FLAGS_FS_FUNCTIONS,\n\t\tR_FLAGS_FS_SIGNS,\n\t\tR_FLAGS_FS_CLASSES,\n\t\tR_FLAGS_FS_SYMBOLS,\n\t\tR_FLAGS_FS_IMPORTS,\n\t\tR_FLAGS_FS_RELOCS,\n\t\tR_FLAGS_FS_STRINGS,\n\t\tR_FLAGS_FS_RESOURCES,\n\t\tR_FLAGS_FS_SYMBOLS_SECTIONS,\n\t\tR_FLAGS_FS_SECTIONS,\n\t\tR_FLAGS_FS_SEGMENTS,\n\t\tNULL);\n}\n\n#if __WINDOWS__\n// XXX move to rcons?\nstatic int win_eprintf(const char *format, ...) {\n\tva_list ap;\n\tva_start (ap, format);\n\tr_cons_win_vhprintf (STD_ERROR_HANDLE, false, format, ap);\n\tva_end (ap);\n\treturn 0;\n}\n#endif\n\nR_API bool r_core_init(RCore *core) {\n\tcore->blocksize = R_CORE_BLOCKSIZE;\n\tcore->block = (ut8 *)calloc (R_CORE_BLOCKSIZE + 1, 1);\n\tif (!core->block) {\n\t\teprintf (\"Cannot allocate %d byte(s)\\n\", R_CORE_BLOCKSIZE);\n\t\t/* XXX memory leak */\n\t\treturn false;\n\t}\n\tr_core_setenv (core);\n\tcore->ev = r_event_new (core);\n\tr_event_hook (core->ev, R_EVENT_ALL, cb_event_handler, NULL);\n\tcore->max_cmd_depth = R_CONS_CMD_DEPTH + 1;\n\tcore->sdb = sdb_new (NULL, \"r2kv.sdb\", 0); // XXX: path must be in home?\n\tcore->lastsearch = NULL;\n\tcore->cmdfilter = NULL;\n\tcore->switch_file_view = 0;\n\tcore->cmdremote = 0;\n\tcore->incomment = false;\n\tcore->config = NULL;\n\tcore->http_up = false;\n\tcore->use_tree_sitter_r2cmd = false;\n\tZERO_FILL (core->root_cmd_descriptor);\n\tcore->print = r_print_new ();\n\tcore->ropchain = r_list_newf ((RListFree)free);\n\tr_core_bind (core, &(core->print->coreb));\n\tcore->print->user = core;\n\tcore->print->num = core->num;\n\tcore->print->offname = r_core_print_offname;\n\tcore->print->offsize = r_core_print_offsize;\n\tcore->print->cb_printf = r_cons_printf;\n#if __WINDOWS__\n\tcore->print->cb_eprintf = win_eprintf;\n#endif\n\tcore->print->cb_color = r_cons_rainbow_get;\n\tcore->print->write = mywrite;\n\tcore->print->exists_var = exists_var;\n\tcore->print->disasm = __disasm;\n\tcore->print->colorfor = colorfor_cb;\n\tcore->print->hasrefs = hasrefs_cb;\n\tcore->print->get_comments = get_comments_cb;\n\tcore->print->get_section_name = get_section_name;\n\tcore->print->use_comments = false;\n\tcore->rtr_n = 0;\n\tcore->blocksize_max = R_CORE_BLOCKSIZE_MAX;\n\tr_core_task_scheduler_init (&core->tasks, core);\n\tcore->watchers = r_list_new ();\n\tcore->watchers->free = (RListFree)r_core_cmpwatch_free;\n\tcore->scriptstack = r_list_new ();\n\tcore->scriptstack->free = (RListFree)free;\n\tcore->log = r_core_log_new ();\n\tcore->times = R_NEW0 (RCoreTimes);\n\tcore->vmode = false;\n\tcore->printidx = 0;\n\tcore->lastcmd = NULL;\n\tcore->cmdlog = NULL;\n\tcore->stkcmd = NULL;\n\tcore->cmdqueue = NULL;\n\tcore->cmdrepeat = true;\n\tcore->yank_buf = r_buf_new ();\n\tcore->num = r_num_new (&num_callback, &str_callback, core);\n\tcore->egg = r_egg_new ();\n\tr_egg_setup (core->egg, R_SYS_ARCH, R_SYS_BITS, 0, R_SYS_OS);\n\n\tcore->undos = r_list_newf ((RListFree)r_core_undo_free);\n\tcore->fixedarch = false;\n\tcore->fixedbits = false;\n\n\t/* initialize libraries */\n\tcore->cons = r_cons_new ();\n\tif (core->cons->refcnt == 1) {\n\t\tcore->cons = r_cons_singleton ();\n\t\tif (core->cons->line) {\n\t\t\tcore->cons->line->user = core;\n\t\t\tcore->cons->line->cb_editor = \\\n\t\t\t\t(RLineEditorCb)&r_core_editor;\n\t\t\tcore->cons->line->cb_fkey = core->cons->cb_fkey;\n\t\t}\n#if __EMSCRIPTEN__\n\t\tcore->cons->user_fgets = NULL;\n#else\n\t\tcore->cons->user_fgets = (void *)r_core_fgets;\n#endif\n\t\t//r_line_singleton ()->user = (void *)core;\n\t\tr_line_hist_load (R2_HOME_HISTORY);\n\t}\n\tcore->print->cons = core->cons;\n\tr_cons_bind (&core->print->consbind);\n\n\t// We save the old num ad user, in order to restore it after free\n\tcore->lang = r_lang_new ();\n\tcore->lang->cmd_str = (char *(*)(void *, const char *))r_core_cmd_str;\n\tcore->lang->cmdf = (int (*)(void *, const char *, ...))r_core_cmdf;\n\tr_core_bind_cons (core);\n\tcore->lang->cb_printf = r_cons_printf;\n\tr_lang_define (core->lang, \"RCore\", \"core\", core);\n\tr_lang_set_user_ptr (core->lang, core);\n\tcore->assembler = r_asm_new ();\n\tcore->assembler->num = core->num;\n\tr_asm_set_user_ptr (core->assembler, core);\n\tcore->anal = r_anal_new ();\n\tcore->gadgets = r_list_newf ((RListFree)r_core_gadget_free);\n\tcore->anal->ev = core->ev;\n\tcore->anal->log = r_core_anal_log;\n\tcore->anal->read_at = r_core_anal_read_at;\n\tcore->anal->flag_get = r_core_flag_get_by_spaces;\n\tcore->anal->cb.on_fcn_new = on_fcn_new;\n\tcore->anal->cb.on_fcn_delete = on_fcn_delete;\n\tcore->anal->cb.on_fcn_rename = on_fcn_rename;\n\tcore->print->sdb_types = core->anal->sdb_types;\n\tcore->assembler->syscall = r_syscall_ref (core->anal->syscall); // BIND syscall anal/asm\n\tr_anal_set_user_ptr (core->anal, core);\n\tcore->anal->cb_printf = (void *) r_cons_printf;\n\tcore->parser = r_parse_new ();\n\tr_anal_bind (core->anal, &(core->parser->analb));\n\tcore->parser->varlist = r_anal_var_list;\n\t/// XXX shouhld be using coreb\n\tr_parse_set_user_ptr (core->parser, core);\n\tcore->bin = r_bin_new ();\n\tr_cons_bind (&core->bin->consb);\n\t// XXX we shuold use RConsBind instead of this hardcoded pointer\n\tcore->bin->cb_printf = (PrintfCallback) r_cons_printf;\n\tr_bin_set_user_ptr (core->bin, core);\n\tcore->io = r_io_new ();\n\tcore->io->ff = 1;\n\tcore->io->user = (void *)core;\n\tcore->io->cb_core_cmd = core_cmd_callback;\n\tcore->io->cb_core_cmdstr = core_cmdstr_callback;\n\tcore->io->cb_core_post_write = core_post_write_callback;\n\tcore->search = r_search_new (R_SEARCH_KEYWORD);\n\tr_io_undo_enable (core->io, 1, 0); // TODO: configurable via eval\n\tcore->fs = r_fs_new ();\n\tcore->flags = r_flag_new ();\n\tcore->flags->cb_printf = r_cons_printf;\n\tcore->graph = r_agraph_new (r_cons_canvas_new (1, 1));\n\tcore->graph->need_reload_nodes = false;\n\tcore->asmqjmps_size = R_CORE_ASMQJMPS_NUM;\n\tif (sizeof (ut64) * core->asmqjmps_size < core->asmqjmps_size) {\n\t\tcore->asmqjmps_size = 0;\n\t\tcore->asmqjmps = NULL;\n\t} else {\n\t\tcore->asmqjmps = R_NEWS (ut64, core->asmqjmps_size);\n\t}\n\n\tr_bin_bind (core->bin, &(core->assembler->binb));\n\tr_bin_bind (core->bin, &(core->anal->binb));\n\tr_bin_bind (core->bin, &(core->anal->binb));\n\n\tr_io_bind (core->io, &(core->search->iob));\n\tr_io_bind (core->io, &(core->print->iob));\n\tr_io_bind (core->io, &(core->anal->iob));\n\tr_io_bind (core->io, &(core->fs->iob));\n\tr_cons_bind (&(core->fs->csb));\n\tr_core_bind (core, &(core->fs->cob));\n\tr_io_bind (core->io, &(core->bin->iob));\n\tr_flag_bind (core->flags, &(core->anal->flb));\n\tcore->anal->flg_class_set = core_flg_class_set;\n\tcore->anal->flg_class_get = core_flg_class_get;\n\tcore->anal->flg_fcn_set = core_flg_fcn_set;\n\tr_anal_bind (core->anal, &(core->parser->analb));\n\tcore->parser->flag_get = r_core_flag_get_by_spaces;\n\tcore->parser->label_get = r_anal_fcn_label_at;\n\n\tr_core_bind (core, &(core->anal->coreb));\n\n\tcore->file = NULL;\n\tcore->files = r_list_newf ((RListFree)r_core_file_free);\n\tcore->offset = 0LL;\n\tcore->prompt_offset = 0LL;\n\tr_core_cmd_init (core);\n\tcore->dbg = r_debug_new (true);\n\n\tr_io_bind (core->io, &(core->dbg->iob));\n\tr_io_bind (core->io, &(core->dbg->bp->iob));\n\tr_core_bind (core, &core->dbg->corebind);\n\tr_core_bind (core, &core->dbg->bp->corebind);\n\tcore->dbg->anal = core->anal; // XXX: dupped instance.. can cause lost pointerz\n\t//r_debug_use (core->dbg, \"native\");\n// XXX pushing uninitialized regstate results in trashed reg values\n//\tr_reg_arena_push (core->dbg->reg); // create a 2 level register state stack\n//\tcore->dbg->anal->reg = core->anal->reg; // XXX: dupped instance.. can cause lost pointerz\n\tcore->io->cb_printf = r_cons_printf;\n\tcore->dbg->cb_printf = r_cons_printf;\n\tcore->dbg->bp->cb_printf = r_cons_printf;\n\tcore->dbg->ev = core->ev;\n\t// initialize config before any corebind\n\tr_core_config_init (core);\n\n\tr_core_loadlibs_init (core);\n\t//r_core_loadlibs (core);\n\n\t// TODO: get arch from r_bin or from native arch\n\tr_asm_use (core->assembler, R_SYS_ARCH);\n\tr_anal_use (core->anal, R_SYS_ARCH);\n\tif (R_SYS_BITS & R_SYS_BITS_64) {\n\t\tr_config_set_i (core->config, \"asm.bits\", 64);\n\t} else {\n\t\tif (R_SYS_BITS & R_SYS_BITS_32) {\n\t\t\tr_config_set_i (core->config, \"asm.bits\", 32);\n\t\t}\n\t}\n\tr_config_set (core->config, \"asm.arch\", R_SYS_ARCH);\n\tr_bp_use (core->dbg->bp, R_SYS_ARCH, core->anal->bits);\n\tupdate_sdb (core);\n\t{\n\t\tchar *a = r_str_r2_prefix (R2_FLAGS);\n\t\tif (a) {\n\t\t\tchar *file = r_str_newf (\"%s/tags.r2\", a);\n\t\t\t(void)r_core_run_script (core, file);\n\t\t\tfree (file);\n\t\t\tfree (a);\n\t\t}\n\t}\n\tr_core_anal_type_init (core);\n\t__init_autocomplete (core);\n\treturn 0;\n}\n\nR_API void __cons_cb_fkey(RCore *core, int fkey) {\n\tchar buf[32];\n\tsnprintf (buf, sizeof (buf), \"key.f%d\", fkey);\n\tconst char *v = r_config_get (core->config, buf);\n\tif (v && *v) {\n\t\tr_cons_printf (\"%s\\n\", v);\n\t\tr_core_cmd0 (core, v);\n\t\tr_cons_flush ();\n\t}\n}\n\nR_API void r_core_bind_cons(RCore *core) {\n\tcore->cons->num = core->num;\n\tcore->cons->cb_fkey = (RConsFunctionKey)__cons_cb_fkey;\n\tcore->cons->cb_editor = (RConsEditorCallback)r_core_editor;\n\tcore->cons->cb_break = (RConsBreakCallback)r_core_break;\n\tcore->cons->cb_sleep_begin = (RConsSleepBeginCallback)r_core_sleep_begin;\n\tcore->cons->cb_sleep_end = (RConsSleepEndCallback)r_core_sleep_end;\n\tcore->cons->cb_task_oneshot = (RConsQueueTaskOneshot) r_core_task_enqueue_oneshot;\n\tcore->cons->user = (void*)core;\n}\n\nR_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\t/* TODO: it leaks as shit */\n\t//update_sdb (c);\n\t// avoid double free\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\t// TODO: sync or not? sdb_sync (c->sdb);\n\t// TODO: sync all dbs?\n\t//r_core_file_free (c->file);\n\t//c->file = NULL;\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\t/* after r_config_free, the value of I.teefile is trashed */\n\t/* rconfig doesnt knows how to deinitialize vars, so we\n\tshould probably need to add a r_config_free_payload callback */\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; // HACK\n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}\n\nR_API void r_core_free(RCore *c) {\n\tif (c) {\n\t\tr_core_fini (c);\n\t\tfree (c);\n\t}\n}\n\nR_API void r_core_prompt_loop(RCore *r) {\n\tint ret;\n\tdo {\n\t\tint err = r_core_prompt (r, false);\n\t\tif (err < 1) {\n\t\t\t// handle ^D\n\t\t\tr->num->value = 0; // r.num->value will be read by r_main_radare2() after calling this fcn\n\t\t\tbreak;\n\t\t}\n\t\t/* -1 means invalid command, -2 means quit prompt loop */\n\t\tif ((ret = r_core_prompt_exec (r)) == -2) {\n\t\t\tbreak;\n\t\t}\n\t} while (ret != R_CORE_CMD_EXIT);\n}\n\nstatic int prompt_flag (RCore *r, char *s, size_t maxlen) {\n\tconst char DOTS[] = \"...\";\n\tconst RFlagItem *f = r_flag_get_at (r->flags, r->offset, false);\n\tif (!f) {\n\t\treturn false;\n\t}\n\tif (f->offset < r->offset) {\n\t\tsnprintf (s, maxlen, \"%s + %\" PFMT64u, f->name, r->offset - f->offset);\n\t} else {\n\t\tsnprintf (s, maxlen, \"%s\", f->name);\n\t}\n\tif (strlen (s) > maxlen - sizeof (DOTS)) {\n\t\ts[maxlen - sizeof (DOTS) - 1] = '\\0';\n\t\tstrcat (s, DOTS);\n\t}\n\treturn true;\n}\n\nstatic void prompt_sec(RCore *r, char *s, size_t maxlen) {\n\tconst RBinSection *sec = r_bin_get_section_at (r_bin_cur_object (r->bin), r->offset, true);\n\tif (!sec) {\n\t\treturn;\n\t}\n\tr_str_ncpy (s, sec->name, maxlen - 2);\n\tstrcat (s, \":\");\n}\n\nstatic void chop_prompt (const char *filename, char *tmp, size_t max_tmp_size) {\n\tsize_t tmp_len, file_len;\n\tunsigned int OTHRSCH = 3;\n\tconst char DOTS[] = \"...\";\n\tint w, p_len;\n\n\tw = r_cons_get_size (NULL);\n\tfile_len = strlen (filename);\n\ttmp_len = strlen (tmp);\n\tp_len = R_MAX (0, w - 6);\n\tif (file_len + tmp_len + OTHRSCH >= p_len) {\n\t\tsize_t dots_size = sizeof (DOTS);\n\t\tsize_t chop_point = (size_t)(p_len - OTHRSCH - file_len - dots_size - 1);\n\t\tif (chop_point < (max_tmp_size - dots_size - 1)) {\n\t\t\ttmp[chop_point] = '\\0';\n\t\t\tstrncat (tmp, DOTS, dots_size);\n\t\t}\n\t}\n}\n\nstatic void set_prompt (RCore *r) {\n\tchar tmp[128];\n\tchar *filename = strdup (\"\");\n\tconst char *cmdprompt = r_config_get (r->config, \"cmd.prompt\");\n\tconst char *BEGIN = \"\";\n\tconst char *END = \"\";\n\tconst char *remote = \"\";\n\n\tif (cmdprompt && *cmdprompt) {\n\t\tr_core_cmd (r, cmdprompt, 0);\n\t}\n\n\tif (r_config_get_i (r->config, \"scr.prompt.file\")) {\n\t\tfree (filename);\n\t\tfilename = r_str_newf (\"\\\"%s\\\"\",\n\t\t\tr->io->desc ? r_file_basename (r->io->desc->name) : \"\");\n\t}\n\tif (r->cmdremote) {\n\t\tchar *s = r_core_cmd_str (r, \"s\");\n\t\tr->offset = r_num_math (NULL, s);\n\t\tfree (s);\n\t\tremote = \"=!\";\n\t}\n\n\tif (r_config_get_i (r->config, \"scr.color\")) {\n\t\tBEGIN = r->cons->context->pal.prompt;\n\t\tEND = r->cons->context->pal.reset;\n\t}\n\n\t// TODO: also in visual prompt and disasm/hexdump ?\n\tif (r_config_get_i (r->config, \"asm.segoff\")) {\n\t\tut32 a, b;\n\t\tunsigned int seggrn = r_config_get_i (r->config, \"asm.seggrn\");\n\n\t\ta = ((r->offset >> 16) << (16 - seggrn));\n\t\tb = (r->offset & 0xffff);\n\t\tsnprintf (tmp, 128, \"%04x:%04x\", a, b);\n\t} else {\n\t\tchar p[64], sec[32];\n\t\tint promptset = false;\n\n\t\tsec[0] = '\\0';\n\t\tif (r_config_get_i (r->config, \"scr.prompt.flag\")) {\n\t\t\tpromptset = prompt_flag (r, p, sizeof (p));\n\t\t}\n\t\tif (r_config_get_i (r->config, \"scr.prompt.sect\")) {\n\t\t\tprompt_sec (r, sec, sizeof (sec));\n\t\t}\n\n\t\tif (!promptset) {\n\t\t\tif (r->print->wide_offsets && r->dbg->bits & R_SYS_BITS_64) {\n\t\t\t\tsnprintf (p, sizeof (p), \"0x%016\" PFMT64x, r->offset);\n\t\t\t} else {\n\t\t\t\tsnprintf (p, sizeof (p), \"0x%08\" PFMT64x, r->offset);\n\t\t\t}\n\t\t}\n\t\tsnprintf (tmp, sizeof (tmp), \"%s%s\", sec, p);\n\t}\n\n\tchop_prompt (filename, tmp, 128);\n\tchar *prompt = r_str_newf (\"%s%s[%s%s]>%s \", filename, BEGIN, remote,\n\t\ttmp, END);\n\tr_line_set_prompt (prompt ? prompt : \"\");\n\n\tR_FREE (filename);\n\tR_FREE (prompt);\n}\n\nR_API int r_core_prompt(RCore *r, int sync) {\n\tchar line[4096];\n\n\tint rnv = r->num->value;\n\tset_prompt (r);\n\tint ret = r_cons_fgets (line, sizeof (line), 0, NULL);\n\tif (ret == -2) {\n\t\treturn R_CORE_CMD_EXIT; // ^D\n\t}\n\tif (ret == -1) {\n\t\treturn false; // FD READ ERROR\n\t}\n\tr->num->value = rnv;\n\tif (sync) {\n\t\treturn r_core_prompt_exec (r);\n\t}\n\tfree (r->cmdqueue);\n\tr->cmdqueue = strdup (line);\n        if (r->scr_gadgets && *line && *line != 'q') {\n                r_core_cmd0 (r, \"pg\");\n        }\n\tr->num->value = r->rc;\n\treturn true;\n}\n\nextern void r_core_echo(RCore *core, const char *input);\n\nR_API int r_core_prompt_exec(RCore *r) {\n\tint ret = r_core_cmd (r, r->cmdqueue, true);\n\tr->rc = r->num->value;\n\t//int ret = r_core_cmd (r, r->cmdqueue, true);\n\tif (r->cons && r->cons->use_tts) {\n\t\tconst char *buf = r_cons_get_buffer();\n\t\tr_sys_tts (buf, true);\n\t\tr->cons->use_tts = false;\n\t}\n\tr_cons_echo (NULL);\n\tr_cons_flush ();\n\tif (r->cons && r->cons->line && r->cons->line->zerosep) {\n\t\tr_cons_zero ();\n\t}\n\treturn ret;\n}\n\nR_API int r_core_seek_size(RCore *core, ut64 addr, int bsize) {\n\tut8 *bump;\n\tint ret = false;\n\tif (bsize < 0) {\n\t\treturn false;\n\t}\n\tif (bsize == core->blocksize) {\n\t\treturn true;\n\t}\n\tif (r_sandbox_enable (0)) {\n\t\t// TODO : restrict to filesize?\n\t\tif (bsize > 1024*32) {\n\t\t\teprintf (\"Sandbox mode restricts blocksize bigger than 32k\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (bsize > core->blocksize_max) {\n\t\teprintf (\"Block size %d is too big\\n\", bsize);\n\t\treturn false;\n\t}\n\tcore->offset = addr;\n\tif (bsize < 1) {\n\t\tbsize = 1;\n\t} else if (core->blocksize_max && bsize>core->blocksize_max) {\n\t\teprintf (\"bsize is bigger than `bm`. dimmed to 0x%x > 0x%x\\n\",\n\t\t\tbsize, core->blocksize_max);\n\t\tbsize = core->blocksize_max;\n\t}\n\tbump = realloc (core->block, bsize + 1);\n\tif (!bump) {\n\t\teprintf (\"Oops. cannot allocate that much (%u)\\n\", bsize);\n\t\tret = false;\n\t} else {\n\t\tret = true;\n\t\tcore->block = bump;\n\t\tcore->blocksize = bsize;\n\t\tmemset (core->block, 0xff, core->blocksize);\n\t\tr_core_block_read (core);\n\t}\n\treturn ret;\n}\n\nR_API int r_core_block_size(RCore *core, int bsize) {\n\treturn r_core_seek_size (core, core->offset, bsize);\n}\n\nR_API int r_core_seek_align(RCore *core, ut64 align, int times) {\n\tint inc = (times >= 0)? 1: -1;\n\tut64 seek = core->offset;\n\tif (!align) {\n\t\treturn false;\n\t}\n\tint diff = core->offset % align;\n\tif (!times) {\n\t\tdiff = -diff;\n\t} else if (diff) {\n\t\tif (inc > 0) {\n\t\t\tdiff += align-diff;\n\t\t} else {\n\t\t\tdiff = -diff;\n\t\t}\n\t\tif (times) {\n\t\t\ttimes -= inc;\n\t\t}\n\t}\n\twhile ((times*inc) > 0) {\n\t\ttimes -= inc;\n\t\tdiff += (align * inc);\n\t}\n\tif (diff < 0 && -diff > seek) {\n\t\tseek = diff = 0;\n\t}\n\treturn r_core_seek (core, seek + diff, 1);\n}\n\nR_API char *r_core_op_str(RCore *core, ut64 addr) {\n\tRAsmOp op = {0};\n\tut8 buf[64];\n\tr_asm_set_pc (core->assembler, addr);\n\tr_io_read_at (core->io, addr, buf, sizeof (buf));\n\tint ret = r_asm_disassemble (core->assembler, &op, buf, sizeof (buf));\n\tchar *str = (ret > 0)? strdup (r_strbuf_get (&op.buf_asm)): NULL;\n\tr_asm_op_fini (&op);\n\treturn str;\n}\n\nR_API RAnalOp *r_core_op_anal(RCore *core, ut64 addr) {\n\tut8 buf[64];\n\tRAnalOp *op = R_NEW (RAnalOp);\n\tr_io_read_at (core->io, addr, buf, sizeof (buf));\n\tr_anal_op (core->anal, op, addr, buf, sizeof (buf), R_ANAL_OP_MASK_ALL);\n\treturn op;\n}\n\nstatic void rap_break (void *u) {\n\tRIORap *rior = (RIORap*) u;\n\tif (u) {\n\t\tr_socket_close (rior->fd);\n\t\trior->fd = NULL;\n\t}\n}\n\n// TODO: PLEASE move into core/io/rap? */\n// TODO: use static buffer instead of mallocs all the time. it's network!\nR_API bool r_core_serve(RCore *core, RIODesc *file) {\n\tut8 cmd, flg, *ptr = NULL, buf[1024];\n\tint i, pipefd = -1;\n\tut64 x;\n\n\tRIORap *rior = (RIORap *)file->data;\n\tif (!rior|| !rior->fd) {\n\t\teprintf (\"rap: cannot listen.\\n\");\n\t\treturn false;\n\t}\n\tRSocket *fd = rior->fd;\n\teprintf (\"RAP Server started (rap.loop=%s)\\n\",\n\t\t\tr_config_get (core->config, \"rap.loop\"));\n\tr_cons_break_push (rap_break, rior);\nreaccept:\n\twhile (!r_cons_is_breaked ()) {\n\t\tRSocket *c = r_socket_accept (fd);\n\t\tif (!c) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tgoto out_of_function;\n\t\t}\n\t\tif (!c) {\n\t\t\teprintf (\"rap: cannot accept\\n\");\n\t\t\tr_socket_free (c);\n\t\t\tgoto out_of_function;\n\t\t}\n\t\teprintf (\"rap: client connected\\n\");\n\t\tfor (;!r_cons_is_breaked ();) {\n\t\t\tif (!r_socket_read (c, &cmd, 1)) {\n\t\t\t\teprintf (\"rap: connection closed\\n\");\n\t\t\t\tif (r_config_get_i (core->config, \"rap.loop\")) {\n\t\t\t\t\teprintf (\"rap: waiting for new connection\\n\");\n\t\t\t\t\tr_socket_free (c);\n\t\t\t\t\tgoto reaccept;\n\t\t\t\t}\n\t\t\t\tgoto out_of_function;\n\t\t\t}\n\t\t\tswitch ((ut8)cmd) {\n\t\t\tcase RMT_OPEN:\n\t\t\t\tr_socket_read_block (c, &flg, 1); // flags\n\t\t\t\teprintf (\"open (%d): \", cmd);\n\t\t\t\tr_socket_read_block (c, &cmd, 1); // len\n\t\t\t\tpipefd = -1;\n\t\t\t\tptr = malloc (cmd + 1);\n\t\t\t\t//XXX cmd is ut8..so <256 if (cmd<RMT_MAX)\n\t\t\t\tif (!ptr) {\n\t\t\t\t\teprintf (\"Cannot malloc in rmt-open len = %d\\n\", cmd);\n\t\t\t\t} else {\n\t\t\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.laddr\");\n\t\t\t\t\tr_socket_read_block (c, ptr, cmd);\n\t\t\t\t\tptr[cmd] = 0;\n\t\t\t\t\tut32 perm = R_PERM_R;\n\t\t\t\t\tif (flg & R_PERM_W) {\n\t\t\t\t\t\tperm |= R_PERM_W;\n\t\t\t\t\t}\n\t\t\t\t\tif (r_core_file_open (core, (const char *)ptr, perm, 0)) {\n\t\t\t\t\t\tint fd = r_io_fd_get_current (core->io);\n\t\t\t\t\t\tr_core_bin_load (core, NULL, baddr);\n\t\t\t\t\t\tr_io_map_add (core->io, fd, perm, 0, 0, r_io_fd_size (core->io, fd));\n\t\t\t\t\t\tif (core->file) {\n\t\t\t\t\t\t\tpipefd = fd;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpipefd = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\teprintf (\"(flags: %d) len: %d filename: '%s'\\n\",\n\t\t\t\t\t\t\tflg, cmd, ptr); //config.file);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpipefd = -1;\n\t\t\t\t\t\teprintf (\"Cannot open file (%s)\\n\", ptr);\n\t\t\t\t\t\tr_socket_close (c);\n\t\t\t\t\t\tif (r_config_get_i (core->config, \"rap.loop\")) {\n\t\t\t\t\t\t\teprintf (\"rap: waiting for new connection\\n\");\n\t\t\t\t\t\t\tr_socket_free (c);\n\t\t\t\t\t\t\tgoto reaccept;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto out_of_function; //XXX: Close connection and goto accept\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[0] = RMT_OPEN | RMT_REPLY;\n\t\t\t\tr_write_be32 (buf + 1, pipefd);\n\t\t\t\tr_socket_write (c, buf, 5);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\tR_FREE (ptr);\n\t\t\t\tbreak;\n\t\t\tcase RMT_READ:\n\t\t\t\tr_socket_read_block (c, (ut8*)&buf, 4);\n\t\t\t\ti = r_read_be32 (buf);\n\t\t\t\tptr = (ut8 *)malloc (i + core->blocksize + 5);\n\t\t\t\tif (ptr) {\n\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t\tptr[0] = RMT_READ | RMT_REPLY;\n\t\t\t\t\tif (i > RMT_MAX) {\n\t\t\t\t\t\ti = RMT_MAX;\n\t\t\t\t\t}\n\t\t\t\t\tif (i > core->blocksize) {\n\t\t\t\t\t\tr_core_block_size (core, i);\n\t\t\t\t\t}\n\t\t\t\t\tif (i + 128 < core->blocksize) {\n\t\t\t\t\t\tr_core_block_size (core, i);\n\t\t\t\t\t}\n\t\t\t\t\tr_write_be32 (ptr + 1, i);\n\t\t\t\t\tmemcpy (ptr + 5, core->block, i); //core->blocksize);\n\t\t\t\t\tr_socket_write (c, ptr, i + 5);\n\t\t\t\t\tr_socket_flush (c);\n\t\t\t\t\tR_FREE (ptr);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Cannot read %d byte(s)\\n\", i);\n\t\t\t\t\tr_socket_free (c);\n\t\t\t\t\t// TODO: reply error here\n\t\t\t\t\tgoto out_of_function;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RMT_CMD:\n\t\t\t\t{\n\t\t\t\tchar *cmd = NULL, *cmd_output = NULL;\n\t\t\t\tchar bufr[8], *bufw = NULL;\n\t\t\t\tut32 cmd_len = 0;\n\t\t\t\tint i;\n\n\t\t\t\t/* read */\n\t\t\t\tr_socket_read_block (c, (ut8*)&bufr, 4);\n\t\t\t\ti = r_read_be32 (bufr);\n\t\t\t\tif (i > 0 && i < RMT_MAX) {\n\t\t\t\t\tif ((cmd = malloc (i + 1))) {\n\t\t\t\t\t\tr_socket_read_block (c, (ut8*)cmd, i);\n\t\t\t\t\t\tcmd[i] = '\\0';\n\t\t\t\t\t\tint scr_interactive = r_config_get_i (core->config, \"scr.interactive\");\n\t\t\t\t\t\tr_config_set_i (core->config, \"scr.interactive\", 0);\n\t\t\t\t\t\tcmd_output = r_core_cmd_str (core, cmd);\n\t\t\t\t\t\tr_config_set_i (core->config, \"scr.interactive\", scr_interactive);\n\t\t\t\t\t\tfree (cmd);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"rap: cannot malloc\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"rap: invalid length '%d'\\n\", i);\n\t\t\t\t}\n\t\t\t\t/* write */\n\t\t\t\tif (cmd_output) {\n\t\t\t\t\tcmd_len = strlen (cmd_output) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcmd_output = strdup (\"\");\n\t\t\t\t\tcmd_len = 0;\n\t\t\t\t}\n#if DEMO_SERVER_SENDS_CMD_TO_CLIENT\n\t\t\t\tstatic bool once = true;\n\t\t\t\t/* TODO: server can reply a command request to the client only here */\n\t\t\t\tif (once) {\n\t\t\t\t\tconst char *cmd = \"pd 4\";\n\t\t\t\t\tint cmd_len = strlen (cmd) + 1;\n\t\t\t\t\tut8 *b = malloc (cmd_len + 5);\n\t\t\t\t\tb[0] = RMT_CMD;\n\t\t\t\t\tr_write_be32 (b + 1, cmd_len);\n\t\t\t\t\tstrcpy ((char *)b+ 5, cmd);\n\t\t\t\t\tr_socket_write (c, b, 5 + cmd_len);\n\t\t\t\t\tr_socket_flush (c);\n\n\t\t\t\t\t/* read response */\n\t\t\t\t\tr_socket_read (c, b, 5);\n\t\t\t\t\tif (b[0] == (RMT_CMD | RMT_REPLY)) {\n\t\t\t\t\t\tut32 n = r_read_be32 (b + 1);\n\t\t\t\t\t\teprintf (\"REPLY %d\\n\", n);\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tut8 *res = calloc (1, n);\n\t\t\t\t\t\t\tr_socket_read (c, res, n);\n\t\t\t\t\t\t\teprintf (\"RESPONSE(%s)\\n\", (const char *)res);\n\t\t\t\t\t\t\tfree (res);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_socket_flush (c);\n\t\t\t\t\tfree (b);\n\t\t\t\t\tonce = false;\n\t\t\t\t}\n#endif\n\t\t\t\tbufw = malloc (cmd_len + 5);\n\t\t\t\tbufw[0] = (ut8) (RMT_CMD | RMT_REPLY);\n\t\t\t\tr_write_be32 (bufw + 1, cmd_len);\n\t\t\t\tmemcpy (bufw + 5, cmd_output, cmd_len);\n\t\t\t\tr_socket_write (c, bufw, cmd_len+5);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\tfree (bufw);\n\t\t\t\tfree (cmd_output);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase RMT_WRITE:\n\t\t\t\tr_socket_read (c, buf, 4);\n\t\t\t\tx = r_read_at_be32 (buf, 0);\n\t\t\t\tptr = malloc (x);\n\t\t\t\tr_socket_read (c, ptr, x);\n\t\t\t\tint ret = r_core_write_at (core, core->offset, ptr, x);\n\t\t\t\tbuf[0] = RMT_WRITE | RMT_REPLY;\n\t\t\t\tr_write_be32 (buf + 1, ret);\n\t\t\t\tr_socket_write (c, buf, 5);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\tR_FREE (ptr);\n\t\t\t\tbreak;\n\t\t\tcase RMT_SEEK:\n\t\t\t\tr_socket_read_block (c, buf, 9);\n\t\t\t\tx = r_read_at_be64 (buf, 1);\n\t\t\t\tif (buf[0] == 2) {\n\t\t\t\t\tif (core->file) {\n\t\t\t\t\t\tx = r_io_fd_size (core->io, core->file->fd);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (buf[0] == 0) {\n\t\t\t\t\t\tr_core_seek (core, x, 1); //buf[0]);\n\t\t\t\t\t}\n\t\t\t\t\tx = core->offset;\n\t\t\t\t}\n\t\t\t\tbuf[0] = RMT_SEEK | RMT_REPLY;\n\t\t\t\tr_write_be64 (buf + 1, x);\n\t\t\t\tr_socket_write (c, buf, 9);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\tbreak;\n\t\t\tcase RMT_CLOSE:\n\t\t\t\t// XXX : proper shutdown\n\t\t\t\tr_socket_read_block (c, buf, 4);\n\t\t\t\ti = r_read_be32 (buf);\n\t\t\t\t{\n\t\t\t\t//FIXME: Use r_socket_close\n\t\t\t\tint ret = close (i);\n\t\t\t\tr_write_be32 (buf + 1, ret);\n\t\t\t\tbuf[0] = RMT_CLOSE | RMT_REPLY;\n\t\t\t\tr_socket_write (c, buf, 5);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (cmd == 'G') {\n\t\t\t\t\t// silly http emulation over rap://\n\t\t\t\t\tchar line[256] = {0};\n\t\t\t\t\tchar *cmd = line;\n\t\t\t\t\tr_socket_read (c, (ut8*)line, sizeof (line));\n\t\t\t\t\tif (!strncmp (line, \"ET /cmd/\", 8)) {\n\t\t\t\t\t\tcmd = line + 8;\n\t\t\t\t\t\tchar *http = strstr (cmd, \"HTTP\");\n\t\t\t\t\t\tif (http) {\n\t\t\t\t\t\t\t*http = 0;\n\t\t\t\t\t\t\thttp--;\n\t\t\t\t\t\t\tif (*http == ' ') {\n\t\t\t\t\t\t\t\t*http = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_str_uri_decode (cmd);\n\t\t\t\t\t\tchar *res = r_core_cmd_str (core, cmd);\n\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\tr_socket_printf (c, \"HTTP/1.0 %d %s\\r\\n%s\"\n\t\t\t\t\t\t\t\t\t\"Connection: close\\r\\nContent-Length: %d\\r\\n\\r\\n\",\n\t\t\t\t\t\t\t\t\t200, \"OK\", \"\", -1); // strlen (res));\n\t\t\t\t\t\t\tr_socket_write (c, res, strlen (res));\n\t\t\t\t\t\t\tfree (res);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_socket_flush (c);\n\t\t\t\t\t\tr_socket_close (c);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"[r2p] unknown command 0x%02x\\n\", cmd);\n\t\t\t\t\tr_socket_close (c);\n\t\t\t\t\tR_FREE (ptr);\n\t\t\t\t}\n\t\t\t\tif (r_config_get_i (core->config, \"rap.loop\")) {\n\t\t\t\t\teprintf (\"rap: waiting for new connection\\n\");\n\t\t\t\t\tr_socket_free (c);\n\t\t\t\t\tgoto reaccept;\n\t\t\t\t}\n\t\t\t\tgoto out_of_function;\n\t\t\t}\n\t\t}\n\t\teprintf (\"client: disconnected\\n\");\n\t\tr_socket_free (c);\n\t}\nout_of_function:\n\tr_cons_break_pop ();\n\treturn false;\n}\n\nR_API int r_core_search_cb(RCore *core, ut64 from, ut64 to, RCoreSearchCallback cb) {\n\tint ret, len = core->blocksize;\n\tut8 *buf;\n\tif ((buf = malloc (len))) {\n\t\twhile (from < to) {\n\t\t\tut64 delta = to-from;\n\t\t\tif (delta < len) {\n\t\t\t\tlen = (int)delta;\n\t\t\t}\n\t\t\tif (!r_io_read_at (core->io, from, buf, len)) {\n\t\t\t\teprintf (\"Cannot read at 0x%\"PFMT64x\"\\n\", from);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (ret = 0; ret < len;) {\n\t\t\t\tint done = cb (core, from, buf+ret, len-ret);\n\t\t\t\tif (done < 1) { /* interrupted */\n\t\t\t\t\tfree (buf);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tret += done;\n\t\t\t}\n\t\t\tfrom += len;\n\t\t}\n\t\tfree (buf);\n\t} else {\n\t\teprintf (\"Cannot allocate blocksize\\n\");\n\t}\n\treturn true;\n}\n\nR_API char *r_core_editor(const RCore *core, const char *file, const char *str) {\n\tconst bool interactive = r_cons_is_interactive ();\n\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n\tchar *name = NULL, *ret = NULL;\n\tint fd;\n\n\tif (!interactive || !editor || !*editor) {\n\t\treturn NULL;\n\t}\n\tbool readonly = false;\n\tif (file && *file != '*') {\n\t\tname = strdup (file);\n\t\tfd = r_sandbox_open (file, O_RDWR, 0644);\n\t\tif (fd == -1) {\n\t\t\tfd = r_sandbox_open (file, O_RDONLY, 0644);\n\t\t\treadonly = true;\n\t\t}\n\t} else {\n\t\tfd = r_file_mkstemp (file, &name);\n\t}\n\tif (fd == -1) {\n\t\tfree (name);\n\t\treturn NULL;\n\t}\n\tif (readonly) {\n\t\teprintf (\"Opening in read-only\\n\");\n\t} else {\n\t\tif (str) {\n\t\t\twrite (fd, str, strlen (str));\n\t\t}\n\t}\n\tclose (fd);\n\n\tif (name && (!editor || !*editor || !strcmp (editor, \"-\"))) {\n\t\tRCons *cons = r_cons_singleton ();\n\t\tvoid *tmp = cons->cb_editor;\n\t\tcons->cb_editor = NULL;\n\t\tr_cons_editor (name, NULL);\n\t\tcons->cb_editor = tmp;\n\t} else {\n\t\tif (editor && name) {\n\t\t\tr_sys_cmdf (\"%s '%s'\", editor, name);\n\t\t}\n\t}\n\tsize_t len = 0;\n\tret = name? r_file_slurp (name, &len): 0;\n\tif (ret) {\n\t\tif (len && ret[len - 1] == '\\n') {\n\t\t\tret[len - 1] = 0; // chop\n\t\t}\n\t\tif (!file) {\n\t\t\tr_file_rm (name);\n\t\t}\n\t}\n\tfree (name);\n\treturn ret;\n}\n\n/* weak getters */\nR_API RCons *r_core_get_cons (RCore *core) {\n\treturn core->cons;\n}\n\nR_API RConfig *r_core_get_config (RCore *core) {\n\treturn core->config;\n}\n\nR_API RBin *r_core_get_bin (RCore *core) {\n\treturn core->bin;\n}\n\nR_API RBuffer *r_core_syscallf (RCore *core, const char *name, const char *fmt, ...) {\n\tchar str[1024];\n\tRBuffer *buf;\n\tva_list ap;\n\tva_start (ap, fmt);\n\n\tvsnprintf (str, sizeof (str), fmt, ap);\n\tbuf = r_core_syscall (core, name, str);\n\n\tva_end (ap);\n\treturn buf;\n}\n\nR_API RBuffer *r_core_syscall (RCore *core, const char *name, const char *args) {\n\tRBuffer *b = NULL;\n\tchar code[1024];\n\tint num;\n\n\t//arch check\n\tif (strcmp (core->anal->cur->arch, \"x86\")) {\n\t\teprintf (\"architecture not yet supported!\\n\");\n\t\treturn 0;\n\t}\n\n\tnum = r_syscall_get_num (core->anal->syscall, name);\n\n\t//bits check\n\tswitch (core->assembler->bits) {\n\tcase 32:\n\t\tif (strcmp (name, \"setup\") && !num ) {\n\t\t\teprintf (\"syscall not found!\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase 64:\n\t\tif (strcmp (name, \"read\") && !num ) {\n\t\t\teprintf (\"syscall not found!\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"syscall not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tsnprintf (code, sizeof (code),\n\t\t\"sc@syscall(%d);\\n\"\n\t\t\"main@global(0) { sc(%s);\\n\"\n\t\t\":int3\\n\" /// XXX USE trap\n\t\t\"}\\n\", num, args);\n\tr_egg_reset (core->egg);\n\t// TODO: setup arch/bits/os?\n\tr_egg_load (core->egg, code, 0);\n\n\tif (!r_egg_compile (core->egg)) {\n\t\teprintf (\"Cannot compile.\\n\");\n\t}\n\tif (!r_egg_assemble (core->egg)) {\n\t\teprintf (\"r_egg_assemble: invalid assembly\\n\");\n\t}\n\tif ((b = r_egg_get_bin (core->egg))) {\n#if 0\n\t\tif (b->length > 0) {\n\t\t\tfor (i = 0; i < b->length; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", b->buf[i]);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\n\");\n\t\t}\n#endif\n\t}\n\treturn b;\n}\n\nR_API RCoreAutocomplete *r_core_autocomplete_add(RCoreAutocomplete *parent, const char* cmd, int type, bool lock) {\n\tif (!parent || !cmd || type < 0 || type >= R_CORE_AUTOCMPLT_END) {\n\t\treturn NULL;\n\t}\n\tRCoreAutocomplete *autocmpl = R_NEW0 (RCoreAutocomplete);\n\tif (!autocmpl) {\n\t\treturn NULL;\n\t}\n\tRCoreAutocomplete **updated = realloc (parent->subcmds, (parent->n_subcmds + 1) * sizeof (RCoreAutocomplete*));\n\tif (!updated) {\n\t\tfree (autocmpl);\n\t\treturn NULL;\n\t}\n\tparent->subcmds = updated;\n\tparent->subcmds[parent->n_subcmds] = autocmpl;\n\tparent->n_subcmds++;\n\tautocmpl->cmd = strdup (cmd);\n\tautocmpl->locked = lock;\n\tautocmpl->type = type;\n\tautocmpl->length = strlen (cmd);\n\treturn autocmpl;\n}\n\nR_API void r_core_autocomplete_free(RCoreAutocomplete *obj) {\n\tif (!obj) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; i < obj->n_subcmds; i++) {\n\t\tr_core_autocomplete_free (obj->subcmds[i]);\n\t\tobj->subcmds[i] = NULL;\n\t}\n\tfree (obj->subcmds);\n\tfree ((char*) obj->cmd);\n\tfree (obj);\n}\n\nR_API RCoreAutocomplete *r_core_autocomplete_find(RCoreAutocomplete *parent, const char* cmd, bool exact) {\n\tif (!parent || !cmd) {\n\t\treturn false;\n\t}\n\tint len = strlen (cmd);\n\tint i;\n\tfor (i = 0; i < parent->n_subcmds; i++) {\n\t\tif (exact && len == parent->subcmds[i]->length && !strncmp (cmd, parent->subcmds[i]->cmd, len)) {\n\t\t\treturn parent->subcmds[i];\n\t\t} else if (!exact && !strncmp (cmd, parent->subcmds[i]->cmd, len)) {\n\t\t\treturn parent->subcmds[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API bool r_core_autocomplete_remove(RCoreAutocomplete *parent, const char* cmd) {\n\tif (!parent || !cmd) {\n\t\treturn false;\n\t}\n\tint i, j;\n\tfor (i = 0; i < parent->n_subcmds; i++) {\n\t\tRCoreAutocomplete *ac = parent->subcmds[i];\n\t\tif (ac->locked) {\n\t\t\tcontinue;\n\t\t}\n\t\t// if (!strncmp (parent->subcmds[i]->cmd, cmd, parent->subcmds[i]->length)) {\n\t\tif (r_str_glob (ac->cmd, cmd)) {\n\t\t\tfor (j = i + 1; j < parent->n_subcmds; j++) {\n\t\t\t\tparent->subcmds[j - 1] = parent->subcmds[j];\n\t\t\t\tparent->subcmds[j] = NULL;\n\t\t\t}\n\t\t\tr_core_autocomplete_free (ac);\n\t\t\tRCoreAutocomplete **updated = realloc (parent->subcmds, (parent->n_subcmds - 1) * sizeof (RCoreAutocomplete*));\n\t\t\tif (!updated && (parent->n_subcmds - 1) > 0) {\n\t\t\t\teprintf (\"Something really bad has happen.. this should never ever happen..\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tparent->subcmds = updated;\n\t\t\tparent->n_subcmds--;\n\t\t\ti--;\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API RTable *r_core_table(RCore *core) {\n\tRTable *table = r_table_new ();\n\tif (table) {\n\t\ttable->cons = core->cons;\n\t}\n\treturn table;\n}\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2009-2020 - pancake */\n\n#include <r_core.h>\n#include <r_socket.h>\n#include <config.h>\n#include <r_util.h>\n#if __UNIX__\n#include <signal.h>\n#endif\n\n#define DB core->sdb\n\nR_LIB_VERSION(r_core);\n\nstatic ut64 letter_divs[R_CORE_ASMQJMPS_LEN_LETTERS - 1] = {\n\tR_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS,\n\tR_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS,\n\tR_CORE_ASMQJMPS_LETTERS * R_CORE_ASMQJMPS_LETTERS,\n\tR_CORE_ASMQJMPS_LETTERS\n};\n\nextern bool r_core_is_project (RCore *core, const char *name);\n\nstatic int on_fcn_new(RAnal *_anal, void* _user, RAnalFunction *fcn) {\n\tRCore *core = (RCore*)_user;\n\tconst char *cmd = r_config_get (core->config, \"cmd.fcn.new\");\n\tif (cmd && *cmd) {\n\t\tut64 oaddr = core->offset;\n\t\tut64 addr = fcn->addr;\n\t\tr_core_seek (core, addr, 1);\n\t\tr_core_cmd0 (core, cmd);\n\t\tr_core_seek (core, oaddr, 1);\n\t}\n\treturn 0;\n}\n\nstatic int on_fcn_delete (RAnal *_anal, void* _user, RAnalFunction *fcn) {\n\tRCore *core = (RCore*)_user;\n\tconst char *cmd = r_config_get (core->config, \"cmd.fcn.delete\");\n\tif (cmd && *cmd) {\n\t\tut64 oaddr = core->offset;\n\t\tut64 addr = fcn->addr;\n\t\tr_core_seek (core, addr, 1);\n\t\tr_core_cmd0 (core, cmd);\n\t\tr_core_seek (core, oaddr, 1);\n\t}\n\treturn 0;\n}\n\nstatic int on_fcn_rename(RAnal *_anal, void* _user, RAnalFunction *fcn, const char *oname) {\n\tRCore *core = (RCore*)_user;\n\tconst char *cmd = r_config_get (core->config, \"cmd.fcn.rename\");\n\tif (cmd && *cmd) {\n\t\t// XXX: wat do with old name here?\n\t\tut64 oaddr = core->offset;\n\t\tut64 addr = fcn->addr;\n\t\tr_core_seek (core, addr, 1);\n\t\tr_core_cmd0 (core, cmd);\n\t\tr_core_seek (core, oaddr, 1);\n\t}\n\treturn 0;\n}\n\nstatic void r_core_debug_breakpoint_hit(RCore *core, RBreakpointItem *bpi) {\n\tconst char *cmdbp = r_config_get (core->config, \"cmd.bp\");\n\tconst bool cmdbp_exists = (cmdbp && *cmdbp);\n\tconst bool bpcmd_exists = (bpi->data && bpi->data[0]);\n\tconst bool may_output = (cmdbp_exists || bpcmd_exists);\n\tif (may_output) {\n\t\tr_cons_push ();\n\t}\n\tif (cmdbp_exists) {\n\t\tr_core_cmd0 (core, cmdbp);\n\t}\n\tif (bpcmd_exists) {\n\t\tr_core_cmd0 (core, bpi->data);\n\t}\n\tif (may_output) {\n\t\tr_cons_flush ();\n\t\tr_cons_pop ();\n\t}\n}\n\nstatic void r_core_debug_syscall_hit(RCore *core) {\n\tconst char *cmdhit = r_config_get (core->config, \"cmd.onsyscall\");\n\n\tif (cmdhit && cmdhit[0] != 0) {\n\t\tr_core_cmd0 (core, cmdhit);\n\t\tr_cons_flush ();\n\t}\n}\n\nstruct getreloc_t {\n        ut64 vaddr;\n        int size;\n};\n\nstatic int getreloc_tree(const void *user, const RBNode *n, void *user2) {\n        struct getreloc_t *gr = (struct getreloc_t *)user;\n        const RBinReloc *r = container_of (n, const RBinReloc, vrb);\n        if ((r->vaddr >= gr->vaddr) && (r->vaddr < (gr->vaddr + gr->size))) {\n                return 0;\n        }\n\n        if (gr->vaddr > r->vaddr) {\n                return 1;\n        }\n        if (gr->vaddr < r->vaddr) {\n                return -1;\n        }\n        return 0;\n}\n\n// TODO: Use sdb in rbin to accelerate this\n// we shuold use aligned reloc addresses instead of iterating all of them\nR_API RBinReloc *r_core_getreloc(RCore *core, ut64 addr, int size) {\n        if (size < 1 || addr == UT64_MAX) {\n                return NULL;\n        }\n        RBNode *relocs = r_bin_get_relocs (core->bin);\n        if (!relocs) {\n                return NULL;\n        }\n        struct getreloc_t gr = { .vaddr = addr, .size = size };\n        RBNode *res = r_rbtree_find (relocs, &gr, getreloc_tree, NULL);\n        return res? container_of (res, RBinReloc, vrb): NULL;\n}\n\n/* returns the address of a jmp/call given a shortcut by the user or UT64_MAX\n * if there's no valid shortcut. When is_asmqjmps_letter is true, the string\n * should be of the form XYZWu, where XYZW are uppercase letters and u is a\n * lowercase one. If is_asmqjmps_letter is false, the string should be a number\n * between 1 and 9 included. */\nR_API ut64 r_core_get_asmqjmps(RCore *core, const char *str) {\n\tif (!core->asmqjmps) {\n\t\treturn UT64_MAX;\n\t}\n\tif (core->is_asmqjmps_letter) {\n\t\tint i, pos = 0;\n\t\tint len = strlen (str);\n\t\tfor (i = 0; i < len - 1; i++) {\n\t\t\tif (!isupper ((ut8)str[i])) {\n\t\t\t\treturn UT64_MAX;\n\t\t\t}\n\t\t\tpos *= R_CORE_ASMQJMPS_LETTERS;\n\t\t\tpos += str[i] - 'A' + 1;\n\t\t}\n\t\tif (!islower ((ut8)str[i])) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tpos *= R_CORE_ASMQJMPS_LETTERS;\n\t\tpos += str[i] - 'a';\n\t\tif (pos < core->asmqjmps_count) {\n\t\t\treturn core->asmqjmps[pos + 1];\n\t\t}\n\t} else if (str[0] > '0' && str[1] <= '9') {\n\t\tint pos = str[0] - '0';\n\t\tif (pos <= core->asmqjmps_count) {\n\t\t\treturn core->asmqjmps[pos];\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\n/**\n * Takes addr and returns already saved shortcut or a new one\n * The returned buffer needs to be freed\n */\nR_API char* r_core_add_asmqjmp(RCore *core, ut64 addr) {\n\tbool found = false;\n\tif (!core->asmqjmps) {\n\t\treturn NULL;\n\t}\n\tif (core->is_asmqjmps_letter) {\n\t\tif (core->asmqjmps_count >= R_CORE_ASMQJMPS_MAX_LETTERS) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (core->asmqjmps_count >= core->asmqjmps_size - 2) {\n\t\t\tcore->asmqjmps = realloc (core->asmqjmps, core->asmqjmps_size * 2 * sizeof (ut64));\n\t\t\tif (!core->asmqjmps) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcore->asmqjmps_size *= 2;\n\t\t}\n\t}\n\tif (core->asmqjmps_count < core->asmqjmps_size - 1) {\n\t\tint i = 0;\n\t\tchar t[R_CORE_ASMQJMPS_LEN_LETTERS + 1] = {0};\n\t\tfor (i = 0; i < core->asmqjmps_count + 1; i++) {\n\t\t\tif (core->asmqjmps[i] == addr) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\ti = ++core->asmqjmps_count;\n\t\t\tcore->asmqjmps[i] = addr;\n\t\t}\n\t\t// This check makes pos never be <1, thefor not fill 't' with trash\n\t\tif (i < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_core_set_asmqjmps (core, t, sizeof (t), i);\n\t\treturn strdup (t);\n\t}\n\treturn NULL;\n}\n\n/* returns in str a string that represents the shortcut to access the asmqjmp\n * at position pos. When is_asmqjmps_letter is true, pos is converted into a\n * multiletter shortcut of the form XYWZu and returned (see r_core_get_asmqjmps\n * for more info). Otherwise, the shortcut is the string representation of pos. */\nR_API void r_core_set_asmqjmps(RCore *core, char *str, size_t len, int pos) {\n\tif (core->is_asmqjmps_letter) {\n\t\tint i, j = 0;\n\t\t// if (pos > 0) {\n\t\t\tpos --;\n\t\t////  }\n\t\tfor (i = 0; i < R_CORE_ASMQJMPS_LEN_LETTERS - 1; i++) {\n\t\t\tint div = pos / letter_divs[i];\n\t\t\tpos %= letter_divs[i];\n\t\t\tif (div > 0 && j < len) {\n\t\t\t\tstr[j++] = 'A' + div - 1;\n\t\t\t}\n\t\t}\n\t\tif (j < len) {\n\t\t\tint div = pos % R_CORE_ASMQJMPS_LETTERS;\n\t\t\tstr[j++] = 'a' + div;\n\t\t}\n\t\tstr[j] = '\\0';\n\t} else {\n\t\tsnprintf (str, len, \"%d\", pos);\n\t}\n}\n\nstatic void setab(RCore *core, const char *arch, int bits) {\n\tif (arch) {\n\t\tr_config_set (core->config, \"asm.arch\", arch);\n\t}\n\tif (bits > 0) {\n\t\tr_config_set_i (core->config, \"asm.bits\", bits);\n\t}\n}\n\nstatic const char *getName(RCore *core, ut64 addr) {\n\tRFlagItem *item = r_flag_get_i (core->flags, addr);\n\tif (item) {\n\t\tif (core->flags->realnames) {\n\t\t\treturn item->realname\n\t\t\t\t? item->realname: item->name;\n\t\t}\n\t\treturn item->name;\n\t}\n\treturn NULL;\n}\n\nstatic char *getNameDelta(RCore *core, ut64 addr) {\n\tRFlagItem *item = r_flag_get_at (core->flags, addr, true);\n\tif (item) {\n\t\tif (item->offset != addr) {\n\t\t\treturn r_str_newf (\"%s + %d\", item->name, (int)(addr - item->offset));\n\t\t}\n\t\treturn strdup (item->name);\n\t}\n\treturn NULL;\n}\n\nstatic void archbits(RCore *core, ut64 addr) {\n\tr_core_seek_arch_bits (core, addr);\n}\n\nstatic int cfggeti(RCore *core, const char *k) {\n\treturn r_config_get_i (core->config, k);\n}\n\nstatic const char *cfgget(RCore *core, const char *k) {\n\treturn r_config_get (core->config, k);\n}\n\nstatic ut64 numget(RCore *core, const char *k) {\n\treturn r_num_math (core->num, k);\n}\n\nstatic bool __isMapped(RCore *core, ut64 addr, int perm) {\n\tif (r_config_get_i (core->config, \"cfg.debug\")) {\n\t\t// RList *maps = core->dbg->maps;\n\t\tRDebugMap *map = NULL;\n\t\tRListIter *iter = NULL;\n\n\t\tr_list_foreach (core->dbg->maps, iter, map) {\n\t\t\tif (addr >= map->addr && addr < map->addr_end) {\n\t\t\t\tif (perm > 0) {\n\t\t\t\t\tif (map->perm & perm) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn r_io_map_is_mapped (core->io, addr);\n}\n\nstatic bool __syncDebugMaps(RCore *core) {\n\tif (r_config_get_i (core->config, \"cfg.debug\")) {\n\t\treturn r_debug_map_sync (core->dbg);\n\t}\n\treturn false;\n}\n\nR_API int r_core_bind(RCore *core, RCoreBind *bnd) {\n\tbnd->core = core;\n\tbnd->bphit = (RCoreDebugBpHit)r_core_debug_breakpoint_hit;\n\tbnd->syshit = (RCoreDebugSyscallHit)r_core_debug_syscall_hit;\n\tbnd->cmd = (RCoreCmd)r_core_cmd0;\n\tbnd->cmdf = (RCoreCmdF)r_core_cmdf;\n\tbnd->cmdstr = (RCoreCmdStr)r_core_cmd_str;\n\tbnd->cmdstrf = (RCoreCmdStrF)r_core_cmd_strf;\n\tbnd->puts = (RCorePuts)r_cons_strcat;\n\tbnd->setab = (RCoreSetArchBits)setab;\n\tbnd->getName = (RCoreGetName)getName;\n\tbnd->getNameDelta = (RCoreGetNameDelta)getNameDelta;\n\tbnd->archbits = (RCoreSeekArchBits)archbits;\n\tbnd->cfggeti = (RCoreConfigGetI)cfggeti;\n\tbnd->cfgGet = (RCoreConfigGet)cfgget;\n\tbnd->numGet = (RCoreNumGet)numget;\n\tbnd->isMapped = (RCoreIsMapped)__isMapped;\n\tbnd->syncDebugMaps = (RCoreDebugMapsSync)__syncDebugMaps;\n\treturn true;\n}\n\nR_API RCore *r_core_ncast(ut64 p) {\n\treturn (RCore*)(size_t)p;\n}\n\nR_API RCore *r_core_cast(void *p) {\n\treturn (RCore*)p;\n}\n\nstatic void core_post_write_callback(void *user, ut64 maddr, ut8 *bytes, int cnt) {\n\tRCore *core = (RCore *)user;\n\tRBinSection *sec;\n\tut64 vaddr;\n\n\tif (!r_config_get_i (core->config, \"asm.cmt.patch\")) {\n\t\treturn;\n\t}\n\n\tchar *hex_pairs = r_hex_bin2strdup (bytes, cnt);\n\tif (!hex_pairs) {\n\t\teprintf (\"core_post_write_callback: Cannot obtain hex pairs\\n\");\n\t\treturn;\n\t}\n\n\tchar *comment = r_str_newf (\"patch: %d byte(s) (%s)\", cnt, hex_pairs);\n\tfree (hex_pairs);\n\tif (!comment) {\n\t\teprintf (\"core_post_write_callback: Cannot create comment\\n\");\n\t\treturn;\n\t}\n\n\tif ((sec = r_bin_get_section_at (r_bin_cur_object (core->bin), maddr, false))) {\n\t\tvaddr = maddr + sec->vaddr - sec->paddr;\n\t} else {\n\t\tvaddr = maddr;\n\t}\n\n\tr_meta_add (core->anal, R_META_TYPE_COMMENT, vaddr, vaddr, comment);\n\tfree (comment);\n}\n\nstatic int core_cmd_callback (void *user, const char *cmd) {\n    RCore *core = (RCore *)user;\n    return r_core_cmd0 (core, cmd);\n}\n\nstatic char *core_cmdstr_callback (void *user, const char *cmd) {\n\tRCore *core = (RCore *)user;\n\treturn r_core_cmd_str (core, cmd);\n}\n\nstatic ut64 getref (RCore *core, int n, char t, int type) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\tRListIter *iter;\n\tRAnalRef *r;\n\tRList *list;\n\tint i = 0;\n\tif (!fcn) {\n\t\treturn UT64_MAX;\n\t}\n#if FCN_OLD\n\tif (t == 'r') {\n\t\tlist = r_anal_function_get_refs (fcn);\n\t} else {\n\t\tlist = r_anal_function_get_xrefs (fcn);\n\t}\n\tr_list_foreach (list, iter, r) {\n\t\tif (r->type == type) {\n\t\t\tif (i == n) {\n\t\t\t\tut64 addr = r->addr;\n\t\t\t\tr_list_free (list);\n\t\t\t\treturn addr;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tr_list_free (list);\n#else\n#warning implement getref() using sdb\n#endif\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbInstructions(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->ninstr;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbBegin(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->addr;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbJump(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->jump;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbFail(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->fail;\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n\nstatic ut64 bbSize(RAnalFunction *fcn, ut64 addr) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (R_BETWEEN (bb->addr, addr, bb->addr + bb->size - 1)) {\n\t\t\treturn bb->size;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const char *str_callback(RNum *user, ut64 off, int *ok) {\n\tRFlag *f = (RFlag*)user;\n\tif (ok) {\n\t\t*ok = 0;\n\t}\n\tif (f) {\n\t\tRFlagItem *item = r_flag_get_i (f, off);\n\t\tif (item) {\n\t\t\tif (ok) {\n\t\t\t\t*ok = true;\n\t\t\t}\n\t\t\treturn item->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut64 num_callback(RNum *userptr, const char *str, int *ok) {\n\tRCore *core = (RCore *)userptr; // XXX ?\n\tRAnalFunction *fcn;\n\tchar *ptr, *bptr, *out = NULL;\n\tRFlagItem *flag;\n\tRBinSection *s;\n\tRAnalOp op;\n\tut64 ret = 0;\n\n\tif (ok) {\n\t\t*ok = false;\n\t}\n\tswitch (*str) {\n\tcase '.':\n\t\tif (str[1] == '.') {\n\t\t\tif (ok) {\n\t\t\t\t*ok = true;\n\t\t\t}\n\t\t\treturn r_num_tail (core->num, core->offset, str + 2);\n\t\t}\n\t\tif (core->num->nc.curr_tok == '+') {\n\t\t\tut64 off = core->num->nc.number_value.n;\n\t\t\tif (!off) {\n\t\t\t\toff = core->offset;\n\t\t\t}\n\t\t\tRAnalFunction *fcn = r_anal_get_function_at (core->anal, off);\n\t\t\tif (fcn) {\n\t\t\t\tif (ok) {\n\t\t\t\t\t*ok = true;\n\t\t\t\t}\n\t\t\t\tut64 dst = r_anal_fcn_label_get (core->anal, fcn, str + 1);\n\t\t\t\tif (dst == UT64_MAX) {\n\t\t\t\t\tdst = fcn->addr;\n\t\t\t\t}\n\t\t\t\tst64 delta = dst - off;\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\tcore->num->nc.curr_tok = '-';\n\t\t\t\t\tdelta = off - dst;\n\t\t\t\t}\n\t\t\t\treturn delta;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '[':\n{\n\t\tut64 n = 0LL;\n\t\tint refsz = core->assembler->bits / 8;\n\t\tconst char *p = NULL;\n\t\tif (strlen (str) > 5) {\n\t\t\tp = strchr (str + 5, ':');\n\t\t}\n\t\tif (p) {\n\t\t\trefsz = atoi (str + 1);\n\t\t\tstr = p;\n\t\t}\n\t\t// push state\n\t\tif (str[0] && str[1]) {\n\t\t\tconst char *q;\n\t\t\tchar *o = strdup (str + 1);\n\t\t\tif (o) {\n\t\t\t\tq = r_num_calc_index (core->num, NULL);\n\t\t\t\tif (q) {\n\t\t\t\t\tif (r_str_replace_char (o, ']', 0)>0) {\n\t\t\t\t\t\tn = r_num_math (core->num, o);\n\t\t\t\t\t\tif (core->num->nc.errors) {\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_num_calc_index (core->num, q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (o);\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t// pop state\n\t\tif (ok) {\n\t\t\t*ok = 1;\n\t\t}\n\t\tut8 buf[sizeof (ut64)] = R_EMPTY;\n\t\t(void)r_io_read_at (core->io, n, buf, R_MIN (sizeof (buf), refsz));\n\t\tswitch (refsz) {\n\t\tcase 8:\n\t\t\treturn r_read_ble64 (buf, core->print->big_endian);\n\t\tcase 4:\n\t\t\treturn r_read_ble32 (buf, core->print->big_endian);\n\t\tcase 2:\n\t\t\treturn r_read_ble16 (buf, core->print->big_endian);\n\t\tcase 1:\n\t\t\treturn r_read_ble8 (buf);\n\t\tdefault:\n\t\t\teprintf (\"Invalid reference size: %d (%s)\\n\", refsz, str);\n\t\t\treturn 0LL;\n\t\t}\n}\n\t\tbreak;\n\tcase '$':\n\t\tif (ok) {\n\t\t\t*ok = 1;\n\t\t}\n\t\t// TODO: group analop-dependant vars after a char, so i can filter\n\t\tr_anal_op (core->anal, &op, core->offset, core->block, core->blocksize, R_ANAL_OP_MASK_BASIC);\n\t\tr_anal_op_fini (&op); // we don't need strings or pointers, just values, which are not nullified in fini\n\t\tswitch (str[1]) {\n\t\tcase '.': // can use pc, sp, a0, a1, ...\n\t\t\treturn r_debug_reg_get (core->dbg, str + 2);\n\t\tcase 'k': // $k{kv}\n\t\t\tif (str[2] != '{') {\n\t\t\t\teprintf (\"Expected '{' after 'k'.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbptr = strdup (str + 3);\n\t\t\tptr = strchr (bptr, '}');\n\t\t\tif (!ptr) {\n\t\t\t\t// invalid json\n\t\t\t\tfree (bptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*ptr = '\\0';\n\t\t\tret = 0LL;\n\t\t\tout = sdb_querys (core->sdb, NULL, 0, bptr);\n\t\t\tif (out && *out) {\n\t\t\t\tif (strstr (out, \"$k{\")) {\n\t\t\t\t\teprintf (\"Recursivity is not permitted here\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tret = r_num_math (core->num, out);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (bptr);\n\t\t\tfree (out);\n\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase '{': // ${ev} eval var\n\t\t\tbptr = strdup (str + 2);\n\t\t\tptr = strchr (bptr, '}');\n\t\t\tif (ptr) {\n\t\t\t\tptr[0] = '\\0';\n\t\t\t\tut64 ret = r_config_get_i (core->config, bptr);\n\t\t\t\tfree (bptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t// take flag here\n\t\t\tfree (bptr);\n\t\t\tbreak;\n\t\tcase 'c': // $c console width\n\t\t\treturn r_cons_get_size (NULL);\n\t\tcase 'r': // $r\n\t\t\tif (str[2] == '{') {\n\t\t\t\tbptr = strdup (str + 3);\n\t\t\t\tptr = strchr (bptr, '}');\n\t\t\t\tif (!ptr) {\n\t\t\t\t\tfree (bptr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*ptr = 0;\n\t\t\t\tif (r_config_get_i (core->config, \"cfg.debug\")) {\n\t\t\t\t\tif (r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false)) {\n\t\t\t\t\t\tRRegItem *r = r_reg_get (core->dbg->reg, bptr, -1);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\tfree (bptr);\n\t\t\t\t\t\t\treturn r_reg_get_value (core->dbg->reg, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tRRegItem *r = r_reg_get (core->anal->reg, bptr, -1);\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tfree (bptr);\n\t\t\t\t\t\treturn r_reg_get_value (core->anal->reg, r);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (bptr);\n\t\t\t\treturn 0; // UT64_MAX;\n\t\t\t} else {\n\t\t\t\tint rows;\n\t\t\t\t(void)r_cons_get_size (&rows);\n\t\t\t\treturn rows;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'e': // $e\n\t\t\tif (str[2] == '{') { // $e{flag} flag off + size\n\t\t\t\tchar *flagName = strdup (str + 3);\n\t\t\t\tint flagLength = strlen (flagName);\n\t\t\t\tif (flagLength > 0) {\n\t\t\t\t\tflagName[flagLength - 1] = 0;\n\t\t\t\t}\n\t\t\t\tRFlagItem *flag = r_flag_get (core->flags, flagName);\n\t\t\t\tfree (flagName);\n\t\t\t\tif (flag) {\n\t\t\t\t\treturn flag->offset + flag->size;\n\t\t\t\t}\n\t\t\t\treturn UT64_MAX;\n\t\t\t}\n\t\t\treturn r_anal_op_is_eob (&op);\n\t\tcase 'j': // $j jump address\n\t\t\treturn op.jump;\n\t\tcase 'p': // $p\n\t\t\treturn r_sys_getpid ();\n\t\tcase 'P': // $P\n\t\t\treturn core->dbg->pid > 0 ? core->dbg->pid : 0;\n\t\tcase 'f': // $f jump fail address\n\t\t\tif (str[2] == 'l') { // $fl flag length\n\t\t\t\tRFlagItem *fi = r_flag_get_i (core->flags, core->offset);\n\t\t\t\tif (fi) {\n\t\t\t\t\treturn fi->size;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn op.fail;\n\t\tcase 'm': // $m memref\n\t\t\treturn op.ptr;\n\t\tcase 'B': // $B base address\n\t\tcase 'M': { // $M map address\n\t\t\t\tut64 lower = UT64_MAX;\n\t\t\t\tut64 size = 0LL;\n\t\t\t\tRIOMap *map = r_io_map_get (core->io, core->offset);\n\t\t\t\tif (map) {\n\t\t\t\t\tlower = r_itv_begin (map->itv);\n\t\t\t\t\tsize = r_itv_size (map->itv);\n\t\t\t\t}\n\n\t\t\t\tif (str[1] == 'B') {\n\t\t\t\t\t/* clear lower bits of the lowest map address to define the base address */\n\t\t\t\t\tconst int clear_bits = 16;\n\t\t\t\t\tlower >>= clear_bits;\n\t\t\t\t\tlower <<= clear_bits;\n\t\t\t\t}\n\t\t\t\tif (str[2] == 'M') {\n\t\t\t\t\treturn size;\n\t\t\t\t}\n\t\t\t\treturn (lower == UT64_MAX)? 0LL: lower;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v': // $v immediate value\n\t\t\treturn op.val;\n\t\tcase 'l': // $l opcode length\n\t\t\treturn op.size;\n\t\tcase 'b': // $b\n\t\t\treturn core->blocksize;\n\t\tcase 's': // $s file size\n\t\t\tif (str[2] == '{') { // $s{flag} flag size\n\t\t\t\tbptr = strdup (str + 3);\n\t\t\t\tptr = strchr (bptr, '}');\n\t\t\t\tif (!ptr) {\n\t\t\t\t\t// invalid json\n\t\t\t\t\tfree (bptr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tRFlagItem *flag = r_flag_get (core->flags, bptr);\n\t\t\t\tret = flag? flag->size: 0LL; // flag\n\t\t\t\tfree (bptr);\n\t\t\t\tfree (out);\n\t\t\t\treturn ret;\n\t\t\t} else if (core->file) {\n\t\t\t\treturn r_io_fd_size (core->io, core->file->fd);\n\t\t\t}\n\t\t\treturn 0LL;\n\t\tcase 'w': // $w word size\n\t\t\treturn r_config_get_i (core->config, \"asm.bits\") / 8;\n\t\tcase 'S': // $S section offset\n\t\t\t{\n\t\t\t\tRBinObject *bo = r_bin_cur_object (core->bin);\n\t\t\t\tif (bo && (s = r_bin_get_section_at (bo, core->offset, true))) {\n\t\t\t\t\treturn (str[2] == 'S'? s->size: s->vaddr);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0LL;\n\t\tcase 'D': // $D\n\t\t\tif (str[2] == 'B') { // $DD\n\t\t\t\treturn r_debug_get_baddr (core->dbg, NULL);\n\t\t\t} else if (IS_DIGIT (str[2])) {\n\t\t\t\treturn getref (core, atoi (str + 2), 'r', R_ANAL_REF_TYPE_DATA);\n\t\t\t} else {\n\t\t\t\tRDebugMap *map;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (core->dbg->maps, iter, map) {\n\t\t\t\t\tif (core->offset >= map->addr && core->offset < map->addr_end) {\n\t\t\t\t\t\treturn (str[2] == 'D')? map->size: map->addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0LL; // maybe // return UT64_MAX;\n\t\tcase '?': // $?\n\t\t\treturn core->num->value; // rc;\n\t\tcase '$': // $$ offset\n\t\t\treturn str[2] == '$' ? core->prompt_offset : core->offset;\n\t\tcase 'o': { // $o\n\t\t\tRBinSection *s = r_bin_get_section_at (r_bin_cur_object (core->bin), core->offset, true);\n\t\t\treturn s ? core->offset - s->vaddr + s->paddr : core->offset;\n\t\t\tbreak;\n\t\t}\n\t\tcase 'O': // $O\n\t\t\t  if (core->print->cur_enabled) {\n\t\t\t\t  return core->offset + core->print->cur;\n\t\t\t  }\n\t\t\t  return core->offset;\n\t\tcase 'C': // $C nth call\n\t\t\treturn getref (core, atoi (str + 2), 'r', R_ANAL_REF_TYPE_CALL);\n\t\tcase 'J': // $J nth jump\n\t\t\treturn getref (core, atoi (str + 2), 'r', R_ANAL_REF_TYPE_CODE);\n\t\tcase 'X': // $X nth xref\n\t\t\treturn getref (core, atoi (str + 2), 'x', R_ANAL_REF_TYPE_CALL);\n\t\tcase 'F': // $F function size\n\t\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\t\tif (fcn) {\n\t\t\t\tswitch (str[2]) {\n\t\t\t\t/* function bounds (uppercase) */\n\t\t\t\tcase 'B': return fcn->addr; // begin\n\t\t\t\tcase 'E': return r_anal_function_max_addr (fcn); // end\n\t\t\t\tcase 'S': return (str[3]=='S') ? r_anal_function_realsize (fcn) : r_anal_function_linear_size (fcn);\n\t\t\t\tcase 'I': return fcn->ninstr;\n\t\t\t\t/* basic blocks (lowercase) */\n\t\t\t\tcase 'b': return bbBegin (fcn, core->offset);\n\t\t\t\tcase 'e': return bbBegin (fcn, core->offset) + bbSize (fcn, core->offset);\n\t\t\t\tcase 'i': return bbInstructions (fcn, core->offset);\n\t\t\t\tcase 's': return bbSize (fcn, core->offset);\n\t\t\t\tcase 'j': return bbJump (fcn, core->offset); // jump\n\t\t\t\tcase 'f': return bbFail (fcn, core->offset); // fail\n\t\t\t\t}\n\t\t\t\treturn fcn->addr;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (*str >= 'A') {\n\t\t\t// NOTE: functions override flags\n\t\t\tRAnalFunction *fcn = r_anal_get_function_byname (core->anal, str);\n\t\t\tif (fcn) {\n\t\t\t\tif (ok) {\n\t\t\t\t\t*ok = true;\n\t\t\t\t}\n\t\t\t\treturn fcn->addr;\n\t\t\t}\n#if 0\n\t\t\tut64 addr = r_anal_fcn_label_get (core->anal, core->offset, str);\n\t\t\tif (addr != 0) {\n\t\t\t\tret = addr;\n\t\t\t} else {\n\t\t\t\t...\n\t\t\t}\n#endif\n\t\t\tif ((flag = r_flag_get (core->flags, str))) {\n\t\t\t\tret = flag->offset;\n\t\t\t\tif (ok) {\n\t\t\t\t\t*ok = true;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// check for reg alias\n\t\t\tstruct r_reg_item_t *r = r_reg_get (core->dbg->reg, str, -1);\n\t\t\tif (!r) {\n\t\t\t\tint role = r_reg_get_name_idx (str);\n\t\t\t\tif (role != -1) {\n\t\t\t\t\tconst char *alias = r_reg_get_name (core->dbg->reg, role);\n\t\t\t\t\tif (alias) {\n\t\t\t\t\t\tr = r_reg_get (core->dbg->reg, alias, -1);\n\t\t\t\t\t\tif (r) {\n\t\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\t\t*ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = r_reg_get_value (core->dbg->reg, r);\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ok) {\n\t\t\t\t\t*ok = true;\n\t\t\t\t}\n\t\t\t\tret = r_reg_get_value (core->dbg->reg, r);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nR_API RCore *r_core_new() {\n\tRCore *c = R_NEW0 (RCore);\n\tif (c) {\n\t\tr_core_init (c);\n\t}\n\treturn c;\n}\n\n/*-----------------------------------*/\n#define radare_argc (sizeof (radare_argv) / sizeof(const char*) - 1)\n#define ms_argc (sizeof (ms_argv) / sizeof (const char*) - 1)\nstatic const char *ms_argv[] = {\n\t\"?\", \"!\", \"ls\", \"cd\", \"cat\", \"get\", \"mount\", \"help\", \"q\", \"exit\", NULL\n};\n\nstatic const char *radare_argv[] = {\n\t\"whereis\", \"which\", \"ls\", \"rm\", \"mkdir\", \"pwd\", \"cat\", \"sort\", \"uniq\", \"join\", \"less\", \"exit\", \"quit\",\n\t\"#?\", \"#!\", \"#sha1\", \"#crc32\", \"#pcprint\", \"#sha256\", \"#sha512\", \"#md4\", \"#md5\",\n\t\"#!python\", \"#!vala\", \"#!pipe\",\n\t\"*?\", \"*\", \"$\",\n\t\"(\", \"(*\", \"(-\", \"()\", \".?\", \".\", \"..\", \"...\", \".:\", \".--\", \".-\", \".!\", \".(\", \"./\", \".*\",\n\t\"_?\", \"_\",\n\t\"=?\", \"=\", \"=<\", \"=!\", \"=+\", \"=-\", \"==\", \"=!=\", \"!=!\", \"=:\", \"=&:\",\n\t\"=g?\", \"=g\", \"=g!\", \"=h?\", \"=h\", \"=h-\", \"=h--\", \"=h*\", \"=h&\", \"=H?\", \"=H\", \"=H&\",\n\t\"<\",\n\t\"/?\", \"/\", \"/j\", \"/j!\", \"/j!x\", \"/+\", \"//\", \"/a\", \"/a1\", \"/ab\", \"/ad\", \"/aa\", \"/as\", \"/asl\", \"/at\", \"/atl\", \"/af\", \"/afl\", \"/ae\", \"/aej\", \"/ai\", \"/aij\",\n\t\"/c\", \"/ca\", \"/car\", \"/d\", \"/e\", \"/E\", \"/f\", \"/F\", \"/g\", \"/gg\", \"/h\", \"/ht\", \"/i\", \"/m\", \"/mb\", \"/mm\",\n\t\"/o\", \"/O\", \"/p\", \"/P\", \"/s\", \"/s*\", \"/r?\", \"/r\", \"/ra\", \"/rc\", \"/re\", \"/rr\", \"/rw\", \"/rc\",\n\t\"/R\",\n\t\"/v?\", \"/v\", \"/v1\", \"/v2\", \"/v4\", \"/v8\",\n\t\"/V?\", \"/V\", \"/V1\", \"/V2\", \"/V4\", \"/V8\",\n\t\"/w\", \"/wi\", \"/x\", \"/z\",\n\t\"!?\", \"!\", \"!!\", \"!!!\", \"!!!-\", \"!-\", \"!-*\", \"!=!\",\n\t\"a?\", \"a\", \"aa\", \"aa*\",\n\t\"aaa\", \"aab\", \"aac\", \"aac*\", \"aad\", \"aae\", \"aaf\", \"aaF\", \"aaFa\", \"aai\", \"aaij\", \"aan\", \"aang\", \"aao\", \"aap\",\n\t\"aar?\", \"aar\", \"aar*\", \"aarj\", \"aas\", \"aat\", \"aaT\", \"aau\", \"aav\",\n\t\"a8\", \"ab\", \"abb\",\n\t\"acl\", \"acll\", \"aclj\", \"acl*\", \"ac?\", \"ac\", \"ac-\", \"acn\", \"acv\", \"acvf\", \"acv-\", \"acb\", \"acb-\", \"acm\", \"acm-\", \"acmn\",\n\t\"aC?\", \"aC\", \"aCe\", \"ad\", \"ad4\", \"ad8\", \"adf\", \"adfg\", \"adt\", \"adk\",\n\t\"ae?\", \"ae??\", \"ae\", \"aea\", \"aeA\", \"aeaf\", \"aeAf\", \"aeC\", \"aec?\", \"aec\", \"aecs\", \"aecc\", \"aecu\", \"aecue\",\n\t\"aef\", \"aefa\",\n\t\"aei\", \"aeim\", \"aeip\", \"aek\", \"aek-\", \"aeli\", \"aelir\", \"aep?\", \"aep\", \"aep-\", \"aepc\",\n\t\"aer\", \"aets?\", \"aets\", \"aets+\", \"aes\", \"aesp\", \"aesb\", \"aeso\", \"aesou\", \"aess\", \"aesu\", \"aesue\", \"aetr\", \"aex\",\n\t\"af?\", \"af\", \"afr\", \"af+\", \"af-\",\n\t\"afa\", \"afan\",\n\t\"afb?\", \"afb\", \"afb.\", \"afb+\", \"afbb\", \"afbr\", \"afbi\", \"afbj\", \"afbe\", \"afB\", \"afbc\", \"afb=\",\n\t\"afB\", \"afC\", \"afCl\", \"afCc\", \"afc?\", \"afc\", \"afc=\", \"afcr\", \"afcrj\", \"afca\", \"afcf\", \"afcfj\",\n\t\"afck\", \"afcl\", \"afco\", \"afcR\",\n\t\"afd\", \"aff\", \"afF\", \"afi\",\n\t\"afl?\", \"afl\", \"afl+\", \"aflc\", \"aflj\", \"afll\", \"afllj\", \"aflm\", \"aflq\", \"aflqj\", \"afls\",\n\t\"afm\", \"afM\", \"afn?\", \"afna\", \"afns\", \"afnsj\", \"afl=\",\n\t\"afo\", \"afs\", \"afS\", \"aft?\", \"aft\", \"afu\",\n\t\"afv?\", \"afv\", \"afvr?\", \"afvr\", \"afvr*\", \"afvrj\", \"afvr-\", \"afvrg\", \"afvrs\",\n\t\"afvb?\", \"afvb\", \"afvbj\", \"afvb-\", \"afvbg\", \"afvbs\",\n\t\"afvs?\", \"afvs\", \"afvs*\", \"afvsj\", \"afvs-\", \"afvsg\", \"afvss\",\n\t\"afv*\", \"afvR\", \"afvW\", \"afva\", \"afvd\", \"afvn\", \"afvt\", \"afv-\", \"af*\", \"afx\",\n\t\"aF\",\n\t\"ag?\", \"ag\", \"aga\", \"agA\", \"agc\", \"agC\", \"agd\", \"agf\", \"agi\", \"agr\", \"agR\", \"agx\", \"agg\", \"ag-\",\n\t\"agn?\", \"agn\", \"agn-\", \"age?\", \"age\", \"age-\",\n\t\"agl\", \"agfl\",\n\t\"ah?\", \"ah\", \"ah.\", \"ah-\", \"ah*\", \"aha\", \"ahb\", \"ahc\", \"ahe\", \"ahf\", \"ahh\", \"ahi?\", \"ahi\", \"ahj\", \"aho\",\n\t\"ahp\", \"ahr\", \"ahs\", \"ahS\", \"aht\",\n\t\"ai\", \"aL\", \"an\",\n\t\"ao?\", \"ao\", \"aoj\", \"aoe\", \"aor\", \"aos\", \"aom\", \"aod\", \"aoda\", \"aoc\", \"ao*\",\n\t\"aO\", \"ap\",\n\t\"ar?\", \"ar\", \"ar0\", \"ara?\", \"ara\", \"ara+\", \"ara-\", \"aras\", \"arA\", \"arC\", \"arr\", \"arrj\", \"ar=\",\n\t\"arb\", \"arc\", \"ard\", \"arn\", \"aro\", \"arp?\", \"arp\", \"arpi\", \"arp.\", \"arpj\", \"arps\",\n\t\"ars\", \"art\", \"arw\",\n\t\"as?\", \"as\", \"asc\", \"asca\", \"asf\", \"asj\", \"asl\", \"ask\",\n\t\"av?\", \"av\", \"avj\", \"av*\", \"avr\", \"avra\", \"avraj\", \"avrr\", \"avrD\",\n\t\"at\",\n\t\"ax?\", \"ax\", \"ax*\", \"ax-\", \"ax-*\", \"axc\", \"axC\", \"axg\", \"axg*\", \"axgj\", \"axd\", \"axw\", \"axj\", \"axF\",\n\t\"axt\", \"axf\", \"ax.\", \"axff\", \"axffj\", \"axs\",\n\t\"b?\", \"b\", \"b+\", \"b-\", \"bf\", \"bm\",\n\t\"c?\", \"c\", \"c1\", \"c2\", \"c4\", \"c8\", \"cc\", \"ccd\", \"cf\", \"cg?\", \"cg\", \"cgf\", \"cgff\", \"cgfc\", \"cgfn\", \"cgo\",\n\t\"cu?\", \"cu\", \"cu1\", \"cu2\", \"cu4\", \"cu8\", \"cud\",\n\t\"cv\", \"cv1\", \"cv2\", \"cv4\", \"cv8\",\n\t\"cV\", \"cV1\", \"cV2\", \"cV4\", \"cV8\",\n\t\"cw?\", \"cw\", \"cw*\", \"cwr\", \"cwu\",\n\t\"cx\", \"cx*\", \"cX\",\n\t\"cl\", \"cls\", \"clear\",\n\t\"d?\", \"db \", \"db-\", \"db-*\", \"db.\", \"dbj\", \"dbc\", \"dbC\", \"dbd\", \"dbe\", \"dbs\", \"dbf\", \"dbm\", \"dbn\",\n\t\"db?\", \"dbi\", \"dbi.\", \"dbix\", \"dbic\", \"dbie\", \"dbid\", \"dbis\", \"dbite\", \"dbitd\", \"dbits\", \"dbh\", \"dbh-\",\n\t\"dbt\", \"dbt*\", \"dbt=\", \"dbtv\", \"dbtj\", \"dbta\", \"dbte\", \"dbtd\", \"dbts\", \"dbx\", \"dbw\",\n\t\"dc?\", \"dc\", \"dca\", \"dcb\", \"dcc\", \"dccu\", \"dcf\", \"dck\", \"dcp\", \"dcr\", \"dcs\", \"dcs*\", \"dct\", \"dcu\", \"dcu.\",\n\t\"dd?\", \"dd\", \"dd-\", \"dd*\", \"dds\", \"ddd\", \"ddr\", \"ddw\",\n\t\"de\",\n\t\"dg\",\n\t\"dH\",\n\t\"di?\", \"di\", \"di*\", \"diq\", \"dij\",\n\t\"dk?\", \"dk\", \"dko\", \"dkj\",\n\t\"dL?\", \"dL\", \"dLq\", \"dLj\",\n\t\"dm?\", \"dm\", \"dm=\", \"dm.\", \"dm*\", \"dm-\", \"dmd\",\n\t\"dmh?\", \"dmh\", \"dmha\", \"dmhb\", \"dmhbg\", \"dmhc\", \"dmhf\", \"dmhg\", \"dmhi\", \"dmhm\", \"dmht\",\n\t\"dmi?\", \"dmi\", \"dmi*\", \"dmi.\", \"dmiv\",\n\t\"dmj\",\n\t\"dml?\", \"dml\",\n\t\"dmm?\", \"dmm\", \"dmm*\", \"dmm.\", \"dmmj\",\n\t\"dmp?\", \"dmp\",\n\t\"dms?\", \"dms\", \"dmsj\", \"dms*\", \"dms-\", \"dmsA\", \"dmsC\", \"dmsd\", \"dmsw\", \"dmsa\", \"dmsf\", \"dmst\",\n\t\"dmS\", \"dmS*\",\n\t\"do?\", \"do\", \"dor\", \"doo\",\n\t\"dp?\", \"dp\", \"dpj\", \"dpl\", \"dplj\", \"dp-\", \"dp=\", \"dpa\", \"dpc\", \"dpc*\", \"dpe\", \"dpf\", \"dpk\", \"dpn\", \"dptn\", \"dpt\",\n\t\"dr?\", \"dr\", \"drps\", \"drpj\", \"drr\", \"drrj\", \"drs\", \"drs+\", \"drs-\", \"drt\", \"drt*\", \"drtj\", \"drw\", \"drx\", \"drx-\",\n\t\".dr*\", \".dr-\",\n\t\"ds?\", \"ds\", \"dsb\", \"dsf\", \"dsi\", \"dsl\", \"dso\", \"dsp\", \"dss\", \"dsu\", \"dsui\", \"dsuo\", \"dsue\", \"dsuf\",\n\t\"dt?\", \"dt\", \"dt%\", \"dt*\", \"dt+\", \"dt-\", \"dt=\", \"dtD\", \"dta\", \"dtc\", \"dtd\", \"dte\", \"dte-*\", \"dtei\", \"dtek\",\n\t\"dtg\", \"dtg*\", \"dtgi\",\n\t\"dtr\",\n\t\"dts?\", \"dts\", \"dts+\", \"dts-\", \"dtsf\", \"dtst\", \"dtsC\", \"dtt\",\n\t\"dw\",\n\t\"dx?\", \"dx\", \"dxa\", \"dxe\", \"dxr\", \"dxs\",\n\t\"e?\", \"e\", \"e-\", \"e*\", \"e!\", \"ec\", \"ee?\", \"ee\", \"?ed\", \"ed\", \"ej\", \"env\", \"er\", \"es\" \"et\", \"ev\", \"evj\",\n\t\"ec?\", \"ec\", \"ec*\", \"ecd\", \"ecr\", \"ecs\", \"ecj\", \"ecc\", \"eco\", \"ecp\", \"ecn\",\n\t\"ecH?\", \"ecH\", \"ecHi\", \"ecHw\", \"ecH-\",\n\t\"f?\", \"f\", \"f.\", \"f*\", \"f-\", \"f--\", \"f+\", \"f=\", \"fa\", \"fb\", \"fc?\", \"fc\", \"fC\", \"fd\", \"fe-\", \"fe\",\n\t\"ff\", \"fi\", \"fg\", \"fj\",\n\t\"fl\", \"fla\", \"fm\", \"fn\", \"fnj\", \"fo\", \"fO\", \"fr\", \"fR\", \"fR?\",\n\t\"fs?\", \"fs\", \"fs*\", \"fsj\", \"fs-\", \"fs+\", \"fs-.\", \"fsq\", \"fsm\", \"fss\", \"fss*\", \"fssj\", \"fsr\",\n\t\"ft?\", \"ft\", \"ftn\", \"fV\", \"fx\", \"fq\",\n\t\"fz?\", \"fz\", \"fz-\", \"fz.\", \"fz:\", \"fz*\",\n\t\"g?\", \"g\", \"gw\", \"gc\", \"gl?\", \"gl\", \"gs\", \"gi\", \"gp\", \"ge\", \"gr\", \"gS\",\n\t\"i?\", \"i\", \"ij\", \"iA\", \"ia\", \"ib\", \"ic\", \"icc\", \"iC\",\n\t\"id?\", \"id\", \"idp\", \"idpi\", \"idpi*\", \"idpd\", \"iD\", \"ie\", \"iee\", \"iE\", \"iE.\",\n\t\"ih\", \"iHH\", \"ii\", \"iI\", \"ik\", \"il\", \"iL\", \"im\", \"iM\", \"io\", \"iO?\", \"iO\",\n\t\"ir\", \"iR\", \"is\", \"is.\", \"iS\", \"iS.\", \"iS=\", \"iSS\",\n\t\"it\", \"iV\", \"iX\", \"iz\", \"izj\", \"izz\", \"izzz\", \"iz-\", \"iZ\",\n\t\"k?\", \"k\", \"ko\", \"kd\", \"ks\", \"kj\",\n\t\"l\",\n\t\"L?\", \"L\", \"L-\", \"Ll\", \"LL\", \"La\", \"Lc\", \"Ld\", \"Lh\", \"Li\", \"Lo\",\n\t\"m?\", \"m\", \"m*\", \"ml\", \"m-\", \"md\", \"mf?\", \"mf\", \"mg\", \"mo\", \"mi\", \"mp\", \"ms\", \"my\",\n\t\"o?\", \"o\", \"o-\", \"o--\", \"o+\", \"oa\", \"oa-\", \"oq\", \"o*\", \"o.\", \"o=\",\n\t\"ob?\", \"ob\", \"ob*\", \"obo\", \"obb\", \"oba\", \"obf\", \"obj\", \"obr\", \"ob-\", \"ob-*\",\n\t\"oc\", \"of\", \"oi\", \"oj\", \"oL\", \"om\", \"on\",\n\t\"oo?\", \"oo\", \"oo+\", \"oob\", \"ood\", \"oom\", \"oon\", \"oon+\", \"oonn\", \"oonn+\",\n\t\"op\",  \"ox\",\n\t\"p?\", \"p-\", \"p=\", \"p2\", \"p3\", \"p6?\", \"p6\", \"p6d\", \"p6e\", \"p8?\", \"p8\", \"p8f\", \"p8j\",\n\t\"pa?\", \"paD\", \"pad\", \"pade\", \"pae\", \"pA\",\n\t\"pb?\", \"pb\", \"pB\", \"pxb\", \"pB?\",\n\t\"pc?\", \"pc\", \"pc*\", \"pca\", \"pcA\", \"pcd\", \"pch\", \"pcj\", \"pcp\", \"pcs\", \"pcS\", \"pcw\",\n\t\"pC?\", \"pC\", \"pCa\", \"pCA\", \"pCc\", \"pCd\", \"pCD\", \"pCx\", \"pCw\",\n\t\"pd?\", \"pd\", \"pd--\", \"pD\", \"pda\", \"pdb\", \"pdc\", \"pdC\", \"pdf\", \"pdi\", \"pdj\", \"pdJ\",\n\t\"pdk\", \"pdl\", \"pdp\", \"pdr\", \"pdr.\", \"pdR\", \"pds?\", \"pds\", \"pdsb\", \"pdsf\", \"pdt\",\n\t\"pD\",\n\t\"pf?\", \"pf\", \"pf??\", \"pf???\", \"pf.\", \"pfj\", \"pfj.\", \"pf*\", \"pf*.\", \"pfd\", \"pfd.\",\n\t\"pfo\", \"pfq\", \"pfv\", \"pfv.\", \"pfs\", \"pfs.\",\n\t\"pF?\", \"pF\", \"pFa\", \"pFaq\", \"pFo\", \"pFp\", \"pFx\",\n\t\"pg?\", \"pg\", \"pg*\", \"pg-*\",\n\t\"ph?\", \"ph\", \"ph=\",\n\t\"pi?\", \"pi\", \"pia\", \"pib\", \"pid\", \"pie\", \"pif?\", \"pif\", \"pifc\", \"pifcj\", \"pifj\", \"pij\", \"pir\",\n\t\"pI?\", \"pI\", \"pIa\", \"pIb\", \"pId\", \"pIe\", \"pIf?\", \"pIf\", \"pIfc\", \"pIfcj\", \"pIfj\", \"pIj\",\t\"pIr\",\n\t\"pj?\", \"pj\", \"pj.\", \"pj..\",\n\t\"pk?\", \"pk\", \"pK?\", \"pK\",\n\t\"pm?\", \"pm\",\n\t\"pq?\", \"pq\", \"pqi\", \"pqz\",\n\t\"pr?\", \"pr\", \"prc\", \"prl\", \"prx\", \"prg?\", \"prg\", \"prgi\", \"prgo\", \"prz\",\n\t\"ps?\", \"ps\", \"psb\", \"psi\", \"psj\", \"psp\", \"pss\", \"psu\", \"psw\", \"psW\", \"psx\", \"psz\", \"ps+\",\n\t\"pt?\", \"pt\", \"pt.\", \"ptd\", \"pth\", \"ptn\",\n\t\"pu?\", \"pu\", \"puw\", \"pU\",\n\t\"pv?\", \"pv\", \"pv1\", \"pv2\", \"pv4\", \"pv8\", \"pvz\", \"pvj\", \"pvh\", \"pv1j\", \"pv2j\", \"pv4j\", \"pv8j\",\n\t\"pv1h\", \"pv2h\", \"pv4h\", \"pv8h\",\n\t\"px?\", \"px\", \"px/\", \"px0\", \"pxa\", \"pxA?\", \"pxA\", \"pxb\", \"pxc\", \"pxd?\", \"pxd\", \"pxd2\", \"pxd4\", \"pxd8\",\n\t\"pxe\", \"pxf\", \"pxh\", \"pxH\", \"pxi\", \"pxl\", \"pxo\", \"pxq\", \"pxq\", \"pxQ\", \"pxQq\", \"pxr\", \"pxrj\",\n\t\"pxs\", \"pxt\", \"pxt*\", \"pxt.\", \"pxw\", \"pxW\", \"pxWq\", \"pxx\", \"pxX\",\n\t\"pz?\", \"pz\", \"pzp\", \"pzf\", \"pzs\", \"pz0\", \"pzF\", \"pze\", \"pzh\",\n\t\"P?\", \"P\", \"Pc\", \"Pd\", \"Pi\", \"Pn\", \"Pnj\", \"Po\", \"Ps\", \"PS\", \"P-\",\n\t\"q?\", \"q\", \"q!\", \"q!!\", \"q!!!\", \"qy\", \"qn\", \"qyy\", \"qyn\", \"qny\", \"qnn\",\n\t\"r?\", \"r\", \"r-\", \"r+\", \"rh\",\n\t\"s?\", \"s\", \"s:\", \"s-\", \"s-*\", \"s--\", \"s+\", \"s++\", \"sj\", \"s*\", \"s=\", \"s!\", \"s/\", \"s/x\", \"s.\", \"sa\", \"sb\",\n\t\"sC?\", \"sC\", \"sC*\",\n\t\"sf\", \"sf.\", \"sg\", \"sG\", \"sl?\", \"sl\", \"sl+\", \"sl-\", \"slc\", \"sll\", \"sn\", \"sp\", \"so\", \"sr\", \"ss\",\n\t\"t?\", \"t\", \"tj\", \"t*\", \"t-\", \"t-*\", \"ta\", \"tb\", \"tc\", \"te?\", \"te\", \"tej\", \"teb\", \"tec\",\n\t\"td?\", \"td\", \"td-\", \"tf\", \"tk\", \"tl\", \"tn\", \"to\", \"tos\", \"tp\", \"tpx\", \"ts?\", \"ts\", \"tsj\", \"ts*\", \"tsc\", \"tss\",\n\t\"tu?\", \"tu\", \"tuj\", \"tu*\", \"tuc\", \"tt?\", \"tt\", \"ttj\", \"ttc\",\n\t\"T?\", \"T\", \"T*\", \"T-\", \"Tl\", \"Tj\", \"Tm\", \"Ts\", \"TT\", \"T=\", \"T=.\", \"T=&\",\n\t\"u?\", \"u\", \"uw\", \"us\", \"uc\",\n\t\"v\", \"V\", \"v!\", \"vv\", \"vV\", \"vVV\", \"VV\",\n\t\"w?\", \"w\", \"w1+\", \"w1-\", \"w2+\", \"w2-\", \"w4+\", \"w4-\", \"w8+\", \"w8-\",\n\t\"w0\", \"w\", \"w6\", \"w6d\", \"w6e\", \"wa\", \"wa*\", \"waf\", \"wao?\", \"wao\",\n\t\"wA?\", \"wA\", \"wB\", \"wB-\", \"wc\", \"wcj\", \"wc-\", \"wc+\", \"wc*\", \"wcr\", \"wci\", \"wcp\", \"wcp*\", \"wcpi\",\n\t\"wd\", \"we?\", \"we\", \"wen\", \"weN\", \"wes\", \"wex\", \"weX\",\n\t\"wf?\", \"wf\", \"wff\", \"wfs\", \"wF\", \"wh\", \"wm\",\n\t\"wo?\", \"wo\", \"wo2\", \"wo4\", \"woa\", \"woA\", \"wod\", \"woD\", \"woe\", \"woE\", \"wol\", \"wom\", \"woo\",\n\t\"wop?\", \"wop\", \"wopD\", \"wopD*\", \"wopO\",\n\t\"wp?\", \"wp\", \"wr\", \"ws\",\n\t\"wt?\", \"wt\", \"wta\", \"wtf\", \"wtf!\", \"wtff\", \"wts\",\n\t\"wu\",\n\t\"wv?\", \"wv\", \"wv1\", \"wv2\",  \"wv4\", \"wv8\",\n\t\"ww\",\n\t\"wx?\", \"wx\", \"wxf\", \"wxs\",\n\t\"wz\",\n\t\"x?\", \"x\", \"x/\", \"x0\", \"xa\", \"xA?\", \"xA\", \"xb\", \"xc\", \"xd?\", \"xd\", \"xd2\", \"xd4\", \"xd8\",\n\t\"xe\", \"xf\", \"xh\", \"xH\", \"xi\", \"xl\", \"xo\", \"xq\", \"xq\", \"xQ\", \"xQq\", \"xr\", \"xrj\",\n\t\"xs\", \"xt\", \"xt*\", \"xt.\", \"xw\", \"xW\", \"xWq\", \"xx\", \"xX\",\n\t\"y?\", \"y\", \"yz\", \"yp\", \"yx\", \"ys\", \"yt\", \"ytf\", \"yf\", \"yfa\", \"yfx\", \"yw\", \"ywx\", \"yy\",\n\t\"z?\", \"z\", \"z*\", \"zj\", \"z-\", \"z-*\",\n\t\"za?\", \"za??\", \"za\", \"zaf\", \"zaF\", \"zg\",\n\t\"zo?\", \"zo\", \"zoz\", \"zos\",\n\t\"zf?\", \"zfd\", \"zfs\", \"zfz\",\n\t\"z/?\", \"z/\", \"z/*\",\n\t\"zc\",\n\t\"zs?\", \"zs\", \"zs-\", \"zs-*\", \"zs+\", \"zsr\",\n\t\"zi\",\n\t\"?\", \"?v\", \"?$?\", \"?@?\", \"?>?\",\n\tNULL\n};\n\nstatic void autocomplete_mount_point (RLineCompletion *completion, RCore *core, const char *path) {\n\tRFSRoot *r;\n\tRListIter *iter;\n\tr_list_foreach (core->fs->roots, iter, r) {\n\t\tchar *base = strdup (r->path);\n\t\tchar *ls = (char *) r_str_lchr (base, '/');\n\t\tif (ls) {\n\t\t\tls++;\n\t\t\t*ls = 0;\n\t\t}\n\t\tif (!strcmp (path, base)) {\n\t\t\tr_line_completion_push (completion, r->path);\n\t\t}\n\t\tfree (base);\n\t}\n}\n\nstatic void autocomplete_ms_path(RLineCompletion *completion, RCore *core, const char *str, const char *path) {\n\tchar *lpath = NULL, *dirname = NULL , *basename = NULL;\n\tchar *p = NULL;\n\tchar *pwd = (core->rfs && *(core->rfs->cwd)) ? *(core->rfs->cwd): \".\";\n\tint n = 0;\n\tRList *list;\n\tRListIter *iter;\n\tRFSFile *file;\n\tr_return_if_fail (path);\n\tlpath = r_str_new (path);\n\tp = (char *)r_str_last (lpath, R_SYS_DIR);\n\tif (p) {\n\t\t*p = 0;\n\t\tif (p == lpath) { // /xxx\n\t\t\tdirname  = r_str_new (\"/\");\n\t\t} else if (lpath[0] == '.') { // ./xxx/yyy\n\t\t\tdirname = r_str_newf (\"%s%s\", pwd, R_SYS_DIR);\n\t\t} else if (lpath[0] == '/') { // /xxx/yyy\n      \t\t\tdirname = r_str_newf (\"%s%s\", lpath, R_SYS_DIR);\n    \t\t} else { // xxx/yyy\n      \t\t\tif (strlen (pwd) == 1) { // if pwd is root\n        \t\t\tdirname = r_str_newf (\"%s%s%s\", R_SYS_DIR, lpath, R_SYS_DIR);\n      \t\t\t} else {\n\t\t\t\tdirname = r_str_newf (\"%s%s%s%s\", pwd, R_SYS_DIR, lpath, R_SYS_DIR);\n      \t\t\t}\n\t\t}\n\t\tbasename = r_str_new (p + 1);\n\t} else { // xxx\n    \t\tif (strlen (pwd) == 1) {\n      \t\t\tdirname = r_str_newf (\"%s\", R_SYS_DIR);\n    \t\t} else {\n      \t\t\tdirname = r_str_newf (\"%s%s\", pwd, R_SYS_DIR);\n    \t\t}\n\t\tbasename = r_str_new (lpath);\n\t}\n\n\tif (!dirname || !basename) {\n\t\tgoto out;\n\t}\n\tlist= r_fs_dir (core->fs, dirname);\n\tn = strlen (basename);\n\tbool chgdir = !strncmp (str, \"cd  \", 3);\n\tif (list) {\n\t\tr_list_foreach (list, iter, file) {\n\t\t\tif (!file) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!basename[0] || !strncmp (file->name, basename, n))  {\n\t\t\t\tchar *tmpstring = r_str_newf (\"%s%s\", dirname, file->name);\n\t\t\t\tif (r_file_is_directory (tmpstring)) {\n\t\t\t\t\tchar *s = r_str_newf (\"%s/\", tmpstring);\n\t\t\t\t\tr_line_completion_push (completion, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t} else if (!chgdir) {\n\t\t\t\t\tr_line_completion_push (completion, tmpstring);\n\t\t\t\t}\n\t\t\t\tfree (tmpstring);\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\n\tautocomplete_mount_point (completion, core, path);\nout:\n\tfree (lpath);\n\tfree (dirname);\n\tfree (basename);\n}\n\nstatic void autocomplete_process_path(RLineCompletion *completion, const char *str, const char *path) {\n\tchar *lpath = NULL, *dirname = NULL , *basename = NULL;\n\tchar *home = NULL, *filename = NULL, *p = NULL;\n\tint n = 0;\n\tRList *list;\n\tRListIter *iter;\n\n\tif (!path) {\n\t\tgoto out;\n\t}\n\n\tlpath = r_str_new (path);\n#if __WINDOWS__\n\tr_str_replace_ch (lpath, '/', '\\\\', true);\n#endif\n\tp = (char *)r_str_last (lpath, R_SYS_DIR);\n\tif (p) {\n\t\t*p = 0;\n\t\tif (p == lpath) { // /xxx\n#if __WINDOWS__\n\t\t\tdirname = strdup (\"\\\\.\\\\\");\n#else\n\t\t\tdirname = r_str_new (R_SYS_DIR);\n#endif\n\t\t} else if (lpath[0] == '~' && lpath[1]) { // ~/xxx/yyy\n\t\t\tdirname = r_str_home (lpath + 2);\n\t\t} else if (lpath[0] == '~') { // ~/xxx\n\t\t\tif (!(home = r_str_home (NULL))) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdirname = r_str_newf (\"%s%s\", home, R_SYS_DIR);\n\t\t\tfree (home);\n\t\t} else if (lpath[0] == '.' || lpath[0] == R_SYS_DIR[0] ) { // ./xxx/yyy || /xxx/yyy\n\t\t\tdirname = r_str_newf (\"%s%s\", lpath, R_SYS_DIR);\n\t\t} else { // xxx/yyy\n\t\t\tchar *fmt = \".%s%s%s\";\n#if __WINDOWS__\n\t\t\tif (strchr (path, ':')) {\n\t\t\t\tfmt = \"%.0s%s%s\";\n\t\t\t}\n#endif\n\t\t\tdirname = r_str_newf (fmt, R_SYS_DIR, lpath, R_SYS_DIR);\n\t\t}\n\t\tbasename = r_str_new (p + 1);\n\t} else { // xxx\n\t\tdirname = r_str_newf (\".%s\", R_SYS_DIR);\n\t\tbasename = r_str_new (lpath);\n\t}\n\n\tif (!dirname || !basename) {\n\t\tgoto out;\n\t}\n\n\tlist= r_sys_dir (dirname);\n\tn = strlen (basename);\n\tbool chgdir = !strncmp (str, \"cd \", 3);\n\tif (list) {\n\t\tr_list_foreach (list, iter, filename) {\n\t\t\tif (*filename == '.') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!basename[0] || !strncmp (filename, basename, n))  {\n\t\t\t\tchar *tmpstring = r_str_newf (\"%s%s\", dirname, filename);\n\t\t\t\tif (r_file_is_directory (tmpstring)) {\n\t\t\t\t\tchar *s = r_str_newf (\"%s%s\", tmpstring, R_SYS_DIR);\n\t\t\t\t\tr_line_completion_push (completion, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t} else if (!chgdir) {\n\t\t\t\t\tr_line_completion_push (completion, tmpstring);\n\t\t\t\t}\n\t\t\t\tfree (tmpstring);\n\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\nout:\n\tfree (lpath);\n\tfree (dirname);\n\tfree (basename);\n}\n\nstatic void autocompleteFilename(RLineCompletion *completion, RLineBuffer *buf, char **extra_paths, int narg) {\n\tchar *args = NULL, *input = NULL;\n\tint n = 0, i = 0;\n\tchar *pipe = strchr (buf->data, '>');\n\tif (pipe) {\n\t\targs = r_str_new (pipe + 1);\n\t} else {\n\t\targs = r_str_new (buf->data);\n\t}\n\tif (!args) {\n\t\tgoto out;\n\t}\n\n\tn = r_str_word_set0 (args);\n\tif (n < narg) {\n\t\tgoto out;\n\t}\n\n\tinput = r_str_new (r_str_word_get0 (args, narg));\n\tif (!input) {\n\t\tgoto out;\n\t}\n\tconst char *tinput = r_str_trim_head_ro (input);\n\n\tautocomplete_process_path (completion, buf->data, tinput);\n\n\tif (input[0] == '/' || input[0] == '.' || !extra_paths) {\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; extra_paths[i]; i ++) {\n\t\tchar *s = r_str_newf (\"%s%s%s\", extra_paths[i], R_SYS_DIR, tinput);\n\t\tif (!s) {\n\t\t\tbreak;\n\t\t}\n\t\tautocomplete_process_path (completion, buf->data, s);\n\t\tfree (s);\n\t}\nout:\n\tfree (args);\n\tfree (input);\n}\n\n//TODO: make it recursive to handle nested struct\nstatic int autocomplete_pfele (RCore *core, RLineCompletion *completion, char *key, char *pfx, int idx, char *ptr) {\n\tint i, ret = 0;\n\tint len = strlen (ptr);\n\tchar* fmt = sdb_get (core->print->formats, key, NULL);\n\tif (fmt) {\n\t\tint nargs = r_str_word_set0_stack (fmt);\n\t\tif (nargs > 1) {\n\t\t\tfor (i = 1; i < nargs; i++) {\n\t\t\t\tconst char *arg = r_str_word_get0 (fmt, i);\n\t\t\t\tchar *p = strchr (arg, '(');\n\t\t\t\tchar *p2 = strchr (arg, ')');\n\t\t\t\t// remove '(' and ')' from fmt\n\t\t\t\tif (p && p2) {\n\t\t\t\t\targ = p + 1;\n\t\t\t\t\t*p2 = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!len || !strncmp (ptr, arg, len)) {\n\t\t\t\t\tchar *s = r_str_newf (\"pf%s.%s.%s\", pfx, key, arg);\n\t\t\t\t\tr_line_completion_push (completion, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (fmt);\n\treturn ret;\n}\n\n#define ADDARG(x) if (!strncmp (buf->data+chr, x, strlen (buf->data+chr))) { r_line_completion_push (completion, x); }\n\nstatic void autocomplete_default(R_NULLABLE RCore *core, RLineCompletion *completion, RLineBuffer *buf) {\n\tRCoreAutocomplete *a = core ? core->autocomplete : NULL;\n\tint i;\n\tif (a) {\n\t\tfor (i = 0; i < a->n_subcmds; i++) {\n\t\t\tif (buf->data[0] == 0 || !strncmp (a->subcmds[i]->cmd, buf->data, a->subcmds[i]->length)) {\n\t\t\t\tr_line_completion_push (completion, a->subcmds[i]->cmd);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < radare_argc && radare_argv[i]; i++) {\n\t\t\tint length = strlen (radare_argv[i]);\n\t\t\tif (!strncmp (radare_argv[i], buf->data, length)) {\n\t\t\t\tr_line_completion_push (completion, radare_argv[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void autocomplete_evals(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tRConfigNode *bt;\n\tRListIter *iter;\n\tchar *tmp = strrchr (str, ' ');\n\tif (tmp) {\n\t\tstr = tmp + 1;\n\t}\n\tint n = strlen (str);\n\tif (n < 1) {\n\t\treturn;\n\t}\n\tr_list_foreach (core->config->nodes, iter, bt) {\n\t\tif (!strncmp (bt->name, str, n)) {\n\t\t\tr_line_completion_push (completion, bt->name);\n\t\t}\n\t}\n}\n\nstatic void autocomplete_project(RCore *core, RLineCompletion *completion, const char* str) {\n\tr_return_if_fail (str);\n\tchar *foo, *projects_path = r_file_abspath (r_config_get (core->config, \"dir.projects\"));\n\tRList *list = r_sys_dir (projects_path);\n\tRListIter *iter;\n\tint n = strlen (str);\n\tif (projects_path) {\n\t\tr_list_foreach (list, iter, foo) {\n\t\t\tif (r_core_is_project (core, foo)) {\n\t\t\t\tif (!strncmp (foo, str, n)) {\n\t\t\t\t\tr_line_completion_push (completion, foo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (projects_path);\n\t\tr_list_free (list);\n\t}\n}\n\nstatic void autocomplete_minus(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tint count;\n\tint length = strlen (str);\n\tchar **keys = r_cmd_alias_keys(core->rcmd, &count);\n\tif (!keys) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; i < count; i++) {\n\t\tif (!strncmp (keys[i], str, length)) {\n\t\t\tr_line_completion_push (completion, keys[i]);\n\t\t}\n\t}\n}\n\nstatic void autocomplete_breakpoints(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tRListIter *iter;\n\tRBreakpoint *bp = core->dbg->bp;\n\tRBreakpointItem *b;\n\tint n = strlen (str);\n\tr_list_foreach (bp->bps, iter, b) {\n\t\tchar *addr = r_str_newf (\"0x%\"PFMT64x\"\", b->addr);\n\t\tif (!strncmp (addr, str, n)) {\n\t\t\tr_line_completion_push (completion, addr);\n\t\t}\n\t\tfree (addr);\n\t}\n}\n\nstatic bool add_argv(RFlagItem *fi, void *user) {\n\tRLineCompletion *completion = user;\n\tr_line_completion_push (completion, fi->name);\n\treturn true;\n}\n\nstatic void autocomplete_flags(RCore *core, RLineCompletion *completion, const char* str) {\n\tr_return_if_fail (str);\n\tint n = strlen (str);\n\tr_flag_foreach_prefix (core->flags, str, n, add_argv, completion);\n}\n\n// TODO: Should be refactored\nstatic void autocomplete_sdb (RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (core && completion && str);\n\tchar *pipe = strchr (str, '>');\n\tSdb *sdb = core->sdb;\n\tchar *lpath = NULL, *p1 = NULL, *out = NULL, *p2 = NULL;\n\tchar *cur_pos = NULL, *cur_cmd = NULL, *next_cmd = NULL;\n\tchar *temp_cmd = NULL, *temp_pos = NULL, *key = NULL;\n\tif (pipe) {\n\t\tstr = r_str_trim_head_ro (pipe + 1);\n\t}\n\tlpath = r_str_new (str);\n\tp1 = strchr (lpath, '/');\n\tif (p1) {\n\t\t*p1 = 0;\n\t\tchar *ns = p1 + 1;\n\t\tp2 = strchr (ns, '/');\n\t\tif (!p2) { // anal/m\n\t\t\tchar *tmp = p1 + 1;\n\t\t\tint n = strlen (tmp);\n\t\t\tout = sdb_querys (sdb, NULL, 0, \"anal/**\");\n\t\t\tif (!out) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (*out) {\n\t\t\t\tcur_pos = strchr (out, '\\n');\n\t\t\t\tif (!cur_pos) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur_cmd = r_str_ndup (out, cur_pos - out);\n\t\t\t\tif (!strncmp (tmp, cur_cmd, n)) {\n\t\t\t\t\tchar *cmplt = r_str_newf (\"anal/%s/\", cur_cmd);\n\t\t\t\t\tr_line_completion_push (completion, cmplt);\n\t\t\t\t\tfree (cmplt);\n\t\t\t\t}\n\t\t\t\tout += cur_pos - out + 1;\n\t\t\t}\n\n\t\t} else { // anal/meta/*\n\t\t\tchar *tmp = p2 + 1;\n\t\t\tint n = strlen (tmp);\n\t\t\tchar *spltr = strchr (ns, '/');\n\t\t\t*spltr = 0;\n\t\t\tnext_cmd = r_str_newf (\"anal/%s/*\", ns);\n\t\t\tout = sdb_querys (sdb, NULL, 0, next_cmd);\n\t\t\tif (!out) {\n\t\t\t\tfree (lpath);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twhile (*out) {\n\t\t\t\ttemp_pos = strchr (out, '\\n');\n\t\t\t\tif (!temp_pos) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttemp_cmd = r_str_ndup (out, temp_pos - out); // contains the key=value pair\n\t\t\t\tkey = strchr (temp_cmd, '=');\n\t\t\t\t*key = 0;\n\t\t\t\tif (!strncmp (tmp, temp_cmd, n)) {\n\t\t\t\t\tchar *cmplt = r_str_newf (\"anal/%s/%s\", ns, temp_cmd);\n\t\t\t\t\tr_line_completion_push (completion, cmplt);\n\t\t\t\t\tfree (cmplt);\n\t\t\t\t}\n\t\t\t\tout += temp_pos - out + 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint n = strlen (lpath);\n\t\tif (!strncmp (lpath, \"anal\", n)) {\n\t\t\tr_line_completion_push (completion, \"anal/\");\n\t\t}\n\t}\n}\n\nstatic void autocomplete_zignatures(RCore *core, RLineCompletion *completion, const char* msg) {\n\tr_return_if_fail (msg);\n\tint length = strlen (msg);\n\tRSpaces *zs = &core->anal->zign_spaces;\n\tRSpace *s;\n\tRSpaceIter it;\n\n\tr_spaces_foreach (zs, it, s) {\n\t\tif (!strncmp (msg, s->name, length)) {\n\t\t\tr_line_completion_push (completion, s->name);\n\t\t}\n\t}\n\n\tif (strlen (msg) == 0) {\n\t\tr_line_completion_push (completion, \"*\");\n\t}\n}\n\nstatic void autocomplete_flagspaces(RCore *core, RLineCompletion *completion, const char* msg) {\n\tr_return_if_fail (msg);\n\tint length = strlen (msg);\n\tRFlag *flag = core->flags;\n\tRSpaceIter it;\n\tRSpace *s;\n\tr_flag_space_foreach (flag, it, s) {\n\t\tif (!strncmp (msg, s->name, length)) {\n\t\t\tr_line_completion_push (completion, s->name);\n\t\t}\n\t}\n\n\tif (strlen (msg) == 0) {\n\t\tr_line_completion_push (completion, \"*\");\n\t}\n}\n\nstatic void autocomplete_functions (RCore *core, RLineCompletion *completion, const char* str) {\n\tr_return_if_fail (str);\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tint n = strlen (str);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tchar *name = r_core_anal_fcn_name (core, fcn);\n\t\tif (!strncmp (name, str, n)) {\n\t\t\tr_line_completion_push (completion, name);\n\t\t}\n\t\tfree (name);\n\t}\n}\n\nstatic void autocomplete_macro(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tRCmdMacroItem *item;\n\tRListIter *iter;\n\tchar buf[1024];\n\tint n = strlen(str);\n\tr_list_foreach (core->rcmd->macro.macros, iter, item) {\n\t\tchar *p = item->name;\n\t\tif (!*str || !strncmp (str, p, n)) {\n\t\t\tsnprintf (buf, sizeof (buf), \"%s%s)\", str, p);\n\t\t\tr_line_completion_push (completion, buf);\n\t\t}\n\t}\n}\n\nstatic void autocomplete_file(RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tchar *pipe = strchr (str, '>');\n\n\tif (pipe) {\n\t\tstr = r_str_trim_head_ro (pipe + 1);\n\t}\n\tif (str && !*str) {\n\t\tautocomplete_process_path (completion, str, \"./\");\n\t} else {\n\t\tautocomplete_process_path (completion, str, str);\n\t}\n\n}\n\nstatic void autocomplete_ms_file(RCore* core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tchar *pipe = strchr (str, '>');\n\tchar *path = (core->rfs && *(core->rfs->cwd)) ? *(core->rfs->cwd): \"/\";\n\tif (pipe) {\n\t\tstr = r_str_trim_head_ro (pipe + 1);\n\t}\n\tif (str && !*str) {\n\t\tautocomplete_ms_path (completion, core, str, path);\n\t} else {\n\t\tautocomplete_ms_path (completion, core, str, str);\n\t}\n}\n\nstatic void autocomplete_theme(RCore *core, RLineCompletion *completion, const char *str) {\n\tr_return_if_fail (str);\n\tint len = strlen (str);\n\tchar *theme;\n\tRListIter *iter;\n\tRList *themes = r_core_list_themes (core);\n\tr_list_foreach (themes, iter, theme) {\n\t\tif (!len || !strncmp (str, theme, len)) {\n\t\t\tr_line_completion_push (completion, theme);\n\t\t}\n\t}\n\tr_list_free (themes);\n}\n\nstatic bool find_e_opts(RCore *core, RLineCompletion *completion, RLineBuffer *buf) {\n\tconst char *pattern = \"e (.*)=\";\n\tRRegex *rx = r_regex_new (pattern, \"e\");\n\tconst size_t nmatch = 2;\n\tRRegexMatch pmatch[2];\n\tbool ret = false;\n\n\t// required to get the new list of items to autocomplete for cmd.pdc at least\n\tr_core_config_update (core);\n\n\tif (r_regex_exec (rx, buf->data, nmatch, pmatch, 1)) {\n\t\tgoto out;\n\t}\n\tint i;\n\tchar *str = NULL, *sp;\n\tfor (i = pmatch[1].rm_so; i < pmatch[1].rm_eo; i++) {\n\t\tstr = r_str_appendch (str, buf->data[i]);\n\t}\n\tif (!str) {\n\t\tgoto out;\n\t}\n\tif ((sp = strchr (str, ' '))) {\n\t\t// if the name contains a space, just null\n\t\t*sp = 0;\n\t}\n\tRConfigNode *node = r_config_node_get (core->config, str);\n\tif (sp) {\n\t\t// if nulled, then restore.\n\t\t*sp = ' ';\n\t}\n\tif (!node) {\n\t\treturn false;\n\t}\n\tRListIter *iter;\n\tchar *option;\n\tchar *p = (char *) strchr (buf->data, '=');\n\tp = r_str_ichr (p + 1, ' ');\n\tint n = strlen (p);\n\tr_list_foreach (node->options, iter, option) {\n\t\tif (!strncmp (option, p, n)) {\n\t\t\tr_line_completion_push (completion, option);\n\t\t}\n\t}\n\tcompletion->opt = true;\n\tret = true;\n\n out:\n\tr_regex_free (rx);\n\treturn ret;\n}\n\nstatic bool find_autocomplete(RCore *core, RLineCompletion *completion, RLineBuffer *buf) {\n\tRCoreAutocomplete* child = NULL;\n\tRCoreAutocomplete* parent = core->autocomplete;\n\tconst char* p = buf->data;\n\tif (!*p) {\n\t\treturn false;\n\t}\n\tchar arg[256];\n\targ[0] = 0;\n\twhile (*p) {\n\t\tconst char* e = r_str_trim_head_wp (p);\n\t\tif (!e || (e - p) >= 256 || e == p) {\n\t\t\treturn false;\n\t\t}\n\t\tmemcpy (arg, p, e - p);\n\t\targ[e - p] = 0;\n\t\tchild = r_core_autocomplete_find (parent, arg, false);\n\t\tif (child && child->length < buf->length && p[child->length] == ' ') {\n\t\t\t// if is spaced then i can provide the\n\t\t\t// next subtree as suggestion..\n\t\t\tp = r_str_trim_head_ro (p + child->length);\n\t\t\tif (child->type == R_CORE_AUTOCMPLT_OPTN) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tparent = child;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tint i;\n\t/* if something went wrong this will prevent bad behavior */\n\tr_line_completion_clear (completion);\n\tswitch (parent->type) {\n\tcase R_CORE_AUTOCMPLT_SEEK:\n\t\tautocomplete_functions (core, completion, p);\n\tcase R_CORE_AUTOCMPLT_FLAG:\n\t\tautocomplete_flags (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_FLSP:\n\t\tautocomplete_flagspaces (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_FCN:\n\t\tautocomplete_functions (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_ZIGN:\n\t\tautocomplete_zignatures (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_EVAL:\n\t\tautocomplete_evals (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_PRJT:\n\t\tautocomplete_project (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_MINS:\n\t\tautocomplete_minus (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_BRKP:\n\t\tautocomplete_breakpoints (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_MACR:\n\t\tautocomplete_macro (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_MS:\n\t\tautocomplete_ms_file(core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_FILE:\n\t\tautocomplete_file (completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_THME:\n\t\tautocomplete_theme (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_SDB:\n\t\tautocomplete_sdb (core, completion, p);\n\t\tbreak;\n\tcase R_CORE_AUTOCMPLT_OPTN:\n\t\t// handled before\n\t\tbreak;\n\tdefault:\n\t\tif (r_config_get_i (core->config, \"cfg.newtab\")) {\n\t\t\tRCmdDescriptor *desc = &core->root_cmd_descriptor;\n\t\t\tfor (i = 0; arg[i] && desc; i++) {\n\t\t\t\tut8 c = arg[i];\n\t\t\t\tdesc = c < R_ARRAY_SIZE (desc->sub) ? desc->sub[c] : NULL;\n\t\t\t}\n\t\t\tif (desc && desc->help_msg) {\n\t\t\t\tr_core_cmd_help (core, desc->help_msg);\n\t\t\t\tr_cons_flush ();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// fallback to command listing\n\t\t}\n\t\tint length = strlen (arg);\n\t\tfor (i = 0; i < parent->n_subcmds; i++) {\n\t\t\tif (!strncmp (arg, parent->subcmds[i]->cmd, length)) {\n\t\t\t\tr_line_completion_push (completion, parent->subcmds[i]->cmd);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API void r_core_autocomplete(R_NULLABLE RCore *core, RLineCompletion *completion, RLineBuffer *buf, RLinePromptType prompt_type) {\n\tif (!core) {\n\t\tautocomplete_default (core, completion, buf);\n\t\treturn;\n\t}\n\tr_line_completion_clear (completion);\n\tchar *pipe = strchr (buf->data, '>');\n\tchar *ptr = strchr (buf->data, '@');\n\tif (pipe && strchr (pipe + 1, ' ') && buf->data + buf->index >= pipe) {\n\t\tautocompleteFilename (completion, buf, NULL, 1);\n\t} else if (ptr && strchr (ptr + 1, ' ') && buf->data + buf->index >= ptr) {\n\t\tint sdelta, n;\n\t\tptr = (char *)r_str_trim_head_ro (ptr + 1);\n\t\tn = strlen (ptr);//(buf->data+sdelta);\n\t\tsdelta = (int)(size_t)(ptr - buf->data);\n\t\tr_flag_foreach_prefix (core->flags, buf->data + sdelta, n, add_argv, completion);\n\t} else if (!strncmp (buf->data, \"#!pipe \", 7)) {\n\t\tif (strchr (buf->data + 7, ' ')) {\n\t\t\tautocompleteFilename (completion, buf, NULL, 2);\n\t\t} else {\n\t\t\tint chr = 7;\n\t\t\tADDARG (\"node\");\n\t\t\tADDARG (\"vala\");\n\t\t\tADDARG (\"ruby\");\n\t\t\tADDARG (\"newlisp\");\n\t\t\tADDARG (\"perl\");\n\t\t\tADDARG (\"python\");\n\t\t}\n\t} else if (!strncmp (buf->data, \"ec \", 3)) {\n\t\tif (strchr (buf->data + 3, ' ')) {\n\t\t\tautocompleteFilename (completion, buf, NULL, 2);\n\t\t} else {\n\t\t\tint chr = 3;\n\t\t\tADDARG(\"comment\")\n\t\t\tADDARG(\"usrcmt\")\n\t\t\tADDARG(\"args\")\n\t\t\tADDARG(\"fname\")\n\t\t\tADDARG(\"floc\")\n\t\t\tADDARG(\"fline\")\n\t\t\tADDARG(\"flag\")\n\t\t\tADDARG(\"label\")\n\t\t\tADDARG(\"help\")\n\t\t\tADDARG(\"flow\")\n\t\t\tADDARG(\"prompt\")\n\t\t\tADDARG(\"offset\")\n\t\t\tADDARG(\"input\")\n\t\t\tADDARG(\"invalid\")\n\t\t\tADDARG(\"other\")\n\t\t\tADDARG(\"b0x00\")\n\t\t\tADDARG(\"b0x7f\")\n\t\t\tADDARG(\"b0xff\")\n\t\t\tADDARG(\"math\")\n\t\t\tADDARG(\"bin\")\n\t\t\tADDARG(\"btext\")\n\t\t\tADDARG(\"push\")\n\t\t\tADDARG(\"pop\")\n\t\t\tADDARG(\"crypto\")\n\t\t\tADDARG(\"jmp\")\n\t\t\tADDARG(\"cjmp\")\n\t\t\tADDARG(\"call\")\n\t\t\tADDARG(\"nop\")\n\t\t\tADDARG(\"ret\")\n\t\t\tADDARG(\"trap\")\n\t\t\tADDARG(\"swi\")\n\t\t\tADDARG(\"cmp\")\n\t\t\tADDARG(\"reg\")\n\t\t\tADDARG(\"creg\")\n\t\t\tADDARG(\"num\")\n\t\t\tADDARG(\"mov\")\n\t\t\tADDARG(\"func_var\")\n\t\t\tADDARG(\"func_var_type\")\n\t\t\tADDARG(\"func_var_addr\")\n\t\t\tADDARG(\"widget_bg\")\n\t\t\tADDARG(\"widget_sel\")\n\t\t\tADDARG(\"ai.read\")\n\t\t\tADDARG(\"ai.write\")\n\t\t\tADDARG(\"ai.exec\")\n\t\t\tADDARG(\"ai.seq\")\n\t\t\tADDARG(\"ai.ascii\")\n\t\t\tADDARG(\"ai.unmap\")\n\t\t\tADDARG(\"graph.box\")\n\t\t\tADDARG(\"graph.box2\")\n\t\t\tADDARG(\"graph.box3\")\n\t\t\tADDARG(\"graph.box4\")\n\t\t\tADDARG(\"graph.true\")\n\t\t\tADDARG(\"graph.false\")\n\t\t\tADDARG(\"graph.trufae\")\n\t\t\tADDARG(\"graph.current\")\n\t\t\tADDARG(\"graph.traced\")\n\t\t\tADDARG(\"gui.cflow\")\n\t\t\tADDARG(\"gui.dataoffset\")\n\t\t\tADDARG(\"gui.background\")\n\t\t\tADDARG(\"gui.alt_background\")\n\t\t\tADDARG(\"gui.border\")\n\t\t}\n\t} else if (!strncmp (buf->data, \"pf.\", 3)\n\t|| !strncmp (buf->data, \"pf*.\", 4)\n\t|| !strncmp (buf->data, \"pfd.\", 4)\n\t|| !strncmp (buf->data, \"pfv.\", 4)\n\t|| !strncmp (buf->data, \"pfj.\", 4)) {\n\t\tchar pfx[2];\n\t\tint chr = (buf->data[2]=='.')? 3: 4;\n\t\tif (chr == 4) {\n\t\t\tpfx[0] = buf->data[2];\n\t\t\tpfx[1] = 0;\n\t\t} else {\n\t\t\t*pfx = 0;\n\t\t}\n\t\tSdbList *sls = sdb_foreach_list (core->print->formats, false);\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tint j = 0;\n\t\tls_foreach (sls, iter, kv) {\n\t\t\tint len = strlen (buf->data + chr);\n\t\t\tint minlen = R_MIN (len,  strlen (sdbkv_key (kv)));\n\t\t\tif (!len || !strncmp (buf->data + chr, sdbkv_key (kv), minlen)) {\n\t\t\t\tchar *p = strchr (buf->data + chr, '.');\n\t\t\t\tif (p) {\n\t\t\t\t\tj += autocomplete_pfele (core, completion, sdbkv_key (kv), pfx, j, p + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tchar *s = r_str_newf (\"pf%s.%s\", pfx, sdbkv_key (kv));\n\t\t\t\t\tr_line_completion_push (completion, s);\n\t\t\t\t\tfree (s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if ((!strncmp (buf->data, \"afvn \", 5))\n\t|| (!strncmp (buf->data, \"afan \", 5))) {\n\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tRList *vars;\n\t\tif (!strncmp (buf->data, \"afvn \", 5)) {\n\t\t\tvars = r_anal_var_list (core->anal, fcn, R_ANAL_VAR_KIND_BPV);\n\t\t} else {\n\t\t\tvars = r_anal_var_list (core->anal, fcn, R_ANAL_VAR_KIND_ARG);\n\t\t}\n\t\tconst char *f_ptr, *l_ptr;\n\t\tRAnalVar *var;\n\t\tint len = strlen (buf->data);\n\n\t\tf_ptr = r_sub_str_lchr (buf->data, 0, buf->index, ' ');\n\t\tf_ptr = f_ptr != NULL ? f_ptr + 1 : buf->data;\n\t\tl_ptr = r_sub_str_rchr (buf->data, buf->index, len, ' ');\n\t\tif (!l_ptr) {\n\t\t\tl_ptr = buf->data + len;\n\t\t}\n\t\tRListIter *iter;\n\t\tr_list_foreach (vars, iter, var) {\n\t\t\tif (!strncmp (f_ptr, var->name, l_ptr - f_ptr)) {\n\t\t\t\tr_line_completion_push (completion, var->name);\n\t\t\t}\n\t\t}\n\t\tr_list_free (vars);\n\t} else if (!strncmp (buf->data, \"t \", 2)\n\t|| !strncmp (buf->data, \"t- \", 3)) {\n\t\tSdbList *l = sdb_foreach_list (core->anal->sdb_types, true);\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tint chr = (buf->data[1] == ' ')? 2: 3;\n\t\tls_foreach (l, iter, kv) {\n\t\t\tint len = strlen (buf->data + chr);\n\t\t\tif (!len || !strncmp (buf->data + chr, sdbkv_key (kv), len)) {\n\t\t\t\tif (!strcmp (sdbkv_value (kv), \"type\") || !strcmp (sdbkv_value (kv), \"enum\")\n\t\t\t\t|| !strcmp (sdbkv_value (kv), \"struct\")) {\n\t\t\t\t\tr_line_completion_push (completion, sdbkv_key (kv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls_free (l);\n\t} else if ((!strncmp (buf->data, \"te \", 3))) {\n\t\tSdbList *l = sdb_foreach_list (core->anal->sdb_types, true);\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tint chr = 3;\n\t\tls_foreach (l, iter, kv) {\n\t\t\tint len = strlen (buf->data + chr);\n\t\t\tif (!len || !strncmp (buf->data + chr, sdbkv_key (kv), len)) {\n\t\t\t\tif (!strcmp (sdbkv_value (kv), \"enum\")) {\n\t\t\t\t\tr_line_completion_push (completion, sdbkv_key (kv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls_free (l);\n\t} else if (!strncmp (buf->data, \"$\", 1)) {\n\t\tint i;\n\t\tfor (i = 0; i < core->rcmd->aliases.count; i++) {\n\t\t\tconst char *key = core->rcmd->aliases.keys[i];\n\t\t\tint len = strlen (buf->data);\n\t\t\tif (!len || !strncmp (buf->data, key, len)) {\n\t\t\t\tr_line_completion_push (completion, key);\n\t\t\t}\n\t\t}\n\t} else if (!strncmp (buf->data, \"ts \", 3)\n\t|| !strncmp (buf->data, \"ta \", 3)\n\t|| !strncmp (buf->data, \"tp \", 3)\n\t|| !strncmp (buf->data, \"tl \", 3)\n\t|| !strncmp (buf->data, \"tpx \", 4)\n\t|| !strncmp (buf->data, \"tss \", 4)\n\t|| !strncmp (buf->data, \"ts* \", 4)) {\n\t\tSdbList *l = sdb_foreach_list (core->anal->sdb_types, true);\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tint chr = (buf->data[2] == ' ')? 3: 4;\n\t\tls_foreach (l, iter, kv) {\n\t\t\tint len = strlen (buf->data + chr);\n\t\t\tconst char *key = sdbkv_key (kv);\n\t\t\tif (!len || !strncmp (buf->data + chr, key, len)) {\n\t\t\t\tif (!strncmp (sdbkv_value (kv), \"struct\", strlen (\"struct\") + 1)) {\n\t\t\t\t\tr_line_completion_push (completion, key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls_free (l);\n\t} else if (!strncmp (buf->data, \"zo \", 3)\n\t|| !strncmp (buf->data, \"zoz \", 4)) {\n\t\tif (core->anal->zign_path && core->anal->zign_path[0]) {\n\t\t\tchar *zignpath = r_file_abspath (core->anal->zign_path);\n\t\t\tchar *paths[2] = { zignpath, NULL };\n\t\t\tautocompleteFilename (completion, buf, paths, 1);\n\t\t\tfree (zignpath);\n\t\t} else {\n\t\t\tautocompleteFilename (completion, buf, NULL, 1);\n\t\t}\n\t} else if (find_e_opts (core, completion, buf)) {\n\t\treturn;\n\t} else if (prompt_type == R_LINE_PROMPT_OFFSET) {\n\t\tautocomplete_flags (core, completion, buf->data);\n\t} else if (prompt_type == R_LINE_PROMPT_FILE) {\n\t\tautocomplete_file (completion, buf->data);\n\t} else if (!find_autocomplete (core, completion, buf)) {\n\t\tautocomplete_default (core, completion, buf);\n\t}\n}\n\nstatic int autocomplete(RLineCompletion *completion, RLineBuffer *buf, RLinePromptType prompt_type, void *user) {\n\tRCore *core = user;\n\tr_core_autocomplete (core, completion, buf, prompt_type);\n\treturn true;\n}\n\nR_API int r_core_fgets(char *buf, int len) {\n\tconst char *ptr;\n\tRLine *rli = r_line_singleton ();\n\tbuf[0] = '\\0';\n\tr_line_completion_set (&rli->completion, radare_argc, radare_argv);\n \trli->completion.run = autocomplete;\n \trli->completion.run_user = rli->user;\n\tptr = r_line_readline ();\n\tif (!ptr) {\n\t\treturn -1;\n\t}\n\tstrncpy (buf, ptr, len - 1);\n\tbuf[len - 1] = 0;\n\treturn strlen (buf);\n}\n\nstatic const char *r_core_print_offname(void *p, ut64 addr) {\n\tRCore *c = (RCore*)p;\n\tRFlagItem *item = r_flag_get_i (c->flags, addr);\n\treturn item ? item->name : NULL;\n}\n\nstatic int r_core_print_offsize(void *p, ut64 addr) {\n\tRCore *c = (RCore*)p;\n\tRFlagItem *item = r_flag_get_i (c->flags, addr);\n\treturn item ? item->size: -1;\n}\n\n/**\n * Disassemble one instruction at specified address.\n */\nstatic int __disasm(void *_core, ut64 addr) {\n\tRCore *core = _core;\n\tut64 prevaddr = core->offset;\n\n\tr_core_seek (core, addr, true);\n\tint len = r_core_print_disasm_instructions (core, 0, 1);\n\tr_core_seek (core, prevaddr, true);\n\n\treturn len;\n}\n\nstatic void update_sdb(RCore *core) {\n\tSdb *d;\n\tRBinObject *o;\n\tif (!core) {\n\t\treturn;\n\t}\n\t//SDB// anal/\n\tif (core->anal && core->anal->sdb) {\n\t\tsdb_ns_set (DB, \"anal\", core->anal->sdb);\n\t}\n\t//SDB// bin/\n\tif (core->bin && core->bin->sdb) {\n\t\tsdb_ns_set (DB, \"bin\", core->bin->sdb);\n\t}\n\t//SDB// bin/info\n\to = r_bin_cur_object (core->bin);\n\tif (o) {\n\t\tsdb_ns_set (sdb_ns (DB, \"bin\", 1), \"info\", o->kv);\n\t}\n\t//sdb_ns_set (core->sdb, \"flags\", core->flags->sdb);\n\t//sdb_ns_set (core->sdb, \"bin\", core->bin->sdb);\n\t//SDB// syscall/\n\tif (core->assembler && core->assembler->syscall && core->assembler->syscall->db) {\n\t\tcore->assembler->syscall->db->refs++;\n\t\tsdb_ns_set (DB, \"syscall\", core->assembler->syscall->db);\n\t}\n\td = sdb_ns (DB, \"debug\", 1);\n\tif (core->dbg->sgnls) {\n\t\tcore->dbg->sgnls->refs++;\n\t\tsdb_ns_set (d, \"signals\", core->dbg->sgnls);\n\t}\n}\n\n#define MINLEN 1\nstatic int is_string (const ut8 *buf, int size, int *len) {\n\tint i;\n\tif (size < 1) {\n\t\treturn 0;\n\t}\n\tif (size > 3 && buf[0] && !buf[1] && buf[2] && !buf[3]) {\n\t\t*len = 1; // XXX: TODO: Measure wide string length\n\t\treturn 2; // is wide\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\tif (!buf[i] && i > MINLEN) {\n\t\t\t*len = i;\n\t\t\treturn 1;\n\t\t}\n\t\tif (buf[i] == 10|| buf[i] == 13|| buf[i] == 9) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] < 32 || buf[i] > 127) {\n\t\t\t// not ascii text\n\t\t\treturn 0;\n\t\t}\n\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t*len = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*len = i;\n\treturn 1;\n}\n\nstatic char *r_core_anal_hasrefs_to_depth(RCore *core, ut64 value, int depth);\nR_API char *r_core_anal_hasrefs(RCore *core, ut64 value, bool verbose) {\n\tif (verbose) {\n\t\tconst int hex_depth = r_config_get_i (core->config, \"hex.depth\");\n\t\treturn r_core_anal_hasrefs_to_depth (core, value, hex_depth);\n\t}\n\tRFlagItem *fi = r_flag_get_i (core->flags, value);\n\treturn fi? strdup (fi->name): NULL;\n}\n\nstatic char *r_core_anal_hasrefs_to_depth(RCore *core, ut64 value, int depth) {\n\tr_return_val_if_fail (core, NULL);\n\tif (depth < 1 || value == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRStrBuf *s = r_strbuf_new (NULL);\n\tchar *mapname = NULL;\n\tRFlagItem *fi = r_flag_get_i (core->flags, value);\n\tut64 type = r_core_anal_address (core, value);\n\tif (value && value != UT64_MAX) {\n\t\tRDebugMap *map = r_debug_map_get (core->dbg, value);\n\t\tif (map && map->name && map->name[0]) {\n\t\t\tmapname = strdup (map->name);\n\t\t}\n\t}\n\tif (mapname) {\n\t\tr_strbuf_appendf (s, \" (%s)\", mapname);\n\t\tR_FREE (mapname);\n\t}\n\tint bits = core->assembler->bits;\n\tswitch (bits) {\n\tcase 16: // umf, not in sync with pxr\n\t\t{\n\t\t\tst16 v = (st16)(value & UT16_MAX);\n\t\t\tst16 h = UT16_MAX / 0x100;\n\t\t\tif (v > -h && v < h) {\n\t\t\t\tr_strbuf_appendf (s,\" %hd\", v);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\t{\n\t\t\tst32 v = (st32)(value & 0xffffffff);\n\t\t\tst32 h = UT32_MAX / 0x10000;\n\t\t\tif (v > -h && v < h) {\n\t\t\t\tr_strbuf_appendf (s,\" %d\", v);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 64:\n\t\t{\n\t\t\tst64 v = (st64)(value);\n\t\t\tst64 h = UT64_MAX / 0x1000000;\n\t\t\tif (v > -h && v < h) {\n\t\t\t\tr_strbuf_appendf (s,\" %\"PFMT64d, v);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tRBinSection *sect = value? r_bin_get_section_at (r_bin_cur_object (core->bin), value, true): NULL;\n\tif(! ((type&R_ANAL_ADDR_TYPE_HEAP)||(type&R_ANAL_ADDR_TYPE_STACK)) ) {\n\t\t// Do not repeat \"stack\" or \"heap\" words unnecessarily.\n\t\tif (sect && sect->name[0]) {\n\t\t\tr_strbuf_appendf (s,\" (%s)\", sect->name);\n\t\t}\n\t}\n\tif (fi) {\n\t\tRRegItem *r = r_reg_get (core->dbg->reg, fi->name, -1);\n\t\tif (!r) {\n\t\t\tr_strbuf_appendf (s, \" %s\", fi->name);\n\t\t}\n\t}\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, value, 0);\n\tif (fcn) {\n\t\tr_strbuf_appendf (s, \" %s\", fcn->name);\n\t}\n\tif (type) {\n\t\tconst char *c = r_core_anal_optype_colorfor (core, value, true);\n\t\tconst char *cend = (c && *c) ? Color_RESET: \"\";\n\t\tif (!c) {\n\t\t\tc = \"\";\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_HEAP) {\n\t\t\tr_strbuf_appendf (s, \" %sheap%s\", c, cend);\n\t\t} else if (type & R_ANAL_ADDR_TYPE_STACK) {\n\t\t\tr_strbuf_appendf (s, \" %sstack%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_PROGRAM) {\n\t\t\tr_strbuf_appendf (s, \" %sprogram%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_LIBRARY) {\n\t\t\tr_strbuf_appendf (s, \" %slibrary%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_ASCII) {\n\t\t\tr_strbuf_appendf (s, \" %sascii%s ('%c')\", c, cend, value);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE) {\n\t\t\tr_strbuf_appendf (s, \" %ssequence%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_READ) {\n\t\t\tr_strbuf_appendf (s, \" %sR%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_WRITE) {\n\t\t\tr_strbuf_appendf (s, \" %sW%s\", c, cend);\n\t\t}\n\t\tif (type & R_ANAL_ADDR_TYPE_EXEC) {\n\t\t\tRAsmOp op;\n\t\t\tut8 buf[32];\n\t\t\tr_strbuf_appendf (s, \" %sX%s\", c, cend);\n\t\t\t/* instruction disassembly */\n\t\t\tr_io_read_at (core->io, value, buf, sizeof (buf));\n\t\t\tr_asm_set_pc (core->assembler, value);\n\t\t\tr_asm_disassemble (core->assembler, &op, buf, sizeof (buf));\n\t\t\tr_strbuf_appendf (s, \" '%s'\", r_asm_op_get_asm (&op));\n\t\t\t/* get library name */\n\t\t\t{ // NOTE: dup for mapname?\n\t\t\t\tRDebugMap *map;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (core->dbg->maps, iter, map) {\n\t\t\t\t\tif ((value >= map->addr) &&\n\t\t\t\t\t\t(value<map->addr_end)) {\n\t\t\t\t\t\tconst char *lastslash = r_str_lchr (map->name, '/');\n\t\t\t\t\t\tr_strbuf_appendf (s, \" '%s'\", lastslash?\n\t\t\t\t\t\t\tlastslash+1:map->name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type & R_ANAL_ADDR_TYPE_READ) {\n\t\t\tut8 buf[32];\n\t\t\tut32 *n32 = (ut32 *)buf;\n\t\t\tut64 *n64 = (ut64*)buf;\n\t\t\tr_io_read_at (core->io, value, buf, sizeof (buf));\n\t\t\tut64 n = (core->assembler->bits == 64)? *n64: *n32;\n\t\t\tr_strbuf_appendf (s, \" 0x%\"PFMT64x, n);\n\t\t}\n\t}\n\t{\n\t\tut8 buf[128], widebuf[256];\n\t\tconst char *c = r_config_get_i (core->config, \"scr.color\")? core->cons->context->pal.ai_ascii: \"\";\n\t\tconst char *cend = (c && *c) ? Color_RESET: \"\";\n\t\tint len, r;\n\t\tif (r_io_read_at (core->io, value, buf, sizeof (buf))) {\n\t\t\tbuf[sizeof (buf) - 1] = 0;\n\t\t\tswitch (is_string (buf, sizeof(buf), &len)) {\n\t\t\tcase 1:\n\t\t\t\tr_strbuf_appendf (s, \" (%s%s%s)\", c, buf, cend);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tr = r_utf8_encode_str ((const RRune *)buf, widebuf,\n\t\t\t\t\t\t       sizeof (widebuf) - 1);\n\t\t\t\tif (r == -1) {\n\t\t\t\t\teprintf (\"Something was wrong with refs\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (s, \" (%s%s%s)\", c, widebuf, cend);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\tif ((type & R_ANAL_ADDR_TYPE_READ) && !(type & R_ANAL_ADDR_TYPE_EXEC) && depth) {\n\t\t// Try to telescope further, but only several levels deep.\n\t\tut8 buf[32];\n\t\tut32 *n32 = (ut32 *)buf;\n\t\tut64 *n64 = (ut64*)buf;\n\t\tr_io_read_at (core->io, value, buf, sizeof (buf));\n\t\tut64 n = (core->assembler->bits == 64)? *n64: *n32;\n\t\tif(n != value) {\n\t\t\tchar* rrstr = r_core_anal_hasrefs_to_depth (core, n, depth-1);\n\t\t\tif (rrstr) {\n\t\t\t\tif (rrstr[0]) {\n\t\t\t\t\tr_strbuf_appendf (s, \" --> %s\", rrstr);\n\t\t\t\t}\n\t\t\t\tfree (rrstr);\n\t\t\t}\n\t\t}\n\t}\n\tfree (mapname);\n\treturn r_strbuf_drain (s);\n}\n\nR_API char *r_core_anal_get_comments(RCore *core, ut64 addr) {\n\tif (core) {\n\t\tchar *type = r_meta_get_string (core->anal, R_META_TYPE_VARTYPE, addr);\n\t\tchar *cmt = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\tif (type && cmt) {\n\t\t\tchar *ret = r_str_newf (\"%s %s\", type, cmt);\n\t\t\tfree (type);\n\t\t\tfree (cmt);\n\t\t\treturn ret;\n\t\t} else if (type) {\n\t\t\treturn type;\n\t\t} else if (cmt) {\n\t\t\treturn cmt;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API const char *r_core_anal_optype_colorfor(RCore *core, ut64 addr, bool verbose) {\n\tut64 type;\n\tif (!(core->print->flags & R_PRINT_FLAGS_COLOR)) {\n\t\treturn NULL;\n\t}\n\tif (!r_config_get_i (core->config, \"scr.color\")) {\n\t\treturn NULL;\n\t}\n\ttype = r_core_anal_address (core, addr);\n\tif (type & R_ANAL_ADDR_TYPE_EXEC) {\n\t\treturn core->cons->context->pal.ai_exec; //Color_RED;\n\t}\n\tif (type & R_ANAL_ADDR_TYPE_WRITE) {\n\t\treturn core->cons->context->pal.ai_write; //Color_BLUE;\n\t}\n\tif (type & R_ANAL_ADDR_TYPE_READ) {\n\t\treturn core->cons->context->pal.ai_read; //Color_GREEN;\n\t}\n\tif (type & R_ANAL_ADDR_TYPE_SEQUENCE) {\n\t\treturn core->cons->context->pal.ai_seq; //Color_MAGENTA;\n\t}\n\tif (type & R_ANAL_ADDR_TYPE_ASCII) {\n\t\treturn core->cons->context->pal.ai_ascii; //Color_YELLOW;\n\t}\n\treturn NULL;\n}\n\nstatic void r_core_setenv (RCore *core) {\n\tchar *e = r_sys_getenv (\"PATH\");\n\tchar *h = r_str_home (R2_HOME_BIN);\n\tchar *n = r_str_newf (\"%s%s%s\", h, R_SYS_ENVSEP, e);\n\tr_sys_setenv (\"PATH\", n);\n\tfree (n);\n\tfree (h);\n\tfree (e);\n}\n\nstatic int mywrite(const ut8 *buf, int len) {\n\treturn r_cons_memcat ((const char *)buf, len);\n}\n\nstatic bool exists_var(RPrint *print, ut64 func_addr, char *str) {\n\tchar *name_key = sdb_fmt (\"var.0x%\"PFMT64x \".%d.%s\", func_addr, 1, str);\n\tif (sdb_const_get_len (((RCore*)(print->user))->anal->sdb_fcns, name_key, NULL, 0)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool r_core_anal_log(struct r_anal_t *anal, const char *msg) {\n\tRCore *core = anal->user;\n\tif (core->cfglog) {\n\t\tr_core_log_add (core, msg);\n\t}\n\treturn true;\n}\n\nstatic bool r_core_anal_read_at(struct r_anal_t *anal, ut64 addr, ut8 *buf, int len) {\n\treturn r_io_read_at (anal->iob.io, addr, buf, len);\n}\n\nstatic void r_core_break (RCore *core) {\n}\n\nstatic void *r_core_sleep_begin (RCore *core) {\n\tRCoreTask *task = r_core_task_self (&core->tasks);\n\tif (task) {\n\t\tr_core_task_sleep_begin (task);\n\t}\n\treturn task;\n}\n\nstatic void r_core_sleep_end (RCore *core, void *user) {\n\tRCoreTask *task = (RCoreTask *)user;\n\tif (task) {\n\t\tr_core_task_sleep_end (task);\n\t}\n}\n\nstatic void __foreach(RCore *core, const char **cmds, int type) {\n\tint i;\n\tfor (i = 0; cmds[i]; i++) {\n\t\tr_core_autocomplete_add (core->autocomplete, cmds[i], type, true);\n\t}\n}\n\nstatic void __init_autocomplete_default (RCore* core) {\n\tconst char *fcns[] = {\n\t\t\"afi\", \"afcf\", \"afn\", NULL\n\t};\n\tconst char *seeks[] = {\n\t\t\"s\", NULL\n\t};\n\tconst char *flags[] = {\n\t\t\"*\", \"s\", \"s+\", \"b\", \"f\", \"fg\", \"?\", \"?v\", \"ad\", \"bf\", \"c1\", \"db\", \"dbw\",\n\t\t\"f-\", \"fr\", \"tf\", \"/a\", \"/v\", \"/r\", \"/re\", \"aav\", \"aep\", \"aef\", \"afb\",\n\t\t\"afc\", \"axg\", \"axt\", \"axf\", \"dcu\", \"ag\", \"agfl\", \"aecu\", \"aesu\", \"aeim\", NULL\n\t};\n\tconst char *evals[] = {\n\t\t\"e\", \"ee\", \"et\", \"e?\", \"e!\", \"ev\", \"evj\", NULL\n\t};\n\tconst char *breaks[] = {\n\t\t\"db-\", \"dbc\", \"dbC\", \"dbd\", \"dbe\", \"dbs\", \"dbi\", \"dbte\", \"dbtd\", \"dbts\", NULL\n\t};\n\tconst char *files[] = {\n\t\t\".\", \"..\", \".*\", \"/F\", \"/m\", \"!\", \"!!\", \"#!c\", \"#!v\", \"#!cpipe\", \"#!vala\",\n\t\t\"#!rust\", \"#!zig\", \"#!pipe\", \"#!python\", \"aeli\", \"arp\", \"dmd\", \"drp\", \"o\",\n\t\t\"idp\", \"idpi\", \"L\", \"obf\", \"o+\", \"oc\", \"r2\", \"rabin2\", \"rasm2\", \"rahash2\", \"rax2\",\n\t\t\"rafind2\", \"cd\", \"on\", \"op\", \"wf\", \"rm\", \"wF\", \"wp\", \"Sd\", \"Sl\", \"to\", \"pm\",\n\t\t\"/m\", \"zos\", \"zfd\", \"zfs\", \"zfz\", \"cat\", \"wta\", \"wtf\", \"wxf\", \"dml\", \"vi\",\n\t\t\"less\", \"head\", \"tail\", NULL\n\t};\n\tconst char *projs[] = {\n\t\t\"Pc\", \"Pd\", \"Pi\", \"Po\", \"Ps\", \"P-\", NULL\n\t};\n\tconst char *mounts[] = {\n\t\t\"md\", \"mg\", \"mo\", \"ms\", \"mc\", \"mi\", \"mw\", NULL\n\t};\n\t__foreach (core, flags, R_CORE_AUTOCMPLT_FLAG);\n\t__foreach (core, seeks, R_CORE_AUTOCMPLT_SEEK);\n\t__foreach (core, fcns, R_CORE_AUTOCMPLT_FCN);\n\t__foreach (core, evals, R_CORE_AUTOCMPLT_EVAL);\n\t__foreach (core, breaks, R_CORE_AUTOCMPLT_BRKP);\n\t__foreach (core, files, R_CORE_AUTOCMPLT_FILE);\n\t__foreach (core, projs, R_CORE_AUTOCMPLT_PRJT);\n\t__foreach (core, mounts, R_CORE_AUTOCMPLT_MS);\n\n\tr_core_autocomplete_add (core->autocomplete, \"-\", R_CORE_AUTOCMPLT_MINS, true);\n\tr_core_autocomplete_add (core->autocomplete, \"zs\", R_CORE_AUTOCMPLT_ZIGN, true);\n\tr_core_autocomplete_add (core->autocomplete, \"fs\", R_CORE_AUTOCMPLT_FLSP, true);\n\tr_core_autocomplete_add (\n\t\tr_core_autocomplete_add (core->autocomplete, \"ls\", R_CORE_AUTOCMPLT_DFLT, true),\n\t\t\"-l\", R_CORE_AUTOCMPLT_FILE, true);\n\tr_core_autocomplete_add (core->autocomplete, \"eco\", R_CORE_AUTOCMPLT_THME, true);\n\tr_core_autocomplete_add (core->autocomplete, \"k\", R_CORE_AUTOCMPLT_SDB, true);\n\t/* macros */\n\tr_core_autocomplete_add (core->autocomplete, \".(\", R_CORE_AUTOCMPLT_MACR, true);\n\tr_core_autocomplete_add (core->autocomplete, \"(-\", R_CORE_AUTOCMPLT_MACR, true);\n\t/* just for hints */\n\tint i;\n\tfor (i = 0; i < radare_argc && radare_argv[i]; i++) {\n\t\tif (!r_core_autocomplete_find (core->autocomplete, radare_argv[i], true)) {\n\t\t\tr_core_autocomplete_add (core->autocomplete, radare_argv[i], R_CORE_AUTOCMPLT_DFLT, true);\n\t\t}\n\t}\n}\n\nstatic void __init_autocomplete (RCore* core) {\n\tint i;\n\tcore->autocomplete = R_NEW0 (RCoreAutocomplete);\n\tif (core->autocomplete_type == AUTOCOMPLETE_DEFAULT) {\n\t\t__init_autocomplete_default (core);\n\t} else if (core->autocomplete_type == AUTOCOMPLETE_MS) {\n\t\tr_core_autocomplete_add (core->autocomplete, \"ls\", R_CORE_AUTOCMPLT_MS, true);\n\t\tr_core_autocomplete_add (core->autocomplete, \"cd\", R_CORE_AUTOCMPLT_MS, true);\n\t\tr_core_autocomplete_add (core->autocomplete, \"cat\", R_CORE_AUTOCMPLT_MS, true);\n\t\tr_core_autocomplete_add (core->autocomplete, \"get\", R_CORE_AUTOCMPLT_MS, true);\n\t\tr_core_autocomplete_add (core->autocomplete, \"mount\", R_CORE_AUTOCMPLT_MS, true);\n\t\tfor (i = 0; i < ms_argc && ms_argv[i]; i++) {\n\t\t\tif (!r_core_autocomplete_find (core->autocomplete, ms_argv[i], true)) {\n\t\t\t\tr_core_autocomplete_add (core->autocomplete, ms_argv[i], R_CORE_AUTOCMPLT_MS, true);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const char *colorfor_cb(void *user, ut64 addr, bool verbose) {\n\treturn r_core_anal_optype_colorfor ((RCore *)user, addr, verbose);\n}\n\nstatic char *hasrefs_cb(void *user, ut64 addr, bool verbose) {\n\treturn r_core_anal_hasrefs ((RCore *)user, addr, verbose);\n}\n\nstatic const char *get_section_name(void *user, ut64 addr) {\n\treturn r_core_get_section_name ((RCore *)user, addr);\n}\n\nstatic char *get_comments_cb(void *user, ut64 addr) {\n\treturn r_core_anal_get_comments ((RCore *)user, addr);\n}\n\nstatic void cb_event_handler(REvent *ev, int event_type, void *user, void *data) {\n\tRCore *core = (RCore *)ev->user;\n\tif (!core->log_events) {\n\t\treturn;\n\t}\n\tREventMeta *rems = data;\n\tchar *str = r_base64_encode_dyn (rems->string, -1);\n\tswitch (event_type) {\n\tcase R_EVENT_META_SET:\n\t\tswitch (rems->type) {\n\t\tcase 'C':\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":add-comment 0x%08\"PFMT64x\" %s\\n\", rems->addr, str? str: \"\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase R_EVENT_META_DEL:\n\t\tswitch (rems->type) {\n\t\tcase 'C':\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":del-comment 0x%08\"PFMT64x, rems->addr));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":del-comment 0x%08\"PFMT64x, rems->addr));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase R_EVENT_META_CLEAR:\n\t\tswitch (rems->type) {\n\t\tcase 'C':\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":clear-comments 0x%08\"PFMT64x, rems->addr));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_core_log_add (ev->user, sdb_fmt (\":clear-comments 0x%08\"PFMT64x, rems->addr));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t// TODO\n\t\tbreak;\n\t}\n\tfree (str);\n}\n\nstatic RFlagItem *core_flg_class_set(RFlag *f, const char *name, ut64 addr, ut32 size) {\n\tr_flag_space_push (f, R_FLAGS_FS_CLASSES);\n\tRFlagItem *res = r_flag_set (f, name, addr, size);\n\tr_flag_space_pop (f);\n\treturn res;\n}\n\nstatic RFlagItem *core_flg_class_get(RFlag *f, const char *name) {\n\tr_flag_space_push (f, R_FLAGS_FS_CLASSES);\n\tRFlagItem *res = r_flag_get (f, name);\n\tr_flag_space_pop (f);\n\treturn res;\n}\n\nstatic RFlagItem *core_flg_fcn_set(RFlag *f, const char *name, ut64 addr, ut32 size) {\n\tr_flag_space_push (f, R_FLAGS_FS_FUNCTIONS);\n\tRFlagItem *res = r_flag_set (f, name, addr, size);\n\tr_flag_space_pop (f);\n\treturn res;\n}\n\nR_API void r_core_autocomplete_reload (RCore *core) {\n\tr_return_if_fail (core);\n\tr_core_autocomplete_free (core->autocomplete);\n\t__init_autocomplete (core);\n}\n\nR_API RFlagItem *r_core_flag_get_by_spaces(RFlag *f, ut64 off) {\n\treturn r_flag_get_by_spaces (f, off,\n\t\tR_FLAGS_FS_FUNCTIONS,\n\t\tR_FLAGS_FS_SIGNS,\n\t\tR_FLAGS_FS_CLASSES,\n\t\tR_FLAGS_FS_SYMBOLS,\n\t\tR_FLAGS_FS_IMPORTS,\n\t\tR_FLAGS_FS_RELOCS,\n\t\tR_FLAGS_FS_STRINGS,\n\t\tR_FLAGS_FS_RESOURCES,\n\t\tR_FLAGS_FS_SYMBOLS_SECTIONS,\n\t\tR_FLAGS_FS_SECTIONS,\n\t\tR_FLAGS_FS_SEGMENTS,\n\t\tNULL);\n}\n\n#if __WINDOWS__\n// XXX move to rcons?\nstatic int win_eprintf(const char *format, ...) {\n\tva_list ap;\n\tva_start (ap, format);\n\tr_cons_win_vhprintf (STD_ERROR_HANDLE, false, format, ap);\n\tva_end (ap);\n\treturn 0;\n}\n#endif\n\nR_API bool r_core_init(RCore *core) {\n\tcore->blocksize = R_CORE_BLOCKSIZE;\n\tcore->block = (ut8 *)calloc (R_CORE_BLOCKSIZE + 1, 1);\n\tif (!core->block) {\n\t\teprintf (\"Cannot allocate %d byte(s)\\n\", R_CORE_BLOCKSIZE);\n\t\t/* XXX memory leak */\n\t\treturn false;\n\t}\n\tr_core_setenv (core);\n\tcore->ev = r_event_new (core);\n\tr_event_hook (core->ev, R_EVENT_ALL, cb_event_handler, NULL);\n\tcore->max_cmd_depth = R_CONS_CMD_DEPTH + 1;\n\tcore->sdb = sdb_new (NULL, \"r2kv.sdb\", 0); // XXX: path must be in home?\n\tcore->lastsearch = NULL;\n\tcore->cmdfilter = NULL;\n\tcore->switch_file_view = 0;\n\tcore->cmdremote = 0;\n\tcore->incomment = false;\n\tcore->config = NULL;\n\tcore->http_up = false;\n\tcore->use_tree_sitter_r2cmd = false;\n\tZERO_FILL (core->root_cmd_descriptor);\n\tcore->print = r_print_new ();\n\tcore->ropchain = r_list_newf ((RListFree)free);\n\tr_core_bind (core, &(core->print->coreb));\n\tcore->print->user = core;\n\tcore->print->num = core->num;\n\tcore->print->offname = r_core_print_offname;\n\tcore->print->offsize = r_core_print_offsize;\n\tcore->print->cb_printf = r_cons_printf;\n#if __WINDOWS__\n\tcore->print->cb_eprintf = win_eprintf;\n#endif\n\tcore->print->cb_color = r_cons_rainbow_get;\n\tcore->print->write = mywrite;\n\tcore->print->exists_var = exists_var;\n\tcore->print->disasm = __disasm;\n\tcore->print->colorfor = colorfor_cb;\n\tcore->print->hasrefs = hasrefs_cb;\n\tcore->print->get_comments = get_comments_cb;\n\tcore->print->get_section_name = get_section_name;\n\tcore->print->use_comments = false;\n\tcore->rtr_n = 0;\n\tcore->blocksize_max = R_CORE_BLOCKSIZE_MAX;\n\tr_core_task_scheduler_init (&core->tasks, core);\n\tcore->watchers = r_list_new ();\n\tcore->watchers->free = (RListFree)r_core_cmpwatch_free;\n\tcore->scriptstack = r_list_new ();\n\tcore->scriptstack->free = (RListFree)free;\n\tcore->log = r_core_log_new ();\n\tcore->times = R_NEW0 (RCoreTimes);\n\tcore->vmode = false;\n\tcore->printidx = 0;\n\tcore->lastcmd = NULL;\n\tcore->cmdlog = NULL;\n\tcore->stkcmd = NULL;\n\tcore->cmdqueue = NULL;\n\tcore->cmdrepeat = true;\n\tcore->yank_buf = r_buf_new ();\n\tcore->num = r_num_new (&num_callback, &str_callback, core);\n\tcore->egg = r_egg_new ();\n\tr_egg_setup (core->egg, R_SYS_ARCH, R_SYS_BITS, 0, R_SYS_OS);\n\n\tcore->undos = r_list_newf ((RListFree)r_core_undo_free);\n\tcore->fixedarch = false;\n\tcore->fixedbits = false;\n\n\t/* initialize libraries */\n\tcore->cons = r_cons_new ();\n\tif (core->cons->refcnt == 1) {\n\t\tcore->cons = r_cons_singleton ();\n\t\tif (core->cons->line) {\n\t\t\tcore->cons->line->user = core;\n\t\t\tcore->cons->line->cb_editor = \\\n\t\t\t\t(RLineEditorCb)&r_core_editor;\n\t\t\tcore->cons->line->cb_fkey = core->cons->cb_fkey;\n\t\t}\n#if __EMSCRIPTEN__\n\t\tcore->cons->user_fgets = NULL;\n#else\n\t\tcore->cons->user_fgets = (void *)r_core_fgets;\n#endif\n\t\t//r_line_singleton ()->user = (void *)core;\n\t\tr_line_hist_load (R2_HOME_HISTORY);\n\t}\n\tcore->print->cons = core->cons;\n\tr_cons_bind (&core->print->consbind);\n\n\t// We save the old num ad user, in order to restore it after free\n\tcore->lang = r_lang_new ();\n\tcore->lang->cmd_str = (char *(*)(void *, const char *))r_core_cmd_str;\n\tcore->lang->cmdf = (int (*)(void *, const char *, ...))r_core_cmdf;\n\tr_core_bind_cons (core);\n\tcore->lang->cb_printf = r_cons_printf;\n\tr_lang_define (core->lang, \"RCore\", \"core\", core);\n\tr_lang_set_user_ptr (core->lang, core);\n\tcore->assembler = r_asm_new ();\n\tcore->assembler->num = core->num;\n\tr_asm_set_user_ptr (core->assembler, core);\n\tcore->anal = r_anal_new ();\n\tcore->gadgets = r_list_newf ((RListFree)r_core_gadget_free);\n\tcore->anal->ev = core->ev;\n\tcore->anal->log = r_core_anal_log;\n\tcore->anal->read_at = r_core_anal_read_at;\n\tcore->anal->flag_get = r_core_flag_get_by_spaces;\n\tcore->anal->cb.on_fcn_new = on_fcn_new;\n\tcore->anal->cb.on_fcn_delete = on_fcn_delete;\n\tcore->anal->cb.on_fcn_rename = on_fcn_rename;\n\tcore->print->sdb_types = core->anal->sdb_types;\n\tcore->assembler->syscall = r_syscall_ref (core->anal->syscall); // BIND syscall anal/asm\n\tr_anal_set_user_ptr (core->anal, core);\n\tcore->anal->cb_printf = (void *) r_cons_printf;\n\tcore->parser = r_parse_new ();\n\tr_anal_bind (core->anal, &(core->parser->analb));\n\tcore->parser->varlist = r_anal_var_list;\n\t/// XXX shouhld be using coreb\n\tr_parse_set_user_ptr (core->parser, core);\n\tcore->bin = r_bin_new ();\n\tr_cons_bind (&core->bin->consb);\n\t// XXX we shuold use RConsBind instead of this hardcoded pointer\n\tcore->bin->cb_printf = (PrintfCallback) r_cons_printf;\n\tr_bin_set_user_ptr (core->bin, core);\n\tcore->io = r_io_new ();\n\tcore->io->ff = 1;\n\tcore->io->user = (void *)core;\n\tcore->io->cb_core_cmd = core_cmd_callback;\n\tcore->io->cb_core_cmdstr = core_cmdstr_callback;\n\tcore->io->cb_core_post_write = core_post_write_callback;\n\tcore->search = r_search_new (R_SEARCH_KEYWORD);\n\tr_io_undo_enable (core->io, 1, 0); // TODO: configurable via eval\n\tcore->fs = r_fs_new ();\n\tcore->flags = r_flag_new ();\n\tcore->flags->cb_printf = r_cons_printf;\n\tcore->graph = r_agraph_new (r_cons_canvas_new (1, 1));\n\tcore->graph->need_reload_nodes = false;\n\tcore->asmqjmps_size = R_CORE_ASMQJMPS_NUM;\n\tif (sizeof (ut64) * core->asmqjmps_size < core->asmqjmps_size) {\n\t\tcore->asmqjmps_size = 0;\n\t\tcore->asmqjmps = NULL;\n\t} else {\n\t\tcore->asmqjmps = R_NEWS (ut64, core->asmqjmps_size);\n\t}\n\n\tr_bin_bind (core->bin, &(core->assembler->binb));\n\tr_bin_bind (core->bin, &(core->anal->binb));\n\tr_bin_bind (core->bin, &(core->anal->binb));\n\n\tr_io_bind (core->io, &(core->search->iob));\n\tr_io_bind (core->io, &(core->print->iob));\n\tr_io_bind (core->io, &(core->anal->iob));\n\tr_io_bind (core->io, &(core->fs->iob));\n\tr_cons_bind (&(core->fs->csb));\n\tr_core_bind (core, &(core->fs->cob));\n\tr_io_bind (core->io, &(core->bin->iob));\n\tr_flag_bind (core->flags, &(core->anal->flb));\n\tcore->anal->flg_class_set = core_flg_class_set;\n\tcore->anal->flg_class_get = core_flg_class_get;\n\tcore->anal->flg_fcn_set = core_flg_fcn_set;\n\tr_anal_bind (core->anal, &(core->parser->analb));\n\tcore->parser->flag_get = r_core_flag_get_by_spaces;\n\tcore->parser->label_get = r_anal_fcn_label_at;\n\n\tr_core_bind (core, &(core->anal->coreb));\n\n\tcore->file = NULL;\n\tcore->files = r_list_newf ((RListFree)r_core_file_free);\n\tcore->offset = 0LL;\n\tcore->prompt_offset = 0LL;\n\tr_core_cmd_init (core);\n\tcore->dbg = r_debug_new (true);\n\n\tr_io_bind (core->io, &(core->dbg->iob));\n\tr_io_bind (core->io, &(core->dbg->bp->iob));\n\tr_core_bind (core, &core->dbg->corebind);\n\tr_core_bind (core, &core->dbg->bp->corebind);\n\tcore->dbg->anal = core->anal; // XXX: dupped instance.. can cause lost pointerz\n\t//r_debug_use (core->dbg, \"native\");\n// XXX pushing uninitialized regstate results in trashed reg values\n//\tr_reg_arena_push (core->dbg->reg); // create a 2 level register state stack\n//\tcore->dbg->anal->reg = core->anal->reg; // XXX: dupped instance.. can cause lost pointerz\n\tcore->io->cb_printf = r_cons_printf;\n\tcore->dbg->cb_printf = r_cons_printf;\n\tcore->dbg->bp->cb_printf = r_cons_printf;\n\tcore->dbg->ev = core->ev;\n\t// initialize config before any corebind\n\tr_core_config_init (core);\n\n\tr_core_loadlibs_init (core);\n\t//r_core_loadlibs (core);\n\n\t// TODO: get arch from r_bin or from native arch\n\tr_asm_use (core->assembler, R_SYS_ARCH);\n\tr_anal_use (core->anal, R_SYS_ARCH);\n\tif (R_SYS_BITS & R_SYS_BITS_64) {\n\t\tr_config_set_i (core->config, \"asm.bits\", 64);\n\t} else {\n\t\tif (R_SYS_BITS & R_SYS_BITS_32) {\n\t\t\tr_config_set_i (core->config, \"asm.bits\", 32);\n\t\t}\n\t}\n\tr_config_set (core->config, \"asm.arch\", R_SYS_ARCH);\n\tr_bp_use (core->dbg->bp, R_SYS_ARCH, core->anal->bits);\n\tupdate_sdb (core);\n\t{\n\t\tchar *a = r_str_r2_prefix (R2_FLAGS);\n\t\tif (a) {\n\t\t\tchar *file = r_str_newf (\"%s/tags.r2\", a);\n\t\t\t(void)r_core_run_script (core, file);\n\t\t\tfree (file);\n\t\t\tfree (a);\n\t\t}\n\t}\n\tr_core_anal_type_init (core);\n\t__init_autocomplete (core);\n\treturn 0;\n}\n\nR_API void __cons_cb_fkey(RCore *core, int fkey) {\n\tchar buf[32];\n\tsnprintf (buf, sizeof (buf), \"key.f%d\", fkey);\n\tconst char *v = r_config_get (core->config, buf);\n\tif (v && *v) {\n\t\tr_cons_printf (\"%s\\n\", v);\n\t\tr_core_cmd0 (core, v);\n\t\tr_cons_flush ();\n\t}\n}\n\nR_API void r_core_bind_cons(RCore *core) {\n\tcore->cons->num = core->num;\n\tcore->cons->cb_fkey = (RConsFunctionKey)__cons_cb_fkey;\n\tcore->cons->cb_editor = (RConsEditorCallback)r_core_editor;\n\tcore->cons->cb_break = (RConsBreakCallback)r_core_break;\n\tcore->cons->cb_sleep_begin = (RConsSleepBeginCallback)r_core_sleep_begin;\n\tcore->cons->cb_sleep_end = (RConsSleepEndCallback)r_core_sleep_end;\n\tcore->cons->cb_task_oneshot = (RConsQueueTaskOneshot) r_core_task_enqueue_oneshot;\n\tcore->cons->user = (void*)core;\n}\n\nR_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\t/* TODO: it leaks as shit */\n\t//update_sdb (c);\n\t// avoid double free\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\t// TODO: sync or not? sdb_sync (c->sdb);\n\t// TODO: sync all dbs?\n\t//r_core_file_free (c->file);\n\t//c->file = NULL;\n\tR_FREE (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\t/* after r_config_free, the value of I.teefile is trashed */\n\t/* rconfig doesnt knows how to deinitialize vars, so we\n\tshould probably need to add a r_config_free_payload callback */\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; // HACK\n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}\n\nR_API void r_core_free(RCore *c) {\n\tif (c) {\n\t\tr_core_fini (c);\n\t\tfree (c);\n\t}\n}\n\nR_API void r_core_prompt_loop(RCore *r) {\n\tint ret;\n\tdo {\n\t\tint err = r_core_prompt (r, false);\n\t\tif (err < 1) {\n\t\t\t// handle ^D\n\t\t\tr->num->value = 0; // r.num->value will be read by r_main_radare2() after calling this fcn\n\t\t\tbreak;\n\t\t}\n\t\t/* -1 means invalid command, -2 means quit prompt loop */\n\t\tif ((ret = r_core_prompt_exec (r)) == -2) {\n\t\t\tbreak;\n\t\t}\n\t} while (ret != R_CORE_CMD_EXIT);\n}\n\nstatic int prompt_flag (RCore *r, char *s, size_t maxlen) {\n\tconst char DOTS[] = \"...\";\n\tconst RFlagItem *f = r_flag_get_at (r->flags, r->offset, false);\n\tif (!f) {\n\t\treturn false;\n\t}\n\tif (f->offset < r->offset) {\n\t\tsnprintf (s, maxlen, \"%s + %\" PFMT64u, f->name, r->offset - f->offset);\n\t} else {\n\t\tsnprintf (s, maxlen, \"%s\", f->name);\n\t}\n\tif (strlen (s) > maxlen - sizeof (DOTS)) {\n\t\ts[maxlen - sizeof (DOTS) - 1] = '\\0';\n\t\tstrcat (s, DOTS);\n\t}\n\treturn true;\n}\n\nstatic void prompt_sec(RCore *r, char *s, size_t maxlen) {\n\tconst RBinSection *sec = r_bin_get_section_at (r_bin_cur_object (r->bin), r->offset, true);\n\tif (!sec) {\n\t\treturn;\n\t}\n\tr_str_ncpy (s, sec->name, maxlen - 2);\n\tstrcat (s, \":\");\n}\n\nstatic void chop_prompt (const char *filename, char *tmp, size_t max_tmp_size) {\n\tsize_t tmp_len, file_len;\n\tunsigned int OTHRSCH = 3;\n\tconst char DOTS[] = \"...\";\n\tint w, p_len;\n\n\tw = r_cons_get_size (NULL);\n\tfile_len = strlen (filename);\n\ttmp_len = strlen (tmp);\n\tp_len = R_MAX (0, w - 6);\n\tif (file_len + tmp_len + OTHRSCH >= p_len) {\n\t\tsize_t dots_size = sizeof (DOTS);\n\t\tsize_t chop_point = (size_t)(p_len - OTHRSCH - file_len - dots_size - 1);\n\t\tif (chop_point < (max_tmp_size - dots_size - 1)) {\n\t\t\ttmp[chop_point] = '\\0';\n\t\t\tstrncat (tmp, DOTS, dots_size);\n\t\t}\n\t}\n}\n\nstatic void set_prompt (RCore *r) {\n\tchar tmp[128];\n\tchar *filename = strdup (\"\");\n\tconst char *cmdprompt = r_config_get (r->config, \"cmd.prompt\");\n\tconst char *BEGIN = \"\";\n\tconst char *END = \"\";\n\tconst char *remote = \"\";\n\n\tif (cmdprompt && *cmdprompt) {\n\t\tr_core_cmd (r, cmdprompt, 0);\n\t}\n\n\tif (r_config_get_i (r->config, \"scr.prompt.file\")) {\n\t\tfree (filename);\n\t\tfilename = r_str_newf (\"\\\"%s\\\"\",\n\t\t\tr->io->desc ? r_file_basename (r->io->desc->name) : \"\");\n\t}\n\tif (r->cmdremote) {\n\t\tchar *s = r_core_cmd_str (r, \"s\");\n\t\tr->offset = r_num_math (NULL, s);\n\t\tfree (s);\n\t\tremote = \"=!\";\n\t}\n\n\tif (r_config_get_i (r->config, \"scr.color\")) {\n\t\tBEGIN = r->cons->context->pal.prompt;\n\t\tEND = r->cons->context->pal.reset;\n\t}\n\n\t// TODO: also in visual prompt and disasm/hexdump ?\n\tif (r_config_get_i (r->config, \"asm.segoff\")) {\n\t\tut32 a, b;\n\t\tunsigned int seggrn = r_config_get_i (r->config, \"asm.seggrn\");\n\n\t\ta = ((r->offset >> 16) << (16 - seggrn));\n\t\tb = (r->offset & 0xffff);\n\t\tsnprintf (tmp, 128, \"%04x:%04x\", a, b);\n\t} else {\n\t\tchar p[64], sec[32];\n\t\tint promptset = false;\n\n\t\tsec[0] = '\\0';\n\t\tif (r_config_get_i (r->config, \"scr.prompt.flag\")) {\n\t\t\tpromptset = prompt_flag (r, p, sizeof (p));\n\t\t}\n\t\tif (r_config_get_i (r->config, \"scr.prompt.sect\")) {\n\t\t\tprompt_sec (r, sec, sizeof (sec));\n\t\t}\n\n\t\tif (!promptset) {\n\t\t\tif (r->print->wide_offsets && r->dbg->bits & R_SYS_BITS_64) {\n\t\t\t\tsnprintf (p, sizeof (p), \"0x%016\" PFMT64x, r->offset);\n\t\t\t} else {\n\t\t\t\tsnprintf (p, sizeof (p), \"0x%08\" PFMT64x, r->offset);\n\t\t\t}\n\t\t}\n\t\tsnprintf (tmp, sizeof (tmp), \"%s%s\", sec, p);\n\t}\n\n\tchop_prompt (filename, tmp, 128);\n\tchar *prompt = r_str_newf (\"%s%s[%s%s]>%s \", filename, BEGIN, remote,\n\t\ttmp, END);\n\tr_line_set_prompt (prompt ? prompt : \"\");\n\n\tR_FREE (filename);\n\tR_FREE (prompt);\n}\n\nR_API int r_core_prompt(RCore *r, int sync) {\n\tchar line[4096];\n\n\tint rnv = r->num->value;\n\tset_prompt (r);\n\tint ret = r_cons_fgets (line, sizeof (line), 0, NULL);\n\tif (ret == -2) {\n\t\treturn R_CORE_CMD_EXIT; // ^D\n\t}\n\tif (ret == -1) {\n\t\treturn false; // FD READ ERROR\n\t}\n\tr->num->value = rnv;\n\tif (sync) {\n\t\treturn r_core_prompt_exec (r);\n\t}\n\tfree (r->cmdqueue);\n\tr->cmdqueue = strdup (line);\n        if (r->scr_gadgets && *line && *line != 'q') {\n                r_core_cmd0 (r, \"pg\");\n        }\n\tr->num->value = r->rc;\n\treturn true;\n}\n\nextern void r_core_echo(RCore *core, const char *input);\n\nR_API int r_core_prompt_exec(RCore *r) {\n\tint ret = r_core_cmd (r, r->cmdqueue, true);\n\tr->rc = r->num->value;\n\t//int ret = r_core_cmd (r, r->cmdqueue, true);\n\tif (r->cons && r->cons->use_tts) {\n\t\tconst char *buf = r_cons_get_buffer();\n\t\tr_sys_tts (buf, true);\n\t\tr->cons->use_tts = false;\n\t}\n\tr_cons_echo (NULL);\n\tr_cons_flush ();\n\tif (r->cons && r->cons->line && r->cons->line->zerosep) {\n\t\tr_cons_zero ();\n\t}\n\treturn ret;\n}\n\nR_API int r_core_seek_size(RCore *core, ut64 addr, int bsize) {\n\tut8 *bump;\n\tint ret = false;\n\tif (bsize < 0) {\n\t\treturn false;\n\t}\n\tif (bsize == core->blocksize) {\n\t\treturn true;\n\t}\n\tif (r_sandbox_enable (0)) {\n\t\t// TODO : restrict to filesize?\n\t\tif (bsize > 1024*32) {\n\t\t\teprintf (\"Sandbox mode restricts blocksize bigger than 32k\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (bsize > core->blocksize_max) {\n\t\teprintf (\"Block size %d is too big\\n\", bsize);\n\t\treturn false;\n\t}\n\tcore->offset = addr;\n\tif (bsize < 1) {\n\t\tbsize = 1;\n\t} else if (core->blocksize_max && bsize>core->blocksize_max) {\n\t\teprintf (\"bsize is bigger than `bm`. dimmed to 0x%x > 0x%x\\n\",\n\t\t\tbsize, core->blocksize_max);\n\t\tbsize = core->blocksize_max;\n\t}\n\tbump = realloc (core->block, bsize + 1);\n\tif (!bump) {\n\t\teprintf (\"Oops. cannot allocate that much (%u)\\n\", bsize);\n\t\tret = false;\n\t} else {\n\t\tret = true;\n\t\tcore->block = bump;\n\t\tcore->blocksize = bsize;\n\t\tmemset (core->block, 0xff, core->blocksize);\n\t\tr_core_block_read (core);\n\t}\n\treturn ret;\n}\n\nR_API int r_core_block_size(RCore *core, int bsize) {\n\treturn r_core_seek_size (core, core->offset, bsize);\n}\n\nR_API int r_core_seek_align(RCore *core, ut64 align, int times) {\n\tint inc = (times >= 0)? 1: -1;\n\tut64 seek = core->offset;\n\tif (!align) {\n\t\treturn false;\n\t}\n\tint diff = core->offset % align;\n\tif (!times) {\n\t\tdiff = -diff;\n\t} else if (diff) {\n\t\tif (inc > 0) {\n\t\t\tdiff += align-diff;\n\t\t} else {\n\t\t\tdiff = -diff;\n\t\t}\n\t\tif (times) {\n\t\t\ttimes -= inc;\n\t\t}\n\t}\n\twhile ((times*inc) > 0) {\n\t\ttimes -= inc;\n\t\tdiff += (align * inc);\n\t}\n\tif (diff < 0 && -diff > seek) {\n\t\tseek = diff = 0;\n\t}\n\treturn r_core_seek (core, seek + diff, 1);\n}\n\nR_API char *r_core_op_str(RCore *core, ut64 addr) {\n\tRAsmOp op = {0};\n\tut8 buf[64];\n\tr_asm_set_pc (core->assembler, addr);\n\tr_io_read_at (core->io, addr, buf, sizeof (buf));\n\tint ret = r_asm_disassemble (core->assembler, &op, buf, sizeof (buf));\n\tchar *str = (ret > 0)? strdup (r_strbuf_get (&op.buf_asm)): NULL;\n\tr_asm_op_fini (&op);\n\treturn str;\n}\n\nR_API RAnalOp *r_core_op_anal(RCore *core, ut64 addr) {\n\tut8 buf[64];\n\tRAnalOp *op = R_NEW (RAnalOp);\n\tr_io_read_at (core->io, addr, buf, sizeof (buf));\n\tr_anal_op (core->anal, op, addr, buf, sizeof (buf), R_ANAL_OP_MASK_ALL);\n\treturn op;\n}\n\nstatic void rap_break (void *u) {\n\tRIORap *rior = (RIORap*) u;\n\tif (u) {\n\t\tr_socket_close (rior->fd);\n\t\trior->fd = NULL;\n\t}\n}\n\n// TODO: PLEASE move into core/io/rap? */\n// TODO: use static buffer instead of mallocs all the time. it's network!\nR_API bool r_core_serve(RCore *core, RIODesc *file) {\n\tut8 cmd, flg, *ptr = NULL, buf[1024];\n\tint i, pipefd = -1;\n\tut64 x;\n\n\tRIORap *rior = (RIORap *)file->data;\n\tif (!rior|| !rior->fd) {\n\t\teprintf (\"rap: cannot listen.\\n\");\n\t\treturn false;\n\t}\n\tRSocket *fd = rior->fd;\n\teprintf (\"RAP Server started (rap.loop=%s)\\n\",\n\t\t\tr_config_get (core->config, \"rap.loop\"));\n\tr_cons_break_push (rap_break, rior);\nreaccept:\n\twhile (!r_cons_is_breaked ()) {\n\t\tRSocket *c = r_socket_accept (fd);\n\t\tif (!c) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tgoto out_of_function;\n\t\t}\n\t\tif (!c) {\n\t\t\teprintf (\"rap: cannot accept\\n\");\n\t\t\tr_socket_free (c);\n\t\t\tgoto out_of_function;\n\t\t}\n\t\teprintf (\"rap: client connected\\n\");\n\t\tfor (;!r_cons_is_breaked ();) {\n\t\t\tif (!r_socket_read (c, &cmd, 1)) {\n\t\t\t\teprintf (\"rap: connection closed\\n\");\n\t\t\t\tif (r_config_get_i (core->config, \"rap.loop\")) {\n\t\t\t\t\teprintf (\"rap: waiting for new connection\\n\");\n\t\t\t\t\tr_socket_free (c);\n\t\t\t\t\tgoto reaccept;\n\t\t\t\t}\n\t\t\t\tgoto out_of_function;\n\t\t\t}\n\t\t\tswitch ((ut8)cmd) {\n\t\t\tcase RMT_OPEN:\n\t\t\t\tr_socket_read_block (c, &flg, 1); // flags\n\t\t\t\teprintf (\"open (%d): \", cmd);\n\t\t\t\tr_socket_read_block (c, &cmd, 1); // len\n\t\t\t\tpipefd = -1;\n\t\t\t\tptr = malloc (cmd + 1);\n\t\t\t\t//XXX cmd is ut8..so <256 if (cmd<RMT_MAX)\n\t\t\t\tif (!ptr) {\n\t\t\t\t\teprintf (\"Cannot malloc in rmt-open len = %d\\n\", cmd);\n\t\t\t\t} else {\n\t\t\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.laddr\");\n\t\t\t\t\tr_socket_read_block (c, ptr, cmd);\n\t\t\t\t\tptr[cmd] = 0;\n\t\t\t\t\tut32 perm = R_PERM_R;\n\t\t\t\t\tif (flg & R_PERM_W) {\n\t\t\t\t\t\tperm |= R_PERM_W;\n\t\t\t\t\t}\n\t\t\t\t\tif (r_core_file_open (core, (const char *)ptr, perm, 0)) {\n\t\t\t\t\t\tint fd = r_io_fd_get_current (core->io);\n\t\t\t\t\t\tr_core_bin_load (core, NULL, baddr);\n\t\t\t\t\t\tr_io_map_add (core->io, fd, perm, 0, 0, r_io_fd_size (core->io, fd));\n\t\t\t\t\t\tif (core->file) {\n\t\t\t\t\t\t\tpipefd = fd;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpipefd = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\teprintf (\"(flags: %d) len: %d filename: '%s'\\n\",\n\t\t\t\t\t\t\tflg, cmd, ptr); //config.file);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpipefd = -1;\n\t\t\t\t\t\teprintf (\"Cannot open file (%s)\\n\", ptr);\n\t\t\t\t\t\tr_socket_close (c);\n\t\t\t\t\t\tif (r_config_get_i (core->config, \"rap.loop\")) {\n\t\t\t\t\t\t\teprintf (\"rap: waiting for new connection\\n\");\n\t\t\t\t\t\t\tr_socket_free (c);\n\t\t\t\t\t\t\tgoto reaccept;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto out_of_function; //XXX: Close connection and goto accept\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[0] = RMT_OPEN | RMT_REPLY;\n\t\t\t\tr_write_be32 (buf + 1, pipefd);\n\t\t\t\tr_socket_write (c, buf, 5);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\tR_FREE (ptr);\n\t\t\t\tbreak;\n\t\t\tcase RMT_READ:\n\t\t\t\tr_socket_read_block (c, (ut8*)&buf, 4);\n\t\t\t\ti = r_read_be32 (buf);\n\t\t\t\tptr = (ut8 *)malloc (i + core->blocksize + 5);\n\t\t\t\tif (ptr) {\n\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t\tptr[0] = RMT_READ | RMT_REPLY;\n\t\t\t\t\tif (i > RMT_MAX) {\n\t\t\t\t\t\ti = RMT_MAX;\n\t\t\t\t\t}\n\t\t\t\t\tif (i > core->blocksize) {\n\t\t\t\t\t\tr_core_block_size (core, i);\n\t\t\t\t\t}\n\t\t\t\t\tif (i + 128 < core->blocksize) {\n\t\t\t\t\t\tr_core_block_size (core, i);\n\t\t\t\t\t}\n\t\t\t\t\tr_write_be32 (ptr + 1, i);\n\t\t\t\t\tmemcpy (ptr + 5, core->block, i); //core->blocksize);\n\t\t\t\t\tr_socket_write (c, ptr, i + 5);\n\t\t\t\t\tr_socket_flush (c);\n\t\t\t\t\tR_FREE (ptr);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Cannot read %d byte(s)\\n\", i);\n\t\t\t\t\tr_socket_free (c);\n\t\t\t\t\t// TODO: reply error here\n\t\t\t\t\tgoto out_of_function;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RMT_CMD:\n\t\t\t\t{\n\t\t\t\tchar *cmd = NULL, *cmd_output = NULL;\n\t\t\t\tchar bufr[8], *bufw = NULL;\n\t\t\t\tut32 cmd_len = 0;\n\t\t\t\tint i;\n\n\t\t\t\t/* read */\n\t\t\t\tr_socket_read_block (c, (ut8*)&bufr, 4);\n\t\t\t\ti = r_read_be32 (bufr);\n\t\t\t\tif (i > 0 && i < RMT_MAX) {\n\t\t\t\t\tif ((cmd = malloc (i + 1))) {\n\t\t\t\t\t\tr_socket_read_block (c, (ut8*)cmd, i);\n\t\t\t\t\t\tcmd[i] = '\\0';\n\t\t\t\t\t\tint scr_interactive = r_config_get_i (core->config, \"scr.interactive\");\n\t\t\t\t\t\tr_config_set_i (core->config, \"scr.interactive\", 0);\n\t\t\t\t\t\tcmd_output = r_core_cmd_str (core, cmd);\n\t\t\t\t\t\tr_config_set_i (core->config, \"scr.interactive\", scr_interactive);\n\t\t\t\t\t\tfree (cmd);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"rap: cannot malloc\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"rap: invalid length '%d'\\n\", i);\n\t\t\t\t}\n\t\t\t\t/* write */\n\t\t\t\tif (cmd_output) {\n\t\t\t\t\tcmd_len = strlen (cmd_output) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcmd_output = strdup (\"\");\n\t\t\t\t\tcmd_len = 0;\n\t\t\t\t}\n#if DEMO_SERVER_SENDS_CMD_TO_CLIENT\n\t\t\t\tstatic bool once = true;\n\t\t\t\t/* TODO: server can reply a command request to the client only here */\n\t\t\t\tif (once) {\n\t\t\t\t\tconst char *cmd = \"pd 4\";\n\t\t\t\t\tint cmd_len = strlen (cmd) + 1;\n\t\t\t\t\tut8 *b = malloc (cmd_len + 5);\n\t\t\t\t\tb[0] = RMT_CMD;\n\t\t\t\t\tr_write_be32 (b + 1, cmd_len);\n\t\t\t\t\tstrcpy ((char *)b+ 5, cmd);\n\t\t\t\t\tr_socket_write (c, b, 5 + cmd_len);\n\t\t\t\t\tr_socket_flush (c);\n\n\t\t\t\t\t/* read response */\n\t\t\t\t\tr_socket_read (c, b, 5);\n\t\t\t\t\tif (b[0] == (RMT_CMD | RMT_REPLY)) {\n\t\t\t\t\t\tut32 n = r_read_be32 (b + 1);\n\t\t\t\t\t\teprintf (\"REPLY %d\\n\", n);\n\t\t\t\t\t\tif (n > 0) {\n\t\t\t\t\t\t\tut8 *res = calloc (1, n);\n\t\t\t\t\t\t\tr_socket_read (c, res, n);\n\t\t\t\t\t\t\teprintf (\"RESPONSE(%s)\\n\", (const char *)res);\n\t\t\t\t\t\t\tfree (res);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_socket_flush (c);\n\t\t\t\t\tfree (b);\n\t\t\t\t\tonce = false;\n\t\t\t\t}\n#endif\n\t\t\t\tbufw = malloc (cmd_len + 5);\n\t\t\t\tbufw[0] = (ut8) (RMT_CMD | RMT_REPLY);\n\t\t\t\tr_write_be32 (bufw + 1, cmd_len);\n\t\t\t\tmemcpy (bufw + 5, cmd_output, cmd_len);\n\t\t\t\tr_socket_write (c, bufw, cmd_len+5);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\tfree (bufw);\n\t\t\t\tfree (cmd_output);\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase RMT_WRITE:\n\t\t\t\tr_socket_read (c, buf, 4);\n\t\t\t\tx = r_read_at_be32 (buf, 0);\n\t\t\t\tptr = malloc (x);\n\t\t\t\tr_socket_read (c, ptr, x);\n\t\t\t\tint ret = r_core_write_at (core, core->offset, ptr, x);\n\t\t\t\tbuf[0] = RMT_WRITE | RMT_REPLY;\n\t\t\t\tr_write_be32 (buf + 1, ret);\n\t\t\t\tr_socket_write (c, buf, 5);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\tR_FREE (ptr);\n\t\t\t\tbreak;\n\t\t\tcase RMT_SEEK:\n\t\t\t\tr_socket_read_block (c, buf, 9);\n\t\t\t\tx = r_read_at_be64 (buf, 1);\n\t\t\t\tif (buf[0] == 2) {\n\t\t\t\t\tif (core->file) {\n\t\t\t\t\t\tx = r_io_fd_size (core->io, core->file->fd);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (buf[0] == 0) {\n\t\t\t\t\t\tr_core_seek (core, x, 1); //buf[0]);\n\t\t\t\t\t}\n\t\t\t\t\tx = core->offset;\n\t\t\t\t}\n\t\t\t\tbuf[0] = RMT_SEEK | RMT_REPLY;\n\t\t\t\tr_write_be64 (buf + 1, x);\n\t\t\t\tr_socket_write (c, buf, 9);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\tbreak;\n\t\t\tcase RMT_CLOSE:\n\t\t\t\t// XXX : proper shutdown\n\t\t\t\tr_socket_read_block (c, buf, 4);\n\t\t\t\ti = r_read_be32 (buf);\n\t\t\t\t{\n\t\t\t\t//FIXME: Use r_socket_close\n\t\t\t\tint ret = close (i);\n\t\t\t\tr_write_be32 (buf + 1, ret);\n\t\t\t\tbuf[0] = RMT_CLOSE | RMT_REPLY;\n\t\t\t\tr_socket_write (c, buf, 5);\n\t\t\t\tr_socket_flush (c);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (cmd == 'G') {\n\t\t\t\t\t// silly http emulation over rap://\n\t\t\t\t\tchar line[256] = {0};\n\t\t\t\t\tchar *cmd = line;\n\t\t\t\t\tr_socket_read (c, (ut8*)line, sizeof (line));\n\t\t\t\t\tif (!strncmp (line, \"ET /cmd/\", 8)) {\n\t\t\t\t\t\tcmd = line + 8;\n\t\t\t\t\t\tchar *http = strstr (cmd, \"HTTP\");\n\t\t\t\t\t\tif (http) {\n\t\t\t\t\t\t\t*http = 0;\n\t\t\t\t\t\t\thttp--;\n\t\t\t\t\t\t\tif (*http == ' ') {\n\t\t\t\t\t\t\t\t*http = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_str_uri_decode (cmd);\n\t\t\t\t\t\tchar *res = r_core_cmd_str (core, cmd);\n\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\tr_socket_printf (c, \"HTTP/1.0 %d %s\\r\\n%s\"\n\t\t\t\t\t\t\t\t\t\"Connection: close\\r\\nContent-Length: %d\\r\\n\\r\\n\",\n\t\t\t\t\t\t\t\t\t200, \"OK\", \"\", -1); // strlen (res));\n\t\t\t\t\t\t\tr_socket_write (c, res, strlen (res));\n\t\t\t\t\t\t\tfree (res);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_socket_flush (c);\n\t\t\t\t\t\tr_socket_close (c);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"[r2p] unknown command 0x%02x\\n\", cmd);\n\t\t\t\t\tr_socket_close (c);\n\t\t\t\t\tR_FREE (ptr);\n\t\t\t\t}\n\t\t\t\tif (r_config_get_i (core->config, \"rap.loop\")) {\n\t\t\t\t\teprintf (\"rap: waiting for new connection\\n\");\n\t\t\t\t\tr_socket_free (c);\n\t\t\t\t\tgoto reaccept;\n\t\t\t\t}\n\t\t\t\tgoto out_of_function;\n\t\t\t}\n\t\t}\n\t\teprintf (\"client: disconnected\\n\");\n\t\tr_socket_free (c);\n\t}\nout_of_function:\n\tr_cons_break_pop ();\n\treturn false;\n}\n\nR_API int r_core_search_cb(RCore *core, ut64 from, ut64 to, RCoreSearchCallback cb) {\n\tint ret, len = core->blocksize;\n\tut8 *buf;\n\tif ((buf = malloc (len))) {\n\t\twhile (from < to) {\n\t\t\tut64 delta = to-from;\n\t\t\tif (delta < len) {\n\t\t\t\tlen = (int)delta;\n\t\t\t}\n\t\t\tif (!r_io_read_at (core->io, from, buf, len)) {\n\t\t\t\teprintf (\"Cannot read at 0x%\"PFMT64x\"\\n\", from);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (ret = 0; ret < len;) {\n\t\t\t\tint done = cb (core, from, buf+ret, len-ret);\n\t\t\t\tif (done < 1) { /* interrupted */\n\t\t\t\t\tfree (buf);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tret += done;\n\t\t\t}\n\t\t\tfrom += len;\n\t\t}\n\t\tfree (buf);\n\t} else {\n\t\teprintf (\"Cannot allocate blocksize\\n\");\n\t}\n\treturn true;\n}\n\nR_API char *r_core_editor(const RCore *core, const char *file, const char *str) {\n\tconst bool interactive = r_cons_is_interactive ();\n\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n\tchar *name = NULL, *ret = NULL;\n\tint fd;\n\n\tif (!interactive || !editor || !*editor) {\n\t\treturn NULL;\n\t}\n\tbool readonly = false;\n\tif (file && *file != '*') {\n\t\tname = strdup (file);\n\t\tfd = r_sandbox_open (file, O_RDWR, 0644);\n\t\tif (fd == -1) {\n\t\t\tfd = r_sandbox_open (file, O_RDONLY, 0644);\n\t\t\treadonly = true;\n\t\t}\n\t} else {\n\t\tfd = r_file_mkstemp (file, &name);\n\t}\n\tif (fd == -1) {\n\t\tfree (name);\n\t\treturn NULL;\n\t}\n\tif (readonly) {\n\t\teprintf (\"Opening in read-only\\n\");\n\t} else {\n\t\tif (str) {\n\t\t\twrite (fd, str, strlen (str));\n\t\t}\n\t}\n\tclose (fd);\n\n\tif (name && (!editor || !*editor || !strcmp (editor, \"-\"))) {\n\t\tRCons *cons = r_cons_singleton ();\n\t\tvoid *tmp = cons->cb_editor;\n\t\tcons->cb_editor = NULL;\n\t\tr_cons_editor (name, NULL);\n\t\tcons->cb_editor = tmp;\n\t} else {\n\t\tif (editor && name) {\n\t\t\tr_sys_cmdf (\"%s '%s'\", editor, name);\n\t\t}\n\t}\n\tsize_t len = 0;\n\tret = name? r_file_slurp (name, &len): 0;\n\tif (ret) {\n\t\tif (len && ret[len - 1] == '\\n') {\n\t\t\tret[len - 1] = 0; // chop\n\t\t}\n\t\tif (!file) {\n\t\t\tr_file_rm (name);\n\t\t}\n\t}\n\tfree (name);\n\treturn ret;\n}\n\n/* weak getters */\nR_API RCons *r_core_get_cons (RCore *core) {\n\treturn core->cons;\n}\n\nR_API RConfig *r_core_get_config (RCore *core) {\n\treturn core->config;\n}\n\nR_API RBin *r_core_get_bin (RCore *core) {\n\treturn core->bin;\n}\n\nR_API RBuffer *r_core_syscallf (RCore *core, const char *name, const char *fmt, ...) {\n\tchar str[1024];\n\tRBuffer *buf;\n\tva_list ap;\n\tva_start (ap, fmt);\n\n\tvsnprintf (str, sizeof (str), fmt, ap);\n\tbuf = r_core_syscall (core, name, str);\n\n\tva_end (ap);\n\treturn buf;\n}\n\nR_API RBuffer *r_core_syscall (RCore *core, const char *name, const char *args) {\n\tRBuffer *b = NULL;\n\tchar code[1024];\n\tint num;\n\n\t//arch check\n\tif (strcmp (core->anal->cur->arch, \"x86\")) {\n\t\teprintf (\"architecture not yet supported!\\n\");\n\t\treturn 0;\n\t}\n\n\tnum = r_syscall_get_num (core->anal->syscall, name);\n\n\t//bits check\n\tswitch (core->assembler->bits) {\n\tcase 32:\n\t\tif (strcmp (name, \"setup\") && !num ) {\n\t\t\teprintf (\"syscall not found!\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase 64:\n\t\tif (strcmp (name, \"read\") && !num ) {\n\t\t\teprintf (\"syscall not found!\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"syscall not found!\\n\");\n\t\treturn 0;\n\t}\n\n\tsnprintf (code, sizeof (code),\n\t\t\"sc@syscall(%d);\\n\"\n\t\t\"main@global(0) { sc(%s);\\n\"\n\t\t\":int3\\n\" /// XXX USE trap\n\t\t\"}\\n\", num, args);\n\tr_egg_reset (core->egg);\n\t// TODO: setup arch/bits/os?\n\tr_egg_load (core->egg, code, 0);\n\n\tif (!r_egg_compile (core->egg)) {\n\t\teprintf (\"Cannot compile.\\n\");\n\t}\n\tif (!r_egg_assemble (core->egg)) {\n\t\teprintf (\"r_egg_assemble: invalid assembly\\n\");\n\t}\n\tif ((b = r_egg_get_bin (core->egg))) {\n#if 0\n\t\tif (b->length > 0) {\n\t\t\tfor (i = 0; i < b->length; i++) {\n\t\t\t\tr_cons_printf (\"%02x\", b->buf[i]);\n\t\t\t}\n\t\t\tr_cons_printf (\"\\n\");\n\t\t}\n#endif\n\t}\n\treturn b;\n}\n\nR_API RCoreAutocomplete *r_core_autocomplete_add(RCoreAutocomplete *parent, const char* cmd, int type, bool lock) {\n\tif (!parent || !cmd || type < 0 || type >= R_CORE_AUTOCMPLT_END) {\n\t\treturn NULL;\n\t}\n\tRCoreAutocomplete *autocmpl = R_NEW0 (RCoreAutocomplete);\n\tif (!autocmpl) {\n\t\treturn NULL;\n\t}\n\tRCoreAutocomplete **updated = realloc (parent->subcmds, (parent->n_subcmds + 1) * sizeof (RCoreAutocomplete*));\n\tif (!updated) {\n\t\tfree (autocmpl);\n\t\treturn NULL;\n\t}\n\tparent->subcmds = updated;\n\tparent->subcmds[parent->n_subcmds] = autocmpl;\n\tparent->n_subcmds++;\n\tautocmpl->cmd = strdup (cmd);\n\tautocmpl->locked = lock;\n\tautocmpl->type = type;\n\tautocmpl->length = strlen (cmd);\n\treturn autocmpl;\n}\n\nR_API void r_core_autocomplete_free(RCoreAutocomplete *obj) {\n\tif (!obj) {\n\t\treturn;\n\t}\n\tint i;\n\tfor (i = 0; i < obj->n_subcmds; i++) {\n\t\tr_core_autocomplete_free (obj->subcmds[i]);\n\t\tobj->subcmds[i] = NULL;\n\t}\n\tfree (obj->subcmds);\n\tfree ((char*) obj->cmd);\n\tfree (obj);\n}\n\nR_API RCoreAutocomplete *r_core_autocomplete_find(RCoreAutocomplete *parent, const char* cmd, bool exact) {\n\tif (!parent || !cmd) {\n\t\treturn false;\n\t}\n\tint len = strlen (cmd);\n\tint i;\n\tfor (i = 0; i < parent->n_subcmds; i++) {\n\t\tif (exact && len == parent->subcmds[i]->length && !strncmp (cmd, parent->subcmds[i]->cmd, len)) {\n\t\t\treturn parent->subcmds[i];\n\t\t} else if (!exact && !strncmp (cmd, parent->subcmds[i]->cmd, len)) {\n\t\t\treturn parent->subcmds[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API bool r_core_autocomplete_remove(RCoreAutocomplete *parent, const char* cmd) {\n\tif (!parent || !cmd) {\n\t\treturn false;\n\t}\n\tint i, j;\n\tfor (i = 0; i < parent->n_subcmds; i++) {\n\t\tRCoreAutocomplete *ac = parent->subcmds[i];\n\t\tif (ac->locked) {\n\t\t\tcontinue;\n\t\t}\n\t\t// if (!strncmp (parent->subcmds[i]->cmd, cmd, parent->subcmds[i]->length)) {\n\t\tif (r_str_glob (ac->cmd, cmd)) {\n\t\t\tfor (j = i + 1; j < parent->n_subcmds; j++) {\n\t\t\t\tparent->subcmds[j - 1] = parent->subcmds[j];\n\t\t\t\tparent->subcmds[j] = NULL;\n\t\t\t}\n\t\t\tr_core_autocomplete_free (ac);\n\t\t\tRCoreAutocomplete **updated = realloc (parent->subcmds, (parent->n_subcmds - 1) * sizeof (RCoreAutocomplete*));\n\t\t\tif (!updated && (parent->n_subcmds - 1) > 0) {\n\t\t\t\teprintf (\"Something really bad has happen.. this should never ever happen..\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tparent->subcmds = updated;\n\t\t\tparent->n_subcmds--;\n\t\t\ti--;\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API RTable *r_core_table(RCore *core) {\n\tRTable *table = r_table_new ();\n\tif (table) {\n\t\ttable->cons = core->cons;\n\t}\n\treturn table;\n}\n"], "filenames": ["libr/core/core.c"], "buggy_code_start_loc": [2845], "buggy_code_end_loc": [2846], "fixing_code_start_loc": [2845], "fixing_code_end_loc": [2846], "type": "CWE-415", "message": "A double free issue was discovered in radare2 in cmd_info.c:cmd_info(). Successful exploitation could lead to modification of unexpected memory locations and potentially causing a crash.", "other": {"cve": {"id": "CVE-2020-27794", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-19T23:15:08.427", "lastModified": "2022-08-22T13:47:12.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A double free issue was discovered in radare2 in cmd_info.c:cmd_info(). Successful exploitation could lead to modification of unexpected memory locations and potentially causing a crash."}, {"lang": "es", "value": "Se ha detectado un problema de doble liberaci\u00f3n en radare2 en la funci\u00f3n cmd_info.c:cmd_info(). Una explotaci\u00f3n con \u00e9xito podr\u00eda conllevar a una modificaci\u00f3n de ubicaciones de memoria no esperadas y causar potencialmente un bloqueo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4.0", "matchCriteriaId": "EEE8DA49-FB7A-4416-8942-56DD67E62CD9"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/cb8b683758edddae2d2f62e8e63a738c39f92683", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radareorg/radare2/issues/16303", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/cb8b683758edddae2d2f62e8e63a738c39f92683"}}