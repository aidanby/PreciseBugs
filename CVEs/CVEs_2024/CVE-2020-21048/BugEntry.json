{"buggy_code": ["/*\n * Copyright (c) 2014-2018 Hayaki Saito\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#if HAVE_LIMITS_H\n# include <limits.h>\n#endif\n\n#if HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n\n#include \"dither.h\"\n#include \"quant.h\"\n#include <sixel.h>\n\n\nstatic const unsigned char pal_mono_dark[] = {\n    0x00, 0x00, 0x00, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_mono_light[] = {\n    0xff, 0xff, 0xff, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char pal_gray_1bit[] = {\n    0x00, 0x00, 0x00, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_gray_2bit[] = {\n    0x00, 0x00, 0x00, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_gray_4bit[] = {\n    0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x33, 0x33, 0x33,\n    0x44, 0x44, 0x44, 0x55, 0x55, 0x55, 0x66, 0x66, 0x66, 0x77, 0x77, 0x77,\n    0x88, 0x88, 0x88, 0x99, 0x99, 0x99, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb,\n    0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xee, 0xee, 0xee, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_gray_8bit[] = {\n    0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03,\n    0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07,\n    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b,\n    0x0c, 0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f,\n    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13,\n    0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17,\n    0x18, 0x18, 0x18, 0x19, 0x19, 0x19, 0x1a, 0x1a, 0x1a, 0x1b, 0x1b, 0x1b,\n    0x1c, 0x1c, 0x1c, 0x1d, 0x1d, 0x1d, 0x1e, 0x1e, 0x1e, 0x1f, 0x1f, 0x1f,\n    0x20, 0x20, 0x20, 0x21, 0x21, 0x21, 0x22, 0x22, 0x22, 0x23, 0x23, 0x23,\n    0x24, 0x24, 0x24, 0x25, 0x25, 0x25, 0x26, 0x26, 0x26, 0x27, 0x27, 0x27,\n    0x28, 0x28, 0x28, 0x29, 0x29, 0x29, 0x2a, 0x2a, 0x2a, 0x2b, 0x2b, 0x2b,\n    0x2c, 0x2c, 0x2c, 0x2d, 0x2d, 0x2d, 0x2e, 0x2e, 0x2e, 0x2f, 0x2f, 0x2f,\n    0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x32, 0x32, 0x32, 0x33, 0x33, 0x33,\n    0x34, 0x34, 0x34, 0x35, 0x35, 0x35, 0x36, 0x36, 0x36, 0x37, 0x37, 0x37,\n    0x38, 0x38, 0x38, 0x39, 0x39, 0x39, 0x3a, 0x3a, 0x3a, 0x3b, 0x3b, 0x3b,\n    0x3c, 0x3c, 0x3c, 0x3d, 0x3d, 0x3d, 0x3e, 0x3e, 0x3e, 0x3f, 0x3f, 0x3f,\n    0x40, 0x40, 0x40, 0x41, 0x41, 0x41, 0x42, 0x42, 0x42, 0x43, 0x43, 0x43,\n    0x44, 0x44, 0x44, 0x45, 0x45, 0x45, 0x46, 0x46, 0x46, 0x47, 0x47, 0x47,\n    0x48, 0x48, 0x48, 0x49, 0x49, 0x49, 0x4a, 0x4a, 0x4a, 0x4b, 0x4b, 0x4b,\n    0x4c, 0x4c, 0x4c, 0x4d, 0x4d, 0x4d, 0x4e, 0x4e, 0x4e, 0x4f, 0x4f, 0x4f,\n    0x50, 0x50, 0x50, 0x51, 0x51, 0x51, 0x52, 0x52, 0x52, 0x53, 0x53, 0x53,\n    0x54, 0x54, 0x54, 0x55, 0x55, 0x55, 0x56, 0x56, 0x56, 0x57, 0x57, 0x57,\n    0x58, 0x58, 0x58, 0x59, 0x59, 0x59, 0x5a, 0x5a, 0x5a, 0x5b, 0x5b, 0x5b,\n    0x5c, 0x5c, 0x5c, 0x5d, 0x5d, 0x5d, 0x5e, 0x5e, 0x5e, 0x5f, 0x5f, 0x5f,\n    0x60, 0x60, 0x60, 0x61, 0x61, 0x61, 0x62, 0x62, 0x62, 0x63, 0x63, 0x63,\n    0x64, 0x64, 0x64, 0x65, 0x65, 0x65, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67,\n    0x68, 0x68, 0x68, 0x69, 0x69, 0x69, 0x6a, 0x6a, 0x6a, 0x6b, 0x6b, 0x6b,\n    0x6c, 0x6c, 0x6c, 0x6d, 0x6d, 0x6d, 0x6e, 0x6e, 0x6e, 0x6f, 0x6f, 0x6f,\n    0x70, 0x70, 0x70, 0x71, 0x71, 0x71, 0x72, 0x72, 0x72, 0x73, 0x73, 0x73,\n    0x74, 0x74, 0x74, 0x75, 0x75, 0x75, 0x76, 0x76, 0x76, 0x77, 0x77, 0x77,\n    0x78, 0x78, 0x78, 0x79, 0x79, 0x79, 0x7a, 0x7a, 0x7a, 0x7b, 0x7b, 0x7b,\n    0x7c, 0x7c, 0x7c, 0x7d, 0x7d, 0x7d, 0x7e, 0x7e, 0x7e, 0x7f, 0x7f, 0x7f,\n    0x80, 0x80, 0x80, 0x81, 0x81, 0x81, 0x82, 0x82, 0x82, 0x83, 0x83, 0x83,\n    0x84, 0x84, 0x84, 0x85, 0x85, 0x85, 0x86, 0x86, 0x86, 0x87, 0x87, 0x87,\n    0x88, 0x88, 0x88, 0x89, 0x89, 0x89, 0x8a, 0x8a, 0x8a, 0x8b, 0x8b, 0x8b,\n    0x8c, 0x8c, 0x8c, 0x8d, 0x8d, 0x8d, 0x8e, 0x8e, 0x8e, 0x8f, 0x8f, 0x8f,\n    0x90, 0x90, 0x90, 0x91, 0x91, 0x91, 0x92, 0x92, 0x92, 0x93, 0x93, 0x93,\n    0x94, 0x94, 0x94, 0x95, 0x95, 0x95, 0x96, 0x96, 0x96, 0x97, 0x97, 0x97,\n    0x98, 0x98, 0x98, 0x99, 0x99, 0x99, 0x9a, 0x9a, 0x9a, 0x9b, 0x9b, 0x9b,\n    0x9c, 0x9c, 0x9c, 0x9d, 0x9d, 0x9d, 0x9e, 0x9e, 0x9e, 0x9f, 0x9f, 0x9f,\n    0xa0, 0xa0, 0xa0, 0xa1, 0xa1, 0xa1, 0xa2, 0xa2, 0xa2, 0xa3, 0xa3, 0xa3,\n    0xa4, 0xa4, 0xa4, 0xa5, 0xa5, 0xa5, 0xa6, 0xa6, 0xa6, 0xa7, 0xa7, 0xa7,\n    0xa8, 0xa8, 0xa8, 0xa9, 0xa9, 0xa9, 0xaa, 0xaa, 0xaa, 0xab, 0xab, 0xab,\n    0xac, 0xac, 0xac, 0xad, 0xad, 0xad, 0xae, 0xae, 0xae, 0xaf, 0xaf, 0xaf,\n    0xb0, 0xb0, 0xb0, 0xb1, 0xb1, 0xb1, 0xb2, 0xb2, 0xb2, 0xb3, 0xb3, 0xb3,\n    0xb4, 0xb4, 0xb4, 0xb5, 0xb5, 0xb5, 0xb6, 0xb6, 0xb6, 0xb7, 0xb7, 0xb7,\n    0xb8, 0xb8, 0xb8, 0xb9, 0xb9, 0xb9, 0xba, 0xba, 0xba, 0xbb, 0xbb, 0xbb,\n    0xbc, 0xbc, 0xbc, 0xbd, 0xbd, 0xbd, 0xbe, 0xbe, 0xbe, 0xbf, 0xbf, 0xbf,\n    0xc0, 0xc0, 0xc0, 0xc1, 0xc1, 0xc1, 0xc2, 0xc2, 0xc2, 0xc3, 0xc3, 0xc3,\n    0xc4, 0xc4, 0xc4, 0xc5, 0xc5, 0xc5, 0xc6, 0xc6, 0xc6, 0xc7, 0xc7, 0xc7,\n    0xc8, 0xc8, 0xc8, 0xc9, 0xc9, 0xc9, 0xca, 0xca, 0xca, 0xcb, 0xcb, 0xcb,\n    0xcc, 0xcc, 0xcc, 0xcd, 0xcd, 0xcd, 0xce, 0xce, 0xce, 0xcf, 0xcf, 0xcf,\n    0xd0, 0xd0, 0xd0, 0xd1, 0xd1, 0xd1, 0xd2, 0xd2, 0xd2, 0xd3, 0xd3, 0xd3,\n    0xd4, 0xd4, 0xd4, 0xd5, 0xd5, 0xd5, 0xd6, 0xd6, 0xd6, 0xd7, 0xd7, 0xd7,\n    0xd8, 0xd8, 0xd8, 0xd9, 0xd9, 0xd9, 0xda, 0xda, 0xda, 0xdb, 0xdb, 0xdb,\n    0xdc, 0xdc, 0xdc, 0xdd, 0xdd, 0xdd, 0xde, 0xde, 0xde, 0xdf, 0xdf, 0xdf,\n    0xe0, 0xe0, 0xe0, 0xe1, 0xe1, 0xe1, 0xe2, 0xe2, 0xe2, 0xe3, 0xe3, 0xe3,\n    0xe4, 0xe4, 0xe4, 0xe5, 0xe5, 0xe5, 0xe6, 0xe6, 0xe6, 0xe7, 0xe7, 0xe7,\n    0xe8, 0xe8, 0xe8, 0xe9, 0xe9, 0xe9, 0xea, 0xea, 0xea, 0xeb, 0xeb, 0xeb,\n    0xec, 0xec, 0xec, 0xed, 0xed, 0xed, 0xee, 0xee, 0xee, 0xef, 0xef, 0xef,\n    0xf0, 0xf0, 0xf0, 0xf1, 0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf3, 0xf3, 0xf3,\n    0xf4, 0xf4, 0xf4, 0xf5, 0xf5, 0xf5, 0xf6, 0xf6, 0xf6, 0xf7, 0xf7, 0xf7,\n    0xf8, 0xf8, 0xf8, 0xf9, 0xf9, 0xf9, 0xfa, 0xfa, 0xfa, 0xfb, 0xfb, 0xfb,\n    0xfc, 0xfc, 0xfc, 0xfd, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_xterm256[] = {\n    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,\n    0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0xc0,\n    0x80, 0x80, 0x80, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00,\n    0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x87, 0x00, 0x00, 0xaf,\n    0x00, 0x00, 0xd7, 0x00, 0x00, 0xff, 0x00, 0x5f, 0x00, 0x00, 0x5f, 0x5f,\n    0x00, 0x5f, 0x87, 0x00, 0x5f, 0xaf, 0x00, 0x5f, 0xd7, 0x00, 0x5f, 0xff,\n    0x00, 0x87, 0x00, 0x00, 0x87, 0x5f, 0x00, 0x87, 0x87, 0x00, 0x87, 0xaf,\n    0x00, 0x87, 0xd7, 0x00, 0x87, 0xff, 0x00, 0xaf, 0x00, 0x00, 0xaf, 0x5f,\n    0x00, 0xaf, 0x87, 0x00, 0xaf, 0xaf, 0x00, 0xaf, 0xd7, 0x00, 0xaf, 0xff,\n    0x00, 0xd7, 0x00, 0x00, 0xd7, 0x5f, 0x00, 0xd7, 0x87, 0x00, 0xd7, 0xaf,\n    0x00, 0xd7, 0xd7, 0x00, 0xd7, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0x5f,\n    0x00, 0xff, 0x87, 0x00, 0xff, 0xaf, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,\n    0x5f, 0x00, 0x00, 0x5f, 0x00, 0x5f, 0x5f, 0x00, 0x87, 0x5f, 0x00, 0xaf,\n    0x5f, 0x00, 0xd7, 0x5f, 0x00, 0xff, 0x5f, 0x5f, 0x00, 0x5f, 0x5f, 0x5f,\n    0x5f, 0x5f, 0x87, 0x5f, 0x5f, 0xaf, 0x5f, 0x5f, 0xd7, 0x5f, 0x5f, 0xff,\n    0x5f, 0x87, 0x00, 0x5f, 0x87, 0x5f, 0x5f, 0x87, 0x87, 0x5f, 0x87, 0xaf,\n    0x5f, 0x87, 0xd7, 0x5f, 0x87, 0xff, 0x5f, 0xaf, 0x00, 0x5f, 0xaf, 0x5f,\n    0x5f, 0xaf, 0x87, 0x5f, 0xaf, 0xaf, 0x5f, 0xaf, 0xd7, 0x5f, 0xaf, 0xff,\n    0x5f, 0xd7, 0x00, 0x5f, 0xd7, 0x5f, 0x5f, 0xd7, 0x87, 0x5f, 0xd7, 0xaf,\n    0x5f, 0xd7, 0xd7, 0x5f, 0xd7, 0xff, 0x5f, 0xff, 0x00, 0x5f, 0xff, 0x5f,\n    0x5f, 0xff, 0x87, 0x5f, 0xff, 0xaf, 0x5f, 0xff, 0xd7, 0x5f, 0xff, 0xff,\n    0x87, 0x00, 0x00, 0x87, 0x00, 0x5f, 0x87, 0x00, 0x87, 0x87, 0x00, 0xaf,\n    0x87, 0x00, 0xd7, 0x87, 0x00, 0xff, 0x87, 0x5f, 0x00, 0x87, 0x5f, 0x5f,\n    0x87, 0x5f, 0x87, 0x87, 0x5f, 0xaf, 0x87, 0x5f, 0xd7, 0x87, 0x5f, 0xff,\n    0x87, 0x87, 0x00, 0x87, 0x87, 0x5f, 0x87, 0x87, 0x87, 0x87, 0x87, 0xaf,\n    0x87, 0x87, 0xd7, 0x87, 0x87, 0xff, 0x87, 0xaf, 0x00, 0x87, 0xaf, 0x5f,\n    0x87, 0xaf, 0x87, 0x87, 0xaf, 0xaf, 0x87, 0xaf, 0xd7, 0x87, 0xaf, 0xff,\n    0x87, 0xd7, 0x00, 0x87, 0xd7, 0x5f, 0x87, 0xd7, 0x87, 0x87, 0xd7, 0xaf,\n    0x87, 0xd7, 0xd7, 0x87, 0xd7, 0xff, 0x87, 0xff, 0x00, 0x87, 0xff, 0x5f,\n    0x87, 0xff, 0x87, 0x87, 0xff, 0xaf, 0x87, 0xff, 0xd7, 0x87, 0xff, 0xff,\n    0xaf, 0x00, 0x00, 0xaf, 0x00, 0x5f, 0xaf, 0x00, 0x87, 0xaf, 0x00, 0xaf,\n    0xaf, 0x00, 0xd7, 0xaf, 0x00, 0xff, 0xaf, 0x5f, 0x00, 0xaf, 0x5f, 0x5f,\n    0xaf, 0x5f, 0x87, 0xaf, 0x5f, 0xaf, 0xaf, 0x5f, 0xd7, 0xaf, 0x5f, 0xff,\n    0xaf, 0x87, 0x00, 0xaf, 0x87, 0x5f, 0xaf, 0x87, 0x87, 0xaf, 0x87, 0xaf,\n    0xaf, 0x87, 0xd7, 0xaf, 0x87, 0xff, 0xaf, 0xaf, 0x00, 0xaf, 0xaf, 0x5f,\n    0xaf, 0xaf, 0x87, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xd7, 0xaf, 0xaf, 0xff,\n    0xaf, 0xd7, 0x00, 0xaf, 0xd7, 0x5f, 0xaf, 0xd7, 0x87, 0xaf, 0xd7, 0xaf,\n    0xaf, 0xd7, 0xd7, 0xaf, 0xd7, 0xff, 0xaf, 0xff, 0x00, 0xaf, 0xff, 0x5f,\n    0xaf, 0xff, 0x87, 0xaf, 0xff, 0xaf, 0xaf, 0xff, 0xd7, 0xaf, 0xff, 0xff,\n    0xd7, 0x00, 0x00, 0xd7, 0x00, 0x5f, 0xd7, 0x00, 0x87, 0xd7, 0x00, 0xaf,\n    0xd7, 0x00, 0xd7, 0xd7, 0x00, 0xff, 0xd7, 0x5f, 0x00, 0xd7, 0x5f, 0x5f,\n    0xd7, 0x5f, 0x87, 0xd7, 0x5f, 0xaf, 0xd7, 0x5f, 0xd7, 0xd7, 0x5f, 0xff,\n    0xd7, 0x87, 0x00, 0xd7, 0x87, 0x5f, 0xd7, 0x87, 0x87, 0xd7, 0x87, 0xaf,\n    0xd7, 0x87, 0xd7, 0xd7, 0x87, 0xff, 0xd7, 0xaf, 0x00, 0xd7, 0xaf, 0x5f,\n    0xd7, 0xaf, 0x87, 0xd7, 0xaf, 0xaf, 0xd7, 0xaf, 0xd7, 0xd7, 0xaf, 0xff,\n    0xd7, 0xd7, 0x00, 0xd7, 0xd7, 0x5f, 0xd7, 0xd7, 0x87, 0xd7, 0xd7, 0xaf,\n    0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xff, 0xd7, 0xff, 0x00, 0xd7, 0xff, 0x5f,\n    0xd7, 0xff, 0x87, 0xd7, 0xff, 0xaf, 0xd7, 0xff, 0xd7, 0xd7, 0xff, 0xff,\n    0xff, 0x00, 0x00, 0xff, 0x00, 0x5f, 0xff, 0x00, 0x87, 0xff, 0x00, 0xaf,\n    0xff, 0x00, 0xd7, 0xff, 0x00, 0xff, 0xff, 0x5f, 0x00, 0xff, 0x5f, 0x5f,\n    0xff, 0x5f, 0x87, 0xff, 0x5f, 0xaf, 0xff, 0x5f, 0xd7, 0xff, 0x5f, 0xff,\n    0xff, 0x87, 0x00, 0xff, 0x87, 0x5f, 0xff, 0x87, 0x87, 0xff, 0x87, 0xaf,\n    0xff, 0x87, 0xd7, 0xff, 0x87, 0xff, 0xff, 0xaf, 0x00, 0xff, 0xaf, 0x5f,\n    0xff, 0xaf, 0x87, 0xff, 0xaf, 0xaf, 0xff, 0xaf, 0xd7, 0xff, 0xaf, 0xff,\n    0xff, 0xd7, 0x00, 0xff, 0xd7, 0x5f, 0xff, 0xd7, 0x87, 0xff, 0xd7, 0xaf,\n    0xff, 0xd7, 0xd7, 0xff, 0xd7, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x5f,\n    0xff, 0xff, 0x87, 0xff, 0xff, 0xaf, 0xff, 0xff, 0xd7, 0xff, 0xff, 0xff,\n    0x08, 0x08, 0x08, 0x12, 0x12, 0x12, 0x1c, 0x1c, 0x1c, 0x26, 0x26, 0x26,\n    0x30, 0x30, 0x30, 0x3a, 0x3a, 0x3a, 0x44, 0x44, 0x44, 0x4e, 0x4e, 0x4e,\n    0x58, 0x58, 0x58, 0x62, 0x62, 0x62, 0x6c, 0x6c, 0x6c, 0x76, 0x76, 0x76,\n    0x80, 0x80, 0x80, 0x8a, 0x8a, 0x8a, 0x94, 0x94, 0x94, 0x9e, 0x9e, 0x9e,\n    0xa8, 0xa8, 0xa8, 0xb2, 0xb2, 0xb2, 0xbc, 0xbc, 0xbc, 0xc6, 0xc6, 0xc6,\n    0xd0, 0xd0, 0xd0, 0xda, 0xda, 0xda, 0xe4, 0xe4, 0xe4, 0xee, 0xee, 0xee,\n};\n\n\n/*\n * VT340 undocumented behavior regarding the color palette reported\n * by Vertis Sidus(@vrtsds):\n *     it loads the first fifteen colors as 1 through 15, and loads the\n *     sixteenth color as 0.\n */\nstatic const unsigned char pal_vt340_mono[] = {\n    /* 1   Gray-2   */  13 * 255 / 100, 13 * 255 / 100, 13 * 255 / 100,\n    /* 2   Gray-4   */  26 * 255 / 100, 26 * 255 / 100, 26 * 255 / 100,\n    /* 3   Gray-6   */  40 * 255 / 100, 40 * 255 / 100, 40 * 255 / 100,\n    /* 4   Gray-1   */   6 * 255 / 100,  6 * 255 / 100,  6 * 255 / 100,\n    /* 5   Gray-3   */  20 * 255 / 100, 20 * 255 / 100, 20 * 255 / 100,\n    /* 6   Gray-5   */  33 * 255 / 100, 33 * 255 / 100, 33 * 255 / 100,\n    /* 7   White 7  */  46 * 255 / 100, 46 * 255 / 100, 46 * 255 / 100,\n    /* 8   Black 0  */   0 * 255 / 100,  0 * 255 / 100,  0 * 255 / 100,\n    /* 9   Gray-2   */  13 * 255 / 100, 13 * 255 / 100, 13 * 255 / 100,\n    /* 10  Gray-4   */  26 * 255 / 100, 26 * 255 / 100, 26 * 255 / 100,\n    /* 11  Gray-6   */  40 * 255 / 100, 40 * 255 / 100, 40 * 255 / 100,\n    /* 12  Gray-1   */   6 * 255 / 100,  6 * 255 / 100,  6 * 255 / 100,\n    /* 13  Gray-3   */  20 * 255 / 100, 20 * 255 / 100, 20 * 255 / 100,\n    /* 14  Gray-5   */  33 * 255 / 100, 33 * 255 / 100, 33 * 255 / 100,\n    /* 15  White 7  */  46 * 255 / 100, 46 * 255 / 100, 46 * 255 / 100,\n    /* 0   Black    */   0 * 255 / 100,  0 * 255 / 100,  0 * 255 / 100,\n};\n\n\nstatic const unsigned char pal_vt340_color[] = {\n    /* 1   Blue     */  20 * 255 / 100, 20 * 255 / 100, 80 * 255 / 100,\n    /* 2   Red      */  80 * 255 / 100, 13 * 255 / 100, 13 * 255 / 100,\n    /* 3   Green    */  20 * 255 / 100, 80 * 255 / 100, 20 * 255 / 100,\n    /* 4   Magenta  */  80 * 255 / 100, 20 * 255 / 100, 80 * 255 / 100,\n    /* 5   Cyan     */  20 * 255 / 100, 80 * 255 / 100, 80 * 255 / 100,\n    /* 6   Yellow   */  80 * 255 / 100, 80 * 255 / 100, 20 * 255 / 100,\n    /* 7   Gray 50% */  53 * 255 / 100, 53 * 255 / 100, 53 * 255 / 100,\n    /* 8   Gray 25% */  26 * 255 / 100, 26 * 255 / 100, 26 * 255 / 100,\n    /* 9   Blue*    */  33 * 255 / 100, 33 * 255 / 100, 60 * 255 / 100,\n    /* 10  Red*     */  60 * 255 / 100, 26 * 255 / 100, 26 * 255 / 100,\n    /* 11  Green*   */  33 * 255 / 100, 60 * 255 / 100, 33 * 255 / 100,\n    /* 12  Magenta* */  60 * 255 / 100, 33 * 255 / 100, 60 * 255 / 100,\n    /* 13  Cyan*    */  33 * 255 / 100, 60 * 255 / 100, 60 * 255 / 100,\n    /* 14  Yellow*  */  60 * 255 / 100, 60 * 255 / 100, 33 * 255 / 100,\n    /* 15  Gray 75% */  80 * 255 / 100, 80 * 255 / 100, 80 * 255 / 100,\n    /* 0   Black    */   0 * 255 / 100,  0 * 255 / 100,  0 * 255 / 100,\n};\n\n\n/* create dither context object */\nSIXELAPI SIXELSTATUS\nsixel_dither_new(\n    sixel_dither_t    /* out */ **ppdither, /* dither object to be created */\n    int               /* in */  ncolors,    /* required colors */\n    sixel_allocator_t /* in */  *allocator) /* allocator, null if you use\n                                               default allocator */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    size_t headsize;\n    size_t datasize;\n    size_t wholesize;\n    int quality_mode;\n\n    if (ppdither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: ppdither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    if (allocator == NULL) {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            *ppdither = NULL;\n            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            ncolors = 256;\n        } else if (ncolors < 2) {\n            ncolors = 2;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    (*ppdither)->ref = 1;\n    (*ppdither)->palette = (unsigned char*)(*ppdither + 1);\n    (*ppdither)->cachetable = NULL;\n    (*ppdither)->reqcolors = ncolors;\n    (*ppdither)->ncolors = ncolors;\n    (*ppdither)->origcolors = (-1);\n    (*ppdither)->keycolor = (-1);\n    (*ppdither)->optimized = 0;\n    (*ppdither)->optimize_palette = 0;\n    (*ppdither)->complexion = 1;\n    (*ppdither)->bodyonly = 0;\n    (*ppdither)->method_for_largest = SIXEL_LARGE_NORM;\n    (*ppdither)->method_for_rep = SIXEL_REP_CENTER_BOX;\n    (*ppdither)->method_for_diffuse = SIXEL_DIFFUSE_FS;\n    (*ppdither)->quality_mode = quality_mode;\n    (*ppdither)->pixelformat = SIXEL_PIXELFORMAT_RGB888;\n    (*ppdither)->allocator = allocator;\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* create dither context object (deprecated) */\nSIXELAPI sixel_dither_t *\nsixel_dither_create(\n    int     /* in */ ncolors)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_dither_t *dither = NULL;\n\n    status = sixel_dither_new(&dither, ncolors, NULL);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\nend:\n    return dither;\n}\n\n\nSIXELAPI void\nsixel_dither_destroy(\n    sixel_dither_t  /* in */ *dither)\n{\n    sixel_allocator_t *allocator;\n\n    if (dither) {\n        allocator = dither->allocator;\n        sixel_allocator_free(allocator, dither->cachetable);\n        dither->cachetable = NULL;\n        sixel_allocator_free(allocator, dither);\n        sixel_allocator_unref(allocator);\n    }\n}\n\n\nSIXELAPI void\nsixel_dither_ref(\n    sixel_dither_t  /* in */ *dither)\n{\n    /* TODO: be thread safe */\n    ++dither->ref;\n}\n\n\nSIXELAPI void\nsixel_dither_unref(\n    sixel_dither_t  /* in */ *dither)\n{\n    /* TODO: be thread safe */\n    if (dither != NULL && --dither->ref == 0) {\n        sixel_dither_destroy(dither);\n    }\n}\n\n\nSIXELAPI sixel_dither_t *\nsixel_dither_get(\n    int     /* in */ builtin_dither)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char *palette;\n    int ncolors;\n    int keycolor;\n    sixel_dither_t *dither = NULL;\n\n    switch (builtin_dither) {\n    case SIXEL_BUILTIN_MONO_DARK:\n        ncolors = 2;\n        palette = (unsigned char *)pal_mono_dark;\n        keycolor = 0;\n        break;\n    case SIXEL_BUILTIN_MONO_LIGHT:\n        ncolors = 2;\n        palette = (unsigned char *)pal_mono_light;\n        keycolor = 0;\n        break;\n    case SIXEL_BUILTIN_XTERM16:\n        ncolors = 16;\n        palette = (unsigned char *)pal_xterm256;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_XTERM256:\n        ncolors = 256;\n        palette = (unsigned char *)pal_xterm256;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_VT340_MONO:\n        ncolors = 16;\n        palette = (unsigned char *)pal_vt340_mono;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_VT340_COLOR:\n        ncolors = 16;\n        palette = (unsigned char *)pal_vt340_color;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_G1:\n        ncolors = 2;\n        palette = (unsigned char *)pal_gray_1bit;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_G2:\n        ncolors = 4;\n        palette = (unsigned char *)pal_gray_2bit;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_G4:\n        ncolors = 16;\n        palette = (unsigned char *)pal_gray_4bit;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_G8:\n        ncolors = 256;\n        palette = (unsigned char *)pal_gray_8bit;\n        keycolor = (-1);\n        break;\n    default:\n        goto end;\n    }\n\n    status = sixel_dither_new(&dither, ncolors, NULL);\n    if (SIXEL_FAILED(status)) {\n        dither = NULL;\n        goto end;\n    }\n\n    dither->palette = palette;\n    dither->keycolor = keycolor;\n    dither->optimized = 1;\n    dither->optimize_palette = 0;\n\nend:\n    return dither;\n}\n\n\nstatic void\nsixel_dither_set_method_for_largest(\n    sixel_dither_t  /* in */ *dither,\n    int             /* in */ method_for_largest)\n{\n    if (method_for_largest == SIXEL_LARGE_AUTO) {\n        method_for_largest = SIXEL_LARGE_NORM;\n    }\n    dither->method_for_largest = method_for_largest;\n}\n\n\nstatic void\nsixel_dither_set_method_for_rep(\n    sixel_dither_t  /* in */ *dither,\n    int             /* in */ method_for_rep)\n{\n    if (method_for_rep == SIXEL_REP_AUTO) {\n        method_for_rep = SIXEL_REP_CENTER_BOX;\n    }\n    dither->method_for_rep = method_for_rep;\n}\n\n\nstatic void\nsixel_dither_set_quality_mode(\n    sixel_dither_t  /* in */  *dither,\n    int             /* in */  quality_mode)\n{\n    if (quality_mode == SIXEL_QUALITY_AUTO) {\n        if (dither->ncolors <= 8) {\n            quality_mode = SIXEL_QUALITY_HIGH;\n        } else {\n            quality_mode = SIXEL_QUALITY_LOW;\n        }\n    }\n    dither->quality_mode = quality_mode;\n}\n\n\nSIXELAPI SIXELSTATUS\nsixel_dither_initialize(\n    sixel_dither_t  /* in */ *dither,\n    unsigned char   /* in */ *data,\n    int             /* in */ width,\n    int             /* in */ height,\n    int             /* in */ pixelformat,\n    int             /* in */ method_for_largest,\n    int             /* in */ method_for_rep,\n    int             /* in */ quality_mode)\n{\n    unsigned char *buf = NULL;\n    unsigned char *normalized_pixels = NULL;\n    unsigned char *input_pixels;\n    SIXELSTATUS status = SIXEL_FALSE;\n\n    if (dither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: dither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    sixel_dither_ref(dither);\n\n    sixel_dither_set_pixelformat(dither, pixelformat);\n\n    switch (pixelformat) {\n    case SIXEL_PIXELFORMAT_RGB888:\n        input_pixels = data;\n        break;\n    default:\n        /* normalize pixelformat */\n        normalized_pixels\n            = (unsigned char *)sixel_allocator_malloc(dither->allocator, (size_t)(width * height * 3));\n        if (normalized_pixels == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_dither_initialize: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n\n        status = sixel_helper_normalize_pixelformat(\n            normalized_pixels,\n            &pixelformat,\n            data,\n            pixelformat,\n            width,\n            height);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        input_pixels = normalized_pixels;\n        break;\n    }\n\n    sixel_dither_set_method_for_largest(dither, method_for_largest);\n    sixel_dither_set_method_for_rep(dither, method_for_rep);\n    sixel_dither_set_quality_mode(dither, quality_mode);\n\n    status = sixel_quant_make_palette(&buf,\n                                      input_pixels,\n                                      (unsigned int)(width * height * 3),\n                                      SIXEL_PIXELFORMAT_RGB888,\n                                      (unsigned int)dither->reqcolors,\n                                      (unsigned int *)&dither->ncolors,\n                                      (unsigned int *)&dither->origcolors,\n                                      dither->method_for_largest,\n                                      dither->method_for_rep,\n                                      dither->quality_mode,\n                                      dither->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n    memcpy(dither->palette, buf, (size_t)(dither->ncolors * 3));\n\n    dither->optimized = 1;\n    if (dither->origcolors <= dither->ncolors) {\n        dither->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n    }\n\n    sixel_quant_free_palette(buf, dither->allocator);\n    status = SIXEL_OK;\n\nend:\n    free(normalized_pixels);\n    sixel_dither_unref(dither);\n    return status;\n}\n\n\n/* set diffusion type, choose from enum methodForDiffuse */\nSIXELAPI void\nsixel_dither_set_diffusion_type(\n    sixel_dither_t  /* in */ *dither,\n    int             /* in */ method_for_diffuse)\n{\n    if (method_for_diffuse == SIXEL_DIFFUSE_AUTO) {\n        if (dither->ncolors > 16) {\n            method_for_diffuse = SIXEL_DIFFUSE_FS;\n        } else {\n            method_for_diffuse = SIXEL_DIFFUSE_ATKINSON;\n        }\n    }\n    dither->method_for_diffuse = method_for_diffuse;\n}\n\n\n/* get number of palette colors */\nSIXELAPI int\nsixel_dither_get_num_of_palette_colors(\n    sixel_dither_t  /* in */ *dither)\n{\n    return dither->ncolors;\n}\n\n\n/* get number of histogram colors */\nSIXELAPI int\nsixel_dither_get_num_of_histogram_colors(\n    sixel_dither_t /* in */ *dither)  /* dither context object */\n{\n    return dither->origcolors;\n}\n\n\n/* typoed: remained for keeping compatibility */\nSIXELAPI int\nsixel_dither_get_num_of_histgram_colors(\n    sixel_dither_t /* in */ *dither)  /* dither context object */\n{\n    return sixel_dither_get_num_of_histogram_colors(dither);\n}\n\n\n/* get palette */\nSIXELAPI unsigned char *\nsixel_dither_get_palette(\n    sixel_dither_t /* in */ *dither)  /* dither context object */\n{\n    return dither->palette;\n}\n\n\n/* set palette */\nSIXELAPI void\nsixel_dither_set_palette(\n    sixel_dither_t /* in */ *dither,   /* dither context object */\n    unsigned char  /* in */ *palette)\n{\n    memcpy(dither->palette, palette, (size_t)(dither->ncolors * 3));\n}\n\n\n/* set the factor of complexion color correcting */\nSIXELAPI void\nsixel_dither_set_complexion_score(\n    sixel_dither_t /* in */ *dither,  /* dither context object */\n    int            /* in */ score)    /* complexion score (>= 1) */\n{\n    dither->complexion = score;\n}\n\n\n/* set whether omitting palette difinition */\nSIXELAPI void\nsixel_dither_set_body_only(\n    sixel_dither_t /* in */ *dither,     /* dither context object */\n    int            /* in */ bodyonly)    /* 0: output palette section\n                                            1: do not output palette section  */\n{\n    dither->bodyonly = bodyonly;\n}\n\n\n/* set whether optimize palette size */\nSIXELAPI void\nsixel_dither_set_optimize_palette(\n    sixel_dither_t /* in */ *dither,   /* dither context object */\n    int            /* in */ do_opt)    /* 0: optimize palette size\n                                          1: don't optimize palette size */\n{\n    dither->optimize_palette = do_opt;\n}\n\n\n/* set pixelformat */\nSIXELAPI void\nsixel_dither_set_pixelformat(\n    sixel_dither_t /* in */ *dither,     /* dither context object */\n    int            /* in */ pixelformat) /* one of enum pixelFormat */\n{\n    dither->pixelformat = pixelformat;\n}\n\n\n/* set transparent */\nSIXELAPI void\nsixel_dither_set_transparent(\n    sixel_dither_t /* in */ *dither,      /* dither context object */\n    int            /* in */ transparent)  /* transparent color index */\n{\n    dither->keycolor = transparent;\n}\n\n\n/* set transparent */\nSIXELAPI unsigned char *\nsixel_dither_apply_palette(\n    sixel_dither_t  /* in */ *dither,\n    unsigned char   /* in */ *pixels,\n    int             /* in */ width,\n    int             /* in */ height)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    size_t bufsize;\n    unsigned char *dest = NULL;\n    int ncolors;\n    unsigned char *normalized_pixels = NULL;\n    unsigned char *input_pixels;\n\n    if (dither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_apply_palette: dither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    sixel_dither_ref(dither);\n\n    bufsize = (size_t)(width * height) * sizeof(unsigned char);\n    dest = (unsigned char *)sixel_allocator_malloc(dither->allocator, bufsize);\n    if (dest == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    /* if quality_mode is full, do not use palette caching */\n    if (dither->quality_mode == SIXEL_QUALITY_FULL) {\n        dither->optimized = 0;\n    }\n\n    if (dither->cachetable == NULL && dither->optimized) {\n        if (dither->palette != pal_mono_dark && dither->palette != pal_mono_light) {\n            dither->cachetable = (unsigned short *)sixel_allocator_calloc(dither->allocator,\n                                                                          (size_t)(1 << 3 * 5),\n                                                                          sizeof(unsigned short));\n            if (dither->cachetable == NULL) {\n                sixel_helper_set_additional_message(\n                    \"sixel_dither_new: sixel_allocator_calloc() failed.\");\n                status = SIXEL_BAD_ALLOCATION;\n                goto end;\n            }\n        }\n    }\n\n    if (dither->pixelformat != SIXEL_PIXELFORMAT_RGB888) {\n        /* normalize pixelformat */\n        normalized_pixels\n            = (unsigned char *)sixel_allocator_malloc(dither->allocator, (size_t)(width * height * 3));\n        if (normalized_pixels == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        status = sixel_helper_normalize_pixelformat(normalized_pixels,\n                                                    &dither->pixelformat,\n                                                    pixels, dither->pixelformat,\n                                                    width, height);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        input_pixels = normalized_pixels;\n    } else {\n        input_pixels = pixels;\n    }\n\n    status = sixel_quant_apply_palette(dest,\n                                       input_pixels,\n                                       width, height, 3,\n                                       dither->palette,\n                                       dither->ncolors,\n                                       dither->method_for_diffuse,\n                                       dither->optimized,\n                                       dither->optimize_palette,\n                                       dither->complexion,\n                                       dither->cachetable,\n                                       &ncolors,\n                                       dither->allocator);\n    if (SIXEL_FAILED(status)) {\n        free(dest);\n        dest = NULL;\n        goto end;\n    }\n\n    dither->ncolors = ncolors;\n\nend:\n    free(normalized_pixels);\n    sixel_dither_unref(dither);\n    return dest;\n}\n\n\n#if HAVE_TESTS\nstatic int\ntest1(void)\n{\n    sixel_dither_t *dither = NULL;\n    int nret = EXIT_FAILURE;\n\n#if HAVE_DIAGNOSTIC_DEPRECATED_DECLARATIONS\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n    dither = sixel_dither_create(0);\n#if HAVE_DIAGNOSTIC_DEPRECATED_DECLARATIONS\n#  pragma GCC diagnostic pop\n#endif\n    if (dither == NULL) {\n        goto error;\n    }\n    sixel_dither_ref(dither);\n    sixel_dither_unref(dither);\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_dither_unref(dither);\n    return nret;\n}\n\nstatic int\ntest2(void)\n{\n    sixel_dither_t *dither = NULL;\n    int colors;\n    int nret = EXIT_FAILURE;\n\n#if HAVE_DIAGNOSTIC_DEPRECATED_DECLARATIONS\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n    dither = sixel_dither_create(INT_MAX);\n#if HAVE_DIAGNOSTIC_DEPRECATED_DECLARATIONS\n#  pragma GCC diagnostic pop\n#endif\n    if (dither == NULL) {\n        goto error;\n    }\n    sixel_dither_set_body_only(dither, 1);\n    colors = sixel_dither_get_num_of_histogram_colors(dither);\n    if (colors != -1) {\n        goto error;\n    }\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_dither_unref(dither);\n    return nret;\n}\n\n\nSIXELAPI int\nsixel_dither_tests_main(void)\n{\n    int nret = EXIT_FAILURE;\n    size_t i;\n    typedef int (* testcase)(void);\n\n    static testcase const testcases[] = {\n        test1,\n        test2,\n    };\n\n    for (i = 0; i < sizeof(testcases) / sizeof(testcase); ++i) {\n        nret = testcases[i]();\n        if (nret != EXIT_SUCCESS) {\n            goto error;\n        }\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    return nret;\n}\n#endif  /* HAVE_TESTS */\n\n/* emacs Local Variables:      */\n/* emacs mode: c               */\n/* emacs tab-width: 4          */\n/* emacs indent-tabs-mode: nil */\n/* emacs c-basic-offset: 4     */\n/* emacs End:                  */\n/* vim: set expandtab ts=4 sts=4 sw=4 : */\n/* EOF */\n"], "fixing_code": ["/*\n * Copyright (c) 2014-2018 Hayaki Saito\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n\n#if HAVE_LIMITS_H\n# include <limits.h>\n#endif\n\n#if HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n\n#include \"dither.h\"\n#include \"quant.h\"\n#include <sixel.h>\n\n\nstatic const unsigned char pal_mono_dark[] = {\n    0x00, 0x00, 0x00, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_mono_light[] = {\n    0xff, 0xff, 0xff, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char pal_gray_1bit[] = {\n    0x00, 0x00, 0x00, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_gray_2bit[] = {\n    0x00, 0x00, 0x00, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_gray_4bit[] = {\n    0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x33, 0x33, 0x33,\n    0x44, 0x44, 0x44, 0x55, 0x55, 0x55, 0x66, 0x66, 0x66, 0x77, 0x77, 0x77,\n    0x88, 0x88, 0x88, 0x99, 0x99, 0x99, 0xaa, 0xaa, 0xaa, 0xbb, 0xbb, 0xbb,\n    0xcc, 0xcc, 0xcc, 0xdd, 0xdd, 0xdd, 0xee, 0xee, 0xee, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_gray_8bit[] = {\n    0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03,\n    0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07,\n    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b,\n    0x0c, 0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f,\n    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13,\n    0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17,\n    0x18, 0x18, 0x18, 0x19, 0x19, 0x19, 0x1a, 0x1a, 0x1a, 0x1b, 0x1b, 0x1b,\n    0x1c, 0x1c, 0x1c, 0x1d, 0x1d, 0x1d, 0x1e, 0x1e, 0x1e, 0x1f, 0x1f, 0x1f,\n    0x20, 0x20, 0x20, 0x21, 0x21, 0x21, 0x22, 0x22, 0x22, 0x23, 0x23, 0x23,\n    0x24, 0x24, 0x24, 0x25, 0x25, 0x25, 0x26, 0x26, 0x26, 0x27, 0x27, 0x27,\n    0x28, 0x28, 0x28, 0x29, 0x29, 0x29, 0x2a, 0x2a, 0x2a, 0x2b, 0x2b, 0x2b,\n    0x2c, 0x2c, 0x2c, 0x2d, 0x2d, 0x2d, 0x2e, 0x2e, 0x2e, 0x2f, 0x2f, 0x2f,\n    0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x32, 0x32, 0x32, 0x33, 0x33, 0x33,\n    0x34, 0x34, 0x34, 0x35, 0x35, 0x35, 0x36, 0x36, 0x36, 0x37, 0x37, 0x37,\n    0x38, 0x38, 0x38, 0x39, 0x39, 0x39, 0x3a, 0x3a, 0x3a, 0x3b, 0x3b, 0x3b,\n    0x3c, 0x3c, 0x3c, 0x3d, 0x3d, 0x3d, 0x3e, 0x3e, 0x3e, 0x3f, 0x3f, 0x3f,\n    0x40, 0x40, 0x40, 0x41, 0x41, 0x41, 0x42, 0x42, 0x42, 0x43, 0x43, 0x43,\n    0x44, 0x44, 0x44, 0x45, 0x45, 0x45, 0x46, 0x46, 0x46, 0x47, 0x47, 0x47,\n    0x48, 0x48, 0x48, 0x49, 0x49, 0x49, 0x4a, 0x4a, 0x4a, 0x4b, 0x4b, 0x4b,\n    0x4c, 0x4c, 0x4c, 0x4d, 0x4d, 0x4d, 0x4e, 0x4e, 0x4e, 0x4f, 0x4f, 0x4f,\n    0x50, 0x50, 0x50, 0x51, 0x51, 0x51, 0x52, 0x52, 0x52, 0x53, 0x53, 0x53,\n    0x54, 0x54, 0x54, 0x55, 0x55, 0x55, 0x56, 0x56, 0x56, 0x57, 0x57, 0x57,\n    0x58, 0x58, 0x58, 0x59, 0x59, 0x59, 0x5a, 0x5a, 0x5a, 0x5b, 0x5b, 0x5b,\n    0x5c, 0x5c, 0x5c, 0x5d, 0x5d, 0x5d, 0x5e, 0x5e, 0x5e, 0x5f, 0x5f, 0x5f,\n    0x60, 0x60, 0x60, 0x61, 0x61, 0x61, 0x62, 0x62, 0x62, 0x63, 0x63, 0x63,\n    0x64, 0x64, 0x64, 0x65, 0x65, 0x65, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67,\n    0x68, 0x68, 0x68, 0x69, 0x69, 0x69, 0x6a, 0x6a, 0x6a, 0x6b, 0x6b, 0x6b,\n    0x6c, 0x6c, 0x6c, 0x6d, 0x6d, 0x6d, 0x6e, 0x6e, 0x6e, 0x6f, 0x6f, 0x6f,\n    0x70, 0x70, 0x70, 0x71, 0x71, 0x71, 0x72, 0x72, 0x72, 0x73, 0x73, 0x73,\n    0x74, 0x74, 0x74, 0x75, 0x75, 0x75, 0x76, 0x76, 0x76, 0x77, 0x77, 0x77,\n    0x78, 0x78, 0x78, 0x79, 0x79, 0x79, 0x7a, 0x7a, 0x7a, 0x7b, 0x7b, 0x7b,\n    0x7c, 0x7c, 0x7c, 0x7d, 0x7d, 0x7d, 0x7e, 0x7e, 0x7e, 0x7f, 0x7f, 0x7f,\n    0x80, 0x80, 0x80, 0x81, 0x81, 0x81, 0x82, 0x82, 0x82, 0x83, 0x83, 0x83,\n    0x84, 0x84, 0x84, 0x85, 0x85, 0x85, 0x86, 0x86, 0x86, 0x87, 0x87, 0x87,\n    0x88, 0x88, 0x88, 0x89, 0x89, 0x89, 0x8a, 0x8a, 0x8a, 0x8b, 0x8b, 0x8b,\n    0x8c, 0x8c, 0x8c, 0x8d, 0x8d, 0x8d, 0x8e, 0x8e, 0x8e, 0x8f, 0x8f, 0x8f,\n    0x90, 0x90, 0x90, 0x91, 0x91, 0x91, 0x92, 0x92, 0x92, 0x93, 0x93, 0x93,\n    0x94, 0x94, 0x94, 0x95, 0x95, 0x95, 0x96, 0x96, 0x96, 0x97, 0x97, 0x97,\n    0x98, 0x98, 0x98, 0x99, 0x99, 0x99, 0x9a, 0x9a, 0x9a, 0x9b, 0x9b, 0x9b,\n    0x9c, 0x9c, 0x9c, 0x9d, 0x9d, 0x9d, 0x9e, 0x9e, 0x9e, 0x9f, 0x9f, 0x9f,\n    0xa0, 0xa0, 0xa0, 0xa1, 0xa1, 0xa1, 0xa2, 0xa2, 0xa2, 0xa3, 0xa3, 0xa3,\n    0xa4, 0xa4, 0xa4, 0xa5, 0xa5, 0xa5, 0xa6, 0xa6, 0xa6, 0xa7, 0xa7, 0xa7,\n    0xa8, 0xa8, 0xa8, 0xa9, 0xa9, 0xa9, 0xaa, 0xaa, 0xaa, 0xab, 0xab, 0xab,\n    0xac, 0xac, 0xac, 0xad, 0xad, 0xad, 0xae, 0xae, 0xae, 0xaf, 0xaf, 0xaf,\n    0xb0, 0xb0, 0xb0, 0xb1, 0xb1, 0xb1, 0xb2, 0xb2, 0xb2, 0xb3, 0xb3, 0xb3,\n    0xb4, 0xb4, 0xb4, 0xb5, 0xb5, 0xb5, 0xb6, 0xb6, 0xb6, 0xb7, 0xb7, 0xb7,\n    0xb8, 0xb8, 0xb8, 0xb9, 0xb9, 0xb9, 0xba, 0xba, 0xba, 0xbb, 0xbb, 0xbb,\n    0xbc, 0xbc, 0xbc, 0xbd, 0xbd, 0xbd, 0xbe, 0xbe, 0xbe, 0xbf, 0xbf, 0xbf,\n    0xc0, 0xc0, 0xc0, 0xc1, 0xc1, 0xc1, 0xc2, 0xc2, 0xc2, 0xc3, 0xc3, 0xc3,\n    0xc4, 0xc4, 0xc4, 0xc5, 0xc5, 0xc5, 0xc6, 0xc6, 0xc6, 0xc7, 0xc7, 0xc7,\n    0xc8, 0xc8, 0xc8, 0xc9, 0xc9, 0xc9, 0xca, 0xca, 0xca, 0xcb, 0xcb, 0xcb,\n    0xcc, 0xcc, 0xcc, 0xcd, 0xcd, 0xcd, 0xce, 0xce, 0xce, 0xcf, 0xcf, 0xcf,\n    0xd0, 0xd0, 0xd0, 0xd1, 0xd1, 0xd1, 0xd2, 0xd2, 0xd2, 0xd3, 0xd3, 0xd3,\n    0xd4, 0xd4, 0xd4, 0xd5, 0xd5, 0xd5, 0xd6, 0xd6, 0xd6, 0xd7, 0xd7, 0xd7,\n    0xd8, 0xd8, 0xd8, 0xd9, 0xd9, 0xd9, 0xda, 0xda, 0xda, 0xdb, 0xdb, 0xdb,\n    0xdc, 0xdc, 0xdc, 0xdd, 0xdd, 0xdd, 0xde, 0xde, 0xde, 0xdf, 0xdf, 0xdf,\n    0xe0, 0xe0, 0xe0, 0xe1, 0xe1, 0xe1, 0xe2, 0xe2, 0xe2, 0xe3, 0xe3, 0xe3,\n    0xe4, 0xe4, 0xe4, 0xe5, 0xe5, 0xe5, 0xe6, 0xe6, 0xe6, 0xe7, 0xe7, 0xe7,\n    0xe8, 0xe8, 0xe8, 0xe9, 0xe9, 0xe9, 0xea, 0xea, 0xea, 0xeb, 0xeb, 0xeb,\n    0xec, 0xec, 0xec, 0xed, 0xed, 0xed, 0xee, 0xee, 0xee, 0xef, 0xef, 0xef,\n    0xf0, 0xf0, 0xf0, 0xf1, 0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf3, 0xf3, 0xf3,\n    0xf4, 0xf4, 0xf4, 0xf5, 0xf5, 0xf5, 0xf6, 0xf6, 0xf6, 0xf7, 0xf7, 0xf7,\n    0xf8, 0xf8, 0xf8, 0xf9, 0xf9, 0xf9, 0xfa, 0xfa, 0xfa, 0xfb, 0xfb, 0xfb,\n    0xfc, 0xfc, 0xfc, 0xfd, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff\n};\n\n\nstatic const unsigned char pal_xterm256[] = {\n    0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00,\n    0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0xc0, 0xc0, 0xc0,\n    0x80, 0x80, 0x80, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00,\n    0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x87, 0x00, 0x00, 0xaf,\n    0x00, 0x00, 0xd7, 0x00, 0x00, 0xff, 0x00, 0x5f, 0x00, 0x00, 0x5f, 0x5f,\n    0x00, 0x5f, 0x87, 0x00, 0x5f, 0xaf, 0x00, 0x5f, 0xd7, 0x00, 0x5f, 0xff,\n    0x00, 0x87, 0x00, 0x00, 0x87, 0x5f, 0x00, 0x87, 0x87, 0x00, 0x87, 0xaf,\n    0x00, 0x87, 0xd7, 0x00, 0x87, 0xff, 0x00, 0xaf, 0x00, 0x00, 0xaf, 0x5f,\n    0x00, 0xaf, 0x87, 0x00, 0xaf, 0xaf, 0x00, 0xaf, 0xd7, 0x00, 0xaf, 0xff,\n    0x00, 0xd7, 0x00, 0x00, 0xd7, 0x5f, 0x00, 0xd7, 0x87, 0x00, 0xd7, 0xaf,\n    0x00, 0xd7, 0xd7, 0x00, 0xd7, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0x5f,\n    0x00, 0xff, 0x87, 0x00, 0xff, 0xaf, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,\n    0x5f, 0x00, 0x00, 0x5f, 0x00, 0x5f, 0x5f, 0x00, 0x87, 0x5f, 0x00, 0xaf,\n    0x5f, 0x00, 0xd7, 0x5f, 0x00, 0xff, 0x5f, 0x5f, 0x00, 0x5f, 0x5f, 0x5f,\n    0x5f, 0x5f, 0x87, 0x5f, 0x5f, 0xaf, 0x5f, 0x5f, 0xd7, 0x5f, 0x5f, 0xff,\n    0x5f, 0x87, 0x00, 0x5f, 0x87, 0x5f, 0x5f, 0x87, 0x87, 0x5f, 0x87, 0xaf,\n    0x5f, 0x87, 0xd7, 0x5f, 0x87, 0xff, 0x5f, 0xaf, 0x00, 0x5f, 0xaf, 0x5f,\n    0x5f, 0xaf, 0x87, 0x5f, 0xaf, 0xaf, 0x5f, 0xaf, 0xd7, 0x5f, 0xaf, 0xff,\n    0x5f, 0xd7, 0x00, 0x5f, 0xd7, 0x5f, 0x5f, 0xd7, 0x87, 0x5f, 0xd7, 0xaf,\n    0x5f, 0xd7, 0xd7, 0x5f, 0xd7, 0xff, 0x5f, 0xff, 0x00, 0x5f, 0xff, 0x5f,\n    0x5f, 0xff, 0x87, 0x5f, 0xff, 0xaf, 0x5f, 0xff, 0xd7, 0x5f, 0xff, 0xff,\n    0x87, 0x00, 0x00, 0x87, 0x00, 0x5f, 0x87, 0x00, 0x87, 0x87, 0x00, 0xaf,\n    0x87, 0x00, 0xd7, 0x87, 0x00, 0xff, 0x87, 0x5f, 0x00, 0x87, 0x5f, 0x5f,\n    0x87, 0x5f, 0x87, 0x87, 0x5f, 0xaf, 0x87, 0x5f, 0xd7, 0x87, 0x5f, 0xff,\n    0x87, 0x87, 0x00, 0x87, 0x87, 0x5f, 0x87, 0x87, 0x87, 0x87, 0x87, 0xaf,\n    0x87, 0x87, 0xd7, 0x87, 0x87, 0xff, 0x87, 0xaf, 0x00, 0x87, 0xaf, 0x5f,\n    0x87, 0xaf, 0x87, 0x87, 0xaf, 0xaf, 0x87, 0xaf, 0xd7, 0x87, 0xaf, 0xff,\n    0x87, 0xd7, 0x00, 0x87, 0xd7, 0x5f, 0x87, 0xd7, 0x87, 0x87, 0xd7, 0xaf,\n    0x87, 0xd7, 0xd7, 0x87, 0xd7, 0xff, 0x87, 0xff, 0x00, 0x87, 0xff, 0x5f,\n    0x87, 0xff, 0x87, 0x87, 0xff, 0xaf, 0x87, 0xff, 0xd7, 0x87, 0xff, 0xff,\n    0xaf, 0x00, 0x00, 0xaf, 0x00, 0x5f, 0xaf, 0x00, 0x87, 0xaf, 0x00, 0xaf,\n    0xaf, 0x00, 0xd7, 0xaf, 0x00, 0xff, 0xaf, 0x5f, 0x00, 0xaf, 0x5f, 0x5f,\n    0xaf, 0x5f, 0x87, 0xaf, 0x5f, 0xaf, 0xaf, 0x5f, 0xd7, 0xaf, 0x5f, 0xff,\n    0xaf, 0x87, 0x00, 0xaf, 0x87, 0x5f, 0xaf, 0x87, 0x87, 0xaf, 0x87, 0xaf,\n    0xaf, 0x87, 0xd7, 0xaf, 0x87, 0xff, 0xaf, 0xaf, 0x00, 0xaf, 0xaf, 0x5f,\n    0xaf, 0xaf, 0x87, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xd7, 0xaf, 0xaf, 0xff,\n    0xaf, 0xd7, 0x00, 0xaf, 0xd7, 0x5f, 0xaf, 0xd7, 0x87, 0xaf, 0xd7, 0xaf,\n    0xaf, 0xd7, 0xd7, 0xaf, 0xd7, 0xff, 0xaf, 0xff, 0x00, 0xaf, 0xff, 0x5f,\n    0xaf, 0xff, 0x87, 0xaf, 0xff, 0xaf, 0xaf, 0xff, 0xd7, 0xaf, 0xff, 0xff,\n    0xd7, 0x00, 0x00, 0xd7, 0x00, 0x5f, 0xd7, 0x00, 0x87, 0xd7, 0x00, 0xaf,\n    0xd7, 0x00, 0xd7, 0xd7, 0x00, 0xff, 0xd7, 0x5f, 0x00, 0xd7, 0x5f, 0x5f,\n    0xd7, 0x5f, 0x87, 0xd7, 0x5f, 0xaf, 0xd7, 0x5f, 0xd7, 0xd7, 0x5f, 0xff,\n    0xd7, 0x87, 0x00, 0xd7, 0x87, 0x5f, 0xd7, 0x87, 0x87, 0xd7, 0x87, 0xaf,\n    0xd7, 0x87, 0xd7, 0xd7, 0x87, 0xff, 0xd7, 0xaf, 0x00, 0xd7, 0xaf, 0x5f,\n    0xd7, 0xaf, 0x87, 0xd7, 0xaf, 0xaf, 0xd7, 0xaf, 0xd7, 0xd7, 0xaf, 0xff,\n    0xd7, 0xd7, 0x00, 0xd7, 0xd7, 0x5f, 0xd7, 0xd7, 0x87, 0xd7, 0xd7, 0xaf,\n    0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xff, 0xd7, 0xff, 0x00, 0xd7, 0xff, 0x5f,\n    0xd7, 0xff, 0x87, 0xd7, 0xff, 0xaf, 0xd7, 0xff, 0xd7, 0xd7, 0xff, 0xff,\n    0xff, 0x00, 0x00, 0xff, 0x00, 0x5f, 0xff, 0x00, 0x87, 0xff, 0x00, 0xaf,\n    0xff, 0x00, 0xd7, 0xff, 0x00, 0xff, 0xff, 0x5f, 0x00, 0xff, 0x5f, 0x5f,\n    0xff, 0x5f, 0x87, 0xff, 0x5f, 0xaf, 0xff, 0x5f, 0xd7, 0xff, 0x5f, 0xff,\n    0xff, 0x87, 0x00, 0xff, 0x87, 0x5f, 0xff, 0x87, 0x87, 0xff, 0x87, 0xaf,\n    0xff, 0x87, 0xd7, 0xff, 0x87, 0xff, 0xff, 0xaf, 0x00, 0xff, 0xaf, 0x5f,\n    0xff, 0xaf, 0x87, 0xff, 0xaf, 0xaf, 0xff, 0xaf, 0xd7, 0xff, 0xaf, 0xff,\n    0xff, 0xd7, 0x00, 0xff, 0xd7, 0x5f, 0xff, 0xd7, 0x87, 0xff, 0xd7, 0xaf,\n    0xff, 0xd7, 0xd7, 0xff, 0xd7, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x5f,\n    0xff, 0xff, 0x87, 0xff, 0xff, 0xaf, 0xff, 0xff, 0xd7, 0xff, 0xff, 0xff,\n    0x08, 0x08, 0x08, 0x12, 0x12, 0x12, 0x1c, 0x1c, 0x1c, 0x26, 0x26, 0x26,\n    0x30, 0x30, 0x30, 0x3a, 0x3a, 0x3a, 0x44, 0x44, 0x44, 0x4e, 0x4e, 0x4e,\n    0x58, 0x58, 0x58, 0x62, 0x62, 0x62, 0x6c, 0x6c, 0x6c, 0x76, 0x76, 0x76,\n    0x80, 0x80, 0x80, 0x8a, 0x8a, 0x8a, 0x94, 0x94, 0x94, 0x9e, 0x9e, 0x9e,\n    0xa8, 0xa8, 0xa8, 0xb2, 0xb2, 0xb2, 0xbc, 0xbc, 0xbc, 0xc6, 0xc6, 0xc6,\n    0xd0, 0xd0, 0xd0, 0xda, 0xda, 0xda, 0xe4, 0xe4, 0xe4, 0xee, 0xee, 0xee,\n};\n\n\n/*\n * VT340 undocumented behavior regarding the color palette reported\n * by Vertis Sidus(@vrtsds):\n *     it loads the first fifteen colors as 1 through 15, and loads the\n *     sixteenth color as 0.\n */\nstatic const unsigned char pal_vt340_mono[] = {\n    /* 1   Gray-2   */  13 * 255 / 100, 13 * 255 / 100, 13 * 255 / 100,\n    /* 2   Gray-4   */  26 * 255 / 100, 26 * 255 / 100, 26 * 255 / 100,\n    /* 3   Gray-6   */  40 * 255 / 100, 40 * 255 / 100, 40 * 255 / 100,\n    /* 4   Gray-1   */   6 * 255 / 100,  6 * 255 / 100,  6 * 255 / 100,\n    /* 5   Gray-3   */  20 * 255 / 100, 20 * 255 / 100, 20 * 255 / 100,\n    /* 6   Gray-5   */  33 * 255 / 100, 33 * 255 / 100, 33 * 255 / 100,\n    /* 7   White 7  */  46 * 255 / 100, 46 * 255 / 100, 46 * 255 / 100,\n    /* 8   Black 0  */   0 * 255 / 100,  0 * 255 / 100,  0 * 255 / 100,\n    /* 9   Gray-2   */  13 * 255 / 100, 13 * 255 / 100, 13 * 255 / 100,\n    /* 10  Gray-4   */  26 * 255 / 100, 26 * 255 / 100, 26 * 255 / 100,\n    /* 11  Gray-6   */  40 * 255 / 100, 40 * 255 / 100, 40 * 255 / 100,\n    /* 12  Gray-1   */   6 * 255 / 100,  6 * 255 / 100,  6 * 255 / 100,\n    /* 13  Gray-3   */  20 * 255 / 100, 20 * 255 / 100, 20 * 255 / 100,\n    /* 14  Gray-5   */  33 * 255 / 100, 33 * 255 / 100, 33 * 255 / 100,\n    /* 15  White 7  */  46 * 255 / 100, 46 * 255 / 100, 46 * 255 / 100,\n    /* 0   Black    */   0 * 255 / 100,  0 * 255 / 100,  0 * 255 / 100,\n};\n\n\nstatic const unsigned char pal_vt340_color[] = {\n    /* 1   Blue     */  20 * 255 / 100, 20 * 255 / 100, 80 * 255 / 100,\n    /* 2   Red      */  80 * 255 / 100, 13 * 255 / 100, 13 * 255 / 100,\n    /* 3   Green    */  20 * 255 / 100, 80 * 255 / 100, 20 * 255 / 100,\n    /* 4   Magenta  */  80 * 255 / 100, 20 * 255 / 100, 80 * 255 / 100,\n    /* 5   Cyan     */  20 * 255 / 100, 80 * 255 / 100, 80 * 255 / 100,\n    /* 6   Yellow   */  80 * 255 / 100, 80 * 255 / 100, 20 * 255 / 100,\n    /* 7   Gray 50% */  53 * 255 / 100, 53 * 255 / 100, 53 * 255 / 100,\n    /* 8   Gray 25% */  26 * 255 / 100, 26 * 255 / 100, 26 * 255 / 100,\n    /* 9   Blue*    */  33 * 255 / 100, 33 * 255 / 100, 60 * 255 / 100,\n    /* 10  Red*     */  60 * 255 / 100, 26 * 255 / 100, 26 * 255 / 100,\n    /* 11  Green*   */  33 * 255 / 100, 60 * 255 / 100, 33 * 255 / 100,\n    /* 12  Magenta* */  60 * 255 / 100, 33 * 255 / 100, 60 * 255 / 100,\n    /* 13  Cyan*    */  33 * 255 / 100, 60 * 255 / 100, 60 * 255 / 100,\n    /* 14  Yellow*  */  60 * 255 / 100, 60 * 255 / 100, 33 * 255 / 100,\n    /* 15  Gray 75% */  80 * 255 / 100, 80 * 255 / 100, 80 * 255 / 100,\n    /* 0   Black    */   0 * 255 / 100,  0 * 255 / 100,  0 * 255 / 100,\n};\n\n\n/* create dither context object */\nSIXELAPI SIXELSTATUS\nsixel_dither_new(\n    sixel_dither_t    /* out */ **ppdither, /* dither object to be created */\n    int               /* in */  ncolors,    /* required colors */\n    sixel_allocator_t /* in */  *allocator) /* allocator, null if you use\n                                               default allocator */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    size_t headsize;\n    size_t datasize;\n    size_t wholesize;\n    int quality_mode;\n\n    if (ppdither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: ppdither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    if (allocator == NULL) {\n        status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL);\n        if (SIXEL_FAILED(status)) {\n            *ppdither = NULL;\n            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            status = SIXEL_BAD_INPUT;\n            ncolors = 256;\n        } else if (ncolors < 1) {\n            status = SIXEL_BAD_INPUT;\n            sixel_helper_set_additional_message(\n                \"sixel_dither_new: palette colors must be more than 0\");\n            goto end;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    (*ppdither)->ref = 1;\n    (*ppdither)->palette = (unsigned char*)(*ppdither + 1);\n    (*ppdither)->cachetable = NULL;\n    (*ppdither)->reqcolors = ncolors;\n    (*ppdither)->ncolors = ncolors;\n    (*ppdither)->origcolors = (-1);\n    (*ppdither)->keycolor = (-1);\n    (*ppdither)->optimized = 0;\n    (*ppdither)->optimize_palette = 0;\n    (*ppdither)->complexion = 1;\n    (*ppdither)->bodyonly = 0;\n    (*ppdither)->method_for_largest = SIXEL_LARGE_NORM;\n    (*ppdither)->method_for_rep = SIXEL_REP_CENTER_BOX;\n    (*ppdither)->method_for_diffuse = SIXEL_DIFFUSE_FS;\n    (*ppdither)->quality_mode = quality_mode;\n    (*ppdither)->pixelformat = SIXEL_PIXELFORMAT_RGB888;\n    (*ppdither)->allocator = allocator;\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}\n\n\n/* create dither context object (deprecated) */\nSIXELAPI sixel_dither_t *\nsixel_dither_create(\n    int     /* in */ ncolors)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    sixel_dither_t *dither = NULL;\n\n    status = sixel_dither_new(&dither, ncolors, NULL);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\nend:\n    return dither;\n}\n\n\nSIXELAPI void\nsixel_dither_destroy(\n    sixel_dither_t  /* in */ *dither)\n{\n    sixel_allocator_t *allocator;\n\n    if (dither) {\n        allocator = dither->allocator;\n        sixel_allocator_free(allocator, dither->cachetable);\n        dither->cachetable = NULL;\n        sixel_allocator_free(allocator, dither);\n        sixel_allocator_unref(allocator);\n    }\n}\n\n\nSIXELAPI void\nsixel_dither_ref(\n    sixel_dither_t  /* in */ *dither)\n{\n    /* TODO: be thread safe */\n    ++dither->ref;\n}\n\n\nSIXELAPI void\nsixel_dither_unref(\n    sixel_dither_t  /* in */ *dither)\n{\n    /* TODO: be thread safe */\n    if (dither != NULL && --dither->ref == 0) {\n        sixel_dither_destroy(dither);\n    }\n}\n\n\nSIXELAPI sixel_dither_t *\nsixel_dither_get(\n    int     /* in */ builtin_dither)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char *palette;\n    int ncolors;\n    int keycolor;\n    sixel_dither_t *dither = NULL;\n\n    switch (builtin_dither) {\n    case SIXEL_BUILTIN_MONO_DARK:\n        ncolors = 2;\n        palette = (unsigned char *)pal_mono_dark;\n        keycolor = 0;\n        break;\n    case SIXEL_BUILTIN_MONO_LIGHT:\n        ncolors = 2;\n        palette = (unsigned char *)pal_mono_light;\n        keycolor = 0;\n        break;\n    case SIXEL_BUILTIN_XTERM16:\n        ncolors = 16;\n        palette = (unsigned char *)pal_xterm256;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_XTERM256:\n        ncolors = 256;\n        palette = (unsigned char *)pal_xterm256;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_VT340_MONO:\n        ncolors = 16;\n        palette = (unsigned char *)pal_vt340_mono;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_VT340_COLOR:\n        ncolors = 16;\n        palette = (unsigned char *)pal_vt340_color;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_G1:\n        ncolors = 2;\n        palette = (unsigned char *)pal_gray_1bit;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_G2:\n        ncolors = 4;\n        palette = (unsigned char *)pal_gray_2bit;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_G4:\n        ncolors = 16;\n        palette = (unsigned char *)pal_gray_4bit;\n        keycolor = (-1);\n        break;\n    case SIXEL_BUILTIN_G8:\n        ncolors = 256;\n        palette = (unsigned char *)pal_gray_8bit;\n        keycolor = (-1);\n        break;\n    default:\n        goto end;\n    }\n\n    status = sixel_dither_new(&dither, ncolors, NULL);\n    if (SIXEL_FAILED(status)) {\n        dither = NULL;\n        goto end;\n    }\n\n    dither->palette = palette;\n    dither->keycolor = keycolor;\n    dither->optimized = 1;\n    dither->optimize_palette = 0;\n\nend:\n    return dither;\n}\n\n\nstatic void\nsixel_dither_set_method_for_largest(\n    sixel_dither_t  /* in */ *dither,\n    int             /* in */ method_for_largest)\n{\n    if (method_for_largest == SIXEL_LARGE_AUTO) {\n        method_for_largest = SIXEL_LARGE_NORM;\n    }\n    dither->method_for_largest = method_for_largest;\n}\n\n\nstatic void\nsixel_dither_set_method_for_rep(\n    sixel_dither_t  /* in */ *dither,\n    int             /* in */ method_for_rep)\n{\n    if (method_for_rep == SIXEL_REP_AUTO) {\n        method_for_rep = SIXEL_REP_CENTER_BOX;\n    }\n    dither->method_for_rep = method_for_rep;\n}\n\n\nstatic void\nsixel_dither_set_quality_mode(\n    sixel_dither_t  /* in */  *dither,\n    int             /* in */  quality_mode)\n{\n    if (quality_mode == SIXEL_QUALITY_AUTO) {\n        if (dither->ncolors <= 8) {\n            quality_mode = SIXEL_QUALITY_HIGH;\n        } else {\n            quality_mode = SIXEL_QUALITY_LOW;\n        }\n    }\n    dither->quality_mode = quality_mode;\n}\n\n\nSIXELAPI SIXELSTATUS\nsixel_dither_initialize(\n    sixel_dither_t  /* in */ *dither,\n    unsigned char   /* in */ *data,\n    int             /* in */ width,\n    int             /* in */ height,\n    int             /* in */ pixelformat,\n    int             /* in */ method_for_largest,\n    int             /* in */ method_for_rep,\n    int             /* in */ quality_mode)\n{\n    unsigned char *buf = NULL;\n    unsigned char *normalized_pixels = NULL;\n    unsigned char *input_pixels;\n    SIXELSTATUS status = SIXEL_FALSE;\n\n    if (dither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: dither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    sixel_dither_ref(dither);\n\n    sixel_dither_set_pixelformat(dither, pixelformat);\n\n    switch (pixelformat) {\n    case SIXEL_PIXELFORMAT_RGB888:\n        input_pixels = data;\n        break;\n    default:\n        /* normalize pixelformat */\n        normalized_pixels\n            = (unsigned char *)sixel_allocator_malloc(dither->allocator, (size_t)(width * height * 3));\n        if (normalized_pixels == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_dither_initialize: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n\n        status = sixel_helper_normalize_pixelformat(\n            normalized_pixels,\n            &pixelformat,\n            data,\n            pixelformat,\n            width,\n            height);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        input_pixels = normalized_pixels;\n        break;\n    }\n\n    sixel_dither_set_method_for_largest(dither, method_for_largest);\n    sixel_dither_set_method_for_rep(dither, method_for_rep);\n    sixel_dither_set_quality_mode(dither, quality_mode);\n\n    status = sixel_quant_make_palette(&buf,\n                                      input_pixels,\n                                      (unsigned int)(width * height * 3),\n                                      SIXEL_PIXELFORMAT_RGB888,\n                                      (unsigned int)dither->reqcolors,\n                                      (unsigned int *)&dither->ncolors,\n                                      (unsigned int *)&dither->origcolors,\n                                      dither->method_for_largest,\n                                      dither->method_for_rep,\n                                      dither->quality_mode,\n                                      dither->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n    memcpy(dither->palette, buf, (size_t)(dither->ncolors * 3));\n\n    dither->optimized = 1;\n    if (dither->origcolors <= dither->ncolors) {\n        dither->method_for_diffuse = SIXEL_DIFFUSE_NONE;\n    }\n\n    sixel_quant_free_palette(buf, dither->allocator);\n    status = SIXEL_OK;\n\nend:\n    free(normalized_pixels);\n    sixel_dither_unref(dither);\n    return status;\n}\n\n\n/* set diffusion type, choose from enum methodForDiffuse */\nSIXELAPI void\nsixel_dither_set_diffusion_type(\n    sixel_dither_t  /* in */ *dither,\n    int             /* in */ method_for_diffuse)\n{\n    if (method_for_diffuse == SIXEL_DIFFUSE_AUTO) {\n        if (dither->ncolors > 16) {\n            method_for_diffuse = SIXEL_DIFFUSE_FS;\n        } else {\n            method_for_diffuse = SIXEL_DIFFUSE_ATKINSON;\n        }\n    }\n    dither->method_for_diffuse = method_for_diffuse;\n}\n\n\n/* get number of palette colors */\nSIXELAPI int\nsixel_dither_get_num_of_palette_colors(\n    sixel_dither_t  /* in */ *dither)\n{\n    return dither->ncolors;\n}\n\n\n/* get number of histogram colors */\nSIXELAPI int\nsixel_dither_get_num_of_histogram_colors(\n    sixel_dither_t /* in */ *dither)  /* dither context object */\n{\n    return dither->origcolors;\n}\n\n\n/* typoed: remained for keeping compatibility */\nSIXELAPI int\nsixel_dither_get_num_of_histgram_colors(\n    sixel_dither_t /* in */ *dither)  /* dither context object */\n{\n    return sixel_dither_get_num_of_histogram_colors(dither);\n}\n\n\n/* get palette */\nSIXELAPI unsigned char *\nsixel_dither_get_palette(\n    sixel_dither_t /* in */ *dither)  /* dither context object */\n{\n    return dither->palette;\n}\n\n\n/* set palette */\nSIXELAPI void\nsixel_dither_set_palette(\n    sixel_dither_t /* in */ *dither,   /* dither context object */\n    unsigned char  /* in */ *palette)\n{\n    memcpy(dither->palette, palette, (size_t)(dither->ncolors * 3));\n}\n\n\n/* set the factor of complexion color correcting */\nSIXELAPI void\nsixel_dither_set_complexion_score(\n    sixel_dither_t /* in */ *dither,  /* dither context object */\n    int            /* in */ score)    /* complexion score (>= 1) */\n{\n    dither->complexion = score;\n}\n\n\n/* set whether omitting palette difinition */\nSIXELAPI void\nsixel_dither_set_body_only(\n    sixel_dither_t /* in */ *dither,     /* dither context object */\n    int            /* in */ bodyonly)    /* 0: output palette section\n                                            1: do not output palette section  */\n{\n    dither->bodyonly = bodyonly;\n}\n\n\n/* set whether optimize palette size */\nSIXELAPI void\nsixel_dither_set_optimize_palette(\n    sixel_dither_t /* in */ *dither,   /* dither context object */\n    int            /* in */ do_opt)    /* 0: optimize palette size\n                                          1: don't optimize palette size */\n{\n    dither->optimize_palette = do_opt;\n}\n\n\n/* set pixelformat */\nSIXELAPI void\nsixel_dither_set_pixelformat(\n    sixel_dither_t /* in */ *dither,     /* dither context object */\n    int            /* in */ pixelformat) /* one of enum pixelFormat */\n{\n    dither->pixelformat = pixelformat;\n}\n\n\n/* set transparent */\nSIXELAPI void\nsixel_dither_set_transparent(\n    sixel_dither_t /* in */ *dither,      /* dither context object */\n    int            /* in */ transparent)  /* transparent color index */\n{\n    dither->keycolor = transparent;\n}\n\n\n/* set transparent */\nSIXELAPI unsigned char *\nsixel_dither_apply_palette(\n    sixel_dither_t  /* in */ *dither,\n    unsigned char   /* in */ *pixels,\n    int             /* in */ width,\n    int             /* in */ height)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    size_t bufsize;\n    unsigned char *dest = NULL;\n    int ncolors;\n    unsigned char *normalized_pixels = NULL;\n    unsigned char *input_pixels;\n\n    if (dither == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_apply_palette: dither is null.\");\n        status = SIXEL_BAD_ARGUMENT;\n        goto end;\n    }\n\n    sixel_dither_ref(dither);\n\n    bufsize = (size_t)(width * height) * sizeof(unsigned char);\n    dest = (unsigned char *)sixel_allocator_malloc(dither->allocator, bufsize);\n    if (dest == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    /* if quality_mode is full, do not use palette caching */\n    if (dither->quality_mode == SIXEL_QUALITY_FULL) {\n        dither->optimized = 0;\n    }\n\n    if (dither->cachetable == NULL && dither->optimized) {\n        if (dither->palette != pal_mono_dark && dither->palette != pal_mono_light) {\n            dither->cachetable = (unsigned short *)sixel_allocator_calloc(dither->allocator,\n                                                                          (size_t)(1 << 3 * 5),\n                                                                          sizeof(unsigned short));\n            if (dither->cachetable == NULL) {\n                sixel_helper_set_additional_message(\n                    \"sixel_dither_new: sixel_allocator_calloc() failed.\");\n                status = SIXEL_BAD_ALLOCATION;\n                goto end;\n            }\n        }\n    }\n\n    if (dither->pixelformat != SIXEL_PIXELFORMAT_RGB888) {\n        /* normalize pixelformat */\n        normalized_pixels\n            = (unsigned char *)sixel_allocator_malloc(dither->allocator, (size_t)(width * height * 3));\n        if (normalized_pixels == NULL) {\n            sixel_helper_set_additional_message(\n                \"sixel_dither_new: sixel_allocator_malloc() failed.\");\n            status = SIXEL_BAD_ALLOCATION;\n            goto end;\n        }\n        status = sixel_helper_normalize_pixelformat(normalized_pixels,\n                                                    &dither->pixelformat,\n                                                    pixels, dither->pixelformat,\n                                                    width, height);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n        input_pixels = normalized_pixels;\n    } else {\n        input_pixels = pixels;\n    }\n\n    status = sixel_quant_apply_palette(dest,\n                                       input_pixels,\n                                       width, height, 3,\n                                       dither->palette,\n                                       dither->ncolors,\n                                       dither->method_for_diffuse,\n                                       dither->optimized,\n                                       dither->optimize_palette,\n                                       dither->complexion,\n                                       dither->cachetable,\n                                       &ncolors,\n                                       dither->allocator);\n    if (SIXEL_FAILED(status)) {\n        free(dest);\n        dest = NULL;\n        goto end;\n    }\n\n    dither->ncolors = ncolors;\n\nend:\n    free(normalized_pixels);\n    sixel_dither_unref(dither);\n    return dest;\n}\n\n\n#if HAVE_TESTS\nstatic int\ntest1(void)\n{\n    sixel_dither_t *dither = NULL;\n    int nret = EXIT_FAILURE;\n\n#if HAVE_DIAGNOSTIC_DEPRECATED_DECLARATIONS\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n    dither = sixel_dither_create(0);\n#if HAVE_DIAGNOSTIC_DEPRECATED_DECLARATIONS\n#  pragma GCC diagnostic pop\n#endif\n    if (dither == NULL) {\n        goto error;\n    }\n    sixel_dither_ref(dither);\n    sixel_dither_unref(dither);\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_dither_unref(dither);\n    return nret;\n}\n\nstatic int\ntest2(void)\n{\n    sixel_dither_t *dither = NULL;\n    int colors;\n    int nret = EXIT_FAILURE;\n\n#if HAVE_DIAGNOSTIC_DEPRECATED_DECLARATIONS\n#  pragma GCC diagnostic push\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n    dither = sixel_dither_create(INT_MAX);\n#if HAVE_DIAGNOSTIC_DEPRECATED_DECLARATIONS\n#  pragma GCC diagnostic pop\n#endif\n    if (dither == NULL) {\n        goto error;\n    }\n    sixel_dither_set_body_only(dither, 1);\n    colors = sixel_dither_get_num_of_histogram_colors(dither);\n    if (colors != -1) {\n        goto error;\n    }\n    nret = EXIT_SUCCESS;\n\nerror:\n    sixel_dither_unref(dither);\n    return nret;\n}\n\n\nSIXELAPI int\nsixel_dither_tests_main(void)\n{\n    int nret = EXIT_FAILURE;\n    size_t i;\n    typedef int (* testcase)(void);\n\n    static testcase const testcases[] = {\n        test1,\n        test2,\n    };\n\n    for (i = 0; i < sizeof(testcases) / sizeof(testcase); ++i) {\n        nret = testcases[i]();\n        if (nret != EXIT_SUCCESS) {\n            goto error;\n        }\n    }\n\n    nret = EXIT_SUCCESS;\n\nerror:\n    return nret;\n}\n#endif  /* HAVE_TESTS */\n\n/* emacs Local Variables:      */\n/* emacs mode: c               */\n/* emacs tab-width: 4          */\n/* emacs indent-tabs-mode: nil */\n/* emacs c-basic-offset: 4     */\n/* emacs End:                  */\n/* vim: set expandtab ts=4 sts=4 sw=4 : */\n/* EOF */\n"], "filenames": ["src/dither.c"], "buggy_code_start_loc": [286], "buggy_code_end_loc": [290], "fixing_code_start_loc": [287], "fixing_code_end_loc": [294], "type": "NVD-CWE-noinfo", "message": "An issue in the dither.c component of libsixel prior to v1.8.4 allows attackers to cause a denial of service (DOS) via a crafted PNG file.", "other": {"cve": {"id": "CVE-2020-21048", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-14T16:15:08.403", "lastModified": "2021-09-24T17:05:49.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue in the dither.c component of libsixel prior to v1.8.4 allows attackers to cause a denial of service (DOS) via a crafted PNG file."}, {"lang": "es", "value": "Un problema en el componente dither.c de libsixel versiones anteriores a v1.8.4, permite a atacantes causar una denegaci\u00f3n de servicio (DOS) por medio de un archivo PNG dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libsixel_project:libsixel:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.4", "matchCriteriaId": "BF1F3897-870A-4F82-896A-EBE9581C656A"}]}]}], "references": [{"url": "https://bitbucket.org/netbsd/pkgsrc/commits/6f0c011cbfccdffa635d04c84433b1a02687adad", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://github.com/saitoha/libsixel/blob/master/ChangeLog", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/saitoha/libsixel/commit/cb373ab6614c910407c5e5a93ab935144e62b037", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/saitoha/libsixel/issues/73", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/saitoha/libsixel/releases/tag/v1.8.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/saitoha/libsixel/commit/cb373ab6614c910407c5e5a93ab935144e62b037"}}