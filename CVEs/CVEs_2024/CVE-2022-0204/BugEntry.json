{"buggy_code": ["// SPDX-License-Identifier: LGPL-2.1-or-later\n/*\n *\n *  BlueZ - Bluetooth protocol stack for Linux\n *\n *  Copyright (C) 2014  Google Inc.\n *\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <sys/uio.h>\n#include <errno.h>\n\n#include \"src/shared/att.h\"\n#include \"lib/bluetooth.h\"\n#include \"lib/uuid.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/gatt-server.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/timeout.h\"\n\n#ifndef MAX\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#endif\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n/*\n * TODO: This is an arbitrary limit. Come up with something reasonable or\n * perhaps an API to set this value if there is a use case for it.\n */\n#define DEFAULT_MAX_PREP_QUEUE_LEN 30\n\n#define NFY_MULT_TIMEOUT 10\n\nstruct async_read_op {\n\tstruct bt_att_chan *chan;\n\tstruct bt_gatt_server *server;\n\tuint8_t opcode;\n\tbool done;\n\tuint8_t *pdu;\n\tsize_t pdu_len;\n\tsize_t value_len;\n\tstruct queue *db_data;\n};\n\nstruct async_write_op {\n\tstruct bt_att_chan *chan;\n\tstruct bt_gatt_server *server;\n\tuint8_t opcode;\n};\n\nstruct prep_write_data {\n\tstruct bt_gatt_server *server;\n\tuint8_t *value;\n\tuint16_t handle;\n\tuint16_t offset;\n\tuint16_t length;\n\n\tbool reliable_supported;\n};\n\nstatic void prep_write_data_destroy(void *user_data)\n{\n\tstruct prep_write_data *data = user_data;\n\n\tfree(data->value);\n\tfree(data);\n}\n\nstruct nfy_mult_data {\n\tunsigned int id;\n\tuint8_t *pdu;\n\tuint16_t offset;\n\tuint16_t len;\n};\n\nstruct bt_gatt_server {\n\tstruct gatt_db *db;\n\tstruct bt_att *att;\n\tint ref_count;\n\tuint16_t mtu;\n\n\tunsigned int mtu_id;\n\tunsigned int read_by_grp_type_id;\n\tunsigned int read_by_type_id;\n\tunsigned int find_info_id;\n\tunsigned int find_by_type_value_id;\n\tunsigned int write_id;\n\tunsigned int write_cmd_id;\n\tunsigned int read_id;\n\tunsigned int read_blob_id;\n\tunsigned int read_multiple_id;\n\tunsigned int read_multiple_vl_id;\n\tunsigned int prep_write_id;\n\tunsigned int exec_write_id;\n\n\tuint8_t min_enc_size;\n\n\tstruct queue *prep_queue;\n\tunsigned int max_prep_queue_len;\n\n\tbt_gatt_server_debug_func_t debug_callback;\n\tbt_gatt_server_destroy_func_t debug_destroy;\n\tvoid *debug_data;\n\n\tbt_gatt_server_authorize_cb_t authorize;\n\tvoid *authorize_data;\n\n\tstruct nfy_mult_data *nfy_mult;\n};\n\nstatic void bt_gatt_server_free(struct bt_gatt_server *server)\n{\n\tif (server->debug_destroy)\n\t\tserver->debug_destroy(server->debug_data);\n\n\tbt_att_unregister(server->att, server->mtu_id);\n\tbt_att_unregister(server->att, server->read_by_grp_type_id);\n\tbt_att_unregister(server->att, server->read_by_type_id);\n\tbt_att_unregister(server->att, server->find_info_id);\n\tbt_att_unregister(server->att, server->find_by_type_value_id);\n\tbt_att_unregister(server->att, server->write_id);\n\tbt_att_unregister(server->att, server->write_cmd_id);\n\tbt_att_unregister(server->att, server->read_id);\n\tbt_att_unregister(server->att, server->read_blob_id);\n\tbt_att_unregister(server->att, server->read_multiple_id);\n\tbt_att_unregister(server->att, server->read_multiple_vl_id);\n\tbt_att_unregister(server->att, server->prep_write_id);\n\tbt_att_unregister(server->att, server->exec_write_id);\n\n\tqueue_destroy(server->prep_queue, prep_write_data_destroy);\n\n\tgatt_db_unref(server->db);\n\tbt_att_unref(server->att);\n\tfree(server);\n}\n\nstatic bool get_uuid_le(const uint8_t *uuid, size_t len, bt_uuid_t *out_uuid)\n{\n\tuint128_t u128;\n\n\tswitch (len) {\n\tcase 2:\n\t\tbt_uuid16_create(out_uuid, get_le16(uuid));\n\t\treturn true;\n\tcase 16:\n\t\tbswap_128(uuid, &u128.data);\n\t\tbt_uuid128_create(out_uuid, u128);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic void attribute_read_cb(struct gatt_db_attribute *attrib, int err,\n\t\t\t\t\tconst uint8_t *value, size_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct iovec *iov = user_data;\n\n\tiov->iov_base = (void *) value;\n\tiov->iov_len = length;\n}\n\nstatic bool encode_read_by_grp_type_rsp(struct gatt_db *db, struct queue *q,\n\t\t\t\t\t\tstruct bt_att *att,\n\t\t\t\t\t\tuint16_t mtu, uint8_t *pdu,\n\t\t\t\t\t\tuint16_t *len)\n{\n\tint iter = 0;\n\tuint16_t start_handle, end_handle;\n\tstruct iovec value;\n\tuint8_t data_val_len;\n\n\t*len = 0;\n\n\twhile (queue_peek_head(q)) {\n\t\tstruct gatt_db_attribute *attrib = queue_pop_head(q);\n\n\t\tvalue.iov_base = NULL;\n\t\tvalue.iov_len = 0;\n\n\t\t/*\n\t\t * This should never be deferred to the read callback for\n\t\t * primary/secondary service declarations.\n\t\t */\n\t\tif (!gatt_db_attribute_read(attrib, 0,\n\t\t\t\t\t\tBT_ATT_OP_READ_BY_GRP_TYPE_REQ,\n\t\t\t\t\t\tatt, attribute_read_cb,\n\t\t\t\t\t\t&value) || !value.iov_len)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Use the first attribute to determine the length of each\n\t\t * attribute data unit. Stop the list when a different attribute\n\t\t * value is seen.\n\t\t */\n\t\tif (iter == 0) {\n\t\t\tdata_val_len = MIN(MIN((unsigned)mtu - 6, 251),\n\t\t\t\t\t\t\t\tvalue.iov_len);\n\t\t\tpdu[0] = data_val_len + 4;\n\t\t\titer++;\n\t\t} else if (value.iov_len != data_val_len)\n\t\t\tbreak;\n\n\t\t/* Stop if this unit would surpass the MTU */\n\t\tif (iter + data_val_len + 4 > mtu - 1)\n\t\t\tbreak;\n\n\t\tgatt_db_attribute_get_service_handles(attrib, &start_handle,\n\t\t\t\t\t\t\t\t&end_handle);\n\n\t\tput_le16(start_handle, pdu + iter);\n\t\tput_le16(end_handle, pdu + iter + 2);\n\t\tmemcpy(pdu + iter + 4, value.iov_base, data_val_len);\n\n\t\titer += data_val_len + 4;\n\t}\n\n\t*len = iter;\n\n\treturn true;\n}\n\nstatic void read_by_grp_type_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t start, end;\n\tbt_uuid_t type;\n\tbt_uuid_t prim, snd;\n\tuint16_t mtu = bt_att_get_mtu(server->att);\n\tuint8_t rsp_pdu[mtu];\n\tuint16_t rsp_len;\n\tuint8_t ecode = 0;\n\tuint16_t ehandle = 0;\n\tstruct queue *q = NULL;\n\n\tif (length != 6 && length != 20) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tq = queue_new();\n\n\tstart = get_le16(pdu);\n\tend = get_le16(pdu + 2);\n\tget_uuid_le(pdu + 4, length - 4, &type);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Read By Grp Type - start: 0x%04x end: 0x%04x\",\n\t\t\t\tstart, end);\n\n\tif (!start || !end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tehandle = start;\n\n\tif (start > end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\t/*\n\t * GATT defines that only the <<Primary Service>> and\n\t * <<Secondary Service>> group types can be used for the\n\t * \"Read By Group Type\" request (Core v4.1, Vol 3, sec 2.5.3). Return an\n\t * error if any other group type is given.\n\t */\n\tbt_uuid16_create(&prim, GATT_PRIM_SVC_UUID);\n\tbt_uuid16_create(&snd, GATT_SND_SVC_UUID);\n\tif (bt_uuid_cmp(&type, &prim) && bt_uuid_cmp(&type, &snd)) {\n\t\tecode = BT_ATT_ERROR_UNSUPPORTED_GROUP_TYPE;\n\t\tgoto error;\n\t}\n\n\tgatt_db_read_by_group_type(server->db, start, end, type, q);\n\n\tif (queue_isempty(q)) {\n\t\tecode = BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND;\n\t\tgoto error;\n\t}\n\n\tif (!encode_read_by_grp_type_rsp(server->db, q, server->att, mtu,\n\t\t\t\t\t\t\trsp_pdu, &rsp_len)) {\n\t\tecode = BT_ATT_ERROR_UNLIKELY;\n\t\tgoto error;\n\t}\n\n\tqueue_destroy(q, NULL);\n\n\tbt_att_chan_send_rsp(chan, BT_ATT_OP_READ_BY_GRP_TYPE_RSP,\n\t\t\t\t\t\trsp_pdu, rsp_len);\n\n\treturn;\n\nerror:\n\tqueue_destroy(q, NULL);\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, ecode);\n}\n\nstatic void async_read_op_destroy(struct async_read_op *op)\n{\n\tbt_gatt_server_unref(op->server);\n\tqueue_destroy(op->db_data, NULL);\n\tfree(op->pdu);\n\tfree(op);\n}\n\nstatic void process_read_by_type(struct async_read_op *op);\n\nstatic void read_by_type_read_complete_cb(struct gatt_db_attribute *attr,\n\t\t\t\t\t\tint err, const uint8_t *value,\n\t\t\t\t\t\tsize_t len, void *user_data)\n{\n\tstruct async_read_op *op = user_data;\n\tstruct bt_gatt_server *server = op->server;\n\tuint16_t mtu;\n\tuint16_t handle;\n\n\tmtu = bt_att_get_mtu(server->att);\n\thandle = gatt_db_attribute_get_handle(attr);\n\n\t/* Terminate the operation if there was an error */\n\tif (err) {\n\t\tbt_att_chan_send_error_rsp(op->chan, BT_ATT_OP_READ_BY_TYPE_REQ,\n\t\t\t\t\t\t\t\thandle, err);\n\t\tasync_read_op_destroy(op);\n\t\treturn;\n\t}\n\n\tif (op->pdu_len == 0) {\n\t\top->value_len = MIN(MIN((unsigned) mtu - 4, 253), len);\n\t\top->pdu[0] = op->value_len + 2;\n\t\top->pdu_len++;\n\t} else if (len != op->value_len) {\n\t\top->done = true;\n\t\tgoto done;\n\t}\n\n\t/* Stop if this would surpass the MTU */\n\tif (op->pdu_len + op->value_len + 2 > (unsigned) mtu - 1) {\n\t\top->done = true;\n\t\tgoto done;\n\t}\n\n\t/* Encode the current value */\n\tput_le16(handle, op->pdu + op->pdu_len);\n\tmemcpy(op->pdu + op->pdu_len + 2, value, op->value_len);\n\n\top->pdu_len += op->value_len + 2;\n\n\tif (op->pdu_len == (unsigned) mtu - 1)\n\t\top->done = true;\n\ndone:\n\tprocess_read_by_type(op);\n}\n\nstatic bool check_min_key_size(uint8_t min_size, uint8_t size)\n{\n\tif (!min_size || !size)\n\t\treturn true;\n\n\treturn min_size <= size;\n}\n\nstatic uint8_t check_permissions(struct bt_gatt_server *server,\n\t\t\t\tstruct gatt_db_attribute *attr, uint32_t mask)\n{\n\tuint8_t enc_size;\n\tuint32_t perm;\n\tint security;\n\n\tperm = gatt_db_attribute_get_permissions(attr);\n\n\tif (perm && mask & BT_ATT_PERM_READ && !(perm & BT_ATT_PERM_READ))\n\t\treturn BT_ATT_ERROR_READ_NOT_PERMITTED;\n\n\tif (perm && mask & BT_ATT_PERM_WRITE && !(perm & BT_ATT_PERM_WRITE))\n\t\treturn BT_ATT_ERROR_WRITE_NOT_PERMITTED;\n\n\tperm &= mask;\n\tif (!perm)\n\t\treturn 0;\n\n\tsecurity = bt_att_get_security(server->att, &enc_size);\n\tif (security < 0)\n\t\treturn BT_ATT_ERROR_UNLIKELY;\n\n\tif (perm & BT_ATT_PERM_SECURE) {\n\t\tif (security < BT_ATT_SECURITY_FIPS)\n\t\t\treturn BT_ATT_ERROR_AUTHENTICATION;\n\n\t\tif (!check_min_key_size(server->min_enc_size, enc_size))\n\t\t\treturn BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE;\n\t}\n\n\tif (perm & BT_ATT_PERM_AUTHEN) {\n\t\tif (security < BT_ATT_SECURITY_HIGH)\n\t\t\treturn BT_ATT_ERROR_AUTHENTICATION;\n\n\t\tif (!check_min_key_size(server->min_enc_size, enc_size))\n\t\t\treturn BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE;\n\t}\n\n\tif (perm & BT_ATT_PERM_ENCRYPT) {\n\t\tif (security < BT_ATT_SECURITY_MEDIUM)\n\t\t\treturn BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION;\n\n\t\tif (!check_min_key_size(server->min_enc_size, enc_size))\n\t\t\treturn BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic void process_read_by_type(struct async_read_op *op)\n{\n\tstruct bt_gatt_server *server = op->server;\n\tuint8_t ecode;\n\tstruct gatt_db_attribute *attr;\n\n\tattr = queue_pop_head(op->db_data);\n\n\tif (op->done || !attr) {\n\t\tbt_att_chan_send_rsp(op->chan, BT_ATT_OP_READ_BY_TYPE_RSP,\n\t\t\t\t\t\top->pdu, op->pdu_len);\n\t\tasync_read_op_destroy(op);\n\t\treturn;\n\t}\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_READ_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tif (gatt_db_attribute_read(attr, 0, op->opcode, server->att,\n\t\t\t\t\tread_by_type_read_complete_cb, op))\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tbt_att_chan_send_error_rsp(op->chan, BT_ATT_OP_READ_BY_TYPE_REQ,\n\t\t\t\tgatt_db_attribute_get_handle(attr), ecode);\n\tasync_read_op_destroy(op);\n}\n\nstatic void read_by_type_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t start, end;\n\tbt_uuid_t type;\n\tuint16_t ehandle = 0;\n\tuint8_t ecode;\n\tstruct queue *q = NULL;\n\tstruct async_read_op *op;\n\n\tif (length != 6 && length != 20) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tq = queue_new();\n\n\tstart = get_le16(pdu);\n\tend = get_le16(pdu + 2);\n\tget_uuid_le(pdu + 4, length - 4, &type);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Read By Type - start: 0x%04x end: 0x%04x\",\n\t\t\t\tstart, end);\n\n\tif (!start || !end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tehandle = start;\n\n\tif (start > end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tgatt_db_read_by_type(server->db, start, end, type, q);\n\n\tif (queue_isempty(q)) {\n\t\tecode = BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND;\n\t\tgoto error;\n\t}\n\n\top = new0(struct async_read_op, 1);\n\top->pdu = malloc(bt_att_get_mtu(server->att));\n\tif (!op->pdu) {\n\t\tfree(op);\n\t\tecode = BT_ATT_ERROR_INSUFFICIENT_RESOURCES;\n\t\tgoto error;\n\t}\n\n\top->chan = chan;\n\top->opcode = opcode;\n\top->server = bt_gatt_server_ref(server);\n\top->db_data = q;\n\n\tprocess_read_by_type(op);\n\n\treturn;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, ecode);\n\tqueue_destroy(q, NULL);\n}\n\nstatic bool encode_find_info_rsp(struct gatt_db *db, struct queue *q,\n\t\t\t\t\t\tuint16_t mtu,\n\t\t\t\t\t\tuint8_t *pdu, uint16_t *len)\n{\n\tuint16_t handle;\n\tstruct gatt_db_attribute *attr;\n\tconst bt_uuid_t *type;\n\tint uuid_len, cur_uuid_len;\n\tint iter = 0;\n\n\t*len = 0;\n\n\twhile (queue_peek_head(q)) {\n\t\tattr = queue_pop_head(q);\n\t\thandle = gatt_db_attribute_get_handle(attr);\n\t\ttype = gatt_db_attribute_get_type(attr);\n\t\tif (!handle || !type)\n\t\t\treturn false;\n\n\t\tcur_uuid_len = bt_uuid_len(type);\n\n\t\tif (iter == 0) {\n\t\t\tswitch (cur_uuid_len) {\n\t\t\tcase 2:\n\t\t\t\tuuid_len = 2;\n\t\t\t\tpdu[0] = 0x01;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 16:\n\t\t\t\tuuid_len = 16;\n\t\t\t\tpdu[0] = 0x02;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\titer++;\n\t\t} else if (cur_uuid_len != uuid_len)\n\t\t\tbreak;\n\n\t\tif (iter + uuid_len + 2 > mtu - 1)\n\t\t\tbreak;\n\n\t\tput_le16(handle, pdu + iter);\n\t\tbt_uuid_to_le(type, pdu + iter + 2);\n\n\t\titer += uuid_len + 2;\n\t}\n\n\t*len = iter;\n\n\treturn true;\n}\n\nstatic void find_info_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t start, end;\n\tuint16_t mtu = bt_att_get_mtu(server->att);\n\tuint8_t rsp_pdu[mtu];\n\tuint16_t rsp_len;\n\tuint8_t ecode = 0;\n\tuint16_t ehandle = 0;\n\tstruct queue *q = NULL;\n\n\tif (length != 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tq = queue_new();\n\n\tstart = get_le16(pdu);\n\tend = get_le16(pdu + 2);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\t\"Find Info - start: 0x%04x end: 0x%04x\",\n\t\t\t\t\tstart, end);\n\n\tif (!start || !end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tehandle = start;\n\n\tif (start > end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tgatt_db_find_information(server->db, start, end, q);\n\n\tif (queue_isempty(q)) {\n\t\tecode = BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND;\n\t\tgoto error;\n\t}\n\n\tif (!encode_find_info_rsp(server->db, q, mtu, rsp_pdu, &rsp_len)) {\n\t\tecode = BT_ATT_ERROR_UNLIKELY;\n\t\tgoto error;\n\t}\n\n\tbt_att_chan_send_rsp(chan, BT_ATT_OP_FIND_INFO_RSP, rsp_pdu, rsp_len);\n\n\tqueue_destroy(q, NULL);\n\n\treturn;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, ecode);\n\tqueue_destroy(q, NULL);\n\n}\n\nstruct find_by_type_val_data {\n\tuint8_t *pdu;\n\tuint16_t len;\n\tuint16_t mtu;\n\tuint8_t ecode;\n};\n\nstatic void find_by_type_val_att_cb(struct gatt_db_attribute *attrib,\n\t\t\t\t\t\t\t\tvoid *user_data)\n{\n\tuint16_t handle, end_handle;\n\tstruct find_by_type_val_data *data = user_data;\n\n\tif (data->ecode)\n\t\treturn;\n\n\tif (data->len + 4 > data->mtu - 1)\n\t\treturn;\n\n\t/*\n\t * This OP is only valid for Primary Service per the spec\n\t * page 562, so this should work.\n\t */\n\tgatt_db_attribute_get_service_data(attrib, &handle, &end_handle, NULL,\n\t\t\t\t\t\t\t\t\tNULL);\n\n\tif (!handle || !end_handle) {\n\t\tdata->ecode = BT_ATT_ERROR_UNLIKELY;\n\t\treturn;\n\t}\n\n\tput_le16(handle, data->pdu + data->len);\n\tput_le16(end_handle, data->pdu + data->len + 2);\n\n\tdata->len += 4;\n}\n\nstatic void find_by_type_val_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t start, end, uuid16;\n\tstruct find_by_type_val_data data;\n\tuint16_t mtu = bt_att_get_mtu(server->att);\n\tuint8_t rsp_pdu[mtu];\n\tuint16_t ehandle = 0;\n\tbt_uuid_t uuid;\n\n\tif (length < 6) {\n\t\tdata.ecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tdata.pdu = rsp_pdu;\n\tdata.len = 0;\n\tdata.mtu = mtu;\n\tdata.ecode = 0;\n\n\tstart = get_le16(pdu);\n\tend = get_le16(pdu + 2);\n\tuuid16 = get_le16(pdu + 4);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\"Find By Type Value - start: 0x%04x end: 0x%04x uuid: 0x%04x\",\n\t\t\tstart, end, uuid16);\n\tehandle = start;\n\tif (start > end) {\n\t\tdata.ecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tbt_uuid16_create(&uuid, uuid16);\n\tgatt_db_find_by_type_value(server->db, start, end, &uuid, pdu + 6,\n\t\t\t\t\t\t\tlength - 6,\n\t\t\t\t\t\t\tfind_by_type_val_att_cb,\n\t\t\t\t\t\t\t&data);\n\n\tif (!data.len)\n\t\tdata.ecode = BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND;\n\n\tif (data.ecode)\n\t\tgoto error;\n\n\tbt_att_chan_send_rsp(chan, BT_ATT_OP_FIND_BY_TYPE_RSP,\n\t\t\t\t\tdata.pdu, data.len);\n\n\treturn;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, data.ecode);\n}\n\nstatic void async_write_op_destroy(struct async_write_op *op)\n{\n\tbt_gatt_server_unref(op->server);\n\tfree(op);\n}\n\nstatic void write_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct async_write_op *op = user_data;\n\tstruct bt_gatt_server *server = op->server;\n\tuint16_t handle;\n\n\tif (op->opcode == BT_ATT_OP_WRITE_CMD) {\n\t\tasync_write_op_destroy(op);\n\t\treturn;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\t\t\"Write Complete: err %d\", err);\n\n\thandle = gatt_db_attribute_get_handle(attr);\n\n\tif (err)\n\t\tbt_att_chan_send_error_rsp(op->chan, op->opcode, handle, err);\n\telse\n\t\tbt_att_chan_send_rsp(op->chan, BT_ATT_OP_WRITE_RSP, NULL, 0);\n\n\tasync_write_op_destroy(op);\n}\n\nstatic uint8_t authorize_req(struct bt_gatt_server *server,\n\t\t\t\t\tuint8_t opcode, uint16_t handle)\n{\n\tif (!server->authorize)\n\t\treturn 0;\n\n\treturn server->authorize(server->att, opcode, handle,\n\t\t\t\t\t\tserver->authorize_data);\n}\n\nstatic void write_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct gatt_db_attribute *attr;\n\tuint16_t handle = 0;\n\tstruct async_write_op *op = NULL;\n\tuint8_t ecode;\n\n\tif (length < 2) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tecode = authorize_req(server, opcode, handle);\n\tif (ecode)\n\t\tgoto error;\n\n\thandle = get_le16(pdu);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Write %s - handle: 0x%04x\",\n\t\t\t\t(opcode == BT_ATT_OP_WRITE_REQ) ? \"Req\" : \"Cmd\",\n\t\t\t\thandle);\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\top = new0(struct async_write_op, 1);\n\top->chan = chan;\n\top->server = bt_gatt_server_ref(server);\n\top->opcode = opcode;\n\n\tif (gatt_db_attribute_write(attr, 0, pdu + 2, length - 2, opcode,\n\t\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\t\twrite_complete_cb, op))\n\t\treturn;\n\n\tasync_write_op_destroy(op);\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tif (opcode == BT_ATT_OP_WRITE_CMD)\n\t\treturn;\n\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n\nstatic uint8_t get_read_rsp_opcode(uint8_t opcode)\n{\n\n\tswitch (opcode) {\n\tcase BT_ATT_OP_READ_REQ:\n\t\treturn BT_ATT_OP_READ_RSP;\n\tcase BT_ATT_OP_READ_BLOB_REQ:\n\t\treturn BT_ATT_OP_READ_BLOB_RSP;\n\tdefault:\n\t\t/*\n\t\t * Should never happen\n\t\t *\n\t\t * TODO: It would be nice to have a debug-mode assert macro\n\t\t * for development builds. This way bugs could be easily catched\n\t\t * during development and there would be self documenting code\n\t\t * that wouldn't be crash release builds.\n\t\t */\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void read_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\tconst uint8_t *value, size_t len,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct async_read_op *op = user_data;\n\tstruct bt_gatt_server *server = op->server;\n\tuint8_t rsp_opcode;\n\tuint16_t mtu;\n\tuint16_t handle;\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Read Complete: err %d\", err);\n\n\tmtu = bt_att_get_mtu(server->att);\n\thandle = gatt_db_attribute_get_handle(attr);\n\n\tif (err) {\n\t\tbt_att_chan_send_error_rsp(op->chan, op->opcode, handle, err);\n\t\tasync_read_op_destroy(op);\n\t\treturn;\n\t}\n\n\trsp_opcode = get_read_rsp_opcode(op->opcode);\n\n\tbt_att_chan_send_rsp(op->chan, rsp_opcode, len ? value : NULL,\n\t\t\t\t\tMIN((unsigned int) mtu - 1, len));\n\tasync_read_op_destroy(op);\n}\n\nstatic void handle_read_req(struct bt_att_chan *chan,\n\t\t\t\tstruct bt_gatt_server *server, uint8_t opcode,\n\t\t\t\tuint16_t handle, uint16_t offset)\n{\n\tstruct gatt_db_attribute *attr;\n\tuint8_t ecode;\n\tstruct async_read_op *op = NULL;\n\n\tecode = authorize_req(server, opcode, handle);\n\tif (ecode)\n\t\tgoto error;\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\"Read %sReq - handle: 0x%04x\",\n\t\t\topcode == BT_ATT_OP_READ_BLOB_REQ ? \"Blob \" : \"\",\n\t\t\thandle);\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_READ_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\top = new0(struct async_read_op, 1);\n\top->chan = chan;\n\top->opcode = opcode;\n\top->server = bt_gatt_server_ref(server);\n\n\tif (gatt_db_attribute_read(attr, offset, opcode, server->att,\n\t\t\t\t\t\t\tread_complete_cb, op))\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tif (op)\n\t\tasync_read_op_destroy(op);\n\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n\nstatic void read_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle;\n\n\tif (length != 2) {\n\t\tbt_att_chan_send_error_rsp(chan, opcode, 0,\n\t\t\t\t\t\tBT_ATT_ERROR_INVALID_PDU);\n\t\treturn;\n\t}\n\n\thandle = get_le16(pdu);\n\n\thandle_read_req(chan, server, opcode, handle, 0);\n}\n\nstatic void read_blob_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle, offset;\n\n\tif (length != 4) {\n\t\tbt_att_chan_send_error_rsp(chan, opcode, 0,\n\t\t\t\t\t\tBT_ATT_ERROR_INVALID_PDU);\n\t\treturn;\n\t}\n\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\n\thandle_read_req(chan, server, opcode, handle, offset);\n}\n\nstruct read_mult_data {\n\tstruct bt_att_chan *chan;\n\tstruct bt_gatt_server *server;\n\tuint8_t opcode;\n\tuint16_t *handles;\n\tsize_t cur_handle;\n\tsize_t num_handles;\n\tuint8_t *rsp_data;\n\tsize_t length;\n\tsize_t mtu;\n};\n\nstatic void read_mult_data_free(struct read_mult_data *data)\n{\n\tfree(data->handles);\n\tfree(data->rsp_data);\n\tfree(data);\n}\n\nstatic void read_multiple_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\tconst uint8_t *value, size_t len,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct read_mult_data *data = user_data;\n\tstruct gatt_db_attribute *next_attr;\n\tuint16_t handle = gatt_db_attribute_get_handle(attr);\n\tuint8_t ecode;\n\tuint16_t length;\n\n\tif (err != 0) {\n\t\tecode = err;\n\t\tgoto error;\n\t}\n\n\tlength = data->opcode == BT_ATT_OP_READ_MULT_VL_REQ ?\n\t\t\tMIN(len, MAX(data->mtu - data->length, 3) - 3) :\n\t\t\tMIN(len, data->mtu - data->length - 1);\n\n\tif (data->opcode == BT_ATT_OP_READ_MULT_VL_REQ) {\n\t\t/* The Length Value Tuple List may be truncated within the first\n\t\t * two octets of a tuple due to the size limits of the current\n\t\t * ATT_MTU, but the first two octets cannot be separated.\n\t\t */\n\t\tif (data->mtu - data->length >= 3) {\n\t\t\tput_le16(len, data->rsp_data + data->length);\n\t\t\tdata->length += 2;\n\t\t}\n\t}\n\n\tmemcpy(data->rsp_data + data->length, value, length);\n\tdata->length += length;\n\n\tdata->cur_handle++;\n\n\tif (data->cur_handle == data->num_handles) {\n\t\tbt_att_chan_send_rsp(data->chan, data->opcode + 1,\n\t\t\t\t\t\tdata->rsp_data, data->length);\n\t\tread_mult_data_free(data);\n\t\treturn;\n\t}\n\n\thandle = data->handles[data->cur_handle];\n\n\tutil_debug(data->server->debug_callback, data->server->debug_data,\n\t\t\t\t\"%s Req - #%zu of %zu: 0x%04x\",\n\t\t\t\tdata->opcode == BT_ATT_OP_READ_MULT_REQ ?\n\t\t\t\t\"Read Multiple\" :\n\t\t\t\t\"Read Multiple Variable Length\",\n\t\t\t\tdata->cur_handle + 1, data->num_handles,\n\t\t\t\thandle);\n\n\tnext_attr = gatt_db_get_attribute(data->server->db, handle);\n\n\tif (!next_attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tecode = check_permissions(data->server, next_attr,\n\t\t\t\t\t\tBT_ATT_PERM_READ_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tif (gatt_db_attribute_read(next_attr, 0, data->opcode,\n\t\t\t\t\tdata->server->att,\n\t\t\t\t\tread_multiple_complete_cb, data))\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tbt_att_chan_send_error_rsp(data->chan, data->opcode, handle, ecode);\n\tread_mult_data_free(data);\n}\n\nstatic struct read_mult_data *read_mult_data_new(struct bt_gatt_server *server,\n\t\t\t\t\t\tstruct bt_att_chan *chan,\n\t\t\t\t\t\tuint8_t opcode,\n\t\t\t\t\t\tuint16_t num_handles)\n{\n\tstruct read_mult_data *data;\n\n\tdata = new0(struct read_mult_data, 1);\n\tdata->chan = chan;\n\tdata->opcode = opcode;\n\tdata->handles = new0(uint16_t, num_handles);\n\tdata->rsp_data = NULL;\n\tdata->server = server;\n\tdata->num_handles = num_handles;\n\tdata->cur_handle = 0;\n\tdata->mtu = bt_att_get_mtu(server->att);\n\tdata->length = 0;\n\tdata->rsp_data = new0(uint8_t, data->mtu - 1);\n\n\treturn data;\n}\n\nstatic void read_multiple_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct gatt_db_attribute *attr;\n\tstruct read_mult_data *data = NULL;\n\tuint8_t ecode;\n\tsize_t i = 0;\n\tuint16_t handle = 0;\n\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tdata = read_mult_data_new(server, chan, opcode, length / 2);\n\tif (!data)\n\t\tgoto error;\n\n\tfor (i = 0; i < data->num_handles; i++)\n\t\tdata->handles[i] = get_le16(pdu + i * 2);\n\n\thandle = data->handles[0];\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\"%s Req - %zu handles, 1st: 0x%04x\",\n\t\t\tdata->opcode == BT_ATT_OP_READ_MULT_REQ ?\n\t\t\t\"Read Multiple\" : \"Read Multiple Variable Length\",\n\t\t\tdata->num_handles, handle);\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tecode = check_permissions(data->server, attr, BT_ATT_PERM_READ_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tif (gatt_db_attribute_read(attr, 0, opcode, server->att,\n\t\t\t\t\tread_multiple_complete_cb, data))\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tif (data)\n\t\tread_mult_data_free(data);\n\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n\nstatic bool append_prep_data(struct prep_write_data *prep_data, uint16_t handle,\n\t\t\t\t\tuint16_t length, uint8_t *value)\n{\n\tuint8_t *val;\n\tuint16_t len;\n\n\tif (!length)\n\t\treturn true;\n\n\tlen = prep_data->length + length;\n\n\tval = realloc(prep_data->value, len);\n\tif (!val)\n\t\treturn false;\n\n\tmemcpy(val + prep_data->length, value, length);\n\n\tprep_data->value = val;\n\tprep_data->length = len;\n\n\treturn true;\n}\n\nstatic bool is_reliable_write_supported(const struct bt_gatt_server  *server,\n\t\t\t\t\t\t\tuint16_t handle)\n{\n\tstruct gatt_db_attribute *attr;\n\tuint16_t ext_prop;\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr)\n\t\treturn false;\n\n\tif (!gatt_db_attribute_get_char_data(attr, NULL, NULL, NULL, &ext_prop,\n\t\t\t\t\t\t\t\t\tNULL))\n\t\treturn false;\n\n\treturn (ext_prop & BT_GATT_CHRC_EXT_PROP_RELIABLE_WRITE);\n}\n\nstatic bool prep_data_new(struct bt_gatt_server *server,\n\t\t\t\t\tuint16_t handle, uint16_t offset,\n\t\t\t\t\tuint16_t length, uint8_t *value)\n{\n\tstruct prep_write_data *prep_data;\n\n\tprep_data = new0(struct prep_write_data, 1);\n\n\tif (!append_prep_data(prep_data, handle, length, value)) {\n\t\tprep_write_data_destroy(prep_data);\n\t\treturn false;\n\t}\n\n\tprep_data->server = server;\n\tprep_data->handle = handle;\n\tprep_data->offset = offset;\n\n\t/*\n\t * Handle is the value handle. We need characteristic declaration\n\t * handle which in BlueZ is handle_value -1\n\t */\n\tprep_data->reliable_supported = is_reliable_write_supported(server,\n\t\t\t\t\t\t\t\thandle - 1);\n\n\tqueue_push_tail(server->prep_queue, prep_data);\n\n\treturn true;\n}\n\nstatic bool store_prep_data(struct bt_gatt_server *server,\n\t\t\t\t\tuint16_t handle, uint16_t offset,\n\t\t\t\t\tuint16_t length, uint8_t *value)\n{\n\tstruct prep_write_data *prep_data = NULL;\n\n\t/*\n\t * Now lets check if prep write is a continuation of long write\n\t * If so do aggregation of data\n\t */\n\tprep_data = queue_peek_tail(server->prep_queue);\n\tif (prep_data && (prep_data->handle == handle) &&\n\t\t\t(offset == (prep_data->length + prep_data->offset)))\n\t\treturn append_prep_data(prep_data, handle, length, value);\n\n\treturn prep_data_new(server, handle, offset, length, value);\n}\n\nstruct prep_write_complete_data {\n\tstruct bt_att_chan *chan;\n\tvoid *pdu;\n\tuint16_t length;\n\tstruct bt_gatt_server *server;\n};\n\nstatic void prep_write_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct prep_write_complete_data *pwcd = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\n\thandle = get_le16(pwcd->pdu);\n\n\tif (err) {\n\t\tbt_att_chan_send_error_rsp(pwcd->chan, BT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\t\t\thandle, err);\n\t\tfree(pwcd->pdu);\n\t\tfree(pwcd);\n\n\t\treturn;\n\t}\n\n\toffset = get_le16(pwcd->pdu + 2);\n\n\tif (!store_prep_data(pwcd->server, handle, offset, pwcd->length - 4,\n\t\t\t\t\t\t&((uint8_t *) pwcd->pdu)[4]))\n\t\tbt_att_chan_send_error_rsp(pwcd->chan, BT_ATT_OP_PREP_WRITE_RSP,\n\t\t\t\t\thandle,\n\t\t\t\t\tBT_ATT_ERROR_INSUFFICIENT_RESOURCES);\n\n\tbt_att_chan_send_rsp(pwcd->chan, BT_ATT_OP_PREP_WRITE_RSP, pwcd->pdu,\n\t\t\t\t\t\t\t\tpwcd->length);\n\n\tfree(pwcd->pdu);\n\tfree(pwcd);\n}\n\nstatic void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\tstruct gatt_db_attribute *attr;\n\tstruct prep_write_complete_data *pwcd;\n\tuint8_t ecode, status;\n\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tif (queue_length(server->prep_queue) >= server->max_prep_queue_len) {\n\t\tecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;\n\t\tgoto error;\n\t}\n\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Prep Write Req - handle: 0x%04x\", handle);\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tpwcd = new0(struct prep_write_complete_data, 1);\n\tpwcd->chan = chan;\n\tpwcd->pdu = malloc(length);\n\tmemcpy(pwcd->pdu, pdu, length);\n\tpwcd->length = length;\n\tpwcd->server = server;\n\n\tstatus = gatt_db_attribute_write(attr, offset, NULL, 0,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\tprep_write_complete_cb, pwcd);\n\n\tif (status)\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n\nstruct exec_data {\n\tstruct bt_att_chan *chan;\n\tstruct bt_gatt_server *server;\n};\n\nstatic void exec_next_prep_write(struct exec_data *data, uint16_t ehandle,\n\t\t\t\t\t\t\t\tint err);\n\nstatic void exec_write_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct exec_data *data = user_data;\n\tuint16_t handle = gatt_db_attribute_get_handle(attr);\n\n\texec_next_prep_write(data, handle, err);\n}\n\nstatic void exec_next_prep_write(struct exec_data *data, uint16_t ehandle,\n\t\t\t\t\t\t\t\tint err)\n{\n\tstruct prep_write_data *next = NULL;\n\tstruct gatt_db_attribute *attr;\n\tbool status;\n\n\tif (err)\n\t\tgoto error;\n\n\tnext = queue_pop_head(data->server->prep_queue);\n\tif (!next) {\n\t\tbt_att_chan_send_rsp(data->chan, BT_ATT_OP_EXEC_WRITE_RSP,\n\t\t\t\t\t\t\t\tNULL, 0);\n\t\tfree(data);\n\t\treturn;\n\t}\n\n\tattr = gatt_db_get_attribute(data->server->db, next->handle);\n\tif (!attr) {\n\t\terr = BT_ATT_ERROR_UNLIKELY;\n\t\tgoto error;\n\t}\n\n\tstatus = gatt_db_attribute_write(attr, next->offset,\n\t\t\t\t\t\tnext->value, next->length,\n\t\t\t\t\t\tBT_ATT_OP_EXEC_WRITE_REQ,\n\t\t\t\t\t\tdata->server->att,\n\t\t\t\t\t\texec_write_complete_cb, data);\n\n\tprep_write_data_destroy(next);\n\n\tif (status)\n\t\treturn;\n\n\terr = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tqueue_remove_all(data->server->prep_queue, NULL, NULL,\n\t\t\t\t\t\tprep_write_data_destroy);\n\n\tbt_att_chan_send_error_rsp(data->chan, BT_ATT_OP_EXEC_WRITE_REQ,\n\t\t\t\t\t\t\t\tehandle, err);\n\tfree(data);\n}\n\nstatic bool find_no_reliable_characteristic(const void *data,\n\t\t\t\t\t\tconst void *match_data)\n{\n\tconst struct prep_write_data *prep_data = data;\n\n\treturn !prep_data->reliable_supported;\n}\n\nstatic void exec_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct exec_data *data;\n\tuint8_t flags;\n\tuint8_t ecode;\n\tbool write;\n\tuint16_t ehandle = 0;\n\n\tif (length != 1) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tflags = ((uint8_t *) pdu)[0];\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Exec Write Req - flags: 0x%02x\", flags);\n\n\tif (flags == 0x00)\n\t\twrite = false;\n\telse if (flags == 0x01)\n\t\twrite = true;\n\telse {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tif (!write) {\n\t\tqueue_remove_all(server->prep_queue, NULL, NULL,\n\t\t\t\t\t\tprep_write_data_destroy);\n\t\tbt_att_chan_send_rsp(chan, BT_ATT_OP_EXEC_WRITE_RSP, NULL, 0);\n\t\treturn;\n\t}\n\n\t/* If there is more than one prep request, we are in reliable session */\n\tif (queue_length(server->prep_queue) > 1) {\n\t\tstruct prep_write_data *prep_data;\n\n\t\tprep_data = queue_find(server->prep_queue,\n\t\t\t\t\tfind_no_reliable_characteristic, NULL);\n\t\tif (prep_data) {\n\t\t\tecode = BT_ATT_ERROR_REQUEST_NOT_SUPPORTED;\n\t\t\tehandle = prep_data->handle;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdata = new0(struct exec_data, 1);\n\tdata->chan = chan;\n\tdata->server = server;\n\n\texec_next_prep_write(data, 0, 0);\n\n\treturn;\n\nerror:\n\tqueue_remove_all(server->prep_queue, NULL, NULL,\n\t\t\t\t\t\tprep_write_data_destroy);\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, ecode);\n}\n\nstatic void exchange_mtu_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t client_rx_mtu;\n\tuint16_t final_mtu;\n\tuint8_t rsp_pdu[2];\n\n\tif (length != 2) {\n\t\tbt_att_chan_send_error_rsp(chan, opcode, 0,\n\t\t\t\t\t\tBT_ATT_ERROR_INVALID_PDU);\n\t\treturn;\n\t}\n\n\tclient_rx_mtu = get_le16(pdu);\n\tfinal_mtu = MAX(MIN(client_rx_mtu, server->mtu), BT_ATT_DEFAULT_LE_MTU);\n\n\t/* Respond with the server MTU */\n\tput_le16(server->mtu, rsp_pdu);\n\tbt_att_chan_send_rsp(chan, BT_ATT_OP_MTU_RSP, rsp_pdu, 2);\n\n\t/* Set MTU to be the minimum */\n\tserver->mtu = final_mtu;\n\tbt_att_set_mtu(server->att, final_mtu);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\"MTU exchange complete, with MTU: %u\", final_mtu);\n}\n\nstatic bool gatt_server_register_att_handlers(struct bt_gatt_server *server)\n{\n\t/* Exchange MTU */\n\tserver->mtu_id = bt_att_register(server->att, BT_ATT_OP_MTU_REQ,\n\t\t\t\t\t\t\t\texchange_mtu_cb,\n\t\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->mtu_id)\n\t\treturn false;\n\n\t/* Read By Group Type */\n\tserver->read_by_grp_type_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_READ_BY_GRP_TYPE_REQ,\n\t\t\t\t\t\tread_by_grp_type_cb,\n\t\t\t\t\t\tserver, NULL);\n\tif (!server->read_by_grp_type_id)\n\t\treturn false;\n\n\t/* Read By Type */\n\tserver->read_by_type_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_READ_BY_TYPE_REQ,\n\t\t\t\t\t\tread_by_type_cb,\n\t\t\t\t\t\tserver, NULL);\n\tif (!server->read_by_type_id)\n\t\treturn false;\n\n\t/* Find Information */\n\tserver->find_info_id = bt_att_register(server->att,\n\t\t\t\t\t\t\tBT_ATT_OP_FIND_INFO_REQ,\n\t\t\t\t\t\t\tfind_info_cb,\n\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->find_info_id)\n\t\treturn false;\n\n\t/* Find By Type Value */\n\tserver->find_by_type_value_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_FIND_BY_TYPE_REQ,\n\t\t\t\t\t\tfind_by_type_val_cb,\n\t\t\t\t\t\tserver, NULL);\n\n\tif (!server->find_by_type_value_id)\n\t\treturn false;\n\n\t/* Write Request */\n\tserver->write_id = bt_att_register(server->att, BT_ATT_OP_WRITE_REQ,\n\t\t\t\t\t\t\t\twrite_cb,\n\t\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->write_id)\n\t\treturn false;\n\n\t/* Write Command */\n\tserver->write_cmd_id = bt_att_register(server->att, BT_ATT_OP_WRITE_CMD,\n\t\t\t\t\t\t\t\twrite_cb,\n\t\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->write_cmd_id)\n\t\treturn false;\n\n\t/* Read Request */\n\tserver->read_id = bt_att_register(server->att, BT_ATT_OP_READ_REQ,\n\t\t\t\t\t\t\t\tread_cb,\n\t\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->read_id)\n\t\treturn false;\n\n\t/* Read Blob Request */\n\tserver->read_blob_id = bt_att_register(server->att,\n\t\t\t\t\t\t\tBT_ATT_OP_READ_BLOB_REQ,\n\t\t\t\t\t\t\tread_blob_cb,\n\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->read_blob_id)\n\t\treturn false;\n\n\t/* Read Multiple Request */\n\tserver->read_multiple_id = bt_att_register(server->att,\n\t\t\t\t\t\t\tBT_ATT_OP_READ_MULT_REQ,\n\t\t\t\t\t\t\tread_multiple_cb,\n\t\t\t\t\t\t\tserver, NULL);\n\n\tif (!server->read_multiple_id)\n\t\treturn false;\n\n\t/* Read Multiple Variable Length Request */\n\tserver->read_multiple_vl_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_READ_MULT_VL_REQ,\n\t\t\t\t\t\tread_multiple_cb,\n\t\t\t\t\t\tserver, NULL);\n\n\tif (!server->read_multiple_vl_id)\n\t\treturn false;\n\n\t/* Prepare Write Request */\n\tserver->prep_write_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tprep_write_cb, server, NULL);\n\tif (!server->prep_write_id)\n\t\treturn false;\n\n\t/* Execute Write Request */\n\tserver->exec_write_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_EXEC_WRITE_REQ,\n\t\t\t\t\t\texec_write_cb, server, NULL);\n\tif (!server->exec_write_id)\n\t\treturn NULL;\n\n\treturn true;\n}\n\nstruct bt_gatt_server *bt_gatt_server_new(struct gatt_db *db,\n\t\t\t\t\tstruct bt_att *att, uint16_t mtu,\n\t\t\t\t\tuint8_t min_enc_size)\n{\n\tstruct bt_gatt_server *server;\n\n\tif (!att || !db)\n\t\treturn NULL;\n\n\tserver = new0(struct bt_gatt_server, 1);\n\tserver->db = gatt_db_ref(db);\n\tserver->att = bt_att_ref(att);\n\tserver->mtu = MAX(mtu, BT_ATT_DEFAULT_LE_MTU);\n\tserver->max_prep_queue_len = DEFAULT_MAX_PREP_QUEUE_LEN;\n\tserver->prep_queue = queue_new();\n\tserver->min_enc_size = min_enc_size;\n\n\tif (!gatt_server_register_att_handlers(server)) {\n\t\tbt_gatt_server_free(server);\n\t\treturn NULL;\n\t}\n\n\treturn bt_gatt_server_ref(server);\n}\n\nuint16_t bt_gatt_server_get_mtu(struct bt_gatt_server *server)\n{\n\tif (!server || !server->att)\n\t\treturn 0;\n\n\treturn bt_att_get_mtu(server->att);\n}\n\nstruct bt_att *bt_gatt_server_get_att(struct bt_gatt_server *server)\n{\n\tif (!server)\n\t\treturn NULL;\n\n\treturn server->att;\n}\n\nstruct bt_gatt_server *bt_gatt_server_ref(struct bt_gatt_server *server)\n{\n\tif (!server)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&server->ref_count, 1);\n\n\treturn server;\n}\n\nvoid bt_gatt_server_unref(struct bt_gatt_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&server->ref_count, 1))\n\t\treturn;\n\n\tbt_gatt_server_free(server);\n}\n\nbool bt_gatt_server_set_debug(struct bt_gatt_server *server,\n\t\t\t\t\tbt_gatt_server_debug_func_t callback,\n\t\t\t\t\tvoid *user_data,\n\t\t\t\t\tbt_gatt_server_destroy_func_t destroy)\n{\n\tif (!server)\n\t\treturn false;\n\n\tif (server->debug_destroy)\n\t\tserver->debug_destroy(server->debug_data);\n\n\tserver->debug_callback = callback;\n\tserver->debug_destroy = destroy;\n\tserver->debug_data = user_data;\n\n\treturn true;\n}\n\nstatic bool notify_multiple(void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\n\tbt_att_send(server->att, BT_ATT_OP_HANDLE_NFY_MULT,\n\t\t\tserver->nfy_mult->pdu, server->nfy_mult->offset, NULL,\n\t\t\tNULL, NULL);\n\n\tfree(server->nfy_mult->pdu);\n\tfree(server->nfy_mult);\n\tserver->nfy_mult = NULL;\n\n\treturn false;\n}\n\nstatic bool notify_append_le16(struct nfy_mult_data *data, uint16_t value)\n{\n\tif (data->offset + sizeof(value) > data->len)\n\t\treturn false;\n\n\tput_le16(value, data->pdu + data->offset);\n\tdata->offset += sizeof(value);\n\n\treturn true;\n}\n\nbool bt_gatt_server_send_notification(struct bt_gatt_server *server,\n\t\t\t\t\tuint16_t handle, const uint8_t *value,\n\t\t\t\t\tuint16_t length, bool multiple)\n{\n\tstruct nfy_mult_data *data = NULL;\n\tbool result;\n\n\tif (!server || (length && !value))\n\t\treturn false;\n\n\tif (multiple) {\n\t\tdata = server->nfy_mult;\n\n\t\t/* flush buffered data if this request hits buffer size limit */\n\t\tif (data && data->offset > 0 &&\n\t\t\t\tdata->len - data->offset < 4 + length) {\n\t\t\tif (server->nfy_mult->id)\n\t\t\t\ttimeout_remove(server->nfy_mult->id);\n\t\t\tnotify_multiple(server);\n\t\t\t/* data has been freed by notify_multiple */\n\t\t\tdata = NULL;\n\t\t}\n\t}\n\n\tif (!data) {\n\t\tdata = new0(struct nfy_mult_data, 1);\n\t\tdata->len = bt_att_get_mtu(server->att) - 1;\n\t\tdata->pdu = malloc(data->len);\n\t}\n\n\tif (!notify_append_le16(data, handle))\n\t\tgoto error;\n\n\tif (multiple) {\n\t\tlength = MIN(data->len - data->offset - 2, length);\n\t\tif (!notify_append_le16(data, length))\n\t\t\tgoto error;\n\t} else {\n\t\tlength = MIN(data->len - data->offset, length);\n\t}\n\n\tmemcpy(data->pdu + data->offset, value, length);\n\tdata->offset += length;\n\n\tif (multiple) {\n\t\tif (!server->nfy_mult)\n\t\t\tserver->nfy_mult = data;\n\n\t\tif (!server->nfy_mult->id)\n\t\t\tserver->nfy_mult->id = timeout_add(NFY_MULT_TIMEOUT,\n\t\t\t\t\t\t   notify_multiple, server,\n\t\t\t\t\t\t   NULL);\n\n\t\treturn true;\n\t}\n\n\tresult = !!bt_att_send(server->att, BT_ATT_OP_HANDLE_NFY,\n\t\t\t\tdata->pdu, data->offset, NULL, NULL, NULL);\n\tfree(data->pdu);\n\tfree(data);\n\n\treturn result;\n\nerror:\n\tif (data)\n\t\tfree(data);\n\n\treturn false;\n}\n\nstruct ind_data {\n\tbt_gatt_server_conf_func_t callback;\n\tbt_gatt_server_destroy_func_t destroy;\n\tvoid *user_data;\n};\n\nstatic void destroy_ind_data(void *user_data)\n{\n\tstruct ind_data *data = user_data;\n\n\tif (data->destroy)\n\t\tdata->destroy(data->user_data);\n\n\tfree(data);\n}\n\nstatic void conf_cb(uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct ind_data *data = user_data;\n\n\tif (data->callback)\n\t\tdata->callback(data->user_data);\n}\n\nbool bt_gatt_server_send_indication(struct bt_gatt_server *server,\n\t\t\t\t\tuint16_t handle, const uint8_t *value,\n\t\t\t\t\tuint16_t length,\n\t\t\t\t\tbt_gatt_server_conf_func_t callback,\n\t\t\t\t\tvoid *user_data,\n\t\t\t\t\tbt_gatt_server_destroy_func_t destroy)\n{\n\tuint16_t pdu_len;\n\tuint8_t *pdu;\n\tstruct ind_data *data;\n\tbool result;\n\n\tif (!server || (length && !value))\n\t\treturn false;\n\n\tpdu_len = MIN(bt_att_get_mtu(server->att) - 1, length + 2);\n\tpdu = malloc(pdu_len);\n\tif (!pdu)\n\t\treturn false;\n\n\tdata = new0(struct ind_data, 1);\n\n\tdata->callback = callback;\n\tdata->destroy = destroy;\n\tdata->user_data = user_data;\n\n\tput_le16(handle, pdu);\n\tmemcpy(pdu + 2, value, pdu_len - 2);\n\n\tresult = !!bt_att_send(server->att, BT_ATT_OP_HANDLE_IND, pdu,\n\t\t\t\t\t\t\tpdu_len, conf_cb,\n\t\t\t\t\t\t\tdata, destroy_ind_data);\n\tif (!result)\n\t\tdestroy_ind_data(data);\n\n\tfree(pdu);\n\n\treturn result;\n}\n\nbool bt_gatt_server_set_authorize(struct bt_gatt_server *server,\n\t\t\t\t\tbt_gatt_server_authorize_cb_t cb,\n\t\t\t\t\tvoid *user_data)\n{\n\tif (!server)\n\t\treturn false;\n\n\tserver->authorize = cb;\n\tserver->authorize_data = user_data;\n\n\treturn true;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: LGPL-2.1-or-later\n/*\n *\n *  BlueZ - Bluetooth protocol stack for Linux\n *\n *  Copyright (C) 2014  Google Inc.\n *\n *\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <sys/uio.h>\n#include <errno.h>\n\n#include \"src/shared/att.h\"\n#include \"lib/bluetooth.h\"\n#include \"lib/uuid.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/gatt-server.h\"\n#include \"src/shared/gatt-helpers.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/timeout.h\"\n\n#ifndef MAX\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#endif\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n/*\n * TODO: This is an arbitrary limit. Come up with something reasonable or\n * perhaps an API to set this value if there is a use case for it.\n */\n#define DEFAULT_MAX_PREP_QUEUE_LEN 30\n\n#define NFY_MULT_TIMEOUT 10\n\nstruct async_read_op {\n\tstruct bt_att_chan *chan;\n\tstruct bt_gatt_server *server;\n\tuint8_t opcode;\n\tbool done;\n\tuint8_t *pdu;\n\tsize_t pdu_len;\n\tsize_t value_len;\n\tstruct queue *db_data;\n};\n\nstruct async_write_op {\n\tstruct bt_att_chan *chan;\n\tstruct bt_gatt_server *server;\n\tuint8_t opcode;\n};\n\nstruct prep_write_data {\n\tstruct bt_gatt_server *server;\n\tuint8_t *value;\n\tuint16_t handle;\n\tuint16_t offset;\n\tuint16_t length;\n\n\tbool reliable_supported;\n};\n\nstatic void prep_write_data_destroy(void *user_data)\n{\n\tstruct prep_write_data *data = user_data;\n\n\tfree(data->value);\n\tfree(data);\n}\n\nstruct nfy_mult_data {\n\tunsigned int id;\n\tuint8_t *pdu;\n\tuint16_t offset;\n\tuint16_t len;\n};\n\nstruct bt_gatt_server {\n\tstruct gatt_db *db;\n\tstruct bt_att *att;\n\tint ref_count;\n\tuint16_t mtu;\n\n\tunsigned int mtu_id;\n\tunsigned int read_by_grp_type_id;\n\tunsigned int read_by_type_id;\n\tunsigned int find_info_id;\n\tunsigned int find_by_type_value_id;\n\tunsigned int write_id;\n\tunsigned int write_cmd_id;\n\tunsigned int read_id;\n\tunsigned int read_blob_id;\n\tunsigned int read_multiple_id;\n\tunsigned int read_multiple_vl_id;\n\tunsigned int prep_write_id;\n\tunsigned int exec_write_id;\n\n\tuint8_t min_enc_size;\n\n\tstruct queue *prep_queue;\n\tunsigned int max_prep_queue_len;\n\n\tbt_gatt_server_debug_func_t debug_callback;\n\tbt_gatt_server_destroy_func_t debug_destroy;\n\tvoid *debug_data;\n\n\tbt_gatt_server_authorize_cb_t authorize;\n\tvoid *authorize_data;\n\n\tstruct nfy_mult_data *nfy_mult;\n};\n\nstatic void bt_gatt_server_free(struct bt_gatt_server *server)\n{\n\tif (server->debug_destroy)\n\t\tserver->debug_destroy(server->debug_data);\n\n\tbt_att_unregister(server->att, server->mtu_id);\n\tbt_att_unregister(server->att, server->read_by_grp_type_id);\n\tbt_att_unregister(server->att, server->read_by_type_id);\n\tbt_att_unregister(server->att, server->find_info_id);\n\tbt_att_unregister(server->att, server->find_by_type_value_id);\n\tbt_att_unregister(server->att, server->write_id);\n\tbt_att_unregister(server->att, server->write_cmd_id);\n\tbt_att_unregister(server->att, server->read_id);\n\tbt_att_unregister(server->att, server->read_blob_id);\n\tbt_att_unregister(server->att, server->read_multiple_id);\n\tbt_att_unregister(server->att, server->read_multiple_vl_id);\n\tbt_att_unregister(server->att, server->prep_write_id);\n\tbt_att_unregister(server->att, server->exec_write_id);\n\n\tqueue_destroy(server->prep_queue, prep_write_data_destroy);\n\n\tgatt_db_unref(server->db);\n\tbt_att_unref(server->att);\n\tfree(server);\n}\n\nstatic bool get_uuid_le(const uint8_t *uuid, size_t len, bt_uuid_t *out_uuid)\n{\n\tuint128_t u128;\n\n\tswitch (len) {\n\tcase 2:\n\t\tbt_uuid16_create(out_uuid, get_le16(uuid));\n\t\treturn true;\n\tcase 16:\n\t\tbswap_128(uuid, &u128.data);\n\t\tbt_uuid128_create(out_uuid, u128);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic void attribute_read_cb(struct gatt_db_attribute *attrib, int err,\n\t\t\t\t\tconst uint8_t *value, size_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct iovec *iov = user_data;\n\n\tiov->iov_base = (void *) value;\n\tiov->iov_len = length;\n}\n\nstatic bool encode_read_by_grp_type_rsp(struct gatt_db *db, struct queue *q,\n\t\t\t\t\t\tstruct bt_att *att,\n\t\t\t\t\t\tuint16_t mtu, uint8_t *pdu,\n\t\t\t\t\t\tuint16_t *len)\n{\n\tint iter = 0;\n\tuint16_t start_handle, end_handle;\n\tstruct iovec value;\n\tuint8_t data_val_len;\n\n\t*len = 0;\n\n\twhile (queue_peek_head(q)) {\n\t\tstruct gatt_db_attribute *attrib = queue_pop_head(q);\n\n\t\tvalue.iov_base = NULL;\n\t\tvalue.iov_len = 0;\n\n\t\t/*\n\t\t * This should never be deferred to the read callback for\n\t\t * primary/secondary service declarations.\n\t\t */\n\t\tif (!gatt_db_attribute_read(attrib, 0,\n\t\t\t\t\t\tBT_ATT_OP_READ_BY_GRP_TYPE_REQ,\n\t\t\t\t\t\tatt, attribute_read_cb,\n\t\t\t\t\t\t&value) || !value.iov_len)\n\t\t\treturn false;\n\n\t\t/*\n\t\t * Use the first attribute to determine the length of each\n\t\t * attribute data unit. Stop the list when a different attribute\n\t\t * value is seen.\n\t\t */\n\t\tif (iter == 0) {\n\t\t\tdata_val_len = MIN(MIN((unsigned)mtu - 6, 251),\n\t\t\t\t\t\t\t\tvalue.iov_len);\n\t\t\tpdu[0] = data_val_len + 4;\n\t\t\titer++;\n\t\t} else if (value.iov_len != data_val_len)\n\t\t\tbreak;\n\n\t\t/* Stop if this unit would surpass the MTU */\n\t\tif (iter + data_val_len + 4 > mtu - 1)\n\t\t\tbreak;\n\n\t\tgatt_db_attribute_get_service_handles(attrib, &start_handle,\n\t\t\t\t\t\t\t\t&end_handle);\n\n\t\tput_le16(start_handle, pdu + iter);\n\t\tput_le16(end_handle, pdu + iter + 2);\n\t\tmemcpy(pdu + iter + 4, value.iov_base, data_val_len);\n\n\t\titer += data_val_len + 4;\n\t}\n\n\t*len = iter;\n\n\treturn true;\n}\n\nstatic void read_by_grp_type_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t start, end;\n\tbt_uuid_t type;\n\tbt_uuid_t prim, snd;\n\tuint16_t mtu = bt_att_get_mtu(server->att);\n\tuint8_t rsp_pdu[mtu];\n\tuint16_t rsp_len;\n\tuint8_t ecode = 0;\n\tuint16_t ehandle = 0;\n\tstruct queue *q = NULL;\n\n\tif (length != 6 && length != 20) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tq = queue_new();\n\n\tstart = get_le16(pdu);\n\tend = get_le16(pdu + 2);\n\tget_uuid_le(pdu + 4, length - 4, &type);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Read By Grp Type - start: 0x%04x end: 0x%04x\",\n\t\t\t\tstart, end);\n\n\tif (!start || !end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tehandle = start;\n\n\tif (start > end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\t/*\n\t * GATT defines that only the <<Primary Service>> and\n\t * <<Secondary Service>> group types can be used for the\n\t * \"Read By Group Type\" request (Core v4.1, Vol 3, sec 2.5.3). Return an\n\t * error if any other group type is given.\n\t */\n\tbt_uuid16_create(&prim, GATT_PRIM_SVC_UUID);\n\tbt_uuid16_create(&snd, GATT_SND_SVC_UUID);\n\tif (bt_uuid_cmp(&type, &prim) && bt_uuid_cmp(&type, &snd)) {\n\t\tecode = BT_ATT_ERROR_UNSUPPORTED_GROUP_TYPE;\n\t\tgoto error;\n\t}\n\n\tgatt_db_read_by_group_type(server->db, start, end, type, q);\n\n\tif (queue_isempty(q)) {\n\t\tecode = BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND;\n\t\tgoto error;\n\t}\n\n\tif (!encode_read_by_grp_type_rsp(server->db, q, server->att, mtu,\n\t\t\t\t\t\t\trsp_pdu, &rsp_len)) {\n\t\tecode = BT_ATT_ERROR_UNLIKELY;\n\t\tgoto error;\n\t}\n\n\tqueue_destroy(q, NULL);\n\n\tbt_att_chan_send_rsp(chan, BT_ATT_OP_READ_BY_GRP_TYPE_RSP,\n\t\t\t\t\t\trsp_pdu, rsp_len);\n\n\treturn;\n\nerror:\n\tqueue_destroy(q, NULL);\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, ecode);\n}\n\nstatic void async_read_op_destroy(struct async_read_op *op)\n{\n\tbt_gatt_server_unref(op->server);\n\tqueue_destroy(op->db_data, NULL);\n\tfree(op->pdu);\n\tfree(op);\n}\n\nstatic void process_read_by_type(struct async_read_op *op);\n\nstatic void read_by_type_read_complete_cb(struct gatt_db_attribute *attr,\n\t\t\t\t\t\tint err, const uint8_t *value,\n\t\t\t\t\t\tsize_t len, void *user_data)\n{\n\tstruct async_read_op *op = user_data;\n\tstruct bt_gatt_server *server = op->server;\n\tuint16_t mtu;\n\tuint16_t handle;\n\n\tmtu = bt_att_get_mtu(server->att);\n\thandle = gatt_db_attribute_get_handle(attr);\n\n\t/* Terminate the operation if there was an error */\n\tif (err) {\n\t\tbt_att_chan_send_error_rsp(op->chan, BT_ATT_OP_READ_BY_TYPE_REQ,\n\t\t\t\t\t\t\t\thandle, err);\n\t\tasync_read_op_destroy(op);\n\t\treturn;\n\t}\n\n\tif (op->pdu_len == 0) {\n\t\top->value_len = MIN(MIN((unsigned) mtu - 4, 253), len);\n\t\top->pdu[0] = op->value_len + 2;\n\t\top->pdu_len++;\n\t} else if (len != op->value_len) {\n\t\top->done = true;\n\t\tgoto done;\n\t}\n\n\t/* Stop if this would surpass the MTU */\n\tif (op->pdu_len + op->value_len + 2 > (unsigned) mtu - 1) {\n\t\top->done = true;\n\t\tgoto done;\n\t}\n\n\t/* Encode the current value */\n\tput_le16(handle, op->pdu + op->pdu_len);\n\tmemcpy(op->pdu + op->pdu_len + 2, value, op->value_len);\n\n\top->pdu_len += op->value_len + 2;\n\n\tif (op->pdu_len == (unsigned) mtu - 1)\n\t\top->done = true;\n\ndone:\n\tprocess_read_by_type(op);\n}\n\nstatic bool check_min_key_size(uint8_t min_size, uint8_t size)\n{\n\tif (!min_size || !size)\n\t\treturn true;\n\n\treturn min_size <= size;\n}\n\nstatic uint8_t check_permissions(struct bt_gatt_server *server,\n\t\t\t\tstruct gatt_db_attribute *attr, uint32_t mask)\n{\n\tuint8_t enc_size;\n\tuint32_t perm;\n\tint security;\n\n\tperm = gatt_db_attribute_get_permissions(attr);\n\n\tif (perm && mask & BT_ATT_PERM_READ && !(perm & BT_ATT_PERM_READ))\n\t\treturn BT_ATT_ERROR_READ_NOT_PERMITTED;\n\n\tif (perm && mask & BT_ATT_PERM_WRITE && !(perm & BT_ATT_PERM_WRITE))\n\t\treturn BT_ATT_ERROR_WRITE_NOT_PERMITTED;\n\n\tperm &= mask;\n\tif (!perm)\n\t\treturn 0;\n\n\tsecurity = bt_att_get_security(server->att, &enc_size);\n\tif (security < 0)\n\t\treturn BT_ATT_ERROR_UNLIKELY;\n\n\tif (perm & BT_ATT_PERM_SECURE) {\n\t\tif (security < BT_ATT_SECURITY_FIPS)\n\t\t\treturn BT_ATT_ERROR_AUTHENTICATION;\n\n\t\tif (!check_min_key_size(server->min_enc_size, enc_size))\n\t\t\treturn BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE;\n\t}\n\n\tif (perm & BT_ATT_PERM_AUTHEN) {\n\t\tif (security < BT_ATT_SECURITY_HIGH)\n\t\t\treturn BT_ATT_ERROR_AUTHENTICATION;\n\n\t\tif (!check_min_key_size(server->min_enc_size, enc_size))\n\t\t\treturn BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE;\n\t}\n\n\tif (perm & BT_ATT_PERM_ENCRYPT) {\n\t\tif (security < BT_ATT_SECURITY_MEDIUM)\n\t\t\treturn BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION;\n\n\t\tif (!check_min_key_size(server->min_enc_size, enc_size))\n\t\t\treturn BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic void process_read_by_type(struct async_read_op *op)\n{\n\tstruct bt_gatt_server *server = op->server;\n\tuint8_t ecode;\n\tstruct gatt_db_attribute *attr;\n\n\tattr = queue_pop_head(op->db_data);\n\n\tif (op->done || !attr) {\n\t\tbt_att_chan_send_rsp(op->chan, BT_ATT_OP_READ_BY_TYPE_RSP,\n\t\t\t\t\t\top->pdu, op->pdu_len);\n\t\tasync_read_op_destroy(op);\n\t\treturn;\n\t}\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_READ_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tif (gatt_db_attribute_read(attr, 0, op->opcode, server->att,\n\t\t\t\t\tread_by_type_read_complete_cb, op))\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tbt_att_chan_send_error_rsp(op->chan, BT_ATT_OP_READ_BY_TYPE_REQ,\n\t\t\t\tgatt_db_attribute_get_handle(attr), ecode);\n\tasync_read_op_destroy(op);\n}\n\nstatic void read_by_type_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t start, end;\n\tbt_uuid_t type;\n\tuint16_t ehandle = 0;\n\tuint8_t ecode;\n\tstruct queue *q = NULL;\n\tstruct async_read_op *op;\n\n\tif (length != 6 && length != 20) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tq = queue_new();\n\n\tstart = get_le16(pdu);\n\tend = get_le16(pdu + 2);\n\tget_uuid_le(pdu + 4, length - 4, &type);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Read By Type - start: 0x%04x end: 0x%04x\",\n\t\t\t\tstart, end);\n\n\tif (!start || !end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tehandle = start;\n\n\tif (start > end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tgatt_db_read_by_type(server->db, start, end, type, q);\n\n\tif (queue_isempty(q)) {\n\t\tecode = BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND;\n\t\tgoto error;\n\t}\n\n\top = new0(struct async_read_op, 1);\n\top->pdu = malloc(bt_att_get_mtu(server->att));\n\tif (!op->pdu) {\n\t\tfree(op);\n\t\tecode = BT_ATT_ERROR_INSUFFICIENT_RESOURCES;\n\t\tgoto error;\n\t}\n\n\top->chan = chan;\n\top->opcode = opcode;\n\top->server = bt_gatt_server_ref(server);\n\top->db_data = q;\n\n\tprocess_read_by_type(op);\n\n\treturn;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, ecode);\n\tqueue_destroy(q, NULL);\n}\n\nstatic bool encode_find_info_rsp(struct gatt_db *db, struct queue *q,\n\t\t\t\t\t\tuint16_t mtu,\n\t\t\t\t\t\tuint8_t *pdu, uint16_t *len)\n{\n\tuint16_t handle;\n\tstruct gatt_db_attribute *attr;\n\tconst bt_uuid_t *type;\n\tint uuid_len, cur_uuid_len;\n\tint iter = 0;\n\n\t*len = 0;\n\n\twhile (queue_peek_head(q)) {\n\t\tattr = queue_pop_head(q);\n\t\thandle = gatt_db_attribute_get_handle(attr);\n\t\ttype = gatt_db_attribute_get_type(attr);\n\t\tif (!handle || !type)\n\t\t\treturn false;\n\n\t\tcur_uuid_len = bt_uuid_len(type);\n\n\t\tif (iter == 0) {\n\t\t\tswitch (cur_uuid_len) {\n\t\t\tcase 2:\n\t\t\t\tuuid_len = 2;\n\t\t\t\tpdu[0] = 0x01;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tcase 16:\n\t\t\t\tuuid_len = 16;\n\t\t\t\tpdu[0] = 0x02;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\titer++;\n\t\t} else if (cur_uuid_len != uuid_len)\n\t\t\tbreak;\n\n\t\tif (iter + uuid_len + 2 > mtu - 1)\n\t\t\tbreak;\n\n\t\tput_le16(handle, pdu + iter);\n\t\tbt_uuid_to_le(type, pdu + iter + 2);\n\n\t\titer += uuid_len + 2;\n\t}\n\n\t*len = iter;\n\n\treturn true;\n}\n\nstatic void find_info_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t start, end;\n\tuint16_t mtu = bt_att_get_mtu(server->att);\n\tuint8_t rsp_pdu[mtu];\n\tuint16_t rsp_len;\n\tuint8_t ecode = 0;\n\tuint16_t ehandle = 0;\n\tstruct queue *q = NULL;\n\n\tif (length != 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tq = queue_new();\n\n\tstart = get_le16(pdu);\n\tend = get_le16(pdu + 2);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\t\"Find Info - start: 0x%04x end: 0x%04x\",\n\t\t\t\t\tstart, end);\n\n\tif (!start || !end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tehandle = start;\n\n\tif (start > end) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tgatt_db_find_information(server->db, start, end, q);\n\n\tif (queue_isempty(q)) {\n\t\tecode = BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND;\n\t\tgoto error;\n\t}\n\n\tif (!encode_find_info_rsp(server->db, q, mtu, rsp_pdu, &rsp_len)) {\n\t\tecode = BT_ATT_ERROR_UNLIKELY;\n\t\tgoto error;\n\t}\n\n\tbt_att_chan_send_rsp(chan, BT_ATT_OP_FIND_INFO_RSP, rsp_pdu, rsp_len);\n\n\tqueue_destroy(q, NULL);\n\n\treturn;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, ecode);\n\tqueue_destroy(q, NULL);\n\n}\n\nstruct find_by_type_val_data {\n\tuint8_t *pdu;\n\tuint16_t len;\n\tuint16_t mtu;\n\tuint8_t ecode;\n};\n\nstatic void find_by_type_val_att_cb(struct gatt_db_attribute *attrib,\n\t\t\t\t\t\t\t\tvoid *user_data)\n{\n\tuint16_t handle, end_handle;\n\tstruct find_by_type_val_data *data = user_data;\n\n\tif (data->ecode)\n\t\treturn;\n\n\tif (data->len + 4 > data->mtu - 1)\n\t\treturn;\n\n\t/*\n\t * This OP is only valid for Primary Service per the spec\n\t * page 562, so this should work.\n\t */\n\tgatt_db_attribute_get_service_data(attrib, &handle, &end_handle, NULL,\n\t\t\t\t\t\t\t\t\tNULL);\n\n\tif (!handle || !end_handle) {\n\t\tdata->ecode = BT_ATT_ERROR_UNLIKELY;\n\t\treturn;\n\t}\n\n\tput_le16(handle, data->pdu + data->len);\n\tput_le16(end_handle, data->pdu + data->len + 2);\n\n\tdata->len += 4;\n}\n\nstatic void find_by_type_val_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t start, end, uuid16;\n\tstruct find_by_type_val_data data;\n\tuint16_t mtu = bt_att_get_mtu(server->att);\n\tuint8_t rsp_pdu[mtu];\n\tuint16_t ehandle = 0;\n\tbt_uuid_t uuid;\n\n\tif (length < 6) {\n\t\tdata.ecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tdata.pdu = rsp_pdu;\n\tdata.len = 0;\n\tdata.mtu = mtu;\n\tdata.ecode = 0;\n\n\tstart = get_le16(pdu);\n\tend = get_le16(pdu + 2);\n\tuuid16 = get_le16(pdu + 4);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\"Find By Type Value - start: 0x%04x end: 0x%04x uuid: 0x%04x\",\n\t\t\tstart, end, uuid16);\n\tehandle = start;\n\tif (start > end) {\n\t\tdata.ecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tbt_uuid16_create(&uuid, uuid16);\n\tgatt_db_find_by_type_value(server->db, start, end, &uuid, pdu + 6,\n\t\t\t\t\t\t\tlength - 6,\n\t\t\t\t\t\t\tfind_by_type_val_att_cb,\n\t\t\t\t\t\t\t&data);\n\n\tif (!data.len)\n\t\tdata.ecode = BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND;\n\n\tif (data.ecode)\n\t\tgoto error;\n\n\tbt_att_chan_send_rsp(chan, BT_ATT_OP_FIND_BY_TYPE_RSP,\n\t\t\t\t\tdata.pdu, data.len);\n\n\treturn;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, data.ecode);\n}\n\nstatic void async_write_op_destroy(struct async_write_op *op)\n{\n\tbt_gatt_server_unref(op->server);\n\tfree(op);\n}\n\nstatic void write_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct async_write_op *op = user_data;\n\tstruct bt_gatt_server *server = op->server;\n\tuint16_t handle;\n\n\tif (op->opcode == BT_ATT_OP_WRITE_CMD) {\n\t\tasync_write_op_destroy(op);\n\t\treturn;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\t\t\"Write Complete: err %d\", err);\n\n\thandle = gatt_db_attribute_get_handle(attr);\n\n\tif (err)\n\t\tbt_att_chan_send_error_rsp(op->chan, op->opcode, handle, err);\n\telse\n\t\tbt_att_chan_send_rsp(op->chan, BT_ATT_OP_WRITE_RSP, NULL, 0);\n\n\tasync_write_op_destroy(op);\n}\n\nstatic uint8_t authorize_req(struct bt_gatt_server *server,\n\t\t\t\t\tuint8_t opcode, uint16_t handle)\n{\n\tif (!server->authorize)\n\t\treturn 0;\n\n\treturn server->authorize(server->att, opcode, handle,\n\t\t\t\t\t\tserver->authorize_data);\n}\n\nstatic uint8_t check_length(uint16_t length, uint16_t offset)\n{\n\tif (length > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\n\tif (offset > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_OFFSET;\n\n\tif (length + offset > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\n\treturn 0;\n}\n\nstatic void write_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct gatt_db_attribute *attr;\n\tuint16_t handle = 0;\n\tstruct async_write_op *op = NULL;\n\tuint8_t ecode;\n\n\tif (length < 2) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tecode = authorize_req(server, opcode, handle);\n\tif (ecode)\n\t\tgoto error;\n\n\thandle = get_le16(pdu);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Write %s - handle: 0x%04x\",\n\t\t\t\t(opcode == BT_ATT_OP_WRITE_REQ) ? \"Req\" : \"Cmd\",\n\t\t\t\thandle);\n\n\tecode = check_length(length, 0);\n\tif (ecode)\n\t\tgoto error;\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\top = new0(struct async_write_op, 1);\n\top->chan = chan;\n\top->server = bt_gatt_server_ref(server);\n\top->opcode = opcode;\n\n\tif (gatt_db_attribute_write(attr, 0, pdu + 2, length - 2, opcode,\n\t\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\t\twrite_complete_cb, op))\n\t\treturn;\n\n\tasync_write_op_destroy(op);\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tif (opcode == BT_ATT_OP_WRITE_CMD)\n\t\treturn;\n\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n\nstatic uint8_t get_read_rsp_opcode(uint8_t opcode)\n{\n\n\tswitch (opcode) {\n\tcase BT_ATT_OP_READ_REQ:\n\t\treturn BT_ATT_OP_READ_RSP;\n\tcase BT_ATT_OP_READ_BLOB_REQ:\n\t\treturn BT_ATT_OP_READ_BLOB_RSP;\n\tdefault:\n\t\t/*\n\t\t * Should never happen\n\t\t *\n\t\t * TODO: It would be nice to have a debug-mode assert macro\n\t\t * for development builds. This way bugs could be easily catched\n\t\t * during development and there would be self documenting code\n\t\t * that wouldn't be crash release builds.\n\t\t */\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void read_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\tconst uint8_t *value, size_t len,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct async_read_op *op = user_data;\n\tstruct bt_gatt_server *server = op->server;\n\tuint8_t rsp_opcode;\n\tuint16_t mtu;\n\tuint16_t handle;\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Read Complete: err %d\", err);\n\n\tmtu = bt_att_get_mtu(server->att);\n\thandle = gatt_db_attribute_get_handle(attr);\n\n\tif (err) {\n\t\tbt_att_chan_send_error_rsp(op->chan, op->opcode, handle, err);\n\t\tasync_read_op_destroy(op);\n\t\treturn;\n\t}\n\n\trsp_opcode = get_read_rsp_opcode(op->opcode);\n\n\tbt_att_chan_send_rsp(op->chan, rsp_opcode, len ? value : NULL,\n\t\t\t\t\tMIN((unsigned int) mtu - 1, len));\n\tasync_read_op_destroy(op);\n}\n\nstatic void handle_read_req(struct bt_att_chan *chan,\n\t\t\t\tstruct bt_gatt_server *server, uint8_t opcode,\n\t\t\t\tuint16_t handle, uint16_t offset)\n{\n\tstruct gatt_db_attribute *attr;\n\tuint8_t ecode;\n\tstruct async_read_op *op = NULL;\n\n\tecode = authorize_req(server, opcode, handle);\n\tif (ecode)\n\t\tgoto error;\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\"Read %sReq - handle: 0x%04x\",\n\t\t\topcode == BT_ATT_OP_READ_BLOB_REQ ? \"Blob \" : \"\",\n\t\t\thandle);\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_READ_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\top = new0(struct async_read_op, 1);\n\top->chan = chan;\n\top->opcode = opcode;\n\top->server = bt_gatt_server_ref(server);\n\n\tif (gatt_db_attribute_read(attr, offset, opcode, server->att,\n\t\t\t\t\t\t\tread_complete_cb, op))\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tif (op)\n\t\tasync_read_op_destroy(op);\n\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n\nstatic void read_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle;\n\n\tif (length != 2) {\n\t\tbt_att_chan_send_error_rsp(chan, opcode, 0,\n\t\t\t\t\t\tBT_ATT_ERROR_INVALID_PDU);\n\t\treturn;\n\t}\n\n\thandle = get_le16(pdu);\n\n\thandle_read_req(chan, server, opcode, handle, 0);\n}\n\nstatic void read_blob_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle, offset;\n\n\tif (length != 4) {\n\t\tbt_att_chan_send_error_rsp(chan, opcode, 0,\n\t\t\t\t\t\tBT_ATT_ERROR_INVALID_PDU);\n\t\treturn;\n\t}\n\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\n\thandle_read_req(chan, server, opcode, handle, offset);\n}\n\nstruct read_mult_data {\n\tstruct bt_att_chan *chan;\n\tstruct bt_gatt_server *server;\n\tuint8_t opcode;\n\tuint16_t *handles;\n\tsize_t cur_handle;\n\tsize_t num_handles;\n\tuint8_t *rsp_data;\n\tsize_t length;\n\tsize_t mtu;\n};\n\nstatic void read_mult_data_free(struct read_mult_data *data)\n{\n\tfree(data->handles);\n\tfree(data->rsp_data);\n\tfree(data);\n}\n\nstatic void read_multiple_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\tconst uint8_t *value, size_t len,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct read_mult_data *data = user_data;\n\tstruct gatt_db_attribute *next_attr;\n\tuint16_t handle = gatt_db_attribute_get_handle(attr);\n\tuint8_t ecode;\n\tuint16_t length;\n\n\tif (err != 0) {\n\t\tecode = err;\n\t\tgoto error;\n\t}\n\n\tlength = data->opcode == BT_ATT_OP_READ_MULT_VL_REQ ?\n\t\t\tMIN(len, MAX(data->mtu - data->length, 3) - 3) :\n\t\t\tMIN(len, data->mtu - data->length - 1);\n\n\tif (data->opcode == BT_ATT_OP_READ_MULT_VL_REQ) {\n\t\t/* The Length Value Tuple List may be truncated within the first\n\t\t * two octets of a tuple due to the size limits of the current\n\t\t * ATT_MTU, but the first two octets cannot be separated.\n\t\t */\n\t\tif (data->mtu - data->length >= 3) {\n\t\t\tput_le16(len, data->rsp_data + data->length);\n\t\t\tdata->length += 2;\n\t\t}\n\t}\n\n\tmemcpy(data->rsp_data + data->length, value, length);\n\tdata->length += length;\n\n\tdata->cur_handle++;\n\n\tif (data->cur_handle == data->num_handles) {\n\t\tbt_att_chan_send_rsp(data->chan, data->opcode + 1,\n\t\t\t\t\t\tdata->rsp_data, data->length);\n\t\tread_mult_data_free(data);\n\t\treturn;\n\t}\n\n\thandle = data->handles[data->cur_handle];\n\n\tutil_debug(data->server->debug_callback, data->server->debug_data,\n\t\t\t\t\"%s Req - #%zu of %zu: 0x%04x\",\n\t\t\t\tdata->opcode == BT_ATT_OP_READ_MULT_REQ ?\n\t\t\t\t\"Read Multiple\" :\n\t\t\t\t\"Read Multiple Variable Length\",\n\t\t\t\tdata->cur_handle + 1, data->num_handles,\n\t\t\t\thandle);\n\n\tnext_attr = gatt_db_get_attribute(data->server->db, handle);\n\n\tif (!next_attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tecode = check_permissions(data->server, next_attr,\n\t\t\t\t\t\tBT_ATT_PERM_READ_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tif (gatt_db_attribute_read(next_attr, 0, data->opcode,\n\t\t\t\t\tdata->server->att,\n\t\t\t\t\tread_multiple_complete_cb, data))\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tbt_att_chan_send_error_rsp(data->chan, data->opcode, handle, ecode);\n\tread_mult_data_free(data);\n}\n\nstatic struct read_mult_data *read_mult_data_new(struct bt_gatt_server *server,\n\t\t\t\t\t\tstruct bt_att_chan *chan,\n\t\t\t\t\t\tuint8_t opcode,\n\t\t\t\t\t\tuint16_t num_handles)\n{\n\tstruct read_mult_data *data;\n\n\tdata = new0(struct read_mult_data, 1);\n\tdata->chan = chan;\n\tdata->opcode = opcode;\n\tdata->handles = new0(uint16_t, num_handles);\n\tdata->rsp_data = NULL;\n\tdata->server = server;\n\tdata->num_handles = num_handles;\n\tdata->cur_handle = 0;\n\tdata->mtu = bt_att_get_mtu(server->att);\n\tdata->length = 0;\n\tdata->rsp_data = new0(uint8_t, data->mtu - 1);\n\n\treturn data;\n}\n\nstatic void read_multiple_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct gatt_db_attribute *attr;\n\tstruct read_mult_data *data = NULL;\n\tuint8_t ecode;\n\tsize_t i = 0;\n\tuint16_t handle = 0;\n\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tdata = read_mult_data_new(server, chan, opcode, length / 2);\n\tif (!data)\n\t\tgoto error;\n\n\tfor (i = 0; i < data->num_handles; i++)\n\t\tdata->handles[i] = get_le16(pdu + i * 2);\n\n\thandle = data->handles[0];\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\"%s Req - %zu handles, 1st: 0x%04x\",\n\t\t\tdata->opcode == BT_ATT_OP_READ_MULT_REQ ?\n\t\t\t\"Read Multiple\" : \"Read Multiple Variable Length\",\n\t\t\tdata->num_handles, handle);\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tecode = check_permissions(data->server, attr, BT_ATT_PERM_READ_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tif (gatt_db_attribute_read(attr, 0, opcode, server->att,\n\t\t\t\t\tread_multiple_complete_cb, data))\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tif (data)\n\t\tread_mult_data_free(data);\n\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n\nstatic bool append_prep_data(struct prep_write_data *prep_data, uint16_t handle,\n\t\t\t\t\tuint16_t length, uint8_t *value)\n{\n\tuint8_t *val;\n\tuint16_t len;\n\n\tif (!length)\n\t\treturn true;\n\n\tlen = prep_data->length + length;\n\n\tval = realloc(prep_data->value, len);\n\tif (!val)\n\t\treturn false;\n\n\tmemcpy(val + prep_data->length, value, length);\n\n\tprep_data->value = val;\n\tprep_data->length = len;\n\n\treturn true;\n}\n\nstatic bool is_reliable_write_supported(const struct bt_gatt_server  *server,\n\t\t\t\t\t\t\tuint16_t handle)\n{\n\tstruct gatt_db_attribute *attr;\n\tuint16_t ext_prop;\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr)\n\t\treturn false;\n\n\tif (!gatt_db_attribute_get_char_data(attr, NULL, NULL, NULL, &ext_prop,\n\t\t\t\t\t\t\t\t\tNULL))\n\t\treturn false;\n\n\treturn (ext_prop & BT_GATT_CHRC_EXT_PROP_RELIABLE_WRITE);\n}\n\nstatic bool prep_data_new(struct bt_gatt_server *server,\n\t\t\t\t\tuint16_t handle, uint16_t offset,\n\t\t\t\t\tuint16_t length, uint8_t *value)\n{\n\tstruct prep_write_data *prep_data;\n\n\tprep_data = new0(struct prep_write_data, 1);\n\n\tif (!append_prep_data(prep_data, handle, length, value)) {\n\t\tprep_write_data_destroy(prep_data);\n\t\treturn false;\n\t}\n\n\tprep_data->server = server;\n\tprep_data->handle = handle;\n\tprep_data->offset = offset;\n\n\t/*\n\t * Handle is the value handle. We need characteristic declaration\n\t * handle which in BlueZ is handle_value -1\n\t */\n\tprep_data->reliable_supported = is_reliable_write_supported(server,\n\t\t\t\t\t\t\t\thandle - 1);\n\n\tqueue_push_tail(server->prep_queue, prep_data);\n\n\treturn true;\n}\n\nstatic bool store_prep_data(struct bt_gatt_server *server,\n\t\t\t\t\tuint16_t handle, uint16_t offset,\n\t\t\t\t\tuint16_t length, uint8_t *value)\n{\n\tstruct prep_write_data *prep_data = NULL;\n\n\t/*\n\t * Now lets check if prep write is a continuation of long write\n\t * If so do aggregation of data\n\t */\n\tprep_data = queue_peek_tail(server->prep_queue);\n\tif (prep_data && (prep_data->handle == handle) &&\n\t\t\t(offset == (prep_data->length + prep_data->offset)))\n\t\treturn append_prep_data(prep_data, handle, length, value);\n\n\treturn prep_data_new(server, handle, offset, length, value);\n}\n\nstruct prep_write_complete_data {\n\tstruct bt_att_chan *chan;\n\tvoid *pdu;\n\tuint16_t length;\n\tstruct bt_gatt_server *server;\n};\n\nstatic void prep_write_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct prep_write_complete_data *pwcd = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\n\thandle = get_le16(pwcd->pdu);\n\n\tif (err) {\n\t\tbt_att_chan_send_error_rsp(pwcd->chan, BT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\t\t\thandle, err);\n\t\tfree(pwcd->pdu);\n\t\tfree(pwcd);\n\n\t\treturn;\n\t}\n\n\toffset = get_le16(pwcd->pdu + 2);\n\n\tif (!store_prep_data(pwcd->server, handle, offset, pwcd->length - 4,\n\t\t\t\t\t\t&((uint8_t *) pwcd->pdu)[4]))\n\t\tbt_att_chan_send_error_rsp(pwcd->chan, BT_ATT_OP_PREP_WRITE_RSP,\n\t\t\t\t\thandle,\n\t\t\t\t\tBT_ATT_ERROR_INSUFFICIENT_RESOURCES);\n\n\tbt_att_chan_send_rsp(pwcd->chan, BT_ATT_OP_PREP_WRITE_RSP, pwcd->pdu,\n\t\t\t\t\t\t\t\tpwcd->length);\n\n\tfree(pwcd->pdu);\n\tfree(pwcd);\n}\n\nstatic void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\tstruct gatt_db_attribute *attr;\n\tstruct prep_write_complete_data *pwcd;\n\tuint8_t ecode, status;\n\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tif (queue_length(server->prep_queue) >= server->max_prep_queue_len) {\n\t\tecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;\n\t\tgoto error;\n\t}\n\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Prep Write Req - handle: 0x%04x\", handle);\n\n\tecode = check_length(length, offset);\n\tif (ecode)\n\t\tgoto error;\n\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\n\tpwcd = new0(struct prep_write_complete_data, 1);\n\tpwcd->chan = chan;\n\tpwcd->pdu = malloc(length);\n\tmemcpy(pwcd->pdu, pdu, length);\n\tpwcd->length = length;\n\tpwcd->server = server;\n\n\tstatus = gatt_db_attribute_write(attr, offset, NULL, 0,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\tprep_write_complete_cb, pwcd);\n\n\tif (status)\n\t\treturn;\n\n\tecode = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}\n\nstruct exec_data {\n\tstruct bt_att_chan *chan;\n\tstruct bt_gatt_server *server;\n};\n\nstatic void exec_next_prep_write(struct exec_data *data, uint16_t ehandle,\n\t\t\t\t\t\t\t\tint err);\n\nstatic void exec_write_complete_cb(struct gatt_db_attribute *attr, int err,\n\t\t\t\t\t\t\t\tvoid *user_data)\n{\n\tstruct exec_data *data = user_data;\n\tuint16_t handle = gatt_db_attribute_get_handle(attr);\n\n\texec_next_prep_write(data, handle, err);\n}\n\nstatic void exec_next_prep_write(struct exec_data *data, uint16_t ehandle,\n\t\t\t\t\t\t\t\tint err)\n{\n\tstruct prep_write_data *next = NULL;\n\tstruct gatt_db_attribute *attr;\n\tbool status;\n\n\tif (err)\n\t\tgoto error;\n\n\tnext = queue_pop_head(data->server->prep_queue);\n\tif (!next) {\n\t\tbt_att_chan_send_rsp(data->chan, BT_ATT_OP_EXEC_WRITE_RSP,\n\t\t\t\t\t\t\t\tNULL, 0);\n\t\tfree(data);\n\t\treturn;\n\t}\n\n\tattr = gatt_db_get_attribute(data->server->db, next->handle);\n\tif (!attr) {\n\t\terr = BT_ATT_ERROR_UNLIKELY;\n\t\tgoto error;\n\t}\n\n\tstatus = gatt_db_attribute_write(attr, next->offset,\n\t\t\t\t\t\tnext->value, next->length,\n\t\t\t\t\t\tBT_ATT_OP_EXEC_WRITE_REQ,\n\t\t\t\t\t\tdata->server->att,\n\t\t\t\t\t\texec_write_complete_cb, data);\n\n\tprep_write_data_destroy(next);\n\n\tif (status)\n\t\treturn;\n\n\terr = BT_ATT_ERROR_UNLIKELY;\n\nerror:\n\tqueue_remove_all(data->server->prep_queue, NULL, NULL,\n\t\t\t\t\t\tprep_write_data_destroy);\n\n\tbt_att_chan_send_error_rsp(data->chan, BT_ATT_OP_EXEC_WRITE_REQ,\n\t\t\t\t\t\t\t\tehandle, err);\n\tfree(data);\n}\n\nstatic bool find_no_reliable_characteristic(const void *data,\n\t\t\t\t\t\tconst void *match_data)\n{\n\tconst struct prep_write_data *prep_data = data;\n\n\treturn !prep_data->reliable_supported;\n}\n\nstatic void exec_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct exec_data *data;\n\tuint8_t flags;\n\tuint8_t ecode;\n\tbool write;\n\tuint16_t ehandle = 0;\n\n\tif (length != 1) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tflags = ((uint8_t *) pdu)[0];\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Exec Write Req - flags: 0x%02x\", flags);\n\n\tif (flags == 0x00)\n\t\twrite = false;\n\telse if (flags == 0x01)\n\t\twrite = true;\n\telse {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\n\tif (!write) {\n\t\tqueue_remove_all(server->prep_queue, NULL, NULL,\n\t\t\t\t\t\tprep_write_data_destroy);\n\t\tbt_att_chan_send_rsp(chan, BT_ATT_OP_EXEC_WRITE_RSP, NULL, 0);\n\t\treturn;\n\t}\n\n\t/* If there is more than one prep request, we are in reliable session */\n\tif (queue_length(server->prep_queue) > 1) {\n\t\tstruct prep_write_data *prep_data;\n\n\t\tprep_data = queue_find(server->prep_queue,\n\t\t\t\t\tfind_no_reliable_characteristic, NULL);\n\t\tif (prep_data) {\n\t\t\tecode = BT_ATT_ERROR_REQUEST_NOT_SUPPORTED;\n\t\t\tehandle = prep_data->handle;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdata = new0(struct exec_data, 1);\n\tdata->chan = chan;\n\tdata->server = server;\n\n\texec_next_prep_write(data, 0, 0);\n\n\treturn;\n\nerror:\n\tqueue_remove_all(server->prep_queue, NULL, NULL,\n\t\t\t\t\t\tprep_write_data_destroy);\n\tbt_att_chan_send_error_rsp(chan, opcode, ehandle, ecode);\n}\n\nstatic void exchange_mtu_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t client_rx_mtu;\n\tuint16_t final_mtu;\n\tuint8_t rsp_pdu[2];\n\n\tif (length != 2) {\n\t\tbt_att_chan_send_error_rsp(chan, opcode, 0,\n\t\t\t\t\t\tBT_ATT_ERROR_INVALID_PDU);\n\t\treturn;\n\t}\n\n\tclient_rx_mtu = get_le16(pdu);\n\tfinal_mtu = MAX(MIN(client_rx_mtu, server->mtu), BT_ATT_DEFAULT_LE_MTU);\n\n\t/* Respond with the server MTU */\n\tput_le16(server->mtu, rsp_pdu);\n\tbt_att_chan_send_rsp(chan, BT_ATT_OP_MTU_RSP, rsp_pdu, 2);\n\n\t/* Set MTU to be the minimum */\n\tserver->mtu = final_mtu;\n\tbt_att_set_mtu(server->att, final_mtu);\n\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\"MTU exchange complete, with MTU: %u\", final_mtu);\n}\n\nstatic bool gatt_server_register_att_handlers(struct bt_gatt_server *server)\n{\n\t/* Exchange MTU */\n\tserver->mtu_id = bt_att_register(server->att, BT_ATT_OP_MTU_REQ,\n\t\t\t\t\t\t\t\texchange_mtu_cb,\n\t\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->mtu_id)\n\t\treturn false;\n\n\t/* Read By Group Type */\n\tserver->read_by_grp_type_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_READ_BY_GRP_TYPE_REQ,\n\t\t\t\t\t\tread_by_grp_type_cb,\n\t\t\t\t\t\tserver, NULL);\n\tif (!server->read_by_grp_type_id)\n\t\treturn false;\n\n\t/* Read By Type */\n\tserver->read_by_type_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_READ_BY_TYPE_REQ,\n\t\t\t\t\t\tread_by_type_cb,\n\t\t\t\t\t\tserver, NULL);\n\tif (!server->read_by_type_id)\n\t\treturn false;\n\n\t/* Find Information */\n\tserver->find_info_id = bt_att_register(server->att,\n\t\t\t\t\t\t\tBT_ATT_OP_FIND_INFO_REQ,\n\t\t\t\t\t\t\tfind_info_cb,\n\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->find_info_id)\n\t\treturn false;\n\n\t/* Find By Type Value */\n\tserver->find_by_type_value_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_FIND_BY_TYPE_REQ,\n\t\t\t\t\t\tfind_by_type_val_cb,\n\t\t\t\t\t\tserver, NULL);\n\n\tif (!server->find_by_type_value_id)\n\t\treturn false;\n\n\t/* Write Request */\n\tserver->write_id = bt_att_register(server->att, BT_ATT_OP_WRITE_REQ,\n\t\t\t\t\t\t\t\twrite_cb,\n\t\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->write_id)\n\t\treturn false;\n\n\t/* Write Command */\n\tserver->write_cmd_id = bt_att_register(server->att, BT_ATT_OP_WRITE_CMD,\n\t\t\t\t\t\t\t\twrite_cb,\n\t\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->write_cmd_id)\n\t\treturn false;\n\n\t/* Read Request */\n\tserver->read_id = bt_att_register(server->att, BT_ATT_OP_READ_REQ,\n\t\t\t\t\t\t\t\tread_cb,\n\t\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->read_id)\n\t\treturn false;\n\n\t/* Read Blob Request */\n\tserver->read_blob_id = bt_att_register(server->att,\n\t\t\t\t\t\t\tBT_ATT_OP_READ_BLOB_REQ,\n\t\t\t\t\t\t\tread_blob_cb,\n\t\t\t\t\t\t\tserver, NULL);\n\tif (!server->read_blob_id)\n\t\treturn false;\n\n\t/* Read Multiple Request */\n\tserver->read_multiple_id = bt_att_register(server->att,\n\t\t\t\t\t\t\tBT_ATT_OP_READ_MULT_REQ,\n\t\t\t\t\t\t\tread_multiple_cb,\n\t\t\t\t\t\t\tserver, NULL);\n\n\tif (!server->read_multiple_id)\n\t\treturn false;\n\n\t/* Read Multiple Variable Length Request */\n\tserver->read_multiple_vl_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_READ_MULT_VL_REQ,\n\t\t\t\t\t\tread_multiple_cb,\n\t\t\t\t\t\tserver, NULL);\n\n\tif (!server->read_multiple_vl_id)\n\t\treturn false;\n\n\t/* Prepare Write Request */\n\tserver->prep_write_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tprep_write_cb, server, NULL);\n\tif (!server->prep_write_id)\n\t\treturn false;\n\n\t/* Execute Write Request */\n\tserver->exec_write_id = bt_att_register(server->att,\n\t\t\t\t\t\tBT_ATT_OP_EXEC_WRITE_REQ,\n\t\t\t\t\t\texec_write_cb, server, NULL);\n\tif (!server->exec_write_id)\n\t\treturn NULL;\n\n\treturn true;\n}\n\nstruct bt_gatt_server *bt_gatt_server_new(struct gatt_db *db,\n\t\t\t\t\tstruct bt_att *att, uint16_t mtu,\n\t\t\t\t\tuint8_t min_enc_size)\n{\n\tstruct bt_gatt_server *server;\n\n\tif (!att || !db)\n\t\treturn NULL;\n\n\tserver = new0(struct bt_gatt_server, 1);\n\tserver->db = gatt_db_ref(db);\n\tserver->att = bt_att_ref(att);\n\tserver->mtu = MAX(mtu, BT_ATT_DEFAULT_LE_MTU);\n\tserver->max_prep_queue_len = DEFAULT_MAX_PREP_QUEUE_LEN;\n\tserver->prep_queue = queue_new();\n\tserver->min_enc_size = min_enc_size;\n\n\tif (!gatt_server_register_att_handlers(server)) {\n\t\tbt_gatt_server_free(server);\n\t\treturn NULL;\n\t}\n\n\treturn bt_gatt_server_ref(server);\n}\n\nuint16_t bt_gatt_server_get_mtu(struct bt_gatt_server *server)\n{\n\tif (!server || !server->att)\n\t\treturn 0;\n\n\treturn bt_att_get_mtu(server->att);\n}\n\nstruct bt_att *bt_gatt_server_get_att(struct bt_gatt_server *server)\n{\n\tif (!server)\n\t\treturn NULL;\n\n\treturn server->att;\n}\n\nstruct bt_gatt_server *bt_gatt_server_ref(struct bt_gatt_server *server)\n{\n\tif (!server)\n\t\treturn NULL;\n\n\t__sync_fetch_and_add(&server->ref_count, 1);\n\n\treturn server;\n}\n\nvoid bt_gatt_server_unref(struct bt_gatt_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\tif (__sync_sub_and_fetch(&server->ref_count, 1))\n\t\treturn;\n\n\tbt_gatt_server_free(server);\n}\n\nbool bt_gatt_server_set_debug(struct bt_gatt_server *server,\n\t\t\t\t\tbt_gatt_server_debug_func_t callback,\n\t\t\t\t\tvoid *user_data,\n\t\t\t\t\tbt_gatt_server_destroy_func_t destroy)\n{\n\tif (!server)\n\t\treturn false;\n\n\tif (server->debug_destroy)\n\t\tserver->debug_destroy(server->debug_data);\n\n\tserver->debug_callback = callback;\n\tserver->debug_destroy = destroy;\n\tserver->debug_data = user_data;\n\n\treturn true;\n}\n\nstatic bool notify_multiple(void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\n\tbt_att_send(server->att, BT_ATT_OP_HANDLE_NFY_MULT,\n\t\t\tserver->nfy_mult->pdu, server->nfy_mult->offset, NULL,\n\t\t\tNULL, NULL);\n\n\tfree(server->nfy_mult->pdu);\n\tfree(server->nfy_mult);\n\tserver->nfy_mult = NULL;\n\n\treturn false;\n}\n\nstatic bool notify_append_le16(struct nfy_mult_data *data, uint16_t value)\n{\n\tif (data->offset + sizeof(value) > data->len)\n\t\treturn false;\n\n\tput_le16(value, data->pdu + data->offset);\n\tdata->offset += sizeof(value);\n\n\treturn true;\n}\n\nbool bt_gatt_server_send_notification(struct bt_gatt_server *server,\n\t\t\t\t\tuint16_t handle, const uint8_t *value,\n\t\t\t\t\tuint16_t length, bool multiple)\n{\n\tstruct nfy_mult_data *data = NULL;\n\tbool result;\n\n\tif (!server || (length && !value))\n\t\treturn false;\n\n\tif (multiple) {\n\t\tdata = server->nfy_mult;\n\n\t\t/* flush buffered data if this request hits buffer size limit */\n\t\tif (data && data->offset > 0 &&\n\t\t\t\tdata->len - data->offset < 4 + length) {\n\t\t\tif (server->nfy_mult->id)\n\t\t\t\ttimeout_remove(server->nfy_mult->id);\n\t\t\tnotify_multiple(server);\n\t\t\t/* data has been freed by notify_multiple */\n\t\t\tdata = NULL;\n\t\t}\n\t}\n\n\tif (!data) {\n\t\tdata = new0(struct nfy_mult_data, 1);\n\t\tdata->len = bt_att_get_mtu(server->att) - 1;\n\t\tdata->pdu = malloc(data->len);\n\t}\n\n\tif (!notify_append_le16(data, handle))\n\t\tgoto error;\n\n\tif (multiple) {\n\t\tlength = MIN(data->len - data->offset - 2, length);\n\t\tif (!notify_append_le16(data, length))\n\t\t\tgoto error;\n\t} else {\n\t\tlength = MIN(data->len - data->offset, length);\n\t}\n\n\tmemcpy(data->pdu + data->offset, value, length);\n\tdata->offset += length;\n\n\tif (multiple) {\n\t\tif (!server->nfy_mult)\n\t\t\tserver->nfy_mult = data;\n\n\t\tif (!server->nfy_mult->id)\n\t\t\tserver->nfy_mult->id = timeout_add(NFY_MULT_TIMEOUT,\n\t\t\t\t\t\t   notify_multiple, server,\n\t\t\t\t\t\t   NULL);\n\n\t\treturn true;\n\t}\n\n\tresult = !!bt_att_send(server->att, BT_ATT_OP_HANDLE_NFY,\n\t\t\t\tdata->pdu, data->offset, NULL, NULL, NULL);\n\tfree(data->pdu);\n\tfree(data);\n\n\treturn result;\n\nerror:\n\tif (data)\n\t\tfree(data);\n\n\treturn false;\n}\n\nstruct ind_data {\n\tbt_gatt_server_conf_func_t callback;\n\tbt_gatt_server_destroy_func_t destroy;\n\tvoid *user_data;\n};\n\nstatic void destroy_ind_data(void *user_data)\n{\n\tstruct ind_data *data = user_data;\n\n\tif (data->destroy)\n\t\tdata->destroy(data->user_data);\n\n\tfree(data);\n}\n\nstatic void conf_cb(uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct ind_data *data = user_data;\n\n\tif (data->callback)\n\t\tdata->callback(data->user_data);\n}\n\nbool bt_gatt_server_send_indication(struct bt_gatt_server *server,\n\t\t\t\t\tuint16_t handle, const uint8_t *value,\n\t\t\t\t\tuint16_t length,\n\t\t\t\t\tbt_gatt_server_conf_func_t callback,\n\t\t\t\t\tvoid *user_data,\n\t\t\t\t\tbt_gatt_server_destroy_func_t destroy)\n{\n\tuint16_t pdu_len;\n\tuint8_t *pdu;\n\tstruct ind_data *data;\n\tbool result;\n\n\tif (!server || (length && !value))\n\t\treturn false;\n\n\tpdu_len = MIN(bt_att_get_mtu(server->att) - 1, length + 2);\n\tpdu = malloc(pdu_len);\n\tif (!pdu)\n\t\treturn false;\n\n\tdata = new0(struct ind_data, 1);\n\n\tdata->callback = callback;\n\tdata->destroy = destroy;\n\tdata->user_data = user_data;\n\n\tput_le16(handle, pdu);\n\tmemcpy(pdu + 2, value, pdu_len - 2);\n\n\tresult = !!bt_att_send(server->att, BT_ATT_OP_HANDLE_IND, pdu,\n\t\t\t\t\t\t\tpdu_len, conf_cb,\n\t\t\t\t\t\t\tdata, destroy_ind_data);\n\tif (!result)\n\t\tdestroy_ind_data(data);\n\n\tfree(pdu);\n\n\treturn result;\n}\n\nbool bt_gatt_server_set_authorize(struct bt_gatt_server *server,\n\t\t\t\t\tbt_gatt_server_authorize_cb_t cb,\n\t\t\t\t\tvoid *user_data)\n{\n\tif (!server)\n\t\treturn false;\n\n\tserver->authorize = cb;\n\tserver->authorize_data = user_data;\n\n\treturn true;\n}\n"], "filenames": ["src/shared/gatt-server.c"], "buggy_code_start_loc": [781], "buggy_code_end_loc": [1301], "fixing_code_start_loc": [782], "fixing_code_end_loc": [1324], "type": "CWE-119", "message": "A heap overflow vulnerability was found in bluez in versions prior to 5.63. An attacker with local network access could pass specially crafted files causing an application to halt or crash, leading to a denial of service.", "other": {"cve": {"id": "CVE-2022-0204", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-10T17:44:55.230", "lastModified": "2022-11-07T18:53:42.610", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap overflow vulnerability was found in bluez in versions prior to 5.63. An attacker with local network access could pass specially crafted files causing an application to halt or crash, leading to a denial of service."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad de desbordamiento de pila en bluez en versiones anteriores a la 5.63. Un atacante con acceso a la red local podr\u00eda pasar archivos especialmente dise\u00f1ados causando a una aplicaci\u00f3n detenerse o bloquearse, conllevando a una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.5, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bluez:bluez:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.63", "matchCriteriaId": "92791467-35A3-4E92-AEDC-1E3751013EE8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2039807", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/bluez/bluez/commit/591c546c536b42bef696d027f64aa22434f8c3f0", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bluez/bluez/security/advisories/GHSA-479m-xcq5-9g2q", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00026.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202209-16", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bluez/bluez/commit/591c546c536b42bef696d027f64aa22434f8c3f0"}}