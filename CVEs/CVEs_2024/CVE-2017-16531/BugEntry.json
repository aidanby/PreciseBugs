{"buggy_code": ["/*\n * Released under the GPLv2 only.\n * SPDX-License-Identifier: GPL-2.0\n */\n\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/quirks.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <asm/byteorder.h>\n#include \"usb.h\"\n\n\n#define USB_MAXALTSETTING\t\t128\t/* Hard limit */\n\n#define USB_MAXCONFIG\t\t\t8\t/* Arbitrary limit */\n\n\nstatic inline const char *plural(int n)\n{\n\treturn (n == 1 ? \"\" : \"s\");\n}\n\nstatic int find_next_descriptor(unsigned char *buffer, int size,\n    int dt1, int dt2, int *num_skipped)\n{\n\tstruct usb_descriptor_header *h;\n\tint n = 0;\n\tunsigned char *buffer0 = buffer;\n\n\t/* Find the next descriptor of type dt1 or dt2 */\n\twhile (size > 0) {\n\t\th = (struct usb_descriptor_header *) buffer;\n\t\tif (h->bDescriptorType == dt1 || h->bDescriptorType == dt2)\n\t\t\tbreak;\n\t\tbuffer += h->bLength;\n\t\tsize -= h->bLength;\n\t\t++n;\n\t}\n\n\t/* Store the number of descriptors skipped and return the\n\t * number of bytes skipped */\n\tif (num_skipped)\n\t\t*num_skipped = n;\n\treturn buffer - buffer0;\n}\n\nstatic void usb_parse_ssp_isoc_endpoint_companion(struct device *ddev,\n\t\tint cfgno, int inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ssp_isoc_ep_comp_descriptor *desc;\n\n\t/*\n\t * The SuperSpeedPlus Isoc endpoint companion descriptor immediately\n\t * follows the SuperSpeed Endpoint Companion descriptor\n\t */\n\tdesc = (struct usb_ssp_isoc_ep_comp_descriptor *) buffer;\n\tif (desc->bDescriptorType != USB_DT_SSP_ISOC_ENDPOINT_COMP ||\n\t    size < USB_DT_SSP_ISOC_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"Invalid SuperSpeedPlus isoc endpoint companion\"\n\t\t\t \"for config %d interface %d altsetting %d ep %d.\\n\",\n\t\t\t cfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\treturn;\n\t}\n\tmemcpy(&ep->ssp_isoc_ep_comp, desc, USB_DT_SSP_ISOC_EP_COMP_SIZE);\n}\n\nstatic void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,\n\t\tint inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ss_ep_comp_descriptor *desc;\n\tint max_tx;\n\n\t/* The SuperSpeed endpoint companion descriptor is supposed to\n\t * be the first thing immediately following the endpoint descriptor.\n\t */\n\tdesc = (struct usb_ss_ep_comp_descriptor *) buffer;\n\n\tif (desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||\n\t\t\tsize < USB_DT_SS_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"No SuperSpeed endpoint companion for config %d \"\n\t\t\t\t\" interface %d altsetting %d ep %d: \"\n\t\t\t\t\"using minimum values\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\n\t\t/* Fill in some default values.\n\t\t * Leave bmAttributes as zero, which will mean no streams for\n\t\t * bulk, and isoc won't support multiple bursts of packets.\n\t\t * With bursts of only one packet, and a Mult of 1, the max\n\t\t * amount of data moved per endpoint service interval is one\n\t\t * packet.\n\t\t */\n\t\tep->ss_ep_comp.bLength = USB_DT_SS_EP_COMP_SIZE;\n\t\tep->ss_ep_comp.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;\n\t\tif (usb_endpoint_xfer_isoc(&ep->desc) ||\n\t\t\t\tusb_endpoint_xfer_int(&ep->desc))\n\t\t\tep->ss_ep_comp.wBytesPerInterval =\n\t\t\t\t\tep->desc.wMaxPacketSize;\n\t\treturn;\n\t}\n\tbuffer += desc->bLength;\n\tsize -= desc->bLength;\n\tmemcpy(&ep->ss_ep_comp, desc, USB_DT_SS_EP_COMP_SIZE);\n\n\t/* Check the various values */\n\tif (usb_endpoint_xfer_control(&ep->desc) && desc->bMaxBurst != 0) {\n\t\tdev_warn(ddev, \"Control endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 0;\n\t} else if (desc->bMaxBurst > 15) {\n\t\tdev_warn(ddev, \"Endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 15\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 15;\n\t}\n\n\tif ((usb_endpoint_xfer_control(&ep->desc) ||\n\t\t\tusb_endpoint_xfer_int(&ep->desc)) &&\n\t\t\t\tdesc->bmAttributes != 0) {\n\t\tdev_warn(ddev, \"%s endpoint with bmAttributes = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\",\n\t\t\t\tusb_endpoint_xfer_control(&ep->desc) ? \"Control\" : \"Bulk\",\n\t\t\t\tdesc->bmAttributes,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 0;\n\t} else if (usb_endpoint_xfer_bulk(&ep->desc) &&\n\t\t\tdesc->bmAttributes > 16) {\n\t\tdev_warn(ddev, \"Bulk endpoint with more than 65536 streams in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to max\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 16;\n\t} else if (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t\t   !USB_SS_SSP_ISOC_COMP(desc->bmAttributes) &&\n\t\t   USB_SS_MULT(desc->bmAttributes) > 3) {\n\t\tdev_warn(ddev, \"Isoc endpoint has Mult of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 3\\n\",\n\t\t\t\tUSB_SS_MULT(desc->bmAttributes),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 2;\n\t}\n\n\tif (usb_endpoint_xfer_isoc(&ep->desc))\n\t\tmax_tx = (desc->bMaxBurst + 1) *\n\t\t\t(USB_SS_MULT(desc->bmAttributes)) *\n\t\t\tusb_endpoint_maxp(&ep->desc);\n\telse if (usb_endpoint_xfer_int(&ep->desc))\n\t\tmax_tx = usb_endpoint_maxp(&ep->desc) *\n\t\t\t(desc->bMaxBurst + 1);\n\telse\n\t\tmax_tx = 999999;\n\tif (le16_to_cpu(desc->wBytesPerInterval) > max_tx) {\n\t\tdev_warn(ddev, \"%s endpoint with wBytesPerInterval of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to %d\\n\",\n\t\t\t\tusb_endpoint_xfer_isoc(&ep->desc) ? \"Isoc\" : \"Int\",\n\t\t\t\tle16_to_cpu(desc->wBytesPerInterval),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress,\n\t\t\t\tmax_tx);\n\t\tep->ss_ep_comp.wBytesPerInterval = cpu_to_le16(max_tx);\n\t}\n\t/* Parse a possible SuperSpeedPlus isoc ep companion descriptor */\n\tif (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t    USB_SS_SSP_ISOC_COMP(desc->bmAttributes))\n\t\tusb_parse_ssp_isoc_endpoint_companion(ddev, cfgno, inum, asnum,\n\t\t\t\t\t\t\tep, buffer, size);\n}\n\nstatic const unsigned short low_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 8,\n\t[USB_ENDPOINT_XFER_ISOC] = 0,\n\t[USB_ENDPOINT_XFER_BULK] = 0,\n\t[USB_ENDPOINT_XFER_INT] = 8,\n};\nstatic const unsigned short full_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1023,\n\t[USB_ENDPOINT_XFER_BULK] = 64,\n\t[USB_ENDPOINT_XFER_INT] = 64,\n};\nstatic const unsigned short high_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 512,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\nstatic const unsigned short super_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 512,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 1024,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\n\nstatic int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,\n    int asnum, struct usb_host_interface *ifp, int num_ep,\n    unsigned char *buffer, int size)\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_endpoint_descriptor *d;\n\tstruct usb_host_endpoint *endpoint;\n\tint n, i, j, retval;\n\tunsigned int maxp;\n\tconst unsigned short *maxpacket_maxes;\n\n\td = (struct usb_endpoint_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE)\n\t\tn = USB_DT_ENDPOINT_AUDIO_SIZE;\n\telse if (d->bLength >= USB_DT_ENDPOINT_SIZE)\n\t\tn = USB_DT_ENDPOINT_SIZE;\n\telse {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint descriptor of length %d, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bLength);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\ti = d->bEndpointAddress & ~USB_ENDPOINT_DIR_MASK;\n\tif (i >= 16 || i == 0) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint with address 0x%X, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\t/* Only store as many endpoints as we have room for */\n\tif (ifp->desc.bNumEndpoints >= num_ep)\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\n\t/* Check for duplicate endpoint addresses */\n\tfor (i = 0; i < ifp->desc.bNumEndpoints; ++i) {\n\t\tif (ifp->endpoint[i].desc.bEndpointAddress ==\n\t\t    d->bEndpointAddress) {\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\\n\",\n\t\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t\t}\n\t}\n\n\tendpoint = &ifp->endpoint[ifp->desc.bNumEndpoints];\n\t++ifp->desc.bNumEndpoints;\n\n\tmemcpy(&endpoint->desc, d, n);\n\tINIT_LIST_HEAD(&endpoint->urb_list);\n\n\t/*\n\t * Fix up bInterval values outside the legal range.\n\t * Use 10 or 8 ms if no proper value can be guessed.\n\t */\n\ti = 0;\t\t/* i = min, j = max, n = default */\n\tj = 255;\n\tif (usb_endpoint_xfer_int(d)) {\n\t\ti = 1;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\tcase USB_SPEED_SUPER:\n\t\tcase USB_SPEED_HIGH:\n\t\t\t/*\n\t\t\t * Many device manufacturers are using full-speed\n\t\t\t * bInterval values in high-speed interrupt endpoint\n\t\t\t * descriptors. Try to fix those and fall back to an\n\t\t\t * 8-ms default value otherwise.\n\t\t\t */\n\t\t\tn = fls(d->bInterval*8);\n\t\t\tif (n == 0)\n\t\t\t\tn = 7;\t/* 8 ms = 2^(7-1) uframes */\n\t\t\tj = 16;\n\n\t\t\t/*\n\t\t\t * Adjust bInterval for quirked devices.\n\t\t\t */\n\t\t\t/*\n\t\t\t * This quirk fixes bIntervals reported in ms.\n\t\t\t */\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval) + 3, i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\t/*\n\t\t\t * This quirk fixes bIntervals reported in\n\t\t\t * linear microframes.\n\t\t\t */\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval), i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t\t/* USB_SPEED_FULL or _LOW */\n\t\t\t/*\n\t\t\t * For low-speed, 10 ms is the official minimum.\n\t\t\t * But some \"overclocked\" devices might want faster\n\t\t\t * polling so we'll allow it.\n\t\t\t */\n\t\t\tn = 10;\n\t\t\tbreak;\n\t\t}\n\t} else if (usb_endpoint_xfer_isoc(d)) {\n\t\ti = 1;\n\t\tj = 16;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_HIGH:\n\t\t\tn = 7;\t\t/* 8 ms = 2^(7-1) uframes */\n\t\t\tbreak;\n\t\tdefault:\t\t/* USB_SPEED_FULL */\n\t\t\tn = 4;\t\t/* 8 ms = 2^(4-1) frames */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (d->bInterval < i || d->bInterval > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X has an invalid bInterval %d, \"\n\t\t    \"changing to %d\\n\",\n\t\t    cfgno, inum, asnum,\n\t\t    d->bEndpointAddress, d->bInterval, n);\n\t\tendpoint->desc.bInterval = n;\n\t}\n\n\t/* Some buggy low-speed devices have Bulk endpoints, which is\n\t * explicitly forbidden by the USB spec.  In an attempt to make\n\t * them usable, we will try treating them as Interrupt endpoints.\n\t */\n\tif (to_usb_device(ddev)->speed == USB_SPEED_LOW &&\n\t\t\tusb_endpoint_xfer_bulk(d)) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X is Bulk; changing to Interrupt\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tendpoint->desc.bmAttributes = USB_ENDPOINT_XFER_INT;\n\t\tendpoint->desc.bInterval = 1;\n\t\tif (usb_endpoint_maxp(&endpoint->desc) > 8)\n\t\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(8);\n\t}\n\n\t/* Validate the wMaxPacketSize field */\n\tmaxp = usb_endpoint_maxp(&endpoint->desc);\n\n\t/* Find the highest legal maxpacket size for this endpoint */\n\ti = 0;\t\t/* additional transactions per microframe */\n\tswitch (to_usb_device(ddev)->speed) {\n\tcase USB_SPEED_LOW:\n\t\tmaxpacket_maxes = low_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tmaxpacket_maxes = full_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\t/* Bits 12..11 are allowed only for HS periodic endpoints */\n\t\tif (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {\n\t\t\ti = maxp & (BIT(12) | BIT(11));\n\t\t\tmaxp &= ~i;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tmaxpacket_maxes = high_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tmaxpacket_maxes = super_speed_maxpacket_maxes;\n\t\tbreak;\n\t}\n\tj = maxpacket_maxes[usb_endpoint_type(&endpoint->desc)];\n\n\tif (maxp > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress, maxp, j);\n\t\tmaxp = j;\n\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(i | maxp);\n\t}\n\n\t/*\n\t * Some buggy high speed devices have bulk endpoints using\n\t * maxpacket sizes other than 512.  High speed HCDs may not\n\t * be able to handle that particular bug, so let's warn...\n\t */\n\tif (to_usb_device(ddev)->speed == USB_SPEED_HIGH\n\t\t\t&& usb_endpoint_xfer_bulk(d)) {\n\t\tif (maxp != 512)\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t\t\t\"bulk endpoint 0x%X has invalid maxpacket %d\\n\",\n\t\t\t\tcfgno, inum, asnum, d->bEndpointAddress,\n\t\t\t\tmaxp);\n\t}\n\n\t/* Parse a possible SuperSpeed endpoint companion descriptor */\n\tif (to_usb_device(ddev)->speed >= USB_SPEED_SUPER)\n\t\tusb_parse_ss_endpoint_companion(ddev, cfgno,\n\t\t\t\tinum, asnum, endpoint, buffer, size);\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the next endpoint or interface descriptor */\n\tendpoint->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t\t\tUSB_DT_INTERFACE, &n);\n\tendpoint->extralen = i;\n\tretval = buffer - buffer0 + i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"endpoint\");\n\treturn retval;\n\nskip_to_next_endpoint_or_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nvoid usb_release_interface_cache(struct kref *ref)\n{\n\tstruct usb_interface_cache *intfc = ref_to_usb_interface_cache(ref);\n\tint j;\n\n\tfor (j = 0; j < intfc->num_altsetting; j++) {\n\t\tstruct usb_host_interface *alt = &intfc->altsetting[j];\n\n\t\tkfree(alt->endpoint);\n\t\tkfree(alt->string);\n\t}\n\tkfree(intfc);\n}\n\nstatic int usb_parse_interface(struct device *ddev, int cfgno,\n    struct usb_host_config *config, unsigned char *buffer, int size,\n    u8 inums[], u8 nalts[])\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_interface_descriptor\t*d;\n\tint inum, asnum;\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint i, n;\n\tint len, retval;\n\tint num_ep, num_ep_orig;\n\n\td = (struct usb_interface_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength < USB_DT_INTERFACE_SIZE)\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t/* Which interface entry is this? */\n\tintfc = NULL;\n\tinum = d->bInterfaceNumber;\n\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\tif (inums[i] == inum) {\n\t\t\tintfc = config->intf_cache[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!intfc || intfc->num_altsetting >= nalts[i])\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t/* Check for duplicate altsetting entries */\n\tasnum = d->bAlternateSetting;\n\tfor ((i = 0, alt = &intfc->altsetting[0]);\n\t      i < intfc->num_altsetting;\n\t     (++i, ++alt)) {\n\t\tif (alt->desc.bAlternateSetting == asnum) {\n\t\t\tdev_warn(ddev, \"Duplicate descriptor for config %d \"\n\t\t\t    \"interface %d altsetting %d, skipping\\n\",\n\t\t\t    cfgno, inum, asnum);\n\t\t\tgoto skip_to_next_interface_descriptor;\n\t\t}\n\t}\n\n\t++intfc->num_altsetting;\n\tmemcpy(&alt->desc, d, USB_DT_INTERFACE_SIZE);\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first endpoint or interface descriptor */\n\talt->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, &n);\n\talt->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"interface\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Allocate space for the right(?) number of endpoints */\n\tnum_ep = num_ep_orig = alt->desc.bNumEndpoints;\n\talt->desc.bNumEndpoints = 0;\t\t/* Use as a counter */\n\tif (num_ep > USB_MAXENDPOINTS) {\n\t\tdev_warn(ddev, \"too many endpoints for config %d interface %d \"\n\t\t    \"altsetting %d: %d, using maximum allowed: %d\\n\",\n\t\t    cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);\n\t\tnum_ep = USB_MAXENDPOINTS;\n\t}\n\n\tif (num_ep > 0) {\n\t\t/* Can't allocate 0 bytes */\n\t\tlen = sizeof(struct usb_host_endpoint) * num_ep;\n\t\talt->endpoint = kzalloc(len, GFP_KERNEL);\n\t\tif (!alt->endpoint)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Parse all the endpoint descriptors */\n\tn = 0;\n\twhile (size > 0) {\n\t\tif (((struct usb_descriptor_header *) buffer)->bDescriptorType\n\t\t     == USB_DT_INTERFACE)\n\t\t\tbreak;\n\t\tretval = usb_parse_endpoint(ddev, cfgno, inum, asnum, alt,\n\t\t    num_ep, buffer, size);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\t++n;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\tif (n != num_ep_orig)\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has %d \"\n\t\t    \"endpoint descriptor%s, different from the interface \"\n\t\t    \"descriptor's value: %d\\n\",\n\t\t    cfgno, inum, asnum, n, plural(n), num_ep_orig);\n\treturn buffer - buffer0;\n\nskip_to_next_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nstatic int usb_parse_configuration(struct usb_device *dev, int cfgidx,\n    struct usb_host_config *config, unsigned char *buffer, int size)\n{\n\tstruct device *ddev = &dev->dev;\n\tunsigned char *buffer0 = buffer;\n\tint cfgno;\n\tint nintf, nintf_orig;\n\tint i, j, n;\n\tstruct usb_interface_cache *intfc;\n\tunsigned char *buffer2;\n\tint size2;\n\tstruct usb_descriptor_header *header;\n\tint len, retval;\n\tu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\n\tunsigned iad_num = 0;\n\n\tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n\tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n\t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n\t    config->desc.bLength > size) {\n\t\tdev_err(ddev, \"invalid descriptor for config index %d: \"\n\t\t    \"type = 0x%X, length = %d\\n\", cfgidx,\n\t\t    config->desc.bDescriptorType, config->desc.bLength);\n\t\treturn -EINVAL;\n\t}\n\tcfgno = config->desc.bConfigurationValue;\n\n\tbuffer += config->desc.bLength;\n\tsize -= config->desc.bLength;\n\n\tnintf = nintf_orig = config->desc.bNumInterfaces;\n\tif (nintf > USB_MAXINTERFACES) {\n\t\tdev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\t\t    \"using maximum allowed: %d\\n\",\n\t\t    cfgno, nintf, USB_MAXINTERFACES);\n\t\tnintf = USB_MAXINTERFACES;\n\t}\n\n\t/* Go through the descriptors, checking their length and counting the\n\t * number of altsettings for each interface */\n\tn = 0;\n\tfor ((buffer2 = buffer, size2 = size);\n\t      size2 > 0;\n\t     (buffer2 += header->bLength, size2 -= header->bLength)) {\n\n\t\tif (size2 < sizeof(struct usb_descriptor_header)) {\n\t\t\tdev_warn(ddev, \"config %d descriptor has %d excess \"\n\t\t\t    \"byte%s, ignoring\\n\",\n\t\t\t    cfgno, size2, plural(size2));\n\t\t\tbreak;\n\t\t}\n\n\t\theader = (struct usb_descriptor_header *) buffer2;\n\t\tif ((header->bLength > size2) || (header->bLength < 2)) {\n\t\t\tdev_warn(ddev, \"config %d has an invalid descriptor \"\n\t\t\t    \"of length %d, skipping remainder of the config\\n\",\n\t\t\t    cfgno, header->bLength);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *d;\n\t\t\tint inum;\n\n\t\t\td = (struct usb_interface_descriptor *) header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_SIZE) {\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface descriptor of length %d, \"\n\t\t\t\t    \"skipping\\n\", cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinum = d->bInterfaceNumber;\n\n\t\t\tif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\n\t\t\t    n >= nintf_orig) {\n\t\t\t\tdev_warn(ddev, \"config %d has more interface \"\n\t\t\t\t    \"descriptors, than it declares in \"\n\t\t\t\t    \"bNumInterfaces, ignoring interface \"\n\t\t\t\t    \"number: %d\\n\", cfgno, inum);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inum >= nintf_orig)\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface number: %d but max is %d\\n\",\n\t\t\t\t    cfgno, inum, nintf_orig - 1);\n\n\t\t\t/* Have we already encountered this interface?\n\t\t\t * Count its altsettings */\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tif (inums[i] == inum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < n) {\n\t\t\t\tif (nalts[i] < 255)\n\t\t\t\t\t++nalts[i];\n\t\t\t} else if (n < USB_MAXINTERFACES) {\n\t\t\t\tinums[n] = inum;\n\t\t\t\tnalts[n] = 1;\n\t\t\t\t++n;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType ==\n\t\t\t\tUSB_DT_INTERFACE_ASSOCIATION) {\n\t\t\tif (iad_num == USB_MAXIADS) {\n\t\t\t\tdev_warn(ddev, \"found more Interface \"\n\t\t\t\t\t       \"Association Descriptors \"\n\t\t\t\t\t       \"than allocated for in \"\n\t\t\t\t\t       \"configuration %d\\n\", cfgno);\n\t\t\t} else {\n\t\t\t\tconfig->intf_assoc[iad_num] =\n\t\t\t\t\t(struct usb_interface_assoc_descriptor\n\t\t\t\t\t*)header;\n\t\t\t\tiad_num++;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType == USB_DT_DEVICE ||\n\t\t\t    header->bDescriptorType == USB_DT_CONFIG)\n\t\t\tdev_warn(ddev, \"config %d contains an unexpected \"\n\t\t\t    \"descriptor of type 0x%X, skipping\\n\",\n\t\t\t    cfgno, header->bDescriptorType);\n\n\t}\t/* for ((buffer2 = buffer, size2 = size); ...) */\n\tsize = buffer2 - buffer;\n\tconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\n\n\tif (n != nintf)\n\t\tdev_warn(ddev, \"config %d has %d interface%s, different from \"\n\t\t    \"the descriptor's value: %d\\n\",\n\t\t    cfgno, n, plural(n), nintf_orig);\n\telse if (n == 0)\n\t\tdev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\n\tconfig->desc.bNumInterfaces = nintf = n;\n\n\t/* Check for missing interface numbers */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tfor (j = 0; j < nintf; ++j) {\n\t\t\tif (inums[j] == i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= nintf)\n\t\t\tdev_warn(ddev, \"config %d has no interface number \"\n\t\t\t    \"%d\\n\", cfgno, i);\n\t}\n\n\t/* Allocate the usb_interface_caches and altsetting arrays */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tj = nalts[i];\n\t\tif (j > USB_MAXALTSETTING) {\n\t\t\tdev_warn(ddev, \"too many alternate settings for \"\n\t\t\t    \"config %d interface %d: %d, \"\n\t\t\t    \"using maximum allowed: %d\\n\",\n\t\t\t    cfgno, inums[i], j, USB_MAXALTSETTING);\n\t\t\tnalts[i] = j = USB_MAXALTSETTING;\n\t\t}\n\n\t\tlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\n\t\tconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\n\t\tif (!intfc)\n\t\t\treturn -ENOMEM;\n\t\tkref_init(&intfc->ref);\n\t}\n\n\t/* FIXME: parse the BOS descriptor */\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first interface descriptor */\n\tconfig->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, &n);\n\tconfig->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"configuration\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Parse all the interface/altsetting descriptors */\n\twhile (size > 0) {\n\t\tretval = usb_parse_interface(ddev, cfgno, config,\n\t\t    buffer, size, inums, nalts);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\t/* Check for missing altsettings */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tintfc = config->intf_cache[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\tfor (n = 0; n < intfc->num_altsetting; ++n) {\n\t\t\t\tif (intfc->altsetting[n].desc.\n\t\t\t\t    bAlternateSetting == j)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= intfc->num_altsetting)\n\t\t\t\tdev_warn(ddev, \"config %d interface %d has no \"\n\t\t\t\t    \"altsetting %d\\n\", cfgno, inums[i], j);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* hub-only!! ... and only exported for reset/reinit path.\n * otherwise used internally on disconnect/destroy path\n */\nvoid usb_destroy_configuration(struct usb_device *dev)\n{\n\tint c, i;\n\n\tif (!dev->config)\n\t\treturn;\n\n\tif (dev->rawdescriptors) {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++)\n\t\t\tkfree(dev->rawdescriptors[i]);\n\n\t\tkfree(dev->rawdescriptors);\n\t\tdev->rawdescriptors = NULL;\n\t}\n\n\tfor (c = 0; c < dev->descriptor.bNumConfigurations; c++) {\n\t\tstruct usb_host_config *cf = &dev->config[c];\n\n\t\tkfree(cf->string);\n\t\tfor (i = 0; i < cf->desc.bNumInterfaces; i++) {\n\t\t\tif (cf->intf_cache[i])\n\t\t\t\tkref_put(&cf->intf_cache[i]->ref,\n\t\t\t\t\t  usb_release_interface_cache);\n\t\t}\n\t}\n\tkfree(dev->config);\n\tdev->config = NULL;\n}\n\n\n/*\n * Get the USB config descriptors, cache and parse'em\n *\n * hub-only!! ... and only in reset path, or usb_new_device()\n * (used by real hubs and virtual root hubs)\n */\nint usb_get_configuration(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tint ncfg = dev->descriptor.bNumConfigurations;\n\tint result = 0;\n\tunsigned int cfgno, length;\n\tunsigned char *bigbuffer;\n\tstruct usb_config_descriptor *desc;\n\n\tcfgno = 0;\n\tresult = -ENOMEM;\n\tif (ncfg > USB_MAXCONFIG) {\n\t\tdev_warn(ddev, \"too many configurations: %d, \"\n\t\t    \"using maximum allowed: %d\\n\", ncfg, USB_MAXCONFIG);\n\t\tdev->descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;\n\t}\n\n\tif (ncfg < 1) {\n\t\tdev_err(ddev, \"no configurations\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlength = ncfg * sizeof(struct usb_host_config);\n\tdev->config = kzalloc(length, GFP_KERNEL);\n\tif (!dev->config)\n\t\tgoto err2;\n\n\tlength = ncfg * sizeof(char *);\n\tdev->rawdescriptors = kzalloc(length, GFP_KERNEL);\n\tif (!dev->rawdescriptors)\n\t\tgoto err2;\n\n\tdesc = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto err2;\n\n\tresult = 0;\n\tfor (; cfgno < ncfg; cfgno++) {\n\t\t/* We grab just the first descriptor so we know how long\n\t\t * the whole configuration is */\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    desc, USB_DT_CONFIG_SIZE);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s: %d\\n\", cfgno, \"start\", result);\n\t\t\tif (result != -EPIPE)\n\t\t\t\tgoto err;\n\t\t\tdev_err(ddev, \"chopping to %d config(s)\\n\", cfgno);\n\t\t\tdev->descriptor.bNumConfigurations = cfgno;\n\t\t\tbreak;\n\t\t} else if (result < 4) {\n\t\t\tdev_err(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno,\n\t\t\t    USB_DT_CONFIG_SIZE, result);\n\t\t\tresult = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tlength = max((int) le16_to_cpu(desc->wTotalLength),\n\t\t    USB_DT_CONFIG_SIZE);\n\n\t\t/* Now that we know the length, get the whole thing */\n\t\tbigbuffer = kmalloc(length, GFP_KERNEL);\n\t\tif (!bigbuffer) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(200);\n\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s\\n\", cfgno, \"all\");\n\t\t\tkfree(bigbuffer);\n\t\t\tgoto err;\n\t\t}\n\t\tif (result < length) {\n\t\t\tdev_warn(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno, length, result);\n\t\t\tlength = result;\n\t\t}\n\n\t\tdev->rawdescriptors[cfgno] = bigbuffer;\n\n\t\tresult = usb_parse_configuration(dev, cfgno,\n\t\t    &dev->config[cfgno], bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\t++cfgno;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tresult = 0;\n\nerr:\n\tkfree(desc);\n\tdev->descriptor.bNumConfigurations = cfgno;\nerr2:\n\tif (result == -ENOMEM)\n\t\tdev_err(ddev, \"out of memory\\n\");\n\treturn result;\n}\n\nvoid usb_release_bos_descriptor(struct usb_device *dev)\n{\n\tif (dev->bos) {\n\t\tkfree(dev->bos->desc);\n\t\tkfree(dev->bos);\n\t\tdev->bos = NULL;\n\t}\n}\n\n/* Get BOS descriptor set */\nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\n", "/*\n * This file holds USB constants and structures that are needed for\n * USB device APIs.  These are used by the USB device model, which is\n * defined in chapter 9 of the USB 2.0 specification and in the\n * Wireless USB 1.0 (spread around).  Linux has several APIs in C that\n * need these:\n *\n * - the master/host side Linux-USB kernel driver API;\n * - the \"usbfs\" user space API; and\n * - the Linux \"gadget\" slave/device/peripheral side driver API.\n *\n * USB 2.0 adds an additional \"On The Go\" (OTG) mode, which lets systems\n * act either as a USB master/host or as a USB slave/device.  That means\n * the master and slave side APIs benefit from working well together.\n *\n * There's also \"Wireless USB\", using low power short range radios for\n * peripheral interconnection but otherwise building on the USB framework.\n *\n * Note all descriptors are declared '__attribute__((packed))' so that:\n *\n * [a] they never get padded, either internally (USB spec writers\n *     probably handled that) or externally;\n *\n * [b] so that accessing bigger-than-a-bytes fields will never\n *     generate bus errors on any platform, even when the location of\n *     its descriptor inside a bundle isn't \"naturally aligned\", and\n *\n * [c] for consistency, removing all doubt even when it appears to\n *     someone that the two other points are non-issues for that\n *     particular descriptor type.\n */\n\n#ifndef _UAPI__LINUX_USB_CH9_H\n#define _UAPI__LINUX_USB_CH9_H\n\n#include <linux/types.h>\t/* __u8 etc */\n#include <asm/byteorder.h>\t/* le16_to_cpu */\n\n/*-------------------------------------------------------------------------*/\n\n/* CONTROL REQUEST SUPPORT */\n\n/*\n * USB directions\n *\n * This bit flag is used in endpoint descriptors' bEndpointAddress field.\n * It's also one of three fields in control requests bRequestType.\n */\n#define USB_DIR_OUT\t\t\t0\t\t/* to device */\n#define USB_DIR_IN\t\t\t0x80\t\t/* to host */\n\n/*\n * USB types, the second of three bRequestType fields\n */\n#define USB_TYPE_MASK\t\t\t(0x03 << 5)\n#define USB_TYPE_STANDARD\t\t(0x00 << 5)\n#define USB_TYPE_CLASS\t\t\t(0x01 << 5)\n#define USB_TYPE_VENDOR\t\t\t(0x02 << 5)\n#define USB_TYPE_RESERVED\t\t(0x03 << 5)\n\n/*\n * USB recipients, the third of three bRequestType fields\n */\n#define USB_RECIP_MASK\t\t\t0x1f\n#define USB_RECIP_DEVICE\t\t0x00\n#define USB_RECIP_INTERFACE\t\t0x01\n#define USB_RECIP_ENDPOINT\t\t0x02\n#define USB_RECIP_OTHER\t\t\t0x03\n/* From Wireless USB 1.0 */\n#define USB_RECIP_PORT\t\t\t0x04\n#define USB_RECIP_RPIPE\t\t0x05\n\n/*\n * Standard requests, for the bRequest field of a SETUP packet.\n *\n * These are qualified by the bRequestType field, so that for example\n * TYPE_CLASS or TYPE_VENDOR specific feature flags could be retrieved\n * by a GET_STATUS request.\n */\n#define USB_REQ_GET_STATUS\t\t0x00\n#define USB_REQ_CLEAR_FEATURE\t\t0x01\n#define USB_REQ_SET_FEATURE\t\t0x03\n#define USB_REQ_SET_ADDRESS\t\t0x05\n#define USB_REQ_GET_DESCRIPTOR\t\t0x06\n#define USB_REQ_SET_DESCRIPTOR\t\t0x07\n#define USB_REQ_GET_CONFIGURATION\t0x08\n#define USB_REQ_SET_CONFIGURATION\t0x09\n#define USB_REQ_GET_INTERFACE\t\t0x0A\n#define USB_REQ_SET_INTERFACE\t\t0x0B\n#define USB_REQ_SYNCH_FRAME\t\t0x0C\n#define USB_REQ_SET_SEL\t\t\t0x30\n#define USB_REQ_SET_ISOCH_DELAY\t\t0x31\n\n#define USB_REQ_SET_ENCRYPTION\t\t0x0D\t/* Wireless USB */\n#define USB_REQ_GET_ENCRYPTION\t\t0x0E\n#define USB_REQ_RPIPE_ABORT\t\t0x0E\n#define USB_REQ_SET_HANDSHAKE\t\t0x0F\n#define USB_REQ_RPIPE_RESET\t\t0x0F\n#define USB_REQ_GET_HANDSHAKE\t\t0x10\n#define USB_REQ_SET_CONNECTION\t\t0x11\n#define USB_REQ_SET_SECURITY_DATA\t0x12\n#define USB_REQ_GET_SECURITY_DATA\t0x13\n#define USB_REQ_SET_WUSB_DATA\t\t0x14\n#define USB_REQ_LOOPBACK_DATA_WRITE\t0x15\n#define USB_REQ_LOOPBACK_DATA_READ\t0x16\n#define USB_REQ_SET_INTERFACE_DS\t0x17\n\n/* specific requests for USB Power Delivery */\n#define USB_REQ_GET_PARTNER_PDO\t\t20\n#define USB_REQ_GET_BATTERY_STATUS\t21\n#define USB_REQ_SET_PDO\t\t\t22\n#define USB_REQ_GET_VDM\t\t\t23\n#define USB_REQ_SEND_VDM\t\t24\n\n/* The Link Power Management (LPM) ECN defines USB_REQ_TEST_AND_SET command,\n * used by hubs to put ports into a new L1 suspend state, except that it\n * forgot to define its number ...\n */\n\n/*\n * USB feature flags are written using USB_REQ_{CLEAR,SET}_FEATURE, and\n * are read as a bit array returned by USB_REQ_GET_STATUS.  (So there\n * are at most sixteen features of each type.)  Hubs may also support a\n * new USB_REQ_TEST_AND_SET_FEATURE to put ports into L1 suspend.\n */\n#define USB_DEVICE_SELF_POWERED\t\t0\t/* (read only) */\n#define USB_DEVICE_REMOTE_WAKEUP\t1\t/* dev may initiate wakeup */\n#define USB_DEVICE_TEST_MODE\t\t2\t/* (wired high speed only) */\n#define USB_DEVICE_BATTERY\t\t2\t/* (wireless) */\n#define USB_DEVICE_B_HNP_ENABLE\t\t3\t/* (otg) dev may initiate HNP */\n#define USB_DEVICE_WUSB_DEVICE\t\t3\t/* (wireless)*/\n#define USB_DEVICE_A_HNP_SUPPORT\t4\t/* (otg) RH port supports HNP */\n#define USB_DEVICE_A_ALT_HNP_SUPPORT\t5\t/* (otg) other RH port does */\n#define USB_DEVICE_DEBUG_MODE\t\t6\t/* (special devices only) */\n\n/*\n * Test Mode Selectors\n * See USB 2.0 spec Table 9-7\n */\n#define\tTEST_J\t\t1\n#define\tTEST_K\t\t2\n#define\tTEST_SE0_NAK\t3\n#define\tTEST_PACKET\t4\n#define\tTEST_FORCE_EN\t5\n\n/*\n * New Feature Selectors as added by USB 3.0\n * See USB 3.0 spec Table 9-7\n */\n#define USB_DEVICE_U1_ENABLE\t48\t/* dev may initiate U1 transition */\n#define USB_DEVICE_U2_ENABLE\t49\t/* dev may initiate U2 transition */\n#define USB_DEVICE_LTM_ENABLE\t50\t/* dev may send LTM */\n#define USB_INTRF_FUNC_SUSPEND\t0\t/* function suspend */\n\n#define USB_INTR_FUNC_SUSPEND_OPT_MASK\t0xFF00\n/*\n * Suspend Options, Table 9-8 USB 3.0 spec\n */\n#define USB_INTRF_FUNC_SUSPEND_LP\t(1 << (8 + 0))\n#define USB_INTRF_FUNC_SUSPEND_RW\t(1 << (8 + 1))\n\n/*\n * Interface status, Figure 9-5 USB 3.0 spec\n */\n#define USB_INTRF_STAT_FUNC_RW_CAP     1\n#define USB_INTRF_STAT_FUNC_RW         2\n\n#define USB_ENDPOINT_HALT\t\t0\t/* IN/OUT will STALL */\n\n/* Bit array elements as returned by the USB_REQ_GET_STATUS request. */\n#define USB_DEV_STAT_U1_ENABLED\t\t2\t/* transition into U1 state */\n#define USB_DEV_STAT_U2_ENABLED\t\t3\t/* transition into U2 state */\n#define USB_DEV_STAT_LTM_ENABLED\t4\t/* Latency tolerance messages */\n\n/*\n * Feature selectors from Table 9-8 USB Power Delivery spec\n */\n#define USB_DEVICE_BATTERY_WAKE_MASK\t40\n#define USB_DEVICE_OS_IS_PD_AWARE\t41\n#define USB_DEVICE_POLICY_MODE\t\t42\n#define USB_PORT_PR_SWAP\t\t43\n#define USB_PORT_GOTO_MIN\t\t44\n#define USB_PORT_RETURN_POWER\t\t45\n#define USB_PORT_ACCEPT_PD_REQUEST\t46\n#define USB_PORT_REJECT_PD_REQUEST\t47\n#define USB_PORT_PORT_PD_RESET\t\t48\n#define USB_PORT_C_PORT_PD_CHANGE\t49\n#define USB_PORT_CABLE_PD_RESET\t\t50\n#define USB_DEVICE_CHARGING_POLICY\t54\n\n/**\n * struct usb_ctrlrequest - SETUP data for a USB device control request\n * @bRequestType: matches the USB bmRequestType field\n * @bRequest: matches the USB bRequest field\n * @wValue: matches the USB wValue field (le16 byte order)\n * @wIndex: matches the USB wIndex field (le16 byte order)\n * @wLength: matches the USB wLength field (le16 byte order)\n *\n * This structure is used to send control requests to a USB device.  It matches\n * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the\n * USB spec for a fuller description of the different fields, and what they are\n * used for.\n *\n * Note that the driver for any interface can issue control requests.\n * For most devices, interfaces don't coordinate with each other, so\n * such requests may be made at any time.\n */\nstruct usb_ctrlrequest {\n\t__u8 bRequestType;\n\t__u8 bRequest;\n\t__le16 wValue;\n\t__le16 wIndex;\n\t__le16 wLength;\n} __attribute__ ((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/*\n * STANDARD DESCRIPTORS ... as returned by GET_DESCRIPTOR, or\n * (rarely) accepted by SET_DESCRIPTOR.\n *\n * Note that all multi-byte values here are encoded in little endian\n * byte order \"on the wire\".  Within the kernel and when exposed\n * through the Linux-USB APIs, they are not converted to cpu byte\n * order; it is the responsibility of the client code to do this.\n * The single exception is when device and configuration descriptors (but\n * not other descriptors) are read from character devices\n * (i.e. /dev/bus/usb/BBB/DDD);\n * in this case the fields are converted to host endianness by the kernel.\n */\n\n/*\n * Descriptor types ... USB 2.0 spec table 9.5\n */\n#define USB_DT_DEVICE\t\t\t0x01\n#define USB_DT_CONFIG\t\t\t0x02\n#define USB_DT_STRING\t\t\t0x03\n#define USB_DT_INTERFACE\t\t0x04\n#define USB_DT_ENDPOINT\t\t\t0x05\n#define USB_DT_DEVICE_QUALIFIER\t\t0x06\n#define USB_DT_OTHER_SPEED_CONFIG\t0x07\n#define USB_DT_INTERFACE_POWER\t\t0x08\n/* these are from a minor usb 2.0 revision (ECN) */\n#define USB_DT_OTG\t\t\t0x09\n#define USB_DT_DEBUG\t\t\t0x0a\n#define USB_DT_INTERFACE_ASSOCIATION\t0x0b\n/* these are from the Wireless USB spec */\n#define USB_DT_SECURITY\t\t\t0x0c\n#define USB_DT_KEY\t\t\t0x0d\n#define USB_DT_ENCRYPTION_TYPE\t\t0x0e\n#define USB_DT_BOS\t\t\t0x0f\n#define USB_DT_DEVICE_CAPABILITY\t0x10\n#define USB_DT_WIRELESS_ENDPOINT_COMP\t0x11\n#define USB_DT_WIRE_ADAPTER\t\t0x21\n#define USB_DT_RPIPE\t\t\t0x22\n#define USB_DT_CS_RADIO_CONTROL\t\t0x23\n/* From the T10 UAS specification */\n#define USB_DT_PIPE_USAGE\t\t0x24\n/* From the USB 3.0 spec */\n#define\tUSB_DT_SS_ENDPOINT_COMP\t\t0x30\n/* From the USB 3.1 spec */\n#define\tUSB_DT_SSP_ISOC_ENDPOINT_COMP\t0x31\n\n/* Conventional codes for class-specific descriptors.  The convention is\n * defined in the USB \"Common Class\" Spec (3.11).  Individual class specs\n * are authoritative for their usage, not the \"common class\" writeup.\n */\n#define USB_DT_CS_DEVICE\t\t(USB_TYPE_CLASS | USB_DT_DEVICE)\n#define USB_DT_CS_CONFIG\t\t(USB_TYPE_CLASS | USB_DT_CONFIG)\n#define USB_DT_CS_STRING\t\t(USB_TYPE_CLASS | USB_DT_STRING)\n#define USB_DT_CS_INTERFACE\t\t(USB_TYPE_CLASS | USB_DT_INTERFACE)\n#define USB_DT_CS_ENDPOINT\t\t(USB_TYPE_CLASS | USB_DT_ENDPOINT)\n\n/* All standard descriptors have these 2 fields at the beginning */\nstruct usb_descriptor_header {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n} __attribute__ ((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEVICE: Device descriptor */\nstruct usb_device_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 bcdUSB;\n\t__u8  bDeviceClass;\n\t__u8  bDeviceSubClass;\n\t__u8  bDeviceProtocol;\n\t__u8  bMaxPacketSize0;\n\t__le16 idVendor;\n\t__le16 idProduct;\n\t__le16 bcdDevice;\n\t__u8  iManufacturer;\n\t__u8  iProduct;\n\t__u8  iSerialNumber;\n\t__u8  bNumConfigurations;\n} __attribute__ ((packed));\n\n#define USB_DT_DEVICE_SIZE\t\t18\n\n\n/*\n * Device and/or Interface Class codes\n * as found in bDeviceClass or bInterfaceClass\n * and defined by www.usb.org documents\n */\n#define USB_CLASS_PER_INTERFACE\t\t0\t/* for DeviceClass */\n#define USB_CLASS_AUDIO\t\t\t1\n#define USB_CLASS_COMM\t\t\t2\n#define USB_CLASS_HID\t\t\t3\n#define USB_CLASS_PHYSICAL\t\t5\n#define USB_CLASS_STILL_IMAGE\t\t6\n#define USB_CLASS_PRINTER\t\t7\n#define USB_CLASS_MASS_STORAGE\t\t8\n#define USB_CLASS_HUB\t\t\t9\n#define USB_CLASS_CDC_DATA\t\t0x0a\n#define USB_CLASS_CSCID\t\t\t0x0b\t/* chip+ smart card */\n#define USB_CLASS_CONTENT_SEC\t\t0x0d\t/* content security */\n#define USB_CLASS_VIDEO\t\t\t0x0e\n#define USB_CLASS_WIRELESS_CONTROLLER\t0xe0\n#define USB_CLASS_MISC\t\t\t0xef\n#define USB_CLASS_APP_SPEC\t\t0xfe\n#define USB_CLASS_VENDOR_SPEC\t\t0xff\n\n#define USB_SUBCLASS_VENDOR_SPEC\t0xff\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_CONFIG: Configuration descriptor information.\n *\n * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the\n * descriptor type is different.  Highspeed-capable devices can look\n * different depending on what speed they're currently running.  Only\n * devices with a USB_DT_DEVICE_QUALIFIER have any OTHER_SPEED_CONFIG\n * descriptors.\n */\nstruct usb_config_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wTotalLength;\n\t__u8  bNumInterfaces;\n\t__u8  bConfigurationValue;\n\t__u8  iConfiguration;\n\t__u8  bmAttributes;\n\t__u8  bMaxPower;\n} __attribute__ ((packed));\n\n#define USB_DT_CONFIG_SIZE\t\t9\n\n/* from config descriptor bmAttributes */\n#define USB_CONFIG_ATT_ONE\t\t(1 << 7)\t/* must be set */\n#define USB_CONFIG_ATT_SELFPOWER\t(1 << 6)\t/* self powered */\n#define USB_CONFIG_ATT_WAKEUP\t\t(1 << 5)\t/* can wakeup */\n#define USB_CONFIG_ATT_BATTERY\t\t(1 << 4)\t/* battery powered */\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_STRING: String descriptor */\nstruct usb_string_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wData[1];\t\t/* UTF-16LE encoded */\n} __attribute__ ((packed));\n\n/* note that \"string\" zero is special, it holds language codes that\n * the device supports, not Unicode characters.\n */\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_INTERFACE: Interface descriptor */\nstruct usb_interface_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bInterfaceNumber;\n\t__u8  bAlternateSetting;\n\t__u8  bNumEndpoints;\n\t__u8  bInterfaceClass;\n\t__u8  bInterfaceSubClass;\n\t__u8  bInterfaceProtocol;\n\t__u8  iInterface;\n} __attribute__ ((packed));\n\n#define USB_DT_INTERFACE_SIZE\t\t9\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_ENDPOINT: Endpoint descriptor */\nstruct usb_endpoint_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bEndpointAddress;\n\t__u8  bmAttributes;\n\t__le16 wMaxPacketSize;\n\t__u8  bInterval;\n\n\t/* NOTE:  these two are _only_ in audio endpoints. */\n\t/* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */\n\t__u8  bRefresh;\n\t__u8  bSynchAddress;\n} __attribute__ ((packed));\n\n#define USB_DT_ENDPOINT_SIZE\t\t7\n#define USB_DT_ENDPOINT_AUDIO_SIZE\t9\t/* Audio extension */\n\n\n/*\n * Endpoints\n */\n#define USB_ENDPOINT_NUMBER_MASK\t0x0f\t/* in bEndpointAddress */\n#define USB_ENDPOINT_DIR_MASK\t\t0x80\n\n#define USB_ENDPOINT_XFERTYPE_MASK\t0x03\t/* in bmAttributes */\n#define USB_ENDPOINT_XFER_CONTROL\t0\n#define USB_ENDPOINT_XFER_ISOC\t\t1\n#define USB_ENDPOINT_XFER_BULK\t\t2\n#define USB_ENDPOINT_XFER_INT\t\t3\n#define USB_ENDPOINT_MAX_ADJUSTABLE\t0x80\n\n#define USB_ENDPOINT_MAXP_MASK\t0x07ff\n#define USB_EP_MAXP_MULT_SHIFT\t11\n#define USB_EP_MAXP_MULT_MASK\t(3 << USB_EP_MAXP_MULT_SHIFT)\n#define USB_EP_MAXP_MULT(m) \\\n\t(((m) & USB_EP_MAXP_MULT_MASK) >> USB_EP_MAXP_MULT_SHIFT)\n\n/* The USB 3.0 spec redefines bits 5:4 of bmAttributes as interrupt ep type. */\n#define USB_ENDPOINT_INTRTYPE\t\t0x30\n#define USB_ENDPOINT_INTR_PERIODIC\t(0 << 4)\n#define USB_ENDPOINT_INTR_NOTIFICATION\t(1 << 4)\n\n#define USB_ENDPOINT_SYNCTYPE\t\t0x0c\n#define USB_ENDPOINT_SYNC_NONE\t\t(0 << 2)\n#define USB_ENDPOINT_SYNC_ASYNC\t\t(1 << 2)\n#define USB_ENDPOINT_SYNC_ADAPTIVE\t(2 << 2)\n#define USB_ENDPOINT_SYNC_SYNC\t\t(3 << 2)\n\n#define USB_ENDPOINT_USAGE_MASK\t\t0x30\n#define USB_ENDPOINT_USAGE_DATA\t\t0x00\n#define USB_ENDPOINT_USAGE_FEEDBACK\t0x10\n#define USB_ENDPOINT_USAGE_IMPLICIT_FB\t0x20\t/* Implicit feedback Data endpoint */\n\n/*-------------------------------------------------------------------------*/\n\n/**\n * usb_endpoint_num - get the endpoint's number\n * @epd: endpoint to be checked\n *\n * Returns @epd's number: 0 to 15.\n */\nstatic inline int usb_endpoint_num(const struct usb_endpoint_descriptor *epd)\n{\n\treturn epd->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;\n}\n\n/**\n * usb_endpoint_type - get the endpoint's transfer type\n * @epd: endpoint to be checked\n *\n * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according\n * to @epd's transfer type.\n */\nstatic inline int usb_endpoint_type(const struct usb_endpoint_descriptor *epd)\n{\n\treturn epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n}\n\n/**\n * usb_endpoint_dir_in - check if the endpoint has IN direction\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type IN, otherwise it returns false.\n */\nstatic inline int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);\n}\n\n/**\n * usb_endpoint_dir_out - check if the endpoint has OUT direction\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type OUT, otherwise it returns false.\n */\nstatic inline int usb_endpoint_dir_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);\n}\n\n/**\n * usb_endpoint_xfer_bulk - check if the endpoint has bulk transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type bulk, otherwise it returns false.\n */\nstatic inline int usb_endpoint_xfer_bulk(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_BULK);\n}\n\n/**\n * usb_endpoint_xfer_control - check if the endpoint has control transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type control, otherwise it returns false.\n */\nstatic inline int usb_endpoint_xfer_control(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_CONTROL);\n}\n\n/**\n * usb_endpoint_xfer_int - check if the endpoint has interrupt transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type interrupt, otherwise it returns\n * false.\n */\nstatic inline int usb_endpoint_xfer_int(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_INT);\n}\n\n/**\n * usb_endpoint_xfer_isoc - check if the endpoint has isochronous transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type isochronous, otherwise it returns\n * false.\n */\nstatic inline int usb_endpoint_xfer_isoc(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_ISOC);\n}\n\n/**\n * usb_endpoint_is_bulk_in - check if the endpoint is bulk IN\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has bulk transfer type and IN direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_bulk_in(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_in(epd);\n}\n\n/**\n * usb_endpoint_is_bulk_out - check if the endpoint is bulk OUT\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has bulk transfer type and OUT direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_bulk_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_out(epd);\n}\n\n/**\n * usb_endpoint_is_int_in - check if the endpoint is interrupt IN\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has interrupt transfer type and IN direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_int_in(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_int(epd) && usb_endpoint_dir_in(epd);\n}\n\n/**\n * usb_endpoint_is_int_out - check if the endpoint is interrupt OUT\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has interrupt transfer type and OUT direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_int_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_int(epd) && usb_endpoint_dir_out(epd);\n}\n\n/**\n * usb_endpoint_is_isoc_in - check if the endpoint is isochronous IN\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has isochronous transfer type and IN direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_isoc_in(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_in(epd);\n}\n\n/**\n * usb_endpoint_is_isoc_out - check if the endpoint is isochronous OUT\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has isochronous transfer type and OUT direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_isoc_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_out(epd);\n}\n\n/**\n * usb_endpoint_maxp - get endpoint's max packet size\n * @epd: endpoint to be checked\n *\n * Returns @epd's max packet bits [10:0]\n */\nstatic inline int usb_endpoint_maxp(const struct usb_endpoint_descriptor *epd)\n{\n\treturn __le16_to_cpu(epd->wMaxPacketSize) & USB_ENDPOINT_MAXP_MASK;\n}\n\n/**\n * usb_endpoint_maxp_mult - get endpoint's transactional opportunities\n * @epd: endpoint to be checked\n *\n * Return @epd's wMaxPacketSize[12:11] + 1\n */\nstatic inline int\nusb_endpoint_maxp_mult(const struct usb_endpoint_descriptor *epd)\n{\n\tint maxp = __le16_to_cpu(epd->wMaxPacketSize);\n\n\treturn USB_EP_MAXP_MULT(maxp) + 1;\n}\n\nstatic inline int usb_endpoint_interrupt_type(\n\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn epd->bmAttributes & USB_ENDPOINT_INTRTYPE;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_SSP_ISOC_ENDPOINT_COMP: SuperSpeedPlus Isochronous Endpoint Companion\n * descriptor\n */\nstruct usb_ssp_isoc_ep_comp_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__le16 wReseved;\n\t__le32 dwBytesPerInterval;\n} __attribute__ ((packed));\n\n#define USB_DT_SSP_ISOC_EP_COMP_SIZE\t\t8\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_SS_ENDPOINT_COMP: SuperSpeed Endpoint Companion descriptor */\nstruct usb_ss_ep_comp_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bMaxBurst;\n\t__u8  bmAttributes;\n\t__le16 wBytesPerInterval;\n} __attribute__ ((packed));\n\n#define USB_DT_SS_EP_COMP_SIZE\t\t6\n\n/* Bits 4:0 of bmAttributes if this is a bulk endpoint */\nstatic inline int\nusb_ss_max_streams(const struct usb_ss_ep_comp_descriptor *comp)\n{\n\tint\t\tmax_streams;\n\n\tif (!comp)\n\t\treturn 0;\n\n\tmax_streams = comp->bmAttributes & 0x1f;\n\n\tif (!max_streams)\n\t\treturn 0;\n\n\tmax_streams = 1 << max_streams;\n\n\treturn max_streams;\n}\n\n/* Bits 1:0 of bmAttributes if this is an isoc endpoint */\n#define USB_SS_MULT(p)\t\t\t(1 + ((p) & 0x3))\n/* Bit 7 of bmAttributes if a SSP isoc endpoint companion descriptor exists */\n#define USB_SS_SSP_ISOC_COMP(p)\t\t((p) & (1 << 7))\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEVICE_QUALIFIER: Device Qualifier descriptor */\nstruct usb_qualifier_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 bcdUSB;\n\t__u8  bDeviceClass;\n\t__u8  bDeviceSubClass;\n\t__u8  bDeviceProtocol;\n\t__u8  bMaxPacketSize0;\n\t__u8  bNumConfigurations;\n\t__u8  bRESERVED;\n} __attribute__ ((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_OTG (from OTG 1.0a supplement) */\nstruct usb_otg_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bmAttributes;\t/* support for HNP, SRP, etc */\n} __attribute__ ((packed));\n\n/* USB_DT_OTG (from OTG 2.0 supplement) */\nstruct usb_otg20_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bmAttributes;\t/* support for HNP, SRP and ADP, etc */\n\t__le16 bcdOTG;\t\t/* OTG and EH supplement release number\n\t\t\t\t * in binary-coded decimal(i.e. 2.0 is 0200H)\n\t\t\t\t */\n} __attribute__ ((packed));\n\n/* from usb_otg_descriptor.bmAttributes */\n#define USB_OTG_SRP\t\t(1 << 0)\n#define USB_OTG_HNP\t\t(1 << 1)\t/* swap host/device roles */\n#define USB_OTG_ADP\t\t(1 << 2)\t/* support ADP */\n\n#define OTG_STS_SELECTOR\t0xF000\t\t/* OTG status selector */\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEBUG:  for special highspeed devices, replacing serial console */\nstruct usb_debug_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t/* bulk endpoints with 8 byte maxpacket */\n\t__u8  bDebugInEndpoint;\n\t__u8  bDebugOutEndpoint;\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_INTERFACE_ASSOCIATION: groups interfaces */\nstruct usb_interface_assoc_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bFirstInterface;\n\t__u8  bInterfaceCount;\n\t__u8  bFunctionClass;\n\t__u8  bFunctionSubClass;\n\t__u8  bFunctionProtocol;\n\t__u8  iFunction;\n} __attribute__ ((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_SECURITY:  group of wireless security descriptors, including\n * encryption types available for setting up a CC/association.\n */\nstruct usb_security_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wTotalLength;\n\t__u8  bNumEncryptionTypes;\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_KEY:  used with {GET,SET}_SECURITY_DATA; only public keys\n * may be retrieved.\n */\nstruct usb_key_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  tTKID[3];\n\t__u8  bReserved;\n\t__u8  bKeyData[0];\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_ENCRYPTION_TYPE:  bundled in DT_SECURITY groups */\nstruct usb_encryption_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bEncryptionType;\n#define\tUSB_ENC_TYPE_UNSECURE\t\t0\n#define\tUSB_ENC_TYPE_WIRED\t\t1\t/* non-wireless mode */\n#define\tUSB_ENC_TYPE_CCM_1\t\t2\t/* aes128/cbc session */\n#define\tUSB_ENC_TYPE_RSA_1\t\t3\t/* rsa3072/sha1 auth */\n\t__u8  bEncryptionValue;\t\t/* use in SET_ENCRYPTION */\n\t__u8  bAuthKeyIndex;\n} __attribute__((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_BOS:  group of device-level capabilities */\nstruct usb_bos_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wTotalLength;\n\t__u8  bNumDeviceCaps;\n} __attribute__((packed));\n\n#define USB_DT_BOS_SIZE\t\t5\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEVICE_CAPABILITY:  grouped with BOS */\nstruct usb_dev_cap_header {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n} __attribute__((packed));\n\n#define\tUSB_CAP_TYPE_WIRELESS_USB\t1\n\nstruct usb_wireless_cap_descriptor {\t/* Ultra Wide Band */\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\n\t__u8  bmAttributes;\n#define\tUSB_WIRELESS_P2P_DRD\t\t(1 << 1)\n#define\tUSB_WIRELESS_BEACON_MASK\t(3 << 2)\n#define\tUSB_WIRELESS_BEACON_SELF\t(1 << 2)\n#define\tUSB_WIRELESS_BEACON_DIRECTED\t(2 << 2)\n#define\tUSB_WIRELESS_BEACON_NONE\t(3 << 2)\n\t__le16 wPHYRates;\t/* bit rates, Mbps */\n#define\tUSB_WIRELESS_PHY_53\t\t(1 << 0)\t/* always set */\n#define\tUSB_WIRELESS_PHY_80\t\t(1 << 1)\n#define\tUSB_WIRELESS_PHY_107\t\t(1 << 2)\t/* always set */\n#define\tUSB_WIRELESS_PHY_160\t\t(1 << 3)\n#define\tUSB_WIRELESS_PHY_200\t\t(1 << 4)\t/* always set */\n#define\tUSB_WIRELESS_PHY_320\t\t(1 << 5)\n#define\tUSB_WIRELESS_PHY_400\t\t(1 << 6)\n#define\tUSB_WIRELESS_PHY_480\t\t(1 << 7)\n\t__u8  bmTFITXPowerInfo;\t/* TFI power levels */\n\t__u8  bmFFITXPowerInfo;\t/* FFI power levels */\n\t__le16 bmBandGroup;\n\t__u8  bReserved;\n} __attribute__((packed));\n\n/* USB 2.0 Extension descriptor */\n#define\tUSB_CAP_TYPE_EXT\t\t2\n\nstruct usb_ext_cap_descriptor {\t\t/* Link Power Management */\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__le32 bmAttributes;\n#define USB_LPM_SUPPORT\t\t\t(1 << 1)\t/* supports LPM */\n#define USB_BESL_SUPPORT\t\t(1 << 2)\t/* supports BESL */\n#define USB_BESL_BASELINE_VALID\t\t(1 << 3)\t/* Baseline BESL valid*/\n#define USB_BESL_DEEP_VALID\t\t(1 << 4)\t/* Deep BESL valid */\n#define USB_GET_BESL_BASELINE(p)\t(((p) & (0xf << 8)) >> 8)\n#define USB_GET_BESL_DEEP(p)\t\t(((p) & (0xf << 12)) >> 12)\n} __attribute__((packed));\n\n#define USB_DT_USB_EXT_CAP_SIZE\t7\n\n/*\n * SuperSpeed USB Capability descriptor: Defines the set of SuperSpeed USB\n * specific device level capabilities\n */\n#define\t\tUSB_SS_CAP_TYPE\t\t3\nstruct usb_ss_cap_descriptor {\t\t/* Link Power Management */\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__u8  bmAttributes;\n#define USB_LTM_SUPPORT\t\t\t(1 << 1) /* supports LTM */\n\t__le16 wSpeedSupported;\n#define USB_LOW_SPEED_OPERATION\t\t(1)\t /* Low speed operation */\n#define USB_FULL_SPEED_OPERATION\t(1 << 1) /* Full speed operation */\n#define USB_HIGH_SPEED_OPERATION\t(1 << 2) /* High speed operation */\n#define USB_5GBPS_OPERATION\t\t(1 << 3) /* Operation at 5Gbps */\n\t__u8  bFunctionalitySupport;\n\t__u8  bU1devExitLat;\n\t__le16 bU2DevExitLat;\n} __attribute__((packed));\n\n#define USB_DT_USB_SS_CAP_SIZE\t10\n\n/*\n * Container ID Capability descriptor: Defines the instance unique ID used to\n * identify the instance across all operating modes\n */\n#define\tCONTAINER_ID_TYPE\t4\nstruct usb_ss_container_id_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__u8  bReserved;\n\t__u8  ContainerID[16]; /* 128-bit number */\n} __attribute__((packed));\n\n#define USB_DT_USB_SS_CONTN_ID_SIZE\t20\n\n/*\n * SuperSpeed Plus USB Capability descriptor: Defines the set of\n * SuperSpeed Plus USB specific device level capabilities\n */\n#define\tUSB_SSP_CAP_TYPE\t0xa\nstruct usb_ssp_cap_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__u8  bReserved;\n\t__le32 bmAttributes;\n#define USB_SSP_SUBLINK_SPEED_ATTRIBS\t(0x1f << 0) /* sublink speed entries */\n#define USB_SSP_SUBLINK_SPEED_IDS\t(0xf << 5)  /* speed ID entries */\n\t__le16  wFunctionalitySupport;\n#define USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID\t(0xf)\n#define USB_SSP_MIN_RX_LANE_COUNT\t\t(0xf << 8)\n#define USB_SSP_MIN_TX_LANE_COUNT\t\t(0xf << 12)\n\t__le16 wReserved;\n\t__le32 bmSublinkSpeedAttr[1]; /* list of sublink speed attrib entries */\n#define USB_SSP_SUBLINK_SPEED_SSID\t(0xf)\t\t/* sublink speed ID */\n#define USB_SSP_SUBLINK_SPEED_LSE\t(0x3 << 4)\t/* Lanespeed exponent */\n#define USB_SSP_SUBLINK_SPEED_ST\t(0x3 << 6)\t/* Sublink type */\n#define USB_SSP_SUBLINK_SPEED_RSVD\t(0x3f << 8)\t/* Reserved */\n#define USB_SSP_SUBLINK_SPEED_LP\t(0x3 << 14)\t/* Link protocol */\n#define USB_SSP_SUBLINK_SPEED_LSM\t(0xff << 16)\t/* Lanespeed mantissa */\n} __attribute__((packed));\n\n/*\n * USB Power Delivery Capability Descriptor:\n * Defines capabilities for PD\n */\n/* Defines the various PD Capabilities of this device */\n#define USB_PD_POWER_DELIVERY_CAPABILITY\t0x06\n/* Provides information on each battery supported by the device */\n#define USB_PD_BATTERY_INFO_CAPABILITY\t\t0x07\n/* The Consumer characteristics of a Port on the device */\n#define USB_PD_PD_CONSUMER_PORT_CAPABILITY\t0x08\n/* The provider characteristics of a Port on the device */\n#define USB_PD_PD_PROVIDER_PORT_CAPABILITY\t0x09\n\nstruct usb_pd_cap_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType; /* set to USB_PD_POWER_DELIVERY_CAPABILITY */\n\t__u8  bReserved;\n\t__le32 bmAttributes;\n#define USB_PD_CAP_BATTERY_CHARGING\t(1 << 1) /* supports Battery Charging specification */\n#define USB_PD_CAP_USB_PD\t\t(1 << 2) /* supports USB Power Delivery specification */\n#define USB_PD_CAP_PROVIDER\t\t(1 << 3) /* can provide power */\n#define USB_PD_CAP_CONSUMER\t\t(1 << 4) /* can consume power */\n#define USB_PD_CAP_CHARGING_POLICY\t(1 << 5) /* supports CHARGING_POLICY feature */\n#define USB_PD_CAP_TYPE_C_CURRENT\t(1 << 6) /* supports power capabilities defined in the USB Type-C Specification */\n\n#define USB_PD_CAP_PWR_AC\t\t(1 << 8)\n#define USB_PD_CAP_PWR_BAT\t\t(1 << 9)\n#define USB_PD_CAP_PWR_USE_V_BUS\t(1 << 14)\n\n\t__le16 bmProviderPorts; /* Bit zero refers to the UFP of the device */\n\t__le16 bmConsumerPorts;\n\t__le16 bcdBCVersion;\n\t__le16 bcdPDVersion;\n\t__le16 bcdUSBTypeCVersion;\n} __attribute__((packed));\n\nstruct usb_pd_cap_battery_info_descriptor {\n\t__u8 bLength;\n\t__u8 bDescriptorType;\n\t__u8 bDevCapabilityType;\n\t/* Index of string descriptor shall contain the user friendly name for this battery */\n\t__u8 iBattery;\n\t/* Index of string descriptor shall contain the Serial Number String for this battery */\n\t__u8 iSerial;\n\t__u8 iManufacturer;\n\t__u8 bBatteryId; /* uniquely identifies this battery in status Messages */\n\t__u8 bReserved;\n\t/*\n\t * Shall contain the Battery Charge value above which this\n\t * battery is considered to be fully charged but not necessarily\n\t * \u201ctopped off.\u201d\n\t */\n\t__le32 dwChargedThreshold; /* in mWh */\n\t/*\n\t * Shall contain the minimum charge level of this battery such\n\t * that above this threshold, a device can be assured of being\n\t * able to power up successfully (see Battery Charging 1.2).\n\t */\n\t__le32 dwWeakThreshold; /* in mWh */\n\t__le32 dwBatteryDesignCapacity; /* in mWh */\n\t__le32 dwBatteryLastFullchargeCapacity; /* in mWh */\n} __attribute__((packed));\n\nstruct usb_pd_cap_consumer_port_descriptor {\n\t__u8 bLength;\n\t__u8 bDescriptorType;\n\t__u8 bDevCapabilityType;\n\t__u8 bReserved;\n\t__u8 bmCapabilities;\n/* port will oerate under: */\n#define USB_PD_CAP_CONSUMER_BC\t\t(1 << 0) /* BC */\n#define USB_PD_CAP_CONSUMER_PD\t\t(1 << 1) /* PD */\n#define USB_PD_CAP_CONSUMER_TYPE_C\t(1 << 2) /* USB Type-C Current */\n\t__le16 wMinVoltage; /* in 50mV units */\n\t__le16 wMaxVoltage; /* in 50mV units */\n\t__u16 wReserved;\n\t__le32 dwMaxOperatingPower; /* in 10 mW - operating at steady state */\n\t__le32 dwMaxPeakPower; /* in 10mW units - operating at peak power */\n\t__le32 dwMaxPeakPowerTime; /* in 100ms units - duration of peak */\n#define USB_PD_CAP_CONSUMER_UNKNOWN_PEAK_POWER_TIME 0xffff\n} __attribute__((packed));\n\nstruct usb_pd_cap_provider_port_descriptor {\n\t__u8 bLength;\n\t__u8 bDescriptorType;\n\t__u8 bDevCapabilityType;\n\t__u8 bReserved1;\n\t__u8 bmCapabilities;\n/* port will oerate under: */\n#define USB_PD_CAP_PROVIDER_BC\t\t(1 << 0) /* BC */\n#define USB_PD_CAP_PROVIDER_PD\t\t(1 << 1) /* PD */\n#define USB_PD_CAP_PROVIDER_TYPE_C\t(1 << 2) /* USB Type-C Current */\n\t__u8 bNumOfPDObjects;\n\t__u8 bReserved2;\n\t__le32 wPowerDataObject[];\n} __attribute__((packed));\n\n/*\n * Precision time measurement capability descriptor: advertised by devices and\n * hubs that support PTM\n */\n#define\tUSB_PTM_CAP_TYPE\t0xb\nstruct usb_ptm_cap_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n} __attribute__((packed));\n\n/*\n * The size of the descriptor for the Sublink Speed Attribute Count\n * (SSAC) specified in bmAttributes[4:0].\n */\n#define USB_DT_USB_SSP_CAP_SIZE(ssac)\t(16 + ssac * 4)\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_WIRELESS_ENDPOINT_COMP:  companion descriptor associated with\n * each endpoint descriptor for a wireless device\n */\nstruct usb_wireless_ep_comp_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bMaxBurst;\n\t__u8  bMaxSequence;\n\t__le16 wMaxStreamDelay;\n\t__le16 wOverTheAirPacketSize;\n\t__u8  bOverTheAirInterval;\n\t__u8  bmCompAttributes;\n#define USB_ENDPOINT_SWITCH_MASK\t0x03\t/* in bmCompAttributes */\n#define USB_ENDPOINT_SWITCH_NO\t\t0\n#define USB_ENDPOINT_SWITCH_SWITCH\t1\n#define USB_ENDPOINT_SWITCH_SCALE\t2\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_REQ_SET_HANDSHAKE is a four-way handshake used between a wireless\n * host and a device for connection set up, mutual authentication, and\n * exchanging short lived session keys.  The handshake depends on a CC.\n */\nstruct usb_handshake {\n\t__u8 bMessageNumber;\n\t__u8 bStatus;\n\t__u8 tTKID[3];\n\t__u8 bReserved;\n\t__u8 CDID[16];\n\t__u8 nonce[16];\n\t__u8 MIC[8];\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_REQ_SET_CONNECTION modifies or revokes a connection context (CC).\n * A CC may also be set up using non-wireless secure channels (including\n * wired USB!), and some devices may support CCs with multiple hosts.\n */\nstruct usb_connection_context {\n\t__u8 CHID[16];\t\t/* persistent host id */\n\t__u8 CDID[16];\t\t/* device id (unique w/in host context) */\n\t__u8 CK[16];\t\t/* connection key */\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB 2.0 defines three speeds, here's how Linux identifies them */\n\nenum usb_device_speed {\n\tUSB_SPEED_UNKNOWN = 0,\t\t\t/* enumerating */\n\tUSB_SPEED_LOW, USB_SPEED_FULL,\t\t/* usb 1.1 */\n\tUSB_SPEED_HIGH,\t\t\t\t/* usb 2.0 */\n\tUSB_SPEED_WIRELESS,\t\t\t/* wireless (usb 2.5) */\n\tUSB_SPEED_SUPER,\t\t\t/* usb 3.0 */\n\tUSB_SPEED_SUPER_PLUS,\t\t\t/* usb 3.1 */\n};\n\n\nenum usb_device_state {\n\t/* NOTATTACHED isn't in the USB spec, and this state acts\n\t * the same as ATTACHED ... but it's clearer this way.\n\t */\n\tUSB_STATE_NOTATTACHED = 0,\n\n\t/* chapter 9 and authentication (wireless) device states */\n\tUSB_STATE_ATTACHED,\n\tUSB_STATE_POWERED,\t\t\t/* wired */\n\tUSB_STATE_RECONNECTING,\t\t\t/* auth */\n\tUSB_STATE_UNAUTHENTICATED,\t\t/* auth */\n\tUSB_STATE_DEFAULT,\t\t\t/* limited function */\n\tUSB_STATE_ADDRESS,\n\tUSB_STATE_CONFIGURED,\t\t\t/* most functions */\n\n\tUSB_STATE_SUSPENDED\n\n\t/* NOTE:  there are actually four different SUSPENDED\n\t * states, returning to POWERED, DEFAULT, ADDRESS, or\n\t * CONFIGURED respectively when SOF tokens flow again.\n\t * At this level there's no difference between L1 and L2\n\t * suspend states.  (L2 being original USB 1.1 suspend.)\n\t */\n};\n\nenum usb3_link_state {\n\tUSB3_LPM_U0 = 0,\n\tUSB3_LPM_U1,\n\tUSB3_LPM_U2,\n\tUSB3_LPM_U3\n};\n\n/*\n * A U1 timeout of 0x0 means the parent hub will reject any transitions to U1.\n * 0xff means the parent hub will accept transitions to U1, but will not\n * initiate a transition.\n *\n * A U1 timeout of 0x1 to 0x7F also causes the hub to initiate a transition to\n * U1 after that many microseconds.  Timeouts of 0x80 to 0xFE are reserved\n * values.\n *\n * A U2 timeout of 0x0 means the parent hub will reject any transitions to U2.\n * 0xff means the parent hub will accept transitions to U2, but will not\n * initiate a transition.\n *\n * A U2 timeout of 0x1 to 0xFE also causes the hub to initiate a transition to\n * U2 after N*256 microseconds.  Therefore a U2 timeout value of 0x1 means a U2\n * idle timer of 256 microseconds, 0x2 means 512 microseconds, 0xFE means\n * 65.024ms.\n */\n#define USB3_LPM_DISABLED\t\t0x0\n#define USB3_LPM_U1_MAX_TIMEOUT\t\t0x7F\n#define USB3_LPM_U2_MAX_TIMEOUT\t\t0xFE\n#define USB3_LPM_DEVICE_INITIATED\t0xFF\n\nstruct usb_set_sel_req {\n\t__u8\tu1_sel;\n\t__u8\tu1_pel;\n\t__le16\tu2_sel;\n\t__le16\tu2_pel;\n} __attribute__ ((packed));\n\n/*\n * The Set System Exit Latency control transfer provides one byte each for\n * U1 SEL and U1 PEL, so the max exit latency is 0xFF.  U2 SEL and U2 PEL each\n * are two bytes long.\n */\n#define USB3_LPM_MAX_U1_SEL_PEL\t\t0xFF\n#define USB3_LPM_MAX_U2_SEL_PEL\t\t0xFFFF\n\n/*-------------------------------------------------------------------------*/\n\n/*\n * As per USB compliance update, a device that is actively drawing\n * more than 100mA from USB must report itself as bus-powered in\n * the GetStatus(DEVICE) call.\n * http://compliance.usb.org/index.asp?UpdateFile=Electrical&Format=Standard#34\n */\n#define USB_SELF_POWER_VBUS_MAX_DRAW\t\t100\n\n#endif /* _UAPI__LINUX_USB_CH9_H */\n"], "fixing_code": ["/*\n * Released under the GPLv2 only.\n * SPDX-License-Identifier: GPL-2.0\n */\n\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/quirks.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <asm/byteorder.h>\n#include \"usb.h\"\n\n\n#define USB_MAXALTSETTING\t\t128\t/* Hard limit */\n\n#define USB_MAXCONFIG\t\t\t8\t/* Arbitrary limit */\n\n\nstatic inline const char *plural(int n)\n{\n\treturn (n == 1 ? \"\" : \"s\");\n}\n\nstatic int find_next_descriptor(unsigned char *buffer, int size,\n    int dt1, int dt2, int *num_skipped)\n{\n\tstruct usb_descriptor_header *h;\n\tint n = 0;\n\tunsigned char *buffer0 = buffer;\n\n\t/* Find the next descriptor of type dt1 or dt2 */\n\twhile (size > 0) {\n\t\th = (struct usb_descriptor_header *) buffer;\n\t\tif (h->bDescriptorType == dt1 || h->bDescriptorType == dt2)\n\t\t\tbreak;\n\t\tbuffer += h->bLength;\n\t\tsize -= h->bLength;\n\t\t++n;\n\t}\n\n\t/* Store the number of descriptors skipped and return the\n\t * number of bytes skipped */\n\tif (num_skipped)\n\t\t*num_skipped = n;\n\treturn buffer - buffer0;\n}\n\nstatic void usb_parse_ssp_isoc_endpoint_companion(struct device *ddev,\n\t\tint cfgno, int inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ssp_isoc_ep_comp_descriptor *desc;\n\n\t/*\n\t * The SuperSpeedPlus Isoc endpoint companion descriptor immediately\n\t * follows the SuperSpeed Endpoint Companion descriptor\n\t */\n\tdesc = (struct usb_ssp_isoc_ep_comp_descriptor *) buffer;\n\tif (desc->bDescriptorType != USB_DT_SSP_ISOC_ENDPOINT_COMP ||\n\t    size < USB_DT_SSP_ISOC_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"Invalid SuperSpeedPlus isoc endpoint companion\"\n\t\t\t \"for config %d interface %d altsetting %d ep %d.\\n\",\n\t\t\t cfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\treturn;\n\t}\n\tmemcpy(&ep->ssp_isoc_ep_comp, desc, USB_DT_SSP_ISOC_EP_COMP_SIZE);\n}\n\nstatic void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,\n\t\tint inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ss_ep_comp_descriptor *desc;\n\tint max_tx;\n\n\t/* The SuperSpeed endpoint companion descriptor is supposed to\n\t * be the first thing immediately following the endpoint descriptor.\n\t */\n\tdesc = (struct usb_ss_ep_comp_descriptor *) buffer;\n\n\tif (desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||\n\t\t\tsize < USB_DT_SS_EP_COMP_SIZE) {\n\t\tdev_warn(ddev, \"No SuperSpeed endpoint companion for config %d \"\n\t\t\t\t\" interface %d altsetting %d ep %d: \"\n\t\t\t\t\"using minimum values\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\n\t\t/* Fill in some default values.\n\t\t * Leave bmAttributes as zero, which will mean no streams for\n\t\t * bulk, and isoc won't support multiple bursts of packets.\n\t\t * With bursts of only one packet, and a Mult of 1, the max\n\t\t * amount of data moved per endpoint service interval is one\n\t\t * packet.\n\t\t */\n\t\tep->ss_ep_comp.bLength = USB_DT_SS_EP_COMP_SIZE;\n\t\tep->ss_ep_comp.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;\n\t\tif (usb_endpoint_xfer_isoc(&ep->desc) ||\n\t\t\t\tusb_endpoint_xfer_int(&ep->desc))\n\t\t\tep->ss_ep_comp.wBytesPerInterval =\n\t\t\t\t\tep->desc.wMaxPacketSize;\n\t\treturn;\n\t}\n\tbuffer += desc->bLength;\n\tsize -= desc->bLength;\n\tmemcpy(&ep->ss_ep_comp, desc, USB_DT_SS_EP_COMP_SIZE);\n\n\t/* Check the various values */\n\tif (usb_endpoint_xfer_control(&ep->desc) && desc->bMaxBurst != 0) {\n\t\tdev_warn(ddev, \"Control endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 0;\n\t} else if (desc->bMaxBurst > 15) {\n\t\tdev_warn(ddev, \"Endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 15\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 15;\n\t}\n\n\tif ((usb_endpoint_xfer_control(&ep->desc) ||\n\t\t\tusb_endpoint_xfer_int(&ep->desc)) &&\n\t\t\t\tdesc->bmAttributes != 0) {\n\t\tdev_warn(ddev, \"%s endpoint with bmAttributes = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\",\n\t\t\t\tusb_endpoint_xfer_control(&ep->desc) ? \"Control\" : \"Bulk\",\n\t\t\t\tdesc->bmAttributes,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 0;\n\t} else if (usb_endpoint_xfer_bulk(&ep->desc) &&\n\t\t\tdesc->bmAttributes > 16) {\n\t\tdev_warn(ddev, \"Bulk endpoint with more than 65536 streams in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to max\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 16;\n\t} else if (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t\t   !USB_SS_SSP_ISOC_COMP(desc->bmAttributes) &&\n\t\t   USB_SS_MULT(desc->bmAttributes) > 3) {\n\t\tdev_warn(ddev, \"Isoc endpoint has Mult of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 3\\n\",\n\t\t\t\tUSB_SS_MULT(desc->bmAttributes),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 2;\n\t}\n\n\tif (usb_endpoint_xfer_isoc(&ep->desc))\n\t\tmax_tx = (desc->bMaxBurst + 1) *\n\t\t\t(USB_SS_MULT(desc->bmAttributes)) *\n\t\t\tusb_endpoint_maxp(&ep->desc);\n\telse if (usb_endpoint_xfer_int(&ep->desc))\n\t\tmax_tx = usb_endpoint_maxp(&ep->desc) *\n\t\t\t(desc->bMaxBurst + 1);\n\telse\n\t\tmax_tx = 999999;\n\tif (le16_to_cpu(desc->wBytesPerInterval) > max_tx) {\n\t\tdev_warn(ddev, \"%s endpoint with wBytesPerInterval of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to %d\\n\",\n\t\t\t\tusb_endpoint_xfer_isoc(&ep->desc) ? \"Isoc\" : \"Int\",\n\t\t\t\tle16_to_cpu(desc->wBytesPerInterval),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress,\n\t\t\t\tmax_tx);\n\t\tep->ss_ep_comp.wBytesPerInterval = cpu_to_le16(max_tx);\n\t}\n\t/* Parse a possible SuperSpeedPlus isoc ep companion descriptor */\n\tif (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t    USB_SS_SSP_ISOC_COMP(desc->bmAttributes))\n\t\tusb_parse_ssp_isoc_endpoint_companion(ddev, cfgno, inum, asnum,\n\t\t\t\t\t\t\tep, buffer, size);\n}\n\nstatic const unsigned short low_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 8,\n\t[USB_ENDPOINT_XFER_ISOC] = 0,\n\t[USB_ENDPOINT_XFER_BULK] = 0,\n\t[USB_ENDPOINT_XFER_INT] = 8,\n};\nstatic const unsigned short full_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1023,\n\t[USB_ENDPOINT_XFER_BULK] = 64,\n\t[USB_ENDPOINT_XFER_INT] = 64,\n};\nstatic const unsigned short high_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 512,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\nstatic const unsigned short super_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 512,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 1024,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\n\nstatic int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,\n    int asnum, struct usb_host_interface *ifp, int num_ep,\n    unsigned char *buffer, int size)\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_endpoint_descriptor *d;\n\tstruct usb_host_endpoint *endpoint;\n\tint n, i, j, retval;\n\tunsigned int maxp;\n\tconst unsigned short *maxpacket_maxes;\n\n\td = (struct usb_endpoint_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE)\n\t\tn = USB_DT_ENDPOINT_AUDIO_SIZE;\n\telse if (d->bLength >= USB_DT_ENDPOINT_SIZE)\n\t\tn = USB_DT_ENDPOINT_SIZE;\n\telse {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint descriptor of length %d, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bLength);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\ti = d->bEndpointAddress & ~USB_ENDPOINT_DIR_MASK;\n\tif (i >= 16 || i == 0) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint with address 0x%X, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\t/* Only store as many endpoints as we have room for */\n\tif (ifp->desc.bNumEndpoints >= num_ep)\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\n\t/* Check for duplicate endpoint addresses */\n\tfor (i = 0; i < ifp->desc.bNumEndpoints; ++i) {\n\t\tif (ifp->endpoint[i].desc.bEndpointAddress ==\n\t\t    d->bEndpointAddress) {\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\\n\",\n\t\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t\t}\n\t}\n\n\tendpoint = &ifp->endpoint[ifp->desc.bNumEndpoints];\n\t++ifp->desc.bNumEndpoints;\n\n\tmemcpy(&endpoint->desc, d, n);\n\tINIT_LIST_HEAD(&endpoint->urb_list);\n\n\t/*\n\t * Fix up bInterval values outside the legal range.\n\t * Use 10 or 8 ms if no proper value can be guessed.\n\t */\n\ti = 0;\t\t/* i = min, j = max, n = default */\n\tj = 255;\n\tif (usb_endpoint_xfer_int(d)) {\n\t\ti = 1;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\tcase USB_SPEED_SUPER:\n\t\tcase USB_SPEED_HIGH:\n\t\t\t/*\n\t\t\t * Many device manufacturers are using full-speed\n\t\t\t * bInterval values in high-speed interrupt endpoint\n\t\t\t * descriptors. Try to fix those and fall back to an\n\t\t\t * 8-ms default value otherwise.\n\t\t\t */\n\t\t\tn = fls(d->bInterval*8);\n\t\t\tif (n == 0)\n\t\t\t\tn = 7;\t/* 8 ms = 2^(7-1) uframes */\n\t\t\tj = 16;\n\n\t\t\t/*\n\t\t\t * Adjust bInterval for quirked devices.\n\t\t\t */\n\t\t\t/*\n\t\t\t * This quirk fixes bIntervals reported in ms.\n\t\t\t */\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval) + 3, i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\t/*\n\t\t\t * This quirk fixes bIntervals reported in\n\t\t\t * linear microframes.\n\t\t\t */\n\t\t\tif (to_usb_device(ddev)->quirks &\n\t\t\t\tUSB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval), i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t\t/* USB_SPEED_FULL or _LOW */\n\t\t\t/*\n\t\t\t * For low-speed, 10 ms is the official minimum.\n\t\t\t * But some \"overclocked\" devices might want faster\n\t\t\t * polling so we'll allow it.\n\t\t\t */\n\t\t\tn = 10;\n\t\t\tbreak;\n\t\t}\n\t} else if (usb_endpoint_xfer_isoc(d)) {\n\t\ti = 1;\n\t\tj = 16;\n\t\tswitch (to_usb_device(ddev)->speed) {\n\t\tcase USB_SPEED_HIGH:\n\t\t\tn = 7;\t\t/* 8 ms = 2^(7-1) uframes */\n\t\t\tbreak;\n\t\tdefault:\t\t/* USB_SPEED_FULL */\n\t\t\tn = 4;\t\t/* 8 ms = 2^(4-1) frames */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (d->bInterval < i || d->bInterval > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X has an invalid bInterval %d, \"\n\t\t    \"changing to %d\\n\",\n\t\t    cfgno, inum, asnum,\n\t\t    d->bEndpointAddress, d->bInterval, n);\n\t\tendpoint->desc.bInterval = n;\n\t}\n\n\t/* Some buggy low-speed devices have Bulk endpoints, which is\n\t * explicitly forbidden by the USB spec.  In an attempt to make\n\t * them usable, we will try treating them as Interrupt endpoints.\n\t */\n\tif (to_usb_device(ddev)->speed == USB_SPEED_LOW &&\n\t\t\tusb_endpoint_xfer_bulk(d)) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X is Bulk; changing to Interrupt\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tendpoint->desc.bmAttributes = USB_ENDPOINT_XFER_INT;\n\t\tendpoint->desc.bInterval = 1;\n\t\tif (usb_endpoint_maxp(&endpoint->desc) > 8)\n\t\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(8);\n\t}\n\n\t/* Validate the wMaxPacketSize field */\n\tmaxp = usb_endpoint_maxp(&endpoint->desc);\n\n\t/* Find the highest legal maxpacket size for this endpoint */\n\ti = 0;\t\t/* additional transactions per microframe */\n\tswitch (to_usb_device(ddev)->speed) {\n\tcase USB_SPEED_LOW:\n\t\tmaxpacket_maxes = low_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tmaxpacket_maxes = full_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\t/* Bits 12..11 are allowed only for HS periodic endpoints */\n\t\tif (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {\n\t\t\ti = maxp & (BIT(12) | BIT(11));\n\t\t\tmaxp &= ~i;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tmaxpacket_maxes = high_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tmaxpacket_maxes = super_speed_maxpacket_maxes;\n\t\tbreak;\n\t}\n\tj = maxpacket_maxes[usb_endpoint_type(&endpoint->desc)];\n\n\tif (maxp > j) {\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress, maxp, j);\n\t\tmaxp = j;\n\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(i | maxp);\n\t}\n\n\t/*\n\t * Some buggy high speed devices have bulk endpoints using\n\t * maxpacket sizes other than 512.  High speed HCDs may not\n\t * be able to handle that particular bug, so let's warn...\n\t */\n\tif (to_usb_device(ddev)->speed == USB_SPEED_HIGH\n\t\t\t&& usb_endpoint_xfer_bulk(d)) {\n\t\tif (maxp != 512)\n\t\t\tdev_warn(ddev, \"config %d interface %d altsetting %d \"\n\t\t\t\t\"bulk endpoint 0x%X has invalid maxpacket %d\\n\",\n\t\t\t\tcfgno, inum, asnum, d->bEndpointAddress,\n\t\t\t\tmaxp);\n\t}\n\n\t/* Parse a possible SuperSpeed endpoint companion descriptor */\n\tif (to_usb_device(ddev)->speed >= USB_SPEED_SUPER)\n\t\tusb_parse_ss_endpoint_companion(ddev, cfgno,\n\t\t\t\tinum, asnum, endpoint, buffer, size);\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the next endpoint or interface descriptor */\n\tendpoint->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t\t\tUSB_DT_INTERFACE, &n);\n\tendpoint->extralen = i;\n\tretval = buffer - buffer0 + i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"endpoint\");\n\treturn retval;\n\nskip_to_next_endpoint_or_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nvoid usb_release_interface_cache(struct kref *ref)\n{\n\tstruct usb_interface_cache *intfc = ref_to_usb_interface_cache(ref);\n\tint j;\n\n\tfor (j = 0; j < intfc->num_altsetting; j++) {\n\t\tstruct usb_host_interface *alt = &intfc->altsetting[j];\n\n\t\tkfree(alt->endpoint);\n\t\tkfree(alt->string);\n\t}\n\tkfree(intfc);\n}\n\nstatic int usb_parse_interface(struct device *ddev, int cfgno,\n    struct usb_host_config *config, unsigned char *buffer, int size,\n    u8 inums[], u8 nalts[])\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_interface_descriptor\t*d;\n\tint inum, asnum;\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint i, n;\n\tint len, retval;\n\tint num_ep, num_ep_orig;\n\n\td = (struct usb_interface_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength < USB_DT_INTERFACE_SIZE)\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t/* Which interface entry is this? */\n\tintfc = NULL;\n\tinum = d->bInterfaceNumber;\n\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\tif (inums[i] == inum) {\n\t\t\tintfc = config->intf_cache[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!intfc || intfc->num_altsetting >= nalts[i])\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t/* Check for duplicate altsetting entries */\n\tasnum = d->bAlternateSetting;\n\tfor ((i = 0, alt = &intfc->altsetting[0]);\n\t      i < intfc->num_altsetting;\n\t     (++i, ++alt)) {\n\t\tif (alt->desc.bAlternateSetting == asnum) {\n\t\t\tdev_warn(ddev, \"Duplicate descriptor for config %d \"\n\t\t\t    \"interface %d altsetting %d, skipping\\n\",\n\t\t\t    cfgno, inum, asnum);\n\t\t\tgoto skip_to_next_interface_descriptor;\n\t\t}\n\t}\n\n\t++intfc->num_altsetting;\n\tmemcpy(&alt->desc, d, USB_DT_INTERFACE_SIZE);\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first endpoint or interface descriptor */\n\talt->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, &n);\n\talt->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"interface\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Allocate space for the right(?) number of endpoints */\n\tnum_ep = num_ep_orig = alt->desc.bNumEndpoints;\n\talt->desc.bNumEndpoints = 0;\t\t/* Use as a counter */\n\tif (num_ep > USB_MAXENDPOINTS) {\n\t\tdev_warn(ddev, \"too many endpoints for config %d interface %d \"\n\t\t    \"altsetting %d: %d, using maximum allowed: %d\\n\",\n\t\t    cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);\n\t\tnum_ep = USB_MAXENDPOINTS;\n\t}\n\n\tif (num_ep > 0) {\n\t\t/* Can't allocate 0 bytes */\n\t\tlen = sizeof(struct usb_host_endpoint) * num_ep;\n\t\talt->endpoint = kzalloc(len, GFP_KERNEL);\n\t\tif (!alt->endpoint)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Parse all the endpoint descriptors */\n\tn = 0;\n\twhile (size > 0) {\n\t\tif (((struct usb_descriptor_header *) buffer)->bDescriptorType\n\t\t     == USB_DT_INTERFACE)\n\t\t\tbreak;\n\t\tretval = usb_parse_endpoint(ddev, cfgno, inum, asnum, alt,\n\t\t    num_ep, buffer, size);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\t++n;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\tif (n != num_ep_orig)\n\t\tdev_warn(ddev, \"config %d interface %d altsetting %d has %d \"\n\t\t    \"endpoint descriptor%s, different from the interface \"\n\t\t    \"descriptor's value: %d\\n\",\n\t\t    cfgno, inum, asnum, n, plural(n), num_ep_orig);\n\treturn buffer - buffer0;\n\nskip_to_next_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nstatic int usb_parse_configuration(struct usb_device *dev, int cfgidx,\n    struct usb_host_config *config, unsigned char *buffer, int size)\n{\n\tstruct device *ddev = &dev->dev;\n\tunsigned char *buffer0 = buffer;\n\tint cfgno;\n\tint nintf, nintf_orig;\n\tint i, j, n;\n\tstruct usb_interface_cache *intfc;\n\tunsigned char *buffer2;\n\tint size2;\n\tstruct usb_descriptor_header *header;\n\tint len, retval;\n\tu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\n\tunsigned iad_num = 0;\n\n\tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n\tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n\t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n\t    config->desc.bLength > size) {\n\t\tdev_err(ddev, \"invalid descriptor for config index %d: \"\n\t\t    \"type = 0x%X, length = %d\\n\", cfgidx,\n\t\t    config->desc.bDescriptorType, config->desc.bLength);\n\t\treturn -EINVAL;\n\t}\n\tcfgno = config->desc.bConfigurationValue;\n\n\tbuffer += config->desc.bLength;\n\tsize -= config->desc.bLength;\n\n\tnintf = nintf_orig = config->desc.bNumInterfaces;\n\tif (nintf > USB_MAXINTERFACES) {\n\t\tdev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\t\t    \"using maximum allowed: %d\\n\",\n\t\t    cfgno, nintf, USB_MAXINTERFACES);\n\t\tnintf = USB_MAXINTERFACES;\n\t}\n\n\t/* Go through the descriptors, checking their length and counting the\n\t * number of altsettings for each interface */\n\tn = 0;\n\tfor ((buffer2 = buffer, size2 = size);\n\t      size2 > 0;\n\t     (buffer2 += header->bLength, size2 -= header->bLength)) {\n\n\t\tif (size2 < sizeof(struct usb_descriptor_header)) {\n\t\t\tdev_warn(ddev, \"config %d descriptor has %d excess \"\n\t\t\t    \"byte%s, ignoring\\n\",\n\t\t\t    cfgno, size2, plural(size2));\n\t\t\tbreak;\n\t\t}\n\n\t\theader = (struct usb_descriptor_header *) buffer2;\n\t\tif ((header->bLength > size2) || (header->bLength < 2)) {\n\t\t\tdev_warn(ddev, \"config %d has an invalid descriptor \"\n\t\t\t    \"of length %d, skipping remainder of the config\\n\",\n\t\t\t    cfgno, header->bLength);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *d;\n\t\t\tint inum;\n\n\t\t\td = (struct usb_interface_descriptor *) header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_SIZE) {\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface descriptor of length %d, \"\n\t\t\t\t    \"skipping\\n\", cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinum = d->bInterfaceNumber;\n\n\t\t\tif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\n\t\t\t    n >= nintf_orig) {\n\t\t\t\tdev_warn(ddev, \"config %d has more interface \"\n\t\t\t\t    \"descriptors, than it declares in \"\n\t\t\t\t    \"bNumInterfaces, ignoring interface \"\n\t\t\t\t    \"number: %d\\n\", cfgno, inum);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inum >= nintf_orig)\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface number: %d but max is %d\\n\",\n\t\t\t\t    cfgno, inum, nintf_orig - 1);\n\n\t\t\t/* Have we already encountered this interface?\n\t\t\t * Count its altsettings */\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tif (inums[i] == inum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < n) {\n\t\t\t\tif (nalts[i] < 255)\n\t\t\t\t\t++nalts[i];\n\t\t\t} else if (n < USB_MAXINTERFACES) {\n\t\t\t\tinums[n] = inum;\n\t\t\t\tnalts[n] = 1;\n\t\t\t\t++n;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType ==\n\t\t\t\tUSB_DT_INTERFACE_ASSOCIATION) {\n\t\t\tstruct usb_interface_assoc_descriptor *d;\n\n\t\t\td = (struct usb_interface_assoc_descriptor *)header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {\n\t\t\t\tdev_warn(ddev,\n\t\t\t\t\t \"config %d has an invalid interface association descriptor of length %d, skipping\\n\",\n\t\t\t\t\t cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iad_num == USB_MAXIADS) {\n\t\t\t\tdev_warn(ddev, \"found more Interface \"\n\t\t\t\t\t       \"Association Descriptors \"\n\t\t\t\t\t       \"than allocated for in \"\n\t\t\t\t\t       \"configuration %d\\n\", cfgno);\n\t\t\t} else {\n\t\t\t\tconfig->intf_assoc[iad_num] = d;\n\t\t\t\tiad_num++;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType == USB_DT_DEVICE ||\n\t\t\t    header->bDescriptorType == USB_DT_CONFIG)\n\t\t\tdev_warn(ddev, \"config %d contains an unexpected \"\n\t\t\t    \"descriptor of type 0x%X, skipping\\n\",\n\t\t\t    cfgno, header->bDescriptorType);\n\n\t}\t/* for ((buffer2 = buffer, size2 = size); ...) */\n\tsize = buffer2 - buffer;\n\tconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\n\n\tif (n != nintf)\n\t\tdev_warn(ddev, \"config %d has %d interface%s, different from \"\n\t\t    \"the descriptor's value: %d\\n\",\n\t\t    cfgno, n, plural(n), nintf_orig);\n\telse if (n == 0)\n\t\tdev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\n\tconfig->desc.bNumInterfaces = nintf = n;\n\n\t/* Check for missing interface numbers */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tfor (j = 0; j < nintf; ++j) {\n\t\t\tif (inums[j] == i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= nintf)\n\t\t\tdev_warn(ddev, \"config %d has no interface number \"\n\t\t\t    \"%d\\n\", cfgno, i);\n\t}\n\n\t/* Allocate the usb_interface_caches and altsetting arrays */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tj = nalts[i];\n\t\tif (j > USB_MAXALTSETTING) {\n\t\t\tdev_warn(ddev, \"too many alternate settings for \"\n\t\t\t    \"config %d interface %d: %d, \"\n\t\t\t    \"using maximum allowed: %d\\n\",\n\t\t\t    cfgno, inums[i], j, USB_MAXALTSETTING);\n\t\t\tnalts[i] = j = USB_MAXALTSETTING;\n\t\t}\n\n\t\tlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\n\t\tconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\n\t\tif (!intfc)\n\t\t\treturn -ENOMEM;\n\t\tkref_init(&intfc->ref);\n\t}\n\n\t/* FIXME: parse the BOS descriptor */\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first interface descriptor */\n\tconfig->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, &n);\n\tconfig->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"configuration\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Parse all the interface/altsetting descriptors */\n\twhile (size > 0) {\n\t\tretval = usb_parse_interface(ddev, cfgno, config,\n\t\t    buffer, size, inums, nalts);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\t/* Check for missing altsettings */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tintfc = config->intf_cache[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\tfor (n = 0; n < intfc->num_altsetting; ++n) {\n\t\t\t\tif (intfc->altsetting[n].desc.\n\t\t\t\t    bAlternateSetting == j)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= intfc->num_altsetting)\n\t\t\t\tdev_warn(ddev, \"config %d interface %d has no \"\n\t\t\t\t    \"altsetting %d\\n\", cfgno, inums[i], j);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* hub-only!! ... and only exported for reset/reinit path.\n * otherwise used internally on disconnect/destroy path\n */\nvoid usb_destroy_configuration(struct usb_device *dev)\n{\n\tint c, i;\n\n\tif (!dev->config)\n\t\treturn;\n\n\tif (dev->rawdescriptors) {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++)\n\t\t\tkfree(dev->rawdescriptors[i]);\n\n\t\tkfree(dev->rawdescriptors);\n\t\tdev->rawdescriptors = NULL;\n\t}\n\n\tfor (c = 0; c < dev->descriptor.bNumConfigurations; c++) {\n\t\tstruct usb_host_config *cf = &dev->config[c];\n\n\t\tkfree(cf->string);\n\t\tfor (i = 0; i < cf->desc.bNumInterfaces; i++) {\n\t\t\tif (cf->intf_cache[i])\n\t\t\t\tkref_put(&cf->intf_cache[i]->ref,\n\t\t\t\t\t  usb_release_interface_cache);\n\t\t}\n\t}\n\tkfree(dev->config);\n\tdev->config = NULL;\n}\n\n\n/*\n * Get the USB config descriptors, cache and parse'em\n *\n * hub-only!! ... and only in reset path, or usb_new_device()\n * (used by real hubs and virtual root hubs)\n */\nint usb_get_configuration(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tint ncfg = dev->descriptor.bNumConfigurations;\n\tint result = 0;\n\tunsigned int cfgno, length;\n\tunsigned char *bigbuffer;\n\tstruct usb_config_descriptor *desc;\n\n\tcfgno = 0;\n\tresult = -ENOMEM;\n\tif (ncfg > USB_MAXCONFIG) {\n\t\tdev_warn(ddev, \"too many configurations: %d, \"\n\t\t    \"using maximum allowed: %d\\n\", ncfg, USB_MAXCONFIG);\n\t\tdev->descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;\n\t}\n\n\tif (ncfg < 1) {\n\t\tdev_err(ddev, \"no configurations\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlength = ncfg * sizeof(struct usb_host_config);\n\tdev->config = kzalloc(length, GFP_KERNEL);\n\tif (!dev->config)\n\t\tgoto err2;\n\n\tlength = ncfg * sizeof(char *);\n\tdev->rawdescriptors = kzalloc(length, GFP_KERNEL);\n\tif (!dev->rawdescriptors)\n\t\tgoto err2;\n\n\tdesc = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\tgoto err2;\n\n\tresult = 0;\n\tfor (; cfgno < ncfg; cfgno++) {\n\t\t/* We grab just the first descriptor so we know how long\n\t\t * the whole configuration is */\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    desc, USB_DT_CONFIG_SIZE);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s: %d\\n\", cfgno, \"start\", result);\n\t\t\tif (result != -EPIPE)\n\t\t\t\tgoto err;\n\t\t\tdev_err(ddev, \"chopping to %d config(s)\\n\", cfgno);\n\t\t\tdev->descriptor.bNumConfigurations = cfgno;\n\t\t\tbreak;\n\t\t} else if (result < 4) {\n\t\t\tdev_err(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno,\n\t\t\t    USB_DT_CONFIG_SIZE, result);\n\t\t\tresult = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tlength = max((int) le16_to_cpu(desc->wTotalLength),\n\t\t    USB_DT_CONFIG_SIZE);\n\n\t\t/* Now that we know the length, get the whole thing */\n\t\tbigbuffer = kmalloc(length, GFP_KERNEL);\n\t\tif (!bigbuffer) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(200);\n\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s\\n\", cfgno, \"all\");\n\t\t\tkfree(bigbuffer);\n\t\t\tgoto err;\n\t\t}\n\t\tif (result < length) {\n\t\t\tdev_warn(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno, length, result);\n\t\t\tlength = result;\n\t\t}\n\n\t\tdev->rawdescriptors[cfgno] = bigbuffer;\n\n\t\tresult = usb_parse_configuration(dev, cfgno,\n\t\t    &dev->config[cfgno], bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\t++cfgno;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tresult = 0;\n\nerr:\n\tkfree(desc);\n\tdev->descriptor.bNumConfigurations = cfgno;\nerr2:\n\tif (result == -ENOMEM)\n\t\tdev_err(ddev, \"out of memory\\n\");\n\treturn result;\n}\n\nvoid usb_release_bos_descriptor(struct usb_device *dev)\n{\n\tif (dev->bos) {\n\t\tkfree(dev->bos->desc);\n\t\tkfree(dev->bos);\n\t\tdev->bos = NULL;\n\t}\n}\n\n/* Get BOS descriptor set */\nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tunsigned char *buffer;\n\tint length, total_len, num, i;\n\tint ret;\n\n\tbos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t/* Get BOS descriptor */\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t/* Now let's get the whole BOS descriptor set */\n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_err(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\ttotal_len -= length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tbuffer += length;\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\t\tlength = cap->bLength;\n\n\t\tif (total_len < length)\n\t\t\tbreak;\n\t\ttotal_len -= length;\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_warn(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (cap->bDevCapabilityType) {\n\t\tcase USB_CAP_TYPE_WIRELESS_USB:\n\t\t\t/* Wireless USB cap descriptor is handled by wusb */\n\t\t\tbreak;\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tdev->bos->ssp_cap =\n\t\t\t\t(struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\n", "/*\n * This file holds USB constants and structures that are needed for\n * USB device APIs.  These are used by the USB device model, which is\n * defined in chapter 9 of the USB 2.0 specification and in the\n * Wireless USB 1.0 (spread around).  Linux has several APIs in C that\n * need these:\n *\n * - the master/host side Linux-USB kernel driver API;\n * - the \"usbfs\" user space API; and\n * - the Linux \"gadget\" slave/device/peripheral side driver API.\n *\n * USB 2.0 adds an additional \"On The Go\" (OTG) mode, which lets systems\n * act either as a USB master/host or as a USB slave/device.  That means\n * the master and slave side APIs benefit from working well together.\n *\n * There's also \"Wireless USB\", using low power short range radios for\n * peripheral interconnection but otherwise building on the USB framework.\n *\n * Note all descriptors are declared '__attribute__((packed))' so that:\n *\n * [a] they never get padded, either internally (USB spec writers\n *     probably handled that) or externally;\n *\n * [b] so that accessing bigger-than-a-bytes fields will never\n *     generate bus errors on any platform, even when the location of\n *     its descriptor inside a bundle isn't \"naturally aligned\", and\n *\n * [c] for consistency, removing all doubt even when it appears to\n *     someone that the two other points are non-issues for that\n *     particular descriptor type.\n */\n\n#ifndef _UAPI__LINUX_USB_CH9_H\n#define _UAPI__LINUX_USB_CH9_H\n\n#include <linux/types.h>\t/* __u8 etc */\n#include <asm/byteorder.h>\t/* le16_to_cpu */\n\n/*-------------------------------------------------------------------------*/\n\n/* CONTROL REQUEST SUPPORT */\n\n/*\n * USB directions\n *\n * This bit flag is used in endpoint descriptors' bEndpointAddress field.\n * It's also one of three fields in control requests bRequestType.\n */\n#define USB_DIR_OUT\t\t\t0\t\t/* to device */\n#define USB_DIR_IN\t\t\t0x80\t\t/* to host */\n\n/*\n * USB types, the second of three bRequestType fields\n */\n#define USB_TYPE_MASK\t\t\t(0x03 << 5)\n#define USB_TYPE_STANDARD\t\t(0x00 << 5)\n#define USB_TYPE_CLASS\t\t\t(0x01 << 5)\n#define USB_TYPE_VENDOR\t\t\t(0x02 << 5)\n#define USB_TYPE_RESERVED\t\t(0x03 << 5)\n\n/*\n * USB recipients, the third of three bRequestType fields\n */\n#define USB_RECIP_MASK\t\t\t0x1f\n#define USB_RECIP_DEVICE\t\t0x00\n#define USB_RECIP_INTERFACE\t\t0x01\n#define USB_RECIP_ENDPOINT\t\t0x02\n#define USB_RECIP_OTHER\t\t\t0x03\n/* From Wireless USB 1.0 */\n#define USB_RECIP_PORT\t\t\t0x04\n#define USB_RECIP_RPIPE\t\t0x05\n\n/*\n * Standard requests, for the bRequest field of a SETUP packet.\n *\n * These are qualified by the bRequestType field, so that for example\n * TYPE_CLASS or TYPE_VENDOR specific feature flags could be retrieved\n * by a GET_STATUS request.\n */\n#define USB_REQ_GET_STATUS\t\t0x00\n#define USB_REQ_CLEAR_FEATURE\t\t0x01\n#define USB_REQ_SET_FEATURE\t\t0x03\n#define USB_REQ_SET_ADDRESS\t\t0x05\n#define USB_REQ_GET_DESCRIPTOR\t\t0x06\n#define USB_REQ_SET_DESCRIPTOR\t\t0x07\n#define USB_REQ_GET_CONFIGURATION\t0x08\n#define USB_REQ_SET_CONFIGURATION\t0x09\n#define USB_REQ_GET_INTERFACE\t\t0x0A\n#define USB_REQ_SET_INTERFACE\t\t0x0B\n#define USB_REQ_SYNCH_FRAME\t\t0x0C\n#define USB_REQ_SET_SEL\t\t\t0x30\n#define USB_REQ_SET_ISOCH_DELAY\t\t0x31\n\n#define USB_REQ_SET_ENCRYPTION\t\t0x0D\t/* Wireless USB */\n#define USB_REQ_GET_ENCRYPTION\t\t0x0E\n#define USB_REQ_RPIPE_ABORT\t\t0x0E\n#define USB_REQ_SET_HANDSHAKE\t\t0x0F\n#define USB_REQ_RPIPE_RESET\t\t0x0F\n#define USB_REQ_GET_HANDSHAKE\t\t0x10\n#define USB_REQ_SET_CONNECTION\t\t0x11\n#define USB_REQ_SET_SECURITY_DATA\t0x12\n#define USB_REQ_GET_SECURITY_DATA\t0x13\n#define USB_REQ_SET_WUSB_DATA\t\t0x14\n#define USB_REQ_LOOPBACK_DATA_WRITE\t0x15\n#define USB_REQ_LOOPBACK_DATA_READ\t0x16\n#define USB_REQ_SET_INTERFACE_DS\t0x17\n\n/* specific requests for USB Power Delivery */\n#define USB_REQ_GET_PARTNER_PDO\t\t20\n#define USB_REQ_GET_BATTERY_STATUS\t21\n#define USB_REQ_SET_PDO\t\t\t22\n#define USB_REQ_GET_VDM\t\t\t23\n#define USB_REQ_SEND_VDM\t\t24\n\n/* The Link Power Management (LPM) ECN defines USB_REQ_TEST_AND_SET command,\n * used by hubs to put ports into a new L1 suspend state, except that it\n * forgot to define its number ...\n */\n\n/*\n * USB feature flags are written using USB_REQ_{CLEAR,SET}_FEATURE, and\n * are read as a bit array returned by USB_REQ_GET_STATUS.  (So there\n * are at most sixteen features of each type.)  Hubs may also support a\n * new USB_REQ_TEST_AND_SET_FEATURE to put ports into L1 suspend.\n */\n#define USB_DEVICE_SELF_POWERED\t\t0\t/* (read only) */\n#define USB_DEVICE_REMOTE_WAKEUP\t1\t/* dev may initiate wakeup */\n#define USB_DEVICE_TEST_MODE\t\t2\t/* (wired high speed only) */\n#define USB_DEVICE_BATTERY\t\t2\t/* (wireless) */\n#define USB_DEVICE_B_HNP_ENABLE\t\t3\t/* (otg) dev may initiate HNP */\n#define USB_DEVICE_WUSB_DEVICE\t\t3\t/* (wireless)*/\n#define USB_DEVICE_A_HNP_SUPPORT\t4\t/* (otg) RH port supports HNP */\n#define USB_DEVICE_A_ALT_HNP_SUPPORT\t5\t/* (otg) other RH port does */\n#define USB_DEVICE_DEBUG_MODE\t\t6\t/* (special devices only) */\n\n/*\n * Test Mode Selectors\n * See USB 2.0 spec Table 9-7\n */\n#define\tTEST_J\t\t1\n#define\tTEST_K\t\t2\n#define\tTEST_SE0_NAK\t3\n#define\tTEST_PACKET\t4\n#define\tTEST_FORCE_EN\t5\n\n/*\n * New Feature Selectors as added by USB 3.0\n * See USB 3.0 spec Table 9-7\n */\n#define USB_DEVICE_U1_ENABLE\t48\t/* dev may initiate U1 transition */\n#define USB_DEVICE_U2_ENABLE\t49\t/* dev may initiate U2 transition */\n#define USB_DEVICE_LTM_ENABLE\t50\t/* dev may send LTM */\n#define USB_INTRF_FUNC_SUSPEND\t0\t/* function suspend */\n\n#define USB_INTR_FUNC_SUSPEND_OPT_MASK\t0xFF00\n/*\n * Suspend Options, Table 9-8 USB 3.0 spec\n */\n#define USB_INTRF_FUNC_SUSPEND_LP\t(1 << (8 + 0))\n#define USB_INTRF_FUNC_SUSPEND_RW\t(1 << (8 + 1))\n\n/*\n * Interface status, Figure 9-5 USB 3.0 spec\n */\n#define USB_INTRF_STAT_FUNC_RW_CAP     1\n#define USB_INTRF_STAT_FUNC_RW         2\n\n#define USB_ENDPOINT_HALT\t\t0\t/* IN/OUT will STALL */\n\n/* Bit array elements as returned by the USB_REQ_GET_STATUS request. */\n#define USB_DEV_STAT_U1_ENABLED\t\t2\t/* transition into U1 state */\n#define USB_DEV_STAT_U2_ENABLED\t\t3\t/* transition into U2 state */\n#define USB_DEV_STAT_LTM_ENABLED\t4\t/* Latency tolerance messages */\n\n/*\n * Feature selectors from Table 9-8 USB Power Delivery spec\n */\n#define USB_DEVICE_BATTERY_WAKE_MASK\t40\n#define USB_DEVICE_OS_IS_PD_AWARE\t41\n#define USB_DEVICE_POLICY_MODE\t\t42\n#define USB_PORT_PR_SWAP\t\t43\n#define USB_PORT_GOTO_MIN\t\t44\n#define USB_PORT_RETURN_POWER\t\t45\n#define USB_PORT_ACCEPT_PD_REQUEST\t46\n#define USB_PORT_REJECT_PD_REQUEST\t47\n#define USB_PORT_PORT_PD_RESET\t\t48\n#define USB_PORT_C_PORT_PD_CHANGE\t49\n#define USB_PORT_CABLE_PD_RESET\t\t50\n#define USB_DEVICE_CHARGING_POLICY\t54\n\n/**\n * struct usb_ctrlrequest - SETUP data for a USB device control request\n * @bRequestType: matches the USB bmRequestType field\n * @bRequest: matches the USB bRequest field\n * @wValue: matches the USB wValue field (le16 byte order)\n * @wIndex: matches the USB wIndex field (le16 byte order)\n * @wLength: matches the USB wLength field (le16 byte order)\n *\n * This structure is used to send control requests to a USB device.  It matches\n * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the\n * USB spec for a fuller description of the different fields, and what they are\n * used for.\n *\n * Note that the driver for any interface can issue control requests.\n * For most devices, interfaces don't coordinate with each other, so\n * such requests may be made at any time.\n */\nstruct usb_ctrlrequest {\n\t__u8 bRequestType;\n\t__u8 bRequest;\n\t__le16 wValue;\n\t__le16 wIndex;\n\t__le16 wLength;\n} __attribute__ ((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/*\n * STANDARD DESCRIPTORS ... as returned by GET_DESCRIPTOR, or\n * (rarely) accepted by SET_DESCRIPTOR.\n *\n * Note that all multi-byte values here are encoded in little endian\n * byte order \"on the wire\".  Within the kernel and when exposed\n * through the Linux-USB APIs, they are not converted to cpu byte\n * order; it is the responsibility of the client code to do this.\n * The single exception is when device and configuration descriptors (but\n * not other descriptors) are read from character devices\n * (i.e. /dev/bus/usb/BBB/DDD);\n * in this case the fields are converted to host endianness by the kernel.\n */\n\n/*\n * Descriptor types ... USB 2.0 spec table 9.5\n */\n#define USB_DT_DEVICE\t\t\t0x01\n#define USB_DT_CONFIG\t\t\t0x02\n#define USB_DT_STRING\t\t\t0x03\n#define USB_DT_INTERFACE\t\t0x04\n#define USB_DT_ENDPOINT\t\t\t0x05\n#define USB_DT_DEVICE_QUALIFIER\t\t0x06\n#define USB_DT_OTHER_SPEED_CONFIG\t0x07\n#define USB_DT_INTERFACE_POWER\t\t0x08\n/* these are from a minor usb 2.0 revision (ECN) */\n#define USB_DT_OTG\t\t\t0x09\n#define USB_DT_DEBUG\t\t\t0x0a\n#define USB_DT_INTERFACE_ASSOCIATION\t0x0b\n/* these are from the Wireless USB spec */\n#define USB_DT_SECURITY\t\t\t0x0c\n#define USB_DT_KEY\t\t\t0x0d\n#define USB_DT_ENCRYPTION_TYPE\t\t0x0e\n#define USB_DT_BOS\t\t\t0x0f\n#define USB_DT_DEVICE_CAPABILITY\t0x10\n#define USB_DT_WIRELESS_ENDPOINT_COMP\t0x11\n#define USB_DT_WIRE_ADAPTER\t\t0x21\n#define USB_DT_RPIPE\t\t\t0x22\n#define USB_DT_CS_RADIO_CONTROL\t\t0x23\n/* From the T10 UAS specification */\n#define USB_DT_PIPE_USAGE\t\t0x24\n/* From the USB 3.0 spec */\n#define\tUSB_DT_SS_ENDPOINT_COMP\t\t0x30\n/* From the USB 3.1 spec */\n#define\tUSB_DT_SSP_ISOC_ENDPOINT_COMP\t0x31\n\n/* Conventional codes for class-specific descriptors.  The convention is\n * defined in the USB \"Common Class\" Spec (3.11).  Individual class specs\n * are authoritative for their usage, not the \"common class\" writeup.\n */\n#define USB_DT_CS_DEVICE\t\t(USB_TYPE_CLASS | USB_DT_DEVICE)\n#define USB_DT_CS_CONFIG\t\t(USB_TYPE_CLASS | USB_DT_CONFIG)\n#define USB_DT_CS_STRING\t\t(USB_TYPE_CLASS | USB_DT_STRING)\n#define USB_DT_CS_INTERFACE\t\t(USB_TYPE_CLASS | USB_DT_INTERFACE)\n#define USB_DT_CS_ENDPOINT\t\t(USB_TYPE_CLASS | USB_DT_ENDPOINT)\n\n/* All standard descriptors have these 2 fields at the beginning */\nstruct usb_descriptor_header {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n} __attribute__ ((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEVICE: Device descriptor */\nstruct usb_device_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 bcdUSB;\n\t__u8  bDeviceClass;\n\t__u8  bDeviceSubClass;\n\t__u8  bDeviceProtocol;\n\t__u8  bMaxPacketSize0;\n\t__le16 idVendor;\n\t__le16 idProduct;\n\t__le16 bcdDevice;\n\t__u8  iManufacturer;\n\t__u8  iProduct;\n\t__u8  iSerialNumber;\n\t__u8  bNumConfigurations;\n} __attribute__ ((packed));\n\n#define USB_DT_DEVICE_SIZE\t\t18\n\n\n/*\n * Device and/or Interface Class codes\n * as found in bDeviceClass or bInterfaceClass\n * and defined by www.usb.org documents\n */\n#define USB_CLASS_PER_INTERFACE\t\t0\t/* for DeviceClass */\n#define USB_CLASS_AUDIO\t\t\t1\n#define USB_CLASS_COMM\t\t\t2\n#define USB_CLASS_HID\t\t\t3\n#define USB_CLASS_PHYSICAL\t\t5\n#define USB_CLASS_STILL_IMAGE\t\t6\n#define USB_CLASS_PRINTER\t\t7\n#define USB_CLASS_MASS_STORAGE\t\t8\n#define USB_CLASS_HUB\t\t\t9\n#define USB_CLASS_CDC_DATA\t\t0x0a\n#define USB_CLASS_CSCID\t\t\t0x0b\t/* chip+ smart card */\n#define USB_CLASS_CONTENT_SEC\t\t0x0d\t/* content security */\n#define USB_CLASS_VIDEO\t\t\t0x0e\n#define USB_CLASS_WIRELESS_CONTROLLER\t0xe0\n#define USB_CLASS_MISC\t\t\t0xef\n#define USB_CLASS_APP_SPEC\t\t0xfe\n#define USB_CLASS_VENDOR_SPEC\t\t0xff\n\n#define USB_SUBCLASS_VENDOR_SPEC\t0xff\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_CONFIG: Configuration descriptor information.\n *\n * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the\n * descriptor type is different.  Highspeed-capable devices can look\n * different depending on what speed they're currently running.  Only\n * devices with a USB_DT_DEVICE_QUALIFIER have any OTHER_SPEED_CONFIG\n * descriptors.\n */\nstruct usb_config_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wTotalLength;\n\t__u8  bNumInterfaces;\n\t__u8  bConfigurationValue;\n\t__u8  iConfiguration;\n\t__u8  bmAttributes;\n\t__u8  bMaxPower;\n} __attribute__ ((packed));\n\n#define USB_DT_CONFIG_SIZE\t\t9\n\n/* from config descriptor bmAttributes */\n#define USB_CONFIG_ATT_ONE\t\t(1 << 7)\t/* must be set */\n#define USB_CONFIG_ATT_SELFPOWER\t(1 << 6)\t/* self powered */\n#define USB_CONFIG_ATT_WAKEUP\t\t(1 << 5)\t/* can wakeup */\n#define USB_CONFIG_ATT_BATTERY\t\t(1 << 4)\t/* battery powered */\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_STRING: String descriptor */\nstruct usb_string_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wData[1];\t\t/* UTF-16LE encoded */\n} __attribute__ ((packed));\n\n/* note that \"string\" zero is special, it holds language codes that\n * the device supports, not Unicode characters.\n */\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_INTERFACE: Interface descriptor */\nstruct usb_interface_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bInterfaceNumber;\n\t__u8  bAlternateSetting;\n\t__u8  bNumEndpoints;\n\t__u8  bInterfaceClass;\n\t__u8  bInterfaceSubClass;\n\t__u8  bInterfaceProtocol;\n\t__u8  iInterface;\n} __attribute__ ((packed));\n\n#define USB_DT_INTERFACE_SIZE\t\t9\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_ENDPOINT: Endpoint descriptor */\nstruct usb_endpoint_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bEndpointAddress;\n\t__u8  bmAttributes;\n\t__le16 wMaxPacketSize;\n\t__u8  bInterval;\n\n\t/* NOTE:  these two are _only_ in audio endpoints. */\n\t/* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. */\n\t__u8  bRefresh;\n\t__u8  bSynchAddress;\n} __attribute__ ((packed));\n\n#define USB_DT_ENDPOINT_SIZE\t\t7\n#define USB_DT_ENDPOINT_AUDIO_SIZE\t9\t/* Audio extension */\n\n\n/*\n * Endpoints\n */\n#define USB_ENDPOINT_NUMBER_MASK\t0x0f\t/* in bEndpointAddress */\n#define USB_ENDPOINT_DIR_MASK\t\t0x80\n\n#define USB_ENDPOINT_XFERTYPE_MASK\t0x03\t/* in bmAttributes */\n#define USB_ENDPOINT_XFER_CONTROL\t0\n#define USB_ENDPOINT_XFER_ISOC\t\t1\n#define USB_ENDPOINT_XFER_BULK\t\t2\n#define USB_ENDPOINT_XFER_INT\t\t3\n#define USB_ENDPOINT_MAX_ADJUSTABLE\t0x80\n\n#define USB_ENDPOINT_MAXP_MASK\t0x07ff\n#define USB_EP_MAXP_MULT_SHIFT\t11\n#define USB_EP_MAXP_MULT_MASK\t(3 << USB_EP_MAXP_MULT_SHIFT)\n#define USB_EP_MAXP_MULT(m) \\\n\t(((m) & USB_EP_MAXP_MULT_MASK) >> USB_EP_MAXP_MULT_SHIFT)\n\n/* The USB 3.0 spec redefines bits 5:4 of bmAttributes as interrupt ep type. */\n#define USB_ENDPOINT_INTRTYPE\t\t0x30\n#define USB_ENDPOINT_INTR_PERIODIC\t(0 << 4)\n#define USB_ENDPOINT_INTR_NOTIFICATION\t(1 << 4)\n\n#define USB_ENDPOINT_SYNCTYPE\t\t0x0c\n#define USB_ENDPOINT_SYNC_NONE\t\t(0 << 2)\n#define USB_ENDPOINT_SYNC_ASYNC\t\t(1 << 2)\n#define USB_ENDPOINT_SYNC_ADAPTIVE\t(2 << 2)\n#define USB_ENDPOINT_SYNC_SYNC\t\t(3 << 2)\n\n#define USB_ENDPOINT_USAGE_MASK\t\t0x30\n#define USB_ENDPOINT_USAGE_DATA\t\t0x00\n#define USB_ENDPOINT_USAGE_FEEDBACK\t0x10\n#define USB_ENDPOINT_USAGE_IMPLICIT_FB\t0x20\t/* Implicit feedback Data endpoint */\n\n/*-------------------------------------------------------------------------*/\n\n/**\n * usb_endpoint_num - get the endpoint's number\n * @epd: endpoint to be checked\n *\n * Returns @epd's number: 0 to 15.\n */\nstatic inline int usb_endpoint_num(const struct usb_endpoint_descriptor *epd)\n{\n\treturn epd->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;\n}\n\n/**\n * usb_endpoint_type - get the endpoint's transfer type\n * @epd: endpoint to be checked\n *\n * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according\n * to @epd's transfer type.\n */\nstatic inline int usb_endpoint_type(const struct usb_endpoint_descriptor *epd)\n{\n\treturn epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n}\n\n/**\n * usb_endpoint_dir_in - check if the endpoint has IN direction\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type IN, otherwise it returns false.\n */\nstatic inline int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);\n}\n\n/**\n * usb_endpoint_dir_out - check if the endpoint has OUT direction\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type OUT, otherwise it returns false.\n */\nstatic inline int usb_endpoint_dir_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);\n}\n\n/**\n * usb_endpoint_xfer_bulk - check if the endpoint has bulk transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type bulk, otherwise it returns false.\n */\nstatic inline int usb_endpoint_xfer_bulk(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_BULK);\n}\n\n/**\n * usb_endpoint_xfer_control - check if the endpoint has control transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type control, otherwise it returns false.\n */\nstatic inline int usb_endpoint_xfer_control(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_CONTROL);\n}\n\n/**\n * usb_endpoint_xfer_int - check if the endpoint has interrupt transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type interrupt, otherwise it returns\n * false.\n */\nstatic inline int usb_endpoint_xfer_int(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_INT);\n}\n\n/**\n * usb_endpoint_xfer_isoc - check if the endpoint has isochronous transfer type\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint is of type isochronous, otherwise it returns\n * false.\n */\nstatic inline int usb_endpoint_xfer_isoc(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\tUSB_ENDPOINT_XFER_ISOC);\n}\n\n/**\n * usb_endpoint_is_bulk_in - check if the endpoint is bulk IN\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has bulk transfer type and IN direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_bulk_in(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_in(epd);\n}\n\n/**\n * usb_endpoint_is_bulk_out - check if the endpoint is bulk OUT\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has bulk transfer type and OUT direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_bulk_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_out(epd);\n}\n\n/**\n * usb_endpoint_is_int_in - check if the endpoint is interrupt IN\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has interrupt transfer type and IN direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_int_in(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_int(epd) && usb_endpoint_dir_in(epd);\n}\n\n/**\n * usb_endpoint_is_int_out - check if the endpoint is interrupt OUT\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has interrupt transfer type and OUT direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_int_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_int(epd) && usb_endpoint_dir_out(epd);\n}\n\n/**\n * usb_endpoint_is_isoc_in - check if the endpoint is isochronous IN\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has isochronous transfer type and IN direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_isoc_in(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_in(epd);\n}\n\n/**\n * usb_endpoint_is_isoc_out - check if the endpoint is isochronous OUT\n * @epd: endpoint to be checked\n *\n * Returns true if the endpoint has isochronous transfer type and OUT direction,\n * otherwise it returns false.\n */\nstatic inline int usb_endpoint_is_isoc_out(\n\t\t\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_out(epd);\n}\n\n/**\n * usb_endpoint_maxp - get endpoint's max packet size\n * @epd: endpoint to be checked\n *\n * Returns @epd's max packet bits [10:0]\n */\nstatic inline int usb_endpoint_maxp(const struct usb_endpoint_descriptor *epd)\n{\n\treturn __le16_to_cpu(epd->wMaxPacketSize) & USB_ENDPOINT_MAXP_MASK;\n}\n\n/**\n * usb_endpoint_maxp_mult - get endpoint's transactional opportunities\n * @epd: endpoint to be checked\n *\n * Return @epd's wMaxPacketSize[12:11] + 1\n */\nstatic inline int\nusb_endpoint_maxp_mult(const struct usb_endpoint_descriptor *epd)\n{\n\tint maxp = __le16_to_cpu(epd->wMaxPacketSize);\n\n\treturn USB_EP_MAXP_MULT(maxp) + 1;\n}\n\nstatic inline int usb_endpoint_interrupt_type(\n\t\tconst struct usb_endpoint_descriptor *epd)\n{\n\treturn epd->bmAttributes & USB_ENDPOINT_INTRTYPE;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_SSP_ISOC_ENDPOINT_COMP: SuperSpeedPlus Isochronous Endpoint Companion\n * descriptor\n */\nstruct usb_ssp_isoc_ep_comp_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__le16 wReseved;\n\t__le32 dwBytesPerInterval;\n} __attribute__ ((packed));\n\n#define USB_DT_SSP_ISOC_EP_COMP_SIZE\t\t8\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_SS_ENDPOINT_COMP: SuperSpeed Endpoint Companion descriptor */\nstruct usb_ss_ep_comp_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bMaxBurst;\n\t__u8  bmAttributes;\n\t__le16 wBytesPerInterval;\n} __attribute__ ((packed));\n\n#define USB_DT_SS_EP_COMP_SIZE\t\t6\n\n/* Bits 4:0 of bmAttributes if this is a bulk endpoint */\nstatic inline int\nusb_ss_max_streams(const struct usb_ss_ep_comp_descriptor *comp)\n{\n\tint\t\tmax_streams;\n\n\tif (!comp)\n\t\treturn 0;\n\n\tmax_streams = comp->bmAttributes & 0x1f;\n\n\tif (!max_streams)\n\t\treturn 0;\n\n\tmax_streams = 1 << max_streams;\n\n\treturn max_streams;\n}\n\n/* Bits 1:0 of bmAttributes if this is an isoc endpoint */\n#define USB_SS_MULT(p)\t\t\t(1 + ((p) & 0x3))\n/* Bit 7 of bmAttributes if a SSP isoc endpoint companion descriptor exists */\n#define USB_SS_SSP_ISOC_COMP(p)\t\t((p) & (1 << 7))\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEVICE_QUALIFIER: Device Qualifier descriptor */\nstruct usb_qualifier_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 bcdUSB;\n\t__u8  bDeviceClass;\n\t__u8  bDeviceSubClass;\n\t__u8  bDeviceProtocol;\n\t__u8  bMaxPacketSize0;\n\t__u8  bNumConfigurations;\n\t__u8  bRESERVED;\n} __attribute__ ((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_OTG (from OTG 1.0a supplement) */\nstruct usb_otg_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bmAttributes;\t/* support for HNP, SRP, etc */\n} __attribute__ ((packed));\n\n/* USB_DT_OTG (from OTG 2.0 supplement) */\nstruct usb_otg20_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bmAttributes;\t/* support for HNP, SRP and ADP, etc */\n\t__le16 bcdOTG;\t\t/* OTG and EH supplement release number\n\t\t\t\t * in binary-coded decimal(i.e. 2.0 is 0200H)\n\t\t\t\t */\n} __attribute__ ((packed));\n\n/* from usb_otg_descriptor.bmAttributes */\n#define USB_OTG_SRP\t\t(1 << 0)\n#define USB_OTG_HNP\t\t(1 << 1)\t/* swap host/device roles */\n#define USB_OTG_ADP\t\t(1 << 2)\t/* support ADP */\n\n#define OTG_STS_SELECTOR\t0xF000\t\t/* OTG status selector */\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEBUG:  for special highspeed devices, replacing serial console */\nstruct usb_debug_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t/* bulk endpoints with 8 byte maxpacket */\n\t__u8  bDebugInEndpoint;\n\t__u8  bDebugOutEndpoint;\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_INTERFACE_ASSOCIATION: groups interfaces */\nstruct usb_interface_assoc_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bFirstInterface;\n\t__u8  bInterfaceCount;\n\t__u8  bFunctionClass;\n\t__u8  bFunctionSubClass;\n\t__u8  bFunctionProtocol;\n\t__u8  iFunction;\n} __attribute__ ((packed));\n\n#define USB_DT_INTERFACE_ASSOCIATION_SIZE\t8\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_SECURITY:  group of wireless security descriptors, including\n * encryption types available for setting up a CC/association.\n */\nstruct usb_security_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wTotalLength;\n\t__u8  bNumEncryptionTypes;\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_KEY:  used with {GET,SET}_SECURITY_DATA; only public keys\n * may be retrieved.\n */\nstruct usb_key_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  tTKID[3];\n\t__u8  bReserved;\n\t__u8  bKeyData[0];\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_ENCRYPTION_TYPE:  bundled in DT_SECURITY groups */\nstruct usb_encryption_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bEncryptionType;\n#define\tUSB_ENC_TYPE_UNSECURE\t\t0\n#define\tUSB_ENC_TYPE_WIRED\t\t1\t/* non-wireless mode */\n#define\tUSB_ENC_TYPE_CCM_1\t\t2\t/* aes128/cbc session */\n#define\tUSB_ENC_TYPE_RSA_1\t\t3\t/* rsa3072/sha1 auth */\n\t__u8  bEncryptionValue;\t\t/* use in SET_ENCRYPTION */\n\t__u8  bAuthKeyIndex;\n} __attribute__((packed));\n\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_BOS:  group of device-level capabilities */\nstruct usb_bos_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__le16 wTotalLength;\n\t__u8  bNumDeviceCaps;\n} __attribute__((packed));\n\n#define USB_DT_BOS_SIZE\t\t5\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_DEVICE_CAPABILITY:  grouped with BOS */\nstruct usb_dev_cap_header {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n} __attribute__((packed));\n\n#define\tUSB_CAP_TYPE_WIRELESS_USB\t1\n\nstruct usb_wireless_cap_descriptor {\t/* Ultra Wide Band */\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\n\t__u8  bmAttributes;\n#define\tUSB_WIRELESS_P2P_DRD\t\t(1 << 1)\n#define\tUSB_WIRELESS_BEACON_MASK\t(3 << 2)\n#define\tUSB_WIRELESS_BEACON_SELF\t(1 << 2)\n#define\tUSB_WIRELESS_BEACON_DIRECTED\t(2 << 2)\n#define\tUSB_WIRELESS_BEACON_NONE\t(3 << 2)\n\t__le16 wPHYRates;\t/* bit rates, Mbps */\n#define\tUSB_WIRELESS_PHY_53\t\t(1 << 0)\t/* always set */\n#define\tUSB_WIRELESS_PHY_80\t\t(1 << 1)\n#define\tUSB_WIRELESS_PHY_107\t\t(1 << 2)\t/* always set */\n#define\tUSB_WIRELESS_PHY_160\t\t(1 << 3)\n#define\tUSB_WIRELESS_PHY_200\t\t(1 << 4)\t/* always set */\n#define\tUSB_WIRELESS_PHY_320\t\t(1 << 5)\n#define\tUSB_WIRELESS_PHY_400\t\t(1 << 6)\n#define\tUSB_WIRELESS_PHY_480\t\t(1 << 7)\n\t__u8  bmTFITXPowerInfo;\t/* TFI power levels */\n\t__u8  bmFFITXPowerInfo;\t/* FFI power levels */\n\t__le16 bmBandGroup;\n\t__u8  bReserved;\n} __attribute__((packed));\n\n/* USB 2.0 Extension descriptor */\n#define\tUSB_CAP_TYPE_EXT\t\t2\n\nstruct usb_ext_cap_descriptor {\t\t/* Link Power Management */\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__le32 bmAttributes;\n#define USB_LPM_SUPPORT\t\t\t(1 << 1)\t/* supports LPM */\n#define USB_BESL_SUPPORT\t\t(1 << 2)\t/* supports BESL */\n#define USB_BESL_BASELINE_VALID\t\t(1 << 3)\t/* Baseline BESL valid*/\n#define USB_BESL_DEEP_VALID\t\t(1 << 4)\t/* Deep BESL valid */\n#define USB_GET_BESL_BASELINE(p)\t(((p) & (0xf << 8)) >> 8)\n#define USB_GET_BESL_DEEP(p)\t\t(((p) & (0xf << 12)) >> 12)\n} __attribute__((packed));\n\n#define USB_DT_USB_EXT_CAP_SIZE\t7\n\n/*\n * SuperSpeed USB Capability descriptor: Defines the set of SuperSpeed USB\n * specific device level capabilities\n */\n#define\t\tUSB_SS_CAP_TYPE\t\t3\nstruct usb_ss_cap_descriptor {\t\t/* Link Power Management */\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__u8  bmAttributes;\n#define USB_LTM_SUPPORT\t\t\t(1 << 1) /* supports LTM */\n\t__le16 wSpeedSupported;\n#define USB_LOW_SPEED_OPERATION\t\t(1)\t /* Low speed operation */\n#define USB_FULL_SPEED_OPERATION\t(1 << 1) /* Full speed operation */\n#define USB_HIGH_SPEED_OPERATION\t(1 << 2) /* High speed operation */\n#define USB_5GBPS_OPERATION\t\t(1 << 3) /* Operation at 5Gbps */\n\t__u8  bFunctionalitySupport;\n\t__u8  bU1devExitLat;\n\t__le16 bU2DevExitLat;\n} __attribute__((packed));\n\n#define USB_DT_USB_SS_CAP_SIZE\t10\n\n/*\n * Container ID Capability descriptor: Defines the instance unique ID used to\n * identify the instance across all operating modes\n */\n#define\tCONTAINER_ID_TYPE\t4\nstruct usb_ss_container_id_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__u8  bReserved;\n\t__u8  ContainerID[16]; /* 128-bit number */\n} __attribute__((packed));\n\n#define USB_DT_USB_SS_CONTN_ID_SIZE\t20\n\n/*\n * SuperSpeed Plus USB Capability descriptor: Defines the set of\n * SuperSpeed Plus USB specific device level capabilities\n */\n#define\tUSB_SSP_CAP_TYPE\t0xa\nstruct usb_ssp_cap_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n\t__u8  bReserved;\n\t__le32 bmAttributes;\n#define USB_SSP_SUBLINK_SPEED_ATTRIBS\t(0x1f << 0) /* sublink speed entries */\n#define USB_SSP_SUBLINK_SPEED_IDS\t(0xf << 5)  /* speed ID entries */\n\t__le16  wFunctionalitySupport;\n#define USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID\t(0xf)\n#define USB_SSP_MIN_RX_LANE_COUNT\t\t(0xf << 8)\n#define USB_SSP_MIN_TX_LANE_COUNT\t\t(0xf << 12)\n\t__le16 wReserved;\n\t__le32 bmSublinkSpeedAttr[1]; /* list of sublink speed attrib entries */\n#define USB_SSP_SUBLINK_SPEED_SSID\t(0xf)\t\t/* sublink speed ID */\n#define USB_SSP_SUBLINK_SPEED_LSE\t(0x3 << 4)\t/* Lanespeed exponent */\n#define USB_SSP_SUBLINK_SPEED_ST\t(0x3 << 6)\t/* Sublink type */\n#define USB_SSP_SUBLINK_SPEED_RSVD\t(0x3f << 8)\t/* Reserved */\n#define USB_SSP_SUBLINK_SPEED_LP\t(0x3 << 14)\t/* Link protocol */\n#define USB_SSP_SUBLINK_SPEED_LSM\t(0xff << 16)\t/* Lanespeed mantissa */\n} __attribute__((packed));\n\n/*\n * USB Power Delivery Capability Descriptor:\n * Defines capabilities for PD\n */\n/* Defines the various PD Capabilities of this device */\n#define USB_PD_POWER_DELIVERY_CAPABILITY\t0x06\n/* Provides information on each battery supported by the device */\n#define USB_PD_BATTERY_INFO_CAPABILITY\t\t0x07\n/* The Consumer characteristics of a Port on the device */\n#define USB_PD_PD_CONSUMER_PORT_CAPABILITY\t0x08\n/* The provider characteristics of a Port on the device */\n#define USB_PD_PD_PROVIDER_PORT_CAPABILITY\t0x09\n\nstruct usb_pd_cap_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType; /* set to USB_PD_POWER_DELIVERY_CAPABILITY */\n\t__u8  bReserved;\n\t__le32 bmAttributes;\n#define USB_PD_CAP_BATTERY_CHARGING\t(1 << 1) /* supports Battery Charging specification */\n#define USB_PD_CAP_USB_PD\t\t(1 << 2) /* supports USB Power Delivery specification */\n#define USB_PD_CAP_PROVIDER\t\t(1 << 3) /* can provide power */\n#define USB_PD_CAP_CONSUMER\t\t(1 << 4) /* can consume power */\n#define USB_PD_CAP_CHARGING_POLICY\t(1 << 5) /* supports CHARGING_POLICY feature */\n#define USB_PD_CAP_TYPE_C_CURRENT\t(1 << 6) /* supports power capabilities defined in the USB Type-C Specification */\n\n#define USB_PD_CAP_PWR_AC\t\t(1 << 8)\n#define USB_PD_CAP_PWR_BAT\t\t(1 << 9)\n#define USB_PD_CAP_PWR_USE_V_BUS\t(1 << 14)\n\n\t__le16 bmProviderPorts; /* Bit zero refers to the UFP of the device */\n\t__le16 bmConsumerPorts;\n\t__le16 bcdBCVersion;\n\t__le16 bcdPDVersion;\n\t__le16 bcdUSBTypeCVersion;\n} __attribute__((packed));\n\nstruct usb_pd_cap_battery_info_descriptor {\n\t__u8 bLength;\n\t__u8 bDescriptorType;\n\t__u8 bDevCapabilityType;\n\t/* Index of string descriptor shall contain the user friendly name for this battery */\n\t__u8 iBattery;\n\t/* Index of string descriptor shall contain the Serial Number String for this battery */\n\t__u8 iSerial;\n\t__u8 iManufacturer;\n\t__u8 bBatteryId; /* uniquely identifies this battery in status Messages */\n\t__u8 bReserved;\n\t/*\n\t * Shall contain the Battery Charge value above which this\n\t * battery is considered to be fully charged but not necessarily\n\t * \u201ctopped off.\u201d\n\t */\n\t__le32 dwChargedThreshold; /* in mWh */\n\t/*\n\t * Shall contain the minimum charge level of this battery such\n\t * that above this threshold, a device can be assured of being\n\t * able to power up successfully (see Battery Charging 1.2).\n\t */\n\t__le32 dwWeakThreshold; /* in mWh */\n\t__le32 dwBatteryDesignCapacity; /* in mWh */\n\t__le32 dwBatteryLastFullchargeCapacity; /* in mWh */\n} __attribute__((packed));\n\nstruct usb_pd_cap_consumer_port_descriptor {\n\t__u8 bLength;\n\t__u8 bDescriptorType;\n\t__u8 bDevCapabilityType;\n\t__u8 bReserved;\n\t__u8 bmCapabilities;\n/* port will oerate under: */\n#define USB_PD_CAP_CONSUMER_BC\t\t(1 << 0) /* BC */\n#define USB_PD_CAP_CONSUMER_PD\t\t(1 << 1) /* PD */\n#define USB_PD_CAP_CONSUMER_TYPE_C\t(1 << 2) /* USB Type-C Current */\n\t__le16 wMinVoltage; /* in 50mV units */\n\t__le16 wMaxVoltage; /* in 50mV units */\n\t__u16 wReserved;\n\t__le32 dwMaxOperatingPower; /* in 10 mW - operating at steady state */\n\t__le32 dwMaxPeakPower; /* in 10mW units - operating at peak power */\n\t__le32 dwMaxPeakPowerTime; /* in 100ms units - duration of peak */\n#define USB_PD_CAP_CONSUMER_UNKNOWN_PEAK_POWER_TIME 0xffff\n} __attribute__((packed));\n\nstruct usb_pd_cap_provider_port_descriptor {\n\t__u8 bLength;\n\t__u8 bDescriptorType;\n\t__u8 bDevCapabilityType;\n\t__u8 bReserved1;\n\t__u8 bmCapabilities;\n/* port will oerate under: */\n#define USB_PD_CAP_PROVIDER_BC\t\t(1 << 0) /* BC */\n#define USB_PD_CAP_PROVIDER_PD\t\t(1 << 1) /* PD */\n#define USB_PD_CAP_PROVIDER_TYPE_C\t(1 << 2) /* USB Type-C Current */\n\t__u8 bNumOfPDObjects;\n\t__u8 bReserved2;\n\t__le32 wPowerDataObject[];\n} __attribute__((packed));\n\n/*\n * Precision time measurement capability descriptor: advertised by devices and\n * hubs that support PTM\n */\n#define\tUSB_PTM_CAP_TYPE\t0xb\nstruct usb_ptm_cap_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\t__u8  bDevCapabilityType;\n} __attribute__((packed));\n\n/*\n * The size of the descriptor for the Sublink Speed Attribute Count\n * (SSAC) specified in bmAttributes[4:0].\n */\n#define USB_DT_USB_SSP_CAP_SIZE(ssac)\t(16 + ssac * 4)\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_DT_WIRELESS_ENDPOINT_COMP:  companion descriptor associated with\n * each endpoint descriptor for a wireless device\n */\nstruct usb_wireless_ep_comp_descriptor {\n\t__u8  bLength;\n\t__u8  bDescriptorType;\n\n\t__u8  bMaxBurst;\n\t__u8  bMaxSequence;\n\t__le16 wMaxStreamDelay;\n\t__le16 wOverTheAirPacketSize;\n\t__u8  bOverTheAirInterval;\n\t__u8  bmCompAttributes;\n#define USB_ENDPOINT_SWITCH_MASK\t0x03\t/* in bmCompAttributes */\n#define USB_ENDPOINT_SWITCH_NO\t\t0\n#define USB_ENDPOINT_SWITCH_SWITCH\t1\n#define USB_ENDPOINT_SWITCH_SCALE\t2\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_REQ_SET_HANDSHAKE is a four-way handshake used between a wireless\n * host and a device for connection set up, mutual authentication, and\n * exchanging short lived session keys.  The handshake depends on a CC.\n */\nstruct usb_handshake {\n\t__u8 bMessageNumber;\n\t__u8 bStatus;\n\t__u8 tTKID[3];\n\t__u8 bReserved;\n\t__u8 CDID[16];\n\t__u8 nonce[16];\n\t__u8 MIC[8];\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB_REQ_SET_CONNECTION modifies or revokes a connection context (CC).\n * A CC may also be set up using non-wireless secure channels (including\n * wired USB!), and some devices may support CCs with multiple hosts.\n */\nstruct usb_connection_context {\n\t__u8 CHID[16];\t\t/* persistent host id */\n\t__u8 CDID[16];\t\t/* device id (unique w/in host context) */\n\t__u8 CK[16];\t\t/* connection key */\n} __attribute__((packed));\n\n/*-------------------------------------------------------------------------*/\n\n/* USB 2.0 defines three speeds, here's how Linux identifies them */\n\nenum usb_device_speed {\n\tUSB_SPEED_UNKNOWN = 0,\t\t\t/* enumerating */\n\tUSB_SPEED_LOW, USB_SPEED_FULL,\t\t/* usb 1.1 */\n\tUSB_SPEED_HIGH,\t\t\t\t/* usb 2.0 */\n\tUSB_SPEED_WIRELESS,\t\t\t/* wireless (usb 2.5) */\n\tUSB_SPEED_SUPER,\t\t\t/* usb 3.0 */\n\tUSB_SPEED_SUPER_PLUS,\t\t\t/* usb 3.1 */\n};\n\n\nenum usb_device_state {\n\t/* NOTATTACHED isn't in the USB spec, and this state acts\n\t * the same as ATTACHED ... but it's clearer this way.\n\t */\n\tUSB_STATE_NOTATTACHED = 0,\n\n\t/* chapter 9 and authentication (wireless) device states */\n\tUSB_STATE_ATTACHED,\n\tUSB_STATE_POWERED,\t\t\t/* wired */\n\tUSB_STATE_RECONNECTING,\t\t\t/* auth */\n\tUSB_STATE_UNAUTHENTICATED,\t\t/* auth */\n\tUSB_STATE_DEFAULT,\t\t\t/* limited function */\n\tUSB_STATE_ADDRESS,\n\tUSB_STATE_CONFIGURED,\t\t\t/* most functions */\n\n\tUSB_STATE_SUSPENDED\n\n\t/* NOTE:  there are actually four different SUSPENDED\n\t * states, returning to POWERED, DEFAULT, ADDRESS, or\n\t * CONFIGURED respectively when SOF tokens flow again.\n\t * At this level there's no difference between L1 and L2\n\t * suspend states.  (L2 being original USB 1.1 suspend.)\n\t */\n};\n\nenum usb3_link_state {\n\tUSB3_LPM_U0 = 0,\n\tUSB3_LPM_U1,\n\tUSB3_LPM_U2,\n\tUSB3_LPM_U3\n};\n\n/*\n * A U1 timeout of 0x0 means the parent hub will reject any transitions to U1.\n * 0xff means the parent hub will accept transitions to U1, but will not\n * initiate a transition.\n *\n * A U1 timeout of 0x1 to 0x7F also causes the hub to initiate a transition to\n * U1 after that many microseconds.  Timeouts of 0x80 to 0xFE are reserved\n * values.\n *\n * A U2 timeout of 0x0 means the parent hub will reject any transitions to U2.\n * 0xff means the parent hub will accept transitions to U2, but will not\n * initiate a transition.\n *\n * A U2 timeout of 0x1 to 0xFE also causes the hub to initiate a transition to\n * U2 after N*256 microseconds.  Therefore a U2 timeout value of 0x1 means a U2\n * idle timer of 256 microseconds, 0x2 means 512 microseconds, 0xFE means\n * 65.024ms.\n */\n#define USB3_LPM_DISABLED\t\t0x0\n#define USB3_LPM_U1_MAX_TIMEOUT\t\t0x7F\n#define USB3_LPM_U2_MAX_TIMEOUT\t\t0xFE\n#define USB3_LPM_DEVICE_INITIATED\t0xFF\n\nstruct usb_set_sel_req {\n\t__u8\tu1_sel;\n\t__u8\tu1_pel;\n\t__le16\tu2_sel;\n\t__le16\tu2_pel;\n} __attribute__ ((packed));\n\n/*\n * The Set System Exit Latency control transfer provides one byte each for\n * U1 SEL and U1 PEL, so the max exit latency is 0xFF.  U2 SEL and U2 PEL each\n * are two bytes long.\n */\n#define USB3_LPM_MAX_U1_SEL_PEL\t\t0xFF\n#define USB3_LPM_MAX_U2_SEL_PEL\t\t0xFFFF\n\n/*-------------------------------------------------------------------------*/\n\n/*\n * As per USB compliance update, a device that is actively drawing\n * more than 100mA from USB must report itself as bus-powered in\n * the GetStatus(DEVICE) call.\n * http://compliance.usb.org/index.asp?UpdateFile=Electrical&Format=Standard#34\n */\n#define USB_SELF_POWER_VBUS_MAX_DRAW\t\t100\n\n#endif /* _UAPI__LINUX_USB_CH9_H */\n"], "filenames": ["drivers/usb/core/config.c", "include/uapi/linux/usb/ch9.h"], "buggy_code_start_loc": [645, 782], "buggy_code_end_loc": [655, 782], "fixing_code_start_loc": [646, 783], "fixing_code_end_loc": [663, 784], "type": "CWE-119", "message": "drivers/usb/core/config.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device, related to the USB_DT_INTERFACE_ASSOCIATION descriptor.", "other": {"cve": {"id": "CVE-2017-16531", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:36.943", "lastModified": "2018-08-24T10:29:00.977", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "drivers/usb/core/config.c in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device, related to the USB_DT_INTERFACE_ASSOCIATION descriptor."}, {"lang": "es", "value": "drivers/usb/core/config.c en el kernel de Linux, en versiones anteriores a la 4.13.6, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas que utilizan un descriptor USB_DT_INTERFACE_ASSOCIATION."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.5", "matchCriteriaId": "8CBA5FF4-3406-4A63-9242-E6597219C011"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/102025", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/hP6L-m59m_8/Co2ouWeFAwAJ", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuoct2019-5072832.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bd7a3fe770ebd8391d1c7d072ff88e9e76d063eb"}}