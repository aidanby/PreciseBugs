{"buggy_code": ["/* auditsc.c -- System-call auditing support\n * Handles all system-call specific auditing features.\n *\n * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.\n * Copyright 2005 Hewlett-Packard Development Company, L.P.\n * Copyright (C) 2005, 2006 IBM Corporation\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Written by Rickard E. (Rik) Faith <faith@redhat.com>\n *\n * Many of the ideas implemented here are from Stephen C. Tweedie,\n * especially the idea of avoiding a copy by using getname.\n *\n * The method for actual interception of syscall entry and exit (not in\n * this file -- see entry.S) is based on a GPL'd patch written by\n * okir@suse.de and Copyright 2003 SuSE Linux AG.\n *\n * POSIX message queue support added by George Wilson <ltcgcw@us.ibm.com>,\n * 2006.\n *\n * The support of additional filter rules compares (>, <, >=, <=) was\n * added by Dustin Kirkland <dustin.kirkland@us.ibm.com>, 2005.\n *\n * Modified by Amy Griffis <amy.griffis@hp.com> to collect additional\n * filesystem information.\n *\n * Subject and object context labeling support added by <danjones@us.ibm.com>\n * and <dustin.kirkland@us.ibm.com> for LSPP certification compliance.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <asm/types.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/socket.h>\n#include <linux/mqueue.h>\n#include <linux/audit.h>\n#include <linux/personality.h>\n#include <linux/time.h>\n#include <linux/netlink.h>\n#include <linux/compiler.h>\n#include <asm/unistd.h>\n#include <linux/security.h>\n#include <linux/list.h>\n#include <linux/tty.h>\n#include <linux/binfmts.h>\n#include <linux/highmem.h>\n#include <linux/syscalls.h>\n#include <asm/syscall.h>\n#include <linux/capability.h>\n#include <linux/fs_struct.h>\n#include <linux/compat.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <uapi/linux/limits.h>\n\n#include \"audit.h\"\n\n/* flags stating the success for a syscall */\n#define AUDITSC_INVALID 0\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_FAILURE 2\n\n/* no execve audit message should be longer than this (userspace limits) */\n#define MAX_EXECVE_AUDIT_LEN 7500\n\n/* max length to print of cmdline/proctitle value during audit */\n#define MAX_PROCTITLE_AUDIT_LEN 128\n\n/* number of audit rules */\nint audit_n_rules;\n\n/* determines whether we collect data for signals sent */\nint audit_signals;\n\nstruct audit_aux_data {\n\tstruct audit_aux_data\t*next;\n\tint\t\t\ttype;\n};\n\n#define AUDIT_AUX_IPCPERM\t0\n\n/* Number of target pids per aux struct. */\n#define AUDIT_AUX_PIDS\t16\n\nstruct audit_aux_data_pids {\n\tstruct audit_aux_data\td;\n\tpid_t\t\t\ttarget_pid[AUDIT_AUX_PIDS];\n\tkuid_t\t\t\ttarget_auid[AUDIT_AUX_PIDS];\n\tkuid_t\t\t\ttarget_uid[AUDIT_AUX_PIDS];\n\tunsigned int\t\ttarget_sessionid[AUDIT_AUX_PIDS];\n\tu32\t\t\ttarget_sid[AUDIT_AUX_PIDS];\n\tchar \t\t\ttarget_comm[AUDIT_AUX_PIDS][TASK_COMM_LEN];\n\tint\t\t\tpid_count;\n};\n\nstruct audit_aux_data_bprm_fcaps {\n\tstruct audit_aux_data\td;\n\tstruct audit_cap_data\tfcap;\n\tunsigned int\t\tfcap_ver;\n\tstruct audit_cap_data\told_pcap;\n\tstruct audit_cap_data\tnew_pcap;\n};\n\nstruct audit_tree_refs {\n\tstruct audit_tree_refs *next;\n\tstruct audit_chunk *c[31];\n};\n\nstatic int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase 0:\t/* native */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 1: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 2: /* open */\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase 3: /* openat */\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase 4: /* socketcall */\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase 5: /* execve */\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * We keep a linked list of fixed-sized (31 pointer) arrays of audit_chunk *;\n * ->first_trees points to its beginning, ->trees - to the current end of data.\n * ->tree_count is the number of free entries in array pointed to by ->trees.\n * Original condition is (NULL, NULL, 0); as soon as it grows we never revert to NULL,\n * \"empty\" becomes (p, p, 31) afterwards.  We don't shrink the list (and seriously,\n * it's going to remain 1-element for almost any setup) until we free context itself.\n * References in it _are_ dropped - at the same time we free/drop aux stuff.\n */\n\n#ifdef CONFIG_AUDIT_TREE\nstatic void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n}\n\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}\n#endif\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}\n\nstatic void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}\n\nstatic int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *p;\n\tint n;\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(tsk->loginuid, name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, tsk->loginuid);\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(tsk->loginuid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(tsk->loginuid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(tsk->loginuid, f->op, cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n/* Determine if any context name data matches a rule's watch data */\n/* Compare a task_struct with an audit_rule.  Return 1 on match, 0\n * otherwise.\n *\n * If task_creation is true, this is an explicit indication that we are\n * filtering a task rule at task creation time.  This and tsk == current are\n * the only situations where tsk->cred may be accessed without an rcu read lock.\n */\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_pid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = in_group_p(f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !in_group_p(f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = in_egroup_p(f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !in_egroup_p(f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(tsk->loginuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\n/* At process creation time, we can determine if system-call auditing is\n * completely disabled for this task.  Since we only have the task\n * structure at this point, we can only check uid and gid.\n */\nstatic enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_RECORD_CONTEXT)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}\n\n/* At syscall entry and exit time, this filter is called if the\n * audit_state is not low enough that auditing cannot take place, but is\n * also not high enough that we already know we have to write an audit\n * record (i.e., the state is AUDIT_SETUP_CONTEXT or AUDIT_BUILD_CONTEXT).\n */\nstatic enum audit_state audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t\t     struct audit_context *ctx,\n\t\t\t\t\t     struct list_head *list)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (audit_pid && tsk->tgid == audit_pid)\n\t\treturn AUDIT_DISABLED;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t\t       &state, false)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tctx->current_state = state;\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}\n\n/*\n * Given an audit_name check the inode hash table to see if they match.\n * Called holding the rcu read lock to protect the use of audit_inode_hash\n */\nstatic int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (list_empty(list))\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* At syscall exit time, this filter is called if any audit_names have been\n * collected during syscall processing.  We only check rules in sublists at hash\n * buckets applicable to the inode numbers in audit_names.\n * Regarding audit_state, same rules apply as for audit_filter_syscall().\n */\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (audit_pid && tsk->tgid == audit_pid)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\n\n/* Transfer the audit context pointer to the caller, clearing it in the tsk's struct */\nstatic inline struct audit_context *audit_take_context(struct task_struct *tsk,\n\t\t\t\t\t\t      int return_valid,\n\t\t\t\t\t\t      long return_code)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn NULL;\n\tcontext->return_valid = return_valid;\n\n\t/*\n\t * we need to fix up the return code in the audit logs if the actual\n\t * return codes are later going to be fixed up by the arch specific\n\t * signal handlers\n\t *\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(return_code <= -ERESTARTSYS) &&\n\t    (return_code >= -ERESTART_RESTARTBLOCK) &&\n\t    (return_code != -ENOIOCTLCMD))\n\t\tcontext->return_code = -EINTR;\n\telse\n\t\tcontext->return_code  = return_code;\n\n\tif (context->in_syscall && !context->dummy) {\n\t\taudit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\n\t\taudit_filter_inodes(tsk, context);\n\t}\n\n\ttsk->audit_context = NULL;\n\treturn context;\n}\n\nstatic inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}\n\nstatic inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}\n\nstatic inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n}\n\nstatic inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\treturn context;\n}\n\n/**\n * audit_alloc - allocate an audit context block for a task\n * @tsk: task\n *\n * Filter on the task information and allocate a per-task audit context\n * if necessary.  Doing so turns on system call auditing for the\n * specified task.  This is called from copy_process, so no lock is\n * needed.\n */\nint audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0; /* Return if not auditing. */\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_DISABLED) {\n\t\tclear_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\t\treturn 0;\n\t}\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\ttsk->audit_context  = context;\n\tset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\treturn 0;\n}\n\nstatic inline void audit_free_context(struct audit_context *context)\n{\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\tfree_tree_refs(context);\n\taudit_free_aux(context);\n\tkfree(context->filterkey);\n\tkfree(context->sockaddr);\n\taudit_proctitle_free(context);\n\tkfree(context);\n}\n\nstatic int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}\n\n/*\n * to_send and len_sent accounting are very loose estimates.  We aren't\n * really worried about a hard cap to MAX_EXECVE_AUDIT_LEN so much as being\n * within about 500 bytes (next page boundary)\n *\n * why snprintf?  an int is up to 12 digits long.  if we just assumed when\n * logging that a[%d]= was going to be 16 characters long we would be wasting\n * space in every audit message.  In one 7500 byte message we can log up to\n * about 1000 min size arguments.  That comes down to about 50% waste of space\n * if we didn't do the snprintf to find out how long arg_num_len was.\n */\nstatic int audit_log_single_execve_arg(struct audit_context *context,\n\t\t\t\t\tstruct audit_buffer **ab,\n\t\t\t\t\tint arg_num,\n\t\t\t\t\tsize_t *len_sent,\n\t\t\t\t\tconst char __user *p,\n\t\t\t\t\tchar *buf)\n{\n\tchar arg_num_len_buf[12];\n\tconst char __user *tmp_p = p;\n\t/* how many digits are in arg_num? 5 is the length of ' a=\"\"' */\n\tsize_t arg_num_len = snprintf(arg_num_len_buf, 12, \"%d\", arg_num) + 5;\n\tsize_t len, len_left, to_send;\n\tsize_t max_execve_audit_len = MAX_EXECVE_AUDIT_LEN;\n\tunsigned int i, has_cntl = 0, too_long = 0;\n\tint ret;\n\n\t/* strnlen_user includes the null we don't want to send */\n\tlen_left = len = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t/*\n\t * We just created this mm, if we can't find the strings\n\t * we just copied into it something is _very_ wrong. Similar\n\t * for strings that are too long, we should not have created\n\t * any.\n\t */\n\tif (WARN_ON_ONCE(len < 0 || len > MAX_ARG_STRLEN - 1)) {\n\t\tsend_sig(SIGKILL, current, 0);\n\t\treturn -1;\n\t}\n\n\t/* walk the whole argument looking for non-ascii chars */\n\tdo {\n\t\tif (len_left > MAX_EXECVE_AUDIT_LEN)\n\t\t\tto_send = MAX_EXECVE_AUDIT_LEN;\n\t\telse\n\t\t\tto_send = len_left;\n\t\tret = copy_from_user(buf, tmp_p, to_send);\n\t\t/*\n\t\t * There is no reason for this copy to be short. We just\n\t\t * copied them here, and the mm hasn't been exposed to user-\n\t\t * space yet.\n\t\t */\n\t\tif (ret) {\n\t\t\tWARN_ON(1);\n\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\treturn -1;\n\t\t}\n\t\tbuf[to_send] = '\\0';\n\t\thas_cntl = audit_string_contains_control(buf, to_send);\n\t\tif (has_cntl) {\n\t\t\t/*\n\t\t\t * hex messages get logged as 2 bytes, so we can only\n\t\t\t * send half as much in each message\n\t\t\t */\n\t\t\tmax_execve_audit_len = MAX_EXECVE_AUDIT_LEN / 2;\n\t\t\tbreak;\n\t\t}\n\t\tlen_left -= to_send;\n\t\ttmp_p += to_send;\n\t} while (len_left > 0);\n\n\tlen_left = len;\n\n\tif (len > max_execve_audit_len)\n\t\ttoo_long = 1;\n\n\t/* rewalk the argument actually logging the message */\n\tfor (i = 0; len_left > 0; i++) {\n\t\tint room_left;\n\n\t\tif (len_left > max_execve_audit_len)\n\t\t\tto_send = max_execve_audit_len;\n\t\telse\n\t\t\tto_send = len_left;\n\n\t\t/* do we have space left to send this argument in this ab? */\n\t\troom_left = MAX_EXECVE_AUDIT_LEN - arg_num_len - *len_sent;\n\t\tif (has_cntl)\n\t\t\troom_left -= (to_send * 2);\n\t\telse\n\t\t\troom_left -= to_send;\n\t\tif (room_left < 0) {\n\t\t\t*len_sent = 0;\n\t\t\taudit_log_end(*ab);\n\t\t\t*ab = audit_log_start(context, GFP_KERNEL, AUDIT_EXECVE);\n\t\t\tif (!*ab)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * first record needs to say how long the original string was\n\t\t * so we can be sure nothing was lost.\n\t\t */\n\t\tif ((i == 0) && (too_long))\n\t\t\taudit_log_format(*ab, \" a%d_len=%zu\", arg_num,\n\t\t\t\t\t has_cntl ? 2*len : len);\n\n\t\t/*\n\t\t * normally arguments are small enough to fit and we already\n\t\t * filled buf above when we checked for control characters\n\t\t * so don't bother with another copy_from_user\n\t\t */\n\t\tif (len >= max_execve_audit_len)\n\t\t\tret = copy_from_user(buf, p, to_send);\n\t\telse\n\t\t\tret = 0;\n\t\tif (ret) {\n\t\t\tWARN_ON(1);\n\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\treturn -1;\n\t\t}\n\t\tbuf[to_send] = '\\0';\n\n\t\t/* actually log it */\n\t\taudit_log_format(*ab, \" a%d\", arg_num);\n\t\tif (too_long)\n\t\t\taudit_log_format(*ab, \"[%d]\", i);\n\t\taudit_log_format(*ab, \"=\");\n\t\tif (has_cntl)\n\t\t\taudit_log_n_hex(*ab, buf, to_send);\n\t\telse\n\t\t\taudit_log_string(*ab, buf);\n\n\t\tp += to_send;\n\t\tlen_left -= to_send;\n\t\t*len_sent += arg_num_len;\n\t\tif (has_cntl)\n\t\t\t*len_sent += to_send * 2;\n\t\telse\n\t\t\t*len_sent += to_send;\n\t}\n\t/* include the null we didn't log */\n\treturn len + 1;\n}\n\nstatic void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tint i, len;\n\tsize_t len_sent = 0;\n\tconst char __user *p;\n\tchar *buf;\n\n\tp = (const char __user *)current->mm->arg_start;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\t/*\n\t * we need some kernel buffer to hold the userspace args.  Just\n\t * allocate one big one rather than allocating one of the right size\n\t * for every single argument inside audit_log_single_execve_arg()\n\t * should be <8k allocation so should be pretty safe.\n\t */\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < context->execve.argc; i++) {\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n\t\t\t\t\t\t  &len_sent, p, buf);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}\n\nstatic void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN: {\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_MQ_SENDRECV: {\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%ld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak; }\n\tcase AUDIT_MQ_NOTIFY: {\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak; }\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET: {\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\tbreak; }\n\tcase AUDIT_MMAP: {\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak; }\n\tcase AUDIT_EXECVE: {\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak; }\n\t}\n\taudit_log_end(ab);\n}\n\nstatic inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}\n\nstatic void audit_log_proctitle(struct task_struct *tsk,\n\t\t\t struct audit_context *context)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(tsk, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}\n\nstatic void audit_log_exit(struct audit_context *context, struct task_struct *tsk)\n{\n\tint i, call_panic = 0;\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\t/* tsk == current */\n\tcontext->personality = tsk->personality;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\tif (!ab)\n\t\treturn;\t\t/* audit_panic has been called */\n\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t context->arch, context->major);\n\tif (context->personality != PER_LINUX)\n\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\tif (context->return_valid)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (context->return_valid==AUDITSC_SUCCESS)?\"yes\":\"no\",\n\t\t\t\t context->return_code);\n\n\taudit_log_format(ab,\n\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t context->argv[0],\n\t\t\t context->argv[1],\n\t\t\t context->argv[2],\n\t\t\t context->argv[3],\n\t\t\t context->name_count);\n\n\taudit_log_task_info(ab, tsk);\n\taudit_log_key(ab, context->filterkey);\n\taudit_log_end(ab);\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"new_pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"new_pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"new_pe\", &axs->new_pcap.effective);\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\taudit_log_proctitle(tsk, context);\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error converting sid to string\");\n}\n\n/**\n * audit_free - free a per-task audit context\n * @tsk: task whose audit context block to free\n *\n * Called from copy_process and do_exit\n */\nvoid __audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\n\tcontext = audit_take_context(tsk, 0, 0);\n\tif (!context)\n\t\treturn;\n\n\t/* Check for system calls that do not go through the exit\n\t * function (e.g., exit_group), then free context block.\n\t * We use GFP_ATOMIC here because we might be doing this\n\t * in the context of the idle thread */\n\t/* that can happen only if we are called from do_exit() */\n\tif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\n\t\taudit_log_exit(context, tsk);\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(&context->killed_trees);\n\n\taudit_free_context(context);\n}\n\n/**\n * audit_syscall_entry - fill in an audit record at syscall entry\n * @major: major syscall type (function)\n * @a1: additional syscall register 1\n * @a2: additional syscall register 2\n * @a3: additional syscall register 3\n * @a4: additional syscall register 4\n *\n * Fill in audit context at syscall entry.  This only happens if the\n * audit context was created when the task was created and the state or\n * filters demand the audit context be built.  If the state from the\n * per-task filter or from the per-syscall filter is AUDIT_RECORD_CONTEXT,\n * then the record will be written at syscall exit time (otherwise, it\n * will only be written if another part of the kernel requests that it\n * be written).\n */\nvoid __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,\n\t\t\t   unsigned long a3, unsigned long a4)\n{\n\tstruct task_struct *tsk = current;\n\tstruct audit_context *context = tsk->audit_context;\n\tenum audit_state     state;\n\n\tif (!context)\n\t\treturn;\n\n\tBUG_ON(context->in_syscall || context->name_count);\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tcontext->arch\t    = syscall_get_arch();\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\n\tstate = context->state;\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && state == AUDIT_BUILD_CONTEXT) {\n\t\tcontext->prio = 0;\n\t\tstate = audit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_ENTRY]);\n\t}\n\tif (state == AUDIT_DISABLED)\n\t\treturn;\n\n\tcontext->serial     = 0;\n\tcontext->ctime      = CURRENT_TIME;\n\tcontext->in_syscall = 1;\n\tcontext->current_state  = state;\n\tcontext->ppid       = 0;\n}\n\n/**\n * audit_syscall_exit - deallocate audit context after a system call\n * @success: success value of the syscall\n * @return_code: return value of the syscall\n *\n * Tear down after system call.  If the audit context has been marked as\n * auditable (either because of the AUDIT_RECORD_CONTEXT state from\n * filtering, or because some other part of the kernel wrote an audit\n * message), then write out the syscall information.  In call cases,\n * free the names stored from getname().\n */\nvoid __audit_syscall_exit(int success, long return_code)\n{\n\tstruct task_struct *tsk = current;\n\tstruct audit_context *context;\n\n\tif (success)\n\t\tsuccess = AUDITSC_SUCCESS;\n\telse\n\t\tsuccess = AUDITSC_FAILURE;\n\n\tcontext = audit_take_context(tsk, success, return_code);\n\tif (!context)\n\t\treturn;\n\n\tif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\n\t\taudit_log_exit(context, tsk);\n\n\tcontext->in_syscall = 0;\n\tcontext->prio = context->state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(&context->killed_trees);\n\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\taudit_free_aux(context);\n\tcontext->aux = NULL;\n\tcontext->aux_pids = NULL;\n\tcontext->target_pid = 0;\n\tcontext->target_sid = 0;\n\tcontext->sockaddr_len = 0;\n\tcontext->type = 0;\n\tcontext->fds[0] = -1;\n\tif (context->state != AUDIT_RECORD_CONTEXT) {\n\t\tkfree(context->filterkey);\n\t\tcontext->filterkey = NULL;\n\t}\n\ttsk->audit_context = context;\n}\n\nstatic inline void handle_one(const struct inode *inode)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\tif (likely(hlist_empty(&inode->i_fsnotify_marks)))\n\t\treturn;\n\tcontext = current->audit_context;\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n#endif\n}\n\nstatic void handle_path(const struct dentry *dentry)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = current->audit_context;\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\t\tif (inode && unlikely(!hlist_empty(&inode->i_fsnotify_marks))) {\n\t\t\tstruct audit_chunk *chunk;\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n#endif\n}\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}\n\n/**\n * audit_reusename - fill out filename with info from existing entry\n * @uptr: userland ptr to pathname\n *\n * Search the audit_names list for the current audit context. If there is an\n * existing entry with a matching \"uptr\" then return the filename\n * associated with that audit_name. If not, return NULL.\n */\nstruct filename *\n__audit_reusename(const __user char *uptr)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct audit_names *n;\n\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name)\n\t\t\tcontinue;\n\t\tif (n->name->uptr == uptr) {\n\t\t\tn->name->refcnt++;\n\t\t\treturn n->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * audit_getname - add a name to the list\n * @name: name to add\n *\n * Add a name to the list of audit names for this context.\n * Called from fs/namei.c:getname().\n */\nvoid __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct audit_names *n;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tname->refcnt++;\n\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n}\n\n/**\n * __audit_inode - store the inode and device from a lookup\n * @name: name being audited\n * @dentry: dentry being audited\n * @flags: attributes for this particular entry\n */\nvoid __audit_inode(struct filename *name, const struct dentry *dentry,\n\t\t   unsigned int flags)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct audit_names *n;\n\tbool parent = flags & AUDIT_INODE_PARENT;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tif (!name)\n\t\tgoto out_alloc;\n\n\t/*\n\t * If we have a pointer to an audit_names entry already, then we can\n\t * just use it directly if the type is correct.\n\t */\n\tn = name->aname;\n\tif (n) {\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_reverse(n, &context->names_list, list) {\n\t\tif (n->ino) {\n\t\t\t/* valid inode number, use that for the comparison */\n\t\t\tif (n->ino != inode->i_ino ||\n\t\t\t    n->dev != inode->i_sb->s_dev)\n\t\t\t\tcontinue;\n\t\t} else if (n->name) {\n\t\t\t/* inode number has not been set, check the name */\n\t\t\tif (strcmp(n->name->name, name->name))\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\t/* no inode and no name (?!) ... this is odd ... */\n\t\t\tcontinue;\n\n\t\t/* match the correct record type */\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout_alloc:\n\t/* unable to find an entry with both a matching name and type */\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\tif (name) {\n\t\tn->name = name;\n\t\tname->refcnt++;\n\t}\n\nout:\n\tif (parent) {\n\t\tn->name_len = n->name ? parent_len(n->name->name) : AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_PARENT;\n\t\tif (flags & AUDIT_INODE_HIDDEN)\n\t\t\tn->hidden = true;\n\t} else {\n\t\tn->name_len = AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_NORMAL;\n\t}\n\thandle_path(dentry);\n\taudit_copy_inode(n, dentry, inode);\n}\n\nvoid __audit_file(const struct file *file)\n{\n\t__audit_inode(NULL, file->f_path.dentry, 0);\n}\n\n/**\n * __audit_inode_child - collect inode info for created/removed objects\n * @parent: inode of dentry parent\n * @dentry: dentry being audited\n * @type:   AUDIT_TYPE_* value that we're looking for\n *\n * For syscalls that create or remove filesystem objects, audit_inode\n * can only collect information for the filesystem object's parent.\n * This call updates the audit context with the child's information.\n * Syscalls that create a new filesystem object must be hooked after\n * the object is created.  Syscalls that remove a filesystem object\n * must be hooked prior, in order to capture the target inode during\n * unsuccessful attempts.\n */\nvoid __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst char *dname = dentry->d_name.name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}\nEXPORT_SYMBOL_GPL(__audit_inode_child);\n\n/**\n * auditsc_get_stamp - get local copies of audit_context values\n * @ctx: audit_context for the task\n * @t: timespec to store time recorded in the audit_context\n * @serial: serial value that is recorded in the audit_context\n *\n * Also sets the context as auditable.\n */\nint auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec *t, unsigned int *serial)\n{\n\tif (!ctx->in_syscall)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n\treturn 1;\n}\n\n/* global counter which is incremented every time something logs in */\nstatic atomic_t session_id = ATOMIC_INIT(0);\n\nstatic int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID) && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\nstatic void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid, unsigned int sessionid,\n\t\t\t\t   int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid),\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_pid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, oldsessionid, sessionid, !rc);\n\taudit_log_end(ab);\n}\n\n/**\n * audit_set_loginuid - set current task's audit_context loginuid\n * @loginuid: loginuid value\n *\n * Returns 0.\n *\n * Called (set) from fs/proc/base.c::proc_loginuid_write().\n */\nint audit_set_loginuid(kuid_t loginuid)\n{\n\tstruct task_struct *task = current;\n\tunsigned int oldsessionid, sessionid = (unsigned int)-1;\n\tkuid_t oldloginuid;\n\tint rc;\n\n\toldloginuid = audit_get_loginuid(current);\n\toldsessionid = audit_get_sessionid(current);\n\n\trc = audit_set_loginuid_perm(loginuid);\n\tif (rc)\n\t\tgoto out;\n\n\t/* are we setting or clearing? */\n\tif (uid_valid(loginuid))\n\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\n\ttask->sessionid = sessionid;\n\ttask->loginuid = loginuid;\nout:\n\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);\n\treturn rc;\n}\n\n/**\n * __audit_mq_open - record audit data for a POSIX MQ open\n * @oflag: open flag\n * @mode: mode bits\n * @attr: queue attributes\n *\n */\nvoid __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tif (attr)\n\t\tmemcpy(&context->mq_open.attr, attr, sizeof(struct mq_attr));\n\telse\n\t\tmemset(&context->mq_open.attr, 0, sizeof(struct mq_attr));\n\n\tcontext->mq_open.oflag = oflag;\n\tcontext->mq_open.mode = mode;\n\n\tcontext->type = AUDIT_MQ_OPEN;\n}\n\n/**\n * __audit_mq_sendrecv - record audit data for a POSIX MQ timed send/receive\n * @mqdes: MQ descriptor\n * @msg_len: Message length\n * @msg_prio: Message priority\n * @abs_timeout: Message timeout in absolute time\n *\n */\nvoid __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio,\n\t\t\tconst struct timespec *abs_timeout)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct timespec *p = &context->mq_sendrecv.abs_timeout;\n\n\tif (abs_timeout)\n\t\tmemcpy(p, abs_timeout, sizeof(struct timespec));\n\telse\n\t\tmemset(p, 0, sizeof(struct timespec));\n\n\tcontext->mq_sendrecv.mqdes = mqdes;\n\tcontext->mq_sendrecv.msg_len = msg_len;\n\tcontext->mq_sendrecv.msg_prio = msg_prio;\n\n\tcontext->type = AUDIT_MQ_SENDRECV;\n}\n\n/**\n * __audit_mq_notify - record audit data for a POSIX MQ notify\n * @mqdes: MQ descriptor\n * @notification: Notification event\n *\n */\n\nvoid __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tif (notification)\n\t\tcontext->mq_notify.sigev_signo = notification->sigev_signo;\n\telse\n\t\tcontext->mq_notify.sigev_signo = 0;\n\n\tcontext->mq_notify.mqdes = mqdes;\n\tcontext->type = AUDIT_MQ_NOTIFY;\n}\n\n/**\n * __audit_mq_getsetattr - record audit data for a POSIX MQ get/set attribute\n * @mqdes: MQ descriptor\n * @mqstat: MQ flags\n *\n */\nvoid __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->mq_getsetattr.mqdes = mqdes;\n\tcontext->mq_getsetattr.mqstat = *mqstat;\n\tcontext->type = AUDIT_MQ_GETSETATTR;\n}\n\n/**\n * audit_ipc_obj - record audit data for ipc object\n * @ipcp: ipc permissions\n *\n */\nvoid __audit_ipc_obj(struct kern_ipc_perm *ipcp)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->ipc.uid = ipcp->uid;\n\tcontext->ipc.gid = ipcp->gid;\n\tcontext->ipc.mode = ipcp->mode;\n\tcontext->ipc.has_perm = 0;\n\tsecurity_ipc_getsecid(ipcp, &context->ipc.osid);\n\tcontext->type = AUDIT_IPC;\n}\n\n/**\n * audit_ipc_set_perm - record audit data for new ipc permissions\n * @qbytes: msgq bytes\n * @uid: msgq user id\n * @gid: msgq group id\n * @mode: msgq mode (permissions)\n *\n * Called only after audit_ipc_obj().\n */\nvoid __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tcontext->ipc.qbytes = qbytes;\n\tcontext->ipc.perm_uid = uid;\n\tcontext->ipc.perm_gid = gid;\n\tcontext->ipc.perm_mode = mode;\n\tcontext->ipc.has_perm = 1;\n}\n\nvoid __audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tcontext->type = AUDIT_EXECVE;\n\tcontext->execve.argc = bprm->argc;\n}\n\n\n/**\n * audit_socketcall - record audit data for sys_socketcall\n * @nargs: number of args, which should not be more than AUDITSC_ARGS.\n * @args: args array\n *\n */\nint __audit_socketcall(int nargs, unsigned long *args)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tif (nargs <= 0 || nargs > AUDITSC_ARGS || !args)\n\t\treturn -EINVAL;\n\tcontext->type = AUDIT_SOCKETCALL;\n\tcontext->socketcall.nargs = nargs;\n\tmemcpy(context->socketcall.args, args, nargs * sizeof(unsigned long));\n\treturn 0;\n}\n\n/**\n * __audit_fd_pair - record audit data for pipe and socketpair\n * @fd1: the first file descriptor\n * @fd2: the second file descriptor\n *\n */\nvoid __audit_fd_pair(int fd1, int fd2)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->fds[0] = fd1;\n\tcontext->fds[1] = fd2;\n}\n\n/**\n * audit_sockaddr - record audit data for sys_bind, sys_connect, sys_sendto\n * @len: data length in user space\n * @a: data address in kernel space\n *\n * Returns 0 for success or NULL context or < 0 on error.\n */\nint __audit_sockaddr(int len, void *a)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tif (!context->sockaddr) {\n\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tcontext->sockaddr = p;\n\t}\n\n\tcontext->sockaddr_len = len;\n\tmemcpy(context->sockaddr, a, len);\n\treturn 0;\n}\n\nvoid __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tcontext->target_pid = task_pid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}\n\n/**\n * audit_signal_info - record signal info for shutting down audit subsystem\n * @sig: signal value\n * @t: task being signaled\n *\n * If the audit subsystem is being terminated, record the task (pid)\n * and uid that is doing that.\n */\nint __audit_signal_info(int sig, struct task_struct *t)\n{\n\tstruct audit_aux_data_pids *axp;\n\tstruct task_struct *tsk = current;\n\tstruct audit_context *ctx = tsk->audit_context;\n\tkuid_t uid = current_uid(), t_uid = task_uid(t);\n\n\tif (audit_pid && t->tgid == audit_pid) {\n\t\tif (sig == SIGTERM || sig == SIGHUP || sig == SIGUSR1 || sig == SIGUSR2) {\n\t\t\taudit_sig_pid = task_pid_nr(tsk);\n\t\t\tif (uid_valid(tsk->loginuid))\n\t\t\t\taudit_sig_uid = tsk->loginuid;\n\t\t\telse\n\t\t\t\taudit_sig_uid = uid;\n\t\t\tsecurity_task_getsecid(tsk, &audit_sig_sid);\n\t\t}\n\t\tif (!audit_signals || audit_dummy_context())\n\t\t\treturn 0;\n\t}\n\n\t/* optimize the common case by putting first signal recipient directly\n\t * in audit_context */\n\tif (!ctx->target_pid) {\n\t\tctx->target_pid = task_tgid_nr(t);\n\t\tctx->target_auid = audit_get_loginuid(t);\n\t\tctx->target_uid = t_uid;\n\t\tctx->target_sessionid = audit_get_sessionid(t);\n\t\tsecurity_task_getsecid(t, &ctx->target_sid);\n\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\n\t\treturn 0;\n\t}\n\n\taxp = (void *)ctx->aux_pids;\n\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\n\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\n\t\tif (!axp)\n\t\t\treturn -ENOMEM;\n\n\t\taxp->d.type = AUDIT_OBJ_PID;\n\t\taxp->d.next = ctx->aux_pids;\n\t\tctx->aux_pids = (void *)axp;\n\t}\n\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\n\n\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);\n\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\n\taxp->target_uid[axp->pid_count] = t_uid;\n\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &axp->target_sid[axp->pid_count]);\n\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\n\taxp->pid_count++;\n\n\treturn 0;\n}\n\n/**\n * __audit_log_bprm_fcaps - store information about a loading bprm and relevant fcaps\n * @bprm: pointer to the bprm being processed\n * @new: the proposed new credentials\n * @old: the old credentials\n *\n * Simply check if the proc already has the caps given by the file and if not\n * store the priv escalation info for later auditing at the end of the syscall\n *\n * -Eric\n */\nint __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t   const struct cred *new, const struct cred *old)\n{\n\tstruct audit_aux_data_bprm_fcaps *ax;\n\tstruct audit_context *context = current->audit_context;\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\n\tax->d.type = AUDIT_BPRM_FCAPS;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\n\tget_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\n\tax->fcap.permitted = vcaps.permitted;\n\tax->fcap.inheritable = vcaps.inheritable;\n\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\n\n\tax->old_pcap.permitted   = old->cap_permitted;\n\tax->old_pcap.inheritable = old->cap_inheritable;\n\tax->old_pcap.effective   = old->cap_effective;\n\n\tax->new_pcap.permitted   = new->cap_permitted;\n\tax->new_pcap.inheritable = new->cap_inheritable;\n\tax->new_pcap.effective   = new->cap_effective;\n\treturn 0;\n}\n\n/**\n * __audit_log_capset - store information about the arguments to the capset syscall\n * @new: the new credentials\n * @old: the old (current) credentials\n *\n * Record the arguments userspace sent to sys_capset for later printing by the\n * audit system if applicable\n */\nvoid __audit_log_capset(const struct cred *new, const struct cred *old)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->capset.pid = task_pid_nr(current);\n\tcontext->capset.cap.effective   = new->cap_effective;\n\tcontext->capset.cap.inheritable = new->cap_effective;\n\tcontext->capset.cap.permitted   = new->cap_permitted;\n\tcontext->type = AUDIT_CAPSET;\n}\n\nvoid __audit_mmap_fd(int fd, int flags)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->mmap.fd = fd;\n\tcontext->mmap.flags = flags;\n\tcontext->type = AUDIT_MMAP;\n}\n\nstatic void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_pid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}\n\n/**\n * audit_core_dumps - record information about processes that end abnormally\n * @signr: signal value\n *\n * If a process ends with a core dump, something fishy is going on and we\n * should record the event for investigation.\n */\nvoid audit_core_dumps(long signr)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tif (signr == SIGQUIT)\t/* don't care for those */\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_ANOM_ABEND);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld\", signr);\n\taudit_log_end(ab);\n}\n\nvoid __audit_seccomp(unsigned long syscall, long signr, int code)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_SECCOMP);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\",\n\t\t\t signr, syscall_get_arch(), syscall,\n\t\t\t in_compat_syscall(), KSTK_EIP(current), code);\n\taudit_log_end(ab);\n}\n\nstruct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = current->audit_context;\n\tif (likely(!ctx || !ctx->in_syscall))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}\n"], "fixing_code": ["/* auditsc.c -- System-call auditing support\n * Handles all system-call specific auditing features.\n *\n * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.\n * Copyright 2005 Hewlett-Packard Development Company, L.P.\n * Copyright (C) 2005, 2006 IBM Corporation\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Written by Rickard E. (Rik) Faith <faith@redhat.com>\n *\n * Many of the ideas implemented here are from Stephen C. Tweedie,\n * especially the idea of avoiding a copy by using getname.\n *\n * The method for actual interception of syscall entry and exit (not in\n * this file -- see entry.S) is based on a GPL'd patch written by\n * okir@suse.de and Copyright 2003 SuSE Linux AG.\n *\n * POSIX message queue support added by George Wilson <ltcgcw@us.ibm.com>,\n * 2006.\n *\n * The support of additional filter rules compares (>, <, >=, <=) was\n * added by Dustin Kirkland <dustin.kirkland@us.ibm.com>, 2005.\n *\n * Modified by Amy Griffis <amy.griffis@hp.com> to collect additional\n * filesystem information.\n *\n * Subject and object context labeling support added by <danjones@us.ibm.com>\n * and <dustin.kirkland@us.ibm.com> for LSPP certification compliance.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <asm/types.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/socket.h>\n#include <linux/mqueue.h>\n#include <linux/audit.h>\n#include <linux/personality.h>\n#include <linux/time.h>\n#include <linux/netlink.h>\n#include <linux/compiler.h>\n#include <asm/unistd.h>\n#include <linux/security.h>\n#include <linux/list.h>\n#include <linux/tty.h>\n#include <linux/binfmts.h>\n#include <linux/highmem.h>\n#include <linux/syscalls.h>\n#include <asm/syscall.h>\n#include <linux/capability.h>\n#include <linux/fs_struct.h>\n#include <linux/compat.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/limits.h>\n\n#include \"audit.h\"\n\n/* flags stating the success for a syscall */\n#define AUDITSC_INVALID 0\n#define AUDITSC_SUCCESS 1\n#define AUDITSC_FAILURE 2\n\n/* no execve audit message should be longer than this (userspace limits),\n * see the note near the top of audit_log_execve_info() about this value */\n#define MAX_EXECVE_AUDIT_LEN 7500\n\n/* max length to print of cmdline/proctitle value during audit */\n#define MAX_PROCTITLE_AUDIT_LEN 128\n\n/* number of audit rules */\nint audit_n_rules;\n\n/* determines whether we collect data for signals sent */\nint audit_signals;\n\nstruct audit_aux_data {\n\tstruct audit_aux_data\t*next;\n\tint\t\t\ttype;\n};\n\n#define AUDIT_AUX_IPCPERM\t0\n\n/* Number of target pids per aux struct. */\n#define AUDIT_AUX_PIDS\t16\n\nstruct audit_aux_data_pids {\n\tstruct audit_aux_data\td;\n\tpid_t\t\t\ttarget_pid[AUDIT_AUX_PIDS];\n\tkuid_t\t\t\ttarget_auid[AUDIT_AUX_PIDS];\n\tkuid_t\t\t\ttarget_uid[AUDIT_AUX_PIDS];\n\tunsigned int\t\ttarget_sessionid[AUDIT_AUX_PIDS];\n\tu32\t\t\ttarget_sid[AUDIT_AUX_PIDS];\n\tchar \t\t\ttarget_comm[AUDIT_AUX_PIDS][TASK_COMM_LEN];\n\tint\t\t\tpid_count;\n};\n\nstruct audit_aux_data_bprm_fcaps {\n\tstruct audit_aux_data\td;\n\tstruct audit_cap_data\tfcap;\n\tunsigned int\t\tfcap_ver;\n\tstruct audit_cap_data\told_pcap;\n\tstruct audit_cap_data\tnew_pcap;\n};\n\nstruct audit_tree_refs {\n\tstruct audit_tree_refs *next;\n\tstruct audit_chunk *c[31];\n};\n\nstatic int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase 0:\t/* native */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 1: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 2: /* open */\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase 3: /* openat */\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase 4: /* socketcall */\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase 5: /* execve */\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * We keep a linked list of fixed-sized (31 pointer) arrays of audit_chunk *;\n * ->first_trees points to its beginning, ->trees - to the current end of data.\n * ->tree_count is the number of free entries in array pointed to by ->trees.\n * Original condition is (NULL, NULL, 0); as soon as it grows we never revert to NULL,\n * \"empty\" becomes (p, p, 31) afterwards.  We don't shrink the list (and seriously,\n * it's going to remain 1-element for almost any setup) until we free context itself.\n * References in it _are_ dropped - at the same time we free/drop aux stuff.\n */\n\n#ifdef CONFIG_AUDIT_TREE\nstatic void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n}\n\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}\n#endif\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}\n\nstatic void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}\n\nstatic int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *p;\n\tint n;\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(tsk->loginuid, name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, tsk->loginuid);\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(tsk->loginuid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(tsk->loginuid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(tsk->loginuid, f->op, cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n/* Determine if any context name data matches a rule's watch data */\n/* Compare a task_struct with an audit_rule.  Return 1 on match, 0\n * otherwise.\n *\n * If task_creation is true, this is an explicit indication that we are\n * filtering a task rule at task creation time.  This and tsk == current are\n * the only situations where tsk->cred may be accessed without an rcu read lock.\n */\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_pid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = in_group_p(f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !in_group_p(f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = in_egroup_p(f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !in_egroup_p(f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(tsk->loginuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}\n\n/* At process creation time, we can determine if system-call auditing is\n * completely disabled for this task.  Since we only have the task\n * structure at this point, we can only check uid and gid.\n */\nstatic enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_RECORD_CONTEXT)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}\n\n/* At syscall entry and exit time, this filter is called if the\n * audit_state is not low enough that auditing cannot take place, but is\n * also not high enough that we already know we have to write an audit\n * record (i.e., the state is AUDIT_SETUP_CONTEXT or AUDIT_BUILD_CONTEXT).\n */\nstatic enum audit_state audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t\t     struct audit_context *ctx,\n\t\t\t\t\t     struct list_head *list)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (audit_pid && tsk->tgid == audit_pid)\n\t\treturn AUDIT_DISABLED;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t\t       &state, false)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tctx->current_state = state;\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}\n\n/*\n * Given an audit_name check the inode hash table to see if they match.\n * Called holding the rcu read lock to protect the use of audit_inode_hash\n */\nstatic int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (list_empty(list))\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* At syscall exit time, this filter is called if any audit_names have been\n * collected during syscall processing.  We only check rules in sublists at hash\n * buckets applicable to the inode numbers in audit_names.\n * Regarding audit_state, same rules apply as for audit_filter_syscall().\n */\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (audit_pid && tsk->tgid == audit_pid)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\n\n/* Transfer the audit context pointer to the caller, clearing it in the tsk's struct */\nstatic inline struct audit_context *audit_take_context(struct task_struct *tsk,\n\t\t\t\t\t\t      int return_valid,\n\t\t\t\t\t\t      long return_code)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn NULL;\n\tcontext->return_valid = return_valid;\n\n\t/*\n\t * we need to fix up the return code in the audit logs if the actual\n\t * return codes are later going to be fixed up by the arch specific\n\t * signal handlers\n\t *\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(return_code <= -ERESTARTSYS) &&\n\t    (return_code >= -ERESTART_RESTARTBLOCK) &&\n\t    (return_code != -ENOIOCTLCMD))\n\t\tcontext->return_code = -EINTR;\n\telse\n\t\tcontext->return_code  = return_code;\n\n\tif (context->in_syscall && !context->dummy) {\n\t\taudit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\n\t\taudit_filter_inodes(tsk, context);\n\t}\n\n\ttsk->audit_context = NULL;\n\treturn context;\n}\n\nstatic inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}\n\nstatic inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}\n\nstatic inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n}\n\nstatic inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\treturn context;\n}\n\n/**\n * audit_alloc - allocate an audit context block for a task\n * @tsk: task\n *\n * Filter on the task information and allocate a per-task audit context\n * if necessary.  Doing so turns on system call auditing for the\n * specified task.  This is called from copy_process, so no lock is\n * needed.\n */\nint audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0; /* Return if not auditing. */\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_DISABLED) {\n\t\tclear_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\t\treturn 0;\n\t}\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\ttsk->audit_context  = context;\n\tset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\treturn 0;\n}\n\nstatic inline void audit_free_context(struct audit_context *context)\n{\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\tfree_tree_refs(context);\n\taudit_free_aux(context);\n\tkfree(context->filterkey);\n\tkfree(context->sockaddr);\n\taudit_proctitle_free(context);\n\tkfree(context);\n}\n\nstatic int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}\n\nstatic void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n\t *       data we put in the audit record for this argument (see the\n\t *       code below) ... at this point in time 96 is plenty */\n\tchar abuf[96];\n\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n\t *       current value of 7500 is not as important as the fact that it\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n\t *       room if we go over a little bit in the logging below */\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t/* scratch buffer to hold the userspace args */\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t/* NOTE: we don't ever want to trust this value for anything\n\t\t *       serious, but the audit record format insists we\n\t\t *       provide an argument length for really long arguments,\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n\t\t *       to use strncpy_from_user() to obtain this value for\n\t\t *       recording in the log, although we don't use it\n\t\t *       anywhere here to avoid a double-fetch problem */\n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t/* read more data from userspace */\n\t\tif (require_data) {\n\t\t\t/* can we make more room in the buffer? */\n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t/* fetch as much as we can of the argument */\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t/* unable to copy from userspace */\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t/* buffer is not large enough */\n\t\t\t\trequire_data = true;\n\t\t\t\t/* NOTE: if we are going to span multiple\n\t\t\t\t *       buffers force the encoding so we stand\n\t\t\t\t *       a chance at a sane len_full value and\n\t\t\t\t *       consistent record encoding */\n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t/* try to use a trusted value for len_full */\n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t/* length of the buffer in the audit record? */\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t/* write as much as we can to the audit log */\n\t\tif (len_buf > 0) {\n\t\t\t/* NOTE: some magic numbers here - basically if we\n\t\t\t *       can't fit a reasonable amount of data into the\n\t\t\t *       existing audit buffer, flush it and start with\n\t\t\t *       a new buffer */\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* create the non-arg portion of the arg record */\n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t/* log the arg in the audit record */\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t/* don't subtract the \"2\" because we still need\n\t\t\t\t * to add quotes to the remaining string */\n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t/* ready to move to the next argument? */\n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t/* NOTE: the caller handles the final audit_log_end() call */\n\nout:\n\tkfree(buf_head);\n}\n\nstatic void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN: {\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_MQ_SENDRECV: {\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%ld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak; }\n\tcase AUDIT_MQ_NOTIFY: {\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak; }\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET: {\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\tbreak; }\n\tcase AUDIT_MMAP: {\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak; }\n\tcase AUDIT_EXECVE: {\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak; }\n\t}\n\taudit_log_end(ab);\n}\n\nstatic inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}\n\nstatic void audit_log_proctitle(struct task_struct *tsk,\n\t\t\t struct audit_context *context)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(tsk, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}\n\nstatic void audit_log_exit(struct audit_context *context, struct task_struct *tsk)\n{\n\tint i, call_panic = 0;\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\t/* tsk == current */\n\tcontext->personality = tsk->personality;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\tif (!ab)\n\t\treturn;\t\t/* audit_panic has been called */\n\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t context->arch, context->major);\n\tif (context->personality != PER_LINUX)\n\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\tif (context->return_valid)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (context->return_valid==AUDITSC_SUCCESS)?\"yes\":\"no\",\n\t\t\t\t context->return_code);\n\n\taudit_log_format(ab,\n\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t context->argv[0],\n\t\t\t context->argv[1],\n\t\t\t context->argv[2],\n\t\t\t context->argv[3],\n\t\t\t context->name_count);\n\n\taudit_log_task_info(ab, tsk);\n\taudit_log_key(ab, context->filterkey);\n\taudit_log_end(ab);\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"new_pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"new_pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"new_pe\", &axs->new_pcap.effective);\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\taudit_log_proctitle(tsk, context);\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error converting sid to string\");\n}\n\n/**\n * audit_free - free a per-task audit context\n * @tsk: task whose audit context block to free\n *\n * Called from copy_process and do_exit\n */\nvoid __audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\n\tcontext = audit_take_context(tsk, 0, 0);\n\tif (!context)\n\t\treturn;\n\n\t/* Check for system calls that do not go through the exit\n\t * function (e.g., exit_group), then free context block.\n\t * We use GFP_ATOMIC here because we might be doing this\n\t * in the context of the idle thread */\n\t/* that can happen only if we are called from do_exit() */\n\tif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\n\t\taudit_log_exit(context, tsk);\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(&context->killed_trees);\n\n\taudit_free_context(context);\n}\n\n/**\n * audit_syscall_entry - fill in an audit record at syscall entry\n * @major: major syscall type (function)\n * @a1: additional syscall register 1\n * @a2: additional syscall register 2\n * @a3: additional syscall register 3\n * @a4: additional syscall register 4\n *\n * Fill in audit context at syscall entry.  This only happens if the\n * audit context was created when the task was created and the state or\n * filters demand the audit context be built.  If the state from the\n * per-task filter or from the per-syscall filter is AUDIT_RECORD_CONTEXT,\n * then the record will be written at syscall exit time (otherwise, it\n * will only be written if another part of the kernel requests that it\n * be written).\n */\nvoid __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,\n\t\t\t   unsigned long a3, unsigned long a4)\n{\n\tstruct task_struct *tsk = current;\n\tstruct audit_context *context = tsk->audit_context;\n\tenum audit_state     state;\n\n\tif (!context)\n\t\treturn;\n\n\tBUG_ON(context->in_syscall || context->name_count);\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tcontext->arch\t    = syscall_get_arch();\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\n\tstate = context->state;\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && state == AUDIT_BUILD_CONTEXT) {\n\t\tcontext->prio = 0;\n\t\tstate = audit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_ENTRY]);\n\t}\n\tif (state == AUDIT_DISABLED)\n\t\treturn;\n\n\tcontext->serial     = 0;\n\tcontext->ctime      = CURRENT_TIME;\n\tcontext->in_syscall = 1;\n\tcontext->current_state  = state;\n\tcontext->ppid       = 0;\n}\n\n/**\n * audit_syscall_exit - deallocate audit context after a system call\n * @success: success value of the syscall\n * @return_code: return value of the syscall\n *\n * Tear down after system call.  If the audit context has been marked as\n * auditable (either because of the AUDIT_RECORD_CONTEXT state from\n * filtering, or because some other part of the kernel wrote an audit\n * message), then write out the syscall information.  In call cases,\n * free the names stored from getname().\n */\nvoid __audit_syscall_exit(int success, long return_code)\n{\n\tstruct task_struct *tsk = current;\n\tstruct audit_context *context;\n\n\tif (success)\n\t\tsuccess = AUDITSC_SUCCESS;\n\telse\n\t\tsuccess = AUDITSC_FAILURE;\n\n\tcontext = audit_take_context(tsk, success, return_code);\n\tif (!context)\n\t\treturn;\n\n\tif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\n\t\taudit_log_exit(context, tsk);\n\n\tcontext->in_syscall = 0;\n\tcontext->prio = context->state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(&context->killed_trees);\n\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\taudit_free_aux(context);\n\tcontext->aux = NULL;\n\tcontext->aux_pids = NULL;\n\tcontext->target_pid = 0;\n\tcontext->target_sid = 0;\n\tcontext->sockaddr_len = 0;\n\tcontext->type = 0;\n\tcontext->fds[0] = -1;\n\tif (context->state != AUDIT_RECORD_CONTEXT) {\n\t\tkfree(context->filterkey);\n\t\tcontext->filterkey = NULL;\n\t}\n\ttsk->audit_context = context;\n}\n\nstatic inline void handle_one(const struct inode *inode)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\tif (likely(hlist_empty(&inode->i_fsnotify_marks)))\n\t\treturn;\n\tcontext = current->audit_context;\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n#endif\n}\n\nstatic void handle_path(const struct dentry *dentry)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = current->audit_context;\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\t\tif (inode && unlikely(!hlist_empty(&inode->i_fsnotify_marks))) {\n\t\t\tstruct audit_chunk *chunk;\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n#endif\n}\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}\n\n/**\n * audit_reusename - fill out filename with info from existing entry\n * @uptr: userland ptr to pathname\n *\n * Search the audit_names list for the current audit context. If there is an\n * existing entry with a matching \"uptr\" then return the filename\n * associated with that audit_name. If not, return NULL.\n */\nstruct filename *\n__audit_reusename(const __user char *uptr)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct audit_names *n;\n\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name)\n\t\t\tcontinue;\n\t\tif (n->name->uptr == uptr) {\n\t\t\tn->name->refcnt++;\n\t\t\treturn n->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * audit_getname - add a name to the list\n * @name: name to add\n *\n * Add a name to the list of audit names for this context.\n * Called from fs/namei.c:getname().\n */\nvoid __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct audit_names *n;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tname->refcnt++;\n\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n}\n\n/**\n * __audit_inode - store the inode and device from a lookup\n * @name: name being audited\n * @dentry: dentry being audited\n * @flags: attributes for this particular entry\n */\nvoid __audit_inode(struct filename *name, const struct dentry *dentry,\n\t\t   unsigned int flags)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct audit_names *n;\n\tbool parent = flags & AUDIT_INODE_PARENT;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tif (!name)\n\t\tgoto out_alloc;\n\n\t/*\n\t * If we have a pointer to an audit_names entry already, then we can\n\t * just use it directly if the type is correct.\n\t */\n\tn = name->aname;\n\tif (n) {\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_reverse(n, &context->names_list, list) {\n\t\tif (n->ino) {\n\t\t\t/* valid inode number, use that for the comparison */\n\t\t\tif (n->ino != inode->i_ino ||\n\t\t\t    n->dev != inode->i_sb->s_dev)\n\t\t\t\tcontinue;\n\t\t} else if (n->name) {\n\t\t\t/* inode number has not been set, check the name */\n\t\t\tif (strcmp(n->name->name, name->name))\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\t/* no inode and no name (?!) ... this is odd ... */\n\t\t\tcontinue;\n\n\t\t/* match the correct record type */\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout_alloc:\n\t/* unable to find an entry with both a matching name and type */\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\tif (name) {\n\t\tn->name = name;\n\t\tname->refcnt++;\n\t}\n\nout:\n\tif (parent) {\n\t\tn->name_len = n->name ? parent_len(n->name->name) : AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_PARENT;\n\t\tif (flags & AUDIT_INODE_HIDDEN)\n\t\t\tn->hidden = true;\n\t} else {\n\t\tn->name_len = AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_NORMAL;\n\t}\n\thandle_path(dentry);\n\taudit_copy_inode(n, dentry, inode);\n}\n\nvoid __audit_file(const struct file *file)\n{\n\t__audit_inode(NULL, file->f_path.dentry, 0);\n}\n\n/**\n * __audit_inode_child - collect inode info for created/removed objects\n * @parent: inode of dentry parent\n * @dentry: dentry being audited\n * @type:   AUDIT_TYPE_* value that we're looking for\n *\n * For syscalls that create or remove filesystem objects, audit_inode\n * can only collect information for the filesystem object's parent.\n * This call updates the audit context with the child's information.\n * Syscalls that create a new filesystem object must be hooked after\n * the object is created.  Syscalls that remove a filesystem object\n * must be hooked prior, in order to capture the target inode during\n * unsuccessful attempts.\n */\nvoid __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst char *dname = dentry->d_name.name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}\nEXPORT_SYMBOL_GPL(__audit_inode_child);\n\n/**\n * auditsc_get_stamp - get local copies of audit_context values\n * @ctx: audit_context for the task\n * @t: timespec to store time recorded in the audit_context\n * @serial: serial value that is recorded in the audit_context\n *\n * Also sets the context as auditable.\n */\nint auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec *t, unsigned int *serial)\n{\n\tif (!ctx->in_syscall)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n\treturn 1;\n}\n\n/* global counter which is incremented every time something logs in */\nstatic atomic_t session_id = ATOMIC_INIT(0);\n\nstatic int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID) && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}\n\nstatic void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid, unsigned int sessionid,\n\t\t\t\t   int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid),\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_pid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, oldsessionid, sessionid, !rc);\n\taudit_log_end(ab);\n}\n\n/**\n * audit_set_loginuid - set current task's audit_context loginuid\n * @loginuid: loginuid value\n *\n * Returns 0.\n *\n * Called (set) from fs/proc/base.c::proc_loginuid_write().\n */\nint audit_set_loginuid(kuid_t loginuid)\n{\n\tstruct task_struct *task = current;\n\tunsigned int oldsessionid, sessionid = (unsigned int)-1;\n\tkuid_t oldloginuid;\n\tint rc;\n\n\toldloginuid = audit_get_loginuid(current);\n\toldsessionid = audit_get_sessionid(current);\n\n\trc = audit_set_loginuid_perm(loginuid);\n\tif (rc)\n\t\tgoto out;\n\n\t/* are we setting or clearing? */\n\tif (uid_valid(loginuid))\n\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\n\ttask->sessionid = sessionid;\n\ttask->loginuid = loginuid;\nout:\n\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);\n\treturn rc;\n}\n\n/**\n * __audit_mq_open - record audit data for a POSIX MQ open\n * @oflag: open flag\n * @mode: mode bits\n * @attr: queue attributes\n *\n */\nvoid __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tif (attr)\n\t\tmemcpy(&context->mq_open.attr, attr, sizeof(struct mq_attr));\n\telse\n\t\tmemset(&context->mq_open.attr, 0, sizeof(struct mq_attr));\n\n\tcontext->mq_open.oflag = oflag;\n\tcontext->mq_open.mode = mode;\n\n\tcontext->type = AUDIT_MQ_OPEN;\n}\n\n/**\n * __audit_mq_sendrecv - record audit data for a POSIX MQ timed send/receive\n * @mqdes: MQ descriptor\n * @msg_len: Message length\n * @msg_prio: Message priority\n * @abs_timeout: Message timeout in absolute time\n *\n */\nvoid __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio,\n\t\t\tconst struct timespec *abs_timeout)\n{\n\tstruct audit_context *context = current->audit_context;\n\tstruct timespec *p = &context->mq_sendrecv.abs_timeout;\n\n\tif (abs_timeout)\n\t\tmemcpy(p, abs_timeout, sizeof(struct timespec));\n\telse\n\t\tmemset(p, 0, sizeof(struct timespec));\n\n\tcontext->mq_sendrecv.mqdes = mqdes;\n\tcontext->mq_sendrecv.msg_len = msg_len;\n\tcontext->mq_sendrecv.msg_prio = msg_prio;\n\n\tcontext->type = AUDIT_MQ_SENDRECV;\n}\n\n/**\n * __audit_mq_notify - record audit data for a POSIX MQ notify\n * @mqdes: MQ descriptor\n * @notification: Notification event\n *\n */\n\nvoid __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tif (notification)\n\t\tcontext->mq_notify.sigev_signo = notification->sigev_signo;\n\telse\n\t\tcontext->mq_notify.sigev_signo = 0;\n\n\tcontext->mq_notify.mqdes = mqdes;\n\tcontext->type = AUDIT_MQ_NOTIFY;\n}\n\n/**\n * __audit_mq_getsetattr - record audit data for a POSIX MQ get/set attribute\n * @mqdes: MQ descriptor\n * @mqstat: MQ flags\n *\n */\nvoid __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->mq_getsetattr.mqdes = mqdes;\n\tcontext->mq_getsetattr.mqstat = *mqstat;\n\tcontext->type = AUDIT_MQ_GETSETATTR;\n}\n\n/**\n * audit_ipc_obj - record audit data for ipc object\n * @ipcp: ipc permissions\n *\n */\nvoid __audit_ipc_obj(struct kern_ipc_perm *ipcp)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->ipc.uid = ipcp->uid;\n\tcontext->ipc.gid = ipcp->gid;\n\tcontext->ipc.mode = ipcp->mode;\n\tcontext->ipc.has_perm = 0;\n\tsecurity_ipc_getsecid(ipcp, &context->ipc.osid);\n\tcontext->type = AUDIT_IPC;\n}\n\n/**\n * audit_ipc_set_perm - record audit data for new ipc permissions\n * @qbytes: msgq bytes\n * @uid: msgq user id\n * @gid: msgq group id\n * @mode: msgq mode (permissions)\n *\n * Called only after audit_ipc_obj().\n */\nvoid __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tcontext->ipc.qbytes = qbytes;\n\tcontext->ipc.perm_uid = uid;\n\tcontext->ipc.perm_gid = gid;\n\tcontext->ipc.perm_mode = mode;\n\tcontext->ipc.has_perm = 1;\n}\n\nvoid __audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tcontext->type = AUDIT_EXECVE;\n\tcontext->execve.argc = bprm->argc;\n}\n\n\n/**\n * audit_socketcall - record audit data for sys_socketcall\n * @nargs: number of args, which should not be more than AUDITSC_ARGS.\n * @args: args array\n *\n */\nint __audit_socketcall(int nargs, unsigned long *args)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tif (nargs <= 0 || nargs > AUDITSC_ARGS || !args)\n\t\treturn -EINVAL;\n\tcontext->type = AUDIT_SOCKETCALL;\n\tcontext->socketcall.nargs = nargs;\n\tmemcpy(context->socketcall.args, args, nargs * sizeof(unsigned long));\n\treturn 0;\n}\n\n/**\n * __audit_fd_pair - record audit data for pipe and socketpair\n * @fd1: the first file descriptor\n * @fd2: the second file descriptor\n *\n */\nvoid __audit_fd_pair(int fd1, int fd2)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->fds[0] = fd1;\n\tcontext->fds[1] = fd2;\n}\n\n/**\n * audit_sockaddr - record audit data for sys_bind, sys_connect, sys_sendto\n * @len: data length in user space\n * @a: data address in kernel space\n *\n * Returns 0 for success or NULL context or < 0 on error.\n */\nint __audit_sockaddr(int len, void *a)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tif (!context->sockaddr) {\n\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tcontext->sockaddr = p;\n\t}\n\n\tcontext->sockaddr_len = len;\n\tmemcpy(context->sockaddr, a, len);\n\treturn 0;\n}\n\nvoid __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tcontext->target_pid = task_pid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}\n\n/**\n * audit_signal_info - record signal info for shutting down audit subsystem\n * @sig: signal value\n * @t: task being signaled\n *\n * If the audit subsystem is being terminated, record the task (pid)\n * and uid that is doing that.\n */\nint __audit_signal_info(int sig, struct task_struct *t)\n{\n\tstruct audit_aux_data_pids *axp;\n\tstruct task_struct *tsk = current;\n\tstruct audit_context *ctx = tsk->audit_context;\n\tkuid_t uid = current_uid(), t_uid = task_uid(t);\n\n\tif (audit_pid && t->tgid == audit_pid) {\n\t\tif (sig == SIGTERM || sig == SIGHUP || sig == SIGUSR1 || sig == SIGUSR2) {\n\t\t\taudit_sig_pid = task_pid_nr(tsk);\n\t\t\tif (uid_valid(tsk->loginuid))\n\t\t\t\taudit_sig_uid = tsk->loginuid;\n\t\t\telse\n\t\t\t\taudit_sig_uid = uid;\n\t\t\tsecurity_task_getsecid(tsk, &audit_sig_sid);\n\t\t}\n\t\tif (!audit_signals || audit_dummy_context())\n\t\t\treturn 0;\n\t}\n\n\t/* optimize the common case by putting first signal recipient directly\n\t * in audit_context */\n\tif (!ctx->target_pid) {\n\t\tctx->target_pid = task_tgid_nr(t);\n\t\tctx->target_auid = audit_get_loginuid(t);\n\t\tctx->target_uid = t_uid;\n\t\tctx->target_sessionid = audit_get_sessionid(t);\n\t\tsecurity_task_getsecid(t, &ctx->target_sid);\n\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\n\t\treturn 0;\n\t}\n\n\taxp = (void *)ctx->aux_pids;\n\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\n\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\n\t\tif (!axp)\n\t\t\treturn -ENOMEM;\n\n\t\taxp->d.type = AUDIT_OBJ_PID;\n\t\taxp->d.next = ctx->aux_pids;\n\t\tctx->aux_pids = (void *)axp;\n\t}\n\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\n\n\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);\n\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\n\taxp->target_uid[axp->pid_count] = t_uid;\n\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &axp->target_sid[axp->pid_count]);\n\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\n\taxp->pid_count++;\n\n\treturn 0;\n}\n\n/**\n * __audit_log_bprm_fcaps - store information about a loading bprm and relevant fcaps\n * @bprm: pointer to the bprm being processed\n * @new: the proposed new credentials\n * @old: the old credentials\n *\n * Simply check if the proc already has the caps given by the file and if not\n * store the priv escalation info for later auditing at the end of the syscall\n *\n * -Eric\n */\nint __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t   const struct cred *new, const struct cred *old)\n{\n\tstruct audit_aux_data_bprm_fcaps *ax;\n\tstruct audit_context *context = current->audit_context;\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\n\tax->d.type = AUDIT_BPRM_FCAPS;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\n\tget_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\n\tax->fcap.permitted = vcaps.permitted;\n\tax->fcap.inheritable = vcaps.inheritable;\n\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\n\n\tax->old_pcap.permitted   = old->cap_permitted;\n\tax->old_pcap.inheritable = old->cap_inheritable;\n\tax->old_pcap.effective   = old->cap_effective;\n\n\tax->new_pcap.permitted   = new->cap_permitted;\n\tax->new_pcap.inheritable = new->cap_inheritable;\n\tax->new_pcap.effective   = new->cap_effective;\n\treturn 0;\n}\n\n/**\n * __audit_log_capset - store information about the arguments to the capset syscall\n * @new: the new credentials\n * @old: the old (current) credentials\n *\n * Record the arguments userspace sent to sys_capset for later printing by the\n * audit system if applicable\n */\nvoid __audit_log_capset(const struct cred *new, const struct cred *old)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->capset.pid = task_pid_nr(current);\n\tcontext->capset.cap.effective   = new->cap_effective;\n\tcontext->capset.cap.inheritable = new->cap_effective;\n\tcontext->capset.cap.permitted   = new->cap_permitted;\n\tcontext->type = AUDIT_CAPSET;\n}\n\nvoid __audit_mmap_fd(int fd, int flags)\n{\n\tstruct audit_context *context = current->audit_context;\n\tcontext->mmap.fd = fd;\n\tcontext->mmap.flags = flags;\n\tcontext->type = AUDIT_MMAP;\n}\n\nstatic void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_pid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}\n\n/**\n * audit_core_dumps - record information about processes that end abnormally\n * @signr: signal value\n *\n * If a process ends with a core dump, something fishy is going on and we\n * should record the event for investigation.\n */\nvoid audit_core_dumps(long signr)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tif (signr == SIGQUIT)\t/* don't care for those */\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_ANOM_ABEND);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld\", signr);\n\taudit_log_end(ab);\n}\n\nvoid __audit_seccomp(unsigned long syscall, long signr, int code)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_SECCOMP);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\",\n\t\t\t signr, syscall_get_arch(), syscall,\n\t\t\t in_compat_syscall(), KSTK_EIP(current), code);\n\taudit_log_end(ab);\n}\n\nstruct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = current->audit_context;\n\tif (likely(!ctx || !ctx->in_syscall))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}\n"], "filenames": ["kernel/auditsc.c"], "buggy_code_start_loc": [75], "buggy_code_end_loc": [1173], "fixing_code_start_loc": [76], "fixing_code_end_loc": [1169], "type": "CWE-362", "message": "Race condition in the audit_log_single_execve_arg function in kernel/auditsc.c in the Linux kernel through 4.7 allows local users to bypass intended character-set restrictions or disrupt system-call auditing by changing a certain string, aka a \"double fetch\" vulnerability.", "other": {"cve": {"id": "CVE-2016-6136", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-06T20:59:06.800", "lastModified": "2018-01-05T02:31:04.667", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the audit_log_single_execve_arg function in kernel/auditsc.c in the Linux kernel through 4.7 allows local users to bypass intended character-set restrictions or disrupt system-call auditing by changing a certain string, aka a \"double fetch\" vulnerability."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n audit_log_single_execve_arg en kernel/auditsc.c en el kernel de Linux hasta la versi\u00f3n 4.7 permite a usuarios locales eludir restricciones de set de caracteres intencionados o interrumpir la auditoria del sistema de llamada cambiando una cierta cadena, tambi\u00e9n conocido como una vulnerabilidad de \"doble recuperaci\u00f3n\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.7", "matchCriteriaId": "6AF8F457-8A21-4907-BB5E-6193D0DAD885"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=43761473c254b45883a64441dd0bc85a42f3645c", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2574.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2584.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2017-0307.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/archive/1/538835/30/0/threaded", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/91558", "source": "cve@mitre.org"}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=120681", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1353533", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/linux-audit/audit-kernel/issues/18", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/43761473c254b45883a64441dd0bc85a42f3645c", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://source.android.com/security/bulletin/2016-11-01.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/43761473c254b45883a64441dd0bc85a42f3645c"}}