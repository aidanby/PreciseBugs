{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nuse Pimcore\\Cache;\nuse Pimcore\\File;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\HttpKernel\\KernelInterface;\n\nclass Pimcore\n{\n    /**\n     * @var bool|null\n     */\n    private static $adminMode;\n\n    /**\n     * @var bool\n     */\n    private static $shutdownEnabled = true;\n\n    /**\n     * @var KernelInterface|null\n     */\n    private static ?KernelInterface $kernel = null;\n\n    /**\n     * @var \\Composer\\Autoload\\ClassLoader\n     */\n    private static $autoloader;\n\n    /**\n     * @return bool\n     */\n    public static function inDebugMode(): bool\n    {\n        return (bool) self::getKernel()->isDebug();\n    }\n\n    /**\n     * @return bool\n     */\n    public static function inDevMode(): bool\n    {\n        if (!isset($_SERVER['PIMCORE_DEV_MODE']) || !is_bool($_SERVER['PIMCORE_DEV_MODE'])) {\n            $value = $_SERVER['PIMCORE_DEV_MODE'] ?? false;\n            if (!is_bool($value)) {\n                $value = filter_var($value, \\FILTER_VALIDATE_BOOLEAN);\n            }\n            $_SERVER['PIMCORE_DEV_MODE'] = (bool) $value;\n        }\n\n        return $_SERVER['PIMCORE_DEV_MODE'];\n    }\n\n    /**\n     * switches pimcore into the admin mode - there you can access also unpublished elements, ....\n     *\n     * @internal\n     */\n    public static function setAdminMode()\n    {\n        self::$adminMode = true;\n    }\n\n    /**\n     * switches back to the non admin mode, where unpublished elements are invisible\n     *\n     * @internal\n     */\n    public static function unsetAdminMode()\n    {\n        self::$adminMode = false;\n    }\n\n    /**\n     * check if the process is currently in admin mode or not\n     *\n     * @return bool\n     */\n    public static function inAdmin()\n    {\n        if (self::$adminMode !== null) {\n            return self::$adminMode;\n        }\n\n        return false;\n    }\n\n    /**\n     * @return bool\n     */\n    public static function isInstalled()\n    {\n        try {\n            \\Pimcore\\Db::get()->fetchOne('SELECT id FROM assets LIMIT 1');\n\n            return true;\n        } catch (\\Exception $e) {\n            return false;\n        }\n    }\n\n    /**\n     * @internal\n     *\n     * @return EventDispatcherInterface\n     */\n    public static function getEventDispatcher()\n    {\n        return self::getContainer()->get('event_dispatcher');\n    }\n\n    /**\n     * @internal\n     *\n     * @return KernelInterface\n     */\n    public static function getKernel()\n    {\n        return self::$kernel;\n    }\n\n    /**\n     * @internal\n     *\n     * @return bool\n     */\n    public static function hasKernel()\n    {\n        if (self::$kernel) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @internal\n     *\n     * @param KernelInterface $kernel\n     */\n    public static function setKernel(KernelInterface $kernel)\n    {\n        self::$kernel = $kernel;\n    }\n\n    /**\n     * Accessing the container this way is discouraged as dependencies should be wired through the container instead of\n     * needing to access the container directly. This exists mainly for compatibility with legacy code.\n     *\n     * @internal\n     *\n     * @deprecated this method just exists for legacy reasons and shouldn't be used in new code\n     *\n     * @return ContainerInterface|null\n     */\n    public static function getContainer()\n    {\n        return static::getKernel()->getContainer();\n    }\n\n    /**\n     * @return bool\n     *\n     * @internal\n     */\n    public static function hasContainer()\n    {\n        if (static::hasKernel()) {\n            try {\n                $container = static::getContainer();\n                if ($container) {\n                    return true;\n                }\n            } catch (\\LogicException) {\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @return \\Composer\\Autoload\\ClassLoader\n     *\n     * @internal\n     */\n    public static function getAutoloader(): \\Composer\\Autoload\\ClassLoader\n    {\n        return self::$autoloader;\n    }\n\n    /**\n     * @param \\Composer\\Autoload\\ClassLoader $autoloader\n     *\n     * @internal\n     */\n    public static function setAutoloader(\\Composer\\Autoload\\ClassLoader $autoloader)\n    {\n        self::$autoloader = $autoloader;\n    }\n\n    /**\n     * Forces a garbage collection.\n     *\n     * @static\n     *\n     * @param array $keepItems\n     */\n    public static function collectGarbage($keepItems = [])\n    {\n        $longRunningHelper = self::getContainer()->get(\\Pimcore\\Helper\\LongRunningHelper::class);\n        $longRunningHelper->cleanUp([\n            'pimcoreRuntimeCache' => [\n                'keepItems' => $keepItems,\n            ],\n        ]);\n    }\n\n    /**\n     * Deletes temporary files which got created during the runtime of current process\n     *\n     * @static\n     */\n    public static function deleteTemporaryFiles()\n    {\n        /** @var \\Pimcore\\Helper\\LongRunningHelper $longRunningHelper */\n        $longRunningHelper = self::getContainer()->get(\\Pimcore\\Helper\\LongRunningHelper::class);\n        $longRunningHelper->deleteTemporaryFiles();\n    }\n\n    /**\n     * this method is called with register_shutdown_function() and writes all data queued into the cache\n     *\n     * @internal\n     */\n    public static function shutdown()\n    {\n        try {\n            self::getContainer();\n        } catch (\\LogicException $e) {\n            return;\n        }\n\n        if (self::$shutdownEnabled && self::isInstalled()) {\n            // write and clean up cache\n            Cache::shutdown();\n        }\n    }\n\n    /**\n     * @internal\n     */\n    public static function disableShutdown()\n    {\n        self::$shutdownEnabled = false;\n    }\n\n    /**\n     * @internal\n     */\n    public static function enableShutdown()\n    {\n        self::$shutdownEnabled = true;\n    }\n\n    /**\n     * @internal\n     *\n     * @return bool\n     */\n    public static function disableMinifyJs(): bool\n    {\n        if (self::inDevMode()) {\n            return true;\n        }\n\n        // magic parameter for debugging ExtJS stuff\n        if (array_key_exists('unminified_js', $_REQUEST) && self::inDebugMode()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @internal\n     *\n     * @throws Exception\n     */\n    public static function initLogger()\n    {\n        // special request log -> if parameter pimcore_log is set\n        if (array_key_exists('pimcore_log', $_REQUEST) && self::inDebugMode()) {\n            $requestLogName = date('Y-m-d_H-i-s');\n            if (!empty($_REQUEST['pimcore_log'])) {\n                // slashed are not allowed, replace them with hyphens\n                $requestLogName = str_replace('/', '-', $_REQUEST['pimcore_log']);\n            }\n\n            $requestLogFile = resolvePath(PIMCORE_LOG_DIRECTORY . '/request-' . $requestLogName . '.log');\n            if (strpos($requestLogFile, PIMCORE_LOG_DIRECTORY) !== 0) {\n                throw new \\Exception('Not allowed');\n            }\n\n            if (!file_exists($requestLogFile)) {\n                File::put($requestLogFile, '');\n            }\n\n            $requestDebugHandler = new \\Monolog\\Handler\\StreamHandler($requestLogFile);\n\n            /** @var \\Symfony\\Component\\DependencyInjection\\Container $container */\n            $container = self::getContainer();\n            foreach ($container->getServiceIds() as $id) {\n                if (strpos($id, 'monolog.logger.') === 0) {\n                    $logger = self::getContainer()->get($id);\n                    if ($logger->getName() != 'event') {\n                        // replace all handlers\n                        $logger->setHandlers([$requestDebugHandler]);\n                    }\n                }\n            }\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nuse Pimcore\\Cache;\nuse Pimcore\\File;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\HttpKernel\\KernelInterface;\n\nclass Pimcore\n{\n    /**\n     * @var bool|null\n     */\n    private static $adminMode;\n\n    /**\n     * @var bool\n     */\n    private static $shutdownEnabled = true;\n\n    /**\n     * @var KernelInterface|null\n     */\n    private static ?KernelInterface $kernel = null;\n\n    /**\n     * @var \\Composer\\Autoload\\ClassLoader\n     */\n    private static $autoloader;\n\n    /**\n     * @return bool\n     */\n    public static function inDebugMode(): bool\n    {\n        return (bool) self::getKernel()->isDebug();\n    }\n\n    /**\n     * @return bool\n     */\n    public static function inDevMode(): bool\n    {\n        if (!isset($_SERVER['PIMCORE_DEV_MODE']) || !is_bool($_SERVER['PIMCORE_DEV_MODE'])) {\n            $value = $_SERVER['PIMCORE_DEV_MODE'] ?? false;\n            if (!is_bool($value)) {\n                $value = filter_var($value, \\FILTER_VALIDATE_BOOLEAN);\n            }\n            $_SERVER['PIMCORE_DEV_MODE'] = (bool) $value;\n        }\n\n        return $_SERVER['PIMCORE_DEV_MODE'];\n    }\n\n    /**\n     * switches pimcore into the admin mode - there you can access also unpublished elements, ....\n     *\n     * @internal\n     */\n    public static function setAdminMode()\n    {\n        self::$adminMode = true;\n    }\n\n    /**\n     * switches back to the non admin mode, where unpublished elements are invisible\n     *\n     * @internal\n     */\n    public static function unsetAdminMode()\n    {\n        self::$adminMode = false;\n    }\n\n    /**\n     * check if the process is currently in admin mode or not\n     *\n     * @return bool\n     */\n    public static function inAdmin()\n    {\n        if (self::$adminMode !== null) {\n            return self::$adminMode;\n        }\n\n        return false;\n    }\n\n    /**\n     * @return bool\n     */\n    public static function isInstalled()\n    {\n        try {\n            \\Pimcore\\Db::get()->fetchOne('SELECT id FROM assets LIMIT 1');\n\n            return true;\n        } catch (\\Exception $e) {\n            return false;\n        }\n    }\n\n    /**\n     * @internal\n     *\n     * @return EventDispatcherInterface\n     */\n    public static function getEventDispatcher()\n    {\n        return self::getContainer()->get('event_dispatcher');\n    }\n\n    /**\n     * @internal\n     *\n     * @return KernelInterface\n     */\n    public static function getKernel()\n    {\n        return self::$kernel;\n    }\n\n    /**\n     * @internal\n     *\n     * @return bool\n     */\n    public static function hasKernel()\n    {\n        if (self::$kernel) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @internal\n     *\n     * @param KernelInterface $kernel\n     */\n    public static function setKernel(KernelInterface $kernel)\n    {\n        self::$kernel = $kernel;\n    }\n\n    /**\n     * Accessing the container this way is discouraged as dependencies should be wired through the container instead of\n     * needing to access the container directly. This exists mainly for compatibility with legacy code.\n     *\n     * @internal\n     *\n     * @deprecated this method just exists for legacy reasons and shouldn't be used in new code\n     *\n     * @return ContainerInterface|null\n     */\n    public static function getContainer()\n    {\n        return static::getKernel()->getContainer();\n    }\n\n    /**\n     * @return bool\n     *\n     * @internal\n     */\n    public static function hasContainer()\n    {\n        if (static::hasKernel()) {\n            try {\n                $container = static::getContainer();\n                if ($container) {\n                    return true;\n                }\n            } catch (\\LogicException) {\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @return \\Composer\\Autoload\\ClassLoader\n     *\n     * @internal\n     */\n    public static function getAutoloader(): \\Composer\\Autoload\\ClassLoader\n    {\n        return self::$autoloader;\n    }\n\n    /**\n     * @param \\Composer\\Autoload\\ClassLoader $autoloader\n     *\n     * @internal\n     */\n    public static function setAutoloader(\\Composer\\Autoload\\ClassLoader $autoloader)\n    {\n        self::$autoloader = $autoloader;\n    }\n\n    /**\n     * Forces a garbage collection.\n     *\n     * @static\n     *\n     * @param array $keepItems\n     */\n    public static function collectGarbage($keepItems = [])\n    {\n        $longRunningHelper = self::getContainer()->get(\\Pimcore\\Helper\\LongRunningHelper::class);\n        $longRunningHelper->cleanUp([\n            'pimcoreRuntimeCache' => [\n                'keepItems' => $keepItems,\n            ],\n        ]);\n    }\n\n    /**\n     * Deletes temporary files which got created during the runtime of current process\n     *\n     * @static\n     */\n    public static function deleteTemporaryFiles()\n    {\n        /** @var \\Pimcore\\Helper\\LongRunningHelper $longRunningHelper */\n        $longRunningHelper = self::getContainer()->get(\\Pimcore\\Helper\\LongRunningHelper::class);\n        $longRunningHelper->deleteTemporaryFiles();\n    }\n\n    /**\n     * this method is called with register_shutdown_function() and writes all data queued into the cache\n     *\n     * @internal\n     */\n    public static function shutdown()\n    {\n        try {\n            self::getContainer();\n        } catch (\\LogicException $e) {\n            return;\n        }\n\n        if (self::$shutdownEnabled && self::isInstalled()) {\n            // write and clean up cache\n            Cache::shutdown();\n        }\n    }\n\n    /**\n     * @internal\n     */\n    public static function disableShutdown()\n    {\n        self::$shutdownEnabled = false;\n    }\n\n    /**\n     * @internal\n     */\n    public static function enableShutdown()\n    {\n        self::$shutdownEnabled = true;\n    }\n\n    /**\n     * @internal\n     *\n     * @return bool\n     */\n    public static function disableMinifyJs(): bool\n    {\n        if (self::inDevMode()) {\n            return true;\n        }\n\n        // magic parameter for debugging ExtJS stuff\n        if (array_key_exists('unminified_js', $_REQUEST) && self::inDebugMode()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @internal\n     *\n     * @throws Exception\n     */\n    public static function initLogger()\n    {\n        // special request log -> if parameter pimcore_log is set\n        if (array_key_exists('pimcore_log', $_REQUEST) && self::inDebugMode()) {\n            $requestLogName = date('Y-m-d_H-i-s');\n            if (!empty($_REQUEST['pimcore_log'])) {\n                $requestLogName = str_replace(['/', '\\\\', '..'], '-', $_REQUEST['pimcore_log']);\n            }\n\n            $requestLogFile = resolvePath(PIMCORE_LOG_DIRECTORY . '/request-' . $requestLogName . '.log');\n            if (strpos($requestLogFile, PIMCORE_LOG_DIRECTORY) !== 0) {\n                throw new \\Exception('Not allowed');\n            }\n\n            if (!file_exists($requestLogFile)) {\n                File::put($requestLogFile, '');\n            }\n\n            $requestDebugHandler = new \\Monolog\\Handler\\StreamHandler($requestLogFile);\n\n            /** @var \\Symfony\\Component\\DependencyInjection\\Container $container */\n            $container = self::getContainer();\n            foreach ($container->getServiceIds() as $id) {\n                if (strpos($id, 'monolog.logger.') === 0) {\n                    $logger = self::getContainer()->get($id);\n                    if ($logger->getName() != 'event') {\n                        // replace all handlers\n                        $logger->setHandlers([$requestDebugHandler]);\n                    }\n                }\n            }\n        }\n    }\n}\n"], "filenames": ["lib/Pimcore.php"], "buggy_code_start_loc": [309], "buggy_code_end_loc": [311], "fixing_code_start_loc": [309], "fixing_code_end_loc": [310], "type": "CWE-29", "message": "Path Traversal: '\\..\\filename' in GitHub repository pimcore/pimcore prior to 10.5.22.", "other": {"cve": {"id": "CVE-2023-2984", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-30T15:15:09.700", "lastModified": "2023-06-05T18:16:42.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Path Traversal: '\\..\\filename' in GitHub repository pimcore/pimcore prior to 10.5.22."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-29"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.22", "matchCriteriaId": "F6F9FCC7-1EC6-4C10-9CEC-1F8E27BD7001"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/e8dbc4da58ae86618bceb67ed35ce23e5e54d2ed", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/5df8b951-e2f1-4548-a7e3-601186e1b191", "source": "security@huntr.dev", "tags": ["Exploit", "Mitigation", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/e8dbc4da58ae86618bceb67ed35ce23e5e54d2ed"}}