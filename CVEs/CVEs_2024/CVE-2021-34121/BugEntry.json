{"buggy_code": ["# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed crash bugs for books (Issue #412, Issue #414)\n- Fixed a number-up crash bug (Issue #413)\n- Fixed JPEG error handling (Issue #415)\n- Fixed crash bugs with bogus table attributes (Issue #416, Issue #417)\n- Fixed a crash bug with malformed URIs (Issue #418)\n- Fixed a crash bug with malformed GIF files (Issue #423)\n- Fixed a crash bug with empty titles (Issue #425)\n- Fixed crash bugs with bogus text (Issue #426, Issue #429, Issue #430,\n  Issue #431)\n- Fixed some issues reported by Coverity.\n- Removed the bundled libjpeg, libpng, and zlib.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * Table of contents generator for HTMLDOC, a HTML document processing\n * program.\n *\n * Copyright 2011-2019 by Michael R Sweet.\n * Copyright 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n\n\n/*\n * Local functions...\n */\n\nstatic void\tadd_heading(tree_t *toc, tree_t *heading);\nstatic void\tparse_tree(tree_t *t);\n\n\n/*\n * Local globals...\n */\n\nstatic int\theading_numbers[15];\nstatic uchar\theading_types[15] =\n\t\t{\n\t\t  '1', '1', '1', '1', '1', '1', '1', '1',\n\t\t  '1', '1', '1', '1', '1', '1', '1'\n\t\t};\nstatic int\tlast_level;\nstatic tree_t\t*heading_parents[15];\n\n\n/*\n * 'toc_build()' - Build a table of contents of the given HTML tree.\n */\n\ntree_t *\t\t\t/* O - Table of contents tree */\ntoc_build(tree_t *tree)\t\t/* I - Document tree */\n{\n  tree_t\t*toc,\t\t/* TOC tree pointer */\n\t\t*title,\t\t/* Title entry */\n\t\t*link;\t\t/* Link entry */\n\n\n  TocDocCount        = 0;\n  last_level         = 0;\t/* Currently at the \"top\" level */\n  heading_numbers[0] = 0;\t/* Start at 1 (see below) */\n\n  toc = htmlAddTree(NULL, MARKUP_BODY, NULL);\n\n  title = htmlAddTree(toc, MARKUP_H1, NULL);\n  htmlSetVariable(title, (uchar *)\"ALIGN\", (uchar *)\"CENTER\");\n  link = htmlAddTree(title, MARKUP_A, NULL);\n  htmlSetVariable(link, (uchar *)\"NAME\", (uchar *)\"CONTENTS\");\n  htmlAddTree(link, MARKUP_NONE, (uchar *)TocTitle);\n\n  heading_parents[0]  = toc;\n  heading_parents[1]  = toc;\n  heading_parents[2]  = toc;\n  heading_parents[3]  = toc;\n  heading_parents[4]  = toc;\n  heading_parents[5]  = toc;\n  heading_parents[6]  = toc;\n  heading_parents[7]  = toc;\n  heading_parents[8]  = toc;\n  heading_parents[9]  = toc;\n  heading_parents[10] = toc;\n  heading_parents[11] = toc;\n  heading_parents[12] = toc;\n  heading_parents[13] = toc;\n  heading_parents[14] = toc;\n\n  parse_tree(tree);\n\n  return (toc);\n}\n\n\n/*\n * 'add_heading()' - Add heading records to the given toc entry...\n */\n\nstatic void\nadd_heading(tree_t *toc,\t/* I - Table of contents */\n            tree_t *heading)\t/* I - Heading entry */\n{\n  while (heading != NULL)\n  {\n    if (heading->markup != MARKUP_UNKNOWN && heading->child != NULL)\n      add_heading(toc, heading->child);\n    else if (heading->markup == MARKUP_NONE && heading->data != NULL)\n      htmlAddTree(toc, MARKUP_NONE, heading->data);\n\n    heading = heading->next;\n  }\n}\n\n\n/*\n * 'parse_tree()' - Parse headings from the given tree...\n *\n * Note: We also add anchor points and numbers as necessary...\n */\n\nstatic void\t\t\t/* O - Tree of TOC entries */\nparse_tree(tree_t *t)\t\t/* I - Document tree */\n{\n  tree_t\t*parent;\t/* Parent of toc entry (DD or LI) */\n  tree_t\t*target,\t/* Link target */\n\t\t*temp;\t\t/* Looping var */\n  uchar\t\theading[255],\t/* Heading numbers */\n\t\tlink[255],\t/* Actual link */\n\t\tbaselink[255],\t/* Base link (numbered) */\n\t\t*existing;\t/* Existing link string */\n  int\t\ti, level;\t/* Header level */\n  uchar\t\t*var;\t\t/* Starting value/type for this level */\n  static const char *ones[10] =\n\t\t{\n\t\t  \"\",\t\"i\",\t\"ii\",\t\"iii\",\t\"iv\",\n\t\t  \"v\",\t\"vi\",\t\"vii\",\t\"viii\",\t\"ix\"\n\t\t},\n\t\t*tens[10] =\n\t\t{\n\t\t  \"\",\t\"x\",\t\"xx\",\t\"xxx\",\t\"xl\",\n\t\t  \"l\",\t\"lx\",\t\"lxx\",\t\"lxxx\",\t\"xc\"\n\t\t},\n\t\t*hundreds[10] =\n\t\t{\n\t\t  \"\",\t\"c\",\t\"cc\",\t\"ccc\",\t\"cd\",\n\t\t  \"d\",\t\"dc\",\t\"dcc\",\t\"dccc\",\t\"cm\"\n\t\t},\n\t\t*ONES[10] =\n\t\t{\n\t\t  \"\",\t\"I\",\t\"II\",\t\"III\",\t\"IV\",\n\t\t  \"V\",\t\"VI\",\t\"VII\",\t\"VIII\",\t\"IX\"\n\t\t},\n\t\t*TENS[10] =\n\t\t{\n\t\t  \"\",\t\"X\",\t\"XX\",\t\"XXX\",\t\"XL\",\n\t\t  \"L\",\t\"LX\",\t\"LXX\",\t\"LXXX\",\t\"XC\"\n\t\t},\n\t\t*HUNDREDS[10] =\n\t\t{\n\t\t  \"\",\t\"C\",\t\"CC\",\t\"CCC\",\t\"CD\",\n\t\t  \"D\",\t\"DC\",\t\"DCC\",\t\"DCCC\",\t\"CM\"\n\t\t};\n\n\n  while (t != NULL)\n  {\n    switch (t->markup)\n    {\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n          level = t->markup - MARKUP_H1;\n\n\t  if ((level - last_level) > 1)\n\t  {\n\t   /*\n\t    * This step necessary to keep page numbers synced up...\n\t    */\n\n\t    level     = last_level + 1;\n\t    t->markup = (markup_t)(MARKUP_H1 + level);\n\t  }\n\n          if ((var = htmlGetVariable(t, (uchar *)\"VALUE\")) != NULL)\n            heading_numbers[level] = atoi((char *)var);\n          else\n            heading_numbers[level] ++;\n\n          if (level == 0)\n            TocDocCount ++;\n\n          if ((var = htmlGetVariable(t, (uchar *)\"TYPE\")) != NULL)\n            heading_types[level] = var[0];\n\n          for (i = level + 1; i < 15; i ++)\n            heading_numbers[i] = 0;\n\n          heading[0]  = '\\0';\n\t  baselink[0] = '\\0';\n\n          for (i = 0; i <= level; i ++)\n          {\n            uchar\t*baseptr = baselink + strlen((char *)baselink);\n            uchar\t*headptr = heading + strlen((char *)heading);\n\n            if (i == 0)\n              snprintf((char *)baseptr, sizeof(baselink) - (size_t)(baseptr - baselink), \"%d\", TocDocCount);\n            else\n              snprintf((char *)baseptr, sizeof(baselink) - (size_t)(baseptr - baselink), \"%d\", heading_numbers[i]);\n\n            switch (heading_types[i])\n            {\n              case '1' :\n                  snprintf((char *)headptr, sizeof(heading) - (size_t)(headptr - heading), \"%d\", heading_numbers[i]);\n                  break;\n              case 'a' :\n                  if (heading_numbers[i] > 26)\n                    snprintf((char *)headptr, sizeof(heading) - (size_t)(headptr - heading), \"%c%c\", 'a' + (heading_numbers[i] / 26) - 1, 'a' + (heading_numbers[i] % 26) - 1);\n                  else\n                    snprintf((char *)headptr, sizeof(heading) - (size_t)(headptr - heading), \"%c\", 'a' + heading_numbers[i] - 1);\n                  break;\n              case 'A' :\n                  if (heading_numbers[i] > 26)\n                    snprintf((char *)headptr, sizeof(heading) - (size_t)(headptr - heading), \"%c%c\", 'A' + (heading_numbers[i] / 26) - 1, 'A' + (heading_numbers[i] % 26) - 1);\n                  else\n                    snprintf((char *)headptr, sizeof(heading) - (size_t)(headptr - heading), \"%c\", 'A' + heading_numbers[i] - 1);\n                  break;\n              case 'i' :\n                  snprintf((char *)headptr, sizeof(heading) - (size_t)(headptr - heading), \"%s%s%s\", hundreds[heading_numbers[i] / 100], tens[(heading_numbers[i] / 10) % 10], ones[heading_numbers[i] % 10]);\n                  break;\n              case 'I' :\n                  snprintf((char *)headptr, sizeof(heading) - (size_t)(headptr - heading), \"%s%s%s\", HUNDREDS[heading_numbers[i] / 100], TENS[(heading_numbers[i] / 10) % 10], ONES[heading_numbers[i] % 10]);\n                  break;\n            }\n\n            if (i < level)\n            {\n              strlcat((char *)heading, \".\", sizeof(heading));\n              strlcat((char *)baselink, \"_\", sizeof(baselink));\n            }\n          }\n\n         /*\n\t  * See if we have an existing <A NAME=...> or <A ID=...> for this\n\t  * heading...\n\t  */\n\n          existing = NULL;\n\n          if (t->parent != NULL && t->parent->markup == MARKUP_A)\n          {\n\t    existing = htmlGetVariable(t->parent, (uchar *)\"NAME\");\n\n\t    if (!existing)\n              existing = htmlGetVariable(t->parent, (uchar *)\"ID\");\n          }\n\n\t  if (existing == NULL &&\n              t->child != NULL && t->child->markup == MARKUP_A)\n          {\n\t    existing = htmlGetVariable(t->child, (uchar *)\"NAME\");\n\n\t    if (!existing)\n              existing = htmlGetVariable(t->child, (uchar *)\"ID\");\n          }\n\n          if (existing != NULL &&\n\t      strlen((char *)existing) >= 124)\t/* Max size of link name */\n\t    existing = NULL;\n\n          if (existing != NULL)\n\t    snprintf((char *)link, sizeof(link), \"#%s\", existing);\n\t  else\n\t    snprintf((char *)link, sizeof(link), \"#%s\", baselink);\n\n         /*\n\t  * Number the headings as needed...\n\t  */\n\n          if (TocNumbers)\n\t  {\n            strlcat((char *)heading, \" \", sizeof(heading));\n\n            htmlInsertTree(t, MARKUP_NONE, heading);\n\t  }\n\n         /*\n\t  * Add the heading to the table of contents...\n\t  */\n\n          if (level < TocLevels)\n          {\n            if (level > last_level)\n\t    {\n\t      if (heading_parents[last_level]->last_child && level > 1)\n        \theading_parents[level] =\n\t\t    htmlAddTree(heading_parents[last_level]->last_child,\n                                MARKUP_UL, NULL);\n              else\n        \theading_parents[level] =\n\t\t    htmlAddTree(heading_parents[last_level], MARKUP_UL, NULL);\n\n              DEBUG_printf((\"level=%d, last_level=%d, created new UL parent %p\\n\",\n\t                    level, last_level, (void *)heading_parents[level]));\n\t    }\n\n            if (level == 0)\n            {\n              if (last_level == 0)\n              {\n                htmlAddTree(heading_parents[level], MARKUP_BR, NULL);\n                htmlAddTree(heading_parents[level], MARKUP_BR, NULL);\n              }\n\n              parent = htmlAddTree(heading_parents[level], MARKUP_B, NULL);\n            }\n            else\n              parent = htmlAddTree(heading_parents[level], MARKUP_LI, NULL);\n\n            DEBUG_printf((\"parent=%p\\n\", (void *)parent));\n\n            if ((var = htmlGetVariable(t, (uchar *)\"_HD_OMIT_TOC\")) != NULL)\n\t      htmlSetVariable(parent, (uchar *)\"_HD_OMIT_TOC\", var);\n\n            if (TocLinks)\n            {\n             /*\n              * Add a link for the toc...\n              */\n\n              parent = htmlAddTree(parent, MARKUP_A, NULL);\n              htmlSetVariable(parent, (uchar *)\"HREF\", link);\n\n             /*\n              * Insert a NAME marker if needed and reparent all the\n\t      * heading children.\n              */\n\n              if (existing == NULL)\n\t      {\n\t       /*\n\t        * Add NAME to existing A element, if present.\n\t\t*/\n\n                if (t->parent != NULL && t->parent->markup == MARKUP_A)\n\t          htmlSetVariable(t->parent, (uchar *)\"NAME\", baselink);\n\t\telse if (t->child != NULL && t->child->markup == MARKUP_A)\n\t          htmlSetVariable(t->child, (uchar *)\"NAME\", baselink);\n\t\telse\n\t\t{\n        \t  target = htmlNewTree(t, MARKUP_A, NULL);\n\n        \t  htmlSetVariable(target, (uchar *)\"NAME\", baselink);\n        \t  for (temp = t->child; temp != NULL; temp = temp->next)\n                    temp->parent = target;\n\n        \t  target->child = t->child;\n        \t  t->child      = target;\n\t        }\n\t      }\n            }\n\n            add_heading(parent, t->child);\n          }\n\n          last_level = level;\n          break;\n\n      default :\n          if (t->child != NULL)\n            parse_tree(t->child);\n          break;\n    }\n\n    t = t->next;\n  }\n}\n", "/*\n * Utility functions for HTMLDOC, a HTML document processing program.\n *\n * Copyright \u00a9 2011-2020 by Michael R Sweet.\n * Copyright \u00a9 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n#include <ctype.h>\n\n\n/*\n * 'format_number()' - Format a number into arabic numerals, roman numerals,\n *                     or letters.\n */\n\nchar *\t\t\t\t/* O - String */\nformat_number(int  n,\t\t/* I - Number */\n              char f)\t\t/* I - Format */\n{\n  static const char *ones[10] =\t/* Roman numerals, 0-9 */\n\t\t{\n\t\t  \"\",\t\"i\",\t\"ii\",\t\"iii\",\t\"iv\",\n\t\t  \"v\",\t\"vi\",\t\"vii\",\t\"viii\",\t\"ix\"\n\t\t},\n\t\t*tens[10] =\t/* Roman numerals, 10-90 */\n\t\t{\n\t\t  \"\",\t\"x\",\t\"xx\",\t\"xxx\",\t\"xl\",\n\t\t  \"l\",\t\"lx\",\t\"lxx\",\t\"lxxx\",\t\"xc\"\n\t\t},\n\t\t*hundreds[10] =\t/* Roman numerals, 100-900 */\n\t\t{\n\t\t  \"\",\t\"c\",\t\"cc\",\t\"ccc\",\t\"cd\",\n\t\t  \"d\",\t\"dc\",\t\"dcc\",\t\"dccc\",\t\"cm\"\n\t\t};\n  static const char *ONES[10] =\t/* Roman numerals, 0-9 */\n\t\t{\n\t\t  \"\",\t\"I\",\t\"II\",\t\"III\",\t\"IV\",\n\t\t  \"V\",\t\"VI\",\t\"VII\",\t\"VIII\",\t\"IX\"\n\t\t},\n\t\t*TENS[10] =\t/* Roman numerals, 10-90 */\n\t\t{\n\t\t  \"\",\t\"X\",\t\"XX\",\t\"XXX\",\t\"XL\",\n\t\t  \"L\",\t\"LX\",\t\"LXX\",\t\"LXXX\",\t\"XC\"\n\t\t},\n\t\t*HUNDREDS[10] =\t/* Roman numerals, 100-900 */\n\t\t{\n\t\t  \"\",\t\"C\",\t\"CC\",\t\"CCC\",\t\"CD\",\n\t\t  \"D\",\t\"DC\",\t\"DCC\",\t\"DCCC\",\t\"CM\"\n\t\t};\n  static char\tbuffer[1024];\t/* String buffer */\n\n\n  switch (f)\n  {\n    default :\n        buffer[0] = '\\0';\n\tbreak;\n\n    case 'a' :\n        if (n >= (26 * 26))\n\t  buffer[0] = '\\0';\n        else if (n > 26)\n          snprintf(buffer, sizeof(buffer), \"%c%c\", 'a' + (n / 26) - 1, 'a' + (n % 26) - 1);\n        else\n          snprintf(buffer, sizeof(buffer), \"%c\", 'a' + n - 1);\n        break;\n\n    case 'A' :\n        if (n >= (26 * 26))\n\t  buffer[0] = '\\0';\n        else if (n > 26)\n          snprintf(buffer, sizeof(buffer), \"%c%c\", 'A' + (n / 26) - 1, 'A' + (n % 26) - 1);\n        else\n          snprintf(buffer, sizeof(buffer), \"%c\", 'A' + n - 1);\n        break;\n\n    case '1' :\n        snprintf(buffer, sizeof(buffer), \"%d\", n);\n        break;\n\n    case 'i' :\n        if (n >= 1000)\n\t  buffer[0] = '\\0';\n\telse\n          snprintf(buffer, sizeof(buffer), \"%s%s%s\", hundreds[n / 100], tens[(n / 10) % 10], ones[n % 10]);\n        break;\n\n    case 'I' :\n        if (n >= 1000)\n\t  buffer[0] = '\\0';\n\telse\n          snprintf(buffer, sizeof(buffer), \"%s%s%s\", HUNDREDS[n / 100], TENS[(n / 10) % 10], ONES[n % 10]);\n        break;\n  }\n\n  return (buffer);\n}\n\n\n/*\n * 'get_color()' - Get a standard color value...\n */\n\nvoid\nget_color(const uchar *color,\t/* I - Color attribute */\n          float       *rgb,\t/* O - RGB value */\n\t  int         defblack)\t/* I - Default color is black? */\n{\n  int\t\ti;\t\t/* Looping vars */\n  static uchar\ttempcolor[8];\t/* Temporary holding place for hex colors */\n  static struct\n  {\n    const char\t*name;\t\t/* Color name */\n    uchar\tred,\t\t/* Red value */\n\t\tgreen,\t\t/* Green value */\n\t\tblue;\t\t/* Blue value */\n  }\t\tcolors[] =\t/* Color \"database\" */\n  {\n    { \"aqua\",\t\t0,   255, 255 }, /* AKA Cyan */\n    { \"black\",\t\t0,   0,   0 },\n    { \"blue\",\t\t0,   0,   255 },\n    { \"cyan\",\t\t0,   255, 255 },\n    { \"fuchsia\",\t255, 0,   255 }, /* AKA Magenta */\n    { \"gray\",\t\t128, 128, 128 },\n    { \"green\",\t\t0,   128, 0 },\n    { \"grey\",\t\t128, 128, 128 },\n    { \"lime\",\t\t0,   255, 0 },\n    { \"magenta\",\t255, 0,   255 },\n    { \"maroon\",\t\t128, 0,   0 },\n    { \"navy\",\t\t0,   0,   128 },\n    { \"olive\",\t\t128, 128, 0 },\n    { \"purple\",\t\t128, 0,   128 },\n    { \"red\",\t\t255, 0,   0 },\n    { \"silver\",\t\t192, 192, 192 },\n    { \"teal\",\t\t0,   128, 128 },\n    { \"white\",\t\t255, 255, 255 },\n    { \"yellow\",\t\t255, 255, 0 }\n  };\n\n\n  // First, see if this is a hex color with a missing # in front...\n  if (strlen((char *)color) == 6)\n  {\n    for (i = 0; i < 6; i ++)\n      if (!isxdigit(color[i]))\n        break;\n\n    if (i == 3 || i == 6)\n    {\n      // Update the color name to be #RRGGBB instead of RRGGBB...\n      tempcolor[0] = '#';\n      strlcpy((char *)tempcolor + 1, (char *)color, sizeof(tempcolor) - 1);\n      color = tempcolor;\n    }\n  }\n\n  if (!color[0])\n  {\n    if (defblack)\n    {\n      rgb[0] = 0.0f;\n      rgb[1] = 0.0f;\n      rgb[2] = 0.0f;\n    }\n    else\n    {\n      rgb[0] = 1.0f;\n      rgb[1] = 1.0f;\n      rgb[2] = 1.0f;\n    }\n    return;\n  }\n  else if (color[0] == '#')\n  {\n   /*\n    * RGB value in hex...\n    */\n\n    i = (int)strlen((char *)color + 1);\n    if (i == 3)\n    {\n      i      = strtol((char *)color + 1, NULL, 16);\n      rgb[0] = (i >> 8) / 15.0f;\n      rgb[1] = ((i >> 4) & 15) / 15.0f;\n      rgb[2] = (i & 15) / 15.0f;\n    }\n    else if (i == 6)\n    {\n      i      = strtol((char *)color + 1, NULL, 16);\n      rgb[0] = (i >> 16) / 255.0f;\n      rgb[1] = ((i >> 8) & 255) / 255.0f;\n      rgb[2] = (i & 255) / 255.0f;\n    }\n    else if (defblack)\n    {\n      rgb[0] = rgb[1] = rgb[2] = 0.0f;\n    }\n    else\n    {\n      rgb[0] = rgb[1] = rgb[2] = 1.0f;\n    }\n  }\n  else\n  {\n    for (i = 0; i < (int)(sizeof(colors) / sizeof(colors[0])); i ++)\n      if (strcasecmp(colors[i].name, (char *)color) == 0)\n\tbreak;\n\n    if (i >= (int)(sizeof(colors) / sizeof(colors[0])))\n    {\n      if (defblack)\n        i = 1; /* Black */\n      else\n        i = 17; /* White */\n    }\n\n    rgb[0] = colors[i].red / 255.0f;\n    rgb[1] = colors[i].green / 255.0f;\n    rgb[2] = colors[i].blue / 255.0f;\n  }\n}\n\n\n//\n// 'get_format()' - Convert an old \"fff\" format string to the new format.\n//\n\nvoid\nget_format(const char *fmt,\t\t// I - Old \"fff\" format\n           char       **formats)\t// O - New format strings\n{\n  int\ti;\t\t\t\t// Looping var\n\n\n  for (i = 0; i < 3; i ++)\n  {\n    if (formats[i])\n    {\n      free(formats[i]);\n      formats[i] = NULL;\n    }\n\n    switch (fmt[i])\n    {\n      case '/' :\n          formats[i] = strdup(\"$PAGE(1)/$PAGES\");\n          break;\n\n      case ':' :\n          formats[i] = strdup(\"$CHAPTERPAGE(1)/$CHAPTERPAGES\");\n          break;\n\n      case '1' :\n          formats[i] = strdup(\"$PAGE(1)\");\n          break;\n\n      case 'a' :\n          formats[i] = strdup(\"$PAGE(a)\");\n          break;\n\n      case 'A' :\n          formats[i] = strdup(\"$PAGE(A)\");\n          break;\n\n      case 'c' :\n          formats[i] = strdup(\"$CHAPTER\");\n          break;\n\n      case 'C' :\n          formats[i] = strdup(\"$CHAPTERPAGE(1)\");\n          break;\n\n      case 'd' :\n          formats[i] = strdup(\"$DATE\");\n          break;\n\n      case 'D' :\n          formats[i] = strdup(\"$DATE $TIME\");\n          break;\n\n      case 'h' :\n          formats[i] = strdup(\"$HEADING\");\n          break;\n\n      case 'i' :\n          formats[i] = strdup(\"$PAGE(i)\");\n          break;\n\n      case 'I' :\n          formats[i] = strdup(\"$PAGE(I)\");\n          break;\n\n      case 'l' :\n          formats[i] = strdup(\"$LOGOIMAGE\");\n          break;\n\n      case 'L' :\n          formats[i] = strdup(\"$LETTERHEAD\");\n          break;\n\n      case 't' :\n          formats[i] = strdup(\"$TITLE\");\n          break;\n\n      case 'T' :\n          formats[i] = strdup(\"$TIME\");\n          break;\n\n      case 'u' :\n          formats[i] = strdup(\"$URL\");\n          break;\n\n      default :\n          formats[i] = NULL;\n          break;\n    }\n  }\n}\n\n\n//\n// 'get_fmt()' - Convert a new format string to the old \"fff\" format.\n//\n\nconst char *\t\t\t\t// O - Old format string\nget_fmt(char **formats)\t\t\t// I - New format strings\n{\n  int\t\ti, j;\t\t\t// Looping vars\n  static char\tfmt[4];\t\t\t// Old format string\n  static struct\t\t\t\t// Format string conversions...\n  {\n    char\tf;\t\t\t// Format character\n    const char\t*format;\t\t// Format string\n  }\t\ttable[] =\n  {\n    { '/', \"$PAGE(1)/$PAGES\" },\n    { ':', \"$CHAPTERPAGE(1)/$CHAPTERPAGES\" },\n    { '1', \"$PAGE(1)\" },\n    { 'a', \"$PAGE(a)\" },\n    { 'A', \"$PAGE(A)\" },\n    { 'c', \"$CHAPTER\" },\n    { 'C', \"$CHAPTERPAGE(1)\" },\n    { 'd', \"$DATE\" },\n    { 'D', \"$DATE $TIME\" },\n    { 'h', \"$HEADING\" },\n    { 'i', \"$PAGE(i)\" },\n    { 'I', \"$PAGE(I)\" },\n    { 'l', \"$LOGOIMAGE\" },\n    { 't', \"$TITLE\" },\n    { 'T', \"$TIME\" }\n  };\n\n\n  // Safe because fmt is 4 chars long\n  strlcpy(fmt, \"...\", sizeof(fmt));\n\n  for (i = 0; i < 3; i ++)\n    if (formats[i])\n      for (j = 0; j < (int)(sizeof(table) / sizeof(table[0])); j ++)\n        if (strcmp(formats[i], table[j].format) == 0)\n\t{\n\t  fmt[i] = table[j].f;\n\t  break;\n\t}\n\n  return (fmt);\n}\n\n\n/*\n * 'get_measurement()' - Get a size measurement in inches, points, centimeters,\n *                       or millimeters.\n */\n\nint\t\t\t\t/* O - Measurement in points */\nget_measurement(const char *s,\t/* I - Measurement string */\n                float      mul)\t/* I - Multiplier */\n{\n  float\tval;\t\t\t/* Measurement value */\n\n\n /*\n  * Get the floating point value of \"s\" and skip all digits and decimal points.\n  */\n\n  val = (float)atof(s);\n  while (isdigit(*s) || *s == '.')\n    s ++;\n\n /*\n  * Check for a trailing unit specifier...\n  */\n\n  if (strcasecmp(s, \"mm\") == 0)\n    val *= 72.0f / 25.4f;\n  else if (strcasecmp(s, \"cm\") == 0)\n    val *= 72.0f / 2.54f;\n  else if (strncasecmp(s, \"in\", 2) == 0)\n    val *= 72.0f;\n  else\n    val *= mul;\n\n  return ((int)val);\n}\n\n\n/*\n * 'set_page_size()' - Set the output page size.\n */\n\nvoid\nset_page_size(const char *size)\t/* I - Page size string */\n{\n  float\twidth,\t\t\t/* Width in points */\n\tlength;\t\t\t/* Length in points */\n  char\tunits[255];\t\t/* Units string */\n\n\n /*\n  * Check for common media sizes...\n  */\n\n  if (strcasecmp(size, \"letter\") == 0 ||\n      strcasecmp(size, \"a\") == 0)\n  {\n   /*\n    * US Letter - 8.5x11 inches (216x279mm).\n    */\n\n    PageWidth  = 612;\n    PageLength = 792;\n  }\n  else if (strcasecmp(size, \"legal\") == 0)\n  {\n   /*\n    * US Legal - 8.5x14 inches (216x356mm).\n    */\n\n    PageWidth  = 612;\n    PageLength = 1008;\n  }\n  else if (strcasecmp(size, \"tabloid\") == 0 ||\n           strcasecmp(size, \"b\") == 0)\n  {\n   /*\n    * US Tabloid - 11x17 inches (279x432mm).\n    */\n\n    PageWidth  = 792;\n    PageLength = 1224;\n  }\n  else if (strcasecmp(size, \"a4\") == 0)\n  {\n   /*\n    * European standard A4 - 210x297mm (8.27x11.69 inches).\n    */\n\n    PageWidth  = 595;\n    PageLength = 842;\n  }\n  else if (strcasecmp(size, \"a3\") == 0)\n  {\n   /*\n    * European standard A3 - 297x420mm (11.69x16.54 inches).\n    */\n\n    PageWidth  = 842;\n    PageLength = 1190;\n  }\n  else if (strcasecmp(size, \"universal\") == 0)\n  {\n   /*\n    * \"Universal\" size - 8.27x11.00 inches (210x279mm).\n    */\n\n    PageWidth  = 595;\n    PageLength = 792;\n  }\n  else if (sscanf(size, \"%fx%f%254s\", &width, &length, units) >= 2)\n  {\n   /*\n    * Custom size...\n    */\n\n    if (strcasecmp(units, \"mm\") == 0)\n    {\n      PageWidth  = (int)(72.0 * width / 25.4);\n      PageLength = (int)(72.0 * length / 25.4);\n    }\n    else if (strcasecmp(units, \"cm\") == 0)\n    {\n      PageWidth  = (int)(72.0 * width / 2.54);\n      PageLength = (int)(72.0 * length / 2.54);\n    }\n    else if (strncasecmp(units, \"in\", 2) == 0)\n    {\n      PageWidth  = (int)(72.0 * width);\n      PageLength = (int)(72.0 * length);\n    }\n    else\n    {\n      PageWidth  = (int)width;\n      PageLength = (int)length;\n    }\n  }\n}\n"], "fixing_code": ["# Changes in HTMLDOC v1.9.13\n\n- Fixed an issue with large values for roman numerals and letters in headings\n  (Issue #433)\n\n\n# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed crash bugs for books (Issue #412, Issue #414)\n- Fixed a number-up crash bug (Issue #413)\n- Fixed JPEG error handling (Issue #415)\n- Fixed crash bugs with bogus table attributes (Issue #416, Issue #417)\n- Fixed a crash bug with malformed URIs (Issue #418)\n- Fixed a crash bug with malformed GIF files (Issue #423)\n- Fixed a crash bug with empty titles (Issue #425)\n- Fixed crash bugs with bogus text (Issue #426, Issue #429, Issue #430,\n  Issue #431)\n- Fixed some issues reported by Coverity.\n- Removed the bundled libjpeg, libpng, and zlib.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * Table of contents generator for HTMLDOC, a HTML document processing\n * program.\n *\n * Copyright 2011-2019 by Michael R Sweet.\n * Copyright 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n\n\n/*\n * Local functions...\n */\n\nstatic void\tadd_heading(tree_t *toc, tree_t *heading);\nstatic void\tparse_tree(tree_t *t);\n\n\n/*\n * Local globals...\n */\n\nstatic int\theading_numbers[15];\nstatic uchar\theading_types[15] =\n\t\t{\n\t\t  '1', '1', '1', '1', '1', '1', '1', '1',\n\t\t  '1', '1', '1', '1', '1', '1', '1'\n\t\t};\nstatic int\tlast_level;\nstatic tree_t\t*heading_parents[15];\n\n\n/*\n * 'toc_build()' - Build a table of contents of the given HTML tree.\n */\n\ntree_t *\t\t\t/* O - Table of contents tree */\ntoc_build(tree_t *tree)\t\t/* I - Document tree */\n{\n  tree_t\t*toc,\t\t/* TOC tree pointer */\n\t\t*title,\t\t/* Title entry */\n\t\t*link;\t\t/* Link entry */\n\n\n  TocDocCount        = 0;\n  last_level         = 0;\t/* Currently at the \"top\" level */\n  heading_numbers[0] = 0;\t/* Start at 1 (see below) */\n\n  toc = htmlAddTree(NULL, MARKUP_BODY, NULL);\n\n  title = htmlAddTree(toc, MARKUP_H1, NULL);\n  htmlSetVariable(title, (uchar *)\"ALIGN\", (uchar *)\"CENTER\");\n  link = htmlAddTree(title, MARKUP_A, NULL);\n  htmlSetVariable(link, (uchar *)\"NAME\", (uchar *)\"CONTENTS\");\n  htmlAddTree(link, MARKUP_NONE, (uchar *)TocTitle);\n\n  heading_parents[0]  = toc;\n  heading_parents[1]  = toc;\n  heading_parents[2]  = toc;\n  heading_parents[3]  = toc;\n  heading_parents[4]  = toc;\n  heading_parents[5]  = toc;\n  heading_parents[6]  = toc;\n  heading_parents[7]  = toc;\n  heading_parents[8]  = toc;\n  heading_parents[9]  = toc;\n  heading_parents[10] = toc;\n  heading_parents[11] = toc;\n  heading_parents[12] = toc;\n  heading_parents[13] = toc;\n  heading_parents[14] = toc;\n\n  parse_tree(tree);\n\n  return (toc);\n}\n\n\n/*\n * 'add_heading()' - Add heading records to the given toc entry...\n */\n\nstatic void\nadd_heading(tree_t *toc,\t/* I - Table of contents */\n            tree_t *heading)\t/* I - Heading entry */\n{\n  while (heading != NULL)\n  {\n    if (heading->markup != MARKUP_UNKNOWN && heading->child != NULL)\n      add_heading(toc, heading->child);\n    else if (heading->markup == MARKUP_NONE && heading->data != NULL)\n      htmlAddTree(toc, MARKUP_NONE, heading->data);\n\n    heading = heading->next;\n  }\n}\n\n\n/*\n * 'parse_tree()' - Parse headings from the given tree...\n *\n * Note: We also add anchor points and numbers as necessary...\n */\n\nstatic void\t\t\t/* O - Tree of TOC entries */\nparse_tree(tree_t *t)\t\t/* I - Document tree */\n{\n  tree_t\t*parent;\t/* Parent of toc entry (DD or LI) */\n  tree_t\t*target,\t/* Link target */\n\t\t*temp;\t\t/* Looping var */\n  uchar\t\theading[255],\t/* Heading numbers */\n\t\tlink[255],\t/* Actual link */\n\t\tbaselink[255],\t/* Base link (numbered) */\n\t\t*existing;\t/* Existing link string */\n  int\t\ti, level;\t/* Header level */\n  uchar\t\t*var;\t\t/* Starting value/type for this level */\n\n\n  while (t != NULL)\n  {\n    switch (t->markup)\n    {\n      case MARKUP_H1 :\n      case MARKUP_H2 :\n      case MARKUP_H3 :\n      case MARKUP_H4 :\n      case MARKUP_H5 :\n      case MARKUP_H6 :\n      case MARKUP_H7 :\n      case MARKUP_H8 :\n      case MARKUP_H9 :\n      case MARKUP_H10 :\n      case MARKUP_H11 :\n      case MARKUP_H12 :\n      case MARKUP_H13 :\n      case MARKUP_H14 :\n      case MARKUP_H15 :\n          level = t->markup - MARKUP_H1;\n\n\t  if ((level - last_level) > 1)\n\t  {\n\t   /*\n\t    * This step necessary to keep page numbers synced up...\n\t    */\n\n\t    level     = last_level + 1;\n\t    t->markup = (markup_t)(MARKUP_H1 + level);\n\t  }\n\n          if ((var = htmlGetVariable(t, (uchar *)\"VALUE\")) != NULL)\n            heading_numbers[level] = atoi((char *)var);\n          else\n            heading_numbers[level] ++;\n\n          if (level == 0)\n            TocDocCount ++;\n\n          if ((var = htmlGetVariable(t, (uchar *)\"TYPE\")) != NULL)\n            heading_types[level] = var[0];\n\n          for (i = level + 1; i < 15; i ++)\n            heading_numbers[i] = 0;\n\n          heading[0]  = '\\0';\n\t  baselink[0] = '\\0';\n\n          for (i = 0; i <= level; i ++)\n          {\n            uchar\t*baseptr = baselink + strlen((char *)baselink);\n            uchar\t*headptr = heading + strlen((char *)heading);\n\n            if (i == 0)\n              snprintf((char *)baseptr, sizeof(baselink) - (size_t)(baseptr - baselink), \"%d\", TocDocCount);\n            else\n              snprintf((char *)baseptr, sizeof(baselink) - (size_t)(baseptr - baselink), \"%d\", heading_numbers[i]);\n\n            strlcpy((char *)headptr, format_number(heading_numbers[i], heading_types[i]), sizeof(heading) - (size_t)(headptr - heading));\n\n            if (i < level)\n            {\n              strlcat((char *)heading, \".\", sizeof(heading));\n              strlcat((char *)baselink, \"_\", sizeof(baselink));\n            }\n          }\n\n         /*\n\t  * See if we have an existing <A NAME=...> or <A ID=...> for this\n\t  * heading...\n\t  */\n\n          existing = NULL;\n\n          if (t->parent != NULL && t->parent->markup == MARKUP_A)\n          {\n\t    existing = htmlGetVariable(t->parent, (uchar *)\"NAME\");\n\n\t    if (!existing)\n              existing = htmlGetVariable(t->parent, (uchar *)\"ID\");\n          }\n\n\t  if (existing == NULL &&\n              t->child != NULL && t->child->markup == MARKUP_A)\n          {\n\t    existing = htmlGetVariable(t->child, (uchar *)\"NAME\");\n\n\t    if (!existing)\n              existing = htmlGetVariable(t->child, (uchar *)\"ID\");\n          }\n\n          if (existing != NULL &&\n\t      strlen((char *)existing) >= 124)\t/* Max size of link name */\n\t    existing = NULL;\n\n          if (existing != NULL)\n\t    snprintf((char *)link, sizeof(link), \"#%s\", existing);\n\t  else\n\t    snprintf((char *)link, sizeof(link), \"#%s\", baselink);\n\n         /*\n\t  * Number the headings as needed...\n\t  */\n\n          if (TocNumbers)\n\t  {\n            strlcat((char *)heading, \" \", sizeof(heading));\n\n            htmlInsertTree(t, MARKUP_NONE, heading);\n\t  }\n\n         /*\n\t  * Add the heading to the table of contents...\n\t  */\n\n          if (level < TocLevels)\n          {\n            if (level > last_level)\n\t    {\n\t      if (heading_parents[last_level]->last_child && level > 1)\n        \theading_parents[level] =\n\t\t    htmlAddTree(heading_parents[last_level]->last_child,\n                                MARKUP_UL, NULL);\n              else\n        \theading_parents[level] =\n\t\t    htmlAddTree(heading_parents[last_level], MARKUP_UL, NULL);\n\n              DEBUG_printf((\"level=%d, last_level=%d, created new UL parent %p\\n\",\n\t                    level, last_level, (void *)heading_parents[level]));\n\t    }\n\n            if (level == 0)\n            {\n              if (last_level == 0)\n              {\n                htmlAddTree(heading_parents[level], MARKUP_BR, NULL);\n                htmlAddTree(heading_parents[level], MARKUP_BR, NULL);\n              }\n\n              parent = htmlAddTree(heading_parents[level], MARKUP_B, NULL);\n            }\n            else\n              parent = htmlAddTree(heading_parents[level], MARKUP_LI, NULL);\n\n            DEBUG_printf((\"parent=%p\\n\", (void *)parent));\n\n            if ((var = htmlGetVariable(t, (uchar *)\"_HD_OMIT_TOC\")) != NULL)\n\t      htmlSetVariable(parent, (uchar *)\"_HD_OMIT_TOC\", var);\n\n            if (TocLinks)\n            {\n             /*\n              * Add a link for the toc...\n              */\n\n              parent = htmlAddTree(parent, MARKUP_A, NULL);\n              htmlSetVariable(parent, (uchar *)\"HREF\", link);\n\n             /*\n              * Insert a NAME marker if needed and reparent all the\n\t      * heading children.\n              */\n\n              if (existing == NULL)\n\t      {\n\t       /*\n\t        * Add NAME to existing A element, if present.\n\t\t*/\n\n                if (t->parent != NULL && t->parent->markup == MARKUP_A)\n\t          htmlSetVariable(t->parent, (uchar *)\"NAME\", baselink);\n\t\telse if (t->child != NULL && t->child->markup == MARKUP_A)\n\t          htmlSetVariable(t->child, (uchar *)\"NAME\", baselink);\n\t\telse\n\t\t{\n        \t  target = htmlNewTree(t, MARKUP_A, NULL);\n\n        \t  htmlSetVariable(target, (uchar *)\"NAME\", baselink);\n        \t  for (temp = t->child; temp != NULL; temp = temp->next)\n                    temp->parent = target;\n\n        \t  target->child = t->child;\n        \t  t->child      = target;\n\t        }\n\t      }\n            }\n\n            add_heading(parent, t->child);\n          }\n\n          last_level = level;\n          break;\n\n      default :\n          if (t->child != NULL)\n            parse_tree(t->child);\n          break;\n    }\n\n    t = t->next;\n  }\n}\n", "/*\n * Utility functions for HTMLDOC, a HTML document processing program.\n *\n * Copyright \u00a9 2011-2020 by Michael R Sweet.\n * Copyright \u00a9 1997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n#include <ctype.h>\n\n\n/*\n * 'format_number()' - Format a number into arabic numerals, roman numerals,\n *                     or letters.\n */\n\nchar *\t\t\t\t/* O - String */\nformat_number(int  n,\t\t/* I - Number */\n              char f)\t\t/* I - Format */\n{\n  static const char *ones[10] =\t/* Roman numerals, 0-9 */\n\t\t{\n\t\t  \"\",\t\"i\",\t\"ii\",\t\"iii\",\t\"iv\",\n\t\t  \"v\",\t\"vi\",\t\"vii\",\t\"viii\",\t\"ix\"\n\t\t},\n\t\t*tens[10] =\t/* Roman numerals, 10-90 */\n\t\t{\n\t\t  \"\",\t\"x\",\t\"xx\",\t\"xxx\",\t\"xl\",\n\t\t  \"l\",\t\"lx\",\t\"lxx\",\t\"lxxx\",\t\"xc\"\n\t\t},\n\t\t*hundreds[30] =\t/* Roman numerals, 100-2900 */\n\t\t{\n\t\t  \"\",    \"c\",    \"cc\",    \"ccc\",    \"cd\",\n\t\t  \"d\",   \"dc\",   \"dcc\",   \"dccc\",   \"cm\",\n\t\t  \"m\",   \"mc\",   \"cc\",    \"ccc\",    \"cd\",\n\t\t  \"m\",   \"mdc\",  \"mdcc\",  \"mdccc\",  \"mcm\",\n\t\t  \"mm\",  \"mmc\",  \"mmcc\",  \"mmccc\",  \"mmcd\",\n\t\t  \"mmd\", \"mmdc\", \"mmdcc\", \"mmdccc\", \"mmcm\"\n\t\t};\n  static const char *ONES[10] =\t/* Roman numerals, 0-9 */\n\t\t{\n\t\t  \"\",\t\"I\",\t\"II\",\t\"III\",\t\"IV\",\n\t\t  \"V\",\t\"VI\",\t\"VII\",\t\"VIII\",\t\"IX\"\n\t\t},\n\t\t*TENS[10] =\t/* Roman numerals, 10-90 */\n\t\t{\n\t\t  \"\",\t\"X\",\t\"XX\",\t\"XXX\",\t\"XL\",\n\t\t  \"L\",\t\"LX\",\t\"LXX\",\t\"LXXX\",\t\"XC\"\n\t\t},\n\t\t*HUNDREDS[30] =\t/* Roman numerals, 100-2900 */\n\t\t{\n\t\t  \"\",    \"C\",    \"CC\",    \"CCC\",    \"CD\",\n\t\t  \"D\",   \"DC\",   \"DCC\",   \"DCCC\",   \"CM\",\n\t\t  \"M\",   \"MC\",   \"CC\",    \"CCC\",    \"CD\",\n\t\t  \"M\",   \"MDC\",  \"MDCC\",  \"MDCCC\",  \"MCM\",\n\t\t  \"MM\",  \"MMC\",  \"MMCC\",  \"MMCCC\",  \"MMCD\",\n\t\t  \"MMD\", \"MMDC\", \"MMDCC\", \"MMDCCC\", \"MMCM\"\n\t\t};\n  static char\tbuffer[1024];\t/* String buffer */\n\n\n  switch (f)\n  {\n    default :\n        buffer[0] = '\\0';\n\tbreak;\n\n    case 'a' :\n        if (n > (26 * 26))\n          n = (n % (26 * 26)) + 1;\n\n        if (n > 26)\n          snprintf(buffer, sizeof(buffer), \"%c%c\", 'a' + (n / 26) - 1, 'a' + (n % 26) - 1);\n        else\n          snprintf(buffer, sizeof(buffer), \"%c\", 'a' + n - 1);\n        break;\n\n    case 'A' :\n        if (n > (26 * 26))\n          n = (n % (26 * 26)) + 1;\n\n        if (n > 26)\n          snprintf(buffer, sizeof(buffer), \"%c%c\", 'A' + (n / 26) - 1, 'A' + (n % 26) - 1);\n        else\n          snprintf(buffer, sizeof(buffer), \"%c\", 'A' + n - 1);\n        break;\n\n    case '1' :\n        snprintf(buffer, sizeof(buffer), \"%d\", n);\n        break;\n\n    case 'i' :\n        if (n >= 3000)\n          n = (n % 3000) + 1;\n        \n\tsnprintf(buffer, sizeof(buffer), \"%s%s%s\", hundreds[n / 100], tens[(n / 10) % 10], ones[n % 10]);\n        break;\n\n    case 'I' :\n        if (n >= 3000)\n          n = (n % 3000) + 1;\n        \n\tsnprintf(buffer, sizeof(buffer), \"%s%s%s\", HUNDREDS[n / 100], TENS[(n / 10) % 10], ONES[n % 10]);\n        break;\n  }\n\n  return (buffer);\n}\n\n\n/*\n * 'get_color()' - Get a standard color value...\n */\n\nvoid\nget_color(const uchar *color,\t/* I - Color attribute */\n          float       *rgb,\t/* O - RGB value */\n\t  int         defblack)\t/* I - Default color is black? */\n{\n  int\t\ti;\t\t/* Looping vars */\n  static uchar\ttempcolor[8];\t/* Temporary holding place for hex colors */\n  static struct\n  {\n    const char\t*name;\t\t/* Color name */\n    uchar\tred,\t\t/* Red value */\n\t\tgreen,\t\t/* Green value */\n\t\tblue;\t\t/* Blue value */\n  }\t\tcolors[] =\t/* Color \"database\" */\n  {\n    { \"aqua\",\t\t0,   255, 255 }, /* AKA Cyan */\n    { \"black\",\t\t0,   0,   0 },\n    { \"blue\",\t\t0,   0,   255 },\n    { \"cyan\",\t\t0,   255, 255 },\n    { \"fuchsia\",\t255, 0,   255 }, /* AKA Magenta */\n    { \"gray\",\t\t128, 128, 128 },\n    { \"green\",\t\t0,   128, 0 },\n    { \"grey\",\t\t128, 128, 128 },\n    { \"lime\",\t\t0,   255, 0 },\n    { \"magenta\",\t255, 0,   255 },\n    { \"maroon\",\t\t128, 0,   0 },\n    { \"navy\",\t\t0,   0,   128 },\n    { \"olive\",\t\t128, 128, 0 },\n    { \"purple\",\t\t128, 0,   128 },\n    { \"red\",\t\t255, 0,   0 },\n    { \"silver\",\t\t192, 192, 192 },\n    { \"teal\",\t\t0,   128, 128 },\n    { \"white\",\t\t255, 255, 255 },\n    { \"yellow\",\t\t255, 255, 0 }\n  };\n\n\n  // First, see if this is a hex color with a missing # in front...\n  if (strlen((char *)color) == 6)\n  {\n    for (i = 0; i < 6; i ++)\n      if (!isxdigit(color[i]))\n        break;\n\n    if (i == 3 || i == 6)\n    {\n      // Update the color name to be #RRGGBB instead of RRGGBB...\n      tempcolor[0] = '#';\n      strlcpy((char *)tempcolor + 1, (char *)color, sizeof(tempcolor) - 1);\n      color = tempcolor;\n    }\n  }\n\n  if (!color[0])\n  {\n    if (defblack)\n    {\n      rgb[0] = 0.0f;\n      rgb[1] = 0.0f;\n      rgb[2] = 0.0f;\n    }\n    else\n    {\n      rgb[0] = 1.0f;\n      rgb[1] = 1.0f;\n      rgb[2] = 1.0f;\n    }\n    return;\n  }\n  else if (color[0] == '#')\n  {\n   /*\n    * RGB value in hex...\n    */\n\n    i = (int)strlen((char *)color + 1);\n    if (i == 3)\n    {\n      i      = strtol((char *)color + 1, NULL, 16);\n      rgb[0] = (i >> 8) / 15.0f;\n      rgb[1] = ((i >> 4) & 15) / 15.0f;\n      rgb[2] = (i & 15) / 15.0f;\n    }\n    else if (i == 6)\n    {\n      i      = strtol((char *)color + 1, NULL, 16);\n      rgb[0] = (i >> 16) / 255.0f;\n      rgb[1] = ((i >> 8) & 255) / 255.0f;\n      rgb[2] = (i & 255) / 255.0f;\n    }\n    else if (defblack)\n    {\n      rgb[0] = rgb[1] = rgb[2] = 0.0f;\n    }\n    else\n    {\n      rgb[0] = rgb[1] = rgb[2] = 1.0f;\n    }\n  }\n  else\n  {\n    for (i = 0; i < (int)(sizeof(colors) / sizeof(colors[0])); i ++)\n      if (strcasecmp(colors[i].name, (char *)color) == 0)\n\tbreak;\n\n    if (i >= (int)(sizeof(colors) / sizeof(colors[0])))\n    {\n      if (defblack)\n        i = 1; /* Black */\n      else\n        i = 17; /* White */\n    }\n\n    rgb[0] = colors[i].red / 255.0f;\n    rgb[1] = colors[i].green / 255.0f;\n    rgb[2] = colors[i].blue / 255.0f;\n  }\n}\n\n\n//\n// 'get_format()' - Convert an old \"fff\" format string to the new format.\n//\n\nvoid\nget_format(const char *fmt,\t\t// I - Old \"fff\" format\n           char       **formats)\t// O - New format strings\n{\n  int\ti;\t\t\t\t// Looping var\n\n\n  for (i = 0; i < 3; i ++)\n  {\n    if (formats[i])\n    {\n      free(formats[i]);\n      formats[i] = NULL;\n    }\n\n    switch (fmt[i])\n    {\n      case '/' :\n          formats[i] = strdup(\"$PAGE(1)/$PAGES\");\n          break;\n\n      case ':' :\n          formats[i] = strdup(\"$CHAPTERPAGE(1)/$CHAPTERPAGES\");\n          break;\n\n      case '1' :\n          formats[i] = strdup(\"$PAGE(1)\");\n          break;\n\n      case 'a' :\n          formats[i] = strdup(\"$PAGE(a)\");\n          break;\n\n      case 'A' :\n          formats[i] = strdup(\"$PAGE(A)\");\n          break;\n\n      case 'c' :\n          formats[i] = strdup(\"$CHAPTER\");\n          break;\n\n      case 'C' :\n          formats[i] = strdup(\"$CHAPTERPAGE(1)\");\n          break;\n\n      case 'd' :\n          formats[i] = strdup(\"$DATE\");\n          break;\n\n      case 'D' :\n          formats[i] = strdup(\"$DATE $TIME\");\n          break;\n\n      case 'h' :\n          formats[i] = strdup(\"$HEADING\");\n          break;\n\n      case 'i' :\n          formats[i] = strdup(\"$PAGE(i)\");\n          break;\n\n      case 'I' :\n          formats[i] = strdup(\"$PAGE(I)\");\n          break;\n\n      case 'l' :\n          formats[i] = strdup(\"$LOGOIMAGE\");\n          break;\n\n      case 'L' :\n          formats[i] = strdup(\"$LETTERHEAD\");\n          break;\n\n      case 't' :\n          formats[i] = strdup(\"$TITLE\");\n          break;\n\n      case 'T' :\n          formats[i] = strdup(\"$TIME\");\n          break;\n\n      case 'u' :\n          formats[i] = strdup(\"$URL\");\n          break;\n\n      default :\n          formats[i] = NULL;\n          break;\n    }\n  }\n}\n\n\n//\n// 'get_fmt()' - Convert a new format string to the old \"fff\" format.\n//\n\nconst char *\t\t\t\t// O - Old format string\nget_fmt(char **formats)\t\t\t// I - New format strings\n{\n  int\t\ti, j;\t\t\t// Looping vars\n  static char\tfmt[4];\t\t\t// Old format string\n  static struct\t\t\t\t// Format string conversions...\n  {\n    char\tf;\t\t\t// Format character\n    const char\t*format;\t\t// Format string\n  }\t\ttable[] =\n  {\n    { '/', \"$PAGE(1)/$PAGES\" },\n    { ':', \"$CHAPTERPAGE(1)/$CHAPTERPAGES\" },\n    { '1', \"$PAGE(1)\" },\n    { 'a', \"$PAGE(a)\" },\n    { 'A', \"$PAGE(A)\" },\n    { 'c', \"$CHAPTER\" },\n    { 'C', \"$CHAPTERPAGE(1)\" },\n    { 'd', \"$DATE\" },\n    { 'D', \"$DATE $TIME\" },\n    { 'h', \"$HEADING\" },\n    { 'i', \"$PAGE(i)\" },\n    { 'I', \"$PAGE(I)\" },\n    { 'l', \"$LOGOIMAGE\" },\n    { 't', \"$TITLE\" },\n    { 'T', \"$TIME\" }\n  };\n\n\n  // Safe because fmt is 4 chars long\n  strlcpy(fmt, \"...\", sizeof(fmt));\n\n  for (i = 0; i < 3; i ++)\n    if (formats[i])\n      for (j = 0; j < (int)(sizeof(table) / sizeof(table[0])); j ++)\n        if (strcmp(formats[i], table[j].format) == 0)\n\t{\n\t  fmt[i] = table[j].f;\n\t  break;\n\t}\n\n  return (fmt);\n}\n\n\n/*\n * 'get_measurement()' - Get a size measurement in inches, points, centimeters,\n *                       or millimeters.\n */\n\nint\t\t\t\t/* O - Measurement in points */\nget_measurement(const char *s,\t/* I - Measurement string */\n                float      mul)\t/* I - Multiplier */\n{\n  float\tval;\t\t\t/* Measurement value */\n\n\n /*\n  * Get the floating point value of \"s\" and skip all digits and decimal points.\n  */\n\n  val = (float)atof(s);\n  while (isdigit(*s) || *s == '.')\n    s ++;\n\n /*\n  * Check for a trailing unit specifier...\n  */\n\n  if (strcasecmp(s, \"mm\") == 0)\n    val *= 72.0f / 25.4f;\n  else if (strcasecmp(s, \"cm\") == 0)\n    val *= 72.0f / 2.54f;\n  else if (strncasecmp(s, \"in\", 2) == 0)\n    val *= 72.0f;\n  else\n    val *= mul;\n\n  return ((int)val);\n}\n\n\n/*\n * 'set_page_size()' - Set the output page size.\n */\n\nvoid\nset_page_size(const char *size)\t/* I - Page size string */\n{\n  float\twidth,\t\t\t/* Width in points */\n\tlength;\t\t\t/* Length in points */\n  char\tunits[255];\t\t/* Units string */\n\n\n /*\n  * Check for common media sizes...\n  */\n\n  if (strcasecmp(size, \"letter\") == 0 ||\n      strcasecmp(size, \"a\") == 0)\n  {\n   /*\n    * US Letter - 8.5x11 inches (216x279mm).\n    */\n\n    PageWidth  = 612;\n    PageLength = 792;\n  }\n  else if (strcasecmp(size, \"legal\") == 0)\n  {\n   /*\n    * US Legal - 8.5x14 inches (216x356mm).\n    */\n\n    PageWidth  = 612;\n    PageLength = 1008;\n  }\n  else if (strcasecmp(size, \"tabloid\") == 0 ||\n           strcasecmp(size, \"b\") == 0)\n  {\n   /*\n    * US Tabloid - 11x17 inches (279x432mm).\n    */\n\n    PageWidth  = 792;\n    PageLength = 1224;\n  }\n  else if (strcasecmp(size, \"a4\") == 0)\n  {\n   /*\n    * European standard A4 - 210x297mm (8.27x11.69 inches).\n    */\n\n    PageWidth  = 595;\n    PageLength = 842;\n  }\n  else if (strcasecmp(size, \"a3\") == 0)\n  {\n   /*\n    * European standard A3 - 297x420mm (11.69x16.54 inches).\n    */\n\n    PageWidth  = 842;\n    PageLength = 1190;\n  }\n  else if (strcasecmp(size, \"universal\") == 0)\n  {\n   /*\n    * \"Universal\" size - 8.27x11.00 inches (210x279mm).\n    */\n\n    PageWidth  = 595;\n    PageLength = 792;\n  }\n  else if (sscanf(size, \"%fx%f%254s\", &width, &length, units) >= 2)\n  {\n   /*\n    * Custom size...\n    */\n\n    if (strcasecmp(units, \"mm\") == 0)\n    {\n      PageWidth  = (int)(72.0 * width / 25.4);\n      PageLength = (int)(72.0 * length / 25.4);\n    }\n    else if (strcasecmp(units, \"cm\") == 0)\n    {\n      PageWidth  = (int)(72.0 * width / 2.54);\n      PageLength = (int)(72.0 * length / 2.54);\n    }\n    else if (strncasecmp(units, \"in\", 2) == 0)\n    {\n      PageWidth  = (int)(72.0 * width);\n      PageLength = (int)(72.0 * length);\n    }\n    else\n    {\n      PageWidth  = (int)width;\n      PageLength = (int)length;\n    }\n  }\n}\n"], "filenames": ["CHANGES.md", "htmldoc/toc.cxx", "htmldoc/util.cxx"], "buggy_code_start_loc": [0, 125, 38], "buggy_code_end_loc": [0, 239, 101], "fixing_code_start_loc": [1, 124, 38], "fixing_code_end_loc": [7, 186, 111], "type": "CWE-125", "message": "An Out of Bounds flaw was discovered in htmodoc 1.9.12 in function parse_tree() in toc.cxx, this possibly leads to memory layout information leaking in the data. This might be used in a chain of vulnerability in order to reach code execution.", "other": {"cve": {"id": "CVE-2021-34121", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-18T14:15:11.780", "lastModified": "2023-07-27T15:19:31.567", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An Out of Bounds flaw was discovered in htmodoc 1.9.12 in function parse_tree() in toc.cxx, this possibly leads to memory layout information leaking in the data. This might be used in a chain of vulnerability in order to reach code execution."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:htmldoc_project:htmldoc:1.9.12:*:*:*:*:*:*:*", "matchCriteriaId": "645554AD-DA7C-4B11-864A-89F423B08291"}]}]}], "references": [{"url": "https://github.com/michaelrsweet/htmldoc/commit/c67bbd8756f015e33e4ba639a40c7f9d8bd9e8ab", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/michaelrsweet/htmldoc/issues/433", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking"]}]}, "github_commit_url": "https://github.com/michaelrsweet/htmldoc/commit/c67bbd8756f015e33e4ba639a40c7f9d8bd9e8ab"}}