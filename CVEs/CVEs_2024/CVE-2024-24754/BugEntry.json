{"buggy_code": ["<?php declare(strict_types=1);\n\nnamespace Bref\\Event\\Http;\n\nuse Bref\\Context\\Context;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass Psr15Handler extends HttpHandler\n{\n    private RequestHandlerInterface $psr15Handler;\n\n    public function __construct(RequestHandlerInterface $psr15Handler)\n    {\n        $this->psr15Handler = $psr15Handler;\n    }\n\n    public function handleRequest(HttpRequestEvent $event, Context $context): HttpResponse\n    {\n        $request = Psr7Bridge::convertRequest($event, $context);\n\n        $response = $this->psr15Handler->handle($request);\n\n        return Psr7Bridge::convertResponse($response);\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Event\\Http;\n\nuse Bref\\Context\\Context;\nuse Nyholm\\Psr7\\ServerRequest;\nuse Nyholm\\Psr7\\Stream;\nuse Nyholm\\Psr7\\UploadedFile;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Riverline\\MultiPartParser\\Part;\nuse RuntimeException;\n\nuse function str_starts_with;\n\n/**\n * Bridges PSR-7 requests and responses with API Gateway or ALB event/response formats.\n */\nfinal class Psr7Bridge\n{\n    /**\n     * Create a PSR-7 server request from an AWS Lambda HTTP event.\n     */\n    public static function convertRequest(HttpRequestEvent $event, Context $context): ServerRequestInterface\n    {\n        $headers = $event->getHeaders();\n\n        [$files, $parsedBody] = self::parseBodyAndUploadedFiles($event);\n        [$user, $password] = $event->getBasicAuthCredentials();\n\n        $server = array_filter([\n            'CONTENT_LENGTH' => $headers['content-length'][0] ?? null,\n            'CONTENT_TYPE' => $event->getContentType(),\n            'DOCUMENT_ROOT' => getcwd(),\n            'QUERY_STRING' => $event->getQueryString(),\n            'REQUEST_METHOD' => $event->getMethod(),\n            'SERVER_NAME' => $event->getServerName(),\n            'SERVER_PORT' => $event->getServerPort(),\n            'SERVER_PROTOCOL' => $event->getProtocol(),\n            'PATH_INFO' => $event->getPath(),\n            'HTTP_HOST' => $headers['host'] ?? null,\n            'REMOTE_ADDR' => $event->getSourceIp(),\n            'REMOTE_PORT' => $event->getRemotePort(),\n            'REQUEST_TIME' => time(),\n            'REQUEST_TIME_FLOAT' => microtime(true),\n            'REQUEST_URI' => $event->getUri(),\n            'PHP_AUTH_USER' => $user,\n            'PHP_AUTH_PW' => $password,\n        ]);\n\n        foreach ($headers as $name => $values) {\n            $server['HTTP_' . strtoupper(str_replace('-', '_', (string) $name))] = $values[0];\n        }\n\n        /**\n         * Nyholm/psr7 does not rewind body streams, we do it manually\n         * so that users can fetch the content of the body directly.\n         */\n        $bodyStream = Stream::create($event->getBody());\n        $bodyStream->rewind();\n\n        $request = new ServerRequest(\n            $event->getMethod(),\n            $event->getUri(),\n            $event->getHeaders(),\n            $bodyStream,\n            $event->getProtocolVersion(),\n            $server\n        );\n\n        foreach ($event->getPathParameters() as $key => $value) {\n            $request = $request->withAttribute($key, $value);\n        }\n\n        return $request->withUploadedFiles($files)\n            ->withCookieParams($event->getCookies())\n            ->withQueryParams($event->getQueryParameters())\n            ->withParsedBody($parsedBody)\n            ->withAttribute('lambda-event', $event)\n            ->withAttribute('lambda-context', $context);\n    }\n\n    /**\n     * Create a ALB/API Gateway response from a PSR-7 response.\n     */\n    public static function convertResponse(ResponseInterface $response): HttpResponse\n    {\n        $response->getBody()->rewind();\n        $body = $response->getBody()->getContents();\n\n        return new HttpResponse($body, $response->getHeaders(), $response->getStatusCode());\n    }\n\n    private static function parseBodyAndUploadedFiles(HttpRequestEvent $event): array\n    {\n        $bodyString = $event->getBody();\n        $files = [];\n        $parsedBody = null;\n        $contentType = $event->getContentType();\n        if ($contentType !== null && $event->getMethod() === 'POST') {\n            if (str_starts_with($contentType, 'application/x-www-form-urlencoded')) {\n                parse_str($bodyString, $parsedBody);\n            } else {\n                $document = new Part(\"Content-type: $contentType\\r\\n\\r\\n\" . $bodyString);\n                if ($document->isMultiPart()) {\n                    $parsedBody = [];\n                    foreach ($document->getParts() as $part) {\n                        if ($part->isFile()) {\n                            $tmpPath = tempnam(sys_get_temp_dir(), 'bref_upload_');\n                            if ($tmpPath === false) {\n                                throw new RuntimeException('Unable to create a temporary directory');\n                            }\n                            file_put_contents($tmpPath, $part->getBody());\n                            $file = new UploadedFile($tmpPath, filesize($tmpPath), UPLOAD_ERR_OK, $part->getFileName(), $part->getMimeType());\n\n                            self::parseKeyAndInsertValueInArray($files, $part->getName(), $file);\n                        } else {\n                            self::parseKeyAndInsertValueInArray($parsedBody, $part->getName(), $part->getBody());\n                        }\n                    }\n                }\n            }\n        }\n        return [$files, $parsedBody];\n    }\n\n    /**\n     * Parse a string key like \"files[id_cards][jpg][]\" and do $array['files']['id_cards']['jpg'][] = $value\n     */\n    private static function parseKeyAndInsertValueInArray(array &$array, string $key, mixed $value): void\n    {\n        if (! str_contains($key, '[')) {\n            $array[$key] = $value;\n\n            return;\n        }\n\n        $parts = explode('[', $key); // files[id_cards][jpg][] => [ 'files',  'id_cards]', 'jpg]', ']' ]\n        $pointer = &$array;\n\n        foreach ($parts as $k => $part) {\n            if ($k === 0) {\n                $pointer = &$pointer[$part];\n\n                continue;\n            }\n\n            // Skip two special cases:\n            // [[ in the key produces empty string\n            // [test : starts with [ but does not end with ]\n            if ($part === '' || ! str_ends_with($part, ']')) {\n                // Malformed key, we use it \"as is\"\n                $array[$key] = $value;\n\n                return;\n            }\n\n            $part = substr($part, 0, -1); // The last char is a ] => remove it to have the real key\n\n            if ($part === '') { // [] case\n                $pointer = &$pointer[];\n            } else {\n                $pointer = &$pointer[$part];\n            }\n        }\n\n        $pointer = $value;\n    }\n}\n"], "fixing_code": ["<?php declare(strict_types=1);\n\nnamespace Bref\\Event\\Http;\n\nuse Bref\\Context\\Context;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass Psr15Handler extends HttpHandler\n{\n    private RequestHandlerInterface $psr15Handler;\n\n    public function __construct(RequestHandlerInterface $psr15Handler)\n    {\n        $this->psr15Handler = $psr15Handler;\n    }\n\n    public function handleRequest(HttpRequestEvent $event, Context $context): HttpResponse\n    {\n        Psr7Bridge::cleanupUploadedFiles();\n\n        $request = Psr7Bridge::convertRequest($event, $context);\n\n        $response = $this->psr15Handler->handle($request);\n\n        return Psr7Bridge::convertResponse($response);\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Bref\\Event\\Http;\n\nuse Bref\\Context\\Context;\nuse Nyholm\\Psr7\\ServerRequest;\nuse Nyholm\\Psr7\\Stream;\nuse Nyholm\\Psr7\\UploadedFile;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Riverline\\MultiPartParser\\Part;\nuse RuntimeException;\n\nuse function str_starts_with;\n\n/**\n * Bridges PSR-7 requests and responses with API Gateway or ALB event/response formats.\n */\nfinal class Psr7Bridge\n{\n    private const UPLOADED_FILES_PREFIX = 'bref_upload_';\n\n    /**\n     * Create a PSR-7 server request from an AWS Lambda HTTP event.\n     */\n    public static function convertRequest(HttpRequestEvent $event, Context $context): ServerRequestInterface\n    {\n        $headers = $event->getHeaders();\n\n        [$files, $parsedBody] = self::parseBodyAndUploadedFiles($event);\n        [$user, $password] = $event->getBasicAuthCredentials();\n\n        $server = array_filter([\n            'CONTENT_LENGTH' => $headers['content-length'][0] ?? null,\n            'CONTENT_TYPE' => $event->getContentType(),\n            'DOCUMENT_ROOT' => getcwd(),\n            'QUERY_STRING' => $event->getQueryString(),\n            'REQUEST_METHOD' => $event->getMethod(),\n            'SERVER_NAME' => $event->getServerName(),\n            'SERVER_PORT' => $event->getServerPort(),\n            'SERVER_PROTOCOL' => $event->getProtocol(),\n            'PATH_INFO' => $event->getPath(),\n            'HTTP_HOST' => $headers['host'] ?? null,\n            'REMOTE_ADDR' => $event->getSourceIp(),\n            'REMOTE_PORT' => $event->getRemotePort(),\n            'REQUEST_TIME' => time(),\n            'REQUEST_TIME_FLOAT' => microtime(true),\n            'REQUEST_URI' => $event->getUri(),\n            'PHP_AUTH_USER' => $user,\n            'PHP_AUTH_PW' => $password,\n        ]);\n\n        foreach ($headers as $name => $values) {\n            $server['HTTP_' . strtoupper(str_replace('-', '_', (string) $name))] = $values[0];\n        }\n\n        /**\n         * Nyholm/psr7 does not rewind body streams, we do it manually\n         * so that users can fetch the content of the body directly.\n         */\n        $bodyStream = Stream::create($event->getBody());\n        $bodyStream->rewind();\n\n        $request = new ServerRequest(\n            $event->getMethod(),\n            $event->getUri(),\n            $event->getHeaders(),\n            $bodyStream,\n            $event->getProtocolVersion(),\n            $server\n        );\n\n        foreach ($event->getPathParameters() as $key => $value) {\n            $request = $request->withAttribute($key, $value);\n        }\n\n        return $request->withUploadedFiles($files)\n            ->withCookieParams($event->getCookies())\n            ->withQueryParams($event->getQueryParameters())\n            ->withParsedBody($parsedBody)\n            ->withAttribute('lambda-event', $event)\n            ->withAttribute('lambda-context', $context);\n    }\n\n    /**\n     * Create a ALB/API Gateway response from a PSR-7 response.\n     */\n    public static function convertResponse(ResponseInterface $response): HttpResponse\n    {\n        $response->getBody()->rewind();\n        $body = $response->getBody()->getContents();\n\n        return new HttpResponse($body, $response->getHeaders(), $response->getStatusCode());\n    }\n\n    private static function parseBodyAndUploadedFiles(HttpRequestEvent $event): array\n    {\n        $bodyString = $event->getBody();\n        $files = [];\n        $parsedBody = null;\n        $contentType = $event->getContentType();\n        if ($contentType !== null && $event->getMethod() === 'POST') {\n            if (str_starts_with($contentType, 'application/x-www-form-urlencoded')) {\n                parse_str($bodyString, $parsedBody);\n            } else {\n                $document = new Part(\"Content-type: $contentType\\r\\n\\r\\n\" . $bodyString);\n                if ($document->isMultiPart()) {\n                    $parsedBody = [];\n                    foreach ($document->getParts() as $part) {\n                        if ($part->isFile()) {\n                            $tmpPath = tempnam(sys_get_temp_dir(), self::UPLOADED_FILES_PREFIX);\n                            if ($tmpPath === false) {\n                                throw new RuntimeException('Unable to create a temporary directory');\n                            }\n                            file_put_contents($tmpPath, $part->getBody());\n                            $file = new UploadedFile($tmpPath, filesize($tmpPath), UPLOAD_ERR_OK, $part->getFileName(), $part->getMimeType());\n\n                            self::parseKeyAndInsertValueInArray($files, $part->getName(), $file);\n                        } else {\n                            self::parseKeyAndInsertValueInArray($parsedBody, $part->getName(), $part->getBody());\n                        }\n                    }\n                }\n            }\n        }\n        return [$files, $parsedBody];\n    }\n\n    /**\n     * Parse a string key like \"files[id_cards][jpg][]\" and do $array['files']['id_cards']['jpg'][] = $value\n     */\n    private static function parseKeyAndInsertValueInArray(array &$array, string $key, mixed $value): void\n    {\n        if (! str_contains($key, '[')) {\n            $array[$key] = $value;\n\n            return;\n        }\n\n        $parts = explode('[', $key); // files[id_cards][jpg][] => [ 'files',  'id_cards]', 'jpg]', ']' ]\n        $pointer = &$array;\n\n        foreach ($parts as $k => $part) {\n            if ($k === 0) {\n                $pointer = &$pointer[$part];\n\n                continue;\n            }\n\n            // Skip two special cases:\n            // [[ in the key produces empty string\n            // [test : starts with [ but does not end with ]\n            if ($part === '' || ! str_ends_with($part, ']')) {\n                // Malformed key, we use it \"as is\"\n                $array[$key] = $value;\n\n                return;\n            }\n\n            $part = substr($part, 0, -1); // The last char is a ] => remove it to have the real key\n\n            if ($part === '') { // [] case\n                $pointer = &$pointer[];\n            } else {\n                $pointer = &$pointer[$part];\n            }\n        }\n\n        $pointer = $value;\n    }\n\n    /**\n     * Cleanup previously uploaded files.\n     */\n    public static function cleanupUploadedFiles(): void\n    {\n        $tmpFiles = glob(sys_get_temp_dir() . '/' . self::UPLOADED_FILES_PREFIX . '*');\n        if ($tmpFiles !== false) {\n            foreach ($tmpFiles as $file) {\n                if(is_file($file)) {\n                    unlink($file);\n                }\n            }\n        }\n    }\n}\n"], "filenames": ["src/Event/Http/Psr15Handler.php", "src/Event/Http/Psr7Bridge.php"], "buggy_code_start_loc": [18, 20], "buggy_code_end_loc": [18, 168], "fixing_code_start_loc": [19, 21], "fixing_code_end_loc": [21, 186], "type": "CWE-436", "message": "Bref enable serverless PHP on AWS Lambda. When Bref is used with the Event-Driven Function runtime and the handler is a `RequestHandlerInterface`, then the Lambda event is converted to a PSR7 object. During the conversion process, if the request is a MultiPart, each part is parsed and its content added in the `$files` or `$parsedBody` arrays. The conversion process produces a different output compared to the one of plain PHP when keys ending with and open square bracket ([) are used. Based on the application logic the difference in the body parsing might lead to vulnerabilities and/or undefined behaviors. This vulnerability is patched in 2.1.13.", "other": {"cve": {"id": "CVE-2024-24754", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-01T16:17:14.877", "lastModified": "2024-02-09T01:56:35.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Bref enable serverless PHP on AWS Lambda. When Bref is used with the Event-Driven Function runtime and the handler is a `RequestHandlerInterface`, then the Lambda event is converted to a PSR7 object. During the conversion process, if the request is a MultiPart, each part is parsed and its content added in the `$files` or `$parsedBody` arrays. The conversion process produces a different output compared to the one of plain PHP when keys ending with and open square bracket ([) are used. Based on the application logic the difference in the body parsing might lead to vulnerabilities and/or undefined behaviors. This vulnerability is patched in 2.1.13."}, {"lang": "es", "value": "Bref habilita PHP sin servidor en AWS Lambda. Cuando se usa Bref con el tiempo de ejecuci\u00f3n de la funci\u00f3n controlada por eventos y el controlador es \"RequestHandlerInterface\", el evento Lambda se convierte en un objeto PSR7. Durante el proceso de conversi\u00f3n, si la solicitud es MultiPart, cada parte se analiza y su contenido se agrega en las matrices `$files` o `$parsedBody`. El proceso de conversi\u00f3n produce un resultado diferente en comparaci\u00f3n con el de PHP simple cuando se utilizan claves que terminan en un corchete abierto ([). Seg\u00fan la l\u00f3gica de la aplicaci\u00f3n, la diferencia en el an\u00e1lisis del cuerpo podr\u00eda generar vulnerabilidades y/o comportamientos indefinidos. Esta vulnerabilidad est\u00e1 parcheada en 2.1.13."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-436"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mnapoli:bref:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.13", "matchCriteriaId": "D8473D9F-5007-4ADC-B256-FD331BB522A0"}]}]}], "references": [{"url": "https://github.com/brefphp/bref/commit/c77d9f5abf021f29fa96b5720b7b84adbd199092", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/brefphp/bref/security/advisories/GHSA-82vx-mm6r-gg8w", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/brefphp/bref/commit/c77d9f5abf021f29fa96b5720b7b84adbd199092"}}