{"buggy_code": ["/*\n *  Routines for driver control interface\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/threads.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/info.h>\n#include <sound/control.h>\n\n/* max number of user-defined controls */\n#define MAX_USER_CONTROLS\t32\n#define MAX_CONTROL_COUNT\t1028\n\nstruct snd_kctl_ioctl {\n\tstruct list_head list;\t\t/* list of all ioctls */\n\tsnd_kctl_ioctl_func_t fioctl;\n};\n\nstatic DECLARE_RWSEM(snd_ioctl_rwsem);\nstatic LIST_HEAD(snd_control_ioctls);\n#ifdef CONFIG_COMPAT\nstatic LIST_HEAD(snd_control_compat_ioctls);\n#endif\n\nstatic int snd_ctl_open(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard = snd_lookup_minor_data(iminor(inode), SNDRV_DEVICE_TYPE_CONTROL);\n\tif (!card) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\terr = snd_card_file_add(card, file);\n\tif (err < 0) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\tif (!try_module_get(card->module)) {\n\t\terr = -EFAULT;\n\t\tgoto __error2;\n\t}\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (ctl == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\tINIT_LIST_HEAD(&ctl->events);\n\tinit_waitqueue_head(&ctl->change_sleep);\n\tspin_lock_init(&ctl->read_lock);\n\tctl->card = card;\n\tctl->prefer_pcm_subdevice = -1;\n\tctl->prefer_rawmidi_subdevice = -1;\n\tctl->pid = get_pid(task_pid(current));\n\tfile->private_data = ctl;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_add_tail(&ctl->list, &card->ctl_files);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tsnd_card_unref(card);\n\treturn 0;\n\n      __error:\n\tmodule_put(card->module);\n      __error2:\n\tsnd_card_file_remove(card, file);\n      __error1:\n\tif (card)\n\t\tsnd_card_unref(card);\n      \treturn err;\n}\n\nstatic void snd_ctl_empty_read_queue(struct snd_ctl_file * ctl)\n{\n\tunsigned long flags;\n\tstruct snd_kctl_event *cread;\n\t\n\tspin_lock_irqsave(&ctl->read_lock, flags);\n\twhile (!list_empty(&ctl->events)) {\n\t\tcread = snd_kctl_event(ctl->events.next);\n\t\tlist_del(&cread->list);\n\t\tkfree(cread);\n\t}\n\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n}\n\nstatic int snd_ctl_release(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kcontrol *control;\n\tunsigned int idx;\n\n\tctl = file->private_data;\n\tfile->private_data = NULL;\n\tcard = ctl->card;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_del(&ctl->list);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tdown_write(&card->controls_rwsem);\n\tlist_for_each_entry(control, &card->controls, list)\n\t\tfor (idx = 0; idx < control->count; idx++)\n\t\t\tif (control->vd[idx].owner == ctl)\n\t\t\t\tcontrol->vd[idx].owner = NULL;\n\tup_write(&card->controls_rwsem);\n\tsnd_ctl_empty_read_queue(ctl);\n\tput_pid(ctl->pid);\n\tkfree(ctl);\n\tmodule_put(card->module);\n\tsnd_card_file_remove(card, file);\n\treturn 0;\n}\n\nvoid snd_ctl_notify(struct snd_card *card, unsigned int mask,\n\t\t    struct snd_ctl_elem_id *id)\n{\n\tunsigned long flags;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kctl_event *ev;\n\t\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn;\n\tread_lock(&card->ctl_files_rwlock);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tcard->mixer_oss_change_count++;\n#endif\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\tif (!ctl->subscribed)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&ctl->read_lock, flags);\n\t\tlist_for_each_entry(ev, &ctl->events, list) {\n\t\t\tif (ev->id.numid == id->numid) {\n\t\t\t\tev->mask |= mask;\n\t\t\t\tgoto _found;\n\t\t\t}\n\t\t}\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (ev) {\n\t\t\tev->id = *id;\n\t\t\tev->mask = mask;\n\t\t\tlist_add_tail(&ev->list, &ctl->events);\n\t\t} else {\n\t\t\tdev_err(card->dev, \"No memory available to allocate event\\n\");\n\t\t}\n\t_found:\n\t\twake_up(&ctl->change_sleep);\n\t\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n\t\tkill_fasync(&ctl->fasync, SIGIO, POLL_IN);\n\t}\n\tread_unlock(&card->ctl_files_rwlock);\n}\n\nEXPORT_SYMBOL(snd_ctl_notify);\n\n/**\n * snd_ctl_new - create a control instance from the template\n * @control: the control template\n * @access: the default control access\n *\n * Allocates a new struct snd_kcontrol instance and copies the given template \n * to the new instance. It does not copy volatile data (access).\n *\n * Return: The pointer of the new instance, or %NULL on failure.\n */\nstatic struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,\n\t\t\t\t\tunsigned int access)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\t\n\tif (snd_BUG_ON(!control || !control->count))\n\t\treturn NULL;\n\n\tif (control->count > MAX_CONTROL_COUNT)\n\t\treturn NULL;\n\n\tkctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);\n\tif (kctl == NULL) {\n\t\tpr_err(\"ALSA: Cannot allocate control instance\\n\");\n\t\treturn NULL;\n\t}\n\t*kctl = *control;\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tkctl->vd[idx].access = access;\n\treturn kctl;\n}\n\n/**\n * snd_ctl_new1 - create a control instance from the template\n * @ncontrol: the initialization record\n * @private_data: the private data to set\n *\n * Allocates a new struct snd_kcontrol instance and initialize from the given \n * template.  When the access field of ncontrol is 0, it's assumed as\n * READWRITE access. When the count field is 0, it's assumes as one.\n *\n * Return: The pointer of the newly generated instance, or %NULL on failure.\n */\nstruct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new *ncontrol,\n\t\t\t\t  void *private_data)\n{\n\tstruct snd_kcontrol kctl;\n\tunsigned int access;\n\t\n\tif (snd_BUG_ON(!ncontrol || !ncontrol->info))\n\t\treturn NULL;\n\tmemset(&kctl, 0, sizeof(kctl));\n\tkctl.id.iface = ncontrol->iface;\n\tkctl.id.device = ncontrol->device;\n\tkctl.id.subdevice = ncontrol->subdevice;\n\tif (ncontrol->name) {\n\t\tstrlcpy(kctl.id.name, ncontrol->name, sizeof(kctl.id.name));\n\t\tif (strcmp(ncontrol->name, kctl.id.name) != 0)\n\t\t\tpr_warn(\"ALSA: Control name '%s' truncated to '%s'\\n\",\n\t\t\t\tncontrol->name, kctl.id.name);\n\t}\n\tkctl.id.index = ncontrol->index;\n\tkctl.count = ncontrol->count ? ncontrol->count : 1;\n\taccess = ncontrol->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :\n\t\t (ncontrol->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_VOLATILE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_INACTIVE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK));\n\tkctl.info = ncontrol->info;\n\tkctl.get = ncontrol->get;\n\tkctl.put = ncontrol->put;\n\tkctl.tlv.p = ncontrol->tlv.p;\n\tkctl.private_value = ncontrol->private_value;\n\tkctl.private_data = private_data;\n\treturn snd_ctl_new(&kctl, access);\n}\n\nEXPORT_SYMBOL(snd_ctl_new1);\n\n/**\n * snd_ctl_free_one - release the control instance\n * @kcontrol: the control instance\n *\n * Releases the control instance created via snd_ctl_new()\n * or snd_ctl_new1().\n * Don't call this after the control was added to the card.\n */\nvoid snd_ctl_free_one(struct snd_kcontrol *kcontrol)\n{\n\tif (kcontrol) {\n\t\tif (kcontrol->private_free)\n\t\t\tkcontrol->private_free(kcontrol);\n\t\tkfree(kcontrol);\n\t}\n}\n\nEXPORT_SYMBOL(snd_ctl_free_one);\n\nstatic bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int snd_ctl_find_hole(struct snd_card *card, unsigned int count)\n{\n\tunsigned int iter = 100000;\n\n\twhile (snd_ctl_remove_numid_conflict(card, count)) {\n\t\tif (--iter == 0) {\n\t\t\t/* this situation is very unlikely */\n\t\t\tdev_err(card->dev, \"unable to allocate new control numid\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * snd_ctl_add - add the control instance to the card\n * @card: the card instance\n * @kcontrol: the control instance to add\n *\n * Adds the control instance created via snd_ctl_new() or\n * snd_ctl_new1() to the given card. Assigns also an unique\n * numid used for fast search.\n *\n * It frees automatically the control which cannot be added.\n *\n * Return: Zero if successful, or a negative error code on failure.\n *\n */\nint snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n\nEXPORT_SYMBOL(snd_ctl_add);\n\n/**\n * snd_ctl_replace - replace the control instance of the card\n * @card: the card instance\n * @kcontrol: the control instance to replace\n * @add_on_replace: add the control if not already added\n *\n * Replaces the given control.  If the given control does not exist\n * and the add_on_replace flag is set, the control is added.  If the\n * control exists, it is destroyed first.\n *\n * It frees automatically the control which cannot be added or replaced.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol,\n\t\t    bool add_on_replace)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tstruct snd_kcontrol *old;\n\tint ret;\n\n\tif (!kcontrol)\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!card || !kcontrol->info)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\told = snd_ctl_find_id(card, &id);\n\tif (!old) {\n\t\tif (add_on_replace)\n\t\t\tgoto add;\n\t\tup_write(&card->controls_rwsem);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tret = snd_ctl_remove(card, old);\n\tif (ret < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\tgoto error;\n\t}\nadd:\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\nerror:\n\tsnd_ctl_free_one(kcontrol);\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_ctl_replace);\n\n/**\n * snd_ctl_remove - remove the control from the card and release it\n * @card: the card instance\n * @kcontrol: the control instance to remove\n *\n * Removes the control from the card and then releases the instance.\n * You don't need to call snd_ctl_free_one(). You must be in\n * the write lock - down_write(&card->controls_rwsem).\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\n\tif (snd_BUG_ON(!card || !kcontrol))\n\t\treturn -EINVAL;\n\tlist_del(&kcontrol->list);\n\tcard->controls_count -= kcontrol->count;\n\tid = kcontrol->id;\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_REMOVE, &id);\n\tsnd_ctl_free_one(kcontrol);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_remove);\n\n/**\n * snd_ctl_remove_id - remove the control of the given id and release it\n * @card: the card instance\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove_id(struct snd_card *card, struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tret = snd_ctl_remove(card, kctl);\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(snd_ctl_remove_id);\n\n/**\n * snd_ctl_remove_user_ctl - remove and release the unlocked user control\n * @file: active control handle\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nstatic int snd_ctl_remove_user_ctl(struct snd_ctl_file * file,\n\t\t\t\t   struct snd_ctl_elem_id *id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol *kctl;\n\tint idx, ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto error;\n\t}\n\tif (!(kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_USER)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tif (kctl->vd[idx].owner != NULL && kctl->vd[idx].owner != file) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\tret = snd_ctl_remove(card, kctl);\n\tif (ret < 0)\n\t\tgoto error;\n\tcard->user_ctl_count--;\nerror:\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\n/**\n * snd_ctl_activate_id - activate/inactivate the control of the given id\n * @card: the card instance\n * @id: the control id to activate/inactivate\n * @active: non-zero to activate\n *\n * Finds the control instance with the given id, and activate or\n * inactivate the control together with notification, if changed.\n *\n * Return: 0 if unchanged, 1 if changed, or a negative error code on failure.\n */\nint snd_ctl_activate_id(struct snd_card *card, struct snd_ctl_elem_id *id,\n\t\t\tint active)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\tindex_offset = snd_ctl_get_ioff(kctl, &kctl->id);\n\tvd = &kctl->vd[index_offset];\n\tret = 0;\n\tif (active) {\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE))\n\t\t\tgoto unlock;\n\t\tvd->access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t} else {\n\t\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE)\n\t\t\tgoto unlock;\n\t\tvd->access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t}\n\tret = 1;\n unlock:\n\tup_write(&card->controls_rwsem);\n\tif (ret > 0)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO, id);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_activate_id);\n\n/**\n * snd_ctl_rename_id - replace the id of a control on the card\n * @card: the card instance\n * @src_id: the old id\n * @dst_id: the new id\n *\n * Finds the control with the old id from the card, and replaces the\n * id with the new one.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_rename_id(struct snd_card *card, struct snd_ctl_elem_id *src_id,\n\t\t      struct snd_ctl_elem_id *dst_id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, src_id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tkctl->id = *dst_id;\n\tkctl->id.numid = card->last_numid + 1;\n\tcard->last_numid += kctl->count;\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_rename_id);\n\n/**\n * snd_ctl_find_numid - find the control instance with the given number-id\n * @card: the card instance\n * @numid: the number-id to search\n *\n * Finds the control instance with the given number-id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_numid(struct snd_card *card, unsigned int numid)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !numid))\n\t\treturn NULL;\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid)\n\t\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(snd_ctl_find_numid);\n\n/**\n * snd_ctl_find_id - find the control instance with the given id\n * @card: the card instance\n * @id: the id to search\n *\n * Finds the control instance with the given id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_id(struct snd_card *card,\n\t\t\t\t     struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn NULL;\n\tif (id->numid != 0)\n\t\treturn snd_ctl_find_numid(card, id->numid);\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.iface != id->iface)\n\t\t\tcontinue;\n\t\tif (kctl->id.device != id->device)\n\t\t\tcontinue;\n\t\tif (kctl->id.subdevice != id->subdevice)\n\t\t\tcontinue;\n\t\tif (strncmp(kctl->id.name, id->name, sizeof(kctl->id.name)))\n\t\t\tcontinue;\n\t\tif (kctl->id.index > id->index)\n\t\t\tcontinue;\n\t\tif (kctl->id.index + kctl->count <= id->index)\n\t\t\tcontinue;\n\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(snd_ctl_find_id);\n\nstatic int snd_ctl_card_info(struct snd_card *card, struct snd_ctl_file * ctl,\n\t\t\t     unsigned int cmd, void __user *arg)\n{\n\tstruct snd_ctl_card_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tdown_read(&snd_ioctl_rwsem);\n\tinfo->card = card->number;\n\tstrlcpy(info->id, card->id, sizeof(info->id));\n\tstrlcpy(info->driver, card->driver, sizeof(info->driver));\n\tstrlcpy(info->name, card->shortname, sizeof(info->name));\n\tstrlcpy(info->longname, card->longname, sizeof(info->longname));\n\tstrlcpy(info->mixername, card->mixername, sizeof(info->mixername));\n\tstrlcpy(info->components, card->components, sizeof(info->components));\n\tup_read(&snd_ioctl_rwsem);\n\tif (copy_to_user(arg, info, sizeof(struct snd_ctl_card_info))) {\n\t\tkfree(info);\n\t\treturn -EFAULT;\n\t}\n\tkfree(info);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_list(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_list __user *_list)\n{\n\tstruct list_head *plist;\n\tstruct snd_ctl_elem_list list;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_id *dst, *id;\n\tunsigned int offset, space, jidx;\n\t\n\tif (copy_from_user(&list, _list, sizeof(list)))\n\t\treturn -EFAULT;\n\toffset = list.offset;\n\tspace = list.space;\n\t/* try limit maximum space */\n\tif (space > 16384)\n\t\treturn -ENOMEM;\n\tif (space > 0) {\n\t\t/* allocate temporary buffer for atomic operation */\n\t\tdst = vmalloc(space * sizeof(struct snd_ctl_elem_id));\n\t\tif (dst == NULL)\n\t\t\treturn -ENOMEM;\n\t\tdown_read(&card->controls_rwsem);\n\t\tlist.count = card->controls_count;\n\t\tplist = card->controls.next;\n\t\twhile (plist != &card->controls) {\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\t\t\tkctl = snd_kcontrol(plist);\n\t\t\tif (offset < kctl->count)\n\t\t\t\tbreak;\n\t\t\toffset -= kctl->count;\n\t\t\tplist = plist->next;\n\t\t}\n\t\tlist.used = 0;\n\t\tid = dst;\n\t\twhile (space > 0 && plist != &card->controls) {\n\t\t\tkctl = snd_kcontrol(plist);\n\t\t\tfor (jidx = offset; space > 0 && jidx < kctl->count; jidx++) {\n\t\t\t\tsnd_ctl_build_ioff(id, kctl, jidx);\n\t\t\t\tid++;\n\t\t\t\tspace--;\n\t\t\t\tlist.used++;\n\t\t\t}\n\t\t\tplist = plist->next;\n\t\t\toffset = 0;\n\t\t}\n\t\tup_read(&card->controls_rwsem);\n\t\tif (list.used > 0 &&\n\t\t    copy_to_user(list.pids, dst,\n\t\t\t\t list.used * sizeof(struct snd_ctl_elem_id))) {\n\t\t\tvfree(dst);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tvfree(dst);\n\t} else {\n\t\tdown_read(&card->controls_rwsem);\n\t\tlist.count = card->controls_count;\n\t\tup_read(&card->controls_rwsem);\n\t}\n\tif (copy_to_user(_list, &list, sizeof(list)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_info(struct snd_ctl_file *ctl,\n\t\t\t     struct snd_ctl_elem_info *info)\n{\n\tstruct snd_card *card = ctl->card;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\t\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &info->id);\n\tif (kctl == NULL) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n#ifdef CONFIG_SND_DEBUG\n\tinfo->access = 0;\n#endif\n\tresult = kctl->info(kctl, info);\n\tif (result >= 0) {\n\t\tsnd_BUG_ON(info->access);\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &info->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tsnd_ctl_build_ioff(&info->id, kctl, index_offset);\n\t\tinfo->access = vd->access;\n\t\tif (vd->owner) {\n\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_LOCK;\n\t\t\tif (vd->owner == ctl)\n\t\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_OWNER;\n\t\t\tinfo->owner = pid_vnr(vd->owner->pid);\n\t\t} else {\n\t\t\tinfo->owner = -1;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tsnd_power_lock(ctl->card);\n\tresult = snd_power_wait(ctl->card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_info(ctl, &info);\n\tsnd_power_unlock(ctl->card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif ((vd->access & SNDRV_CTL_ELEM_ACCESS_READ) &&\n\t\t    kctl->get != NULL) {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->get(kctl, control);\n\t\t} else\n\t\t\tresult = -EPERM;\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_read(card, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->put(kctl, control);\n\t\t}\n\t\tif (result > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &control->id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_lock(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\t\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner != NULL)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tvd->owner = file;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_unlock(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\t\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner == NULL)\n\t\t\tresult = -EINVAL;\n\t\telse if (vd->owner != file)\n\t\t\tresult = -EPERM;\n\t\telse {\n\t\t\tvd->owner = NULL;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstruct user_element {\n\tstruct snd_ctl_elem_info info;\n\tstruct snd_card *card;\n\tvoid *elem_data;\t\t/* element data */\n\tunsigned long elem_data_size;\t/* size of element data in bytes */\n\tvoid *tlv_data;\t\t\t/* TLV data */\n\tunsigned long tlv_data_size;\t/* TLV data size */\n\tvoid *priv_data;\t\t/* private data (like strings for enumerated type) */\n};\n\nstatic int snd_ctl_elem_user_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\t*uinfo = ue->info;\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tconst char *names;\n\tunsigned int item;\n\n\titem = uinfo->value.enumerated.item;\n\n\t*uinfo = ue->info;\n\n\titem = min(item, uinfo->value.enumerated.items - 1);\n\tuinfo->value.enumerated.item = item;\n\n\tnames = ue->priv_data;\n\tfor (; item > 0; --item)\n\t\tnames += strlen(names) + 1;\n\tstrcpy(uinfo->value.enumerated.name, names);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn change;\n}\n\nstatic int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t} else {\n\t\tint ret = 0;\n\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tif (!ue->tlv_data_size || !ue->tlv_data) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (size < ue->tlv_data_size) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\tret = -EFAULT;\nerr_unlock:\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn change;\n}\n\nstatic int snd_ctl_elem_init_enum_names(struct user_element *ue)\n{\n\tchar *names, *p;\n\tsize_t buf_len, name_len;\n\tunsigned int i;\n\tconst uintptr_t user_ptrval = ue->info.value.enumerated.names_ptr;\n\n\tif (ue->info.value.enumerated.names_length > 64 * 1024)\n\t\treturn -EINVAL;\n\n\tnames = memdup_user((const void __user *)user_ptrval,\n\t\tue->info.value.enumerated.names_length);\n\tif (IS_ERR(names))\n\t\treturn PTR_ERR(names);\n\n\t/* check that there are enough valid names */\n\tbuf_len = ue->info.value.enumerated.names_length;\n\tp = names;\n\tfor (i = 0; i < ue->info.value.enumerated.items; ++i) {\n\t\tname_len = strnlen(p, buf_len);\n\t\tif (name_len == 0 || name_len >= 64 || name_len == buf_len) {\n\t\t\tkfree(names);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp += name_len + 1;\n\t\tbuf_len -= name_len + 1;\n\t}\n\n\tue->priv_data = names;\n\tue->info.value.enumerated.names_ptr = 0;\n\n\treturn 0;\n}\n\nstatic void snd_ctl_elem_user_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tkfree(ue->tlv_data);\n\tkfree(ue->priv_data);\n\tkfree(ue);\n}\n\nstatic int snd_ctl_elem_add(struct snd_ctl_file *file,\n\t\t\t    struct snd_ctl_elem_info *info, int replace)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol kctl, *_kctl;\n\tunsigned int access;\n\tlong private_size;\n\tstruct user_element *ue;\n\tint idx, err;\n\n\tif (!replace && card->user_ctl_count >= MAX_USER_CONTROLS)\n\t\treturn -ENOMEM;\n\tif (info->count < 1)\n\t\treturn -EINVAL;\n\taccess = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :\n\t\t(info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_INACTIVE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));\n\tinfo->id.numid = 0;\n\tmemset(&kctl, 0, sizeof(kctl));\n\tdown_write(&card->controls_rwsem);\n\t_kctl = snd_ctl_find_id(card, &info->id);\n\terr = 0;\n\tif (_kctl) {\n\t\tif (replace)\n\t\t\terr = snd_ctl_remove(card, _kctl);\n\t\telse\n\t\t\terr = -EBUSY;\n\t} else {\n\t\tif (replace)\n\t\t\terr = -ENOENT;\n\t}\n\tup_write(&card->controls_rwsem);\n\tif (err < 0)\n\t\treturn err;\n\tmemcpy(&kctl.id, &info->id, sizeof(info->id));\n\tkctl.count = info->owner ? info->owner : 1;\n\taccess |= SNDRV_CTL_ELEM_ACCESS_USER;\n\tif (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)\n\t\tkctl.info = snd_ctl_elem_user_enum_info;\n\telse\n\t\tkctl.info = snd_ctl_elem_user_info;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_READ)\n\t\tkctl.get = snd_ctl_elem_user_get;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_WRITE)\n\t\tkctl.put = snd_ctl_elem_user_put;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {\n\t\tkctl.tlv.c = snd_ctl_elem_user_tlv;\n\t\taccess |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t}\n\tswitch (info->type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tprivate_size = sizeof(long);\n\t\tif (info->count > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\tprivate_size = sizeof(long long);\n\t\tif (info->count > 64)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tprivate_size = sizeof(unsigned int);\n\t\tif (info->count > 128 || info->value.enumerated.items == 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_BYTES:\n\t\tprivate_size = sizeof(unsigned char);\n\t\tif (info->count > 512)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_IEC958:\n\t\tprivate_size = sizeof(struct snd_aes_iec958);\n\t\tif (info->count != 1)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tprivate_size *= info->count;\n\tue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);\n\tif (ue == NULL)\n\t\treturn -ENOMEM;\n\tue->card = card;\n\tue->info = *info;\n\tue->info.access = 0;\n\tue->elem_data = (char *)ue + sizeof(*ue);\n\tue->elem_data_size = private_size;\n\tif (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {\n\t\terr = snd_ctl_elem_init_enum_names(ue);\n\t\tif (err < 0) {\n\t\t\tkfree(ue);\n\t\t\treturn err;\n\t\t}\n\t}\n\tkctl.private_free = snd_ctl_elem_user_free;\n\t_kctl = snd_ctl_new(&kctl, access);\n\tif (_kctl == NULL) {\n\t\tkfree(ue->priv_data);\n\t\tkfree(ue);\n\t\treturn -ENOMEM;\n\t}\n\t_kctl->private_data = ue;\n\tfor (idx = 0; idx < _kctl->count; idx++)\n\t\t_kctl->vd[idx].owner = file;\n\terr = snd_ctl_add(card, _kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\tdown_write(&card->controls_rwsem);\n\tcard->user_ctl_count++;\n\tup_write(&card->controls_rwsem);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_add_user(struct snd_ctl_file *file,\n\t\t\t\t struct snd_ctl_elem_info __user *_info, int replace)\n{\n\tstruct snd_ctl_elem_info info;\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_elem_add(file, &info, replace);\n}\n\nstatic int snd_ctl_elem_remove(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_ctl_elem_id id;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_remove_user_ctl(file, &id);\n}\n\nstatic int snd_ctl_subscribe_events(struct snd_ctl_file *file, int __user *ptr)\n{\n\tint subscribe;\n\tif (get_user(subscribe, ptr))\n\t\treturn -EFAULT;\n\tif (subscribe < 0) {\n\t\tsubscribe = file->subscribed;\n\t\tif (put_user(subscribe, ptr))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tif (subscribe) {\n\t\tfile->subscribed = 1;\n\t\treturn 0;\n\t} else if (file->subscribed) {\n\t\tsnd_ctl_empty_read_queue(file);\n\t\tfile->subscribed = 0;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,\n                             struct snd_ctl_tlv __user *_tlv,\n                             int op_flag)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_tlv tlv;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int len;\n\tint err = 0;\n\n\tif (copy_from_user(&tlv, _tlv, sizeof(tlv)))\n\t\treturn -EFAULT;\n\tif (tlv.length < sizeof(unsigned int) * 2)\n\t\treturn -EINVAL;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid(card, tlv.numid);\n\tif (kctl == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto __kctl_end;\n\t}\n\tif (kctl->tlv.p == NULL) {\n\t\terr = -ENXIO;\n\t\tgoto __kctl_end;\n\t}\n\tvd = &kctl->vd[tlv.numid - kctl->id.numid];\n\tif ((op_flag == 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) == 0) ||\n\t    (op_flag > 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) == 0) ||\n\t    (op_flag < 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) == 0)) {\n\t    \terr = -ENXIO;\n\t    \tgoto __kctl_end;\n\t}\n\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\tif (vd->owner != NULL && vd->owner != file) {\n\t\t\terr = -EPERM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\terr = kctl->tlv.c(kctl, op_flag, tlv.length, _tlv->tlv);\n\t\tif (err > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &kctl->id);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (op_flag) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tlen = kctl->tlv.p[1] + 2 * sizeof(unsigned int);\n\t\tif (tlv.length < len) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tif (copy_to_user(_tlv->tlv, kctl->tlv.p, len))\n\t\t\terr = -EFAULT;\n\t}\n      __kctl_end:\n\tup_read(&card->controls_rwsem);\n\treturn err;\n}\n\nstatic long snd_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_card *card;\n\tstruct snd_kctl_ioctl *p;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *ip = argp;\n\tint err;\n\n\tctl = file->private_data;\n\tcard = ctl->card;\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_CTL_VERSION, ip) ? -EFAULT : 0;\n\tcase SNDRV_CTL_IOCTL_CARD_INFO:\n\t\treturn snd_ctl_card_info(card, ctl, cmd, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LIST:\n\t\treturn snd_ctl_elem_list(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_INFO:\n\t\treturn snd_ctl_elem_info_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_READ:\n\t\treturn snd_ctl_elem_read_user(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_WRITE:\n\t\treturn snd_ctl_elem_write_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LOCK:\n\t\treturn snd_ctl_elem_lock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_UNLOCK:\n\t\treturn snd_ctl_elem_unlock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_ADD:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_ELEM_REPLACE:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_ELEM_REMOVE:\n\t\treturn snd_ctl_elem_remove(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS:\n\t\treturn snd_ctl_subscribe_events(ctl, ip);\n\tcase SNDRV_CTL_IOCTL_TLV_READ:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_TLV_WRITE:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_TLV_COMMAND:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, -1);\n\tcase SNDRV_CTL_IOCTL_POWER:\n\t\treturn -ENOPROTOOPT;\n\tcase SNDRV_CTL_IOCTL_POWER_STATE:\n#ifdef CONFIG_PM\n\t\treturn put_user(card->power_state, ip) ? -EFAULT : 0;\n#else\n\t\treturn put_user(SNDRV_CTL_POWER_D0, ip) ? -EFAULT : 0;\n#endif\n\t}\n\tdown_read(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, &snd_control_ioctls, list) {\n\t\terr = p->fioctl(card, ctl, cmd, arg);\n\t\tif (err != -ENOIOCTLCMD) {\n\t\t\tup_read(&snd_ioctl_rwsem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tup_read(&snd_ioctl_rwsem);\n\tdev_dbg(card->dev, \"unknown ioctl = 0x%x\\n\", cmd);\n\treturn -ENOTTY;\n}\n\nstatic ssize_t snd_ctl_read(struct file *file, char __user *buffer,\n\t\t\t    size_t count, loff_t * offset)\n{\n\tstruct snd_ctl_file *ctl;\n\tint err = 0;\n\tssize_t result = 0;\n\n\tctl = file->private_data;\n\tif (snd_BUG_ON(!ctl || !ctl->card))\n\t\treturn -ENXIO;\n\tif (!ctl->subscribed)\n\t\treturn -EBADFD;\n\tif (count < sizeof(struct snd_ctl_event))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctl->read_lock);\n\twhile (count >= sizeof(struct snd_ctl_event)) {\n\t\tstruct snd_ctl_event ev;\n\t\tstruct snd_kctl_event *kev;\n\t\twhile (list_empty(&ctl->events)) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto __end_lock;\n\t\t\t}\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ctl->read_lock);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tif (ctl->card->shutdown)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tspin_lock_irq(&ctl->read_lock);\n\t\t}\n\t\tkev = snd_kctl_event(ctl->events.next);\n\t\tev.type = SNDRV_CTL_EVENT_ELEM;\n\t\tev.data.elem.mask = kev->mask;\n\t\tev.data.elem.id = kev->id;\n\t\tlist_del(&kev->list);\n\t\tspin_unlock_irq(&ctl->read_lock);\n\t\tkfree(kev);\n\t\tif (copy_to_user(buffer, &ev, sizeof(struct snd_ctl_event))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto __end;\n\t\t}\n\t\tspin_lock_irq(&ctl->read_lock);\n\t\tbuffer += sizeof(struct snd_ctl_event);\n\t\tcount -= sizeof(struct snd_ctl_event);\n\t\tresult += sizeof(struct snd_ctl_event);\n\t}\n      __end_lock:\n\tspin_unlock_irq(&ctl->read_lock);\n      __end:\n      \treturn result > 0 ? result : err;\n}\n\nstatic unsigned int snd_ctl_poll(struct file *file, poll_table * wait)\n{\n\tunsigned int mask;\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\tif (!ctl->subscribed)\n\t\treturn 0;\n\tpoll_wait(file, &ctl->change_sleep, wait);\n\n\tmask = 0;\n\tif (!list_empty(&ctl->events))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\treturn mask;\n}\n\n/*\n * register the device-specific control-ioctls.\n * called from each device manager like pcm.c, hwdep.c, etc.\n */\nstatic int _snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn, struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *pn;\n\n\tpn = kzalloc(sizeof(struct snd_kctl_ioctl), GFP_KERNEL);\n\tif (pn == NULL)\n\t\treturn -ENOMEM;\n\tpn->fioctl = fcn;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_add_tail(&pn->list, lists);\n\tup_write(&snd_ioctl_rwsem);\n\treturn 0;\n}\n\nint snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_register_ioctl);\n\n#ifdef CONFIG_COMPAT\nint snd_ctl_register_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_compat_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_register_ioctl_compat);\n#endif\n\n/*\n * de-register the device-specific control-ioctls.\n */\nstatic int _snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn,\n\t\t\t\t     struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *p;\n\n\tif (snd_BUG_ON(!fcn))\n\t\treturn -EINVAL;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, lists, list) {\n\t\tif (p->fioctl == fcn) {\n\t\t\tlist_del(&p->list);\n\t\t\tup_write(&snd_ioctl_rwsem);\n\t\t\tkfree(p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_write(&snd_ioctl_rwsem);\n\tsnd_BUG();\n\treturn -EINVAL;\n}\n\nint snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl);\n\n#ifdef CONFIG_COMPAT\nint snd_ctl_unregister_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_compat_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);\n#endif\n\nstatic int snd_ctl_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\treturn fasync_helper(fd, file, on, &ctl->fasync);\n}\n\n/*\n * ioctl32 compat\n */\n#ifdef CONFIG_COMPAT\n#include \"control_compat.c\"\n#else\n#define snd_ctl_ioctl_compat\tNULL\n#endif\n\n/*\n *  INIT PART\n */\n\nstatic const struct file_operations snd_ctl_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_ctl_read,\n\t.open =\t\tsnd_ctl_open,\n\t.release =\tsnd_ctl_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_ctl_poll,\n\t.unlocked_ioctl =\tsnd_ctl_ioctl,\n\t.compat_ioctl =\tsnd_ctl_ioctl_compat,\n\t.fasync =\tsnd_ctl_fasync,\n};\n\n/*\n * registration of the control device\n */\nstatic int snd_ctl_dev_register(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tint err, cardnum;\n\tchar name[16];\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\tsprintf(name, \"controlC%i\", cardnum);\n\tif ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1,\n\t\t\t\t       &snd_ctl_f_ops, card, name)) < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n/*\n * disconnection of the control device\n */\nstatic int snd_ctl_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_ctl_file *ctl;\n\tint err, cardnum;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\n\tread_lock(&card->ctl_files_rwlock);\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\twake_up(&ctl->change_sleep);\n\t\tkill_fasync(&ctl->fasync, SIGIO, POLL_ERR);\n\t}\n\tread_unlock(&card->ctl_files_rwlock);\n\n\tif ((err = snd_unregister_device(SNDRV_DEVICE_TYPE_CONTROL,\n\t\t\t\t\t card, -1)) < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n/*\n * free all controls\n */\nstatic int snd_ctl_dev_free(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_kcontrol *control;\n\n\tdown_write(&card->controls_rwsem);\n\twhile (!list_empty(&card->controls)) {\n\t\tcontrol = snd_kcontrol(card->controls.next);\n\t\tsnd_ctl_remove(card, control);\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\n\n/*\n * create control core:\n * called from init.c\n */\nint snd_ctl_create(struct snd_card *card)\n{\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_ctl_dev_free,\n\t\t.dev_register =\tsnd_ctl_dev_register,\n\t\t.dev_disconnect = snd_ctl_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\treturn snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);\n}\n\n/*\n * Frequently used control callbacks/helpers\n */\nint snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_boolean_mono_info);\n\nint snd_ctl_boolean_stereo_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_boolean_stereo_info);\n\n/**\n * snd_ctl_enum_info - fills the info structure for an enumerated control\n * @info: the structure to be filled\n * @channels: the number of the control's channels; often one\n * @items: the number of control values; also the size of @names\n * @names: an array containing the names of all control values\n *\n * Sets all required fields in @info to their appropriate values.\n * If the control's accessibility is not the default (readable and writable),\n * the caller has to fill @info->access.\n *\n * Return: Zero.\n */\nint snd_ctl_enum_info(struct snd_ctl_elem_info *info, unsigned int channels,\n\t\t      unsigned int items, const char *const names[])\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tinfo->count = channels;\n\tinfo->value.enumerated.items = items;\n\tif (info->value.enumerated.item >= items)\n\t\tinfo->value.enumerated.item = items - 1;\n\tstrlcpy(info->value.enumerated.name,\n\t\tnames[info->value.enumerated.item],\n\t\tsizeof(info->value.enumerated.name));\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_enum_info);\n"], "fixing_code": ["/*\n *  Routines for driver control interface\n *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n#include <linux/threads.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n#include <sound/info.h>\n#include <sound/control.h>\n\n/* max number of user-defined controls */\n#define MAX_USER_CONTROLS\t32\n#define MAX_CONTROL_COUNT\t1028\n\nstruct snd_kctl_ioctl {\n\tstruct list_head list;\t\t/* list of all ioctls */\n\tsnd_kctl_ioctl_func_t fioctl;\n};\n\nstatic DECLARE_RWSEM(snd_ioctl_rwsem);\nstatic LIST_HEAD(snd_control_ioctls);\n#ifdef CONFIG_COMPAT\nstatic LIST_HEAD(snd_control_compat_ioctls);\n#endif\n\nstatic int snd_ctl_open(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\tcard = snd_lookup_minor_data(iminor(inode), SNDRV_DEVICE_TYPE_CONTROL);\n\tif (!card) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\terr = snd_card_file_add(card, file);\n\tif (err < 0) {\n\t\terr = -ENODEV;\n\t\tgoto __error1;\n\t}\n\tif (!try_module_get(card->module)) {\n\t\terr = -EFAULT;\n\t\tgoto __error2;\n\t}\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (ctl == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto __error;\n\t}\n\tINIT_LIST_HEAD(&ctl->events);\n\tinit_waitqueue_head(&ctl->change_sleep);\n\tspin_lock_init(&ctl->read_lock);\n\tctl->card = card;\n\tctl->prefer_pcm_subdevice = -1;\n\tctl->prefer_rawmidi_subdevice = -1;\n\tctl->pid = get_pid(task_pid(current));\n\tfile->private_data = ctl;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_add_tail(&ctl->list, &card->ctl_files);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tsnd_card_unref(card);\n\treturn 0;\n\n      __error:\n\tmodule_put(card->module);\n      __error2:\n\tsnd_card_file_remove(card, file);\n      __error1:\n\tif (card)\n\t\tsnd_card_unref(card);\n      \treturn err;\n}\n\nstatic void snd_ctl_empty_read_queue(struct snd_ctl_file * ctl)\n{\n\tunsigned long flags;\n\tstruct snd_kctl_event *cread;\n\t\n\tspin_lock_irqsave(&ctl->read_lock, flags);\n\twhile (!list_empty(&ctl->events)) {\n\t\tcread = snd_kctl_event(ctl->events.next);\n\t\tlist_del(&cread->list);\n\t\tkfree(cread);\n\t}\n\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n}\n\nstatic int snd_ctl_release(struct inode *inode, struct file *file)\n{\n\tunsigned long flags;\n\tstruct snd_card *card;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kcontrol *control;\n\tunsigned int idx;\n\n\tctl = file->private_data;\n\tfile->private_data = NULL;\n\tcard = ctl->card;\n\twrite_lock_irqsave(&card->ctl_files_rwlock, flags);\n\tlist_del(&ctl->list);\n\twrite_unlock_irqrestore(&card->ctl_files_rwlock, flags);\n\tdown_write(&card->controls_rwsem);\n\tlist_for_each_entry(control, &card->controls, list)\n\t\tfor (idx = 0; idx < control->count; idx++)\n\t\t\tif (control->vd[idx].owner == ctl)\n\t\t\t\tcontrol->vd[idx].owner = NULL;\n\tup_write(&card->controls_rwsem);\n\tsnd_ctl_empty_read_queue(ctl);\n\tput_pid(ctl->pid);\n\tkfree(ctl);\n\tmodule_put(card->module);\n\tsnd_card_file_remove(card, file);\n\treturn 0;\n}\n\nvoid snd_ctl_notify(struct snd_card *card, unsigned int mask,\n\t\t    struct snd_ctl_elem_id *id)\n{\n\tunsigned long flags;\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_kctl_event *ev;\n\t\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn;\n\tread_lock(&card->ctl_files_rwlock);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tcard->mixer_oss_change_count++;\n#endif\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\tif (!ctl->subscribed)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&ctl->read_lock, flags);\n\t\tlist_for_each_entry(ev, &ctl->events, list) {\n\t\t\tif (ev->id.numid == id->numid) {\n\t\t\t\tev->mask |= mask;\n\t\t\t\tgoto _found;\n\t\t\t}\n\t\t}\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (ev) {\n\t\t\tev->id = *id;\n\t\t\tev->mask = mask;\n\t\t\tlist_add_tail(&ev->list, &ctl->events);\n\t\t} else {\n\t\t\tdev_err(card->dev, \"No memory available to allocate event\\n\");\n\t\t}\n\t_found:\n\t\twake_up(&ctl->change_sleep);\n\t\tspin_unlock_irqrestore(&ctl->read_lock, flags);\n\t\tkill_fasync(&ctl->fasync, SIGIO, POLL_IN);\n\t}\n\tread_unlock(&card->ctl_files_rwlock);\n}\n\nEXPORT_SYMBOL(snd_ctl_notify);\n\n/**\n * snd_ctl_new - create a control instance from the template\n * @control: the control template\n * @access: the default control access\n *\n * Allocates a new struct snd_kcontrol instance and copies the given template \n * to the new instance. It does not copy volatile data (access).\n *\n * Return: The pointer of the new instance, or %NULL on failure.\n */\nstatic struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,\n\t\t\t\t\tunsigned int access)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\t\n\tif (snd_BUG_ON(!control || !control->count))\n\t\treturn NULL;\n\n\tif (control->count > MAX_CONTROL_COUNT)\n\t\treturn NULL;\n\n\tkctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);\n\tif (kctl == NULL) {\n\t\tpr_err(\"ALSA: Cannot allocate control instance\\n\");\n\t\treturn NULL;\n\t}\n\t*kctl = *control;\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tkctl->vd[idx].access = access;\n\treturn kctl;\n}\n\n/**\n * snd_ctl_new1 - create a control instance from the template\n * @ncontrol: the initialization record\n * @private_data: the private data to set\n *\n * Allocates a new struct snd_kcontrol instance and initialize from the given \n * template.  When the access field of ncontrol is 0, it's assumed as\n * READWRITE access. When the count field is 0, it's assumes as one.\n *\n * Return: The pointer of the newly generated instance, or %NULL on failure.\n */\nstruct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new *ncontrol,\n\t\t\t\t  void *private_data)\n{\n\tstruct snd_kcontrol kctl;\n\tunsigned int access;\n\t\n\tif (snd_BUG_ON(!ncontrol || !ncontrol->info))\n\t\treturn NULL;\n\tmemset(&kctl, 0, sizeof(kctl));\n\tkctl.id.iface = ncontrol->iface;\n\tkctl.id.device = ncontrol->device;\n\tkctl.id.subdevice = ncontrol->subdevice;\n\tif (ncontrol->name) {\n\t\tstrlcpy(kctl.id.name, ncontrol->name, sizeof(kctl.id.name));\n\t\tif (strcmp(ncontrol->name, kctl.id.name) != 0)\n\t\t\tpr_warn(\"ALSA: Control name '%s' truncated to '%s'\\n\",\n\t\t\t\tncontrol->name, kctl.id.name);\n\t}\n\tkctl.id.index = ncontrol->index;\n\tkctl.count = ncontrol->count ? ncontrol->count : 1;\n\taccess = ncontrol->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :\n\t\t (ncontrol->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_VOLATILE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_INACTIVE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND|\n\t\t\t\t      SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK));\n\tkctl.info = ncontrol->info;\n\tkctl.get = ncontrol->get;\n\tkctl.put = ncontrol->put;\n\tkctl.tlv.p = ncontrol->tlv.p;\n\tkctl.private_value = ncontrol->private_value;\n\tkctl.private_data = private_data;\n\treturn snd_ctl_new(&kctl, access);\n}\n\nEXPORT_SYMBOL(snd_ctl_new1);\n\n/**\n * snd_ctl_free_one - release the control instance\n * @kcontrol: the control instance\n *\n * Releases the control instance created via snd_ctl_new()\n * or snd_ctl_new1().\n * Don't call this after the control was added to the card.\n */\nvoid snd_ctl_free_one(struct snd_kcontrol *kcontrol)\n{\n\tif (kcontrol) {\n\t\tif (kcontrol->private_free)\n\t\t\tkcontrol->private_free(kcontrol);\n\t\tkfree(kcontrol);\n\t}\n}\n\nEXPORT_SYMBOL(snd_ctl_free_one);\n\nstatic bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int snd_ctl_find_hole(struct snd_card *card, unsigned int count)\n{\n\tunsigned int iter = 100000;\n\n\twhile (snd_ctl_remove_numid_conflict(card, count)) {\n\t\tif (--iter == 0) {\n\t\t\t/* this situation is very unlikely */\n\t\t\tdev_err(card->dev, \"unable to allocate new control numid\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * snd_ctl_add - add the control instance to the card\n * @card: the card instance\n * @kcontrol: the control instance to add\n *\n * Adds the control instance created via snd_ctl_new() or\n * snd_ctl_new1() to the given card. Assigns also an unique\n * numid used for fast search.\n *\n * It frees automatically the control which cannot be added.\n *\n * Return: Zero if successful, or a negative error code on failure.\n *\n */\nint snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n\nEXPORT_SYMBOL(snd_ctl_add);\n\n/**\n * snd_ctl_replace - replace the control instance of the card\n * @card: the card instance\n * @kcontrol: the control instance to replace\n * @add_on_replace: add the control if not already added\n *\n * Replaces the given control.  If the given control does not exist\n * and the add_on_replace flag is set, the control is added.  If the\n * control exists, it is destroyed first.\n *\n * It frees automatically the control which cannot be added or replaced.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol,\n\t\t    bool add_on_replace)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tstruct snd_kcontrol *old;\n\tint ret;\n\n\tif (!kcontrol)\n\t\treturn -EINVAL;\n\tif (snd_BUG_ON(!card || !kcontrol->info)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\told = snd_ctl_find_id(card, &id);\n\tif (!old) {\n\t\tif (add_on_replace)\n\t\t\tgoto add;\n\t\tup_write(&card->controls_rwsem);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tret = snd_ctl_remove(card, old);\n\tif (ret < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\tgoto error;\n\t}\nadd:\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\nerror:\n\tsnd_ctl_free_one(kcontrol);\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_ctl_replace);\n\n/**\n * snd_ctl_remove - remove the control from the card and release it\n * @card: the card instance\n * @kcontrol: the control instance to remove\n *\n * Removes the control from the card and then releases the instance.\n * You don't need to call snd_ctl_free_one(). You must be in\n * the write lock - down_write(&card->controls_rwsem).\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\n\tif (snd_BUG_ON(!card || !kcontrol))\n\t\treturn -EINVAL;\n\tlist_del(&kcontrol->list);\n\tcard->controls_count -= kcontrol->count;\n\tid = kcontrol->id;\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_REMOVE, &id);\n\tsnd_ctl_free_one(kcontrol);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_remove);\n\n/**\n * snd_ctl_remove_id - remove the control of the given id and release it\n * @card: the card instance\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nint snd_ctl_remove_id(struct snd_card *card, struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tret = snd_ctl_remove(card, kctl);\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(snd_ctl_remove_id);\n\n/**\n * snd_ctl_remove_user_ctl - remove and release the unlocked user control\n * @file: active control handle\n * @id: the control id to remove\n *\n * Finds the control instance with the given id, removes it from the\n * card list and releases it.\n *\n * Return: 0 if successful, or a negative error code on failure.\n */\nstatic int snd_ctl_remove_user_ctl(struct snd_ctl_file * file,\n\t\t\t\t   struct snd_ctl_elem_id *id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol *kctl;\n\tint idx, ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto error;\n\t}\n\tif (!(kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_USER)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tif (kctl->vd[idx].owner != NULL && kctl->vd[idx].owner != file) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto error;\n\t\t}\n\tret = snd_ctl_remove(card, kctl);\n\tif (ret < 0)\n\t\tgoto error;\n\tcard->user_ctl_count--;\nerror:\n\tup_write(&card->controls_rwsem);\n\treturn ret;\n}\n\n/**\n * snd_ctl_activate_id - activate/inactivate the control of the given id\n * @card: the card instance\n * @id: the control id to activate/inactivate\n * @active: non-zero to activate\n *\n * Finds the control instance with the given id, and activate or\n * inactivate the control together with notification, if changed.\n *\n * Return: 0 if unchanged, 1 if changed, or a negative error code on failure.\n */\nint snd_ctl_activate_id(struct snd_card *card, struct snd_ctl_elem_id *id,\n\t\t\tint active)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint ret;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\tindex_offset = snd_ctl_get_ioff(kctl, &kctl->id);\n\tvd = &kctl->vd[index_offset];\n\tret = 0;\n\tif (active) {\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE))\n\t\t\tgoto unlock;\n\t\tvd->access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t} else {\n\t\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE)\n\t\t\tgoto unlock;\n\t\tvd->access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\t}\n\tret = 1;\n unlock:\n\tup_write(&card->controls_rwsem);\n\tif (ret > 0)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO, id);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_ctl_activate_id);\n\n/**\n * snd_ctl_rename_id - replace the id of a control on the card\n * @card: the card instance\n * @src_id: the old id\n * @dst_id: the new id\n *\n * Finds the control with the old id from the card, and replaces the\n * id with the new one.\n *\n * Return: Zero if successful, or a negative error code on failure.\n */\nint snd_ctl_rename_id(struct snd_card *card, struct snd_ctl_elem_id *src_id,\n\t\t      struct snd_ctl_elem_id *dst_id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, src_id);\n\tif (kctl == NULL) {\n\t\tup_write(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n\tkctl->id = *dst_id;\n\tkctl->id.numid = card->last_numid + 1;\n\tcard->last_numid += kctl->count;\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_rename_id);\n\n/**\n * snd_ctl_find_numid - find the control instance with the given number-id\n * @card: the card instance\n * @numid: the number-id to search\n *\n * Finds the control instance with the given number-id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_numid(struct snd_card *card, unsigned int numid)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !numid))\n\t\treturn NULL;\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid <= numid && kctl->id.numid + kctl->count > numid)\n\t\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(snd_ctl_find_numid);\n\n/**\n * snd_ctl_find_id - find the control instance with the given id\n * @card: the card instance\n * @id: the id to search\n *\n * Finds the control instance with the given id from the card.\n *\n * The caller must down card->controls_rwsem before calling this function\n * (if the race condition can happen).\n *\n * Return: The pointer of the instance if found, or %NULL if not.\n *\n */\nstruct snd_kcontrol *snd_ctl_find_id(struct snd_card *card,\n\t\t\t\t     struct snd_ctl_elem_id *id)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (snd_BUG_ON(!card || !id))\n\t\treturn NULL;\n\tif (id->numid != 0)\n\t\treturn snd_ctl_find_numid(card, id->numid);\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.iface != id->iface)\n\t\t\tcontinue;\n\t\tif (kctl->id.device != id->device)\n\t\t\tcontinue;\n\t\tif (kctl->id.subdevice != id->subdevice)\n\t\t\tcontinue;\n\t\tif (strncmp(kctl->id.name, id->name, sizeof(kctl->id.name)))\n\t\t\tcontinue;\n\t\tif (kctl->id.index > id->index)\n\t\t\tcontinue;\n\t\tif (kctl->id.index + kctl->count <= id->index)\n\t\t\tcontinue;\n\t\treturn kctl;\n\t}\n\treturn NULL;\n}\n\nEXPORT_SYMBOL(snd_ctl_find_id);\n\nstatic int snd_ctl_card_info(struct snd_card *card, struct snd_ctl_file * ctl,\n\t\t\t     unsigned int cmd, void __user *arg)\n{\n\tstruct snd_ctl_card_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (! info)\n\t\treturn -ENOMEM;\n\tdown_read(&snd_ioctl_rwsem);\n\tinfo->card = card->number;\n\tstrlcpy(info->id, card->id, sizeof(info->id));\n\tstrlcpy(info->driver, card->driver, sizeof(info->driver));\n\tstrlcpy(info->name, card->shortname, sizeof(info->name));\n\tstrlcpy(info->longname, card->longname, sizeof(info->longname));\n\tstrlcpy(info->mixername, card->mixername, sizeof(info->mixername));\n\tstrlcpy(info->components, card->components, sizeof(info->components));\n\tup_read(&snd_ioctl_rwsem);\n\tif (copy_to_user(arg, info, sizeof(struct snd_ctl_card_info))) {\n\t\tkfree(info);\n\t\treturn -EFAULT;\n\t}\n\tkfree(info);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_list(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_list __user *_list)\n{\n\tstruct list_head *plist;\n\tstruct snd_ctl_elem_list list;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_ctl_elem_id *dst, *id;\n\tunsigned int offset, space, jidx;\n\t\n\tif (copy_from_user(&list, _list, sizeof(list)))\n\t\treturn -EFAULT;\n\toffset = list.offset;\n\tspace = list.space;\n\t/* try limit maximum space */\n\tif (space > 16384)\n\t\treturn -ENOMEM;\n\tif (space > 0) {\n\t\t/* allocate temporary buffer for atomic operation */\n\t\tdst = vmalloc(space * sizeof(struct snd_ctl_elem_id));\n\t\tif (dst == NULL)\n\t\t\treturn -ENOMEM;\n\t\tdown_read(&card->controls_rwsem);\n\t\tlist.count = card->controls_count;\n\t\tplist = card->controls.next;\n\t\twhile (plist != &card->controls) {\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\t\t\tkctl = snd_kcontrol(plist);\n\t\t\tif (offset < kctl->count)\n\t\t\t\tbreak;\n\t\t\toffset -= kctl->count;\n\t\t\tplist = plist->next;\n\t\t}\n\t\tlist.used = 0;\n\t\tid = dst;\n\t\twhile (space > 0 && plist != &card->controls) {\n\t\t\tkctl = snd_kcontrol(plist);\n\t\t\tfor (jidx = offset; space > 0 && jidx < kctl->count; jidx++) {\n\t\t\t\tsnd_ctl_build_ioff(id, kctl, jidx);\n\t\t\t\tid++;\n\t\t\t\tspace--;\n\t\t\t\tlist.used++;\n\t\t\t}\n\t\t\tplist = plist->next;\n\t\t\toffset = 0;\n\t\t}\n\t\tup_read(&card->controls_rwsem);\n\t\tif (list.used > 0 &&\n\t\t    copy_to_user(list.pids, dst,\n\t\t\t\t list.used * sizeof(struct snd_ctl_elem_id))) {\n\t\t\tvfree(dst);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tvfree(dst);\n\t} else {\n\t\tdown_read(&card->controls_rwsem);\n\t\tlist.count = card->controls_count;\n\t\tup_read(&card->controls_rwsem);\n\t}\n\tif (copy_to_user(_list, &list, sizeof(list)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_info(struct snd_ctl_file *ctl,\n\t\t\t     struct snd_ctl_elem_info *info)\n{\n\tstruct snd_card *card = ctl->card;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\t\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &info->id);\n\tif (kctl == NULL) {\n\t\tup_read(&card->controls_rwsem);\n\t\treturn -ENOENT;\n\t}\n#ifdef CONFIG_SND_DEBUG\n\tinfo->access = 0;\n#endif\n\tresult = kctl->info(kctl, info);\n\tif (result >= 0) {\n\t\tsnd_BUG_ON(info->access);\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &info->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tsnd_ctl_build_ioff(&info->id, kctl, index_offset);\n\t\tinfo->access = vd->access;\n\t\tif (vd->owner) {\n\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_LOCK;\n\t\t\tif (vd->owner == ctl)\n\t\t\t\tinfo->access |= SNDRV_CTL_ELEM_ACCESS_OWNER;\n\t\t\tinfo->owner = pid_vnr(vd->owner->pid);\n\t\t} else {\n\t\t\tinfo->owner = -1;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tsnd_power_lock(ctl->card);\n\tresult = snd_power_wait(ctl->card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_info(ctl, &info);\n\tsnd_power_unlock(ctl->card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif ((vd->access & SNDRV_CTL_ELEM_ACCESS_READ) &&\n\t\t    kctl->get != NULL) {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->get(kctl, control);\n\t\t} else\n\t\t\tresult = -EPERM;\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_read(card, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->put(kctl, control);\n\t\t}\n\t\tif (result > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &control->id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_lock(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\t\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner != NULL)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tvd->owner = file;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstatic int snd_ctl_elem_unlock(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\t\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner == NULL)\n\t\t\tresult = -EINVAL;\n\t\telse if (vd->owner != file)\n\t\t\tresult = -EPERM;\n\t\telse {\n\t\t\tvd->owner = NULL;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}\n\nstruct user_element {\n\tstruct snd_ctl_elem_info info;\n\tstruct snd_card *card;\n\tvoid *elem_data;\t\t/* element data */\n\tunsigned long elem_data_size;\t/* size of element data in bytes */\n\tvoid *tlv_data;\t\t\t/* TLV data */\n\tunsigned long tlv_data_size;\t/* TLV data size */\n\tvoid *priv_data;\t\t/* private data (like strings for enumerated type) */\n};\n\nstatic int snd_ctl_elem_user_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\t*uinfo = ue->info;\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_enum_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tconst char *names;\n\tunsigned int item;\n\n\titem = uinfo->value.enumerated.item;\n\n\t*uinfo = ue->info;\n\n\titem = min(item, uinfo->value.enumerated.items - 1);\n\tuinfo->value.enumerated.item = item;\n\n\tnames = ue->priv_data;\n\tfor (; item > 0; --item)\n\t\tnames += strlen(names) + 1;\n\tstrcpy(uinfo->value.enumerated.name, names);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn change;\n}\n\nstatic int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t/* sane value */\n\t\t\treturn -EINVAL;\n\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t} else {\n\t\tint ret = 0;\n\n\t\tmutex_lock(&ue->card->user_ctl_lock);\n\t\tif (!ue->tlv_data_size || !ue->tlv_data) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (size < ue->tlv_data_size) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\tret = -EFAULT;\nerr_unlock:\n\t\tmutex_unlock(&ue->card->user_ctl_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn change;\n}\n\nstatic int snd_ctl_elem_init_enum_names(struct user_element *ue)\n{\n\tchar *names, *p;\n\tsize_t buf_len, name_len;\n\tunsigned int i;\n\tconst uintptr_t user_ptrval = ue->info.value.enumerated.names_ptr;\n\n\tif (ue->info.value.enumerated.names_length > 64 * 1024)\n\t\treturn -EINVAL;\n\n\tnames = memdup_user((const void __user *)user_ptrval,\n\t\tue->info.value.enumerated.names_length);\n\tif (IS_ERR(names))\n\t\treturn PTR_ERR(names);\n\n\t/* check that there are enough valid names */\n\tbuf_len = ue->info.value.enumerated.names_length;\n\tp = names;\n\tfor (i = 0; i < ue->info.value.enumerated.items; ++i) {\n\t\tname_len = strnlen(p, buf_len);\n\t\tif (name_len == 0 || name_len >= 64 || name_len == buf_len) {\n\t\t\tkfree(names);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp += name_len + 1;\n\t\tbuf_len -= name_len + 1;\n\t}\n\n\tue->priv_data = names;\n\tue->info.value.enumerated.names_ptr = 0;\n\n\treturn 0;\n}\n\nstatic void snd_ctl_elem_user_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tkfree(ue->tlv_data);\n\tkfree(ue->priv_data);\n\tkfree(ue);\n}\n\nstatic int snd_ctl_elem_add(struct snd_ctl_file *file,\n\t\t\t    struct snd_ctl_elem_info *info, int replace)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_kcontrol kctl, *_kctl;\n\tunsigned int access;\n\tlong private_size;\n\tstruct user_element *ue;\n\tint idx, err;\n\n\tif (info->count < 1)\n\t\treturn -EINVAL;\n\taccess = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :\n\t\t(info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_INACTIVE|\n\t\t\t\t SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));\n\tinfo->id.numid = 0;\n\tmemset(&kctl, 0, sizeof(kctl));\n\n\tif (replace) {\n\t\terr = snd_ctl_remove_user_ctl(file, &info->id);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (card->user_ctl_count >= MAX_USER_CONTROLS)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&kctl.id, &info->id, sizeof(info->id));\n\tkctl.count = info->owner ? info->owner : 1;\n\taccess |= SNDRV_CTL_ELEM_ACCESS_USER;\n\tif (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)\n\t\tkctl.info = snd_ctl_elem_user_enum_info;\n\telse\n\t\tkctl.info = snd_ctl_elem_user_info;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_READ)\n\t\tkctl.get = snd_ctl_elem_user_get;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_WRITE)\n\t\tkctl.put = snd_ctl_elem_user_put;\n\tif (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {\n\t\tkctl.tlv.c = snd_ctl_elem_user_tlv;\n\t\taccess |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t}\n\tswitch (info->type) {\n\tcase SNDRV_CTL_ELEM_TYPE_BOOLEAN:\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER:\n\t\tprivate_size = sizeof(long);\n\t\tif (info->count > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_INTEGER64:\n\t\tprivate_size = sizeof(long long);\n\t\tif (info->count > 64)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_ENUMERATED:\n\t\tprivate_size = sizeof(unsigned int);\n\t\tif (info->count > 128 || info->value.enumerated.items == 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_BYTES:\n\t\tprivate_size = sizeof(unsigned char);\n\t\tif (info->count > 512)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase SNDRV_CTL_ELEM_TYPE_IEC958:\n\t\tprivate_size = sizeof(struct snd_aes_iec958);\n\t\tif (info->count != 1)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tprivate_size *= info->count;\n\tue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);\n\tif (ue == NULL)\n\t\treturn -ENOMEM;\n\tue->card = card;\n\tue->info = *info;\n\tue->info.access = 0;\n\tue->elem_data = (char *)ue + sizeof(*ue);\n\tue->elem_data_size = private_size;\n\tif (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {\n\t\terr = snd_ctl_elem_init_enum_names(ue);\n\t\tif (err < 0) {\n\t\t\tkfree(ue);\n\t\t\treturn err;\n\t\t}\n\t}\n\tkctl.private_free = snd_ctl_elem_user_free;\n\t_kctl = snd_ctl_new(&kctl, access);\n\tif (_kctl == NULL) {\n\t\tkfree(ue->priv_data);\n\t\tkfree(ue);\n\t\treturn -ENOMEM;\n\t}\n\t_kctl->private_data = ue;\n\tfor (idx = 0; idx < _kctl->count; idx++)\n\t\t_kctl->vd[idx].owner = file;\n\terr = snd_ctl_add(card, _kctl);\n\tif (err < 0)\n\t\treturn err;\n\n\tdown_write(&card->controls_rwsem);\n\tcard->user_ctl_count++;\n\tup_write(&card->controls_rwsem);\n\n\treturn 0;\n}\n\nstatic int snd_ctl_elem_add_user(struct snd_ctl_file *file,\n\t\t\t\t struct snd_ctl_elem_info __user *_info, int replace)\n{\n\tstruct snd_ctl_elem_info info;\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_elem_add(file, &info, replace);\n}\n\nstatic int snd_ctl_elem_remove(struct snd_ctl_file *file,\n\t\t\t       struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_ctl_elem_id id;\n\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\treturn snd_ctl_remove_user_ctl(file, &id);\n}\n\nstatic int snd_ctl_subscribe_events(struct snd_ctl_file *file, int __user *ptr)\n{\n\tint subscribe;\n\tif (get_user(subscribe, ptr))\n\t\treturn -EFAULT;\n\tif (subscribe < 0) {\n\t\tsubscribe = file->subscribed;\n\t\tif (put_user(subscribe, ptr))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tif (subscribe) {\n\t\tfile->subscribed = 1;\n\t\treturn 0;\n\t} else if (file->subscribed) {\n\t\tsnd_ctl_empty_read_queue(file);\n\t\tfile->subscribed = 0;\n\t}\n\treturn 0;\n}\n\nstatic int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,\n                             struct snd_ctl_tlv __user *_tlv,\n                             int op_flag)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_tlv tlv;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int len;\n\tint err = 0;\n\n\tif (copy_from_user(&tlv, _tlv, sizeof(tlv)))\n\t\treturn -EFAULT;\n\tif (tlv.length < sizeof(unsigned int) * 2)\n\t\treturn -EINVAL;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid(card, tlv.numid);\n\tif (kctl == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto __kctl_end;\n\t}\n\tif (kctl->tlv.p == NULL) {\n\t\terr = -ENXIO;\n\t\tgoto __kctl_end;\n\t}\n\tvd = &kctl->vd[tlv.numid - kctl->id.numid];\n\tif ((op_flag == 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) == 0) ||\n\t    (op_flag > 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) == 0) ||\n\t    (op_flag < 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) == 0)) {\n\t    \terr = -ENXIO;\n\t    \tgoto __kctl_end;\n\t}\n\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\tif (vd->owner != NULL && vd->owner != file) {\n\t\t\terr = -EPERM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\terr = kctl->tlv.c(kctl, op_flag, tlv.length, _tlv->tlv);\n\t\tif (err > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &kctl->id);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (op_flag) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tlen = kctl->tlv.p[1] + 2 * sizeof(unsigned int);\n\t\tif (tlv.length < len) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tif (copy_to_user(_tlv->tlv, kctl->tlv.p, len))\n\t\t\terr = -EFAULT;\n\t}\n      __kctl_end:\n\tup_read(&card->controls_rwsem);\n\treturn err;\n}\n\nstatic long snd_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct snd_ctl_file *ctl;\n\tstruct snd_card *card;\n\tstruct snd_kctl_ioctl *p;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *ip = argp;\n\tint err;\n\n\tctl = file->private_data;\n\tcard = ctl->card;\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tswitch (cmd) {\n\tcase SNDRV_CTL_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_CTL_VERSION, ip) ? -EFAULT : 0;\n\tcase SNDRV_CTL_IOCTL_CARD_INFO:\n\t\treturn snd_ctl_card_info(card, ctl, cmd, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LIST:\n\t\treturn snd_ctl_elem_list(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_INFO:\n\t\treturn snd_ctl_elem_info_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_READ:\n\t\treturn snd_ctl_elem_read_user(card, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_WRITE:\n\t\treturn snd_ctl_elem_write_user(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_LOCK:\n\t\treturn snd_ctl_elem_lock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_UNLOCK:\n\t\treturn snd_ctl_elem_unlock(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_ELEM_ADD:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_ELEM_REPLACE:\n\t\treturn snd_ctl_elem_add_user(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_ELEM_REMOVE:\n\t\treturn snd_ctl_elem_remove(ctl, argp);\n\tcase SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS:\n\t\treturn snd_ctl_subscribe_events(ctl, ip);\n\tcase SNDRV_CTL_IOCTL_TLV_READ:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, 0);\n\tcase SNDRV_CTL_IOCTL_TLV_WRITE:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, 1);\n\tcase SNDRV_CTL_IOCTL_TLV_COMMAND:\n\t\treturn snd_ctl_tlv_ioctl(ctl, argp, -1);\n\tcase SNDRV_CTL_IOCTL_POWER:\n\t\treturn -ENOPROTOOPT;\n\tcase SNDRV_CTL_IOCTL_POWER_STATE:\n#ifdef CONFIG_PM\n\t\treturn put_user(card->power_state, ip) ? -EFAULT : 0;\n#else\n\t\treturn put_user(SNDRV_CTL_POWER_D0, ip) ? -EFAULT : 0;\n#endif\n\t}\n\tdown_read(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, &snd_control_ioctls, list) {\n\t\terr = p->fioctl(card, ctl, cmd, arg);\n\t\tif (err != -ENOIOCTLCMD) {\n\t\t\tup_read(&snd_ioctl_rwsem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tup_read(&snd_ioctl_rwsem);\n\tdev_dbg(card->dev, \"unknown ioctl = 0x%x\\n\", cmd);\n\treturn -ENOTTY;\n}\n\nstatic ssize_t snd_ctl_read(struct file *file, char __user *buffer,\n\t\t\t    size_t count, loff_t * offset)\n{\n\tstruct snd_ctl_file *ctl;\n\tint err = 0;\n\tssize_t result = 0;\n\n\tctl = file->private_data;\n\tif (snd_BUG_ON(!ctl || !ctl->card))\n\t\treturn -ENXIO;\n\tif (!ctl->subscribed)\n\t\treturn -EBADFD;\n\tif (count < sizeof(struct snd_ctl_event))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctl->read_lock);\n\twhile (count >= sizeof(struct snd_ctl_event)) {\n\t\tstruct snd_ctl_event ev;\n\t\tstruct snd_kctl_event *kev;\n\t\twhile (list_empty(&ctl->events)) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto __end_lock;\n\t\t\t}\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ctl->read_lock);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&ctl->change_sleep, &wait);\n\t\t\tif (ctl->card->shutdown)\n\t\t\t\treturn -ENODEV;\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tspin_lock_irq(&ctl->read_lock);\n\t\t}\n\t\tkev = snd_kctl_event(ctl->events.next);\n\t\tev.type = SNDRV_CTL_EVENT_ELEM;\n\t\tev.data.elem.mask = kev->mask;\n\t\tev.data.elem.id = kev->id;\n\t\tlist_del(&kev->list);\n\t\tspin_unlock_irq(&ctl->read_lock);\n\t\tkfree(kev);\n\t\tif (copy_to_user(buffer, &ev, sizeof(struct snd_ctl_event))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto __end;\n\t\t}\n\t\tspin_lock_irq(&ctl->read_lock);\n\t\tbuffer += sizeof(struct snd_ctl_event);\n\t\tcount -= sizeof(struct snd_ctl_event);\n\t\tresult += sizeof(struct snd_ctl_event);\n\t}\n      __end_lock:\n\tspin_unlock_irq(&ctl->read_lock);\n      __end:\n      \treturn result > 0 ? result : err;\n}\n\nstatic unsigned int snd_ctl_poll(struct file *file, poll_table * wait)\n{\n\tunsigned int mask;\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\tif (!ctl->subscribed)\n\t\treturn 0;\n\tpoll_wait(file, &ctl->change_sleep, wait);\n\n\tmask = 0;\n\tif (!list_empty(&ctl->events))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\treturn mask;\n}\n\n/*\n * register the device-specific control-ioctls.\n * called from each device manager like pcm.c, hwdep.c, etc.\n */\nstatic int _snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn, struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *pn;\n\n\tpn = kzalloc(sizeof(struct snd_kctl_ioctl), GFP_KERNEL);\n\tif (pn == NULL)\n\t\treturn -ENOMEM;\n\tpn->fioctl = fcn;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_add_tail(&pn->list, lists);\n\tup_write(&snd_ioctl_rwsem);\n\treturn 0;\n}\n\nint snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_register_ioctl);\n\n#ifdef CONFIG_COMPAT\nint snd_ctl_register_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_register_ioctl(fcn, &snd_control_compat_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_register_ioctl_compat);\n#endif\n\n/*\n * de-register the device-specific control-ioctls.\n */\nstatic int _snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn,\n\t\t\t\t     struct list_head *lists)\n{\n\tstruct snd_kctl_ioctl *p;\n\n\tif (snd_BUG_ON(!fcn))\n\t\treturn -EINVAL;\n\tdown_write(&snd_ioctl_rwsem);\n\tlist_for_each_entry(p, lists, list) {\n\t\tif (p->fioctl == fcn) {\n\t\t\tlist_del(&p->list);\n\t\t\tup_write(&snd_ioctl_rwsem);\n\t\t\tkfree(p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_write(&snd_ioctl_rwsem);\n\tsnd_BUG();\n\treturn -EINVAL;\n}\n\nint snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl);\n\n#ifdef CONFIG_COMPAT\nint snd_ctl_unregister_ioctl_compat(snd_kctl_ioctl_func_t fcn)\n{\n\treturn _snd_ctl_unregister_ioctl(fcn, &snd_control_compat_ioctls);\n}\n\nEXPORT_SYMBOL(snd_ctl_unregister_ioctl_compat);\n#endif\n\nstatic int snd_ctl_fasync(int fd, struct file * file, int on)\n{\n\tstruct snd_ctl_file *ctl;\n\n\tctl = file->private_data;\n\treturn fasync_helper(fd, file, on, &ctl->fasync);\n}\n\n/*\n * ioctl32 compat\n */\n#ifdef CONFIG_COMPAT\n#include \"control_compat.c\"\n#else\n#define snd_ctl_ioctl_compat\tNULL\n#endif\n\n/*\n *  INIT PART\n */\n\nstatic const struct file_operations snd_ctl_f_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tsnd_ctl_read,\n\t.open =\t\tsnd_ctl_open,\n\t.release =\tsnd_ctl_release,\n\t.llseek =\tno_llseek,\n\t.poll =\t\tsnd_ctl_poll,\n\t.unlocked_ioctl =\tsnd_ctl_ioctl,\n\t.compat_ioctl =\tsnd_ctl_ioctl_compat,\n\t.fasync =\tsnd_ctl_fasync,\n};\n\n/*\n * registration of the control device\n */\nstatic int snd_ctl_dev_register(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tint err, cardnum;\n\tchar name[16];\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\tsprintf(name, \"controlC%i\", cardnum);\n\tif ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1,\n\t\t\t\t       &snd_ctl_f_ops, card, name)) < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n/*\n * disconnection of the control device\n */\nstatic int snd_ctl_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_ctl_file *ctl;\n\tint err, cardnum;\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\n\tread_lock(&card->ctl_files_rwlock);\n\tlist_for_each_entry(ctl, &card->ctl_files, list) {\n\t\twake_up(&ctl->change_sleep);\n\t\tkill_fasync(&ctl->fasync, SIGIO, POLL_ERR);\n\t}\n\tread_unlock(&card->ctl_files_rwlock);\n\n\tif ((err = snd_unregister_device(SNDRV_DEVICE_TYPE_CONTROL,\n\t\t\t\t\t card, -1)) < 0)\n\t\treturn err;\n\treturn 0;\n}\n\n/*\n * free all controls\n */\nstatic int snd_ctl_dev_free(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_kcontrol *control;\n\n\tdown_write(&card->controls_rwsem);\n\twhile (!list_empty(&card->controls)) {\n\t\tcontrol = snd_kcontrol(card->controls.next);\n\t\tsnd_ctl_remove(card, control);\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}\n\n/*\n * create control core:\n * called from init.c\n */\nint snd_ctl_create(struct snd_card *card)\n{\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_ctl_dev_free,\n\t\t.dev_register =\tsnd_ctl_dev_register,\n\t\t.dev_disconnect = snd_ctl_dev_disconnect,\n\t};\n\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\treturn snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);\n}\n\n/*\n * Frequently used control callbacks/helpers\n */\nint snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_boolean_mono_info);\n\nint snd_ctl_boolean_stereo_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(snd_ctl_boolean_stereo_info);\n\n/**\n * snd_ctl_enum_info - fills the info structure for an enumerated control\n * @info: the structure to be filled\n * @channels: the number of the control's channels; often one\n * @items: the number of control values; also the size of @names\n * @names: an array containing the names of all control values\n *\n * Sets all required fields in @info to their appropriate values.\n * If the control's accessibility is not the default (readable and writable),\n * the caller has to fill @info->access.\n *\n * Return: Zero.\n */\nint snd_ctl_enum_info(struct snd_ctl_elem_info *info, unsigned int channels,\n\t\t      unsigned int items, const char *const names[])\n{\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tinfo->count = channels;\n\tinfo->value.enumerated.items = items;\n\tif (info->value.enumerated.item >= items)\n\t\tinfo->value.enumerated.item = items - 1;\n\tstrlcpy(info->value.enumerated.name,\n\t\tnames[info->value.enumerated.item],\n\t\tsizeof(info->value.enumerated.name));\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_ctl_enum_info);\n"], "filenames": ["sound/core/control.c"], "buggy_code_start_loc": [1157], "buggy_code_end_loc": [1182], "fixing_code_start_loc": [1156], "fixing_code_end_loc": [1175], "type": "CWE-416", "message": "The snd_ctl_elem_add function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not check authorization for SNDRV_CTL_IOCTL_ELEM_REPLACE commands, which allows local users to remove kernel controls and cause a denial of service (use-after-free and system crash) by leveraging /dev/snd/controlCX access for an ioctl call.", "other": {"cve": {"id": "CVE-2014-4654", "sourceIdentifier": "cve@mitre.org", "published": "2014-07-03T04:22:15.793", "lastModified": "2020-08-14T18:01:45.453", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The snd_ctl_elem_add function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not check authorization for SNDRV_CTL_IOCTL_ELEM_REPLACE commands, which allows local users to remove kernel controls and cause a denial of service (use-after-free and system crash) by leveraging /dev/snd/controlCX access for an ioctl call."}, {"lang": "es", "value": "La funci\u00f3n snd_ctl_elem_add en sound/core/control.c de la implementaci\u00f3n del control ALSA en el kernel de Linux anterior a 3.15.2 no comprueba la autorizaci\u00f3n para los comandos SNDRV_CTL_IOCTL_ELEM_REPLACE, lo que permite a usuarios locales eliminar los controles del kernel y provocar una denegaci\u00f3n de servicio (usar despu\u00e9s de liberar y una ca\u00edda del sistema) al aprovechar el acceso a /dev/snd/controlICS para una llamada ioctl."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.15.2", "matchCriteriaId": "588069C4-9D69-48F6-913F-2FEB3E643870"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:10:sp4:*:*:ltss:*:*:*", "matchCriteriaId": "35BBD83D-BDC7-4678-BE94-639F59281139"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=82262a46627bebb0febcc26664746c25cef08563", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1083.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/60545", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.15.2", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/06/26/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/68162", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2334-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2335-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1113445", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563"}}