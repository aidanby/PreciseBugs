{"buggy_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"path\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/dustin/go-humanize\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n\txnet \"github.com/minio/pkg/net\"\n\n\t\"github.com/minio/minio/internal/amztime\"\n\t\"github.com/minio/minio/internal/config/dns\"\n\t\"github.com/minio/minio/internal/crypto\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/http/stats\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/minio/internal/mcontext\"\n)\n\nconst (\n\t// Maximum allowed form data field values. 64MiB is a guessed practical value\n\t// which is more than enough to accommodate any form data fields and headers.\n\trequestFormDataSize = 64 * humanize.MiByte\n\n\t// For any HTTP request, request body should be not more than 16GiB + requestFormDataSize\n\t// where, 16GiB is the maximum allowed object size for object upload.\n\trequestMaxBodySize = globalMaxObjectSize + requestFormDataSize\n\n\t// Maximum size for http headers - See: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html\n\tmaxHeaderSize = 8 * 1024\n\n\t// Maximum size for user-defined metadata - See: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html\n\tmaxUserDataSize = 2 * 1024\n\n\t// maxBuckets upto 500000 for any MinIO deployment.\n\tmaxBuckets = 500 * 1000\n)\n\n// ReservedMetadataPrefix is the prefix of a metadata key which\n// is reserved and for internal use only.\nconst (\n\tReservedMetadataPrefix      = \"X-Minio-Internal-\"\n\tReservedMetadataPrefixLower = \"x-minio-internal-\"\n)\n\n// containsReservedMetadata returns true if the http.Header contains\n// keys which are treated as metadata but are reserved for internal use\n// and must not set by clients\nfunc containsReservedMetadata(header http.Header) bool {\n\tfor key := range header {\n\t\tif strings.HasPrefix(strings.ToLower(key), ReservedMetadataPrefixLower) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isHTTPHeaderSizeTooLarge returns true if the provided\n// header is larger than 8 KB or the user-defined metadata\n// is larger than 2 KB.\nfunc isHTTPHeaderSizeTooLarge(header http.Header) bool {\n\tvar size, usersize int\n\tfor key := range header {\n\t\tlength := len(key) + len(header.Get(key))\n\t\tsize += length\n\t\tfor _, prefix := range userMetadataKeyPrefixes {\n\t\t\tif strings.HasPrefix(strings.ToLower(key), prefix) {\n\t\t\t\tusersize += length\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif usersize > maxUserDataSize || size > maxHeaderSize {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Limits body and header to specific allowed maximum limits as per S3/MinIO API requirements.\nfunc setRequestLimitHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttc, ok := r.Context().Value(mcontext.ContextTraceKey).(*mcontext.TraceCtxt)\n\n\t\t// Reject unsupported reserved metadata first before validation.\n\t\tif containsReservedMetadata(r.Header) {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrUnsupportedMetadata), r.URL)\n\t\t\treturn\n\t\t}\n\n\t\tif isHTTPHeaderSizeTooLarge(r.Header) {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrMetadataTooLarge), r.URL)\n\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsHeader, 1)\n\t\t\treturn\n\t\t}\n\t\t// Restricting read data to a given maximum length\n\t\tr.Body = http.MaxBytesReader(w, r.Body, requestMaxBodySize)\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// Reserved bucket.\nconst (\n\tminioReservedBucket              = \"minio\"\n\tminioReservedBucketPath          = SlashSeparator + minioReservedBucket\n\tminioReservedBucketPathWithSlash = SlashSeparator + minioReservedBucket + SlashSeparator\n\n\tloginPathPrefix = SlashSeparator + \"login\"\n)\n\nfunc guessIsBrowserReq(r *http.Request) bool {\n\taType := getRequestAuthType(r)\n\treturn strings.Contains(r.Header.Get(\"User-Agent\"), \"Mozilla\") &&\n\t\tglobalBrowserEnabled && aType == authTypeAnonymous\n}\n\nfunc setBrowserRedirectHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tread := r.Method == http.MethodGet || r.Method == http.MethodHead\n\t\t// Re-direction is handled specifically for browser requests.\n\t\tif guessIsBrowserReq(r) && read {\n\t\t\t// Fetch the redirect location if any.\n\t\t\tif u := getRedirectLocation(r); u != nil {\n\t\t\t\t// Employ a temporary re-direct.\n\t\t\t\thttp.Redirect(w, r, u.String(), http.StatusTemporaryRedirect)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\nvar redirectPrefixes = map[string]struct{}{\n\t\"favicon-16x16.png\": {},\n\t\"favicon-32x32.png\": {},\n\t\"favicon-96x96.png\": {},\n\t\"index.html\":        {},\n\tminioReservedBucket: {},\n}\n\n// Fetch redirect location if urlPath satisfies certain\n// criteria. Some special names are considered to be\n// redirectable, this is purely internal function and\n// serves only limited purpose on redirect-handler for\n// browser requests.\nfunc getRedirectLocation(r *http.Request) *xnet.URL {\n\tresource, err := getResource(r.URL.Path, r.Host, globalDomainNames)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tbucket, _ := path2BucketObject(resource)\n\t_, redirect := redirectPrefixes[path.Clean(bucket)]\n\tif redirect || resource == slashSeparator {\n\t\tif globalBrowserRedirectURL != nil {\n\t\t\treturn globalBrowserRedirectURL\n\t\t}\n\t\txhost, err := xnet.ParseHost(r.Host)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn &xnet.URL{\n\t\t\tHost: net.JoinHostPort(xhost.Name, globalMinioConsolePort),\n\t\t\tScheme: func() string {\n\t\t\t\tscheme := \"http\"\n\t\t\t\tif r.TLS != nil {\n\t\t\t\t\tscheme = \"https\"\n\t\t\t\t}\n\t\t\t\treturn scheme\n\t\t\t}(),\n\t\t}\n\t}\n\treturn nil\n}\n\n// guessIsHealthCheckReq - returns true if incoming request looks\n// like healthcheck request\nfunc guessIsHealthCheckReq(req *http.Request) bool {\n\tif req == nil {\n\t\treturn false\n\t}\n\taType := getRequestAuthType(req)\n\treturn aType == authTypeAnonymous && (req.Method == http.MethodGet || req.Method == http.MethodHead) &&\n\t\t(req.URL.Path == healthCheckPathPrefix+healthCheckLivenessPath ||\n\t\t\treq.URL.Path == healthCheckPathPrefix+healthCheckReadinessPath ||\n\t\t\treq.URL.Path == healthCheckPathPrefix+healthCheckClusterPath ||\n\t\t\treq.URL.Path == healthCheckPathPrefix+healthCheckClusterReadPath)\n}\n\n// guessIsMetricsReq - returns true if incoming request looks\n// like metrics request\nfunc guessIsMetricsReq(req *http.Request) bool {\n\tif req == nil {\n\t\treturn false\n\t}\n\taType := getRequestAuthType(req)\n\treturn (aType == authTypeAnonymous || aType == authTypeJWT) &&\n\t\treq.URL.Path == minioReservedBucketPath+prometheusMetricsPathLegacy ||\n\t\treq.URL.Path == minioReservedBucketPath+prometheusMetricsV2ClusterPath ||\n\t\treq.URL.Path == minioReservedBucketPath+prometheusMetricsV2NodePath\n}\n\n// guessIsRPCReq - returns true if the request is for an RPC endpoint.\nfunc guessIsRPCReq(req *http.Request) bool {\n\tif req == nil {\n\t\treturn false\n\t}\n\treturn req.Method == http.MethodPost &&\n\t\tstrings.HasPrefix(req.URL.Path, minioReservedBucketPath+SlashSeparator)\n}\n\n// Check to allow access to the reserved \"bucket\" `/minio` for Admin\n// API requests.\nfunc isAdminReq(r *http.Request) bool {\n\treturn strings.HasPrefix(r.URL.Path, adminPathPrefix)\n}\n\n// Check to allow access to the reserved \"bucket\" `/minio` for KMS\n// API requests.\nfunc isKMSReq(r *http.Request) bool {\n\treturn strings.HasPrefix(r.URL.Path, kmsPathPrefix)\n}\n\n// Supported Amz date headers.\nvar amzDateHeaders = []string{\n\t// Do not chane this order, x-amz-date value should be\n\t// validated first.\n\t\"x-amz-date\",\n\t\"date\",\n}\n\n// parseAmzDateHeader - parses supported amz date headers, in\n// supported amz date formats.\nfunc parseAmzDateHeader(req *http.Request) (time.Time, APIErrorCode) {\n\tfor _, amzDateHeader := range amzDateHeaders {\n\t\tamzDateStr := req.Header.Get(amzDateHeader)\n\t\tif amzDateStr != \"\" {\n\t\t\tt, err := amztime.Parse(amzDateStr)\n\t\t\tif err != nil {\n\t\t\t\treturn time.Time{}, ErrMalformedDate\n\t\t\t}\n\t\t\treturn t, ErrNone\n\t\t}\n\t}\n\t// Date header missing.\n\treturn time.Time{}, ErrMissingDateHeader\n}\n\n// splitStr splits a string into n parts, empty strings are added\n// if we are not able to reach n elements\nfunc splitStr(path, sep string, n int) []string {\n\tsplits := strings.SplitN(path, sep, n)\n\t// Add empty strings if we found elements less than nr\n\tfor i := n - len(splits); i > 0; i-- {\n\t\tsplits = append(splits, \"\")\n\t}\n\treturn splits\n}\n\nfunc url2Bucket(p string) (bucket string) {\n\ttokens := splitStr(p, SlashSeparator, 3)\n\treturn tokens[1]\n}\n\n// setHttpStatsHandler sets a http Stats handler to gather HTTP statistics\nfunc setHTTPStatsHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Meters s3 connection stats.\n\t\tmeteredRequest := &stats.IncomingTrafficMeter{ReadCloser: r.Body}\n\t\tmeteredResponse := &stats.OutgoingTrafficMeter{ResponseWriter: w}\n\n\t\t// Execute the request\n\t\tr.Body = meteredRequest\n\t\th.ServeHTTP(meteredResponse, r)\n\n\t\tif strings.HasPrefix(r.URL.Path, storageRESTPrefix) ||\n\t\t\tstrings.HasPrefix(r.URL.Path, peerRESTPrefix) ||\n\t\t\tstrings.HasPrefix(r.URL.Path, peerS3Prefix) ||\n\t\t\tstrings.HasPrefix(r.URL.Path, lockRESTPrefix) {\n\t\t\tglobalConnStats.incInputBytes(meteredRequest.BytesRead())\n\t\t\tglobalConnStats.incOutputBytes(meteredResponse.BytesWritten())\n\t\t\treturn\n\t\t}\n\t\tif strings.HasPrefix(r.URL.Path, minioReservedBucketPath) {\n\t\t\tglobalConnStats.incAdminInputBytes(meteredRequest.BytesRead())\n\t\t\tglobalConnStats.incAdminOutputBytes(meteredResponse.BytesWritten())\n\t\t\treturn\n\t\t}\n\n\t\tglobalConnStats.incS3InputBytes(meteredRequest.BytesRead())\n\t\tglobalConnStats.incS3OutputBytes(meteredResponse.BytesWritten())\n\n\t\tif r.URL != nil {\n\t\t\tbucket := url2Bucket(r.URL.Path)\n\t\t\tif bucket != \"\" && bucket != minioReservedBucket {\n\t\t\t\tglobalBucketConnStats.incS3InputBytes(bucket, meteredRequest.BytesRead())\n\t\t\t\tglobalBucketConnStats.incS3OutputBytes(bucket, meteredResponse.BytesWritten())\n\t\t\t}\n\t\t}\n\t})\n}\n\n// Bad path components to be rejected by the path validity handler.\nconst (\n\tdotdotComponent = \"..\"\n\tdotComponent    = \".\"\n)\n\nfunc hasBadHost(host string) error {\n\tif globalIsCICD && strings.TrimSpace(host) == \"\" {\n\t\t// under CI/CD test setups ignore empty hosts as invalid hosts\n\t\treturn nil\n\t}\n\t_, err := xnet.ParseHost(host)\n\treturn err\n}\n\n// Check if the incoming path has bad path components,\n// such as \"..\" and \".\"\nfunc hasBadPathComponent(path string) bool {\n\tpath = strings.TrimSpace(path)\n\tfor _, p := range strings.Split(path, SlashSeparator) {\n\t\tswitch strings.TrimSpace(p) {\n\t\tcase dotdotComponent:\n\t\t\treturn true\n\t\tcase dotComponent:\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if client is sending a malicious request.\nfunc hasMultipleAuth(r *http.Request) bool {\n\tauthTypeCount := 0\n\tfor _, hasValidAuth := range []func(*http.Request) bool{\n\t\tisRequestSignatureV2, isRequestPresignedSignatureV2,\n\t\tisRequestSignatureV4, isRequestPresignedSignatureV4,\n\t\tisRequestJWT, isRequestPostPolicySignatureV4,\n\t} {\n\t\tif hasValidAuth(r) {\n\t\t\tauthTypeCount++\n\t\t}\n\t}\n\treturn authTypeCount > 1\n}\n\n// requestValidityHandler validates all the incoming paths for\n// any malicious requests.\nfunc setRequestValidityHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttc, ok := r.Context().Value(mcontext.ContextTraceKey).(*mcontext.TraceCtxt)\n\n\t\tif err := hasBadHost(r.Host); err != nil {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\tinvalidReq := errorCodes.ToAPIErr(ErrInvalidRequest)\n\t\t\tinvalidReq.Description = fmt.Sprintf(\"%s (%s)\", invalidReq.Description, err)\n\t\t\twriteErrorResponse(r.Context(), w, invalidReq, r.URL)\n\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsInvalid, 1)\n\t\t\treturn\n\t\t}\n\n\t\t// Check for bad components in URL path.\n\t\tif hasBadPathComponent(r.URL.Path) {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInvalidResourceName), r.URL)\n\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsInvalid, 1)\n\t\t\treturn\n\t\t}\n\t\t// Check for bad components in URL query values.\n\t\tfor _, vv := range r.Form {\n\t\t\tfor _, v := range vv {\n\t\t\t\tif hasBadPathComponent(v) {\n\t\t\t\t\tif ok {\n\t\t\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t\t}\n\n\t\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInvalidResourceName), r.URL)\n\t\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsInvalid, 1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif hasMultipleAuth(r) {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\tinvalidReq := errorCodes.ToAPIErr(ErrInvalidRequest)\n\t\t\tinvalidReq.Description = fmt.Sprintf(\"%s (request has multiple authentication types, please use one)\", invalidReq.Description)\n\t\t\twriteErrorResponse(r.Context(), w, invalidReq, r.URL)\n\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsInvalid, 1)\n\t\t\treturn\n\t\t}\n\t\t// For all other requests reject access to reserved buckets\n\t\tbucketName, _ := request2BucketObjectName(r)\n\t\tif isMinioReservedBucket(bucketName) || isMinioMetaBucket(bucketName) {\n\t\t\tif !guessIsRPCReq(r) && !guessIsBrowserReq(r) && !guessIsHealthCheckReq(r) && !guessIsMetricsReq(r) && !isAdminReq(r) && !isKMSReq(r) {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrAllAccessDisabled), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// Deny SSE-C requests if not made over TLS\n\t\tif !globalIsTLS && (crypto.SSEC.IsRequested(r.Header) || crypto.SSECopy.IsRequested(r.Header)) {\n\t\t\tif r.Method == http.MethodHead {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = false\n\t\t\t\t}\n\n\t\t\t\twriteErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(ErrInsecureSSECustomerRequest))\n\t\t\t} else {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInsecureSSECustomerRequest), r.URL)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// setBucketForwardingHandler middleware forwards the path style requests\n// on a bucket to the right bucket location, bucket to IP configuration\n// is obtained from centralized etcd configuration service.\nfunc setBucketForwardingHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif globalDNSConfig == nil || !globalBucketFederation ||\n\t\t\tguessIsHealthCheckReq(r) || guessIsMetricsReq(r) ||\n\t\t\tguessIsRPCReq(r) || guessIsLoginSTSReq(r) || isAdminReq(r) {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tbucket, object := request2BucketObjectName(r)\n\n\t\t// Requests in federated setups for STS type calls which are\n\t\t// performed at '/' resource should be routed by the muxer,\n\t\t// the assumption is simply such that requests without a bucket\n\t\t// in a federated setup cannot be proxied, so serve them at\n\t\t// current server.\n\t\tif bucket == \"\" {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\t// MakeBucket requests should be handled at current endpoint\n\t\tif r.Method == http.MethodPut && bucket != \"\" && object == \"\" && r.URL.RawQuery == \"\" {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\t// CopyObject requests should be handled at current endpoint as path style\n\t\t// requests have target bucket and object in URI and source details are in\n\t\t// header fields\n\t\tif r.Method == http.MethodPut && r.Header.Get(xhttp.AmzCopySource) != \"\" {\n\t\t\tbucket, object = path2BucketObject(r.Header.Get(xhttp.AmzCopySource))\n\t\t\tif bucket == \"\" || object == \"\" {\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tsr, err := globalDNSConfig.Get(bucket)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrNoSuchBucket), r.URL)\n\t\t\t} else {\n\t\t\t\twriteErrorResponse(r.Context(), w, toAPIError(r.Context(), err), r.URL)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif globalDomainIPs.Intersection(set.CreateStringSet(getHostsSlice(sr)...)).IsEmpty() {\n\t\t\tr.URL.Scheme = \"http\"\n\t\t\tif globalIsTLS {\n\t\t\t\tr.URL.Scheme = \"https\"\n\t\t\t}\n\t\t\tr.URL.Host = getHostFromSrv(sr)\n\t\t\t// Make sure we remove any existing headers before\n\t\t\t// proxying the request to another node.\n\t\t\tfor k := range w.Header() {\n\t\t\t\tw.Header().Del(k)\n\t\t\t}\n\t\t\tglobalForwarder.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// addCustomHeaders adds various HTTP(S) response headers.\n// Security Headers enable various security protections behaviors in the client's browser.\nfunc addCustomHeaders(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\theader := w.Header()\n\t\theader.Set(\"X-XSS-Protection\", \"1; mode=block\")                                // Prevents against XSS attacks\n\t\theader.Set(\"Content-Security-Policy\", \"block-all-mixed-content\")               // prevent mixed (HTTP / HTTPS content)\n\t\theader.Set(\"X-Content-Type-Options\", \"nosniff\")                                // Prevent mime-sniff\n\t\theader.Set(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\") // HSTS mitigates variants of MITM attacks\n\n\t\t// Previously, this value was set right before a response was sent to\n\t\t// the client. So, logger and Error response XML were not using this\n\t\t// value. This is set here so that this header can be logged as\n\t\t// part of the log entry, Error response XML and auditing.\n\t\t// Set custom headers such as x-amz-request-id for each request.\n\t\tw.Header().Set(xhttp.AmzRequestID, mustGetRequestID(UTCNow()))\n\t\tif globalLocalNodeName != \"\" {\n\t\t\tw.Header().Set(xhttp.AmzRequestHostID, globalLocalNodeNameHex)\n\t\t}\n\t\th.ServeHTTP(xhttp.NewResponseRecorder(w), r)\n\t})\n}\n\n// criticalErrorHandler handles panics and fatal errors by\n// `panic(logger.ErrCritical)` as done by `logger.CriticalIf`.\n//\n// It should be always the first / highest HTTP handler.\nfunc setCriticalErrorHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tif rec := recover(); rec == logger.ErrCritical { // handle\n\t\t\t\tstack := debug.Stack()\n\t\t\t\tlogger.Error(\"critical: \\\"%s %s\\\": %v\\n%s\", r.Method, r.URL, rec, string(stack))\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInternalError), r.URL)\n\t\t\t\treturn\n\t\t\t} else if rec != nil {\n\t\t\t\tstack := debug.Stack()\n\t\t\t\tlogger.Error(\"panic: \\\"%s %s\\\": %v\\n%s\", r.Method, r.URL, rec, string(stack))\n\t\t\t\t// Try to write an error response, upstream may not have written header.\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInternalError), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// setUploadForwardingHandler middleware forwards multiparts requests\n// in a site replication setup to peer that initiated the upload\nfunc setUploadForwardingHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !globalSiteReplicationSys.isEnabled() ||\n\t\t\tguessIsHealthCheckReq(r) || guessIsMetricsReq(r) ||\n\t\t\tguessIsRPCReq(r) || guessIsLoginSTSReq(r) || isAdminReq(r) {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\tbucket, object := request2BucketObjectName(r)\n\t\tuploadID := r.Form.Get(xhttp.UploadID)\n\n\t\tif bucket != \"\" && object != \"\" && uploadID != \"\" {\n\t\t\tdeplID, err := getDeplIDFromUpload(uploadID)\n\t\t\tif err != nil {\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tremote, self := globalSiteReplicationSys.getPeerForUpload(deplID)\n\t\t\tif self {\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// forward request to peer handling this upload\n\t\t\tif globalBucketTargetSys.isOffline(remote.EndpointURL) {\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrReplicationRemoteConnectionError), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tr.URL.Scheme = remote.EndpointURL.Scheme\n\t\t\tr.URL.Host = remote.EndpointURL.Host\n\t\t\t// Make sure we remove any existing headers before\n\t\t\t// proxying the request to another node.\n\t\t\tfor k := range w.Header() {\n\t\t\t\tw.Header().Del(k)\n\t\t\t}\n\t\t\tglobalForwarder.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n"], "fixing_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/dustin/go-humanize\"\n\t\"github.com/minio/minio-go/v7/pkg/set\"\n\txnet \"github.com/minio/pkg/net\"\n\n\t\"github.com/minio/minio/internal/amztime\"\n\t\"github.com/minio/minio/internal/config/dns\"\n\t\"github.com/minio/minio/internal/crypto\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/http/stats\"\n\t\"github.com/minio/minio/internal/logger\"\n\t\"github.com/minio/minio/internal/mcontext\"\n)\n\nconst (\n\t// Maximum allowed form data field values. 64MiB is a guessed practical value\n\t// which is more than enough to accommodate any form data fields and headers.\n\trequestFormDataSize = 64 * humanize.MiByte\n\n\t// For any HTTP request, request body should be not more than 16GiB + requestFormDataSize\n\t// where, 16GiB is the maximum allowed object size for object upload.\n\trequestMaxBodySize = globalMaxObjectSize + requestFormDataSize\n\n\t// Maximum size for http headers - See: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html\n\tmaxHeaderSize = 8 * 1024\n\n\t// Maximum size for user-defined metadata - See: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html\n\tmaxUserDataSize = 2 * 1024\n\n\t// maxBuckets upto 500000 for any MinIO deployment.\n\tmaxBuckets = 500 * 1000\n)\n\n// ReservedMetadataPrefix is the prefix of a metadata key which\n// is reserved and for internal use only.\nconst (\n\tReservedMetadataPrefix      = \"X-Minio-Internal-\"\n\tReservedMetadataPrefixLower = \"x-minio-internal-\"\n)\n\n// containsReservedMetadata returns true if the http.Header contains\n// keys which are treated as metadata but are reserved for internal use\n// and must not set by clients\nfunc containsReservedMetadata(header http.Header) bool {\n\tfor key := range header {\n\t\tif strings.HasPrefix(strings.ToLower(key), ReservedMetadataPrefixLower) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isHTTPHeaderSizeTooLarge returns true if the provided\n// header is larger than 8 KB or the user-defined metadata\n// is larger than 2 KB.\nfunc isHTTPHeaderSizeTooLarge(header http.Header) bool {\n\tvar size, usersize int\n\tfor key := range header {\n\t\tlength := len(key) + len(header.Get(key))\n\t\tsize += length\n\t\tfor _, prefix := range userMetadataKeyPrefixes {\n\t\t\tif strings.HasPrefix(strings.ToLower(key), prefix) {\n\t\t\t\tusersize += length\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif usersize > maxUserDataSize || size > maxHeaderSize {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Limits body and header to specific allowed maximum limits as per S3/MinIO API requirements.\nfunc setRequestLimitHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttc, ok := r.Context().Value(mcontext.ContextTraceKey).(*mcontext.TraceCtxt)\n\n\t\t// Reject unsupported reserved metadata first before validation.\n\t\tif containsReservedMetadata(r.Header) {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrUnsupportedMetadata), r.URL)\n\t\t\treturn\n\t\t}\n\n\t\tif isHTTPHeaderSizeTooLarge(r.Header) {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrMetadataTooLarge), r.URL)\n\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsHeader, 1)\n\t\t\treturn\n\t\t}\n\t\t// Restricting read data to a given maximum length\n\t\tr.Body = http.MaxBytesReader(w, r.Body, requestMaxBodySize)\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// Reserved bucket.\nconst (\n\tminioReservedBucket              = \"minio\"\n\tminioReservedBucketPath          = SlashSeparator + minioReservedBucket\n\tminioReservedBucketPathWithSlash = SlashSeparator + minioReservedBucket + SlashSeparator\n\n\tloginPathPrefix = SlashSeparator + \"login\"\n)\n\nfunc guessIsBrowserReq(r *http.Request) bool {\n\taType := getRequestAuthType(r)\n\treturn strings.Contains(r.Header.Get(\"User-Agent\"), \"Mozilla\") &&\n\t\tglobalBrowserEnabled && aType == authTypeAnonymous\n}\n\nfunc setBrowserRedirectHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tread := r.Method == http.MethodGet || r.Method == http.MethodHead\n\t\t// Re-direction is handled specifically for browser requests.\n\t\tif guessIsBrowserReq(r) && read {\n\t\t\t// Fetch the redirect location if any.\n\t\t\tif u := getRedirectLocation(r); u != nil {\n\t\t\t\t// Employ a temporary re-direct.\n\t\t\t\thttp.Redirect(w, r, u.String(), http.StatusTemporaryRedirect)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\nvar redirectPrefixes = map[string]struct{}{\n\t\"favicon-16x16.png\": {},\n\t\"favicon-32x32.png\": {},\n\t\"favicon-96x96.png\": {},\n\t\"index.html\":        {},\n\tminioReservedBucket: {},\n}\n\n// Fetch redirect location if urlPath satisfies certain\n// criteria. Some special names are considered to be\n// redirectable, this is purely internal function and\n// serves only limited purpose on redirect-handler for\n// browser requests.\nfunc getRedirectLocation(r *http.Request) *xnet.URL {\n\tresource, err := getResource(r.URL.Path, r.Host, globalDomainNames)\n\tif err != nil {\n\t\treturn nil\n\t}\n\tbucket, _ := path2BucketObject(resource)\n\t_, redirect := redirectPrefixes[path.Clean(bucket)]\n\tif redirect || resource == slashSeparator {\n\t\tif globalBrowserRedirectURL != nil {\n\t\t\treturn globalBrowserRedirectURL\n\t\t}\n\t\txhost, err := xnet.ParseHost(r.Host)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn &xnet.URL{\n\t\t\tHost: net.JoinHostPort(xhost.Name, globalMinioConsolePort),\n\t\t\tScheme: func() string {\n\t\t\t\tscheme := \"http\"\n\t\t\t\tif r.TLS != nil {\n\t\t\t\t\tscheme = \"https\"\n\t\t\t\t}\n\t\t\t\treturn scheme\n\t\t\t}(),\n\t\t}\n\t}\n\treturn nil\n}\n\n// guessIsHealthCheckReq - returns true if incoming request looks\n// like healthcheck request\nfunc guessIsHealthCheckReq(req *http.Request) bool {\n\tif req == nil {\n\t\treturn false\n\t}\n\taType := getRequestAuthType(req)\n\treturn aType == authTypeAnonymous && (req.Method == http.MethodGet || req.Method == http.MethodHead) &&\n\t\t(req.URL.Path == healthCheckPathPrefix+healthCheckLivenessPath ||\n\t\t\treq.URL.Path == healthCheckPathPrefix+healthCheckReadinessPath ||\n\t\t\treq.URL.Path == healthCheckPathPrefix+healthCheckClusterPath ||\n\t\t\treq.URL.Path == healthCheckPathPrefix+healthCheckClusterReadPath)\n}\n\n// guessIsMetricsReq - returns true if incoming request looks\n// like metrics request\nfunc guessIsMetricsReq(req *http.Request) bool {\n\tif req == nil {\n\t\treturn false\n\t}\n\taType := getRequestAuthType(req)\n\treturn (aType == authTypeAnonymous || aType == authTypeJWT) &&\n\t\treq.URL.Path == minioReservedBucketPath+prometheusMetricsPathLegacy ||\n\t\treq.URL.Path == minioReservedBucketPath+prometheusMetricsV2ClusterPath ||\n\t\treq.URL.Path == minioReservedBucketPath+prometheusMetricsV2NodePath\n}\n\n// guessIsRPCReq - returns true if the request is for an RPC endpoint.\nfunc guessIsRPCReq(req *http.Request) bool {\n\tif req == nil {\n\t\treturn false\n\t}\n\treturn req.Method == http.MethodPost &&\n\t\tstrings.HasPrefix(req.URL.Path, minioReservedBucketPath+SlashSeparator)\n}\n\n// Check to allow access to the reserved \"bucket\" `/minio` for Admin\n// API requests.\nfunc isAdminReq(r *http.Request) bool {\n\treturn strings.HasPrefix(r.URL.Path, adminPathPrefix)\n}\n\n// Check to allow access to the reserved \"bucket\" `/minio` for KMS\n// API requests.\nfunc isKMSReq(r *http.Request) bool {\n\treturn strings.HasPrefix(r.URL.Path, kmsPathPrefix)\n}\n\n// Supported Amz date headers.\nvar amzDateHeaders = []string{\n\t// Do not chane this order, x-amz-date value should be\n\t// validated first.\n\t\"x-amz-date\",\n\t\"date\",\n}\n\n// parseAmzDateHeader - parses supported amz date headers, in\n// supported amz date formats.\nfunc parseAmzDateHeader(req *http.Request) (time.Time, APIErrorCode) {\n\tfor _, amzDateHeader := range amzDateHeaders {\n\t\tamzDateStr := req.Header.Get(amzDateHeader)\n\t\tif amzDateStr != \"\" {\n\t\t\tt, err := amztime.Parse(amzDateStr)\n\t\t\tif err != nil {\n\t\t\t\treturn time.Time{}, ErrMalformedDate\n\t\t\t}\n\t\t\treturn t, ErrNone\n\t\t}\n\t}\n\t// Date header missing.\n\treturn time.Time{}, ErrMissingDateHeader\n}\n\n// splitStr splits a string into n parts, empty strings are added\n// if we are not able to reach n elements\nfunc splitStr(path, sep string, n int) []string {\n\tsplits := strings.SplitN(path, sep, n)\n\t// Add empty strings if we found elements less than nr\n\tfor i := n - len(splits); i > 0; i-- {\n\t\tsplits = append(splits, \"\")\n\t}\n\treturn splits\n}\n\nfunc url2Bucket(p string) (bucket string) {\n\ttokens := splitStr(p, SlashSeparator, 3)\n\treturn tokens[1]\n}\n\n// setHttpStatsHandler sets a http Stats handler to gather HTTP statistics\nfunc setHTTPStatsHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t// Meters s3 connection stats.\n\t\tmeteredRequest := &stats.IncomingTrafficMeter{ReadCloser: r.Body}\n\t\tmeteredResponse := &stats.OutgoingTrafficMeter{ResponseWriter: w}\n\n\t\t// Execute the request\n\t\tr.Body = meteredRequest\n\t\th.ServeHTTP(meteredResponse, r)\n\n\t\tif strings.HasPrefix(r.URL.Path, storageRESTPrefix) ||\n\t\t\tstrings.HasPrefix(r.URL.Path, peerRESTPrefix) ||\n\t\t\tstrings.HasPrefix(r.URL.Path, peerS3Prefix) ||\n\t\t\tstrings.HasPrefix(r.URL.Path, lockRESTPrefix) {\n\t\t\tglobalConnStats.incInputBytes(meteredRequest.BytesRead())\n\t\t\tglobalConnStats.incOutputBytes(meteredResponse.BytesWritten())\n\t\t\treturn\n\t\t}\n\t\tif strings.HasPrefix(r.URL.Path, minioReservedBucketPath) {\n\t\t\tglobalConnStats.incAdminInputBytes(meteredRequest.BytesRead())\n\t\t\tglobalConnStats.incAdminOutputBytes(meteredResponse.BytesWritten())\n\t\t\treturn\n\t\t}\n\n\t\tglobalConnStats.incS3InputBytes(meteredRequest.BytesRead())\n\t\tglobalConnStats.incS3OutputBytes(meteredResponse.BytesWritten())\n\n\t\tif r.URL != nil {\n\t\t\tbucket := url2Bucket(r.URL.Path)\n\t\t\tif bucket != \"\" && bucket != minioReservedBucket {\n\t\t\t\tglobalBucketConnStats.incS3InputBytes(bucket, meteredRequest.BytesRead())\n\t\t\t\tglobalBucketConnStats.incS3OutputBytes(bucket, meteredResponse.BytesWritten())\n\t\t\t}\n\t\t}\n\t})\n}\n\n// Bad path components to be rejected by the path validity handler.\nconst (\n\tdotdotComponent = \"..\"\n\tdotComponent    = \".\"\n)\n\nfunc hasBadHost(host string) error {\n\tif globalIsCICD && strings.TrimSpace(host) == \"\" {\n\t\t// under CI/CD test setups ignore empty hosts as invalid hosts\n\t\treturn nil\n\t}\n\t_, err := xnet.ParseHost(host)\n\treturn err\n}\n\n// Check if the incoming path has bad path components,\n// such as \"..\" and \".\"\nfunc hasBadPathComponent(path string) bool {\n\tpath = filepath.ToSlash(strings.TrimSpace(path)) // For windows '\\' must be converted to '/'\n\tfor _, p := range strings.Split(path, SlashSeparator) {\n\t\tswitch strings.TrimSpace(p) {\n\t\tcase dotdotComponent:\n\t\t\treturn true\n\t\tcase dotComponent:\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Check if client is sending a malicious request.\nfunc hasMultipleAuth(r *http.Request) bool {\n\tauthTypeCount := 0\n\tfor _, hasValidAuth := range []func(*http.Request) bool{\n\t\tisRequestSignatureV2, isRequestPresignedSignatureV2,\n\t\tisRequestSignatureV4, isRequestPresignedSignatureV4,\n\t\tisRequestJWT, isRequestPostPolicySignatureV4,\n\t} {\n\t\tif hasValidAuth(r) {\n\t\t\tauthTypeCount++\n\t\t}\n\t}\n\treturn authTypeCount > 1\n}\n\n// requestValidityHandler validates all the incoming paths for\n// any malicious requests.\nfunc setRequestValidityHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttc, ok := r.Context().Value(mcontext.ContextTraceKey).(*mcontext.TraceCtxt)\n\n\t\tif err := hasBadHost(r.Host); err != nil {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\tinvalidReq := errorCodes.ToAPIErr(ErrInvalidRequest)\n\t\t\tinvalidReq.Description = fmt.Sprintf(\"%s (%s)\", invalidReq.Description, err)\n\t\t\twriteErrorResponse(r.Context(), w, invalidReq, r.URL)\n\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsInvalid, 1)\n\t\t\treturn\n\t\t}\n\n\t\t// Check for bad components in URL path.\n\t\tif hasBadPathComponent(r.URL.Path) {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInvalidResourceName), r.URL)\n\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsInvalid, 1)\n\t\t\treturn\n\t\t}\n\t\t// Check for bad components in URL query values.\n\t\tfor _, vv := range r.Form {\n\t\t\tfor _, v := range vv {\n\t\t\t\tif hasBadPathComponent(v) {\n\t\t\t\t\tif ok {\n\t\t\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t\t}\n\n\t\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInvalidResourceName), r.URL)\n\t\t\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsInvalid, 1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif hasMultipleAuth(r) {\n\t\t\tif ok {\n\t\t\t\ttc.FuncName = \"handler.Auth\"\n\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t}\n\n\t\t\tinvalidReq := errorCodes.ToAPIErr(ErrInvalidRequest)\n\t\t\tinvalidReq.Description = fmt.Sprintf(\"%s (request has multiple authentication types, please use one)\", invalidReq.Description)\n\t\t\twriteErrorResponse(r.Context(), w, invalidReq, r.URL)\n\t\t\tatomic.AddUint64(&globalHTTPStats.rejectedRequestsInvalid, 1)\n\t\t\treturn\n\t\t}\n\t\t// For all other requests reject access to reserved buckets\n\t\tbucketName, _ := request2BucketObjectName(r)\n\t\tif isMinioReservedBucket(bucketName) || isMinioMetaBucket(bucketName) {\n\t\t\tif !guessIsRPCReq(r) && !guessIsBrowserReq(r) && !guessIsHealthCheckReq(r) && !guessIsMetricsReq(r) && !isAdminReq(r) && !isKMSReq(r) {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrAllAccessDisabled), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t// Deny SSE-C requests if not made over TLS\n\t\tif !globalIsTLS && (crypto.SSEC.IsRequested(r.Header) || crypto.SSECopy.IsRequested(r.Header)) {\n\t\t\tif r.Method == http.MethodHead {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = false\n\t\t\t\t}\n\n\t\t\t\twriteErrorResponseHeadersOnly(w, errorCodes.ToAPIErr(ErrInsecureSSECustomerRequest))\n\t\t\t} else {\n\t\t\t\tif ok {\n\t\t\t\t\ttc.FuncName = \"handler.ValidRequest\"\n\t\t\t\t\ttc.ResponseRecorder.LogErrBody = true\n\t\t\t\t}\n\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInsecureSSECustomerRequest), r.URL)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// setBucketForwardingHandler middleware forwards the path style requests\n// on a bucket to the right bucket location, bucket to IP configuration\n// is obtained from centralized etcd configuration service.\nfunc setBucketForwardingHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif globalDNSConfig == nil || !globalBucketFederation ||\n\t\t\tguessIsHealthCheckReq(r) || guessIsMetricsReq(r) ||\n\t\t\tguessIsRPCReq(r) || guessIsLoginSTSReq(r) || isAdminReq(r) {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\tbucket, object := request2BucketObjectName(r)\n\n\t\t// Requests in federated setups for STS type calls which are\n\t\t// performed at '/' resource should be routed by the muxer,\n\t\t// the assumption is simply such that requests without a bucket\n\t\t// in a federated setup cannot be proxied, so serve them at\n\t\t// current server.\n\t\tif bucket == \"\" {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\t// MakeBucket requests should be handled at current endpoint\n\t\tif r.Method == http.MethodPut && bucket != \"\" && object == \"\" && r.URL.RawQuery == \"\" {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\n\t\t// CopyObject requests should be handled at current endpoint as path style\n\t\t// requests have target bucket and object in URI and source details are in\n\t\t// header fields\n\t\tif r.Method == http.MethodPut && r.Header.Get(xhttp.AmzCopySource) != \"\" {\n\t\t\tbucket, object = path2BucketObject(r.Header.Get(xhttp.AmzCopySource))\n\t\t\tif bucket == \"\" || object == \"\" {\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tsr, err := globalDNSConfig.Get(bucket)\n\t\tif err != nil {\n\t\t\tif err == dns.ErrNoEntriesFound {\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrNoSuchBucket), r.URL)\n\t\t\t} else {\n\t\t\t\twriteErrorResponse(r.Context(), w, toAPIError(r.Context(), err), r.URL)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif globalDomainIPs.Intersection(set.CreateStringSet(getHostsSlice(sr)...)).IsEmpty() {\n\t\t\tr.URL.Scheme = \"http\"\n\t\t\tif globalIsTLS {\n\t\t\t\tr.URL.Scheme = \"https\"\n\t\t\t}\n\t\t\tr.URL.Host = getHostFromSrv(sr)\n\t\t\t// Make sure we remove any existing headers before\n\t\t\t// proxying the request to another node.\n\t\t\tfor k := range w.Header() {\n\t\t\t\tw.Header().Del(k)\n\t\t\t}\n\t\t\tglobalForwarder.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// addCustomHeaders adds various HTTP(S) response headers.\n// Security Headers enable various security protections behaviors in the client's browser.\nfunc addCustomHeaders(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\theader := w.Header()\n\t\theader.Set(\"X-XSS-Protection\", \"1; mode=block\")                                // Prevents against XSS attacks\n\t\theader.Set(\"Content-Security-Policy\", \"block-all-mixed-content\")               // prevent mixed (HTTP / HTTPS content)\n\t\theader.Set(\"X-Content-Type-Options\", \"nosniff\")                                // Prevent mime-sniff\n\t\theader.Set(\"Strict-Transport-Security\", \"max-age=31536000; includeSubDomains\") // HSTS mitigates variants of MITM attacks\n\n\t\t// Previously, this value was set right before a response was sent to\n\t\t// the client. So, logger and Error response XML were not using this\n\t\t// value. This is set here so that this header can be logged as\n\t\t// part of the log entry, Error response XML and auditing.\n\t\t// Set custom headers such as x-amz-request-id for each request.\n\t\tw.Header().Set(xhttp.AmzRequestID, mustGetRequestID(UTCNow()))\n\t\tif globalLocalNodeName != \"\" {\n\t\t\tw.Header().Set(xhttp.AmzRequestHostID, globalLocalNodeNameHex)\n\t\t}\n\t\th.ServeHTTP(xhttp.NewResponseRecorder(w), r)\n\t})\n}\n\n// criticalErrorHandler handles panics and fatal errors by\n// `panic(logger.ErrCritical)` as done by `logger.CriticalIf`.\n//\n// It should be always the first / highest HTTP handler.\nfunc setCriticalErrorHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tif rec := recover(); rec == logger.ErrCritical { // handle\n\t\t\t\tstack := debug.Stack()\n\t\t\t\tlogger.Error(\"critical: \\\"%s %s\\\": %v\\n%s\", r.Method, r.URL, rec, string(stack))\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInternalError), r.URL)\n\t\t\t\treturn\n\t\t\t} else if rec != nil {\n\t\t\t\tstack := debug.Stack()\n\t\t\t\tlogger.Error(\"panic: \\\"%s %s\\\": %v\\n%s\", r.Method, r.URL, rec, string(stack))\n\t\t\t\t// Try to write an error response, upstream may not have written header.\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrInternalError), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\t\th.ServeHTTP(w, r)\n\t})\n}\n\n// setUploadForwardingHandler middleware forwards multiparts requests\n// in a site replication setup to peer that initiated the upload\nfunc setUploadForwardingHandler(h http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !globalSiteReplicationSys.isEnabled() ||\n\t\t\tguessIsHealthCheckReq(r) || guessIsMetricsReq(r) ||\n\t\t\tguessIsRPCReq(r) || guessIsLoginSTSReq(r) || isAdminReq(r) {\n\t\t\th.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\tbucket, object := request2BucketObjectName(r)\n\t\tuploadID := r.Form.Get(xhttp.UploadID)\n\n\t\tif bucket != \"\" && object != \"\" && uploadID != \"\" {\n\t\t\tdeplID, err := getDeplIDFromUpload(uploadID)\n\t\t\tif err != nil {\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tremote, self := globalSiteReplicationSys.getPeerForUpload(deplID)\n\t\t\tif self {\n\t\t\t\th.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// forward request to peer handling this upload\n\t\t\tif globalBucketTargetSys.isOffline(remote.EndpointURL) {\n\t\t\t\twriteErrorResponse(r.Context(), w, errorCodes.ToAPIErr(ErrReplicationRemoteConnectionError), r.URL)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tr.URL.Scheme = remote.EndpointURL.Scheme\n\t\t\tr.URL.Host = remote.EndpointURL.Host\n\t\t\t// Make sure we remove any existing headers before\n\t\t\t// proxying the request to another node.\n\t\t\tfor k := range w.Header() {\n\t\t\t\tw.Header().Del(k)\n\t\t\t}\n\t\t\tglobalForwarder.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t\th.ServeHTTP(w, r)\n\t})\n}\n"], "filenames": ["cmd/generic-handlers.go"], "buggy_code_start_loc": [24], "buggy_code_end_loc": [353], "fixing_code_start_loc": [25], "fixing_code_end_loc": [354], "type": "NVD-CWE-noinfo", "message": "Minio is a Multi-Cloud Object Storage framework. All users on Windows prior to version RELEASE.2023-03-20T20-16-18Z are impacted. MinIO fails to filter the `\\` character, which allows for arbitrary object placement across buckets. As a result, a user with low privileges, such as an access key, service account, or STS credential, which only has permission to `PutObject` in a specific bucket, can create an admin user. This issue is patched in RELEASE.2023-03-20T20-16-18Z. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-28433", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-22T21:15:18.340", "lastModified": "2023-03-28T16:25:36.637", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Minio is a Multi-Cloud Object Storage framework. All users on Windows prior to version RELEASE.2023-03-20T20-16-18Z are impacted. MinIO fails to filter the `\\` character, which allows for arbitrary object placement across buckets. As a result, a user with low privileges, such as an access key, service account, or STS credential, which only has permission to `PutObject` in a specific bucket, can create an admin user. This issue is patched in RELEASE.2023-03-20T20-16-18Z. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-03-20t20-16-18z", "matchCriteriaId": "63CBB19F-80FF-4D6B-ADF3-7BD9768861D0"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/8d6558b23649f613414c8527b58973fbdfa4d1b8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/minio/minio/commit/b3c54ec81e0a06392abfb3a1ffcdc80c6fbf6ebc", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/minio/minio/releases/tag/RELEASE.2023-03-20T20-16-18Z", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-w23q-4hw3-2pp6", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/8d6558b23649f613414c8527b58973fbdfa4d1b8"}}