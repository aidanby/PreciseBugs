{"buggy_code": ["require 'net/http'\nrequire 'openid'\nrequire 'openid/util'\n\nbegin\n  require 'net/https'\nrescue LoadError\n  OpenID::Util.log('WARNING: no SSL support found.  Will not be able ' +\n                   'to fetch HTTPS URLs!')\n  require 'net/http'\nend\n\nMAX_RESPONSE_KB = 1024\n\nmodule Net\n  class HTTP\n    def post_connection_check(hostname)\n      check_common_name = true\n      cert = @socket.io.peer_cert\n      cert.extensions.each { |ext|\n        next if ext.oid != \"subjectAltName\"\n        ext.value.split(/,\\s+/).each{ |general_name|\n          if /\\ADNS:(.*)/ =~ general_name\n            check_common_name = false\n            reg = Regexp.escape($1).gsub(/\\\\\\*/, \"[^.]+\")\n            return true if /\\A#{reg}\\z/i =~ hostname\n          elsif /\\AIP Address:(.*)/ =~ general_name\n            check_common_name = false\n            return true if $1 == hostname\n          end\n        }\n      }\n      if check_common_name\n        cert.subject.to_a.each{ |oid, value|\n          if oid == \"CN\"\n            reg = Regexp.escape(value).gsub(/\\\\\\*/, \"[^.]+\")\n            return true if /\\A#{reg}\\z/i =~ hostname\n          end\n        }\n      end\n      raise OpenSSL::SSL::SSLError, \"hostname does not match\"\n    end\n  end\nend\n\nmodule OpenID\n  # Our HTTPResponse class extends Net::HTTPResponse with an additional\n  # method, final_url.\n  class HTTPResponse\n    attr_accessor :final_url\n\n    attr_accessor :_response\n\n    def self._from_net_response(response, final_url, headers=nil)\n      me = self.new\n      me._response = response\n      me.final_url = final_url\n      return me\n    end\n\n    def method_missing(method, *args)\n      @_response.send(method, *args)\n    end\n\n    def body=(s)\n      @_response.instance_variable_set('@body', s)\n      # XXX Hack to work around ruby's HTTP library behavior.  @body\n      # is only returned if it has been read from the response\n      # object's socket, but since we're not using a socket in this\n      # case, we need to set the @read flag to true to avoid a bug in\n      # Net::HTTPResponse.stream_check when @socket is nil.\n      @_response.instance_variable_set('@read', true)\n    end\n  end\n\n  class FetchingError < OpenIDError\n  end\n\n  class HTTPRedirectLimitReached < FetchingError\n  end\n\n  class SSLFetchingError < FetchingError\n  end\n\n  @fetcher = nil\n\n  def self.fetch(url, body=nil, headers=nil,\n                 redirect_limit=StandardFetcher::REDIRECT_LIMIT)\n    return fetcher.fetch(url, body, headers, redirect_limit)\n  end\n\n  def self.fetcher\n    if @fetcher.nil?\n      @fetcher = StandardFetcher.new\n    end\n\n    return @fetcher\n  end\n\n  def self.fetcher=(fetcher)\n    @fetcher = fetcher\n  end\n\n  # Set the default fetcher to use the HTTP proxy defined in the environment\n  # variable 'http_proxy'.\n  def self.fetcher_use_env_http_proxy\n    proxy_string = ENV['http_proxy']\n    return unless proxy_string\n\n    proxy_uri = URI.parse(proxy_string)\n    @fetcher = StandardFetcher.new(proxy_uri.host, proxy_uri.port,\n                                   proxy_uri.user, proxy_uri.password)\n  end\n  \n  class StandardFetcher\n\n    USER_AGENT = \"ruby-openid/#{OpenID::VERSION} (#{RUBY_PLATFORM})\"\n\n    REDIRECT_LIMIT = 5\n    TIMEOUT = 60\n\n    attr_accessor :ca_file\n    attr_accessor :timeout\n\n    # I can fetch through a HTTP proxy; arguments are as for Net::HTTP::Proxy.\n    def initialize(proxy_addr=nil, proxy_port=nil,\n                   proxy_user=nil, proxy_pass=nil)\n      @ca_file = nil\n      @proxy = Net::HTTP::Proxy(proxy_addr, proxy_port, proxy_user, proxy_pass)\n      @timeout = TIMEOUT\n    end\n\n    def supports_ssl?(conn)\n      return conn.respond_to?(:use_ssl=)\n    end\n\n    def make_http(uri)\n      http = @proxy.new(uri.host, uri.port)\n      http.read_timeout = @timeout\n      http.open_timeout = @timeout\n      return http\n    end\n\n    def set_verified(conn, verify)\n      if verify\n        conn.verify_mode = OpenSSL::SSL::VERIFY_PEER\n      else\n        conn.verify_mode = OpenSSL::SSL::VERIFY_NONE\n      end\n    end\n\n    def make_connection(uri)\n      conn = make_http(uri)\n\n      if !conn.is_a?(Net::HTTP)\n        raise RuntimeError, sprintf(\"Expected Net::HTTP object from make_http; got %s\",\n                                    conn.class)\n      end\n\n      if uri.scheme == 'https'\n        if supports_ssl?(conn)\n\n          conn.use_ssl = true\n\n          if @ca_file\n            set_verified(conn, true)\n            conn.ca_file = @ca_file\n          else\n            Util.log(\"WARNING: making https request to #{uri} without verifying \" +\n                     \"server certificate; no CA path was specified.\")\n            set_verified(conn, false)\n          end\n        else\n          raise RuntimeError, \"SSL support not found; cannot fetch #{uri}\"\n        end\n      end\n\n      return conn\n    end\n\n    def fetch(url, body=nil, headers=nil, redirect_limit=REDIRECT_LIMIT)\n      unparsed_url = url.dup\n      url = URI::parse(url)\n      if url.nil?\n        raise FetchingError, \"Invalid URL: #{unparsed_url}\"\n      end\n\n      headers ||= {}\n      headers['User-agent'] ||= USER_AGENT\n\n      begin\n        conn = make_connection(url)\n        response = nil\n\n        response = conn.start {\n          # Check the certificate against the URL's hostname\n          if supports_ssl?(conn) and conn.use_ssl?\n            conn.post_connection_check(url.host)\n          end\n\n          if body.nil?\n            conn.request_get(url.request_uri, headers)\n          else\n            headers[\"Content-type\"] ||= \"application/x-www-form-urlencoded\"\n            conn.request_post(url.request_uri, body, headers)\n          end\n        }\n        setup_encoding(response)\n      rescue Timeout::Error => why\n        raise FetchingError, \"Error fetching #{url}: #{why}\"\n      rescue RuntimeError => why\n        raise why\n      rescue OpenSSL::SSL::SSLError => why\n        raise SSLFetchingError, \"Error connecting to SSL URL #{url}: #{why}\"\n      rescue FetchingError => why\n        raise why\n      rescue Exception => why\n        raise FetchingError, \"Error fetching #{url}: #{why}\"\n      end\n\n      case response\n      when Net::HTTPRedirection\n        if redirect_limit <= 0\n          raise HTTPRedirectLimitReached.new(\n            \"Too many redirects, not fetching #{response['location']}\")\n        end\n        begin\n          return fetch(response['location'], body, headers, redirect_limit - 1)\n        rescue HTTPRedirectLimitReached => e\n          raise e\n        rescue FetchingError => why\n          raise FetchingError, \"Error encountered in redirect from #{url}: #{why}\"\n        end\n      else\n        return HTTPResponse._from_net_response(response, unparsed_url)\n      end\n    end\n\n    private\n    def setup_encoding(response)\n      return unless defined?(Encoding.default_external)\n      return unless charset = response.type_params[\"charset\"]\n\n      begin\n        encoding = Encoding.find(charset)\n      rescue ArgumentError\n      end\n      encoding ||= Encoding.default_external\n\n      body = response.body\n      if body.respond_to?(:force_encoding)\n        body.force_encoding(encoding)\n      else\n        body.set_encoding(encoding)\n      end\n    end\n  end\nend\n", "require 'rexml/document'\nrequire 'rexml/element'\nrequire 'rexml/xpath'\n\nrequire 'openid/yadis/xri'\n\nmodule OpenID\n  module Yadis\n\n    XRD_NS_2_0 = 'xri://$xrd*($v*2.0)'\n    XRDS_NS = 'xri://$xrds'\n\n    XRDS_NAMESPACES = {\n      'xrds' => XRDS_NS,\n      'xrd' => XRD_NS_2_0,\n    }\n\n    class XRDSError < StandardError; end\n\n    # Raised when there's an assertion in the XRDS that it does not\n    # have the authority to make.\n    class XRDSFraud < XRDSError\n    end\n\n    def Yadis::get_canonical_id(iname, xrd_tree)\n      # Return the CanonicalID from this XRDS document.\n      #\n      # @param iname: the XRI being resolved.\n      # @type iname: unicode\n      #\n      # @param xrd_tree: The XRDS output from the resolver.\n      #\n      # @returns: The XRI CanonicalID or None.\n      # @returntype: unicode or None\n\n      xrd_list = []\n      REXML::XPath::match(xrd_tree.root, '/xrds:XRDS/xrd:XRD', XRDS_NAMESPACES).each { |el|\n        xrd_list << el\n      }\n\n      xrd_list.reverse!\n\n      cid_elements = []\n\n      if !xrd_list.empty?\n        xrd_list[0].elements.each { |e|\n          if !e.respond_to?('name')\n            next\n          end\n          if e.name == 'CanonicalID'\n            cid_elements << e\n          end\n        }\n      end\n\n      cid_element = cid_elements[0]\n\n      if !cid_element\n        return nil\n      end\n\n      canonicalID = XRI.make_xri(cid_element.text)\n\n      childID = canonicalID.downcase\n\n      xrd_list[1..-1].each { |xrd|\n        parent_sought = childID[0...childID.rindex('!')]\n\n        parent = XRI.make_xri(xrd.elements[\"CanonicalID\"].text)\n\n        if parent_sought != parent.downcase\n          raise XRDSFraud.new(sprintf(\"%s can not come from %s\", parent_sought,\n                                      parent))\n        end\n\n        childID = parent_sought\n      }\n\n      root = XRI.root_authority(iname)\n      if not XRI.provider_is_authoritative(root, childID)\n        raise XRDSFraud.new(sprintf(\"%s can not come from root %s\", childID, root))\n      end\n\n      return canonicalID\n    end\n\n    class XRDSError < StandardError\n    end\n\n    def Yadis::parseXRDS(text)\n      if text.nil?\n        raise XRDSError.new(\"Not an XRDS document.\")\n      end\n\n      begin\n        d = REXML::Document.new(text)\n      rescue RuntimeError => why\n        raise XRDSError.new(\"Not an XRDS document. Failed to parse XML.\")\n      end\n\n      if is_xrds?(d)\n        return d\n      else\n        raise XRDSError.new(\"Not an XRDS document.\")\n      end\n    end\n\n    def Yadis::is_xrds?(xrds_tree)\n      xrds_root = xrds_tree.root\n      return (!xrds_root.nil? and\n        xrds_root.name == 'XRDS' and\n        xrds_root.namespace == XRDS_NS)\n    end\n\n    def Yadis::get_yadis_xrd(xrds_tree)\n      REXML::XPath.each(xrds_tree.root,\n                        '/xrds:XRDS/xrd:XRD[last()]',\n                        XRDS_NAMESPACES) { |el|\n        return el\n      }\n      raise XRDSError.new(\"No XRD element found.\")\n    end\n\n    # aka iterServices in Python\n    def Yadis::each_service(xrds_tree, &block)\n      xrd = get_yadis_xrd(xrds_tree)\n      xrd.each_element('Service', &block)\n    end\n\n    def Yadis::services(xrds_tree)\n      s = []\n      each_service(xrds_tree) { |service|\n        s << service\n      }\n      return s\n    end\n\n    def Yadis::expand_service(service_element)\n      es = service_element.elements\n      uris = es.each('URI') { |u| }\n      uris = prio_sort(uris)\n      types = es.each('Type/text()')\n      # REXML::Text objects are not strings.\n      types = types.collect { |t| t.to_s }\n      uris.collect { |uri| [types, uri.text, service_element] }\n    end\n\n    # Sort a list of elements that have priority attributes.\n    def Yadis::prio_sort(elements)\n      elements.sort { |a,b|\n        a.attribute('priority').to_s.to_i <=> b.attribute('priority').to_s.to_i\n      }\n    end\n  end\nend\n"], "fixing_code": ["require 'net/http'\nrequire 'openid'\nrequire 'openid/util'\n\nbegin\n  require 'net/https'\nrescue LoadError\n  OpenID::Util.log('WARNING: no SSL support found.  Will not be able ' +\n                   'to fetch HTTPS URLs!')\n  require 'net/http'\nend\n\nMAX_RESPONSE_KB = 10485760 # 10 MB (can be smaller, I guess)\n\nmodule Net\n  class HTTP\n    def post_connection_check(hostname)\n      check_common_name = true\n      cert = @socket.io.peer_cert\n      cert.extensions.each { |ext|\n        next if ext.oid != \"subjectAltName\"\n        ext.value.split(/,\\s+/).each{ |general_name|\n          if /\\ADNS:(.*)/ =~ general_name\n            check_common_name = false\n            reg = Regexp.escape($1).gsub(/\\\\\\*/, \"[^.]+\")\n            return true if /\\A#{reg}\\z/i =~ hostname\n          elsif /\\AIP Address:(.*)/ =~ general_name\n            check_common_name = false\n            return true if $1 == hostname\n          end\n        }\n      }\n      if check_common_name\n        cert.subject.to_a.each{ |oid, value|\n          if oid == \"CN\"\n            reg = Regexp.escape(value).gsub(/\\\\\\*/, \"[^.]+\")\n            return true if /\\A#{reg}\\z/i =~ hostname\n          end\n        }\n      end\n      raise OpenSSL::SSL::SSLError, \"hostname does not match\"\n    end\n  end\nend\n\nmodule OpenID\n  # Our HTTPResponse class extends Net::HTTPResponse with an additional\n  # method, final_url.\n  class HTTPResponse\n    attr_accessor :final_url\n\n    attr_accessor :_response\n\n    def self._from_net_response(response, final_url, headers=nil)\n      me = self.new\n      me._response = response\n      me.final_url = final_url\n      return me\n    end\n\n    def method_missing(method, *args)\n      @_response.send(method, *args)\n    end\n\n    def body=(s)\n      @_response.instance_variable_set('@body', s)\n      # XXX Hack to work around ruby's HTTP library behavior.  @body\n      # is only returned if it has been read from the response\n      # object's socket, but since we're not using a socket in this\n      # case, we need to set the @read flag to true to avoid a bug in\n      # Net::HTTPResponse.stream_check when @socket is nil.\n      @_response.instance_variable_set('@read', true)\n    end\n  end\n\n  class FetchingError < OpenIDError\n  end\n\n  class HTTPRedirectLimitReached < FetchingError\n  end\n\n  class SSLFetchingError < FetchingError\n  end\n\n  @fetcher = nil\n\n  def self.fetch(url, body=nil, headers=nil,\n                 redirect_limit=StandardFetcher::REDIRECT_LIMIT)\n    return fetcher.fetch(url, body, headers, redirect_limit)\n  end\n\n  def self.fetcher\n    if @fetcher.nil?\n      @fetcher = StandardFetcher.new\n    end\n\n    return @fetcher\n  end\n\n  def self.fetcher=(fetcher)\n    @fetcher = fetcher\n  end\n\n  # Set the default fetcher to use the HTTP proxy defined in the environment\n  # variable 'http_proxy'.\n  def self.fetcher_use_env_http_proxy\n    proxy_string = ENV['http_proxy']\n    return unless proxy_string\n\n    proxy_uri = URI.parse(proxy_string)\n    @fetcher = StandardFetcher.new(proxy_uri.host, proxy_uri.port,\n                                   proxy_uri.user, proxy_uri.password)\n  end\n  \n  class StandardFetcher\n\n    USER_AGENT = \"ruby-openid/#{OpenID::VERSION} (#{RUBY_PLATFORM})\"\n\n    REDIRECT_LIMIT = 5\n    TIMEOUT = 60\n\n    attr_accessor :ca_file\n    attr_accessor :timeout\n\n    # I can fetch through a HTTP proxy; arguments are as for Net::HTTP::Proxy.\n    def initialize(proxy_addr=nil, proxy_port=nil,\n                   proxy_user=nil, proxy_pass=nil)\n      @ca_file = nil\n      @proxy = Net::HTTP::Proxy(proxy_addr, proxy_port, proxy_user, proxy_pass)\n      @timeout = TIMEOUT\n    end\n\n    def supports_ssl?(conn)\n      return conn.respond_to?(:use_ssl=)\n    end\n\n    def make_http(uri)\n      http = @proxy.new(uri.host, uri.port)\n      http.read_timeout = @timeout\n      http.open_timeout = @timeout\n      return http\n    end\n\n    def set_verified(conn, verify)\n      if verify\n        conn.verify_mode = OpenSSL::SSL::VERIFY_PEER\n      else\n        conn.verify_mode = OpenSSL::SSL::VERIFY_NONE\n      end\n    end\n\n    def make_connection(uri)\n      conn = make_http(uri)\n\n      if !conn.is_a?(Net::HTTP)\n        raise RuntimeError, sprintf(\"Expected Net::HTTP object from make_http; got %s\",\n                                    conn.class)\n      end\n\n      if uri.scheme == 'https'\n        if supports_ssl?(conn)\n\n          conn.use_ssl = true\n\n          if @ca_file\n            set_verified(conn, true)\n            conn.ca_file = @ca_file\n          else\n            Util.log(\"WARNING: making https request to #{uri} without verifying \" +\n                     \"server certificate; no CA path was specified.\")\n            set_verified(conn, false)\n          end\n        else\n          raise RuntimeError, \"SSL support not found; cannot fetch #{uri}\"\n        end\n      end\n\n      return conn\n    end\n\n    def fetch(url, body=nil, headers=nil, redirect_limit=REDIRECT_LIMIT)\n      unparsed_url = url.dup\n      url = URI::parse(url)\n      if url.nil?\n        raise FetchingError, \"Invalid URL: #{unparsed_url}\"\n      end\n\n      headers ||= {}\n      headers['User-agent'] ||= USER_AGENT\n\n      begin\n        conn = make_connection(url)\n        response = nil\n\n        whole_body = ''\n        body_size_limitter = lambda do |r|\n          r.read_body do |partial|   # read body now\n            whole_body << partial\n            if whole_body.length > MAX_RESPONSE_KB\n              raise FetchingError.new(\"Response Too Large\")\n            end\n          end\n          whole_body\n        end\n        response = conn.start {\n          # Check the certificate against the URL's hostname\n          if supports_ssl?(conn) and conn.use_ssl?\n            conn.post_connection_check(url.host)\n          end\n\n          if body.nil?\n            conn.request_get(url.request_uri, headers, &body_size_limitter)\n          else\n            headers[\"Content-type\"] ||= \"application/x-www-form-urlencoded\"\n            conn.request_post(url.request_uri, body, headers, &body_size_limitter)\n          end\n        }\n      rescue Timeout::Error => why\n        raise FetchingError, \"Error fetching #{url}: #{why}\"\n      rescue RuntimeError => why\n        raise why\n      rescue OpenSSL::SSL::SSLError => why\n        raise SSLFetchingError, \"Error connecting to SSL URL #{url}: #{why}\"\n      rescue FetchingError => why\n        raise why\n      rescue Exception => why\n        raise FetchingError, \"Error fetching #{url}: #{why}\"\n      end\n\n      case response\n      when Net::HTTPRedirection\n        if redirect_limit <= 0\n          raise HTTPRedirectLimitReached.new(\n            \"Too many redirects, not fetching #{response['location']}\")\n        end\n        begin\n          return fetch(response['location'], body, headers, redirect_limit - 1)\n        rescue HTTPRedirectLimitReached => e\n          raise e\n        rescue FetchingError => why\n          raise FetchingError, \"Error encountered in redirect from #{url}: #{why}\"\n        end\n      else\n        response = HTTPResponse._from_net_response(response, unparsed_url)\n        response.body = whole_body\n        setup_encoding(response)\n        return response\n      end\n    end\n\n    private\n    def setup_encoding(response)\n      return unless defined?(Encoding.default_external)\n      return unless charset = response.type_params[\"charset\"]\n\n      begin\n        encoding = Encoding.find(charset)\n      rescue ArgumentError\n      end\n      encoding ||= Encoding.default_external\n\n      body = response.body\n      if body.respond_to?(:force_encoding)\n        body.force_encoding(encoding)\n      else\n        body.set_encoding(encoding)\n      end\n    end\n  end\nend\n", "require 'rexml/document'\nrequire 'rexml/element'\nrequire 'rexml/xpath'\n\nrequire 'openid/yadis/xri'\n\nmodule OpenID\n  module Yadis\n\n    XRD_NS_2_0 = 'xri://$xrd*($v*2.0)'\n    XRDS_NS = 'xri://$xrds'\n\n    XRDS_NAMESPACES = {\n      'xrds' => XRDS_NS,\n      'xrd' => XRD_NS_2_0,\n    }\n\n    class XRDSError < StandardError; end\n\n    # Raised when there's an assertion in the XRDS that it does not\n    # have the authority to make.\n    class XRDSFraud < XRDSError\n    end\n\n    def Yadis::get_canonical_id(iname, xrd_tree)\n      # Return the CanonicalID from this XRDS document.\n      #\n      # @param iname: the XRI being resolved.\n      # @type iname: unicode\n      #\n      # @param xrd_tree: The XRDS output from the resolver.\n      #\n      # @returns: The XRI CanonicalID or None.\n      # @returntype: unicode or None\n\n      xrd_list = []\n      REXML::XPath::match(xrd_tree.root, '/xrds:XRDS/xrd:XRD', XRDS_NAMESPACES).each { |el|\n        xrd_list << el\n      }\n\n      xrd_list.reverse!\n\n      cid_elements = []\n\n      if !xrd_list.empty?\n        xrd_list[0].elements.each { |e|\n          if !e.respond_to?('name')\n            next\n          end\n          if e.name == 'CanonicalID'\n            cid_elements << e\n          end\n        }\n      end\n\n      cid_element = cid_elements[0]\n\n      if !cid_element\n        return nil\n      end\n\n      canonicalID = XRI.make_xri(cid_element.text)\n\n      childID = canonicalID.downcase\n\n      xrd_list[1..-1].each { |xrd|\n        parent_sought = childID[0...childID.rindex('!')]\n\n        parent = XRI.make_xri(xrd.elements[\"CanonicalID\"].text)\n\n        if parent_sought != parent.downcase\n          raise XRDSFraud.new(sprintf(\"%s can not come from %s\", parent_sought,\n                                      parent))\n        end\n\n        childID = parent_sought\n      }\n\n      root = XRI.root_authority(iname)\n      if not XRI.provider_is_authoritative(root, childID)\n        raise XRDSFraud.new(sprintf(\"%s can not come from root %s\", childID, root))\n      end\n\n      return canonicalID\n    end\n\n    class XRDSError < StandardError\n    end\n\n    def Yadis::parseXRDS(text)\n      disable_entity_expansion do\n        if text.nil?\n          raise XRDSError.new(\"Not an XRDS document.\")\n        end\n\n        begin\n          d = REXML::Document.new(text)\n        rescue RuntimeError => why\n          raise XRDSError.new(\"Not an XRDS document. Failed to parse XML.\")\n        end\n\n        if is_xrds?(d)\n          return d\n        else\n          raise XRDSError.new(\"Not an XRDS document.\")\n        end\n      end\n    end\n\n    def Yadis::disable_entity_expansion\n      _previous_ = REXML::Document::entity_expansion_limit\n      REXML::Document::entity_expansion_limit = 0\n      yield\n    ensure\n      REXML::Document::entity_expansion_limit = _previous_\n    end\n\n    def Yadis::is_xrds?(xrds_tree)\n      xrds_root = xrds_tree.root\n      return (!xrds_root.nil? and\n        xrds_root.name == 'XRDS' and\n        xrds_root.namespace == XRDS_NS)\n    end\n\n    def Yadis::get_yadis_xrd(xrds_tree)\n      REXML::XPath.each(xrds_tree.root,\n                        '/xrds:XRDS/xrd:XRD[last()]',\n                        XRDS_NAMESPACES) { |el|\n        return el\n      }\n      raise XRDSError.new(\"No XRD element found.\")\n    end\n\n    # aka iterServices in Python\n    def Yadis::each_service(xrds_tree, &block)\n      xrd = get_yadis_xrd(xrds_tree)\n      xrd.each_element('Service', &block)\n    end\n\n    def Yadis::services(xrds_tree)\n      s = []\n      each_service(xrds_tree) { |service|\n        s << service\n      }\n      return s\n    end\n\n    def Yadis::expand_service(service_element)\n      es = service_element.elements\n      uris = es.each('URI') { |u| }\n      uris = prio_sort(uris)\n      types = es.each('Type/text()')\n      # REXML::Text objects are not strings.\n      types = types.collect { |t| t.to_s }\n      uris.collect { |uri| [types, uri.text, service_element] }\n    end\n\n    # Sort a list of elements that have priority attributes.\n    def Yadis::prio_sort(elements)\n      elements.sort { |a,b|\n        a.attribute('priority').to_s.to_i <=> b.attribute('priority').to_s.to_i\n      }\n    end\n  end\nend\n"], "filenames": ["lib/openid/fetchers.rb", "lib/openid/yadis/xrds.rb"], "buggy_code_start_loc": [13, 91], "buggy_code_end_loc": [236, 106], "fixing_code_start_loc": [13, 91], "fixing_code_end_loc": [248, 116], "type": "CWE-399", "message": "The ruby-openid gem before 2.2.2 for Ruby allows remote OpenID providers to cause a denial of service (CPU consumption) via (1) a large XRDS document or (2) an XML Entity Expansion (XEE) attack.", "other": {"cve": {"id": "CVE-2013-1812", "sourceIdentifier": "secalert@redhat.com", "published": "2013-12-12T18:55:10.663", "lastModified": "2013-12-13T16:12:20.850", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ruby-openid gem before 2.2.2 for Ruby allows remote OpenID providers to cause a denial of service (CPU consumption) via (1) a large XRDS document or (2) an XML Entity Expansion (XEE) attack."}, {"lang": "es", "value": "El gem de ruby-openid anterior a la versi\u00f3n 2.2.2 para Ruby permite a proveedores de OpenID remotos provocar una denegaci\u00f3n de servicio (consumo de CPU) a trav\u00e9s de (1) un documento XRDS grande o (2) un ataque de XML Entity Expansion (XEE)."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:17:*:*:*:*:*:*:*", "matchCriteriaId": "2DA9D861-3EAF-42F5-B0B6-A4CD7BDD6188"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:18:*:*:*:*:*:*:*", "matchCriteriaId": "E14271AE-1309-48F3-B9C6-D7DEEC488279"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:janrain:ruby-openid:*:-:-:*:-:ruby:*:*", "versionEndIncluding": "2.2.1", "matchCriteriaId": "C65026BB-8118-4A82-ADC6-99E5DF6F7DF1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:janrain:ruby-openid:2.2.0:-:-:*:-:ruby:*:*", "matchCriteriaId": "DBD5FD0A-EDA3-479D-869C-F4852A613AD4"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-November/120204.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-November/120361.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/03/03/8", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=918134", "source": "secalert@redhat.com"}, {"url": "https://github.com/openid/ruby-openid/blob/master/CHANGELOG.md", "source": "secalert@redhat.com"}, {"url": "https://github.com/openid/ruby-openid/commit/a3693cef06049563f5b4e4824f4d3211288508ed", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/openid/ruby-openid/pull/43", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/openid/ruby-openid/commit/a3693cef06049563f5b4e4824f4d3211288508ed"}}