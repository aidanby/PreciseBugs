{"buggy_code": ["#ifndef _ASM_X86_PGTABLE_3LEVEL_H\n#define _ASM_X86_PGTABLE_3LEVEL_H\n\n/*\n * Intel Physical Address Extension (PAE) Mode - three-level page\n * tables on PPro+ CPUs.\n *\n * Copyright (C) 1999 Ingo Molnar <mingo@redhat.com>\n */\n\n#define pte_ERROR(e)\t\t\t\t\t\t\t\\\n\tprintk(\"%s:%d: bad pte %p(%08lx%08lx).\\n\",\t\t\t\\\n\t       __FILE__, __LINE__, &(e), (e).pte_high, (e).pte_low)\n#define pmd_ERROR(e)\t\t\t\t\t\t\t\\\n\tprintk(\"%s:%d: bad pmd %p(%016Lx).\\n\",\t\t\t\t\\\n\t       __FILE__, __LINE__, &(e), pmd_val(e))\n#define pgd_ERROR(e)\t\t\t\t\t\t\t\\\n\tprintk(\"%s:%d: bad pgd %p(%016Lx).\\n\",\t\t\t\t\\\n\t       __FILE__, __LINE__, &(e), pgd_val(e))\n\n/* Rules for using set_pte: the pte being assigned *must* be\n * either not present or in a state where the hardware will\n * not attempt to update the pte.  In places where this is\n * not possible, use pte_get_and_clear to obtain the old pte\n * value and then use set_pte to update it.  -ben\n */\nstatic inline void native_set_pte(pte_t *ptep, pte_t pte)\n{\n\tptep->pte_high = pte.pte_high;\n\tsmp_wmb();\n\tptep->pte_low = pte.pte_low;\n}\n\nstatic inline void native_set_pte_atomic(pte_t *ptep, pte_t pte)\n{\n\tset_64bit((unsigned long long *)(ptep), native_pte_val(pte));\n}\n\nstatic inline void native_set_pmd(pmd_t *pmdp, pmd_t pmd)\n{\n\tset_64bit((unsigned long long *)(pmdp), native_pmd_val(pmd));\n}\n\nstatic inline void native_set_pud(pud_t *pudp, pud_t pud)\n{\n\tset_64bit((unsigned long long *)(pudp), native_pud_val(pud));\n}\n\n/*\n * For PTEs and PDEs, we must clear the P-bit first when clearing a page table\n * entry, so clear the bottom half first and enforce ordering with a compiler\n * barrier.\n */\nstatic inline void native_pte_clear(struct mm_struct *mm, unsigned long addr,\n\t\t\t\t    pte_t *ptep)\n{\n\tptep->pte_low = 0;\n\tsmp_wmb();\n\tptep->pte_high = 0;\n}\n\nstatic inline void native_pmd_clear(pmd_t *pmd)\n{\n\tu32 *tmp = (u32 *)pmd;\n\t*tmp = 0;\n\tsmp_wmb();\n\t*(tmp + 1) = 0;\n}\n\nstatic inline void pud_clear(pud_t *pudp)\n{\n\tset_pud(pudp, __pud(0));\n\n\t/*\n\t * According to Intel App note \"TLBs, Paging-Structure Caches,\n\t * and Their Invalidation\", April 2007, document 317080-001,\n\t * section 8.1: in PAE mode we explicitly have to flush the\n\t * TLB via cr3 if the top-level pgd is changed...\n\t *\n\t * Currently all places where pud_clear() is called either have\n\t * flush_tlb_mm() followed or don't need TLB flush (x86_64 code or\n\t * pud_clear_bad()), so we don't need TLB flush here.\n\t */\n}\n\n#ifdef CONFIG_SMP\nstatic inline pte_t native_ptep_get_and_clear(pte_t *ptep)\n{\n\tpte_t res;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\tres.pte_low = xchg(&ptep->pte_low, 0);\n\tres.pte_high = ptep->pte_high;\n\tptep->pte_high = 0;\n\n\treturn res;\n}\n#else\n#define native_ptep_get_and_clear(xp) native_local_ptep_get_and_clear(xp)\n#endif\n\n#ifdef CONFIG_SMP\nunion split_pmd {\n\tstruct {\n\t\tu32 pmd_low;\n\t\tu32 pmd_high;\n\t};\n\tpmd_t pmd;\n};\nstatic inline pmd_t native_pmdp_get_and_clear(pmd_t *pmdp)\n{\n\tunion split_pmd res, *orig = (union split_pmd *)pmdp;\n\n\t/* xchg acts as a barrier before setting of the high bits */\n\tres.pmd_low = xchg(&orig->pmd_low, 0);\n\tres.pmd_high = orig->pmd_high;\n\torig->pmd_high = 0;\n\n\treturn res.pmd;\n}\n#else\n#define native_pmdp_get_and_clear(xp) native_local_pmdp_get_and_clear(xp)\n#endif\n\n/*\n * Bits 0, 6 and 7 are taken in the low part of the pte,\n * put the 32 bits of offset into the high part.\n */\n#define pte_to_pgoff(pte) ((pte).pte_high)\n#define pgoff_to_pte(off)\t\t\t\t\t\t\\\n\t((pte_t) { { .pte_low = _PAGE_FILE, .pte_high = (off) } })\n#define PTE_FILE_MAX_BITS       32\n\n/* Encode and de-code a swap entry */\n#define MAX_SWAPFILES_CHECK() BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > 5)\n#define __swp_type(x)\t\t\t(((x).val) & 0x1f)\n#define __swp_offset(x)\t\t\t((x).val >> 5)\n#define __swp_entry(type, offset)\t((swp_entry_t){(type) | (offset) << 5})\n#define __pte_to_swp_entry(pte)\t\t((swp_entry_t){ (pte).pte_high })\n#define __swp_entry_to_pte(x)\t\t((pte_t){ { .pte_high = (x).val } })\n\n#endif /* _ASM_X86_PGTABLE_3LEVEL_H */\n", "#ifndef _ASM_GENERIC_PGTABLE_H\n#define _ASM_GENERIC_PGTABLE_H\n\n#ifndef __ASSEMBLY__\n#ifdef CONFIG_MMU\n\n#include <linux/mm_types.h>\n#include <linux/bug.h>\n\n#ifndef __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS\nextern int ptep_set_access_flags(struct vm_area_struct *vma,\n\t\t\t\t unsigned long address, pte_t *ptep,\n\t\t\t\t pte_t entry, int dirty);\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_SET_ACCESS_FLAGS\nextern int pmdp_set_access_flags(struct vm_area_struct *vma,\n\t\t\t\t unsigned long address, pmd_t *pmdp,\n\t\t\t\t pmd_t entry, int dirty);\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG\nstatic inline int ptep_test_and_clear_young(struct vm_area_struct *vma,\n\t\t\t\t\t    unsigned long address,\n\t\t\t\t\t    pte_t *ptep)\n{\n\tpte_t pte = *ptep;\n\tint r = 1;\n\tif (!pte_young(pte))\n\t\tr = 0;\n\telse\n\t\tset_pte_at(vma->vm_mm, address, ptep, pte_mkold(pte));\n\treturn r;\n}\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_TEST_AND_CLEAR_YOUNG\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline int pmdp_test_and_clear_young(struct vm_area_struct *vma,\n\t\t\t\t\t    unsigned long address,\n\t\t\t\t\t    pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\tint r = 1;\n\tif (!pmd_young(pmd))\n\t\tr = 0;\n\telse\n\t\tset_pmd_at(vma->vm_mm, address, pmdp, pmd_mkold(pmd));\n\treturn r;\n}\n#else /* CONFIG_TRANSPARENT_HUGEPAGE */\nstatic inline int pmdp_test_and_clear_young(struct vm_area_struct *vma,\n\t\t\t\t\t    unsigned long address,\n\t\t\t\t\t    pmd_t *pmdp)\n{\n\tBUG();\n\treturn 0;\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_CLEAR_YOUNG_FLUSH\nint ptep_clear_flush_young(struct vm_area_struct *vma,\n\t\t\t   unsigned long address, pte_t *ptep);\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_CLEAR_YOUNG_FLUSH\nint pmdp_clear_flush_young(struct vm_area_struct *vma,\n\t\t\t   unsigned long address, pmd_t *pmdp);\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_GET_AND_CLEAR\nstatic inline pte_t ptep_get_and_clear(struct mm_struct *mm,\n\t\t\t\t       unsigned long address,\n\t\t\t\t       pte_t *ptep)\n{\n\tpte_t pte = *ptep;\n\tpte_clear(mm, address, ptep);\n\treturn pte;\n}\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_GET_AND_CLEAR\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline pmd_t pmdp_get_and_clear(struct mm_struct *mm,\n\t\t\t\t       unsigned long address,\n\t\t\t\t       pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\tpmd_clear(mm, address, pmdp);\n\treturn pmd;\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_GET_AND_CLEAR_FULL\nstatic inline pte_t ptep_get_and_clear_full(struct mm_struct *mm,\n\t\t\t\t\t    unsigned long address, pte_t *ptep,\n\t\t\t\t\t    int full)\n{\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\treturn pte;\n}\n#endif\n\n/*\n * Some architectures may be able to avoid expensive synchronization\n * primitives when modifications are made to PTE's which are already\n * not present, or in the process of an address space destruction.\n */\n#ifndef __HAVE_ARCH_PTE_CLEAR_NOT_PRESENT_FULL\nstatic inline void pte_clear_not_present_full(struct mm_struct *mm,\n\t\t\t\t\t      unsigned long address,\n\t\t\t\t\t      pte_t *ptep,\n\t\t\t\t\t      int full)\n{\n\tpte_clear(mm, address, ptep);\n}\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_CLEAR_FLUSH\nextern pte_t ptep_clear_flush(struct vm_area_struct *vma,\n\t\t\t      unsigned long address,\n\t\t\t      pte_t *ptep);\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_CLEAR_FLUSH\nextern pmd_t pmdp_clear_flush(struct vm_area_struct *vma,\n\t\t\t      unsigned long address,\n\t\t\t      pmd_t *pmdp);\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_SET_WRPROTECT\nstruct mm_struct;\nstatic inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long address, pte_t *ptep)\n{\n\tpte_t old_pte = *ptep;\n\tset_pte_at(mm, address, ptep, pte_wrprotect(old_pte));\n}\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_SET_WRPROTECT\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline void pmdp_set_wrprotect(struct mm_struct *mm,\n\t\t\t\t      unsigned long address, pmd_t *pmdp)\n{\n\tpmd_t old_pmd = *pmdp;\n\tset_pmd_at(mm, address, pmdp, pmd_wrprotect(old_pmd));\n}\n#else /* CONFIG_TRANSPARENT_HUGEPAGE */\nstatic inline void pmdp_set_wrprotect(struct mm_struct *mm,\n\t\t\t\t      unsigned long address, pmd_t *pmdp)\n{\n\tBUG();\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_SPLITTING_FLUSH\nextern void pmdp_splitting_flush(struct vm_area_struct *vma,\n\t\t\t\t unsigned long address, pmd_t *pmdp);\n#endif\n\n#ifndef __HAVE_ARCH_PTE_SAME\nstatic inline int pte_same(pte_t pte_a, pte_t pte_b)\n{\n\treturn pte_val(pte_a) == pte_val(pte_b);\n}\n#endif\n\n#ifndef __HAVE_ARCH_PMD_SAME\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline int pmd_same(pmd_t pmd_a, pmd_t pmd_b)\n{\n\treturn pmd_val(pmd_a) == pmd_val(pmd_b);\n}\n#else /* CONFIG_TRANSPARENT_HUGEPAGE */\nstatic inline int pmd_same(pmd_t pmd_a, pmd_t pmd_b)\n{\n\tBUG();\n\treturn 0;\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n#endif\n\n#ifndef __HAVE_ARCH_PAGE_TEST_AND_CLEAR_DIRTY\n#define page_test_and_clear_dirty(pfn, mapped)\t(0)\n#endif\n\n#ifndef __HAVE_ARCH_PAGE_TEST_AND_CLEAR_DIRTY\n#define pte_maybe_dirty(pte)\t\tpte_dirty(pte)\n#else\n#define pte_maybe_dirty(pte)\t\t(1)\n#endif\n\n#ifndef __HAVE_ARCH_PAGE_TEST_AND_CLEAR_YOUNG\n#define page_test_and_clear_young(pfn) (0)\n#endif\n\n#ifndef __HAVE_ARCH_PGD_OFFSET_GATE\n#define pgd_offset_gate(mm, addr)\tpgd_offset(mm, addr)\n#endif\n\n#ifndef __HAVE_ARCH_MOVE_PTE\n#define move_pte(pte, prot, old_addr, new_addr)\t(pte)\n#endif\n\n#ifndef flush_tlb_fix_spurious_fault\n#define flush_tlb_fix_spurious_fault(vma, address) flush_tlb_page(vma, address)\n#endif\n\n#ifndef pgprot_noncached\n#define pgprot_noncached(prot)\t(prot)\n#endif\n\n#ifndef pgprot_writecombine\n#define pgprot_writecombine pgprot_noncached\n#endif\n\n/*\n * When walking page tables, get the address of the next boundary,\n * or the end address of the range if that comes earlier.  Although no\n * vma end wraps to 0, rounded up __boundary may wrap to 0 throughout.\n */\n\n#define pgd_addr_end(addr, end)\t\t\t\t\t\t\\\n({\tunsigned long __boundary = ((addr) + PGDIR_SIZE) & PGDIR_MASK;\t\\\n\t(__boundary - 1 < (end) - 1)? __boundary: (end);\t\t\\\n})\n\n#ifndef pud_addr_end\n#define pud_addr_end(addr, end)\t\t\t\t\t\t\\\n({\tunsigned long __boundary = ((addr) + PUD_SIZE) & PUD_MASK;\t\\\n\t(__boundary - 1 < (end) - 1)? __boundary: (end);\t\t\\\n})\n#endif\n\n#ifndef pmd_addr_end\n#define pmd_addr_end(addr, end)\t\t\t\t\t\t\\\n({\tunsigned long __boundary = ((addr) + PMD_SIZE) & PMD_MASK;\t\\\n\t(__boundary - 1 < (end) - 1)? __boundary: (end);\t\t\\\n})\n#endif\n\n/*\n * When walking page tables, we usually want to skip any p?d_none entries;\n * and any p?d_bad entries - reporting the error before resetting to none.\n * Do the tests inline, but report and clear the bad entry in mm/memory.c.\n */\nvoid pgd_clear_bad(pgd_t *);\nvoid pud_clear_bad(pud_t *);\nvoid pmd_clear_bad(pmd_t *);\n\nstatic inline int pgd_none_or_clear_bad(pgd_t *pgd)\n{\n\tif (pgd_none(*pgd))\n\t\treturn 1;\n\tif (unlikely(pgd_bad(*pgd))) {\n\t\tpgd_clear_bad(pgd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int pud_none_or_clear_bad(pud_t *pud)\n{\n\tif (pud_none(*pud))\n\t\treturn 1;\n\tif (unlikely(pud_bad(*pud))) {\n\t\tpud_clear_bad(pud);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int pmd_none_or_clear_bad(pmd_t *pmd)\n{\n\tif (pmd_none(*pmd))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(*pmd))) {\n\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline pte_t __ptep_modify_prot_start(struct mm_struct *mm,\n\t\t\t\t\t     unsigned long addr,\n\t\t\t\t\t     pte_t *ptep)\n{\n\t/*\n\t * Get the current pte state, but zero it out to make it\n\t * non-present, preventing the hardware from asynchronously\n\t * updating it.\n\t */\n\treturn ptep_get_and_clear(mm, addr, ptep);\n}\n\nstatic inline void __ptep_modify_prot_commit(struct mm_struct *mm,\n\t\t\t\t\t     unsigned long addr,\n\t\t\t\t\t     pte_t *ptep, pte_t pte)\n{\n\t/*\n\t * The pte is non-present, so there's no hardware state to\n\t * preserve.\n\t */\n\tset_pte_at(mm, addr, ptep, pte);\n}\n\n#ifndef __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION\n/*\n * Start a pte protection read-modify-write transaction, which\n * protects against asynchronous hardware modifications to the pte.\n * The intention is not to prevent the hardware from making pte\n * updates, but to prevent any updates it may make from being lost.\n *\n * This does not protect against other software modifications of the\n * pte; the appropriate pte lock must be held over the transation.\n *\n * Note that this interface is intended to be batchable, meaning that\n * ptep_modify_prot_commit may not actually update the pte, but merely\n * queue the update to be done at some later time.  The update must be\n * actually committed before the pte lock is released, however.\n */\nstatic inline pte_t ptep_modify_prot_start(struct mm_struct *mm,\n\t\t\t\t\t   unsigned long addr,\n\t\t\t\t\t   pte_t *ptep)\n{\n\treturn __ptep_modify_prot_start(mm, addr, ptep);\n}\n\n/*\n * Commit an update to a pte, leaving any hardware-controlled bits in\n * the PTE unmodified.\n */\nstatic inline void ptep_modify_prot_commit(struct mm_struct *mm,\n\t\t\t\t\t   unsigned long addr,\n\t\t\t\t\t   pte_t *ptep, pte_t pte)\n{\n\t__ptep_modify_prot_commit(mm, addr, ptep, pte);\n}\n#endif /* __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION */\n#endif /* CONFIG_MMU */\n\n/*\n * A facility to provide lazy MMU batching.  This allows PTE updates and\n * page invalidations to be delayed until a call to leave lazy MMU mode\n * is issued.  Some architectures may benefit from doing this, and it is\n * beneficial for both shadow and direct mode hypervisors, which may batch\n * the PTE updates which happen during this window.  Note that using this\n * interface requires that read hazards be removed from the code.  A read\n * hazard could result in the direct mode hypervisor case, since the actual\n * write to the page tables may not yet have taken place, so reads though\n * a raw PTE pointer after it has been modified are not guaranteed to be\n * up to date.  This mode can only be entered and left under the protection of\n * the page table locks for all page tables which may be modified.  In the UP\n * case, this is required so that preemption is disabled, and in the SMP case,\n * it must synchronize the delayed page table writes properly on other CPUs.\n */\n#ifndef __HAVE_ARCH_ENTER_LAZY_MMU_MODE\n#define arch_enter_lazy_mmu_mode()\tdo {} while (0)\n#define arch_leave_lazy_mmu_mode()\tdo {} while (0)\n#define arch_flush_lazy_mmu_mode()\tdo {} while (0)\n#endif\n\n/*\n * A facility to provide batching of the reload of page tables and\n * other process state with the actual context switch code for\n * paravirtualized guests.  By convention, only one of the batched\n * update (lazy) modes (CPU, MMU) should be active at any given time,\n * entry should never be nested, and entry and exits should always be\n * paired.  This is for sanity of maintaining and reasoning about the\n * kernel code.  In this case, the exit (end of the context switch) is\n * in architecture-specific code, and so doesn't need a generic\n * definition.\n */\n#ifndef __HAVE_ARCH_START_CONTEXT_SWITCH\n#define arch_start_context_switch(prev)\tdo {} while (0)\n#endif\n\n#ifndef __HAVE_PFNMAP_TRACKING\n/*\n * Interface that can be used by architecture code to keep track of\n * memory type of pfn mappings (remap_pfn_range, vm_insert_pfn)\n *\n * track_pfn_vma_new is called when a _new_ pfn mapping is being established\n * for physical range indicated by pfn and size.\n */\nstatic inline int track_pfn_vma_new(struct vm_area_struct *vma, pgprot_t *prot,\n\t\t\t\t\tunsigned long pfn, unsigned long size)\n{\n\treturn 0;\n}\n\n/*\n * Interface that can be used by architecture code to keep track of\n * memory type of pfn mappings (remap_pfn_range, vm_insert_pfn)\n *\n * track_pfn_vma_copy is called when vma that is covering the pfnmap gets\n * copied through copy_page_range().\n */\nstatic inline int track_pfn_vma_copy(struct vm_area_struct *vma)\n{\n\treturn 0;\n}\n\n/*\n * Interface that can be used by architecture code to keep track of\n * memory type of pfn mappings (remap_pfn_range, vm_insert_pfn)\n *\n * untrack_pfn_vma is called while unmapping a pfnmap for a region.\n * untrack can be called for a specific region indicated by pfn and size or\n * can be for the entire vma (in which case size can be zero).\n */\nstatic inline void untrack_pfn_vma(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long pfn, unsigned long size)\n{\n}\n#else\nextern int track_pfn_vma_new(struct vm_area_struct *vma, pgprot_t *prot,\n\t\t\t\tunsigned long pfn, unsigned long size);\nextern int track_pfn_vma_copy(struct vm_area_struct *vma);\nextern void untrack_pfn_vma(struct vm_area_struct *vma, unsigned long pfn,\n\t\t\t\tunsigned long size);\n#endif\n\n#ifdef CONFIG_MMU\n\n#ifndef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline int pmd_trans_huge(pmd_t pmd)\n{\n\treturn 0;\n}\nstatic inline int pmd_trans_splitting(pmd_t pmd)\n{\n\treturn 0;\n}\n#ifndef __HAVE_ARCH_PMD_WRITE\nstatic inline int pmd_write(pmd_t pmd)\n{\n\tBUG();\n\treturn 0;\n}\n#endif /* __HAVE_ARCH_PMD_WRITE */\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\n/*\n * This function is meant to be used by sites walking pagetables with\n * the mmap_sem hold in read mode to protect against MADV_DONTNEED and\n * transhuge page faults. MADV_DONTNEED can convert a transhuge pmd\n * into a null pmd and the transhuge page fault can convert a null pmd\n * into an hugepmd or into a regular pmd (if the hugepage allocation\n * fails). While holding the mmap_sem in read mode the pmd becomes\n * stable and stops changing under us only if it's not null and not a\n * transhuge pmd. When those races occurs and this function makes a\n * difference vs the standard pmd_none_or_clear_bad, the result is\n * undefined so behaving like if the pmd was none is safe (because it\n * can return none anyway). The compiler level barrier() is critically\n * important to compute the two checks atomically on the same pmdval.\n */\nstatic inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\t/* depend on compiler for an atomic pmd read */\n\tpmd_t pmdval = *pmd;\n\t/*\n\t * The barrier will stabilize the pmdval in a register or on\n\t * the stack so that it will stop changing under the code.\n\t */\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * This is a noop if Transparent Hugepage Support is not built into\n * the kernel. Otherwise it is equivalent to\n * pmd_none_or_trans_huge_or_clear_bad(), and shall only be called in\n * places that already verified the pmd is not none and they want to\n * walk ptes while holding the mmap sem in read mode (write mode don't\n * need this). If THP is not enabled, the pmd can't go away under the\n * code even if MADV_DONTNEED runs, but if THP is enabled we need to\n * run a pmd_trans_unstable before walking the ptes after\n * split_huge_page_pmd returns (because it may have run when the pmd\n * become null, but then a page fault can map in a THP and not a\n * regular page).\n */\nstatic inline int pmd_trans_unstable(pmd_t *pmd)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\treturn pmd_none_or_trans_huge_or_clear_bad(pmd);\n#else\n\treturn 0;\n#endif\n}\n\n#endif /* CONFIG_MMU */\n\n#endif /* !__ASSEMBLY__ */\n\n#endif /* _ASM_GENERIC_PGTABLE_H */\n"], "fixing_code": ["#ifndef _ASM_X86_PGTABLE_3LEVEL_H\n#define _ASM_X86_PGTABLE_3LEVEL_H\n\n/*\n * Intel Physical Address Extension (PAE) Mode - three-level page\n * tables on PPro+ CPUs.\n *\n * Copyright (C) 1999 Ingo Molnar <mingo@redhat.com>\n */\n\n#define pte_ERROR(e)\t\t\t\t\t\t\t\\\n\tprintk(\"%s:%d: bad pte %p(%08lx%08lx).\\n\",\t\t\t\\\n\t       __FILE__, __LINE__, &(e), (e).pte_high, (e).pte_low)\n#define pmd_ERROR(e)\t\t\t\t\t\t\t\\\n\tprintk(\"%s:%d: bad pmd %p(%016Lx).\\n\",\t\t\t\t\\\n\t       __FILE__, __LINE__, &(e), pmd_val(e))\n#define pgd_ERROR(e)\t\t\t\t\t\t\t\\\n\tprintk(\"%s:%d: bad pgd %p(%016Lx).\\n\",\t\t\t\t\\\n\t       __FILE__, __LINE__, &(e), pgd_val(e))\n\n/* Rules for using set_pte: the pte being assigned *must* be\n * either not present or in a state where the hardware will\n * not attempt to update the pte.  In places where this is\n * not possible, use pte_get_and_clear to obtain the old pte\n * value and then use set_pte to update it.  -ben\n */\nstatic inline void native_set_pte(pte_t *ptep, pte_t pte)\n{\n\tptep->pte_high = pte.pte_high;\n\tsmp_wmb();\n\tptep->pte_low = pte.pte_low;\n}\n\n#define pmd_read_atomic pmd_read_atomic\n/*\n * pte_offset_map_lock on 32bit PAE kernels was reading the pmd_t with\n * a \"*pmdp\" dereference done by gcc. Problem is, in certain places\n * where pte_offset_map_lock is called, concurrent page faults are\n * allowed, if the mmap_sem is hold for reading. An example is mincore\n * vs page faults vs MADV_DONTNEED. On the page fault side\n * pmd_populate rightfully does a set_64bit, but if we're reading the\n * pmd_t with a \"*pmdp\" on the mincore side, a SMP race can happen\n * because gcc will not read the 64bit of the pmd atomically. To fix\n * this all places running pmd_offset_map_lock() while holding the\n * mmap_sem in read mode, shall read the pmdp pointer using this\n * function to know if the pmd is null nor not, and in turn to know if\n * they can run pmd_offset_map_lock or pmd_trans_huge or other pmd\n * operations.\n *\n * Without THP if the mmap_sem is hold for reading, the\n * pmd can only transition from null to not null while pmd_read_atomic runs.\n * So there's no need of literally reading it atomically.\n *\n * With THP if the mmap_sem is hold for reading, the pmd can become\n * THP or null or point to a pte (and in turn become \"stable\") at any\n * time under pmd_read_atomic, so it's mandatory to read it atomically\n * with cmpxchg8b.\n */\n#ifndef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\tpmdval_t ret;\n\tu32 *tmp = (u32 *)pmdp;\n\n\tret = (pmdval_t) (*tmp);\n\tif (ret) {\n\t\t/*\n\t\t * If the low part is null, we must not read the high part\n\t\t * or we can end up with a partial pmd.\n\t\t */\n\t\tsmp_rmb();\n\t\tret |= ((pmdval_t)*(tmp + 1)) << 32;\n\t}\n\n\treturn (pmd_t) { ret };\n}\n#else /* CONFIG_TRANSPARENT_HUGEPAGE */\nstatic inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\treturn (pmd_t) { atomic64_read((atomic64_t *)pmdp) };\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\nstatic inline void native_set_pte_atomic(pte_t *ptep, pte_t pte)\n{\n\tset_64bit((unsigned long long *)(ptep), native_pte_val(pte));\n}\n\nstatic inline void native_set_pmd(pmd_t *pmdp, pmd_t pmd)\n{\n\tset_64bit((unsigned long long *)(pmdp), native_pmd_val(pmd));\n}\n\nstatic inline void native_set_pud(pud_t *pudp, pud_t pud)\n{\n\tset_64bit((unsigned long long *)(pudp), native_pud_val(pud));\n}\n\n/*\n * For PTEs and PDEs, we must clear the P-bit first when clearing a page table\n * entry, so clear the bottom half first and enforce ordering with a compiler\n * barrier.\n */\nstatic inline void native_pte_clear(struct mm_struct *mm, unsigned long addr,\n\t\t\t\t    pte_t *ptep)\n{\n\tptep->pte_low = 0;\n\tsmp_wmb();\n\tptep->pte_high = 0;\n}\n\nstatic inline void native_pmd_clear(pmd_t *pmd)\n{\n\tu32 *tmp = (u32 *)pmd;\n\t*tmp = 0;\n\tsmp_wmb();\n\t*(tmp + 1) = 0;\n}\n\nstatic inline void pud_clear(pud_t *pudp)\n{\n\tset_pud(pudp, __pud(0));\n\n\t/*\n\t * According to Intel App note \"TLBs, Paging-Structure Caches,\n\t * and Their Invalidation\", April 2007, document 317080-001,\n\t * section 8.1: in PAE mode we explicitly have to flush the\n\t * TLB via cr3 if the top-level pgd is changed...\n\t *\n\t * Currently all places where pud_clear() is called either have\n\t * flush_tlb_mm() followed or don't need TLB flush (x86_64 code or\n\t * pud_clear_bad()), so we don't need TLB flush here.\n\t */\n}\n\n#ifdef CONFIG_SMP\nstatic inline pte_t native_ptep_get_and_clear(pte_t *ptep)\n{\n\tpte_t res;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\tres.pte_low = xchg(&ptep->pte_low, 0);\n\tres.pte_high = ptep->pte_high;\n\tptep->pte_high = 0;\n\n\treturn res;\n}\n#else\n#define native_ptep_get_and_clear(xp) native_local_ptep_get_and_clear(xp)\n#endif\n\n#ifdef CONFIG_SMP\nunion split_pmd {\n\tstruct {\n\t\tu32 pmd_low;\n\t\tu32 pmd_high;\n\t};\n\tpmd_t pmd;\n};\nstatic inline pmd_t native_pmdp_get_and_clear(pmd_t *pmdp)\n{\n\tunion split_pmd res, *orig = (union split_pmd *)pmdp;\n\n\t/* xchg acts as a barrier before setting of the high bits */\n\tres.pmd_low = xchg(&orig->pmd_low, 0);\n\tres.pmd_high = orig->pmd_high;\n\torig->pmd_high = 0;\n\n\treturn res.pmd;\n}\n#else\n#define native_pmdp_get_and_clear(xp) native_local_pmdp_get_and_clear(xp)\n#endif\n\n/*\n * Bits 0, 6 and 7 are taken in the low part of the pte,\n * put the 32 bits of offset into the high part.\n */\n#define pte_to_pgoff(pte) ((pte).pte_high)\n#define pgoff_to_pte(off)\t\t\t\t\t\t\\\n\t((pte_t) { { .pte_low = _PAGE_FILE, .pte_high = (off) } })\n#define PTE_FILE_MAX_BITS       32\n\n/* Encode and de-code a swap entry */\n#define MAX_SWAPFILES_CHECK() BUILD_BUG_ON(MAX_SWAPFILES_SHIFT > 5)\n#define __swp_type(x)\t\t\t(((x).val) & 0x1f)\n#define __swp_offset(x)\t\t\t((x).val >> 5)\n#define __swp_entry(type, offset)\t((swp_entry_t){(type) | (offset) << 5})\n#define __pte_to_swp_entry(pte)\t\t((swp_entry_t){ (pte).pte_high })\n#define __swp_entry_to_pte(x)\t\t((pte_t){ { .pte_high = (x).val } })\n\n#endif /* _ASM_X86_PGTABLE_3LEVEL_H */\n", "#ifndef _ASM_GENERIC_PGTABLE_H\n#define _ASM_GENERIC_PGTABLE_H\n\n#ifndef __ASSEMBLY__\n#ifdef CONFIG_MMU\n\n#include <linux/mm_types.h>\n#include <linux/bug.h>\n\n#ifndef __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS\nextern int ptep_set_access_flags(struct vm_area_struct *vma,\n\t\t\t\t unsigned long address, pte_t *ptep,\n\t\t\t\t pte_t entry, int dirty);\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_SET_ACCESS_FLAGS\nextern int pmdp_set_access_flags(struct vm_area_struct *vma,\n\t\t\t\t unsigned long address, pmd_t *pmdp,\n\t\t\t\t pmd_t entry, int dirty);\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG\nstatic inline int ptep_test_and_clear_young(struct vm_area_struct *vma,\n\t\t\t\t\t    unsigned long address,\n\t\t\t\t\t    pte_t *ptep)\n{\n\tpte_t pte = *ptep;\n\tint r = 1;\n\tif (!pte_young(pte))\n\t\tr = 0;\n\telse\n\t\tset_pte_at(vma->vm_mm, address, ptep, pte_mkold(pte));\n\treturn r;\n}\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_TEST_AND_CLEAR_YOUNG\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline int pmdp_test_and_clear_young(struct vm_area_struct *vma,\n\t\t\t\t\t    unsigned long address,\n\t\t\t\t\t    pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\tint r = 1;\n\tif (!pmd_young(pmd))\n\t\tr = 0;\n\telse\n\t\tset_pmd_at(vma->vm_mm, address, pmdp, pmd_mkold(pmd));\n\treturn r;\n}\n#else /* CONFIG_TRANSPARENT_HUGEPAGE */\nstatic inline int pmdp_test_and_clear_young(struct vm_area_struct *vma,\n\t\t\t\t\t    unsigned long address,\n\t\t\t\t\t    pmd_t *pmdp)\n{\n\tBUG();\n\treturn 0;\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_CLEAR_YOUNG_FLUSH\nint ptep_clear_flush_young(struct vm_area_struct *vma,\n\t\t\t   unsigned long address, pte_t *ptep);\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_CLEAR_YOUNG_FLUSH\nint pmdp_clear_flush_young(struct vm_area_struct *vma,\n\t\t\t   unsigned long address, pmd_t *pmdp);\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_GET_AND_CLEAR\nstatic inline pte_t ptep_get_and_clear(struct mm_struct *mm,\n\t\t\t\t       unsigned long address,\n\t\t\t\t       pte_t *ptep)\n{\n\tpte_t pte = *ptep;\n\tpte_clear(mm, address, ptep);\n\treturn pte;\n}\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_GET_AND_CLEAR\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline pmd_t pmdp_get_and_clear(struct mm_struct *mm,\n\t\t\t\t       unsigned long address,\n\t\t\t\t       pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\tpmd_clear(mm, address, pmdp);\n\treturn pmd;\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_GET_AND_CLEAR_FULL\nstatic inline pte_t ptep_get_and_clear_full(struct mm_struct *mm,\n\t\t\t\t\t    unsigned long address, pte_t *ptep,\n\t\t\t\t\t    int full)\n{\n\tpte_t pte;\n\tpte = ptep_get_and_clear(mm, address, ptep);\n\treturn pte;\n}\n#endif\n\n/*\n * Some architectures may be able to avoid expensive synchronization\n * primitives when modifications are made to PTE's which are already\n * not present, or in the process of an address space destruction.\n */\n#ifndef __HAVE_ARCH_PTE_CLEAR_NOT_PRESENT_FULL\nstatic inline void pte_clear_not_present_full(struct mm_struct *mm,\n\t\t\t\t\t      unsigned long address,\n\t\t\t\t\t      pte_t *ptep,\n\t\t\t\t\t      int full)\n{\n\tpte_clear(mm, address, ptep);\n}\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_CLEAR_FLUSH\nextern pte_t ptep_clear_flush(struct vm_area_struct *vma,\n\t\t\t      unsigned long address,\n\t\t\t      pte_t *ptep);\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_CLEAR_FLUSH\nextern pmd_t pmdp_clear_flush(struct vm_area_struct *vma,\n\t\t\t      unsigned long address,\n\t\t\t      pmd_t *pmdp);\n#endif\n\n#ifndef __HAVE_ARCH_PTEP_SET_WRPROTECT\nstruct mm_struct;\nstatic inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long address, pte_t *ptep)\n{\n\tpte_t old_pte = *ptep;\n\tset_pte_at(mm, address, ptep, pte_wrprotect(old_pte));\n}\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_SET_WRPROTECT\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline void pmdp_set_wrprotect(struct mm_struct *mm,\n\t\t\t\t      unsigned long address, pmd_t *pmdp)\n{\n\tpmd_t old_pmd = *pmdp;\n\tset_pmd_at(mm, address, pmdp, pmd_wrprotect(old_pmd));\n}\n#else /* CONFIG_TRANSPARENT_HUGEPAGE */\nstatic inline void pmdp_set_wrprotect(struct mm_struct *mm,\n\t\t\t\t      unsigned long address, pmd_t *pmdp)\n{\n\tBUG();\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n#endif\n\n#ifndef __HAVE_ARCH_PMDP_SPLITTING_FLUSH\nextern void pmdp_splitting_flush(struct vm_area_struct *vma,\n\t\t\t\t unsigned long address, pmd_t *pmdp);\n#endif\n\n#ifndef __HAVE_ARCH_PTE_SAME\nstatic inline int pte_same(pte_t pte_a, pte_t pte_b)\n{\n\treturn pte_val(pte_a) == pte_val(pte_b);\n}\n#endif\n\n#ifndef __HAVE_ARCH_PMD_SAME\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline int pmd_same(pmd_t pmd_a, pmd_t pmd_b)\n{\n\treturn pmd_val(pmd_a) == pmd_val(pmd_b);\n}\n#else /* CONFIG_TRANSPARENT_HUGEPAGE */\nstatic inline int pmd_same(pmd_t pmd_a, pmd_t pmd_b)\n{\n\tBUG();\n\treturn 0;\n}\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n#endif\n\n#ifndef __HAVE_ARCH_PAGE_TEST_AND_CLEAR_DIRTY\n#define page_test_and_clear_dirty(pfn, mapped)\t(0)\n#endif\n\n#ifndef __HAVE_ARCH_PAGE_TEST_AND_CLEAR_DIRTY\n#define pte_maybe_dirty(pte)\t\tpte_dirty(pte)\n#else\n#define pte_maybe_dirty(pte)\t\t(1)\n#endif\n\n#ifndef __HAVE_ARCH_PAGE_TEST_AND_CLEAR_YOUNG\n#define page_test_and_clear_young(pfn) (0)\n#endif\n\n#ifndef __HAVE_ARCH_PGD_OFFSET_GATE\n#define pgd_offset_gate(mm, addr)\tpgd_offset(mm, addr)\n#endif\n\n#ifndef __HAVE_ARCH_MOVE_PTE\n#define move_pte(pte, prot, old_addr, new_addr)\t(pte)\n#endif\n\n#ifndef flush_tlb_fix_spurious_fault\n#define flush_tlb_fix_spurious_fault(vma, address) flush_tlb_page(vma, address)\n#endif\n\n#ifndef pgprot_noncached\n#define pgprot_noncached(prot)\t(prot)\n#endif\n\n#ifndef pgprot_writecombine\n#define pgprot_writecombine pgprot_noncached\n#endif\n\n/*\n * When walking page tables, get the address of the next boundary,\n * or the end address of the range if that comes earlier.  Although no\n * vma end wraps to 0, rounded up __boundary may wrap to 0 throughout.\n */\n\n#define pgd_addr_end(addr, end)\t\t\t\t\t\t\\\n({\tunsigned long __boundary = ((addr) + PGDIR_SIZE) & PGDIR_MASK;\t\\\n\t(__boundary - 1 < (end) - 1)? __boundary: (end);\t\t\\\n})\n\n#ifndef pud_addr_end\n#define pud_addr_end(addr, end)\t\t\t\t\t\t\\\n({\tunsigned long __boundary = ((addr) + PUD_SIZE) & PUD_MASK;\t\\\n\t(__boundary - 1 < (end) - 1)? __boundary: (end);\t\t\\\n})\n#endif\n\n#ifndef pmd_addr_end\n#define pmd_addr_end(addr, end)\t\t\t\t\t\t\\\n({\tunsigned long __boundary = ((addr) + PMD_SIZE) & PMD_MASK;\t\\\n\t(__boundary - 1 < (end) - 1)? __boundary: (end);\t\t\\\n})\n#endif\n\n/*\n * When walking page tables, we usually want to skip any p?d_none entries;\n * and any p?d_bad entries - reporting the error before resetting to none.\n * Do the tests inline, but report and clear the bad entry in mm/memory.c.\n */\nvoid pgd_clear_bad(pgd_t *);\nvoid pud_clear_bad(pud_t *);\nvoid pmd_clear_bad(pmd_t *);\n\nstatic inline int pgd_none_or_clear_bad(pgd_t *pgd)\n{\n\tif (pgd_none(*pgd))\n\t\treturn 1;\n\tif (unlikely(pgd_bad(*pgd))) {\n\t\tpgd_clear_bad(pgd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int pud_none_or_clear_bad(pud_t *pud)\n{\n\tif (pud_none(*pud))\n\t\treturn 1;\n\tif (unlikely(pud_bad(*pud))) {\n\t\tpud_clear_bad(pud);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int pmd_none_or_clear_bad(pmd_t *pmd)\n{\n\tif (pmd_none(*pmd))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(*pmd))) {\n\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline pte_t __ptep_modify_prot_start(struct mm_struct *mm,\n\t\t\t\t\t     unsigned long addr,\n\t\t\t\t\t     pte_t *ptep)\n{\n\t/*\n\t * Get the current pte state, but zero it out to make it\n\t * non-present, preventing the hardware from asynchronously\n\t * updating it.\n\t */\n\treturn ptep_get_and_clear(mm, addr, ptep);\n}\n\nstatic inline void __ptep_modify_prot_commit(struct mm_struct *mm,\n\t\t\t\t\t     unsigned long addr,\n\t\t\t\t\t     pte_t *ptep, pte_t pte)\n{\n\t/*\n\t * The pte is non-present, so there's no hardware state to\n\t * preserve.\n\t */\n\tset_pte_at(mm, addr, ptep, pte);\n}\n\n#ifndef __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION\n/*\n * Start a pte protection read-modify-write transaction, which\n * protects against asynchronous hardware modifications to the pte.\n * The intention is not to prevent the hardware from making pte\n * updates, but to prevent any updates it may make from being lost.\n *\n * This does not protect against other software modifications of the\n * pte; the appropriate pte lock must be held over the transation.\n *\n * Note that this interface is intended to be batchable, meaning that\n * ptep_modify_prot_commit may not actually update the pte, but merely\n * queue the update to be done at some later time.  The update must be\n * actually committed before the pte lock is released, however.\n */\nstatic inline pte_t ptep_modify_prot_start(struct mm_struct *mm,\n\t\t\t\t\t   unsigned long addr,\n\t\t\t\t\t   pte_t *ptep)\n{\n\treturn __ptep_modify_prot_start(mm, addr, ptep);\n}\n\n/*\n * Commit an update to a pte, leaving any hardware-controlled bits in\n * the PTE unmodified.\n */\nstatic inline void ptep_modify_prot_commit(struct mm_struct *mm,\n\t\t\t\t\t   unsigned long addr,\n\t\t\t\t\t   pte_t *ptep, pte_t pte)\n{\n\t__ptep_modify_prot_commit(mm, addr, ptep, pte);\n}\n#endif /* __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION */\n#endif /* CONFIG_MMU */\n\n/*\n * A facility to provide lazy MMU batching.  This allows PTE updates and\n * page invalidations to be delayed until a call to leave lazy MMU mode\n * is issued.  Some architectures may benefit from doing this, and it is\n * beneficial for both shadow and direct mode hypervisors, which may batch\n * the PTE updates which happen during this window.  Note that using this\n * interface requires that read hazards be removed from the code.  A read\n * hazard could result in the direct mode hypervisor case, since the actual\n * write to the page tables may not yet have taken place, so reads though\n * a raw PTE pointer after it has been modified are not guaranteed to be\n * up to date.  This mode can only be entered and left under the protection of\n * the page table locks for all page tables which may be modified.  In the UP\n * case, this is required so that preemption is disabled, and in the SMP case,\n * it must synchronize the delayed page table writes properly on other CPUs.\n */\n#ifndef __HAVE_ARCH_ENTER_LAZY_MMU_MODE\n#define arch_enter_lazy_mmu_mode()\tdo {} while (0)\n#define arch_leave_lazy_mmu_mode()\tdo {} while (0)\n#define arch_flush_lazy_mmu_mode()\tdo {} while (0)\n#endif\n\n/*\n * A facility to provide batching of the reload of page tables and\n * other process state with the actual context switch code for\n * paravirtualized guests.  By convention, only one of the batched\n * update (lazy) modes (CPU, MMU) should be active at any given time,\n * entry should never be nested, and entry and exits should always be\n * paired.  This is for sanity of maintaining and reasoning about the\n * kernel code.  In this case, the exit (end of the context switch) is\n * in architecture-specific code, and so doesn't need a generic\n * definition.\n */\n#ifndef __HAVE_ARCH_START_CONTEXT_SWITCH\n#define arch_start_context_switch(prev)\tdo {} while (0)\n#endif\n\n#ifndef __HAVE_PFNMAP_TRACKING\n/*\n * Interface that can be used by architecture code to keep track of\n * memory type of pfn mappings (remap_pfn_range, vm_insert_pfn)\n *\n * track_pfn_vma_new is called when a _new_ pfn mapping is being established\n * for physical range indicated by pfn and size.\n */\nstatic inline int track_pfn_vma_new(struct vm_area_struct *vma, pgprot_t *prot,\n\t\t\t\t\tunsigned long pfn, unsigned long size)\n{\n\treturn 0;\n}\n\n/*\n * Interface that can be used by architecture code to keep track of\n * memory type of pfn mappings (remap_pfn_range, vm_insert_pfn)\n *\n * track_pfn_vma_copy is called when vma that is covering the pfnmap gets\n * copied through copy_page_range().\n */\nstatic inline int track_pfn_vma_copy(struct vm_area_struct *vma)\n{\n\treturn 0;\n}\n\n/*\n * Interface that can be used by architecture code to keep track of\n * memory type of pfn mappings (remap_pfn_range, vm_insert_pfn)\n *\n * untrack_pfn_vma is called while unmapping a pfnmap for a region.\n * untrack can be called for a specific region indicated by pfn and size or\n * can be for the entire vma (in which case size can be zero).\n */\nstatic inline void untrack_pfn_vma(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long pfn, unsigned long size)\n{\n}\n#else\nextern int track_pfn_vma_new(struct vm_area_struct *vma, pgprot_t *prot,\n\t\t\t\tunsigned long pfn, unsigned long size);\nextern int track_pfn_vma_copy(struct vm_area_struct *vma);\nextern void untrack_pfn_vma(struct vm_area_struct *vma, unsigned long pfn,\n\t\t\t\tunsigned long size);\n#endif\n\n#ifdef CONFIG_MMU\n\n#ifndef CONFIG_TRANSPARENT_HUGEPAGE\nstatic inline int pmd_trans_huge(pmd_t pmd)\n{\n\treturn 0;\n}\nstatic inline int pmd_trans_splitting(pmd_t pmd)\n{\n\treturn 0;\n}\n#ifndef __HAVE_ARCH_PMD_WRITE\nstatic inline int pmd_write(pmd_t pmd)\n{\n\tBUG();\n\treturn 0;\n}\n#endif /* __HAVE_ARCH_PMD_WRITE */\n#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n\n#ifndef pmd_read_atomic\nstatic inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\t/*\n\t * Depend on compiler for an atomic pmd read. NOTE: this is\n\t * only going to work, if the pmdval_t isn't larger than\n\t * an unsigned long.\n\t */\n\treturn *pmdp;\n}\n#endif\n\n/*\n * This function is meant to be used by sites walking pagetables with\n * the mmap_sem hold in read mode to protect against MADV_DONTNEED and\n * transhuge page faults. MADV_DONTNEED can convert a transhuge pmd\n * into a null pmd and the transhuge page fault can convert a null pmd\n * into an hugepmd or into a regular pmd (if the hugepage allocation\n * fails). While holding the mmap_sem in read mode the pmd becomes\n * stable and stops changing under us only if it's not null and not a\n * transhuge pmd. When those races occurs and this function makes a\n * difference vs the standard pmd_none_or_clear_bad, the result is\n * undefined so behaving like if the pmd was none is safe (because it\n * can return none anyway). The compiler level barrier() is critically\n * important to compute the two checks atomically on the same pmdval.\n *\n * For 32bit kernels with a 64bit large pmd_t this automatically takes\n * care of reading the pmd atomically to avoid SMP race conditions\n * against pmd_populate() when the mmap_sem is hold for reading by the\n * caller (a special atomic read not done by \"gcc\" as in the generic\n * version above, is also needed when THP is disabled because the page\n * fault can populate the pmd from under us).\n */\nstatic inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n\t/*\n\t * The barrier will stabilize the pmdval in a register or on\n\t * the stack so that it will stop changing under the code.\n\t */\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * This is a noop if Transparent Hugepage Support is not built into\n * the kernel. Otherwise it is equivalent to\n * pmd_none_or_trans_huge_or_clear_bad(), and shall only be called in\n * places that already verified the pmd is not none and they want to\n * walk ptes while holding the mmap sem in read mode (write mode don't\n * need this). If THP is not enabled, the pmd can't go away under the\n * code even if MADV_DONTNEED runs, but if THP is enabled we need to\n * run a pmd_trans_unstable before walking the ptes after\n * split_huge_page_pmd returns (because it may have run when the pmd\n * become null, but then a page fault can map in a THP and not a\n * regular page).\n */\nstatic inline int pmd_trans_unstable(pmd_t *pmd)\n{\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\treturn pmd_none_or_trans_huge_or_clear_bad(pmd);\n#else\n\treturn 0;\n#endif\n}\n\n#endif /* CONFIG_MMU */\n\n#endif /* !__ASSEMBLY__ */\n\n#endif /* _ASM_GENERIC_PGTABLE_H */\n"], "filenames": ["arch/x86/include/asm/pgtable-3level.h", "include/asm-generic/pgtable.h"], "buggy_code_start_loc": [32, 447], "buggy_code_end_loc": [32, 466], "fixing_code_start_loc": [33, 448], "fixing_code_end_loc": [83, 484], "type": "CWE-362", "message": "The Linux kernel before 3.4.5 on the x86 platform, when Physical Address Extension (PAE) is enabled, does not properly use the Page Middle Directory (PMD), which allows local users to cause a denial of service (panic) via a crafted application that triggers a race condition.", "other": {"cve": {"id": "CVE-2012-2373", "sourceIdentifier": "secalert@redhat.com", "published": "2012-08-09T10:29:46.917", "lastModified": "2023-02-13T00:24:52.950", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Linux kernel before 3.4.5 on the x86 platform, when Physical Address Extension (PAE) is enabled, does not properly use the Page Middle Directory (PMD), which allows local users to cause a denial of service (panic) via a crafted application that triggers a race condition."}, {"lang": "es", "value": "El kernel de Linux anterior a v3.4.5 en la plataforma x86, cuando Physical Address Extension (PAE) est\u00e1 activada, no utiliza correctamente Page Middle Directory (PMD), permitiendo a usuarios locales causar una denegaci\u00f3n de servicio a trav\u00e9s de una aplicaci\u00f3n especialmente dise\u00f1ada que lanza una condici\u00f3n de carrera"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:x86:*", "versionEndIncluding": "3.4.4", "matchCriteriaId": "41A75DAA-62E7-4616-B987-B7FB45E56709"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:x86:*", "matchCriteriaId": "8C3D9C66-933A-469E-9073-75015A8AD17D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:x86:*", "matchCriteriaId": "C92F29A0-DEFF-49E4-AE86-5DBDAD51C677"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:x86:*", "matchCriteriaId": "5690A703-390D-4D8A-9258-2F47116DAB4F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:x86:*", "matchCriteriaId": "AB1EDDA7-15AF-4B45-A931-DFCBB1EEB701"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:x86:*", "matchCriteriaId": "952FE0DC-B2ED-4080-BF29-A2C265E83FEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:x86:*", "matchCriteriaId": "1CE7ABDB-6572-40E8-B952-CBE52C999858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:x86:*", "matchCriteriaId": "0F417186-D1ED-4A31-92B2-83DEDA1AF272"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:x86:*", "matchCriteriaId": "3D4FCFAE-918C-4886-9A17-08A5B94D35F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:x86:*", "matchCriteriaId": "830D2914-C9FE-406F-AFCE-7A04BB9E2896"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:x86:*", "matchCriteriaId": "F4B791B5-2EB5-403A-90CC-B219F6277D1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:x86:*", "matchCriteriaId": "2BA5F34D-7490-4B2B-A7E6-8450F9C1FC31"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=26c191788f18129af0eb32a358cdaea0c7479626", "source": "secalert@redhat.com"}, {"url": "http://marc.info/?l=bugtraq&m=139447903326211&w=2", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-0743.html", "source": "secalert@redhat.com"}, {"url": "http://ubuntu.com/usn/usn-1529-1", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.4.5", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/05/18/11", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=822821", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/26c191788f18129af0eb32a358cdaea0c7479626", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/26c191788f18129af0eb32a358cdaea0c7479626"}}