{"buggy_code": ["/*\n\nCopyright (c) 2011, 2012, Simon Howard\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n\n#include \"lha_endian.h\"\n#include \"lha_file_header.h\"\n#include \"ext_header.h\"\n#include \"crc16.h\"\n\n#define COMMON_HEADER_LEN 22 /* bytes */\n\n// Minimum length of a level 0 header (with zero-length filename).\n#define LEVEL_0_MIN_HEADER_LEN 22 /* bytes */\n\n// Minimum length of a level 1 base header (with zero-length filename).\n#define LEVEL_1_MIN_HEADER_LEN 25 /* bytes */\n\n// Length of a level 2 base header.\n#define LEVEL_2_HEADER_LEN 26 /* bytes */\n\n// Length of a level 3 base header.\n#define LEVEL_3_HEADER_LEN 32 /* bytes */\n\n// Maximum length of a level 3 header (including extended headers).\n#define LEVEL_3_MAX_HEADER_LEN (1024 * 1024) /* 1 MB */\n\n// Length of a level 0 Unix extended area.\n#define LEVEL_0_UNIX_EXTENDED_LEN 12 /* bytes */\n\n// Length of a level 0 OS-9 extended area.\n#define LEVEL_0_OS9_EXTENDED_LEN 22 /* bytes */\n\n#define RAW_DATA(hdr_ptr, off)  ((*hdr_ptr)->raw_data[off])\n#define RAW_DATA_LEN(hdr_ptr)   ((*hdr_ptr)->raw_data_len)\n\nchar *lha_file_header_full_path(LHAFileHeader *header)\n{\n\tchar *path;\n\tchar *filename;\n\tchar *result;\n\n\tif (header->path != NULL) {\n\t\tpath = header->path;\n\t} else {\n\t\tpath = \"\";\n\t}\n\n\tif (header->filename != NULL) {\n\t\tfilename = header->filename;\n\t} else {\n\t\tfilename = \"\";\n\t}\n\n\tresult = malloc(strlen(path) + strlen(filename) + 1);\n\n\tif (result == NULL) {\n\t\treturn NULL;\n\t}\n\n\tsprintf(result, \"%s%s\", path, filename);\n\n\treturn result;\n}\n\n/**\n * Given a file header with the filename set, split it into separate\n * path and filename components, if necessary.\n *\n * @param header         Point to the file header structure.\n * @return               Non-zero for success, or zero for failure.\n */\n\nstatic int split_header_filename(LHAFileHeader *header)\n{\n\tchar *sep;\n\tchar *new_filename;\n\n\t// Is there a directory separator in the path?  If so, we need to\n\t// split into directory name and filename.\n\n\tsep = strrchr(header->filename, '/');\n\n\tif (sep != NULL) {\n\t\tnew_filename = strdup(sep + 1);\n\n\t\tif (new_filename == NULL) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t*(sep + 1) = '\\0';\n\t\theader->path = header->filename;\n\t\theader->filename = new_filename;\n\t}\n\n\treturn 1;\n}\n\n// Perform checksum of header contents.\n\nstatic int check_l0_checksum(uint8_t *header, size_t header_len, size_t csum)\n{\n\tunsigned int result;\n\tunsigned int i;\n\n\tresult = 0;\n\n\tfor (i = 0; i < header_len; ++i) {\n\t\tresult += header[i];\n\t}\n\n\treturn (result & 0xff) == csum;\n}\n\n// Perform full-header CRC check, based on CRC from \"common\" extended header.\n\nstatic int check_common_crc(LHAFileHeader *header)\n{\n\tuint16_t crc;\n\n\tcrc = 0;\n\tlha_crc16_buf(&crc, header->raw_data, header->raw_data_len);\n\n\treturn crc == header->common_crc;\n}\n\n// Decode MS-DOS timestamp.\n\nstatic unsigned int decode_ftime(uint8_t *buf)\n{\n\tint raw;\n\tstruct tm datetime;\n\n\traw = (int) lha_decode_uint32(buf);\n\n\tif (raw == 0) {\n\t\treturn 0;\n\t}\n\n\t// Deconstruct the contents of the MS-DOS time value and populate the\n\t// 'datetime' structure. Note that 'mktime' generates a timestamp for\n\t// the local time zone: this is unfortunate, but probably the best\n\t// that can be done, due to the limited data stored in MS-DOS time\n\t// values.\n\n\tmemset(&datetime, 0, sizeof(struct tm));\n\n\tdatetime.tm_sec = (raw << 1) & 0x3e;\n\tdatetime.tm_min = (raw >> 5) & 0x3f;\n\tdatetime.tm_hour = (raw >> 11) & 0x1f;\n\tdatetime.tm_mday = (raw >> 16) & 0x1f;\n\tdatetime.tm_mon = ((raw >> 21) & 0xf) - 1;\n\tdatetime.tm_year = 80 + ((raw >> 25) & 0x7f);\n\tdatetime.tm_wday = 0;\n\tdatetime.tm_yday = 0;\n\tdatetime.tm_isdst = -1;\n\n\treturn (unsigned int) mktime(&datetime);\n}\n\n// MS-DOS archives (and archives from similar systems) may have paths and\n// filenames that are in all-caps. Detect these and convert them to\n// lower-case.\n\nstatic void fix_msdos_allcaps(LHAFileHeader *header)\n{\n\tunsigned int i;\n\tint is_allcaps;\n\n\t// Check both path and filename to see if there are any lower-case\n\t// characters.\n\n\tis_allcaps = 1;\n\n\tif (header->path != NULL) {\n\t\tfor (i = 0; header->path[i] != '\\0'; ++i) {\n\t\t\tif (islower((unsigned) header->path[i])) {\n\t\t\t\tis_allcaps = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_allcaps && header->filename != NULL) {\n\t\tfor (i = 0; header->filename[i] != '\\0'; ++i) {\n\t\t\tif (islower((unsigned) header->filename[i])) {\n\t\t\t\tis_allcaps = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If both are all-caps, convert them all to lower-case.\n\n\tif (is_allcaps) {\n\t\tif (header->path != NULL) {\n\t\t\tfor (i = 0; header->path[i] != '\\0'; ++i) {\n\t\t\t\theader->path[i]\n\t\t\t\t    = tolower((unsigned) header->path[i]);\n\t\t\t}\n\t\t}\n\t\tif (header->filename != NULL) {\n\t\t\tfor (i = 0; header->filename[i] != '\\0'; ++i) {\n\t\t\t\theader->filename[i]\n\t\t\t\t    = tolower((unsigned) header->filename[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Process the OS-9 permissions field and translate into the equivalent\n// Unix permissions.\n\nstatic void os9_to_unix_permissions(LHAFileHeader *header)\n{\n\tunsigned int or, ow, oe, pr, pw, pe, d;\n\n\t// Translate into equivalent Unix permissions. OS-9 just has\n\t// owner and public, so double up public for the owner field.\n\n\tor = (header->os9_perms & 0x01) != 0;\n\tow = (header->os9_perms & 0x02) != 0;\n\toe = (header->os9_perms & 0x04) != 0;\n\tpr = (header->os9_perms & 0x08) != 0;\n\tpw = (header->os9_perms & 0x10) != 0;\n\tpe = (header->os9_perms & 0x20) != 0;\n\td = (header->os9_perms & 0x80) != 0;\n\n\theader->extra_flags |= LHA_FILE_UNIX_PERMS;\n\theader->unix_perms = (d << 14)\n\t                   | (or << 8) | (ow << 7) | (oe << 6)  // owner\n\t                   | (pr << 5) | (pw << 4) | (pe << 3)  // group\n\t                   | (pr << 2) | (pw << 1) | (pe << 0); // everyone\n}\n\n// Parse a Unix symbolic link. These are stored in the format:\n// filename = symlink|target\n\nstatic int parse_symlink(LHAFileHeader *header)\n{\n\tchar *fullpath;\n\tchar *p;\n\n\t// Although the format is always the same, some files have\n\t// symlink headers where the path is split between the path\n\t// and filename headers. For example:\n\t//    path = etc|../../\n\t//    filename = etc\n\n\tfullpath = lha_file_header_full_path(header);\n\n\tif (fullpath == NULL) {\n\t\treturn 0;\n\t}\n\n\tp = strchr(fullpath, '|');\n\n\tif (p == NULL) {\n\t\tfree(fullpath);\n\t\treturn 0;\n\t}\n\n\theader->symlink_target = strdup(p + 1);\n\n\tif (header->symlink_target == NULL) {\n\t\tfree(fullpath);\n\t\treturn 0;\n\t}\n\n\t// Cut the string in half at the separator. Keep the left side\n\t// as the value for filename.\n\n\t*p = '\\0';\n\n\tfree(header->path);\n\tfree(header->filename);\n\theader->path = NULL;\n\theader->filename = fullpath;\n\n\t// Having joined path and filename together during processing,\n\t// we now have the opposite problem: header->filename might\n\t// contain a full path rather than just a filename. Split back\n\t// into two again.\n\n\treturn split_header_filename(header);\n}\n\n// Decode the path field in the header.\n\nstatic int process_level0_path(LHAFileHeader *header, uint8_t *data,\n                               size_t data_len)\n{\n\tunsigned int i;\n\n\t// Zero-length filename probably means that this is a directory\n\t// entry. Leave the filename field as NULL - this makes us\n\t// consistent with level 2/3 headers.\n\n\tif (data_len == 0) {\n\t\treturn 1;\n\t}\n\n\theader->filename = malloc(data_len + 1);\n\n\tif (header->filename == NULL) {\n\t\treturn 0;\n\t}\n\n\tmemcpy(header->filename, data, data_len);\n\theader->filename[data_len] = '\\0';\n\n\t// Convert MS-DOS path separators to Unix path separators.\n\n\tfor (i = 0; i < data_len; ++i) {\n\t\tif (header->filename[i] == '\\\\') {\n\t\t\theader->filename[i] = '/';\n\t\t}\n\t}\n\n\treturn split_header_filename(header);\n}\n\n// Read some more data from the input stream, extending the raw_data\n// array (and the size of the header).\n\nstatic uint8_t *extend_raw_data(LHAFileHeader **header,\n                                LHAInputStream *stream,\n                                size_t nbytes)\n{\n\tLHAFileHeader *new_header;\n\tsize_t new_raw_len;\n\tuint8_t *result;\n\n\t// Reallocate the header and raw_data area to be larger.\n\n\tnew_raw_len = RAW_DATA_LEN(header) + nbytes;\n\tnew_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len);\n\n\tif (new_header == NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Update the header pointer to point to the new area.\n\n\t*header = new_header;\n\tnew_header->raw_data = (uint8_t *) (new_header + 1);\n\tresult = new_header->raw_data + new_header->raw_data_len;\n\n\t// Read data from stream into new area.\n\n\tif (!lha_input_stream_read(stream, result, nbytes)) {\n\t\treturn NULL;\n\t}\n\n\tnew_header->raw_data_len = new_raw_len;\n\n\treturn result;\n}\n\n// Starting at the specified offset in the raw_data array, walk\n// through the list of extended headers and parse them.\n\nstatic int decode_extended_headers(LHAFileHeader **header,\n                                   unsigned int offset)\n{\n\tunsigned int field_size;\n\tuint8_t *ext_header;\n\tsize_t ext_header_len;\n\tsize_t available_length;\n\n\t// Level 3 headers use 32-bit length fields; all others use\n\t// 16-bit fields.\n\n\tif ((*header)->header_level == 3) {\n\t\tfield_size = 4;\n\t} else {\n\t\tfield_size = 2;\n\t}\n\n\tavailable_length = RAW_DATA_LEN(header) - offset - field_size;\n\n\twhile (offset <= RAW_DATA_LEN(header) - field_size) {\n\t\text_header = &RAW_DATA(header, offset + field_size);\n\n\t\tif (field_size == 4) {\n\t\t\text_header_len\n\t\t\t    = lha_decode_uint32(&RAW_DATA(header, offset));\n\t\t} else {\n\t\t\text_header_len\n\t\t\t    = lha_decode_uint16(&RAW_DATA(header, offset));\n\t\t}\n\n\t\t// Header length zero indicates end of chain. Otherwise, sanity\n\t\t// check the header length is valid.\n\n\t\tif (ext_header_len == 0) {\n\t\t\tbreak;\n\t\t} else if (ext_header_len < field_size + 1\n\t\t        || ext_header_len > available_length) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Process header:\n\n\t\tlha_ext_header_decode(*header, ext_header[0], ext_header + 1,\n\t\t                      ext_header_len - field_size - 1);\n\n\t\t// Advance to next header.\n\n\t\toffset += ext_header_len;\n\t\tavailable_length -= ext_header_len;\n\t}\n\n\treturn 1;\n}\n\nstatic int read_next_ext_header(LHAFileHeader **header,\n                                LHAInputStream *stream,\n                                uint8_t **ext_header,\n                                size_t *ext_header_len)\n{\n\t// Last two bytes of the header raw data contain the size\n\t// of the next header.\n\n\t*ext_header_len\n\t    = lha_decode_uint16(&RAW_DATA(header, RAW_DATA_LEN(header) - 2));\n\n\t// No more headers?\n\n\tif (*ext_header_len == 0) {\n\t\t*ext_header = NULL;\n\t\treturn 1;\n\t}\n\n\t*ext_header = extend_raw_data(header, stream, *ext_header_len);\n\n\treturn *ext_header != NULL;\n}\n\n// Read extended headers for a level 1 header, extending the\n// raw_data block to include them.\n\nstatic int read_l1_extended_headers(LHAFileHeader **header,\n                                    LHAInputStream *stream)\n{\n\tuint8_t *ext_header;\n\tsize_t ext_header_len;\n\n\tfor (;;) {\n\t\t// Try to read the next header.\n\n\t\tif (!read_next_ext_header(header, stream,\n\t\t                          &ext_header, &ext_header_len)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Last header?\n\n\t\tif (ext_header_len == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// For backwards compatibility with level 0 headers,\n\t\t// the compressed length field is actually \"compressed\n\t\t// length + length of all extended headers\":\n\n\t\tif ((*header)->compressed_length < ext_header_len) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t(*header)->compressed_length -= ext_header_len;\n\n\t\t// Must be at least 3 bytes - 1 byte header type\n\t\t// + 2 bytes for next header length\n\n\t\tif (ext_header_len < 3) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n// Process a level 0 Unix extended area.\n\nstatic void process_level0_unix_area(LHAFileHeader *header,\n                                     uint8_t *data, size_t data_len)\n{\n\t// A typical Unix extended area:\n\t//\n\t// 00000000  55 00 00 3b 3d 4b 80 81  e8 03 e8 03\n\n\t// Sanity check.\n\n\tif (data_len < LEVEL_0_UNIX_EXTENDED_LEN || data[1] != 0x00) {\n\t\treturn;\n\t}\n\n\t// OS-9/68k generates an extended area that is broadly compatible\n\t// with the Unix one.\n\n\t// Fill in the header fields from the data from the extended area.\n\t// There's one minor point to note here: OS-9/68k LHA includes the\n\t// timestamp twice - I have no idea why. In order to support both\n\t// variants, read the end fields from the end of the extended area.\n\n\theader->os_type = data[0];\n\theader->timestamp = lha_decode_uint32(data + 2);\n\n\theader->unix_perms = lha_decode_uint16(data + data_len - 6);\n\theader->unix_uid = lha_decode_uint16(data + data_len - 4);\n\theader->unix_gid = lha_decode_uint16(data + data_len - 2);\n\n\theader->extra_flags |= LHA_FILE_UNIX_PERMS | LHA_FILE_UNIX_UID_GID;\n}\n\n// Process a level 0 OS-9 extended area.\n\nstatic void process_level0_os9_area(LHAFileHeader *header,\n                                    uint8_t *data, size_t data_len)\n{\n\t// A typical OS-9 extended area:\n\t//\n\t// 00000000  39 13 00 00 c3 16 00 0f  00 cc 18 07 09 03 01 16\n\t// 00000010  00 13 00 00 00 00\n\n\t// Sanity checks:\n\n\tif (data_len < LEVEL_0_OS9_EXTENDED_LEN\n\t || data[9] != 0xcc || data[1] != data[17] || data[2] != data[18]) {\n\t\treturn;\n\t}\n\n\t// The contents resemble the contents of the OS-9 extended header.\n\t// We just want the permissions field.\n\n\theader->os_type = LHA_OS_TYPE_OS9;\n\theader->os9_perms = lha_decode_uint16(data + 1);\n\theader->extra_flags |= LHA_FILE_OS9_PERMS;\n}\n\n// Handling for level 0 extended areas.\n\nstatic void process_level0_extended_area(LHAFileHeader *header,\n                                         uint8_t *data, size_t data_len)\n{\n\t// PMarc archives can include comments that are stored in the\n\t// extended area. It is possible that this could conflict with\n\t// the logic below, so specifically exclude them.\n\n\tif (!strncmp(header->compress_method, \"-pm\", 3)) {\n\t\treturn;\n\t}\n\n\t// Different tools include different extended areas. Try to\n\t// identify which tool generated this one, based on the first\n\t// byte.\n\n\tswitch (data[0]) {\n\t\tcase LHA_OS_TYPE_UNIX:\n\t\tcase LHA_OS_TYPE_OS9_68K:\n\t\t\tprocess_level0_unix_area(header, data, data_len);\n\t\t\tbreak;\n\n\t\tcase LHA_OS_TYPE_OS9:\n\t\t\tprocess_level0_os9_area(header, data, data_len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n\n// Decode a level 0 or 1 header.\n\nstatic int decode_level0_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tuint8_t header_len;\n\tuint8_t header_csum;\n\tsize_t path_len;\n\tsize_t min_len;\n\n\theader_len = RAW_DATA(header, 0);\n\theader_csum = RAW_DATA(header, 1);\n\n\t// Sanity check header length.  This is the minimum header length\n\t// for a header that has a zero-length path.\n\n\tswitch ((*header)->header_level) {\n\t\tcase 0:\n\t\t\tmin_len = LEVEL_0_MIN_HEADER_LEN;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmin_len = LEVEL_1_MIN_HEADER_LEN;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\n\tif (header_len < min_len) {\n\t\treturn 0;\n\t}\n\n\t// We only have a partial header so far. Read the full header.\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len + 2 - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Checksum the header.\n\n\tif (!check_l0_checksum(&RAW_DATA(header, 2),\n\t                       RAW_DATA_LEN(header) - 2,\n\t                       header_csum)) {\n\t\treturn 0;\n\t}\n\n\t// Compression method:\n\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\n\t// File lengths:\n\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\n\t// Timestamp:\n\n\t(*header)->timestamp = decode_ftime(&RAW_DATA(header, 15));\n\n\t// Read path.  Check path length field - is the header long enough\n\t// to hold this full path?\n\n\tpath_len = RAW_DATA(header, 21);\n\n\tif (min_len + path_len > header_len) {\n\t\treturn 0;\n\t}\n\n\t// OS type?\n\n\tif ((*header)->header_level == 0) {\n\t\t(*header)->os_type = LHA_OS_TYPE_UNKNOWN;\n\t} else {\n\t\t(*header)->os_type = RAW_DATA(header, 24 + path_len);\n\t}\n\n\t// Read filename field:\n\n\tif (!process_level0_path(*header, &RAW_DATA(header, 22), path_len)) {\n\t\treturn 0;\n\t}\n\n\t// CRC field.\n\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 22 + path_len));\n\n\t// Level 0 headers can contain extended data through different schemes\n\t// to the extended header system used in level 1+.\n\n\tif ((*header)->header_level == 0\n\t && header_len > LEVEL_0_MIN_HEADER_LEN + path_len) {\n\t\tprocess_level0_extended_area(*header,\n\t\t  &RAW_DATA(header, LEVEL_0_MIN_HEADER_LEN + 2 + path_len),\n\t\t  header_len - LEVEL_0_MIN_HEADER_LEN - path_len);\n\t}\n\n\treturn 1;\n}\n\nstatic int decode_level1_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int ext_header_start;\n\n\tif (!decode_level0_header(header, stream)) {\n\t\treturn 0;\n\t}\n\n\t// Level 1 headers can have extended headers, so parse them.\n\n\text_header_start = RAW_DATA_LEN(header) - 2;\n\n\tif (!read_l1_extended_headers(header, stream)\n\t || !decode_extended_headers(header, ext_header_start)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int decode_level2_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\n\theader_len = lha_decode_uint16(&RAW_DATA(header, 0));\n\n\tif (header_len < LEVEL_2_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\n\t// Read the full header.\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Compression method:\n\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\n\t// File lengths:\n\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\n\t// Timestamp. Unlike level 0/1, this is a Unix-style timestamp.\n\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\n\t// CRC.\n\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\n\t// OS type:\n\n\t(*header)->os_type = RAW_DATA(header, 23);\n\n\t// LHA for OS-9/68k generates broken level 2 archives: the header\n\t// length field is the length of the remainder of the header, not\n\t// the complete header length. As a result it's two bytes too\n\t// short. We can use the OS type field to detect these archives\n\t// and compensate.\n\n\tif ((*header)->os_type == LHA_OS_TYPE_OS9_68K) {\n\t\tif (!extend_raw_data(header, stream, 2)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!decode_extended_headers(header, 24)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\n\t// The first field at the start of a level 3 header is supposed to\n\t// indicate word size, with the idea being that the header format\n\t// can be extended beyond 32-bit words in the future. In practise,\n\t// nothing supports anything other than 32-bit (4 bytes), and neither\n\t// do we.\n\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\n\t// Read the full header.\n\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Read the header length field (including extended headers), and\n\t// extend to this full length. Because this is a 32-bit value,\n\t// we must place a sensible limit on the amount of data that will\n\t// be read, to avoid possibly allocating gigabytes of memory.\n\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Compression method:\n\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\n\t// File lengths:\n\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\n\t// Unix-style timestamp.\n\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\n\t// CRC.\n\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\n\t// OS type:\n\n\t(*header)->os_type = RAW_DATA(header, 23);\n\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\n// \"Collapse\" a path down, by removing all instances of \".\" and \"..\"\n// paths. This is to protect against malicious archives that might include\n// \"..\" in a path to break out of the extract directory.\n\nstatic void collapse_path(char *filename)\n{\n\tunsigned int currpath_len;\n\tchar *currpath;\n\tchar *r, *w;\n\n\t// If the path starts with a /, it is an absolute path; skip over\n\t// that first character and don't remove it.\n\n\tif (filename[0] == '/') {\n\t\t++filename;\n\t}\n\n\t// Step through each character, copying it from 'r' to 'w'. It\n\t// is always the case that w <= r, and the final string will\n\t// be equal in length or shorter than the original.\n\n\tcurrpath = filename;\n\tw = filename;\n\n\tfor (r = filename; *r != '\\0'; ++r) {\n\t\t*w++ = *r;\n\n\t\t// Each time a new path separator is found, examine the\n\t\t// path that was just written.\n\n\t\tif (*r == '/') {\n\n\t\t\tcurrpath_len = w - currpath - 1;\n\n\t\t\t// Empty path (//) or current directory (.)?\n\n\t\t\tif (currpath_len == 0\n\t\t\t || (currpath_len == 1 && currpath[0] == '.')) {\n\t\t\t\tw = currpath;\n\n\t\t\t// Parent directory (..)?\n\n\t\t\t} else if (currpath_len == 2\n\t\t\t        && currpath[0] == '.' && currpath[1] == '.') {\n\n\t\t\t\t// Walk back up by one directory. Don't go\n\t\t\t\t// past the start of the string.\n\n\t\t\t\tif (currpath == filename) {\n\t\t\t\t\tw = filename;\n\t\t\t\t} else {\n\t\t\t\t\tw = currpath - 1;\n\n\t\t\t\t\twhile (w > filename) {\n\t\t\t\t\t\tif (*(w - 1) == '/') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t--w;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrpath = w;\n\t\t\t\t}\n\n\t\t\t// Save for next time we start a new path.\n\n\t\t\t} else {\n\t\t\t\tcurrpath = w;\n\t\t\t}\n\t\t}\n\t}\n\n\t*w = '\\0';\n}\n\nLHAFileHeader *lha_file_header_read(LHAInputStream *stream)\n{\n\tLHAFileHeader *header;\n\tint success;\n\n\t// We cannot decode the file header until we identify the\n\t// header level (as different header level formats are\n\t// decoded in different ways. The header level field is\n\t// located at byte offset 20 within the header, so we\n\t// must read the first 21 bytes to read it (actually this\n\t// reads one byte more, so that we get the filename length\n\t// byte for level 1 headers as well).\n\n\t// Allocate result structure.\n\n\theader = calloc(1, sizeof(LHAFileHeader) + COMMON_HEADER_LEN);\n\n\tif (header == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemset(header, 0, sizeof(LHAFileHeader));\n\n\theader->_refcount = 1;\n\n\t// Read first chunk of header.\n\n\theader->raw_data = (uint8_t *) (header + 1);\n\theader->raw_data_len = COMMON_HEADER_LEN;\n\n\tif (!lha_input_stream_read(stream, header->raw_data,\n\t                           header->raw_data_len)) {\n\t\tgoto fail;\n\t}\n\n\t// Identify header level, and decode header depending on\n\t// the value encountered.\n\n\theader->header_level = header->raw_data[20];\n\n\tswitch (header->header_level) {\n\t\tcase 0:\n\t\t\tsuccess = decode_level0_header(&header, stream);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tsuccess = decode_level1_header(&header, stream);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tsuccess = decode_level2_header(&header, stream);\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tsuccess = decode_level3_header(&header, stream);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsuccess = 0;\n\t\t\tbreak;\n\t}\n\n\tif (!success) {\n\t\tgoto fail;\n\t}\n\n\t// Sanity check that we got some headers, at least.\n\t// Directory entries must have a path, and files must have a\n\t// filename. Symlinks are stored using the same compression method\n\t// field string (-lhd-) as directories.\n\n\tif (strcmp(header->compress_method, LHA_COMPRESS_TYPE_DIR) != 0) {\n\t\tif (header->filename == NULL) {\n\t\t\tgoto fail;\n\t\t}\n\t} else if (!strcmp(header->compress_method, LHA_COMPRESS_TYPE_DIR)\n\t        && LHA_FILE_HAVE_EXTRA(header, LHA_FILE_UNIX_PERMS)\n\t\t&& (header->path != NULL || header->filename != NULL)\n\t\t&& (header->unix_perms & 0170000) == 0120000) {\n\n\t\tif (!parse_symlink(header)) {\n\t\t\tgoto fail;\n\t\t}\n\n\t} else {\n\t\tif (header->path == NULL) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t// Is the path an all-caps filename?  If so, it is a DOS path that\n\t// should be translated to lower case.\n\n\tif (header->os_type == LHA_OS_TYPE_UNKNOWN\n\t || header->os_type == LHA_OS_TYPE_MSDOS\n\t || header->os_type == LHA_OS_TYPE_ATARI\n\t || header->os_type == LHA_OS_TYPE_OS2) {\n\t\tfix_msdos_allcaps(header);\n\t}\n\n\t// Collapse special directory paths to ensure the path is clean.\n\n\tif (header->path != NULL) {\n\t\tcollapse_path(header->path);\n\t}\n\n\t// Is this header generated by OS-9/68k LHA? If so, any Unix\n\t// permissions are actually OS-9 permissions.\n\n\tif (header->os_type == LHA_OS_TYPE_OS9_68K\n\t && LHA_FILE_HAVE_EXTRA(header, LHA_FILE_UNIX_PERMS)) {\n\t\theader->os9_perms = header->unix_perms;\n\t\theader->extra_flags |= LHA_FILE_OS9_PERMS;\n\t}\n\n\t// If OS-9 permissions were read, translate into Unix permissions.\n\n\tif (LHA_FILE_HAVE_EXTRA(header, LHA_FILE_OS9_PERMS)) {\n\t\tos9_to_unix_permissions(header);\n\t}\n\n\t// Was the \"common\" extended header read, which contains a CRC of\n\t// the full header? If so, perform a CRC check now.\n\n\tif (LHA_FILE_HAVE_EXTRA(header, LHA_FILE_COMMON_CRC)\n\t && !check_common_crc(header)) {\n\t\tgoto fail;\n\t}\n\n\treturn header;\nfail:\n\tlha_file_header_free(header);\n\treturn NULL;\n}\n\nvoid lha_file_header_free(LHAFileHeader *header)\n{\n\t// Sanity check:\n\n\tif (header->_refcount == 0) {\n\t\treturn;\n\t}\n\n\t// Count down references and only free when all have been removed.\n\n\t--header->_refcount;\n\n\tif (header->_refcount > 0) {\n\t\treturn;\n\t}\n\n\tfree(header->filename);\n\tfree(header->path);\n\tfree(header->symlink_target);\n\tfree(header->unix_username);\n\tfree(header->unix_group);\n\tfree(header);\n}\n\nvoid lha_file_header_add_ref(LHAFileHeader *header)\n{\n\t++header->_refcount;\n}\n\n"], "fixing_code": ["/*\n\nCopyright (c) 2011, 2012, Simon Howard\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n\n#include \"lha_endian.h\"\n#include \"lha_file_header.h\"\n#include \"ext_header.h\"\n#include \"crc16.h\"\n\n#define COMMON_HEADER_LEN 22 /* bytes */\n\n// Minimum length of a level 0 header (with zero-length filename).\n#define LEVEL_0_MIN_HEADER_LEN 22 /* bytes */\n\n// Minimum length of a level 1 base header (with zero-length filename).\n#define LEVEL_1_MIN_HEADER_LEN 25 /* bytes */\n\n// Length of a level 2 base header.\n#define LEVEL_2_HEADER_LEN 26 /* bytes */\n\n// Length of a level 3 base header.\n#define LEVEL_3_HEADER_LEN 32 /* bytes */\n\n// Maximum length of a level 3 header (including extended headers).\n#define LEVEL_3_MAX_HEADER_LEN (1024 * 1024) /* 1 MB */\n\n// Length of a level 0 Unix extended area.\n#define LEVEL_0_UNIX_EXTENDED_LEN 12 /* bytes */\n\n// Length of a level 0 OS-9 extended area.\n#define LEVEL_0_OS9_EXTENDED_LEN 22 /* bytes */\n\n#define RAW_DATA(hdr_ptr, off)  ((*hdr_ptr)->raw_data[off])\n#define RAW_DATA_LEN(hdr_ptr)   ((*hdr_ptr)->raw_data_len)\n\nchar *lha_file_header_full_path(LHAFileHeader *header)\n{\n\tchar *path;\n\tchar *filename;\n\tchar *result;\n\n\tif (header->path != NULL) {\n\t\tpath = header->path;\n\t} else {\n\t\tpath = \"\";\n\t}\n\n\tif (header->filename != NULL) {\n\t\tfilename = header->filename;\n\t} else {\n\t\tfilename = \"\";\n\t}\n\n\tresult = malloc(strlen(path) + strlen(filename) + 1);\n\n\tif (result == NULL) {\n\t\treturn NULL;\n\t}\n\n\tsprintf(result, \"%s%s\", path, filename);\n\n\treturn result;\n}\n\n/**\n * Given a file header with the filename set, split it into separate\n * path and filename components, if necessary.\n *\n * @param header         Point to the file header structure.\n * @return               Non-zero for success, or zero for failure.\n */\n\nstatic int split_header_filename(LHAFileHeader *header)\n{\n\tchar *sep;\n\tchar *new_filename;\n\n\t// Is there a directory separator in the path?  If so, we need to\n\t// split into directory name and filename.\n\n\tsep = strrchr(header->filename, '/');\n\n\tif (sep != NULL) {\n\t\tnew_filename = strdup(sep + 1);\n\n\t\tif (new_filename == NULL) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t*(sep + 1) = '\\0';\n\t\theader->path = header->filename;\n\t\theader->filename = new_filename;\n\t}\n\n\treturn 1;\n}\n\n// Perform checksum of header contents.\n\nstatic int check_l0_checksum(uint8_t *header, size_t header_len, size_t csum)\n{\n\tunsigned int result;\n\tunsigned int i;\n\n\tresult = 0;\n\n\tfor (i = 0; i < header_len; ++i) {\n\t\tresult += header[i];\n\t}\n\n\treturn (result & 0xff) == csum;\n}\n\n// Perform full-header CRC check, based on CRC from \"common\" extended header.\n\nstatic int check_common_crc(LHAFileHeader *header)\n{\n\tuint16_t crc;\n\n\tcrc = 0;\n\tlha_crc16_buf(&crc, header->raw_data, header->raw_data_len);\n\n\treturn crc == header->common_crc;\n}\n\n// Decode MS-DOS timestamp.\n\nstatic unsigned int decode_ftime(uint8_t *buf)\n{\n\tint raw;\n\tstruct tm datetime;\n\n\traw = (int) lha_decode_uint32(buf);\n\n\tif (raw == 0) {\n\t\treturn 0;\n\t}\n\n\t// Deconstruct the contents of the MS-DOS time value and populate the\n\t// 'datetime' structure. Note that 'mktime' generates a timestamp for\n\t// the local time zone: this is unfortunate, but probably the best\n\t// that can be done, due to the limited data stored in MS-DOS time\n\t// values.\n\n\tmemset(&datetime, 0, sizeof(struct tm));\n\n\tdatetime.tm_sec = (raw << 1) & 0x3e;\n\tdatetime.tm_min = (raw >> 5) & 0x3f;\n\tdatetime.tm_hour = (raw >> 11) & 0x1f;\n\tdatetime.tm_mday = (raw >> 16) & 0x1f;\n\tdatetime.tm_mon = ((raw >> 21) & 0xf) - 1;\n\tdatetime.tm_year = 80 + ((raw >> 25) & 0x7f);\n\tdatetime.tm_wday = 0;\n\tdatetime.tm_yday = 0;\n\tdatetime.tm_isdst = -1;\n\n\treturn (unsigned int) mktime(&datetime);\n}\n\n// MS-DOS archives (and archives from similar systems) may have paths and\n// filenames that are in all-caps. Detect these and convert them to\n// lower-case.\n\nstatic void fix_msdos_allcaps(LHAFileHeader *header)\n{\n\tunsigned int i;\n\tint is_allcaps;\n\n\t// Check both path and filename to see if there are any lower-case\n\t// characters.\n\n\tis_allcaps = 1;\n\n\tif (header->path != NULL) {\n\t\tfor (i = 0; header->path[i] != '\\0'; ++i) {\n\t\t\tif (islower((unsigned) header->path[i])) {\n\t\t\t\tis_allcaps = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_allcaps && header->filename != NULL) {\n\t\tfor (i = 0; header->filename[i] != '\\0'; ++i) {\n\t\t\tif (islower((unsigned) header->filename[i])) {\n\t\t\t\tis_allcaps = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If both are all-caps, convert them all to lower-case.\n\n\tif (is_allcaps) {\n\t\tif (header->path != NULL) {\n\t\t\tfor (i = 0; header->path[i] != '\\0'; ++i) {\n\t\t\t\theader->path[i]\n\t\t\t\t    = tolower((unsigned) header->path[i]);\n\t\t\t}\n\t\t}\n\t\tif (header->filename != NULL) {\n\t\t\tfor (i = 0; header->filename[i] != '\\0'; ++i) {\n\t\t\t\theader->filename[i]\n\t\t\t\t    = tolower((unsigned) header->filename[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Process the OS-9 permissions field and translate into the equivalent\n// Unix permissions.\n\nstatic void os9_to_unix_permissions(LHAFileHeader *header)\n{\n\tunsigned int or, ow, oe, pr, pw, pe, d;\n\n\t// Translate into equivalent Unix permissions. OS-9 just has\n\t// owner and public, so double up public for the owner field.\n\n\tor = (header->os9_perms & 0x01) != 0;\n\tow = (header->os9_perms & 0x02) != 0;\n\toe = (header->os9_perms & 0x04) != 0;\n\tpr = (header->os9_perms & 0x08) != 0;\n\tpw = (header->os9_perms & 0x10) != 0;\n\tpe = (header->os9_perms & 0x20) != 0;\n\td = (header->os9_perms & 0x80) != 0;\n\n\theader->extra_flags |= LHA_FILE_UNIX_PERMS;\n\theader->unix_perms = (d << 14)\n\t                   | (or << 8) | (ow << 7) | (oe << 6)  // owner\n\t                   | (pr << 5) | (pw << 4) | (pe << 3)  // group\n\t                   | (pr << 2) | (pw << 1) | (pe << 0); // everyone\n}\n\n// Parse a Unix symbolic link. These are stored in the format:\n// filename = symlink|target\n\nstatic int parse_symlink(LHAFileHeader *header)\n{\n\tchar *fullpath;\n\tchar *p;\n\n\t// Although the format is always the same, some files have\n\t// symlink headers where the path is split between the path\n\t// and filename headers. For example:\n\t//    path = etc|../../\n\t//    filename = etc\n\n\tfullpath = lha_file_header_full_path(header);\n\n\tif (fullpath == NULL) {\n\t\treturn 0;\n\t}\n\n\tp = strchr(fullpath, '|');\n\n\tif (p == NULL) {\n\t\tfree(fullpath);\n\t\treturn 0;\n\t}\n\n\theader->symlink_target = strdup(p + 1);\n\n\tif (header->symlink_target == NULL) {\n\t\tfree(fullpath);\n\t\treturn 0;\n\t}\n\n\t// Cut the string in half at the separator. Keep the left side\n\t// as the value for filename.\n\n\t*p = '\\0';\n\n\tfree(header->path);\n\tfree(header->filename);\n\theader->path = NULL;\n\theader->filename = fullpath;\n\n\t// Having joined path and filename together during processing,\n\t// we now have the opposite problem: header->filename might\n\t// contain a full path rather than just a filename. Split back\n\t// into two again.\n\n\treturn split_header_filename(header);\n}\n\n// Decode the path field in the header.\n\nstatic int process_level0_path(LHAFileHeader *header, uint8_t *data,\n                               size_t data_len)\n{\n\tunsigned int i;\n\n\t// Zero-length filename probably means that this is a directory\n\t// entry. Leave the filename field as NULL - this makes us\n\t// consistent with level 2/3 headers.\n\n\tif (data_len == 0) {\n\t\treturn 1;\n\t}\n\n\theader->filename = malloc(data_len + 1);\n\n\tif (header->filename == NULL) {\n\t\treturn 0;\n\t}\n\n\tmemcpy(header->filename, data, data_len);\n\theader->filename[data_len] = '\\0';\n\n\t// Convert MS-DOS path separators to Unix path separators.\n\n\tfor (i = 0; i < data_len; ++i) {\n\t\tif (header->filename[i] == '\\\\') {\n\t\t\theader->filename[i] = '/';\n\t\t}\n\t}\n\n\treturn split_header_filename(header);\n}\n\n// Read some more data from the input stream, extending the raw_data\n// array (and the size of the header).\n\nstatic uint8_t *extend_raw_data(LHAFileHeader **header,\n                                LHAInputStream *stream,\n                                size_t nbytes)\n{\n\tLHAFileHeader *new_header;\n\tsize_t new_raw_len;\n\tuint8_t *result;\n\n\tif (nbytes > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn NULL;\n\t}\n\n\t// Reallocate the header and raw_data area to be larger.\n\n\tnew_raw_len = RAW_DATA_LEN(header) + nbytes;\n\tnew_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len);\n\n\tif (new_header == NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Update the header pointer to point to the new area.\n\n\t*header = new_header;\n\tnew_header->raw_data = (uint8_t *) (new_header + 1);\n\tresult = new_header->raw_data + new_header->raw_data_len;\n\n\t// Read data from stream into new area.\n\n\tif (!lha_input_stream_read(stream, result, nbytes)) {\n\t\treturn NULL;\n\t}\n\n\tnew_header->raw_data_len = new_raw_len;\n\n\treturn result;\n}\n\n// Starting at the specified offset in the raw_data array, walk\n// through the list of extended headers and parse them.\n\nstatic int decode_extended_headers(LHAFileHeader **header,\n                                   unsigned int offset)\n{\n\tunsigned int field_size;\n\tuint8_t *ext_header;\n\tsize_t ext_header_len;\n\tsize_t available_length;\n\n\t// Level 3 headers use 32-bit length fields; all others use\n\t// 16-bit fields.\n\n\tif ((*header)->header_level == 3) {\n\t\tfield_size = 4;\n\t} else {\n\t\tfield_size = 2;\n\t}\n\n\tavailable_length = RAW_DATA_LEN(header) - offset - field_size;\n\n\twhile (offset <= RAW_DATA_LEN(header) - field_size) {\n\t\text_header = &RAW_DATA(header, offset + field_size);\n\n\t\tif (field_size == 4) {\n\t\t\text_header_len\n\t\t\t    = lha_decode_uint32(&RAW_DATA(header, offset));\n\t\t} else {\n\t\t\text_header_len\n\t\t\t    = lha_decode_uint16(&RAW_DATA(header, offset));\n\t\t}\n\n\t\t// Header length zero indicates end of chain. Otherwise, sanity\n\t\t// check the header length is valid.\n\n\t\tif (ext_header_len == 0) {\n\t\t\tbreak;\n\t\t} else if (ext_header_len < field_size + 1\n\t\t        || ext_header_len > available_length) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Process header:\n\n\t\tlha_ext_header_decode(*header, ext_header[0], ext_header + 1,\n\t\t                      ext_header_len - field_size - 1);\n\n\t\t// Advance to next header.\n\n\t\toffset += ext_header_len;\n\t\tavailable_length -= ext_header_len;\n\t}\n\n\treturn 1;\n}\n\nstatic int read_next_ext_header(LHAFileHeader **header,\n                                LHAInputStream *stream,\n                                uint8_t **ext_header,\n                                size_t *ext_header_len)\n{\n\t// Last two bytes of the header raw data contain the size\n\t// of the next header.\n\n\t*ext_header_len\n\t    = lha_decode_uint16(&RAW_DATA(header, RAW_DATA_LEN(header) - 2));\n\n\t// No more headers?\n\n\tif (*ext_header_len == 0) {\n\t\t*ext_header = NULL;\n\t\treturn 1;\n\t}\n\n\t*ext_header = extend_raw_data(header, stream, *ext_header_len);\n\n\treturn *ext_header != NULL;\n}\n\n// Read extended headers for a level 1 header, extending the\n// raw_data block to include them.\n\nstatic int read_l1_extended_headers(LHAFileHeader **header,\n                                    LHAInputStream *stream)\n{\n\tuint8_t *ext_header;\n\tsize_t ext_header_len;\n\n\tfor (;;) {\n\t\t// Try to read the next header.\n\n\t\tif (!read_next_ext_header(header, stream,\n\t\t                          &ext_header, &ext_header_len)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Last header?\n\n\t\tif (ext_header_len == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// For backwards compatibility with level 0 headers,\n\t\t// the compressed length field is actually \"compressed\n\t\t// length + length of all extended headers\":\n\n\t\tif ((*header)->compressed_length < ext_header_len) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t(*header)->compressed_length -= ext_header_len;\n\n\t\t// Must be at least 3 bytes - 1 byte header type\n\t\t// + 2 bytes for next header length\n\n\t\tif (ext_header_len < 3) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n// Process a level 0 Unix extended area.\n\nstatic void process_level0_unix_area(LHAFileHeader *header,\n                                     uint8_t *data, size_t data_len)\n{\n\t// A typical Unix extended area:\n\t//\n\t// 00000000  55 00 00 3b 3d 4b 80 81  e8 03 e8 03\n\n\t// Sanity check.\n\n\tif (data_len < LEVEL_0_UNIX_EXTENDED_LEN || data[1] != 0x00) {\n\t\treturn;\n\t}\n\n\t// OS-9/68k generates an extended area that is broadly compatible\n\t// with the Unix one.\n\n\t// Fill in the header fields from the data from the extended area.\n\t// There's one minor point to note here: OS-9/68k LHA includes the\n\t// timestamp twice - I have no idea why. In order to support both\n\t// variants, read the end fields from the end of the extended area.\n\n\theader->os_type = data[0];\n\theader->timestamp = lha_decode_uint32(data + 2);\n\n\theader->unix_perms = lha_decode_uint16(data + data_len - 6);\n\theader->unix_uid = lha_decode_uint16(data + data_len - 4);\n\theader->unix_gid = lha_decode_uint16(data + data_len - 2);\n\n\theader->extra_flags |= LHA_FILE_UNIX_PERMS | LHA_FILE_UNIX_UID_GID;\n}\n\n// Process a level 0 OS-9 extended area.\n\nstatic void process_level0_os9_area(LHAFileHeader *header,\n                                    uint8_t *data, size_t data_len)\n{\n\t// A typical OS-9 extended area:\n\t//\n\t// 00000000  39 13 00 00 c3 16 00 0f  00 cc 18 07 09 03 01 16\n\t// 00000010  00 13 00 00 00 00\n\n\t// Sanity checks:\n\n\tif (data_len < LEVEL_0_OS9_EXTENDED_LEN\n\t || data[9] != 0xcc || data[1] != data[17] || data[2] != data[18]) {\n\t\treturn;\n\t}\n\n\t// The contents resemble the contents of the OS-9 extended header.\n\t// We just want the permissions field.\n\n\theader->os_type = LHA_OS_TYPE_OS9;\n\theader->os9_perms = lha_decode_uint16(data + 1);\n\theader->extra_flags |= LHA_FILE_OS9_PERMS;\n}\n\n// Handling for level 0 extended areas.\n\nstatic void process_level0_extended_area(LHAFileHeader *header,\n                                         uint8_t *data, size_t data_len)\n{\n\t// PMarc archives can include comments that are stored in the\n\t// extended area. It is possible that this could conflict with\n\t// the logic below, so specifically exclude them.\n\n\tif (!strncmp(header->compress_method, \"-pm\", 3)) {\n\t\treturn;\n\t}\n\n\t// Different tools include different extended areas. Try to\n\t// identify which tool generated this one, based on the first\n\t// byte.\n\n\tswitch (data[0]) {\n\t\tcase LHA_OS_TYPE_UNIX:\n\t\tcase LHA_OS_TYPE_OS9_68K:\n\t\t\tprocess_level0_unix_area(header, data, data_len);\n\t\t\tbreak;\n\n\t\tcase LHA_OS_TYPE_OS9:\n\t\t\tprocess_level0_os9_area(header, data, data_len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n\n// Decode a level 0 or 1 header.\n\nstatic int decode_level0_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tuint8_t header_len;\n\tuint8_t header_csum;\n\tsize_t path_len;\n\tsize_t min_len;\n\n\theader_len = RAW_DATA(header, 0);\n\theader_csum = RAW_DATA(header, 1);\n\n\t// Sanity check header length.  This is the minimum header length\n\t// for a header that has a zero-length path.\n\n\tswitch ((*header)->header_level) {\n\t\tcase 0:\n\t\t\tmin_len = LEVEL_0_MIN_HEADER_LEN;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmin_len = LEVEL_1_MIN_HEADER_LEN;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\n\tif (header_len < min_len) {\n\t\treturn 0;\n\t}\n\n\t// We only have a partial header so far. Read the full header.\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len + 2 - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Checksum the header.\n\n\tif (!check_l0_checksum(&RAW_DATA(header, 2),\n\t                       RAW_DATA_LEN(header) - 2,\n\t                       header_csum)) {\n\t\treturn 0;\n\t}\n\n\t// Compression method:\n\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\n\t// File lengths:\n\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\n\t// Timestamp:\n\n\t(*header)->timestamp = decode_ftime(&RAW_DATA(header, 15));\n\n\t// Read path.  Check path length field - is the header long enough\n\t// to hold this full path?\n\n\tpath_len = RAW_DATA(header, 21);\n\n\tif (min_len + path_len > header_len) {\n\t\treturn 0;\n\t}\n\n\t// OS type?\n\n\tif ((*header)->header_level == 0) {\n\t\t(*header)->os_type = LHA_OS_TYPE_UNKNOWN;\n\t} else {\n\t\t(*header)->os_type = RAW_DATA(header, 24 + path_len);\n\t}\n\n\t// Read filename field:\n\n\tif (!process_level0_path(*header, &RAW_DATA(header, 22), path_len)) {\n\t\treturn 0;\n\t}\n\n\t// CRC field.\n\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 22 + path_len));\n\n\t// Level 0 headers can contain extended data through different schemes\n\t// to the extended header system used in level 1+.\n\n\tif ((*header)->header_level == 0\n\t && header_len > LEVEL_0_MIN_HEADER_LEN + path_len) {\n\t\tprocess_level0_extended_area(*header,\n\t\t  &RAW_DATA(header, LEVEL_0_MIN_HEADER_LEN + 2 + path_len),\n\t\t  header_len - LEVEL_0_MIN_HEADER_LEN - path_len);\n\t}\n\n\treturn 1;\n}\n\nstatic int decode_level1_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int ext_header_start;\n\n\tif (!decode_level0_header(header, stream)) {\n\t\treturn 0;\n\t}\n\n\t// Level 1 headers can have extended headers, so parse them.\n\n\text_header_start = RAW_DATA_LEN(header) - 2;\n\n\tif (!read_l1_extended_headers(header, stream)\n\t || !decode_extended_headers(header, ext_header_start)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int decode_level2_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\n\theader_len = lha_decode_uint16(&RAW_DATA(header, 0));\n\n\tif (header_len < LEVEL_2_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\n\t// Read the full header.\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Compression method:\n\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\n\t// File lengths:\n\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\n\t// Timestamp. Unlike level 0/1, this is a Unix-style timestamp.\n\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\n\t// CRC.\n\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\n\t// OS type:\n\n\t(*header)->os_type = RAW_DATA(header, 23);\n\n\t// LHA for OS-9/68k generates broken level 2 archives: the header\n\t// length field is the length of the remainder of the header, not\n\t// the complete header length. As a result it's two bytes too\n\t// short. We can use the OS type field to detect these archives\n\t// and compensate.\n\n\tif ((*header)->os_type == LHA_OS_TYPE_OS9_68K) {\n\t\tif (!extend_raw_data(header, stream, 2)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!decode_extended_headers(header, 24)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\n\t// The first field at the start of a level 3 header is supposed to\n\t// indicate word size, with the idea being that the header format\n\t// can be extended beyond 32-bit words in the future. In practise,\n\t// nothing supports anything other than 32-bit (4 bytes), and neither\n\t// do we.\n\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\n\t// Read the full header.\n\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Read the header length field (including extended headers), and\n\t// extend to this full length. Because this is a 32-bit value,\n\t// we must place a sensible limit on the amount of data that will\n\t// be read, to avoid possibly allocating gigabytes of memory.\n\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN\n\t || header_len < RAW_DATA_LEN(header)) {\n\t\treturn 0;\n\t}\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Compression method:\n\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\n\t// File lengths:\n\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\n\t// Unix-style timestamp.\n\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\n\t// CRC.\n\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\n\t// OS type:\n\n\t(*header)->os_type = RAW_DATA(header, 23);\n\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\n// \"Collapse\" a path down, by removing all instances of \".\" and \"..\"\n// paths. This is to protect against malicious archives that might include\n// \"..\" in a path to break out of the extract directory.\n\nstatic void collapse_path(char *filename)\n{\n\tunsigned int currpath_len;\n\tchar *currpath;\n\tchar *r, *w;\n\n\t// If the path starts with a /, it is an absolute path; skip over\n\t// that first character and don't remove it.\n\n\tif (filename[0] == '/') {\n\t\t++filename;\n\t}\n\n\t// Step through each character, copying it from 'r' to 'w'. It\n\t// is always the case that w <= r, and the final string will\n\t// be equal in length or shorter than the original.\n\n\tcurrpath = filename;\n\tw = filename;\n\n\tfor (r = filename; *r != '\\0'; ++r) {\n\t\t*w++ = *r;\n\n\t\t// Each time a new path separator is found, examine the\n\t\t// path that was just written.\n\n\t\tif (*r == '/') {\n\n\t\t\tcurrpath_len = w - currpath - 1;\n\n\t\t\t// Empty path (//) or current directory (.)?\n\n\t\t\tif (currpath_len == 0\n\t\t\t || (currpath_len == 1 && currpath[0] == '.')) {\n\t\t\t\tw = currpath;\n\n\t\t\t// Parent directory (..)?\n\n\t\t\t} else if (currpath_len == 2\n\t\t\t        && currpath[0] == '.' && currpath[1] == '.') {\n\n\t\t\t\t// Walk back up by one directory. Don't go\n\t\t\t\t// past the start of the string.\n\n\t\t\t\tif (currpath == filename) {\n\t\t\t\t\tw = filename;\n\t\t\t\t} else {\n\t\t\t\t\tw = currpath - 1;\n\n\t\t\t\t\twhile (w > filename) {\n\t\t\t\t\t\tif (*(w - 1) == '/') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t--w;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrpath = w;\n\t\t\t\t}\n\n\t\t\t// Save for next time we start a new path.\n\n\t\t\t} else {\n\t\t\t\tcurrpath = w;\n\t\t\t}\n\t\t}\n\t}\n\n\t*w = '\\0';\n}\n\nLHAFileHeader *lha_file_header_read(LHAInputStream *stream)\n{\n\tLHAFileHeader *header;\n\tint success;\n\n\t// We cannot decode the file header until we identify the\n\t// header level (as different header level formats are\n\t// decoded in different ways. The header level field is\n\t// located at byte offset 20 within the header, so we\n\t// must read the first 21 bytes to read it (actually this\n\t// reads one byte more, so that we get the filename length\n\t// byte for level 1 headers as well).\n\n\t// Allocate result structure.\n\n\theader = calloc(1, sizeof(LHAFileHeader) + COMMON_HEADER_LEN);\n\n\tif (header == NULL) {\n\t\treturn NULL;\n\t}\n\n\tmemset(header, 0, sizeof(LHAFileHeader));\n\n\theader->_refcount = 1;\n\n\t// Read first chunk of header.\n\n\theader->raw_data = (uint8_t *) (header + 1);\n\theader->raw_data_len = COMMON_HEADER_LEN;\n\n\tif (!lha_input_stream_read(stream, header->raw_data,\n\t                           header->raw_data_len)) {\n\t\tgoto fail;\n\t}\n\n\t// Identify header level, and decode header depending on\n\t// the value encountered.\n\n\theader->header_level = header->raw_data[20];\n\n\tswitch (header->header_level) {\n\t\tcase 0:\n\t\t\tsuccess = decode_level0_header(&header, stream);\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tsuccess = decode_level1_header(&header, stream);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tsuccess = decode_level2_header(&header, stream);\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tsuccess = decode_level3_header(&header, stream);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsuccess = 0;\n\t\t\tbreak;\n\t}\n\n\tif (!success) {\n\t\tgoto fail;\n\t}\n\n\t// Sanity check that we got some headers, at least.\n\t// Directory entries must have a path, and files must have a\n\t// filename. Symlinks are stored using the same compression method\n\t// field string (-lhd-) as directories.\n\n\tif (strcmp(header->compress_method, LHA_COMPRESS_TYPE_DIR) != 0) {\n\t\tif (header->filename == NULL) {\n\t\t\tgoto fail;\n\t\t}\n\t} else if (!strcmp(header->compress_method, LHA_COMPRESS_TYPE_DIR)\n\t        && LHA_FILE_HAVE_EXTRA(header, LHA_FILE_UNIX_PERMS)\n\t\t&& (header->path != NULL || header->filename != NULL)\n\t\t&& (header->unix_perms & 0170000) == 0120000) {\n\n\t\tif (!parse_symlink(header)) {\n\t\t\tgoto fail;\n\t\t}\n\n\t} else {\n\t\tif (header->path == NULL) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t// Is the path an all-caps filename?  If so, it is a DOS path that\n\t// should be translated to lower case.\n\n\tif (header->os_type == LHA_OS_TYPE_UNKNOWN\n\t || header->os_type == LHA_OS_TYPE_MSDOS\n\t || header->os_type == LHA_OS_TYPE_ATARI\n\t || header->os_type == LHA_OS_TYPE_OS2) {\n\t\tfix_msdos_allcaps(header);\n\t}\n\n\t// Collapse special directory paths to ensure the path is clean.\n\n\tif (header->path != NULL) {\n\t\tcollapse_path(header->path);\n\t}\n\n\t// Is this header generated by OS-9/68k LHA? If so, any Unix\n\t// permissions are actually OS-9 permissions.\n\n\tif (header->os_type == LHA_OS_TYPE_OS9_68K\n\t && LHA_FILE_HAVE_EXTRA(header, LHA_FILE_UNIX_PERMS)) {\n\t\theader->os9_perms = header->unix_perms;\n\t\theader->extra_flags |= LHA_FILE_OS9_PERMS;\n\t}\n\n\t// If OS-9 permissions were read, translate into Unix permissions.\n\n\tif (LHA_FILE_HAVE_EXTRA(header, LHA_FILE_OS9_PERMS)) {\n\t\tos9_to_unix_permissions(header);\n\t}\n\n\t// Was the \"common\" extended header read, which contains a CRC of\n\t// the full header? If so, perform a CRC check now.\n\n\tif (LHA_FILE_HAVE_EXTRA(header, LHA_FILE_COMMON_CRC)\n\t && !check_common_crc(header)) {\n\t\tgoto fail;\n\t}\n\n\treturn header;\nfail:\n\tlha_file_header_free(header);\n\treturn NULL;\n}\n\nvoid lha_file_header_free(LHAFileHeader *header)\n{\n\t// Sanity check:\n\n\tif (header->_refcount == 0) {\n\t\treturn;\n\t}\n\n\t// Count down references and only free when all have been removed.\n\n\t--header->_refcount;\n\n\tif (header->_refcount > 0) {\n\t\treturn;\n\t}\n\n\tfree(header->filename);\n\tfree(header->path);\n\tfree(header->symlink_target);\n\tfree(header->unix_username);\n\tfree(header->unix_group);\n\tfree(header);\n}\n\nvoid lha_file_header_add_ref(LHAFileHeader *header)\n{\n\t++header->_refcount;\n}\n\n"], "filenames": ["lib/lha_file_header.c"], "buggy_code_start_loc": [353], "buggy_code_end_loc": [801], "fixing_code_start_loc": [354], "fixing_code_end_loc": [806], "type": "CWE-190", "message": "Integer underflow in the decode_level3_header function in lib/lha_file_header.c in Lhasa before 0.3.1 allows remote attackers to execute arbitrary code via a crafted archive.", "other": {"cve": {"id": "CVE-2016-2347", "sourceIdentifier": "cret@cert.org", "published": "2017-04-21T20:59:00.557", "lastModified": "2018-10-30T16:27:37.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer underflow in the decode_level3_header function in lib/lha_file_header.c in Lhasa before 0.3.1 allows remote attackers to execute arbitrary code via a crafted archive."}, {"lang": "es", "value": "Desbordamiento de enteros en la funci\u00f3n decode_level3_header en lib/lha_file_header.c in Lhasa en versiones anteriores a 0.3.1 permite a los atacantes remotos ejecuta el c\u00f3digo arbitrario a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lhasa_project:lhasa:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.3.0", "matchCriteriaId": "6B02163C-C44C-48BE-8313-60BEE89BA1CA"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-04/msg00038.html", "source": "cret@cert.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-04/msg00039.html", "source": "cret@cert.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3540", "source": "cret@cert.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.talosintelligence.com/reports/TALOS-2016-0095/", "source": "cret@cert.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://github.com/fragglet/lhasa/commit/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564", "source": "cret@cert.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/fragglet/lhasa/releases/tag/v0.3.1", "source": "cret@cert.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fragglet/lhasa/commit/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564"}}