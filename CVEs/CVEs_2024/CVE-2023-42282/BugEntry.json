{"buggy_code": ["var ip = exports;\nvar { Buffer } = require('buffer');\nvar os = require('os');\n\nip.toBuffer = function (ip, buff, offset) {\n  offset = ~~offset;\n\n  var result;\n\n  if (this.isV4Format(ip)) {\n    result = buff || new Buffer(offset + 4);\n    ip.split(/\\./g).map((byte) => {\n      result[offset++] = parseInt(byte, 10) & 0xff;\n    });\n  } else if (this.isV6Format(ip)) {\n    var sections = ip.split(':', 8);\n\n    var i;\n    for (i = 0; i < sections.length; i++) {\n      var isv4 = this.isV4Format(sections[i]);\n      var v4Buffer;\n\n      if (isv4) {\n        v4Buffer = this.toBuffer(sections[i]);\n        sections[i] = v4Buffer.slice(0, 2).toString('hex');\n      }\n\n      if (v4Buffer && ++i < 8) {\n        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0');\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0');\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      var argv = [i, 1];\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0');\n      }\n      sections.splice.apply(sections, argv);\n    }\n\n    result = buff || new Buffer(offset + 16);\n    for (i = 0; i < sections.length; i++) {\n      var word = parseInt(sections[i], 16);\n      result[offset++] = (word >> 8) & 0xff;\n      result[offset++] = word & 0xff;\n    }\n  }\n\n  if (!result) {\n    throw Error(`Invalid ip address: ${ip}`);\n  }\n\n  return result;\n};\n\nip.toString = function (buff, offset, length) {\n  offset = ~~offset;\n  length = length || (buff.length - offset);\n\n  var result = [];\n  var i;\n  if (length === 4) {\n    // IPv4\n    for (i = 0; i < length; i++) {\n      result.push(buff[offset + i]);\n    }\n    result = result.join('.');\n  } else if (length === 16) {\n    // IPv6\n    for (i = 0; i < length; i += 2) {\n      result.push(buff.readUInt16BE(offset + i).toString(16));\n    }\n    result = result.join(':');\n    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');\n    result = result.replace(/:{3,4}/, '::');\n  }\n\n  return result;\n};\n\nvar ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nvar ipv6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n\nip.isV4Format = function (ip) {\n  return ipv4Regex.test(ip);\n};\n\nip.isV6Format = function (ip) {\n  return ipv6Regex.test(ip);\n};\n\nfunction _normalizeFamily(family) {\n  if (family === 4) {\n    return 'ipv4';\n  }\n  if (family === 6) {\n    return 'ipv6';\n  }\n  return family ? family.toLowerCase() : 'ipv4';\n}\n\nip.fromPrefixLen = function (prefixlen, family) {\n  if (prefixlen > 32) {\n    family = 'ipv6';\n  } else {\n    family = _normalizeFamily(family);\n  }\n\n  var len = 4;\n  if (family === 'ipv6') {\n    len = 16;\n  }\n  var buff = new Buffer(len);\n\n  for (var i = 0, n = buff.length; i < n; ++i) {\n    var bits = 8;\n    if (prefixlen < 8) {\n      bits = prefixlen;\n    }\n    prefixlen -= bits;\n\n    buff[i] = ~(0xff >> bits) & 0xff;\n  }\n\n  return ip.toString(buff);\n};\n\nip.mask = function (addr, mask) {\n  addr = ip.toBuffer(addr);\n  mask = ip.toBuffer(mask);\n\n  var result = new Buffer(Math.max(addr.length, mask.length));\n\n  // Same protocol - do bitwise and\n  var i;\n  if (addr.length === mask.length) {\n    for (i = 0; i < addr.length; i++) {\n      result[i] = addr[i] & mask[i];\n    }\n  } else if (mask.length === 4) {\n    // IPv6 address and IPv4 mask\n    // (Mask low bits)\n    for (i = 0; i < mask.length; i++) {\n      result[i] = addr[addr.length - 4 + i] & mask[i];\n    }\n  } else {\n    // IPv6 mask and IPv4 addr\n    for (i = 0; i < result.length - 6; i++) {\n      result[i] = 0;\n    }\n\n    // ::ffff:ipv4\n    result[10] = 0xff;\n    result[11] = 0xff;\n    for (i = 0; i < addr.length; i++) {\n      result[i + 12] = addr[i] & mask[i + 12];\n    }\n    i += 12;\n  }\n  for (; i < result.length; i++) {\n    result[i] = 0;\n  }\n\n  return ip.toString(result);\n};\n\nip.cidr = function (cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2) {\n    throw new Error(`invalid CIDR subnet: ${addr}`);\n  }\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.mask(addr, mask);\n};\n\nip.subnet = function (addr, mask) {\n  var networkAddress = ip.toLong(ip.mask(addr, mask));\n\n  // Calculate the mask's length.\n  var maskBuffer = ip.toBuffer(mask);\n  var maskLength = 0;\n\n  for (var i = 0; i < maskBuffer.length; i++) {\n    if (maskBuffer[i] === 0xff) {\n      maskLength += 8;\n    } else {\n      var octet = maskBuffer[i] & 0xff;\n      while (octet) {\n        octet = (octet << 1) & 0xff;\n        maskLength++;\n      }\n    }\n  }\n\n  var numberOfAddresses = Math.pow(2, 32 - maskLength);\n\n  return {\n    networkAddress: ip.fromLong(networkAddress),\n    firstAddress: numberOfAddresses <= 2\n      ? ip.fromLong(networkAddress)\n      : ip.fromLong(networkAddress + 1),\n    lastAddress: numberOfAddresses <= 2\n      ? ip.fromLong(networkAddress + numberOfAddresses - 1)\n      : ip.fromLong(networkAddress + numberOfAddresses - 2),\n    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\n    subnetMask: mask,\n    subnetMaskLength: maskLength,\n    numHosts: numberOfAddresses <= 2\n      ? numberOfAddresses : numberOfAddresses - 2,\n    length: numberOfAddresses,\n    contains(other) {\n      return networkAddress === ip.toLong(ip.mask(other, mask));\n    },\n  };\n};\n\nip.cidrSubnet = function (cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2) {\n    throw new Error(`invalid CIDR subnet: ${addr}`);\n  }\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.subnet(addr, mask);\n};\n\nip.not = function (addr) {\n  var buff = ip.toBuffer(addr);\n  for (var i = 0; i < buff.length; i++) {\n    buff[i] = 0xff ^ buff[i];\n  }\n  return ip.toString(buff);\n};\n\nip.or = function (a, b) {\n  var i;\n\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // same protocol\n  if (a.length === b.length) {\n    for (i = 0; i < a.length; ++i) {\n      a[i] |= b[i];\n    }\n    return ip.toString(a);\n\n  // mixed protocols\n  }\n  var buff = a;\n  var other = b;\n  if (b.length > a.length) {\n    buff = b;\n    other = a;\n  }\n\n  var offset = buff.length - other.length;\n  for (i = offset; i < buff.length; ++i) {\n    buff[i] |= other[i - offset];\n  }\n\n  return ip.toString(buff);\n};\n\nip.isEqual = function (a, b) {\n  var i;\n\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // Same protocol\n  if (a.length === b.length) {\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  // Swap\n  if (b.length === 4) {\n    var t = b;\n    b = a;\n    a = t;\n  }\n\n  // a - IPv4, b - IPv6\n  for (i = 0; i < 10; i++) {\n    if (b[i] !== 0) return false;\n  }\n\n  var word = b.readUInt16BE(10);\n  if (word !== 0 && word !== 0xffff) return false;\n\n  for (i = 0; i < 4; i++) {\n    if (a[i] !== b[i + 12]) return false;\n  }\n\n  return true;\n};\n\nip.isPrivate = function (addr) {\n  return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n    .test(addr)\n    || /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)\n    || /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n      .test(addr)\n    || /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)\n    || /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)\n    || /^f[cd][0-9a-f]{2}:/i.test(addr)\n    || /^fe80:/i.test(addr)\n    || /^::1$/.test(addr)\n    || /^::$/.test(addr);\n};\n\nip.isPublic = function (addr) {\n  return !ip.isPrivate(addr);\n};\n\nip.isLoopback = function (addr) {\n  return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/\n    .test(addr)\n    || /^fe80::1$/.test(addr)\n    || /^::1$/.test(addr)\n    || /^::$/.test(addr);\n};\n\nip.loopback = function (family) {\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  if (family !== 'ipv4' && family !== 'ipv6') {\n    throw new Error('family must be ipv4 or ipv6');\n  }\n\n  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';\n};\n\n//\n// ### function address (name, family)\n// #### @name {string|'public'|'private'} **Optional** Name or security\n//      of the network interface.\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\n//      to ipv4).\n//\n// Returns the address for the network interface on the current system with\n// the specified `name`:\n//   * String: First `family` address of the interface.\n//             If not found see `undefined`.\n//   * 'public': the first public ip address of family.\n//   * 'private': the first private ip address of family.\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\n//\nip.address = function (name, family) {\n  var interfaces = os.networkInterfaces();\n\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  //\n  // If a specific network interface has been named,\n  // return the address.\n  //\n  if (name && name !== 'private' && name !== 'public') {\n    var res = interfaces[name].filter((details) => {\n      var itemFamily = _normalizeFamily(details.family);\n      return itemFamily === family;\n    });\n    if (res.length === 0) {\n      return undefined;\n    }\n    return res[0].address;\n  }\n\n  var all = Object.keys(interfaces).map((nic) => {\n    //\n    // Note: name will only be `public` or `private`\n    // when this is called.\n    //\n    var addresses = interfaces[nic].filter((details) => {\n      details.family = _normalizeFamily(details.family);\n      if (details.family !== family || ip.isLoopback(details.address)) {\n        return false;\n      } if (!name) {\n        return true;\n      }\n\n      return name === 'public' ? ip.isPrivate(details.address)\n        : ip.isPublic(details.address);\n    });\n\n    return addresses.length ? addresses[0].address : undefined;\n  }).filter(Boolean);\n\n  return !all.length ? ip.loopback(family) : all[0];\n};\n\nip.toLong = function (ip) {\n  var ipl = 0;\n  ip.split('.').forEach((octet) => {\n    ipl <<= 8;\n    ipl += parseInt(octet);\n  });\n  return (ipl >>> 0);\n};\n\nip.fromLong = function (ipl) {\n  return (`${ipl >>> 24}.${\n    ipl >> 16 & 255}.${\n    ipl >> 8 & 255}.${\n    ipl & 255}`);\n};\n", "/* global describe, it */\nconst assert = require('assert');\nconst { Buffer } = require('buffer');\nconst net = require('net');\nconst os = require('os');\nconst ip = require('..');\n\ndescribe('IP library for node.js', () => {\n  describe('toBuffer()/toString() methods', () => {\n    it('should convert to buffer IPv4 address', () => {\n      const buf = ip.toBuffer('127.0.0.1');\n      assert.equal(buf.toString('hex'), '7f000001');\n      assert.equal(ip.toString(buf), '127.0.0.1');\n    });\n\n    it('should convert to buffer IPv4 address in-place', () => {\n      const buf = new Buffer(128);\n      const offset = 64;\n      ip.toBuffer('127.0.0.1', buf, offset);\n      assert.equal(buf.toString('hex', offset, offset + 4), '7f000001');\n      assert.equal(ip.toString(buf, offset, 4), '127.0.0.1');\n    });\n\n    it('should convert to buffer IPv6 address', () => {\n      const buf = ip.toBuffer('::1');\n      assert(/(00){15,15}01/.test(buf.toString('hex')));\n      assert.equal(ip.toString(buf), '::1');\n      assert.equal(ip.toString(ip.toBuffer('1::')), '1::');\n      assert.equal(ip.toString(ip.toBuffer('abcd::dcba')), 'abcd::dcba');\n    });\n\n    it('should convert to buffer IPv6 address in-place', () => {\n      const buf = new Buffer(128);\n      const offset = 64;\n      ip.toBuffer('::1', buf, offset);\n      assert(/(00){15,15}01/.test(buf.toString('hex', offset, offset + 16)));\n      assert.equal(ip.toString(buf, offset, 16), '::1');\n      assert.equal(ip.toString(\n        ip.toBuffer('1::', buf, offset),\n        offset,\n        16,\n      ), '1::');\n      assert.equal(ip.toString(\n        ip.toBuffer('abcd::dcba', buf, offset),\n        offset,\n        16,\n      ), 'abcd::dcba');\n    });\n\n    it('should convert to buffer IPv6 mapped IPv4 address', () => {\n      let buf = ip.toBuffer('::ffff:127.0.0.1');\n      assert.equal(buf.toString('hex'), '00000000000000000000ffff7f000001');\n      assert.equal(ip.toString(buf), '::ffff:7f00:1');\n\n      buf = ip.toBuffer('ffff::127.0.0.1');\n      assert.equal(buf.toString('hex'), 'ffff000000000000000000007f000001');\n      assert.equal(ip.toString(buf), 'ffff::7f00:1');\n\n      buf = ip.toBuffer('0:0:0:0:0:ffff:127.0.0.1');\n      assert.equal(buf.toString('hex'), '00000000000000000000ffff7f000001');\n      assert.equal(ip.toString(buf), '::ffff:7f00:1');\n    });\n  });\n\n  describe('fromPrefixLen() method', () => {\n    it('should create IPv4 mask', () => {\n      assert.equal(ip.fromPrefixLen(24), '255.255.255.0');\n    });\n    it('should create IPv6 mask', () => {\n      assert.equal(ip.fromPrefixLen(64), 'ffff:ffff:ffff:ffff::');\n    });\n    it('should create IPv6 mask explicitly', () => {\n      assert.equal(ip.fromPrefixLen(24, 'IPV6'), 'ffff:ff00::');\n    });\n  });\n\n  describe('not() method', () => {\n    it('should reverse bits in address', () => {\n      assert.equal(ip.not('255.255.255.0'), '0.0.0.255');\n    });\n  });\n\n  describe('or() method', () => {\n    it('should or bits in ipv4 addresses', () => {\n      assert.equal(ip.or('0.0.0.255', '192.168.1.10'), '192.168.1.255');\n    });\n    it('should or bits in ipv6 addresses', () => {\n      assert.equal(\n        ip.or('::ff', '::abcd:dcba:abcd:dcba'),\n        '::abcd:dcba:abcd:dcff',\n      );\n    });\n    it('should or bits in mixed addresses', () => {\n      assert.equal(\n        ip.or('0.0.0.255', '::abcd:dcba:abcd:dcba'),\n        '::abcd:dcba:abcd:dcff',\n      );\n    });\n  });\n\n  describe('mask() method', () => {\n    it('should mask bits in address', () => {\n      assert.equal(ip.mask('192.168.1.134', '255.255.255.0'), '192.168.1.0');\n      assert.equal(ip.mask('192.168.1.134', '::ffff:ff00'), '::ffff:c0a8:100');\n    });\n\n    it('should not leak data', () => {\n      for (let i = 0; i < 10; i++) {\n        assert.equal(ip.mask('::1', '0.0.0.0'), '::');\n      }\n    });\n  });\n\n  describe('subnet() method', () => {\n    // Test cases calculated with http://www.subnet-calculator.com/\n    const ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.192');\n\n    it('should compute ipv4 network address', () => {\n      assert.equal(ipv4Subnet.networkAddress, '192.168.1.128');\n    });\n\n    it('should compute ipv4 network\\'s first address', () => {\n      assert.equal(ipv4Subnet.firstAddress, '192.168.1.129');\n    });\n\n    it('should compute ipv4 network\\'s last address', () => {\n      assert.equal(ipv4Subnet.lastAddress, '192.168.1.190');\n    });\n\n    it('should compute ipv4 broadcast address', () => {\n      assert.equal(ipv4Subnet.broadcastAddress, '192.168.1.191');\n    });\n\n    it('should compute ipv4 subnet number of addresses', () => {\n      assert.equal(ipv4Subnet.length, 64);\n    });\n\n    it('should compute ipv4 subnet number of addressable hosts', () => {\n      assert.equal(ipv4Subnet.numHosts, 62);\n    });\n\n    it('should compute ipv4 subnet mask', () => {\n      assert.equal(ipv4Subnet.subnetMask, '255.255.255.192');\n    });\n\n    it('should compute ipv4 subnet mask\\'s length', () => {\n      assert.equal(ipv4Subnet.subnetMaskLength, 26);\n    });\n\n    it('should know whether a subnet contains an address', () => {\n      assert.equal(ipv4Subnet.contains('192.168.1.180'), true);\n    });\n\n    it('should know whether a subnet does not contain an address', () => {\n      assert.equal(ipv4Subnet.contains('192.168.1.195'), false);\n    });\n  });\n\n  describe('subnet() method with mask length 32', () => {\n    // Test cases calculated with http://www.subnet-calculator.com/\n    const ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.255');\n    it('should compute ipv4 network\\'s first address', () => {\n      assert.equal(ipv4Subnet.firstAddress, '192.168.1.134');\n    });\n\n    it('should compute ipv4 network\\'s last address', () => {\n      assert.equal(ipv4Subnet.lastAddress, '192.168.1.134');\n    });\n\n    it('should compute ipv4 subnet number of addressable hosts', () => {\n      assert.equal(ipv4Subnet.numHosts, 1);\n    });\n  });\n\n  describe('subnet() method with mask length 31', () => {\n    // Test cases calculated with http://www.subnet-calculator.com/\n    const ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.254');\n    it('should compute ipv4 network\\'s first address', () => {\n      assert.equal(ipv4Subnet.firstAddress, '192.168.1.134');\n    });\n\n    it('should compute ipv4 network\\'s last address', () => {\n      assert.equal(ipv4Subnet.lastAddress, '192.168.1.135');\n    });\n\n    it('should compute ipv4 subnet number of addressable hosts', () => {\n      assert.equal(ipv4Subnet.numHosts, 2);\n    });\n  });\n\n  describe('cidrSubnet() method', () => {\n    // Test cases calculated with http://www.subnet-calculator.com/\n    const ipv4Subnet = ip.cidrSubnet('192.168.1.134/26');\n\n    it('should compute an ipv4 network address', () => {\n      assert.equal(ipv4Subnet.networkAddress, '192.168.1.128');\n    });\n\n    it('should compute an ipv4 network\\'s first address', () => {\n      assert.equal(ipv4Subnet.firstAddress, '192.168.1.129');\n    });\n\n    it('should compute an ipv4 network\\'s last address', () => {\n      assert.equal(ipv4Subnet.lastAddress, '192.168.1.190');\n    });\n\n    it('should compute an ipv4 broadcast address', () => {\n      assert.equal(ipv4Subnet.broadcastAddress, '192.168.1.191');\n    });\n\n    it('should compute an ipv4 subnet number of addresses', () => {\n      assert.equal(ipv4Subnet.length, 64);\n    });\n\n    it('should compute an ipv4 subnet number of addressable hosts', () => {\n      assert.equal(ipv4Subnet.numHosts, 62);\n    });\n\n    it('should compute an ipv4 subnet mask', () => {\n      assert.equal(ipv4Subnet.subnetMask, '255.255.255.192');\n    });\n\n    it('should compute an ipv4 subnet mask\\'s length', () => {\n      assert.equal(ipv4Subnet.subnetMaskLength, 26);\n    });\n\n    it('should know whether a subnet contains an address', () => {\n      assert.equal(ipv4Subnet.contains('192.168.1.180'), true);\n    });\n\n    it('should know whether a subnet contains an address', () => {\n      assert.equal(ipv4Subnet.contains('192.168.1.195'), false);\n    });\n  });\n\n  describe('cidr() method', () => {\n    it('should mask address in CIDR notation', () => {\n      assert.equal(ip.cidr('192.168.1.134/26'), '192.168.1.128');\n      assert.equal(ip.cidr('2607:f0d0:1002:51::4/56'), '2607:f0d0:1002::');\n    });\n  });\n\n  describe('isEqual() method', () => {\n    it('should check if addresses are equal', () => {\n      assert(ip.isEqual('127.0.0.1', '::7f00:1'));\n      assert(!ip.isEqual('127.0.0.1', '::7f00:2'));\n      assert(ip.isEqual('127.0.0.1', '::ffff:7f00:1'));\n      assert(!ip.isEqual('127.0.0.1', '::ffaf:7f00:1'));\n      assert(ip.isEqual('::ffff:127.0.0.1', '::ffff:127.0.0.1'));\n      assert(ip.isEqual('::ffff:127.0.0.1', '127.0.0.1'));\n    });\n  });\n\n  describe('isPrivate() method', () => {\n    it('should check if an address is localhost', () => {\n      assert.equal(ip.isPrivate('127.0.0.1'), true);\n    });\n\n    it('should check if an address is from a 192.168.x.x network', () => {\n      assert.equal(ip.isPrivate('192.168.0.123'), true);\n      assert.equal(ip.isPrivate('192.168.122.123'), true);\n      assert.equal(ip.isPrivate('192.162.1.2'), false);\n    });\n\n    it('should check if an address is from a 172.16.x.x network', () => {\n      assert.equal(ip.isPrivate('172.16.0.5'), true);\n      assert.equal(ip.isPrivate('172.16.123.254'), true);\n      assert.equal(ip.isPrivate('171.16.0.5'), false);\n      assert.equal(ip.isPrivate('172.25.232.15'), true);\n      assert.equal(ip.isPrivate('172.15.0.5'), false);\n      assert.equal(ip.isPrivate('172.32.0.5'), false);\n    });\n\n    it('should check if an address is from a 169.254.x.x network', () => {\n      assert.equal(ip.isPrivate('169.254.2.3'), true);\n      assert.equal(ip.isPrivate('169.254.221.9'), true);\n      assert.equal(ip.isPrivate('168.254.2.3'), false);\n    });\n\n    it('should check if an address is from a 10.x.x.x network', () => {\n      assert.equal(ip.isPrivate('10.0.2.3'), true);\n      assert.equal(ip.isPrivate('10.1.23.45'), true);\n      assert.equal(ip.isPrivate('12.1.2.3'), false);\n    });\n\n    it('should check if an address is from a private IPv6 network', () => {\n      assert.equal(ip.isPrivate('fd12:3456:789a:1::1'), true);\n      assert.equal(ip.isPrivate('fe80::f2de:f1ff:fe3f:307e'), true);\n      assert.equal(ip.isPrivate('::ffff:10.100.1.42'), true);\n      assert.equal(ip.isPrivate('::FFFF:172.16.200.1'), true);\n      assert.equal(ip.isPrivate('::ffff:192.168.0.1'), true);\n    });\n\n    it('should check if an address is from the internet', () => {\n      assert.equal(ip.isPrivate('165.225.132.33'), false); // joyent.com\n    });\n\n    it('should check if an address is a loopback IPv6 address', () => {\n      assert.equal(ip.isPrivate('::'), true);\n      assert.equal(ip.isPrivate('::1'), true);\n      assert.equal(ip.isPrivate('fe80::1'), true);\n    });\n  });\n\n  describe('loopback() method', () => {\n    describe('undefined', () => {\n      it('should respond with 127.0.0.1', () => {\n        assert.equal(ip.loopback(), '127.0.0.1');\n      });\n    });\n\n    describe('ipv4', () => {\n      it('should respond with 127.0.0.1', () => {\n        assert.equal(ip.loopback('ipv4'), '127.0.0.1');\n      });\n    });\n\n    describe('ipv6', () => {\n      it('should respond with fe80::1', () => {\n        assert.equal(ip.loopback('ipv6'), 'fe80::1');\n      });\n    });\n  });\n\n  describe('isLoopback() method', () => {\n    describe('127.0.0.1', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('127.0.0.1'));\n      });\n    });\n\n    describe('127.8.8.8', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('127.8.8.8'));\n      });\n    });\n\n    describe('8.8.8.8', () => {\n      it('should respond with false', () => {\n        assert.equal(ip.isLoopback('8.8.8.8'), false);\n      });\n    });\n\n    describe('fe80::1', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('fe80::1'));\n      });\n    });\n\n    describe('::1', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('::1'));\n      });\n    });\n\n    describe('::', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('::'));\n      });\n    });\n  });\n\n  describe('address() method', () => {\n    describe('undefined', () => {\n      it('should respond with a private ip', () => {\n        assert.ok(ip.isPrivate(ip.address()));\n      });\n    });\n\n    describe('private', () => {\n      [undefined, 'ipv4', 'ipv6'].forEach((family) => {\n        describe(family || 'undefined', () => {\n          it('should respond with a private ip', () => {\n            assert.ok(ip.isPrivate(ip.address('private', family)));\n          });\n        });\n      });\n    });\n\n    const interfaces = os.networkInterfaces();\n\n    Object.keys(interfaces).forEach((nic) => {\n      describe(nic, () => {\n        [undefined, 'ipv4'].forEach((family) => {\n          describe(family || 'undefined', () => {\n            it('should respond with an ipv4 address', () => {\n              const addr = ip.address(nic, family);\n              assert.ok(!addr || net.isIPv4(addr));\n            });\n          });\n        });\n\n        describe('ipv6', () => {\n          it('should respond with an ipv6 address', () => {\n            const addr = ip.address(nic, 'ipv6');\n            assert.ok(!addr || net.isIPv6(addr));\n          });\n        });\n      });\n    });\n  });\n\n  describe('toLong() method', () => {\n    it('should respond with a int', () => {\n      assert.equal(ip.toLong('127.0.0.1'), 2130706433);\n      assert.equal(ip.toLong('255.255.255.255'), 4294967295);\n    });\n  });\n\n  describe('fromLong() method', () => {\n    it('should repond with ipv4 address', () => {\n      assert.equal(ip.fromLong(2130706433), '127.0.0.1');\n      assert.equal(ip.fromLong(4294967295), '255.255.255.255');\n    });\n  });\n});\n"], "fixing_code": ["var ip = exports;\nvar { Buffer } = require('buffer');\nvar os = require('os');\n\nip.toBuffer = function (ip, buff, offset) {\n  offset = ~~offset;\n\n  var result;\n\n  if (this.isV4Format(ip)) {\n    result = buff || new Buffer(offset + 4);\n    ip.split(/\\./g).map((byte) => {\n      result[offset++] = parseInt(byte, 10) & 0xff;\n    });\n  } else if (this.isV6Format(ip)) {\n    var sections = ip.split(':', 8);\n\n    var i;\n    for (i = 0; i < sections.length; i++) {\n      var isv4 = this.isV4Format(sections[i]);\n      var v4Buffer;\n\n      if (isv4) {\n        v4Buffer = this.toBuffer(sections[i]);\n        sections[i] = v4Buffer.slice(0, 2).toString('hex');\n      }\n\n      if (v4Buffer && ++i < 8) {\n        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0');\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0');\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      var argv = [i, 1];\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0');\n      }\n      sections.splice.apply(sections, argv);\n    }\n\n    result = buff || new Buffer(offset + 16);\n    for (i = 0; i < sections.length; i++) {\n      var word = parseInt(sections[i], 16);\n      result[offset++] = (word >> 8) & 0xff;\n      result[offset++] = word & 0xff;\n    }\n  }\n\n  if (!result) {\n    throw Error(`Invalid ip address: ${ip}`);\n  }\n\n  return result;\n};\n\nip.toString = function (buff, offset, length) {\n  offset = ~~offset;\n  length = length || (buff.length - offset);\n\n  var result = [];\n  var i;\n  if (length === 4) {\n    // IPv4\n    for (i = 0; i < length; i++) {\n      result.push(buff[offset + i]);\n    }\n    result = result.join('.');\n  } else if (length === 16) {\n    // IPv6\n    for (i = 0; i < length; i += 2) {\n      result.push(buff.readUInt16BE(offset + i).toString(16));\n    }\n    result = result.join(':');\n    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');\n    result = result.replace(/:{3,4}/, '::');\n  }\n\n  return result;\n};\n\nvar ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nvar ipv6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n\nip.isV4Format = function (ip) {\n  return ipv4Regex.test(ip);\n};\n\nip.isV6Format = function (ip) {\n  return ipv6Regex.test(ip);\n};\n\nfunction _normalizeFamily(family) {\n  if (family === 4) {\n    return 'ipv4';\n  }\n  if (family === 6) {\n    return 'ipv6';\n  }\n  return family ? family.toLowerCase() : 'ipv4';\n}\n\nip.fromPrefixLen = function (prefixlen, family) {\n  if (prefixlen > 32) {\n    family = 'ipv6';\n  } else {\n    family = _normalizeFamily(family);\n  }\n\n  var len = 4;\n  if (family === 'ipv6') {\n    len = 16;\n  }\n  var buff = new Buffer(len);\n\n  for (var i = 0, n = buff.length; i < n; ++i) {\n    var bits = 8;\n    if (prefixlen < 8) {\n      bits = prefixlen;\n    }\n    prefixlen -= bits;\n\n    buff[i] = ~(0xff >> bits) & 0xff;\n  }\n\n  return ip.toString(buff);\n};\n\nip.mask = function (addr, mask) {\n  addr = ip.toBuffer(addr);\n  mask = ip.toBuffer(mask);\n\n  var result = new Buffer(Math.max(addr.length, mask.length));\n\n  // Same protocol - do bitwise and\n  var i;\n  if (addr.length === mask.length) {\n    for (i = 0; i < addr.length; i++) {\n      result[i] = addr[i] & mask[i];\n    }\n  } else if (mask.length === 4) {\n    // IPv6 address and IPv4 mask\n    // (Mask low bits)\n    for (i = 0; i < mask.length; i++) {\n      result[i] = addr[addr.length - 4 + i] & mask[i];\n    }\n  } else {\n    // IPv6 mask and IPv4 addr\n    for (i = 0; i < result.length - 6; i++) {\n      result[i] = 0;\n    }\n\n    // ::ffff:ipv4\n    result[10] = 0xff;\n    result[11] = 0xff;\n    for (i = 0; i < addr.length; i++) {\n      result[i + 12] = addr[i] & mask[i + 12];\n    }\n    i += 12;\n  }\n  for (; i < result.length; i++) {\n    result[i] = 0;\n  }\n\n  return ip.toString(result);\n};\n\nip.cidr = function (cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2) {\n    throw new Error(`invalid CIDR subnet: ${addr}`);\n  }\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.mask(addr, mask);\n};\n\nip.subnet = function (addr, mask) {\n  var networkAddress = ip.toLong(ip.mask(addr, mask));\n\n  // Calculate the mask's length.\n  var maskBuffer = ip.toBuffer(mask);\n  var maskLength = 0;\n\n  for (var i = 0; i < maskBuffer.length; i++) {\n    if (maskBuffer[i] === 0xff) {\n      maskLength += 8;\n    } else {\n      var octet = maskBuffer[i] & 0xff;\n      while (octet) {\n        octet = (octet << 1) & 0xff;\n        maskLength++;\n      }\n    }\n  }\n\n  var numberOfAddresses = Math.pow(2, 32 - maskLength);\n\n  return {\n    networkAddress: ip.fromLong(networkAddress),\n    firstAddress: numberOfAddresses <= 2\n      ? ip.fromLong(networkAddress)\n      : ip.fromLong(networkAddress + 1),\n    lastAddress: numberOfAddresses <= 2\n      ? ip.fromLong(networkAddress + numberOfAddresses - 1)\n      : ip.fromLong(networkAddress + numberOfAddresses - 2),\n    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\n    subnetMask: mask,\n    subnetMaskLength: maskLength,\n    numHosts: numberOfAddresses <= 2\n      ? numberOfAddresses : numberOfAddresses - 2,\n    length: numberOfAddresses,\n    contains(other) {\n      return networkAddress === ip.toLong(ip.mask(other, mask));\n    },\n  };\n};\n\nip.cidrSubnet = function (cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2) {\n    throw new Error(`invalid CIDR subnet: ${addr}`);\n  }\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.subnet(addr, mask);\n};\n\nip.not = function (addr) {\n  var buff = ip.toBuffer(addr);\n  for (var i = 0; i < buff.length; i++) {\n    buff[i] = 0xff ^ buff[i];\n  }\n  return ip.toString(buff);\n};\n\nip.or = function (a, b) {\n  var i;\n\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // same protocol\n  if (a.length === b.length) {\n    for (i = 0; i < a.length; ++i) {\n      a[i] |= b[i];\n    }\n    return ip.toString(a);\n\n  // mixed protocols\n  }\n  var buff = a;\n  var other = b;\n  if (b.length > a.length) {\n    buff = b;\n    other = a;\n  }\n\n  var offset = buff.length - other.length;\n  for (i = offset; i < buff.length; ++i) {\n    buff[i] |= other[i - offset];\n  }\n\n  return ip.toString(buff);\n};\n\nip.isEqual = function (a, b) {\n  var i;\n\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // Same protocol\n  if (a.length === b.length) {\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  // Swap\n  if (b.length === 4) {\n    var t = b;\n    b = a;\n    a = t;\n  }\n\n  // a - IPv4, b - IPv6\n  for (i = 0; i < 10; i++) {\n    if (b[i] !== 0) return false;\n  }\n\n  var word = b.readUInt16BE(10);\n  if (word !== 0 && word !== 0xffff) return false;\n\n  for (i = 0; i < 4; i++) {\n    if (a[i] !== b[i + 12]) return false;\n  }\n\n  return true;\n};\n\nip.isPrivate = function (addr) {\n  // check loopback addresses first\n  if (ip.isLoopback(addr)) {\n    return true;\n  }\n\n  // ensure the ipv4 address is valid\n  if (!ip.isV6Format(addr)) {\n    const ipl = ip.normalizeToLong(addr);\n    if (ipl < 0) {\n      throw new Error('invalid ipv4 address');\n    }\n    // normalize the address for the private range checks that follow\n    addr = ip.fromLong(ipl);\n  }\n\n  // check private ranges\n  return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)\n    || /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)\n    || /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n      .test(addr)\n    || /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr)\n    || /^f[cd][0-9a-f]{2}:/i.test(addr)\n    || /^fe80:/i.test(addr)\n    || /^::1$/.test(addr)\n    || /^::$/.test(addr);\n};\n\nip.isPublic = function (addr) {\n  return !ip.isPrivate(addr);\n};\n\nip.isLoopback = function (addr) {\n  // If addr is an IPv4 address in long integer form (no dots and no colons), convert it\n  if (!/\\./.test(addr) && !/:/.test(addr)) {\n    addr = ip.fromLong(Number(addr));\n  }\n\n  return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/\n    .test(addr)\n    || /^0177\\./.test(addr)\n    || /^0x7f\\./i.test(addr)\n    || /^fe80::1$/i.test(addr)\n    || /^::1$/.test(addr)\n    || /^::$/.test(addr);\n};\n\nip.loopback = function (family) {\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  if (family !== 'ipv4' && family !== 'ipv6') {\n    throw new Error('family must be ipv4 or ipv6');\n  }\n\n  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';\n};\n\n//\n// ### function address (name, family)\n// #### @name {string|'public'|'private'} **Optional** Name or security\n//      of the network interface.\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\n//      to ipv4).\n//\n// Returns the address for the network interface on the current system with\n// the specified `name`:\n//   * String: First `family` address of the interface.\n//             If not found see `undefined`.\n//   * 'public': the first public ip address of family.\n//   * 'private': the first private ip address of family.\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\n//\nip.address = function (name, family) {\n  var interfaces = os.networkInterfaces();\n\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  //\n  // If a specific network interface has been named,\n  // return the address.\n  //\n  if (name && name !== 'private' && name !== 'public') {\n    var res = interfaces[name].filter((details) => {\n      var itemFamily = _normalizeFamily(details.family);\n      return itemFamily === family;\n    });\n    if (res.length === 0) {\n      return undefined;\n    }\n    return res[0].address;\n  }\n\n  var all = Object.keys(interfaces).map((nic) => {\n    //\n    // Note: name will only be `public` or `private`\n    // when this is called.\n    //\n    var addresses = interfaces[nic].filter((details) => {\n      details.family = _normalizeFamily(details.family);\n      if (details.family !== family || ip.isLoopback(details.address)) {\n        return false;\n      } if (!name) {\n        return true;\n      }\n\n      return name === 'public' ? ip.isPrivate(details.address)\n        : ip.isPublic(details.address);\n    });\n\n    return addresses.length ? addresses[0].address : undefined;\n  }).filter(Boolean);\n\n  return !all.length ? ip.loopback(family) : all[0];\n};\n\nip.toLong = function (ip) {\n  var ipl = 0;\n  ip.split('.').forEach((octet) => {\n    ipl <<= 8;\n    ipl += parseInt(octet);\n  });\n  return (ipl >>> 0);\n};\n\nip.fromLong = function (ipl) {\n  return (`${ipl >>> 24}.${\n    ipl >> 16 & 255}.${\n    ipl >> 8 & 255}.${\n    ipl & 255}`);\n};\n\nip.normalizeToLong = function (addr) {\n  const parts = addr.split('.').map(part => {\n    // Handle hexadecimal format\n    if (part.startsWith('0x') || part.startsWith('0X')) {\n      return parseInt(part, 16);\n    }\n    // Handle octal format (strictly digits 0-7 after a leading zero)\n    else if (part.startsWith('0') && part !== '0' && /^[0-7]+$/.test(part)) {\n      return parseInt(part, 8);\n    }\n    // Handle decimal format, reject invalid leading zeros\n    else if (/^[1-9]\\d*$/.test(part) || part === '0') {\n      return parseInt(part, 10);\n    }\n    // Return NaN for invalid formats to indicate parsing failure\n    else {\n      return NaN;\n    }\n  });\n\n  if (parts.some(isNaN)) return -1; // Indicate error with -1\n\n  let val = 0;\n  const n = parts.length;\n\n  switch (n) {\n  case 1:\n    val = parts[0];\n    break;\n  case 2:\n    if (parts[0] > 0xff || parts[1] > 0xffffff) return -1;\n    val = (parts[0] << 24) | (parts[1] & 0xffffff);\n    break;\n  case 3:\n    if (parts[0] > 0xff || parts[1] > 0xff || parts[2] > 0xffff) return -1;\n    val = (parts[0] << 24) | (parts[1] << 16) | (parts[2] & 0xffff);\n    break;\n  case 4:\n    if (parts.some(part => part > 0xff)) return -1;\n    val = (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8) | parts[3];\n    break;\n  default:\n    return -1; // Error case\n  }\n\n  return val >>> 0;\n};\n", "/* global describe, it */\nconst assert = require('assert');\nconst { Buffer } = require('buffer');\nconst net = require('net');\nconst os = require('os');\nconst ip = require('..');\n\ndescribe('IP library for node.js', () => {\n  describe('toBuffer()/toString() methods', () => {\n    it('should convert to buffer IPv4 address', () => {\n      const buf = ip.toBuffer('127.0.0.1');\n      assert.equal(buf.toString('hex'), '7f000001');\n      assert.equal(ip.toString(buf), '127.0.0.1');\n    });\n\n    it('should convert to buffer IPv4 address in-place', () => {\n      const buf = new Buffer(128);\n      const offset = 64;\n      ip.toBuffer('127.0.0.1', buf, offset);\n      assert.equal(buf.toString('hex', offset, offset + 4), '7f000001');\n      assert.equal(ip.toString(buf, offset, 4), '127.0.0.1');\n    });\n\n    it('should convert to buffer IPv6 address', () => {\n      const buf = ip.toBuffer('::1');\n      assert(/(00){15,15}01/.test(buf.toString('hex')));\n      assert.equal(ip.toString(buf), '::1');\n      assert.equal(ip.toString(ip.toBuffer('1::')), '1::');\n      assert.equal(ip.toString(ip.toBuffer('abcd::dcba')), 'abcd::dcba');\n    });\n\n    it('should convert to buffer IPv6 address in-place', () => {\n      const buf = new Buffer(128);\n      const offset = 64;\n      ip.toBuffer('::1', buf, offset);\n      assert(/(00){15,15}01/.test(buf.toString('hex', offset, offset + 16)));\n      assert.equal(ip.toString(buf, offset, 16), '::1');\n      assert.equal(ip.toString(\n        ip.toBuffer('1::', buf, offset),\n        offset,\n        16,\n      ), '1::');\n      assert.equal(ip.toString(\n        ip.toBuffer('abcd::dcba', buf, offset),\n        offset,\n        16,\n      ), 'abcd::dcba');\n    });\n\n    it('should convert to buffer IPv6 mapped IPv4 address', () => {\n      let buf = ip.toBuffer('::ffff:127.0.0.1');\n      assert.equal(buf.toString('hex'), '00000000000000000000ffff7f000001');\n      assert.equal(ip.toString(buf), '::ffff:7f00:1');\n\n      buf = ip.toBuffer('ffff::127.0.0.1');\n      assert.equal(buf.toString('hex'), 'ffff000000000000000000007f000001');\n      assert.equal(ip.toString(buf), 'ffff::7f00:1');\n\n      buf = ip.toBuffer('0:0:0:0:0:ffff:127.0.0.1');\n      assert.equal(buf.toString('hex'), '00000000000000000000ffff7f000001');\n      assert.equal(ip.toString(buf), '::ffff:7f00:1');\n    });\n  });\n\n  describe('fromPrefixLen() method', () => {\n    it('should create IPv4 mask', () => {\n      assert.equal(ip.fromPrefixLen(24), '255.255.255.0');\n    });\n    it('should create IPv6 mask', () => {\n      assert.equal(ip.fromPrefixLen(64), 'ffff:ffff:ffff:ffff::');\n    });\n    it('should create IPv6 mask explicitly', () => {\n      assert.equal(ip.fromPrefixLen(24, 'IPV6'), 'ffff:ff00::');\n    });\n  });\n\n  describe('not() method', () => {\n    it('should reverse bits in address', () => {\n      assert.equal(ip.not('255.255.255.0'), '0.0.0.255');\n    });\n  });\n\n  describe('or() method', () => {\n    it('should or bits in ipv4 addresses', () => {\n      assert.equal(ip.or('0.0.0.255', '192.168.1.10'), '192.168.1.255');\n    });\n    it('should or bits in ipv6 addresses', () => {\n      assert.equal(\n        ip.or('::ff', '::abcd:dcba:abcd:dcba'),\n        '::abcd:dcba:abcd:dcff',\n      );\n    });\n    it('should or bits in mixed addresses', () => {\n      assert.equal(\n        ip.or('0.0.0.255', '::abcd:dcba:abcd:dcba'),\n        '::abcd:dcba:abcd:dcff',\n      );\n    });\n  });\n\n  describe('mask() method', () => {\n    it('should mask bits in address', () => {\n      assert.equal(ip.mask('192.168.1.134', '255.255.255.0'), '192.168.1.0');\n      assert.equal(ip.mask('192.168.1.134', '::ffff:ff00'), '::ffff:c0a8:100');\n    });\n\n    it('should not leak data', () => {\n      for (let i = 0; i < 10; i++) {\n        assert.equal(ip.mask('::1', '0.0.0.0'), '::');\n      }\n    });\n  });\n\n  describe('subnet() method', () => {\n    // Test cases calculated with http://www.subnet-calculator.com/\n    const ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.192');\n\n    it('should compute ipv4 network address', () => {\n      assert.equal(ipv4Subnet.networkAddress, '192.168.1.128');\n    });\n\n    it('should compute ipv4 network\\'s first address', () => {\n      assert.equal(ipv4Subnet.firstAddress, '192.168.1.129');\n    });\n\n    it('should compute ipv4 network\\'s last address', () => {\n      assert.equal(ipv4Subnet.lastAddress, '192.168.1.190');\n    });\n\n    it('should compute ipv4 broadcast address', () => {\n      assert.equal(ipv4Subnet.broadcastAddress, '192.168.1.191');\n    });\n\n    it('should compute ipv4 subnet number of addresses', () => {\n      assert.equal(ipv4Subnet.length, 64);\n    });\n\n    it('should compute ipv4 subnet number of addressable hosts', () => {\n      assert.equal(ipv4Subnet.numHosts, 62);\n    });\n\n    it('should compute ipv4 subnet mask', () => {\n      assert.equal(ipv4Subnet.subnetMask, '255.255.255.192');\n    });\n\n    it('should compute ipv4 subnet mask\\'s length', () => {\n      assert.equal(ipv4Subnet.subnetMaskLength, 26);\n    });\n\n    it('should know whether a subnet contains an address', () => {\n      assert.equal(ipv4Subnet.contains('192.168.1.180'), true);\n    });\n\n    it('should know whether a subnet does not contain an address', () => {\n      assert.equal(ipv4Subnet.contains('192.168.1.195'), false);\n    });\n  });\n\n  describe('subnet() method with mask length 32', () => {\n    // Test cases calculated with http://www.subnet-calculator.com/\n    const ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.255');\n    it('should compute ipv4 network\\'s first address', () => {\n      assert.equal(ipv4Subnet.firstAddress, '192.168.1.134');\n    });\n\n    it('should compute ipv4 network\\'s last address', () => {\n      assert.equal(ipv4Subnet.lastAddress, '192.168.1.134');\n    });\n\n    it('should compute ipv4 subnet number of addressable hosts', () => {\n      assert.equal(ipv4Subnet.numHosts, 1);\n    });\n  });\n\n  describe('subnet() method with mask length 31', () => {\n    // Test cases calculated with http://www.subnet-calculator.com/\n    const ipv4Subnet = ip.subnet('192.168.1.134', '255.255.255.254');\n    it('should compute ipv4 network\\'s first address', () => {\n      assert.equal(ipv4Subnet.firstAddress, '192.168.1.134');\n    });\n\n    it('should compute ipv4 network\\'s last address', () => {\n      assert.equal(ipv4Subnet.lastAddress, '192.168.1.135');\n    });\n\n    it('should compute ipv4 subnet number of addressable hosts', () => {\n      assert.equal(ipv4Subnet.numHosts, 2);\n    });\n  });\n\n  describe('cidrSubnet() method', () => {\n    // Test cases calculated with http://www.subnet-calculator.com/\n    const ipv4Subnet = ip.cidrSubnet('192.168.1.134/26');\n\n    it('should compute an ipv4 network address', () => {\n      assert.equal(ipv4Subnet.networkAddress, '192.168.1.128');\n    });\n\n    it('should compute an ipv4 network\\'s first address', () => {\n      assert.equal(ipv4Subnet.firstAddress, '192.168.1.129');\n    });\n\n    it('should compute an ipv4 network\\'s last address', () => {\n      assert.equal(ipv4Subnet.lastAddress, '192.168.1.190');\n    });\n\n    it('should compute an ipv4 broadcast address', () => {\n      assert.equal(ipv4Subnet.broadcastAddress, '192.168.1.191');\n    });\n\n    it('should compute an ipv4 subnet number of addresses', () => {\n      assert.equal(ipv4Subnet.length, 64);\n    });\n\n    it('should compute an ipv4 subnet number of addressable hosts', () => {\n      assert.equal(ipv4Subnet.numHosts, 62);\n    });\n\n    it('should compute an ipv4 subnet mask', () => {\n      assert.equal(ipv4Subnet.subnetMask, '255.255.255.192');\n    });\n\n    it('should compute an ipv4 subnet mask\\'s length', () => {\n      assert.equal(ipv4Subnet.subnetMaskLength, 26);\n    });\n\n    it('should know whether a subnet contains an address', () => {\n      assert.equal(ipv4Subnet.contains('192.168.1.180'), true);\n    });\n\n    it('should know whether a subnet contains an address', () => {\n      assert.equal(ipv4Subnet.contains('192.168.1.195'), false);\n    });\n  });\n\n  describe('cidr() method', () => {\n    it('should mask address in CIDR notation', () => {\n      assert.equal(ip.cidr('192.168.1.134/26'), '192.168.1.128');\n      assert.equal(ip.cidr('2607:f0d0:1002:51::4/56'), '2607:f0d0:1002::');\n    });\n  });\n\n  describe('isEqual() method', () => {\n    it('should check if addresses are equal', () => {\n      assert(ip.isEqual('127.0.0.1', '::7f00:1'));\n      assert(!ip.isEqual('127.0.0.1', '::7f00:2'));\n      assert(ip.isEqual('127.0.0.1', '::ffff:7f00:1'));\n      assert(!ip.isEqual('127.0.0.1', '::ffaf:7f00:1'));\n      assert(ip.isEqual('::ffff:127.0.0.1', '::ffff:127.0.0.1'));\n      assert(ip.isEqual('::ffff:127.0.0.1', '127.0.0.1'));\n    });\n  });\n\n  describe('normalizeIpv4() method', () => {\n    // Testing valid inputs with different notations\n    it('should correctly normalize \"127.0.0.1\"', () => {\n      assert.equal(ip.normalizeToLong('127.0.0.1'), 2130706433);\n    });\n\n    it('should correctly handle \"127.1\" as two parts', () => {\n      assert.equal(ip.normalizeToLong('127.1'), 2130706433);\n    });\n\n    it('should correctly handle \"127.0.1\" as three parts', () => {\n      assert.equal(ip.normalizeToLong('127.0.1'), 2130706433);\n    });\n\n\n    it('should correctly handle hexadecimal notation \"0x7f.0x0.0x0.0x1\"', () => {\n      assert.equal(ip.normalizeToLong('0x7f.0x0.0x0.0x1'), 2130706433);\n    });\n\n    // Testing with fewer than 4 parts\n    it('should correctly handle \"0x7f000001\" as a single part', () => {\n      assert.equal(ip.normalizeToLong('0x7f000001'), 2130706433);\n    });\n\n    it('should correctly handle octal notation \"010.0.0.01\"', () => {\n      assert.equal(ip.normalizeToLong('010.0.0.01'), 134217729);\n    });\n\n    // Testing invalid inputs\n    it('should return -1 for an invalid address \"256.100.50.25\"', () => {\n      assert.equal(ip.normalizeToLong('256.100.50.25'), -1);\n    });\n\n    it('should return -1 for an address with invalid octal \"019.0.0.1\"', () => {\n      assert.equal(ip.normalizeToLong('019.0.0.1'), -1);\n    });\n\n    it('should return -1 for an address with invalid hex \"0xGG.0.0.1\"', () => {\n      assert.equal(ip.normalizeToLong('0xGG.0.0.1'), -1);\n    });\n\n    // Testing edge cases\n    it('should return -1 for an empty string', () => {\n      assert.equal(ip.normalizeToLong(''), -1);\n    });\n\n    it('should return -1 for a string with too many parts \"192.168.0.1.100\"', () => {\n      assert.equal(ip.normalizeToLong('192.168.0.1.100'), -1);\n    });\n  });\n\n  describe('isPrivate() method', () => {\n    it('should check if an address is localhost', () => {\n      assert.equal(ip.isPrivate('127.0.0.1'), true);\n    });\n\n    it('should check if an address is from a 192.168.x.x network', () => {\n      assert.equal(ip.isPrivate('192.168.0.123'), true);\n      assert.equal(ip.isPrivate('192.168.122.123'), true);\n      assert.equal(ip.isPrivate('192.162.1.2'), false);\n    });\n\n    it('should check if an address is from a 172.16.x.x network', () => {\n      assert.equal(ip.isPrivate('172.16.0.5'), true);\n      assert.equal(ip.isPrivate('172.16.123.254'), true);\n      assert.equal(ip.isPrivate('171.16.0.5'), false);\n      assert.equal(ip.isPrivate('172.25.232.15'), true);\n      assert.equal(ip.isPrivate('172.15.0.5'), false);\n      assert.equal(ip.isPrivate('172.32.0.5'), false);\n    });\n\n    it('should check if an address is from a 169.254.x.x network', () => {\n      assert.equal(ip.isPrivate('169.254.2.3'), true);\n      assert.equal(ip.isPrivate('169.254.221.9'), true);\n      assert.equal(ip.isPrivate('168.254.2.3'), false);\n    });\n\n    it('should check if an address is from a 10.x.x.x network', () => {\n      assert.equal(ip.isPrivate('10.0.2.3'), true);\n      assert.equal(ip.isPrivate('10.1.23.45'), true);\n      assert.equal(ip.isPrivate('12.1.2.3'), false);\n    });\n\n    it('should check if an address is from a private IPv6 network', () => {\n      assert.equal(ip.isPrivate('fd12:3456:789a:1::1'), true);\n      assert.equal(ip.isPrivate('fe80::f2de:f1ff:fe3f:307e'), true);\n      assert.equal(ip.isPrivate('::ffff:10.100.1.42'), true);\n      assert.equal(ip.isPrivate('::FFFF:172.16.200.1'), true);\n      assert.equal(ip.isPrivate('::ffff:192.168.0.1'), true);\n    });\n\n    it('should check if an address is from the internet', () => {\n      assert.equal(ip.isPrivate('165.225.132.33'), false); // joyent.com\n    });\n\n    it('should check if an address is a loopback IPv6 address', () => {\n      assert.equal(ip.isPrivate('::'), true);\n      assert.equal(ip.isPrivate('::1'), true);\n      assert.equal(ip.isPrivate('fe80::1'), true);\n    });\n\n    it('should correctly identify hexadecimal IP addresses like \\'0x7f.1\\' as private', () => {\n      assert.equal(ip.isPrivate('0x7f.1'), true);\n    });\n  });\n\n  describe('loopback() method', () => {\n    describe('undefined', () => {\n      it('should respond with 127.0.0.1', () => {\n        assert.equal(ip.loopback(), '127.0.0.1');\n      });\n    });\n\n    describe('ipv4', () => {\n      it('should respond with 127.0.0.1', () => {\n        assert.equal(ip.loopback('ipv4'), '127.0.0.1');\n      });\n    });\n\n    describe('ipv6', () => {\n      it('should respond with fe80::1', () => {\n        assert.equal(ip.loopback('ipv6'), 'fe80::1');\n      });\n    });\n  });\n\n  describe('isLoopback() method', () => {\n    describe('127.0.0.1', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('127.0.0.1'));\n      });\n    });\n\n    describe('127.8.8.8', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('127.8.8.8'));\n      });\n    });\n\n    describe('8.8.8.8', () => {\n      it('should respond with false', () => {\n        assert.equal(ip.isLoopback('8.8.8.8'), false);\n      });\n    });\n\n    describe('fe80::1', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('fe80::1'));\n      });\n    });\n\n    describe('::1', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('::1'));\n      });\n    });\n\n    describe('::', () => {\n      it('should respond with true', () => {\n        assert.ok(ip.isLoopback('::'));\n      });\n    });\n  });\n\n  describe('address() method', () => {\n    describe('undefined', () => {\n      it('should respond with a private ip', () => {\n        assert.ok(ip.isPrivate(ip.address()));\n      });\n    });\n\n    describe('private', () => {\n      [undefined, 'ipv4', 'ipv6'].forEach((family) => {\n        describe(family || 'undefined', () => {\n          it('should respond with a private ip', () => {\n            assert.ok(ip.isPrivate(ip.address('private', family)));\n          });\n        });\n      });\n    });\n\n    const interfaces = os.networkInterfaces();\n\n    Object.keys(interfaces).forEach((nic) => {\n      describe(nic, () => {\n        [undefined, 'ipv4'].forEach((family) => {\n          describe(family || 'undefined', () => {\n            it('should respond with an ipv4 address', () => {\n              const addr = ip.address(nic, family);\n              assert.ok(!addr || net.isIPv4(addr));\n            });\n          });\n        });\n\n        describe('ipv6', () => {\n          it('should respond with an ipv6 address', () => {\n            const addr = ip.address(nic, 'ipv6');\n            assert.ok(!addr || net.isIPv6(addr));\n          });\n        });\n      });\n    });\n  });\n\n  describe('toLong() method', () => {\n    it('should respond with a int', () => {\n      assert.equal(ip.toLong('127.0.0.1'), 2130706433);\n      assert.equal(ip.toLong('255.255.255.255'), 4294967295);\n    });\n  });\n\n  describe('fromLong() method', () => {\n    it('should repond with ipv4 address', () => {\n      assert.equal(ip.fromLong(2130706433), '127.0.0.1');\n      assert.equal(ip.fromLong(4294967295), '255.255.255.255');\n    });\n  });\n\n  // IPv4 loopback in octal notation\n  it('should return true for octal representation \"0177.0.0.1\"', () => {\n    assert.equal(ip.isLoopback('0177.0.0.1'), true);\n  });\n\n  it('should return true for octal representation \"0177.0.1\"', () => {\n    assert.equal(ip.isLoopback('0177.0.1'), true);\n  });\n\n  it('should return true for octal representation \"0177.1\"', () => {\n    assert.equal(ip.isLoopback('0177.1'), true);\n  });\n\n  // IPv4 loopback in hexadecimal notation\n  it('should return true for hexadecimal representation \"0x7f.0.0.1\"', () => {\n    assert.equal(ip.isLoopback('0x7f.0.0.1'), true);\n  });\n\n  // IPv4 loopback in hexadecimal notation\n  it('should return true for hexadecimal representation \"0x7f.0.1\"', () => {\n    assert.equal(ip.isLoopback('0x7f.0.1'), true);\n  });\n\n  // IPv4 loopback in hexadecimal notation\n  it('should return true for hexadecimal representation \"0x7f.1\"', () => {\n    assert.equal(ip.isLoopback('0x7f.1'), true);\n  });\n\n  // IPv4 loopback as a single long integer\n  it('should return true for single long integer representation \"2130706433\"', () => {\n    assert.equal(ip.isLoopback('2130706433'), true);\n  });\n\n  // IPv4 non-loopback address\n  it('should return false for \"192.168.1.1\"', () => {\n    assert.equal(ip.isLoopback('192.168.1.1'), false);\n  });\n});\n"], "filenames": ["lib/ip.js", "test/api-test.js"], "buggy_code_start_loc": [314, 253], "buggy_code_end_loc": [427, 415], "fixing_code_start_loc": [314, 254], "fixing_code_end_loc": [497, 509], "type": "CWE-918", "message": "The ip package before 1.1.9 for Node.js might allow SSRF because some IP addresses (such as 0x7f.1) are improperly categorized as globally routable via isPublic.", "other": {"cve": {"id": "CVE-2023-42282", "sourceIdentifier": "cve@mitre.org", "published": "2024-02-08T17:15:10.840", "lastModified": "2024-03-06T15:26:20.373", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ip package before 1.1.9 for Node.js might allow SSRF because some IP addresses (such as 0x7f.1) are improperly categorized as globally routable via isPublic."}, {"lang": "es", "value": "Un problema en el paquete IP NPM v.1.1.8 y anteriores permite a un atacante ejecutar c\u00f3digo arbitrario y obtener informaci\u00f3n confidencial a trav\u00e9s de la funci\u00f3n isPublic()."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fedorindutny:ip:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "1.1.8", "matchCriteriaId": "5E811BCA-8109-4EA6-ACCC-7D7A6BCD6BB1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fedorindutny:ip:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "8822A2CE-A9A4-4308-998A-258BF20B355C"}]}]}], "references": [{"url": "https://cosmosofcyberspace.github.io/npm_ip_cve/npm_ip_cve.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/indutny/node-ip/commit/6a3ada9b471b09d5f0f5be264911ab564bf67894", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/bfc3b23f-ddc0-4ee7-afab-223b07115ed3/", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description"]}]}, "github_commit_url": "https://github.com/indutny/node-ip/commit/6a3ada9b471b09d5f0f5be264911ab564bf67894"}}