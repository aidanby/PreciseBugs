{"buggy_code": ["/*\n * Implementation of the security services.\n *\n * Authors : Stephen Smalley, <sds@epoch.ncsc.mil>\n *\t     James Morris <jmorris@redhat.com>\n *\n * Updated: Trusted Computer Solutions, Inc. <dgoeddel@trustedcs.com>\n *\n *\tSupport for enhanced MLS infrastructure.\n *\tSupport for context based audit filters.\n *\n * Updated: Frank Mayer <mayerf@tresys.com> and Karl MacMillan <kmacmillan@tresys.com>\n *\n *\tAdded conditional policy language extensions\n *\n * Updated: Hewlett-Packard <paul@paul-moore.com>\n *\n *      Added support for NetLabel\n *      Added support for the policy capability bitmap\n *\n * Updated: Chad Sellers <csellers@tresys.com>\n *\n *  Added validation of kernel classes and permissions\n *\n * Updated: KaiGai Kohei <kaigai@ak.jp.nec.com>\n *\n *  Added support for bounds domain and audit messaged on masked permissions\n *\n * Updated: Guido Trentalancia <guido@trentalancia.com>\n *\n *  Added support for runtime switching of the policy type\n *\n * Copyright (C) 2008, 2009 NEC Corporation\n * Copyright (C) 2006, 2007 Hewlett-Packard Development Company, L.P.\n * Copyright (C) 2004-2006 Trusted Computer Solutions, Inc.\n * Copyright (C) 2003 - 2004, 2006 Tresys Technology, LLC\n * Copyright (C) 2003 Red Hat, Inc., James Morris <jmorris@redhat.com>\n *\tThis program is free software; you can redistribute it and/or modify\n *\tit under the terms of the GNU General Public License as published by\n *\tthe Free Software Foundation, version 2.\n */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/sched.h>\n#include <linux/audit.h>\n#include <linux/mutex.h>\n#include <linux/selinux.h>\n#include <linux/flex_array.h>\n#include <linux/vmalloc.h>\n#include <net/netlabel.h>\n\n#include \"flask.h\"\n#include \"avc.h\"\n#include \"avc_ss.h\"\n#include \"security.h\"\n#include \"context.h\"\n#include \"policydb.h\"\n#include \"sidtab.h\"\n#include \"services.h\"\n#include \"conditional.h\"\n#include \"mls.h\"\n#include \"objsec.h\"\n#include \"netlabel.h\"\n#include \"xfrm.h\"\n#include \"ebitmap.h\"\n#include \"audit.h\"\n\nint selinux_policycap_netpeer;\nint selinux_policycap_openperm;\nint selinux_policycap_alwaysnetwork;\n\nstatic DEFINE_RWLOCK(policy_rwlock);\n\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\n/*\n * The largest sequence number that has been used when\n * providing an access decision to the access vector cache.\n * The sequence number only changes when a policy change\n * occurs.\n */\nstatic u32 latest_granting;\n\n/* Forward declaration. */\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t      struct context *tcontext,\n\t\t\t\t      u16 tclass,\n\t\t\t\t      struct av_decision *avd);\n\nstruct selinux_mapping {\n\tu16 value; /* policy value */\n\tunsigned num_perms;\n\tu32 perms[sizeof(u32) * 8];\n};\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic int selinux_set_mapping(struct policydb *pol,\n\t\t\t       struct security_class_mapping *map,\n\t\t\t       struct selinux_mapping **out_map_p,\n\t\t\t       u16 *out_map_size)\n{\n\tstruct selinux_mapping *out_map = NULL;\n\tsize_t size = sizeof(struct selinux_mapping);\n\tu16 i, j;\n\tunsigned k;\n\tbool print_unknown_handle = false;\n\n\t/* Find number of classes in the input mapping */\n\tif (!map)\n\t\treturn -EINVAL;\n\ti = 0;\n\twhile (map[i].name)\n\t\ti++;\n\n\t/* Allocate space for the class records, plus one for class zero */\n\tout_map = kcalloc(++i, size, GFP_ATOMIC);\n\tif (!out_map)\n\t\treturn -ENOMEM;\n\n\t/* Store the raw class and permission values */\n\tj = 0;\n\twhile (map[j].name) {\n\t\tstruct security_class_mapping *p_in = map + (j++);\n\t\tstruct selinux_mapping *p_out = out_map + j;\n\n\t\t/* An empty class string skips ahead */\n\t\tif (!strcmp(p_in->name, \"\")) {\n\t\t\tp_out->num_perms = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp_out->value = string_to_security_class(pol, p_in->name);\n\t\tif (!p_out->value) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"SELinux:  Class %s not defined in policy.\\n\",\n\t\t\t       p_in->name);\n\t\t\tif (pol->reject_unknown)\n\t\t\t\tgoto err;\n\t\t\tp_out->num_perms = 0;\n\t\t\tprint_unknown_handle = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tk = 0;\n\t\twhile (p_in->perms && p_in->perms[k]) {\n\t\t\t/* An empty permission string skips ahead */\n\t\t\tif (!*p_in->perms[k]) {\n\t\t\t\tk++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp_out->perms[k] = string_to_av_perm(pol, p_out->value,\n\t\t\t\t\t\t\t    p_in->perms[k]);\n\t\t\tif (!p_out->perms[k]) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"SELinux:  Permission %s in class %s not defined in policy.\\n\",\n\t\t\t\t       p_in->perms[k], p_in->name);\n\t\t\t\tif (pol->reject_unknown)\n\t\t\t\t\tgoto err;\n\t\t\t\tprint_unknown_handle = true;\n\t\t\t}\n\n\t\t\tk++;\n\t\t}\n\t\tp_out->num_perms = k;\n\t}\n\n\tif (print_unknown_handle)\n\t\tprintk(KERN_INFO \"SELinux: the above unknown classes and permissions will be %s\\n\",\n\t\t       pol->allow_unknown ? \"allowed\" : \"denied\");\n\n\t*out_map_p = out_map;\n\t*out_map_size = i;\n\treturn 0;\nerr:\n\tkfree(out_map);\n\treturn -EINVAL;\n}\n\n/*\n * Get real, policy values from mapped values\n */\n\nstatic u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}\n\n/*\n * Get kernel value for class from its policy value\n */\nstatic u16 map_class(u16 pol_value)\n{\n\tu16 i;\n\n\tfor (i = 1; i < current_mapping_size; i++) {\n\t\tif (current_mapping[i].value == pol_value)\n\t\t\treturn i;\n\t}\n\n\treturn SECCLASS_NULL;\n}\n\nstatic void map_decision(u16 tclass, struct av_decision *avd,\n\t\t\t int allow_unknown)\n{\n\tif (tclass < current_mapping_size) {\n\t\tunsigned i, n = current_mapping[tclass].num_perms;\n\t\tu32 result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->allowed & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\tavd->allowed = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++)\n\t\t\tif (avd->auditallow & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\tavd->auditallow = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->auditdeny & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (!allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\t/*\n\t\t * In case the kernel has a bug and requests a permission\n\t\t * between num_perms and the maximum permission number, we\n\t\t * should audit that denial\n\t\t */\n\t\tfor (; i < (sizeof(u32)*8); i++)\n\t\t\tresult |= 1<<i;\n\t\tavd->auditdeny = result;\n\t}\n}\n\nint security_mls_enabled(void)\n{\n\treturn policydb.mls_enabled;\n}\n\n/*\n * Return the boolean value of a constraint expression\n * when it is applied to the specified source and target\n * security contexts.\n *\n * xcontext is a special beast...  It is used by the validatetrans rules\n * only.  For these rules, scontext is the context before the transition,\n * tcontext is the context after the transition, and xcontext is the context\n * of the process performing the transition.  All other callers of\n * constraint_expr_eval should pass in NULL for xcontext.\n */\nstatic int constraint_expr_eval(struct context *scontext,\n\t\t\t\tstruct context *tcontext,\n\t\t\t\tstruct context *xcontext,\n\t\t\t\tstruct constraint_expr *cexpr)\n{\n\tu32 val1, val2;\n\tstruct context *c;\n\tstruct role_datum *r1, *r2;\n\tstruct mls_level *l1, *l2;\n\tstruct constraint_expr *e;\n\tint s[CEXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (e = cexpr; e; e = e->next) {\n\t\tswitch (e->expr_type) {\n\t\tcase CEXPR_NOT:\n\t\t\tBUG_ON(sp < 0);\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase CEXPR_AND:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_OR:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_ATTR:\n\t\t\tif (sp == (CEXPR_MAXDEPTH - 1))\n\t\t\t\treturn 0;\n\t\t\tswitch (e->attr) {\n\t\t\tcase CEXPR_USER:\n\t\t\t\tval1 = scontext->user;\n\t\t\t\tval2 = tcontext->user;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_TYPE:\n\t\t\t\tval1 = scontext->type;\n\t\t\t\tval2 = tcontext->type;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ROLE:\n\t\t\t\tval1 = scontext->role;\n\t\t\t\tval2 = tcontext->role;\n\t\t\t\tr1 = policydb.role_val_to_struct[val1 - 1];\n\t\t\t\tr2 = policydb.role_val_to_struct[val2 - 1];\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t  val2 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t  val1 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = (!ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t    val2 - 1) &&\n\t\t\t\t\t\t   !ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t    val1 - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_L1L2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1L2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1H2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H1:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(scontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L2H2:\n\t\t\t\tl1 = &(tcontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\nmls_ops:\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOM:\n\t\t\t\ts[++sp] = mls_level_dom(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOMBY:\n\t\t\t\ts[++sp] = mls_level_dom(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_INCOMP:\n\t\t\t\ts[++sp] = mls_level_incomp(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = (val1 == val2);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = (val1 != val2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEXPR_NAMES:\n\t\t\tif (sp == (CEXPR_MAXDEPTH-1))\n\t\t\t\treturn 0;\n\t\t\tc = scontext;\n\t\t\tif (e->attr & CEXPR_TARGET)\n\t\t\t\tc = tcontext;\n\t\t\telse if (e->attr & CEXPR_XTARGET) {\n\t\t\t\tc = xcontext;\n\t\t\t\tif (!c) {\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->attr & CEXPR_USER)\n\t\t\t\tval1 = c->user;\n\t\t\telse if (e->attr & CEXPR_ROLE)\n\t\t\t\tval1 = c->role;\n\t\t\telse if (e->attr & CEXPR_TYPE)\n\t\t\t\tval1 = c->type;\n\t\t\telse {\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(sp != 0);\n\treturn s[0];\n}\n\n/*\n * security_dump_masked_av - dumps masked permissions during\n * security_compute_av due to RBAC, MLS/Constraint and Type bounds.\n */\nstatic int dump_masked_av_helper(void *k, void *d, void *args)\n{\n\tstruct perm_datum *pdatum = d;\n\tchar **permission_names = args;\n\n\tBUG_ON(pdatum->value < 1 || pdatum->value > 32);\n\n\tpermission_names[pdatum->value - 1] = (char *)k;\n\n\treturn 0;\n}\n\nstatic void security_dump_masked_av(struct context *scontext,\n\t\t\t\t    struct context *tcontext,\n\t\t\t\t    u16 tclass,\n\t\t\t\t    u32 permissions,\n\t\t\t\t    const char *reason)\n{\n\tstruct common_datum *common_dat;\n\tstruct class_datum *tclass_dat;\n\tstruct audit_buffer *ab;\n\tchar *tclass_name;\n\tchar *scontext_name = NULL;\n\tchar *tcontext_name = NULL;\n\tchar *permission_names[32];\n\tint index;\n\tu32 length;\n\tbool need_comma = false;\n\n\tif (!permissions)\n\t\treturn;\n\n\ttclass_name = sym_name(&policydb, SYM_CLASSES, tclass - 1);\n\ttclass_dat = policydb.class_val_to_struct[tclass - 1];\n\tcommon_dat = tclass_dat->comdatum;\n\n\t/* init permission_names */\n\tif (common_dat &&\n\t    hashtab_map(common_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\tif (hashtab_map(tclass_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\t/* get scontext/tcontext in text form */\n\tif (context_struct_to_string(scontext,\n\t\t\t\t     &scontext_name, &length) < 0)\n\t\tgoto out;\n\n\tif (context_struct_to_string(tcontext,\n\t\t\t\t     &tcontext_name, &length) < 0)\n\t\tgoto out;\n\n\t/* audit a message */\n\tab = audit_log_start(current->audit_context,\n\t\t\t     GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\tif (!ab)\n\t\tgoto out;\n\n\taudit_log_format(ab, \"op=security_compute_av reason=%s \"\n\t\t\t \"scontext=%s tcontext=%s tclass=%s perms=\",\n\t\t\t reason, scontext_name, tcontext_name, tclass_name);\n\n\tfor (index = 0; index < 32; index++) {\n\t\tu32 mask = (1 << index);\n\n\t\tif ((mask & permissions) == 0)\n\t\t\tcontinue;\n\n\t\taudit_log_format(ab, \"%s%s\",\n\t\t\t\t need_comma ? \",\" : \"\",\n\t\t\t\t permission_names[index]\n\t\t\t\t ? permission_names[index] : \"????\");\n\t\tneed_comma = true;\n\t}\n\taudit_log_end(ab);\nout:\n\t/* release scontext/tcontext */\n\tkfree(tcontext_name);\n\tkfree(scontext_name);\n\n\treturn;\n}\n\n/*\n * security_boundary_permission - drops violated permissions\n * on boundary constraint.\n */\nstatic void type_attribute_bounds_av(struct context *scontext,\n\t\t\t\t     struct context *tcontext,\n\t\t\t\t     u16 tclass,\n\t\t\t\t     struct av_decision *avd)\n{\n\tstruct context lo_scontext;\n\tstruct context lo_tcontext;\n\tstruct av_decision lo_avd;\n\tstruct type_datum *source;\n\tstruct type_datum *target;\n\tu32 masked = 0;\n\n\tsource = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    scontext->type - 1);\n\tBUG_ON(!source);\n\n\ttarget = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    tcontext->type - 1);\n\tBUG_ON(!target);\n\n\tif (source->bounds) {\n\t\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\n\t\tmemcpy(&lo_scontext, scontext, sizeof(lo_scontext));\n\t\tlo_scontext.type = source->bounds;\n\n\t\tcontext_struct_compute_av(&lo_scontext,\n\t\t\t\t\t  tcontext,\n\t\t\t\t\t  tclass,\n\t\t\t\t\t  &lo_avd);\n\t\tif ((lo_avd.allowed & avd->allowed) == avd->allowed)\n\t\t\treturn;\t\t/* no masked permission */\n\t\tmasked = ~lo_avd.allowed & avd->allowed;\n\t}\n\n\tif (target->bounds) {\n\t\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\n\t\tmemcpy(&lo_tcontext, tcontext, sizeof(lo_tcontext));\n\t\tlo_tcontext.type = target->bounds;\n\n\t\tcontext_struct_compute_av(scontext,\n\t\t\t\t\t  &lo_tcontext,\n\t\t\t\t\t  tclass,\n\t\t\t\t\t  &lo_avd);\n\t\tif ((lo_avd.allowed & avd->allowed) == avd->allowed)\n\t\t\treturn;\t\t/* no masked permission */\n\t\tmasked = ~lo_avd.allowed & avd->allowed;\n\t}\n\n\tif (source->bounds && target->bounds) {\n\t\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\t\t/*\n\t\t * lo_scontext and lo_tcontext are already\n\t\t * set up.\n\t\t */\n\n\t\tcontext_struct_compute_av(&lo_scontext,\n\t\t\t\t\t  &lo_tcontext,\n\t\t\t\t\t  tclass,\n\t\t\t\t\t  &lo_avd);\n\t\tif ((lo_avd.allowed & avd->allowed) == avd->allowed)\n\t\t\treturn;\t\t/* no masked permission */\n\t\tmasked = ~lo_avd.allowed & avd->allowed;\n\t}\n\n\tif (masked) {\n\t\t/* mask violated permissions */\n\t\tavd->allowed &= ~masked;\n\n\t\t/* audit masked permissions */\n\t\tsecurity_dump_masked_av(scontext, tcontext,\n\t\t\t\t\ttclass, masked, \"bounds\");\n\t}\n}\n\n/*\n * Compute access vectors based on a context structure pair for\n * the permissions in a particular class.\n */\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t      struct context *tcontext,\n\t\t\t\t      u16 tclass,\n\t\t\t\t      struct av_decision *avd)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.data;\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey, avd);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}\n\nstatic int security_validtrans_handle_fail(struct context *ocontext,\n\t\t\t\t\t   struct context *ncontext,\n\t\t\t\t\t   struct context *tcontext,\n\t\t\t\t\t   u16 tclass)\n{\n\tchar *o = NULL, *n = NULL, *t = NULL;\n\tu32 olen, nlen, tlen;\n\n\tif (context_struct_to_string(ocontext, &o, &olen))\n\t\tgoto out;\n\tif (context_struct_to_string(ncontext, &n, &nlen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"security_validate_transition:  denied for\"\n\t\t  \" oldcontext=%s newcontext=%s taskcontext=%s tclass=%s\",\n\t\t  o, n, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(o);\n\tkfree(n);\n\tkfree(t);\n\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EPERM;\n}\n\nint security_validate_transition(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t u16 orig_tclass)\n{\n\tstruct context *ocontext;\n\tstruct context *ncontext;\n\tstruct context *tcontext;\n\tstruct class_datum *tclass_datum;\n\tstruct constraint_node *constraint;\n\tu16 tclass;\n\tint rc = 0;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\ttclass = unmap_class(orig_tclass);\n\n\tif (!tclass || tclass > policydb.p_classes.nprim) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized class %d\\n\",\n\t\t\t__func__, tclass);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\tocontext = sidtab_search(&sidtab, oldsid);\n\tif (!ocontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, oldsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tncontext = sidtab_search(&sidtab, newsid);\n\tif (!ncontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, newsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tasksid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, tasksid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconstraint = tclass_datum->validatetrans;\n\twhile (constraint) {\n\t\tif (!constraint_expr_eval(ocontext, ncontext, tcontext,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\trc = security_validtrans_handle_fail(ocontext, ncontext,\n\t\t\t\t\t\t\t     tcontext, tclass);\n\t\t\tgoto out;\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n/*\n * security_bounded_transition - check whether the given\n * transition is directed to bounded, or not.\n * It returns 0, if @newsid is bounded by @oldsid.\n * Otherwise, it returns error code.\n *\n * @oldsid : current security identifier\n * @newsid : destinated security identifier\n */\nint security_bounded_transition(u32 old_sid, u32 new_sid)\n{\n\tstruct context *old_context, *new_context;\n\tstruct type_datum *type;\n\tint index;\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\told_context = sidtab_search(&sidtab, old_sid);\n\tif (!old_context) {\n\t\tprintk(KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, old_sid);\n\t\tgoto out;\n\t}\n\n\trc = -EINVAL;\n\tnew_context = sidtab_search(&sidtab, new_sid);\n\tif (!new_context) {\n\t\tprintk(KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, new_sid);\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\t/* type/domain unchanged */\n\tif (old_context->type == new_context->type)\n\t\tgoto out;\n\n\tindex = new_context->type;\n\twhile (true) {\n\t\ttype = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t\t  index - 1);\n\t\tBUG_ON(!type);\n\n\t\t/* not bounded anymore */\n\t\trc = -EPERM;\n\t\tif (!type->bounds)\n\t\t\tbreak;\n\n\t\t/* @newsid is bounded by @oldsid */\n\t\trc = 0;\n\t\tif (type->bounds == old_context->type)\n\t\t\tbreak;\n\n\t\tindex = type->bounds;\n\t}\n\n\tif (rc) {\n\t\tchar *old_name = NULL;\n\t\tchar *new_name = NULL;\n\t\tu32 length;\n\n\t\tif (!context_struct_to_string(old_context,\n\t\t\t\t\t      &old_name, &length) &&\n\t\t    !context_struct_to_string(new_context,\n\t\t\t\t\t      &new_name, &length)) {\n\t\t\taudit_log(current->audit_context,\n\t\t\t\t  GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t\t  \"op=security_bounded_transition \"\n\t\t\t\t  \"result=denied \"\n\t\t\t\t  \"oldcontext=%s newcontext=%s\",\n\t\t\t\t  old_name, new_name);\n\t\t}\n\t\tkfree(new_name);\n\t\tkfree(old_name);\n\t}\nout:\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}\n\nstatic void avd_init(struct av_decision *avd)\n{\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tavd->seqno = latest_granting;\n\tavd->flags = 0;\n}\n\n\n/**\n * security_compute_av - Compute access vector decisions.\n * @ssid: source security identifier\n * @tsid: target security identifier\n * @tclass: target security class\n * @avd: access vector decisions\n *\n * Compute a set of access vector decisions based on the\n * SID pair (@ssid, @tsid) for the permissions in @tclass.\n */\nvoid security_compute_av(u32 ssid,\n\t\t\t u32 tsid,\n\t\t\t u16 orig_tclass,\n\t\t\t struct av_decision *avd)\n{\n\tu16 tclass;\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd);\n\tmap_decision(orig_tclass, avd, policydb.allow_unknown);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}\n\nvoid security_compute_av_user(u32 ssid,\n\t\t\t      u32 tsid,\n\t\t\t      u16 tclass,\n\t\t\t      struct av_decision *avd)\n{\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd);\n out:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}\n\n/*\n * Write the security context string representation of\n * the context structure `context' into a dynamically\n * allocated string of the correct size.  Set `*scontext'\n * to point to this string and set `*scontext_len' to\n * the length of the string.\n */\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tsprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\tscontextp += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) +\n\t\t     1 + strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) +\n\t\t     1 + strlen(sym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}\n\n#include \"initial_sid_to_string.h\"\n\nconst char *security_get_initial_sid_context(u32 sid)\n{\n\tif (unlikely(sid > SECINITSID_NUM))\n\t\treturn NULL;\n\treturn initial_sid_to_string[sid];\n}\n\nstatic int security_sid_to_context_core(u32 sid, char **scontext,\n\t\t\t\t\tu32 *scontext_len, int force)\n{\n\tstruct context *context;\n\tint rc = 0;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len  = 0;\n\n\tif (!ss_initialized) {\n\t\tif (sid <= SECINITSID_NUM) {\n\t\t\tchar *scontextp;\n\n\t\t\t*scontext_len = strlen(initial_sid_to_string[sid]) + 1;\n\t\t\tif (!scontext)\n\t\t\t\tgoto out;\n\t\t\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\t\t\tif (!scontextp) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrcpy(scontextp, initial_sid_to_string[sid]);\n\t\t\t*scontext = scontextp;\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_ERR \"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\", __func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\tif (force)\n\t\tcontext = sidtab_search_force(&sidtab, sid);\n\telse\n\t\tcontext = sidtab_search(&sidtab, sid);\n\tif (!context) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\trc = context_struct_to_string(context, scontext, scontext_len);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\treturn rc;\n\n}\n\n/**\n * security_sid_to_context - Obtain a context for a given SID.\n * @sid: security identifier, SID\n * @scontext: security context\n * @scontext_len: length in bytes\n *\n * Write the string representation of the context associated with @sid\n * into a dynamically allocated string of the correct size.  Set @scontext\n * to point to this string and set @scontext_len to the length of the string.\n */\nint security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 0);\n}\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}\n\n/*\n * Caveat:  Mutates scontext.\n */\nstatic int string_to_context_struct(struct policydb *pol,\n\t\t\t\t    struct sidtab *sidtabp,\n\t\t\t\t    char *scontext,\n\t\t\t\t    u32 scontext_len,\n\t\t\t\t    struct context *ctx,\n\t\t\t\t    u32 def_sid)\n{\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *scontextp, *p, oldc;\n\tint rc = 0;\n\n\tcontext_init(ctx);\n\n\t/* Parse the security context. */\n\n\trc = -EINVAL;\n\tscontextp = (char *) scontext;\n\n\t/* Extract the user. */\n\tp = scontextp;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\tusrdatum = hashtab_search(pol->p_users.table, scontextp);\n\tif (!usrdatum)\n\t\tgoto out;\n\n\tctx->user = usrdatum->value;\n\n\t/* Extract role. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\trole = hashtab_search(pol->p_roles.table, scontextp);\n\tif (!role)\n\t\tgoto out;\n\tctx->role = role->value;\n\n\t/* Extract type. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\toldc = *p;\n\t*p++ = 0;\n\n\ttypdatum = hashtab_search(pol->p_types.table, scontextp);\n\tif (!typdatum || typdatum->attribute)\n\t\tgoto out;\n\n\tctx->type = typdatum->value;\n\n\trc = mls_context_to_sid(pol, oldc, &p, ctx, sidtabp, def_sid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif ((p - scontext) < scontext_len)\n\t\tgoto out;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(pol, ctx))\n\t\tgoto out;\n\trc = 0;\nout:\n\tif (rc)\n\t\tcontext_destroy(ctx);\n\treturn rc;\n}\n\nstatic int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}\n\n/**\n * security_context_to_sid - Obtain a SID for a given security context.\n * @scontext: security context\n * @scontext_len: length in bytes\n * @sid: security identifier, SID\n *\n * Obtains a SID associated with the security context that\n * has the string representation specified by @scontext.\n * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient\n * memory is available, or 0 on success.\n */\nint security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, GFP_KERNEL, 0);\n}\n\n/**\n * security_context_to_sid_default - Obtain a SID for a given security context,\n * falling back to specified default if needed.\n *\n * @scontext: security context\n * @scontext_len: length in bytes\n * @sid: security identifier, SID\n * @def_sid: default SID to assign on error\n *\n * Obtains a SID associated with the security context that\n * has the string representation specified by @scontext.\n * The default SID is passed to the MLS layer to be used to allow\n * kernel labeling of the MLS field if the MLS field is not present\n * (for upgrading to MLS without full relabel).\n * Implicitly forces adding of the context even if it cannot be mapped yet.\n * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient\n * memory is available, or 0 on success.\n */\nint security_context_to_sid_default(const char *scontext, u32 scontext_len,\n\t\t\t\t    u32 *sid, u32 def_sid, gfp_t gfp_flags)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, def_sid, gfp_flags, 1);\n}\n\nint security_context_to_sid_force(const char *scontext, u32 scontext_len,\n\t\t\t\t  u32 *sid)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, GFP_KERNEL, 1);\n}\n\nstatic int compute_sid_handle_invalid_context(\n\tstruct context *scontext,\n\tstruct context *tcontext,\n\tu16 tclass,\n\tstruct context *newcontext)\n{\n\tchar *s = NULL, *t = NULL, *n = NULL;\n\tu32 slen, tlen, nlen;\n\n\tif (context_struct_to_string(scontext, &s, &slen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\tif (context_struct_to_string(newcontext, &n, &nlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"security_compute_sid:  invalid context %s\"\n\t\t  \" for scontext=%s\"\n\t\t  \" tcontext=%s\"\n\t\t  \" tclass=%s\",\n\t\t  n, s, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(s);\n\tkfree(t);\n\tkfree(n);\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\nstatic void filename_compute_type(struct policydb *p, struct context *newcontext,\n\t\t\t\t  u32 stype, u32 ttype, u16 tclass,\n\t\t\t\t  const char *objname)\n{\n\tstruct filename_trans ft;\n\tstruct filename_trans_datum *otype;\n\n\t/*\n\t * Most filename trans rules are going to live in specific directories\n\t * like /dev or /var/run.  This bitmap will quickly skip rule searches\n\t * if the ttype does not contain any rules.\n\t */\n\tif (!ebitmap_get_bit(&p->filename_trans_ttypes, ttype))\n\t\treturn;\n\n\tft.stype = stype;\n\tft.ttype = ttype;\n\tft.tclass = tclass;\n\tft.name = objname;\n\n\totype = hashtab_search(p->filename_trans, &ft);\n\tif (otype)\n\t\tnewcontext->type = otype->otype;\n}\n\nstatic int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}\n\n/**\n * security_transition_sid - Compute the SID for a new subject/object.\n * @ssid: source security identifier\n * @tsid: target security identifier\n * @tclass: target security class\n * @out_sid: security identifier for new subject/object\n *\n * Compute a SID to use for labeling a new subject or object in the\n * class @tclass based on a SID pair (@ssid, @tsid).\n * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM\n * if insufficient memory is available, or %0 if the new SID was\n * computed successfully.\n */\nint security_transition_sid(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t    const struct qstr *qstr, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    qstr ? qstr->name : NULL, out_sid, true);\n}\n\nint security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t const char *objname, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    objname, out_sid, false);\n}\n\n/**\n * security_member_sid - Compute the SID for member selection.\n * @ssid: source security identifier\n * @tsid: target security identifier\n * @tclass: target security class\n * @out_sid: security identifier for selected member\n *\n * Compute a SID to use when selecting a member of a polyinstantiated\n * object of class @tclass based on a SID pair (@ssid, @tsid).\n * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM\n * if insufficient memory is available, or %0 if the SID was\n * computed successfully.\n */\nint security_member_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_MEMBER, NULL,\n\t\t\t\t    out_sid, false);\n}\n\n/**\n * security_change_sid - Compute the SID for object relabeling.\n * @ssid: source security identifier\n * @tsid: target security identifier\n * @tclass: target security class\n * @out_sid: security identifier for selected member\n *\n * Compute a SID to use for relabeling an object of class @tclass\n * based on a SID pair (@ssid, @tsid).\n * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM\n * if insufficient memory is available, or %0 if the SID was\n * computed successfully.\n */\nint security_change_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, NULL,\n\t\t\t\t    out_sid, false);\n}\n\n/* Clone the SID into the new SID table. */\nstatic int clone_sid(u32 sid,\n\t\t     struct context *context,\n\t\t     void *arg)\n{\n\tstruct sidtab *s = arg;\n\n\tif (sid > SECINITSID_NUM)\n\t\treturn sidtab_insert(s, sid, context);\n\telse\n\t\treturn 0;\n}\n\nstatic inline int convert_context_handle_invalid_context(struct context *context)\n{\n\tchar *s;\n\tu32 len;\n\n\tif (selinux_enforcing)\n\t\treturn -EINVAL;\n\n\tif (!context_struct_to_string(context, &s, &len)) {\n\t\tprintk(KERN_WARNING \"SELinux:  Context %s would be invalid if enforcing\\n\", s);\n\t\tkfree(s);\n\t}\n\treturn 0;\n}\n\nstruct convert_context_args {\n\tstruct policydb *oldp;\n\tstruct policydb *newp;\n};\n\n/*\n * Convert the values in the security context\n * structure `c' from the values specified\n * in the policy `p->oldp' to the values specified\n * in the policy `p->newp'.  Verify that the\n * context is valid under the new policy.\n */\nstatic int convert_context(u32 key,\n\t\t\t   struct context *c,\n\t\t\t   void *p)\n{\n\tstruct convert_context_args *args;\n\tstruct context oldc;\n\tstruct ocontext *oc;\n\tstruct mls_range *range;\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *s;\n\tu32 len;\n\tint rc = 0;\n\n\tif (key <= SECINITSID_NUM)\n\t\tgoto out;\n\n\targs = p;\n\n\tif (c->str) {\n\t\tstruct context ctx;\n\n\t\trc = -ENOMEM;\n\t\ts = kstrdup(c->str, GFP_KERNEL);\n\t\tif (!s)\n\t\t\tgoto out;\n\n\t\trc = string_to_context_struct(args->newp, NULL, s,\n\t\t\t\t\t      c->len, &ctx, SECSID_NULL);\n\t\tkfree(s);\n\t\tif (!rc) {\n\t\t\tprintk(KERN_INFO \"SELinux:  Context %s became valid (mapped).\\n\",\n\t\t\t       c->str);\n\t\t\t/* Replace string with mapped representation. */\n\t\t\tkfree(c->str);\n\t\t\tmemcpy(c, &ctx, sizeof(*c));\n\t\t\tgoto out;\n\t\t} else if (rc == -EINVAL) {\n\t\t\t/* Retain string representation for later mapping. */\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Other error condition, e.g. ENOMEM. */\n\t\t\tprintk(KERN_ERR \"SELinux:   Unable to map context %s, rc = %d.\\n\",\n\t\t\t       c->str, -rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = context_cpy(&oldc, c);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Convert the user. */\n\trc = -EINVAL;\n\tusrdatum = hashtab_search(args->newp->p_users.table,\n\t\t\t\t  sym_name(args->oldp, SYM_USERS, c->user - 1));\n\tif (!usrdatum)\n\t\tgoto bad;\n\tc->user = usrdatum->value;\n\n\t/* Convert the role. */\n\trc = -EINVAL;\n\trole = hashtab_search(args->newp->p_roles.table,\n\t\t\t      sym_name(args->oldp, SYM_ROLES, c->role - 1));\n\tif (!role)\n\t\tgoto bad;\n\tc->role = role->value;\n\n\t/* Convert the type. */\n\trc = -EINVAL;\n\ttypdatum = hashtab_search(args->newp->p_types.table,\n\t\t\t\t  sym_name(args->oldp, SYM_TYPES, c->type - 1));\n\tif (!typdatum)\n\t\tgoto bad;\n\tc->type = typdatum->value;\n\n\t/* Convert the MLS fields if dealing with MLS policies */\n\tif (args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\trc = mls_convert_context(args->oldp, args->newp, c);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t} else if (args->oldp->mls_enabled && !args->newp->mls_enabled) {\n\t\t/*\n\t\t * Switching between MLS and non-MLS policy:\n\t\t * free any storage used by the MLS fields in the\n\t\t * context for all existing entries in the sidtab.\n\t\t */\n\t\tmls_context_destroy(c);\n\t} else if (!args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\t/*\n\t\t * Switching between non-MLS and MLS policy:\n\t\t * ensure that the MLS fields of the context for all\n\t\t * existing entries in the sidtab are filled in with a\n\t\t * suitable default value, likely taken from one of the\n\t\t * initial SIDs.\n\t\t */\n\t\toc = args->newp->ocontexts[OCON_ISID];\n\t\twhile (oc && oc->sid[0] != SECINITSID_UNLABELED)\n\t\t\toc = oc->next;\n\t\trc = -EINVAL;\n\t\tif (!oc) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unable to look up\"\n\t\t\t\t\" the initial SIDs list\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\trange = &oc->context[0].range;\n\t\trc = mls_range_set(c, range);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(args->newp, c)) {\n\t\trc = convert_context_handle_invalid_context(&oldc);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tcontext_destroy(&oldc);\n\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\t/* Map old representation to string and save it. */\n\trc = context_struct_to_string(&oldc, &s, &len);\n\tif (rc)\n\t\treturn rc;\n\tcontext_destroy(&oldc);\n\tcontext_destroy(c);\n\tc->str = s;\n\tc->len = len;\n\tprintk(KERN_INFO \"SELinux:  Context %s became invalid (unmapped).\\n\",\n\t       c->str);\n\trc = 0;\n\tgoto out;\n}\n\nstatic void security_load_policycaps(void)\n{\n\tselinux_policycap_netpeer = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_NETPEER);\n\tselinux_policycap_openperm = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_OPENPERM);\n\tselinux_policycap_alwaysnetwork = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_ALWAYSNETWORK);\n}\n\nstatic int security_preserve_bools(struct policydb *p);\n\n/**\n * security_load_policy - Load a security policy configuration.\n * @data: binary policy data\n * @len: length of data in bytes\n *\n * Load a new set of security policy configuration data,\n * validate it and convert the SID table as necessary.\n * This function will flush the access vector cache after\n * loading the new policy.\n */\nint security_load_policy(void *data, size_t len)\n{\n\tstruct policydb *oldpolicydb, *newpolicydb;\n\tstruct sidtab oldsidtab, newsidtab;\n\tstruct selinux_mapping *oldmap, *map = NULL;\n\tstruct convert_context_args args;\n\tu32 seqno;\n\tu16 map_size;\n\tint rc = 0;\n\tstruct policy_file file = { data, len }, *fp = &file;\n\n\toldpolicydb = kzalloc(2 * sizeof(*oldpolicydb), GFP_KERNEL);\n\tif (!oldpolicydb) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnewpolicydb = oldpolicydb + 1;\n\n\tif (!ss_initialized) {\n\t\tavtab_cache_init();\n\t\trc = policydb_read(&policydb, fp);\n\t\tif (rc) {\n\t\t\tavtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tpolicydb.len = len;\n\t\trc = selinux_set_mapping(&policydb, secclass_map,\n\t\t\t\t\t &current_mapping,\n\t\t\t\t\t &current_mapping_size);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = policydb_load_isids(&policydb, &sidtab);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tsecurity_load_policycaps();\n\t\tss_initialized = 1;\n\t\tseqno = ++latest_granting;\n\t\tselinux_complete_init();\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_netlbl_cache_invalidate();\n\t\tselinux_xfrm_notify_policyload();\n\t\tgoto out;\n\t}\n\n#if 0\n\tsidtab_hash_eval(&sidtab, \"sids\");\n#endif\n\n\trc = policydb_read(newpolicydb, fp);\n\tif (rc)\n\t\tgoto out;\n\n\tnewpolicydb->len = len;\n\t/* If switching between different policy types, log MLS status */\n\tif (policydb.mls_enabled && !newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Disabling MLS support...\\n\");\n\telse if (!policydb.mls_enabled && newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Enabling MLS support...\\n\");\n\n\trc = policydb_load_isids(newpolicydb, &newsidtab);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to load the initial SIDs\\n\");\n\t\tpolicydb_destroy(newpolicydb);\n\t\tgoto out;\n\t}\n\n\trc = selinux_set_mapping(newpolicydb, secclass_map, &map, &map_size);\n\tif (rc)\n\t\tgoto err;\n\n\trc = security_preserve_bools(newpolicydb);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to preserve booleans\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Clone the SID table. */\n\tsidtab_shutdown(&sidtab);\n\n\trc = sidtab_map(&sidtab, clone_sid, &newsidtab);\n\tif (rc)\n\t\tgoto err;\n\n\t/*\n\t * Convert the internal representations of contexts\n\t * in the new SID table.\n\t */\n\targs.oldp = &policydb;\n\targs.newp = newpolicydb;\n\trc = sidtab_map(&newsidtab, convert_context, &args);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to convert the internal\"\n\t\t\t\" representation of contexts in the new SID\"\n\t\t\t\" table\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Save the old policydb and SID table to free later. */\n\tmemcpy(oldpolicydb, &policydb, sizeof(policydb));\n\tsidtab_set(&oldsidtab, &sidtab);\n\n\t/* Install the new policydb and SID table. */\n\twrite_lock_irq(&policy_rwlock);\n\tmemcpy(&policydb, newpolicydb, sizeof(policydb));\n\tsidtab_set(&sidtab, &newsidtab);\n\tsecurity_load_policycaps();\n\toldmap = current_mapping;\n\tcurrent_mapping = map;\n\tcurrent_mapping_size = map_size;\n\tseqno = ++latest_granting;\n\twrite_unlock_irq(&policy_rwlock);\n\n\t/* Free the old policydb and SID table. */\n\tpolicydb_destroy(oldpolicydb);\n\tsidtab_destroy(&oldsidtab);\n\tkfree(oldmap);\n\n\tavc_ss_reset(seqno);\n\tselnl_notify_policyload(seqno);\n\tselinux_status_update_policyload(seqno);\n\tselinux_netlbl_cache_invalidate();\n\tselinux_xfrm_notify_policyload();\n\n\trc = 0;\n\tgoto out;\n\nerr:\n\tkfree(map);\n\tsidtab_destroy(&newsidtab);\n\tpolicydb_destroy(newpolicydb);\n\nout:\n\tkfree(oldpolicydb);\n\treturn rc;\n}\n\nsize_t security_policydb_len(void)\n{\n\tsize_t len;\n\n\tread_lock(&policy_rwlock);\n\tlen = policydb.len;\n\tread_unlock(&policy_rwlock);\n\n\treturn len;\n}\n\n/**\n * security_port_sid - Obtain the SID for a port.\n * @protocol: protocol number\n * @port: port number\n * @out_sid: security identifier\n */\nint security_port_sid(u8 protocol, u16 port, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_PORT];\n\twhile (c) {\n\t\tif (c->u.port.protocol == protocol &&\n\t\t    c->u.port.low_port <= port &&\n\t\t    c->u.port.high_port >= port)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_PORT;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n/**\n * security_netif_sid - Obtain the SID for a network interface.\n * @name: interface name\n * @if_sid: interface SID\n */\nint security_netif_sid(char *name, u32 *if_sid)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_NETIF];\n\twhile (c) {\n\t\tif (strcmp(name, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0] || !c->sid[1]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t  &c->context[0],\n\t\t\t\t\t\t  &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[1],\n\t\t\t\t\t\t   &c->sid[1]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*if_sid = c->sid[0];\n\t} else\n\t\t*if_sid = SECINITSID_NETIF;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nstatic int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)\n{\n\tint i, fail = 0;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (addr[i] != (input[i] & mask[i])) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn !fail;\n}\n\n/**\n * security_node_sid - Obtain the SID for a node (host).\n * @domain: communication domain aka address family\n * @addrp: address\n * @addrlen: address length in bytes\n * @out_sid: security identifier\n */\nint security_node_sid(u16 domain,\n\t\t      void *addrp,\n\t\t      u32 addrlen,\n\t\t      u32 *out_sid)\n{\n\tint rc;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tswitch (domain) {\n\tcase AF_INET: {\n\t\tu32 addr;\n\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u32))\n\t\t\tgoto out;\n\n\t\taddr = *((u32 *)addrp);\n\n\t\tc = policydb.ocontexts[OCON_NODE];\n\t\twhile (c) {\n\t\t\tif (c->u.node.addr == (addr & c->u.node.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6:\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u64) * 2)\n\t\t\tgoto out;\n\t\tc = policydb.ocontexts[OCON_NODE6];\n\t\twhile (c) {\n\t\t\tif (match_ipv6_addrmask(addrp, c->u.node6.addr,\n\t\t\t\t\t\tc->u.node6.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = 0;\n\t\t*out_sid = SECINITSID_NODE;\n\t\tgoto out;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_NODE;\n\t}\n\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n#define SIDS_NEL 25\n\n/**\n * security_get_user_sids - Obtain reachable SIDs for a user.\n * @fromsid: starting SID\n * @username: username\n * @sids: array of reachable SIDs for user\n * @nel: number of elements in @sids\n *\n * Generate the set of SIDs for legal security contexts\n * for a given user that can be reached by @fromsid.\n * Set *@sids to point to a dynamically allocated\n * array containing the set of SIDs.  Set *@nel to the\n * number of elements in the array.\n */\n\nint security_get_user_sids(u32 fromsid,\n\t\t\t   char *username,\n\t\t\t   u32 **sids,\n\t\t\t   u32 *nel)\n{\n\tstruct context *fromcon, usercon;\n\tu32 *mysids = NULL, *mysids2, sid;\n\tu32 mynel = 0, maxnel = SIDS_NEL;\n\tstruct user_datum *user;\n\tstruct role_datum *role;\n\tstruct ebitmap_node *rnode, *tnode;\n\tint rc = 0, i, j;\n\n\t*sids = NULL;\n\t*nel = 0;\n\n\tif (!ss_initialized)\n\t\tgoto out;\n\n\tread_lock(&policy_rwlock);\n\n\tcontext_init(&usercon);\n\n\trc = -EINVAL;\n\tfromcon = sidtab_search(&sidtab, fromsid);\n\tif (!fromcon)\n\t\tgoto out_unlock;\n\n\trc = -EINVAL;\n\tuser = hashtab_search(policydb.p_users.table, username);\n\tif (!user)\n\t\tgoto out_unlock;\n\n\tusercon.user = user->value;\n\n\trc = -ENOMEM;\n\tmysids = kcalloc(maxnel, sizeof(*mysids), GFP_ATOMIC);\n\tif (!mysids)\n\t\tgoto out_unlock;\n\n\tebitmap_for_each_positive_bit(&user->roles, rnode, i) {\n\t\trole = policydb.role_val_to_struct[i];\n\t\tusercon.role = i + 1;\n\t\tebitmap_for_each_positive_bit(&role->types, tnode, j) {\n\t\t\tusercon.type = j + 1;\n\n\t\t\tif (mls_setup_user_range(fromcon, user, &usercon))\n\t\t\t\tcontinue;\n\n\t\t\trc = sidtab_context_to_sid(&sidtab, &usercon, &sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out_unlock;\n\t\t\tif (mynel < maxnel) {\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t} else {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tmaxnel += SIDS_NEL;\n\t\t\t\tmysids2 = kcalloc(maxnel, sizeof(*mysids2), GFP_ATOMIC);\n\t\t\t\tif (!mysids2)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tmemcpy(mysids2, mysids, mynel * sizeof(*mysids2));\n\t\t\t\tkfree(mysids);\n\t\t\t\tmysids = mysids2;\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tif (rc || !mynel) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tmysids2 = kcalloc(mynel, sizeof(*mysids2), GFP_KERNEL);\n\tif (!mysids2) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\tfor (i = 0, j = 0; i < mynel; i++) {\n\t\tstruct av_decision dummy_avd;\n\t\trc = avc_has_perm_noaudit(fromsid, mysids[i],\n\t\t\t\t\t  SECCLASS_PROCESS, /* kernel value */\n\t\t\t\t\t  PROCESS__TRANSITION, AVC_STRICT,\n\t\t\t\t\t  &dummy_avd);\n\t\tif (!rc)\n\t\t\tmysids2[j++] = mysids[i];\n\t\tcond_resched();\n\t}\n\trc = 0;\n\tkfree(mysids);\n\t*sids = mysids2;\n\t*nel = j;\nout:\n\treturn rc;\n}\n\n/**\n * security_genfs_sid - Obtain a SID for a file in a filesystem\n * @fstype: filesystem type\n * @path: path from root of mount\n * @sclass: file security class\n * @sid: SID for path\n *\n * Obtain a SID to use for a file in a filesystem that\n * cannot support xattr or use a fixed labeling behavior like\n * transition SIDs or task SIDs.\n */\nint security_genfs_sid(const char *fstype,\n\t\t       char *path,\n\t\t       u16 orig_sclass,\n\t\t       u32 *sid)\n{\n\tint len;\n\tu16 sclass;\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tint rc, cmp = 0;\n\n\twhile (path[0] == '/' && path[1] == '/')\n\t\tpath++;\n\n\tread_lock(&policy_rwlock);\n\n\tsclass = unmap_class(orig_sclass);\n\t*sid = SECINITSID_UNLABELED;\n\n\tfor (genfs = policydb.genfs; genfs; genfs = genfs->next) {\n\t\tcmp = strcmp(fstype, genfs->fstype);\n\t\tif (cmp <= 0)\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!genfs || cmp)\n\t\tgoto out;\n\n\tfor (c = genfs->head; c; c = c->next) {\n\t\tlen = strlen(c->u.name);\n\t\tif ((!c->v.sclass || sclass == c->v.sclass) &&\n\t\t    (strncmp(c->u.name, path, len) == 0))\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!c)\n\t\tgoto out;\n\n\tif (!c->sid[0]) {\n\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t*sid = c->sid[0];\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n/**\n * security_fs_use - Determine how to handle labeling for a filesystem.\n * @sb: superblock in question\n */\nint security_fs_use(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tconst char *fstype = sb->s_type->name;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_FSUSE];\n\twhile (c) {\n\t\tif (strcmp(fstype, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tsbsec->behavior = c->v.behavior;\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\tsbsec->sid = c->sid[0];\n\t} else {\n\t\trc = security_genfs_sid(fstype, \"/\", SECCLASS_DIR, &sbsec->sid);\n\t\tif (rc) {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_NONE;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_GENFS;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nint security_get_bools(int *len, char ***names, int **values)\n{\n\tint i, rc;\n\n\tread_lock(&policy_rwlock);\n\t*names = NULL;\n\t*values = NULL;\n\n\trc = 0;\n\t*len = policydb.p_bools.nprim;\n\tif (!*len)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\t*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\n\tif (!*names)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\t*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\n\tif (!*values)\n\t\tgoto err;\n\n\tfor (i = 0; i < *len; i++) {\n\t\tsize_t name_len;\n\n\t\t(*values)[i] = policydb.bool_val_to_struct[i]->state;\n\t\tname_len = strlen(sym_name(&policydb, SYM_BOOLS, i)) + 1;\n\n\t\trc = -ENOMEM;\n\t\t(*names)[i] = kmalloc(sizeof(char) * name_len, GFP_ATOMIC);\n\t\tif (!(*names)[i])\n\t\t\tgoto err;\n\n\t\tstrncpy((*names)[i], sym_name(&policydb, SYM_BOOLS, i), name_len);\n\t\t(*names)[i][name_len - 1] = 0;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\nerr:\n\tif (*names) {\n\t\tfor (i = 0; i < *len; i++)\n\t\t\tkfree((*names)[i]);\n\t}\n\tkfree(*values);\n\tgoto out;\n}\n\n\nint security_set_bools(int len, int *values)\n{\n\tint i, rc;\n\tint lenp, seqno = 0;\n\tstruct cond_node *cur;\n\n\twrite_lock_irq(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlenp = policydb.p_bools.nprim;\n\tif (len != lenp)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!!values[i] != policydb.bool_val_to_struct[i]->state) {\n\t\t\taudit_log(current->audit_context, GFP_ATOMIC,\n\t\t\t\tAUDIT_MAC_CONFIG_CHANGE,\n\t\t\t\t\"bool=%s val=%d old_val=%d auid=%u ses=%u\",\n\t\t\t\tsym_name(&policydb, SYM_BOOLS, i),\n\t\t\t\t!!values[i],\n\t\t\t\tpolicydb.bool_val_to_struct[i]->state,\n\t\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t\taudit_get_sessionid(current));\n\t\t}\n\t\tif (values[i])\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 1;\n\t\telse\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 0;\n\t}\n\n\tfor (cur = policydb.cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(&policydb, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tseqno = ++latest_granting;\n\trc = 0;\nout:\n\twrite_unlock_irq(&policy_rwlock);\n\tif (!rc) {\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_xfrm_notify_policyload();\n\t}\n\treturn rc;\n}\n\nint security_get_bool_value(int bool)\n{\n\tint rc;\n\tint len;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlen = policydb.p_bools.nprim;\n\tif (bool >= len)\n\t\tgoto out;\n\n\trc = policydb.bool_val_to_struct[bool]->state;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nstatic int security_preserve_bools(struct policydb *p)\n{\n\tint rc, nbools = 0, *bvalues = NULL, i;\n\tchar **bnames = NULL;\n\tstruct cond_bool_datum *booldatum;\n\tstruct cond_node *cur;\n\n\trc = security_get_bools(&nbools, &bnames, &bvalues);\n\tif (rc)\n\t\tgoto out;\n\tfor (i = 0; i < nbools; i++) {\n\t\tbooldatum = hashtab_search(p->p_bools.table, bnames[i]);\n\t\tif (booldatum)\n\t\t\tbooldatum->state = bvalues[i];\n\t}\n\tfor (cur = p->cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(p, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (bnames) {\n\t\tfor (i = 0; i < nbools; i++)\n\t\t\tkfree(bnames[i]);\n\t}\n\tkfree(bnames);\n\tkfree(bvalues);\n\treturn rc;\n}\n\n/*\n * security_sid_mls_copy() - computes a new sid based on the given\n * sid and the mls portion of mls_sid.\n */\nint security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid)\n{\n\tstruct context *context1;\n\tstruct context *context2;\n\tstruct context newcon;\n\tchar *s;\n\tu32 len;\n\tint rc;\n\n\trc = 0;\n\tif (!ss_initialized || !policydb.mls_enabled) {\n\t\t*new_sid = sid;\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcon);\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tcontext1 = sidtab_search(&sidtab, sid);\n\tif (!context1) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\tgoto out_unlock;\n\t}\n\n\trc = -EINVAL;\n\tcontext2 = sidtab_search(&sidtab, mls_sid);\n\tif (!context2) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, mls_sid);\n\t\tgoto out_unlock;\n\t}\n\n\tnewcon.user = context1->user;\n\tnewcon.role = context1->role;\n\tnewcon.type = context1->type;\n\trc = mls_context_cpy(&newcon, context2);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(&policydb, &newcon)) {\n\t\trc = convert_context_handle_invalid_context(&newcon);\n\t\tif (rc) {\n\t\t\tif (!context_struct_to_string(&newcon, &s, &len)) {\n\t\t\t\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t\t\t  \"security_sid_mls_copy: invalid context %s\", s);\n\t\t\t\tkfree(s);\n\t\t\t}\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\trc = sidtab_context_to_sid(&sidtab, &newcon, new_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcon);\nout:\n\treturn rc;\n}\n\n/**\n * security_net_peersid_resolve - Compare and resolve two network peer SIDs\n * @nlbl_sid: NetLabel SID\n * @nlbl_type: NetLabel labeling protocol type\n * @xfrm_sid: XFRM SID\n *\n * Description:\n * Compare the @nlbl_sid and @xfrm_sid values and if the two SIDs can be\n * resolved into a single SID it is returned via @peer_sid and the function\n * returns zero.  Otherwise @peer_sid is set to SECSID_NULL and the function\n * returns a negative value.  A table summarizing the behavior is below:\n *\n *                                 | function return |      @sid\n *   ------------------------------+-----------------+-----------------\n *   no peer labels                |        0        |    SECSID_NULL\n *   single peer label             |        0        |    <peer_label>\n *   multiple, consistent labels   |        0        |    <peer_label>\n *   multiple, inconsistent labels |    -<errno>     |    SECSID_NULL\n *\n */\nint security_net_peersid_resolve(u32 nlbl_sid, u32 nlbl_type,\n\t\t\t\t u32 xfrm_sid,\n\t\t\t\t u32 *peer_sid)\n{\n\tint rc;\n\tstruct context *nlbl_ctx;\n\tstruct context *xfrm_ctx;\n\n\t*peer_sid = SECSID_NULL;\n\n\t/* handle the common (which also happens to be the set of easy) cases\n\t * right away, these two if statements catch everything involving a\n\t * single or absent peer SID/label */\n\tif (xfrm_sid == SECSID_NULL) {\n\t\t*peer_sid = nlbl_sid;\n\t\treturn 0;\n\t}\n\t/* NOTE: an nlbl_type == NETLBL_NLTYPE_UNLABELED is a \"fallback\" label\n\t * and is treated as if nlbl_sid == SECSID_NULL when a XFRM SID/label\n\t * is present */\n\tif (nlbl_sid == SECSID_NULL || nlbl_type == NETLBL_NLTYPE_UNLABELED) {\n\t\t*peer_sid = xfrm_sid;\n\t\treturn 0;\n\t}\n\n\t/* we don't need to check ss_initialized here since the only way both\n\t * nlbl_sid and xfrm_sid are not equal to SECSID_NULL would be if the\n\t * security server was initialized and ss_initialized was true */\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tnlbl_ctx = sidtab_search(&sidtab, nlbl_sid);\n\tif (!nlbl_ctx) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, nlbl_sid);\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\txfrm_ctx = sidtab_search(&sidtab, xfrm_sid);\n\tif (!xfrm_ctx) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, xfrm_sid);\n\t\tgoto out;\n\t}\n\trc = (mls_context_cmp(nlbl_ctx, xfrm_ctx) ? 0 : -EACCES);\n\tif (rc)\n\t\tgoto out;\n\n\t/* at present NetLabel SIDs/labels really only carry MLS\n\t * information so if the MLS portion of the NetLabel SID\n\t * matches the MLS portion of the labeled XFRM SID/label\n\t * then pass along the XFRM SID as it is the most\n\t * expressive */\n\t*peer_sid = xfrm_sid;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nstatic int get_classes_callback(void *k, void *d, void *args)\n{\n\tstruct class_datum *datum = d;\n\tchar *name = k, **classes = args;\n\tint value = datum->value - 1;\n\n\tclasses[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!classes[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint security_get_classes(char ***classes, int *nclasses)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOMEM;\n\t*nclasses = policydb.p_classes.nprim;\n\t*classes = kcalloc(*nclasses, sizeof(**classes), GFP_ATOMIC);\n\tif (!*classes)\n\t\tgoto out;\n\n\trc = hashtab_map(policydb.p_classes.table, get_classes_callback,\n\t\t\t*classes);\n\tif (rc) {\n\t\tint i;\n\t\tfor (i = 0; i < *nclasses; i++)\n\t\t\tkfree((*classes)[i]);\n\t\tkfree(*classes);\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nstatic int get_permissions_callback(void *k, void *d, void *args)\n{\n\tstruct perm_datum *datum = d;\n\tchar *name = k, **perms = args;\n\tint value = datum->value - 1;\n\n\tperms[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!perms[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint security_get_permissions(char *class, char ***perms, int *nperms)\n{\n\tint rc, i;\n\tstruct class_datum *match;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tmatch = hashtab_search(policydb.p_classes.table, class);\n\tif (!match) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized class %s\\n\",\n\t\t\t__func__, class);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\t*nperms = match->permissions.nprim;\n\t*perms = kcalloc(*nperms, sizeof(**perms), GFP_ATOMIC);\n\tif (!*perms)\n\t\tgoto out;\n\n\tif (match->comdatum) {\n\t\trc = hashtab_map(match->comdatum->permissions.table,\n\t\t\t\tget_permissions_callback, *perms);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\trc = hashtab_map(match->permissions.table, get_permissions_callback,\n\t\t\t*perms);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n\nerr:\n\tread_unlock(&policy_rwlock);\n\tfor (i = 0; i < *nperms; i++)\n\t\tkfree((*perms)[i]);\n\tkfree(*perms);\n\treturn rc;\n}\n\nint security_get_reject_unknown(void)\n{\n\treturn policydb.reject_unknown;\n}\n\nint security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}\n\n/**\n * security_policycap_supported - Check for a specific policy capability\n * @req_cap: capability\n *\n * Description:\n * This function queries the currently loaded policy to see if it supports the\n * capability specified by @req_cap.  Returns true (1) if the capability is\n * supported, false (0) if it isn't supported.\n *\n */\nint security_policycap_supported(unsigned int req_cap)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\trc = ebitmap_get_bit(&policydb.policycaps, req_cap);\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}\n\nstruct selinux_audit_rule {\n\tu32 au_seqno;\n\tstruct context au_ctxt;\n};\n\nvoid selinux_audit_rule_free(void *vrule)\n{\n\tstruct selinux_audit_rule *rule = vrule;\n\n\tif (rule) {\n\t\tcontext_destroy(&rule->au_ctxt);\n\t\tkfree(rule);\n\t}\n}\n\nint selinux_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\n{\n\tstruct selinux_audit_rule *tmprule;\n\tstruct role_datum *roledatum;\n\tstruct type_datum *typedatum;\n\tstruct user_datum *userdatum;\n\tstruct selinux_audit_rule **rule = (struct selinux_audit_rule **)vrule;\n\tint rc = 0;\n\n\t*rule = NULL;\n\n\tif (!ss_initialized)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\t\t/* only 'equals' and 'not equals' fit user, role, and type */\n\t\tif (op != Audit_equal && op != Audit_not_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t/* we do not allow a range, indicated by the presence of '-' */\n\t\tif (strchr(rulestr, '-'))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t/* only the above fields are valid */\n\t\treturn -EINVAL;\n\t}\n\n\ttmprule = kzalloc(sizeof(struct selinux_audit_rule), GFP_KERNEL);\n\tif (!tmprule)\n\t\treturn -ENOMEM;\n\n\tcontext_init(&tmprule->au_ctxt);\n\n\tread_lock(&policy_rwlock);\n\n\ttmprule->au_seqno = latest_granting;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\trc = -EINVAL;\n\t\tuserdatum = hashtab_search(policydb.p_users.table, rulestr);\n\t\tif (!userdatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.user = userdatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\trc = -EINVAL;\n\t\troledatum = hashtab_search(policydb.p_roles.table, rulestr);\n\t\tif (!roledatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.role = roledatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\trc = -EINVAL;\n\t\ttypedatum = hashtab_search(policydb.p_types.table, rulestr);\n\t\tif (!typedatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.type = typedatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\trc = mls_from_string(rulestr, &tmprule->au_ctxt, GFP_ATOMIC);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\n\tif (rc) {\n\t\tselinux_audit_rule_free(tmprule);\n\t\ttmprule = NULL;\n\t}\n\n\t*rule = tmprule;\n\n\treturn rc;\n}\n\n/* Check to see if the rule contains any selinux fields */\nint selinux_audit_rule_known(struct audit_krule *rule)\n{\n\tint i;\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tswitch (f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint selinux_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule,\n\t\t\t     struct audit_context *actx)\n{\n\tstruct context *ctxt;\n\tstruct mls_level *level;\n\tstruct selinux_audit_rule *rule = vrule;\n\tint match = 0;\n\n\tif (!rule) {\n\t\taudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"selinux_audit_rule_match: missing rule\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (rule->au_seqno < latest_granting) {\n\t\taudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"selinux_audit_rule_match: stale rule\\n\");\n\t\tmatch = -ESTALE;\n\t\tgoto out;\n\t}\n\n\tctxt = sidtab_search(&sidtab, sid);\n\tif (!ctxt) {\n\t\taudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"selinux_audit_rule_match: unrecognized SID %d\\n\",\n\t\t\t  sid);\n\t\tmatch = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* a field/op pair that is not caught here will simply fall through\n\t   without a match */\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->user == rule->au_ctxt.user);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->user != rule->au_ctxt.user);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->role == rule->au_ctxt.role);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->role != rule->au_ctxt.role);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->type == rule->au_ctxt.type);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->type != rule->au_ctxt.type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tlevel = ((field == AUDIT_SUBJ_SEN ||\n\t\t\t  field == AUDIT_OBJ_LEV_LOW) ?\n\t\t\t &ctxt->range.level[0] : &ctxt->range.level[1]);\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t     level);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_lt:\n\t\t\tmatch = (mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level) &&\n\t\t\t\t !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level));\n\t\t\tbreak;\n\t\tcase Audit_le:\n\t\t\tmatch = mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_gt:\n\t\t\tmatch = (mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]) &&\n\t\t\t\t !mls_level_eq(level,\n\t\t\t\t\t       &rule->au_ctxt.range.level[0]));\n\t\t\tbreak;\n\t\tcase Audit_ge:\n\t\t\tmatch = mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn match;\n}\n\nstatic int (*aurule_callback)(void) = audit_update_lsm_rules;\n\nstatic int aurule_avc_callback(u32 event)\n{\n\tint err = 0;\n\n\tif (event == AVC_CALLBACK_RESET && aurule_callback)\n\t\terr = aurule_callback();\n\treturn err;\n}\n\nstatic int __init aurule_init(void)\n{\n\tint err;\n\n\terr = avc_add_callback(aurule_avc_callback, AVC_CALLBACK_RESET);\n\tif (err)\n\t\tpanic(\"avc_add_callback() failed, error %d\\n\", err);\n\n\treturn err;\n}\n__initcall(aurule_init);\n\n#ifdef CONFIG_NETLABEL\n/**\n * security_netlbl_cache_add - Add an entry to the NetLabel cache\n * @secattr: the NetLabel packet security attributes\n * @sid: the SELinux SID\n *\n * Description:\n * Attempt to cache the context in @ctx, which was derived from the packet in\n * @skb, in the NetLabel subsystem cache.  This function assumes @secattr has\n * already been initialized.\n *\n */\nstatic void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t      u32 sid)\n{\n\tu32 *sid_cache;\n\n\tsid_cache = kmalloc(sizeof(*sid_cache), GFP_ATOMIC);\n\tif (sid_cache == NULL)\n\t\treturn;\n\tsecattr->cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);\n\tif (secattr->cache == NULL) {\n\t\tkfree(sid_cache);\n\t\treturn;\n\t}\n\n\t*sid_cache = sid;\n\tsecattr->cache->free = kfree;\n\tsecattr->cache->data = sid_cache;\n\tsecattr->flags |= NETLBL_SECATTR_CACHE;\n}\n\n/**\n * security_netlbl_secattr_to_sid - Convert a NetLabel secattr to a SELinux SID\n * @secattr: the NetLabel packet security attributes\n * @sid: the SELinux SID\n *\n * Description:\n * Convert the given NetLabel security attributes in @secattr into a\n * SELinux SID.  If the @secattr field does not contain a full SELinux\n * SID/context then use SECINITSID_NETMSG as the foundation.  If possible the\n * 'cache' field of @secattr is set and the CACHE flag is set; this is to\n * allow the @secattr to be used by NetLabel to cache the secattr to SID\n * conversion for future lookups.  Returns zero on success, negative values on\n * failure.\n *\n */\nint security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\tstruct context *ctx;\n\tstruct context ctx_new;\n\n\tif (!ss_initialized) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (secattr->flags & NETLBL_SECATTR_CACHE)\n\t\t*sid = *(u32 *)secattr->cache->data;\n\telse if (secattr->flags & NETLBL_SECATTR_SECID)\n\t\t*sid = secattr->attr.secid;\n\telse if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {\n\t\trc = -EIDRM;\n\t\tctx = sidtab_search(&sidtab, SECINITSID_NETMSG);\n\t\tif (ctx == NULL)\n\t\t\tgoto out;\n\n\t\tcontext_init(&ctx_new);\n\t\tctx_new.user = ctx->user;\n\t\tctx_new.role = ctx->role;\n\t\tctx_new.type = ctx->type;\n\t\tmls_import_netlbl_lvl(&ctx_new, secattr);\n\t\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\t\trc = ebitmap_netlbl_import(&ctx_new.range.level[0].cat,\n\t\t\t\t\t\t   secattr->attr.mls.cat);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tmemcpy(&ctx_new.range.level[1].cat,\n\t\t\t       &ctx_new.range.level[0].cat,\n\t\t\t       sizeof(ctx_new.range.level[0].cat));\n\t\t}\n\t\trc = -EIDRM;\n\t\tif (!mls_context_isvalid(&policydb, &ctx_new))\n\t\t\tgoto out_free;\n\n\t\trc = sidtab_context_to_sid(&sidtab, &ctx_new, sid);\n\t\tif (rc)\n\t\t\tgoto out_free;\n\n\t\tsecurity_netlbl_cache_add(secattr, *sid);\n\n\t\tebitmap_destroy(&ctx_new.range.level[0].cat);\n\t} else\n\t\t*sid = SECSID_NULL;\n\n\tread_unlock(&policy_rwlock);\n\treturn 0;\nout_free:\n\tebitmap_destroy(&ctx_new.range.level[0].cat);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n/**\n * security_netlbl_sid_to_secattr - Convert a SELinux SID to a NetLabel secattr\n * @sid: the SELinux SID\n * @secattr: the NetLabel packet security attributes\n *\n * Description:\n * Convert the given SELinux SID in @sid into a NetLabel security attribute.\n * Returns zero on success, negative values on failure.\n *\n */\nint security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n#endif /* CONFIG_NETLABEL */\n\n/**\n * security_read_policy - read the policy.\n * @data: binary policy data\n * @len: length of data in bytes\n *\n */\nint security_read_policy(void **data, size_t *len)\n{\n\tint rc;\n\tstruct policy_file fp;\n\n\tif (!ss_initialized)\n\t\treturn -EINVAL;\n\n\t*len = security_policydb_len();\n\n\t*data = vmalloc_user(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\tfp.data = *data;\n\tfp.len = *len;\n\n\tread_lock(&policy_rwlock);\n\trc = policydb_write(&policydb, &fp);\n\tread_unlock(&policy_rwlock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t*len = (unsigned long)fp.data - (unsigned long)*data;\n\treturn 0;\n\n}\n"], "fixing_code": ["/*\n * Implementation of the security services.\n *\n * Authors : Stephen Smalley, <sds@epoch.ncsc.mil>\n *\t     James Morris <jmorris@redhat.com>\n *\n * Updated: Trusted Computer Solutions, Inc. <dgoeddel@trustedcs.com>\n *\n *\tSupport for enhanced MLS infrastructure.\n *\tSupport for context based audit filters.\n *\n * Updated: Frank Mayer <mayerf@tresys.com> and Karl MacMillan <kmacmillan@tresys.com>\n *\n *\tAdded conditional policy language extensions\n *\n * Updated: Hewlett-Packard <paul@paul-moore.com>\n *\n *      Added support for NetLabel\n *      Added support for the policy capability bitmap\n *\n * Updated: Chad Sellers <csellers@tresys.com>\n *\n *  Added validation of kernel classes and permissions\n *\n * Updated: KaiGai Kohei <kaigai@ak.jp.nec.com>\n *\n *  Added support for bounds domain and audit messaged on masked permissions\n *\n * Updated: Guido Trentalancia <guido@trentalancia.com>\n *\n *  Added support for runtime switching of the policy type\n *\n * Copyright (C) 2008, 2009 NEC Corporation\n * Copyright (C) 2006, 2007 Hewlett-Packard Development Company, L.P.\n * Copyright (C) 2004-2006 Trusted Computer Solutions, Inc.\n * Copyright (C) 2003 - 2004, 2006 Tresys Technology, LLC\n * Copyright (C) 2003 Red Hat, Inc., James Morris <jmorris@redhat.com>\n *\tThis program is free software; you can redistribute it and/or modify\n *\tit under the terms of the GNU General Public License as published by\n *\tthe Free Software Foundation, version 2.\n */\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/rcupdate.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/sched.h>\n#include <linux/audit.h>\n#include <linux/mutex.h>\n#include <linux/selinux.h>\n#include <linux/flex_array.h>\n#include <linux/vmalloc.h>\n#include <net/netlabel.h>\n\n#include \"flask.h\"\n#include \"avc.h\"\n#include \"avc_ss.h\"\n#include \"security.h\"\n#include \"context.h\"\n#include \"policydb.h\"\n#include \"sidtab.h\"\n#include \"services.h\"\n#include \"conditional.h\"\n#include \"mls.h\"\n#include \"objsec.h\"\n#include \"netlabel.h\"\n#include \"xfrm.h\"\n#include \"ebitmap.h\"\n#include \"audit.h\"\n\nint selinux_policycap_netpeer;\nint selinux_policycap_openperm;\nint selinux_policycap_alwaysnetwork;\n\nstatic DEFINE_RWLOCK(policy_rwlock);\n\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\n/*\n * The largest sequence number that has been used when\n * providing an access decision to the access vector cache.\n * The sequence number only changes when a policy change\n * occurs.\n */\nstatic u32 latest_granting;\n\n/* Forward declaration. */\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t      struct context *tcontext,\n\t\t\t\t      u16 tclass,\n\t\t\t\t      struct av_decision *avd);\n\nstruct selinux_mapping {\n\tu16 value; /* policy value */\n\tunsigned num_perms;\n\tu32 perms[sizeof(u32) * 8];\n};\n\nstatic struct selinux_mapping *current_mapping;\nstatic u16 current_mapping_size;\n\nstatic int selinux_set_mapping(struct policydb *pol,\n\t\t\t       struct security_class_mapping *map,\n\t\t\t       struct selinux_mapping **out_map_p,\n\t\t\t       u16 *out_map_size)\n{\n\tstruct selinux_mapping *out_map = NULL;\n\tsize_t size = sizeof(struct selinux_mapping);\n\tu16 i, j;\n\tunsigned k;\n\tbool print_unknown_handle = false;\n\n\t/* Find number of classes in the input mapping */\n\tif (!map)\n\t\treturn -EINVAL;\n\ti = 0;\n\twhile (map[i].name)\n\t\ti++;\n\n\t/* Allocate space for the class records, plus one for class zero */\n\tout_map = kcalloc(++i, size, GFP_ATOMIC);\n\tif (!out_map)\n\t\treturn -ENOMEM;\n\n\t/* Store the raw class and permission values */\n\tj = 0;\n\twhile (map[j].name) {\n\t\tstruct security_class_mapping *p_in = map + (j++);\n\t\tstruct selinux_mapping *p_out = out_map + j;\n\n\t\t/* An empty class string skips ahead */\n\t\tif (!strcmp(p_in->name, \"\")) {\n\t\t\tp_out->num_perms = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tp_out->value = string_to_security_class(pol, p_in->name);\n\t\tif (!p_out->value) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"SELinux:  Class %s not defined in policy.\\n\",\n\t\t\t       p_in->name);\n\t\t\tif (pol->reject_unknown)\n\t\t\t\tgoto err;\n\t\t\tp_out->num_perms = 0;\n\t\t\tprint_unknown_handle = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tk = 0;\n\t\twhile (p_in->perms && p_in->perms[k]) {\n\t\t\t/* An empty permission string skips ahead */\n\t\t\tif (!*p_in->perms[k]) {\n\t\t\t\tk++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tp_out->perms[k] = string_to_av_perm(pol, p_out->value,\n\t\t\t\t\t\t\t    p_in->perms[k]);\n\t\t\tif (!p_out->perms[k]) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"SELinux:  Permission %s in class %s not defined in policy.\\n\",\n\t\t\t\t       p_in->perms[k], p_in->name);\n\t\t\t\tif (pol->reject_unknown)\n\t\t\t\t\tgoto err;\n\t\t\t\tprint_unknown_handle = true;\n\t\t\t}\n\n\t\t\tk++;\n\t\t}\n\t\tp_out->num_perms = k;\n\t}\n\n\tif (print_unknown_handle)\n\t\tprintk(KERN_INFO \"SELinux: the above unknown classes and permissions will be %s\\n\",\n\t\t       pol->allow_unknown ? \"allowed\" : \"denied\");\n\n\t*out_map_p = out_map;\n\t*out_map_size = i;\n\treturn 0;\nerr:\n\tkfree(out_map);\n\treturn -EINVAL;\n}\n\n/*\n * Get real, policy values from mapped values\n */\n\nstatic u16 unmap_class(u16 tclass)\n{\n\tif (tclass < current_mapping_size)\n\t\treturn current_mapping[tclass].value;\n\n\treturn tclass;\n}\n\n/*\n * Get kernel value for class from its policy value\n */\nstatic u16 map_class(u16 pol_value)\n{\n\tu16 i;\n\n\tfor (i = 1; i < current_mapping_size; i++) {\n\t\tif (current_mapping[i].value == pol_value)\n\t\t\treturn i;\n\t}\n\n\treturn SECCLASS_NULL;\n}\n\nstatic void map_decision(u16 tclass, struct av_decision *avd,\n\t\t\t int allow_unknown)\n{\n\tif (tclass < current_mapping_size) {\n\t\tunsigned i, n = current_mapping[tclass].num_perms;\n\t\tu32 result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->allowed & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\tavd->allowed = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++)\n\t\t\tif (avd->auditallow & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\tavd->auditallow = result;\n\n\t\tfor (i = 0, result = 0; i < n; i++) {\n\t\t\tif (avd->auditdeny & current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t\tif (!allow_unknown && !current_mapping[tclass].perms[i])\n\t\t\t\tresult |= 1<<i;\n\t\t}\n\t\t/*\n\t\t * In case the kernel has a bug and requests a permission\n\t\t * between num_perms and the maximum permission number, we\n\t\t * should audit that denial\n\t\t */\n\t\tfor (; i < (sizeof(u32)*8); i++)\n\t\t\tresult |= 1<<i;\n\t\tavd->auditdeny = result;\n\t}\n}\n\nint security_mls_enabled(void)\n{\n\treturn policydb.mls_enabled;\n}\n\n/*\n * Return the boolean value of a constraint expression\n * when it is applied to the specified source and target\n * security contexts.\n *\n * xcontext is a special beast...  It is used by the validatetrans rules\n * only.  For these rules, scontext is the context before the transition,\n * tcontext is the context after the transition, and xcontext is the context\n * of the process performing the transition.  All other callers of\n * constraint_expr_eval should pass in NULL for xcontext.\n */\nstatic int constraint_expr_eval(struct context *scontext,\n\t\t\t\tstruct context *tcontext,\n\t\t\t\tstruct context *xcontext,\n\t\t\t\tstruct constraint_expr *cexpr)\n{\n\tu32 val1, val2;\n\tstruct context *c;\n\tstruct role_datum *r1, *r2;\n\tstruct mls_level *l1, *l2;\n\tstruct constraint_expr *e;\n\tint s[CEXPR_MAXDEPTH];\n\tint sp = -1;\n\n\tfor (e = cexpr; e; e = e->next) {\n\t\tswitch (e->expr_type) {\n\t\tcase CEXPR_NOT:\n\t\t\tBUG_ON(sp < 0);\n\t\t\ts[sp] = !s[sp];\n\t\t\tbreak;\n\t\tcase CEXPR_AND:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] &= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_OR:\n\t\t\tBUG_ON(sp < 1);\n\t\t\tsp--;\n\t\t\ts[sp] |= s[sp + 1];\n\t\t\tbreak;\n\t\tcase CEXPR_ATTR:\n\t\t\tif (sp == (CEXPR_MAXDEPTH - 1))\n\t\t\t\treturn 0;\n\t\t\tswitch (e->attr) {\n\t\t\tcase CEXPR_USER:\n\t\t\t\tval1 = scontext->user;\n\t\t\t\tval2 = tcontext->user;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_TYPE:\n\t\t\t\tval1 = scontext->type;\n\t\t\t\tval2 = tcontext->type;\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_ROLE:\n\t\t\t\tval1 = scontext->role;\n\t\t\t\tval2 = tcontext->role;\n\t\t\t\tr1 = policydb.role_val_to_struct[val1 - 1];\n\t\t\t\tr2 = policydb.role_val_to_struct[val2 - 1];\n\t\t\t\tswitch (e->op) {\n\t\t\t\tcase CEXPR_DOM:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t  val2 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_DOMBY:\n\t\t\t\t\ts[++sp] = ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t  val1 - 1);\n\t\t\t\t\tcontinue;\n\t\t\t\tcase CEXPR_INCOMP:\n\t\t\t\t\ts[++sp] = (!ebitmap_get_bit(&r1->dominates,\n\t\t\t\t\t\t\t\t    val2 - 1) &&\n\t\t\t\t\t\t   !ebitmap_get_bit(&r2->dominates,\n\t\t\t\t\t\t\t\t    val1 - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_L1L2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H2:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1L2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[0]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_H1H2:\n\t\t\t\tl1 = &(scontext->range.level[1]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L1H1:\n\t\t\t\tl1 = &(scontext->range.level[0]);\n\t\t\t\tl2 = &(scontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\n\t\t\tcase CEXPR_L2H2:\n\t\t\t\tl1 = &(tcontext->range.level[0]);\n\t\t\t\tl2 = &(tcontext->range.level[1]);\n\t\t\t\tgoto mls_ops;\nmls_ops:\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !mls_level_eq(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOM:\n\t\t\t\ts[++sp] = mls_level_dom(l1, l2);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_DOMBY:\n\t\t\t\ts[++sp] = mls_level_dom(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tcase CEXPR_INCOMP:\n\t\t\t\ts[++sp] = mls_level_incomp(l2, l1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = (val1 == val2);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = (val1 != val2);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CEXPR_NAMES:\n\t\t\tif (sp == (CEXPR_MAXDEPTH-1))\n\t\t\t\treturn 0;\n\t\t\tc = scontext;\n\t\t\tif (e->attr & CEXPR_TARGET)\n\t\t\t\tc = tcontext;\n\t\t\telse if (e->attr & CEXPR_XTARGET) {\n\t\t\t\tc = xcontext;\n\t\t\t\tif (!c) {\n\t\t\t\t\tBUG();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->attr & CEXPR_USER)\n\t\t\t\tval1 = c->user;\n\t\t\telse if (e->attr & CEXPR_ROLE)\n\t\t\t\tval1 = c->role;\n\t\t\telse if (e->attr & CEXPR_TYPE)\n\t\t\t\tval1 = c->type;\n\t\t\telse {\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tswitch (e->op) {\n\t\t\tcase CEXPR_EQ:\n\t\t\t\ts[++sp] = ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tcase CEXPR_NEQ:\n\t\t\t\ts[++sp] = !ebitmap_get_bit(&e->names, val1 - 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(sp != 0);\n\treturn s[0];\n}\n\n/*\n * security_dump_masked_av - dumps masked permissions during\n * security_compute_av due to RBAC, MLS/Constraint and Type bounds.\n */\nstatic int dump_masked_av_helper(void *k, void *d, void *args)\n{\n\tstruct perm_datum *pdatum = d;\n\tchar **permission_names = args;\n\n\tBUG_ON(pdatum->value < 1 || pdatum->value > 32);\n\n\tpermission_names[pdatum->value - 1] = (char *)k;\n\n\treturn 0;\n}\n\nstatic void security_dump_masked_av(struct context *scontext,\n\t\t\t\t    struct context *tcontext,\n\t\t\t\t    u16 tclass,\n\t\t\t\t    u32 permissions,\n\t\t\t\t    const char *reason)\n{\n\tstruct common_datum *common_dat;\n\tstruct class_datum *tclass_dat;\n\tstruct audit_buffer *ab;\n\tchar *tclass_name;\n\tchar *scontext_name = NULL;\n\tchar *tcontext_name = NULL;\n\tchar *permission_names[32];\n\tint index;\n\tu32 length;\n\tbool need_comma = false;\n\n\tif (!permissions)\n\t\treturn;\n\n\ttclass_name = sym_name(&policydb, SYM_CLASSES, tclass - 1);\n\ttclass_dat = policydb.class_val_to_struct[tclass - 1];\n\tcommon_dat = tclass_dat->comdatum;\n\n\t/* init permission_names */\n\tif (common_dat &&\n\t    hashtab_map(common_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\tif (hashtab_map(tclass_dat->permissions.table,\n\t\t\tdump_masked_av_helper, permission_names) < 0)\n\t\tgoto out;\n\n\t/* get scontext/tcontext in text form */\n\tif (context_struct_to_string(scontext,\n\t\t\t\t     &scontext_name, &length) < 0)\n\t\tgoto out;\n\n\tif (context_struct_to_string(tcontext,\n\t\t\t\t     &tcontext_name, &length) < 0)\n\t\tgoto out;\n\n\t/* audit a message */\n\tab = audit_log_start(current->audit_context,\n\t\t\t     GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\tif (!ab)\n\t\tgoto out;\n\n\taudit_log_format(ab, \"op=security_compute_av reason=%s \"\n\t\t\t \"scontext=%s tcontext=%s tclass=%s perms=\",\n\t\t\t reason, scontext_name, tcontext_name, tclass_name);\n\n\tfor (index = 0; index < 32; index++) {\n\t\tu32 mask = (1 << index);\n\n\t\tif ((mask & permissions) == 0)\n\t\t\tcontinue;\n\n\t\taudit_log_format(ab, \"%s%s\",\n\t\t\t\t need_comma ? \",\" : \"\",\n\t\t\t\t permission_names[index]\n\t\t\t\t ? permission_names[index] : \"????\");\n\t\tneed_comma = true;\n\t}\n\taudit_log_end(ab);\nout:\n\t/* release scontext/tcontext */\n\tkfree(tcontext_name);\n\tkfree(scontext_name);\n\n\treturn;\n}\n\n/*\n * security_boundary_permission - drops violated permissions\n * on boundary constraint.\n */\nstatic void type_attribute_bounds_av(struct context *scontext,\n\t\t\t\t     struct context *tcontext,\n\t\t\t\t     u16 tclass,\n\t\t\t\t     struct av_decision *avd)\n{\n\tstruct context lo_scontext;\n\tstruct context lo_tcontext;\n\tstruct av_decision lo_avd;\n\tstruct type_datum *source;\n\tstruct type_datum *target;\n\tu32 masked = 0;\n\n\tsource = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    scontext->type - 1);\n\tBUG_ON(!source);\n\n\ttarget = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t    tcontext->type - 1);\n\tBUG_ON(!target);\n\n\tif (source->bounds) {\n\t\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\n\t\tmemcpy(&lo_scontext, scontext, sizeof(lo_scontext));\n\t\tlo_scontext.type = source->bounds;\n\n\t\tcontext_struct_compute_av(&lo_scontext,\n\t\t\t\t\t  tcontext,\n\t\t\t\t\t  tclass,\n\t\t\t\t\t  &lo_avd);\n\t\tif ((lo_avd.allowed & avd->allowed) == avd->allowed)\n\t\t\treturn;\t\t/* no masked permission */\n\t\tmasked = ~lo_avd.allowed & avd->allowed;\n\t}\n\n\tif (target->bounds) {\n\t\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\n\t\tmemcpy(&lo_tcontext, tcontext, sizeof(lo_tcontext));\n\t\tlo_tcontext.type = target->bounds;\n\n\t\tcontext_struct_compute_av(scontext,\n\t\t\t\t\t  &lo_tcontext,\n\t\t\t\t\t  tclass,\n\t\t\t\t\t  &lo_avd);\n\t\tif ((lo_avd.allowed & avd->allowed) == avd->allowed)\n\t\t\treturn;\t\t/* no masked permission */\n\t\tmasked = ~lo_avd.allowed & avd->allowed;\n\t}\n\n\tif (source->bounds && target->bounds) {\n\t\tmemset(&lo_avd, 0, sizeof(lo_avd));\n\t\t/*\n\t\t * lo_scontext and lo_tcontext are already\n\t\t * set up.\n\t\t */\n\n\t\tcontext_struct_compute_av(&lo_scontext,\n\t\t\t\t\t  &lo_tcontext,\n\t\t\t\t\t  tclass,\n\t\t\t\t\t  &lo_avd);\n\t\tif ((lo_avd.allowed & avd->allowed) == avd->allowed)\n\t\t\treturn;\t\t/* no masked permission */\n\t\tmasked = ~lo_avd.allowed & avd->allowed;\n\t}\n\n\tif (masked) {\n\t\t/* mask violated permissions */\n\t\tavd->allowed &= ~masked;\n\n\t\t/* audit masked permissions */\n\t\tsecurity_dump_masked_av(scontext, tcontext,\n\t\t\t\t\ttclass, masked, \"bounds\");\n\t}\n}\n\n/*\n * Compute access vectors based on a context structure pair for\n * the permissions in a particular class.\n */\nstatic void context_struct_compute_av(struct context *scontext,\n\t\t\t\t      struct context *tcontext,\n\t\t\t\t      u16 tclass,\n\t\t\t\t      struct av_decision *avd)\n{\n\tstruct constraint_node *constraint;\n\tstruct role_allow *ra;\n\tstruct avtab_key avkey;\n\tstruct avtab_node *node;\n\tstruct class_datum *tclass_datum;\n\tstruct ebitmap *sattr, *tattr;\n\tstruct ebitmap_node *snode, *tnode;\n\tunsigned int i, j;\n\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\n\tif (unlikely(!tclass || tclass > policydb.p_classes.nprim)) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"SELinux:  Invalid class %hu\\n\", tclass);\n\t\treturn;\n\t}\n\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\t/*\n\t * If a specific type enforcement rule was defined for\n\t * this permission check, then use it.\n\t */\n\tavkey.target_class = tclass;\n\tavkey.specified = AVTAB_AV;\n\tsattr = flex_array_get(policydb.type_attr_map_array, scontext->type - 1);\n\tBUG_ON(!sattr);\n\ttattr = flex_array_get(policydb.type_attr_map_array, tcontext->type - 1);\n\tBUG_ON(!tattr);\n\tebitmap_for_each_positive_bit(sattr, snode, i) {\n\t\tebitmap_for_each_positive_bit(tattr, tnode, j) {\n\t\t\tavkey.source_type = i + 1;\n\t\t\tavkey.target_type = j + 1;\n\t\t\tfor (node = avtab_search_node(&policydb.te_avtab, &avkey);\n\t\t\t     node;\n\t\t\t     node = avtab_search_node_next(node, avkey.specified)) {\n\t\t\t\tif (node->key.specified == AVTAB_ALLOWED)\n\t\t\t\t\tavd->allowed |= node->datum.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITALLOW)\n\t\t\t\t\tavd->auditallow |= node->datum.data;\n\t\t\t\telse if (node->key.specified == AVTAB_AUDITDENY)\n\t\t\t\t\tavd->auditdeny &= node->datum.data;\n\t\t\t}\n\n\t\t\t/* Check conditional av table for additional permissions */\n\t\t\tcond_compute_av(&policydb.te_cond_avtab, &avkey, avd);\n\n\t\t}\n\t}\n\n\t/*\n\t * Remove any permissions prohibited by a constraint (this includes\n\t * the MLS policy).\n\t */\n\tconstraint = tclass_datum->constraints;\n\twhile (constraint) {\n\t\tif ((constraint->permissions & (avd->allowed)) &&\n\t\t    !constraint_expr_eval(scontext, tcontext, NULL,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\tavd->allowed &= ~(constraint->permissions);\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\n\t/*\n\t * If checking process transition permission and the\n\t * role is changing, then check the (current_role, new_role)\n\t * pair.\n\t */\n\tif (tclass == policydb.process_class &&\n\t    (avd->allowed & policydb.process_trans_perms) &&\n\t    scontext->role != tcontext->role) {\n\t\tfor (ra = policydb.role_allow; ra; ra = ra->next) {\n\t\t\tif (scontext->role == ra->role &&\n\t\t\t    tcontext->role == ra->new_role)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!ra)\n\t\t\tavd->allowed &= ~policydb.process_trans_perms;\n\t}\n\n\t/*\n\t * If the given source and target types have boundary\n\t * constraint, lazy checks have to mask any violated\n\t * permission and notice it to userspace via audit.\n\t */\n\ttype_attribute_bounds_av(scontext, tcontext,\n\t\t\t\t tclass, avd);\n}\n\nstatic int security_validtrans_handle_fail(struct context *ocontext,\n\t\t\t\t\t   struct context *ncontext,\n\t\t\t\t\t   struct context *tcontext,\n\t\t\t\t\t   u16 tclass)\n{\n\tchar *o = NULL, *n = NULL, *t = NULL;\n\tu32 olen, nlen, tlen;\n\n\tif (context_struct_to_string(ocontext, &o, &olen))\n\t\tgoto out;\n\tif (context_struct_to_string(ncontext, &n, &nlen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"security_validate_transition:  denied for\"\n\t\t  \" oldcontext=%s newcontext=%s taskcontext=%s tclass=%s\",\n\t\t  o, n, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(o);\n\tkfree(n);\n\tkfree(t);\n\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EPERM;\n}\n\nint security_validate_transition(u32 oldsid, u32 newsid, u32 tasksid,\n\t\t\t\t u16 orig_tclass)\n{\n\tstruct context *ocontext;\n\tstruct context *ncontext;\n\tstruct context *tcontext;\n\tstruct class_datum *tclass_datum;\n\tstruct constraint_node *constraint;\n\tu16 tclass;\n\tint rc = 0;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\ttclass = unmap_class(orig_tclass);\n\n\tif (!tclass || tclass > policydb.p_classes.nprim) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized class %d\\n\",\n\t\t\t__func__, tclass);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\ttclass_datum = policydb.class_val_to_struct[tclass - 1];\n\n\tocontext = sidtab_search(&sidtab, oldsid);\n\tif (!ocontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, oldsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tncontext = sidtab_search(&sidtab, newsid);\n\tif (!ncontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, newsid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttcontext = sidtab_search(&sidtab, tasksid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, tasksid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconstraint = tclass_datum->validatetrans;\n\twhile (constraint) {\n\t\tif (!constraint_expr_eval(ocontext, ncontext, tcontext,\n\t\t\t\t\t  constraint->expr)) {\n\t\t\trc = security_validtrans_handle_fail(ocontext, ncontext,\n\t\t\t\t\t\t\t     tcontext, tclass);\n\t\t\tgoto out;\n\t\t}\n\t\tconstraint = constraint->next;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n/*\n * security_bounded_transition - check whether the given\n * transition is directed to bounded, or not.\n * It returns 0, if @newsid is bounded by @oldsid.\n * Otherwise, it returns error code.\n *\n * @oldsid : current security identifier\n * @newsid : destinated security identifier\n */\nint security_bounded_transition(u32 old_sid, u32 new_sid)\n{\n\tstruct context *old_context, *new_context;\n\tstruct type_datum *type;\n\tint index;\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\told_context = sidtab_search(&sidtab, old_sid);\n\tif (!old_context) {\n\t\tprintk(KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, old_sid);\n\t\tgoto out;\n\t}\n\n\trc = -EINVAL;\n\tnew_context = sidtab_search(&sidtab, new_sid);\n\tif (!new_context) {\n\t\tprintk(KERN_ERR \"SELinux: %s: unrecognized SID %u\\n\",\n\t\t       __func__, new_sid);\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\t/* type/domain unchanged */\n\tif (old_context->type == new_context->type)\n\t\tgoto out;\n\n\tindex = new_context->type;\n\twhile (true) {\n\t\ttype = flex_array_get_ptr(policydb.type_val_to_struct_array,\n\t\t\t\t\t  index - 1);\n\t\tBUG_ON(!type);\n\n\t\t/* not bounded anymore */\n\t\trc = -EPERM;\n\t\tif (!type->bounds)\n\t\t\tbreak;\n\n\t\t/* @newsid is bounded by @oldsid */\n\t\trc = 0;\n\t\tif (type->bounds == old_context->type)\n\t\t\tbreak;\n\n\t\tindex = type->bounds;\n\t}\n\n\tif (rc) {\n\t\tchar *old_name = NULL;\n\t\tchar *new_name = NULL;\n\t\tu32 length;\n\n\t\tif (!context_struct_to_string(old_context,\n\t\t\t\t\t      &old_name, &length) &&\n\t\t    !context_struct_to_string(new_context,\n\t\t\t\t\t      &new_name, &length)) {\n\t\t\taudit_log(current->audit_context,\n\t\t\t\t  GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t\t  \"op=security_bounded_transition \"\n\t\t\t\t  \"result=denied \"\n\t\t\t\t  \"oldcontext=%s newcontext=%s\",\n\t\t\t\t  old_name, new_name);\n\t\t}\n\t\tkfree(new_name);\n\t\tkfree(old_name);\n\t}\nout:\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}\n\nstatic void avd_init(struct av_decision *avd)\n{\n\tavd->allowed = 0;\n\tavd->auditallow = 0;\n\tavd->auditdeny = 0xffffffff;\n\tavd->seqno = latest_granting;\n\tavd->flags = 0;\n}\n\n\n/**\n * security_compute_av - Compute access vector decisions.\n * @ssid: source security identifier\n * @tsid: target security identifier\n * @tclass: target security class\n * @avd: access vector decisions\n *\n * Compute a set of access vector decisions based on the\n * SID pair (@ssid, @tsid) for the permissions in @tclass.\n */\nvoid security_compute_av(u32 ssid,\n\t\t\t u32 tsid,\n\t\t\t u16 orig_tclass,\n\t\t\t struct av_decision *avd)\n{\n\tu16 tclass;\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\ttclass = unmap_class(orig_tclass);\n\tif (unlikely(orig_tclass && !tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd);\n\tmap_decision(orig_tclass, avd, policydb.allow_unknown);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}\n\nvoid security_compute_av_user(u32 ssid,\n\t\t\t      u32 tsid,\n\t\t\t      u16 tclass,\n\t\t\t      struct av_decision *avd)\n{\n\tstruct context *scontext = NULL, *tcontext = NULL;\n\n\tread_lock(&policy_rwlock);\n\tavd_init(avd);\n\tif (!ss_initialized)\n\t\tgoto allow;\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\tgoto out;\n\t}\n\n\t/* permissive domain? */\n\tif (ebitmap_get_bit(&policydb.permissive_map, scontext->type))\n\t\tavd->flags |= AVD_FLAGS_PERMISSIVE;\n\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!tclass)) {\n\t\tif (policydb.allow_unknown)\n\t\t\tgoto allow;\n\t\tgoto out;\n\t}\n\n\tcontext_struct_compute_av(scontext, tcontext, tclass, avd);\n out:\n\tread_unlock(&policy_rwlock);\n\treturn;\nallow:\n\tavd->allowed = 0xffffffff;\n\tgoto out;\n}\n\n/*\n * Write the security context string representation of\n * the context structure `context' into a dynamically\n * allocated string of the correct size.  Set `*scontext'\n * to point to this string and set `*scontext_len' to\n * the length of the string.\n */\nstatic int context_struct_to_string(struct context *context, char **scontext, u32 *scontext_len)\n{\n\tchar *scontextp;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len = 0;\n\n\tif (context->len) {\n\t\t*scontext_len = context->len;\n\t\tif (scontext) {\n\t\t\t*scontext = kstrdup(context->str, GFP_ATOMIC);\n\t\t\tif (!(*scontext))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Compute the size of the context. */\n\t*scontext_len += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) + 1;\n\t*scontext_len += strlen(sym_name(&policydb, SYM_TYPES, context->type - 1)) + 1;\n\t*scontext_len += mls_compute_context_len(context);\n\n\tif (!scontext)\n\t\treturn 0;\n\n\t/* Allocate space for the context; caller must free this space. */\n\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\tif (!scontextp)\n\t\treturn -ENOMEM;\n\t*scontext = scontextp;\n\n\t/*\n\t * Copy the user name, role name and type name into the context.\n\t */\n\tsprintf(scontextp, \"%s:%s:%s\",\n\t\tsym_name(&policydb, SYM_USERS, context->user - 1),\n\t\tsym_name(&policydb, SYM_ROLES, context->role - 1),\n\t\tsym_name(&policydb, SYM_TYPES, context->type - 1));\n\tscontextp += strlen(sym_name(&policydb, SYM_USERS, context->user - 1)) +\n\t\t     1 + strlen(sym_name(&policydb, SYM_ROLES, context->role - 1)) +\n\t\t     1 + strlen(sym_name(&policydb, SYM_TYPES, context->type - 1));\n\n\tmls_sid_to_context(context, &scontextp);\n\n\t*scontextp = 0;\n\n\treturn 0;\n}\n\n#include \"initial_sid_to_string.h\"\n\nconst char *security_get_initial_sid_context(u32 sid)\n{\n\tif (unlikely(sid > SECINITSID_NUM))\n\t\treturn NULL;\n\treturn initial_sid_to_string[sid];\n}\n\nstatic int security_sid_to_context_core(u32 sid, char **scontext,\n\t\t\t\t\tu32 *scontext_len, int force)\n{\n\tstruct context *context;\n\tint rc = 0;\n\n\tif (scontext)\n\t\t*scontext = NULL;\n\t*scontext_len  = 0;\n\n\tif (!ss_initialized) {\n\t\tif (sid <= SECINITSID_NUM) {\n\t\t\tchar *scontextp;\n\n\t\t\t*scontext_len = strlen(initial_sid_to_string[sid]) + 1;\n\t\t\tif (!scontext)\n\t\t\t\tgoto out;\n\t\t\tscontextp = kmalloc(*scontext_len, GFP_ATOMIC);\n\t\t\tif (!scontextp) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstrcpy(scontextp, initial_sid_to_string[sid]);\n\t\t\t*scontext = scontextp;\n\t\t\tgoto out;\n\t\t}\n\t\tprintk(KERN_ERR \"SELinux: %s:  called before initial \"\n\t\t       \"load_policy on unknown SID %d\\n\", __func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\tif (force)\n\t\tcontext = sidtab_search_force(&sidtab, sid);\n\telse\n\t\tcontext = sidtab_search(&sidtab, sid);\n\tif (!context) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\trc = context_struct_to_string(context, scontext, scontext_len);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\treturn rc;\n\n}\n\n/**\n * security_sid_to_context - Obtain a context for a given SID.\n * @sid: security identifier, SID\n * @scontext: security context\n * @scontext_len: length in bytes\n *\n * Write the string representation of the context associated with @sid\n * into a dynamically allocated string of the correct size.  Set @scontext\n * to point to this string and set @scontext_len to the length of the string.\n */\nint security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 0);\n}\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}\n\n/*\n * Caveat:  Mutates scontext.\n */\nstatic int string_to_context_struct(struct policydb *pol,\n\t\t\t\t    struct sidtab *sidtabp,\n\t\t\t\t    char *scontext,\n\t\t\t\t    u32 scontext_len,\n\t\t\t\t    struct context *ctx,\n\t\t\t\t    u32 def_sid)\n{\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *scontextp, *p, oldc;\n\tint rc = 0;\n\n\tcontext_init(ctx);\n\n\t/* Parse the security context. */\n\n\trc = -EINVAL;\n\tscontextp = (char *) scontext;\n\n\t/* Extract the user. */\n\tp = scontextp;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\tusrdatum = hashtab_search(pol->p_users.table, scontextp);\n\tif (!usrdatum)\n\t\tgoto out;\n\n\tctx->user = usrdatum->value;\n\n\t/* Extract role. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\n\tif (*p == 0)\n\t\tgoto out;\n\n\t*p++ = 0;\n\n\trole = hashtab_search(pol->p_roles.table, scontextp);\n\tif (!role)\n\t\tgoto out;\n\tctx->role = role->value;\n\n\t/* Extract type. */\n\tscontextp = p;\n\twhile (*p && *p != ':')\n\t\tp++;\n\toldc = *p;\n\t*p++ = 0;\n\n\ttypdatum = hashtab_search(pol->p_types.table, scontextp);\n\tif (!typdatum || typdatum->attribute)\n\t\tgoto out;\n\n\tctx->type = typdatum->value;\n\n\trc = mls_context_to_sid(pol, oldc, &p, ctx, sidtabp, def_sid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif ((p - scontext) < scontext_len)\n\t\tgoto out;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(pol, ctx))\n\t\tgoto out;\n\trc = 0;\nout:\n\tif (rc)\n\t\tcontext_destroy(ctx);\n\treturn rc;\n}\n\nstatic int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}\n\n/**\n * security_context_to_sid - Obtain a SID for a given security context.\n * @scontext: security context\n * @scontext_len: length in bytes\n * @sid: security identifier, SID\n *\n * Obtains a SID associated with the security context that\n * has the string representation specified by @scontext.\n * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient\n * memory is available, or 0 on success.\n */\nint security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, GFP_KERNEL, 0);\n}\n\n/**\n * security_context_to_sid_default - Obtain a SID for a given security context,\n * falling back to specified default if needed.\n *\n * @scontext: security context\n * @scontext_len: length in bytes\n * @sid: security identifier, SID\n * @def_sid: default SID to assign on error\n *\n * Obtains a SID associated with the security context that\n * has the string representation specified by @scontext.\n * The default SID is passed to the MLS layer to be used to allow\n * kernel labeling of the MLS field if the MLS field is not present\n * (for upgrading to MLS without full relabel).\n * Implicitly forces adding of the context even if it cannot be mapped yet.\n * Returns -%EINVAL if the context is invalid, -%ENOMEM if insufficient\n * memory is available, or 0 on success.\n */\nint security_context_to_sid_default(const char *scontext, u32 scontext_len,\n\t\t\t\t    u32 *sid, u32 def_sid, gfp_t gfp_flags)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, def_sid, gfp_flags, 1);\n}\n\nint security_context_to_sid_force(const char *scontext, u32 scontext_len,\n\t\t\t\t  u32 *sid)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, GFP_KERNEL, 1);\n}\n\nstatic int compute_sid_handle_invalid_context(\n\tstruct context *scontext,\n\tstruct context *tcontext,\n\tu16 tclass,\n\tstruct context *newcontext)\n{\n\tchar *s = NULL, *t = NULL, *n = NULL;\n\tu32 slen, tlen, nlen;\n\n\tif (context_struct_to_string(scontext, &s, &slen))\n\t\tgoto out;\n\tif (context_struct_to_string(tcontext, &t, &tlen))\n\t\tgoto out;\n\tif (context_struct_to_string(newcontext, &n, &nlen))\n\t\tgoto out;\n\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t  \"security_compute_sid:  invalid context %s\"\n\t\t  \" for scontext=%s\"\n\t\t  \" tcontext=%s\"\n\t\t  \" tclass=%s\",\n\t\t  n, s, t, sym_name(&policydb, SYM_CLASSES, tclass-1));\nout:\n\tkfree(s);\n\tkfree(t);\n\tkfree(n);\n\tif (!selinux_enforcing)\n\t\treturn 0;\n\treturn -EACCES;\n}\n\nstatic void filename_compute_type(struct policydb *p, struct context *newcontext,\n\t\t\t\t  u32 stype, u32 ttype, u16 tclass,\n\t\t\t\t  const char *objname)\n{\n\tstruct filename_trans ft;\n\tstruct filename_trans_datum *otype;\n\n\t/*\n\t * Most filename trans rules are going to live in specific directories\n\t * like /dev or /var/run.  This bitmap will quickly skip rule searches\n\t * if the ttype does not contain any rules.\n\t */\n\tif (!ebitmap_get_bit(&p->filename_trans_ttypes, ttype))\n\t\treturn;\n\n\tft.stype = stype;\n\tft.ttype = ttype;\n\tft.tclass = tclass;\n\tft.name = objname;\n\n\totype = hashtab_search(p->filename_trans, &ft);\n\tif (otype)\n\t\tnewcontext->type = otype->otype;\n}\n\nstatic int security_compute_sid(u32 ssid,\n\t\t\t\tu32 tsid,\n\t\t\t\tu16 orig_tclass,\n\t\t\t\tu32 specified,\n\t\t\t\tconst char *objname,\n\t\t\t\tu32 *out_sid,\n\t\t\t\tbool kern)\n{\n\tstruct class_datum *cladatum = NULL;\n\tstruct context *scontext = NULL, *tcontext = NULL, newcontext;\n\tstruct role_trans *roletr = NULL;\n\tstruct avtab_key avkey;\n\tstruct avtab_datum *avdatum;\n\tstruct avtab_node *node;\n\tu16 tclass;\n\tint rc = 0;\n\tbool sock;\n\n\tif (!ss_initialized) {\n\t\tswitch (orig_tclass) {\n\t\tcase SECCLASS_PROCESS: /* kernel value */\n\t\t\t*out_sid = ssid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*out_sid = tsid;\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcontext);\n\n\tread_lock(&policy_rwlock);\n\n\tif (kern) {\n\t\ttclass = unmap_class(orig_tclass);\n\t\tsock = security_is_socket_class(orig_tclass);\n\t} else {\n\t\ttclass = orig_tclass;\n\t\tsock = security_is_socket_class(map_class(tclass));\n\t}\n\n\tscontext = sidtab_search(&sidtab, ssid);\n\tif (!scontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, ssid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ttcontext = sidtab_search(&sidtab, tsid);\n\tif (!tcontext) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, tsid);\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (tclass && tclass <= policydb.p_classes.nprim)\n\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\n\t/* Set the user identity. */\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\tcase AVTAB_CHANGE:\n\t\tif (cladatum && cladatum->default_user == DEFAULT_TARGET) {\n\t\t\tnewcontext.user = tcontext->user;\n\t\t} else {\n\t\t\t/* notice this gets both DEFAULT_SOURCE and unset */\n\t\t\t/* Use the process user identity. */\n\t\t\tnewcontext.user = scontext->user;\n\t\t}\n\t\tbreak;\n\tcase AVTAB_MEMBER:\n\t\t/* Use the related object owner. */\n\t\tnewcontext.user = tcontext->user;\n\t\tbreak;\n\t}\n\n\t/* Set the role to default values. */\n\tif (cladatum && cladatum->default_role == DEFAULT_SOURCE) {\n\t\tnewcontext.role = scontext->role;\n\t} else if (cladatum && cladatum->default_role == DEFAULT_TARGET) {\n\t\tnewcontext.role = tcontext->role;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\tnewcontext.role = scontext->role;\n\t\telse\n\t\t\tnewcontext.role = OBJECT_R_VAL;\n\t}\n\n\t/* Set the type to default values. */\n\tif (cladatum && cladatum->default_type == DEFAULT_SOURCE) {\n\t\tnewcontext.type = scontext->type;\n\t} else if (cladatum && cladatum->default_type == DEFAULT_TARGET) {\n\t\tnewcontext.type = tcontext->type;\n\t} else {\n\t\tif ((tclass == policydb.process_class) || (sock == true)) {\n\t\t\t/* Use the type of process. */\n\t\t\tnewcontext.type = scontext->type;\n\t\t} else {\n\t\t\t/* Use the type of the related object. */\n\t\t\tnewcontext.type = tcontext->type;\n\t\t}\n\t}\n\n\t/* Look for a type transition/member/change rule. */\n\tavkey.source_type = scontext->type;\n\tavkey.target_type = tcontext->type;\n\tavkey.target_class = tclass;\n\tavkey.specified = specified;\n\tavdatum = avtab_search(&policydb.te_avtab, &avkey);\n\n\t/* If no permanent rule, also check for enabled conditional rules */\n\tif (!avdatum) {\n\t\tnode = avtab_search_node(&policydb.te_cond_avtab, &avkey);\n\t\tfor (; node; node = avtab_search_node_next(node, specified)) {\n\t\t\tif (node->key.specified & AVTAB_ENABLED) {\n\t\t\t\tavdatum = &node->datum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (avdatum) {\n\t\t/* Use the type from the type transition/member/change rule. */\n\t\tnewcontext.type = avdatum->data;\n\t}\n\n\t/* if we have a objname this is a file trans check so check those rules */\n\tif (objname)\n\t\tfilename_compute_type(&policydb, &newcontext, scontext->type,\n\t\t\t\t      tcontext->type, tclass, objname);\n\n\t/* Check for class-specific changes. */\n\tif (specified & AVTAB_TRANSITION) {\n\t\t/* Look for a role transition rule. */\n\t\tfor (roletr = policydb.role_tr; roletr; roletr = roletr->next) {\n\t\t\tif ((roletr->role == scontext->role) &&\n\t\t\t    (roletr->type == tcontext->type) &&\n\t\t\t    (roletr->tclass == tclass)) {\n\t\t\t\t/* Use the role transition rule. */\n\t\t\t\tnewcontext.role = roletr->new_role;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Set the MLS attributes.\n\t   This is done last because it may allocate memory. */\n\trc = mls_compute_sid(scontext, tcontext, tclass, specified,\n\t\t\t     &newcontext, sock);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the context. */\n\tif (!policydb_context_isvalid(&policydb, &newcontext)) {\n\t\trc = compute_sid_handle_invalid_context(scontext,\n\t\t\t\t\t\t\ttcontext,\n\t\t\t\t\t\t\ttclass,\n\t\t\t\t\t\t\t&newcontext);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t}\n\t/* Obtain the sid for the context. */\n\trc = sidtab_context_to_sid(&sidtab, &newcontext, out_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcontext);\nout:\n\treturn rc;\n}\n\n/**\n * security_transition_sid - Compute the SID for a new subject/object.\n * @ssid: source security identifier\n * @tsid: target security identifier\n * @tclass: target security class\n * @out_sid: security identifier for new subject/object\n *\n * Compute a SID to use for labeling a new subject or object in the\n * class @tclass based on a SID pair (@ssid, @tsid).\n * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM\n * if insufficient memory is available, or %0 if the new SID was\n * computed successfully.\n */\nint security_transition_sid(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t    const struct qstr *qstr, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    qstr ? qstr->name : NULL, out_sid, true);\n}\n\nint security_transition_sid_user(u32 ssid, u32 tsid, u16 tclass,\n\t\t\t\t const char *objname, u32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,\n\t\t\t\t    objname, out_sid, false);\n}\n\n/**\n * security_member_sid - Compute the SID for member selection.\n * @ssid: source security identifier\n * @tsid: target security identifier\n * @tclass: target security class\n * @out_sid: security identifier for selected member\n *\n * Compute a SID to use when selecting a member of a polyinstantiated\n * object of class @tclass based on a SID pair (@ssid, @tsid).\n * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM\n * if insufficient memory is available, or %0 if the SID was\n * computed successfully.\n */\nint security_member_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_MEMBER, NULL,\n\t\t\t\t    out_sid, false);\n}\n\n/**\n * security_change_sid - Compute the SID for object relabeling.\n * @ssid: source security identifier\n * @tsid: target security identifier\n * @tclass: target security class\n * @out_sid: security identifier for selected member\n *\n * Compute a SID to use for relabeling an object of class @tclass\n * based on a SID pair (@ssid, @tsid).\n * Return -%EINVAL if any of the parameters are invalid, -%ENOMEM\n * if insufficient memory is available, or %0 if the SID was\n * computed successfully.\n */\nint security_change_sid(u32 ssid,\n\t\t\tu32 tsid,\n\t\t\tu16 tclass,\n\t\t\tu32 *out_sid)\n{\n\treturn security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, NULL,\n\t\t\t\t    out_sid, false);\n}\n\n/* Clone the SID into the new SID table. */\nstatic int clone_sid(u32 sid,\n\t\t     struct context *context,\n\t\t     void *arg)\n{\n\tstruct sidtab *s = arg;\n\n\tif (sid > SECINITSID_NUM)\n\t\treturn sidtab_insert(s, sid, context);\n\telse\n\t\treturn 0;\n}\n\nstatic inline int convert_context_handle_invalid_context(struct context *context)\n{\n\tchar *s;\n\tu32 len;\n\n\tif (selinux_enforcing)\n\t\treturn -EINVAL;\n\n\tif (!context_struct_to_string(context, &s, &len)) {\n\t\tprintk(KERN_WARNING \"SELinux:  Context %s would be invalid if enforcing\\n\", s);\n\t\tkfree(s);\n\t}\n\treturn 0;\n}\n\nstruct convert_context_args {\n\tstruct policydb *oldp;\n\tstruct policydb *newp;\n};\n\n/*\n * Convert the values in the security context\n * structure `c' from the values specified\n * in the policy `p->oldp' to the values specified\n * in the policy `p->newp'.  Verify that the\n * context is valid under the new policy.\n */\nstatic int convert_context(u32 key,\n\t\t\t   struct context *c,\n\t\t\t   void *p)\n{\n\tstruct convert_context_args *args;\n\tstruct context oldc;\n\tstruct ocontext *oc;\n\tstruct mls_range *range;\n\tstruct role_datum *role;\n\tstruct type_datum *typdatum;\n\tstruct user_datum *usrdatum;\n\tchar *s;\n\tu32 len;\n\tint rc = 0;\n\n\tif (key <= SECINITSID_NUM)\n\t\tgoto out;\n\n\targs = p;\n\n\tif (c->str) {\n\t\tstruct context ctx;\n\n\t\trc = -ENOMEM;\n\t\ts = kstrdup(c->str, GFP_KERNEL);\n\t\tif (!s)\n\t\t\tgoto out;\n\n\t\trc = string_to_context_struct(args->newp, NULL, s,\n\t\t\t\t\t      c->len, &ctx, SECSID_NULL);\n\t\tkfree(s);\n\t\tif (!rc) {\n\t\t\tprintk(KERN_INFO \"SELinux:  Context %s became valid (mapped).\\n\",\n\t\t\t       c->str);\n\t\t\t/* Replace string with mapped representation. */\n\t\t\tkfree(c->str);\n\t\t\tmemcpy(c, &ctx, sizeof(*c));\n\t\t\tgoto out;\n\t\t} else if (rc == -EINVAL) {\n\t\t\t/* Retain string representation for later mapping. */\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* Other error condition, e.g. ENOMEM. */\n\t\t\tprintk(KERN_ERR \"SELinux:   Unable to map context %s, rc = %d.\\n\",\n\t\t\t       c->str, -rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trc = context_cpy(&oldc, c);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Convert the user. */\n\trc = -EINVAL;\n\tusrdatum = hashtab_search(args->newp->p_users.table,\n\t\t\t\t  sym_name(args->oldp, SYM_USERS, c->user - 1));\n\tif (!usrdatum)\n\t\tgoto bad;\n\tc->user = usrdatum->value;\n\n\t/* Convert the role. */\n\trc = -EINVAL;\n\trole = hashtab_search(args->newp->p_roles.table,\n\t\t\t      sym_name(args->oldp, SYM_ROLES, c->role - 1));\n\tif (!role)\n\t\tgoto bad;\n\tc->role = role->value;\n\n\t/* Convert the type. */\n\trc = -EINVAL;\n\ttypdatum = hashtab_search(args->newp->p_types.table,\n\t\t\t\t  sym_name(args->oldp, SYM_TYPES, c->type - 1));\n\tif (!typdatum)\n\t\tgoto bad;\n\tc->type = typdatum->value;\n\n\t/* Convert the MLS fields if dealing with MLS policies */\n\tif (args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\trc = mls_convert_context(args->oldp, args->newp, c);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t} else if (args->oldp->mls_enabled && !args->newp->mls_enabled) {\n\t\t/*\n\t\t * Switching between MLS and non-MLS policy:\n\t\t * free any storage used by the MLS fields in the\n\t\t * context for all existing entries in the sidtab.\n\t\t */\n\t\tmls_context_destroy(c);\n\t} else if (!args->oldp->mls_enabled && args->newp->mls_enabled) {\n\t\t/*\n\t\t * Switching between non-MLS and MLS policy:\n\t\t * ensure that the MLS fields of the context for all\n\t\t * existing entries in the sidtab are filled in with a\n\t\t * suitable default value, likely taken from one of the\n\t\t * initial SIDs.\n\t\t */\n\t\toc = args->newp->ocontexts[OCON_ISID];\n\t\twhile (oc && oc->sid[0] != SECINITSID_UNLABELED)\n\t\t\toc = oc->next;\n\t\trc = -EINVAL;\n\t\tif (!oc) {\n\t\t\tprintk(KERN_ERR \"SELinux:  unable to look up\"\n\t\t\t\t\" the initial SIDs list\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\trange = &oc->context[0].range;\n\t\trc = mls_range_set(c, range);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(args->newp, c)) {\n\t\trc = convert_context_handle_invalid_context(&oldc);\n\t\tif (rc)\n\t\t\tgoto bad;\n\t}\n\n\tcontext_destroy(&oldc);\n\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\t/* Map old representation to string and save it. */\n\trc = context_struct_to_string(&oldc, &s, &len);\n\tif (rc)\n\t\treturn rc;\n\tcontext_destroy(&oldc);\n\tcontext_destroy(c);\n\tc->str = s;\n\tc->len = len;\n\tprintk(KERN_INFO \"SELinux:  Context %s became invalid (unmapped).\\n\",\n\t       c->str);\n\trc = 0;\n\tgoto out;\n}\n\nstatic void security_load_policycaps(void)\n{\n\tselinux_policycap_netpeer = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_NETPEER);\n\tselinux_policycap_openperm = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_OPENPERM);\n\tselinux_policycap_alwaysnetwork = ebitmap_get_bit(&policydb.policycaps,\n\t\t\t\t\t\t  POLICYDB_CAPABILITY_ALWAYSNETWORK);\n}\n\nstatic int security_preserve_bools(struct policydb *p);\n\n/**\n * security_load_policy - Load a security policy configuration.\n * @data: binary policy data\n * @len: length of data in bytes\n *\n * Load a new set of security policy configuration data,\n * validate it and convert the SID table as necessary.\n * This function will flush the access vector cache after\n * loading the new policy.\n */\nint security_load_policy(void *data, size_t len)\n{\n\tstruct policydb *oldpolicydb, *newpolicydb;\n\tstruct sidtab oldsidtab, newsidtab;\n\tstruct selinux_mapping *oldmap, *map = NULL;\n\tstruct convert_context_args args;\n\tu32 seqno;\n\tu16 map_size;\n\tint rc = 0;\n\tstruct policy_file file = { data, len }, *fp = &file;\n\n\toldpolicydb = kzalloc(2 * sizeof(*oldpolicydb), GFP_KERNEL);\n\tif (!oldpolicydb) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnewpolicydb = oldpolicydb + 1;\n\n\tif (!ss_initialized) {\n\t\tavtab_cache_init();\n\t\trc = policydb_read(&policydb, fp);\n\t\tif (rc) {\n\t\t\tavtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tpolicydb.len = len;\n\t\trc = selinux_set_mapping(&policydb, secclass_map,\n\t\t\t\t\t &current_mapping,\n\t\t\t\t\t &current_mapping_size);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = policydb_load_isids(&policydb, &sidtab);\n\t\tif (rc) {\n\t\t\tpolicydb_destroy(&policydb);\n\t\t\tavtab_cache_destroy();\n\t\t\tgoto out;\n\t\t}\n\n\t\tsecurity_load_policycaps();\n\t\tss_initialized = 1;\n\t\tseqno = ++latest_granting;\n\t\tselinux_complete_init();\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_netlbl_cache_invalidate();\n\t\tselinux_xfrm_notify_policyload();\n\t\tgoto out;\n\t}\n\n#if 0\n\tsidtab_hash_eval(&sidtab, \"sids\");\n#endif\n\n\trc = policydb_read(newpolicydb, fp);\n\tif (rc)\n\t\tgoto out;\n\n\tnewpolicydb->len = len;\n\t/* If switching between different policy types, log MLS status */\n\tif (policydb.mls_enabled && !newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Disabling MLS support...\\n\");\n\telse if (!policydb.mls_enabled && newpolicydb->mls_enabled)\n\t\tprintk(KERN_INFO \"SELinux: Enabling MLS support...\\n\");\n\n\trc = policydb_load_isids(newpolicydb, &newsidtab);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to load the initial SIDs\\n\");\n\t\tpolicydb_destroy(newpolicydb);\n\t\tgoto out;\n\t}\n\n\trc = selinux_set_mapping(newpolicydb, secclass_map, &map, &map_size);\n\tif (rc)\n\t\tgoto err;\n\n\trc = security_preserve_bools(newpolicydb);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to preserve booleans\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Clone the SID table. */\n\tsidtab_shutdown(&sidtab);\n\n\trc = sidtab_map(&sidtab, clone_sid, &newsidtab);\n\tif (rc)\n\t\tgoto err;\n\n\t/*\n\t * Convert the internal representations of contexts\n\t * in the new SID table.\n\t */\n\targs.oldp = &policydb;\n\targs.newp = newpolicydb;\n\trc = sidtab_map(&newsidtab, convert_context, &args);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux:  unable to convert the internal\"\n\t\t\t\" representation of contexts in the new SID\"\n\t\t\t\" table\\n\");\n\t\tgoto err;\n\t}\n\n\t/* Save the old policydb and SID table to free later. */\n\tmemcpy(oldpolicydb, &policydb, sizeof(policydb));\n\tsidtab_set(&oldsidtab, &sidtab);\n\n\t/* Install the new policydb and SID table. */\n\twrite_lock_irq(&policy_rwlock);\n\tmemcpy(&policydb, newpolicydb, sizeof(policydb));\n\tsidtab_set(&sidtab, &newsidtab);\n\tsecurity_load_policycaps();\n\toldmap = current_mapping;\n\tcurrent_mapping = map;\n\tcurrent_mapping_size = map_size;\n\tseqno = ++latest_granting;\n\twrite_unlock_irq(&policy_rwlock);\n\n\t/* Free the old policydb and SID table. */\n\tpolicydb_destroy(oldpolicydb);\n\tsidtab_destroy(&oldsidtab);\n\tkfree(oldmap);\n\n\tavc_ss_reset(seqno);\n\tselnl_notify_policyload(seqno);\n\tselinux_status_update_policyload(seqno);\n\tselinux_netlbl_cache_invalidate();\n\tselinux_xfrm_notify_policyload();\n\n\trc = 0;\n\tgoto out;\n\nerr:\n\tkfree(map);\n\tsidtab_destroy(&newsidtab);\n\tpolicydb_destroy(newpolicydb);\n\nout:\n\tkfree(oldpolicydb);\n\treturn rc;\n}\n\nsize_t security_policydb_len(void)\n{\n\tsize_t len;\n\n\tread_lock(&policy_rwlock);\n\tlen = policydb.len;\n\tread_unlock(&policy_rwlock);\n\n\treturn len;\n}\n\n/**\n * security_port_sid - Obtain the SID for a port.\n * @protocol: protocol number\n * @port: port number\n * @out_sid: security identifier\n */\nint security_port_sid(u8 protocol, u16 port, u32 *out_sid)\n{\n\tstruct ocontext *c;\n\tint rc = 0;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_PORT];\n\twhile (c) {\n\t\tif (c->u.port.protocol == protocol &&\n\t\t    c->u.port.low_port <= port &&\n\t\t    c->u.port.high_port >= port)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_PORT;\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n/**\n * security_netif_sid - Obtain the SID for a network interface.\n * @name: interface name\n * @if_sid: interface SID\n */\nint security_netif_sid(char *name, u32 *if_sid)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_NETIF];\n\twhile (c) {\n\t\tif (strcmp(name, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0] || !c->sid[1]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t  &c->context[0],\n\t\t\t\t\t\t  &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[1],\n\t\t\t\t\t\t   &c->sid[1]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*if_sid = c->sid[0];\n\t} else\n\t\t*if_sid = SECINITSID_NETIF;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nstatic int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)\n{\n\tint i, fail = 0;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (addr[i] != (input[i] & mask[i])) {\n\t\t\tfail = 1;\n\t\t\tbreak;\n\t\t}\n\n\treturn !fail;\n}\n\n/**\n * security_node_sid - Obtain the SID for a node (host).\n * @domain: communication domain aka address family\n * @addrp: address\n * @addrlen: address length in bytes\n * @out_sid: security identifier\n */\nint security_node_sid(u16 domain,\n\t\t      void *addrp,\n\t\t      u32 addrlen,\n\t\t      u32 *out_sid)\n{\n\tint rc;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tswitch (domain) {\n\tcase AF_INET: {\n\t\tu32 addr;\n\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u32))\n\t\t\tgoto out;\n\n\t\taddr = *((u32 *)addrp);\n\n\t\tc = policydb.ocontexts[OCON_NODE];\n\t\twhile (c) {\n\t\t\tif (c->u.node.addr == (addr & c->u.node.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6:\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u64) * 2)\n\t\t\tgoto out;\n\t\tc = policydb.ocontexts[OCON_NODE6];\n\t\twhile (c) {\n\t\t\tif (match_ipv6_addrmask(addrp, c->u.node6.addr,\n\t\t\t\t\t\tc->u.node6.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = 0;\n\t\t*out_sid = SECINITSID_NODE;\n\t\tgoto out;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_NODE;\n\t}\n\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n#define SIDS_NEL 25\n\n/**\n * security_get_user_sids - Obtain reachable SIDs for a user.\n * @fromsid: starting SID\n * @username: username\n * @sids: array of reachable SIDs for user\n * @nel: number of elements in @sids\n *\n * Generate the set of SIDs for legal security contexts\n * for a given user that can be reached by @fromsid.\n * Set *@sids to point to a dynamically allocated\n * array containing the set of SIDs.  Set *@nel to the\n * number of elements in the array.\n */\n\nint security_get_user_sids(u32 fromsid,\n\t\t\t   char *username,\n\t\t\t   u32 **sids,\n\t\t\t   u32 *nel)\n{\n\tstruct context *fromcon, usercon;\n\tu32 *mysids = NULL, *mysids2, sid;\n\tu32 mynel = 0, maxnel = SIDS_NEL;\n\tstruct user_datum *user;\n\tstruct role_datum *role;\n\tstruct ebitmap_node *rnode, *tnode;\n\tint rc = 0, i, j;\n\n\t*sids = NULL;\n\t*nel = 0;\n\n\tif (!ss_initialized)\n\t\tgoto out;\n\n\tread_lock(&policy_rwlock);\n\n\tcontext_init(&usercon);\n\n\trc = -EINVAL;\n\tfromcon = sidtab_search(&sidtab, fromsid);\n\tif (!fromcon)\n\t\tgoto out_unlock;\n\n\trc = -EINVAL;\n\tuser = hashtab_search(policydb.p_users.table, username);\n\tif (!user)\n\t\tgoto out_unlock;\n\n\tusercon.user = user->value;\n\n\trc = -ENOMEM;\n\tmysids = kcalloc(maxnel, sizeof(*mysids), GFP_ATOMIC);\n\tif (!mysids)\n\t\tgoto out_unlock;\n\n\tebitmap_for_each_positive_bit(&user->roles, rnode, i) {\n\t\trole = policydb.role_val_to_struct[i];\n\t\tusercon.role = i + 1;\n\t\tebitmap_for_each_positive_bit(&role->types, tnode, j) {\n\t\t\tusercon.type = j + 1;\n\n\t\t\tif (mls_setup_user_range(fromcon, user, &usercon))\n\t\t\t\tcontinue;\n\n\t\t\trc = sidtab_context_to_sid(&sidtab, &usercon, &sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out_unlock;\n\t\t\tif (mynel < maxnel) {\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t} else {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tmaxnel += SIDS_NEL;\n\t\t\t\tmysids2 = kcalloc(maxnel, sizeof(*mysids2), GFP_ATOMIC);\n\t\t\t\tif (!mysids2)\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\tmemcpy(mysids2, mysids, mynel * sizeof(*mysids2));\n\t\t\t\tkfree(mysids);\n\t\t\t\tmysids = mysids2;\n\t\t\t\tmysids[mynel++] = sid;\n\t\t\t}\n\t\t}\n\t}\n\trc = 0;\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tif (rc || !mynel) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tmysids2 = kcalloc(mynel, sizeof(*mysids2), GFP_KERNEL);\n\tif (!mysids2) {\n\t\tkfree(mysids);\n\t\tgoto out;\n\t}\n\tfor (i = 0, j = 0; i < mynel; i++) {\n\t\tstruct av_decision dummy_avd;\n\t\trc = avc_has_perm_noaudit(fromsid, mysids[i],\n\t\t\t\t\t  SECCLASS_PROCESS, /* kernel value */\n\t\t\t\t\t  PROCESS__TRANSITION, AVC_STRICT,\n\t\t\t\t\t  &dummy_avd);\n\t\tif (!rc)\n\t\t\tmysids2[j++] = mysids[i];\n\t\tcond_resched();\n\t}\n\trc = 0;\n\tkfree(mysids);\n\t*sids = mysids2;\n\t*nel = j;\nout:\n\treturn rc;\n}\n\n/**\n * security_genfs_sid - Obtain a SID for a file in a filesystem\n * @fstype: filesystem type\n * @path: path from root of mount\n * @sclass: file security class\n * @sid: SID for path\n *\n * Obtain a SID to use for a file in a filesystem that\n * cannot support xattr or use a fixed labeling behavior like\n * transition SIDs or task SIDs.\n */\nint security_genfs_sid(const char *fstype,\n\t\t       char *path,\n\t\t       u16 orig_sclass,\n\t\t       u32 *sid)\n{\n\tint len;\n\tu16 sclass;\n\tstruct genfs *genfs;\n\tstruct ocontext *c;\n\tint rc, cmp = 0;\n\n\twhile (path[0] == '/' && path[1] == '/')\n\t\tpath++;\n\n\tread_lock(&policy_rwlock);\n\n\tsclass = unmap_class(orig_sclass);\n\t*sid = SECINITSID_UNLABELED;\n\n\tfor (genfs = policydb.genfs; genfs; genfs = genfs->next) {\n\t\tcmp = strcmp(fstype, genfs->fstype);\n\t\tif (cmp <= 0)\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!genfs || cmp)\n\t\tgoto out;\n\n\tfor (c = genfs->head; c; c = c->next) {\n\t\tlen = strlen(c->u.name);\n\t\tif ((!c->v.sclass || sclass == c->v.sclass) &&\n\t\t    (strncmp(c->u.name, path, len) == 0))\n\t\t\tbreak;\n\t}\n\n\trc = -ENOENT;\n\tif (!c)\n\t\tgoto out;\n\n\tif (!c->sid[0]) {\n\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0], &c->sid[0]);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t*sid = c->sid[0];\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n/**\n * security_fs_use - Determine how to handle labeling for a filesystem.\n * @sb: superblock in question\n */\nint security_fs_use(struct super_block *sb)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tconst char *fstype = sb->s_type->name;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_FSUSE];\n\twhile (c) {\n\t\tif (strcmp(fstype, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tsbsec->behavior = c->v.behavior;\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab, &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\tsbsec->sid = c->sid[0];\n\t} else {\n\t\trc = security_genfs_sid(fstype, \"/\", SECCLASS_DIR, &sbsec->sid);\n\t\tif (rc) {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_NONE;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_GENFS;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nint security_get_bools(int *len, char ***names, int **values)\n{\n\tint i, rc;\n\n\tread_lock(&policy_rwlock);\n\t*names = NULL;\n\t*values = NULL;\n\n\trc = 0;\n\t*len = policydb.p_bools.nprim;\n\tif (!*len)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\t*names = kcalloc(*len, sizeof(char *), GFP_ATOMIC);\n\tif (!*names)\n\t\tgoto err;\n\n\trc = -ENOMEM;\n\t*values = kcalloc(*len, sizeof(int), GFP_ATOMIC);\n\tif (!*values)\n\t\tgoto err;\n\n\tfor (i = 0; i < *len; i++) {\n\t\tsize_t name_len;\n\n\t\t(*values)[i] = policydb.bool_val_to_struct[i]->state;\n\t\tname_len = strlen(sym_name(&policydb, SYM_BOOLS, i)) + 1;\n\n\t\trc = -ENOMEM;\n\t\t(*names)[i] = kmalloc(sizeof(char) * name_len, GFP_ATOMIC);\n\t\tif (!(*names)[i])\n\t\t\tgoto err;\n\n\t\tstrncpy((*names)[i], sym_name(&policydb, SYM_BOOLS, i), name_len);\n\t\t(*names)[i][name_len - 1] = 0;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\nerr:\n\tif (*names) {\n\t\tfor (i = 0; i < *len; i++)\n\t\t\tkfree((*names)[i]);\n\t}\n\tkfree(*values);\n\tgoto out;\n}\n\n\nint security_set_bools(int len, int *values)\n{\n\tint i, rc;\n\tint lenp, seqno = 0;\n\tstruct cond_node *cur;\n\n\twrite_lock_irq(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlenp = policydb.p_bools.nprim;\n\tif (len != lenp)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (!!values[i] != policydb.bool_val_to_struct[i]->state) {\n\t\t\taudit_log(current->audit_context, GFP_ATOMIC,\n\t\t\t\tAUDIT_MAC_CONFIG_CHANGE,\n\t\t\t\t\"bool=%s val=%d old_val=%d auid=%u ses=%u\",\n\t\t\t\tsym_name(&policydb, SYM_BOOLS, i),\n\t\t\t\t!!values[i],\n\t\t\t\tpolicydb.bool_val_to_struct[i]->state,\n\t\t\t\tfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\n\t\t\t\taudit_get_sessionid(current));\n\t\t}\n\t\tif (values[i])\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 1;\n\t\telse\n\t\t\tpolicydb.bool_val_to_struct[i]->state = 0;\n\t}\n\n\tfor (cur = policydb.cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(&policydb, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tseqno = ++latest_granting;\n\trc = 0;\nout:\n\twrite_unlock_irq(&policy_rwlock);\n\tif (!rc) {\n\t\tavc_ss_reset(seqno);\n\t\tselnl_notify_policyload(seqno);\n\t\tselinux_status_update_policyload(seqno);\n\t\tselinux_xfrm_notify_policyload();\n\t}\n\treturn rc;\n}\n\nint security_get_bool_value(int bool)\n{\n\tint rc;\n\tint len;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EFAULT;\n\tlen = policydb.p_bools.nprim;\n\tif (bool >= len)\n\t\tgoto out;\n\n\trc = policydb.bool_val_to_struct[bool]->state;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nstatic int security_preserve_bools(struct policydb *p)\n{\n\tint rc, nbools = 0, *bvalues = NULL, i;\n\tchar **bnames = NULL;\n\tstruct cond_bool_datum *booldatum;\n\tstruct cond_node *cur;\n\n\trc = security_get_bools(&nbools, &bnames, &bvalues);\n\tif (rc)\n\t\tgoto out;\n\tfor (i = 0; i < nbools; i++) {\n\t\tbooldatum = hashtab_search(p->p_bools.table, bnames[i]);\n\t\tif (booldatum)\n\t\t\tbooldatum->state = bvalues[i];\n\t}\n\tfor (cur = p->cond_list; cur; cur = cur->next) {\n\t\trc = evaluate_cond_node(p, cur);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (bnames) {\n\t\tfor (i = 0; i < nbools; i++)\n\t\t\tkfree(bnames[i]);\n\t}\n\tkfree(bnames);\n\tkfree(bvalues);\n\treturn rc;\n}\n\n/*\n * security_sid_mls_copy() - computes a new sid based on the given\n * sid and the mls portion of mls_sid.\n */\nint security_sid_mls_copy(u32 sid, u32 mls_sid, u32 *new_sid)\n{\n\tstruct context *context1;\n\tstruct context *context2;\n\tstruct context newcon;\n\tchar *s;\n\tu32 len;\n\tint rc;\n\n\trc = 0;\n\tif (!ss_initialized || !policydb.mls_enabled) {\n\t\t*new_sid = sid;\n\t\tgoto out;\n\t}\n\n\tcontext_init(&newcon);\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tcontext1 = sidtab_search(&sidtab, sid);\n\tif (!context1) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, sid);\n\t\tgoto out_unlock;\n\t}\n\n\trc = -EINVAL;\n\tcontext2 = sidtab_search(&sidtab, mls_sid);\n\tif (!context2) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t\t__func__, mls_sid);\n\t\tgoto out_unlock;\n\t}\n\n\tnewcon.user = context1->user;\n\tnewcon.role = context1->role;\n\tnewcon.type = context1->type;\n\trc = mls_context_cpy(&newcon, context2);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t/* Check the validity of the new context. */\n\tif (!policydb_context_isvalid(&policydb, &newcon)) {\n\t\trc = convert_context_handle_invalid_context(&newcon);\n\t\tif (rc) {\n\t\t\tif (!context_struct_to_string(&newcon, &s, &len)) {\n\t\t\t\taudit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t\t\t  \"security_sid_mls_copy: invalid context %s\", s);\n\t\t\t\tkfree(s);\n\t\t\t}\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\trc = sidtab_context_to_sid(&sidtab, &newcon, new_sid);\nout_unlock:\n\tread_unlock(&policy_rwlock);\n\tcontext_destroy(&newcon);\nout:\n\treturn rc;\n}\n\n/**\n * security_net_peersid_resolve - Compare and resolve two network peer SIDs\n * @nlbl_sid: NetLabel SID\n * @nlbl_type: NetLabel labeling protocol type\n * @xfrm_sid: XFRM SID\n *\n * Description:\n * Compare the @nlbl_sid and @xfrm_sid values and if the two SIDs can be\n * resolved into a single SID it is returned via @peer_sid and the function\n * returns zero.  Otherwise @peer_sid is set to SECSID_NULL and the function\n * returns a negative value.  A table summarizing the behavior is below:\n *\n *                                 | function return |      @sid\n *   ------------------------------+-----------------+-----------------\n *   no peer labels                |        0        |    SECSID_NULL\n *   single peer label             |        0        |    <peer_label>\n *   multiple, consistent labels   |        0        |    <peer_label>\n *   multiple, inconsistent labels |    -<errno>     |    SECSID_NULL\n *\n */\nint security_net_peersid_resolve(u32 nlbl_sid, u32 nlbl_type,\n\t\t\t\t u32 xfrm_sid,\n\t\t\t\t u32 *peer_sid)\n{\n\tint rc;\n\tstruct context *nlbl_ctx;\n\tstruct context *xfrm_ctx;\n\n\t*peer_sid = SECSID_NULL;\n\n\t/* handle the common (which also happens to be the set of easy) cases\n\t * right away, these two if statements catch everything involving a\n\t * single or absent peer SID/label */\n\tif (xfrm_sid == SECSID_NULL) {\n\t\t*peer_sid = nlbl_sid;\n\t\treturn 0;\n\t}\n\t/* NOTE: an nlbl_type == NETLBL_NLTYPE_UNLABELED is a \"fallback\" label\n\t * and is treated as if nlbl_sid == SECSID_NULL when a XFRM SID/label\n\t * is present */\n\tif (nlbl_sid == SECSID_NULL || nlbl_type == NETLBL_NLTYPE_UNLABELED) {\n\t\t*peer_sid = xfrm_sid;\n\t\treturn 0;\n\t}\n\n\t/* we don't need to check ss_initialized here since the only way both\n\t * nlbl_sid and xfrm_sid are not equal to SECSID_NULL would be if the\n\t * security server was initialized and ss_initialized was true */\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tnlbl_ctx = sidtab_search(&sidtab, nlbl_sid);\n\tif (!nlbl_ctx) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, nlbl_sid);\n\t\tgoto out;\n\t}\n\trc = -EINVAL;\n\txfrm_ctx = sidtab_search(&sidtab, xfrm_sid);\n\tif (!xfrm_ctx) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized SID %d\\n\",\n\t\t       __func__, xfrm_sid);\n\t\tgoto out;\n\t}\n\trc = (mls_context_cmp(nlbl_ctx, xfrm_ctx) ? 0 : -EACCES);\n\tif (rc)\n\t\tgoto out;\n\n\t/* at present NetLabel SIDs/labels really only carry MLS\n\t * information so if the MLS portion of the NetLabel SID\n\t * matches the MLS portion of the labeled XFRM SID/label\n\t * then pass along the XFRM SID as it is the most\n\t * expressive */\n\t*peer_sid = xfrm_sid;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nstatic int get_classes_callback(void *k, void *d, void *args)\n{\n\tstruct class_datum *datum = d;\n\tchar *name = k, **classes = args;\n\tint value = datum->value - 1;\n\n\tclasses[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!classes[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint security_get_classes(char ***classes, int *nclasses)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOMEM;\n\t*nclasses = policydb.p_classes.nprim;\n\t*classes = kcalloc(*nclasses, sizeof(**classes), GFP_ATOMIC);\n\tif (!*classes)\n\t\tgoto out;\n\n\trc = hashtab_map(policydb.p_classes.table, get_classes_callback,\n\t\t\t*classes);\n\tif (rc) {\n\t\tint i;\n\t\tfor (i = 0; i < *nclasses; i++)\n\t\t\tkfree((*classes)[i]);\n\t\tkfree(*classes);\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\nstatic int get_permissions_callback(void *k, void *d, void *args)\n{\n\tstruct perm_datum *datum = d;\n\tchar *name = k, **perms = args;\n\tint value = datum->value - 1;\n\n\tperms[value] = kstrdup(name, GFP_ATOMIC);\n\tif (!perms[value])\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint security_get_permissions(char *class, char ***perms, int *nperms)\n{\n\tint rc, i;\n\tstruct class_datum *match;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -EINVAL;\n\tmatch = hashtab_search(policydb.p_classes.table, class);\n\tif (!match) {\n\t\tprintk(KERN_ERR \"SELinux: %s:  unrecognized class %s\\n\",\n\t\t\t__func__, class);\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\t*nperms = match->permissions.nprim;\n\t*perms = kcalloc(*nperms, sizeof(**perms), GFP_ATOMIC);\n\tif (!*perms)\n\t\tgoto out;\n\n\tif (match->comdatum) {\n\t\trc = hashtab_map(match->comdatum->permissions.table,\n\t\t\t\tget_permissions_callback, *perms);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\trc = hashtab_map(match->permissions.table, get_permissions_callback,\n\t\t\t*perms);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n\nerr:\n\tread_unlock(&policy_rwlock);\n\tfor (i = 0; i < *nperms; i++)\n\t\tkfree((*perms)[i]);\n\tkfree(*perms);\n\treturn rc;\n}\n\nint security_get_reject_unknown(void)\n{\n\treturn policydb.reject_unknown;\n}\n\nint security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}\n\n/**\n * security_policycap_supported - Check for a specific policy capability\n * @req_cap: capability\n *\n * Description:\n * This function queries the currently loaded policy to see if it supports the\n * capability specified by @req_cap.  Returns true (1) if the capability is\n * supported, false (0) if it isn't supported.\n *\n */\nint security_policycap_supported(unsigned int req_cap)\n{\n\tint rc;\n\n\tread_lock(&policy_rwlock);\n\trc = ebitmap_get_bit(&policydb.policycaps, req_cap);\n\tread_unlock(&policy_rwlock);\n\n\treturn rc;\n}\n\nstruct selinux_audit_rule {\n\tu32 au_seqno;\n\tstruct context au_ctxt;\n};\n\nvoid selinux_audit_rule_free(void *vrule)\n{\n\tstruct selinux_audit_rule *rule = vrule;\n\n\tif (rule) {\n\t\tcontext_destroy(&rule->au_ctxt);\n\t\tkfree(rule);\n\t}\n}\n\nint selinux_audit_rule_init(u32 field, u32 op, char *rulestr, void **vrule)\n{\n\tstruct selinux_audit_rule *tmprule;\n\tstruct role_datum *roledatum;\n\tstruct type_datum *typedatum;\n\tstruct user_datum *userdatum;\n\tstruct selinux_audit_rule **rule = (struct selinux_audit_rule **)vrule;\n\tint rc = 0;\n\n\t*rule = NULL;\n\n\tif (!ss_initialized)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_USER:\n\tcase AUDIT_OBJ_ROLE:\n\tcase AUDIT_OBJ_TYPE:\n\t\t/* only 'equals' and 'not equals' fit user, role, and type */\n\t\tif (op != Audit_equal && op != Audit_not_equal)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t/* we do not allow a range, indicated by the presence of '-' */\n\t\tif (strchr(rulestr, '-'))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t/* only the above fields are valid */\n\t\treturn -EINVAL;\n\t}\n\n\ttmprule = kzalloc(sizeof(struct selinux_audit_rule), GFP_KERNEL);\n\tif (!tmprule)\n\t\treturn -ENOMEM;\n\n\tcontext_init(&tmprule->au_ctxt);\n\n\tread_lock(&policy_rwlock);\n\n\ttmprule->au_seqno = latest_granting;\n\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\trc = -EINVAL;\n\t\tuserdatum = hashtab_search(policydb.p_users.table, rulestr);\n\t\tif (!userdatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.user = userdatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\trc = -EINVAL;\n\t\troledatum = hashtab_search(policydb.p_roles.table, rulestr);\n\t\tif (!roledatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.role = roledatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\trc = -EINVAL;\n\t\ttypedatum = hashtab_search(policydb.p_types.table, rulestr);\n\t\tif (!typedatum)\n\t\t\tgoto out;\n\t\ttmprule->au_ctxt.type = typedatum->value;\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\trc = mls_from_string(rulestr, &tmprule->au_ctxt, GFP_ATOMIC);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\n\tif (rc) {\n\t\tselinux_audit_rule_free(tmprule);\n\t\ttmprule = NULL;\n\t}\n\n\t*rule = tmprule;\n\n\treturn rc;\n}\n\n/* Check to see if the rule contains any selinux fields */\nint selinux_audit_rule_known(struct audit_krule *rule)\n{\n\tint i;\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tswitch (f->type) {\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint selinux_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule,\n\t\t\t     struct audit_context *actx)\n{\n\tstruct context *ctxt;\n\tstruct mls_level *level;\n\tstruct selinux_audit_rule *rule = vrule;\n\tint match = 0;\n\n\tif (!rule) {\n\t\taudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"selinux_audit_rule_match: missing rule\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (rule->au_seqno < latest_granting) {\n\t\taudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"selinux_audit_rule_match: stale rule\\n\");\n\t\tmatch = -ESTALE;\n\t\tgoto out;\n\t}\n\n\tctxt = sidtab_search(&sidtab, sid);\n\tif (!ctxt) {\n\t\taudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"selinux_audit_rule_match: unrecognized SID %d\\n\",\n\t\t\t  sid);\n\t\tmatch = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t/* a field/op pair that is not caught here will simply fall through\n\t   without a match */\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->user == rule->au_ctxt.user);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->user != rule->au_ctxt.user);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->role == rule->au_ctxt.role);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->role != rule->au_ctxt.role);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->type == rule->au_ctxt.type);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->type != rule->au_ctxt.type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tlevel = ((field == AUDIT_SUBJ_SEN ||\n\t\t\t  field == AUDIT_OBJ_LEV_LOW) ?\n\t\t\t &ctxt->range.level[0] : &ctxt->range.level[1]);\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t     level);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_lt:\n\t\t\tmatch = (mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level) &&\n\t\t\t\t !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level));\n\t\t\tbreak;\n\t\tcase Audit_le:\n\t\t\tmatch = mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_gt:\n\t\t\tmatch = (mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]) &&\n\t\t\t\t !mls_level_eq(level,\n\t\t\t\t\t       &rule->au_ctxt.range.level[0]));\n\t\t\tbreak;\n\t\tcase Audit_ge:\n\t\t\tmatch = mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn match;\n}\n\nstatic int (*aurule_callback)(void) = audit_update_lsm_rules;\n\nstatic int aurule_avc_callback(u32 event)\n{\n\tint err = 0;\n\n\tif (event == AVC_CALLBACK_RESET && aurule_callback)\n\t\terr = aurule_callback();\n\treturn err;\n}\n\nstatic int __init aurule_init(void)\n{\n\tint err;\n\n\terr = avc_add_callback(aurule_avc_callback, AVC_CALLBACK_RESET);\n\tif (err)\n\t\tpanic(\"avc_add_callback() failed, error %d\\n\", err);\n\n\treturn err;\n}\n__initcall(aurule_init);\n\n#ifdef CONFIG_NETLABEL\n/**\n * security_netlbl_cache_add - Add an entry to the NetLabel cache\n * @secattr: the NetLabel packet security attributes\n * @sid: the SELinux SID\n *\n * Description:\n * Attempt to cache the context in @ctx, which was derived from the packet in\n * @skb, in the NetLabel subsystem cache.  This function assumes @secattr has\n * already been initialized.\n *\n */\nstatic void security_netlbl_cache_add(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t      u32 sid)\n{\n\tu32 *sid_cache;\n\n\tsid_cache = kmalloc(sizeof(*sid_cache), GFP_ATOMIC);\n\tif (sid_cache == NULL)\n\t\treturn;\n\tsecattr->cache = netlbl_secattr_cache_alloc(GFP_ATOMIC);\n\tif (secattr->cache == NULL) {\n\t\tkfree(sid_cache);\n\t\treturn;\n\t}\n\n\t*sid_cache = sid;\n\tsecattr->cache->free = kfree;\n\tsecattr->cache->data = sid_cache;\n\tsecattr->flags |= NETLBL_SECATTR_CACHE;\n}\n\n/**\n * security_netlbl_secattr_to_sid - Convert a NetLabel secattr to a SELinux SID\n * @secattr: the NetLabel packet security attributes\n * @sid: the SELinux SID\n *\n * Description:\n * Convert the given NetLabel security attributes in @secattr into a\n * SELinux SID.  If the @secattr field does not contain a full SELinux\n * SID/context then use SECINITSID_NETMSG as the foundation.  If possible the\n * 'cache' field of @secattr is set and the CACHE flag is set; this is to\n * allow the @secattr to be used by NetLabel to cache the secattr to SID\n * conversion for future lookups.  Returns zero on success, negative values on\n * failure.\n *\n */\nint security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\tstruct context *ctx;\n\tstruct context ctx_new;\n\n\tif (!ss_initialized) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (secattr->flags & NETLBL_SECATTR_CACHE)\n\t\t*sid = *(u32 *)secattr->cache->data;\n\telse if (secattr->flags & NETLBL_SECATTR_SECID)\n\t\t*sid = secattr->attr.secid;\n\telse if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {\n\t\trc = -EIDRM;\n\t\tctx = sidtab_search(&sidtab, SECINITSID_NETMSG);\n\t\tif (ctx == NULL)\n\t\t\tgoto out;\n\n\t\tcontext_init(&ctx_new);\n\t\tctx_new.user = ctx->user;\n\t\tctx_new.role = ctx->role;\n\t\tctx_new.type = ctx->type;\n\t\tmls_import_netlbl_lvl(&ctx_new, secattr);\n\t\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\t\trc = ebitmap_netlbl_import(&ctx_new.range.level[0].cat,\n\t\t\t\t\t\t   secattr->attr.mls.cat);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tmemcpy(&ctx_new.range.level[1].cat,\n\t\t\t       &ctx_new.range.level[0].cat,\n\t\t\t       sizeof(ctx_new.range.level[0].cat));\n\t\t}\n\t\trc = -EIDRM;\n\t\tif (!mls_context_isvalid(&policydb, &ctx_new))\n\t\t\tgoto out_free;\n\n\t\trc = sidtab_context_to_sid(&sidtab, &ctx_new, sid);\n\t\tif (rc)\n\t\t\tgoto out_free;\n\n\t\tsecurity_netlbl_cache_add(secattr, *sid);\n\n\t\tebitmap_destroy(&ctx_new.range.level[0].cat);\n\t} else\n\t\t*sid = SECSID_NULL;\n\n\tread_unlock(&policy_rwlock);\n\treturn 0;\nout_free:\n\tebitmap_destroy(&ctx_new.range.level[0].cat);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n\n/**\n * security_netlbl_sid_to_secattr - Convert a SELinux SID to a NetLabel secattr\n * @sid: the SELinux SID\n * @secattr: the NetLabel packet security attributes\n *\n * Description:\n * Convert the given SELinux SID in @sid into a NetLabel security attribute.\n * Returns zero on success, negative values on failure.\n *\n */\nint security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n#endif /* CONFIG_NETLABEL */\n\n/**\n * security_read_policy - read the policy.\n * @data: binary policy data\n * @len: length of data in bytes\n *\n */\nint security_read_policy(void **data, size_t *len)\n{\n\tint rc;\n\tstruct policy_file fp;\n\n\tif (!ss_initialized)\n\t\treturn -EINVAL;\n\n\t*len = security_policydb_len();\n\n\t*data = vmalloc_user(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\tfp.data = *data;\n\tfp.len = *len;\n\n\tread_lock(&policy_rwlock);\n\trc = policydb_write(&policydb, &fp);\n\tread_unlock(&policy_rwlock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t*len = (unsigned long)fp.data - (unsigned long)*data;\n\treturn 0;\n\n}\n"], "filenames": ["security/selinux/ss/services.c"], "buggy_code_start_loc": [1234], "buggy_code_end_loc": [1234], "fixing_code_start_loc": [1235], "fixing_code_end_loc": [1239], "type": "CWE-20", "message": "The security_context_to_sid_core function in security/selinux/ss/services.c in the Linux kernel before 3.13.4 allows local users to cause a denial of service (system crash) by leveraging the CAP_MAC_ADMIN capability to set a zero-length security context.", "other": {"cve": {"id": "CVE-2014-1874", "sourceIdentifier": "secalert@redhat.com", "published": "2014-02-28T06:18:54.587", "lastModified": "2023-02-13T00:38:31.907", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The security_context_to_sid_core function in security/selinux/ss/services.c in the Linux kernel before 3.13.4 allows local users to cause a denial of service (system crash) by leveraging the CAP_MAC_ADMIN capability to set a zero-length security context."}, {"lang": "es", "value": "La funci\u00f3n security_context_to_sid_core en security/selinux/ss/services.c en el kernel de Linux anterior a 3.13.4 permite a usuarios locales causar una denegaci\u00f3n de servicio (ca\u00edda del sistema) mediante el aprovechamiento de la funcionalidad CAP_MAC_ADMIN para configurar un contexto de seguridad de longitud cero."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.13.4", "matchCriteriaId": "C5D0B9E7-C5EF-4C15-BD87-FA13FD781E06"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:10:sp4:*:*:ltss:*:*:*", "matchCriteriaId": "35BBD83D-BDC7-4678-BE94-639F59281139"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.10:*:*:*:*:*:*:*", "matchCriteriaId": "E2076871-2E80-4605-A470-A41C1A8EC7EE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:13.10:*:*:*:*:*:*:*", "matchCriteriaId": "7F61F047-129C-41A6-8A27-FFCBB8563E91"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=2172fa709ab32ca60e86179dc67d0857be8e2c98", "source": "secalert@redhat.com"}, {"url": "http://linux.oracle.com/errata/ELSA-2014-0771.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://linux.oracle.com/errata/ELSA-2014-3043.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.13.4", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/02/07/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/65459", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2128-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2129-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2133-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2134-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2135-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2136-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2137-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2138-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2139-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2140-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2141-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1062356", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2172fa709ab32ca60e86179dc67d0857be8e2c98", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2172fa709ab32ca60e86179dc67d0857be8e2c98"}}