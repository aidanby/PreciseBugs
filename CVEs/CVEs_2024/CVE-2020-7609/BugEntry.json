{"buggy_code": ["(function() {\n    'use strict';\n    exports.version = '3.0.0';\n\n    var isEqual = require('lodash.isequal');\n    var filterd = require('lodash.filter');\n    var clonedeep = require('lodash.clonedeep');\n    var matches = require('lodash.matches');\n\n    function RuleEngine(rules, options) {\n        this.init();\n        if (typeof(rules) != \"undefined\") {\n            this.register(rules);\n        }\n        if (options) {\n            this.ignoreFactChanges = options.ignoreFactChanges;\n        }\n        return this;\n    }\n    RuleEngine.prototype.init = function(rules) {\n        this.rules = [];\n        this.activeRules = [];\n    };\n    RuleEngine.prototype.register = function(rules) {\n        if (Array.isArray(rules)) {\n            this.rules = this.rules.concat(rules);\n        } else if (rules !== null && typeof(rules) == \"object\") {\n            this.rules.push(rules);\n        }\n        this.sync();\n    };\n    RuleEngine.prototype.sync = function() {\n        this.activeRules = this.rules.filter(function(a) {\n            if (typeof(a.on) === \"undefined\") {\n                a.on = true;\n            }\n            if (a.on === true) {\n                return a;\n            }\n        });\n        this.activeRules.sort(function(a, b) {\n            if (a.priority && b.priority) {\n                return b.priority - a.priority;\n            } else {\n                return 0;\n            }\n        });\n    };\n    RuleEngine.prototype.execute = function(fact, callback) {\n        //these new attributes have to be in both last session and current session to support\n        // the compare function\n        var complete = false;\n        fact.result = true;\n        var session = clonedeep(fact);\n        var lastSession = clonedeep(fact);\n        var _rules = this.activeRules;\n        var matchPath = [];\n        var ignoreFactChanges = this.ignoreFactChanges;\n        (function FnRuleLoop(x) {\n            var API = {\n                \"rule\": function() { return _rules[x]; },\n                \"when\": function(outcome) {\n                    if (outcome) {\n                        var _consequence = _rules[x].consequence;\n                        _consequence.ruleRef = _rules[x].id || _rules[x].name || 'index_'+x;\n                        process.nextTick(function() {\n                            matchPath.push(_consequence.ruleRef);\n                            _consequence.call(session, API, session);\n                        });\n                    } else {\n                        process.nextTick(function() {\n                            API.next();\n                        });\n                    }\n                },\n                \"restart\": function() {\n                    return FnRuleLoop(0);\n                },\n                \"stop\": function() {\n                    complete = true;\n                    return FnRuleLoop(0);\n                },\n                \"next\": function() {\n                    if (!ignoreFactChanges && !isEqual(lastSession, session)) {\n                        lastSession = clonedeep(session);\n                        process.nextTick(function() {\n                            API.restart();\n                        });\n                    } else {\n                        process.nextTick(function() {\n                            return FnRuleLoop(x + 1);\n                        });\n                    }\n                }\n            };\n            if (x < _rules.length && complete === false) {\n                var _rule = _rules[x].condition;\n                _rule.call(session, API, session);\n            } else {\n                process.nextTick(function() {\n                    session.matchPath = matchPath;\n                    return callback(session);\n                });\n            }\n        })(0);\n    };\n    RuleEngine.prototype.findRules = function(filter) {\n        if (typeof(filter) === \"undefined\") {\n            return this.rules;\n        } else {\n            var find = matches(filter);\n            return filterd(this.rules, find);\n        }\n    }\n    RuleEngine.prototype.turn = function(state, filter) {\n        var state = (state === \"on\" || state === \"ON\") ? true : false;\n        var rules = this.findRules(filter);\n        for (var i = 0, j = rules.length; i < j; i++) {\n            rules[i].on = state;\n        }\n        this.sync();\n    }\n    RuleEngine.prototype.prioritize = function(priority, filter) {\n        priority = parseInt(priority, 10);\n        var rules = this.findRules(filter);\n        for (var i = 0, j = rules.length; i < j; i++) {\n            rules[i].priority = priority;\n        }\n        this.sync();\n    }\n    RuleEngine.prototype.toJSON = function() {\n        var rules = this.rules;\n        if (rules instanceof Array) {\n            rules = rules.map(function(rule) {\n                rule.condition = rule.condition.toString();\n                rule.consequence = rule.consequence.toString();\n                return rule;\n            });\n        } else if (typeof(rules) != \"undefined\") {\n            rules.condition = rules.condition.toString();\n            rules.consequence = rules.consequence.toString();\n        }\n        return rules;\n    };\n    RuleEngine.prototype.fromJSON = function(rules) {\n        this.init();\n        if (typeof(rules) == \"string\") {\n            rules = JSON.parse(rules);\n        }\n        if (rules instanceof Array) {\n            rules = rules.map(function(rule) {\n                rule.condition = eval(\"(\" + rule.condition + \")\");\n                rule.consequence = eval(\"(\" + rule.consequence + \")\");\n                return rule;\n            });\n        } else if (rules !== null && typeof(rules) == \"object\") {\n            rules.condition = eval(\"(\" + rules.condition + \")\");\n            rules.consequence = eval(\"(\" + rules.consequence + \")\");\n        }\n        this.register(rules);\n    };\n    module.exports = RuleEngine;\n}(module.exports));\n"], "fixing_code": ["(function() {\n    'use strict';\n    exports.version = '3.0.0';\n\n    var isEqual = require('lodash.isequal');\n    var filterd = require('lodash.filter');\n    var clonedeep = require('lodash.clonedeep');\n    var matches = require('lodash.matches');\n\n    function RuleEngine(rules, options) {\n        this.init();\n        if (typeof(rules) != \"undefined\") {\n            this.register(rules);\n        }\n        if (options) {\n            this.ignoreFactChanges = options.ignoreFactChanges;\n        }\n        return this;\n    }\n    RuleEngine.prototype.init = function(rules) {\n        this.rules = [];\n        this.activeRules = [];\n    };\n    RuleEngine.prototype.register = function(rules) {\n        if (Array.isArray(rules)) {\n            this.rules = this.rules.concat(rules);\n        } else if (rules !== null && typeof(rules) == \"object\") {\n            this.rules.push(rules);\n        }\n        this.sync();\n    };\n    RuleEngine.prototype.sync = function() {\n        this.activeRules = this.rules.filter(function(a) {\n            if (typeof(a.on) === \"undefined\") {\n                a.on = true;\n            }\n            if (a.on === true) {\n                return a;\n            }\n        });\n        this.activeRules.sort(function(a, b) {\n            if (a.priority && b.priority) {\n                return b.priority - a.priority;\n            } else {\n                return 0;\n            }\n        });\n    };\n    RuleEngine.prototype.execute = function(fact, callback) {\n        //these new attributes have to be in both last session and current session to support\n        // the compare function\n        var complete = false;\n        fact.result = true;\n        var session = clonedeep(fact);\n        var lastSession = clonedeep(fact);\n        var _rules = this.activeRules;\n        var matchPath = [];\n        var ignoreFactChanges = this.ignoreFactChanges;\n        (function FnRuleLoop(x) {\n            var API = {\n                \"rule\": function() { return _rules[x]; },\n                \"when\": function(outcome) {\n                    if (outcome) {\n                        var _consequence = _rules[x].consequence;\n                        _consequence.ruleRef = _rules[x].id || _rules[x].name || 'index_'+x;\n                        process.nextTick(function() {\n                            matchPath.push(_consequence.ruleRef);\n                            _consequence.call(session, API, session);\n                        });\n                    } else {\n                        process.nextTick(function() {\n                            API.next();\n                        });\n                    }\n                },\n                \"restart\": function() {\n                    return FnRuleLoop(0);\n                },\n                \"stop\": function() {\n                    complete = true;\n                    return FnRuleLoop(0);\n                },\n                \"next\": function() {\n                    if (!ignoreFactChanges && !isEqual(lastSession, session)) {\n                        lastSession = clonedeep(session);\n                        process.nextTick(function() {\n                            API.restart();\n                        });\n                    } else {\n                        process.nextTick(function() {\n                            return FnRuleLoop(x + 1);\n                        });\n                    }\n                }\n            };\n            if (x < _rules.length && complete === false) {\n                var _rule = _rules[x].condition;\n                _rule.call(session, API, session);\n            } else {\n                process.nextTick(function() {\n                    session.matchPath = matchPath;\n                    return callback(session);\n                });\n            }\n        })(0);\n    };\n    RuleEngine.prototype.findRules = function(filter) {\n        if (typeof(filter) === \"undefined\") {\n            return this.rules;\n        } else {\n            var find = matches(filter);\n            return filterd(this.rules, find);\n        }\n    }\n    RuleEngine.prototype.turn = function(state, filter) {\n        var state = (state === \"on\" || state === \"ON\") ? true : false;\n        var rules = this.findRules(filter);\n        for (var i = 0, j = rules.length; i < j; i++) {\n            rules[i].on = state;\n        }\n        this.sync();\n    }\n    RuleEngine.prototype.prioritize = function(priority, filter) {\n        priority = parseInt(priority, 10);\n        var rules = this.findRules(filter);\n        for (var i = 0, j = rules.length; i < j; i++) {\n            rules[i].priority = priority;\n        }\n        this.sync();\n    }\n    module.exports = RuleEngine;\n}(module.exports));\n"], "filenames": ["lib/node-rules.js"], "buggy_code_start_loc": [131], "buggy_code_end_loc": [162], "fixing_code_start_loc": [130], "fixing_code_end_loc": [130], "type": "CWE-94", "message": "node-rules including 3.0.0 and prior to 5.0.0 allows injection of arbitrary commands. The argument rules of function \"fromJSON()\" can be controlled by users without any sanitization.", "other": {"cve": {"id": "CVE-2020-7609", "sourceIdentifier": "report@snyk.io", "published": "2020-04-27T22:15:12.317", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "node-rules including 3.0.0 and prior to 5.0.0 allows injection of arbitrary commands. The argument rules of function \"fromJSON()\" can be controlled by users without any sanitization."}, {"lang": "es", "value": "node-rules incluyendo versiones 3.0.0 y anteriores a 5.0.0, permite una inyecci\u00f3n de comandos arbitrarios. Las reglas de argumento de la funci\u00f3n \"fromJSON()\" pueden ser controladas por usuarios sin ning\u00fan saneamiento."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:node-rules_project:node-rules:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "5.0.0", "matchCriteriaId": "78601348-9CAF-4DD1-ADFD-7DC02DA207FD"}]}]}], "references": [{"url": "https://github.com/mithunsatheesh/node-rules/commit/100862223904bb6478fcc33b701c7dee11f7b832", "source": "nvd@nist.gov", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-NODERULES-560426", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mithunsatheesh/node-rules/commit/100862223904bb6478fcc33b701c7dee11f7b832"}}