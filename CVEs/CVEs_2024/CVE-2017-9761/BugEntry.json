{"buggy_code": ["/* radare - LGPL - Copyright 2009-2017 - nibble, pancake */\n#if 0\n* Use RList\n* Support callback for null command (why?)\n* Show help of commands\n  - long commands not yet tested at all\n  - added interface to export command list into an autocompletable\n    argc, argv for dietline\n* r_cmd must provide a nesting char table indexing for commands\n  - this is already partially done\n  - this is pretty similar to r_db\n  - every module can register their own commands\n  - commands can be listed like in a tree\n#endif\n\n#define INTERACTIVE_MAX_REP 1024\n\n#include <r_core.h>\n#include <r_anal.h>\n#include <r_cons.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <stdarg.h>\n#if __UNIX__\n#include <sys/utsname.h>\n#endif\n\nstatic void cmd_debug_reg(RCore *core, const char *str);\n#include \"cmd_quit.c\"\n#include \"cmd_hash.c\"\n#include \"cmd_debug.c\"\n#include \"cmd_log.c\"\n#include \"cmd_zign.c\"\n#include \"cmd_section.c\"\n#include \"cmd_flag.c\"\n#include \"cmd_project.c\"\n#include \"cmd_write.c\"\n#include \"cmd_cmp.c\"\n#include \"cmd_eval.c\"\n#include \"cmd_anal.c\"\n#include \"cmd_open.c\"\n#include \"cmd_meta.c\"\n#include \"cmd_type.c\"\n#include \"cmd_egg.c\"\n#include \"cmd_info.c\"\n#include \"cmd_macro.c\"\n#include \"cmd_magic.c\"\n#include \"cmd_mount.c\"\n#include \"cmd_seek.c\"\n#include \"cmd_print.c\"\n#include \"cmd_help.c\"\n#include \"cmd_search.c\"\n\nstatic void recursive_help(RCore *core, const char *cmd) {\n\tchar *nl, *line;\n\tif (strchr (cmd, '[')) {\n\t\t// eprintf (\"Skip ((%s))\\n\", cmd);\n\t\treturn;\n\t}\n\tchar *msg = r_core_cmd_str (core, cmd);\n\tif (!msg) {\n\t\treturn;\n\t}\n\tline = msg;\n\tr_cons_print (msg);\n\t(void) r_str_ansi_filter (msg, NULL, NULL, strlen (msg));\n\tdo {\n\t\tnl = strchr (line, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *help_token = strstr (line, \"[?]\");\n\t\tif (help_token) {\n\t\t\thelp_token[0] = '?';\n\t\t\thelp_token[1] = 0;\n\t\t\tconst char *sp = strchr (line, ' ');\n\t\t\tif (sp) {\n\t\t\t\trecursive_help (core, sp + 1);\n\t\t\t}\n\t\t}\n\t\tline = nl + 1;\n\t} while (nl);\n\tfree (msg);\n}\n\nstatic int r_core_cmd_nullcallback(void *data) {\n\tRCore *core = (RCore*) data;\n\tif (core->cons->breaked) {\n\t\tcore->cons->breaked = false;\n\t\treturn 0;\n\t}\n\tif (!core->cmdrepeat) {\n\t\treturn 0;\n\t}\n\tr_core_cmd_repeat (core, true);\n\treturn 1;\n}\n\n// TODO: move somewhere else\nR_API RAsmOp *r_core_disassemble (RCore *core, ut64 addr) {\n\tint delta;\n\tut8 buf[128];\n\tstatic RBuffer *b = NULL; // XXX: never freed and non-thread safe. move to RCore\n\tRAsmOp *op;\n\tif (!b) {\n\t\tb = r_buf_new ();\n\t\tif (!b || !r_core_read_at (core, addr, buf, sizeof (buf))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tb->base = addr;\n\t\tr_buf_set_bytes (b, buf, sizeof (buf));\n\t} else {\n\t\tif ((addr < b->base) || addr > (b->base + b->length - 32)) {\n\t\t\tif (!r_core_read_at (core, addr, buf, sizeof (buf))) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tb->base = addr;\n\t\t\tr_buf_set_bytes (b, buf, sizeof (buf));\n\t\t}\n\t}\n\tdelta = addr - b->base;\n\top = R_NEW0 (RAsmOp);\n\tr_asm_set_pc (core->assembler, addr);\n\tif (r_asm_disassemble (core->assembler, op, b->buf + delta, b->length) < 1) {\n\t\tfree (op);\n\t\treturn NULL;\n\t}\n\treturn op;\n}\n\nstatic int cmd_uname(void *data, const char *input) {\n\tconst char* help_msg[] = {\n\t\t\"Usage:\", \"u\", \"uname or undo write/seek\",\n\t\t\"u\", \"\", \"show system uname\",\n\t\t\"uw\", \"\", \"alias for wc (requires: e io.cache=true)\",\n\t\t\"us\", \"\", \"alias for s- (seek history)\",\n\t\tNULL};\n\tswitch (input[0]) {\n\tcase '?':\n\t\tr_core_cmd_help (data, help_msg);\n\t\treturn 1;\n\tcase 's':\n\t\tr_core_cmdf (data, \"s-%s\", input + 1);\n\t\treturn 1;\n\tcase 'w':\n\t\tr_core_cmdf (data, \"wc%s\", input + 1);\n\t\treturn 1;\n\t}\n#if __UNIX__\n\tstruct utsname un;\n\tuname (&un);\n\tr_cons_printf (\"%s %s %s %s\\n\", un.sysname,\n\t\tun.nodename, un.release, un.machine);\n#elif __WINDOWS__\n\tr_cons_printf (\"windows\\n\");\n#else\n\tr_cons_printf (\"unknown\\n\");\n#endif\n\treturn 0;\n}\n\nstatic int cmd_alias(void *data, const char *input) {\n\tint i;\n\tchar *def, *q, *desc, *buf;\n\tRCore *core = (RCore *)data;\n\tif (*input == '?') {\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"$alias[=cmd] [args...]\", \"Alias commands\",\n\t\t\t\"$\", \"\", \"list all defined aliases\",\n\t\t\t\"$*\", \"\", \"same as above, but using r2 commands\",\n\t\t\t\"$\", \"dis='af;pdf'\", \"create command - analyze to show function\",\n\t\t\t\"$\", \"test=#!pipe node /tmp/test.js\", \"create command - rlangpipe script\",\n\t\t\t\"$\", \"dis=\", \"undefine alias\",\n\t\t\t\"$\", \"dis\", \"execute the previously defined alias\",\n\t\t\t\"$\", \"dis?\", \"show commands aliased by 'analyze'\",\n\t\t\tNULL};\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\treturn 0;\n\t}\n\ti = strlen (input);\n\tbuf = malloc (i + 2);\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\t*buf = '$'; // prefix aliases with a dash\n\tmemcpy (buf + 1, input, i + 1);\n\tq = strchr (buf, ' ');\n\tdef = strchr (buf, '=');\n\tdesc = strchr (buf, '?');\n\n\t/* create alias */\n\tif ((def && q && (def < q)) || (def && !q)) {\n\t\t*def++ = 0;\n\t\tsize_t len = strlen (def);\n\t\t/* Remove quotes */\n\t\tif ((def[0] == '\\'') && (def[len - 1] == '\\'')) {\n\t\t\tdef[len - 1] = 0x00;\n\t\t\tdef++;\n\t\t}\n\t\tif (!q || (q && q>def)) {\n\t\t\tif (*def) r_cmd_alias_set (core->rcmd, buf, def, 0);\n\t\t\telse r_cmd_alias_del (core->rcmd, buf);\n\t\t}\n\t/* Show command for alias */\n\t} else if (desc && !q) {\n\t\tchar *v;\n\t\t*desc = 0;\n\t\tv = r_cmd_alias_get (core->rcmd, buf, 0);\n\t\tif (v) {\n\t\t\tr_cons_println (v);\n\t\t\tfree (buf);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n\t\t}\n\n\t/* Show aliases */\n\t} else if (buf[1] == '*') {\n\t\tint i, count = 0;\n\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tconst char *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n\t\t\tr_cons_printf (\"%s=%s\\n\", keys[i], v);\n\t\t}\n\t} else if (!buf[1]) {\n\t\tint i, count = 0;\n\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tr_cons_println (keys[i]);\n\t\t}\n\t/* Execute alias */\n\t} else {\n\t\tchar *v;\n\t\tif (q) *q = 0;\n\t\tv = r_cmd_alias_get (core->rcmd, buf, 0);\n\t\tif (v) {\n\t\t\tif (q) {\n\t\t\t\tchar *out, *args = q + 1;\n\t\t\t\tout = malloc (strlen (v) + strlen (args) + 2);\n\t\t\t\tif (out) { //XXX slow\n\t\t\t\t\tstrcpy (out, v);\n\t\t\t\t\tstrcat (out, \" \");\n\t\t\t\t\tstrcat (out, args);\n\t\t\t\t\tr_core_cmd0 (core, out);\n\t\t\t\t\tfree (out);\n\t\t\t\t} else eprintf (\"cannot malloc\\n\");\n\t\t\t} else {\n\t\t\t\tr_core_cmd0 (core, v);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n\t\t}\n\t}\n\tfree (buf);\n\treturn 0;\n}\n\nstatic int getArg(char ch, int def) {\n\tswitch (ch) {\n\tcase '&':\n\tcase '-':\n\t\treturn ch;\n\t}\n\treturn def;\n}\n\nstatic void aliascmd(RCore *core, const char *str) {\n\tswitch (str[0]) {\n\tcase '-':\n\t\tif (str[1]) {\n\t\t\tr_cmd_alias_del (core->rcmd, str + 2);\n\t\t} else {\n\t\t\tr_cmd_alias_del (core->rcmd, NULL);\n\t\t//\tr_cmd_alias_reset (core->rcmd);\n\t\t}\n\t\tbreak;\n\tcase '?':\n\t\teprintf (\"Usage: =$[-][remotecmd]  # remote command alias\\n\");\n\t\teprintf (\" =$dr   # makes 'dr' alias for =!dr\\n\");\n\t\teprintf (\" =$-dr  # unset 'dr' alias\\n\");\n\t\tbreak;\n\tcase 0:\n\t\tr_core_cmd0 (core, \"$\");\n\t\tbreak;\n\tdefault:\n\t\tr_cmd_alias_set (core->rcmd, str, \"\", 1);\n\t\tbreak;\n\t}\n}\n\nstatic int cmd_rap(void *data, const char *input) {\n\tRCore *core = (RCore *)data;\n\tswitch (*input) {\n\tcase '$': aliascmd (core, input + 1); break;\n\tcase '\\0': r_core_rtr_list (core); break;\n\tcase 'h':\n\t\tr_core_rtr_http (core, getArg (input[1], 'h'), input + 1);\n\t\tbreak;\n\tcase 'H':\n\t\twhile (input[1] == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tr_core_rtr_http (core, getArg (input[1], 'H'), input + 1);\n\t\tbreak;\n\tcase 'g':\n\t\tr_core_rtr_gdb (core, getArg (input[1], 'g'), input + 1);\n\t\tbreak;\n\tcase '?': r_core_rtr_help (core); break;\n\tcase '+': r_core_rtr_add (core, input + 1); break;\n\tcase '-': r_core_rtr_remove (core, input + 1); break;\n\tcase '=': r_core_rtr_session (core, input + 1); break;\n\t//case ':': r_core_rtr_cmds (core, input + 1); break;\n\tcase '<': r_core_rtr_pushout (core, input + 1); break;\n\tcase '!':\n\t\tif (input[1] == '=') {\n\t\t\t// swap core->cmdremote = core->cmdremote? 0: 1;\n\t\t\tcore->cmdremote = input[2]? 1: 0;\n\t\t\tr_cons_println (r_str_bool (core->cmdremote));\n\t\t} else {\n\t\t\tr_io_system (core->io, input + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_rtr_cmd (core, input);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_rap_run(void *data, const char *input) {\n\tRCore *core = (RCore *)data;\n\treturn r_io_system (core->io, input);\n}\n\nstatic int cmd_yank(void *data, const char *input) {\n\tut64 n;\n\tRCore *core = (RCore *)data;\n\tswitch (input[0]) {\n\tcase ' ':\n\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 'l':\n\t\tcore->num->value = core->yank_buf->length;\n\t\tbreak;\n\tcase 'y':\n\t\twhile (input[1] == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n\t\tr_core_yank_paste (core, n, 0);\n\t\tbreak;\n\tcase 'x':\n\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 'z':\n\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 'w':\n\t\tswitch (input[1]) {\n\t\tcase ' ':\n\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (input[2] == ' ') {\n\t\t\t\tchar *out = strdup (input + 3);\n\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n\t\t\t\tif (len> 0) {\n\t\t\t\t\tr_core_yank_set (core, 0LL, (const ut8*)out, len);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Invalid length\\n\");\n\t\t\t\t}\n\t\t\t\tfree (out);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: ywx [hexpairs]\\n\");\n\t\t\t}\n\t\t\t// r_core_yank_write_hex (core, input + 2);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p':\n\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 's':\n\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 't': // \"wt\"\n\t\tif (input[1] == 'f') { // \"wtf\"\n\t\t\tconst char *file = r_str_chop_ro (input + 2);\n\t\t\tif (!r_file_dump (file, core->yank_buf->buf, core->yank_buf->length, false)) {\n\t\t\t\teprintf (\"Cannot dump to '%s'\\n\", file);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_yank_to (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase 'f':\n\t\tswitch (input[1]) {\n\t\tcase ' ': // \"wf\"\n\t\t\tr_core_yank_file_ex (core, input + 1);\n\t\t\tbreak;\n\t\tcase 'a': // \"wfa\"\n\t\t\tr_core_yank_file_all (core, input + 2);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_core_yank_dump (core, r_num_math (core->num, \"\"));\n\t\tbreak;\n\tdefault:{\n\t\tconst char* help_msg[] = {\n\t\t\"Usage:\", \"y[ptxy] [len] [[@]addr]\", \" # See wd? for memcpy, same as 'yf'.\",\n\t\t\"y\", \"\", \"show yank buffer information (srcoff len bytes)\",\n\t\t\"y\", \" 16\", \"copy 16 bytes into clipboard\",\n\t\t\"y\", \" 16 0x200\", \"copy 16 bytes into clipboard from 0x200\",\n\t\t\"y\", \" 16 @ 0x200\", \"copy 16 bytes into clipboard from 0x200\",\n\t\t\"yz\", \"\", \"copy up to blocksize zero terminated string bytes into clipboard\",\n\t\t\"yz\", \" 16\", \"copy up to 16 zero terminated string bytes into clipboard\",\n\t\t\"yz\", \" @ 0x200\", \"copy up to blocksize zero terminated string bytes into clipboard from 0x200\",\n\t\t\"yz\", \" 16 @ 0x200\", \"copy up to 16 zero terminated string bytes into clipboard from 0x200\",\n\t\t\"yp\", \"\", \"print contents of clipboard\",\n\t\t\"yx\", \"\", \"print contents of clipboard in hexadecimal\",\n\t\t\"ys\", \"\", \"print contents of clipboard as string\",\n\t\t\"yt\", \" 64 0x200\", \"copy 64 bytes from current seek to 0x200\",\n\t\t\"ytf\", \" file\", \"dump the clipboard to given file\",\n\t\t\"yf\", \" 64 0x200\", \"file copy 64 bytes from 0x200 from file (opens w/ io), use -1 for all bytes\",\n\t\t\"yfa\", \" file copy\", \"copy all bytes from file (opens w/ io)\",\n\t\t\"yy\", \" 0x3344\", \"paste clipboard\",\n\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API int r_core_run_script (RCore *core, const char *file) {\n\tint ret = false;\n\tRListIter *iter;\n\tRLangPlugin *p;\n\tchar *name;\n\n\tr_list_foreach (core->scriptstack, iter, name) {\n\t\tif (!strcmp (file, name)) {\n\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_list_push (core->scriptstack, strdup (file));\n\n\tif (!strcmp (file, \"-\")) {\n\t\tchar *out = r_core_editor (core, NULL, NULL);\n\t\tif (out) {\n\t\t\tret = r_core_cmd_lines (core, out);\n\t\t\tfree (out);\n\t\t}\n\t} else if (r_parse_is_c_file (file)) {\n\t\tchar *out = r_parse_c_file (core->anal, file);\n\t\tif (out) {\n\t\t\tr_cons_strcat (out);\n\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n\t\t\tfree (out);\n\t\t}\n\t\tret = out? true: false;\n\t} else {\n\t\tp = r_lang_get_by_extension (core->lang, file);\n\t\tif (p) {\n\t\t\tr_lang_use (core->lang, p->name);\n\t\t\tret = r_lang_run_file (core->lang, file);\n\t\t} else {\n#if __WINDOWS__\n#define cmdstr(x) r_str_newf (x\" %s\", file);\n#else\n#define cmdstr(x) r_str_newf (x\" '%s'\", file);\n#endif\n\t\t\tconst char *p = r_str_lchr (file, '.');\n\t\t\tif (p) {\n\t\t\t\tconst char *ext = p + 1;\n\t\t\t\t/* TODO: handle this inside r_lang_pipe with new APIs */\n\t\t\t\tif (!strcmp (ext, \"js\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n#if __WINDOWS__\n\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n#else\n\t\t\t\t\tchar *cmd = cmdstr (\"wine\");\n#endif\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"ruby %s\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ret) {\n\t\t\t\tret = r_core_cmd_file (core, file);\n\t\t\t}\n\t\t}\n\t}\n\tfree (r_list_pop (core->scriptstack));\n\treturn ret;\n}\n\nstatic int cmd_ls(void *data, const char *input) {\n\tif (*input) {\n\t\tchar *res = r_syscmd_ls (input + 1);\n\t\tif (res) {\n\t\t\tr_cons_print (res);\n\t\t\tfree (res);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cmd_stdin(void *data, const char *input) {\n\tRCore *core = (RCore *)data;\n\tif (input[0] == '?') {\n\t\tr_cons_printf (\"Usage: '-' '.-' '. -' do the same\\n\");\n\t\treturn false;\n\t}\n\treturn r_core_run_script (core, \"-\");\n}\n\nstatic int cmd_interpret(void *data, const char *input) {\n\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n\tconst char *host, *port, *cmd;\n\tRCore *core = (RCore *)data;\n\n\tswitch (*input) {\n\tcase '\\0':\n\t\tr_core_cmd_repeat (core, 0);\n\t\tbreak;\n\tcase ':':\n\t\tif ((ptr = strchr (input + 1, ' '))) {\n\t\t\t/* .:port cmd */\n\t\t\t/* .:host:port cmd */\n\t\t\tcmd = ptr + 1;\n\t\t\t*ptr = 0;\n\t\t\teol = strchr (input + 1, ':');\n\t\t\tif (eol) {\n\t\t\t\t*eol = 0;\n\t\t\t\thost = input + 1;\n\t\t\t\tport = eol + 1;\n\t\t\t} else {\n\t\t\t\thost = \"localhost\";\n\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n\t\t\t}\n\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n\t\t\tif (rbuf) {\n\t\t\t\tr_cons_print (rbuf);\n\t\t\t\tfree (rbuf);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_rtr_cmds (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase '.': // same as \\n\n\t\tr_core_cmd_repeat (core, 1);\n\t\tbreak;\n\tcase '-':\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: '-' '.-' '. -' do the same\\n\");\n\t\t} else {\n\t\t\tr_core_run_script (core, \"-\");\n\t\t}\n\t\tbreak;\n\tcase ' ':\n\t\tif (!r_core_run_script (core, input + 1)) {\n\t\t\teprintf (\"Cannot find script '%s'\\n\", input + 1);\n\t\t\tcore->num->value = 1;\n\t\t} else {\n\t\t\tcore->num->value = 0;\n\t\t}\n\t\tbreak;\n\tcase '!':\n\t\t/* from command */\n\t\tr_core_cmd_command (core, input + 1);\n\t\tbreak;\n\tcase '(':\n\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n\t\tbreak;\n\tcase '?':{\n\t\tconst char* help_msg[] = {\n\t\t\"Usage:\", \".[r2cmd] | [file] | [!command] | [(macro)]\", \" # define macro or load r2, cparse or rlang file\",\n\t\t\".\", \"\", \"repeat last command backward\",\n\t\t\".\", \"r2cmd\", \"interpret the output of the command as r2 commands\",\n\t\t\"..\", \"\", \"repeat last command forward (same as \\\\n)\",\n\t\t\".:\", \"8080\", \"listen for commands on given tcp port\",\n\t\t\".\", \" foo.r2\", \"interpret r2 script\",\n\t\t\".-\", \"\", \"open cfg.editor and interpret tmp file\",\n\t\t\".!\", \"rabin -ri $FILE\", \"interpret output of command\",\n\t\t\".\", \"(foo 1 2 3)\", \"run macro 'foo' with args 1, 2, 3\",\n\t\t\"./\", \" ELF\", \"interpret output of command /m ELF as r. commands\",\n\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (*input >= 0 && *input <= 9) {\n\t\t\teprintf (\"|ERROR| No .[0..9] to avoid infinite loops\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tinp = strdup (input);\n\t\tfilter = strchr (inp, '~');\n\t\tif (filter) {\n\t\t\t*filter = 0;\n\t\t}\n\t\tptr = str = r_core_cmd_str (core, inp);\n\t\tif (filter) {\n\t\t\t*filter = '~';\n\t\t}\n\t\tr_cons_break_push (NULL, NULL);\n\t\tif (ptr) {\n\t\t\tfor (;;) {\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\teol = strchr (ptr, '\\n');\n\t\t\t\tif (eol) *eol = '\\0';\n\t\t\t\tif (*ptr) {\n\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n\t\t\t\t\tr_core_cmd0 (core, p);\n\t\t\t\t\tfree (p);\n\t\t\t\t}\n\t\t\t\tif (!eol) break;\n\t\t\t\tptr = eol + 1;\n\t\t\t}\n\t\t}\n\t\tr_cons_break_pop ();\n\t\tfree (str);\n\t\tfree (inp);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int callback_foreach_kv (void *user, const char *k, const char *v) {\n\tr_cons_printf (\"%s=%s\\n\", k, v);\n\treturn 1;\n}\n\nstatic int cmd_kuery(void *data, const char *input) {\n\tchar buf[1024], *out;\n\tRCore *core = (RCore*)data;\n\tconst char *sp, *p = \"[sdb]> \";\n\tconst int buflen = sizeof (buf) - 1;\n\tSdb *s = core->sdb;\n\n\tswitch (input[0]) {\n\tcase ' ':\n\t\tout = sdb_querys (s, NULL, 0, input + 1);\n\t\tif (out) {\n\t\t\tr_cons_println (out);\n\t\t}\n\t\tfree (out);\n\t\tbreak;\n\t//case 's': r_pair_save (s, input + 3); break;\n\t//case 'l': r_pair_load (sdb, input + 3); break;\n\tcase '\\0':\n\t\tsdb_foreach (s, callback_foreach_kv, NULL);\n\t\tbreak;\n\t// TODO: add command to list all namespaces // sdb_ns_foreach ?\n\tcase 's':\n\t\tif (core->http_up) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_config_get_i (core->config, \"scr.interactive\")) {\n\t\t\treturn false;\n\t\t}\n\t\tif (input[1] == ' ') {\n\t\t\tchar *n, *o, *p = strdup (input + 2);\n\t\t\t// TODO: slash split here? or inside sdb_ns ?\n\t\t\tfor (n = o = p; n; o = n) {\n\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n\t\t\t\tif (n) *n++ = 0;\n\t\t\t\ts = sdb_ns (s, o, 1);\n\t\t\t}\n\t\t\tfree (p);\n\t\t}\n\t\tif (!s) s = core->sdb;\n\t\tfor (;;) {\n\t\t\tr_line_set_prompt (p);\n\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1)\n\t\t\t\tbreak;\n\t\t\tif (!*buf) break;\n\t\t\tout = sdb_querys (s, NULL, 0, buf);\n\t\t\tif (out) {\n\t\t\t\tr_cons_println (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'o':\n\t\tif (r_sandbox_enable (0)) {\n\t\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (input[1] == ' ') {\n\t\t\tchar *fn = strdup (input + 2);\n\t\t\tif (!fn) {\n\t\t\t\teprintf(\"Unable to allocate memory\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tchar *ns = strchr (fn, ' ');\n\t\t\tif (ns) {\n\t\t\t\tSdb *db;\n\t\t\t\t*ns++ = 0;\n\t\t\t\tif (r_file_exists (fn)) {\n\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n\t\t\t\t\t\tif (newdb) {\n\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else eprintf (\"Cannot find sdb '%s'\\n\", ns);\n\t\t\t\t} else eprintf (\"Cannot open file\\n\");\n\t\t\t} else eprintf (\"Missing sdb namespace\\n\");\n\t\t\tfree (fn);\n\t\t} else {\n\t\t\teprintf (\"Usage: ko [file] [namespace]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\tif (r_sandbox_enable (0)) {\n\t\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (input[1] == ' ') {\n\t\t\tchar *fn = strdup (input + 2);\n\t\t\tchar *ns = strchr (fn, ' ');\n\t\t\tif (ns) {\n\t\t\t\t*ns++ = 0;\n\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n\t\t\t\tif (db) {\n\t\t\t\t\tsdb_file (db, fn);\n\t\t\t\t\tsdb_sync (db);\n\t\t\t\t} else eprintf (\"Cannot find sdb '%s'\\n\", ns);\n\t\t\t} else eprintf (\"Missing sdb namespace\\n\");\n\t\t\tfree (fn);\n\t\t} else {\n\t\t\teprintf (\"Usage: kd [file] [namespace]\\n\");\n\t\t}\n\t\tbreak;\n\tcase '?': {\n\t\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"k[s] [key[=value]]\", \"Sdb Query\",\n\t\t\t\"k\", \" foo=bar\", \"set value\",\n\t\t\t\"k\", \" foo\", \"show value\",\n\t\t\t\"k\", \"\", \"list keys\",\n\t\t\t\"ko\", \" [file.sdb] [ns]\", \"open file into namespace\",\n\t\t\t\"kd\", \" [file.sdb] [ns]\", \"dump namespace to disk\",\n\t\t\t\"ks\", \" [ns]\", \"enter the sdb query shell\",\n\t\t\t\"k\", \" anal/meta/*\", \"ist kv from anal > meta namespaces\",\n\t\t\t\"k\", \" anal/**\", \"list namespaces under anal\",\n\t\t\t\"k\", \" anal/meta/meta.0x80404\", \"get value for meta.0x80404 key\",\n\t\t\t//\"kl\", \" ha.sdb\", \"load keyvalue from ha.sdb\",\n\t\t\t//\"ks\", \" ha.sdb\", \"save keyvalue to ha.sdb\",\n\t\t\tNULL,\n\t\t\t};\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (input[0] == '\\0') {\n\t\t/* nothing more to do, the command has been parsed. */\n\t\treturn 0;\n\t}\n\n\tsp = strchr (input + 1, ' ');\n\tif (sp) {\n\t\tchar *inp = strdup (input);\n\t\tinp [(size_t)(sp - input)] = 0;\n\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n\t\tif (out) {\n\t\t\tr_cons_println (out);\n\t\t\tfree (out);\n\t\t}\n\t\tfree (inp);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_bsize(void *data, const char *input) {\n\tut64 n;\n\tRFlagItem *flag;\n\tRCore *core = (RCore *)data;\n\tswitch (input[0]) {\n\tcase 'm':\n\t\tn = r_num_math (core->num, input + 1);\n\t\tif (n > 1) core->blocksize_max = n;\n\t\telse r_cons_printf (\"0x%x\\n\", (ut32)core->blocksize_max);\n\t\tbreak;\n\tcase '+':\n\t\tn = r_num_math (core->num, input + 1);\n\t\tr_core_block_size (core, core->blocksize + n);\n\t\tbreak;\n\tcase '-':\n\t\tn = r_num_math (core->num, input + 1);\n\t\tr_core_block_size (core, core->blocksize - n);\n\t\tbreak;\n\tcase 'f':\n\t\tif (input[1] == ' ') {\n\t\t\tflag = r_flag_get (core->flags, input + 2);\n\t\t\tif (flag) {\n\t\t\t\tr_core_block_size (core, flag->size);\n\t\t\t} else {\n\t\t\t\teprintf (\"bf: cannot find flag named '%s'\\n\", input + 2);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: bf [flagname]\\n\");\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_cons_printf (\"0x%x\\n\", core->blocksize);\n\t\tbreak;\n\tcase '?':{\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\",  \"b[f] [arg]\\n\", \"Get/Set block size\",\n\t\t\t\"b\", \"\", \"display current block size\",\n\t\t\t\"b\", \" 33\", \"set block size to 33\",\n\t\t\t\"b\", \"+3\", \"increase blocksize by 3\",\n\t\t\t\"b\", \"-16\", \"decrease blocksize by 16\",\n\t\t\t\"b\", \" eip+4\", \"numeric argument can be an expression\",\n\t\t\t\"bf\", \" foo\", \"set block size to flag size\",\n\t\t\t\"bm\", \" 1M\", \"set max block size\",\n\t\t\tNULL\n\t\t};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t//input = r_str_clean(input);\n\t\tr_core_block_size (core, r_num_math (core->num, input));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_resize(void *data, const char *input) {\n\tRCore *core = (RCore *)data;\n\tut64 oldsize, newsize = 0;\n\tst64 delta = 0;\n\tint grow, ret;\n\n\tif (core->file && core->file->desc)\n\t\toldsize = r_io_desc_size (core->io, core->file->desc);\n\telse oldsize = 0;\n\tswitch (*input) {\n\tcase '2':\n\t\t// TODO: use argv[0] instead of 'radare2'\n\t\tr_sys_cmdf (\"radare%s\", input);\n\t\treturn true;\n\tcase 'm':\n\t\tif (input[1] == ' ')\n\t\t\tr_file_rm (input + 2);\n\t\telse eprintf (\"Usage: rm [file]   # removes a file\\n\");\n\t\treturn true;\n\tcase '\\0':\n\t\tif (core->file && core->file->desc) {\n\t\t\tif (oldsize != -1) {\n\t\t\t\tr_cons_printf (\"%\"PFMT64d\"\\n\", oldsize);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase '+':\n\tcase '-':\n\t\tdelta = (st64)r_num_math (core->num, input);\n\t\tnewsize = oldsize + delta;\n\t\tbreak;\n\tcase ' ':\n\t\tnewsize = r_num_math (core->num, input + 1);\n\t\tif (newsize == 0) {\n\t\t\tif (input[1] == '0')\n\t\t\t\teprintf (\"Invalid size\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase '?':{\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"r[+-][ size]\", \"Resize file\",\n\t\t\t\"r\", \"\", \"display file size\",\n\t\t\t\"r\", \" size\", \"expand or truncate file to given size\",\n\t\t\t\"r-\", \"num\", \"remove num bytes, move following data down\",\n\t\t\t\"r+\", \"num\", \"insert num bytes, move following data up\",\n\t\t\t\"rm\" ,\" [file]\", \"remove file\",\n\t\t\t\"r2\" ,\" [file]\", \"launch r2\",\n\t\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\treturn true;\n\t}\n\n\tgrow = (newsize > oldsize);\n\tif (grow) {\n\t\tret = r_io_resize (core->io, newsize);\n\t\tif (ret < 1)\n\t\t\teprintf (\"r_io_resize: cannot resize\\n\");\n\t}\n\n\tif (delta && core->offset < newsize)\n\t\tr_io_shift (core->io, core->offset, grow?newsize:oldsize, delta);\n\n\tif (!grow) {\n\t\tret = r_io_resize (core->io, newsize);\n\t\tif (ret < 1)\n\t\t\teprintf (\"r_io_resize: cannot resize\\n\");\n\t}\n\n\tif (newsize < core->offset+core->blocksize ||\n\t\t\toldsize < core->offset + core->blocksize) {\n\t\tr_core_block_read (core);\n\t}\n\treturn true;\n}\n\nstatic int cmd_visual(void *data, const char *input) {\n\tRCore *core = (RCore*) data;\n\tif (core->http_up) {\n\t\treturn false;\n\t}\n\tif (!r_config_get_i (core->config, \"scr.interactive\")) {\n\t\treturn false;\n\t}\n\treturn r_core_visual ((RCore *)data, input);\n}\n\nstatic int task_finished(void *user, void *data) {\n\teprintf (\"TASK FINISHED\\n\");\n\treturn 0;\n}\n\nstatic int taskbgrun(RThread *th) {\n\tchar *res;\n\tRCoreTask *task = th->user;\n\tRCore *core = task->core;\n\tclose (2); // no stderr\n\tres = r_core_cmd_str (core, task->msg->text);\n\ttask->msg->res = res;\n\ttask->state = 'd';\n\teprintf (\"Task %d finished\\n\", task->id);\n// TODO: run callback and pass result\n\treturn 0;\n}\n\nstatic int cmd_thread(void *data, const char *input) {\n\tRCore *core = (RCore*) data;\n\tif (r_sandbox_enable (0)) {\n\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\treturn 0;\n\t}\n\tswitch (input[0]) {\n\tcase '\\0':\n\tcase 'j':\n\t\tr_core_task_list (core, *input);\n\t\tbreak;\n\tcase '&':\n\t\tif (input[1] == '&') {\n\t\t\t// wait until ^C\n\t\t} else {\n\t\t\tint tid = r_num_math (core->num, input + 1);\n\t\t\tif (tid) {\n\t\t\t\tRCoreTask *task = r_core_task_get (core, tid);\n\t\t\t\tif (task) {\n\t\t\t\t\tr_core_task_join (core, task);\n\t\t\t\t} else eprintf (\"Cannot find task\\n\");\n\t\t\t} else {\n\t\t\t\tr_core_task_run (core, NULL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '=': {\n\t\tint tid = r_num_math (core->num, input + 1);\n\t\tif (tid) {\n\t\t\tRCoreTask *task = r_core_task_get (core, tid);\n\t\t\tif (task) {\n\t\t\t\tr_cons_printf (\"Task %d Status %c Command %s\\n\",\n\t\t\t\t\ttask->id, task->state, task->msg->text);\n\t\t\t\tif (task->msg->res)\n\t\t\t\t\tr_cons_println (task->msg->res);\n\t\t\t} else eprintf (\"Cannot find task\\n\");\n\t\t} else {\n\t\t\tr_core_task_list (core, 1);\n\t\t}}\n\t\tbreak;\n\tcase '+':\n\t\tr_core_task_add (core, r_core_task_new (core, input + 1, (RCoreTaskCallback)task_finished, core));\n\t\tbreak;\n\tcase '-':\n\t\tif (input[1] == '*') {\n\t\t\tr_core_task_del (core, -1);\n\t\t} else {\n\t\t\tr_core_task_del (core, r_num_math (core->num, input + 1));\n\t\t}\n\t\tbreak;\n\tcase '?':\n\t\t{\n\t\t\thelpCmdTasks (core);\n\t\t}\n\t\tbreak;\n\tcase ' ':\n\t\t{\n\t\t\tint tid = r_num_math (core->num, input + 1);\n\t\t\tif (tid) {\n\t\t\t\tRCoreTask *task = r_core_task_get (core, tid);\n\t\t\t\tif (task) {\n\t\t\t\t\tr_core_task_join (core, task);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Cannot find task\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRCoreTask *task = r_core_task_add (core, r_core_task_new (\n\t\t\t\t\t\t\tcore, input + 1, (RCoreTaskCallback)task_finished, core));\n\t\t\t\tRThread *th = r_th_new (taskbgrun, task, 0);\n\t\t\t\ttask->msg->th = th;\n\t\t\t}\n\t\t\t//r_core_cmd0 (core, task->msg->text);\n\t\t\t//r_core_task_del (core, task->id);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"&?\\n\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_pointer(void *data, const char *input) {\n\tRCore *core = (RCore*) data;\n\tint ret = true;\n\tchar *str, *eq;\n\twhile (*input == ' ') input++;\n\tif (!*input || *input == '?') {\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"*<addr>[=[0x]value]\", \"Pointer read/write data/values\",\n\t\t\t\"*\", \"entry0=cc\", \"write trap in entrypoint\",\n\t\t\t\"*\", \"entry0+10=0x804800\", \"write value in delta address\",\n\t\t\t\"*\", \"entry0\", \"read byte at given address\",\n\t\t\t\"TODO: last command should honor asm.bits\", \"\", \"\",\n\t\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\treturn ret;\n\t}\n\tstr = strdup (input);\n\teq = strchr (str, '=');\n\tif (eq) {\n\t\t*eq++ = 0;\n\t\tif (!strncmp (eq, \"0x\", 2)) {\n\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n\t\t} else {\n\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n\t\t}\n\t} else {\n\t\tret = r_core_cmdf (core, \"?v [%s]\", input);\n\t}\n\tfree (str);\n\treturn ret;\n}\n\nstatic int cmd_env(void *data, const char *input) {\n\tRCore *core = (RCore*)data;\n\tint ret = true;\n\tswitch (*input) {\n\tcase '?':\n\t\t{\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"%[name[=value]]\", \"Set each NAME to VALUE in the environment\",\n\t\t\t\"%\", \"\", \"list all environment variables\",\n\t\t\t\"%\", \"SHELL\", \"prints SHELL value\",\n\t\t\t\"%\", \"TMPDIR=/tmp\", \"sets TMPDIR value to \\\"/tmp\\\"\",\n\t\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = r_core_cmdf (core, \"env %s\", input);\n\t}\n\treturn ret;\n}\n\nstatic int cmd_system(void *data, const char *input) {\n\tRCore *core = (RCore*)data;\n\tut64 n;\n\tint ret = 0;\n\tswitch (*input) {\n\tcase '=':\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: !=[!]  - enable/disable remote commands\\n\");\n\t\t} else {\n\t\t\tif (!r_sandbox_enable (0)) {\n\t\t\t\tcore->cmdremote = input[1]? 1: 0;\n\t\t\t\tr_cons_println (r_str_bool (core->cmdremote));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '!':\n\t\tif (r_sandbox_enable (0)) {\n\t\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (input[1]) {\n\t\t\tint olen;\n\t\t\tchar *out = NULL;\n\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n\t\t\tif (cmd) {\n\t\t\t\tret = r_sys_cmd_str_full (cmd + 1, NULL, &out, &olen, NULL);\n\t\t\t\tr_core_sysenv_end (core, input);\n\t\t\t\tr_cons_memcat (out, olen);\n\t\t\t\tfree (out);\n\t\t\t\tfree (cmd);\n\t\t\t} //else eprintf (\"Error setting up system environment\\n\");\n\t\t} else {\n\t\t\teprintf (\"History saved to \"R2_HOMEDIR\"/history\\n\");\n\t\t\tr_line_hist_save (R2_HOMEDIR\"/history\");\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_line_hist_list ();\n\t\tbreak;\n\tcase '?':\n\t\tr_core_sysenv_help (core);\n\t\tbreak;\n\tdefault:\n\t\tn = atoi (input);\n\t\tif (*input == '0' || n > 0) {\n\t\t\tconst char *cmd = r_line_hist_get (n);\n\t\t\tif (cmd) r_core_cmd0 (core, cmd);\n\t\t\t//else eprintf (\"Error setting up system environment\\n\");\n\t\t} else {\n\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n\t\t\tif (cmd) {\n\t\t\t\tret = r_sys_cmd (cmd);\n\t\t\t\tr_core_sysenv_end (core, input);\n\t\t\t\tfree (cmd);\n\t\t\t} else eprintf (\"Error setting up system environment\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nR_API int r_core_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n#if __UNIX__ || __CYGWIN__\n\tint stdout_fd, fds[2];\n\tint child;\n#endif\n\tint si, olen, ret = -1, pipecolor = -1;\n\tchar *str, *out = NULL;\n\n\tif (r_sandbox_enable (0)) {\n\t\teprintf (\"Pipes are not allowed in sandbox mode\\n\");\n\t\treturn -1;\n\t}\n\tsi = r_config_get_i (core->config, \"scr.interactive\");\n\tr_config_set_i (core->config, \"scr.interactive\", 0);\n\tif (!r_config_get_i (core->config, \"scr.pipecolor\")) {\n\t\tpipecolor = r_config_get_i (core->config, \"scr.color\");\n\t\tr_config_set_i (core->config, \"scr.color\", 0);\n\t}\n\tif (*shell_cmd=='!') {\n\t\tr_cons_grep_parsecmd (shell_cmd, \"\\\"\");\n\t\tolen = 0;\n\t\tout = NULL;\n\t\t// TODO: implement foo\n\t\tstr = r_core_cmd_str (core, radare_cmd);\n\t\tr_sys_cmd_str_full (shell_cmd + 1, str, &out, &olen, NULL);\n\t\tfree (str);\n\t\tr_cons_memcat (out, olen);\n\t\tfree (out);\n\t\tret = 0;\n\t}\n#if __UNIX__ || __CYGWIN__\n\tradare_cmd = (char*)r_str_trim_head (radare_cmd);\n\tshell_cmd = (char*)r_str_trim_head (shell_cmd);\n\n\tsignal (SIGPIPE, SIG_IGN);\n\tstdout_fd = dup (1);\n\tif (stdout_fd != -1) {\n\t\tpipe (fds);\n\t\tchild = r_sys_fork ();\n\t\tif (child == -1) {\n\t\t\teprintf (\"Cannot fork\\n\");\n\t\t\tclose (stdout_fd);\n\t\t} else if (child) {\n\t\t\tdup2 (fds[1], 1);\n\t\t\tclose (fds[1]);\n\t\t\tclose (fds[0]);\n\t\t\tr_core_cmd (core, radare_cmd, 0);\n\t\t\tr_cons_flush ();\n\t\t\tclose (1);\n\t\t\twait (&ret);\n\t\t\tdup2 (stdout_fd, 1);\n\t\t\tclose (stdout_fd);\n\t\t} else {\n\t\t\tclose (fds[1]);\n\t\t\tdup2 (fds[0], 0);\n\t\t\t//dup2 (1, 2); // stderr goes to stdout\n\t\t\tr_sandbox_system (shell_cmd, 0);\n\t\t\tclose (stdout_fd);\n\t\t}\n\t}\n#else\n#ifdef _MSC_VER\n#pragma message (\"r_core_cmd_pipe UNIMPLEMENTED FOR THIS PLATFORM\")\n#else\n#warning r_core_cmd_pipe UNIMPLEMENTED FOR THIS PLATFORM\n#endif\n\teprintf (\"r_core_cmd_pipe: unimplemented for this platform\\n\");\n#endif\n\tif (pipecolor != -1)\n\t\tr_config_set_i (core->config, \"scr.color\", pipecolor);\n\tr_config_set_i (core->config, \"scr.interactive\", si);\n\treturn ret;\n}\n\nstatic char *parse_tmp_evals(RCore *core, const char *str) {\n\tchar *res = NULL;\n\tRStrBuf *buf;\n\tchar *s = strdup (str);\n\tbuf = r_strbuf_new (\"\");\n\tint i, argc = r_str_split (s, ',');\n\tfor (i = 0; i < argc; i++) {\n\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n\t\tif (!kv) {\n\t\t\tbreak;\n\t\t}\n\t\teq = strchr (kv, '=');\n\t\tif (eq) {\n\t\t\t*eq = 0;\n\t\t\tconst char *ov = r_config_get (core->config, kv);\n\t\t\tr_strbuf_appendf (buf, \"e %s=%s;\", kv, ov);\n\t\t\tr_config_set (core->config, kv, eq + 1);\n\t\t\t*eq = '=';\n\t\t} else {\n\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n\t\t}\n\t}\n\tres = r_strbuf_drain (buf);\n\tfree (s);\n\treturn res;\n}\n\nstatic int r_core_cmd_subst_i(RCore *core, char *cmd, char* colon);\nstatic int r_core_cmd_subst(RCore *core, char *cmd) {\n\tint ret = 0, rep = atoi (cmd), orep;\n\tchar *cmt, *colon = NULL, *icmd = strdup (cmd);\n\tconst char *cmdrep = NULL;\n\tcmd = r_str_trim_head_tail (icmd);\n\t// lines starting with # are ignored (never reach cmd_hash()), except #! and #?\n\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n\t\tgoto beach;\n\t}\n\tcmt = *icmd ? strchr (icmd + 1, '#'): NULL;\n\tif (cmt && (cmt[1] == ' ' || cmt[1] == '\\t')) {\n\t\t*cmt = 0;\n\t}\n\tif (*cmd != '\"') {\n\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n\t\t\tif ((colon = strchr (cmd, ';'))) {\n\t\t\t\t*colon = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcolon = NULL;\n\t}\n\tif (rep > 0) {\n\t\twhile (IS_DIGIT(*cmd)) {\n\t\t\tcmd++;\n\t\t}\n\t\t// do not repeat null cmd\n\t\tif (!*cmd) {\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (rep < 1) {\n\t\trep = 1;\n\t}\n\t// XXX if output is a pipe then we dont want to be interactive\n\tif (rep > 1 && r_sandbox_enable (0)) {\n\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n\t\tgoto beach;\n\t} else {\n\t\tif (rep > INTERACTIVE_MAX_REP) {\n\t\t\tif (r_config_get_i (core->config, \"scr.interactive\")) {\n\t\t\t\tif (!r_cons_yesno ('n', \"Are you sure to repeat this %d times? (y/N)\", rep)) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// TODO: store in core->cmdtimes to speedup ?\n\tcmdrep = r_config_get (core->config, \"cmd.times\");\n\tif (!cmdrep) {\n\t\tcmdrep = \"\";\n\t}\n\torep = rep;\n\n\tint ocur_enabled = core->print->cur_enabled;\n\twhile (rep-- && *cmd) {\n\t\tcore->print->cur_enabled = false;\n\t\tif (ocur_enabled && core->seltab >= 0) {\n\t\t\tif (core->seltab == core->curtab) {\n\t\t\t\tcore->print->cur_enabled = true;\n\t\t\t}\n\t\t}\n\t\tchar *cr = strdup (cmdrep);\n\t\tcore->break_loop = false;\n\t\tret = r_core_cmd_subst_i (core, cmd, colon);\n\t\tif (ret && *cmd == 'q') {\n\t\t\tfree (cr);\n\t\t\tgoto beach;\n\t\t}\n\t\tif (core->break_loop) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cr && *cr) {\n\t\t\tif (orep > 1) {\n\t\t\t\t// XXX: do not flush here, we need r_cons_push () and r_cons_pop()\n\t\t\t\tr_cons_flush ();\n\t\t\t\t// XXX: we must import register flags in C\n\t\t\t\t(void)r_core_cmd0 (core, \".dr*\");\n\t\t\t\t(void)r_core_cmd0 (core, cr);\n\t\t\t}\n\t\t}\n\t\tfree (cr);\n\t}\n\tcore->print->cur_enabled = ocur_enabled;\n\tif (colon && colon[1]) {\n\t\tfor (++colon; *colon == ';'; colon++);\n\t\tr_core_cmd_subst (core, colon);\n\t} else {\n\t\tif (!*icmd) {\n\t\t\tr_core_cmd_nullcallback (core);\n\t\t}\n\t}\nbeach:\n\tfree (icmd);\n\treturn ret;\n}\n\nstatic char *find_eoq(char *p) {\n\tfor (; *p; p++) {\n\t\tif (*p == '\"') {\n\t\t\tbreak;\n\t\t}\n\t\tif (*p == '\\\\' && p[1] == '\"') {\n\t\t\tp++;\n\t\t}\n\t}\n\treturn p;\n}\n\nstatic char* findSeparator(char *p) {\n\tchar *q = strchr (p, '+');\n\tif (q) {\n\t\treturn q;\n\t}\n\treturn strchr (p, '-');\n}\n\nstatic int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon) {\n\tconst char *quotestr = \"`\";\n\tconst char *tick = NULL;\n\tchar *ptr, *ptr2, *str;\n\tchar *arroba = NULL;\n\tint i, ret = 0, pipefd;\n\tbool usemyblock = false;\n\tint scr_html = -1;\n\tint scr_color = -1;\n\tbool eos = false;\n\tbool haveQuote = false;\n\n\tif (!cmd) {\n\t\treturn 0;\n\t}\n\tcmd = r_str_trim_head_tail (cmd);\n\n\t/* quoted / raw command */\n\tswitch (*cmd) {\n\tcase '.':\n\t\tif (cmd[1] == '\"') { /* interpret */\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t\tbreak;\n\tcase '\"':\n\t\tfor (; *cmd; ) {\n\t\t\tint pipefd = -1;\n\t\t\tut64 oseek = UT64_MAX;\n\t\t\tchar *line, *p;\n\t\t\thaveQuote = *cmd == '\"';\n\t\t\tif (haveQuote) {\n\t\t\t//\t*cmd = 0;\n\t\t\t\tcmd++;\n\t\t\t\tp = find_eoq (cmd + 1);\n\t\t\t\tif (!p || !*p) {\n\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*p++ = 0;\n\t\t\t\tif (!*p) {\n\t\t\t\t\teos = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchar *sc = strchr (cmd, ';');\n\t\t\t\tif (sc) {\n\t\t\t\t\t*sc = 0;\n\t\t\t\t}\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\tif (!sc) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmd = sc + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[0]) {\n\t\t\t\t// workaround :D\n\t\t\t\tif (p[0] == '@') {\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q = 0;\n\t\t\t\t\t}\n\t\t\t\t\thaveQuote = q != NULL;\n\t\t\t\t\toseek = core->offset;\n\t\t\t\t\tr_core_seek (core,\n\t\t\t\t\t\t     r_num_math (core->num, p + 2), 1);\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tp = q;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = strchr (p + 1, ';');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p && *p && p[1] == '>') {\n\t\t\t\t\tstr = p + 2;\n\t\t\t\t\twhile (*str == '>') {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_flush ();\n\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, p[2] == '>');\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = strdup (cmd);\n\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n\t\t\tif (p && *p && p[1] == '|') {\n\t\t\t\tstr = p + 2;\n\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n\t\t\t} else {\n\t\t\t\tr_cmd_call (core->rcmd, line);\n\t\t\t}\n\t\t\tfree (line);\n\t\t\tif (oseek != UT64_MAX) {\n\t\t\t\tr_core_seek (core, oseek, 1);\n\t\t\t\toseek = UT64_MAX;\n\t\t\t}\n\t\t\tif (pipefd != -1) {\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (eos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (haveQuote) {\n\t\t\t\tif (*p == ';') {\n\t\t\t\t\tcmd = p + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (*p == '\"') {\n\t\t\t\t\t\tcmd = p + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tcmd = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcmd = p + 1;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase '(':\n\t\tif (cmd[1] != '*') {\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t}\n\n// TODO must honor \" and `\n\t/* comments */\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, '#', quotestr);\n\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n\t\t\t*ptr = '\\0';\n\t\t}\n\t}\n\n\t/* multiple commands */\n\t// TODO: must honor \" and ` boundaries\n\t//ptr = strrchr (cmd, ';');\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n\t\tif (colon && ptr) {\n\t\t\tint ret ;\n\t\t\t*ptr = '\\0';\n\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcmd = ptr + 1;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t*ptr = ';';\n\t\t\treturn ret;\n\t\t\t//r_cons_flush ();\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* pipe console to shell process */\n\t//ptr = strchr (cmd, '|');\n\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n\tif (ptr) {\n\t\tchar *ptr2 = strchr (cmd, '`');\n\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n\t\t\tif (!tick || (tick && tick > ptr)) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tcmd = r_str_clean (cmd);\n\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n\t\t\t\t\t// TODO: should be disable scr.color in pd| ?\n\t\t\t\t\teprintf (\"Usage: <r2command> | <program|H|>\\n\");\n\t\t\t\t\teprintf (\" pd|?   - show this help\\n\");\n\t\t\t\t\teprintf (\" pd|    - disable scr.html and scr.color\\n\");\n\t\t\t\t\teprintf (\" pd|H   - enable scr.html, respect scr.color\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t} else if (!strcmp (ptr + 1, \"H\")) { // \"|H\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n\t\t\t\t\tint value = core->num->value;\n\t\t\t\t\tif (*cmd) {\n\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_io_system (core->io, ptr + 1);\n\t\t\t\t\t}\n\t\t\t\t\tcore->num->value = value;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else { // \"|\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* bool conditions */\n\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n\t//ptr = strchr (cmd, '&');\n\twhile (ptr && ptr[1] == '&') {\n\t\t*ptr = '\\0';\n\t\tret = r_cmd_call (core->rcmd, cmd);\n\t\tif (ret == -1) {\n\t\t\teprintf (\"command error(%s)\\n\", cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++);\n\t\tptr = strchr (cmd, '&');\n\t}\n\n\t/* Out Of Band Input */\n\tfree (core->oobi);\n\tcore->oobi = NULL;\n\n\tptr = strstr (cmd, \"?*\");\n\tif (ptr) {\n\t\tchar *prech = ptr - 1;\n\t\tif (*prech != '~') {\n\t\t\tptr[1] = 0;\n\t\t\tif (*cmd != '#' && strlen (cmd) < 5) {\n\t\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\t\trecursive_help (core, cmd);\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n\t\t\t\tif (scr_html != -1) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tptr = strchr (cmd, '<');\n\tif (ptr) {\n\t\tptr[0] = '\\0';\n\t\tif (r_cons_singleton()->is_interactive) {\n\t\t\tif (ptr[1] == '<') {\n\t\t\t\t/* this is a bit mess */\n\t\t\t\t//const char *oprompt = strdup (r_line_singleton ()->prompt);\n\t\t\t\t//oprompt = \">\";\n\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = malloc (1);\n\t\t\t\tif (core->oobi) {\n\t\t\t\t\tcore->oobi[0] = '\\0';\n\t\t\t\t}\n\t\t\t\tcore->oobi_len = 0;\n\t\t\t\tfor (;;) {\n\t\t\t\t\tchar buf[1024];\n\t\t\t\t\tint ret;\n\t\t\t\t\twrite (1, \"> \", 2);\n\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n\t\t\t\t\tif (feof (stdin)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n\t\t\t\t\tret = strlen (buf);\n\t\t\t\t\tcore->oobi_len += ret;\n\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n\t\t\t\t\tif (core->oobi) {\n\t\t\t\t\t\tif (!strcmp (buf, str)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//r_line_set_prompt (oprompt);\n\t\t\t} else {\n\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\tif (!*str) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n\t\t\t\tif (!core->oobi) {\n\t\t\t\t\teprintf (\"cannot open file\\n\");\n\t\t\t\t} else if (ptr == cmd) {\n\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot slurp with << in non-interactive mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\nnext:\n#endif\n\t// TODO must honor \" and `\n\t/* pipe console to file */\n\tptr = strchr (cmd, '>');\n\tif (ptr) {\n\t\tint fdn = 1;\n\t\tint pipecolor = r_config_get_i (core->config, \"scr.pipecolor\");\n\t\tint use_editor = false;\n\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n\t\t*ptr = '\\0';\n\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n\t\tif (!*str) {\n\t\t\teprintf (\"No output?\\n\");\n\t\t\tgoto next2;\n\t\t}\n\t\t/* r_cons_flush() handles interactive output (to the terminal)\n\t\t * differently (e.g. asking about too long output). This conflicts\n\t\t * with piping to a file. Disable it while piping. */\n\t\tif (ptr > (cmd + 1) && ISWHITECHAR (ptr[-2])) {\n\t\t\tchar *fdnum = ptr - 1;\n\t\t\tif (*fdnum == 'H') { // \"H>\"\n\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\tpipecolor = true;\n\t\t\t\t*fdnum = 0;\n\t\t\t} else {\n\t\t\t\tif (IS_DIGIT(*fdnum)) {\n\t\t\t\t\tfdn = *fdnum - '0';\n\t\t\t\t}\n\t\t\t\t*fdnum = 0;\n\t\t\t}\n\t\t}\n\t\tr_cons_set_interactive (false);\n\t\tif (!strcmp (str, \"-\")) {\n\t\t\tuse_editor = true;\n\t\t\tstr = r_file_temp (\"dumpedit\");\n\t\t\tr_config_set (core->config, \"scr.color\", \"false\");\n\t\t}\n\t\tif (fdn > 0) {\n\t\t\tpipefd = r_cons_pipe_open (str, fdn, ptr[1] == '>');\n\t\t\tif (pipefd != -1) {\n\t\t\t\tif (!pipecolor) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n\t\t\t\t}\n\t\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t}\n\t\tr_cons_set_last_interactive ();\n\t\tif (!pipecolor) {\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t}\n\t\tif (use_editor) {\n\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n\t\t\tif (editor && *editor) {\n\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n\t\t\t\tr_file_rm (str);\n\t\t\t} else {\n\t\t\t\teprintf (\"No cfg.editor configured\\n\");\n\t\t\t}\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t\tfree (str);\n\t\t}\n\t\tif (scr_html != -1) {\n\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\treturn ret;\n\t}\nnext2:\n\t/* sub commands */\n\tptr = strchr (cmd, '`');\n\tif (ptr) {\n\t\tint empty = 0;\n\t\tint oneline = 1;\n\t\tif (ptr[1] == '`') {\n\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n\t\t\toneline = 0;\n\t\t\tempty = 1;\n\t\t}\n\t\tptr2 = strchr (ptr + 1, '`');\n\t\tif (empty) {\n\t\t\t/* do nothing */\n\t\t} else if (!ptr2) {\n\t\t\teprintf (\"parse: Missing backtick in expression.\\n\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tint value = core->num->value;\n\t\t\t*ptr = '\\0';\n\t\t\t*ptr2 = '\\0';\n\t\t\tif (ptr[1] == '!') {\n\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n\t\t\t} else {\n\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n\t\t\t}\n\t\t\tif (!str) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t// ignore contents if first char is pipe or comment\n\t\t\tif (*str == '|' || *str == '*') {\n\t\t\t\teprintf (\"r_core_cmd_subst_i: invalid backticked command\\n\");\n\t\t\t\tfree (str);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (oneline && str) {\n\t\t\t\tfor (i = 0; str[i]; i++) {\n\t\t\t\t\tif (str[i] == '\\n') {\n\t\t\t\t\t\tstr[i] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr = r_str_append (str, ptr2 + 1);\n\t\t\tcmd = r_str_append (strdup (cmd), str);\n\t\t\tcore->num->value = value;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\tfree (cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tfree (str);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t// TODO must honor \" and `\n\tcore->fixedblock = false;\n\n\tif (r_str_endswith (cmd, \"~?\") && cmd[2] == '\\0') {\n\t\tr_cons_grep_help ();\n\t\treturn true;\n\t}\n\tif (*cmd != '.') {\n\t\tr_cons_grep_parsecmd (cmd, quotestr);\n\t}\n\n\t/* temporary seek commands */\n\tif (*cmd!= '(' && *cmd != '\"') {\n\t\tptr = strchr (cmd, '@');\n\t\tif (ptr == cmd + 1 && *cmd == '?') {\n\t\t\tptr = NULL;\n\t\t}\n\t} else {\n\t\tptr = NULL;\n\t}\n\n\tcore->tmpseek = ptr? true: false;\n\tint rc = 0;\n\tif (ptr) {\n\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n\t\tut64 addr = UT64_MAX;\n\t\tconst char *tmpbits = NULL;\n\t\tconst char *offstr = NULL;\n\t\tut64 tmpbsz = core->blocksize;\n\t\tchar *tmpeval = NULL;\n\t\tut64 tmpoff = core->offset;\n\t\tchar *tmpasm = NULL;\n\t\tint tmpfd = -1;\n\t\tint sz, len;\n\t\tut8 *buf;\n\n\t\t*ptr = '\\0';\n\t\tfor (ptr++; *ptr == ' '; ptr++) {\n\t\t\t//nothing to see here\n\t\t}\n\t\tif (*ptr && ptr[1] == ':') {\n\t\t\t/* do nothing here */\n\t\t} else {\n\t\t\tptr--;\n\t\t}\n\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n\t\t\tstrchr (ptr + 2, '@'): NULL;\nrepeat_arroba:\n\t\tif (arroba) {\n\t\t\t*arroba = 0;\n\t\t}\n\t\tif (ptr[1] == '?') {\n\t\t\thelpCmdAt (core);\n\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n\t\t\tusemyblock = true;\n\t\t\tswitch (ptr[0]) {\n\t\t\tcase 'f': // \"@f:\" // slurp file in block\n\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n\t\t\t\tif (f) {\n\t\t\t\t\tbuf = malloc (sz);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tfree (core->block);\n\t\t\t\t\t\tcore->block = buf;\n\t\t\t\t\t\tcore->blocksize = sz;\n\t\t\t\t\t\tmemcpy (core->block, f, sz);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n\t\t\t\t\t}\n\t\t\t\t\tfree (f);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'r': // \"@r:\" // regname\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tut64 regval;\n\t\t\t\t\tchar *mander = strdup (ptr + 2);\n\t\t\t\t\tchar *sep = findSeparator (mander);\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tchar ch = *sep;\n\t\t\t\t\t\t*sep = 0;\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n\t\t\t\t\t\t*sep = ch;\n\t\t\t\t\t\tchar *numexpr = r_str_newf (\"0x%\"PFMT64x\"%s\", regval, sep);\n\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n\t\t\t\t\t\tfree (numexpr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t\tr_core_seek (core, regval, 1);\n\t\t\t\t\tfree (mander);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b': // \"@b:\" // bits\n\t\t\t\ttmpbits = strdup (r_config_get (core->config, \"asm.bits\"));\n\t\t\t\tr_config_set_i (core->config, \"asm.bits\",\n\t\t\t\t\tr_num_math (core->num, ptr + 2));\n\t\t\t\tbreak;\n\t\t\tcase 'i': // \"@i:\"\n\t\t\t\t{\n\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n\t\t\t\t\tif (addr) {\n\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'e': // \"@e:\"\n\t\t\t\ttmpeval = parse_tmp_evals (core, ptr + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'x': // \"@x:\" // hexpairs\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n\t\t\t\t\t\tr_core_block_size (core, R_ABS(len));\n\t\t\t\t\t\tmemcpy (core->block, buf, core->blocksize);\n\t\t\t\t\t\tcore->fixedblock = true;\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot allocate\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Invalid @x: syntax\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k': // \"@k\"\n\t\t\t\t {\n\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n\t\t\t\t\tif (out) {\n\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n\t\t\t\t\t\tfree (out);\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\tbreak;\n\t\t\tcase 'o': // \"@o:3\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\ttmpfd = core->io->raised;\n\t\t\t\t\tr_io_raise (core->io, atoi (ptr + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a': // \"@a:\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n\t\t\t\t\ttmpasm = strdup (r_config_get (core->config, \"asm.arch\"));\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q++ = 0;\n\t\t\t\t\t\ttmpbits = r_config_get (core->config, \"asm.bits\");\n\t\t\t\t\t\tr_config_set (core->config, \"asm.bits\", q);\n\t\t\t\t\t}\n\t\t\t\t\tr_config_set (core->config, \"asm.arch\", ptr + 2);\n\t\t\t\t\t// TODO: handle asm.bits\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Usage: pd 10 @a:arm:32\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"@s:\"\n\t\t\t\tlen = strlen (ptr + 2);\n\t\t\t\tr_core_block_size (core, len);\n\t\t\t\tmemcpy (core->block, ptr + 2, len);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\t*ptr = '@';\n\t\t\tgoto next_arroba; //ignore; //return ret;\n\t\t}\nignore:\n\t\tptr = r_str_trim_head (ptr + 1);\n\t\tptr--;\n\n\t\tcmd = r_str_clean (cmd);\n\t\tif (ptr2) {\n\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t    !memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t    !memcmp (ptr2 + 1, \"0x\", 2)) {\n\t\t\t\t/* 0xXXXX:0xYYYY */\n\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n\t\t\t\t/* XXXX:YYYY */\n\t\t\t} else {\n\t\t\t\t*ptr2 = '\\0';\n\t\t\t\tif (!ptr2[1]) {\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n\t\t\t}\n\t\t}\n\n\t\toffstr = r_str_trim_head (ptr + 1);\n\n\t\taddr = r_num_math (core->num, offstr);\n\t\tif (isalpha ((unsigned char)ptr[1]) && !addr) {\n\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tchar ch = *offstr;\n\t\t\tif (ch == '-' || ch == '+') {\n\t\t\t\taddr = core->offset + addr;\n\t\t\t}\n\t\t}\nnext_arroba:\n\t\tif (arroba) {\n\t\t\tptr = arroba;\n\t\t\tarroba = NULL;\n\t\t\tgoto repeat_arroba;\n\t\t}\n\t\tif (ptr[1] == '@') {\n\t\t\t// TODO: remove temporally seek (should be done by cmd_foreach)\n\t\t\tif (ptr[2] == '@') {\n\t\t\t\tchar *rule = ptr + 3;\n\t\t\t\twhile (*rule && *rule == ' ') rule++;\n\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n\t\t\t} else {\n\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n\t\t\t}\n\t\t\t//ret = -1; /* do not run out-of-foreach cmd */\n\t\t} else {\n\t\t\tbool tmpseek = false;\n\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n\t\t\t\t\"io.buffer.from\", \"lines.from\", \"search.from\", \"zoom.from\", NULL };\n\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n\t\t\t\t\"io.buffer.to\", \"lines.to\", \"search.to\", \"zoom.to\", NULL };\n\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n\n\t\t\t// @..\n\t\t\tif (ptr[1] == '.' && ptr[2] == '.') {\n\t\t\t\tchar *range = ptr + 3;\n\t\t\t\tchar *p = strchr (range, ' ');\n\t\t\t\tif (!p) {\n\t\t\t\t\teprintf (\"Usage: / ABCD @..0x1000 0x3000\\n\");\n\t\t\t\t\tfree (tmpeval);\n\t\t\t\t\tfree (tmpasm);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\t*p = '\\x00';\n\t\t\t\tut64 from = r_num_math (core->num, range);\n\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n\t\t\t\t// save current ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n\t\t\t\t}\n\t\t\t\t// set new ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n\t\t\t\t}\n\t\t\t\ttmpseek = true;\n\t\t\t}\n\t\t\tif (usemyblock) {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tcore->offset = addr;\n\t\t\t\t}\n\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t} else {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tif (!ptr[1] || r_core_seek (core, addr, 1)) {\n\t\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmpseek) {\n\t\t\t\t// restore ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ptr2) {\n\t\t\t*ptr2 = '!';\n\t\t\tr_core_block_size (core, tmpbsz);\n\t\t}\n\t\tif (tmpasm) {\n\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n\t\t\ttmpasm = NULL;\n\t\t}\n\t\tif (tmpfd != -1) {\n\t\t\tr_io_raise (core->io, tmpfd);\n\t\t}\n\t\tif (tmpbits) {\n\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n\t\t\ttmpbits = NULL;\n\t\t}\n\t\tif (tmpeval) {\n\t\t\tr_core_cmd0 (core, tmpeval);\n\t\t\tR_FREE (tmpeval);\n\t\t}\n\t\tr_core_seek (core, tmpoff, 1);\n\t\t*ptr = '@';\n\t\trc = ret;\n\t\tgoto beach;\n\t}\n\n\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\nbeach:\n\tif (scr_html != -1) {\n\t\tr_cons_flush ();\n\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t}\n\tif (scr_color != -1) {\n\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t}\n\tcore->fixedblock = false;\n\treturn rc;\nfail:\n\trc = -1;\n\tgoto beach;\n}\n\nstatic int foreach_comment(void *user, const char *k, const char *v) {\n\tRAnalMetaUserItem *ui = user;\n\tRCore *core = ui->anal->user;\n\tconst char *cmd = ui->user;\n\tif (!strncmp (k, \"meta.C.\", 7)) {\n\t\tchar *cmt = (char *)sdb_decode (v, 0);\n\t\tif (!cmt) cmt = strdup (\"\");\n\t\t//eprintf (\"--> %s = %s\\n\", k + 7, cmt);\n\t\tr_core_cmdf (core, \"s %s\", k + 7);\n\t\tr_core_cmd0 (core, cmd);\n\t\tfree (cmt);\n\t}\n\treturn 1;\n}\n\nR_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) {\n\tRDebug *dbg = core->dbg;\n\tRList *list, *head;\n\tRListIter *iter;\n\tRFlagItem *flg;\n\tint i;\n\n\tswitch (each[0]) {\n\tcase '=':\n\t\t{\n\t\tchar *arg;\n\t\tfor (arg = each + 1; ; ) {\n\t\t\tchar *next = strchr (arg, ' ');\n\t\t\tif (next) {\n\t\t\t\t*next = 0;\n\t\t\t}\n\t\t\tif (arg && *arg) {\n\t\t\t\tr_core_cmdf (core, \"%s %s\", cmd, arg);\n\t\t\t}\n\t\t\tif (!next) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ = next + 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?':\n\t\tr_cons_printf (\"Usage: @@@ [type]     # types:\\n\"\n\t\t\t\" symbols\\n\"\n\t\t\t\" imports\\n\"\n\t\t\t\" regs\\n\"\n\t\t\t\" threads\\n\"\n\t\t\t\" comments\\n\"\n\t\t\t\" functions\\n\"\n\t\t\t\" flags\\n\");\n\t\tbreak;\n\tcase 'c':\n\t\tswitch (each[1]) {\n\t\tcase 'a': // call\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_list_cb (core->anal, R_META_TYPE_COMMENT, 0, foreach_comment, (void*)cmd, UT64_MAX);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 't':\n\t\t// iterate over all threads\n\t\tif (dbg && dbg->h && dbg->h->threads) {\n\t\t\tint origpid = dbg->pid;\n\t\t\tRDebugPid *p;\n\t\t\tlist = dbg->h->threads (dbg, dbg->pid);\n\t\t\tif (!list)\n\t\t\t\treturn false;\n\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\tr_core_cmdf (core, \"dp %d\", p->pid);\n\t\t\t\tr_cons_printf (\"PID %d\\n\", p->pid);\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t}\n\t\t\tr_core_cmdf (core, \"dp %d\", origpid);\n\t\t\tr_list_free (list);\n\t\t}\n\t\tbreak;\n\tcase 'r':\n\t\t// registers\n\t\t{\n\t\t\tut64 offorig = core->offset;\n\t\t\tfor (i = 0; i < 128; i++) {\n\t\t\t\tRRegItem *item;\n\t\t\t\tut64 value;\n\t\t\t\thead = r_reg_get_list (dbg->reg, i);\n\t\t\t\tif (!head) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_list_foreach (head, iter, item) {\n\t\t\t\t\tif (item->size != core->anal->bits) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvalue = r_reg_get_value (dbg->reg, item);\n\t\t\t\t\tr_core_seek (core, value, 1);\n\t\t\t\t\tr_cons_printf (\"%s: \", item->name);\n\t\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_seek (core, offorig, 1);\n\t\t}\n\t\tbreak;\n\tcase 'i':\n\t\t// imports\n\t\t{\n\t\t\tRBinImport *imp;\n\t\t\tut64 offorig = core->offset;\n\t\t\tlist = r_bin_get_imports (core->bin);\n\t\t\tr_list_foreach (list, iter, imp) {\n\t\t\t\tchar *impflag = r_str_newf (\"sym.imp.%s\", imp->name);\n\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n\t\t\t\tif (addr && addr != UT64_MAX) {\n\t\t\t\t\tr_core_seek (core, addr, 1);\n\t\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_seek (core, offorig, 1);\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\t// symbols\n\t\t{\n\t\t\tRBinSymbol *sym;\n\t\t\tut64 offorig = core->offset;\n\t\t\tlist = r_bin_get_symbols (core->bin);\n\t\t\tr_list_foreach (list, iter, sym) {\n\t\t\t\tr_core_seek (core, sym->vaddr, 1);\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t}\n\t\t\tr_core_seek (core, offorig, 1);\n\t\t}\n\t\tbreak;\n\tcase 'f':\n\t\tswitch (each[1]) {\n\t\tcase 'l': // flags\n\t\t\tr_list_foreach (core->flags->flags, iter, flg) {\n\t\t\t\tr_core_seek (core, flg->offset, 1);\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u': // functions\n\t\t\t{\n\t\t\t\tut64 offorig = core->offset;\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tlist = core->anal->fcns;\n\t\t\t\tr_list_foreach (list, iter, fcn) {\n\t\t\t\t\tr_cons_printf (\"[0x%08\"PFMT64x\"  %s\\n\", fcn->addr, fcn->name);\n\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n\t\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\t}\n\t\t\t\tr_core_seek (core, offorig, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void foreachOffset (RCore *core, const char *_cmd, const char *each) {\n\tchar *cmd = strdup (_cmd);\n\tchar *str = cmd;\n\tchar *nextLine = NULL;\n\tut64 addr;\n\t/* foreach list of items */\n\twhile (each) {\n\t\t// skip spaces\n\t\twhile (*each == ' ') {\n\t\t\teach++;\n\t\t}\n\t\t// stahp if empty string\n\t\tif (!*each) {\n\t\t\tbreak;\n\t\t}\n\t\t// find newline\n\t\tchar *nl = strchr (each, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\tnextLine = nl + 1;\n\t\t} else {\n\t\t\tnextLine = NULL;\n\t\t}\n\t\t// chop comment in line\n\t\tnl = strchr (each, '#');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t}\n\t\t// space separated numbers\n\t\twhile (each && *each) {\n\t\t\t// find spaces\n\t\t\twhile (*each== ' ') each++;\n\t\t\tstr = strchr (each, ' ');\n\t\t\tif (str) {\n\t\t\t\t*str = '\\0';\n\t\t\t\taddr = r_num_math (core->num, each);\n\t\t\t\t*str = ' ';\n\t\t\t\teach = str + 1;\n\t\t\t} else {\n\t\t\t\tif (!*each) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\taddr = r_num_math (core->num, each);\n\t\t\t\teach = NULL;\n\t\t\t}\n\t\t\tr_core_seek (core, addr, 1);\n\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\tr_cons_flush ();\n\t\t}\n\t\teach = nextLine;\n\t}\n\tfree (cmd);\n}\n\nR_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n\tint i, j;\n\tchar ch;\n\tchar *word = NULL;\n\tchar *str, *ostr;\n\tRListIter *iter;\n\tRFlagItem *flag;\n\tut64 oseek, addr;\n\n\t// for (; *each == ' '; each++);\n\tfor (; *cmd == ' '; cmd++);\n\n\toseek = core->offset;\n\tostr = str = strdup (each);\n\tr_cons_break_push (NULL, NULL); //pop on return\n\tswitch (each[0]) {\n\tcase '/': // \"@@/\"\n\t\t{\n\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n\t\tr_config_set (core->config, \"cmd.hit\", cmd);\n\t\tr_core_cmd0 (core, each);\n\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n\t\tfree (cmdhit);\n\t\t}\n\t\treturn 0;\n\tcase '?':\n\t\thelpCmdForeach (core);\n\t\tbreak;\n\tcase 'b': // \"@@b\" - function basic blocks\n\t\t{\n\t\t\tRListIter *iter;\n\t\t\tRAnalBlock *bb;\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n\t\t\tint bs = core->blocksize;\n\t\t\tif (fcn) {\n\t\t\t\tr_list_sort (fcn->bbs, bb_cmp);\n\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\tr_core_block_size (core, bb->size);\n\t\t\t\t\tr_core_seek (core, bb->addr, 1);\n\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\tr_core_block_size (core, bs);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"@@i\" - function instructions\n\t\t{\n\t\t\tRListIter *iter;\n\t\t\tRAnalBlock *bb;\n\t\t\tint i;\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_list_sort (fcn->bbs, bb_cmp);\n\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n\t\t\t\t\t\tr_core_seek (core, addr, 1);\n\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"@@f\"\n\t\tif (each[1] == ':') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tRListIter *iter;\n\t\t\tif (core->anal) {\n\t\t\t\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\tgoto out_finish;\n\t\t} else {\n\t\t\tRAnalFunction *fcn;\n\t\t\tRListIter *iter;\n\t\t\tif (core->anal) {\n\t\t\t\tRConsGrep grep = core->cons->grep;\n\t\t\t\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t\t\t\tchar *buf;\n\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n\t\t\t\t\tr_cons_push ();\n\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tbuf = strdup (buf);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_pop ();\n\t\t\t\t\tr_cons_strcat (buf);\n\t\t\t\t\tfree (buf);\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcore->cons->grep = grep;\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tbreak;\n\tcase 't':\n\t\t{\n\t\t\tRDebugPid *p;\n\t\t\tint pid = core->dbg->pid;\n\t\t\tif (core->dbg->h && core->dbg->h->pids) {\n\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n\t\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\t\tr_cons_printf (\"# PID %d\\n\", p->pid);\n\t\t\t\t\tr_debug_select (core->dbg, p->pid, p->pid);\n\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t\tr_debug_select (core->dbg, pid, pid);\n\t\t\tfree (ostr);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"@@c:\"\n\t\tif (each[1] == ':') {\n\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n\t\t\tif (arg) {\n\t\t\t\tforeachOffset (core, cmd, arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '=':\n\t\tforeachOffset (core, cmd, str + 1);\n\t\tbreak;\n\tcase 'd':\n\t\tif (each[1] == 'b' && each[2] == 't') {\n\t\t\tut64 oseek = core->offset;\n\t\t\tRDebugFrame *frame;\n\t\t\tRListIter *iter;\n\t\t\tRList *list;\n\t\t\tlist = r_debug_frames (core->dbg, UT64_MAX);\n\t\t\ti = 0;\n\t\t\tr_list_foreach (list, iter, frame) {\n\t\t\t\tswitch (each[3]) {\n\t\t\t\tcase 'b':\n\t\t\t\t\tr_core_seek (core, frame->bp, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tr_core_seek (core, frame->sp, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase 'a':\n\t\t\t\t\tr_core_seek (core, frame->addr, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\tr_cons_newline ();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tr_core_seek (core, oseek, 0);\n\t\t\tr_list_free (list);\n\t\t} else {\n\t\t\teprintf(\"Invalid for-each statement. Use @@=dbt[abs]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'k':\n\t\t/* foreach list of items */\n\t\t{\n\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n\t\tif (out) {\n\t\t\teach = out;\n\t\t\tdo {\n\t\t\t\twhile (*each == ' ') each++;\n\t\t\t\tif (!*each) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr = strchr (each, ' ');\n\t\t\t\tif (str) {\n\t\t\t\t\t*str = '\\0';\n\t\t\t\t\taddr = r_num_math (core->num, each);\n\t\t\t\t\t*str = ' ';\n\t\t\t\t} else {\n\t\t\t\t\taddr = r_num_math (core->num, each);\n\t\t\t\t}\n\t\t\t\t//eprintf (\"; 0x%08\"PFMT64x\":\\n\", addr);\n\t\t\t\teach = str + 1;\n\t\t\t\tr_core_seek (core, addr, 1);\n\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\tr_cons_flush ();\n\t\t\t} while (str != NULL);\n\t\t\tfree (out);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\tif (each[1] == '(') {\n\t\t\tchar cmd2[1024];\n\t\t\t// XXX whats this 999 ?\n\t\t\ti = 0;\n\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n\t\t\t\tif (!core->rcmd->macro.brk_value) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\taddr = core->rcmd->macro._brk_value;\n\t\t\t\tsprintf (cmd2, \"%s @ 0x%08\"PFMT64x\"\", cmd, addr);\n\t\t\t\teprintf (\"0x%08\"PFMT64x\" (%s)\\n\", addr, cmd2);\n\t\t\t\tr_core_seek (core, addr, 1);\n\t\t\t\tr_core_cmd (core, cmd2, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else {\n\t\t\tchar buf[1024];\n\t\t\tchar cmd2[1024];\n\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n\t\t\tif (fd) {\n\t\t\t\tcore->rcmd->macro.counter=0;\n\t\t\t\twhile (!feof (fd)) {\n\t\t\t\t\tbuf[0] = '\\0';\n\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\taddr = r_num_math (core->num, buf);\n\t\t\t\t\teprintf (\"0x%08\"PFMT64x\": %s\\n\", addr, cmd);\n\t\t\t\t\tsprintf (cmd2, \"%s @ 0x%08\"PFMT64x\"\", cmd, addr);\n\t\t\t\t\tr_core_seek (core, addr, 1); // XXX\n\t\t\t\t\tr_core_cmd (core, cmd2, 0);\n\t\t\t\t\tcore->rcmd->macro.counter++;\n\t\t\t\t}\n\t\t\t\tfclose (fd);\n\t\t\t} else {\n\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcore->rcmd->macro.counter = 0;\n\t\tfor (; *each == ' '; each++);\n\t\ti = 0;\n\t\twhile (str[i]) {\n\t\t\tj = i;\n\t\t\tfor (; str[j] && str[j] == ' '; j++); // skip spaces\n\t\t\tfor (i = j; str[i] && str[i] != ' '; i++); // find EOS\n\t\t\tch = str[i];\n\t\t\tstr[i] = '\\0';\n\t\t\tword = strdup (str + j);\n\t\t\tif (!word) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr[i] = ch;\n\t\t\t{\n\t\t\t\tint flagspace = core->flags->space_idx;\n\t\t\t\t/* for all flags in current flagspace */\n\t\t\t\t// XXX: dont ask why, but this only works with _prev..\n\t\t\t\tr_list_foreach (core->flags->flags, iter, flag) {\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* filter per flag spaces */\n\t\t\t\t\tif ((flagspace != -1) && (flag->space != flagspace)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (r_str_glob (flag->name, word)) {\n\t\t\t\t\t\tchar *buf = NULL;\n\t\t\t\t\t\tconst char *tmp = NULL;\n\t\t\t\t\t\tr_core_seek (core, flag->offset, 1);\n\t\t\t\t\t\tr_cons_push ();\n\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\t\ttmp = r_cons_get_buffer ();\n\t\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n\t\t\t\t\t\tr_cons_pop ();\n\t\t\t\t\t\tr_cons_strcat (buf);\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcore->flags->space_idx = flagspace;\n\t\t\t\tcore->rcmd->macro.counter++ ;\n\t\t\t\tfree (word);\n\t\t\t\tword = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\t// XXX: use r_core_seek here\n\tcore->offset = oseek;\n\n\tfree (word);\n\tfree (ostr);\n\treturn true;\nout_finish:\n\tr_cons_break_pop ();\n\treturn false;\n}\n\nR_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n\tchar *cmd, *ocmd, *ptr, *rcmd;\n\tint ret = false, i;\n\n\tr_th_lock_enter (core->lock);\n\tif (core->cmdfilter) {\n\t\tconst char *invalid_chars = \";|>`@\";\n\t\tfor (i = 0; invalid_chars[i]; i++) {\n\t\t\tif (strchr (cstr, invalid_chars[i])) {\n\t\t\t\tret = true;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n\t\t\tret = true;\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (core->cmdremote) {\n\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n\t\t\tr_io_system (core->io, cstr);\n\t\t\tgoto beach; // false\n\t\t}\n\t}\n\n\tif (!cstr || *cstr == '|') {\n\t\t// raw comment syntax\n\t\tgoto beach; // false;\n\t}\n\tif (!strncmp (cstr, \"/*\", 2)) {\n\t\tif (r_sandbox_enable (0)) {\n\t\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\t\tgoto beach; // false\n\t\t}\n\t\tcore->incomment = true;\n\t} else if (!strncmp (cstr, \"*/\", 2)) {\n\t\tcore->incomment = false;\n\t\tgoto beach; // false\n\t}\n\tif (core->incomment) {\n\t\tgoto beach; // false\n\t}\n\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n\t\tfree (core->lastcmd);\n\t\tcore->lastcmd = strdup (cstr);\n\t}\n\n\tocmd = cmd = malloc (strlen (cstr) + 4096);\n\tif (!ocmd) {\n\t\tgoto beach;\n\t}\n\tr_str_cpy (cmd, cstr);\n\tif (log) {\n\t\tr_line_hist_add (cstr);\n\t}\n\n\tif (core->cmd_depth < 1) {\n\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n\t\tfree (ocmd);\n\t\tfree (core->oobi);\n\t\tcore->oobi = NULL;\n\t\tcore->oobi_len = 0;\n\t\tgoto beach;\n\t}\n\tcore->cmd_depth--;\n\tfor (rcmd = cmd;;) {\n\t\tptr = strchr (rcmd, '\\n');\n\t\tif (ptr) {\n\t\t\t*ptr = '\\0';\n\t\t}\n\t\tret = r_core_cmd_subst (core, rcmd);\n\t\tif (ret == -1) {\n\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n\t\t\tbreak;\n\t\t}\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\trcmd = ptr + 1;\n\t}\n\tr_th_lock_leave (core->lock);\n\t/* run pending analysis commands */\n\tif (core->anal->cmdtail) {\n\t\tchar *res = core->anal->cmdtail;\n\t\tcore->anal->cmdtail = NULL;\n\t\tr_core_cmd_lines (core, res);\n\t\tfree (res);\n\t}\n\tcore->cmd_depth++;\n\tfree (ocmd);\n\tfree (core->oobi);\n\tcore->oobi = NULL;\n\tcore->oobi_len = 0;\n\treturn ret;\nbeach:\n\tr_th_lock_leave (core->lock);\n\t/* run pending analysis commands */\n\tif (core->anal->cmdtail) {\n\t\tchar *res = core->anal->cmdtail;\n\t\tcore->anal->cmdtail = NULL;\n\t\tr_core_cmd0 (core, res);\n\t\tfree (res);\n\t}\n\treturn ret;\n}\n\nR_API int r_core_cmd_lines(RCore *core, const char *lines) {\n\tint r, ret = true;\n\tchar *nl, *data, *odata;\n\n\tif (!lines || !*lines) {\n\t\treturn true;\n\t}\n\tdata = odata = strdup (lines);\n\tif (!odata) {\n\t\treturn false;\n\t}\n\tnl = strchr (odata, '\\n');\n\tif (nl) {\n\t\tr_cons_break_push (NULL, NULL);\n\t\tdo {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tfree (odata);\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t*nl = '\\0';\n\t\t\tr = r_core_cmd (core, data, 0);\n\t\t\tif (r < 0) { //== -1) {\n\t\t\t\tdata = nl + 1;\n\t\t\t\tret = -1; //r; //false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_cons_flush ();\n\t\t\tif (data[0] == 'q') {\n\t\t\t\tif (data[1] == '!') {\n\t\t\t\t\tret = -1;\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"'q': quit ignored. Use 'q!'\\n\");\n\t\t\t\t}\n\t\t\t\tdata = nl + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata = nl + 1;\n\t\t} while ((nl = strchr (data, '\\n')));\n\t\tr_cons_break_pop ();\n\t}\n\tif (ret >= 0 && data && *data) {\n\t\tr_core_cmd (core, data, 0);\n\t}\n\tfree (odata);\n\treturn ret;\n}\n\nR_API int r_core_cmd_file(RCore *core, const char *file) {\n\tchar *data, *odata;\n\tdata = r_file_abspath (file);\n\tif (!data) return false;\n\todata = r_file_slurp (data, NULL);\n\tfree (data);\n\tif (!odata) return false;\n\tif (!r_core_cmd_lines (core, odata)) {\n\t\teprintf (\"Failed to run script '%s'\\n\", file);\n\t\tfree (odata);\n\t\treturn false;\n\t}\n\tfree (odata);\n\treturn true;\n}\n\nR_API int r_core_cmd_command(RCore *core, const char *command) {\n\tint ret, len;\n\tchar *buf, *rcmd, *ptr;\n\tchar *cmd = r_core_sysenv_begin (core, command);\n\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n\tif (!buf) {\n\t\tfree (cmd);\n\t\treturn -1;\n\t}\n\tret = r_core_cmd (core, rcmd, 0);\n\tr_core_sysenv_end (core, command);\n\tfree (buf);\n\treturn ret;\n}\n\n//TODO: Fix disasm loop is mandatory\nR_API char *r_core_disassemble_instr(RCore *core, ut64 addr, int l) {\n\tchar *cmd, *ret = NULL;\n\tcmd = r_str_newf (\"pd %i @ 0x%08\"PFMT64x, l, addr);\n\tif (cmd) {\n\t\tret = r_core_cmd_str (core, cmd);\n\t\tfree (cmd);\n\t}\n\treturn ret;\n}\n\nR_API char *r_core_disassemble_bytes(RCore *core, ut64 addr, int b) {\n\tchar *cmd, *ret = NULL;\n\tcmd = r_str_newf (\"pD %i @ 0x%08\"PFMT64x, b, addr);\n\tif (cmd) {\n\t\tret = r_core_cmd_str (core, cmd);\n\t\tfree (cmd);\n\t}\n\treturn ret;\n}\n\nR_API int r_core_cmd_buffer(void *user, const char *buf) {\n\tchar *ptr, *optr, *str = strdup (buf);\n\tif (!str) return false;\n\toptr = str;\n\tptr = strchr (str, '\\n');\n\twhile (ptr) {\n\t\t*ptr = '\\0';\n\t\tr_core_cmd (user, optr, 0);\n\t\toptr = ptr + 1;\n\t\tptr = strchr (str, '\\n');\n\t}\n\tr_core_cmd (user, optr, 0);\n\tfree (str);\n\treturn true;\n}\n\nR_API int r_core_cmdf(void *user, const char *fmt, ...) {\n\tchar string[4096];\n\tint ret;\n\tva_list ap;\n\tva_start (ap, fmt);\n\tvsnprintf (string, sizeof (string), fmt, ap);\n\tret = r_core_cmd ((RCore *)user, string, 0);\n\tva_end (ap);\n\treturn ret;\n}\n\nR_API int r_core_cmd0(void *user, const char *cmd) {\n\treturn r_core_cmd ((RCore *)user, cmd, 0);\n}\n\nR_API int r_core_flush(void *user, const char *cmd) {\n\tint ret = r_core_cmd ((RCore *)user, cmd, 0);\n\tr_cons_flush ();\n\treturn ret;\n}\n\nR_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n\tchar *s, *tmp = NULL;\n\tif (r_sandbox_enable (0)) {\n\t\treturn r_core_cmd_str (core, cmd);\n\t}\n\tr_cons_reset ();\n\tr_sandbox_disable (1);\n\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n\t\tif (pipefd == -1) {\n\t\t\tr_sandbox_disable (0);\n\t\t\treturn r_core_cmd_str (core, cmd);\n\t\t}\n\t\tchar *_cmd = strdup (cmd);\n\t\tr_core_cmd_subst (core, _cmd);\n\t\tr_cons_flush ();\n\t\tr_cons_pipe_close (pipefd);\n\t\ts = r_file_slurp (tmp, NULL);\n\t\tif (s) {\n\t\t\tr_file_rm (tmp);\n\t\t\tr_sandbox_disable (0);\n\t\t\tfree (tmp);\n\t\t\tfree (_cmd);\n\t\t\treturn s;\n\t\t}\n\t\teprintf (\"slurp %s fails\\n\", tmp);\n\t\tr_file_rm (tmp);\n\t\tfree (tmp);\n\t\tfree (_cmd);\n\t\tr_sandbox_disable (0);\n\t\treturn r_core_cmd_str (core, cmd);\n\t}\n\tr_sandbox_disable (0);\n\treturn NULL;\n}\n\nR_API char *r_core_cmd_strf(RCore *core, const char *fmt, ...) {\n\tchar string[4096];\n\tchar *ret;\n\tva_list ap;\n\tva_start (ap, fmt);\n\tvsnprintf (string, sizeof (string), fmt, ap);\n\tret = r_core_cmd_str (core, string);\n\tva_end (ap);\n\treturn ret;\n}\n\n/* return: pointer to a buffer with the output of the command */\nR_API char *r_core_cmd_str(RCore *core, const char *cmd) {\n\tconst char *static_str;\n\tchar *retstr = NULL;\n\tr_cons_push ();\n\tif (r_core_cmd (core, cmd, 0) == -1) {\n\t\t//eprintf (\"Invalid command: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tr_cons_filter ();\n\tstatic_str = r_cons_get_buffer ();\n\tretstr = strdup (static_str? static_str: \"\");\n\tr_cons_pop ();\n\treturn retstr;\n}\n\nR_API void r_core_cmd_repeat(RCore *core, int next) {\n\t// Fix for backtickbug px`~`\n\tif (core->cmd_depth + 1 < R_CORE_CMD_DEPTH)\n\t\treturn;\n\tif (core->lastcmd)\n\tswitch (*core->lastcmd) {\n\tcase '.':\n\t\tif (core->lastcmd[1] == '(') // macro call\n\t\t\tr_core_cmd0 (core, core->lastcmd);\n\t\tbreak;\n\tcase 'd': // debug\n\t\tr_core_cmd0 (core, core->lastcmd);\n\t\tswitch (core->lastcmd[1]) {\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\tr_core_cmd0 (core, \"sr PC;pd 1\");\n\t\t}\n\t\tbreak;\n\tcase 'p': // print\n\tcase 'x':\n\tcase '$':\n\t\tif (next) {\n\t\t\tr_core_seek (core, core->offset + core->blocksize, 1);\n\t\t} else {\n\t\t\tif (core->blocksize > core->offset) {\n\t\t\t\tr_core_seek (core, 0, 1);\n\t\t\t} else {\n\t\t\t\tr_core_seek (core, core->offset - core->blocksize, 1);\n\t\t\t}\n\t\t}\n\t\tr_core_cmd0 (core, core->lastcmd);\n\t\tbreak;\n\t}\n}\n\nstatic int cmd_ox(void *data, const char *input) {\n\treturn r_core_cmdf ((RCore*)data, \"s 0%s\", input);\n}\n\nR_API void r_core_cmd_init(RCore *core) {\n\tcore->rcmd = r_cmd_new ();\n\tcore->rcmd->macro.user = core;\n\tcore->rcmd->macro.num = core->num;\n\tcore->rcmd->macro.cmd = r_core_cmd0;\n\tcore->rcmd->nullcallback = r_core_cmd_nullcallback;\n\tcore->rcmd->macro.cb_printf = (PrintfCallback)r_cons_printf;\n\tr_cmd_set_data (core->rcmd, core);\n\tr_cmd_add (core->rcmd, \"0x\",       \"alias for px\", &cmd_ox);\n\tr_cmd_add (core->rcmd, \"x\",        \"alias for px\", &cmd_hexdump);\n\tr_cmd_add (core->rcmd, \"mount\",    \"mount filesystem\", &cmd_mount);\n\tr_cmd_add (core->rcmd, \"analysis\", \"analysis\", &cmd_anal);\n\tr_cmd_add (core->rcmd, \"flag\",     \"get/set flags\", &cmd_flag);\n\tr_cmd_add (core->rcmd, \"g\",        \"egg manipulation\", &cmd_egg);\n\tr_cmd_add (core->rcmd, \"debug\",    \"debugger operations\", &cmd_debug);\n\tr_cmd_add (core->rcmd, \"ls\",       \"list files and directories\", &cmd_ls);\n\tr_cmd_add (core->rcmd, \"info\",     \"get file info\", &cmd_info);\n\tr_cmd_add (core->rcmd, \"cmp\",      \"compare memory\", &cmd_cmp);\n\tr_cmd_add (core->rcmd, \"seek\",     \"seek to an offset\", &cmd_seek);\n\tr_cmd_add (core->rcmd, \"Text\",     \"Text log utility\", &cmd_log);\n\tr_cmd_add (core->rcmd, \"t\",        \"type information (cparse)\", &cmd_type);\n\tr_cmd_add (core->rcmd, \"zign\",     \"zignatures\", &cmd_zign);\n\tr_cmd_add (core->rcmd, \"Section\",  \"setup section io information\", &cmd_section);\n\tr_cmd_add (core->rcmd, \"bsize\",    \"change block size\", &cmd_bsize);\n\tr_cmd_add (core->rcmd, \"kuery\",    \"perform sdb query\", &cmd_kuery);\n\tr_cmd_add (core->rcmd, \"eval\",     \"evaluate configuration variable\", &cmd_eval);\n\tr_cmd_add (core->rcmd, \"print\",    \"print current block\", &cmd_print);\n\tr_cmd_add (core->rcmd, \"write\",    \"write bytes\", &cmd_write);\n\tr_cmd_add (core->rcmd, \"Code\",     \"code metadata\", &cmd_meta);\n\tr_cmd_add (core->rcmd, \"Project\",  \"project\", &cmd_project);\n\tr_cmd_add (core->rcmd, \"open\",     \"open or map file\", &cmd_open);\n\tr_cmd_add (core->rcmd, \"yank\",     \"yank bytes\", &cmd_yank);\n\tr_cmd_add (core->rcmd, \"resize\",   \"change file size\", &cmd_resize);\n\tr_cmd_add (core->rcmd, \"Visual\",   \"enter visual mode\", &cmd_visual);\n\tr_cmd_add (core->rcmd, \"visual\",   \"enter visual mode\", &cmd_visual);\n\tr_cmd_add (core->rcmd, \"*\",        \"pointer read/write\", &cmd_pointer);\n\tr_cmd_add (core->rcmd, \"&\",        \"threading capabilities\", &cmd_thread);\n\tr_cmd_add (core->rcmd, \"%\",        \"short version of 'env' command\", &cmd_env);\n\tr_cmd_add (core->rcmd, \"!\",        \"run system command\", &cmd_system);\n\tr_cmd_add (core->rcmd, \"=\",        \"io pipe\", &cmd_rap);\n\tr_cmd_add (core->rcmd, \"\\\\\",       \"alias for =!\", &cmd_rap_run);\n\tr_cmd_add (core->rcmd, \"#\",        \"calculate hash\", &cmd_hash);\n\tr_cmd_add (core->rcmd, \"?\",        \"help message\", &cmd_help);\n\tr_cmd_add (core->rcmd, \"$\",        \"alias\", &cmd_alias);\n\tr_cmd_add (core->rcmd, \".\",        \"interpret\", &cmd_interpret);\n\tr_cmd_add (core->rcmd, \"/\",        \"search kw, pattern aes\", &cmd_search);\n\tr_cmd_add (core->rcmd, \"-\",        \"open cfg.editor and run script\", &cmd_stdin);\n\tr_cmd_add (core->rcmd, \"(\",        \"macro\", &cmd_macro);\n\tr_cmd_add (core->rcmd, \"u\",        \"uname/undo\", &cmd_uname);\n\tr_cmd_add (core->rcmd, \"quit\",     \"exit program session\", &cmd_quit);\n\tr_cmd_add (core->rcmd, \"Q\",        \"alias for q!\", &cmd_Quit);\n\tr_cmd_add (core->rcmd, \"L\",        \"manage dynamically loaded plugins\", &cmd_plugins);\n}\n", "/* radare - LGPL - Copyright 2009-2017 - pancake */\n\n#include <string.h>\n#include \"r_bin.h\"\n#include \"r_config.h\"\n#include \"r_cons.h\"\n#include \"r_core.h\"\n\n#define PAIR_WIDTH 9\n// TODO: reuse implementation in core/bin.c\nstatic void pair(const char *a, const char *b) {\n\tchar ws[16];\n\tint al = strlen (a);\n\tif (!b) {\n\t\treturn;\n\t}\n\tmemset (ws, ' ', sizeof (ws));\n\tal = PAIR_WIDTH - al;\n\tif (al < 0) {\n\t\tal = 0;\n\t}\n\tws[al] = 0;\n\tr_cons_printf (\"%s%s%s\\n\", a, ws, b);\n}\n\nstatic bool demangle_internal(RCore *core, const char *lang, const char *s) {\n\tchar *res = NULL;\n\tint type = r_bin_demangle_type (lang);\n\tswitch (type) {\n\tcase R_BIN_NM_CXX: res = r_bin_demangle_cxx (core->bin->cur, s, 0); break;\n\tcase R_BIN_NM_JAVA: res = r_bin_demangle_java (s); break;\n\tcase R_BIN_NM_OBJC: res = r_bin_demangle_objc (NULL, s); break;\n\tcase R_BIN_NM_SWIFT: res = r_bin_demangle_swift (s, core->bin->demanglercmd); break;\n\tcase R_BIN_NM_DLANG: res = r_bin_demangle_plugin (core->bin, \"dlang\", s); break;\n\tdefault:\n\t\tr_bin_demangle_list (core->bin);\n\t\treturn true;\n\t}\n\tif (res) {\n\t\tif (*res) {\n\t\t\tprintf (\"%s\\n\", res);\n\t\t}\n\t\tfree (res);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int demangle(RCore *core, const char *s) {\n\tchar *p, *q;\n\tconst char *ss = strchr (s, ' ');\n\tif (!*s) {\n\t\treturn 0;\n\t}\n\tif (!ss) {\n\t\tconst char *lang = r_config_get (core->config, \"bin.lang\");\n\t\tdemangle_internal (core, lang, s);\n\t\treturn 1;\n\t}\n\tp = strdup (s);\n\tq = p + (ss - s);\n\t*q = 0;\n\tdemangle_internal (core, p, q + 1);\n\tfree (p);\n\treturn 1;\n}\n\n#define STR(x) (x)? (x): \"\"\nstatic void r_core_file_info(RCore *core, int mode) {\n\tconst char *fn = NULL;\n\tint dbg = r_config_get_i (core->config, \"cfg.debug\");\n\tbool io_cache = r_config_get_i (core->config, \"io.cache\");\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tRCoreFile *cf = core->file;\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (binfile);\n\tif (mode == R_CORE_BIN_JSON) {\n\t\tr_cons_printf (\"{\");\n\t}\n\tif (mode == R_CORE_BIN_RADARE) {\n\t\treturn;\n\t}\n\tif (mode == R_CORE_BIN_SIMPLE) {\n\t\treturn;\n\t}\n\tif (info) {\n\t\tfn = info->file;\n\t\tif (mode == R_CORE_BIN_JSON) {\n\t\t\tr_cons_printf (\"\\\"type\\\":\\\"%s\\\"\", STR (info->type));\n\t\t}\n\t} else {\n\t\tfn = (cf && cf->desc)? cf->desc->name: NULL;\n\t}\n\tif (cf && mode == R_CORE_BIN_JSON) {\n\t\tconst char *uri = fn;\n\t\tif (!uri) {\n\t\t\tif (cf->desc && cf->desc->uri && *cf->desc->uri) {\n\t\t\t\turi = cf->desc->uri;\n\t\t\t} else {\n\t\t\t\turi = \"\";\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tchar *escapedFile = r_str_utf16_encode (uri, -1);\n\t\t\tr_cons_printf (\",\\\"file\\\":\\\"%s\\\"\", escapedFile);\n\t\t\tfree (escapedFile);\n\t\t}\n\t\tif (dbg) {\n\t\t\tdbg = R_IO_WRITE | R_IO_EXEC;\n\t\t}\n\t\tif (cf->desc) {\n\t\t\tut64 fsz = r_io_desc_size (core->io, cf->desc);\n\t\t\tr_cons_printf (\",\\\"fd\\\":%d\", cf->desc->fd);\n\t\t\tif (fsz != UT64_MAX) {\n\t\t\t\tr_cons_printf (\",\\\"size\\\":%\"PFMT64d, fsz);\n\t\t\t\tchar *humansz = r_num_units (NULL, fsz);\n\t\t\t\tif (humansz) {\n\t\t\t\t\tr_cons_printf (\",\\\"humansz\\\":\\\"%s\\\"\", humansz);\n\t\t\t\t\tfree (humansz);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\",\\\"iorw\\\":%s\", r_str_bool ( io_cache ||\\\n\t\t\t\t\tcf->desc->flags & R_IO_WRITE ));\n\t\t\tr_cons_printf (\",\\\"mode\\\":\\\"%s\\\"\", r_str_rwx_i (\n\t\t\t\t\tcf->desc->flags & 7 ));\n\t\t\tr_cons_printf (\",\\\"obsz\\\":%\"PFMT64d, (ut64) core->io->desc->obsz);\n\t\t\tif (cf->desc->referer && *cf->desc->referer) {\n\t\t\t\tr_cons_printf (\",\\\"referer\\\":\\\"%s\\\"\", cf->desc->referer);\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\",\\\"block\\\":%d\", core->blocksize);\n\t\tif (binfile) {\n\t\t\tif (binfile->curxtr) {\n\t\t\t\tr_cons_printf (\",\\\"packet\\\":\\\"%s\\\"\",\n\t\t\t\t\tbinfile->curxtr->name);\n\t\t\t}\n\t\t\tif (plugin) {\n\t\t\t\tr_cons_printf (\",\\\"format\\\":\\\"%s\\\"\",\n\t\t\t\t\tplugin->name);\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\"}\");\n\t} else if (cf && mode != R_CORE_BIN_SIMPLE) {\n\t\t//r_cons_printf (\"# Core file info\\n\");\n\t\tif (dbg) {\n\t\t\tdbg = R_IO_WRITE | R_IO_EXEC;\n\t\t}\n\t\tif (cf->desc) {\n\t\t\tpair (\"blksz\", sdb_fmt (0, \"0x%\"PFMT64x, (ut64) core->io->desc->obsz));\n\t\t}\n\t\tpair (\"block\", sdb_fmt (0, \"0x%x\", core->blocksize));\n\t\tif (cf->desc) {\n\t\t\tpair (\"fd\", sdb_fmt (0, \"%d\", cf->desc->fd));\n\t\t}\n\t\tif (fn || (cf->desc && cf->desc->uri)) {\n\t\t\tpair (\"file\", fn? fn: cf->desc->uri);\n\t\t}\n\t\tif (plugin) {\n\t\t\tpair (\"format\", plugin->name);\n\t\t}\n\t\tif (cf->desc) {\n\t\t\tpair (\"iorw\", r_str_bool (io_cache || cf->desc->flags & R_IO_WRITE ));\n\t\t\tpair (\"mode\", r_str_rwx_i (cf->desc->flags & 7));\n\t\t}\n\t\tif (binfile && binfile->curxtr) {\n\t\t\tpair (\"packet\", binfile->curxtr->name);\n\t\t}\n\t\tif (cf->desc && cf->desc->referer && *cf->desc->referer) {\n\t\t\tpair (\"referer\", cf->desc->referer);\n\t\t}\n\t\tif (cf->desc) {\n\t\t\tut64 fsz = r_io_desc_size (core->io, cf->desc);\n\t\t\tif (fsz != UT64_MAX) {\n\t\t\t\tpair (\"size\", sdb_fmt (0,\"0x%\"PFMT64x, fsz));\n\t\t\t\tchar *humansz = r_num_units (NULL, fsz);\n\t\t\t\tif (humansz) {\n\t\t\t\t\tpair (\"humansz\", humansz);\n\t\t\t\t\tfree (humansz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (info) {\n\t\t\tpair (\"type\", info->type);\n\t\t}\n\t}\n}\n\nstatic int bin_is_executable(RBinObject *obj){\n\tRListIter *it;\n\tRBinSection *sec;\n\tif (obj) {\n\t\tif (obj->info && obj->info->arch) {\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (obj->sections, it, sec){\n\t\t\tif (R_BIN_SCN_EXECUTABLE & sec->srwx) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void cmd_info_bin(RCore *core, int va, int mode) {\n\tRBinObject *obj = r_bin_cur_object (core->bin);\n\tint array = 0;\n\tif (core->file) {\n\t\tif ((mode & R_CORE_BIN_JSON) && !(mode & R_CORE_BIN_ARRAY)) {\n\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\tr_cons_printf (\"{\\\"core\\\":\");\n\t\t}\n\t\tif ((mode & R_CORE_BIN_JSON) && (mode & R_CORE_BIN_ARRAY)) {\n\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\tarray = 1;\n\t\t\tr_cons_printf (\",\\\"core\\\":\");\n\t\t}\n\t\tr_core_file_info (core, mode);\n\t\tif (bin_is_executable (obj)) {\n\t\t\tif ((mode & R_CORE_BIN_JSON)) {\n\t\t\t\tr_cons_printf (\",\\\"bin\\\":\");\n\t\t\t}\n\t\t\tr_core_bin_info (core, R_CORE_BIN_ACC_INFO, mode, va, NULL, NULL);\n\t\t}\n\t\tif (mode == R_CORE_BIN_JSON && array == 0) {\n\t\t\tr_cons_printf (\"}\\n\");\n\t\t}\n\t} else {\n\t\teprintf (\"No file selected\\n\");\n\t}\n}\n\nstatic void playMsg(RCore *core, const char *n, int len) {\n\tif (r_config_get_i (core->config, \"scr.tts\")) {\n\t\tif (len > 0) {\n\t\t\tchar *s = r_str_newf (\"%d %s\", len, n);\n\t\t\tr_sys_tts (s, true);\n\t\t\tfree (s);\n\t\t} else if (len == 0) {\n\t\t\tchar *s = r_str_newf (\"there are no %s\", n);\n\t\t\tr_sys_tts (s, true);\n\t\t\tfree (s);\n\t\t}\n\t}\n}\n\nstatic int cmd_info(void *data, const char *input) {\n\tRCore *core = (RCore *) data;\n\tbool newline = r_config_get_i (core->config, \"scr.interactive\");\n\tRBinObject *o = r_bin_cur_object (core->bin);\n\tRCoreFile *cf = core->file;\n\tint i, va = core->io->va || core->io->debug;\n\tint mode = 0; //R_CORE_BIN_SIMPLE;\n\tint is_array = 0;\n\tSdb *db;\n\n\tfor (i = 0; input[i] && input[i] != ' '; i++)\n\t\t;\n\tif (i > 0) {\n\t\tswitch (input[i - 1]) {\n\t\tcase '*': mode = R_CORE_BIN_RADARE; break;\n\t\tcase 'j': mode = R_CORE_BIN_JSON; break;\n\t\tcase 'q': mode = R_CORE_BIN_SIMPLE; break;\n\t\t}\n\t}\n\n\tif (mode == R_CORE_BIN_JSON) {\n\t\tif (strlen (input + 1) > 1) {\n\t\t\tis_array = 1;\n\t\t}\n\t}\n\tif (is_array) {\n\t\tr_cons_printf (\"{\");\n\t}\n\tif (!*input) {\n\t\tcmd_info_bin (core, va, mode);\n\t}\n\t/* i* is an alias for iI* */\n\tif (!strcmp (input, \"*\")) {\n\t\tinput = \"I*\";\n\t}\n\tRBinObject *obj = r_bin_cur_object (core->bin);\n\twhile (*input) {\n\t\tswitch (*input) {\n\t\tcase 'b': // \"ib\"\n\t\t{\n\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tbaddr = r_num_math (core->num, input + 1);\n\t\t\t}\n\t\t\t// XXX: this will reload the bin using the buffer.\n\t\t\t// An assumption is made that assumes there is an underlying\n\t\t\t// plugin that will be used to load the bin (e.g. malloc://)\n\t\t\t// TODO: Might be nice to reload a bin at a specified offset?\n\t\t\tr_core_bin_reload (core, NULL, baddr);\n\t\t\tr_core_block_read (core);\n\t\t\tnewline = false;\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t\tdb = o? o->kv: NULL;\n\t\t\t//:eprintf (\"db = %p\\n\", db);\n\t\t\tswitch (input[1]) {\n\t\t\tcase 'v':\n\t\t\t\tif (db) {\n\t\t\t\t\tchar *o = sdb_querys (db, NULL, 0, input + 3);\n\t\t\t\t\tif (o && *o) {\n\t\t\t\t\t\tr_cons_print (o);\n\t\t\t\t\t}\n\t\t\t\t\tfree (o);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tr_core_bin_export_info_rad (core);\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\tcase ' ':\n\t\t\t\tif (db) {\n\t\t\t\t\tchar *o = sdb_querys (db, NULL, 0, input + 2);\n\t\t\t\t\tif (o && *o) {\n\t\t\t\t\t\tr_cons_print (o);\n\t\t\t\t\t}\n\t\t\t\t\tfree (o);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\0':\n\t\t\t\tif (db) {\n\t\t\t\t\tchar *o = sdb_querys (db, NULL, 0, \"*\");\n\t\t\t\t\tif (o && *o) {\n\t\t\t\t\t\tr_cons_print (o);\n\t\t\t\t\t}\n\t\t\t\t\tfree (o);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\teprintf (\"Usage: ik [sdb-query]\\n\");\n\t\t\t\teprintf (\"Usage: ik*    # load all header information\\n\");\n\t\t\t}\n\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t{\n\t\t\tif (!cf) {\n\t\t\t\teprintf (\"Core file not open\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst char *fn = input[1] == ' '? input + 2: cf->desc->name;\n\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\tr_core_bin_load (core, fn, baddr);\n\t\t}\n\t\tbreak;\n\t\t\t#define RBININFO(n,x,y,z)\\\n\t\t\t\tif (is_array) {\\\n\t\t\t\t\tif (is_array == 1) { is_array++;\\\n\t\t\t\t\t} else { r_cons_printf (\",\");}\\\n\t\t\t\t\tr_cons_printf (\"\\\"%s\\\":\",n);\\\n\t\t\t\t}\\\n\t\t\t\tif (z) { playMsg (core, n, z);}\\\n\t\t\t\tr_core_bin_info (core, x, mode, va, NULL, y);\n\t\tcase 'A':\n\t\t\tnewline = false;\n\t\t\tif (input[1] == 'j') {\n\t\t\t\tr_cons_printf (\"{\");\n\t\t\t\tr_bin_list_archs (core->bin, 'j');\n\t\t\t\tr_cons_printf (\"}\\n\");\n\t\t\t} else {\n\t\t\t\tr_bin_list_archs (core->bin, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'E': RBININFO (\"exports\", R_CORE_BIN_ACC_EXPORTS, NULL, 0); break;\n\t\tcase 'Z': RBININFO (\"size\", R_CORE_BIN_ACC_SIZE, NULL, 0); break;\n\t\tcase 'S':\n\t\t\t//we comes from ia or iS\n\t\t\tif ((input[1] == 'm' && input[2] == 'z') || !input[1]) {\n\t\t\t\tRBININFO (\"sections\", R_CORE_BIN_ACC_SECTIONS, NULL, 0);\n\t\t\t} else {  //iS entropy,sha1\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tif (mode == R_CORE_BIN_RADARE || mode == R_CORE_BIN_JSON || mode == R_CORE_BIN_SIMPLE) {\n\t\t\t\t\tRBININFO (\"sections\", R_CORE_BIN_ACC_SECTIONS, input + 2,\n\t\t\t\t\t\tobj? r_list_length (obj->sections): 0);\n\t\t\t\t} else {\n\t\t\t\t\tRBININFO (\"sections\", R_CORE_BIN_ACC_SECTIONS, input + 1,\n\t\t\t\t\t\tobj? r_list_length (obj->sections): 0);\n\t\t\t\t}\n\t\t\t\t//we move input until get '\\0'\n\t\t\t\twhile (*(++input)) ;\n\t\t\t\t//input-- because we are inside a while that does input++\n\t\t\t\t// oob read if not input--\n\t\t\t\tinput--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tif (input[1] == 'H') { // \"iHH\"\n\t\t\t\tRBININFO (\"header\", R_CORE_BIN_ACC_HEADER, NULL, -1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 'h': RBININFO (\"fields\", R_CORE_BIN_ACC_FIELDS, NULL, 0); break;\n\t\tcase 'l': RBININFO (\"libs\", R_CORE_BIN_ACC_LIBS, NULL, obj? r_list_length (obj->libs): 0); break;\n\t\tcase 'L':\n\t\t{\n\t\t\tchar *ptr = strchr (input, ' ');\n\t\t\tint json = input[1] == 'j'? 'j': 0;\n\n\t\t\tif (ptr && ptr[1]) {\n\t\t\t\tconst char *plugin_name = ptr + 1;\n\t\t\t\tif (is_array) {\n\t\t\t\t\tr_cons_printf (\"\\\"plugin\\\": \");\n\t\t\t\t}\n\t\t\t\tr_bin_list_plugin (core->bin, plugin_name, json);\n\t\t\t} else {\n\t\t\t\tr_bin_list (core->bin, json);\n\t\t\t}\n\n\t\t\tnewline = false;\n\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t\tcase 's':\n\t\t\tif (input[1] == '.') {\n\t\t\t\tut64 addr = core->offset + (core->print->cur_enabled? core->print->cur: 0);\n\t\t\t\tRFlagItem *f = r_flag_get_at (core->flags, addr, false);\n\t\t\t\tif (f) {\n\t\t\t\t\tif (f->offset == addr || !f->offset) {\n\t\t\t\t\t\tr_cons_printf (\"%s\", f->name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s+%d\", f->name, (int) (addr - f->offset));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinput++;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tRBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, NULL, obj? r_list_length (obj->symbols): 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 'R': \n\t\t\tif  (input[1] == '*') {\n\t\t\t\tmode = R_CORE_BIN_RADARE;\n\t\t\t} else if (input[1] == 'j') {\n\t\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\t}\n\t\t\tRBININFO (\"resources\", R_CORE_BIN_ACC_RESOURCES, NULL, 0); \n\t\t\tbreak;\n\t\tcase 'r': RBININFO (\"relocs\", R_CORE_BIN_ACC_RELOCS, NULL, 0); break;\n\t\tcase 'd': RBININFO (\"dwarf\", R_CORE_BIN_ACC_DWARF, NULL, -1); break;\n\t\tcase 'i': RBININFO (\"imports\",R_CORE_BIN_ACC_IMPORTS, NULL, obj? r_list_length (obj->imports): 0); break;\n\t\tcase 'I': RBININFO (\"info\", R_CORE_BIN_ACC_INFO, NULL, 0); break;\n\t\tcase 'e': RBININFO (\"entries\", R_CORE_BIN_ACC_ENTRIES, NULL, 0); break;\n\t\tcase 'M': RBININFO (\"main\", R_CORE_BIN_ACC_MAIN, NULL, 0); break;\n\t\tcase 'm': RBININFO (\"memory\", R_CORE_BIN_ACC_MEM, NULL, 0); break;\n\t\tcase 'V': RBININFO (\"versioninfo\", R_CORE_BIN_ACC_VERSIONINFO, NULL, 0); break;\n\t\tcase 'C': RBININFO (\"signature\", R_CORE_BIN_ACC_SIGNATURE, NULL, 0); break;\n\t\tcase 'z':\n\t\t\tif (input[1] == 'z') { //izz\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase '*':\n\t\t\t\t\tmode = R_CORE_BIN_RADARE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'j':\n\t\t\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q': //izzq\n\t\t\t\t\tif (input[3] == 'q') { //izzqq\n\t\t\t\t\t\tmode = R_CORE_BIN_SIMPLEST;\n\t\t\t\t\t\tinput++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmode = R_CORE_BIN_SIMPLE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmode = R_CORE_BIN_PRINT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinput++;\n\t\t\t\tRBININFO (\"strings\", R_CORE_BIN_ACC_RAW_STRINGS, NULL, 0);\n\t\t\t} else {\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tif (input[1] == 'q') {\n\t\t\t\t\tmode = (input[2] == 'q')\n\t\t\t\t\t? R_CORE_BIN_SIMPLEST\n\t\t\t\t\t: R_CORE_BIN_SIMPLE;\n\t\t\t\t\tinput++;\n\t\t\t\t}\n\t\t\t\tif (obj) {\n\t\t\t\t\tRBININFO (\"strings\", R_CORE_BIN_ACC_STRINGS, NULL,\n\t\t\t\t\t\tobj? r_list_length (obj->strings): 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c': // for r2 `ic`\n\t\t\tif (input[1] == '?') {\n\t\t\t\teprintf (\"Usage: ic[ljq*] [class-index or name]\\n\");\n\t\t\t} else if (input[1] == ' ' || input[1] == 'q' || input[1] == 'j' || input[1] == 'l') {\n\t\t\t\tRBinClass *cls;\n\t\t\t\tRBinSymbol *sym;\n\t\t\t\tRListIter *iter, *iter2;\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tif (obj) {\n\t\t\t\t\tif (input[2]) {\n\t\t\t\t\t\tint idx = -1;\n\t\t\t\t\t\tconst char * cls_name = NULL;\n\t\t\t\t\t\tif (r_num_is_valid_input (core->num, input + 2)) {\n\t\t\t\t\t\t\tidx = r_num_math (core->num, input + 2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst char * first_char = input + ((input[1] == ' ') ? 1 : 2);\n\t\t\t\t\t\t\tint not_space = strspn (first_char, \" \");\n\t\t\t\t\t\t\tif (first_char[not_space]) {\n\t\t\t\t\t\t\t\tcls_name = first_char + not_space;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n\t\t\t\t\t\t\tif ((idx >= 0 && idx != count++) ||\n\t\t\t\t\t\t\t   (cls_name && strcmp (cls_name, cls->name) != 0)){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswitch (input[1]) {\n\t\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"f sym.%s @ 0x%\"PFMT64x \"\\n\",\n\t\t\t\t\t\t\t\t\t\tsym->name, sym->vaddr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tinput++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tconst char *comma = iter2->p? \" \": \"\";\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%\"PFMT64d, comma, sym->vaddr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\t\t\tinput++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'j':\n\t\t\t\t\t\t\t\tinput++;\n\t\t\t\t\t\t\t\tr_cons_printf (\"\\\"class\\\":\\\"%s\\\"\", cls->name);\n\t\t\t\t\t\t\t\tr_cons_printf (\",\\\"methods\\\":[\");\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tconst char *comma = iter2->p? \",\": \"\";\n\n\t\t\t\t\t\t\t\t\tif (sym->method_flags) {\n\t\t\t\t\t\t\t\t\t\tchar *flags = r_core_bin_method_flags_str (sym, R_CORE_BIN_JSON);\n\t\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"vaddr\\\":%\"PFMT64d \"}\",\n\t\t\t\t\t\t\t\t\t\t\tcomma, sym->name, flags, sym->vaddr);\n\t\t\t\t\t\t\t\t\t\tR_FREE (flags);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"vaddr\\\":%\"PFMT64d \"}\",\n\t\t\t\t\t\t\t\t\t\t\tcomma, sym->name, sym->vaddr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tr_cons_printf (\"]\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tr_cons_printf (\"class %s\\n\", cls->name);\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tchar *flags = r_core_bin_method_flags_str (sym, 0);\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" method %s %s %s\\n\",\n\t\t\t\t\t\t\t\t\t\tsym->vaddr, cls->name, flags, sym->name);\n\t\t\t\t\t\t\t\t\tR_FREE (flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplayMsg (core, \"classes\", r_list_length (obj->classes));\n\t\t\t\t\t\tif (input[1] == 'l' && obj) { // \"icl\"\n\t\t\t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tconst char *comma = iter2->p? \" \": \"\";\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%\"PFMT64d, comma, sym->vaddr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!r_list_empty (cls->methods)) {\n\t\t\t\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tRBININFO (\"classes\", R_CORE_BIN_ACC_CLASSES, NULL, r_list_length (obj->classes));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tint len = obj? r_list_length (obj->classes): 0;\n\t\t\t\tRBININFO (\"classes\", R_CORE_BIN_ACC_CLASSES, NULL, len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (input[1] != ' ' || !demangle (core, input + 2)) {\n\t\t\t\teprintf (\"|Usage: iD lang symbolname\\n\");\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 'a':\n\t\t\tswitch (mode) {\n\t\t\tcase R_CORE_BIN_RADARE: cmd_info (core, \"iIiecsSmz*\"); break;\n\t\t\tcase R_CORE_BIN_JSON: cmd_info (core, \"iIiecsSmzj\"); break;\n\t\t\tcase R_CORE_BIN_SIMPLE: cmd_info (core, \"iIiecsSmzq\"); break;\n\t\t\tdefault: cmd_info (core, \"IiEecsSmz\"); break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?': {\n\t\t\tconst char *help_message[] = {\n\t\t\t\t\"Usage: i\", \"\", \"Get info from opened file (see rabin2's manpage)\",\n\t\t\t\t\"Output mode:\", \"\", \"\",\n\t\t\t\t\"'*'\", \"\", \"Output in radare commands\",\n\t\t\t\t\"'j'\", \"\", \"Output in json\",\n\t\t\t\t\"'q'\", \"\", \"Simple quiet output\",\n\t\t\t\t\"Actions:\", \"\", \"\",\n\t\t\t\t\"i|ij\", \"\", \"Show info of current file (in JSON)\",\n\t\t\t\t\"iA\", \"\", \"List archs\",\n\t\t\t\t\"ia\", \"\", \"Show all info (imports, exports, sections..)\",\n\t\t\t\t\"ib\", \"\", \"Reload the current buffer for setting of the bin (use once only)\",\n\t\t\t\t\"ic\", \"\", \"List classes, methods and fields\",\n\t\t\t\t\"iC\", \"\", \"Show signature info (entitlements, ...)\",\n\t\t\t\t\"id\", \"\", \"Debug information (source lines)\",\n\t\t\t\t\"iD\", \" lang sym\", \"demangle symbolname for given language\",\n\t\t\t\t\"ie\", \"\", \"Entrypoint\",\n\t\t\t\t\"iE\", \"\", \"Exports (global symbols)\",\n\t\t\t\t\"ih\", \"\", \"Headers (alias for iH)\",\n\t\t\t\t\"iHH\", \"\", \"Verbose Headers in raw text\",\n\t\t\t\t\"ii\", \"\", \"Imports\",\n\t\t\t\t\"iI\", \"\", \"Binary info\",\n\t\t\t\t\"ik\", \" [query]\", \"Key-value database from RBinObject\",\n\t\t\t\t\"il\", \"\", \"Libraries\",\n\t\t\t\t\"iL \", \"[plugin]\", \"List all RBin plugins loaded or plugin details\",\n\t\t\t\t\"im\", \"\", \"Show info about predefined memory allocation\",\n\t\t\t\t\"iM\", \"\", \"Show main address\",\n\t\t\t\t\"io\", \" [file]\", \"Load info from file (or last opened) use bin.baddr\",\n\t\t\t\t\"ir\", \"\", \"Relocs\",\n\t\t\t\t\"iR\", \"\", \"Resources\",\n\t\t\t\t\"is\", \"\", \"Symbols\",\n\t\t\t\t\"iS \", \"[entropy,sha1]\", \"Sections (choose which hash algorithm to use)\",\n\t\t\t\t\"iV\", \"\", \"Display file version info\",\n\t\t\t\t\"iz|izj\", \"\", \"Strings in data sections (in JSON/Base64)\",\n\t\t\t\t\"izz\", \"\", \"Search for Strings in the whole binary\",\n\t\t\t\t\"iZ\", \"\", \"Guess size of binary program\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tr_core_cmd_help (core, help_message);\n\t\t}\n\t\t\tgoto done;\n\t\tcase '*':\n\t\t\tmode = R_CORE_BIN_RADARE;\n\t\t\tgoto done;\n\t\tcase 'q':\n\t\t\tmode = R_CORE_BIN_SIMPLE;\n\t\t\tcmd_info_bin (core, va, mode);\n\t\t\tgoto done;\n\t\tcase 'j':\n\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\tif (is_array > 1) {\n\t\t\t\tmode |= R_CORE_BIN_ARRAY;\n\t\t\t}\n\t\t\tcmd_info_bin (core, va, mode);\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tcmd_info_bin (core, va, mode);\n\t\t\tbreak;\n\t\t}\n\t\tinput++;\n\t\tif ((*input == 'j' || *input == 'q') && !input[1]) {\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tif (is_array) {\n\t\tr_cons_printf (\"}\\n\");\n\t}\n\tif (newline) {\n\t\tr_cons_newline ();\n\t}\n\treturn 0;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2009-2017 - nibble, pancake */\n#if 0\n* Use RList\n* Support callback for null command (why?)\n* Show help of commands\n  - long commands not yet tested at all\n  - added interface to export command list into an autocompletable\n    argc, argv for dietline\n* r_cmd must provide a nesting char table indexing for commands\n  - this is already partially done\n  - this is pretty similar to r_db\n  - every module can register their own commands\n  - commands can be listed like in a tree\n#endif\n\n#define INTERACTIVE_MAX_REP 1024\n\n#include <r_core.h>\n#include <r_anal.h>\n#include <r_cons.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <stdarg.h>\n#if __UNIX__\n#include <sys/utsname.h>\n#endif\n\nstatic void cmd_debug_reg(RCore *core, const char *str);\n#include \"cmd_quit.c\"\n#include \"cmd_hash.c\"\n#include \"cmd_debug.c\"\n#include \"cmd_log.c\"\n#include \"cmd_zign.c\"\n#include \"cmd_section.c\"\n#include \"cmd_flag.c\"\n#include \"cmd_project.c\"\n#include \"cmd_write.c\"\n#include \"cmd_cmp.c\"\n#include \"cmd_eval.c\"\n#include \"cmd_anal.c\"\n#include \"cmd_open.c\"\n#include \"cmd_meta.c\"\n#include \"cmd_type.c\"\n#include \"cmd_egg.c\"\n#include \"cmd_info.c\"\n#include \"cmd_macro.c\"\n#include \"cmd_magic.c\"\n#include \"cmd_mount.c\"\n#include \"cmd_seek.c\"\n#include \"cmd_print.c\"\n#include \"cmd_help.c\"\n#include \"cmd_search.c\"\n\nstatic void recursive_help(RCore *core, const char *cmd) {\n\tchar *nl, *line;\n\tif (strchr (cmd, '[')) {\n\t\t// eprintf (\"Skip ((%s))\\n\", cmd);\n\t\treturn;\n\t}\n\tchar *msg = r_core_cmd_str (core, cmd);\n\tif (!msg) {\n\t\treturn;\n\t}\n\tline = msg;\n\tr_cons_print (msg);\n\t(void) r_str_ansi_filter (msg, NULL, NULL, strlen (msg));\n\tdo {\n\t\tnl = strchr (line, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *help_token = strstr (line, \"[?]\");\n\t\tif (help_token) {\n\t\t\thelp_token[0] = '?';\n\t\t\thelp_token[1] = 0;\n\t\t\tconst char *sp = strchr (line, ' ');\n\t\t\tif (sp) {\n\t\t\t\trecursive_help (core, sp + 1);\n\t\t\t}\n\t\t}\n\t\tline = nl + 1;\n\t} while (nl);\n\tfree (msg);\n}\n\nstatic int r_core_cmd_nullcallback(void *data) {\n\tRCore *core = (RCore*) data;\n\tif (core->cons->breaked) {\n\t\tcore->cons->breaked = false;\n\t\treturn 0;\n\t}\n\tif (!core->cmdrepeat) {\n\t\treturn 0;\n\t}\n\tr_core_cmd_repeat (core, true);\n\treturn 1;\n}\n\n// TODO: move somewhere else\nR_API RAsmOp *r_core_disassemble (RCore *core, ut64 addr) {\n\tint delta;\n\tut8 buf[128];\n\tstatic RBuffer *b = NULL; // XXX: never freed and non-thread safe. move to RCore\n\tRAsmOp *op;\n\tif (!b) {\n\t\tb = r_buf_new ();\n\t\tif (!b || !r_core_read_at (core, addr, buf, sizeof (buf))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tb->base = addr;\n\t\tr_buf_set_bytes (b, buf, sizeof (buf));\n\t} else {\n\t\tif ((addr < b->base) || addr > (b->base + b->length - 32)) {\n\t\t\tif (!r_core_read_at (core, addr, buf, sizeof (buf))) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tb->base = addr;\n\t\t\tr_buf_set_bytes (b, buf, sizeof (buf));\n\t\t}\n\t}\n\tdelta = addr - b->base;\n\top = R_NEW0 (RAsmOp);\n\tr_asm_set_pc (core->assembler, addr);\n\tif (r_asm_disassemble (core->assembler, op, b->buf + delta, b->length) < 1) {\n\t\tfree (op);\n\t\treturn NULL;\n\t}\n\treturn op;\n}\n\nstatic int cmd_uname(void *data, const char *input) {\n\tconst char* help_msg[] = {\n\t\t\"Usage:\", \"u\", \"uname or undo write/seek\",\n\t\t\"u\", \"\", \"show system uname\",\n\t\t\"uw\", \"\", \"alias for wc (requires: e io.cache=true)\",\n\t\t\"us\", \"\", \"alias for s- (seek history)\",\n\t\tNULL};\n\tswitch (input[0]) {\n\tcase '?':\n\t\tr_core_cmd_help (data, help_msg);\n\t\treturn 1;\n\tcase 's':\n\t\tr_core_cmdf (data, \"s-%s\", input + 1);\n\t\treturn 1;\n\tcase 'w':\n\t\tr_core_cmdf (data, \"wc%s\", input + 1);\n\t\treturn 1;\n\t}\n#if __UNIX__\n\tstruct utsname un;\n\tuname (&un);\n\tr_cons_printf (\"%s %s %s %s\\n\", un.sysname,\n\t\tun.nodename, un.release, un.machine);\n#elif __WINDOWS__\n\tr_cons_printf (\"windows\\n\");\n#else\n\tr_cons_printf (\"unknown\\n\");\n#endif\n\treturn 0;\n}\n\nstatic int cmd_alias(void *data, const char *input) {\n\tint i;\n\tchar *def, *q, *desc, *buf;\n\tRCore *core = (RCore *)data;\n\tif (*input == '?') {\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"$alias[=cmd] [args...]\", \"Alias commands\",\n\t\t\t\"$\", \"\", \"list all defined aliases\",\n\t\t\t\"$*\", \"\", \"same as above, but using r2 commands\",\n\t\t\t\"$\", \"dis='af;pdf'\", \"create command - analyze to show function\",\n\t\t\t\"$\", \"test=#!pipe node /tmp/test.js\", \"create command - rlangpipe script\",\n\t\t\t\"$\", \"dis=\", \"undefine alias\",\n\t\t\t\"$\", \"dis\", \"execute the previously defined alias\",\n\t\t\t\"$\", \"dis?\", \"show commands aliased by 'analyze'\",\n\t\t\tNULL};\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\treturn 0;\n\t}\n\ti = strlen (input);\n\tbuf = malloc (i + 2);\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\t*buf = '$'; // prefix aliases with a dash\n\tmemcpy (buf + 1, input, i + 1);\n\tq = strchr (buf, ' ');\n\tdef = strchr (buf, '=');\n\tdesc = strchr (buf, '?');\n\n\t/* create alias */\n\tif ((def && q && (def < q)) || (def && !q)) {\n\t\t*def++ = 0;\n\t\tsize_t len = strlen (def);\n\t\t/* Remove quotes */\n\t\tif ((def[0] == '\\'') && (def[len - 1] == '\\'')) {\n\t\t\tdef[len - 1] = 0x00;\n\t\t\tdef++;\n\t\t}\n\t\tif (!q || (q && q>def)) {\n\t\t\tif (*def) r_cmd_alias_set (core->rcmd, buf, def, 0);\n\t\t\telse r_cmd_alias_del (core->rcmd, buf);\n\t\t}\n\t/* Show command for alias */\n\t} else if (desc && !q) {\n\t\tchar *v;\n\t\t*desc = 0;\n\t\tv = r_cmd_alias_get (core->rcmd, buf, 0);\n\t\tif (v) {\n\t\t\tr_cons_println (v);\n\t\t\tfree (buf);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n\t\t}\n\n\t/* Show aliases */\n\t} else if (buf[1] == '*') {\n\t\tint i, count = 0;\n\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tconst char *v = r_cmd_alias_get (core->rcmd, keys[i], 0);\n\t\t\tr_cons_printf (\"%s=%s\\n\", keys[i], v);\n\t\t}\n\t} else if (!buf[1]) {\n\t\tint i, count = 0;\n\t\tchar **keys = r_cmd_alias_keys (core->rcmd, &count);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tr_cons_println (keys[i]);\n\t\t}\n\t/* Execute alias */\n\t} else {\n\t\tchar *v;\n\t\tif (q) *q = 0;\n\t\tv = r_cmd_alias_get (core->rcmd, buf, 0);\n\t\tif (v) {\n\t\t\tif (q) {\n\t\t\t\tchar *out, *args = q + 1;\n\t\t\t\tout = malloc (strlen (v) + strlen (args) + 2);\n\t\t\t\tif (out) { //XXX slow\n\t\t\t\t\tstrcpy (out, v);\n\t\t\t\t\tstrcat (out, \" \");\n\t\t\t\t\tstrcat (out, args);\n\t\t\t\t\tr_core_cmd0 (core, out);\n\t\t\t\t\tfree (out);\n\t\t\t\t} else eprintf (\"cannot malloc\\n\");\n\t\t\t} else {\n\t\t\t\tr_core_cmd0 (core, v);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"unknown key '%s'\\n\", buf);\n\t\t}\n\t}\n\tfree (buf);\n\treturn 0;\n}\n\nstatic int getArg(char ch, int def) {\n\tswitch (ch) {\n\tcase '&':\n\tcase '-':\n\t\treturn ch;\n\t}\n\treturn def;\n}\n\nstatic void aliascmd(RCore *core, const char *str) {\n\tswitch (str[0]) {\n\tcase '-':\n\t\tif (str[1]) {\n\t\t\tr_cmd_alias_del (core->rcmd, str + 2);\n\t\t} else {\n\t\t\tr_cmd_alias_del (core->rcmd, NULL);\n\t\t//\tr_cmd_alias_reset (core->rcmd);\n\t\t}\n\t\tbreak;\n\tcase '?':\n\t\teprintf (\"Usage: =$[-][remotecmd]  # remote command alias\\n\");\n\t\teprintf (\" =$dr   # makes 'dr' alias for =!dr\\n\");\n\t\teprintf (\" =$-dr  # unset 'dr' alias\\n\");\n\t\tbreak;\n\tcase 0:\n\t\tr_core_cmd0 (core, \"$\");\n\t\tbreak;\n\tdefault:\n\t\tr_cmd_alias_set (core->rcmd, str, \"\", 1);\n\t\tbreak;\n\t}\n}\n\nstatic int cmd_rap(void *data, const char *input) {\n\tRCore *core = (RCore *)data;\n\tswitch (*input) {\n\tcase '$': aliascmd (core, input + 1); break;\n\tcase '\\0': r_core_rtr_list (core); break;\n\tcase 'h':\n\t\tr_core_rtr_http (core, getArg (input[1], 'h'), input + 1);\n\t\tbreak;\n\tcase 'H':\n\t\twhile (input[1] == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tr_core_rtr_http (core, getArg (input[1], 'H'), input + 1);\n\t\tbreak;\n\tcase 'g':\n\t\tr_core_rtr_gdb (core, getArg (input[1], 'g'), input + 1);\n\t\tbreak;\n\tcase '?': r_core_rtr_help (core); break;\n\tcase '+': r_core_rtr_add (core, input + 1); break;\n\tcase '-': r_core_rtr_remove (core, input + 1); break;\n\tcase '=': r_core_rtr_session (core, input + 1); break;\n\t//case ':': r_core_rtr_cmds (core, input + 1); break;\n\tcase '<': r_core_rtr_pushout (core, input + 1); break;\n\tcase '!':\n\t\tif (input[1] == '=') {\n\t\t\t// swap core->cmdremote = core->cmdremote? 0: 1;\n\t\t\tcore->cmdremote = input[2]? 1: 0;\n\t\t\tr_cons_println (r_str_bool (core->cmdremote));\n\t\t} else {\n\t\t\tr_io_system (core->io, input + 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tr_core_rtr_cmd (core, input);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_rap_run(void *data, const char *input) {\n\tRCore *core = (RCore *)data;\n\treturn r_io_system (core->io, input);\n}\n\nstatic int cmd_yank(void *data, const char *input) {\n\tut64 n;\n\tRCore *core = (RCore *)data;\n\tswitch (input[0]) {\n\tcase ' ':\n\t\tr_core_yank (core, core->offset, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 'l':\n\t\tcore->num->value = core->yank_buf->length;\n\t\tbreak;\n\tcase 'y':\n\t\twhile (input[1] == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tn = input[1]? r_num_math (core->num, input + 1): core->offset;\n\t\tr_core_yank_paste (core, n, 0);\n\t\tbreak;\n\tcase 'x':\n\t\tr_core_yank_hexdump (core, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 'z':\n\t\tr_core_yank_string (core, core->offset, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 'w':\n\t\tswitch (input[1]) {\n\t\tcase ' ':\n\t\t\tr_core_yank_set (core, 0, (const ut8*)input + 2, strlen (input + 2));\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tif (input[2] == ' ') {\n\t\t\t\tchar *out = strdup (input + 3);\n\t\t\t\tint len = r_hex_str2bin (input + 3, (ut8*)out);\n\t\t\t\tif (len> 0) {\n\t\t\t\t\tr_core_yank_set (core, 0LL, (const ut8*)out, len);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Invalid length\\n\");\n\t\t\t\t}\n\t\t\t\tfree (out);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: ywx [hexpairs]\\n\");\n\t\t\t}\n\t\t\t// r_core_yank_write_hex (core, input + 2);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'p':\n\t\tr_core_yank_cat (core, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 's':\n\t\tr_core_yank_cat_string (core, r_num_math (core->num, input + 1));\n\t\tbreak;\n\tcase 't': // \"wt\"\n\t\tif (input[1] == 'f') { // \"wtf\"\n\t\t\tconst char *file = r_str_chop_ro (input + 2);\n\t\t\tif (!r_file_dump (file, core->yank_buf->buf, core->yank_buf->length, false)) {\n\t\t\t\teprintf (\"Cannot dump to '%s'\\n\", file);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_yank_to (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase 'f':\n\t\tswitch (input[1]) {\n\t\tcase ' ': // \"wf\"\n\t\t\tr_core_yank_file_ex (core, input + 1);\n\t\t\tbreak;\n\t\tcase 'a': // \"wfa\"\n\t\t\tr_core_yank_file_all (core, input + 2);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_core_yank_dump (core, r_num_math (core->num, \"\"));\n\t\tbreak;\n\tdefault:{\n\t\tconst char* help_msg[] = {\n\t\t\"Usage:\", \"y[ptxy] [len] [[@]addr]\", \" # See wd? for memcpy, same as 'yf'.\",\n\t\t\"y\", \"\", \"show yank buffer information (srcoff len bytes)\",\n\t\t\"y\", \" 16\", \"copy 16 bytes into clipboard\",\n\t\t\"y\", \" 16 0x200\", \"copy 16 bytes into clipboard from 0x200\",\n\t\t\"y\", \" 16 @ 0x200\", \"copy 16 bytes into clipboard from 0x200\",\n\t\t\"yz\", \"\", \"copy up to blocksize zero terminated string bytes into clipboard\",\n\t\t\"yz\", \" 16\", \"copy up to 16 zero terminated string bytes into clipboard\",\n\t\t\"yz\", \" @ 0x200\", \"copy up to blocksize zero terminated string bytes into clipboard from 0x200\",\n\t\t\"yz\", \" 16 @ 0x200\", \"copy up to 16 zero terminated string bytes into clipboard from 0x200\",\n\t\t\"yp\", \"\", \"print contents of clipboard\",\n\t\t\"yx\", \"\", \"print contents of clipboard in hexadecimal\",\n\t\t\"ys\", \"\", \"print contents of clipboard as string\",\n\t\t\"yt\", \" 64 0x200\", \"copy 64 bytes from current seek to 0x200\",\n\t\t\"ytf\", \" file\", \"dump the clipboard to given file\",\n\t\t\"yf\", \" 64 0x200\", \"file copy 64 bytes from 0x200 from file (opens w/ io), use -1 for all bytes\",\n\t\t\"yfa\", \" file copy\", \"copy all bytes from file (opens w/ io)\",\n\t\t\"yy\", \" 0x3344\", \"paste clipboard\",\n\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nR_API int r_core_run_script (RCore *core, const char *file) {\n\tint ret = false;\n\tRListIter *iter;\n\tRLangPlugin *p;\n\tchar *name;\n\n\tr_list_foreach (core->scriptstack, iter, name) {\n\t\tif (!strcmp (file, name)) {\n\t\t\teprintf (\"WARNING: ignored nested source: %s\\n\", file);\n\t\t\treturn false;\n\t\t}\n\t}\n\tr_list_push (core->scriptstack, strdup (file));\n\n\tif (!strcmp (file, \"-\")) {\n\t\tchar *out = r_core_editor (core, NULL, NULL);\n\t\tif (out) {\n\t\t\tret = r_core_cmd_lines (core, out);\n\t\t\tfree (out);\n\t\t}\n\t} else if (r_parse_is_c_file (file)) {\n\t\tchar *out = r_parse_c_file (core->anal, file);\n\t\tif (out) {\n\t\t\tr_cons_strcat (out);\n\t\t\tsdb_query_lines (core->anal->sdb_types, out);\n\t\t\tfree (out);\n\t\t}\n\t\tret = out? true: false;\n\t} else {\n\t\tp = r_lang_get_by_extension (core->lang, file);\n\t\tif (p) {\n\t\t\tr_lang_use (core->lang, p->name);\n\t\t\tret = r_lang_run_file (core->lang, file);\n\t\t} else {\n#if __WINDOWS__\n#define cmdstr(x) r_str_newf (x\" %s\", file);\n#else\n#define cmdstr(x) r_str_newf (x\" '%s'\", file);\n#endif\n\t\t\tconst char *p = r_str_lchr (file, '.');\n\t\t\tif (p) {\n\t\t\t\tconst char *ext = p + 1;\n\t\t\t\t/* TODO: handle this inside r_lang_pipe with new APIs */\n\t\t\t\tif (!strcmp (ext, \"js\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"node\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"exe\")) {\n#if __WINDOWS__\n\t\t\t\t\tchar *cmd = r_str_newf (\"%s\", file);\n#else\n\t\t\t\t\tchar *cmd = cmdstr (\"wine\");\n#endif\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"d\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"dmd -run\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"lsp\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"newlisp -n\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"go\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"go run\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"es6\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"babel-node\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"rb\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"ruby %s\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"pl\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"perl\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t} else if (!strcmp (ext, \"py\")) {\n\t\t\t\t\tchar *cmd = cmdstr (\"python\");\n\t\t\t\t\tr_lang_use (core->lang, \"pipe\");\n\t\t\t\t\tr_lang_run_file (core->lang, cmd);\n\t\t\t\t\tfree (cmd);\n\t\t\t\t\tret = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ret) {\n\t\t\t\tret = r_core_cmd_file (core, file);\n\t\t\t}\n\t\t}\n\t}\n\tfree (r_list_pop (core->scriptstack));\n\treturn ret;\n}\n\nstatic int cmd_ls(void *data, const char *input) {\n\tif (*input) {\n\t\tchar *res = r_syscmd_ls (input + 1);\n\t\tif (res) {\n\t\t\tr_cons_print (res);\n\t\t\tfree (res);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cmd_stdin(void *data, const char *input) {\n\tRCore *core = (RCore *)data;\n\tif (input[0] == '?') {\n\t\tr_cons_printf (\"Usage: '-' '.-' '. -' do the same\\n\");\n\t\treturn false;\n\t}\n\treturn r_core_run_script (core, \"-\");\n}\n\nstatic int cmd_interpret(void *data, const char *input) {\n\tchar *str, *ptr, *eol, *rbuf, *filter, *inp;\n\tconst char *host, *port, *cmd;\n\tRCore *core = (RCore *)data;\n\n\tswitch (*input) {\n\tcase '\\0':\n\t\tr_core_cmd_repeat (core, 0);\n\t\tbreak;\n\tcase ':':\n\t\tif ((ptr = strchr (input + 1, ' '))) {\n\t\t\t/* .:port cmd */\n\t\t\t/* .:host:port cmd */\n\t\t\tcmd = ptr + 1;\n\t\t\t*ptr = 0;\n\t\t\teol = strchr (input + 1, ':');\n\t\t\tif (eol) {\n\t\t\t\t*eol = 0;\n\t\t\t\thost = input + 1;\n\t\t\t\tport = eol + 1;\n\t\t\t} else {\n\t\t\t\thost = \"localhost\";\n\t\t\t\tport = input + ((input[1] == ':')? 2: 1);\n\t\t\t}\n\t\t\trbuf = r_core_rtr_cmds_query (core, host, port, cmd);\n\t\t\tif (rbuf) {\n\t\t\t\tr_cons_print (rbuf);\n\t\t\t\tfree (rbuf);\n\t\t\t}\n\t\t} else {\n\t\t\tr_core_rtr_cmds (core, input + 1);\n\t\t}\n\t\tbreak;\n\tcase '.': // same as \\n\n\t\tr_core_cmd_repeat (core, 1);\n\t\tbreak;\n\tcase '-':\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: '-' '.-' '. -' do the same\\n\");\n\t\t} else {\n\t\t\tr_core_run_script (core, \"-\");\n\t\t}\n\t\tbreak;\n\tcase ' ':\n\t\tif (!r_core_run_script (core, input + 1)) {\n\t\t\teprintf (\"Cannot find script '%s'\\n\", input + 1);\n\t\t\tcore->num->value = 1;\n\t\t} else {\n\t\t\tcore->num->value = 0;\n\t\t}\n\t\tbreak;\n\tcase '!':\n\t\t/* from command */\n\t\tr_core_cmd_command (core, input + 1);\n\t\tbreak;\n\tcase '(':\n\t\tr_cmd_macro_call (&core->rcmd->macro, input + 1);\n\t\tbreak;\n\tcase '?':{\n\t\tconst char* help_msg[] = {\n\t\t\"Usage:\", \".[r2cmd] | [file] | [!command] | [(macro)]\", \" # define macro or load r2, cparse or rlang file\",\n\t\t\".\", \"\", \"repeat last command backward\",\n\t\t\".\", \"r2cmd\", \"interpret the output of the command as r2 commands\",\n\t\t\"..\", \"\", \"repeat last command forward (same as \\\\n)\",\n\t\t\".:\", \"8080\", \"listen for commands on given tcp port\",\n\t\t\".\", \" foo.r2\", \"interpret r2 script\",\n\t\t\".-\", \"\", \"open cfg.editor and interpret tmp file\",\n\t\t\".!\", \"rabin -ri $FILE\", \"interpret output of command\",\n\t\t\".\", \"(foo 1 2 3)\", \"run macro 'foo' with args 1, 2, 3\",\n\t\t\"./\", \" ELF\", \"interpret output of command /m ELF as r. commands\",\n\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (*input >= 0 && *input <= 9) {\n\t\t\teprintf (\"|ERROR| No .[0..9] to avoid infinite loops\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tinp = strdup (input);\n\t\tfilter = strchr (inp, '~');\n\t\tif (filter) {\n\t\t\t*filter = 0;\n\t\t}\n\t\tptr = str = r_core_cmd_str (core, inp);\n\t\tif (filter) {\n\t\t\t*filter = '~';\n\t\t}\n\t\tr_cons_break_push (NULL, NULL);\n\t\tif (ptr) {\n\t\t\tfor (;;) {\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\teol = strchr (ptr, '\\n');\n\t\t\t\tif (eol) *eol = '\\0';\n\t\t\t\tif (*ptr) {\n\t\t\t\t\tchar *p = r_str_append (strdup (ptr), filter);\n\t\t\t\t\tr_core_cmd0 (core, p);\n\t\t\t\t\tfree (p);\n\t\t\t\t}\n\t\t\t\tif (!eol) break;\n\t\t\t\tptr = eol + 1;\n\t\t\t}\n\t\t}\n\t\tr_cons_break_pop ();\n\t\tfree (str);\n\t\tfree (inp);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int callback_foreach_kv (void *user, const char *k, const char *v) {\n\tr_cons_printf (\"%s=%s\\n\", k, v);\n\treturn 1;\n}\n\nstatic int cmd_kuery(void *data, const char *input) {\n\tchar buf[1024], *out;\n\tRCore *core = (RCore*)data;\n\tconst char *sp, *p = \"[sdb]> \";\n\tconst int buflen = sizeof (buf) - 1;\n\tSdb *s = core->sdb;\n\n\tswitch (input[0]) {\n\tcase ' ':\n\t\tout = sdb_querys (s, NULL, 0, input + 1);\n\t\tif (out) {\n\t\t\tr_cons_println (out);\n\t\t}\n\t\tfree (out);\n\t\tbreak;\n\t//case 's': r_pair_save (s, input + 3); break;\n\t//case 'l': r_pair_load (sdb, input + 3); break;\n\tcase '\\0':\n\t\tsdb_foreach (s, callback_foreach_kv, NULL);\n\t\tbreak;\n\t// TODO: add command to list all namespaces // sdb_ns_foreach ?\n\tcase 's':\n\t\tif (core->http_up) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_config_get_i (core->config, \"scr.interactive\")) {\n\t\t\treturn false;\n\t\t}\n\t\tif (input[1] == ' ') {\n\t\t\tchar *n, *o, *p = strdup (input + 2);\n\t\t\t// TODO: slash split here? or inside sdb_ns ?\n\t\t\tfor (n = o = p; n; o = n) {\n\t\t\t\tn = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE\n\t\t\t\tif (n) *n++ = 0;\n\t\t\t\ts = sdb_ns (s, o, 1);\n\t\t\t}\n\t\t\tfree (p);\n\t\t}\n\t\tif (!s) s = core->sdb;\n\t\tfor (;;) {\n\t\t\tr_line_set_prompt (p);\n\t\t\tif (r_cons_fgets (buf, buflen, 0, NULL) < 1)\n\t\t\t\tbreak;\n\t\t\tif (!*buf) break;\n\t\t\tout = sdb_querys (s, NULL, 0, buf);\n\t\t\tif (out) {\n\t\t\t\tr_cons_println (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'o':\n\t\tif (r_sandbox_enable (0)) {\n\t\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (input[1] == ' ') {\n\t\t\tchar *fn = strdup (input + 2);\n\t\t\tif (!fn) {\n\t\t\t\teprintf(\"Unable to allocate memory\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tchar *ns = strchr (fn, ' ');\n\t\t\tif (ns) {\n\t\t\t\tSdb *db;\n\t\t\t\t*ns++ = 0;\n\t\t\t\tif (r_file_exists (fn)) {\n\t\t\t\t\tdb = sdb_ns_path (core->sdb, ns, 1);\n\t\t\t\t\tif (db) {\n\t\t\t\t\t\tSdb *newdb = sdb_new (NULL, fn, 0);\n\t\t\t\t\t\tif (newdb) {\n\t\t\t\t\t\t\tsdb_drain  (db, newdb);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teprintf (\"Cannot open sdb '%s'\\n\", fn);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else eprintf (\"Cannot find sdb '%s'\\n\", ns);\n\t\t\t\t} else eprintf (\"Cannot open file\\n\");\n\t\t\t} else eprintf (\"Missing sdb namespace\\n\");\n\t\t\tfree (fn);\n\t\t} else {\n\t\t\teprintf (\"Usage: ko [file] [namespace]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'd':\n\t\tif (r_sandbox_enable (0)) {\n\t\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (input[1] == ' ') {\n\t\t\tchar *fn = strdup (input + 2);\n\t\t\tchar *ns = strchr (fn, ' ');\n\t\t\tif (ns) {\n\t\t\t\t*ns++ = 0;\n\t\t\t\tSdb *db = sdb_ns_path (core->sdb, ns, 0);\n\t\t\t\tif (db) {\n\t\t\t\t\tsdb_file (db, fn);\n\t\t\t\t\tsdb_sync (db);\n\t\t\t\t} else eprintf (\"Cannot find sdb '%s'\\n\", ns);\n\t\t\t} else eprintf (\"Missing sdb namespace\\n\");\n\t\t\tfree (fn);\n\t\t} else {\n\t\t\teprintf (\"Usage: kd [file] [namespace]\\n\");\n\t\t}\n\t\tbreak;\n\tcase '?': {\n\t\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"k[s] [key[=value]]\", \"Sdb Query\",\n\t\t\t\"k\", \" foo=bar\", \"set value\",\n\t\t\t\"k\", \" foo\", \"show value\",\n\t\t\t\"k\", \"\", \"list keys\",\n\t\t\t\"ko\", \" [file.sdb] [ns]\", \"open file into namespace\",\n\t\t\t\"kd\", \" [file.sdb] [ns]\", \"dump namespace to disk\",\n\t\t\t\"ks\", \" [ns]\", \"enter the sdb query shell\",\n\t\t\t\"k\", \" anal/meta/*\", \"ist kv from anal > meta namespaces\",\n\t\t\t\"k\", \" anal/**\", \"list namespaces under anal\",\n\t\t\t\"k\", \" anal/meta/meta.0x80404\", \"get value for meta.0x80404 key\",\n\t\t\t//\"kl\", \" ha.sdb\", \"load keyvalue from ha.sdb\",\n\t\t\t//\"ks\", \" ha.sdb\", \"save keyvalue to ha.sdb\",\n\t\t\tNULL,\n\t\t\t};\n\t\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (input[0] == '\\0') {\n\t\t/* nothing more to do, the command has been parsed. */\n\t\treturn 0;\n\t}\n\n\tsp = strchr (input + 1, ' ');\n\tif (sp) {\n\t\tchar *inp = strdup (input);\n\t\tinp [(size_t)(sp - input)] = 0;\n\t\ts = sdb_ns (core->sdb, inp + 1, 1);\n\t\tout = sdb_querys (s, NULL, 0, sp + 1);\n\t\tif (out) {\n\t\t\tr_cons_println (out);\n\t\t\tfree (out);\n\t\t}\n\t\tfree (inp);\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_bsize(void *data, const char *input) {\n\tut64 n;\n\tRFlagItem *flag;\n\tRCore *core = (RCore *)data;\n\tswitch (input[0]) {\n\tcase 'm':\n\t\tn = r_num_math (core->num, input + 1);\n\t\tif (n > 1) core->blocksize_max = n;\n\t\telse r_cons_printf (\"0x%x\\n\", (ut32)core->blocksize_max);\n\t\tbreak;\n\tcase '+':\n\t\tn = r_num_math (core->num, input + 1);\n\t\tr_core_block_size (core, core->blocksize + n);\n\t\tbreak;\n\tcase '-':\n\t\tn = r_num_math (core->num, input + 1);\n\t\tr_core_block_size (core, core->blocksize - n);\n\t\tbreak;\n\tcase 'f':\n\t\tif (input[1] == ' ') {\n\t\t\tflag = r_flag_get (core->flags, input + 2);\n\t\t\tif (flag) {\n\t\t\t\tr_core_block_size (core, flag->size);\n\t\t\t} else {\n\t\t\t\teprintf (\"bf: cannot find flag named '%s'\\n\", input + 2);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: bf [flagname]\\n\");\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_cons_printf (\"0x%x\\n\", core->blocksize);\n\t\tbreak;\n\tcase '?':{\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\",  \"b[f] [arg]\\n\", \"Get/Set block size\",\n\t\t\t\"b\", \"\", \"display current block size\",\n\t\t\t\"b\", \" 33\", \"set block size to 33\",\n\t\t\t\"b\", \"+3\", \"increase blocksize by 3\",\n\t\t\t\"b\", \"-16\", \"decrease blocksize by 16\",\n\t\t\t\"b\", \" eip+4\", \"numeric argument can be an expression\",\n\t\t\t\"bf\", \" foo\", \"set block size to flag size\",\n\t\t\t\"bm\", \" 1M\", \"set max block size\",\n\t\t\tNULL\n\t\t};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t//input = r_str_clean(input);\n\t\tr_core_block_size (core, r_num_math (core->num, input));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_resize(void *data, const char *input) {\n\tRCore *core = (RCore *)data;\n\tut64 oldsize, newsize = 0;\n\tst64 delta = 0;\n\tint grow, ret;\n\n\tif (core->file && core->file->desc)\n\t\toldsize = r_io_desc_size (core->io, core->file->desc);\n\telse oldsize = 0;\n\tswitch (*input) {\n\tcase '2':\n\t\t// TODO: use argv[0] instead of 'radare2'\n\t\tr_sys_cmdf (\"radare%s\", input);\n\t\treturn true;\n\tcase 'm':\n\t\tif (input[1] == ' ')\n\t\t\tr_file_rm (input + 2);\n\t\telse eprintf (\"Usage: rm [file]   # removes a file\\n\");\n\t\treturn true;\n\tcase '\\0':\n\t\tif (core->file && core->file->desc) {\n\t\t\tif (oldsize != -1) {\n\t\t\t\tr_cons_printf (\"%\"PFMT64d\"\\n\", oldsize);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase '+':\n\tcase '-':\n\t\tdelta = (st64)r_num_math (core->num, input);\n\t\tnewsize = oldsize + delta;\n\t\tbreak;\n\tcase ' ':\n\t\tnewsize = r_num_math (core->num, input + 1);\n\t\tif (newsize == 0) {\n\t\t\tif (input[1] == '0')\n\t\t\t\teprintf (\"Invalid size\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase '?':{\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"r[+-][ size]\", \"Resize file\",\n\t\t\t\"r\", \"\", \"display file size\",\n\t\t\t\"r\", \" size\", \"expand or truncate file to given size\",\n\t\t\t\"r-\", \"num\", \"remove num bytes, move following data down\",\n\t\t\t\"r+\", \"num\", \"insert num bytes, move following data up\",\n\t\t\t\"rm\" ,\" [file]\", \"remove file\",\n\t\t\t\"r2\" ,\" [file]\", \"launch r2\",\n\t\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\treturn true;\n\t}\n\n\tgrow = (newsize > oldsize);\n\tif (grow) {\n\t\tret = r_io_resize (core->io, newsize);\n\t\tif (ret < 1)\n\t\t\teprintf (\"r_io_resize: cannot resize\\n\");\n\t}\n\n\tif (delta && core->offset < newsize)\n\t\tr_io_shift (core->io, core->offset, grow?newsize:oldsize, delta);\n\n\tif (!grow) {\n\t\tret = r_io_resize (core->io, newsize);\n\t\tif (ret < 1)\n\t\t\teprintf (\"r_io_resize: cannot resize\\n\");\n\t}\n\n\tif (newsize < core->offset+core->blocksize ||\n\t\t\toldsize < core->offset + core->blocksize) {\n\t\tr_core_block_read (core);\n\t}\n\treturn true;\n}\n\nstatic int cmd_visual(void *data, const char *input) {\n\tRCore *core = (RCore*) data;\n\tif (core->http_up) {\n\t\treturn false;\n\t}\n\tif (!r_config_get_i (core->config, \"scr.interactive\")) {\n\t\treturn false;\n\t}\n\treturn r_core_visual ((RCore *)data, input);\n}\n\nstatic int task_finished(void *user, void *data) {\n\teprintf (\"TASK FINISHED\\n\");\n\treturn 0;\n}\n\nstatic int taskbgrun(RThread *th) {\n\tchar *res;\n\tRCoreTask *task = th->user;\n\tRCore *core = task->core;\n\tclose (2); // no stderr\n\tres = r_core_cmd_str (core, task->msg->text);\n\ttask->msg->res = res;\n\ttask->state = 'd';\n\teprintf (\"Task %d finished\\n\", task->id);\n// TODO: run callback and pass result\n\treturn 0;\n}\n\nstatic int cmd_thread(void *data, const char *input) {\n\tRCore *core = (RCore*) data;\n\tif (r_sandbox_enable (0)) {\n\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\treturn 0;\n\t}\n\tswitch (input[0]) {\n\tcase '\\0':\n\tcase 'j':\n\t\tr_core_task_list (core, *input);\n\t\tbreak;\n\tcase '&':\n\t\tif (input[1] == '&') {\n\t\t\t// wait until ^C\n\t\t} else {\n\t\t\tint tid = r_num_math (core->num, input + 1);\n\t\t\tif (tid) {\n\t\t\t\tRCoreTask *task = r_core_task_get (core, tid);\n\t\t\t\tif (task) {\n\t\t\t\t\tr_core_task_join (core, task);\n\t\t\t\t} else eprintf (\"Cannot find task\\n\");\n\t\t\t} else {\n\t\t\t\tr_core_task_run (core, NULL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '=': {\n\t\tint tid = r_num_math (core->num, input + 1);\n\t\tif (tid) {\n\t\t\tRCoreTask *task = r_core_task_get (core, tid);\n\t\t\tif (task) {\n\t\t\t\tr_cons_printf (\"Task %d Status %c Command %s\\n\",\n\t\t\t\t\ttask->id, task->state, task->msg->text);\n\t\t\t\tif (task->msg->res)\n\t\t\t\t\tr_cons_println (task->msg->res);\n\t\t\t} else eprintf (\"Cannot find task\\n\");\n\t\t} else {\n\t\t\tr_core_task_list (core, 1);\n\t\t}}\n\t\tbreak;\n\tcase '+':\n\t\tr_core_task_add (core, r_core_task_new (core, input + 1, (RCoreTaskCallback)task_finished, core));\n\t\tbreak;\n\tcase '-':\n\t\tif (input[1] == '*') {\n\t\t\tr_core_task_del (core, -1);\n\t\t} else {\n\t\t\tr_core_task_del (core, r_num_math (core->num, input + 1));\n\t\t}\n\t\tbreak;\n\tcase '?':\n\t\t{\n\t\t\thelpCmdTasks (core);\n\t\t}\n\t\tbreak;\n\tcase ' ':\n\t\t{\n\t\t\tint tid = r_num_math (core->num, input + 1);\n\t\t\tif (tid) {\n\t\t\t\tRCoreTask *task = r_core_task_get (core, tid);\n\t\t\t\tif (task) {\n\t\t\t\t\tr_core_task_join (core, task);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Cannot find task\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRCoreTask *task = r_core_task_add (core, r_core_task_new (\n\t\t\t\t\t\t\tcore, input + 1, (RCoreTaskCallback)task_finished, core));\n\t\t\t\tRThread *th = r_th_new (taskbgrun, task, 0);\n\t\t\t\ttask->msg->th = th;\n\t\t\t}\n\t\t\t//r_core_cmd0 (core, task->msg->text);\n\t\t\t//r_core_task_del (core, task->id);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"&?\\n\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cmd_pointer(void *data, const char *input) {\n\tRCore *core = (RCore*) data;\n\tint ret = true;\n\tchar *str, *eq;\n\twhile (*input == ' ') input++;\n\tif (!*input || *input == '?') {\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"*<addr>[=[0x]value]\", \"Pointer read/write data/values\",\n\t\t\t\"*\", \"entry0=cc\", \"write trap in entrypoint\",\n\t\t\t\"*\", \"entry0+10=0x804800\", \"write value in delta address\",\n\t\t\t\"*\", \"entry0\", \"read byte at given address\",\n\t\t\t\"TODO: last command should honor asm.bits\", \"\", \"\",\n\t\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\treturn ret;\n\t}\n\tstr = strdup (input);\n\teq = strchr (str, '=');\n\tif (eq) {\n\t\t*eq++ = 0;\n\t\tif (!strncmp (eq, \"0x\", 2)) {\n\t\t\tret = r_core_cmdf (core, \"wv %s@%s\", eq, str);\n\t\t} else {\n\t\t\tret = r_core_cmdf (core, \"wx %s@%s\", eq, str);\n\t\t}\n\t} else {\n\t\tret = r_core_cmdf (core, \"?v [%s]\", input);\n\t}\n\tfree (str);\n\treturn ret;\n}\n\nstatic int cmd_env(void *data, const char *input) {\n\tRCore *core = (RCore*)data;\n\tint ret = true;\n\tswitch (*input) {\n\tcase '?':\n\t\t{\n\t\tconst char* help_msg[] = {\n\t\t\t\"Usage:\", \"%[name[=value]]\", \"Set each NAME to VALUE in the environment\",\n\t\t\t\"%\", \"\", \"list all environment variables\",\n\t\t\t\"%\", \"SHELL\", \"prints SHELL value\",\n\t\t\t\"%\", \"TMPDIR=/tmp\", \"sets TMPDIR value to \\\"/tmp\\\"\",\n\t\t\tNULL};\n\t\tr_core_cmd_help (core, help_msg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = r_core_cmdf (core, \"env %s\", input);\n\t}\n\treturn ret;\n}\n\nstatic int cmd_system(void *data, const char *input) {\n\tRCore *core = (RCore*)data;\n\tut64 n;\n\tint ret = 0;\n\tswitch (*input) {\n\tcase '=':\n\t\tif (input[1] == '?') {\n\t\t\tr_cons_printf (\"Usage: !=[!]  - enable/disable remote commands\\n\");\n\t\t} else {\n\t\t\tif (!r_sandbox_enable (0)) {\n\t\t\t\tcore->cmdremote = input[1]? 1: 0;\n\t\t\t\tr_cons_println (r_str_bool (core->cmdremote));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '!':\n\t\tif (r_sandbox_enable (0)) {\n\t\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (input[1]) {\n\t\t\tint olen;\n\t\t\tchar *out = NULL;\n\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n\t\t\tif (cmd) {\n\t\t\t\tret = r_sys_cmd_str_full (cmd + 1, NULL, &out, &olen, NULL);\n\t\t\t\tr_core_sysenv_end (core, input);\n\t\t\t\tr_cons_memcat (out, olen);\n\t\t\t\tfree (out);\n\t\t\t\tfree (cmd);\n\t\t\t} //else eprintf (\"Error setting up system environment\\n\");\n\t\t} else {\n\t\t\teprintf (\"History saved to \"R2_HOMEDIR\"/history\\n\");\n\t\t\tr_line_hist_save (R2_HOMEDIR\"/history\");\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_line_hist_list ();\n\t\tbreak;\n\tcase '?':\n\t\tr_core_sysenv_help (core);\n\t\tbreak;\n\tdefault:\n\t\tn = atoi (input);\n\t\tif (*input == '0' || n > 0) {\n\t\t\tconst char *cmd = r_line_hist_get (n);\n\t\t\tif (cmd) r_core_cmd0 (core, cmd);\n\t\t\t//else eprintf (\"Error setting up system environment\\n\");\n\t\t} else {\n\t\t\tchar *cmd = r_core_sysenv_begin (core, input);\n\t\t\tif (cmd) {\n\t\t\t\tret = r_sys_cmd (cmd);\n\t\t\t\tr_core_sysenv_end (core, input);\n\t\t\t\tfree (cmd);\n\t\t\t} else eprintf (\"Error setting up system environment\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nR_API int r_core_cmd_pipe(RCore *core, char *radare_cmd, char *shell_cmd) {\n#if __UNIX__ || __CYGWIN__\n\tint stdout_fd, fds[2];\n\tint child;\n#endif\n\tint si, olen, ret = -1, pipecolor = -1;\n\tchar *str, *out = NULL;\n\n\tif (r_sandbox_enable (0)) {\n\t\teprintf (\"Pipes are not allowed in sandbox mode\\n\");\n\t\treturn -1;\n\t}\n\tsi = r_config_get_i (core->config, \"scr.interactive\");\n\tr_config_set_i (core->config, \"scr.interactive\", 0);\n\tif (!r_config_get_i (core->config, \"scr.pipecolor\")) {\n\t\tpipecolor = r_config_get_i (core->config, \"scr.color\");\n\t\tr_config_set_i (core->config, \"scr.color\", 0);\n\t}\n\tif (*shell_cmd=='!') {\n\t\tr_cons_grep_parsecmd (shell_cmd, \"\\\"\");\n\t\tolen = 0;\n\t\tout = NULL;\n\t\t// TODO: implement foo\n\t\tstr = r_core_cmd_str (core, radare_cmd);\n\t\tr_sys_cmd_str_full (shell_cmd + 1, str, &out, &olen, NULL);\n\t\tfree (str);\n\t\tr_cons_memcat (out, olen);\n\t\tfree (out);\n\t\tret = 0;\n\t}\n#if __UNIX__ || __CYGWIN__\n\tradare_cmd = (char*)r_str_trim_head (radare_cmd);\n\tshell_cmd = (char*)r_str_trim_head (shell_cmd);\n\n\tsignal (SIGPIPE, SIG_IGN);\n\tstdout_fd = dup (1);\n\tif (stdout_fd != -1) {\n\t\tpipe (fds);\n\t\tchild = r_sys_fork ();\n\t\tif (child == -1) {\n\t\t\teprintf (\"Cannot fork\\n\");\n\t\t\tclose (stdout_fd);\n\t\t} else if (child) {\n\t\t\tdup2 (fds[1], 1);\n\t\t\tclose (fds[1]);\n\t\t\tclose (fds[0]);\n\t\t\tr_core_cmd (core, radare_cmd, 0);\n\t\t\tr_cons_flush ();\n\t\t\tclose (1);\n\t\t\twait (&ret);\n\t\t\tdup2 (stdout_fd, 1);\n\t\t\tclose (stdout_fd);\n\t\t} else {\n\t\t\tclose (fds[1]);\n\t\t\tdup2 (fds[0], 0);\n\t\t\t//dup2 (1, 2); // stderr goes to stdout\n\t\t\tr_sandbox_system (shell_cmd, 0);\n\t\t\tclose (stdout_fd);\n\t\t}\n\t}\n#else\n#ifdef _MSC_VER\n#pragma message (\"r_core_cmd_pipe UNIMPLEMENTED FOR THIS PLATFORM\")\n#else\n#warning r_core_cmd_pipe UNIMPLEMENTED FOR THIS PLATFORM\n#endif\n\teprintf (\"r_core_cmd_pipe: unimplemented for this platform\\n\");\n#endif\n\tif (pipecolor != -1)\n\t\tr_config_set_i (core->config, \"scr.color\", pipecolor);\n\tr_config_set_i (core->config, \"scr.interactive\", si);\n\treturn ret;\n}\n\nstatic char *parse_tmp_evals(RCore *core, const char *str) {\n\tchar *res = NULL;\n\tRStrBuf *buf;\n\tchar *s = strdup (str);\n\tbuf = r_strbuf_new (\"\");\n\tint i, argc = r_str_split (s, ',');\n\tfor (i = 0; i < argc; i++) {\n\t\tchar *eq, *kv = (char *)r_str_word_get0 (s, i);\n\t\tif (!kv) {\n\t\t\tbreak;\n\t\t}\n\t\teq = strchr (kv, '=');\n\t\tif (eq) {\n\t\t\t*eq = 0;\n\t\t\tconst char *ov = r_config_get (core->config, kv);\n\t\t\tr_strbuf_appendf (buf, \"e %s=%s;\", kv, ov);\n\t\t\tr_config_set (core->config, kv, eq + 1);\n\t\t\t*eq = '=';\n\t\t} else {\n\t\t\teprintf (\"Missing '=' in e: expression (%s)\\n\", kv);\n\t\t}\n\t}\n\tres = r_strbuf_drain (buf);\n\tfree (s);\n\treturn res;\n}\n\nstatic int r_core_cmd_subst_i(RCore *core, char *cmd, char* colon);\nstatic int r_core_cmd_subst(RCore *core, char *cmd) {\n\tint ret = 0, rep = atoi (cmd), orep;\n\tchar *cmt, *colon = NULL, *icmd = strdup (cmd);\n\tconst char *cmdrep = NULL;\n\tcmd = r_str_trim_head_tail (icmd);\n\t// lines starting with # are ignored (never reach cmd_hash()), except #! and #?\n\tif (!icmd || (cmd[0] == '#' && cmd[1] != '!' && cmd[1] != '?')) {\n\t\tgoto beach;\n\t}\n\tcmt = *icmd ? strchr (icmd + 1, '#'): NULL;\n\tif (cmt && (cmt[1] == ' ' || cmt[1] == '\\t')) {\n\t\t*cmt = 0;\n\t}\n\tif (*cmd != '\"') {\n\t\tif (!strchr (cmd, '\\'')) { // allow | awk '{foo;bar}' // ignore ; if there's a single quote\n\t\t\tif ((colon = strchr (cmd, ';'))) {\n\t\t\t\t*colon = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcolon = NULL;\n\t}\n\tif (rep > 0) {\n\t\twhile (IS_DIGIT(*cmd)) {\n\t\t\tcmd++;\n\t\t}\n\t\t// do not repeat null cmd\n\t\tif (!*cmd) {\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (rep < 1) {\n\t\trep = 1;\n\t}\n\t// XXX if output is a pipe then we dont want to be interactive\n\tif (rep > 1 && r_sandbox_enable (0)) {\n\t\teprintf (\"Command repeat sugar disabled in sandbox mode (%s)\\n\", cmd);\n\t\tgoto beach;\n\t} else {\n\t\tif (rep > INTERACTIVE_MAX_REP) {\n\t\t\tif (r_config_get_i (core->config, \"scr.interactive\")) {\n\t\t\t\tif (!r_cons_yesno ('n', \"Are you sure to repeat this %d times? (y/N)\", rep)) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// TODO: store in core->cmdtimes to speedup ?\n\tcmdrep = r_config_get (core->config, \"cmd.times\");\n\tif (!cmdrep) {\n\t\tcmdrep = \"\";\n\t}\n\torep = rep;\n\n\tint ocur_enabled = core->print->cur_enabled;\n\twhile (rep-- && *cmd) {\n\t\tcore->print->cur_enabled = false;\n\t\tif (ocur_enabled && core->seltab >= 0) {\n\t\t\tif (core->seltab == core->curtab) {\n\t\t\t\tcore->print->cur_enabled = true;\n\t\t\t}\n\t\t}\n\t\tchar *cr = strdup (cmdrep);\n\t\tcore->break_loop = false;\n\t\tret = r_core_cmd_subst_i (core, cmd, colon);\n\t\tif (ret && *cmd == 'q') {\n\t\t\tfree (cr);\n\t\t\tgoto beach;\n\t\t}\n\t\tif (core->break_loop) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cr && *cr) {\n\t\t\tif (orep > 1) {\n\t\t\t\t// XXX: do not flush here, we need r_cons_push () and r_cons_pop()\n\t\t\t\tr_cons_flush ();\n\t\t\t\t// XXX: we must import register flags in C\n\t\t\t\t(void)r_core_cmd0 (core, \".dr*\");\n\t\t\t\t(void)r_core_cmd0 (core, cr);\n\t\t\t}\n\t\t}\n\t\tfree (cr);\n\t}\n\tcore->print->cur_enabled = ocur_enabled;\n\tif (colon && colon[1]) {\n\t\tfor (++colon; *colon == ';'; colon++);\n\t\tr_core_cmd_subst (core, colon);\n\t} else {\n\t\tif (!*icmd) {\n\t\t\tr_core_cmd_nullcallback (core);\n\t\t}\n\t}\nbeach:\n\tfree (icmd);\n\treturn ret;\n}\n\nstatic char *find_eoq(char *p) {\n\tfor (; *p; p++) {\n\t\tif (*p == '\"') {\n\t\t\tbreak;\n\t\t}\n\t\tif (*p == '\\\\' && p[1] == '\"') {\n\t\t\tp++;\n\t\t}\n\t}\n\treturn p;\n}\n\nstatic char* findSeparator(char *p) {\n\tchar *q = strchr (p, '+');\n\tif (q) {\n\t\treturn q;\n\t}\n\treturn strchr (p, '-');\n}\n\nstatic int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon) {\n\tconst char *quotestr = \"`\";\n\tconst char *tick = NULL;\n\tchar *ptr, *ptr2, *str;\n\tchar *arroba = NULL;\n\tint i, ret = 0, pipefd;\n\tbool usemyblock = false;\n\tint scr_html = -1;\n\tint scr_color = -1;\n\tbool eos = false;\n\tbool haveQuote = false;\n\n\tif (!cmd) {\n\t\treturn 0;\n\t}\n\tcmd = r_str_trim_head_tail (cmd);\n\n\t/* quoted / raw command */\n\tswitch (*cmd) {\n\tcase '.':\n\t\tif (cmd[1] == '\"') { /* interpret */\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t\tbreak;\n\tcase '\"':\n\t\tfor (; *cmd; ) {\n\t\t\tint pipefd = -1;\n\t\t\tut64 oseek = UT64_MAX;\n\t\t\tchar *line, *p;\n\t\t\thaveQuote = *cmd == '\"';\n\t\t\tif (haveQuote) {\n\t\t\t//\t*cmd = 0;\n\t\t\t\tcmd++;\n\t\t\t\tp = cmd[0] ? find_eoq (cmd + 1) : NULL;\n\t\t\t\tif (!p || !*p) {\n\t\t\t\t\teprintf (\"Missing \\\" in (%s).\", cmd);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t*p++ = 0;\n\t\t\t\tif (!*p) {\n\t\t\t\t\teos = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchar *sc = strchr (cmd, ';');\n\t\t\t\tif (sc) {\n\t\t\t\t\t*sc = 0;\n\t\t\t\t}\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\tif (!sc) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmd = sc + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (p[0]) {\n\t\t\t\t// workaround :D\n\t\t\t\tif (p[0] == '@') {\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\twhile (p[1] == ';' || IS_WHITESPACE (p[1])) {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tif (p[1] == '@' || (p[1] && p[2] == '@')) {\n\t\t\t\t\tchar *q = strchr (p + 1, '\"');\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q = 0;\n\t\t\t\t\t}\n\t\t\t\t\thaveQuote = q != NULL;\n\t\t\t\t\toseek = core->offset;\n\t\t\t\t\tr_core_seek (core,\n\t\t\t\t\t\t     r_num_math (core->num, p + 2), 1);\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tp = q;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = strchr (p + 1, ';');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (p && *p && p[1] == '>') {\n\t\t\t\t\tstr = p + 2;\n\t\t\t\t\twhile (*str == '>') {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\t\tstr++;\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_flush ();\n\t\t\t\t\tpipefd = r_cons_pipe_open (str, 1, p[2] == '>');\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = strdup (cmd);\n\t\t\tline = r_str_replace (line, \"\\\\\\\"\", \"\\\"\", true);\n\t\t\tif (p && *p && p[1] == '|') {\n\t\t\t\tstr = p + 2;\n\t\t\t\twhile (IS_WHITESPACE (*str)) {\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t\tr_core_cmd_pipe (core, cmd, str);\n\t\t\t} else {\n\t\t\t\tr_cmd_call (core->rcmd, line);\n\t\t\t}\n\t\t\tfree (line);\n\t\t\tif (oseek != UT64_MAX) {\n\t\t\t\tr_core_seek (core, oseek, 1);\n\t\t\t\toseek = UT64_MAX;\n\t\t\t}\n\t\t\tif (pipefd != -1) {\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (eos) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (haveQuote) {\n\t\t\t\tif (*p == ';') {\n\t\t\t\t\tcmd = p + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (*p == '\"') {\n\t\t\t\t\t\tcmd = p + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t*p = '\"';\n\t\t\t\t\t\tcmd = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcmd = p + 1;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\tcase '(':\n\t\tif (cmd[1] != '*') {\n\t\t\treturn r_cmd_call (core->rcmd, cmd);\n\t\t}\n\t}\n\n// TODO must honor \" and `\n\t/* comments */\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, '#', quotestr);\n\t\tif (ptr && (ptr[1] == ' ' || ptr[1] == '\\t')) {\n\t\t\t*ptr = '\\0';\n\t\t}\n\t}\n\n\t/* multiple commands */\n\t// TODO: must honor \" and ` boundaries\n\t//ptr = strrchr (cmd, ';');\n\tif (*cmd != '#') {\n\t\tptr = (char *)r_str_lastbut (cmd, ';', quotestr);\n\t\tif (colon && ptr) {\n\t\t\tint ret ;\n\t\t\t*ptr = '\\0';\n\t\t\tif (r_core_cmd_subst (core, cmd) == -1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcmd = ptr + 1;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t*ptr = ';';\n\t\t\treturn ret;\n\t\t\t//r_cons_flush ();\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* pipe console to shell process */\n\t//ptr = strchr (cmd, '|');\n\tptr = (char *)r_str_lastbut (cmd, '|', quotestr);\n\tif (ptr) {\n\t\tchar *ptr2 = strchr (cmd, '`');\n\t\tif (!ptr2 || (ptr2 && ptr2 > ptr)) {\n\t\t\tif (!tick || (tick && tick > ptr)) {\n\t\t\t\t*ptr = '\\0';\n\t\t\t\tcmd = r_str_clean (cmd);\n\t\t\t\tif (!strcmp (ptr + 1, \"?\")) { // \"|?\"\n\t\t\t\t\t// TODO: should be disable scr.color in pd| ?\n\t\t\t\t\teprintf (\"Usage: <r2command> | <program|H|>\\n\");\n\t\t\t\t\teprintf (\" pd|?   - show this help\\n\");\n\t\t\t\t\teprintf (\" pd|    - disable scr.html and scr.color\\n\");\n\t\t\t\t\teprintf (\" pd|H   - enable scr.html, respect scr.color\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t} else if (!strcmp (ptr + 1, \"H\")) { // \"|H\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\t} else if (ptr[1]) { // \"| grep ..\"\n\t\t\t\t\tint value = core->num->value;\n\t\t\t\t\tif (*cmd) {\n\t\t\t\t\t\tr_core_cmd_pipe (core, cmd, ptr + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_io_system (core->io, ptr + 1);\n\t\t\t\t\t}\n\t\t\t\t\tcore->num->value = value;\n\t\t\t\t\treturn 0;\n\t\t\t\t} else { // \"|\"\n\t\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", 0);\n\t\t\t\t\tscr_color = r_config_get_i (core->config, \"scr.color\");\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO must honor \" and `\n\t/* bool conditions */\n\tptr = (char *)r_str_lastbut (cmd, '&', quotestr);\n\t//ptr = strchr (cmd, '&');\n\twhile (ptr && ptr[1] == '&') {\n\t\t*ptr = '\\0';\n\t\tret = r_cmd_call (core->rcmd, cmd);\n\t\tif (ret == -1) {\n\t\t\teprintf (\"command error(%s)\\n\", cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tfor (cmd = ptr + 2; cmd && *cmd == ' '; cmd++);\n\t\tptr = strchr (cmd, '&');\n\t}\n\n\t/* Out Of Band Input */\n\tfree (core->oobi);\n\tcore->oobi = NULL;\n\n\tptr = strstr (cmd, \"?*\");\n\tif (ptr) {\n\t\tchar *prech = ptr - 1;\n\t\tif (*prech != '~') {\n\t\t\tptr[1] = 0;\n\t\t\tif (*cmd != '#' && strlen (cmd) < 5) {\n\t\t\t\tr_cons_break_push (NULL, NULL);\n\t\t\t\trecursive_help (core, cmd);\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\tr_cons_grep_parsecmd (ptr + 2, \"`\");\n\t\t\t\tif (scr_html != -1) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n#if 0\n\tptr = strchr (cmd, '<');\n\tif (ptr) {\n\t\tptr[0] = '\\0';\n\t\tif (r_cons_singleton()->is_interactive) {\n\t\t\tif (ptr[1] == '<') {\n\t\t\t\t/* this is a bit mess */\n\t\t\t\t//const char *oprompt = strdup (r_line_singleton ()->prompt);\n\t\t\t\t//oprompt = \">\";\n\t\t\t\tfor (str = ptr + 2; str[0] == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\teprintf (\"==> Reading from stdin until '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = malloc (1);\n\t\t\t\tif (core->oobi) {\n\t\t\t\t\tcore->oobi[0] = '\\0';\n\t\t\t\t}\n\t\t\t\tcore->oobi_len = 0;\n\t\t\t\tfor (;;) {\n\t\t\t\t\tchar buf[1024];\n\t\t\t\t\tint ret;\n\t\t\t\t\twrite (1, \"> \", 2);\n\t\t\t\t\tfgets (buf, sizeof (buf) - 1, stdin); // XXX use r_line ??\n\t\t\t\t\tif (feof (stdin)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (*buf) buf[strlen (buf) - 1]='\\0';\n\t\t\t\t\tret = strlen (buf);\n\t\t\t\t\tcore->oobi_len += ret;\n\t\t\t\t\tcore->oobi = realloc (core->oobi, core->oobi_len + 1);\n\t\t\t\t\tif (core->oobi) {\n\t\t\t\t\t\tif (!strcmp (buf, str)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrcat ((char *)core->oobi, buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//r_line_set_prompt (oprompt);\n\t\t\t} else {\n\t\t\t\tfor (str = ptr + 1; *str == ' '; str++) {\n\t\t\t\t\t//nothing to see here\n\t\t\t\t}\n\t\t\t\tif (!*str) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\teprintf (\"Slurping file '%s'\\n\", str);\n\t\t\t\tfree (core->oobi);\n\t\t\t\tcore->oobi = (ut8*)r_file_slurp (str, &core->oobi_len);\n\t\t\t\tif (!core->oobi) {\n\t\t\t\t\teprintf (\"cannot open file\\n\");\n\t\t\t\t} else if (ptr == cmd) {\n\t\t\t\t\treturn r_core_cmd_buffer (core, (const char *)core->oobi);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot slurp with << in non-interactive mode\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\nnext:\n#endif\n\t// TODO must honor \" and `\n\t/* pipe console to file */\n\tptr = strchr (cmd, '>');\n\tif (ptr) {\n\t\tint fdn = 1;\n\t\tint pipecolor = r_config_get_i (core->config, \"scr.pipecolor\");\n\t\tint use_editor = false;\n\t\tint ocolor = r_config_get_i (core->config, \"scr.color\");\n\t\t*ptr = '\\0';\n\t\tstr = r_str_trim_head_tail (ptr + 1 + (ptr[1] == '>'));\n\t\tif (!*str) {\n\t\t\teprintf (\"No output?\\n\");\n\t\t\tgoto next2;\n\t\t}\n\t\t/* r_cons_flush() handles interactive output (to the terminal)\n\t\t * differently (e.g. asking about too long output). This conflicts\n\t\t * with piping to a file. Disable it while piping. */\n\t\tif (ptr > (cmd + 1) && ISWHITECHAR (ptr[-2])) {\n\t\t\tchar *fdnum = ptr - 1;\n\t\t\tif (*fdnum == 'H') { // \"H>\"\n\t\t\t\tscr_html = r_config_get_i (core->config, \"scr.html\");\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", true);\n\t\t\t\tpipecolor = true;\n\t\t\t\t*fdnum = 0;\n\t\t\t} else {\n\t\t\t\tif (IS_DIGIT(*fdnum)) {\n\t\t\t\t\tfdn = *fdnum - '0';\n\t\t\t\t}\n\t\t\t\t*fdnum = 0;\n\t\t\t}\n\t\t}\n\t\tr_cons_set_interactive (false);\n\t\tif (!strcmp (str, \"-\")) {\n\t\t\tuse_editor = true;\n\t\t\tstr = r_file_temp (\"dumpedit\");\n\t\t\tr_config_set (core->config, \"scr.color\", \"false\");\n\t\t}\n\t\tif (fdn > 0) {\n\t\t\tpipefd = r_cons_pipe_open (str, fdn, ptr[1] == '>');\n\t\t\tif (pipefd != -1) {\n\t\t\t\tif (!pipecolor) {\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\n\t\t\t\t}\n\t\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\t\tr_cons_flush ();\n\t\t\t\tr_cons_pipe_close (pipefd);\n\t\t\t}\n\t\t}\n\t\tr_cons_set_last_interactive ();\n\t\tif (!pipecolor) {\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t}\n\t\tif (use_editor) {\n\t\t\tconst char *editor = r_config_get (core->config, \"cfg.editor\");\n\t\t\tif (editor && *editor) {\n\t\t\t\tr_sys_cmdf (\"%s '%s'\", editor, str);\n\t\t\t\tr_file_rm (str);\n\t\t\t} else {\n\t\t\t\teprintf (\"No cfg.editor configured\\n\");\n\t\t\t}\n\t\t\tr_config_set_i (core->config, \"scr.color\", ocolor);\n\t\t\tfree (str);\n\t\t}\n\t\tif (scr_html != -1) {\n\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t}\n\t\t\tif (scr_color != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t\t\t}\n\t\treturn ret;\n\t}\nnext2:\n\t/* sub commands */\n\tptr = strchr (cmd, '`');\n\tif (ptr) {\n\t\tint empty = 0;\n\t\tint oneline = 1;\n\t\tif (ptr[1] == '`') {\n\t\t\tmemmove (ptr, ptr + 1, strlen (ptr));\n\t\t\toneline = 0;\n\t\t\tempty = 1;\n\t\t}\n\t\tptr2 = strchr (ptr + 1, '`');\n\t\tif (empty) {\n\t\t\t/* do nothing */\n\t\t} else if (!ptr2) {\n\t\t\teprintf (\"parse: Missing backtick in expression.\\n\");\n\t\t\tgoto fail;\n\t\t} else {\n\t\t\tint value = core->num->value;\n\t\t\t*ptr = '\\0';\n\t\t\t*ptr2 = '\\0';\n\t\t\tif (ptr[1] == '!') {\n\t\t\t\tstr = r_core_cmd_str_pipe (core, ptr + 1);\n\t\t\t} else {\n\t\t\t\tstr = r_core_cmd_str (core, ptr + 1);\n\t\t\t}\n\t\t\tif (!str) {\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t// ignore contents if first char is pipe or comment\n\t\t\tif (*str == '|' || *str == '*') {\n\t\t\t\teprintf (\"r_core_cmd_subst_i: invalid backticked command\\n\");\n\t\t\t\tfree (str);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (oneline && str) {\n\t\t\t\tfor (i = 0; str[i]; i++) {\n\t\t\t\t\tif (str[i] == '\\n') {\n\t\t\t\t\t\tstr[i] = ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr = r_str_append (str, ptr2 + 1);\n\t\t\tcmd = r_str_append (strdup (cmd), str);\n\t\t\tcore->num->value = value;\n\t\t\tret = r_core_cmd_subst (core, cmd);\n\t\t\tfree (cmd);\n\t\t\tif (scr_html != -1) {\n\t\t\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t\t\t}\n\t\t\tfree (str);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t// TODO must honor \" and `\n\tcore->fixedblock = false;\n\n\tif (r_str_endswith (cmd, \"~?\") && cmd[2] == '\\0') {\n\t\tr_cons_grep_help ();\n\t\treturn true;\n\t}\n\tif (*cmd != '.') {\n\t\tr_cons_grep_parsecmd (cmd, quotestr);\n\t}\n\n\t/* temporary seek commands */\n\tif (*cmd!= '(' && *cmd != '\"') {\n\t\tptr = strchr (cmd, '@');\n\t\tif (ptr == cmd + 1 && *cmd == '?') {\n\t\t\tptr = NULL;\n\t\t}\n\t} else {\n\t\tptr = NULL;\n\t}\n\n\tcore->tmpseek = ptr? true: false;\n\tint rc = 0;\n\tif (ptr) {\n\t\tchar *f, *ptr2 = strchr (ptr + 1, '!');\n\t\tut64 addr = UT64_MAX;\n\t\tconst char *tmpbits = NULL;\n\t\tconst char *offstr = NULL;\n\t\tut64 tmpbsz = core->blocksize;\n\t\tchar *tmpeval = NULL;\n\t\tut64 tmpoff = core->offset;\n\t\tchar *tmpasm = NULL;\n\t\tint tmpfd = -1;\n\t\tint sz, len;\n\t\tut8 *buf;\n\n\t\t*ptr = '\\0';\n\t\tfor (ptr++; *ptr == ' '; ptr++) {\n\t\t\t//nothing to see here\n\t\t}\n\t\tif (*ptr && ptr[1] == ':') {\n\t\t\t/* do nothing here */\n\t\t} else {\n\t\t\tptr--;\n\t\t}\n\t\tarroba = (ptr[0] && ptr[1] && ptr[2])?\n\t\t\tstrchr (ptr + 2, '@'): NULL;\nrepeat_arroba:\n\t\tif (arroba) {\n\t\t\t*arroba = 0;\n\t\t}\n\t\tif (ptr[1] == '?') {\n\t\t\thelpCmdAt (core);\n\t\t} else if (ptr[0] && ptr[1] == ':' && ptr[2]) {\n\t\t\tusemyblock = true;\n\t\t\tswitch (ptr[0]) {\n\t\t\tcase 'f': // \"@f:\" // slurp file in block\n\t\t\t\tf = r_file_slurp (ptr + 2, &sz);\n\t\t\t\tif (f) {\n\t\t\t\t\tbuf = malloc (sz);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tfree (core->block);\n\t\t\t\t\t\tcore->block = buf;\n\t\t\t\t\t\tcore->blocksize = sz;\n\t\t\t\t\t\tmemcpy (core->block, f, sz);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot alloc %d\", sz);\n\t\t\t\t\t}\n\t\t\t\t\tfree (f);\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"cannot open '%s'\\n\", ptr + 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'r': // \"@r:\" // regname\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tut64 regval;\n\t\t\t\t\tchar *mander = strdup (ptr + 2);\n\t\t\t\t\tchar *sep = findSeparator (mander);\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tchar ch = *sep;\n\t\t\t\t\t\t*sep = 0;\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, mander);\n\t\t\t\t\t\t*sep = ch;\n\t\t\t\t\t\tchar *numexpr = r_str_newf (\"0x%\"PFMT64x\"%s\", regval, sep);\n\t\t\t\t\t\tregval = r_num_math (core->num, numexpr);\n\t\t\t\t\t\tfree (numexpr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tregval = r_debug_reg_get (core->dbg, ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t\tr_core_seek (core, regval, 1);\n\t\t\t\t\tfree (mander);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b': // \"@b:\" // bits\n\t\t\t\ttmpbits = strdup (r_config_get (core->config, \"asm.bits\"));\n\t\t\t\tr_config_set_i (core->config, \"asm.bits\",\n\t\t\t\t\tr_num_math (core->num, ptr + 2));\n\t\t\t\tbreak;\n\t\t\tcase 'i': // \"@i:\"\n\t\t\t\t{\n\t\t\t\t\tut64 addr = r_num_math (core->num, ptr + 2);\n\t\t\t\t\tif (addr) {\n\t\t\t\t\t\tr_core_cmdf (core, \"so %s\", ptr + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'e': // \"@e:\"\n\t\t\t\ttmpeval = parse_tmp_evals (core, ptr + 2);\n\t\t\t\tbreak;\n\t\t\tcase 'x': // \"@x:\" // hexpairs\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tbuf = malloc (strlen (ptr + 2) + 1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tlen = r_hex_str2bin (ptr + 2, buf);\n\t\t\t\t\t\tr_core_block_size (core, R_ABS(len));\n\t\t\t\t\t\tmemcpy (core->block, buf, core->blocksize);\n\t\t\t\t\t\tcore->fixedblock = true;\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teprintf (\"cannot allocate\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Invalid @x: syntax\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'k': // \"@k\"\n\t\t\t\t {\n\t\t\t\t\tchar *out = sdb_querys (core->sdb, NULL, 0, ptr + ((ptr[1])? 2: 1));\n\t\t\t\t\tif (out) {\n\t\t\t\t\t\tr_core_seek (core, r_num_math (core->num, out), 1);\n\t\t\t\t\t\tfree (out);\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\tbreak;\n\t\t\tcase 'o': // \"@o:3\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\ttmpfd = core->io->raised;\n\t\t\t\t\tr_io_raise (core->io, atoi (ptr + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a': // \"@a:\"\n\t\t\t\tif (ptr[1] == ':') {\n\t\t\t\t\tchar *q = strchr (ptr + 2, ':');\n\t\t\t\t\ttmpasm = strdup (r_config_get (core->config, \"asm.arch\"));\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\t*q++ = 0;\n\t\t\t\t\t\ttmpbits = r_config_get (core->config, \"asm.bits\");\n\t\t\t\t\t\tr_config_set (core->config, \"asm.bits\", q);\n\t\t\t\t\t}\n\t\t\t\t\tr_config_set (core->config, \"asm.arch\", ptr + 2);\n\t\t\t\t\t// TODO: handle asm.bits\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"Usage: pd 10 @a:arm:32\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's': // \"@s:\"\n\t\t\t\tlen = strlen (ptr + 2);\n\t\t\t\tr_core_block_size (core, len);\n\t\t\t\tmemcpy (core->block, ptr + 2, len);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t\t*ptr = '@';\n\t\t\tgoto next_arroba; //ignore; //return ret;\n\t\t}\nignore:\n\t\tptr = r_str_trim_head (ptr + 1);\n\t\tptr--;\n\n\t\tcmd = r_str_clean (cmd);\n\t\tif (ptr2) {\n\t\t\tif (strlen (ptr + 1) == 13 && strlen (ptr2 + 1) == 6 &&\n\t\t\t    !memcmp (ptr + 1, \"0x\", 2) &&\n\t\t\t    !memcmp (ptr2 + 1, \"0x\", 2)) {\n\t\t\t\t/* 0xXXXX:0xYYYY */\n\t\t\t} else if (strlen (ptr + 1) == 9 && strlen (ptr2 + 1) == 4) {\n\t\t\t\t/* XXXX:YYYY */\n\t\t\t} else {\n\t\t\t\t*ptr2 = '\\0';\n\t\t\t\tif (!ptr2[1]) {\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tr_core_block_size (\n\t\t\t\t\tcore, r_num_math (core->num, ptr2 + 1));\n\t\t\t}\n\t\t}\n\n\t\toffstr = r_str_trim_head (ptr + 1);\n\n\t\taddr = r_num_math (core->num, offstr);\n\t\tif (isalpha ((unsigned char)ptr[1]) && !addr) {\n\t\t\tif (!r_flag_get (core->flags, ptr + 1)) {\n\t\t\t\teprintf (\"Invalid address (%s)\\n\", ptr + 1);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tchar ch = *offstr;\n\t\t\tif (ch == '-' || ch == '+') {\n\t\t\t\taddr = core->offset + addr;\n\t\t\t}\n\t\t}\nnext_arroba:\n\t\tif (arroba) {\n\t\t\tptr = arroba;\n\t\t\tarroba = NULL;\n\t\t\tgoto repeat_arroba;\n\t\t}\n\t\tif (ptr[1] == '@') {\n\t\t\t// TODO: remove temporally seek (should be done by cmd_foreach)\n\t\t\tif (ptr[2] == '@') {\n\t\t\t\tchar *rule = ptr + 3;\n\t\t\t\twhile (*rule && *rule == ' ') rule++;\n\t\t\t\tret = r_core_cmd_foreach3 (core, cmd, rule);\n\t\t\t} else {\n\t\t\t\tret = r_core_cmd_foreach (core, cmd, ptr + 2);\n\t\t\t}\n\t\t\t//ret = -1; /* do not run out-of-foreach cmd */\n\t\t} else {\n\t\t\tbool tmpseek = false;\n\t\t\tconst char *fromvars[] = { \"anal.from\", \"diff.from\", \"graph.from\",\n\t\t\t\t\"io.buffer.from\", \"lines.from\", \"search.from\", \"zoom.from\", NULL };\n\t\t\tconst char *tovars[] = { \"anal.to\", \"diff.to\", \"graph.to\",\n\t\t\t\t\"io.buffer.to\", \"lines.to\", \"search.to\", \"zoom.to\", NULL };\n\t\t\tut64 curfrom[R_ARRAY_SIZE (fromvars) - 1], curto[R_ARRAY_SIZE (tovars) - 1];\n\n\t\t\t// @..\n\t\t\tif (ptr[1] == '.' && ptr[2] == '.') {\n\t\t\t\tchar *range = ptr + 3;\n\t\t\t\tchar *p = strchr (range, ' ');\n\t\t\t\tif (!p) {\n\t\t\t\t\teprintf (\"Usage: / ABCD @..0x1000 0x3000\\n\");\n\t\t\t\t\tfree (tmpeval);\n\t\t\t\t\tfree (tmpasm);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\t*p = '\\x00';\n\t\t\t\tut64 from = r_num_math (core->num, range);\n\t\t\t\tut64 to = r_num_math (core->num, p + 1);\n\t\t\t\t// save current ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tcurfrom[i] = r_config_get_i (core->config, fromvars[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tcurto[i] = r_config_get_i (core->config, tovars[i]);\n\t\t\t\t}\n\t\t\t\t// set new ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], from);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], to);\n\t\t\t\t}\n\t\t\t\ttmpseek = true;\n\t\t\t}\n\t\t\tif (usemyblock) {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tcore->offset = addr;\n\t\t\t\t}\n\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t} else {\n\t\t\t\tif (addr != UT64_MAX) {\n\t\t\t\t\tif (!ptr[1] || r_core_seek (core, addr, 1)) {\n\t\t\t\t\t\tr_core_block_read (core);\n\t\t\t\t\t\tret = r_cmd_call (core->rcmd, r_str_trim_head (cmd));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmpseek) {\n\t\t\t\t// restore ranges\n\t\t\t\tfor (i = 0; fromvars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, fromvars[i], curfrom[i]);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; tovars[i]; i++) {\n\t\t\t\t\tr_config_set_i (core->config, tovars[i], curto[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ptr2) {\n\t\t\t*ptr2 = '!';\n\t\t\tr_core_block_size (core, tmpbsz);\n\t\t}\n\t\tif (tmpasm) {\n\t\t\tr_config_set (core->config, \"asm.arch\", tmpasm);\n\t\t\ttmpasm = NULL;\n\t\t}\n\t\tif (tmpfd != -1) {\n\t\t\tr_io_raise (core->io, tmpfd);\n\t\t}\n\t\tif (tmpbits) {\n\t\t\tr_config_set (core->config, \"asm.bits\", tmpbits);\n\t\t\ttmpbits = NULL;\n\t\t}\n\t\tif (tmpeval) {\n\t\t\tr_core_cmd0 (core, tmpeval);\n\t\t\tR_FREE (tmpeval);\n\t\t}\n\t\tr_core_seek (core, tmpoff, 1);\n\t\t*ptr = '@';\n\t\trc = ret;\n\t\tgoto beach;\n\t}\n\n\trc = cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;\nbeach:\n\tif (scr_html != -1) {\n\t\tr_cons_flush ();\n\t\tr_config_set_i (core->config, \"scr.html\", scr_html);\n\t}\n\tif (scr_color != -1) {\n\t\tr_config_set_i (core->config, \"scr.color\", scr_color);\n\t}\n\tcore->fixedblock = false;\n\treturn rc;\nfail:\n\trc = -1;\n\tgoto beach;\n}\n\nstatic int foreach_comment(void *user, const char *k, const char *v) {\n\tRAnalMetaUserItem *ui = user;\n\tRCore *core = ui->anal->user;\n\tconst char *cmd = ui->user;\n\tif (!strncmp (k, \"meta.C.\", 7)) {\n\t\tchar *cmt = (char *)sdb_decode (v, 0);\n\t\tif (!cmt) cmt = strdup (\"\");\n\t\t//eprintf (\"--> %s = %s\\n\", k + 7, cmt);\n\t\tr_core_cmdf (core, \"s %s\", k + 7);\n\t\tr_core_cmd0 (core, cmd);\n\t\tfree (cmt);\n\t}\n\treturn 1;\n}\n\nR_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) {\n\tRDebug *dbg = core->dbg;\n\tRList *list, *head;\n\tRListIter *iter;\n\tRFlagItem *flg;\n\tint i;\n\n\tswitch (each[0]) {\n\tcase '=':\n\t\t{\n\t\tchar *arg;\n\t\tfor (arg = each + 1; ; ) {\n\t\t\tchar *next = strchr (arg, ' ');\n\t\t\tif (next) {\n\t\t\t\t*next = 0;\n\t\t\t}\n\t\t\tif (arg && *arg) {\n\t\t\t\tr_core_cmdf (core, \"%s %s\", cmd, arg);\n\t\t\t}\n\t\t\tif (!next) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ = next + 1;\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '?':\n\t\tr_cons_printf (\"Usage: @@@ [type]     # types:\\n\"\n\t\t\t\" symbols\\n\"\n\t\t\t\" imports\\n\"\n\t\t\t\" regs\\n\"\n\t\t\t\" threads\\n\"\n\t\t\t\" comments\\n\"\n\t\t\t\" functions\\n\"\n\t\t\t\" flags\\n\");\n\t\tbreak;\n\tcase 'c':\n\t\tswitch (each[1]) {\n\t\tcase 'a': // call\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_list_cb (core->anal, R_META_TYPE_COMMENT, 0, foreach_comment, (void*)cmd, UT64_MAX);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 't':\n\t\t// iterate over all threads\n\t\tif (dbg && dbg->h && dbg->h->threads) {\n\t\t\tint origpid = dbg->pid;\n\t\t\tRDebugPid *p;\n\t\t\tlist = dbg->h->threads (dbg, dbg->pid);\n\t\t\tif (!list)\n\t\t\t\treturn false;\n\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\tr_core_cmdf (core, \"dp %d\", p->pid);\n\t\t\t\tr_cons_printf (\"PID %d\\n\", p->pid);\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t}\n\t\t\tr_core_cmdf (core, \"dp %d\", origpid);\n\t\t\tr_list_free (list);\n\t\t}\n\t\tbreak;\n\tcase 'r':\n\t\t// registers\n\t\t{\n\t\t\tut64 offorig = core->offset;\n\t\t\tfor (i = 0; i < 128; i++) {\n\t\t\t\tRRegItem *item;\n\t\t\t\tut64 value;\n\t\t\t\thead = r_reg_get_list (dbg->reg, i);\n\t\t\t\tif (!head) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_list_foreach (head, iter, item) {\n\t\t\t\t\tif (item->size != core->anal->bits) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvalue = r_reg_get_value (dbg->reg, item);\n\t\t\t\t\tr_core_seek (core, value, 1);\n\t\t\t\t\tr_cons_printf (\"%s: \", item->name);\n\t\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_seek (core, offorig, 1);\n\t\t}\n\t\tbreak;\n\tcase 'i':\n\t\t// imports\n\t\t{\n\t\t\tRBinImport *imp;\n\t\t\tut64 offorig = core->offset;\n\t\t\tlist = r_bin_get_imports (core->bin);\n\t\t\tr_list_foreach (list, iter, imp) {\n\t\t\t\tchar *impflag = r_str_newf (\"sym.imp.%s\", imp->name);\n\t\t\t\tut64 addr = r_num_math (core->num, impflag);\n\t\t\t\tif (addr && addr != UT64_MAX) {\n\t\t\t\t\tr_core_seek (core, addr, 1);\n\t\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_seek (core, offorig, 1);\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\t// symbols\n\t\t{\n\t\t\tRBinSymbol *sym;\n\t\t\tut64 offorig = core->offset;\n\t\t\tlist = r_bin_get_symbols (core->bin);\n\t\t\tr_list_foreach (list, iter, sym) {\n\t\t\t\tr_core_seek (core, sym->vaddr, 1);\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t}\n\t\t\tr_core_seek (core, offorig, 1);\n\t\t}\n\t\tbreak;\n\tcase 'f':\n\t\tswitch (each[1]) {\n\t\tcase 'l': // flags\n\t\t\tr_list_foreach (core->flags->flags, iter, flg) {\n\t\t\t\tr_core_seek (core, flg->offset, 1);\n\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u': // functions\n\t\t\t{\n\t\t\t\tut64 offorig = core->offset;\n\t\t\t\tRAnalFunction *fcn;\n\t\t\t\tlist = core->anal->fcns;\n\t\t\t\tr_list_foreach (list, iter, fcn) {\n\t\t\t\t\tr_cons_printf (\"[0x%08\"PFMT64x\"  %s\\n\", fcn->addr, fcn->name);\n\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n\t\t\t\t\tr_core_cmd0 (core, cmd);\n\t\t\t\t}\n\t\t\t\tr_core_seek (core, offorig, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void foreachOffset (RCore *core, const char *_cmd, const char *each) {\n\tchar *cmd = strdup (_cmd);\n\tchar *str = cmd;\n\tchar *nextLine = NULL;\n\tut64 addr;\n\t/* foreach list of items */\n\twhile (each) {\n\t\t// skip spaces\n\t\twhile (*each == ' ') {\n\t\t\teach++;\n\t\t}\n\t\t// stahp if empty string\n\t\tif (!*each) {\n\t\t\tbreak;\n\t\t}\n\t\t// find newline\n\t\tchar *nl = strchr (each, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\tnextLine = nl + 1;\n\t\t} else {\n\t\t\tnextLine = NULL;\n\t\t}\n\t\t// chop comment in line\n\t\tnl = strchr (each, '#');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t}\n\t\t// space separated numbers\n\t\twhile (each && *each) {\n\t\t\t// find spaces\n\t\t\twhile (*each== ' ') each++;\n\t\t\tstr = strchr (each, ' ');\n\t\t\tif (str) {\n\t\t\t\t*str = '\\0';\n\t\t\t\taddr = r_num_math (core->num, each);\n\t\t\t\t*str = ' ';\n\t\t\t\teach = str + 1;\n\t\t\t} else {\n\t\t\t\tif (!*each) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\taddr = r_num_math (core->num, each);\n\t\t\t\teach = NULL;\n\t\t\t}\n\t\t\tr_core_seek (core, addr, 1);\n\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\tr_cons_flush ();\n\t\t}\n\t\teach = nextLine;\n\t}\n\tfree (cmd);\n}\n\nR_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {\n\tint i, j;\n\tchar ch;\n\tchar *word = NULL;\n\tchar *str, *ostr;\n\tRListIter *iter;\n\tRFlagItem *flag;\n\tut64 oseek, addr;\n\n\t// for (; *each == ' '; each++);\n\tfor (; *cmd == ' '; cmd++);\n\n\toseek = core->offset;\n\tostr = str = strdup (each);\n\tr_cons_break_push (NULL, NULL); //pop on return\n\tswitch (each[0]) {\n\tcase '/': // \"@@/\"\n\t\t{\n\t\tchar *cmdhit = strdup (r_config_get (core->config, \"cmd.hit\"));\n\t\tr_config_set (core->config, \"cmd.hit\", cmd);\n\t\tr_core_cmd0 (core, each);\n\t\tr_config_set (core->config, \"cmd.hit\", cmdhit);\n\t\tfree (cmdhit);\n\t\t}\n\t\treturn 0;\n\tcase '?':\n\t\thelpCmdForeach (core);\n\t\tbreak;\n\tcase 'b': // \"@@b\" - function basic blocks\n\t\t{\n\t\t\tRListIter *iter;\n\t\t\tRAnalBlock *bb;\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n\t\t\tint bs = core->blocksize;\n\t\t\tif (fcn) {\n\t\t\t\tr_list_sort (fcn->bbs, bb_cmp);\n\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\tr_core_block_size (core, bb->size);\n\t\t\t\t\tr_core_seek (core, bb->addr, 1);\n\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\tr_core_block_size (core, bs);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tbreak;\n\tcase 'i': // \"@@i\" - function instructions\n\t\t{\n\t\t\tRListIter *iter;\n\t\t\tRAnalBlock *bb;\n\t\t\tint i;\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_at (core->anal, core->offset, 0);\n\t\t\tif (fcn) {\n\t\t\t\tr_list_sort (fcn->bbs, bb_cmp);\n\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\tfor (i = 0; i < bb->op_pos_size; i++) {\n\t\t\t\t\t\tut64 addr = bb->addr + bb->op_pos[i];\n\t\t\t\t\t\tr_core_seek (core, addr, 1);\n\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tbreak;\n\tcase 'f': // \"@@f\"\n\t\tif (each[1] == ':') {\n\t\t\tRAnalFunction *fcn;\n\t\t\tRListIter *iter;\n\t\t\tif (core->anal) {\n\t\t\t\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t\t\t\tif (each[2] && strstr (fcn->name, each + 2)) {\n\t\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\tgoto out_finish;\n\t\t} else {\n\t\t\tRAnalFunction *fcn;\n\t\t\tRListIter *iter;\n\t\t\tif (core->anal) {\n\t\t\t\tRConsGrep grep = core->cons->grep;\n\t\t\t\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\t\t\t\tchar *buf;\n\t\t\t\t\tr_core_seek (core, fcn->addr, 1);\n\t\t\t\t\tr_cons_push ();\n\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\tbuf = (char *)r_cons_get_buffer ();\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\tbuf = strdup (buf);\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_pop ();\n\t\t\t\t\tr_cons_strcat (buf);\n\t\t\t\t\tfree (buf);\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcore->cons->grep = grep;\n\t\t\t}\n\t\t\tfree (ostr);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tbreak;\n\tcase 't':\n\t\t{\n\t\t\tRDebugPid *p;\n\t\t\tint pid = core->dbg->pid;\n\t\t\tif (core->dbg->h && core->dbg->h->pids) {\n\t\t\t\tRList *list = core->dbg->h->pids (core->dbg, R_MAX (0, pid));\n\t\t\t\tr_list_foreach (list, iter, p) {\n\t\t\t\t\tr_cons_printf (\"# PID %d\\n\", p->pid);\n\t\t\t\t\tr_debug_select (core->dbg, p->pid, p->pid);\n\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\tr_cons_newline ();\n\t\t\t\t}\n\t\t\t\tr_list_free (list);\n\t\t\t}\n\t\t\tr_debug_select (core->dbg, pid, pid);\n\t\t\tfree (ostr);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"@@c:\"\n\t\tif (each[1] == ':') {\n\t\t\tchar *arg = r_core_cmd_str (core, each + 2);\n\t\t\tif (arg) {\n\t\t\t\tforeachOffset (core, cmd, arg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '=':\n\t\tforeachOffset (core, cmd, str + 1);\n\t\tbreak;\n\tcase 'd':\n\t\tif (each[1] == 'b' && each[2] == 't') {\n\t\t\tut64 oseek = core->offset;\n\t\t\tRDebugFrame *frame;\n\t\t\tRListIter *iter;\n\t\t\tRList *list;\n\t\t\tlist = r_debug_frames (core->dbg, UT64_MAX);\n\t\t\ti = 0;\n\t\t\tr_list_foreach (list, iter, frame) {\n\t\t\t\tswitch (each[3]) {\n\t\t\t\tcase 'b':\n\t\t\t\t\tr_core_seek (core, frame->bp, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tr_core_seek (core, frame->sp, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase 'a':\n\t\t\t\t\tr_core_seek (core, frame->addr, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\tr_cons_newline ();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tr_core_seek (core, oseek, 0);\n\t\t\tr_list_free (list);\n\t\t} else {\n\t\t\teprintf(\"Invalid for-each statement. Use @@=dbt[abs]\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'k':\n\t\t/* foreach list of items */\n\t\t{\n\t\tchar *out = sdb_querys (core->sdb, NULL, 0, str + ((str[1])? 2: 1));\n\t\tif (out) {\n\t\t\teach = out;\n\t\t\tdo {\n\t\t\t\twhile (*each == ' ') each++;\n\t\t\t\tif (!*each) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr = strchr (each, ' ');\n\t\t\t\tif (str) {\n\t\t\t\t\t*str = '\\0';\n\t\t\t\t\taddr = r_num_math (core->num, each);\n\t\t\t\t\t*str = ' ';\n\t\t\t\t} else {\n\t\t\t\t\taddr = r_num_math (core->num, each);\n\t\t\t\t}\n\t\t\t\t//eprintf (\"; 0x%08\"PFMT64x\":\\n\", addr);\n\t\t\t\teach = str + 1;\n\t\t\t\tr_core_seek (core, addr, 1);\n\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\tr_cons_flush ();\n\t\t\t} while (str != NULL);\n\t\t\tfree (out);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\tif (each[1] == '(') {\n\t\t\tchar cmd2[1024];\n\t\t\t// XXX whats this 999 ?\n\t\t\ti = 0;\n\t\t\tfor (core->rcmd->macro.counter = 0; i < 999; core->rcmd->macro.counter++) {\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr_cmd_macro_call (&core->rcmd->macro, each + 2);\n\t\t\t\tif (!core->rcmd->macro.brk_value) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\taddr = core->rcmd->macro._brk_value;\n\t\t\t\tsprintf (cmd2, \"%s @ 0x%08\"PFMT64x\"\", cmd, addr);\n\t\t\t\teprintf (\"0x%08\"PFMT64x\" (%s)\\n\", addr, cmd2);\n\t\t\t\tr_core_seek (core, addr, 1);\n\t\t\t\tr_core_cmd (core, cmd2, 0);\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else {\n\t\t\tchar buf[1024];\n\t\t\tchar cmd2[1024];\n\t\t\tFILE *fd = r_sandbox_fopen (each + 1, \"r\");\n\t\t\tif (fd) {\n\t\t\t\tcore->rcmd->macro.counter=0;\n\t\t\t\twhile (!feof (fd)) {\n\t\t\t\t\tbuf[0] = '\\0';\n\t\t\t\t\tif (!fgets (buf, sizeof (buf), fd)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\taddr = r_num_math (core->num, buf);\n\t\t\t\t\teprintf (\"0x%08\"PFMT64x\": %s\\n\", addr, cmd);\n\t\t\t\t\tsprintf (cmd2, \"%s @ 0x%08\"PFMT64x\"\", cmd, addr);\n\t\t\t\t\tr_core_seek (core, addr, 1); // XXX\n\t\t\t\t\tr_core_cmd (core, cmd2, 0);\n\t\t\t\t\tcore->rcmd->macro.counter++;\n\t\t\t\t}\n\t\t\t\tfclose (fd);\n\t\t\t} else {\n\t\t\t\teprintf (\"cannot open file '%s' to read offsets\\n\", each + 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcore->rcmd->macro.counter = 0;\n\t\tfor (; *each == ' '; each++);\n\t\ti = 0;\n\t\twhile (str[i]) {\n\t\t\tj = i;\n\t\t\tfor (; str[j] && str[j] == ' '; j++); // skip spaces\n\t\t\tfor (i = j; str[i] && str[i] != ' '; i++); // find EOS\n\t\t\tch = str[i];\n\t\t\tstr[i] = '\\0';\n\t\t\tword = strdup (str + j);\n\t\t\tif (!word) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstr[i] = ch;\n\t\t\t{\n\t\t\t\tint flagspace = core->flags->space_idx;\n\t\t\t\t/* for all flags in current flagspace */\n\t\t\t\t// XXX: dont ask why, but this only works with _prev..\n\t\t\t\tr_list_foreach (core->flags->flags, iter, flag) {\n\t\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* filter per flag spaces */\n\t\t\t\t\tif ((flagspace != -1) && (flag->space != flagspace)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (r_str_glob (flag->name, word)) {\n\t\t\t\t\t\tchar *buf = NULL;\n\t\t\t\t\t\tconst char *tmp = NULL;\n\t\t\t\t\t\tr_core_seek (core, flag->offset, 1);\n\t\t\t\t\t\tr_cons_push ();\n\t\t\t\t\t\tr_core_cmd (core, cmd, 0);\n\t\t\t\t\t\ttmp = r_cons_get_buffer ();\n\t\t\t\t\t\tbuf = tmp? strdup (tmp): NULL;\n\t\t\t\t\t\tr_cons_pop ();\n\t\t\t\t\t\tr_cons_strcat (buf);\n\t\t\t\t\t\tfree (buf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcore->flags->space_idx = flagspace;\n\t\t\t\tcore->rcmd->macro.counter++ ;\n\t\t\t\tfree (word);\n\t\t\t\tword = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\t// XXX: use r_core_seek here\n\tcore->offset = oseek;\n\n\tfree (word);\n\tfree (ostr);\n\treturn true;\nout_finish:\n\tr_cons_break_pop ();\n\treturn false;\n}\n\nR_API int r_core_cmd(RCore *core, const char *cstr, int log) {\n\tchar *cmd, *ocmd, *ptr, *rcmd;\n\tint ret = false, i;\n\n\tr_th_lock_enter (core->lock);\n\tif (core->cmdfilter) {\n\t\tconst char *invalid_chars = \";|>`@\";\n\t\tfor (i = 0; invalid_chars[i]; i++) {\n\t\t\tif (strchr (cstr, invalid_chars[i])) {\n\t\t\t\tret = true;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tif (strncmp (cstr, core->cmdfilter, strlen (core->cmdfilter))) {\n\t\t\tret = true;\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (core->cmdremote) {\n\t\tif (*cstr != '=' && *cstr != 'q' && strncmp (cstr, \"!=\", 2)) {\n\t\t\tr_io_system (core->io, cstr);\n\t\t\tgoto beach; // false\n\t\t}\n\t}\n\n\tif (!cstr || *cstr == '|') {\n\t\t// raw comment syntax\n\t\tgoto beach; // false;\n\t}\n\tif (!strncmp (cstr, \"/*\", 2)) {\n\t\tif (r_sandbox_enable (0)) {\n\t\t\teprintf (\"This command is disabled in sandbox mode\\n\");\n\t\t\tgoto beach; // false\n\t\t}\n\t\tcore->incomment = true;\n\t} else if (!strncmp (cstr, \"*/\", 2)) {\n\t\tcore->incomment = false;\n\t\tgoto beach; // false\n\t}\n\tif (core->incomment) {\n\t\tgoto beach; // false\n\t}\n\tif (log && (*cstr && (*cstr != '.' || !strncmp (cstr, \".(\", 2)))) {\n\t\tfree (core->lastcmd);\n\t\tcore->lastcmd = strdup (cstr);\n\t}\n\n\tocmd = cmd = malloc (strlen (cstr) + 4096);\n\tif (!ocmd) {\n\t\tgoto beach;\n\t}\n\tr_str_cpy (cmd, cstr);\n\tif (log) {\n\t\tr_line_hist_add (cstr);\n\t}\n\n\tif (core->cmd_depth < 1) {\n\t\teprintf (\"r_core_cmd: That was too deep (%s)...\\n\", cmd);\n\t\tfree (ocmd);\n\t\tfree (core->oobi);\n\t\tcore->oobi = NULL;\n\t\tcore->oobi_len = 0;\n\t\tgoto beach;\n\t}\n\tcore->cmd_depth--;\n\tfor (rcmd = cmd;;) {\n\t\tptr = strchr (rcmd, '\\n');\n\t\tif (ptr) {\n\t\t\t*ptr = '\\0';\n\t\t}\n\t\tret = r_core_cmd_subst (core, rcmd);\n\t\tif (ret == -1) {\n\t\t\teprintf (\"|ERROR| Invalid command '%s' (0x%02x)\\n\", rcmd, *rcmd);\n\t\t\tbreak;\n\t\t}\n\t\tif (!ptr) {\n\t\t\tbreak;\n\t\t}\n\t\trcmd = ptr + 1;\n\t}\n\tr_th_lock_leave (core->lock);\n\t/* run pending analysis commands */\n\tif (core->anal->cmdtail) {\n\t\tchar *res = core->anal->cmdtail;\n\t\tcore->anal->cmdtail = NULL;\n\t\tr_core_cmd_lines (core, res);\n\t\tfree (res);\n\t}\n\tcore->cmd_depth++;\n\tfree (ocmd);\n\tfree (core->oobi);\n\tcore->oobi = NULL;\n\tcore->oobi_len = 0;\n\treturn ret;\nbeach:\n\tr_th_lock_leave (core->lock);\n\t/* run pending analysis commands */\n\tif (core->anal->cmdtail) {\n\t\tchar *res = core->anal->cmdtail;\n\t\tcore->anal->cmdtail = NULL;\n\t\tr_core_cmd0 (core, res);\n\t\tfree (res);\n\t}\n\treturn ret;\n}\n\nR_API int r_core_cmd_lines(RCore *core, const char *lines) {\n\tint r, ret = true;\n\tchar *nl, *data, *odata;\n\n\tif (!lines || !*lines) {\n\t\treturn true;\n\t}\n\tdata = odata = strdup (lines);\n\tif (!odata) {\n\t\treturn false;\n\t}\n\tnl = strchr (odata, '\\n');\n\tif (nl) {\n\t\tr_cons_break_push (NULL, NULL);\n\t\tdo {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tfree (odata);\n\t\t\t\tr_cons_break_pop ();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t*nl = '\\0';\n\t\t\tr = r_core_cmd (core, data, 0);\n\t\t\tif (r < 0) { //== -1) {\n\t\t\t\tdata = nl + 1;\n\t\t\t\tret = -1; //r; //false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_cons_flush ();\n\t\t\tif (data[0] == 'q') {\n\t\t\t\tif (data[1] == '!') {\n\t\t\t\t\tret = -1;\n\t\t\t\t} else {\n\t\t\t\t\teprintf (\"'q': quit ignored. Use 'q!'\\n\");\n\t\t\t\t}\n\t\t\t\tdata = nl + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata = nl + 1;\n\t\t} while ((nl = strchr (data, '\\n')));\n\t\tr_cons_break_pop ();\n\t}\n\tif (ret >= 0 && data && *data) {\n\t\tr_core_cmd (core, data, 0);\n\t}\n\tfree (odata);\n\treturn ret;\n}\n\nR_API int r_core_cmd_file(RCore *core, const char *file) {\n\tchar *data, *odata;\n\tdata = r_file_abspath (file);\n\tif (!data) return false;\n\todata = r_file_slurp (data, NULL);\n\tfree (data);\n\tif (!odata) return false;\n\tif (!r_core_cmd_lines (core, odata)) {\n\t\teprintf (\"Failed to run script '%s'\\n\", file);\n\t\tfree (odata);\n\t\treturn false;\n\t}\n\tfree (odata);\n\treturn true;\n}\n\nR_API int r_core_cmd_command(RCore *core, const char *command) {\n\tint ret, len;\n\tchar *buf, *rcmd, *ptr;\n\tchar *cmd = r_core_sysenv_begin (core, command);\n\trcmd = ptr = buf = r_sys_cmd_str (cmd, 0, &len);\n\tif (!buf) {\n\t\tfree (cmd);\n\t\treturn -1;\n\t}\n\tret = r_core_cmd (core, rcmd, 0);\n\tr_core_sysenv_end (core, command);\n\tfree (buf);\n\treturn ret;\n}\n\n//TODO: Fix disasm loop is mandatory\nR_API char *r_core_disassemble_instr(RCore *core, ut64 addr, int l) {\n\tchar *cmd, *ret = NULL;\n\tcmd = r_str_newf (\"pd %i @ 0x%08\"PFMT64x, l, addr);\n\tif (cmd) {\n\t\tret = r_core_cmd_str (core, cmd);\n\t\tfree (cmd);\n\t}\n\treturn ret;\n}\n\nR_API char *r_core_disassemble_bytes(RCore *core, ut64 addr, int b) {\n\tchar *cmd, *ret = NULL;\n\tcmd = r_str_newf (\"pD %i @ 0x%08\"PFMT64x, b, addr);\n\tif (cmd) {\n\t\tret = r_core_cmd_str (core, cmd);\n\t\tfree (cmd);\n\t}\n\treturn ret;\n}\n\nR_API int r_core_cmd_buffer(void *user, const char *buf) {\n\tchar *ptr, *optr, *str = strdup (buf);\n\tif (!str) return false;\n\toptr = str;\n\tptr = strchr (str, '\\n');\n\twhile (ptr) {\n\t\t*ptr = '\\0';\n\t\tr_core_cmd (user, optr, 0);\n\t\toptr = ptr + 1;\n\t\tptr = strchr (str, '\\n');\n\t}\n\tr_core_cmd (user, optr, 0);\n\tfree (str);\n\treturn true;\n}\n\nR_API int r_core_cmdf(void *user, const char *fmt, ...) {\n\tchar string[4096];\n\tint ret;\n\tva_list ap;\n\tva_start (ap, fmt);\n\tvsnprintf (string, sizeof (string), fmt, ap);\n\tret = r_core_cmd ((RCore *)user, string, 0);\n\tva_end (ap);\n\treturn ret;\n}\n\nR_API int r_core_cmd0(void *user, const char *cmd) {\n\treturn r_core_cmd ((RCore *)user, cmd, 0);\n}\n\nR_API int r_core_flush(void *user, const char *cmd) {\n\tint ret = r_core_cmd ((RCore *)user, cmd, 0);\n\tr_cons_flush ();\n\treturn ret;\n}\n\nR_API char *r_core_cmd_str_pipe(RCore *core, const char *cmd) {\n\tchar *s, *tmp = NULL;\n\tif (r_sandbox_enable (0)) {\n\t\treturn r_core_cmd_str (core, cmd);\n\t}\n\tr_cons_reset ();\n\tr_sandbox_disable (1);\n\tif (r_file_mkstemp (\"cmd\", &tmp) != -1) {\n\t\tint pipefd = r_cons_pipe_open (tmp, 1, 0);\n\t\tif (pipefd == -1) {\n\t\t\tr_sandbox_disable (0);\n\t\t\treturn r_core_cmd_str (core, cmd);\n\t\t}\n\t\tchar *_cmd = strdup (cmd);\n\t\tr_core_cmd_subst (core, _cmd);\n\t\tr_cons_flush ();\n\t\tr_cons_pipe_close (pipefd);\n\t\ts = r_file_slurp (tmp, NULL);\n\t\tif (s) {\n\t\t\tr_file_rm (tmp);\n\t\t\tr_sandbox_disable (0);\n\t\t\tfree (tmp);\n\t\t\tfree (_cmd);\n\t\t\treturn s;\n\t\t}\n\t\teprintf (\"slurp %s fails\\n\", tmp);\n\t\tr_file_rm (tmp);\n\t\tfree (tmp);\n\t\tfree (_cmd);\n\t\tr_sandbox_disable (0);\n\t\treturn r_core_cmd_str (core, cmd);\n\t}\n\tr_sandbox_disable (0);\n\treturn NULL;\n}\n\nR_API char *r_core_cmd_strf(RCore *core, const char *fmt, ...) {\n\tchar string[4096];\n\tchar *ret;\n\tva_list ap;\n\tva_start (ap, fmt);\n\tvsnprintf (string, sizeof (string), fmt, ap);\n\tret = r_core_cmd_str (core, string);\n\tva_end (ap);\n\treturn ret;\n}\n\n/* return: pointer to a buffer with the output of the command */\nR_API char *r_core_cmd_str(RCore *core, const char *cmd) {\n\tconst char *static_str;\n\tchar *retstr = NULL;\n\tr_cons_push ();\n\tif (r_core_cmd (core, cmd, 0) == -1) {\n\t\t//eprintf (\"Invalid command: %s\\n\", cmd);\n\t\treturn NULL;\n\t}\n\tr_cons_filter ();\n\tstatic_str = r_cons_get_buffer ();\n\tretstr = strdup (static_str? static_str: \"\");\n\tr_cons_pop ();\n\treturn retstr;\n}\n\nR_API void r_core_cmd_repeat(RCore *core, int next) {\n\t// Fix for backtickbug px`~`\n\tif (core->cmd_depth + 1 < R_CORE_CMD_DEPTH)\n\t\treturn;\n\tif (core->lastcmd)\n\tswitch (*core->lastcmd) {\n\tcase '.':\n\t\tif (core->lastcmd[1] == '(') // macro call\n\t\t\tr_core_cmd0 (core, core->lastcmd);\n\t\tbreak;\n\tcase 'd': // debug\n\t\tr_core_cmd0 (core, core->lastcmd);\n\t\tswitch (core->lastcmd[1]) {\n\t\tcase 's':\n\t\tcase 'c':\n\t\t\tr_core_cmd0 (core, \"sr PC;pd 1\");\n\t\t}\n\t\tbreak;\n\tcase 'p': // print\n\tcase 'x':\n\tcase '$':\n\t\tif (next) {\n\t\t\tr_core_seek (core, core->offset + core->blocksize, 1);\n\t\t} else {\n\t\t\tif (core->blocksize > core->offset) {\n\t\t\t\tr_core_seek (core, 0, 1);\n\t\t\t} else {\n\t\t\t\tr_core_seek (core, core->offset - core->blocksize, 1);\n\t\t\t}\n\t\t}\n\t\tr_core_cmd0 (core, core->lastcmd);\n\t\tbreak;\n\t}\n}\n\nstatic int cmd_ox(void *data, const char *input) {\n\treturn r_core_cmdf ((RCore*)data, \"s 0%s\", input);\n}\n\nR_API void r_core_cmd_init(RCore *core) {\n\tcore->rcmd = r_cmd_new ();\n\tcore->rcmd->macro.user = core;\n\tcore->rcmd->macro.num = core->num;\n\tcore->rcmd->macro.cmd = r_core_cmd0;\n\tcore->rcmd->nullcallback = r_core_cmd_nullcallback;\n\tcore->rcmd->macro.cb_printf = (PrintfCallback)r_cons_printf;\n\tr_cmd_set_data (core->rcmd, core);\n\tr_cmd_add (core->rcmd, \"0x\",       \"alias for px\", &cmd_ox);\n\tr_cmd_add (core->rcmd, \"x\",        \"alias for px\", &cmd_hexdump);\n\tr_cmd_add (core->rcmd, \"mount\",    \"mount filesystem\", &cmd_mount);\n\tr_cmd_add (core->rcmd, \"analysis\", \"analysis\", &cmd_anal);\n\tr_cmd_add (core->rcmd, \"flag\",     \"get/set flags\", &cmd_flag);\n\tr_cmd_add (core->rcmd, \"g\",        \"egg manipulation\", &cmd_egg);\n\tr_cmd_add (core->rcmd, \"debug\",    \"debugger operations\", &cmd_debug);\n\tr_cmd_add (core->rcmd, \"ls\",       \"list files and directories\", &cmd_ls);\n\tr_cmd_add (core->rcmd, \"info\",     \"get file info\", &cmd_info);\n\tr_cmd_add (core->rcmd, \"cmp\",      \"compare memory\", &cmd_cmp);\n\tr_cmd_add (core->rcmd, \"seek\",     \"seek to an offset\", &cmd_seek);\n\tr_cmd_add (core->rcmd, \"Text\",     \"Text log utility\", &cmd_log);\n\tr_cmd_add (core->rcmd, \"t\",        \"type information (cparse)\", &cmd_type);\n\tr_cmd_add (core->rcmd, \"zign\",     \"zignatures\", &cmd_zign);\n\tr_cmd_add (core->rcmd, \"Section\",  \"setup section io information\", &cmd_section);\n\tr_cmd_add (core->rcmd, \"bsize\",    \"change block size\", &cmd_bsize);\n\tr_cmd_add (core->rcmd, \"kuery\",    \"perform sdb query\", &cmd_kuery);\n\tr_cmd_add (core->rcmd, \"eval\",     \"evaluate configuration variable\", &cmd_eval);\n\tr_cmd_add (core->rcmd, \"print\",    \"print current block\", &cmd_print);\n\tr_cmd_add (core->rcmd, \"write\",    \"write bytes\", &cmd_write);\n\tr_cmd_add (core->rcmd, \"Code\",     \"code metadata\", &cmd_meta);\n\tr_cmd_add (core->rcmd, \"Project\",  \"project\", &cmd_project);\n\tr_cmd_add (core->rcmd, \"open\",     \"open or map file\", &cmd_open);\n\tr_cmd_add (core->rcmd, \"yank\",     \"yank bytes\", &cmd_yank);\n\tr_cmd_add (core->rcmd, \"resize\",   \"change file size\", &cmd_resize);\n\tr_cmd_add (core->rcmd, \"Visual\",   \"enter visual mode\", &cmd_visual);\n\tr_cmd_add (core->rcmd, \"visual\",   \"enter visual mode\", &cmd_visual);\n\tr_cmd_add (core->rcmd, \"*\",        \"pointer read/write\", &cmd_pointer);\n\tr_cmd_add (core->rcmd, \"&\",        \"threading capabilities\", &cmd_thread);\n\tr_cmd_add (core->rcmd, \"%\",        \"short version of 'env' command\", &cmd_env);\n\tr_cmd_add (core->rcmd, \"!\",        \"run system command\", &cmd_system);\n\tr_cmd_add (core->rcmd, \"=\",        \"io pipe\", &cmd_rap);\n\tr_cmd_add (core->rcmd, \"\\\\\",       \"alias for =!\", &cmd_rap_run);\n\tr_cmd_add (core->rcmd, \"#\",        \"calculate hash\", &cmd_hash);\n\tr_cmd_add (core->rcmd, \"?\",        \"help message\", &cmd_help);\n\tr_cmd_add (core->rcmd, \"$\",        \"alias\", &cmd_alias);\n\tr_cmd_add (core->rcmd, \".\",        \"interpret\", &cmd_interpret);\n\tr_cmd_add (core->rcmd, \"/\",        \"search kw, pattern aes\", &cmd_search);\n\tr_cmd_add (core->rcmd, \"-\",        \"open cfg.editor and run script\", &cmd_stdin);\n\tr_cmd_add (core->rcmd, \"(\",        \"macro\", &cmd_macro);\n\tr_cmd_add (core->rcmd, \"u\",        \"uname/undo\", &cmd_uname);\n\tr_cmd_add (core->rcmd, \"quit\",     \"exit program session\", &cmd_quit);\n\tr_cmd_add (core->rcmd, \"Q\",        \"alias for q!\", &cmd_Quit);\n\tr_cmd_add (core->rcmd, \"L\",        \"manage dynamically loaded plugins\", &cmd_plugins);\n}\n", "/* radare - LGPL - Copyright 2009-2017 - pancake */\n\n#include <string.h>\n#include \"r_bin.h\"\n#include \"r_config.h\"\n#include \"r_cons.h\"\n#include \"r_core.h\"\n\n#define PAIR_WIDTH 9\n// TODO: reuse implementation in core/bin.c\nstatic void pair(const char *a, const char *b) {\n\tchar ws[16];\n\tint al = strlen (a);\n\tif (!b) {\n\t\treturn;\n\t}\n\tmemset (ws, ' ', sizeof (ws));\n\tal = PAIR_WIDTH - al;\n\tif (al < 0) {\n\t\tal = 0;\n\t}\n\tws[al] = 0;\n\tr_cons_printf (\"%s%s%s\\n\", a, ws, b);\n}\n\nstatic bool demangle_internal(RCore *core, const char *lang, const char *s) {\n\tchar *res = NULL;\n\tint type = r_bin_demangle_type (lang);\n\tswitch (type) {\n\tcase R_BIN_NM_CXX: res = r_bin_demangle_cxx (core->bin->cur, s, 0); break;\n\tcase R_BIN_NM_JAVA: res = r_bin_demangle_java (s); break;\n\tcase R_BIN_NM_OBJC: res = r_bin_demangle_objc (NULL, s); break;\n\tcase R_BIN_NM_SWIFT: res = r_bin_demangle_swift (s, core->bin->demanglercmd); break;\n\tcase R_BIN_NM_DLANG: res = r_bin_demangle_plugin (core->bin, \"dlang\", s); break;\n\tdefault:\n\t\tr_bin_demangle_list (core->bin);\n\t\treturn true;\n\t}\n\tif (res) {\n\t\tif (*res) {\n\t\t\tprintf (\"%s\\n\", res);\n\t\t}\n\t\tfree (res);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int demangle(RCore *core, const char *s) {\n\tchar *p, *q;\n\tconst char *ss = strchr (s, ' ');\n\tif (!*s) {\n\t\treturn 0;\n\t}\n\tif (!ss) {\n\t\tconst char *lang = r_config_get (core->config, \"bin.lang\");\n\t\tdemangle_internal (core, lang, s);\n\t\treturn 1;\n\t}\n\tp = strdup (s);\n\tq = p + (ss - s);\n\t*q = 0;\n\tdemangle_internal (core, p, q + 1);\n\tfree (p);\n\treturn 1;\n}\n\n#define STR(x) (x)? (x): \"\"\nstatic void r_core_file_info(RCore *core, int mode) {\n\tconst char *fn = NULL;\n\tint dbg = r_config_get_i (core->config, \"cfg.debug\");\n\tbool io_cache = r_config_get_i (core->config, \"io.cache\");\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\tRBinFile *binfile = r_core_bin_cur (core);\n\tRCoreFile *cf = core->file;\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (binfile);\n\tif (mode == R_CORE_BIN_JSON) {\n\t\tr_cons_printf (\"{\");\n\t}\n\tif (mode == R_CORE_BIN_RADARE) {\n\t\treturn;\n\t}\n\tif (mode == R_CORE_BIN_SIMPLE) {\n\t\treturn;\n\t}\n\tif (info) {\n\t\tfn = info->file;\n\t\tif (mode == R_CORE_BIN_JSON) {\n\t\t\tr_cons_printf (\"\\\"type\\\":\\\"%s\\\"\", STR (info->type));\n\t\t}\n\t} else {\n\t\tfn = (cf && cf->desc)? cf->desc->name: NULL;\n\t}\n\tif (cf && mode == R_CORE_BIN_JSON) {\n\t\tconst char *uri = fn;\n\t\tif (!uri) {\n\t\t\tif (cf->desc && cf->desc->uri && *cf->desc->uri) {\n\t\t\t\turi = cf->desc->uri;\n\t\t\t} else {\n\t\t\t\turi = \"\";\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tchar *escapedFile = r_str_utf16_encode (uri, -1);\n\t\t\tr_cons_printf (\",\\\"file\\\":\\\"%s\\\"\", escapedFile);\n\t\t\tfree (escapedFile);\n\t\t}\n\t\tif (dbg) {\n\t\t\tdbg = R_IO_WRITE | R_IO_EXEC;\n\t\t}\n\t\tif (cf->desc) {\n\t\t\tut64 fsz = r_io_desc_size (core->io, cf->desc);\n\t\t\tr_cons_printf (\",\\\"fd\\\":%d\", cf->desc->fd);\n\t\t\tif (fsz != UT64_MAX) {\n\t\t\t\tr_cons_printf (\",\\\"size\\\":%\"PFMT64d, fsz);\n\t\t\t\tchar *humansz = r_num_units (NULL, fsz);\n\t\t\t\tif (humansz) {\n\t\t\t\t\tr_cons_printf (\",\\\"humansz\\\":\\\"%s\\\"\", humansz);\n\t\t\t\t\tfree (humansz);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_cons_printf (\",\\\"iorw\\\":%s\", r_str_bool ( io_cache ||\\\n\t\t\t\t\tcf->desc->flags & R_IO_WRITE ));\n\t\t\tr_cons_printf (\",\\\"mode\\\":\\\"%s\\\"\", r_str_rwx_i (\n\t\t\t\t\tcf->desc->flags & 7 ));\n\t\t\tr_cons_printf (\",\\\"obsz\\\":%\"PFMT64d, (ut64) core->io->desc->obsz);\n\t\t\tif (cf->desc->referer && *cf->desc->referer) {\n\t\t\t\tr_cons_printf (\",\\\"referer\\\":\\\"%s\\\"\", cf->desc->referer);\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\",\\\"block\\\":%d\", core->blocksize);\n\t\tif (binfile) {\n\t\t\tif (binfile->curxtr) {\n\t\t\t\tr_cons_printf (\",\\\"packet\\\":\\\"%s\\\"\",\n\t\t\t\t\tbinfile->curxtr->name);\n\t\t\t}\n\t\t\tif (plugin) {\n\t\t\t\tr_cons_printf (\",\\\"format\\\":\\\"%s\\\"\",\n\t\t\t\t\tplugin->name);\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\"}\");\n\t} else if (cf && mode != R_CORE_BIN_SIMPLE) {\n\t\t//r_cons_printf (\"# Core file info\\n\");\n\t\tif (dbg) {\n\t\t\tdbg = R_IO_WRITE | R_IO_EXEC;\n\t\t}\n\t\tif (cf->desc) {\n\t\t\tpair (\"blksz\", sdb_fmt (0, \"0x%\"PFMT64x, (ut64) core->io->desc->obsz));\n\t\t}\n\t\tpair (\"block\", sdb_fmt (0, \"0x%x\", core->blocksize));\n\t\tif (cf->desc) {\n\t\t\tpair (\"fd\", sdb_fmt (0, \"%d\", cf->desc->fd));\n\t\t}\n\t\tif (fn || (cf->desc && cf->desc->uri)) {\n\t\t\tpair (\"file\", fn? fn: cf->desc->uri);\n\t\t}\n\t\tif (plugin) {\n\t\t\tpair (\"format\", plugin->name);\n\t\t}\n\t\tif (cf->desc) {\n\t\t\tpair (\"iorw\", r_str_bool (io_cache || cf->desc->flags & R_IO_WRITE ));\n\t\t\tpair (\"mode\", r_str_rwx_i (cf->desc->flags & 7));\n\t\t}\n\t\tif (binfile && binfile->curxtr) {\n\t\t\tpair (\"packet\", binfile->curxtr->name);\n\t\t}\n\t\tif (cf->desc && cf->desc->referer && *cf->desc->referer) {\n\t\t\tpair (\"referer\", cf->desc->referer);\n\t\t}\n\t\tif (cf->desc) {\n\t\t\tut64 fsz = r_io_desc_size (core->io, cf->desc);\n\t\t\tif (fsz != UT64_MAX) {\n\t\t\t\tpair (\"size\", sdb_fmt (0,\"0x%\"PFMT64x, fsz));\n\t\t\t\tchar *humansz = r_num_units (NULL, fsz);\n\t\t\t\tif (humansz) {\n\t\t\t\t\tpair (\"humansz\", humansz);\n\t\t\t\t\tfree (humansz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (info) {\n\t\t\tpair (\"type\", info->type);\n\t\t}\n\t}\n}\n\nstatic int bin_is_executable(RBinObject *obj){\n\tRListIter *it;\n\tRBinSection *sec;\n\tif (obj) {\n\t\tif (obj->info && obj->info->arch) {\n\t\t\treturn true;\n\t\t}\n\t\tr_list_foreach (obj->sections, it, sec){\n\t\t\tif (R_BIN_SCN_EXECUTABLE & sec->srwx) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void cmd_info_bin(RCore *core, int va, int mode) {\n\tRBinObject *obj = r_bin_cur_object (core->bin);\n\tint array = 0;\n\tif (core->file) {\n\t\tif ((mode & R_CORE_BIN_JSON) && !(mode & R_CORE_BIN_ARRAY)) {\n\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\tr_cons_printf (\"{\\\"core\\\":\");\n\t\t}\n\t\tif ((mode & R_CORE_BIN_JSON) && (mode & R_CORE_BIN_ARRAY)) {\n\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\tarray = 1;\n\t\t\tr_cons_printf (\",\\\"core\\\":\");\n\t\t}\n\t\tr_core_file_info (core, mode);\n\t\tif (bin_is_executable (obj)) {\n\t\t\tif ((mode & R_CORE_BIN_JSON)) {\n\t\t\t\tr_cons_printf (\",\\\"bin\\\":\");\n\t\t\t}\n\t\t\tr_core_bin_info (core, R_CORE_BIN_ACC_INFO, mode, va, NULL, NULL);\n\t\t}\n\t\tif (mode == R_CORE_BIN_JSON && array == 0) {\n\t\t\tr_cons_printf (\"}\\n\");\n\t\t}\n\t} else {\n\t\teprintf (\"No file selected\\n\");\n\t}\n}\n\nstatic void playMsg(RCore *core, const char *n, int len) {\n\tif (r_config_get_i (core->config, \"scr.tts\")) {\n\t\tif (len > 0) {\n\t\t\tchar *s = r_str_newf (\"%d %s\", len, n);\n\t\t\tr_sys_tts (s, true);\n\t\t\tfree (s);\n\t\t} else if (len == 0) {\n\t\t\tchar *s = r_str_newf (\"there are no %s\", n);\n\t\t\tr_sys_tts (s, true);\n\t\t\tfree (s);\n\t\t}\n\t}\n}\n\nstatic int cmd_info(void *data, const char *input) {\n\tRCore *core = (RCore *) data;\n\tbool newline = r_config_get_i (core->config, \"scr.interactive\");\n\tRBinObject *o = r_bin_cur_object (core->bin);\n\tRCoreFile *cf = core->file;\n\tint i, va = core->io->va || core->io->debug;\n\tint mode = 0; //R_CORE_BIN_SIMPLE;\n\tint is_array = 0;\n\tSdb *db;\n\n\tfor (i = 0; input[i] && input[i] != ' '; i++)\n\t\t;\n\tif (i > 0) {\n\t\tswitch (input[i - 1]) {\n\t\tcase '*': mode = R_CORE_BIN_RADARE; break;\n\t\tcase 'j': mode = R_CORE_BIN_JSON; break;\n\t\tcase 'q': mode = R_CORE_BIN_SIMPLE; break;\n\t\t}\n\t}\n\n\tif (mode == R_CORE_BIN_JSON) {\n\t\tif (strlen (input + 1) > 1) {\n\t\t\tis_array = 1;\n\t\t}\n\t}\n\tif (is_array) {\n\t\tr_cons_printf (\"{\");\n\t}\n\tif (!*input) {\n\t\tcmd_info_bin (core, va, mode);\n\t}\n\t/* i* is an alias for iI* */\n\tif (!strcmp (input, \"*\")) {\n\t\tinput = \"I*\";\n\t}\n\tRBinObject *obj = r_bin_cur_object (core->bin);\n\twhile (*input) {\n\t\tswitch (*input) {\n\t\tcase 'b': // \"ib\"\n\t\t{\n\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\tif (input[1] == ' ') {\n\t\t\t\tbaddr = r_num_math (core->num, input + 1);\n\t\t\t}\n\t\t\t// XXX: this will reload the bin using the buffer.\n\t\t\t// An assumption is made that assumes there is an underlying\n\t\t\t// plugin that will be used to load the bin (e.g. malloc://)\n\t\t\t// TODO: Might be nice to reload a bin at a specified offset?\n\t\t\tr_core_bin_reload (core, NULL, baddr);\n\t\t\tr_core_block_read (core);\n\t\t\tnewline = false;\n\t\t}\n\t\tbreak;\n\t\tcase 'k':\n\t\t\tdb = o? o->kv: NULL;\n\t\t\t//:eprintf (\"db = %p\\n\", db);\n\t\t\tswitch (input[1]) {\n\t\t\tcase 'v':\n\t\t\t\tif (db) {\n\t\t\t\t\tchar *o = sdb_querys (db, NULL, 0, input + 3);\n\t\t\t\t\tif (o && *o) {\n\t\t\t\t\t\tr_cons_print (o);\n\t\t\t\t\t}\n\t\t\t\t\tfree (o);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tr_core_bin_export_info_rad (core);\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\tcase ' ':\n\t\t\t\tif (db) {\n\t\t\t\t\tchar *o = sdb_querys (db, NULL, 0, input + 2);\n\t\t\t\t\tif (o && *o) {\n\t\t\t\t\t\tr_cons_print (o);\n\t\t\t\t\t}\n\t\t\t\t\tfree (o);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '\\0':\n\t\t\t\tif (db) {\n\t\t\t\t\tchar *o = sdb_querys (db, NULL, 0, \"*\");\n\t\t\t\t\tif (o && *o) {\n\t\t\t\t\t\tr_cons_print (o);\n\t\t\t\t\t}\n\t\t\t\t\tfree (o);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\tdefault:\n\t\t\t\teprintf (\"Usage: ik [sdb-query]\\n\");\n\t\t\t\teprintf (\"Usage: ik*    # load all header information\\n\");\n\t\t\t}\n\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t{\n\t\t\tif (!cf) {\n\t\t\t\teprintf (\"Core file not open\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst char *fn = input[1] == ' '? input + 2: cf->desc->name;\n\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\tr_core_bin_load (core, fn, baddr);\n\t\t}\n\t\tbreak;\n\t\t\t#define RBININFO(n,x,y,z)\\\n\t\t\t\tif (is_array) {\\\n\t\t\t\t\tif (is_array == 1) { is_array++;\\\n\t\t\t\t\t} else { r_cons_printf (\",\");}\\\n\t\t\t\t\tr_cons_printf (\"\\\"%s\\\":\",n);\\\n\t\t\t\t}\\\n\t\t\t\tif (z) { playMsg (core, n, z);}\\\n\t\t\t\tr_core_bin_info (core, x, mode, va, NULL, y);\n\t\tcase 'A':\n\t\t\tnewline = false;\n\t\t\tif (input[1] == 'j') {\n\t\t\t\tr_cons_printf (\"{\");\n\t\t\t\tr_bin_list_archs (core->bin, 'j');\n\t\t\t\tr_cons_printf (\"}\\n\");\n\t\t\t} else {\n\t\t\t\tr_bin_list_archs (core->bin, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'E': RBININFO (\"exports\", R_CORE_BIN_ACC_EXPORTS, NULL, 0); break;\n\t\tcase 'Z': RBININFO (\"size\", R_CORE_BIN_ACC_SIZE, NULL, 0); break;\n\t\tcase 'S':\n\t\t\t//we comes from ia or iS\n\t\t\tif ((input[1] == 'm' && input[2] == 'z') || !input[1]) {\n\t\t\t\tRBININFO (\"sections\", R_CORE_BIN_ACC_SECTIONS, NULL, 0);\n\t\t\t} else {  //iS entropy,sha1\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tif (mode == R_CORE_BIN_RADARE || mode == R_CORE_BIN_JSON || mode == R_CORE_BIN_SIMPLE) {\n\t\t\t\t\tRBININFO (\"sections\", R_CORE_BIN_ACC_SECTIONS, input + 2,\n\t\t\t\t\t\tobj? r_list_length (obj->sections): 0);\n\t\t\t\t} else {\n\t\t\t\t\tRBININFO (\"sections\", R_CORE_BIN_ACC_SECTIONS, input + 1,\n\t\t\t\t\t\tobj? r_list_length (obj->sections): 0);\n\t\t\t\t}\n\t\t\t\t//we move input until get '\\0'\n\t\t\t\twhile (*(++input)) ;\n\t\t\t\t//input-- because we are inside a while that does input++\n\t\t\t\t// oob read if not input--\n\t\t\t\tinput--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tif (input[1] == 'H') { // \"iHH\"\n\t\t\t\tRBININFO (\"header\", R_CORE_BIN_ACC_HEADER, NULL, -1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 'h': RBININFO (\"fields\", R_CORE_BIN_ACC_FIELDS, NULL, 0); break;\n\t\tcase 'l': \n\t\t\t  {\n\t\t\t\t  RBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\t  RBININFO (\"libs\", R_CORE_BIN_ACC_LIBS, NULL, obj? r_list_length (obj->libs): 0); \n\t\t\t  }\n\t\t\t  break;\n\t\tcase 'L':\n\t\t{\n\t\t\tchar *ptr = strchr (input, ' ');\n\t\t\tint json = input[1] == 'j'? 'j': 0;\n\n\t\t\tif (ptr && ptr[1]) {\n\t\t\t\tconst char *plugin_name = ptr + 1;\n\t\t\t\tif (is_array) {\n\t\t\t\t\tr_cons_printf (\"\\\"plugin\\\": \");\n\t\t\t\t}\n\t\t\t\tr_bin_list_plugin (core->bin, plugin_name, json);\n\t\t\t} else {\n\t\t\t\tr_bin_list (core->bin, json);\n\t\t\t}\n\n\t\t\tnewline = false;\n\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t\tcase 's':\n\t\t\tif (input[1] == '.') {\n\t\t\t\tut64 addr = core->offset + (core->print->cur_enabled? core->print->cur: 0);\n\t\t\t\tRFlagItem *f = r_flag_get_at (core->flags, addr, false);\n\t\t\t\tif (f) {\n\t\t\t\t\tif (f->offset == addr || !f->offset) {\n\t\t\t\t\t\tr_cons_printf (\"%s\", f->name);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"%s+%d\", f->name, (int) (addr - f->offset));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinput++;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tRBININFO (\"symbols\", R_CORE_BIN_ACC_SYMBOLS, NULL, obj? r_list_length (obj->symbols): 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 'R': \n\t\t\tif  (input[1] == '*') {\n\t\t\t\tmode = R_CORE_BIN_RADARE;\n\t\t\t} else if (input[1] == 'j') {\n\t\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\t}\n\t\t\tRBININFO (\"resources\", R_CORE_BIN_ACC_RESOURCES, NULL, 0); \n\t\t\tbreak;\n\t\tcase 'r': RBININFO (\"relocs\", R_CORE_BIN_ACC_RELOCS, NULL, 0); break;\n\t\tcase 'd': RBININFO (\"dwarf\", R_CORE_BIN_ACC_DWARF, NULL, -1); break;\n\t\tcase 'i': {\n\t\t\t\t  RBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\t  RBININFO (\"imports\", R_CORE_BIN_ACC_IMPORTS, NULL,\n\t\t\t\t\t\t  obj? r_list_length (obj->imports): 0);\n\t\t\t  }\n\t\t\t  break;\n\t\tcase 'I': RBININFO (\"info\", R_CORE_BIN_ACC_INFO, NULL, 0); break;\n\t\tcase 'e': RBININFO (\"entries\", R_CORE_BIN_ACC_ENTRIES, NULL, 0); break;\n\t\tcase 'M': RBININFO (\"main\", R_CORE_BIN_ACC_MAIN, NULL, 0); break;\n\t\tcase 'm': RBININFO (\"memory\", R_CORE_BIN_ACC_MEM, NULL, 0); break;\n\t\tcase 'V': RBININFO (\"versioninfo\", R_CORE_BIN_ACC_VERSIONINFO, NULL, 0); break;\n\t\tcase 'C': RBININFO (\"signature\", R_CORE_BIN_ACC_SIGNATURE, NULL, 0); break;\n\t\tcase 'z':\n\t\t\tif (input[1] == 'z') { //izz\n\t\t\t\tswitch (input[2]) {\n\t\t\t\tcase '*':\n\t\t\t\t\tmode = R_CORE_BIN_RADARE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'j':\n\t\t\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'q': //izzq\n\t\t\t\t\tif (input[3] == 'q') { //izzqq\n\t\t\t\t\t\tmode = R_CORE_BIN_SIMPLEST;\n\t\t\t\t\t\tinput++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmode = R_CORE_BIN_SIMPLE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tmode = R_CORE_BIN_PRINT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinput++;\n\t\t\t\tRBININFO (\"strings\", R_CORE_BIN_ACC_RAW_STRINGS, NULL, 0);\n\t\t\t} else {\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tif (input[1] == 'q') {\n\t\t\t\t\tmode = (input[2] == 'q')\n\t\t\t\t\t? R_CORE_BIN_SIMPLEST\n\t\t\t\t\t: R_CORE_BIN_SIMPLE;\n\t\t\t\t\tinput++;\n\t\t\t\t}\n\t\t\t\tif (obj) {\n\t\t\t\t\tRBININFO (\"strings\", R_CORE_BIN_ACC_STRINGS, NULL,\n\t\t\t\t\t\tobj? r_list_length (obj->strings): 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'c': // for r2 `ic`\n\t\t\tif (input[1] == '?') {\n\t\t\t\teprintf (\"Usage: ic[ljq*] [class-index or name]\\n\");\n\t\t\t} else if (input[1] == ' ' || input[1] == 'q' || input[1] == 'j' || input[1] == 'l') {\n\t\t\t\tRBinClass *cls;\n\t\t\t\tRBinSymbol *sym;\n\t\t\t\tRListIter *iter, *iter2;\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tif (obj) {\n\t\t\t\t\tif (input[2]) {\n\t\t\t\t\t\tint idx = -1;\n\t\t\t\t\t\tconst char * cls_name = NULL;\n\t\t\t\t\t\tif (r_num_is_valid_input (core->num, input + 2)) {\n\t\t\t\t\t\t\tidx = r_num_math (core->num, input + 2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst char * first_char = input + ((input[1] == ' ') ? 1 : 2);\n\t\t\t\t\t\t\tint not_space = strspn (first_char, \" \");\n\t\t\t\t\t\t\tif (first_char[not_space]) {\n\t\t\t\t\t\t\t\tcls_name = first_char + not_space;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n\t\t\t\t\t\t\tif ((idx >= 0 && idx != count++) ||\n\t\t\t\t\t\t\t   (cls_name && strcmp (cls_name, cls->name) != 0)){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswitch (input[1]) {\n\t\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"f sym.%s @ 0x%\"PFMT64x \"\\n\",\n\t\t\t\t\t\t\t\t\t\tsym->name, sym->vaddr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tinput++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tconst char *comma = iter2->p? \" \": \"\";\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%\"PFMT64d, comma, sym->vaddr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\t\t\tinput++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'j':\n\t\t\t\t\t\t\t\tinput++;\n\t\t\t\t\t\t\t\tr_cons_printf (\"\\\"class\\\":\\\"%s\\\"\", cls->name);\n\t\t\t\t\t\t\t\tr_cons_printf (\",\\\"methods\\\":[\");\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tconst char *comma = iter2->p? \",\": \"\";\n\n\t\t\t\t\t\t\t\t\tif (sym->method_flags) {\n\t\t\t\t\t\t\t\t\t\tchar *flags = r_core_bin_method_flags_str (sym, R_CORE_BIN_JSON);\n\t\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"flags\\\":%s,\\\"vaddr\\\":%\"PFMT64d \"}\",\n\t\t\t\t\t\t\t\t\t\t\tcomma, sym->name, flags, sym->vaddr);\n\t\t\t\t\t\t\t\t\t\tR_FREE (flags);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\\\"vaddr\\\":%\"PFMT64d \"}\",\n\t\t\t\t\t\t\t\t\t\t\tcomma, sym->name, sym->vaddr);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tr_cons_printf (\"]\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tr_cons_printf (\"class %s\\n\", cls->name);\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tchar *flags = r_core_bin_method_flags_str (sym, 0);\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x \" method %s %s %s\\n\",\n\t\t\t\t\t\t\t\t\t\tsym->vaddr, cls->name, flags, sym->name);\n\t\t\t\t\t\t\t\t\tR_FREE (flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto done;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplayMsg (core, \"classes\", r_list_length (obj->classes));\n\t\t\t\t\t\tif (input[1] == 'l' && obj) { // \"icl\"\n\t\t\t\t\t\t\tr_list_foreach (obj->classes, iter, cls) {\n\t\t\t\t\t\t\t\tr_list_foreach (cls->methods, iter2, sym) {\n\t\t\t\t\t\t\t\t\tconst char *comma = iter2->p? \" \": \"\";\n\t\t\t\t\t\t\t\t\tr_cons_printf (\"%s0x%\"PFMT64d, comma, sym->vaddr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!r_list_empty (cls->methods)) {\n\t\t\t\t\t\t\t\t\tr_cons_newline ();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tRBININFO (\"classes\", R_CORE_BIN_ACC_CLASSES, NULL, r_list_length (obj->classes));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\t\tint len = obj? r_list_length (obj->classes): 0;\n\t\t\t\tRBININFO (\"classes\", R_CORE_BIN_ACC_CLASSES, NULL, len);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (input[1] != ' ' || !demangle (core, input + 2)) {\n\t\t\t\teprintf (\"|Usage: iD lang symbolname\\n\");\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase 'a':\n\t\t\tswitch (mode) {\n\t\t\tcase R_CORE_BIN_RADARE: cmd_info (core, \"iIiecsSmz*\"); break;\n\t\t\tcase R_CORE_BIN_JSON: cmd_info (core, \"iIiecsSmzj\"); break;\n\t\t\tcase R_CORE_BIN_SIMPLE: cmd_info (core, \"iIiecsSmzq\"); break;\n\t\t\tdefault: cmd_info (core, \"IiEecsSmz\"); break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '?': {\n\t\t\tconst char *help_message[] = {\n\t\t\t\t\"Usage: i\", \"\", \"Get info from opened file (see rabin2's manpage)\",\n\t\t\t\t\"Output mode:\", \"\", \"\",\n\t\t\t\t\"'*'\", \"\", \"Output in radare commands\",\n\t\t\t\t\"'j'\", \"\", \"Output in json\",\n\t\t\t\t\"'q'\", \"\", \"Simple quiet output\",\n\t\t\t\t\"Actions:\", \"\", \"\",\n\t\t\t\t\"i|ij\", \"\", \"Show info of current file (in JSON)\",\n\t\t\t\t\"iA\", \"\", \"List archs\",\n\t\t\t\t\"ia\", \"\", \"Show all info (imports, exports, sections..)\",\n\t\t\t\t\"ib\", \"\", \"Reload the current buffer for setting of the bin (use once only)\",\n\t\t\t\t\"ic\", \"\", \"List classes, methods and fields\",\n\t\t\t\t\"iC\", \"\", \"Show signature info (entitlements, ...)\",\n\t\t\t\t\"id\", \"\", \"Debug information (source lines)\",\n\t\t\t\t\"iD\", \" lang sym\", \"demangle symbolname for given language\",\n\t\t\t\t\"ie\", \"\", \"Entrypoint\",\n\t\t\t\t\"iE\", \"\", \"Exports (global symbols)\",\n\t\t\t\t\"ih\", \"\", \"Headers (alias for iH)\",\n\t\t\t\t\"iHH\", \"\", \"Verbose Headers in raw text\",\n\t\t\t\t\"ii\", \"\", \"Imports\",\n\t\t\t\t\"iI\", \"\", \"Binary info\",\n\t\t\t\t\"ik\", \" [query]\", \"Key-value database from RBinObject\",\n\t\t\t\t\"il\", \"\", \"Libraries\",\n\t\t\t\t\"iL \", \"[plugin]\", \"List all RBin plugins loaded or plugin details\",\n\t\t\t\t\"im\", \"\", \"Show info about predefined memory allocation\",\n\t\t\t\t\"iM\", \"\", \"Show main address\",\n\t\t\t\t\"io\", \" [file]\", \"Load info from file (or last opened) use bin.baddr\",\n\t\t\t\t\"ir\", \"\", \"Relocs\",\n\t\t\t\t\"iR\", \"\", \"Resources\",\n\t\t\t\t\"is\", \"\", \"Symbols\",\n\t\t\t\t\"iS \", \"[entropy,sha1]\", \"Sections (choose which hash algorithm to use)\",\n\t\t\t\t\"iV\", \"\", \"Display file version info\",\n\t\t\t\t\"iz|izj\", \"\", \"Strings in data sections (in JSON/Base64)\",\n\t\t\t\t\"izz\", \"\", \"Search for Strings in the whole binary\",\n\t\t\t\t\"iZ\", \"\", \"Guess size of binary program\",\n\t\t\t\tNULL\n\t\t\t};\n\t\t\tr_core_cmd_help (core, help_message);\n\t\t}\n\t\t\tgoto done;\n\t\tcase '*':\n\t\t\tmode = R_CORE_BIN_RADARE;\n\t\t\tgoto done;\n\t\tcase 'q':\n\t\t\tmode = R_CORE_BIN_SIMPLE;\n\t\t\tcmd_info_bin (core, va, mode);\n\t\t\tgoto done;\n\t\tcase 'j':\n\t\t\tmode = R_CORE_BIN_JSON;\n\t\t\tif (is_array > 1) {\n\t\t\t\tmode |= R_CORE_BIN_ARRAY;\n\t\t\t}\n\t\t\tcmd_info_bin (core, va, mode);\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tcmd_info_bin (core, va, mode);\n\t\t\tbreak;\n\t\t}\n\t\tinput++;\n\t\tif ((*input == 'j' || *input == 'q') && !input[1]) {\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tif (is_array) {\n\t\tr_cons_printf (\"}\\n\");\n\t}\n\tif (newline) {\n\t\tr_cons_newline ();\n\t}\n\treturn 0;\n}\n"], "filenames": ["libr/core/cmd.c", "libr/core/cmd_info.c"], "buggy_code_start_loc": [1446, 398], "buggy_code_end_loc": [1447, 448], "fixing_code_start_loc": [1446, 398], "fixing_code_end_loc": [1447, 458], "type": "CWE-119", "message": "The find_eoq function in libr/core/cmd.c in radare2 1.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.", "other": {"cve": {"id": "CVE-2017-9761", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-19T16:29:00.717", "lastModified": "2017-06-27T14:49:50.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The find_eoq function in libr/core/cmd.c in radare2 1.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file."}, {"lang": "es", "value": "La funci\u00f3n find_eoq en el archivo libr/core/cmd.c en radare2 versi\u00f3n 1.5.0, permite a los atacantes remotos causar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites en la regi\u00f3n heap de la memoria y bloqueo de aplicaci\u00f3n) por medio de un archivo binario especialmente dise\u00f1ado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1F6336FC-AB50-4F45-B01E-2BC3BA758117"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/99138", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/radare/radare2/commit/00e8f205475332d7842d0f0d1481eeab4e83017c", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/7727", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/00e8f205475332d7842d0f0d1481eeab4e83017c"}}