{"buggy_code": ["//! A `Source` for registry-based packages.\n//!\n//! # What's a Registry?\n//!\n//! Registries are central locations where packages can be uploaded to,\n//! discovered, and searched for. The purpose of a registry is to have a\n//! location that serves as permanent storage for versions of a crate over time.\n//!\n//! Compared to git sources, a registry provides many packages as well as many\n//! versions simultaneously. Git sources can also have commits deleted through\n//! rebasings where registries cannot have their versions deleted.\n//!\n//! # The Index of a Registry\n//!\n//! One of the major difficulties with a registry is that hosting so many\n//! packages may quickly run into performance problems when dealing with\n//! dependency graphs. It's infeasible for cargo to download the entire contents\n//! of the registry just to resolve one package's dependencies, for example. As\n//! a result, cargo needs some efficient method of querying what packages are\n//! available on a registry, what versions are available, and what the\n//! dependencies for each version is.\n//!\n//! One method of doing so would be having the registry expose an HTTP endpoint\n//! which can be queried with a list of packages and a response of their\n//! dependencies and versions is returned. This is somewhat inefficient however\n//! as we may have to hit the endpoint many times and we may have already\n//! queried for much of the data locally already (for other packages, for\n//! example). This also involves inventing a transport format between the\n//! registry and Cargo itself, so this route was not taken.\n//!\n//! Instead, Cargo communicates with registries through a git repository\n//! referred to as the Index. The Index of a registry is essentially an easily\n//! query-able version of the registry's database for a list of versions of a\n//! package as well as a list of dependencies for each version.\n//!\n//! Using git to host this index provides a number of benefits:\n//!\n//! * The entire index can be stored efficiently locally on disk. This means\n//!   that all queries of a registry can happen locally and don't need to touch\n//!   the network.\n//!\n//! * Updates of the index are quite efficient. Using git buys incremental\n//!   updates, compressed transmission, etc for free. The index must be updated\n//!   each time we need fresh information from a registry, but this is one\n//!   update of a git repository that probably hasn't changed a whole lot so\n//!   it shouldn't be too expensive.\n//!\n//!   Additionally, each modification to the index is just appending a line at\n//!   the end of a file (the exact format is described later). This means that\n//!   the commits for an index are quite small and easily applied/compressible.\n//!\n//! ## The format of the Index\n//!\n//! The index is a store for the list of versions for all packages known, so its\n//! format on disk is optimized slightly to ensure that `ls registry` doesn't\n//! produce a list of all packages ever known. The index also wants to ensure\n//! that there's not a million files which may actually end up hitting\n//! filesystem limits at some point. To this end, a few decisions were made\n//! about the format of the registry:\n//!\n//! 1. Each crate will have one file corresponding to it. Each version for a\n//!    crate will just be a line in this file.\n//! 2. There will be two tiers of directories for crate names, under which\n//!    crates corresponding to those tiers will be located.\n//!\n//! As an example, this is an example hierarchy of an index:\n//!\n//! ```notrust\n//! .\n//! \u251c\u2500\u2500 3\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 u\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 url\n//! \u251c\u2500\u2500 bz\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 ip\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 bzip2\n//! \u251c\u2500\u2500 config.json\n//! \u251c\u2500\u2500 en\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 co\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 encoding\n//! \u2514\u2500\u2500 li\n//!  \u00a0\u00a0 \u251c\u2500\u2500 bg\n//!  \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 libgit2\n//!  \u00a0\u00a0 \u2514\u2500\u2500 nk\n//!  \u00a0\u00a0     \u2514\u2500\u2500 link-config\n//! ```\n//!\n//! The root of the index contains a `config.json` file with a few entries\n//! corresponding to the registry (see [`RegistryConfig`] below).\n//!\n//! Otherwise, there are three numbered directories (1, 2, 3) for crates with\n//! names 1, 2, and 3 characters in length. The 1/2 directories simply have the\n//! crate files underneath them, while the 3 directory is sharded by the first\n//! letter of the crate name.\n//!\n//! Otherwise the top-level directory contains many two-letter directory names,\n//! each of which has many sub-folders with two letters. At the end of all these\n//! are the actual crate files themselves.\n//!\n//! The purpose of this layout is to hopefully cut down on `ls` sizes as well as\n//! efficient lookup based on the crate name itself.\n//!\n//! ## Crate files\n//!\n//! Each file in the index is the history of one crate over time. Each line in\n//! the file corresponds to one version of a crate, stored in JSON format (see\n//! the `RegistryPackage` structure below).\n//!\n//! As new versions are published, new lines are appended to this file. The only\n//! modifications to this file that should happen over time are yanks of a\n//! particular version.\n//!\n//! # Downloading Packages\n//!\n//! The purpose of the Index was to provide an efficient method to resolve the\n//! dependency graph for a package. So far we only required one network\n//! interaction to update the registry's repository (yay!). After resolution has\n//! been performed, however we need to download the contents of packages so we\n//! can read the full manifest and build the source code.\n//!\n//! To accomplish this, this source's `download` method will make an HTTP\n//! request per-package requested to download tarballs into a local cache. These\n//! tarballs will then be unpacked into a destination folder.\n//!\n//! Note that because versions uploaded to the registry are frozen forever that\n//! the HTTP download and unpacking can all be skipped if the version has\n//! already been downloaded and unpacked. This caching allows us to only\n//! download a package when absolutely necessary.\n//!\n//! # Filesystem Hierarchy\n//!\n//! Overall, the `$HOME/.cargo` looks like this when talking about the registry:\n//!\n//! ```notrust\n//! # A folder under which all registry metadata is hosted (similar to\n//! # $HOME/.cargo/git)\n//! $HOME/.cargo/registry/\n//!\n//!     # For each registry that cargo knows about (keyed by hostname + hash)\n//!     # there is a folder which is the checked out version of the index for\n//!     # the registry in this location. Note that this is done so cargo can\n//!     # support multiple registries simultaneously\n//!     index/\n//!         registry1-<hash>/\n//!         registry2-<hash>/\n//!         ...\n//!\n//!     # This folder is a cache for all downloaded tarballs from a registry.\n//!     # Once downloaded and verified, a tarball never changes.\n//!     cache/\n//!         registry1-<hash>/<pkg>-<version>.crate\n//!         ...\n//!\n//!     # Location in which all tarballs are unpacked. Each tarball is known to\n//!     # be frozen after downloading, so transitively this folder is also\n//!     # frozen once its unpacked (it's never unpacked again)\n//!     src/\n//!         registry1-<hash>/<pkg>-<version>/...\n//!         ...\n//! ```\n\nuse std::borrow::Cow;\nuse std::collections::BTreeMap;\nuse std::collections::HashSet;\nuse std::fs::{File, OpenOptions};\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\nuse std::task::Poll;\n\nuse anyhow::Context as _;\nuse cargo_util::paths::exclude_from_backups_and_indexing;\nuse flate2::read::GzDecoder;\nuse log::debug;\nuse semver::Version;\nuse serde::Deserialize;\nuse tar::Archive;\n\nuse crate::core::dependency::{DepKind, Dependency};\nuse crate::core::source::MaybePackage;\nuse crate::core::{Package, PackageId, QueryKind, Source, SourceId, Summary};\nuse crate::sources::PathSource;\nuse crate::util::hex;\nuse crate::util::interning::InternedString;\nuse crate::util::into_url::IntoUrl;\nuse crate::util::network::PollExt;\nuse crate::util::{restricted_names, CargoResult, Config, Filesystem, OptVersionReq};\n\nconst PACKAGE_SOURCE_LOCK: &str = \".cargo-ok\";\npub const CRATES_IO_INDEX: &str = \"https://github.com/rust-lang/crates.io-index\";\npub const CRATES_IO_HTTP_INDEX: &str = \"sparse+https://index.crates.io/\";\npub const CRATES_IO_REGISTRY: &str = \"crates-io\";\npub const CRATES_IO_DOMAIN: &str = \"crates.io\";\nconst CRATE_TEMPLATE: &str = \"{crate}\";\nconst VERSION_TEMPLATE: &str = \"{version}\";\nconst PREFIX_TEMPLATE: &str = \"{prefix}\";\nconst LOWER_PREFIX_TEMPLATE: &str = \"{lowerprefix}\";\nconst CHECKSUM_TEMPLATE: &str = \"{sha256-checksum}\";\n\n/// A \"source\" for a local (see `local::LocalRegistry`) or remote (see\n/// `remote::RemoteRegistry`) registry.\n///\n/// This contains common functionality that is shared between the two registry\n/// kinds, with the registry-specific logic implemented as part of the\n/// [`RegistryData`] trait referenced via the `ops` field.\npub struct RegistrySource<'cfg> {\n    source_id: SourceId,\n    /// The path where crate files are extracted (`$CARGO_HOME/registry/src/$REG-HASH`).\n    src_path: Filesystem,\n    /// Local reference to [`Config`] for convenience.\n    config: &'cfg Config,\n    /// Abstraction for interfacing to the different registry kinds.\n    ops: Box<dyn RegistryData + 'cfg>,\n    /// Interface for managing the on-disk index.\n    index: index::RegistryIndex<'cfg>,\n    /// A set of packages that should be allowed to be used, even if they are\n    /// yanked.\n    ///\n    /// This is populated from the entries in `Cargo.lock` to ensure that\n    /// `cargo update -p somepkg` won't unlock yanked entries in `Cargo.lock`.\n    /// Otherwise, the resolver would think that those entries no longer\n    /// exist, and it would trigger updates to unrelated packages.\n    yanked_whitelist: HashSet<PackageId>,\n}\n\n/// The `config.json` file stored in the index.\n#[derive(Deserialize, Debug, Clone)]\n#[serde(rename_all = \"kebab-case\")]\npub struct RegistryConfig {\n    /// Download endpoint for all crates.\n    ///\n    /// The string is a template which will generate the download URL for the\n    /// tarball of a specific version of a crate. The substrings `{crate}` and\n    /// `{version}` will be replaced with the crate's name and version\n    /// respectively.  The substring `{prefix}` will be replaced with the\n    /// crate's prefix directory name, and the substring `{lowerprefix}` will\n    /// be replaced with the crate's prefix directory name converted to\n    /// lowercase. The substring `{sha256-checksum}` will be replaced with the\n    /// crate's sha256 checksum.\n    ///\n    /// For backwards compatibility, if the string does not contain any\n    /// markers (`{crate}`, `{version}`, `{prefix}`, or ``{lowerprefix}`), it\n    /// will be extended with `/{crate}/{version}/download` to\n    /// support registries like crates.io which were created before the\n    /// templating setup was created.\n    pub dl: String,\n\n    /// API endpoint for the registry. This is what's actually hit to perform\n    /// operations like yanks, owner modifications, publish new crates, etc.\n    /// If this is None, the registry does not support API commands.\n    pub api: Option<String>,\n}\n\n/// The maximum version of the `v` field in the index this version of cargo\n/// understands.\npub(crate) const INDEX_V_MAX: u32 = 2;\n\n/// A single line in the index representing a single version of a package.\n#[derive(Deserialize)]\npub struct RegistryPackage<'a> {\n    name: InternedString,\n    vers: Version,\n    #[serde(borrow)]\n    deps: Vec<RegistryDependency<'a>>,\n    features: BTreeMap<InternedString, Vec<InternedString>>,\n    /// This field contains features with new, extended syntax. Specifically,\n    /// namespaced features (`dep:`) and weak dependencies (`pkg?/feat`).\n    ///\n    /// This is separated from `features` because versions older than 1.19\n    /// will fail to load due to not being able to parse the new syntax, even\n    /// with a `Cargo.lock` file.\n    features2: Option<BTreeMap<InternedString, Vec<InternedString>>>,\n    cksum: String,\n    /// If `true`, Cargo will skip this version when resolving.\n    ///\n    /// This was added in 2014. Everything in the crates.io index has this set\n    /// now, so this probably doesn't need to be an option anymore.\n    yanked: Option<bool>,\n    /// Native library name this package links to.\n    ///\n    /// Added early 2018 (see <https://github.com/rust-lang/cargo/pull/4978>),\n    /// can be `None` if published before then.\n    links: Option<InternedString>,\n    /// The schema version for this entry.\n    ///\n    /// If this is None, it defaults to version 1. Entries with unknown\n    /// versions are ignored.\n    ///\n    /// Version `2` format adds the `features2` field.\n    ///\n    /// This provides a method to safely introduce changes to index entries\n    /// and allow older versions of cargo to ignore newer entries it doesn't\n    /// understand. This is honored as of 1.51, so unfortunately older\n    /// versions will ignore it, and potentially misinterpret version 2 and\n    /// newer entries.\n    ///\n    /// The intent is that versions older than 1.51 will work with a\n    /// pre-existing `Cargo.lock`, but they may not correctly process `cargo\n    /// update` or build a lock from scratch. In that case, cargo may\n    /// incorrectly select a new package that uses a new index format. A\n    /// workaround is to downgrade any packages that are incompatible with the\n    /// `--precise` flag of `cargo update`.\n    v: Option<u32>,\n}\n\n#[test]\nfn escaped_char_in_json() {\n    let _: RegistryPackage<'_> = serde_json::from_str(\n        r#\"{\"name\":\"a\",\"vers\":\"0.0.1\",\"deps\":[],\"cksum\":\"bae3\",\"features\":{}}\"#,\n    )\n    .unwrap();\n    let _: RegistryPackage<'_> = serde_json::from_str(\n        r#\"{\"name\":\"a\",\"vers\":\"0.0.1\",\"deps\":[],\"cksum\":\"bae3\",\"features\":{\"test\":[\"k\",\"q\"]},\"links\":\"a-sys\"}\"#\n    ).unwrap();\n\n    // Now we add escaped cher all the places they can go\n    // these are not valid, but it should error later than json parsing\n    let _: RegistryPackage<'_> = serde_json::from_str(\n        r#\"{\n        \"name\":\"This name has a escaped cher in it \\n\\t\\\" \",\n        \"vers\":\"0.0.1\",\n        \"deps\":[{\n            \"name\": \" \\n\\t\\\" \",\n            \"req\": \" \\n\\t\\\" \",\n            \"features\": [\" \\n\\t\\\" \"],\n            \"optional\": true,\n            \"default_features\": true,\n            \"target\": \" \\n\\t\\\" \",\n            \"kind\": \" \\n\\t\\\" \",\n            \"registry\": \" \\n\\t\\\" \"\n        }],\n        \"cksum\":\"bae3\",\n        \"features\":{\"test \\n\\t\\\" \":[\"k \\n\\t\\\" \",\"q \\n\\t\\\" \"]},\n        \"links\":\" \\n\\t\\\" \"}\"#,\n    )\n    .unwrap();\n}\n\n/// A dependency as encoded in the index JSON.\n#[derive(Deserialize)]\nstruct RegistryDependency<'a> {\n    name: InternedString,\n    #[serde(borrow)]\n    req: Cow<'a, str>,\n    features: Vec<InternedString>,\n    optional: bool,\n    default_features: bool,\n    target: Option<Cow<'a, str>>,\n    kind: Option<Cow<'a, str>>,\n    registry: Option<Cow<'a, str>>,\n    package: Option<InternedString>,\n    public: Option<bool>,\n}\n\nimpl<'a> RegistryDependency<'a> {\n    /// Converts an encoded dependency in the registry to a cargo dependency\n    pub fn into_dep(self, default: SourceId) -> CargoResult<Dependency> {\n        let RegistryDependency {\n            name,\n            req,\n            mut features,\n            optional,\n            default_features,\n            target,\n            kind,\n            registry,\n            package,\n            public,\n        } = self;\n\n        let id = if let Some(registry) = &registry {\n            SourceId::for_registry(&registry.into_url()?)?\n        } else {\n            default\n        };\n\n        let mut dep = Dependency::parse(package.unwrap_or(name), Some(&req), id)?;\n        if package.is_some() {\n            dep.set_explicit_name_in_toml(name);\n        }\n        let kind = match kind.as_deref().unwrap_or(\"\") {\n            \"dev\" => DepKind::Development,\n            \"build\" => DepKind::Build,\n            _ => DepKind::Normal,\n        };\n\n        let platform = match target {\n            Some(target) => Some(target.parse()?),\n            None => None,\n        };\n\n        // All dependencies are private by default\n        let public = public.unwrap_or(false);\n\n        // Unfortunately older versions of cargo and/or the registry ended up\n        // publishing lots of entries where the features array contained the\n        // empty feature, \"\", inside. This confuses the resolution process much\n        // later on and these features aren't actually valid, so filter them all\n        // out here.\n        features.retain(|s| !s.is_empty());\n\n        // In index, \"registry\" is null if it is from the same index.\n        // In Cargo.toml, \"registry\" is None if it is from the default\n        if !id.is_default_registry() {\n            dep.set_registry_id(id);\n        }\n\n        dep.set_optional(optional)\n            .set_default_features(default_features)\n            .set_features(features)\n            .set_platform(platform)\n            .set_kind(kind)\n            .set_public(public);\n\n        Ok(dep)\n    }\n}\n\npub enum LoadResponse {\n    /// The cache is valid. The cached data should be used.\n    CacheValid,\n\n    /// The cache is out of date. Returned data should be used.\n    Data {\n        raw_data: Vec<u8>,\n        index_version: Option<String>,\n    },\n\n    /// The requested crate was found.\n    NotFound,\n}\n\n/// An abstract interface to handle both a local (see `local::LocalRegistry`)\n/// and remote (see `remote::RemoteRegistry`) registry.\n///\n/// This allows [`RegistrySource`] to abstractly handle both registry kinds.\npub trait RegistryData {\n    /// Performs initialization for the registry.\n    ///\n    /// This should be safe to call multiple times, the implementation is\n    /// expected to not do any work if it is already prepared.\n    fn prepare(&self) -> CargoResult<()>;\n\n    /// Returns the path to the index.\n    ///\n    /// Note that different registries store the index in different formats\n    /// (remote=git, local=files).\n    fn index_path(&self) -> &Filesystem;\n\n    /// Loads the JSON for a specific named package from the index.\n    ///\n    /// * `root` is the root path to the index.\n    /// * `path` is the relative path to the package to load (like `ca/rg/cargo`).\n    /// * `index_version` is the version of the requested crate data currently in cache.\n    fn load(\n        &mut self,\n        root: &Path,\n        path: &Path,\n        index_version: Option<&str>,\n    ) -> Poll<CargoResult<LoadResponse>>;\n\n    /// Loads the `config.json` file and returns it.\n    ///\n    /// Local registries don't have a config, and return `None`.\n    fn config(&mut self) -> Poll<CargoResult<Option<RegistryConfig>>>;\n\n    /// Invalidates locally cached data.\n    fn invalidate_cache(&mut self);\n\n    /// Is the local cached data up-to-date?\n    fn is_updated(&self) -> bool;\n\n    /// Prepare to start downloading a `.crate` file.\n    ///\n    /// Despite the name, this doesn't actually download anything. If the\n    /// `.crate` is already downloaded, then it returns [`MaybeLock::Ready`].\n    /// If it hasn't been downloaded, then it returns [`MaybeLock::Download`]\n    /// which contains the URL to download. The [`crate::core::package::Downloads`]\n    /// system handles the actual download process. After downloading, it\n    /// calls [`Self::finish_download`] to save the downloaded file.\n    ///\n    /// `checksum` is currently only used by local registries to verify the\n    /// file contents (because local registries never actually download\n    /// anything). Remote registries will validate the checksum in\n    /// `finish_download`. For already downloaded `.crate` files, it does not\n    /// validate the checksum, assuming the filesystem does not suffer from\n    /// corruption or manipulation.\n    fn download(&mut self, pkg: PackageId, checksum: &str) -> CargoResult<MaybeLock>;\n\n    /// Finish a download by saving a `.crate` file to disk.\n    ///\n    /// After [`crate::core::package::Downloads`] has finished a download,\n    /// it will call this to save the `.crate` file. This is only relevant\n    /// for remote registries. This should validate the checksum and save\n    /// the given data to the on-disk cache.\n    ///\n    /// Returns a [`File`] handle to the `.crate` file, positioned at the start.\n    fn finish_download(&mut self, pkg: PackageId, checksum: &str, data: &[u8])\n        -> CargoResult<File>;\n\n    /// Returns whether or not the `.crate` file is already downloaded.\n    fn is_crate_downloaded(&self, _pkg: PackageId) -> bool {\n        true\n    }\n\n    /// Validates that the global package cache lock is held.\n    ///\n    /// Given the [`Filesystem`], this will make sure that the package cache\n    /// lock is held. If not, it will panic. See\n    /// [`Config::acquire_package_cache_lock`] for acquiring the global lock.\n    ///\n    /// Returns the [`Path`] to the [`Filesystem`].\n    fn assert_index_locked<'a>(&self, path: &'a Filesystem) -> &'a Path;\n\n    /// Block until all outstanding Poll::Pending requests are Poll::Ready.\n    fn block_until_ready(&mut self) -> CargoResult<()>;\n}\n\n/// The status of [`RegistryData::download`] which indicates if a `.crate`\n/// file has already been downloaded, or if not then the URL to download.\npub enum MaybeLock {\n    /// The `.crate` file is already downloaded. [`File`] is a handle to the\n    /// opened `.crate` file on the filesystem.\n    Ready(File),\n    /// The `.crate` file is not downloaded, here's the URL to download it from.\n    ///\n    /// `descriptor` is just a text string to display to the user of what is\n    /// being downloaded.\n    Download { url: String, descriptor: String },\n}\n\nmod download;\nmod http_remote;\nmod index;\nmod local;\nmod remote;\n\nfn short_name(id: SourceId) -> String {\n    let hash = hex::short_hash(&id);\n    let ident = id.url().host_str().unwrap_or(\"\").to_string();\n    format!(\"{}-{}\", ident, hash)\n}\n\nimpl<'cfg> RegistrySource<'cfg> {\n    pub fn remote(\n        source_id: SourceId,\n        yanked_whitelist: &HashSet<PackageId>,\n        config: &'cfg Config,\n    ) -> CargoResult<RegistrySource<'cfg>> {\n        let name = short_name(source_id);\n        let ops = if source_id.url().scheme().starts_with(\"sparse+\") {\n            Box::new(http_remote::HttpRegistry::new(source_id, config, &name)?) as Box<_>\n        } else {\n            Box::new(remote::RemoteRegistry::new(source_id, config, &name)) as Box<_>\n        };\n\n        Ok(RegistrySource::new(\n            source_id,\n            config,\n            &name,\n            ops,\n            yanked_whitelist,\n        ))\n    }\n\n    pub fn local(\n        source_id: SourceId,\n        path: &Path,\n        yanked_whitelist: &HashSet<PackageId>,\n        config: &'cfg Config,\n    ) -> RegistrySource<'cfg> {\n        let name = short_name(source_id);\n        let ops = local::LocalRegistry::new(path, config, &name);\n        RegistrySource::new(source_id, config, &name, Box::new(ops), yanked_whitelist)\n    }\n\n    fn new(\n        source_id: SourceId,\n        config: &'cfg Config,\n        name: &str,\n        ops: Box<dyn RegistryData + 'cfg>,\n        yanked_whitelist: &HashSet<PackageId>,\n    ) -> RegistrySource<'cfg> {\n        RegistrySource {\n            src_path: config.registry_source_path().join(name),\n            config,\n            source_id,\n            index: index::RegistryIndex::new(source_id, ops.index_path(), config),\n            yanked_whitelist: yanked_whitelist.clone(),\n            ops,\n        }\n    }\n\n    /// Decode the configuration stored within the registry.\n    ///\n    /// This requires that the index has been at least checked out.\n    pub fn config(&mut self) -> Poll<CargoResult<Option<RegistryConfig>>> {\n        self.ops.config()\n    }\n\n    /// Unpacks a downloaded package into a location where it's ready to be\n    /// compiled.\n    ///\n    /// No action is taken if the source looks like it's already unpacked.\n    fn unpack_package(&self, pkg: PackageId, tarball: &File) -> CargoResult<PathBuf> {\n        // The `.cargo-ok` file is used to track if the source is already\n        // unpacked.\n        let package_dir = format!(\"{}-{}\", pkg.name(), pkg.version());\n        let dst = self.src_path.join(&package_dir);\n        dst.create_dir()?;\n        let path = dst.join(PACKAGE_SOURCE_LOCK);\n        let path = self.config.assert_package_cache_locked(&path);\n        let unpack_dir = path.parent().unwrap();\n        if let Ok(meta) = path.metadata() {\n            if meta.len() > 0 {\n                return Ok(unpack_dir.to_path_buf());\n            }\n        }\n        let gz = GzDecoder::new(tarball);\n        let mut tar = Archive::new(gz);\n        let prefix = unpack_dir.file_name().unwrap();\n        let parent = unpack_dir.parent().unwrap();\n        for entry in tar.entries()? {\n            let mut entry = entry.with_context(|| \"failed to iterate over archive\")?;\n            let entry_path = entry\n                .path()\n                .with_context(|| \"failed to read entry path\")?\n                .into_owned();\n\n            // We're going to unpack this tarball into the global source\n            // directory, but we want to make sure that it doesn't accidentally\n            // (or maliciously) overwrite source code from other crates. Cargo\n            // itself should never generate a tarball that hits this error, and\n            // crates.io should also block uploads with these sorts of tarballs,\n            // but be extra sure by adding a check here as well.\n            if !entry_path.starts_with(prefix) {\n                anyhow::bail!(\n                    \"invalid tarball downloaded, contains \\\n                     a file at {:?} which isn't under {:?}\",\n                    entry_path,\n                    prefix\n                )\n            }\n            // Unpacking failed\n            let mut result = entry.unpack_in(parent).map_err(anyhow::Error::from);\n            if cfg!(windows) && restricted_names::is_windows_reserved_path(&entry_path) {\n                result = result.with_context(|| {\n                    format!(\n                        \"`{}` appears to contain a reserved Windows path, \\\n                        it cannot be extracted on Windows\",\n                        entry_path.display()\n                    )\n                });\n            }\n            result\n                .with_context(|| format!(\"failed to unpack entry at `{}`\", entry_path.display()))?;\n        }\n\n        // The lock file is created after unpacking so we overwrite a lock file\n        // which may have been extracted from the package.\n        let mut ok = OpenOptions::new()\n            .create(true)\n            .read(true)\n            .write(true)\n            .open(&path)\n            .with_context(|| format!(\"failed to open `{}`\", path.display()))?;\n\n        // Write to the lock file to indicate that unpacking was successful.\n        write!(ok, \"ok\")?;\n\n        Ok(unpack_dir.to_path_buf())\n    }\n\n    fn get_pkg(&mut self, package: PackageId, path: &File) -> CargoResult<Package> {\n        let path = self\n            .unpack_package(package, path)\n            .with_context(|| format!(\"failed to unpack package `{}`\", package))?;\n        let mut src = PathSource::new(&path, self.source_id, self.config);\n        src.update()?;\n        let mut pkg = match src.download(package)? {\n            MaybePackage::Ready(pkg) => pkg,\n            MaybePackage::Download { .. } => unreachable!(),\n        };\n\n        // After we've loaded the package configure its summary's `checksum`\n        // field with the checksum we know for this `PackageId`.\n        let req = OptVersionReq::exact(package.version());\n        let summary_with_cksum = self\n            .index\n            .summaries(package.name(), &req, &mut *self.ops)?\n            .expect(\"a downloaded dep now pending!?\")\n            .map(|s| s.summary.clone())\n            .next()\n            .expect(\"summary not found\");\n        if let Some(cksum) = summary_with_cksum.checksum() {\n            pkg.manifest_mut()\n                .summary_mut()\n                .set_checksum(cksum.to_string());\n        }\n\n        Ok(pkg)\n    }\n}\n\nimpl<'cfg> Source for RegistrySource<'cfg> {\n    fn query(\n        &mut self,\n        dep: &Dependency,\n        kind: QueryKind,\n        f: &mut dyn FnMut(Summary),\n    ) -> Poll<CargoResult<()>> {\n        // If this is a precise dependency, then it came from a lock file and in\n        // theory the registry is known to contain this version. If, however, we\n        // come back with no summaries, then our registry may need to be\n        // updated, so we fall back to performing a lazy update.\n        if kind == QueryKind::Exact && dep.source_id().precise().is_some() && !self.ops.is_updated()\n        {\n            debug!(\"attempting query without update\");\n            let mut called = false;\n            let pend =\n                self.index\n                    .query_inner(dep, &mut *self.ops, &self.yanked_whitelist, &mut |s| {\n                        if dep.matches(&s) {\n                            called = true;\n                            f(s);\n                        }\n                    })?;\n            if pend.is_pending() {\n                return Poll::Pending;\n            }\n            if called {\n                return Poll::Ready(Ok(()));\n            } else {\n                debug!(\"falling back to an update\");\n                self.invalidate_cache();\n                return Poll::Pending;\n            }\n        }\n\n        self.index\n            .query_inner(dep, &mut *self.ops, &self.yanked_whitelist, &mut |s| {\n                let matched = match kind {\n                    QueryKind::Exact => dep.matches(&s),\n                    QueryKind::Fuzzy => true,\n                };\n                if matched {\n                    f(s);\n                }\n            })\n    }\n\n    fn supports_checksums(&self) -> bool {\n        true\n    }\n\n    fn requires_precise(&self) -> bool {\n        false\n    }\n\n    fn source_id(&self) -> SourceId {\n        self.source_id\n    }\n\n    fn invalidate_cache(&mut self) {\n        self.index.clear_summaries_cache();\n        self.ops.invalidate_cache();\n    }\n\n    fn download(&mut self, package: PackageId) -> CargoResult<MaybePackage> {\n        let hash = loop {\n            match self.index.hash(package, &mut *self.ops)? {\n                Poll::Pending => self.block_until_ready()?,\n                Poll::Ready(hash) => break hash,\n            }\n        };\n        match self.ops.download(package, hash)? {\n            MaybeLock::Ready(file) => self.get_pkg(package, &file).map(MaybePackage::Ready),\n            MaybeLock::Download { url, descriptor } => {\n                Ok(MaybePackage::Download { url, descriptor })\n            }\n        }\n    }\n\n    fn finish_download(&mut self, package: PackageId, data: Vec<u8>) -> CargoResult<Package> {\n        let hash = loop {\n            match self.index.hash(package, &mut *self.ops)? {\n                Poll::Pending => self.block_until_ready()?,\n                Poll::Ready(hash) => break hash,\n            }\n        };\n        let file = self.ops.finish_download(package, hash, &data)?;\n        self.get_pkg(package, &file)\n    }\n\n    fn fingerprint(&self, pkg: &Package) -> CargoResult<String> {\n        Ok(pkg.package_id().version().to_string())\n    }\n\n    fn describe(&self) -> String {\n        self.source_id.display_index()\n    }\n\n    fn add_to_yanked_whitelist(&mut self, pkgs: &[PackageId]) {\n        self.yanked_whitelist.extend(pkgs);\n    }\n\n    fn is_yanked(&mut self, pkg: PackageId) -> Poll<CargoResult<bool>> {\n        self.index.is_yanked(pkg, &mut *self.ops)\n    }\n\n    fn block_until_ready(&mut self) -> CargoResult<()> {\n        // Before starting to work on the registry, make sure that\n        // `<cargo_home>/registry` is marked as excluded from indexing and\n        // backups. Older versions of Cargo didn't do this, so we do it here\n        // regardless of whether `<cargo_home>` exists.\n        //\n        // This does not use `create_dir_all_excluded_from_backups_atomic` for\n        // the same reason: we want to exclude it even if the directory already\n        // exists.\n        //\n        // IO errors in creating and marking it are ignored, e.g. in case we're on a\n        // read-only filesystem.\n        let registry_base = self.config.registry_base_path();\n        let _ = registry_base.create_dir();\n        exclude_from_backups_and_indexing(&registry_base.into_path_unlocked());\n\n        self.ops.block_until_ready()\n    }\n}\n\nfn make_dep_prefix(name: &str) -> String {\n    match name.len() {\n        1 => String::from(\"1\"),\n        2 => String::from(\"2\"),\n        3 => format!(\"3/{}\", &name[..1]),\n        _ => format!(\"{}/{}\", &name[0..2], &name[2..4]),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::make_dep_prefix;\n\n    #[test]\n    fn dep_prefix() {\n        assert_eq!(make_dep_prefix(\"a\"), \"1\");\n        assert_eq!(make_dep_prefix(\"ab\"), \"2\");\n        assert_eq!(make_dep_prefix(\"abc\"), \"3/a\");\n        assert_eq!(make_dep_prefix(\"Abc\"), \"3/A\");\n        assert_eq!(make_dep_prefix(\"AbCd\"), \"Ab/Cd\");\n        assert_eq!(make_dep_prefix(\"aBcDe\"), \"aB/cD\");\n    }\n}\n"], "fixing_code": ["//! A `Source` for registry-based packages.\n//!\n//! # What's a Registry?\n//!\n//! Registries are central locations where packages can be uploaded to,\n//! discovered, and searched for. The purpose of a registry is to have a\n//! location that serves as permanent storage for versions of a crate over time.\n//!\n//! Compared to git sources, a registry provides many packages as well as many\n//! versions simultaneously. Git sources can also have commits deleted through\n//! rebasings where registries cannot have their versions deleted.\n//!\n//! # The Index of a Registry\n//!\n//! One of the major difficulties with a registry is that hosting so many\n//! packages may quickly run into performance problems when dealing with\n//! dependency graphs. It's infeasible for cargo to download the entire contents\n//! of the registry just to resolve one package's dependencies, for example. As\n//! a result, cargo needs some efficient method of querying what packages are\n//! available on a registry, what versions are available, and what the\n//! dependencies for each version is.\n//!\n//! One method of doing so would be having the registry expose an HTTP endpoint\n//! which can be queried with a list of packages and a response of their\n//! dependencies and versions is returned. This is somewhat inefficient however\n//! as we may have to hit the endpoint many times and we may have already\n//! queried for much of the data locally already (for other packages, for\n//! example). This also involves inventing a transport format between the\n//! registry and Cargo itself, so this route was not taken.\n//!\n//! Instead, Cargo communicates with registries through a git repository\n//! referred to as the Index. The Index of a registry is essentially an easily\n//! query-able version of the registry's database for a list of versions of a\n//! package as well as a list of dependencies for each version.\n//!\n//! Using git to host this index provides a number of benefits:\n//!\n//! * The entire index can be stored efficiently locally on disk. This means\n//!   that all queries of a registry can happen locally and don't need to touch\n//!   the network.\n//!\n//! * Updates of the index are quite efficient. Using git buys incremental\n//!   updates, compressed transmission, etc for free. The index must be updated\n//!   each time we need fresh information from a registry, but this is one\n//!   update of a git repository that probably hasn't changed a whole lot so\n//!   it shouldn't be too expensive.\n//!\n//!   Additionally, each modification to the index is just appending a line at\n//!   the end of a file (the exact format is described later). This means that\n//!   the commits for an index are quite small and easily applied/compressible.\n//!\n//! ## The format of the Index\n//!\n//! The index is a store for the list of versions for all packages known, so its\n//! format on disk is optimized slightly to ensure that `ls registry` doesn't\n//! produce a list of all packages ever known. The index also wants to ensure\n//! that there's not a million files which may actually end up hitting\n//! filesystem limits at some point. To this end, a few decisions were made\n//! about the format of the registry:\n//!\n//! 1. Each crate will have one file corresponding to it. Each version for a\n//!    crate will just be a line in this file.\n//! 2. There will be two tiers of directories for crate names, under which\n//!    crates corresponding to those tiers will be located.\n//!\n//! As an example, this is an example hierarchy of an index:\n//!\n//! ```notrust\n//! .\n//! \u251c\u2500\u2500 3\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 u\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 url\n//! \u251c\u2500\u2500 bz\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 ip\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 bzip2\n//! \u251c\u2500\u2500 config.json\n//! \u251c\u2500\u2500 en\n//! \u2502\u00a0\u00a0 \u2514\u2500\u2500 co\n//! \u2502\u00a0\u00a0     \u2514\u2500\u2500 encoding\n//! \u2514\u2500\u2500 li\n//!  \u00a0\u00a0 \u251c\u2500\u2500 bg\n//!  \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 libgit2\n//!  \u00a0\u00a0 \u2514\u2500\u2500 nk\n//!  \u00a0\u00a0     \u2514\u2500\u2500 link-config\n//! ```\n//!\n//! The root of the index contains a `config.json` file with a few entries\n//! corresponding to the registry (see [`RegistryConfig`] below).\n//!\n//! Otherwise, there are three numbered directories (1, 2, 3) for crates with\n//! names 1, 2, and 3 characters in length. The 1/2 directories simply have the\n//! crate files underneath them, while the 3 directory is sharded by the first\n//! letter of the crate name.\n//!\n//! Otherwise the top-level directory contains many two-letter directory names,\n//! each of which has many sub-folders with two letters. At the end of all these\n//! are the actual crate files themselves.\n//!\n//! The purpose of this layout is to hopefully cut down on `ls` sizes as well as\n//! efficient lookup based on the crate name itself.\n//!\n//! ## Crate files\n//!\n//! Each file in the index is the history of one crate over time. Each line in\n//! the file corresponds to one version of a crate, stored in JSON format (see\n//! the `RegistryPackage` structure below).\n//!\n//! As new versions are published, new lines are appended to this file. The only\n//! modifications to this file that should happen over time are yanks of a\n//! particular version.\n//!\n//! # Downloading Packages\n//!\n//! The purpose of the Index was to provide an efficient method to resolve the\n//! dependency graph for a package. So far we only required one network\n//! interaction to update the registry's repository (yay!). After resolution has\n//! been performed, however we need to download the contents of packages so we\n//! can read the full manifest and build the source code.\n//!\n//! To accomplish this, this source's `download` method will make an HTTP\n//! request per-package requested to download tarballs into a local cache. These\n//! tarballs will then be unpacked into a destination folder.\n//!\n//! Note that because versions uploaded to the registry are frozen forever that\n//! the HTTP download and unpacking can all be skipped if the version has\n//! already been downloaded and unpacked. This caching allows us to only\n//! download a package when absolutely necessary.\n//!\n//! # Filesystem Hierarchy\n//!\n//! Overall, the `$HOME/.cargo` looks like this when talking about the registry:\n//!\n//! ```notrust\n//! # A folder under which all registry metadata is hosted (similar to\n//! # $HOME/.cargo/git)\n//! $HOME/.cargo/registry/\n//!\n//!     # For each registry that cargo knows about (keyed by hostname + hash)\n//!     # there is a folder which is the checked out version of the index for\n//!     # the registry in this location. Note that this is done so cargo can\n//!     # support multiple registries simultaneously\n//!     index/\n//!         registry1-<hash>/\n//!         registry2-<hash>/\n//!         ...\n//!\n//!     # This folder is a cache for all downloaded tarballs from a registry.\n//!     # Once downloaded and verified, a tarball never changes.\n//!     cache/\n//!         registry1-<hash>/<pkg>-<version>.crate\n//!         ...\n//!\n//!     # Location in which all tarballs are unpacked. Each tarball is known to\n//!     # be frozen after downloading, so transitively this folder is also\n//!     # frozen once its unpacked (it's never unpacked again)\n//!     src/\n//!         registry1-<hash>/<pkg>-<version>/...\n//!         ...\n//! ```\n\nuse std::borrow::Cow;\nuse std::collections::BTreeMap;\nuse std::collections::HashSet;\nuse std::fs::{File, OpenOptions};\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\nuse std::task::Poll;\n\nuse anyhow::Context as _;\nuse cargo_util::paths::exclude_from_backups_and_indexing;\nuse flate2::read::GzDecoder;\nuse log::debug;\nuse semver::Version;\nuse serde::Deserialize;\nuse tar::Archive;\n\nuse crate::core::dependency::{DepKind, Dependency};\nuse crate::core::source::MaybePackage;\nuse crate::core::{Package, PackageId, QueryKind, Source, SourceId, Summary};\nuse crate::sources::PathSource;\nuse crate::util::hex;\nuse crate::util::interning::InternedString;\nuse crate::util::into_url::IntoUrl;\nuse crate::util::network::PollExt;\nuse crate::util::{restricted_names, CargoResult, Config, Filesystem, OptVersionReq};\n\nconst PACKAGE_SOURCE_LOCK: &str = \".cargo-ok\";\npub const CRATES_IO_INDEX: &str = \"https://github.com/rust-lang/crates.io-index\";\npub const CRATES_IO_HTTP_INDEX: &str = \"sparse+https://index.crates.io/\";\npub const CRATES_IO_REGISTRY: &str = \"crates-io\";\npub const CRATES_IO_DOMAIN: &str = \"crates.io\";\nconst CRATE_TEMPLATE: &str = \"{crate}\";\nconst VERSION_TEMPLATE: &str = \"{version}\";\nconst PREFIX_TEMPLATE: &str = \"{prefix}\";\nconst LOWER_PREFIX_TEMPLATE: &str = \"{lowerprefix}\";\nconst CHECKSUM_TEMPLATE: &str = \"{sha256-checksum}\";\n\n/// A \"source\" for a local (see `local::LocalRegistry`) or remote (see\n/// `remote::RemoteRegistry`) registry.\n///\n/// This contains common functionality that is shared between the two registry\n/// kinds, with the registry-specific logic implemented as part of the\n/// [`RegistryData`] trait referenced via the `ops` field.\npub struct RegistrySource<'cfg> {\n    source_id: SourceId,\n    /// The path where crate files are extracted (`$CARGO_HOME/registry/src/$REG-HASH`).\n    src_path: Filesystem,\n    /// Local reference to [`Config`] for convenience.\n    config: &'cfg Config,\n    /// Abstraction for interfacing to the different registry kinds.\n    ops: Box<dyn RegistryData + 'cfg>,\n    /// Interface for managing the on-disk index.\n    index: index::RegistryIndex<'cfg>,\n    /// A set of packages that should be allowed to be used, even if they are\n    /// yanked.\n    ///\n    /// This is populated from the entries in `Cargo.lock` to ensure that\n    /// `cargo update -p somepkg` won't unlock yanked entries in `Cargo.lock`.\n    /// Otherwise, the resolver would think that those entries no longer\n    /// exist, and it would trigger updates to unrelated packages.\n    yanked_whitelist: HashSet<PackageId>,\n}\n\n/// The `config.json` file stored in the index.\n#[derive(Deserialize, Debug, Clone)]\n#[serde(rename_all = \"kebab-case\")]\npub struct RegistryConfig {\n    /// Download endpoint for all crates.\n    ///\n    /// The string is a template which will generate the download URL for the\n    /// tarball of a specific version of a crate. The substrings `{crate}` and\n    /// `{version}` will be replaced with the crate's name and version\n    /// respectively.  The substring `{prefix}` will be replaced with the\n    /// crate's prefix directory name, and the substring `{lowerprefix}` will\n    /// be replaced with the crate's prefix directory name converted to\n    /// lowercase. The substring `{sha256-checksum}` will be replaced with the\n    /// crate's sha256 checksum.\n    ///\n    /// For backwards compatibility, if the string does not contain any\n    /// markers (`{crate}`, `{version}`, `{prefix}`, or ``{lowerprefix}`), it\n    /// will be extended with `/{crate}/{version}/download` to\n    /// support registries like crates.io which were created before the\n    /// templating setup was created.\n    pub dl: String,\n\n    /// API endpoint for the registry. This is what's actually hit to perform\n    /// operations like yanks, owner modifications, publish new crates, etc.\n    /// If this is None, the registry does not support API commands.\n    pub api: Option<String>,\n}\n\n/// The maximum version of the `v` field in the index this version of cargo\n/// understands.\npub(crate) const INDEX_V_MAX: u32 = 2;\n\n/// A single line in the index representing a single version of a package.\n#[derive(Deserialize)]\npub struct RegistryPackage<'a> {\n    name: InternedString,\n    vers: Version,\n    #[serde(borrow)]\n    deps: Vec<RegistryDependency<'a>>,\n    features: BTreeMap<InternedString, Vec<InternedString>>,\n    /// This field contains features with new, extended syntax. Specifically,\n    /// namespaced features (`dep:`) and weak dependencies (`pkg?/feat`).\n    ///\n    /// This is separated from `features` because versions older than 1.19\n    /// will fail to load due to not being able to parse the new syntax, even\n    /// with a `Cargo.lock` file.\n    features2: Option<BTreeMap<InternedString, Vec<InternedString>>>,\n    cksum: String,\n    /// If `true`, Cargo will skip this version when resolving.\n    ///\n    /// This was added in 2014. Everything in the crates.io index has this set\n    /// now, so this probably doesn't need to be an option anymore.\n    yanked: Option<bool>,\n    /// Native library name this package links to.\n    ///\n    /// Added early 2018 (see <https://github.com/rust-lang/cargo/pull/4978>),\n    /// can be `None` if published before then.\n    links: Option<InternedString>,\n    /// The schema version for this entry.\n    ///\n    /// If this is None, it defaults to version 1. Entries with unknown\n    /// versions are ignored.\n    ///\n    /// Version `2` format adds the `features2` field.\n    ///\n    /// This provides a method to safely introduce changes to index entries\n    /// and allow older versions of cargo to ignore newer entries it doesn't\n    /// understand. This is honored as of 1.51, so unfortunately older\n    /// versions will ignore it, and potentially misinterpret version 2 and\n    /// newer entries.\n    ///\n    /// The intent is that versions older than 1.51 will work with a\n    /// pre-existing `Cargo.lock`, but they may not correctly process `cargo\n    /// update` or build a lock from scratch. In that case, cargo may\n    /// incorrectly select a new package that uses a new index format. A\n    /// workaround is to downgrade any packages that are incompatible with the\n    /// `--precise` flag of `cargo update`.\n    v: Option<u32>,\n}\n\n#[test]\nfn escaped_char_in_json() {\n    let _: RegistryPackage<'_> = serde_json::from_str(\n        r#\"{\"name\":\"a\",\"vers\":\"0.0.1\",\"deps\":[],\"cksum\":\"bae3\",\"features\":{}}\"#,\n    )\n    .unwrap();\n    let _: RegistryPackage<'_> = serde_json::from_str(\n        r#\"{\"name\":\"a\",\"vers\":\"0.0.1\",\"deps\":[],\"cksum\":\"bae3\",\"features\":{\"test\":[\"k\",\"q\"]},\"links\":\"a-sys\"}\"#\n    ).unwrap();\n\n    // Now we add escaped cher all the places they can go\n    // these are not valid, but it should error later than json parsing\n    let _: RegistryPackage<'_> = serde_json::from_str(\n        r#\"{\n        \"name\":\"This name has a escaped cher in it \\n\\t\\\" \",\n        \"vers\":\"0.0.1\",\n        \"deps\":[{\n            \"name\": \" \\n\\t\\\" \",\n            \"req\": \" \\n\\t\\\" \",\n            \"features\": [\" \\n\\t\\\" \"],\n            \"optional\": true,\n            \"default_features\": true,\n            \"target\": \" \\n\\t\\\" \",\n            \"kind\": \" \\n\\t\\\" \",\n            \"registry\": \" \\n\\t\\\" \"\n        }],\n        \"cksum\":\"bae3\",\n        \"features\":{\"test \\n\\t\\\" \":[\"k \\n\\t\\\" \",\"q \\n\\t\\\" \"]},\n        \"links\":\" \\n\\t\\\" \"}\"#,\n    )\n    .unwrap();\n}\n\n/// A dependency as encoded in the index JSON.\n#[derive(Deserialize)]\nstruct RegistryDependency<'a> {\n    name: InternedString,\n    #[serde(borrow)]\n    req: Cow<'a, str>,\n    features: Vec<InternedString>,\n    optional: bool,\n    default_features: bool,\n    target: Option<Cow<'a, str>>,\n    kind: Option<Cow<'a, str>>,\n    registry: Option<Cow<'a, str>>,\n    package: Option<InternedString>,\n    public: Option<bool>,\n}\n\nimpl<'a> RegistryDependency<'a> {\n    /// Converts an encoded dependency in the registry to a cargo dependency\n    pub fn into_dep(self, default: SourceId) -> CargoResult<Dependency> {\n        let RegistryDependency {\n            name,\n            req,\n            mut features,\n            optional,\n            default_features,\n            target,\n            kind,\n            registry,\n            package,\n            public,\n        } = self;\n\n        let id = if let Some(registry) = &registry {\n            SourceId::for_registry(&registry.into_url()?)?\n        } else {\n            default\n        };\n\n        let mut dep = Dependency::parse(package.unwrap_or(name), Some(&req), id)?;\n        if package.is_some() {\n            dep.set_explicit_name_in_toml(name);\n        }\n        let kind = match kind.as_deref().unwrap_or(\"\") {\n            \"dev\" => DepKind::Development,\n            \"build\" => DepKind::Build,\n            _ => DepKind::Normal,\n        };\n\n        let platform = match target {\n            Some(target) => Some(target.parse()?),\n            None => None,\n        };\n\n        // All dependencies are private by default\n        let public = public.unwrap_or(false);\n\n        // Unfortunately older versions of cargo and/or the registry ended up\n        // publishing lots of entries where the features array contained the\n        // empty feature, \"\", inside. This confuses the resolution process much\n        // later on and these features aren't actually valid, so filter them all\n        // out here.\n        features.retain(|s| !s.is_empty());\n\n        // In index, \"registry\" is null if it is from the same index.\n        // In Cargo.toml, \"registry\" is None if it is from the default\n        if !id.is_default_registry() {\n            dep.set_registry_id(id);\n        }\n\n        dep.set_optional(optional)\n            .set_default_features(default_features)\n            .set_features(features)\n            .set_platform(platform)\n            .set_kind(kind)\n            .set_public(public);\n\n        Ok(dep)\n    }\n}\n\npub enum LoadResponse {\n    /// The cache is valid. The cached data should be used.\n    CacheValid,\n\n    /// The cache is out of date. Returned data should be used.\n    Data {\n        raw_data: Vec<u8>,\n        index_version: Option<String>,\n    },\n\n    /// The requested crate was found.\n    NotFound,\n}\n\n/// An abstract interface to handle both a local (see `local::LocalRegistry`)\n/// and remote (see `remote::RemoteRegistry`) registry.\n///\n/// This allows [`RegistrySource`] to abstractly handle both registry kinds.\npub trait RegistryData {\n    /// Performs initialization for the registry.\n    ///\n    /// This should be safe to call multiple times, the implementation is\n    /// expected to not do any work if it is already prepared.\n    fn prepare(&self) -> CargoResult<()>;\n\n    /// Returns the path to the index.\n    ///\n    /// Note that different registries store the index in different formats\n    /// (remote=git, local=files).\n    fn index_path(&self) -> &Filesystem;\n\n    /// Loads the JSON for a specific named package from the index.\n    ///\n    /// * `root` is the root path to the index.\n    /// * `path` is the relative path to the package to load (like `ca/rg/cargo`).\n    /// * `index_version` is the version of the requested crate data currently in cache.\n    fn load(\n        &mut self,\n        root: &Path,\n        path: &Path,\n        index_version: Option<&str>,\n    ) -> Poll<CargoResult<LoadResponse>>;\n\n    /// Loads the `config.json` file and returns it.\n    ///\n    /// Local registries don't have a config, and return `None`.\n    fn config(&mut self) -> Poll<CargoResult<Option<RegistryConfig>>>;\n\n    /// Invalidates locally cached data.\n    fn invalidate_cache(&mut self);\n\n    /// Is the local cached data up-to-date?\n    fn is_updated(&self) -> bool;\n\n    /// Prepare to start downloading a `.crate` file.\n    ///\n    /// Despite the name, this doesn't actually download anything. If the\n    /// `.crate` is already downloaded, then it returns [`MaybeLock::Ready`].\n    /// If it hasn't been downloaded, then it returns [`MaybeLock::Download`]\n    /// which contains the URL to download. The [`crate::core::package::Downloads`]\n    /// system handles the actual download process. After downloading, it\n    /// calls [`Self::finish_download`] to save the downloaded file.\n    ///\n    /// `checksum` is currently only used by local registries to verify the\n    /// file contents (because local registries never actually download\n    /// anything). Remote registries will validate the checksum in\n    /// `finish_download`. For already downloaded `.crate` files, it does not\n    /// validate the checksum, assuming the filesystem does not suffer from\n    /// corruption or manipulation.\n    fn download(&mut self, pkg: PackageId, checksum: &str) -> CargoResult<MaybeLock>;\n\n    /// Finish a download by saving a `.crate` file to disk.\n    ///\n    /// After [`crate::core::package::Downloads`] has finished a download,\n    /// it will call this to save the `.crate` file. This is only relevant\n    /// for remote registries. This should validate the checksum and save\n    /// the given data to the on-disk cache.\n    ///\n    /// Returns a [`File`] handle to the `.crate` file, positioned at the start.\n    fn finish_download(&mut self, pkg: PackageId, checksum: &str, data: &[u8])\n        -> CargoResult<File>;\n\n    /// Returns whether or not the `.crate` file is already downloaded.\n    fn is_crate_downloaded(&self, _pkg: PackageId) -> bool {\n        true\n    }\n\n    /// Validates that the global package cache lock is held.\n    ///\n    /// Given the [`Filesystem`], this will make sure that the package cache\n    /// lock is held. If not, it will panic. See\n    /// [`Config::acquire_package_cache_lock`] for acquiring the global lock.\n    ///\n    /// Returns the [`Path`] to the [`Filesystem`].\n    fn assert_index_locked<'a>(&self, path: &'a Filesystem) -> &'a Path;\n\n    /// Block until all outstanding Poll::Pending requests are Poll::Ready.\n    fn block_until_ready(&mut self) -> CargoResult<()>;\n}\n\n/// The status of [`RegistryData::download`] which indicates if a `.crate`\n/// file has already been downloaded, or if not then the URL to download.\npub enum MaybeLock {\n    /// The `.crate` file is already downloaded. [`File`] is a handle to the\n    /// opened `.crate` file on the filesystem.\n    Ready(File),\n    /// The `.crate` file is not downloaded, here's the URL to download it from.\n    ///\n    /// `descriptor` is just a text string to display to the user of what is\n    /// being downloaded.\n    Download { url: String, descriptor: String },\n}\n\nmod download;\nmod http_remote;\nmod index;\nmod local;\nmod remote;\n\nfn short_name(id: SourceId) -> String {\n    let hash = hex::short_hash(&id);\n    let ident = id.url().host_str().unwrap_or(\"\").to_string();\n    format!(\"{}-{}\", ident, hash)\n}\n\nimpl<'cfg> RegistrySource<'cfg> {\n    pub fn remote(\n        source_id: SourceId,\n        yanked_whitelist: &HashSet<PackageId>,\n        config: &'cfg Config,\n    ) -> CargoResult<RegistrySource<'cfg>> {\n        let name = short_name(source_id);\n        let ops = if source_id.url().scheme().starts_with(\"sparse+\") {\n            Box::new(http_remote::HttpRegistry::new(source_id, config, &name)?) as Box<_>\n        } else {\n            Box::new(remote::RemoteRegistry::new(source_id, config, &name)) as Box<_>\n        };\n\n        Ok(RegistrySource::new(\n            source_id,\n            config,\n            &name,\n            ops,\n            yanked_whitelist,\n        ))\n    }\n\n    pub fn local(\n        source_id: SourceId,\n        path: &Path,\n        yanked_whitelist: &HashSet<PackageId>,\n        config: &'cfg Config,\n    ) -> RegistrySource<'cfg> {\n        let name = short_name(source_id);\n        let ops = local::LocalRegistry::new(path, config, &name);\n        RegistrySource::new(source_id, config, &name, Box::new(ops), yanked_whitelist)\n    }\n\n    fn new(\n        source_id: SourceId,\n        config: &'cfg Config,\n        name: &str,\n        ops: Box<dyn RegistryData + 'cfg>,\n        yanked_whitelist: &HashSet<PackageId>,\n    ) -> RegistrySource<'cfg> {\n        RegistrySource {\n            src_path: config.registry_source_path().join(name),\n            config,\n            source_id,\n            index: index::RegistryIndex::new(source_id, ops.index_path(), config),\n            yanked_whitelist: yanked_whitelist.clone(),\n            ops,\n        }\n    }\n\n    /// Decode the configuration stored within the registry.\n    ///\n    /// This requires that the index has been at least checked out.\n    pub fn config(&mut self) -> Poll<CargoResult<Option<RegistryConfig>>> {\n        self.ops.config()\n    }\n\n    /// Unpacks a downloaded package into a location where it's ready to be\n    /// compiled.\n    ///\n    /// No action is taken if the source looks like it's already unpacked.\n    fn unpack_package(&self, pkg: PackageId, tarball: &File) -> CargoResult<PathBuf> {\n        // The `.cargo-ok` file is used to track if the source is already\n        // unpacked.\n        let package_dir = format!(\"{}-{}\", pkg.name(), pkg.version());\n        let dst = self.src_path.join(&package_dir);\n        dst.create_dir()?;\n        let path = dst.join(PACKAGE_SOURCE_LOCK);\n        let path = self.config.assert_package_cache_locked(&path);\n        let unpack_dir = path.parent().unwrap();\n        if let Ok(meta) = path.metadata() {\n            if meta.len() > 0 {\n                return Ok(unpack_dir.to_path_buf());\n            }\n        }\n        let gz = GzDecoder::new(tarball);\n        let mut tar = Archive::new(gz);\n        let prefix = unpack_dir.file_name().unwrap();\n        let parent = unpack_dir.parent().unwrap();\n        for entry in tar.entries()? {\n            let mut entry = entry.with_context(|| \"failed to iterate over archive\")?;\n            let entry_path = entry\n                .path()\n                .with_context(|| \"failed to read entry path\")?\n                .into_owned();\n\n            // We're going to unpack this tarball into the global source\n            // directory, but we want to make sure that it doesn't accidentally\n            // (or maliciously) overwrite source code from other crates. Cargo\n            // itself should never generate a tarball that hits this error, and\n            // crates.io should also block uploads with these sorts of tarballs,\n            // but be extra sure by adding a check here as well.\n            if !entry_path.starts_with(prefix) {\n                anyhow::bail!(\n                    \"invalid tarball downloaded, contains \\\n                     a file at {:?} which isn't under {:?}\",\n                    entry_path,\n                    prefix\n                )\n            }\n            // Prevent unpacking the lockfile from the crate itself.\n            if entry_path\n                .file_name()\n                .map_or(false, |p| p == PACKAGE_SOURCE_LOCK)\n            {\n                continue;\n            }\n            // Unpacking failed\n            let mut result = entry.unpack_in(parent).map_err(anyhow::Error::from);\n            if cfg!(windows) && restricted_names::is_windows_reserved_path(&entry_path) {\n                result = result.with_context(|| {\n                    format!(\n                        \"`{}` appears to contain a reserved Windows path, \\\n                        it cannot be extracted on Windows\",\n                        entry_path.display()\n                    )\n                });\n            }\n            result\n                .with_context(|| format!(\"failed to unpack entry at `{}`\", entry_path.display()))?;\n        }\n\n        // Now that we've finished unpacking, create and write to the lock file to indicate that\n        // unpacking was successful.\n        let mut ok = OpenOptions::new()\n            .create_new(true)\n            .read(true)\n            .write(true)\n            .open(&path)\n            .with_context(|| format!(\"failed to open `{}`\", path.display()))?;\n        write!(ok, \"ok\")?;\n\n        Ok(unpack_dir.to_path_buf())\n    }\n\n    fn get_pkg(&mut self, package: PackageId, path: &File) -> CargoResult<Package> {\n        let path = self\n            .unpack_package(package, path)\n            .with_context(|| format!(\"failed to unpack package `{}`\", package))?;\n        let mut src = PathSource::new(&path, self.source_id, self.config);\n        src.update()?;\n        let mut pkg = match src.download(package)? {\n            MaybePackage::Ready(pkg) => pkg,\n            MaybePackage::Download { .. } => unreachable!(),\n        };\n\n        // After we've loaded the package configure its summary's `checksum`\n        // field with the checksum we know for this `PackageId`.\n        let req = OptVersionReq::exact(package.version());\n        let summary_with_cksum = self\n            .index\n            .summaries(package.name(), &req, &mut *self.ops)?\n            .expect(\"a downloaded dep now pending!?\")\n            .map(|s| s.summary.clone())\n            .next()\n            .expect(\"summary not found\");\n        if let Some(cksum) = summary_with_cksum.checksum() {\n            pkg.manifest_mut()\n                .summary_mut()\n                .set_checksum(cksum.to_string());\n        }\n\n        Ok(pkg)\n    }\n}\n\nimpl<'cfg> Source for RegistrySource<'cfg> {\n    fn query(\n        &mut self,\n        dep: &Dependency,\n        kind: QueryKind,\n        f: &mut dyn FnMut(Summary),\n    ) -> Poll<CargoResult<()>> {\n        // If this is a precise dependency, then it came from a lock file and in\n        // theory the registry is known to contain this version. If, however, we\n        // come back with no summaries, then our registry may need to be\n        // updated, so we fall back to performing a lazy update.\n        if kind == QueryKind::Exact && dep.source_id().precise().is_some() && !self.ops.is_updated()\n        {\n            debug!(\"attempting query without update\");\n            let mut called = false;\n            let pend =\n                self.index\n                    .query_inner(dep, &mut *self.ops, &self.yanked_whitelist, &mut |s| {\n                        if dep.matches(&s) {\n                            called = true;\n                            f(s);\n                        }\n                    })?;\n            if pend.is_pending() {\n                return Poll::Pending;\n            }\n            if called {\n                return Poll::Ready(Ok(()));\n            } else {\n                debug!(\"falling back to an update\");\n                self.invalidate_cache();\n                return Poll::Pending;\n            }\n        }\n\n        self.index\n            .query_inner(dep, &mut *self.ops, &self.yanked_whitelist, &mut |s| {\n                let matched = match kind {\n                    QueryKind::Exact => dep.matches(&s),\n                    QueryKind::Fuzzy => true,\n                };\n                if matched {\n                    f(s);\n                }\n            })\n    }\n\n    fn supports_checksums(&self) -> bool {\n        true\n    }\n\n    fn requires_precise(&self) -> bool {\n        false\n    }\n\n    fn source_id(&self) -> SourceId {\n        self.source_id\n    }\n\n    fn invalidate_cache(&mut self) {\n        self.index.clear_summaries_cache();\n        self.ops.invalidate_cache();\n    }\n\n    fn download(&mut self, package: PackageId) -> CargoResult<MaybePackage> {\n        let hash = loop {\n            match self.index.hash(package, &mut *self.ops)? {\n                Poll::Pending => self.block_until_ready()?,\n                Poll::Ready(hash) => break hash,\n            }\n        };\n        match self.ops.download(package, hash)? {\n            MaybeLock::Ready(file) => self.get_pkg(package, &file).map(MaybePackage::Ready),\n            MaybeLock::Download { url, descriptor } => {\n                Ok(MaybePackage::Download { url, descriptor })\n            }\n        }\n    }\n\n    fn finish_download(&mut self, package: PackageId, data: Vec<u8>) -> CargoResult<Package> {\n        let hash = loop {\n            match self.index.hash(package, &mut *self.ops)? {\n                Poll::Pending => self.block_until_ready()?,\n                Poll::Ready(hash) => break hash,\n            }\n        };\n        let file = self.ops.finish_download(package, hash, &data)?;\n        self.get_pkg(package, &file)\n    }\n\n    fn fingerprint(&self, pkg: &Package) -> CargoResult<String> {\n        Ok(pkg.package_id().version().to_string())\n    }\n\n    fn describe(&self) -> String {\n        self.source_id.display_index()\n    }\n\n    fn add_to_yanked_whitelist(&mut self, pkgs: &[PackageId]) {\n        self.yanked_whitelist.extend(pkgs);\n    }\n\n    fn is_yanked(&mut self, pkg: PackageId) -> Poll<CargoResult<bool>> {\n        self.index.is_yanked(pkg, &mut *self.ops)\n    }\n\n    fn block_until_ready(&mut self) -> CargoResult<()> {\n        // Before starting to work on the registry, make sure that\n        // `<cargo_home>/registry` is marked as excluded from indexing and\n        // backups. Older versions of Cargo didn't do this, so we do it here\n        // regardless of whether `<cargo_home>` exists.\n        //\n        // This does not use `create_dir_all_excluded_from_backups_atomic` for\n        // the same reason: we want to exclude it even if the directory already\n        // exists.\n        //\n        // IO errors in creating and marking it are ignored, e.g. in case we're on a\n        // read-only filesystem.\n        let registry_base = self.config.registry_base_path();\n        let _ = registry_base.create_dir();\n        exclude_from_backups_and_indexing(&registry_base.into_path_unlocked());\n\n        self.ops.block_until_ready()\n    }\n}\n\nfn make_dep_prefix(name: &str) -> String {\n    match name.len() {\n        1 => String::from(\"1\"),\n        2 => String::from(\"2\"),\n        3 => format!(\"3/{}\", &name[..1]),\n        _ => format!(\"{}/{}\", &name[0..2], &name[2..4]),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::make_dep_prefix;\n\n    #[test]\n    fn dep_prefix() {\n        assert_eq!(make_dep_prefix(\"a\"), \"1\");\n        assert_eq!(make_dep_prefix(\"ab\"), \"2\");\n        assert_eq!(make_dep_prefix(\"abc\"), \"3/a\");\n        assert_eq!(make_dep_prefix(\"Abc\"), \"3/A\");\n        assert_eq!(make_dep_prefix(\"AbCd\"), \"Ab/Cd\");\n        assert_eq!(make_dep_prefix(\"aBcDe\"), \"aB/cD\");\n    }\n}\n"], "filenames": ["src/cargo/sources/registry/mod.rs"], "buggy_code_start_loc": [641], "buggy_code_end_loc": [667], "fixing_code_start_loc": [642], "fixing_code_end_loc": [671], "type": "CWE-22", "message": "Cargo is a package manager for the rust programming language. After a package is downloaded, Cargo extracts its source code in the ~/.cargo folder on disk, making it available to the Rust projects it builds. To record when an extraction is successful, Cargo writes \"ok\" to the .cargo-ok file at the root of the extracted source code once it extracted all the files. It was discovered that Cargo allowed packages to contain a .cargo-ok symbolic link, which Cargo would extract. Then, when Cargo attempted to write \"ok\" into .cargo-ok, it would actually replace the first two bytes of the file the symlink pointed to with ok. This would allow an attacker to corrupt one file on the machine using Cargo to extract the package. Note that by design Cargo allows code execution at build time, due to build scripts and procedural macros. The vulnerabilities in this advisory allow performing a subset of the possible damage in a harder to track down way. Your dependencies must still be trusted if you want to be protected from attacks, as it's possible to perform the same attacks with build scripts and procedural macros. The vulnerability is present in all versions of Cargo. Rust 1.64, to be released on September 22nd, will include a fix for it. Since the vulnerability is just a more limited way to accomplish what a malicious build scripts or procedural macros can do, we decided not to publish Rust point releases backporting the security fix. Patch files are available for Rust 1.63.0 are available in the wg-security-response repository for people building their own toolchain. Mitigations We recommend users of alternate registries to exercise care in which package they download, by only including trusted dependencies in their projects. Please note that even with these vulnerabilities fixed, by design Cargo allows arbitrary code execution at build time thanks to build scripts and procedural macros: a malicious dependency will be able to cause damage regardless of these vulnerabilities. crates.io implemented server-side checks to reject these kinds of packages years ago, and there are no packages on crates.io exploiting these vulnerabilities. crates.io users still need to exercise care in choosing their dependencies though, as remote code execution is allowed by design there as well.", "other": {"cve": {"id": "CVE-2022-36113", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-14T18:15:10.763", "lastModified": "2023-01-20T17:58:15.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cargo is a package manager for the rust programming language. After a package is downloaded, Cargo extracts its source code in the ~/.cargo folder on disk, making it available to the Rust projects it builds. To record when an extraction is successful, Cargo writes \"ok\" to the .cargo-ok file at the root of the extracted source code once it extracted all the files. It was discovered that Cargo allowed packages to contain a .cargo-ok symbolic link, which Cargo would extract. Then, when Cargo attempted to write \"ok\" into .cargo-ok, it would actually replace the first two bytes of the file the symlink pointed to with ok. This would allow an attacker to corrupt one file on the machine using Cargo to extract the package. Note that by design Cargo allows code execution at build time, due to build scripts and procedural macros. The vulnerabilities in this advisory allow performing a subset of the possible damage in a harder to track down way. Your dependencies must still be trusted if you want to be protected from attacks, as it's possible to perform the same attacks with build scripts and procedural macros. The vulnerability is present in all versions of Cargo. Rust 1.64, to be released on September 22nd, will include a fix for it. Since the vulnerability is just a more limited way to accomplish what a malicious build scripts or procedural macros can do, we decided not to publish Rust point releases backporting the security fix. Patch files are available for Rust 1.63.0 are available in the wg-security-response repository for people building their own toolchain. Mitigations We recommend users of alternate registries to exercise care in which package they download, by only including trusted dependencies in their projects. Please note that even with these vulnerabilities fixed, by design Cargo allows arbitrary code execution at build time thanks to build scripts and procedural macros: a malicious dependency will be able to cause damage regardless of these vulnerabilities. crates.io implemented server-side checks to reject these kinds of packages years ago, and there are no packages on crates.io exploiting these vulnerabilities. crates.io users still need to exercise care in choosing their dependencies though, as remote code execution is allowed by design there as well."}, {"lang": "es", "value": "Cargo es un administrador de paquetes para el lenguaje de programaci\u00f3n rust. Despu\u00e9s de descargar un paquete, Cargo extrae su c\u00f3digo fuente en la carpeta ~/.cargo del disco, poni\u00e9ndolo a disposici\u00f3n de los proyectos Rust que construye. Para registrar cuando una extracci\u00f3n es exitosa, Cargo escribe \"ok\" en el archivo .cargo-ok en el root del c\u00f3digo fuente extra\u00eddo una vez que extrajo todos los archivos. Se ha detectado que Cargo permit\u00eda que los paquetes contuvieran un enlace simb\u00f3lico .cargo-ok, que Cargo extra\u00eda. Entonces, cuando Cargo intentaba escribir \"ok\" en .cargo-ok, en realidad sustitu\u00eda los dos primeros bytes del archivo al que apuntaba el enlace simb\u00f3lico por ok. Esto permitir\u00eda a un atacante corromper un archivo en la m\u00e1quina que usa Cargo para extraer el paquete. Tenga en cuenta que, por dise\u00f1o, Cargo permite una ejecuci\u00f3n de c\u00f3digo en tiempo de compilaci\u00f3n, debido a los scripts de compilaci\u00f3n y las macros de procedimiento. Las vulnerabilidades de este aviso permiten llevar a cabo un subconjunto de los posibles da\u00f1os de una forma m\u00e1s dif\u00edcil de rastrear. Tus dependencias deben seguir siendo confiables si quieres estar protegido de los ataques, ya que es posible llevar a cabo los mismos ataques con scripts de construcci\u00f3n y macros de procedimiento. La vulnerabilidad est\u00e1 presente en todas las versiones de Cargo. Rust versi\u00f3n 1.64, ser\u00e1 publicada el 22 de septiembre, incluir\u00e1 una correcci\u00f3n para la misma. Dado que la vulnerabilidad es s\u00f3lo una forma m\u00e1s limitada de lograr lo que pueden hacer los scripts de construcci\u00f3n o las macros de procedimiento maliciosos, hemos decidido no publicar versiones puntuales de Rust que incluyan la correcci\u00f3n de seguridad. Los archivos de parche est\u00e1n disponibles para Rust versi\u00f3n 1.63.0 en el repositorio wg-security-response para las personas que construyen su propia cadena de herramientas. Mitigaci\u00f3n Recomendamos a usuarios de registros alternativos que tengan cuidado con el paquete que descargan, incluyendo s\u00f3lo dependencias confiables en sus proyectos. Tenga en cuenta que incluso con estas vulnerabilidades corregidas, Cargo permite por dise\u00f1o la ejecuci\u00f3n de c\u00f3digo arbitrario en tiempo de compilaci\u00f3n gracias a los scripts de compilaci\u00f3n y a las macros de procedimiento: una dependencia maliciosa podr\u00e1 causar da\u00f1os independientemente de estas vulnerabilidades. crates.io implement\u00f3 comprobaciones del lado del servidor para rechazar este tipo de paquetes hace a\u00f1os, y no se presentan paquetes en crates.io que exploten estas vulnerabilidades"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 3.9, "baseSeverity": "LOW"}, "exploitabilityScore": 0.5, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rust-lang:cargo:*:*:*:*:*:rust:*:*", "versionEndExcluding": "0.65.0", "matchCriteriaId": "28D07B7F-9076-4BCD-8CBE-4CD7E1E996AB"}]}]}], "references": [{"url": "https://github.com/rust-lang/cargo/commit/97b80919e404b0768ea31ae329c3b4da54bed05a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rust-lang/cargo/security/advisories/GHSA-rfj2-q3h3-hm5j", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-09", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rust-lang/cargo/commit/97b80919e404b0768ea31ae329c3b4da54bed05a"}}