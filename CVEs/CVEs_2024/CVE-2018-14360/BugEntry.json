{"buggy_code": ["/**\n * @file\n * Read/parse/write an NNTP config file of subscribed newsgroups\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>\n * Copyright (C) 2000-2017 Vsevolod Volkov <vvv@mutt.org.ua>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page newsrc Read/parse/write an NNTP config file of subscribed newsgroups\n *\n * Read/parse/write an NNTP config file of subscribed newsgroups\n */\n\n#include \"config.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"bcache.h\"\n#include \"context.h\"\n#include \"format_flags.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mutt_window.h\"\n#include \"mx.h\"\n#include \"nntp.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"sort.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\nstruct BodyCache;\n\n/**\n * nntp_data_find - Find NntpData for given newsgroup or add it\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstatic struct NntpData *nntp_data_find(struct NntpServer *nserv, const char *group)\n{\n  struct NntpData *nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (nntp_data)\n    return nntp_data;\n\n  size_t len = strlen(group) + 1;\n  /* create NntpData structure and add it to hash */\n  nntp_data = mutt_mem_calloc(1, sizeof(struct NntpData) + len);\n  nntp_data->group = (char *) nntp_data + sizeof(struct NntpData);\n  mutt_str_strfcpy(nntp_data->group, group, len);\n  nntp_data->nserv = nserv;\n  nntp_data->deleted = true;\n  mutt_hash_insert(nserv->groups_hash, nntp_data->group, nntp_data);\n\n  /* add NntpData to list */\n  if (nserv->groups_num >= nserv->groups_max)\n  {\n    nserv->groups_max *= 2;\n    mutt_mem_realloc(&nserv->groups_list, nserv->groups_max * sizeof(nntp_data));\n  }\n  nserv->groups_list[nserv->groups_num++] = nntp_data;\n\n  return nntp_data;\n}\n\n/**\n * nntp_acache_free - Remove all temporarily cache files\n * @param nntp_data NNTP data\n */\nvoid nntp_acache_free(struct NntpData *nntp_data)\n{\n  for (int i = 0; i < NNTP_ACACHE_LEN; i++)\n  {\n    if (nntp_data->acache[i].path)\n    {\n      unlink(nntp_data->acache[i].path);\n      FREE(&nntp_data->acache[i].path);\n    }\n  }\n}\n\n/**\n * nntp_data_free - Free NntpData, used to destroy hash elements\n * @param data NNTP data\n */\nvoid nntp_data_free(void *data)\n{\n  struct NntpData *nntp_data = data;\n\n  if (!nntp_data)\n    return;\n  nntp_acache_free(nntp_data);\n  mutt_bcache_close(&nntp_data->bcache);\n  FREE(&nntp_data->newsrc_ent);\n  FREE(&nntp_data->desc);\n  FREE(&data);\n}\n\n/**\n * nntp_hash_destructor - Free our hash table data\n * @param type Type (UNUSED)\n * @param obj  NNTP data\n * @param data Data (UNUSED)\n */\nvoid nntp_hash_destructor(int type, void *obj, intptr_t data)\n{\n  nntp_data_free(obj);\n}\n\n/**\n * nntp_newsrc_close - Unlock and close .newsrc file\n * @param nserv NNTP server\n */\nvoid nntp_newsrc_close(struct NntpServer *nserv)\n{\n  if (!nserv->newsrc_fp)\n    return;\n\n  mutt_debug(1, \"Unlocking %s\\n\", nserv->newsrc_file);\n  mutt_file_unlock(fileno(nserv->newsrc_fp));\n  mutt_file_fclose(&nserv->newsrc_fp);\n}\n\n/**\n * nntp_group_unread_stat - Count number of unread articles using .newsrc data\n * @param nntp_data NNTP data\n */\nvoid nntp_group_unread_stat(struct NntpData *nntp_data)\n{\n  nntp_data->unread = 0;\n  if (nntp_data->last_message == 0 || nntp_data->first_message > nntp_data->last_message)\n    return;\n\n  nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  for (unsigned int i = 0; i < nntp_data->newsrc_len; i++)\n  {\n    anum_t first = nntp_data->newsrc_ent[i].first;\n    if (first < nntp_data->first_message)\n      first = nntp_data->first_message;\n    anum_t last = nntp_data->newsrc_ent[i].last;\n    if (last > nntp_data->last_message)\n      last = nntp_data->last_message;\n    if (first <= last)\n      nntp_data->unread -= last - first + 1;\n  }\n}\n\n/**\n * nntp_newsrc_parse - Parse .newsrc file\n * @param nserv NNTP server\n * @retval  0 Not changed\n * @retval  1 Parsed\n * @retval -1 Error\n */\nint nntp_newsrc_parse(struct NntpServer *nserv)\n{\n  char *line = NULL;\n  struct stat sb;\n\n  if (nserv->newsrc_fp)\n  {\n    /* if we already have a handle, close it and reopen */\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n  else\n  {\n    /* if file doesn't exist, create it */\n    nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"a\");\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n\n  /* open .newsrc */\n  nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"r\");\n  if (!nserv->newsrc_fp)\n  {\n    mutt_perror(nserv->newsrc_file);\n    return -1;\n  }\n\n  /* lock it */\n  mutt_debug(1, \"Locking %s\\n\", nserv->newsrc_file);\n  if (mutt_file_lock(fileno(nserv->newsrc_fp), 0, 1))\n  {\n    mutt_file_fclose(&nserv->newsrc_fp);\n    return -1;\n  }\n\n  if (stat(nserv->newsrc_file, &sb))\n  {\n    mutt_perror(nserv->newsrc_file);\n    nntp_newsrc_close(nserv);\n    return -1;\n  }\n\n  if (nserv->size == sb.st_size && nserv->mtime == sb.st_mtime)\n    return 0;\n\n  nserv->size = sb.st_size;\n  nserv->mtime = sb.st_mtime;\n  nserv->newsrc_modified = true;\n  mutt_debug(1, \"Parsing %s\\n\", nserv->newsrc_file);\n\n  /* .newsrc has been externally modified or hasn't been loaded yet */\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data)\n      continue;\n\n    nntp_data->subscribed = false;\n    nntp_data->newsrc_len = 0;\n    FREE(&nntp_data->newsrc_ent);\n  }\n\n  line = mutt_mem_malloc(sb.st_size + 1);\n  while (sb.st_size && fgets(line, sb.st_size + 1, nserv->newsrc_fp))\n  {\n    char *b = NULL, *h = NULL;\n    unsigned int j = 1;\n    bool subs = false;\n\n    /* find end of newsgroup name */\n    char *p = strpbrk(line, \":!\");\n    if (!p)\n      continue;\n\n    /* \":\" - subscribed, \"!\" - unsubscribed */\n    if (*p == ':')\n      subs = true;\n    *p++ = '\\0';\n\n    /* get newsgroup data */\n    struct NntpData *nntp_data = nntp_data_find(nserv, line);\n    FREE(&nntp_data->newsrc_ent);\n\n    /* count number of entries */\n    b = p;\n    while (*b)\n      if (*b++ == ',')\n        j++;\n    nntp_data->newsrc_ent = mutt_mem_calloc(j, sizeof(struct NewsrcEntry));\n    nntp_data->subscribed = subs;\n\n    /* parse entries */\n    j = 0;\n    while (p)\n    {\n      b = p;\n\n      /* find end of entry */\n      p = strchr(p, ',');\n      if (p)\n        *p++ = '\\0';\n\n      /* first-last or single number */\n      h = strchr(b, '-');\n      if (h)\n        *h++ = '\\0';\n      else\n        h = b;\n\n      if (sscanf(b, ANUM, &nntp_data->newsrc_ent[j].first) == 1 &&\n          sscanf(h, ANUM, &nntp_data->newsrc_ent[j].last) == 1)\n      {\n        j++;\n      }\n    }\n    if (j == 0)\n    {\n      nntp_data->newsrc_ent[j].first = 1;\n      nntp_data->newsrc_ent[j].last = 0;\n      j++;\n    }\n    if (nntp_data->last_message == 0)\n      nntp_data->last_message = nntp_data->newsrc_ent[j - 1].last;\n    nntp_data->newsrc_len = j;\n    mutt_mem_realloc(&nntp_data->newsrc_ent, j * sizeof(struct NewsrcEntry));\n    nntp_group_unread_stat(nntp_data);\n    mutt_debug(2, \"%s\\n\", nntp_data->group);\n  }\n  FREE(&line);\n  return 1;\n}\n\n/**\n * nntp_newsrc_gen_entries - Generate array of .newsrc entries\n * @param ctx Mailbox\n */\nvoid nntp_newsrc_gen_entries(struct Context *ctx)\n{\n  struct NntpData *nntp_data = ctx->data;\n  anum_t last = 0, first = 1;\n  bool series;\n  int save_sort = SORT_ORDER;\n  unsigned int entries;\n\n  if (Sort != SORT_ORDER)\n  {\n    save_sort = Sort;\n    Sort = SORT_ORDER;\n    mutt_sort_headers(ctx, 0);\n  }\n\n  entries = nntp_data->newsrc_len;\n  if (!entries)\n  {\n    entries = 5;\n    nntp_data->newsrc_ent = mutt_mem_calloc(entries, sizeof(struct NewsrcEntry));\n  }\n\n  /* Set up to fake initial sequence from 1 to the article before the\n   * first article in our list */\n  nntp_data->newsrc_len = 0;\n  series = true;\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* search for first unread */\n    if (series)\n    {\n      /* We don't actually check sequential order, since we mark\n       * \"missing\" entries as read/deleted */\n      last = NHDR(ctx->hdrs[i])->article_num;\n      if (last >= nntp_data->first_message && !ctx->hdrs[i]->deleted &&\n          !ctx->hdrs[i]->read)\n      {\n        if (nntp_data->newsrc_len >= entries)\n        {\n          entries *= 2;\n          mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n        }\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].last = last - 1;\n        nntp_data->newsrc_len++;\n        series = false;\n      }\n    }\n\n    /* search for first read */\n    else\n    {\n      if (ctx->hdrs[i]->deleted || ctx->hdrs[i]->read)\n      {\n        first = last + 1;\n        series = true;\n      }\n      last = NHDR(ctx->hdrs[i])->article_num;\n    }\n  }\n\n  if (series && first <= nntp_data->last_loaded)\n  {\n    if (nntp_data->newsrc_len >= entries)\n    {\n      entries++;\n      mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n    }\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].last = nntp_data->last_loaded;\n    nntp_data->newsrc_len++;\n  }\n  mutt_mem_realloc(&nntp_data->newsrc_ent, nntp_data->newsrc_len * sizeof(struct NewsrcEntry));\n\n  if (save_sort != Sort)\n  {\n    Sort = save_sort;\n    mutt_sort_headers(ctx, 0);\n  }\n}\n\n/**\n * update_file - Update file with new contents\n * @param filename File to update\n * @param buf      New context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int update_file(char *filename, char *buf)\n{\n  FILE *fp = NULL;\n  char tmpfile[PATH_MAX];\n  int rc = -1;\n\n  while (true)\n  {\n    snprintf(tmpfile, sizeof(tmpfile), \"%s.tmp\", filename);\n    fp = mutt_file_fopen(tmpfile, \"w\");\n    if (!fp)\n    {\n      mutt_perror(tmpfile);\n      *tmpfile = '\\0';\n      break;\n    }\n    if (fputs(buf, fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      break;\n    }\n    if (mutt_file_fclose(&fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      fp = NULL;\n      break;\n    }\n    fp = NULL;\n    if (rename(tmpfile, filename) < 0)\n    {\n      mutt_perror(filename);\n      break;\n    }\n    *tmpfile = '\\0';\n    rc = 0;\n    break;\n  }\n  if (fp)\n    mutt_file_fclose(&fp);\n  if (*tmpfile)\n    unlink(tmpfile);\n  return rc;\n}\n\n/**\n * nntp_newsrc_update - Update .newsrc file\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_newsrc_update(struct NntpServer *nserv)\n{\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc = -1;\n\n  if (!nserv)\n    return -1;\n\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  off = 0;\n\n  /* we will generate full newsrc here */\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data || !nntp_data->newsrc_ent)\n      continue;\n\n    /* write newsgroup name */\n    if (off + strlen(nntp_data->group) + 3 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s%c \", nntp_data->group,\n             nntp_data->subscribed ? ':' : '!');\n    off += strlen(buf + off);\n\n    /* write entries */\n    for (unsigned int j = 0; j < nntp_data->newsrc_len; j++)\n    {\n      if (off + LONG_STRING > buflen)\n      {\n        buflen *= 2;\n        mutt_mem_realloc(&buf, buflen);\n      }\n      if (j)\n        buf[off++] = ',';\n      if (nntp_data->newsrc_ent[j].first == nntp_data->newsrc_ent[j].last)\n        snprintf(buf + off, buflen - off, \"%u\", nntp_data->newsrc_ent[j].first);\n      else if (nntp_data->newsrc_ent[j].first < nntp_data->newsrc_ent[j].last)\n      {\n        snprintf(buf + off, buflen - off, \"%u-%u\",\n                 nntp_data->newsrc_ent[j].first, nntp_data->newsrc_ent[j].last);\n      }\n      off += strlen(buf + off);\n    }\n    buf[off++] = '\\n';\n  }\n  buf[off] = '\\0';\n\n  /* newrc being fully rewritten */\n  mutt_debug(1, \"Updating %s\\n\", nserv->newsrc_file);\n  if (nserv->newsrc_file && update_file(nserv->newsrc_file, buf) == 0)\n  {\n    struct stat sb;\n\n    rc = stat(nserv->newsrc_file, &sb);\n    if (rc == 0)\n    {\n      nserv->size = sb.st_size;\n      nserv->mtime = sb.st_mtime;\n    }\n    else\n    {\n      mutt_perror(nserv->newsrc_file);\n    }\n  }\n  FREE(&buf);\n  return rc;\n}\n\n/**\n * cache_expand - Make fully qualified cache file name\n * @param dst    Buffer for filename\n * @param dstlen Length of buffer\n * @param acct   Account\n * @param src    Path to add to the URL\n */\nstatic void cache_expand(char *dst, size_t dstlen, struct Account *acct, char *src)\n{\n  char *c = NULL;\n  char file[PATH_MAX];\n\n  /* server subdirectory */\n  if (acct)\n  {\n    struct Url url;\n\n    mutt_account_tourl(acct, &url);\n    url.path = src;\n    url_tostring(&url, file, sizeof(file), U_PATH);\n  }\n  else\n    mutt_str_strfcpy(file, src ? src : \"\", sizeof(file));\n\n  snprintf(dst, dstlen, \"%s/%s\", NewsCacheDir, file);\n\n  /* remove trailing slash */\n  c = dst + strlen(dst) - 1;\n  if (*c == '/')\n    *c = '\\0';\n  mutt_expand_path(dst, dstlen);\n  mutt_encode_path(dst, dstlen, dst);\n}\n\n/**\n * nntp_expand_path - Make fully qualified url from newsgroup name\n * @param line String containing newsgroup name\n * @param len  Length of string\n * @param acct Account to save result\n */\nvoid nntp_expand_path(char *line, size_t len, struct Account *acct)\n{\n  struct Url url;\n\n  mutt_account_tourl(acct, &url);\n  url.path = mutt_str_strdup(line);\n  url_tostring(&url, line, len, 0);\n  FREE(&url.path);\n}\n\n/**\n * nntp_add_group - Parse newsgroup\n * @param line String to parse\n * @param data NNTP data\n * @retval 0 Always\n */\nint nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n\n  if (!nserv || !line)\n    return 0;\n\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n    return 0;\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}\n\n/**\n * active_get_cache - Load list of all newsgroups from cache\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int active_get_cache(struct NntpServer *nserv)\n{\n  char buf[HUGE_STRING];\n  char file[PATH_MAX];\n  time_t t;\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, \".active\");\n  mutt_debug(1, \"Parsing %s\\n\", file);\n  FILE *fp = mutt_file_fopen(file, \"r\");\n  if (!fp)\n    return -1;\n\n  if (fgets(buf, sizeof(buf), fp) == NULL || sscanf(buf, \"%ld%s\", &t, file) != 1 || t == 0)\n  {\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n  nserv->newgroups_time = t;\n\n  mutt_message(_(\"Loading list of groups from cache...\"));\n  while (fgets(buf, sizeof(buf), fp))\n    nntp_add_group(buf, nserv);\n  nntp_add_group(NULL, NULL);\n  mutt_file_fclose(&fp);\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_active_save_cache - Save list of all newsgroups to cache\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_active_save_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc;\n\n  if (!nserv->cacheable)\n    return 0;\n\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  snprintf(buf, buflen, \"%lu\\n\", (unsigned long) nserv->newgroups_time);\n  off = strlen(buf);\n\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data || nntp_data->deleted)\n      continue;\n\n    if (off + strlen(nntp_data->group) + (nntp_data->desc ? strlen(nntp_data->desc) : 0) + 50 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s %u %u %c%s%s\\n\", nntp_data->group,\n             nntp_data->last_message, nntp_data->first_message,\n             nntp_data->allowed ? 'y' : 'n', nntp_data->desc ? \" \" : \"\",\n             nntp_data->desc ? nntp_data->desc : \"\");\n    off += strlen(buf + off);\n  }\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, \".active\");\n  mutt_debug(1, \"Updating %s\\n\", file);\n  rc = update_file(file, buf);\n  FREE(&buf);\n  return rc;\n}\n\n#ifdef USE_HCACHE\n/**\n * nntp_hcache_namer - Compose hcache file names\n * @param path    Path of message\n * @param dest    Buffer for filename\n * @param destlen Length of buffer\n * @retval num Characters written to buffer\n *\n * Used by mutt_hcache_open() to compose hcache file name\n */\nstatic int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.hcache\", path);\n}\n\n/**\n * nntp_hcache_open - Open newsgroup hcache\n * @param nntp_data NNTP data\n * @retval ptr  Header cache\n * @retval NULL Error\n */\nheader_cache_t *nntp_hcache_open(struct NntpData *nntp_data)\n{\n  struct Url url;\n  char file[PATH_MAX];\n\n  if (!nntp_data->nserv || !nntp_data->nserv->cacheable ||\n      !nntp_data->nserv->conn || !nntp_data->group ||\n      !(nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed))\n  {\n    return NULL;\n  }\n\n  mutt_account_tourl(&nntp_data->nserv->conn->account, &url);\n  url.path = nntp_data->group;\n  url_tostring(&url, file, sizeof(file), U_PATH);\n  return mutt_hcache_open(NewsCacheDir, file, nntp_hcache_namer);\n}\n\n/**\n * nntp_hcache_update - Remove stale cached headers\n * @param nntp_data NNTP data\n * @param hc        Header cache\n */\nvoid nntp_hcache_update(struct NntpData *nntp_data, header_cache_t *hc)\n{\n  char buf[16];\n  bool old = false;\n  void *hdata = NULL;\n  anum_t first = 0, last = 0;\n\n  if (!hc)\n    return;\n\n  /* fetch previous values of first and last */\n  hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n  if (hdata)\n  {\n    mutt_debug(2, \"mutt_hcache_fetch index: %s\\n\", (char *) hdata);\n    if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n    {\n      old = true;\n      nntp_data->last_cached = last;\n\n      /* clean removed headers from cache */\n      for (anum_t current = first; current <= last; current++)\n      {\n        if (current >= nntp_data->first_message && current <= nntp_data->last_message)\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n        mutt_hcache_delete(hc, buf, strlen(buf));\n      }\n    }\n    mutt_hcache_free(hc, &hdata);\n  }\n\n  /* store current values of first and last */\n  if (!old || nntp_data->first_message != first || nntp_data->last_message != last)\n  {\n    snprintf(buf, sizeof(buf), \"%u %u\", nntp_data->first_message, nntp_data->last_message);\n    mutt_debug(2, \"mutt_hcache_store index: %s\\n\", buf);\n    mutt_hcache_store_raw(hc, \"index\", 5, buf, strlen(buf));\n  }\n}\n#endif\n\n/**\n * nntp_bcache_delete - Remove bcache file\n * @param id     Body cache ID\n * @param bcache Body cache\n * @param data   NNTP data\n * @retval 0 Always\n */\nstatic int nntp_bcache_delete(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct NntpData *nntp_data = data;\n  anum_t anum;\n  char c;\n\n  if (!nntp_data || sscanf(id, ANUM \"%c\", &anum, &c) != 1 ||\n      anum < nntp_data->first_message || anum > nntp_data->last_message)\n  {\n    if (nntp_data)\n      mutt_debug(2, \"mutt_bcache_del %s\\n\", id);\n    mutt_bcache_del(bcache, id);\n  }\n  return 0;\n}\n\n/**\n * nntp_bcache_update - Remove stale cached messages\n * @param nntp_data NNTP data\n */\nvoid nntp_bcache_update(struct NntpData *nntp_data)\n{\n  mutt_bcache_list(nntp_data->bcache, nntp_bcache_delete, nntp_data);\n}\n\n/**\n * nntp_delete_group_cache - Remove hcache and bcache of newsgroup\n * @param nntp_data NNTP data\n */\nvoid nntp_delete_group_cache(struct NntpData *nntp_data)\n{\n  if (!nntp_data || !nntp_data->nserv || !nntp_data->nserv->cacheable)\n    return;\n\n#ifdef USE_HCACHE\n  char file[PATH_MAX];\n  nntp_hcache_namer(nntp_data->group, file, sizeof(file));\n  cache_expand(file, sizeof(file), &nntp_data->nserv->conn->account, file);\n  unlink(file);\n  nntp_data->last_cached = 0;\n  mutt_debug(2, \"%s\\n\", file);\n#endif\n\n  if (!nntp_data->bcache)\n  {\n    nntp_data->bcache =\n        mutt_bcache_open(&nntp_data->nserv->conn->account, nntp_data->group);\n  }\n  if (nntp_data->bcache)\n  {\n    mutt_debug(2, \"%s/*\\n\", nntp_data->group);\n    mutt_bcache_list(nntp_data->bcache, nntp_bcache_delete, NULL);\n    mutt_bcache_close(&nntp_data->bcache);\n  }\n}\n\n/**\n * nntp_clear_cache - Clear the NNTP cache\n * @param nserv NNTP server\n *\n * Remove hcache and bcache of all unexistent and unsubscribed newsgroups\n */\nvoid nntp_clear_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *fp = NULL;\n  struct dirent *entry = NULL;\n  DIR *dp = NULL;\n\n  if (!nserv || !nserv->cacheable)\n    return;\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, NULL);\n  dp = opendir(file);\n  if (dp)\n  {\n    mutt_str_strncat(file, sizeof(file), \"/\", 1);\n    fp = file + strlen(file);\n    while ((entry = readdir(dp)))\n    {\n      char *group = entry->d_name;\n      struct stat sb;\n      struct NntpData *nntp_data = NULL;\n      struct NntpData nntp_tmp;\n\n      if ((mutt_str_strcmp(group, \".\") == 0) || (mutt_str_strcmp(group, \"..\") == 0))\n        continue;\n      *fp = '\\0';\n      mutt_str_strncat(file, sizeof(file), group, strlen(group));\n      if (stat(file, &sb))\n        continue;\n\n#ifdef USE_HCACHE\n      if (S_ISREG(sb.st_mode))\n      {\n        char *ext = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (mutt_str_strcmp(ext, \".hcache\") != 0))\n          continue;\n        *ext = '\\0';\n      }\n      else\n#endif\n          if (!S_ISDIR(sb.st_mode))\n        continue;\n\n      nntp_data = mutt_hash_find(nserv->groups_hash, group);\n      if (!nntp_data)\n      {\n        nntp_data = &nntp_tmp;\n        nntp_data->nserv = nserv;\n        nntp_data->group = group;\n        nntp_data->bcache = NULL;\n      }\n      else if (nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed)\n        continue;\n\n      nntp_delete_group_cache(nntp_data);\n      if (S_ISDIR(sb.st_mode))\n      {\n        rmdir(file);\n        mutt_debug(2, \"%s\\n\", file);\n      }\n    }\n    closedir(dp);\n  }\n}\n\n/**\n * nntp_format_str - Expand the newsrc filename\n * @param[out] buf      Buffer in which to save string\n * @param[in]  buflen   Buffer length\n * @param[in]  col      Starting column\n * @param[in]  cols     Number of screen columns\n * @param[in]  op       printf-like operator, e.g. 't'\n * @param[in]  src      printf-like format string\n * @param[in]  prec     Field precision, e.g. \"-3.4\"\n * @param[in]  if_str   If condition is met, display this string\n * @param[in]  else_str Otherwise, display this string\n * @param[in]  data     Pointer to the mailbox Context\n * @param[in]  flags    Format flags\n * @retval src (unchanged)\n *\n * nntp_format_str() is a callback function for mutt_expando_format().\n *\n * | Expando | Description\n * |:--------|:--------------------------------------------------------\n * | \\%a     | Account url\n * | \\%p     | Port\n * | \\%P     | Port if specified\n * | \\%s     | News server name\n * | \\%S     | Url schema\n * | \\%u     | Username\n */\nconst char *nntp_format_str(char *buf, size_t buflen, size_t col, int cols, char op,\n                            const char *src, const char *prec, const char *if_str,\n                            const char *else_str, unsigned long data, enum FormatFlag flags)\n{\n  struct NntpServer *nserv = (struct NntpServer *) data;\n  struct Account *acct = &nserv->conn->account;\n  struct Url url;\n  char fn[SHORT_STRING], fmt[SHORT_STRING], *p = NULL;\n\n  switch (op)\n  {\n    case 'a':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, '/');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'p':\n      snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n      snprintf(buf, buflen, fmt, acct->port);\n      break;\n    case 'P':\n      *buf = '\\0';\n      if (acct->flags & MUTT_ACCT_PORT)\n      {\n        snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n        snprintf(buf, buflen, fmt, acct->port);\n      }\n      break;\n    case 's':\n      strncpy(fn, acct->host, sizeof(fn) - 1);\n      mutt_str_strlower(fn);\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'S':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, ':');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'u':\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, acct->user);\n      break;\n  }\n  return src;\n}\n\n/**\n * nntp_select_server - Open a connection to an NNTP server\n * @param server     Server URI\n * @param leave_lock Leave the server locked?\n * @retval ptr  NNTP server\n * @retval NULL Error\n *\n * Automatically loads a newsrc into memory, if necessary.  Checks the\n * size/mtime of a newsrc file, if it doesn't match, load again.  Hmm, if a\n * system has broken mtimes, this might mean the file is reloaded every time,\n * which we'd have to fix.\n */\nstruct NntpServer *nntp_select_server(char *server, bool leave_lock)\n{\n  char file[PATH_MAX];\n#ifdef USE_HCACHE\n  char *p = NULL;\n#endif\n  int rc;\n  struct Account acct;\n  struct NntpServer *nserv = NULL;\n  struct NntpData *nntp_data = NULL;\n  struct Connection *conn = NULL;\n  struct Url url;\n\n  if (!server || !*server)\n  {\n    mutt_error(_(\"No news server defined!\"));\n    return NULL;\n  }\n\n  /* create account from news server url */\n  acct.flags = 0;\n  acct.port = NNTP_PORT;\n  acct.type = MUTT_ACCT_TYPE_NNTP;\n  snprintf(file, sizeof(file), \"%s%s\", strstr(server, \"://\") ? \"\" : \"news://\", server);\n  if (url_parse(&url, file) < 0 || (url.path && *url.path) ||\n      !(url.scheme == U_NNTP || url.scheme == U_NNTPS) || !url.host ||\n      mutt_account_fromurl(&acct, &url) < 0)\n  {\n    url_free(&url);\n    mutt_error(_(\"%s is an invalid news server specification!\"), server);\n    return NULL;\n  }\n  if (url.scheme == U_NNTPS)\n  {\n    acct.flags |= MUTT_ACCT_SSL;\n    acct.port = NNTP_SSL_PORT;\n  }\n  url_free(&url);\n\n  /* find connection by account */\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return NULL;\n  if (!(conn->account.flags & MUTT_ACCT_USER) && acct.flags & MUTT_ACCT_USER)\n  {\n    conn->account.flags |= MUTT_ACCT_USER;\n    conn->account.user[0] = '\\0';\n  }\n\n  /* news server already exists */\n  nserv = conn->data;\n  if (nserv)\n  {\n    if (nserv->status == NNTP_BYE)\n      nserv->status = NNTP_NONE;\n    if (nntp_open_connection(nserv) < 0)\n      return NULL;\n\n    rc = nntp_newsrc_parse(nserv);\n    if (rc < 0)\n      return NULL;\n\n    /* check for new newsgroups */\n    if (!leave_lock && nntp_check_new_groups(nserv) < 0)\n      rc = -1;\n\n    /* .newsrc has been externally modified */\n    if (rc > 0)\n      nntp_clear_cache(nserv);\n    if (rc < 0 || !leave_lock)\n      nntp_newsrc_close(nserv);\n    return (rc < 0) ? NULL : nserv;\n  }\n\n  /* new news server */\n  nserv = mutt_mem_calloc(1, sizeof(struct NntpServer));\n  nserv->conn = conn;\n  nserv->groups_hash = mutt_hash_create(1009, 0);\n  mutt_hash_set_destructor(nserv->groups_hash, nntp_hash_destructor, 0);\n  nserv->groups_max = 16;\n  nserv->groups_list = mutt_mem_malloc(nserv->groups_max * sizeof(nntp_data));\n\n  rc = nntp_open_connection(nserv);\n\n  /* try to create cache directory and enable caching */\n  nserv->cacheable = false;\n  if (rc >= 0 && NewsCacheDir && *NewsCacheDir)\n  {\n    cache_expand(file, sizeof(file), &conn->account, NULL);\n    if (mutt_file_mkdir(file, S_IRWXU) < 0)\n    {\n      mutt_error(_(\"Can't create %s: %s.\"), file, strerror(errno));\n    }\n    nserv->cacheable = true;\n  }\n\n  /* load .newsrc */\n  if (rc >= 0)\n  {\n    mutt_expando_format(file, sizeof(file), 0, MuttIndexWindow->cols,\n                        NONULL(Newsrc), nntp_format_str, (unsigned long) nserv, 0);\n    mutt_expand_path(file, sizeof(file));\n    nserv->newsrc_file = mutt_str_strdup(file);\n    rc = nntp_newsrc_parse(nserv);\n  }\n  if (rc >= 0)\n  {\n    /* try to load list of newsgroups from cache */\n    if (nserv->cacheable && active_get_cache(nserv) == 0)\n      rc = nntp_check_new_groups(nserv);\n\n    /* load list of newsgroups from server */\n    else\n      rc = nntp_active_fetch(nserv, false);\n  }\n\n  if (rc >= 0)\n    nntp_clear_cache(nserv);\n\n#ifdef USE_HCACHE\n  /* check cache files */\n  if (rc >= 0 && nserv->cacheable)\n  {\n    struct dirent *entry = NULL;\n    DIR *dp = opendir(file);\n\n    if (dp)\n    {\n      while ((entry = readdir(dp)))\n      {\n        header_cache_t *hc = NULL;\n        void *hdata = NULL;\n        char *group = entry->d_name;\n\n        p = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (strcmp(p, \".hcache\") != 0))\n          continue;\n        *p = '\\0';\n        nntp_data = mutt_hash_find(nserv->groups_hash, group);\n        if (!nntp_data)\n          continue;\n\n        hc = nntp_hcache_open(nntp_data);\n        if (!hc)\n          continue;\n\n        /* fetch previous values of first and last */\n        hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n        if (hdata)\n        {\n          anum_t first, last;\n\n          if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n          {\n            if (nntp_data->deleted)\n            {\n              nntp_data->first_message = first;\n              nntp_data->last_message = last;\n            }\n            if (last >= nntp_data->first_message && last <= nntp_data->last_message)\n            {\n              nntp_data->last_cached = last;\n              mutt_debug(2, \"%s last_cached=%u\\n\", nntp_data->group, last);\n            }\n          }\n          mutt_hcache_free(hc, &hdata);\n        }\n        mutt_hcache_close(hc);\n      }\n      closedir(dp);\n    }\n  }\n#endif\n\n  if (rc < 0 || !leave_lock)\n    nntp_newsrc_close(nserv);\n\n  if (rc < 0)\n  {\n    mutt_hash_destroy(&nserv->groups_hash);\n    FREE(&nserv->groups_list);\n    FREE(&nserv->newsrc_file);\n    FREE(&nserv->authenticators);\n    FREE(&nserv);\n    mutt_socket_close(conn);\n    mutt_socket_free(conn);\n    return NULL;\n  }\n\n  conn->data = nserv;\n  return nserv;\n}\n\n/**\n * nntp_article_status - Get status of articles from .newsrc\n * @param ctx   Mailbox\n * @param hdr   Email Header\n * @param group Newsgroup\n * @param anum  Article number\n *\n * Full status flags are not supported by nntp, but we can fake some of them:\n * Read = a read message number is in the .newsrc\n * New = not read and not cached\n * Old = not read but cached\n */\nvoid nntp_article_status(struct Context *ctx, struct Header *hdr, char *group, anum_t anum)\n{\n  struct NntpData *nntp_data = ctx->data;\n\n  if (group)\n    nntp_data = mutt_hash_find(nntp_data->nserv->groups_hash, group);\n\n  if (!nntp_data)\n    return;\n\n  for (unsigned int i = 0; i < nntp_data->newsrc_len; i++)\n  {\n    if ((anum >= nntp_data->newsrc_ent[i].first) &&\n        (anum <= nntp_data->newsrc_ent[i].last))\n    {\n      /* can't use mutt_set_flag() because mx_update_context()\n         didn't called yet */\n      hdr->read = true;\n      return;\n    }\n  }\n\n  /* article was not cached yet, it's new */\n  if (anum > nntp_data->last_cached)\n    return;\n\n  /* article isn't read but cached, it's old */\n  if (MarkOld)\n    hdr->old = true;\n}\n\n/**\n * mutt_newsgroup_subscribe - Subscribe newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_subscribe(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->subscribed = true;\n  if (!nntp_data->newsrc_ent)\n  {\n    nntp_data->newsrc_ent = mutt_mem_calloc(1, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = 0;\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_unsubscribe - Unsubscribe newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_unsubscribe(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  nntp_data->subscribed = false;\n  if (!SaveUnsubscribed)\n  {\n    nntp_data->newsrc_len = 0;\n    FREE(&nntp_data->newsrc_ent);\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_catchup - Catchup newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_catchup(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  if (nntp_data->newsrc_ent)\n  {\n    mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = nntp_data->last_message;\n  }\n  nntp_data->unread = 0;\n  if (Context && Context->data == nntp_data)\n  {\n    for (unsigned int i = 0; i < Context->msgcount; i++)\n      mutt_set_flag(Context, Context->hdrs[i], MUTT_READ, 1);\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_uncatchup - Uncatchup newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_uncatchup(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  if (nntp_data->newsrc_ent)\n  {\n    mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = nntp_data->first_message - 1;\n  }\n  if (Context && Context->data == nntp_data)\n  {\n    nntp_data->unread = Context->msgcount;\n    for (unsigned int i = 0; i < Context->msgcount; i++)\n      mutt_set_flag(Context, Context->hdrs[i], MUTT_READ, 0);\n  }\n  else\n  {\n    nntp_data->unread = nntp_data->last_message;\n    if (nntp_data->newsrc_ent)\n      nntp_data->unread -= nntp_data->newsrc_ent[0].last;\n  }\n  return nntp_data;\n}\n\n/**\n * nntp_buffy - Get first newsgroup with new messages\n * @param buf Buffer for result\n * @param len Length of buffer\n */\nvoid nntp_buffy(char *buf, size_t len)\n{\n  for (unsigned int i = 0; i < CurrentNewsSrv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = CurrentNewsSrv->groups_list[i];\n\n    if (!nntp_data || !nntp_data->subscribed || !nntp_data->unread)\n      continue;\n\n    if (Context && Context->magic == MUTT_NNTP &&\n        (mutt_str_strcmp(nntp_data->group, ((struct NntpData *) Context->data)->group) == 0))\n    {\n      unsigned int unread = 0;\n\n      for (unsigned int j = 0; j < Context->msgcount; j++)\n        if (!Context->hdrs[j]->read && !Context->hdrs[j]->deleted)\n          unread++;\n      if (!unread)\n        continue;\n    }\n    mutt_str_strfcpy(buf, nntp_data->group, len);\n    break;\n  }\n}\n"], "fixing_code": ["/**\n * @file\n * Read/parse/write an NNTP config file of subscribed newsgroups\n *\n * @authors\n * Copyright (C) 1998 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999 Andrej Gritsenko <andrej@lucky.net>\n * Copyright (C) 2000-2017 Vsevolod Volkov <vvv@mutt.org.ua>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page newsrc Read/parse/write an NNTP config file of subscribed newsgroups\n *\n * Read/parse/write an NNTP config file of subscribed newsgroups\n */\n\n#include \"config.h\"\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"bcache.h\"\n#include \"context.h\"\n#include \"format_flags.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mutt_window.h\"\n#include \"mx.h\"\n#include \"nntp.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#include \"sort.h\"\n#include \"url.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\nstruct BodyCache;\n\n/**\n * nntp_data_find - Find NntpData for given newsgroup or add it\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstatic struct NntpData *nntp_data_find(struct NntpServer *nserv, const char *group)\n{\n  struct NntpData *nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (nntp_data)\n    return nntp_data;\n\n  size_t len = strlen(group) + 1;\n  /* create NntpData structure and add it to hash */\n  nntp_data = mutt_mem_calloc(1, sizeof(struct NntpData) + len);\n  nntp_data->group = (char *) nntp_data + sizeof(struct NntpData);\n  mutt_str_strfcpy(nntp_data->group, group, len);\n  nntp_data->nserv = nserv;\n  nntp_data->deleted = true;\n  mutt_hash_insert(nserv->groups_hash, nntp_data->group, nntp_data);\n\n  /* add NntpData to list */\n  if (nserv->groups_num >= nserv->groups_max)\n  {\n    nserv->groups_max *= 2;\n    mutt_mem_realloc(&nserv->groups_list, nserv->groups_max * sizeof(nntp_data));\n  }\n  nserv->groups_list[nserv->groups_num++] = nntp_data;\n\n  return nntp_data;\n}\n\n/**\n * nntp_acache_free - Remove all temporarily cache files\n * @param nntp_data NNTP data\n */\nvoid nntp_acache_free(struct NntpData *nntp_data)\n{\n  for (int i = 0; i < NNTP_ACACHE_LEN; i++)\n  {\n    if (nntp_data->acache[i].path)\n    {\n      unlink(nntp_data->acache[i].path);\n      FREE(&nntp_data->acache[i].path);\n    }\n  }\n}\n\n/**\n * nntp_data_free - Free NntpData, used to destroy hash elements\n * @param data NNTP data\n */\nvoid nntp_data_free(void *data)\n{\n  struct NntpData *nntp_data = data;\n\n  if (!nntp_data)\n    return;\n  nntp_acache_free(nntp_data);\n  mutt_bcache_close(&nntp_data->bcache);\n  FREE(&nntp_data->newsrc_ent);\n  FREE(&nntp_data->desc);\n  FREE(&data);\n}\n\n/**\n * nntp_hash_destructor - Free our hash table data\n * @param type Type (UNUSED)\n * @param obj  NNTP data\n * @param data Data (UNUSED)\n */\nvoid nntp_hash_destructor(int type, void *obj, intptr_t data)\n{\n  nntp_data_free(obj);\n}\n\n/**\n * nntp_newsrc_close - Unlock and close .newsrc file\n * @param nserv NNTP server\n */\nvoid nntp_newsrc_close(struct NntpServer *nserv)\n{\n  if (!nserv->newsrc_fp)\n    return;\n\n  mutt_debug(1, \"Unlocking %s\\n\", nserv->newsrc_file);\n  mutt_file_unlock(fileno(nserv->newsrc_fp));\n  mutt_file_fclose(&nserv->newsrc_fp);\n}\n\n/**\n * nntp_group_unread_stat - Count number of unread articles using .newsrc data\n * @param nntp_data NNTP data\n */\nvoid nntp_group_unread_stat(struct NntpData *nntp_data)\n{\n  nntp_data->unread = 0;\n  if (nntp_data->last_message == 0 || nntp_data->first_message > nntp_data->last_message)\n    return;\n\n  nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  for (unsigned int i = 0; i < nntp_data->newsrc_len; i++)\n  {\n    anum_t first = nntp_data->newsrc_ent[i].first;\n    if (first < nntp_data->first_message)\n      first = nntp_data->first_message;\n    anum_t last = nntp_data->newsrc_ent[i].last;\n    if (last > nntp_data->last_message)\n      last = nntp_data->last_message;\n    if (first <= last)\n      nntp_data->unread -= last - first + 1;\n  }\n}\n\n/**\n * nntp_newsrc_parse - Parse .newsrc file\n * @param nserv NNTP server\n * @retval  0 Not changed\n * @retval  1 Parsed\n * @retval -1 Error\n */\nint nntp_newsrc_parse(struct NntpServer *nserv)\n{\n  char *line = NULL;\n  struct stat sb;\n\n  if (nserv->newsrc_fp)\n  {\n    /* if we already have a handle, close it and reopen */\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n  else\n  {\n    /* if file doesn't exist, create it */\n    nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"a\");\n    mutt_file_fclose(&nserv->newsrc_fp);\n  }\n\n  /* open .newsrc */\n  nserv->newsrc_fp = mutt_file_fopen(nserv->newsrc_file, \"r\");\n  if (!nserv->newsrc_fp)\n  {\n    mutt_perror(nserv->newsrc_file);\n    return -1;\n  }\n\n  /* lock it */\n  mutt_debug(1, \"Locking %s\\n\", nserv->newsrc_file);\n  if (mutt_file_lock(fileno(nserv->newsrc_fp), 0, 1))\n  {\n    mutt_file_fclose(&nserv->newsrc_fp);\n    return -1;\n  }\n\n  if (stat(nserv->newsrc_file, &sb))\n  {\n    mutt_perror(nserv->newsrc_file);\n    nntp_newsrc_close(nserv);\n    return -1;\n  }\n\n  if (nserv->size == sb.st_size && nserv->mtime == sb.st_mtime)\n    return 0;\n\n  nserv->size = sb.st_size;\n  nserv->mtime = sb.st_mtime;\n  nserv->newsrc_modified = true;\n  mutt_debug(1, \"Parsing %s\\n\", nserv->newsrc_file);\n\n  /* .newsrc has been externally modified or hasn't been loaded yet */\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data)\n      continue;\n\n    nntp_data->subscribed = false;\n    nntp_data->newsrc_len = 0;\n    FREE(&nntp_data->newsrc_ent);\n  }\n\n  line = mutt_mem_malloc(sb.st_size + 1);\n  while (sb.st_size && fgets(line, sb.st_size + 1, nserv->newsrc_fp))\n  {\n    char *b = NULL, *h = NULL;\n    unsigned int j = 1;\n    bool subs = false;\n\n    /* find end of newsgroup name */\n    char *p = strpbrk(line, \":!\");\n    if (!p)\n      continue;\n\n    /* \":\" - subscribed, \"!\" - unsubscribed */\n    if (*p == ':')\n      subs = true;\n    *p++ = '\\0';\n\n    /* get newsgroup data */\n    struct NntpData *nntp_data = nntp_data_find(nserv, line);\n    FREE(&nntp_data->newsrc_ent);\n\n    /* count number of entries */\n    b = p;\n    while (*b)\n      if (*b++ == ',')\n        j++;\n    nntp_data->newsrc_ent = mutt_mem_calloc(j, sizeof(struct NewsrcEntry));\n    nntp_data->subscribed = subs;\n\n    /* parse entries */\n    j = 0;\n    while (p)\n    {\n      b = p;\n\n      /* find end of entry */\n      p = strchr(p, ',');\n      if (p)\n        *p++ = '\\0';\n\n      /* first-last or single number */\n      h = strchr(b, '-');\n      if (h)\n        *h++ = '\\0';\n      else\n        h = b;\n\n      if (sscanf(b, ANUM, &nntp_data->newsrc_ent[j].first) == 1 &&\n          sscanf(h, ANUM, &nntp_data->newsrc_ent[j].last) == 1)\n      {\n        j++;\n      }\n    }\n    if (j == 0)\n    {\n      nntp_data->newsrc_ent[j].first = 1;\n      nntp_data->newsrc_ent[j].last = 0;\n      j++;\n    }\n    if (nntp_data->last_message == 0)\n      nntp_data->last_message = nntp_data->newsrc_ent[j - 1].last;\n    nntp_data->newsrc_len = j;\n    mutt_mem_realloc(&nntp_data->newsrc_ent, j * sizeof(struct NewsrcEntry));\n    nntp_group_unread_stat(nntp_data);\n    mutt_debug(2, \"%s\\n\", nntp_data->group);\n  }\n  FREE(&line);\n  return 1;\n}\n\n/**\n * nntp_newsrc_gen_entries - Generate array of .newsrc entries\n * @param ctx Mailbox\n */\nvoid nntp_newsrc_gen_entries(struct Context *ctx)\n{\n  struct NntpData *nntp_data = ctx->data;\n  anum_t last = 0, first = 1;\n  bool series;\n  int save_sort = SORT_ORDER;\n  unsigned int entries;\n\n  if (Sort != SORT_ORDER)\n  {\n    save_sort = Sort;\n    Sort = SORT_ORDER;\n    mutt_sort_headers(ctx, 0);\n  }\n\n  entries = nntp_data->newsrc_len;\n  if (!entries)\n  {\n    entries = 5;\n    nntp_data->newsrc_ent = mutt_mem_calloc(entries, sizeof(struct NewsrcEntry));\n  }\n\n  /* Set up to fake initial sequence from 1 to the article before the\n   * first article in our list */\n  nntp_data->newsrc_len = 0;\n  series = true;\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* search for first unread */\n    if (series)\n    {\n      /* We don't actually check sequential order, since we mark\n       * \"missing\" entries as read/deleted */\n      last = NHDR(ctx->hdrs[i])->article_num;\n      if (last >= nntp_data->first_message && !ctx->hdrs[i]->deleted &&\n          !ctx->hdrs[i]->read)\n      {\n        if (nntp_data->newsrc_len >= entries)\n        {\n          entries *= 2;\n          mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n        }\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n        nntp_data->newsrc_ent[nntp_data->newsrc_len].last = last - 1;\n        nntp_data->newsrc_len++;\n        series = false;\n      }\n    }\n\n    /* search for first read */\n    else\n    {\n      if (ctx->hdrs[i]->deleted || ctx->hdrs[i]->read)\n      {\n        first = last + 1;\n        series = true;\n      }\n      last = NHDR(ctx->hdrs[i])->article_num;\n    }\n  }\n\n  if (series && first <= nntp_data->last_loaded)\n  {\n    if (nntp_data->newsrc_len >= entries)\n    {\n      entries++;\n      mutt_mem_realloc(&nntp_data->newsrc_ent, entries * sizeof(struct NewsrcEntry));\n    }\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].first = first;\n    nntp_data->newsrc_ent[nntp_data->newsrc_len].last = nntp_data->last_loaded;\n    nntp_data->newsrc_len++;\n  }\n  mutt_mem_realloc(&nntp_data->newsrc_ent, nntp_data->newsrc_len * sizeof(struct NewsrcEntry));\n\n  if (save_sort != Sort)\n  {\n    Sort = save_sort;\n    mutt_sort_headers(ctx, 0);\n  }\n}\n\n/**\n * update_file - Update file with new contents\n * @param filename File to update\n * @param buf      New context\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int update_file(char *filename, char *buf)\n{\n  FILE *fp = NULL;\n  char tmpfile[PATH_MAX];\n  int rc = -1;\n\n  while (true)\n  {\n    snprintf(tmpfile, sizeof(tmpfile), \"%s.tmp\", filename);\n    fp = mutt_file_fopen(tmpfile, \"w\");\n    if (!fp)\n    {\n      mutt_perror(tmpfile);\n      *tmpfile = '\\0';\n      break;\n    }\n    if (fputs(buf, fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      break;\n    }\n    if (mutt_file_fclose(&fp) == EOF)\n    {\n      mutt_perror(tmpfile);\n      fp = NULL;\n      break;\n    }\n    fp = NULL;\n    if (rename(tmpfile, filename) < 0)\n    {\n      mutt_perror(filename);\n      break;\n    }\n    *tmpfile = '\\0';\n    rc = 0;\n    break;\n  }\n  if (fp)\n    mutt_file_fclose(&fp);\n  if (*tmpfile)\n    unlink(tmpfile);\n  return rc;\n}\n\n/**\n * nntp_newsrc_update - Update .newsrc file\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_newsrc_update(struct NntpServer *nserv)\n{\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc = -1;\n\n  if (!nserv)\n    return -1;\n\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  off = 0;\n\n  /* we will generate full newsrc here */\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data || !nntp_data->newsrc_ent)\n      continue;\n\n    /* write newsgroup name */\n    if (off + strlen(nntp_data->group) + 3 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s%c \", nntp_data->group,\n             nntp_data->subscribed ? ':' : '!');\n    off += strlen(buf + off);\n\n    /* write entries */\n    for (unsigned int j = 0; j < nntp_data->newsrc_len; j++)\n    {\n      if (off + LONG_STRING > buflen)\n      {\n        buflen *= 2;\n        mutt_mem_realloc(&buf, buflen);\n      }\n      if (j)\n        buf[off++] = ',';\n      if (nntp_data->newsrc_ent[j].first == nntp_data->newsrc_ent[j].last)\n        snprintf(buf + off, buflen - off, \"%u\", nntp_data->newsrc_ent[j].first);\n      else if (nntp_data->newsrc_ent[j].first < nntp_data->newsrc_ent[j].last)\n      {\n        snprintf(buf + off, buflen - off, \"%u-%u\",\n                 nntp_data->newsrc_ent[j].first, nntp_data->newsrc_ent[j].last);\n      }\n      off += strlen(buf + off);\n    }\n    buf[off++] = '\\n';\n  }\n  buf[off] = '\\0';\n\n  /* newrc being fully rewritten */\n  mutt_debug(1, \"Updating %s\\n\", nserv->newsrc_file);\n  if (nserv->newsrc_file && update_file(nserv->newsrc_file, buf) == 0)\n  {\n    struct stat sb;\n\n    rc = stat(nserv->newsrc_file, &sb);\n    if (rc == 0)\n    {\n      nserv->size = sb.st_size;\n      nserv->mtime = sb.st_mtime;\n    }\n    else\n    {\n      mutt_perror(nserv->newsrc_file);\n    }\n  }\n  FREE(&buf);\n  return rc;\n}\n\n/**\n * cache_expand - Make fully qualified cache file name\n * @param dst    Buffer for filename\n * @param dstlen Length of buffer\n * @param acct   Account\n * @param src    Path to add to the URL\n */\nstatic void cache_expand(char *dst, size_t dstlen, struct Account *acct, char *src)\n{\n  char *c = NULL;\n  char file[PATH_MAX];\n\n  /* server subdirectory */\n  if (acct)\n  {\n    struct Url url;\n\n    mutt_account_tourl(acct, &url);\n    url.path = src;\n    url_tostring(&url, file, sizeof(file), U_PATH);\n  }\n  else\n    mutt_str_strfcpy(file, src ? src : \"\", sizeof(file));\n\n  snprintf(dst, dstlen, \"%s/%s\", NewsCacheDir, file);\n\n  /* remove trailing slash */\n  c = dst + strlen(dst) - 1;\n  if (*c == '/')\n    *c = '\\0';\n  mutt_expand_path(dst, dstlen);\n  mutt_encode_path(dst, dstlen, dst);\n}\n\n/**\n * nntp_expand_path - Make fully qualified url from newsgroup name\n * @param line String containing newsgroup name\n * @param len  Length of string\n * @param acct Account to save result\n */\nvoid nntp_expand_path(char *line, size_t len, struct Account *acct)\n{\n  struct Url url;\n\n  mutt_account_tourl(acct, &url);\n  url.path = mutt_str_strdup(line);\n  url_tostring(&url, line, len, 0);\n  FREE(&url.path);\n}\n\n/**\n * nntp_add_group - Parse newsgroup\n * @param line String to parse\n * @param data NNTP data\n * @retval 0 Always\n */\nint nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING] = \"\";\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n\n  if (!nserv || !line)\n    return 0;\n\n  /* These sscanf limits must match the sizes of the group and desc arrays */\n  if (sscanf(line, \"%1023s \" ANUM \" \" ANUM \" %c %8191[^\\n]\", group, &last, &first, &mod, desc) < 4)\n  {\n    mutt_debug(4, \"Cannot parse server line: %s\\n\", line);\n    return 0;\n  }\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}\n\n/**\n * active_get_cache - Load list of all newsgroups from cache\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int active_get_cache(struct NntpServer *nserv)\n{\n  char buf[HUGE_STRING];\n  char file[PATH_MAX];\n  time_t t;\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, \".active\");\n  mutt_debug(1, \"Parsing %s\\n\", file);\n  FILE *fp = mutt_file_fopen(file, \"r\");\n  if (!fp)\n    return -1;\n\n  if (fgets(buf, sizeof(buf), fp) == NULL || sscanf(buf, \"%ld%s\", &t, file) != 1 || t == 0)\n  {\n    mutt_file_fclose(&fp);\n    return -1;\n  }\n  nserv->newgroups_time = t;\n\n  mutt_message(_(\"Loading list of groups from cache...\"));\n  while (fgets(buf, sizeof(buf), fp))\n    nntp_add_group(buf, nserv);\n  nntp_add_group(NULL, NULL);\n  mutt_file_fclose(&fp);\n  mutt_clear_error();\n  return 0;\n}\n\n/**\n * nntp_active_save_cache - Save list of all newsgroups to cache\n * @param nserv NNTP server\n * @retval  0 Success\n * @retval -1 Failure\n */\nint nntp_active_save_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *buf = NULL;\n  size_t buflen, off;\n  int rc;\n\n  if (!nserv->cacheable)\n    return 0;\n\n  buflen = 10 * LONG_STRING;\n  buf = mutt_mem_calloc(1, buflen);\n  snprintf(buf, buflen, \"%lu\\n\", (unsigned long) nserv->newgroups_time);\n  off = strlen(buf);\n\n  for (unsigned int i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = nserv->groups_list[i];\n\n    if (!nntp_data || nntp_data->deleted)\n      continue;\n\n    if (off + strlen(nntp_data->group) + (nntp_data->desc ? strlen(nntp_data->desc) : 0) + 50 > buflen)\n    {\n      buflen *= 2;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    snprintf(buf + off, buflen - off, \"%s %u %u %c%s%s\\n\", nntp_data->group,\n             nntp_data->last_message, nntp_data->first_message,\n             nntp_data->allowed ? 'y' : 'n', nntp_data->desc ? \" \" : \"\",\n             nntp_data->desc ? nntp_data->desc : \"\");\n    off += strlen(buf + off);\n  }\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, \".active\");\n  mutt_debug(1, \"Updating %s\\n\", file);\n  rc = update_file(file, buf);\n  FREE(&buf);\n  return rc;\n}\n\n#ifdef USE_HCACHE\n/**\n * nntp_hcache_namer - Compose hcache file names\n * @param path    Path of message\n * @param dest    Buffer for filename\n * @param destlen Length of buffer\n * @retval num Characters written to buffer\n *\n * Used by mutt_hcache_open() to compose hcache file name\n */\nstatic int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.hcache\", path);\n}\n\n/**\n * nntp_hcache_open - Open newsgroup hcache\n * @param nntp_data NNTP data\n * @retval ptr  Header cache\n * @retval NULL Error\n */\nheader_cache_t *nntp_hcache_open(struct NntpData *nntp_data)\n{\n  struct Url url;\n  char file[PATH_MAX];\n\n  if (!nntp_data->nserv || !nntp_data->nserv->cacheable ||\n      !nntp_data->nserv->conn || !nntp_data->group ||\n      !(nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed))\n  {\n    return NULL;\n  }\n\n  mutt_account_tourl(&nntp_data->nserv->conn->account, &url);\n  url.path = nntp_data->group;\n  url_tostring(&url, file, sizeof(file), U_PATH);\n  return mutt_hcache_open(NewsCacheDir, file, nntp_hcache_namer);\n}\n\n/**\n * nntp_hcache_update - Remove stale cached headers\n * @param nntp_data NNTP data\n * @param hc        Header cache\n */\nvoid nntp_hcache_update(struct NntpData *nntp_data, header_cache_t *hc)\n{\n  char buf[16];\n  bool old = false;\n  void *hdata = NULL;\n  anum_t first = 0, last = 0;\n\n  if (!hc)\n    return;\n\n  /* fetch previous values of first and last */\n  hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n  if (hdata)\n  {\n    mutt_debug(2, \"mutt_hcache_fetch index: %s\\n\", (char *) hdata);\n    if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n    {\n      old = true;\n      nntp_data->last_cached = last;\n\n      /* clean removed headers from cache */\n      for (anum_t current = first; current <= last; current++)\n      {\n        if (current >= nntp_data->first_message && current <= nntp_data->last_message)\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n        mutt_hcache_delete(hc, buf, strlen(buf));\n      }\n    }\n    mutt_hcache_free(hc, &hdata);\n  }\n\n  /* store current values of first and last */\n  if (!old || nntp_data->first_message != first || nntp_data->last_message != last)\n  {\n    snprintf(buf, sizeof(buf), \"%u %u\", nntp_data->first_message, nntp_data->last_message);\n    mutt_debug(2, \"mutt_hcache_store index: %s\\n\", buf);\n    mutt_hcache_store_raw(hc, \"index\", 5, buf, strlen(buf));\n  }\n}\n#endif\n\n/**\n * nntp_bcache_delete - Remove bcache file\n * @param id     Body cache ID\n * @param bcache Body cache\n * @param data   NNTP data\n * @retval 0 Always\n */\nstatic int nntp_bcache_delete(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct NntpData *nntp_data = data;\n  anum_t anum;\n  char c;\n\n  if (!nntp_data || sscanf(id, ANUM \"%c\", &anum, &c) != 1 ||\n      anum < nntp_data->first_message || anum > nntp_data->last_message)\n  {\n    if (nntp_data)\n      mutt_debug(2, \"mutt_bcache_del %s\\n\", id);\n    mutt_bcache_del(bcache, id);\n  }\n  return 0;\n}\n\n/**\n * nntp_bcache_update - Remove stale cached messages\n * @param nntp_data NNTP data\n */\nvoid nntp_bcache_update(struct NntpData *nntp_data)\n{\n  mutt_bcache_list(nntp_data->bcache, nntp_bcache_delete, nntp_data);\n}\n\n/**\n * nntp_delete_group_cache - Remove hcache and bcache of newsgroup\n * @param nntp_data NNTP data\n */\nvoid nntp_delete_group_cache(struct NntpData *nntp_data)\n{\n  if (!nntp_data || !nntp_data->nserv || !nntp_data->nserv->cacheable)\n    return;\n\n#ifdef USE_HCACHE\n  char file[PATH_MAX];\n  nntp_hcache_namer(nntp_data->group, file, sizeof(file));\n  cache_expand(file, sizeof(file), &nntp_data->nserv->conn->account, file);\n  unlink(file);\n  nntp_data->last_cached = 0;\n  mutt_debug(2, \"%s\\n\", file);\n#endif\n\n  if (!nntp_data->bcache)\n  {\n    nntp_data->bcache =\n        mutt_bcache_open(&nntp_data->nserv->conn->account, nntp_data->group);\n  }\n  if (nntp_data->bcache)\n  {\n    mutt_debug(2, \"%s/*\\n\", nntp_data->group);\n    mutt_bcache_list(nntp_data->bcache, nntp_bcache_delete, NULL);\n    mutt_bcache_close(&nntp_data->bcache);\n  }\n}\n\n/**\n * nntp_clear_cache - Clear the NNTP cache\n * @param nserv NNTP server\n *\n * Remove hcache and bcache of all unexistent and unsubscribed newsgroups\n */\nvoid nntp_clear_cache(struct NntpServer *nserv)\n{\n  char file[PATH_MAX];\n  char *fp = NULL;\n  struct dirent *entry = NULL;\n  DIR *dp = NULL;\n\n  if (!nserv || !nserv->cacheable)\n    return;\n\n  cache_expand(file, sizeof(file), &nserv->conn->account, NULL);\n  dp = opendir(file);\n  if (dp)\n  {\n    mutt_str_strncat(file, sizeof(file), \"/\", 1);\n    fp = file + strlen(file);\n    while ((entry = readdir(dp)))\n    {\n      char *group = entry->d_name;\n      struct stat sb;\n      struct NntpData *nntp_data = NULL;\n      struct NntpData nntp_tmp;\n\n      if ((mutt_str_strcmp(group, \".\") == 0) || (mutt_str_strcmp(group, \"..\") == 0))\n        continue;\n      *fp = '\\0';\n      mutt_str_strncat(file, sizeof(file), group, strlen(group));\n      if (stat(file, &sb))\n        continue;\n\n#ifdef USE_HCACHE\n      if (S_ISREG(sb.st_mode))\n      {\n        char *ext = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (mutt_str_strcmp(ext, \".hcache\") != 0))\n          continue;\n        *ext = '\\0';\n      }\n      else\n#endif\n          if (!S_ISDIR(sb.st_mode))\n        continue;\n\n      nntp_data = mutt_hash_find(nserv->groups_hash, group);\n      if (!nntp_data)\n      {\n        nntp_data = &nntp_tmp;\n        nntp_data->nserv = nserv;\n        nntp_data->group = group;\n        nntp_data->bcache = NULL;\n      }\n      else if (nntp_data->newsrc_ent || nntp_data->subscribed || SaveUnsubscribed)\n        continue;\n\n      nntp_delete_group_cache(nntp_data);\n      if (S_ISDIR(sb.st_mode))\n      {\n        rmdir(file);\n        mutt_debug(2, \"%s\\n\", file);\n      }\n    }\n    closedir(dp);\n  }\n}\n\n/**\n * nntp_format_str - Expand the newsrc filename\n * @param[out] buf      Buffer in which to save string\n * @param[in]  buflen   Buffer length\n * @param[in]  col      Starting column\n * @param[in]  cols     Number of screen columns\n * @param[in]  op       printf-like operator, e.g. 't'\n * @param[in]  src      printf-like format string\n * @param[in]  prec     Field precision, e.g. \"-3.4\"\n * @param[in]  if_str   If condition is met, display this string\n * @param[in]  else_str Otherwise, display this string\n * @param[in]  data     Pointer to the mailbox Context\n * @param[in]  flags    Format flags\n * @retval src (unchanged)\n *\n * nntp_format_str() is a callback function for mutt_expando_format().\n *\n * | Expando | Description\n * |:--------|:--------------------------------------------------------\n * | \\%a     | Account url\n * | \\%p     | Port\n * | \\%P     | Port if specified\n * | \\%s     | News server name\n * | \\%S     | Url schema\n * | \\%u     | Username\n */\nconst char *nntp_format_str(char *buf, size_t buflen, size_t col, int cols, char op,\n                            const char *src, const char *prec, const char *if_str,\n                            const char *else_str, unsigned long data, enum FormatFlag flags)\n{\n  struct NntpServer *nserv = (struct NntpServer *) data;\n  struct Account *acct = &nserv->conn->account;\n  struct Url url;\n  char fn[SHORT_STRING], fmt[SHORT_STRING], *p = NULL;\n\n  switch (op)\n  {\n    case 'a':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, '/');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'p':\n      snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n      snprintf(buf, buflen, fmt, acct->port);\n      break;\n    case 'P':\n      *buf = '\\0';\n      if (acct->flags & MUTT_ACCT_PORT)\n      {\n        snprintf(fmt, sizeof(fmt), \"%%%su\", prec);\n        snprintf(buf, buflen, fmt, acct->port);\n      }\n      break;\n    case 's':\n      strncpy(fn, acct->host, sizeof(fn) - 1);\n      mutt_str_strlower(fn);\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'S':\n      mutt_account_tourl(acct, &url);\n      url_tostring(&url, fn, sizeof(fn), U_PATH);\n      p = strchr(fn, ':');\n      if (p)\n        *p = '\\0';\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, fn);\n      break;\n    case 'u':\n      snprintf(fmt, sizeof(fmt), \"%%%ss\", prec);\n      snprintf(buf, buflen, fmt, acct->user);\n      break;\n  }\n  return src;\n}\n\n/**\n * nntp_select_server - Open a connection to an NNTP server\n * @param server     Server URI\n * @param leave_lock Leave the server locked?\n * @retval ptr  NNTP server\n * @retval NULL Error\n *\n * Automatically loads a newsrc into memory, if necessary.  Checks the\n * size/mtime of a newsrc file, if it doesn't match, load again.  Hmm, if a\n * system has broken mtimes, this might mean the file is reloaded every time,\n * which we'd have to fix.\n */\nstruct NntpServer *nntp_select_server(char *server, bool leave_lock)\n{\n  char file[PATH_MAX];\n#ifdef USE_HCACHE\n  char *p = NULL;\n#endif\n  int rc;\n  struct Account acct;\n  struct NntpServer *nserv = NULL;\n  struct NntpData *nntp_data = NULL;\n  struct Connection *conn = NULL;\n  struct Url url;\n\n  if (!server || !*server)\n  {\n    mutt_error(_(\"No news server defined!\"));\n    return NULL;\n  }\n\n  /* create account from news server url */\n  acct.flags = 0;\n  acct.port = NNTP_PORT;\n  acct.type = MUTT_ACCT_TYPE_NNTP;\n  snprintf(file, sizeof(file), \"%s%s\", strstr(server, \"://\") ? \"\" : \"news://\", server);\n  if (url_parse(&url, file) < 0 || (url.path && *url.path) ||\n      !(url.scheme == U_NNTP || url.scheme == U_NNTPS) || !url.host ||\n      mutt_account_fromurl(&acct, &url) < 0)\n  {\n    url_free(&url);\n    mutt_error(_(\"%s is an invalid news server specification!\"), server);\n    return NULL;\n  }\n  if (url.scheme == U_NNTPS)\n  {\n    acct.flags |= MUTT_ACCT_SSL;\n    acct.port = NNTP_SSL_PORT;\n  }\n  url_free(&url);\n\n  /* find connection by account */\n  conn = mutt_conn_find(NULL, &acct);\n  if (!conn)\n    return NULL;\n  if (!(conn->account.flags & MUTT_ACCT_USER) && acct.flags & MUTT_ACCT_USER)\n  {\n    conn->account.flags |= MUTT_ACCT_USER;\n    conn->account.user[0] = '\\0';\n  }\n\n  /* news server already exists */\n  nserv = conn->data;\n  if (nserv)\n  {\n    if (nserv->status == NNTP_BYE)\n      nserv->status = NNTP_NONE;\n    if (nntp_open_connection(nserv) < 0)\n      return NULL;\n\n    rc = nntp_newsrc_parse(nserv);\n    if (rc < 0)\n      return NULL;\n\n    /* check for new newsgroups */\n    if (!leave_lock && nntp_check_new_groups(nserv) < 0)\n      rc = -1;\n\n    /* .newsrc has been externally modified */\n    if (rc > 0)\n      nntp_clear_cache(nserv);\n    if (rc < 0 || !leave_lock)\n      nntp_newsrc_close(nserv);\n    return (rc < 0) ? NULL : nserv;\n  }\n\n  /* new news server */\n  nserv = mutt_mem_calloc(1, sizeof(struct NntpServer));\n  nserv->conn = conn;\n  nserv->groups_hash = mutt_hash_create(1009, 0);\n  mutt_hash_set_destructor(nserv->groups_hash, nntp_hash_destructor, 0);\n  nserv->groups_max = 16;\n  nserv->groups_list = mutt_mem_malloc(nserv->groups_max * sizeof(nntp_data));\n\n  rc = nntp_open_connection(nserv);\n\n  /* try to create cache directory and enable caching */\n  nserv->cacheable = false;\n  if (rc >= 0 && NewsCacheDir && *NewsCacheDir)\n  {\n    cache_expand(file, sizeof(file), &conn->account, NULL);\n    if (mutt_file_mkdir(file, S_IRWXU) < 0)\n    {\n      mutt_error(_(\"Can't create %s: %s.\"), file, strerror(errno));\n    }\n    nserv->cacheable = true;\n  }\n\n  /* load .newsrc */\n  if (rc >= 0)\n  {\n    mutt_expando_format(file, sizeof(file), 0, MuttIndexWindow->cols,\n                        NONULL(Newsrc), nntp_format_str, (unsigned long) nserv, 0);\n    mutt_expand_path(file, sizeof(file));\n    nserv->newsrc_file = mutt_str_strdup(file);\n    rc = nntp_newsrc_parse(nserv);\n  }\n  if (rc >= 0)\n  {\n    /* try to load list of newsgroups from cache */\n    if (nserv->cacheable && active_get_cache(nserv) == 0)\n      rc = nntp_check_new_groups(nserv);\n\n    /* load list of newsgroups from server */\n    else\n      rc = nntp_active_fetch(nserv, false);\n  }\n\n  if (rc >= 0)\n    nntp_clear_cache(nserv);\n\n#ifdef USE_HCACHE\n  /* check cache files */\n  if (rc >= 0 && nserv->cacheable)\n  {\n    struct dirent *entry = NULL;\n    DIR *dp = opendir(file);\n\n    if (dp)\n    {\n      while ((entry = readdir(dp)))\n      {\n        header_cache_t *hc = NULL;\n        void *hdata = NULL;\n        char *group = entry->d_name;\n\n        p = group + strlen(group) - 7;\n        if (strlen(group) < 8 || (strcmp(p, \".hcache\") != 0))\n          continue;\n        *p = '\\0';\n        nntp_data = mutt_hash_find(nserv->groups_hash, group);\n        if (!nntp_data)\n          continue;\n\n        hc = nntp_hcache_open(nntp_data);\n        if (!hc)\n          continue;\n\n        /* fetch previous values of first and last */\n        hdata = mutt_hcache_fetch_raw(hc, \"index\", 5);\n        if (hdata)\n        {\n          anum_t first, last;\n\n          if (sscanf(hdata, ANUM \" \" ANUM, &first, &last) == 2)\n          {\n            if (nntp_data->deleted)\n            {\n              nntp_data->first_message = first;\n              nntp_data->last_message = last;\n            }\n            if (last >= nntp_data->first_message && last <= nntp_data->last_message)\n            {\n              nntp_data->last_cached = last;\n              mutt_debug(2, \"%s last_cached=%u\\n\", nntp_data->group, last);\n            }\n          }\n          mutt_hcache_free(hc, &hdata);\n        }\n        mutt_hcache_close(hc);\n      }\n      closedir(dp);\n    }\n  }\n#endif\n\n  if (rc < 0 || !leave_lock)\n    nntp_newsrc_close(nserv);\n\n  if (rc < 0)\n  {\n    mutt_hash_destroy(&nserv->groups_hash);\n    FREE(&nserv->groups_list);\n    FREE(&nserv->newsrc_file);\n    FREE(&nserv->authenticators);\n    FREE(&nserv);\n    mutt_socket_close(conn);\n    mutt_socket_free(conn);\n    return NULL;\n  }\n\n  conn->data = nserv;\n  return nserv;\n}\n\n/**\n * nntp_article_status - Get status of articles from .newsrc\n * @param ctx   Mailbox\n * @param hdr   Email Header\n * @param group Newsgroup\n * @param anum  Article number\n *\n * Full status flags are not supported by nntp, but we can fake some of them:\n * Read = a read message number is in the .newsrc\n * New = not read and not cached\n * Old = not read but cached\n */\nvoid nntp_article_status(struct Context *ctx, struct Header *hdr, char *group, anum_t anum)\n{\n  struct NntpData *nntp_data = ctx->data;\n\n  if (group)\n    nntp_data = mutt_hash_find(nntp_data->nserv->groups_hash, group);\n\n  if (!nntp_data)\n    return;\n\n  for (unsigned int i = 0; i < nntp_data->newsrc_len; i++)\n  {\n    if ((anum >= nntp_data->newsrc_ent[i].first) &&\n        (anum <= nntp_data->newsrc_ent[i].last))\n    {\n      /* can't use mutt_set_flag() because mx_update_context()\n         didn't called yet */\n      hdr->read = true;\n      return;\n    }\n  }\n\n  /* article was not cached yet, it's new */\n  if (anum > nntp_data->last_cached)\n    return;\n\n  /* article isn't read but cached, it's old */\n  if (MarkOld)\n    hdr->old = true;\n}\n\n/**\n * mutt_newsgroup_subscribe - Subscribe newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_subscribe(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->subscribed = true;\n  if (!nntp_data->newsrc_ent)\n  {\n    nntp_data->newsrc_ent = mutt_mem_calloc(1, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = 0;\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_unsubscribe - Unsubscribe newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_unsubscribe(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  nntp_data->subscribed = false;\n  if (!SaveUnsubscribed)\n  {\n    nntp_data->newsrc_len = 0;\n    FREE(&nntp_data->newsrc_ent);\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_catchup - Catchup newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_catchup(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  if (nntp_data->newsrc_ent)\n  {\n    mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = nntp_data->last_message;\n  }\n  nntp_data->unread = 0;\n  if (Context && Context->data == nntp_data)\n  {\n    for (unsigned int i = 0; i < Context->msgcount; i++)\n      mutt_set_flag(Context, Context->hdrs[i], MUTT_READ, 1);\n  }\n  return nntp_data;\n}\n\n/**\n * mutt_newsgroup_uncatchup - Uncatchup newsgroup\n * @param nserv NNTP server\n * @param group Newsgroup\n * @retval ptr  NNTP data\n * @retval NULL Error\n */\nstruct NntpData *mutt_newsgroup_uncatchup(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  if (nntp_data->newsrc_ent)\n  {\n    mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = nntp_data->first_message - 1;\n  }\n  if (Context && Context->data == nntp_data)\n  {\n    nntp_data->unread = Context->msgcount;\n    for (unsigned int i = 0; i < Context->msgcount; i++)\n      mutt_set_flag(Context, Context->hdrs[i], MUTT_READ, 0);\n  }\n  else\n  {\n    nntp_data->unread = nntp_data->last_message;\n    if (nntp_data->newsrc_ent)\n      nntp_data->unread -= nntp_data->newsrc_ent[0].last;\n  }\n  return nntp_data;\n}\n\n/**\n * nntp_buffy - Get first newsgroup with new messages\n * @param buf Buffer for result\n * @param len Length of buffer\n */\nvoid nntp_buffy(char *buf, size_t len)\n{\n  for (unsigned int i = 0; i < CurrentNewsSrv->groups_num; i++)\n  {\n    struct NntpData *nntp_data = CurrentNewsSrv->groups_list[i];\n\n    if (!nntp_data || !nntp_data->subscribed || !nntp_data->unread)\n      continue;\n\n    if (Context && Context->magic == MUTT_NNTP &&\n        (mutt_str_strcmp(nntp_data->group, ((struct NntpData *) Context->data)->group) == 0))\n    {\n      unsigned int unread = 0;\n\n      for (unsigned int j = 0; j < Context->msgcount; j++)\n        if (!Context->hdrs[j]->read && !Context->hdrs[j]->deleted)\n          unread++;\n      if (!unread)\n        continue;\n    }\n    mutt_str_strfcpy(buf, nntp_data->group, len);\n    break;\n  }\n}\n"], "filenames": ["newsrc.c"], "buggy_code_start_loc": [595], "buggy_code_end_loc": [604], "fixing_code_start_loc": [595], "fixing_code_end_loc": [609], "type": "CWE-787", "message": "An issue was discovered in NeoMutt before 2018-07-16. nntp_add_group in newsrc.c has a stack-based buffer overflow because of incorrect sscanf usage.", "other": {"cve": {"id": "CVE-2018-14360", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T17:29:00.870", "lastModified": "2020-05-19T17:17:15.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in NeoMutt before 2018-07-16. nntp_add_group in newsrc.c has a stack-based buffer overflow because of incorrect sscanf usage."}, {"lang": "es", "value": "Se ha descubierto un problema en NeoMutt en versiones anteriores al 2018-07-16. nntp_add_group en newsrc.c tiene un desbordamiento de b\u00fafer basado en pila debido a un uso incorrecto de sscanf."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180716", "matchCriteriaId": "1C15CCD1-1752-4913-9506-32035B52A513"}]}]}], "references": [{"url": "https://github.com/neomutt/neomutt/commit/6296f7153f0c9d5e5cd3aaf08f9731e56621bdd3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://neomutt.org/2018/07/16/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/6296f7153f0c9d5e5cd3aaf08f9731e56621bdd3"}}