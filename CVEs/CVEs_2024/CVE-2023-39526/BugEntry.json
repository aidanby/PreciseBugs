{"buggy_code": ["<?php\n/**\n * Copyright since 2007 PrestaShop SA and Contributors\n * PrestaShop is an International Registered Trademark & Property of PrestaShop SA\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.md.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://devdocs.prestashop.com/ for more information.\n *\n * @author    PrestaShop SA and Contributors <contact@prestashop.com>\n * @copyright Since 2007 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n */\n\n/**\n * Class RequestSqlCore.\n */\nclass RequestSqlCore extends ObjectModel\n{\n    public $name;\n    public $sql;\n\n    /**\n     * @see ObjectModel::$definition\n     */\n    public static $definition = [\n        'table' => 'request_sql',\n        'primary' => 'id_request_sql',\n        'fields' => [\n            'name' => ['type' => self::TYPE_STRING, 'validate' => 'isString', 'required' => true, 'size' => 200],\n            'sql' => ['type' => self::TYPE_SQL, 'validate' => 'isString', 'required' => true],\n        ],\n    ];\n\n    /** @var array : List of params to tested */\n    public $tested = [\n        'required' => ['SELECT', 'FROM'],\n        'option' => ['WHERE', 'ORDER', 'LIMIT', 'HAVING', 'GROUP', 'UNION'],\n        'operator' => [\n            'AND', '&&', 'BETWEEN', 'AND', 'BINARY', '&', '~', '|', '^', 'CASE', 'WHEN', 'END', 'DIV', '/', '<=>', '=', '>=',\n            '>', 'IS', 'NOT', 'NULL', '<<', '<=', '<', 'LIKE', '-', '%', '!=', '<>', 'REGEXP', '!', '||', 'OR', '+', '>>', 'RLIKE', 'SOUNDS', '*',\n            '-', 'XOR', 'IN',\n        ],\n        'function' => [\n            'AVG', 'SUM', 'COUNT', 'MIN', 'MAX', 'STDDEV', 'STDDEV_SAMP', 'STDDEV_POP', 'VARIANCE', 'VAR_SAMP', 'VAR_POP',\n            'GROUP_CONCAT', 'BIT_AND', 'BIT_OR', 'BIT_XOR',\n        ],\n        'unauthorized' => [\n            'DELETE', 'ALTER', 'INSERT', 'REPLACE', 'CREATE', 'TRUNCATE', 'OPTIMIZE', 'GRANT', 'REVOKE', 'SHOW', 'HANDLER',\n            'LOAD', 'LOAD_FILE', 'ROLLBACK', 'SAVEPOINT', 'UNLOCK', 'INSTALL', 'UNINSTALL', 'ANALZYE', 'BACKUP', 'CHECK', 'CHECKSUM', 'REPAIR', 'RESTORE', 'CACHE',\n            'DESCRIBE', 'EXPLAIN', 'USE', 'HELP', 'SET', 'DUPLICATE', 'VALUES',  'INTO', 'RENAME', 'CALL', 'PROCEDURE',  'FUNCTION', 'DATABASE', 'SERVER',\n            'LOGFILE', 'DEFINER', 'RETURNS', 'EVENT', 'TABLESPACE', 'VIEW', 'TRIGGER', 'DATA', 'DO', 'PASSWORD', 'USER', 'PLUGIN', 'FLUSH', 'KILL',\n            'RESET', 'START', 'STOP', 'PURGE', 'EXECUTE', 'PREPARE', 'DEALLOCATE', 'LOCK', 'USING', 'DROP', 'FOR', 'UPDATE', 'BEGIN', 'BY', 'ALL', 'SHARE',\n            'MODE', 'TO', 'KEY', 'DISTINCTROW', 'DISTINCT',  'HIGH_PRIORITY', 'LOW_PRIORITY', 'DELAYED', 'IGNORE', 'FORCE', 'STRAIGHT_JOIN',\n            'SQL_SMALL_RESULT', 'SQL_BIG_RESULT', 'QUICK', 'SQL_BUFFER_RESULT', 'SQL_CACHE', 'SQL_NO_CACHE', 'SQL_CALC_FOUND_ROWS', 'WITH',\n        ],\n    ];\n\n    public $attributes = [\n        'passwd' => '*******************',\n        'secure_key' => '*******************',\n    ];\n\n    /** @var array : list of errors */\n    public $error_sql = [];\n\n    /**\n     * Get list of request SQL.\n     *\n     * @return array|bool\n     */\n    public static function getRequestSql()\n    {\n        if (!$result = Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS('SELECT * FROM `' . _DB_PREFIX_ . 'request_sql` ORDER BY `id_request_sql`')) {\n            return false;\n        }\n\n        $requestSql = [];\n        foreach ($result as $row) {\n            $requestSql[] = $row['sql'];\n        }\n\n        return $requestSql;\n    }\n\n    /**\n     * Get list of request SQL by id request.\n     *\n     * @param int $id\n     *\n     * @return array\n     */\n    public static function getRequestSqlById($id)\n    {\n        return Db::getInstance()->executeS('SELECT `sql` FROM `' . _DB_PREFIX_ . 'request_sql` WHERE `id_request_sql` = ' . (int) $id);\n    }\n\n    /**\n     * Call the parserSQL() method in Tools class\n     * Cut the request in table for check it.\n     *\n     * @param string $sql\n     *\n     * @return array|bool\n     */\n    public function parsingSql($sql)\n    {\n        return Tools::parserSQL($sql);\n    }\n\n    /**\n     * Check if the parsing of the SQL request is good or not.\n     *\n     * @param array $tab\n     * @param bool $in\n     * @param string $sql\n     *\n     * @return bool\n     */\n    public function validateParser($tab, $in, $sql)\n    {\n        if (!$tab) {\n            return false;\n        } elseif (isset($tab['UNION'])) {\n            $union = $tab['UNION'];\n            foreach ($union as $tab) {\n                if (!$this->validateSql($tab, $in, $sql)) {\n                    return false;\n                }\n            }\n\n            return true;\n        } else {\n            return $this->validateSql($tab, $in, $sql);\n        }\n    }\n\n    /**\n     * Cut the request for check each cutting.\n     *\n     * @param array<string, array> $tab\n     * @param bool $in\n     * @param string $sql\n     *\n     * @return bool\n     */\n    public function validateSql($tab, $in, $sql)\n    {\n        if (!$this->testedRequired($tab)) {\n            return false;\n        } elseif (!$this->testedUnauthorized($tab)) {\n            return false;\n        } elseif (!$this->checkedFrom($tab['FROM'])) {\n            return false;\n        } elseif (!$this->checkedSelect($tab['SELECT'], $tab['FROM'], $in)) {\n            return false;\n        } elseif (isset($tab['WHERE'])) {\n            if (!$this->checkedWhere($tab['WHERE'], $tab['FROM'], $sql)) {\n                return false;\n            }\n        } elseif (isset($tab['HAVING'])) {\n            if (!$this->checkedHaving($tab['HAVING'], $tab['FROM'])) {\n                return false;\n            }\n        } elseif (isset($tab['ORDER'])) {\n            if (!$this->checkedOrder($tab['ORDER'], $tab['FROM'])) {\n                return false;\n            }\n        } elseif (isset($tab['GROUP'])) {\n            if (!$this->checkedGroupBy($tab['GROUP'], $tab['FROM'])) {\n                return false;\n            }\n        } elseif (isset($tab['LIMIT'])) {\n            if (!$this->checkedLimit($tab['LIMIT'])) {\n                return false;\n            }\n        }\n\n        if (empty($this->_errors) && !Db::getInstance()->executeS($sql)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get list of all tables.\n     *\n     * @return array\n     */\n    public function getTables()\n    {\n        $results = Db::getInstance()->executeS('SHOW TABLES');\n        $tables = [];\n        foreach ($results as $result) {\n            $key = array_keys($result);\n            $tables[] = $result[$key[0]];\n        }\n\n        return $tables;\n    }\n\n    /**\n     * Get list of all attributes by an table.\n     *\n     * @param string $table\n     *\n     * @return array\n     */\n    public function getAttributesByTable($table)\n    {\n        return Db::getInstance()->executeS('DESCRIBE ' . pSQL($table));\n    }\n\n    /**\n     * Cut an join sentence.\n     *\n     * @param array $attrs\n     * @param array $from\n     *\n     * @return array\n     */\n    public function cutJoin($attrs, $from)\n    {\n        $tab = [];\n\n        foreach ($attrs as $attr) {\n            if (in_array($attr['expr_type'], ['operator', 'const'])) {\n                continue;\n            }\n\n            if (!empty($attr['sub_tree'])) {\n                foreach ($attr['sub_tree'] as $treeItem) {\n                    if ($treeItem['expr_type'] !== 'colref') {\n                        continue;\n                    }\n                    if ($attribut = $this->cutAttribute($treeItem['base_expr'], $from)) {\n                        $tab[] = $attribut;\n                    }\n                }\n            } else {\n                if ($attribut = $this->cutAttribute($attr['base_expr'], $from)) {\n                    $tab[] = $attribut;\n                }\n            }\n        }\n\n        return $tab;\n    }\n\n    /**\n     * Cut an attribute with or without the alias.\n     *\n     * @param string $attr\n     * @param array $from\n     *\n     * @return array|bool\n     */\n    public function cutAttribute($attr, $from)\n    {\n        $matches = [];\n        if (preg_match('/((`(\\()?([a-z0-9_])+`(\\))?)|((\\()?([a-z0-9_])+(\\))?))\\.((`(\\()?([a-z0-9_])+`(\\))?)|((\\()?([a-z0-9_])+(\\))?))$/i', $attr, $matches, PREG_OFFSET_CAPTURE)) {\n            $tab = explode('.', str_replace(['`', '(', ')'], '', $matches[0][0]));\n            if ($table = $this->returnNameTable($tab[0], $from)) {\n                return [\n                    'table' => $table,\n                    'alias' => $tab[0],\n                    'attribut' => $tab[1],\n                    'string' => $attr,\n                ];\n            }\n        } elseif (preg_match('/((`(\\()?([a-z0-9_])+`(\\))?)|((\\()?([a-z0-9_])+(\\))?))$/i', $attr, $matches, PREG_OFFSET_CAPTURE)) {\n            $attribut = str_replace(['`', '(', ')'], '', $matches[0][0]);\n            if ($table = $this->returnNameTable(false, $from, $attr)) {\n                return [\n                    'table' => $table,\n                    'attribut' => $attribut,\n                    'string' => $attr,\n                ];\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Get name of table by alias.\n     *\n     * @param string|false $alias\n     * @param array $tables\n     *\n     * @return array|bool\n     */\n    public function returnNameTable($alias, $tables, $attr = null)\n    {\n        if ($alias) {\n            foreach ($tables as $table) {\n                if (!isset($table['alias']) || !isset($table['table'])) {\n                    continue;\n                }\n                /** @var string|array{'parts': array<int, bool>} $tableAlias */\n                $tableAlias = $table['alias']['no_quotes'];\n                if ($tableAlias == $alias || $tableAlias['parts'][0] == $alias) {\n                    return [$table['table']];\n                }\n            }\n        } elseif (count($tables) > 1) {\n            if ($attr !== null) {\n                $tab = [];\n                foreach ($tables as $table) {\n                    if ($this->attributExistInTable($attr, $table['table'])) {\n                        $tab = $table['table'];\n                    }\n                }\n                if (count($tab) == 1) {\n                    return $tab;\n                }\n            }\n\n            $this->error_sql['returnNameTable'] = false;\n\n            return false;\n        }\n\n        $tab = [];\n        foreach ($tables as $table) {\n            $tab[] = $table['table'];\n        }\n\n        return $tab;\n    }\n\n    /**\n     * Check if an attributes exists in a table.\n     *\n     * @param string $attr\n     * @param array $table\n     *\n     * @return bool\n     */\n    public function attributExistInTable($attr, $table)\n    {\n        if (!$attr) {\n            return true;\n        }\n        if (is_array($table) && (count($table) == 1)) {\n            $table = $table[0];\n        }\n        $attributs = $this->getAttributesByTable($table);\n        foreach ($attributs as $attribut) {\n            if ($attribut['Field'] == trim($attr, ' `')) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if all required sentence existing.\n     *\n     * @param array $tab\n     *\n     * @return bool\n     */\n    public function testedRequired($tab)\n    {\n        foreach ($this->tested['required'] as $key) {\n            if (!array_key_exists($key, $tab)) {\n                $this->error_sql['testedRequired'] = $key;\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if an unauthorized existing in an array.\n     *\n     * @param array $tab\n     *\n     * @return bool\n     */\n    public function testedUnauthorized($tab)\n    {\n        foreach ($this->tested['unauthorized'] as $key) {\n            if (array_key_exists($key, $tab)) {\n                $this->error_sql['testedUnauthorized'] = $key;\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"FROM\" sentence.\n     *\n     * @param array<int, array<string, mixed>> $from\n     *\n     * @return bool\n     */\n    public function checkedFrom($from)\n    {\n        $nb = count($from);\n        for ($i = 0; $i < $nb; ++$i) {\n            $table = $from[$i];\n\n            if (isset($table['table']) && !in_array(str_replace('`', '', $table['table']), $this->getTables())) {\n                $this->error_sql['checkedFrom']['table'] = $table['table'];\n\n                return false;\n            }\n            if ($table['ref_type'] == 'ON' && (trim($table['join_type']) == 'LEFT' || trim($table['join_type']) == 'JOIN')) {\n                $attrs = $this->cutJoin($table['ref_clause'], $from);\n                foreach ($attrs as $attr) {\n                    if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                        $this->error_sql['checkedFrom']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"SELECT\" sentence.\n     *\n     * @param array<int, array<string, mixed>> $select\n     * @param array $from\n     * @param bool $in\n     *\n     * @return bool\n     */\n    public function checkedSelect($select, $from, $in = false)\n    {\n        $nb = count($select);\n        for ($i = 0; $i < $nb; ++$i) {\n            $attribut = $select[$i];\n            if ($attribut['base_expr'] != '*' && !preg_match('/\\.\\*$/', $attribut['base_expr'])) {\n                if ($attribut['expr_type'] == 'colref') {\n                    if ($attr = $this->cutAttribute(trim($attribut['base_expr']), $from)) {\n                        if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                            $this->error_sql['checkedSelect']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                            return false;\n                        }\n                    } else {\n                        if (isset($this->error_sql['returnNameTable'])) {\n                            $this->error_sql['checkedSelect'] = $this->error_sql['returnNameTable'];\n\n                            return false;\n                        } else {\n                            $this->error_sql['checkedSelect'] = false;\n\n                            return false;\n                        }\n                    }\n                }\n\n                while (is_array($attribut['sub_tree'])) {\n                    if ($attribut['expr_type'] === 'function' && in_array(strtoupper($attribut['base_expr']), $this->tested['unauthorized'])) {\n                        $this->error_sql['checkedSelect']['function'] = $attribut['base_expr'];\n\n                        return false;\n                    }\n                    $attribut = $attribut['sub_tree'][0];\n                }\n            } elseif ($in) {\n                $this->error_sql['checkedSelect']['*'] = false;\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"WHERE\" sentence.\n     *\n     * @param array<int, array<string, mixed>> $where\n     * @param array $from\n     * @param string $sql\n     *\n     * @return bool\n     */\n    public function checkedWhere($where, $from, $sql)\n    {\n        $nb = count($where);\n        for ($i = 0; $i < $nb; ++$i) {\n            $attribut = $where[$i];\n            if ($attribut['expr_type'] == 'colref') {\n                if ($attr = $this->cutAttribute(trim($attribut['base_expr']), $from)) {\n                    if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                        $this->error_sql['checkedWhere']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                        return false;\n                    }\n                } else {\n                    $this->error_sql['checkedWhere'] = $this->error_sql['returnNameTable'] ?? false;\n\n                    return false;\n                }\n            } elseif ($attribut['expr_type'] == 'reserved') {\n                if ($attribut['base_expr'] !== 'EXISTS' || !isset($where[$i + 1]) || $where[$i + 1]['expr_type'] !== 'subquery') {\n                    $this->error_sql['checkedWhere'] = $this->error_sql['returnNameTable'] ?? false;\n\n                    return false;\n                }\n            } elseif ($attribut['expr_type'] == 'operator') {\n                if (!in_array(strtoupper($attribut['base_expr']), $this->tested['operator'])) {\n                    $this->error_sql['checkedWhere']['operator'] = [$attribut['base_expr']];\n\n                    return false;\n                }\n            } elseif ($attribut['expr_type'] == 'subquery') {\n                $tab = $attribut['sub_tree'];\n\n                return $this->validateParser($tab, true, $sql);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"HAVING\" sentence.\n     *\n     * @param array<int, array<string, mixed>> $having\n     * @param array $from\n     *\n     * @return bool\n     */\n    public function checkedHaving($having, $from)\n    {\n        $nb = count($having);\n        for ($i = 0; $i < $nb; ++$i) {\n            $attribut = $having[$i];\n            if ($attribut['expr_type'] == 'colref') {\n                if ($attr = $this->cutAttribute(trim($attribut['base_expr']), $from)) {\n                    if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                        $this->error_sql['checkedHaving']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                        return false;\n                    }\n                } else {\n                    if (isset($this->error_sql['returnNameTable'])) {\n                        $this->error_sql['checkedHaving'] = $this->error_sql['returnNameTable'];\n\n                        return false;\n                    } else {\n                        $this->error_sql['checkedHaving'] = false;\n\n                        return false;\n                    }\n                }\n            }\n\n            if ($attribut['expr_type'] == 'operator') {\n                if (!in_array(strtoupper($attribut['base_expr']), $this->tested['operator'])) {\n                    $this->error_sql['checkedHaving']['operator'] = [$attribut['base_expr']];\n\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"ORDER\" sentence.\n     *\n     * @param array $order\n     * @param array $from\n     *\n     * @return bool\n     */\n    public function checkedOrder($order, $from)\n    {\n        $order = $order[0];\n        if (array_key_exists('expression', $order) && $order['type'] == 'expression') {\n            if ($attr = $this->cutAttribute(trim($order['base_expr']), $from)) {\n                if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                    $this->error_sql['checkedOrder']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                    return false;\n                }\n            } else {\n                if (isset($this->error_sql['returnNameTable'])) {\n                    $this->error_sql['checkedOrder'] = $this->error_sql['returnNameTable'];\n\n                    return false;\n                } else {\n                    $this->error_sql['checkedOrder'] = false;\n\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"GROUP BY\" sentence.\n     *\n     * @param array $group\n     * @param array $from\n     *\n     * @return bool\n     */\n    public function checkedGroupBy($group, $from)\n    {\n        $group = $group[0];\n        if ($group['expr_type'] == 'colref') {\n            if ($attr = $this->cutAttribute(trim($group['base_expr']), $from)) {\n                if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                    $this->error_sql['checkedGroupBy']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                    return false;\n                }\n            } else {\n                if (isset($this->error_sql['returnNameTable'])) {\n                    $this->error_sql['checkedGroupBy'] = $this->error_sql['returnNameTable'];\n\n                    return false;\n                } else {\n                    $this->error_sql['checkedGroupBy'] = false;\n\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"LIMIT\" sentence.\n     *\n     * @param array $limit\n     *\n     * @return bool\n     */\n    public function checkedLimit($limit)\n    {\n        if (!preg_match('#^[0-9]+$#', trim($limit['offset'])) || !preg_match('#^[0-9]+$#', trim($limit['rowcount']))) {\n            $this->error_sql['checkedLimit'] = false;\n\n            return false;\n        }\n\n        return true;\n    }\n}\n", "<?php\n/**\n * Copyright since 2007 PrestaShop SA and Contributors\n * PrestaShop is an International Registered Trademark & Property of PrestaShop SA\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.md.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://devdocs.prestashop.com/ for more information.\n *\n * @author    PrestaShop SA and Contributors <contact@prestashop.com>\n * @copyright Since 2007 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n */\n/**\n * Class DbCore.\n */\nabstract class DbCore\n{\n    /** @var int Constant used by insert() method */\n    public const INSERT = 1;\n\n    /** @var int Constant used by insert() method */\n    public const INSERT_IGNORE = 2;\n\n    /** @var int Constant used by insert() method */\n    public const REPLACE = 3;\n\n    /** @var int Constant used by insert() method */\n    public const ON_DUPLICATE_KEY = 4;\n\n    /** @var string Server (eg. localhost) */\n    protected $server;\n\n    /** @var string Database user (eg. root) */\n    protected $user;\n\n    /** @var string Database password (eg. can be empty !) */\n    protected $password;\n\n    /** @var string Database name */\n    protected $database;\n\n    /** @var bool */\n    protected $is_cache_enabled;\n\n    /** @var PDO|mysqli|resource|null Resource link */\n    protected $link;\n\n    /** @var PDOStatement|mysqli_result|resource|bool SQL cached result */\n    protected $result;\n\n    /** @var array List of DB instances */\n    public static $instance = [];\n\n    /** @var array List of server settings */\n    public static $_servers = [];\n\n    /** @var bool|null Flag used to load slave servers only once.\n     * See loadSlaveServers() method\n     */\n    public static $_slave_servers_loaded = null;\n\n    /**\n     * Store last executed query.\n     *\n     * @var string\n     */\n    protected $last_query;\n\n    /**\n     * Store hash of the last executed query.\n     *\n     * @var string\n     */\n    protected $last_query_hash;\n\n    /**\n     * Last cached query.\n     *\n     * @var bool\n     */\n    protected $last_cached;\n\n    /**\n     * Opens a database connection.\n     *\n     * @return PDO|mysqli|resource\n     */\n    abstract public function connect();\n\n    /**\n     * Closes database connection.\n     */\n    abstract public function disconnect();\n\n    /**\n     * Execute a query and get result resource.\n     *\n     * @param string $sql\n     *\n     * @return PDOStatement|mysqli_result|resource|bool\n     */\n    abstract protected function _query($sql);\n\n    /**\n     * Get number of rows in a result.\n     *\n     * @param mixed $result\n     *\n     * @return int\n     */\n    abstract protected function _numRows($result);\n\n    /**\n     * Get the ID generated from the previous INSERT operation.\n     *\n     * @return int|string\n     */\n    abstract public function Insert_ID();\n\n    /**\n     * Get number of affected rows in previous database operation.\n     *\n     * @return int\n     */\n    abstract public function Affected_Rows();\n\n    /**\n     * Get next row for a query which does not return an array.\n     *\n     * @param PDOStatement|mysqli_result|resource|bool $result\n     *\n     * @return array|object|false|null\n     */\n    abstract public function nextRow($result = false);\n\n    /**\n     * Get all rows for a query which return an array.\n     *\n     * @param PDOStatement|mysqli_result|resource|bool|null $result\n     *\n     * @return array\n     */\n    abstract protected function getAll($result = false);\n\n    /**\n     * Get database version.\n     *\n     * @return string\n     */\n    abstract public function getVersion();\n\n    /**\n     * Protect string against SQL injections.\n     *\n     * @param string $str\n     *\n     * @return string\n     */\n    abstract public function _escape($str);\n\n    /**\n     * Returns the text of the error message from previous database operation.\n     *\n     * @return string\n     */\n    abstract public function getMsgError();\n\n    /**\n     * Returns the number of the error from previous database operation.\n     *\n     * @return int\n     */\n    abstract public function getNumberError();\n\n    /**\n     * Sets the current active database on the server that's associated with the specified link identifier.\n     * Do not remove, useful for some modules.\n     *\n     * @param string $db_name\n     *\n     * @return bool|int\n     */\n    abstract public function set_db($db_name);\n\n    /**\n     * Selects best table engine.\n     *\n     * @return string\n     */\n    abstract public function getBestEngine();\n\n    /**\n     * Returns database object instance.\n     *\n     * @param bool $master Decides whether the connection to be returned by the master server or the slave server\n     *\n     * @return Db Singleton instance of Db object\n     */\n    public static function getInstance($master = true)\n    {\n        static $id = 0;\n\n        // This MUST not be declared with the class members because some defines (like _DB_SERVER_) may not exist yet (the constructor can be called directly with params)\n        if (!self::$_servers) {\n            self::$_servers = [\n                ['server' => _DB_SERVER_, 'user' => _DB_USER_, 'password' => _DB_PASSWD_, 'database' => _DB_NAME_], /* MySQL Master server */\n            ];\n        }\n\n        if (!$master) {\n            Db::loadSlaveServers();\n        }\n\n        $total_servers = count(self::$_servers);\n        if ($master || $total_servers == 1) {\n            $id_server = 0;\n        } else {\n            ++$id;\n            $id_server = ($total_servers > 2 && ($id % $total_servers) != 0) ? $id % $total_servers : 1;\n        }\n\n        if (!isset(self::$instance[$id_server])) {\n            $class = Db::getClass();\n            self::$instance[$id_server] = new $class(\n                self::$_servers[$id_server]['server'],\n                self::$_servers[$id_server]['user'],\n                self::$_servers[$id_server]['password'],\n                self::$_servers[$id_server]['database']\n            );\n        }\n\n        return self::$instance[$id_server];\n    }\n\n    public function getPrefix()\n    {\n        return _DB_PREFIX_;\n    }\n\n    /**\n     * @param Db $test_db\n     *                    Unit testing purpose only\n     */\n    public static function setInstanceForTesting($test_db)\n    {\n        self::$instance[0] = $test_db;\n    }\n\n    /**\n     * Unit testing purpose only.\n     */\n    public static function deleteTestingInstance()\n    {\n        self::$instance = [];\n    }\n\n    /**\n     * Loads configuration settings for slave servers if needed.\n     */\n    protected static function loadSlaveServers()\n    {\n        if (self::$_slave_servers_loaded !== null) {\n            return;\n        }\n\n        // Add here your slave(s) server(s) in this file\n        if (file_exists(_PS_ROOT_DIR_ . '/config/db_slave_server.inc.php')) {\n            self::$_servers = array_merge(self::$_servers, require(_PS_ROOT_DIR_ . '/config/db_slave_server.inc.php'));\n        }\n\n        self::$_slave_servers_loaded = true;\n    }\n\n    /**\n     * Returns the best child layer database class.\n     *\n     * @return string\n     */\n    public static function getClass()\n    {\n        $class = '';\n        /* @phpstan-ignore-next-line */\n        if (PHP_VERSION_ID >= 50200 && extension_loaded('pdo_mysql')) {\n            $class = 'DbPDO';\n        } elseif (extension_loaded('mysqli')) {\n            $class = 'DbMySQLi';\n        }\n\n        if (empty($class)) {\n            throw new PrestaShopException('Cannot select any valid SQL engine.');\n        }\n\n        return $class;\n    }\n\n    /**\n     * Instantiates a database connection.\n     *\n     * @param string $server Server address\n     * @param string $user User login\n     * @param string $password User password\n     * @param string $database Database name\n     * @param bool $connect If false, don't connect in constructor (since 1.5.0.1)\n     */\n    public function __construct($server, $user, $password, $database, $connect = true)\n    {\n        $this->server = $server;\n        $this->user = $user;\n        $this->password = $password;\n        $this->database = $database;\n        $this->is_cache_enabled = (defined('_PS_CACHE_ENABLED_')) ? _PS_CACHE_ENABLED_ : false;\n\n        if (!defined('_PS_DEBUG_SQL_')) {\n            define('_PS_DEBUG_SQL_', false);\n        }\n\n        if ($connect) {\n            $this->connect();\n        }\n    }\n\n    /**\n     * Disable the use of the cache.\n     */\n    public function disableCache()\n    {\n        $this->is_cache_enabled = false;\n    }\n\n    /**\n     * Enable & flush the cache.\n     */\n    public function enableCache()\n    {\n        $this->is_cache_enabled = true;\n        Cache::getInstance()->flush();\n    }\n\n    /**\n     * Closes connection to database.\n     */\n    public function __destruct()\n    {\n        if ($this->link) {\n            $this->disconnect();\n        }\n    }\n\n    /**\n     * Execute a query and get result resource.\n     *\n     * @param string|DbQuery $sql\n     *\n     * @return bool|mysqli_result|PDOStatement|resource\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function query($sql)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = $this->_query($sql);\n\n        if (!$this->result && $this->getNumberError() == 2006) {\n            $this->connect();\n            $this->result = $this->_query($sql);\n        }\n\n        if (_PS_DEBUG_SQL_) {\n            $this->displayError($sql);\n        }\n\n        return $this->result;\n    }\n\n    /**\n     * Executes an INSERT query.\n     *\n     * @param string $table Table name without prefix\n     * @param array $data Data to insert as associative array. If $data is a list of arrays, multiple insert will be done\n     * @param bool $null_values If we want to use NULL values instead of empty quotes\n     * @param bool $use_cache\n     * @param int $type Must be Db::INSERT or Db::INSERT_IGNORE or Db::REPLACE\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function insert($table, $data, $null_values = false, $use_cache = true, $type = Db::INSERT, $add_prefix = true)\n    {\n        if (!$data && !$null_values) {\n            return true;\n        }\n\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        if ($type == Db::INSERT) {\n            $insert_keyword = 'INSERT';\n        } elseif ($type == Db::INSERT_IGNORE) {\n            $insert_keyword = 'INSERT IGNORE';\n        } elseif ($type == Db::REPLACE) {\n            $insert_keyword = 'REPLACE';\n        } elseif ($type == Db::ON_DUPLICATE_KEY) {\n            $insert_keyword = 'INSERT';\n        } else {\n            throw new PrestaShopDatabaseException('Bad keyword, must be Db::INSERT or Db::INSERT_IGNORE or Db::REPLACE or Db::ON_DUPLICATE_KEY');\n        }\n\n        // Check if $data is a list of row\n        $current = current($data);\n        if (!is_array($current) || isset($current['type'])) {\n            $data = [$data];\n        }\n\n        $keys = [];\n        $values_stringified = [];\n        $first_loop = true;\n        $duplicate_key_stringified = '';\n\n        foreach ($data as $row_data) {\n            $values = [];\n            foreach ($row_data as $key => $value) {\n                if (!$first_loop) {\n                    // Check if row array mapping are the same\n                    if (!in_array(\"`$key`\", $keys)) {\n                        throw new PrestaShopDatabaseException('Keys form $data subarray don\\'t match');\n                    }\n\n                    if ($duplicate_key_stringified != '') {\n                        throw new PrestaShopDatabaseException('On duplicate key cannot be used on insert with more than 1 VALUE group');\n                    }\n                } else {\n                    $keys[] = '`' . bqSQL($key) . '`';\n                }\n\n                if (!is_array($value)) {\n                    $value = ['type' => 'text', 'value' => $value];\n                }\n                if ($value['type'] == 'sql') {\n                    $values[] = $string_value = $value['value'];\n                } else {\n                    $values[] = $string_value = $null_values && ($value['value'] === '' || null === $value['value']) ? 'NULL' : \"'{$value['value']}'\";\n                }\n\n                if ($type == Db::ON_DUPLICATE_KEY) {\n                    $duplicate_key_stringified .= '`' . bqSQL($key) . '` = ' . $string_value . ',';\n                }\n            }\n            $first_loop = false;\n            $values_stringified[] = '(' . implode(', ', $values) . ')';\n        }\n        $keys_stringified = implode(', ', $keys);\n\n        $sql = $insert_keyword . ' INTO `' . $table . '` (' . $keys_stringified . ') VALUES ' . implode(', ', $values_stringified);\n        if ($type == Db::ON_DUPLICATE_KEY) {\n            $sql .= ' ON DUPLICATE KEY UPDATE ' . substr($duplicate_key_stringified, 0, -1);\n        }\n\n        return (bool) $this->q($sql, $use_cache);\n    }\n\n    /**\n     * Executes an UPDATE query.\n     *\n     * @param string $table Table name without prefix\n     * @param array $data Data to insert as associative array. If $data is a list of arrays, multiple insert will be done\n     * @param string $where WHERE condition\n     * @param int $limit\n     * @param bool $null_values If we want to use NULL values instead of empty quotes\n     * @param bool $use_cache\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     */\n    public function update($table, $data, $where = '', $limit = 0, $null_values = false, $use_cache = true, $add_prefix = true)\n    {\n        if (!$data) {\n            return true;\n        }\n\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        $sql = 'UPDATE `' . bqSQL($table) . '` SET ';\n        foreach ($data as $key => $value) {\n            if (!is_array($value)) {\n                $value = ['type' => 'text', 'value' => $value];\n            }\n            if ($value['type'] == 'sql') {\n                $sql .= '`' . bqSQL($key) . \"` = {$value['value']},\";\n            } else {\n                $sql .= ($null_values && ($value['value'] === '' || null === $value['value'])) ? '`' . bqSQL($key) . '` = NULL,' : '`' . bqSQL($key) . \"` = '{$value['value']}',\";\n            }\n        }\n\n        $sql = rtrim($sql, ',');\n        if ($where) {\n            $sql .= ' WHERE ' . $where;\n        }\n        if ($limit) {\n            $sql .= ' LIMIT ' . (int) $limit;\n        }\n\n        return (bool) $this->q($sql, $use_cache);\n    }\n\n    /**\n     * Executes a DELETE query.\n     *\n     * @param string $table Name of the table to delete\n     * @param string $where WHERE clause on query\n     * @param int $limit Number max of rows to delete\n     * @param bool $use_cache Use cache or not\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     */\n    public function delete($table, $where = '', $limit = 0, $use_cache = true, $add_prefix = true)\n    {\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        $this->result = false;\n        $sql = 'DELETE FROM `' . bqSQL($table) . '`' . ($where ? ' WHERE ' . $where : '') . ($limit ? ' LIMIT ' . (int) $limit : '');\n        $res = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        return (bool) $res;\n    }\n\n    /**\n     * Executes a query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return bool\n     */\n    public function execute($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        return (bool) $this->result;\n    }\n\n    /**\n     * Executes return the result of $sql as array.\n     *\n     * @param string|DbQuery $sql Query to execute\n     * @param bool $array Return an array instead of a result object (deprecated since 1.5.0.1, use query method instead)\n     * @param bool $use_cache\n     *\n     * @return array|bool|mysqli_result|PDOStatement|resource|null\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function executeS($sql, $array = true, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = false;\n        $this->last_query = $sql;\n\n        if ($use_cache && $this->is_cache_enabled && $array) {\n            $this->last_query_hash = Cache::getInstance()->getQueryHash($sql);\n            if (($result = Cache::getInstance()->get($this->last_query_hash)) !== false) {\n                Cache::getInstance()->incrementQueryCounter($sql);\n                $this->last_cached = true;\n\n                return $result;\n            }\n        }\n\n        // This method must be used only with queries which display results\n        if (!preg_match('#^\\s*\\(?\\s*(select|show|explain|describe|desc|checksum)\\s#i', $sql)) {\n            throw new PrestaShopDatabaseException('Db->executeS() must be used only with select, show, explain or describe queries');\n        }\n\n        $this->result = $this->query($sql);\n\n        if (!$this->result) {\n            $result = false;\n        } else {\n            if (!$array) {\n                $use_cache = false;\n                $result = $this->result;\n            } else {\n                $result = $this->getAll($this->result);\n            }\n        }\n\n        $this->last_cached = false;\n        if ($use_cache && $this->is_cache_enabled && $array) {\n            Cache::getInstance()->setQuery($sql, $result);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns an associative array containing the first row of the query\n     * This function automatically adds \"LIMIT 1\" to the query.\n     *\n     * @param string|DbQuery $sql the select query (without \"LIMIT 1\")\n     * @param bool $use_cache Find it in cache first\n     *\n     * @return array|bool|object|null\n     */\n    public function getRow($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $sql = rtrim($sql, \" \\t\\n\\r\\0\\x0B;\") . ' LIMIT 1';\n        $this->result = false;\n        $this->last_query = $sql;\n\n        if ($use_cache && $this->is_cache_enabled) {\n            $this->last_query_hash = Cache::getInstance()->getQueryHash($sql);\n            if (($result = Cache::getInstance()->get($this->last_query_hash)) !== false) {\n                Cache::getInstance()->incrementQueryCounter($sql);\n                $this->last_cached = true;\n\n                return $result;\n            }\n        }\n\n        $this->result = $this->query($sql);\n        if (!$this->result) {\n            $result = false;\n        } else {\n            $result = $this->nextRow($this->result);\n        }\n\n        $this->last_cached = false;\n\n        if (null === $result) {\n            $result = false;\n        }\n\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->setQuery($sql, $result);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns a value from the first row, first column of a SELECT query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return string|false|null Returns false if no results\n     */\n    public function getValue($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $result = $this->getRow($sql, $use_cache);\n        if (false === $result) {\n            return false;\n        }\n\n        return array_shift($result);\n    }\n\n    /**\n     * Get number of rows for last result.\n     *\n     * @return int\n     */\n    public function numRows()\n    {\n        if (!$this->last_cached && $this->result) {\n            $nrows = $this->_numRows($this->result);\n            if ($this->is_cache_enabled) {\n                Cache::getInstance()->set($this->last_query_hash . '_nrows', $nrows);\n            }\n\n            return $nrows;\n        } elseif ($this->is_cache_enabled && $this->last_cached) {\n            return Cache::getInstance()->get($this->last_query_hash . '_nrows');\n        }\n\n        return 0;\n    }\n\n    /**\n     * Executes a query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return bool|mysqli_result|PDOStatement|resource\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    protected function q($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = false;\n        $result = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        if (_PS_DEBUG_SQL_) {\n            $this->displayError($sql);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Displays last SQL error.\n     *\n     * @param string|bool $sql\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function displayError($sql = false)\n    {\n        global $webservice_call;\n\n        $errno = $this->getNumberError();\n        if ($webservice_call && $errno) {\n            $dbg = debug_backtrace();\n            WebserviceRequest::getInstance()->setError(500, '[SQL Error] ' . $this->getMsgError() . '. From ' . (isset($dbg[3]['class']) ? $dbg[3]['class'] : '') . '->' . $dbg[3]['function'] . '() Query was : ' . $sql, 97);\n        } elseif (_PS_DEBUG_SQL_ && $errno && !defined('PS_INSTALLATION_IN_PROGRESS')) {\n            if ($sql) {\n                throw new PrestaShopDatabaseException($this->getMsgError() . '<br /><br /><pre>' . $sql . '</pre>');\n            }\n\n            throw new PrestaShopDatabaseException($this->getMsgError());\n        }\n    }\n\n    /**\n     * Sanitize data which will be injected into SQL query.\n     *\n     * @param string $string SQL data which will be injected into SQL query\n     * @param bool $html_ok Does data contain HTML code ? (optional)\n     * @param bool $bq_sql Escape backticks\n     *\n     * @return string Sanitized data\n     */\n    public function escape($string, $html_ok = false, $bq_sql = false)\n    {\n        if (!is_numeric($string)) {\n            $string = $this->_escape($string);\n\n            if (!$html_ok) {\n                $string = strip_tags(Tools::nl2br($string));\n            }\n\n            if ($bq_sql === true) {\n                $string = str_replace('`', '\\`', $string);\n            }\n        }\n\n        return $string;\n    }\n\n    /**\n     * Try a connection to the database.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     * @param string $db Database name\n     * @param bool $new_db_link\n     * @param string|bool $engine\n     * @param int $timeout\n     *\n     * @return int Error code or 0 if connection was successful\n     */\n    public static function checkConnection($server, $user, $pwd, $db, $new_db_link = true, $engine = null, $timeout = 5)\n    {\n        return call_user_func_array([Db::getClass(), 'tryToConnect'], [$server, $user, $pwd, $db, $new_db_link, $engine, $timeout]);\n    }\n\n    /**\n     * Try a connection to the database and set names to UTF-8.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     *\n     * @return bool\n     */\n    public static function checkEncoding($server, $user, $pwd)\n    {\n        return call_user_func_array([Db::getClass(), 'tryUTF8'], [$server, $user, $pwd]);\n    }\n\n    /**\n     * Try a connection to the database and check if at least one table with same prefix exists.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     * @param string $db Database name\n     * @param string $prefix Tables prefix\n     *\n     * @return bool\n     */\n    public static function hasTableWithSamePrefix($server, $user, $pwd, $db, $prefix)\n    {\n        return call_user_func_array([Db::getClass(), 'hasTableWithSamePrefix'], [$server, $user, $pwd, $db, $prefix]);\n    }\n\n    /**\n     * Tries to connect to the database and create a table (checking creation privileges).\n     *\n     * @param string $server\n     * @param string $user\n     * @param string $pwd\n     * @param string $db\n     * @param string $prefix\n     * @param string|null $engine Table engine\n     *\n     * @return bool|string True, false or error\n     */\n    public static function checkCreatePrivilege($server, $user, $pwd, $db, $prefix, $engine = null)\n    {\n        return call_user_func_array([Db::getClass(), 'checkCreatePrivilege'], [$server, $user, $pwd, $db, $prefix, $engine]);\n    }\n\n    /**\n     * Tries to connect to the database and select content (checking select privileges).\n     *\n     * @param string $server\n     * @param string $user\n     * @param string $pwd\n     * @param string $db\n     * @param string $prefix\n     * @param string|null $engine Table engine\n     *\n     * @return bool|string True, false or error\n     */\n    public static function checkSelectPrivilege($server, $user, $pwd, $db, $prefix, $engine = null)\n    {\n        return call_user_func_array([Db::getClass(), 'checkSelectPrivilege'], [$server, $user, $pwd, $db, $prefix, $engine]);\n    }\n\n    /**\n     * Get used link instance.\n     *\n     * @return PDO|mysqli|resource Resource\n     */\n    public function getLink()\n    {\n        return $this->link;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * Copyright since 2007 PrestaShop SA and Contributors\n * PrestaShop is an International Registered Trademark & Property of PrestaShop SA\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.md.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://devdocs.prestashop.com/ for more information.\n *\n * @author    PrestaShop SA and Contributors <contact@prestashop.com>\n * @copyright Since 2007 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n */\n\n/**\n * Class RequestSqlCore.\n */\nclass RequestSqlCore extends ObjectModel\n{\n    public $name;\n    public $sql;\n\n    /**\n     * @see ObjectModel::$definition\n     */\n    public static $definition = [\n        'table' => 'request_sql',\n        'primary' => 'id_request_sql',\n        'fields' => [\n            'name' => ['type' => self::TYPE_STRING, 'validate' => 'isString', 'required' => true, 'size' => 200],\n            'sql' => ['type' => self::TYPE_SQL, 'validate' => 'isString', 'required' => true],\n        ],\n    ];\n\n    /** @var array : List of params to tested */\n    public $tested = [\n        'required' => ['SELECT', 'FROM'],\n        'option' => ['WHERE', 'ORDER', 'LIMIT', 'HAVING', 'GROUP', 'UNION'],\n        'operator' => [\n            'AND', '&&', 'BETWEEN', 'AND', 'BINARY', '&', '~', '|', '^', 'CASE', 'WHEN', 'END', 'DIV', '/', '<=>', '=', '>=',\n            '>', 'IS', 'NOT', 'NULL', '<<', '<=', '<', 'LIKE', '-', '%', '!=', '<>', 'REGEXP', '!', '||', 'OR', '+', '>>', 'RLIKE', 'SOUNDS', '*',\n            '-', 'XOR', 'IN',\n        ],\n        'function' => [\n            'AVG', 'SUM', 'COUNT', 'MIN', 'MAX', 'STDDEV', 'STDDEV_SAMP', 'STDDEV_POP', 'VARIANCE', 'VAR_SAMP', 'VAR_POP',\n            'GROUP_CONCAT', 'BIT_AND', 'BIT_OR', 'BIT_XOR',\n        ],\n        'unauthorized' => [\n            'DELETE', 'ALTER', 'INSERT', 'REPLACE', 'CREATE', 'TRUNCATE', 'OPTIMIZE', 'GRANT', 'REVOKE', 'SHOW', 'HANDLER',\n            'LOAD', 'LOAD_FILE', 'ROLLBACK', 'SAVEPOINT', 'UNLOCK', 'INSTALL', 'UNINSTALL', 'ANALZYE', 'BACKUP', 'CHECK', 'CHECKSUM', 'REPAIR', 'RESTORE', 'CACHE',\n            'DESCRIBE', 'EXPLAIN', 'USE', 'HELP', 'SET', 'DUPLICATE', 'VALUES',  'INTO', 'RENAME', 'CALL', 'PROCEDURE',  'FUNCTION', 'DATABASE', 'SERVER',\n            'LOGFILE', 'DEFINER', 'RETURNS', 'EVENT', 'TABLESPACE', 'VIEW', 'TRIGGER', 'DATA', 'DO', 'PASSWORD', 'USER', 'PLUGIN', 'FLUSH', 'KILL',\n            'RESET', 'START', 'STOP', 'PURGE', 'EXECUTE', 'PREPARE', 'DEALLOCATE', 'LOCK', 'USING', 'DROP', 'FOR', 'UPDATE', 'BEGIN', 'BY', 'ALL', 'SHARE',\n            'MODE', 'TO', 'KEY', 'DISTINCTROW', 'DISTINCT',  'HIGH_PRIORITY', 'LOW_PRIORITY', 'DELAYED', 'IGNORE', 'FORCE', 'STRAIGHT_JOIN',\n            'SQL_SMALL_RESULT', 'SQL_BIG_RESULT', 'QUICK', 'SQL_BUFFER_RESULT', 'SQL_CACHE', 'SQL_NO_CACHE', 'SQL_CALC_FOUND_ROWS', 'WITH',\n            'OUTFILE', 'DUMPFILE',\n        ],\n    ];\n\n    public $attributes = [\n        'passwd' => '*******************',\n        'secure_key' => '*******************',\n    ];\n\n    /** @var array : list of errors */\n    public $error_sql = [];\n\n    /**\n     * Get list of request SQL.\n     *\n     * @return array|bool\n     */\n    public static function getRequestSql()\n    {\n        if (!$result = Db::getInstance(_PS_USE_SQL_SLAVE_)->executeS('SELECT * FROM `' . _DB_PREFIX_ . 'request_sql` ORDER BY `id_request_sql`')) {\n            return false;\n        }\n\n        $requestSql = [];\n        foreach ($result as $row) {\n            $requestSql[] = $row['sql'];\n        }\n\n        return $requestSql;\n    }\n\n    /**\n     * Get list of request SQL by id request.\n     *\n     * @param int $id\n     *\n     * @return array\n     */\n    public static function getRequestSqlById($id)\n    {\n        return Db::getInstance()->executeS('SELECT `sql` FROM `' . _DB_PREFIX_ . 'request_sql` WHERE `id_request_sql` = ' . (int) $id);\n    }\n\n    /**\n     * Call the parserSQL() method in Tools class\n     * Cut the request in table for check it.\n     *\n     * @param string $sql\n     *\n     * @return array|bool\n     */\n    public function parsingSql($sql)\n    {\n        return Tools::parserSQL($sql);\n    }\n\n    /**\n     * Check if the parsing of the SQL request is good or not.\n     *\n     * @param array $tab\n     * @param bool $in\n     * @param string $sql\n     *\n     * @return bool\n     */\n    public function validateParser($tab, $in, $sql)\n    {\n        if (!$tab) {\n            return false;\n        } elseif (isset($tab['UNION'])) {\n            $union = $tab['UNION'];\n            foreach ($union as $tab) {\n                if (!$this->validateSql($tab, $in, $sql)) {\n                    return false;\n                }\n            }\n\n            return true;\n        } else {\n            return $this->validateSql($tab, $in, $sql);\n        }\n    }\n\n    /**\n     * Cut the request for check each cutting.\n     *\n     * @param array<string, array> $tab\n     * @param bool $in\n     * @param string $sql\n     *\n     * @return bool\n     */\n    public function validateSql($tab, $in, $sql)\n    {\n        if (!$this->testedRequired($tab)) {\n            return false;\n        } elseif (!$this->testedUnauthorized($tab)) {\n            return false;\n        } elseif (!$this->checkedFrom($tab['FROM'])) {\n            return false;\n        } elseif (!$this->checkedSelect($tab['SELECT'], $tab['FROM'], $in)) {\n            return false;\n        } elseif (isset($tab['WHERE'])) {\n            if (!$this->checkedWhere($tab['WHERE'], $tab['FROM'], $sql)) {\n                return false;\n            }\n        } elseif (isset($tab['HAVING'])) {\n            if (!$this->checkedHaving($tab['HAVING'], $tab['FROM'])) {\n                return false;\n            }\n        } elseif (isset($tab['ORDER'])) {\n            if (!$this->checkedOrder($tab['ORDER'], $tab['FROM'])) {\n                return false;\n            }\n        } elseif (isset($tab['GROUP'])) {\n            if (!$this->checkedGroupBy($tab['GROUP'], $tab['FROM'])) {\n                return false;\n            }\n        } elseif (isset($tab['LIMIT'])) {\n            if (!$this->checkedLimit($tab['LIMIT'])) {\n                return false;\n            }\n        }\n\n        if (empty($this->_errors) && !Db::getInstance()->executeS($sql)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get list of all tables.\n     *\n     * @return array\n     */\n    public function getTables()\n    {\n        $results = Db::getInstance()->executeS('SHOW TABLES');\n        $tables = [];\n        foreach ($results as $result) {\n            $key = array_keys($result);\n            $tables[] = $result[$key[0]];\n        }\n\n        return $tables;\n    }\n\n    /**\n     * Get list of all attributes by an table.\n     *\n     * @param string $table\n     *\n     * @return array\n     */\n    public function getAttributesByTable($table)\n    {\n        return Db::getInstance()->executeS('DESCRIBE ' . pSQL($table));\n    }\n\n    /**\n     * Cut an join sentence.\n     *\n     * @param array $attrs\n     * @param array $from\n     *\n     * @return array\n     */\n    public function cutJoin($attrs, $from)\n    {\n        $tab = [];\n\n        foreach ($attrs as $attr) {\n            if (in_array($attr['expr_type'], ['operator', 'const'])) {\n                continue;\n            }\n\n            if (!empty($attr['sub_tree'])) {\n                foreach ($attr['sub_tree'] as $treeItem) {\n                    if ($treeItem['expr_type'] !== 'colref') {\n                        continue;\n                    }\n                    if ($attribut = $this->cutAttribute($treeItem['base_expr'], $from)) {\n                        $tab[] = $attribut;\n                    }\n                }\n            } else {\n                if ($attribut = $this->cutAttribute($attr['base_expr'], $from)) {\n                    $tab[] = $attribut;\n                }\n            }\n        }\n\n        return $tab;\n    }\n\n    /**\n     * Cut an attribute with or without the alias.\n     *\n     * @param string $attr\n     * @param array $from\n     *\n     * @return array|bool\n     */\n    public function cutAttribute($attr, $from)\n    {\n        $matches = [];\n        if (preg_match('/((`(\\()?([a-z0-9_])+`(\\))?)|((\\()?([a-z0-9_])+(\\))?))\\.((`(\\()?([a-z0-9_])+`(\\))?)|((\\()?([a-z0-9_])+(\\))?))$/i', $attr, $matches, PREG_OFFSET_CAPTURE)) {\n            $tab = explode('.', str_replace(['`', '(', ')'], '', $matches[0][0]));\n            if ($table = $this->returnNameTable($tab[0], $from)) {\n                return [\n                    'table' => $table,\n                    'alias' => $tab[0],\n                    'attribut' => $tab[1],\n                    'string' => $attr,\n                ];\n            }\n        } elseif (preg_match('/((`(\\()?([a-z0-9_])+`(\\))?)|((\\()?([a-z0-9_])+(\\))?))$/i', $attr, $matches, PREG_OFFSET_CAPTURE)) {\n            $attribut = str_replace(['`', '(', ')'], '', $matches[0][0]);\n            if ($table = $this->returnNameTable(false, $from, $attr)) {\n                return [\n                    'table' => $table,\n                    'attribut' => $attribut,\n                    'string' => $attr,\n                ];\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Get name of table by alias.\n     *\n     * @param string|false $alias\n     * @param array $tables\n     *\n     * @return array|bool\n     */\n    public function returnNameTable($alias, $tables, $attr = null)\n    {\n        if ($alias) {\n            foreach ($tables as $table) {\n                if (!isset($table['alias']) || !isset($table['table'])) {\n                    continue;\n                }\n                /** @var string|array{'parts': array<int, bool>} $tableAlias */\n                $tableAlias = $table['alias']['no_quotes'];\n                if ($tableAlias == $alias || $tableAlias['parts'][0] == $alias) {\n                    return [$table['table']];\n                }\n            }\n        } elseif (count($tables) > 1) {\n            if ($attr !== null) {\n                $tab = [];\n                foreach ($tables as $table) {\n                    if ($this->attributExistInTable($attr, $table['table'])) {\n                        $tab = $table['table'];\n                    }\n                }\n                if (count($tab) == 1) {\n                    return $tab;\n                }\n            }\n\n            $this->error_sql['returnNameTable'] = false;\n\n            return false;\n        }\n\n        $tab = [];\n        foreach ($tables as $table) {\n            $tab[] = $table['table'];\n        }\n\n        return $tab;\n    }\n\n    /**\n     * Check if an attributes exists in a table.\n     *\n     * @param string $attr\n     * @param array $table\n     *\n     * @return bool\n     */\n    public function attributExistInTable($attr, $table)\n    {\n        if (!$attr) {\n            return true;\n        }\n        if (is_array($table) && (count($table) == 1)) {\n            $table = $table[0];\n        }\n        $attributs = $this->getAttributesByTable($table);\n        foreach ($attributs as $attribut) {\n            if ($attribut['Field'] == trim($attr, ' `')) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if all required sentence existing.\n     *\n     * @param array $tab\n     *\n     * @return bool\n     */\n    public function testedRequired($tab)\n    {\n        foreach ($this->tested['required'] as $key) {\n            if (!array_key_exists($key, $tab)) {\n                $this->error_sql['testedRequired'] = $key;\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check if an unauthorized existing in an array.\n     *\n     * @param array $tab\n     *\n     * @return bool\n     */\n    public function testedUnauthorized($tab)\n    {\n        foreach ($this->tested['unauthorized'] as $key) {\n            if (array_key_exists($key, $tab)) {\n                $this->error_sql['testedUnauthorized'] = $key;\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"FROM\" sentence.\n     *\n     * @param array<int, array<string, mixed>> $from\n     *\n     * @return bool\n     */\n    public function checkedFrom($from)\n    {\n        $nb = count($from);\n        for ($i = 0; $i < $nb; ++$i) {\n            $table = $from[$i];\n\n            if (isset($table['table']) && !in_array(str_replace('`', '', $table['table']), $this->getTables())) {\n                $this->error_sql['checkedFrom']['table'] = $table['table'];\n\n                return false;\n            }\n            if ($table['ref_type'] == 'ON' && (trim($table['join_type']) == 'LEFT' || trim($table['join_type']) == 'JOIN')) {\n                $attrs = $this->cutJoin($table['ref_clause'], $from);\n                foreach ($attrs as $attr) {\n                    if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                        $this->error_sql['checkedFrom']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"SELECT\" sentence.\n     *\n     * @param array<int, array<string, mixed>> $select\n     * @param array $from\n     * @param bool $in\n     *\n     * @return bool\n     */\n    public function checkedSelect($select, $from, $in = false)\n    {\n        $nb = count($select);\n        for ($i = 0; $i < $nb; ++$i) {\n            $attribut = $select[$i];\n            if ($attribut['base_expr'] != '*' && !preg_match('/\\.\\*$/', $attribut['base_expr'])) {\n                if ($attribut['expr_type'] == 'colref') {\n                    if ($attr = $this->cutAttribute(trim($attribut['base_expr']), $from)) {\n                        if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                            $this->error_sql['checkedSelect']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                            return false;\n                        }\n                    } else {\n                        if (isset($this->error_sql['returnNameTable'])) {\n                            $this->error_sql['checkedSelect'] = $this->error_sql['returnNameTable'];\n\n                            return false;\n                        } else {\n                            $this->error_sql['checkedSelect'] = false;\n\n                            return false;\n                        }\n                    }\n                }\n\n                while (is_array($attribut['sub_tree'])) {\n                    if ($attribut['expr_type'] === 'function' && in_array(strtoupper($attribut['base_expr']), $this->tested['unauthorized'])) {\n                        $this->error_sql['checkedSelect']['function'] = $attribut['base_expr'];\n\n                        return false;\n                    }\n                    $attribut = $attribut['sub_tree'][0];\n                }\n            } elseif ($in) {\n                $this->error_sql['checkedSelect']['*'] = false;\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"WHERE\" sentence.\n     *\n     * @param array<int, array<string, mixed>> $where\n     * @param array $from\n     * @param string $sql\n     *\n     * @return bool\n     */\n    public function checkedWhere($where, $from, $sql)\n    {\n        $nb = count($where);\n        for ($i = 0; $i < $nb; ++$i) {\n            $attribut = $where[$i];\n            if ($attribut['expr_type'] == 'colref') {\n                if ($attr = $this->cutAttribute(trim($attribut['base_expr']), $from)) {\n                    if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                        $this->error_sql['checkedWhere']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                        return false;\n                    }\n                } else {\n                    $this->error_sql['checkedWhere'] = $this->error_sql['returnNameTable'] ?? false;\n\n                    return false;\n                }\n            } elseif ($attribut['expr_type'] == 'reserved') {\n                if ($attribut['base_expr'] !== 'EXISTS' || !isset($where[$i + 1]) || $where[$i + 1]['expr_type'] !== 'subquery') {\n                    $this->error_sql['checkedWhere'] = $this->error_sql['returnNameTable'] ?? false;\n\n                    return false;\n                }\n            } elseif ($attribut['expr_type'] == 'operator') {\n                if (!in_array(strtoupper($attribut['base_expr']), $this->tested['operator'])) {\n                    $this->error_sql['checkedWhere']['operator'] = [$attribut['base_expr']];\n\n                    return false;\n                }\n            } elseif ($attribut['expr_type'] == 'subquery') {\n                $tab = $attribut['sub_tree'];\n\n                return $this->validateParser($tab, true, $sql);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"HAVING\" sentence.\n     *\n     * @param array<int, array<string, mixed>> $having\n     * @param array $from\n     *\n     * @return bool\n     */\n    public function checkedHaving($having, $from)\n    {\n        $nb = count($having);\n        for ($i = 0; $i < $nb; ++$i) {\n            $attribut = $having[$i];\n            if ($attribut['expr_type'] == 'colref') {\n                if ($attr = $this->cutAttribute(trim($attribut['base_expr']), $from)) {\n                    if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                        $this->error_sql['checkedHaving']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                        return false;\n                    }\n                } else {\n                    if (isset($this->error_sql['returnNameTable'])) {\n                        $this->error_sql['checkedHaving'] = $this->error_sql['returnNameTable'];\n\n                        return false;\n                    } else {\n                        $this->error_sql['checkedHaving'] = false;\n\n                        return false;\n                    }\n                }\n            }\n\n            if ($attribut['expr_type'] == 'operator') {\n                if (!in_array(strtoupper($attribut['base_expr']), $this->tested['operator'])) {\n                    $this->error_sql['checkedHaving']['operator'] = [$attribut['base_expr']];\n\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"ORDER\" sentence.\n     *\n     * @param array $order\n     * @param array $from\n     *\n     * @return bool\n     */\n    public function checkedOrder($order, $from)\n    {\n        $order = $order[0];\n        if (array_key_exists('expression', $order) && $order['type'] == 'expression') {\n            if ($attr = $this->cutAttribute(trim($order['base_expr']), $from)) {\n                if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                    $this->error_sql['checkedOrder']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                    return false;\n                }\n            } else {\n                if (isset($this->error_sql['returnNameTable'])) {\n                    $this->error_sql['checkedOrder'] = $this->error_sql['returnNameTable'];\n\n                    return false;\n                } else {\n                    $this->error_sql['checkedOrder'] = false;\n\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"GROUP BY\" sentence.\n     *\n     * @param array $group\n     * @param array $from\n     *\n     * @return bool\n     */\n    public function checkedGroupBy($group, $from)\n    {\n        $group = $group[0];\n        if ($group['expr_type'] == 'colref') {\n            if ($attr = $this->cutAttribute(trim($group['base_expr']), $from)) {\n                if (!$this->attributExistInTable($attr['attribut'], $attr['table'])) {\n                    $this->error_sql['checkedGroupBy']['attribut'] = [$attr['attribut'], implode(', ', $attr['table'])];\n\n                    return false;\n                }\n            } else {\n                if (isset($this->error_sql['returnNameTable'])) {\n                    $this->error_sql['checkedGroupBy'] = $this->error_sql['returnNameTable'];\n\n                    return false;\n                } else {\n                    $this->error_sql['checkedGroupBy'] = false;\n\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Check a \"LIMIT\" sentence.\n     *\n     * @param array $limit\n     *\n     * @return bool\n     */\n    public function checkedLimit($limit)\n    {\n        if (!preg_match('#^[0-9]+$#', trim($limit['offset'])) || !preg_match('#^[0-9]+$#', trim($limit['rowcount']))) {\n            $this->error_sql['checkedLimit'] = false;\n\n            return false;\n        }\n\n        return true;\n    }\n}\n", "<?php\n/**\n * Copyright since 2007 PrestaShop SA and Contributors\n * PrestaShop is an International Registered Trademark & Property of PrestaShop SA\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.md.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://devdocs.prestashop.com/ for more information.\n *\n * @author    PrestaShop SA and Contributors <contact@prestashop.com>\n * @copyright Since 2007 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n */\n/**\n * Class DbCore.\n */\nabstract class DbCore\n{\n    /** @var int Constant used by insert() method */\n    public const INSERT = 1;\n\n    /** @var int Constant used by insert() method */\n    public const INSERT_IGNORE = 2;\n\n    /** @var int Constant used by insert() method */\n    public const REPLACE = 3;\n\n    /** @var int Constant used by insert() method */\n    public const ON_DUPLICATE_KEY = 4;\n\n    /** @var string Server (eg. localhost) */\n    protected $server;\n\n    /** @var string Database user (eg. root) */\n    protected $user;\n\n    /** @var string Database password (eg. can be empty !) */\n    protected $password;\n\n    /** @var string Database name */\n    protected $database;\n\n    /** @var bool */\n    protected $is_cache_enabled;\n\n    /** @var PDO|mysqli|resource|null Resource link */\n    protected $link;\n\n    /** @var PDOStatement|mysqli_result|resource|bool SQL cached result */\n    protected $result;\n\n    /** @var array List of DB instances */\n    public static $instance = [];\n\n    /** @var array List of server settings */\n    public static $_servers = [];\n\n    /** @var bool|null Flag used to load slave servers only once.\n     * See loadSlaveServers() method\n     */\n    public static $_slave_servers_loaded = null;\n\n    /**\n     * Store last executed query.\n     *\n     * @var string\n     */\n    protected $last_query;\n\n    /**\n     * Store hash of the last executed query.\n     *\n     * @var string\n     */\n    protected $last_query_hash;\n\n    /**\n     * Last cached query.\n     *\n     * @var bool\n     */\n    protected $last_cached;\n\n    /**\n     * Opens a database connection.\n     *\n     * @return PDO|mysqli|resource\n     */\n    abstract public function connect();\n\n    /**\n     * Closes database connection.\n     */\n    abstract public function disconnect();\n\n    /**\n     * Execute a query and get result resource.\n     *\n     * @param string $sql\n     *\n     * @return PDOStatement|mysqli_result|resource|bool\n     */\n    abstract protected function _query($sql);\n\n    /**\n     * Get number of rows in a result.\n     *\n     * @param mixed $result\n     *\n     * @return int\n     */\n    abstract protected function _numRows($result);\n\n    /**\n     * Get the ID generated from the previous INSERT operation.\n     *\n     * @return int|string\n     */\n    abstract public function Insert_ID();\n\n    /**\n     * Get number of affected rows in previous database operation.\n     *\n     * @return int\n     */\n    abstract public function Affected_Rows();\n\n    /**\n     * Get next row for a query which does not return an array.\n     *\n     * @param PDOStatement|mysqli_result|resource|bool $result\n     *\n     * @return array|object|false|null\n     */\n    abstract public function nextRow($result = false);\n\n    /**\n     * Get all rows for a query which return an array.\n     *\n     * @param PDOStatement|mysqli_result|resource|bool|null $result\n     *\n     * @return array\n     */\n    abstract protected function getAll($result = false);\n\n    /**\n     * Get database version.\n     *\n     * @return string\n     */\n    abstract public function getVersion();\n\n    /**\n     * Protect string against SQL injections.\n     *\n     * @param string $str\n     *\n     * @return string\n     */\n    abstract public function _escape($str);\n\n    /**\n     * Returns the text of the error message from previous database operation.\n     *\n     * @return string\n     */\n    abstract public function getMsgError();\n\n    /**\n     * Returns the number of the error from previous database operation.\n     *\n     * @return int\n     */\n    abstract public function getNumberError();\n\n    /**\n     * Sets the current active database on the server that's associated with the specified link identifier.\n     * Do not remove, useful for some modules.\n     *\n     * @param string $db_name\n     *\n     * @return bool|int\n     */\n    abstract public function set_db($db_name);\n\n    /**\n     * Selects best table engine.\n     *\n     * @return string\n     */\n    abstract public function getBestEngine();\n\n    /**\n     * Returns database object instance.\n     *\n     * @param bool $master Decides whether the connection to be returned by the master server or the slave server\n     *\n     * @return Db Singleton instance of Db object\n     */\n    public static function getInstance($master = true)\n    {\n        static $id = 0;\n\n        // This MUST not be declared with the class members because some defines (like _DB_SERVER_) may not exist yet (the constructor can be called directly with params)\n        if (!self::$_servers) {\n            self::$_servers = [\n                ['server' => _DB_SERVER_, 'user' => _DB_USER_, 'password' => _DB_PASSWD_, 'database' => _DB_NAME_], /* MySQL Master server */\n            ];\n        }\n\n        if (!$master) {\n            Db::loadSlaveServers();\n        }\n\n        $total_servers = count(self::$_servers);\n        if ($master || $total_servers == 1) {\n            $id_server = 0;\n        } else {\n            ++$id;\n            $id_server = ($total_servers > 2 && ($id % $total_servers) != 0) ? $id % $total_servers : 1;\n        }\n\n        if (!isset(self::$instance[$id_server])) {\n            $class = Db::getClass();\n            self::$instance[$id_server] = new $class(\n                self::$_servers[$id_server]['server'],\n                self::$_servers[$id_server]['user'],\n                self::$_servers[$id_server]['password'],\n                self::$_servers[$id_server]['database']\n            );\n        }\n\n        return self::$instance[$id_server];\n    }\n\n    public function getPrefix()\n    {\n        return _DB_PREFIX_;\n    }\n\n    /**\n     * @param Db $test_db\n     *                    Unit testing purpose only\n     */\n    public static function setInstanceForTesting($test_db)\n    {\n        self::$instance[0] = $test_db;\n    }\n\n    /**\n     * Unit testing purpose only.\n     */\n    public static function deleteTestingInstance()\n    {\n        self::$instance = [];\n    }\n\n    /**\n     * Loads configuration settings for slave servers if needed.\n     */\n    protected static function loadSlaveServers()\n    {\n        if (self::$_slave_servers_loaded !== null) {\n            return;\n        }\n\n        // Add here your slave(s) server(s) in this file\n        if (file_exists(_PS_ROOT_DIR_ . '/config/db_slave_server.inc.php')) {\n            self::$_servers = array_merge(self::$_servers, require(_PS_ROOT_DIR_ . '/config/db_slave_server.inc.php'));\n        }\n\n        self::$_slave_servers_loaded = true;\n    }\n\n    /**\n     * Returns the best child layer database class.\n     *\n     * @return string\n     */\n    public static function getClass()\n    {\n        $class = '';\n        /* @phpstan-ignore-next-line */\n        if (PHP_VERSION_ID >= 50200 && extension_loaded('pdo_mysql')) {\n            $class = 'DbPDO';\n        } elseif (extension_loaded('mysqli')) {\n            $class = 'DbMySQLi';\n        }\n\n        if (empty($class)) {\n            throw new PrestaShopException('Cannot select any valid SQL engine.');\n        }\n\n        return $class;\n    }\n\n    /**\n     * Instantiates a database connection.\n     *\n     * @param string $server Server address\n     * @param string $user User login\n     * @param string $password User password\n     * @param string $database Database name\n     * @param bool $connect If false, don't connect in constructor (since 1.5.0.1)\n     */\n    public function __construct($server, $user, $password, $database, $connect = true)\n    {\n        $this->server = $server;\n        $this->user = $user;\n        $this->password = $password;\n        $this->database = $database;\n        $this->is_cache_enabled = (defined('_PS_CACHE_ENABLED_')) ? _PS_CACHE_ENABLED_ : false;\n\n        if (!defined('_PS_DEBUG_SQL_')) {\n            define('_PS_DEBUG_SQL_', false);\n        }\n\n        if ($connect) {\n            $this->connect();\n        }\n    }\n\n    /**\n     * Disable the use of the cache.\n     */\n    public function disableCache()\n    {\n        $this->is_cache_enabled = false;\n    }\n\n    /**\n     * Enable & flush the cache.\n     */\n    public function enableCache()\n    {\n        $this->is_cache_enabled = true;\n        Cache::getInstance()->flush();\n    }\n\n    /**\n     * Closes connection to database.\n     */\n    public function __destruct()\n    {\n        if ($this->link) {\n            $this->disconnect();\n        }\n    }\n\n    /**\n     * Execute a query and get result resource.\n     *\n     * @param string|DbQuery $sql\n     *\n     * @return bool|mysqli_result|PDOStatement|resource\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function query($sql)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = $this->_query($sql);\n\n        if (!$this->result && $this->getNumberError() == 2006) {\n            $this->connect();\n            $this->result = $this->_query($sql);\n        }\n\n        if (_PS_DEBUG_SQL_) {\n            $this->displayError($sql);\n        }\n\n        return $this->result;\n    }\n\n    /**\n     * Executes an INSERT query.\n     *\n     * @param string $table Table name without prefix\n     * @param array $data Data to insert as associative array. If $data is a list of arrays, multiple insert will be done\n     * @param bool $null_values If we want to use NULL values instead of empty quotes\n     * @param bool $use_cache\n     * @param int $type Must be Db::INSERT or Db::INSERT_IGNORE or Db::REPLACE\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function insert($table, $data, $null_values = false, $use_cache = true, $type = Db::INSERT, $add_prefix = true)\n    {\n        if (!$data && !$null_values) {\n            return true;\n        }\n\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        if ($type == Db::INSERT) {\n            $insert_keyword = 'INSERT';\n        } elseif ($type == Db::INSERT_IGNORE) {\n            $insert_keyword = 'INSERT IGNORE';\n        } elseif ($type == Db::REPLACE) {\n            $insert_keyword = 'REPLACE';\n        } elseif ($type == Db::ON_DUPLICATE_KEY) {\n            $insert_keyword = 'INSERT';\n        } else {\n            throw new PrestaShopDatabaseException('Bad keyword, must be Db::INSERT or Db::INSERT_IGNORE or Db::REPLACE or Db::ON_DUPLICATE_KEY');\n        }\n\n        // Check if $data is a list of row\n        $current = current($data);\n        if (!is_array($current) || isset($current['type'])) {\n            $data = [$data];\n        }\n\n        $keys = [];\n        $values_stringified = [];\n        $first_loop = true;\n        $duplicate_key_stringified = '';\n\n        foreach ($data as $row_data) {\n            $values = [];\n            foreach ($row_data as $key => $value) {\n                if (!$first_loop) {\n                    // Check if row array mapping are the same\n                    if (!in_array(\"`$key`\", $keys)) {\n                        throw new PrestaShopDatabaseException('Keys form $data subarray don\\'t match');\n                    }\n\n                    if ($duplicate_key_stringified != '') {\n                        throw new PrestaShopDatabaseException('On duplicate key cannot be used on insert with more than 1 VALUE group');\n                    }\n                } else {\n                    $keys[] = '`' . bqSQL($key) . '`';\n                }\n\n                if (!is_array($value)) {\n                    $value = ['type' => 'text', 'value' => $value];\n                }\n                if ($value['type'] == 'sql') {\n                    $values[] = $string_value = $value['value'];\n                } else {\n                    $values[] = $string_value = $null_values && ($value['value'] === '' || null === $value['value']) ? 'NULL' : \"'{$value['value']}'\";\n                }\n\n                if ($type == Db::ON_DUPLICATE_KEY) {\n                    $duplicate_key_stringified .= '`' . bqSQL($key) . '` = ' . $string_value . ',';\n                }\n            }\n            $first_loop = false;\n            $values_stringified[] = '(' . implode(', ', $values) . ')';\n        }\n        $keys_stringified = implode(', ', $keys);\n\n        $sql = $insert_keyword . ' INTO `' . $table . '` (' . $keys_stringified . ') VALUES ' . implode(', ', $values_stringified);\n        if ($type == Db::ON_DUPLICATE_KEY) {\n            $sql .= ' ON DUPLICATE KEY UPDATE ' . substr($duplicate_key_stringified, 0, -1);\n        }\n\n        return (bool) $this->q($sql, $use_cache);\n    }\n\n    /**\n     * Executes an UPDATE query.\n     *\n     * @param string $table Table name without prefix\n     * @param array $data Data to insert as associative array. If $data is a list of arrays, multiple insert will be done\n     * @param string $where WHERE condition\n     * @param int $limit\n     * @param bool $null_values If we want to use NULL values instead of empty quotes\n     * @param bool $use_cache\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     */\n    public function update($table, $data, $where = '', $limit = 0, $null_values = false, $use_cache = true, $add_prefix = true)\n    {\n        if (!$data) {\n            return true;\n        }\n\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        $sql = 'UPDATE `' . bqSQL($table) . '` SET ';\n        foreach ($data as $key => $value) {\n            if (!is_array($value)) {\n                $value = ['type' => 'text', 'value' => $value];\n            }\n            if ($value['type'] == 'sql') {\n                $sql .= '`' . bqSQL($key) . \"` = {$value['value']},\";\n            } else {\n                $sql .= ($null_values && ($value['value'] === '' || null === $value['value'])) ? '`' . bqSQL($key) . '` = NULL,' : '`' . bqSQL($key) . \"` = '{$value['value']}',\";\n            }\n        }\n\n        $sql = rtrim($sql, ',');\n        if ($where) {\n            $sql .= ' WHERE ' . $where;\n        }\n        if ($limit) {\n            $sql .= ' LIMIT ' . (int) $limit;\n        }\n\n        return (bool) $this->q($sql, $use_cache);\n    }\n\n    /**\n     * Executes a DELETE query.\n     *\n     * @param string $table Name of the table to delete\n     * @param string $where WHERE clause on query\n     * @param int $limit Number max of rows to delete\n     * @param bool $use_cache Use cache or not\n     * @param bool $add_prefix Add or not _DB_PREFIX_ before table name\n     *\n     * @return bool\n     */\n    public function delete($table, $where = '', $limit = 0, $use_cache = true, $add_prefix = true)\n    {\n        if ($add_prefix) {\n            $table = _DB_PREFIX_ . $table;\n        }\n\n        $this->result = false;\n        $sql = 'DELETE FROM `' . bqSQL($table) . '`' . ($where ? ' WHERE ' . $where : '') . ($limit ? ' LIMIT ' . (int) $limit : '');\n        $res = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        return (bool) $res;\n    }\n\n    /**\n     * Executes a query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return bool\n     */\n    public function execute($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        return (bool) $this->result;\n    }\n\n    /**\n     * Executes return the result of $sql as array.\n     *\n     * @param string|DbQuery $sql Query to execute\n     * @param bool $array Return an array instead of a result object (deprecated since 1.5.0.1, use query method instead)\n     * @param bool $use_cache\n     *\n     * @return array|bool|mysqli_result|PDOStatement|resource|null\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function executeS($sql, $array = true, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = false;\n        $this->last_query = $sql;\n\n        if ($use_cache && $this->is_cache_enabled && $array) {\n            $this->last_query_hash = Cache::getInstance()->getQueryHash($sql);\n            if (($result = Cache::getInstance()->get($this->last_query_hash)) !== false) {\n                Cache::getInstance()->incrementQueryCounter($sql);\n                $this->last_cached = true;\n\n                return $result;\n            }\n        }\n\n        // This method must be used only with queries which display results\n        if (\n            !preg_match('#^\\s*\\(?\\s*(select|show|explain|describe|desc|checksum)\\s#i', $sql)\n            || stripos($sql, 'outfile') !== false\n            || stripos($sql, 'dumpfile') !== false\n        ) {\n            throw new PrestaShopDatabaseException('Db->executeS() must be used only with select, show, explain or describe queries');\n        }\n\n        $this->result = $this->query($sql);\n\n        if (!$this->result) {\n            $result = false;\n        } else {\n            if (!$array) {\n                $use_cache = false;\n                $result = $this->result;\n            } else {\n                $result = $this->getAll($this->result);\n            }\n        }\n\n        $this->last_cached = false;\n        if ($use_cache && $this->is_cache_enabled && $array) {\n            Cache::getInstance()->setQuery($sql, $result);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns an associative array containing the first row of the query\n     * This function automatically adds \"LIMIT 1\" to the query.\n     *\n     * @param string|DbQuery $sql the select query (without \"LIMIT 1\")\n     * @param bool $use_cache Find it in cache first\n     *\n     * @return array|bool|object|null\n     */\n    public function getRow($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $sql = rtrim($sql, \" \\t\\n\\r\\0\\x0B;\") . ' LIMIT 1';\n        $this->result = false;\n        $this->last_query = $sql;\n\n        if ($use_cache && $this->is_cache_enabled) {\n            $this->last_query_hash = Cache::getInstance()->getQueryHash($sql);\n            if (($result = Cache::getInstance()->get($this->last_query_hash)) !== false) {\n                Cache::getInstance()->incrementQueryCounter($sql);\n                $this->last_cached = true;\n\n                return $result;\n            }\n        }\n\n        $this->result = $this->query($sql);\n        if (!$this->result) {\n            $result = false;\n        } else {\n            $result = $this->nextRow($this->result);\n        }\n\n        $this->last_cached = false;\n\n        if (null === $result) {\n            $result = false;\n        }\n\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->setQuery($sql, $result);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Returns a value from the first row, first column of a SELECT query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return string|false|null Returns false if no results\n     */\n    public function getValue($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $result = $this->getRow($sql, $use_cache);\n        if (false === $result) {\n            return false;\n        }\n\n        return array_shift($result);\n    }\n\n    /**\n     * Get number of rows for last result.\n     *\n     * @return int\n     */\n    public function numRows()\n    {\n        if (!$this->last_cached && $this->result) {\n            $nrows = $this->_numRows($this->result);\n            if ($this->is_cache_enabled) {\n                Cache::getInstance()->set($this->last_query_hash . '_nrows', $nrows);\n            }\n\n            return $nrows;\n        } elseif ($this->is_cache_enabled && $this->last_cached) {\n            return Cache::getInstance()->get($this->last_query_hash . '_nrows');\n        }\n\n        return 0;\n    }\n\n    /**\n     * Executes a query.\n     *\n     * @param string|DbQuery $sql\n     * @param bool $use_cache\n     *\n     * @return bool|mysqli_result|PDOStatement|resource\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    protected function q($sql, $use_cache = true)\n    {\n        if ($sql instanceof DbQuery) {\n            $sql = $sql->build();\n        }\n\n        $this->result = false;\n        $result = $this->query($sql);\n        if ($use_cache && $this->is_cache_enabled) {\n            Cache::getInstance()->deleteQuery($sql);\n        }\n\n        if (_PS_DEBUG_SQL_) {\n            $this->displayError($sql);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Displays last SQL error.\n     *\n     * @param string|bool $sql\n     *\n     * @throws PrestaShopDatabaseException\n     */\n    public function displayError($sql = false)\n    {\n        global $webservice_call;\n\n        $errno = $this->getNumberError();\n        if ($webservice_call && $errno) {\n            $dbg = debug_backtrace();\n            WebserviceRequest::getInstance()->setError(500, '[SQL Error] ' . $this->getMsgError() . '. From ' . (isset($dbg[3]['class']) ? $dbg[3]['class'] : '') . '->' . $dbg[3]['function'] . '() Query was : ' . $sql, 97);\n        } elseif (_PS_DEBUG_SQL_ && $errno && !defined('PS_INSTALLATION_IN_PROGRESS')) {\n            if ($sql) {\n                throw new PrestaShopDatabaseException($this->getMsgError() . '<br /><br /><pre>' . $sql . '</pre>');\n            }\n\n            throw new PrestaShopDatabaseException($this->getMsgError());\n        }\n    }\n\n    /**\n     * Sanitize data which will be injected into SQL query.\n     *\n     * @param string $string SQL data which will be injected into SQL query\n     * @param bool $html_ok Does data contain HTML code ? (optional)\n     * @param bool $bq_sql Escape backticks\n     *\n     * @return string Sanitized data\n     */\n    public function escape($string, $html_ok = false, $bq_sql = false)\n    {\n        if (!is_numeric($string)) {\n            $string = $this->_escape($string);\n\n            if (!$html_ok) {\n                $string = strip_tags(Tools::nl2br($string));\n            }\n\n            if ($bq_sql === true) {\n                $string = str_replace('`', '\\`', $string);\n            }\n        }\n\n        return $string;\n    }\n\n    /**\n     * Try a connection to the database.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     * @param string $db Database name\n     * @param bool $new_db_link\n     * @param string|bool $engine\n     * @param int $timeout\n     *\n     * @return int Error code or 0 if connection was successful\n     */\n    public static function checkConnection($server, $user, $pwd, $db, $new_db_link = true, $engine = null, $timeout = 5)\n    {\n        return call_user_func_array([Db::getClass(), 'tryToConnect'], [$server, $user, $pwd, $db, $new_db_link, $engine, $timeout]);\n    }\n\n    /**\n     * Try a connection to the database and set names to UTF-8.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     *\n     * @return bool\n     */\n    public static function checkEncoding($server, $user, $pwd)\n    {\n        return call_user_func_array([Db::getClass(), 'tryUTF8'], [$server, $user, $pwd]);\n    }\n\n    /**\n     * Try a connection to the database and check if at least one table with same prefix exists.\n     *\n     * @param string $server Server address\n     * @param string $user Login for database connection\n     * @param string $pwd Password for database connection\n     * @param string $db Database name\n     * @param string $prefix Tables prefix\n     *\n     * @return bool\n     */\n    public static function hasTableWithSamePrefix($server, $user, $pwd, $db, $prefix)\n    {\n        return call_user_func_array([Db::getClass(), 'hasTableWithSamePrefix'], [$server, $user, $pwd, $db, $prefix]);\n    }\n\n    /**\n     * Tries to connect to the database and create a table (checking creation privileges).\n     *\n     * @param string $server\n     * @param string $user\n     * @param string $pwd\n     * @param string $db\n     * @param string $prefix\n     * @param string|null $engine Table engine\n     *\n     * @return bool|string True, false or error\n     */\n    public static function checkCreatePrivilege($server, $user, $pwd, $db, $prefix, $engine = null)\n    {\n        return call_user_func_array([Db::getClass(), 'checkCreatePrivilege'], [$server, $user, $pwd, $db, $prefix, $engine]);\n    }\n\n    /**\n     * Tries to connect to the database and select content (checking select privileges).\n     *\n     * @param string $server\n     * @param string $user\n     * @param string $pwd\n     * @param string $db\n     * @param string $prefix\n     * @param string|null $engine Table engine\n     *\n     * @return bool|string True, false or error\n     */\n    public static function checkSelectPrivilege($server, $user, $pwd, $db, $prefix, $engine = null)\n    {\n        return call_user_func_array([Db::getClass(), 'checkSelectPrivilege'], [$server, $user, $pwd, $db, $prefix, $engine]);\n    }\n\n    /**\n     * Get used link instance.\n     *\n     * @return PDO|mysqli|resource Resource\n     */\n    public function getLink()\n    {\n        return $this->link;\n    }\n}\n"], "filenames": ["classes/RequestSql.php", "classes/db/Db.php"], "buggy_code_start_loc": [67, 606], "buggy_code_end_loc": [67, 607], "fixing_code_start_loc": [68, 606], "fixing_code_end_loc": [69, 611], "type": "CWE-89", "message": "PrestaShop is an open source e-commerce web application. Versions prior to 1.7.8.10, 8.0.5, and 8.1.1 are vulnerable to remote code execution through SQL injection and arbitrary file write in the back office. Versions 1.7.8.10, 8.0.5, and 8.1.1 contain a patch. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-39526", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-07T21:15:10.347", "lastModified": "2023-08-09T20:18:36.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PrestaShop is an open source e-commerce web application. Versions prior to 1.7.8.10, 8.0.5, and 8.1.1 are vulnerable to remote code execution through SQL injection and arbitrary file write in the back office. Versions 1.7.8.10, 8.0.5, and 8.1.1 contain a patch. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:prestashop:prestashop:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.8.10", "matchCriteriaId": "67B46788-7E3F-49C3-A69A-2F1922BCA5A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:prestashop:prestashop:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "8.0.5", "matchCriteriaId": "1E3B54B4-4484-44F8-A0F1-714EA40399CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:prestashop:prestashop:8.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "D34AD75A-BC2E-46F5-BFCD-671C06A23898"}]}]}], "references": [{"url": "https://github.com/PrestaShop/PrestaShop/commit/817847e2347844a9b6add017581f1932bcd28c09", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/PrestaShop/PrestaShop/security/advisories/GHSA-gf46-prm4-56pc", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/PrestaShop/PrestaShop/commit/817847e2347844a9b6add017581f1932bcd28c09"}}