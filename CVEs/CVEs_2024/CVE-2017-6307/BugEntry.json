{"buggy_code": ["/*\n * mapi_attr.c -- Functions for handling MAPI attributes\n *\n * Copyright (C)1999-2006 Mark Simpson <damned@theworld.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can either send email to this\n * program's maintainer or write to: The Free Software Foundation,\n * Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.\n *\n */\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include \"common.h\"\n\n#include \"mapi_attr.h\"\n#include \"alloc.h\"\n#include \"options.h\"\n#include \"util.h\"\n#include \"write.h\"\n\n/* return the length padded to a 4 byte boundary */\nstatic size_t\npad_to_4byte (size_t length)\n{\n    return (length+3) & ~3;\n}\n\n/* Copy the GUID data from a character buffer */\nstatic void\ncopy_guid_from_buf (GUID* guid, unsigned char *buf, size_t len)\n{\n    int i;\n    int idx = 0;\n    assert (guid);\n    assert (buf);\n\n    CHECKINT32(idx, len); guid->data1 = GETINT32(buf + idx); idx += sizeof (uint32);\n    CHECKINT16(idx, len); guid->data2 = GETINT16(buf + idx); idx += sizeof (uint16);\n    CHECKINT16(idx, len); guid->data3 = GETINT16(buf + idx); idx += sizeof (uint16);\n    for (i = 0; i < 8; i++, idx += sizeof (uint8))\n\tguid->data4[i] = (uint8)(buf[idx]);\n}\n\n\n/* dumps info about MAPI attributes... useful for debugging */\nstatic void\nmapi_attr_dump (MAPI_Attr* attr)\n{\n    char *name = get_mapi_name_str (attr->name);\n    char *type = get_mapi_type_str (attr->type);\n    size_t i;\n\n    fprintf (stdout, \"(MAPI) %s [type: %s] [num_values = %lu] = \\n\",\n\t     name, type, (unsigned long)attr->num_values);\n    if (attr->guid)\n    {\n\tfprintf (stdout, \"\\tGUID: \");\n\twrite_guid (stdout, attr->guid);\n\tfputc ('\\n', stdout);\n    }\n\t\n    for (i = 0; i < attr->num_names; i++)\n      fprintf (stdout, \"\\tname #%d: '%s'\\n\", (int)i, attr->names[i].data);\n\n    for (i = 0; i < attr->num_values; i++)\n    {\n\tfprintf (stdout, \"\\t#%lu [len: %lu] = \",\n\t\t (unsigned long)i,\n\t\t (unsigned long)attr->values[i].len);\n\n\tswitch (attr->type)\n\t{\n\tcase szMAPI_NULL:\n\t    fprintf (stdout, \"NULL\");\n\t    break;\n\n\tcase szMAPI_SHORT:\n\t    write_int16 (stdout, (int16)attr->values[i].data.bytes2);\n\t    break;\n\n\tcase szMAPI_INT:\n\t    write_int32 (stdout, (int32)attr->values[i].data.bytes4);\n\t    break;\n\n\tcase szMAPI_FLOAT:\n\tcase szMAPI_DOUBLE:\n\t    write_float (stdout, (float)attr->values[i].data.bytes4);\n\t    break;\n\n\tcase szMAPI_BOOLEAN:\n\t    write_boolean (stdout, attr->values[i].data.bytes4);\n\t    break;\n\n\tcase szMAPI_STRING:\n\tcase szMAPI_UNICODE_STRING:\n\t    write_string (stdout, (char*)attr->values[i].data.buf);\n\t    break;\n\n\tcase szMAPI_SYSTIME:\n\tcase szMAPI_CURRENCY:\n\tcase szMAPI_INT8BYTE:\n\tcase szMAPI_APPTIME:\n\t    write_uint64 (stdout, attr->values[i].data.bytes8);\n\t    break;\n\n\tcase szMAPI_ERROR:\n\t    write_uint32 (stdout, attr->values[i].data.bytes4);\n\t    break;\n\n\tcase szMAPI_CLSID:\n\t    write_guid (stdout, &attr->values[i].data.guid);\n\t    break;\n\n\tcase szMAPI_OBJECT:\n\tcase szMAPI_BINARY:\n\t{\n\t    size_t x;\n\n\t    for (x = 0; x < attr->values[i].len; x++)\n\t    {\n\t\twrite_byte (stdout, (uint8)attr->values[i].data.buf[x]);\n\t\tfputc (' ', stdout);\n\t    }\n\t}\n\tbreak;\n\n\tdefault:\n\t    fprintf (stdout, \"<unknown type>\");\n\t    break;\n\t}\n\tfprintf (stdout, \"\\n\");\n    }\n\n    fflush( NULL );\n}\n\nstatic MAPI_Value*\nalloc_mapi_values (MAPI_Attr* a)\n{\n    if (a && a->num_values)\n    {\n\ta->values = CHECKED_XCALLOC (MAPI_Value, a->num_values);\n\treturn a->values;\n    }\n    return NULL;\n}\n\n/*\n  2009/07/07\n  Microsoft documentation reference: [MS-OXPROPS] v 2.0, April 10, 2009\n\n  only multivalue types appearing are:\n  szMAPI_INT, szMAPI_SYSTIME, szMAPI_UNICODE_STRING, szMAPI_BINARY\n*/\n\n/* parses out the MAPI attibutes hidden in the character buffer */\nMAPI_Attr**\nmapi_attr_read (size_t len, unsigned char *buf)\n{\n    size_t idx = 0;\n    uint32 i,j;\n    assert(len > 4);\n    uint32 num_properties = GETINT32(buf+idx);\n    MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));\n\n    idx += 4;\n\n    if (!attrs) return NULL;\n    for (i = 0; i < num_properties; i++)\n    {\n\tMAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);\n\tMAPI_Value* v = NULL;\n\n\tCHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;\n\tCHECKINT16(idx, len); a->name = GETINT16(buf+idx); idx += 2;\n\n\t/* handle special case of GUID prefixed properties */\n\tif (a->name & GUID_EXISTS_FLAG)\n\t{\n\t    /* copy GUID */\n\t    a->guid = CHECKED_XMALLOC(GUID, 1);\n\t    copy_guid_from_buf(a->guid, buf+idx, len);\n\t    idx += sizeof (GUID);\n\n\t    CHECKINT32(idx, len); a->num_names = GETINT32(buf+idx); idx += 4;\n\t    if (a->num_names > 0)\n\t    {\n\t\t/* FIXME: do something useful here! */\n\t\tsize_t i;\n\n\t\ta->names = CHECKED_XCALLOC(VarLenData, a->num_names);\n\n\t\tfor (i = 0; i < a->num_names; i++)\n\t\t{\n\t\t    size_t j;\n\n\t\t    CHECKINT32(idx, len); a->names[i].len = GETINT32(buf+idx); idx += 4;\n\n\t\t    /* read the data into a buffer */\n\t\t    a->names[i].data \n\t\t\t= CHECKED_XMALLOC(unsigned char, a->names[i].len);\n\t\t    for (j = 0; j < (a->names[i].len >> 1); j++)\n\t\t\ta->names[i].data[j] = (buf+idx)[j*2];\n\n\t\t    /* But what are we going to do with it? */\n\t\t    \n\t\t    idx += pad_to_4byte(a->names[i].len);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/* get the 'real' name */\n\t\tCHECKINT32(idx, len); a->name = GETINT32(buf+idx); idx+= 4;\n\t    }\n\t}\n\n\t/* \n\t * Multi-value types and string/object/binary types have\n\t * multiple values \n\t */\n\tif (a->type & MULTI_VALUE_FLAG ||\n\t    a->type == szMAPI_STRING ||\n\t    a->type == szMAPI_UNICODE_STRING ||\n\t    a->type == szMAPI_OBJECT ||\n\t    a->type == szMAPI_BINARY)\n\t{\n\t    CHECKINT32(idx, len); a->num_values = GETINT32(buf+idx);\n\t    idx += 4;\n\t}\n        else\n        {\n\t    a->num_values = 1;\n        }\n\n\t/* Amend the type in case of multi-value type */\n\tif (a->type & MULTI_VALUE_FLAG)\n\t{\n\t    a->type -= MULTI_VALUE_FLAG;\n\t}\n\n\n\tv = alloc_mapi_values (a);\n\n\tfor (j = 0; j < a->num_values; j++) \n\t{\n\t    switch (a->type)\n\t    {\n\t    case szMAPI_SHORT:\t/* 2 bytes */\n\t\tv->len = 2;\n\t\tCHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);\n\t\tidx += 4;\t/* assume padding of 2, advance by 4! */\n\t\tbreak;\n\n\t    case szMAPI_INT:\t/* 4 bytes */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += 4;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_FLOAT:\t/* 4 bytes */\n\t    case szMAPI_BOOLEAN: /* this should be 2 bytes + 2 padding */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_SYSTIME: /* 8 bytes */\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += 8;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_DOUBLE:\t/* 8 bytes */\n\t    case szMAPI_APPTIME:\n\t    case szMAPI_CURRENCY:\n\t    case szMAPI_INT8BYTE:\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_CLSID:\n\t\tv->len = sizeof (GUID);\n\t\tcopy_guid_from_buf(&v->data.guid, buf+idx, len);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_STRING:\n\t    case szMAPI_UNICODE_STRING:\n\t    case szMAPI_OBJECT:\n\t    case szMAPI_BINARY:\n\t\tCHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;\n\n\t\tif (a->type == szMAPI_UNICODE_STRING)\n\t\t{\n\t\t    v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);\n\t\t}\n\t\telse\n\t\t{\n\t\t    v->data.buf = CHECKED_XMALLOC(unsigned char, v->len);\n\t\t    memmove (v->data.buf, buf+idx, v->len);\n\t\t}\n\n\t\tidx += pad_to_4byte(v->len);\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_NULL:\t/* illegal in input tnef streams */\n\t    case szMAPI_ERROR:\n\t    case szMAPI_UNSPECIFIED:\n\t\tfprintf (stderr,\n\t\t\t \"Invalid attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    default:\t\t/* should never get here */\n\t\tfprintf (stderr,\n\t\t\t \"Undefined attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    }\n\t    if (DEBUG_ON) mapi_attr_dump (attrs[i]);\n\t}\n    }\n    attrs[i] = NULL;\n\n    return attrs;\n}\n\nstatic void\nmapi_attr_free (MAPI_Attr* attr)\n{\n    if (attr)\n    {\n\tsize_t i;\n\tfor (i = 0; i < attr->num_values; i++)\n\t{\n\t    if ((attr->type == szMAPI_STRING)\n\t\t|| (attr->type == szMAPI_UNICODE_STRING)\n\t\t|| (attr->type == szMAPI_BINARY))\n\t    {\n\t\tXFREE (attr->values[i].data.buf);\n\t    }\n\t}\n        if (attr->num_names > 0) {\n            for (i = 0; i < attr->num_names; i++)\n            {\n                XFREE(attr->names[i].data);\n            }\n            XFREE(attr->names);\n        }\n\tXFREE (attr->values);\n\tXFREE (attr->guid);\n\tmemset (attr, '\\0', sizeof (MAPI_Attr));\n    }\n}\n\nvoid\nmapi_attr_free_list (MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs && attrs[i]; i++)\n    {\n\tmapi_attr_free (attrs[i]);\n\tXFREE (attrs[i]);\n    }\n}\n"], "fixing_code": ["/*\n * mapi_attr.c -- Functions for handling MAPI attributes\n *\n * Copyright (C)1999-2006 Mark Simpson <damned@theworld.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can either send email to this\n * program's maintainer or write to: The Free Software Foundation,\n * Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.\n *\n */\n#ifdef HAVE_CONFIG_H\n#  include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include \"common.h\"\n\n#include \"mapi_attr.h\"\n#include \"alloc.h\"\n#include \"options.h\"\n#include \"util.h\"\n#include \"write.h\"\n\n/* return the length padded to a 4 byte boundary */\nstatic size_t\npad_to_4byte (size_t length)\n{\n    return (length+3) & ~3;\n}\n\n/* Copy the GUID data from a character buffer */\nstatic void\ncopy_guid_from_buf (GUID* guid, unsigned char *buf, size_t len)\n{\n    int i;\n    int idx = 0;\n    assert (guid);\n    assert (buf);\n\n    CHECKINT32(idx, len); guid->data1 = GETINT32(buf + idx); idx += sizeof (uint32);\n    CHECKINT16(idx, len); guid->data2 = GETINT16(buf + idx); idx += sizeof (uint16);\n    CHECKINT16(idx, len); guid->data3 = GETINT16(buf + idx); idx += sizeof (uint16);\n    for (i = 0; i < 8; i++, idx += sizeof (uint8))\n\tguid->data4[i] = (uint8)(buf[idx]);\n}\n\n\n/* dumps info about MAPI attributes... useful for debugging */\nstatic void\nmapi_attr_dump (MAPI_Attr* attr)\n{\n    char *name = get_mapi_name_str (attr->name);\n    char *type = get_mapi_type_str (attr->type);\n    size_t i;\n\n    fprintf (stdout, \"(MAPI) %s [type: %s] [num_values = %lu] = \\n\",\n\t     name, type, (unsigned long)attr->num_values);\n    if (attr->guid)\n    {\n\tfprintf (stdout, \"\\tGUID: \");\n\twrite_guid (stdout, attr->guid);\n\tfputc ('\\n', stdout);\n    }\n\t\n    for (i = 0; i < attr->num_names; i++)\n      fprintf (stdout, \"\\tname #%d: '%s'\\n\", (int)i, attr->names[i].data);\n\n    for (i = 0; i < attr->num_values; i++)\n    {\n\tfprintf (stdout, \"\\t#%lu [len: %lu] = \",\n\t\t (unsigned long)i,\n\t\t (unsigned long)attr->values[i].len);\n\n\tswitch (attr->type)\n\t{\n\tcase szMAPI_NULL:\n\t    fprintf (stdout, \"NULL\");\n\t    break;\n\n\tcase szMAPI_SHORT:\n\t    write_int16 (stdout, (int16)attr->values[i].data.bytes2);\n\t    break;\n\n\tcase szMAPI_INT:\n\t    write_int32 (stdout, (int32)attr->values[i].data.bytes4);\n\t    break;\n\n\tcase szMAPI_FLOAT:\n\tcase szMAPI_DOUBLE:\n\t    write_float (stdout, (float)attr->values[i].data.bytes4);\n\t    break;\n\n\tcase szMAPI_BOOLEAN:\n\t    write_boolean (stdout, attr->values[i].data.bytes4);\n\t    break;\n\n\tcase szMAPI_STRING:\n\tcase szMAPI_UNICODE_STRING:\n\t    write_string (stdout, (char*)attr->values[i].data.buf);\n\t    break;\n\n\tcase szMAPI_SYSTIME:\n\tcase szMAPI_CURRENCY:\n\tcase szMAPI_INT8BYTE:\n\tcase szMAPI_APPTIME:\n\t    write_uint64 (stdout, attr->values[i].data.bytes8);\n\t    break;\n\n\tcase szMAPI_ERROR:\n\t    write_uint32 (stdout, attr->values[i].data.bytes4);\n\t    break;\n\n\tcase szMAPI_CLSID:\n\t    write_guid (stdout, &attr->values[i].data.guid);\n\t    break;\n\n\tcase szMAPI_OBJECT:\n\tcase szMAPI_BINARY:\n\t{\n\t    size_t x;\n\n\t    for (x = 0; x < attr->values[i].len; x++)\n\t    {\n\t\twrite_byte (stdout, (uint8)attr->values[i].data.buf[x]);\n\t\tfputc (' ', stdout);\n\t    }\n\t}\n\tbreak;\n\n\tdefault:\n\t    fprintf (stdout, \"<unknown type>\");\n\t    break;\n\t}\n\tfprintf (stdout, \"\\n\");\n    }\n\n    fflush( NULL );\n}\n\nstatic MAPI_Value*\nalloc_mapi_values (MAPI_Attr* a)\n{\n    if (a && a->num_values)\n    {\n\ta->values = CHECKED_XCALLOC (MAPI_Value, a->num_values);\n\treturn a->values;\n    }\n    return NULL;\n}\n\n/*\n  2009/07/07\n  Microsoft documentation reference: [MS-OXPROPS] v 2.0, April 10, 2009\n\n  only multivalue types appearing are:\n  szMAPI_INT, szMAPI_SYSTIME, szMAPI_UNICODE_STRING, szMAPI_BINARY\n*/\n\n/* parses out the MAPI attibutes hidden in the character buffer */\nMAPI_Attr**\nmapi_attr_read (size_t len, unsigned char *buf)\n{\n    size_t idx = 0;\n    uint32 i,j;\n    assert(len > 4);\n    uint32 num_properties = GETINT32(buf+idx);\n    assert((num_properties+1) != 0);\n    MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));\n\n    idx += 4;\n\n    if (!attrs) return NULL;\n    for (i = 0; i < num_properties; i++)\n    {\n\tMAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);\n\tMAPI_Value* v = NULL;\n\n\tCHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;\n\tCHECKINT16(idx, len); a->name = GETINT16(buf+idx); idx += 2;\n\n\t/* handle special case of GUID prefixed properties */\n\tif (a->name & GUID_EXISTS_FLAG)\n\t{\n\t    /* copy GUID */\n\t    a->guid = CHECKED_XMALLOC(GUID, 1);\n\t    copy_guid_from_buf(a->guid, buf+idx, len);\n\t    idx += sizeof (GUID);\n\n\t    CHECKINT32(idx, len); a->num_names = GETINT32(buf+idx); idx += 4;\n\t    if (a->num_names > 0)\n\t    {\n\t\t/* FIXME: do something useful here! */\n\t\tsize_t i;\n\n\t\ta->names = CHECKED_XCALLOC(VarLenData, a->num_names);\n\n\t\tfor (i = 0; i < a->num_names; i++)\n\t\t{\n\t\t    size_t j;\n\n\t\t    CHECKINT32(idx, len); a->names[i].len = GETINT32(buf+idx); idx += 4;\n\n\t\t    /* read the data into a buffer */\n\t\t    a->names[i].data \n\t\t\t= CHECKED_XMALLOC(unsigned char, a->names[i].len);\n\t\t    assert((idx+(a->names[i].len*2)) <= len);\n\t\t    for (j = 0; j < (a->names[i].len >> 1); j++)\n\t\t\ta->names[i].data[j] = (buf+idx)[j*2];\n\n\t\t    /* But what are we going to do with it? */\n\t\t    \n\t\t    idx += pad_to_4byte(a->names[i].len);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/* get the 'real' name */\n\t\tCHECKINT32(idx, len); a->name = GETINT32(buf+idx); idx+= 4;\n\t    }\n\t}\n\n\t/* \n\t * Multi-value types and string/object/binary types have\n\t * multiple values \n\t */\n\tif (a->type & MULTI_VALUE_FLAG ||\n\t    a->type == szMAPI_STRING ||\n\t    a->type == szMAPI_UNICODE_STRING ||\n\t    a->type == szMAPI_OBJECT ||\n\t    a->type == szMAPI_BINARY)\n\t{\n\t    CHECKINT32(idx, len); a->num_values = GETINT32(buf+idx);\n\t    idx += 4;\n\t}\n        else\n        {\n\t    a->num_values = 1;\n        }\n\n\t/* Amend the type in case of multi-value type */\n\tif (a->type & MULTI_VALUE_FLAG)\n\t{\n\t    a->type -= MULTI_VALUE_FLAG;\n\t}\n\n\n\tv = alloc_mapi_values (a);\n\n\tfor (j = 0; j < a->num_values; j++) \n\t{\n\t    switch (a->type)\n\t    {\n\t    case szMAPI_SHORT:\t/* 2 bytes */\n\t\tv->len = 2;\n\t\tCHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);\n\t\tidx += 4;\t/* assume padding of 2, advance by 4! */\n\t\tbreak;\n\n\t    case szMAPI_INT:\t/* 4 bytes */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += 4;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_FLOAT:\t/* 4 bytes */\n\t    case szMAPI_BOOLEAN: /* this should be 2 bytes + 2 padding */\n\t\tv->len = 4;\n\t\tCHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_SYSTIME: /* 8 bytes */\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += 8;\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_DOUBLE:\t/* 8 bytes */\n\t    case szMAPI_APPTIME:\n\t    case szMAPI_CURRENCY:\n\t    case szMAPI_INT8BYTE:\n\t\tv->len = 8;\n\t\tCHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);\n\t\tCHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_CLSID:\n\t\tv->len = sizeof (GUID);\n\t\tcopy_guid_from_buf(&v->data.guid, buf+idx, len);\n\t\tidx += v->len;\n\t\tbreak;\n\n\t    case szMAPI_STRING:\n\t    case szMAPI_UNICODE_STRING:\n\t    case szMAPI_OBJECT:\n\t    case szMAPI_BINARY:\n\t\tCHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;\n\n\t\tassert(v->len + idx <= len);\n\n\t\tif (a->type == szMAPI_UNICODE_STRING)\n\t\t{\n\t\t    assert(v->len != 0);\n\t\t    v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);\n\t\t}\n\t\telse\n\t\t{\n\t\t    v->data.buf = CHECKED_XMALLOC(unsigned char, v->len);\n\t\t    memmove (v->data.buf, buf+idx, v->len);\n\t\t}\n\n\t\tidx += pad_to_4byte(v->len);\n\t\tv++;\n\t\tbreak;\n\n\t    case szMAPI_NULL:\t/* illegal in input tnef streams */\n\t    case szMAPI_ERROR:\n\t    case szMAPI_UNSPECIFIED:\n\t\tfprintf (stderr,\n\t\t\t \"Invalid attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    default:\t\t/* should never get here */\n\t\tfprintf (stderr,\n\t\t\t \"Undefined attribute, input file may be corrupted\\n\");\n\t\tif (!ENCODE_SKIP) exit (1);\n\n\t\treturn NULL;\n\n\t    }\n\t    if (DEBUG_ON) mapi_attr_dump (attrs[i]);\n\t}\n    }\n    attrs[i] = NULL;\n\n    return attrs;\n}\n\nstatic void\nmapi_attr_free (MAPI_Attr* attr)\n{\n    if (attr)\n    {\n\tsize_t i;\n\tfor (i = 0; i < attr->num_values; i++)\n\t{\n\t    if ((attr->type == szMAPI_STRING)\n\t\t|| (attr->type == szMAPI_UNICODE_STRING)\n\t\t|| (attr->type == szMAPI_BINARY))\n\t    {\n\t\tXFREE (attr->values[i].data.buf);\n\t    }\n\t}\n        if (attr->num_names > 0) {\n            for (i = 0; i < attr->num_names; i++)\n            {\n                XFREE(attr->names[i].data);\n            }\n            XFREE(attr->names);\n        }\n\tXFREE (attr->values);\n\tXFREE (attr->guid);\n\tmemset (attr, '\\0', sizeof (MAPI_Attr));\n    }\n}\n\nvoid\nmapi_attr_free_list (MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs && attrs[i]; i++)\n    {\n\tmapi_attr_free (attrs[i]);\n\tXFREE (attrs[i]);\n    }\n}\n"], "filenames": ["src/mapi_attr.c"], "buggy_code_start_loc": [176], "buggy_code_end_loc": [312], "fixing_code_start_loc": [177], "fixing_code_end_loc": [318], "type": "CWE-787", "message": "An issue was discovered in tnef before 1.4.13. Two OOB Writes have been identified in src/mapi_attr.c:mapi_attr_read(). These might lead to invalid read and write operations, controlled by an attacker.", "other": {"cve": {"id": "CVE-2017-6307", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-24T04:59:00.560", "lastModified": "2019-03-13T18:21:24.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in tnef before 1.4.13. Two OOB Writes have been identified in src/mapi_attr.c:mapi_attr_read(). These might lead to invalid read and write operations, controlled by an attacker."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en tnef en versiones anteriores a 1.4.13. Se han identificado dos escrituras OOB en src/mapi_attr.c:mapi_attr_read(). Esto puede conducir a operaciones de lectura y escritura no v\u00e1lidas, controladas por un atacante."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tnef_project:tnef:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.4.12", "matchCriteriaId": "89F0C6D8-2B85-44C4-A8C0-1BDBCAC4E6DC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3798", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96427", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/verdammelt/tnef/blob/master/ChangeLog", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201708-02", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.x41-dsec.de/lab/advisories/x41-2017-004-tnef/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a"}}