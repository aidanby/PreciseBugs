{"buggy_code": ["/* $Id: minissdpd.c,v 1.37 2014/02/28 18:39:11 nanard Exp $ */\n/* MiniUPnP project\n * (c) 2007-2014 Thomas Bernard\n * website : http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <time.h>\n#include <sys/queue.h>\n/* for chmod : */\n#include <sys/stat.h>\n/* unix sockets */\n#include <sys/un.h>\n/* for getpwnam() and getgrnam() */\n#include <pwd.h>\n#include <grp.h>\n\n#include \"upnputils.h\"\n#include \"openssdpsocket.h\"\n#include \"daemonize.h\"\n#include \"codelength.h\"\n#include \"ifacewatch.h\"\n\n/* current request management stucture */\nstruct reqelem {\n\tint socket;\n\tLIST_ENTRY(reqelem) entries;\n};\n\n/* divice data structures */\nstruct header {\n\tconst char * p; /* string pointer */\n\tint l;          /* string length */\n};\n\n#define HEADER_NT\t0\n#define HEADER_USN\t1\n#define HEADER_LOCATION\t2\n\nstruct device {\n\tstruct device * next;\n\ttime_t t;                 /* validity time */\n\tstruct header headers[3]; /* NT, USN and LOCATION headers */\n\tchar data[];\n};\n\n#define NTS_SSDP_ALIVE\t1\n#define NTS_SSDP_BYEBYE\t2\n#define NTS_SSDP_UPDATE\t3\n\n/* discovered device list kept in memory */\nstruct device * devlist = 0;\n\n/* bootid and configid */\nunsigned int upnp_bootid = 1;\nunsigned int upnp_configid = 1337;\n\nstatic const char *\nnts_to_str(int nts)\n{\n\tswitch(nts)\n\t{\n\tcase NTS_SSDP_ALIVE:\n\t\treturn \"ssdp:alive\";\n\tcase NTS_SSDP_BYEBYE:\n\t\treturn \"ssdp:byebye\";\n\tcase NTS_SSDP_UPDATE:\n\t\treturn \"ssdp:update\";\n\t}\n\treturn \"unknown\";\n}\n\n/* updateDevice() :\n * adds or updates the device to the list.\n * return value :\n *   0 : the device was updated (or nothing done)\n *   1 : the device was new    */\nstatic int\nupdateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tp = realloc(p, sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\t\t\tif(!p)\t/* allocation error */\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t}\n\treturn 1;\n}\n\n/* removeDevice() :\n * remove a device from the list\n * return value :\n *    0 : no device removed\n *   -1 : device removed */\nstatic int\nremoveDevice(const struct header * headers)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"remove device : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\t*pp = p->next;\n\t\t\tfree(p);\n\t\t\treturn -1;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_WARNING, \"device not found for removing : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\treturn 0;\n}\n\n/* SendSSDPMSEARCHResponse() :\n * build and send response to M-SEARCH SSDP packets. */\nstatic void\nSendSSDPMSEARCHResponse(int s, const struct sockaddr * sockname,\n                        const char * st, const char * usn,\n                        const char * server, const char * location)\n{\n\tint l, n;\n\tchar buf[512];\n\tsocklen_t sockname_len;\n\t/*\n\t * follow guideline from document \"UPnP Device Architecture 1.0\"\n\t * uppercase is recommended.\n\t * DATE: is recommended\n\t * SERVER: OS/ver UPnP/1.0 miniupnpd/1.0\n\t * - check what to put in the 'Cache-Control' header\n\t *\n\t * have a look at the document \"UPnP Device Architecture v1.1 */\n\tl = snprintf(buf, sizeof(buf), \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\"CACHE-CONTROL: max-age=120\\r\\n\"\n\t\t/*\"DATE: ...\\r\\n\"*/\n\t\t\"ST: %s\\r\\n\"\n\t\t\"USN: %s\\r\\n\"\n\t\t\"EXT:\\r\\n\"\n\t\t\"SERVER: %s\\r\\n\"\n\t\t\"LOCATION: %s\\r\\n\"\n\t\t\"OPT: \\\"http://schemas.upnp.org/upnp/1/0/\\\"; ns=01\\r\\n\" /* UDA v1.1 */\n\t\t\"01-NLS: %u\\r\\n\" /* same as BOOTID. UDA v1.1 */\n\t\t\"BOOTID.UPNP.ORG: %u\\r\\n\" /* UDA v1.1 */\n\t\t\"CONFIGID.UPNP.ORG: %u\\r\\n\" /* UDA v1.1 */\n\t\t\"\\r\\n\",\n\t\tst, usn,\n\t\tserver, location,\n\t\tupnp_bootid, upnp_bootid, upnp_configid);\n#ifdef ENABLE_IPV6\n\tsockname_len = (sockname->sa_family == PF_INET6)\n\t             ? sizeof(struct sockaddr_in6)\n\t             : sizeof(struct sockaddr_in);\n#else\n\tsockname_len = sizeof(struct sockaddr_in);\n#endif\n\tn = sendto(s, buf, l, 0,\n\t           sockname, sockname_len );\n\tif(n < 0) {\n\t\t/* XXX handle EINTR, EAGAIN, EWOULDBLOCK */\n\t\tsyslog(LOG_ERR, \"sendto(udp): %m\");\n\t}\n}\n\n/* Services stored for answering to M-SEARCH */\nstruct service {\n\tchar * st;\t/* Service type */\n\tchar * usn;\t/* Unique identifier */\n\tchar * server;\t/* Server string */\n\tchar * location;\t/* URL */\n\tLIST_ENTRY(service) entries;\n};\nLIST_HEAD(servicehead, service) servicelisthead;\n\n/* Process M-SEARCH requests */\nstatic void\nprocessMSEARCH(int s, const char * st, int st_len,\n               const struct sockaddr * addr)\n{\n\tstruct service * serv;\n#ifdef ENABLE_IPV6\n\tchar buf[64];\n#endif\n\n\tif(!st || st_len==0)\n\t\treturn;\n#ifdef ENABLE_IPV6\n\tsockaddr_to_string(addr, buf, sizeof(buf));\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s ST:%.*s\",\n\t       buf, st_len, st);\n#else\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s:%d ST: %.*s\",\n\t       inet_ntoa(((const struct sockaddr_in *)addr)->sin_addr),\n\t       ntohs(((const struct sockaddr_in *)addr)->sin_port),\n\t       st_len, st);\n#endif\n\tif(st_len==8 && (0==memcmp(st, \"ssdp:all\", 8))) {\n\t\t/* send a response for all services */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t                        serv->st, serv->usn,\n\t\t\t                        serv->server, serv->location);\n\t\t}\n\t} else if(st_len > 5 && (0==memcmp(st, \"uuid:\", 5))) {\n\t\t/* find a matching UUID value */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->usn, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* find matching services */\n\t\t/* remove version at the end of the ST string */\n\t\tif(st[st_len-2]==':' && isdigit(st[st_len-1]))\n\t\t\tst_len -= 2;\n\t\t/* answer for each matching service */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->st, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * helper function.\n * reject any non ASCII or non printable character.\n */\nstatic int\ncontainsForbiddenChars(const unsigned char * p, int len)\n{\n\twhile(len > 0) {\n\t\tif(*p < ' ' || *p >= '\\x7f')\n\t\t\treturn 1;\n\t\tp++;\n\t\tlen--;\n\t}\n\treturn 0;\n}\n\n#define METHOD_MSEARCH 1\n#define METHOD_NOTIFY 2\n\n/* ParseSSDPPacket() :\n * parse a received SSDP Packet and call\n * updateDevice() or removeDevice() as needed\n * return value :\n *    -1 : a device was removed\n *     0 : no device removed nor added\n *     1 : a device was added.  */\nstatic int\nParseSSDPPacket(int s, const char * p, ssize_t n,\n                const struct sockaddr * addr)\n{\n\tconst char * linestart;\n\tconst char * lineend;\n\tconst char * nameend;\n\tconst char * valuestart;\n\tstruct header headers[3];\n\tint i, r = 0;\n\tint methodlen;\n\tint nts = -1;\n\tint method = -1;\n\tunsigned int lifetime = 180;\t/* 3 minutes by default */\n\tconst char * st = NULL;\n\tint st_len = 0;\n\n\tmemset(headers, 0, sizeof(headers));\n\tfor(methodlen = 0;\n\t    methodlen < n && (isalpha(p[methodlen]) || p[methodlen]=='-');\n\t\tmethodlen++);\n\tif(methodlen==8 && 0==memcmp(p, \"M-SEARCH\", 8))\n\t\tmethod = METHOD_MSEARCH;\n\telse if(methodlen==6 && 0==memcmp(p, \"NOTIFY\", 6))\n\t\tmethod = METHOD_NOTIFY;\n\telse if(methodlen==4 && 0==memcmp(p, \"HTTP\", 4)) {\n\t\t/* answer to a M-SEARCH => process it as a NOTIFY\n\t\t * with NTS: ssdp:alive */\n\t\tmethod = METHOD_NOTIFY;\n\t\tnts = NTS_SSDP_ALIVE;\n\t}\n\tlinestart = p;\n\twhile(linestart < p + n - 2) {\n\t\t/* start parsing the line : detect line end */\n\t\tlineend = linestart;\n\t\twhile(lineend < p + n && *lineend != '\\n' && *lineend != '\\r')\n\t\t\tlineend++;\n\t\t/*printf(\"line: '%.*s'\\n\", lineend - linestart, linestart);*/\n\t\t/* detect name end : ':' character */\n\t\tnameend = linestart;\n\t\twhile(nameend < lineend && *nameend != ':')\n\t\t\tnameend++;\n\t\t/* detect value */\n\t\tif(nameend < lineend)\n\t\t\tvaluestart = nameend + 1;\n\t\telse\n\t\t\tvaluestart = nameend;\n\t\t/* trim spaces */\n\t\twhile(valuestart < lineend && isspace(*valuestart))\n\t\t\tvaluestart++;\n\t\t/* suppress leading \" if needed */\n\t\tif(valuestart < lineend && *valuestart=='\\\"')\n\t\t\tvaluestart++;\n\t\tif(nameend > linestart && valuestart < lineend) {\n\t\t\tint l = nameend - linestart;\t/* header name length */\n\t\t\tint m = lineend - valuestart;\t/* header value length */\n\t\t\t/* suppress tailing spaces */\n\t\t\twhile(m>0 && isspace(valuestart[m-1]))\n\t\t\t\tm--;\n\t\t\t/* suppress tailing ' if needed */\n\t\t\tif(m>0 && valuestart[m-1] == '\\\"')\n\t\t\t\tm--;\n\t\t\ti = -1;\n\t\t\t/*printf(\"--%.*s: (%d)%.*s--\\n\", l, linestart,\n\t\t\t                           m, m, valuestart);*/\n\t\t\tif(l==2 && 0==strncasecmp(linestart, \"nt\", 2))\n\t\t\t\ti = HEADER_NT;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"usn\", 3))\n\t\t\t\ti = HEADER_USN;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"nts\", 3)) {\n\t\t\t\tif(m==10 && 0==strncasecmp(valuestart, \"ssdp:alive\", 10))\n\t\t\t\t\tnts = NTS_SSDP_ALIVE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:byebye\", 11))\n\t\t\t\t\tnts = NTS_SSDP_BYEBYE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:update\", 11))\n\t\t\t\t\tnts = NTS_SSDP_UPDATE;\n\t\t\t}\n\t\t\telse if(l==8 && 0==strncasecmp(linestart, \"location\", 8))\n\t\t\t\ti = HEADER_LOCATION;\n\t\t\telse if(l==13 && 0==strncasecmp(linestart, \"cache-control\", 13)) {\n\t\t\t\t/* parse \"name1=value1, name_alone, name2=value2\" string */\n\t\t\t\tconst char * name = valuestart;\t/* name */\n\t\t\t\tconst char * val;\t\t\t\t/* value */\n\t\t\t\tint rem = m;\t/* remaining bytes to process */\n\t\t\t\twhile(rem > 0) {\n\t\t\t\t\tval = name;\n\t\t\t\t\twhile(val < name + rem && *val != '=' && *val != ',')\n\t\t\t\t\t\tval++;\n\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(*val == '=') {\n\t\t\t\t\t\twhile(val < name + rem && (*val == '=' || isspace(*val)))\n\t\t\t\t\t\t\tval++;\n\t\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif(0==strncasecmp(name, \"max-age\", 7))\n\t\t\t\t\t\t\tlifetime = (unsigned int)strtoul(val, 0, 0);\n\t\t\t\t\t\t/* move to the next name=value pair */\n\t\t\t\t\t\twhile(rem > 0 && *name != ',') {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* skip spaces */\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trem -= (val - name);\n\t\t\t\t\t\tname = val;\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*syslog(LOG_DEBUG, \"**%.*s**%u\", m, valuestart, lifetime);*/\n\t\t\t} else if(l==2 && 0==strncasecmp(linestart, \"st\", 2)) {\n\t\t\t\tst = valuestart;\n\t\t\t\tst_len = m;\n\t\t\t\tif(method == METHOD_NOTIFY)\n\t\t\t\t\ti = HEADER_NT;\t/* it was a M-SEARCH response */\n\t\t\t}\n\t\t\tif(i>=0) {\n\t\t\t\theaders[i].p = valuestart;\n\t\t\t\theaders[i].l = m;\n\t\t\t}\n\t\t}\n\t\tlinestart = lineend;\n\t\twhile((*linestart == '\\n' || *linestart == '\\r') && linestart < p + n)\n\t\t\tlinestart++;\n\t}\n#if 0\n\tprintf(\"NTS=%d\\n\", nts);\n\tfor(i=0; i<3; i++) {\n\t\tif(headers[i].p)\n\t\t\tprintf(\"%d-'%.*s'\\n\", i, headers[i].l, headers[i].p);\n\t}\n#endif\n\tsyslog(LOG_DEBUG,\"SSDP request: '%.*s' (%d) %s %s=%.*s\",\n\t       methodlen, p, method, nts_to_str(nts),\n\t       (method==METHOD_NOTIFY)?\"nt\":\"st\",\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].l:st_len,\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].p:st);\n\tswitch(method) {\n\tcase METHOD_NOTIFY:\n\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p && headers[HEADER_LOCATION].p) {\n\t\t\tif(nts==NTS_SSDP_ALIVE) {\n\t\t\t\tr = updateDevice(headers, time(NULL) + lifetime);\n\t\t\t}\n\t\t\telse if(nts==NTS_SSDP_BYEBYE) {\n\t\t\t\tr = removeDevice(headers);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase METHOD_MSEARCH:\n\t\tprocessMSEARCH(s, st, st_len, addr);\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"method %.*s, don't know what to do\", methodlen, p);\n\t}\n\treturn r;\n}\n\n/* OpenUnixSocket()\n * open the unix socket and call bind() and listen()\n * return -1 in case of error */\nstatic int\nOpenUnixSocket(const char * path)\n{\n\tstruct sockaddr_un addr;\n\tint s;\n\tint rv;\n\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif(s < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"socket(AF_UNIX): %m\");\n\t\treturn -1;\n\t}\n\t/* unlink the socket pseudo file before binding */\n\trv = unlink(path);\n\tif(rv < 0 && errno != ENOENT)\n\t{\n\t\tsyslog(LOG_ERR, \"unlink(unixsocket, \\\"%s\\\"): %m\", path);\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\taddr.sun_family = AF_UNIX;\n\tstrncpy(addr.sun_path, path, sizeof(addr.sun_path));\n\tif(bind(s, (struct sockaddr *)&addr,\n\t           sizeof(struct sockaddr_un)) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"bind(unixsocket, \\\"%s\\\"): %m\", path);\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\telse if(listen(s, 5) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"listen(unixsocket): %m\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\t/* Change rights so everyone can communicate with us */\n\tif(chmod(path, 0666) < 0)\n\t{\n\t\tsyslog(LOG_WARNING, \"chmod(\\\"%s\\\"): %m\", path);\n\t}\n\treturn s;\n}\n\n/* processRequest() :\n * process the request coming from a unix socket */\nvoid processRequest(struct reqelem * req)\n{\n\tssize_t n;\n\tunsigned int l, m;\n\tunsigned char buf[2048];\n\tconst unsigned char * p;\n\tint type;\n\tstruct device * d = devlist;\n\tunsigned char rbuf[4096];\n\tunsigned char * rp = rbuf+1;\n\tunsigned char nrep = 0;\n\ttime_t t;\n\tstruct service * newserv = NULL;\n\tstruct service * serv;\n\n\tn = read(req->socket, buf, sizeof(buf));\n\tif(n<0) {\n\t\tif(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)\n\t\t\treturn;\t/* try again later */\n\t\tsyslog(LOG_ERR, \"(s=%d) processRequest(): read(): %m\", req->socket);\n\t\tgoto error;\n\t}\n\tif(n==0) {\n\t\tsyslog(LOG_INFO, \"(s=%d) request connection closed\", req->socket);\n\t\tgoto error;\n\t}\n\tt = time(NULL);\n\ttype = buf[0];\n\tp = buf + 1;\n\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\tif(p+l > buf+n) {\n\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\tgoto error;\n\t}\n\tif(l == 0 && type != 3) {\n\t\tsyslog(LOG_WARNING, \"bad request (length=0)\");\n\t\tgoto error;\n\t}\n\tsyslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\",\n\t       req->socket, type, l, p);\n\tswitch(type) {\n\tcase 1:\t/* request by type */\n\tcase 2:\t/* request by USN (unique id) */\n\tcase 3:\t/* everything */\n\t\twhile(d && (nrep < 255)) {\n\t\t\tif(d->t < t) {\n\t\t\t\tsyslog(LOG_INFO, \"outdated device\");\n\t\t\t} else {\n\t\t\t\t/* test if we can put more responses in the buffer */\n\t\t\t\tif(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l\n\t\t\t\t  + d->headers[HEADER_USN].l + 6\n\t\t\t\t  + (rp - rbuf) >= (int)sizeof(rbuf))\n\t\t\t\t\tbreak;\n\t\t\t\tif( (type==1 && 0==memcmp(d->headers[HEADER_NT].p, p, l))\n\t\t\t\t  ||(type==2 && 0==memcmp(d->headers[HEADER_USN].p, p, l))\n\t\t\t\t  ||(type==3) ) {\n\t\t\t\t\t/* response :\n\t\t\t\t\t * 1 - Location\n\t\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t\t * 3 - usn */\n\t\t\t\t\tm = d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);\n\t\t\t\t\trp += d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tm = d->headers[HEADER_NT].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);\n\t\t\t\t\trp += d->headers[HEADER_NT].l;\n\t\t\t\t\tm = d->headers[HEADER_USN].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);\n\t\t\t\t\trp += d->headers[HEADER_USN].l;\n\t\t\t\t\tnrep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = d->next;\n\t\t}\n\t\t/* Also look in service list */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv && (nrep < 255);\n\t\t    serv = serv->entries.le_next) {\n\t\t\t/* test if we can put more responses in the buffer */\n\t\t\tif(strlen(serv->location) + strlen(serv->st)\n\t\t\t  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))\n\t\t\t  \tbreak;\n\t\t\tif( (type==1 && 0==strncmp(serv->st, (const char *)p, l))\n\t\t\t  ||(type==2 && 0==strncmp(serv->usn, (const char *)p, l))\n\t\t\t  ||(type==3) ) {\n\t\t\t\t/* response :\n\t\t\t\t * 1 - Location\n\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t * 3 - usn */\n\t\t\t\tm = strlen(serv->location);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->location, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->st);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->st, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->usn);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\t\trp += m;\n\t\t\t\tnrep++;\n\t\t\t}\n\t\t}\n\t\trbuf[0] = nrep;\n\t\tsyslog(LOG_DEBUG, \"(s=%d) response : %d device%s\",\n\t\t       req->socket, nrep, (nrep > 1) ? \"s\" : \"\");\n\t\tif(write(req->socket, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase 4:\t/* submit service */\n\t\tnewserv = malloc(sizeof(struct service));\n\t\tif(!newserv) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (st contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tnewserv->st = malloc(l + 1);\n\t\tif(!newserv->st) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->st, p, l);\n\t\tnewserv->st[l] = '\\0';\n\t\tp += l;\n\t\tif(p >= buf + n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (missing usn)\");\n\t\t\tgoto error;\n\t\t}\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (usn contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"usn='%.*s'\", l, p);\n\t\tnewserv->usn = malloc(l + 1);\n\t\tif(!newserv->usn) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->usn, p, l);\n\t\tnewserv->usn[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (server contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"server='%.*s'\", l, p);\n\t\tnewserv->server = malloc(l + 1);\n\t\tif(!newserv->server) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->server, p, l);\n\t\tnewserv->server[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (location contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"location='%.*s'\", l, p);\n\t\tnewserv->location = malloc(l + 1);\n\t\tif(!newserv->location) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->location, p, l);\n\t\tnewserv->location[l] = '\\0';\n\t\t/* look in service list for duplicate */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strcmp(newserv->usn, serv->usn)\n\t\t\t  && 0 == strcmp(newserv->st, serv->st)) {\n\t\t\t\tsyslog(LOG_INFO, \"Service allready in the list. Updating...\");\n\t\t\t\tfree(newserv->st);\n\t\t\t\tfree(newserv->usn);\n\t\t\t\tfree(serv->server);\n\t\t\t\tserv->server = newserv->server;\n\t\t\t\tfree(serv->location);\n\t\t\t\tserv->location = newserv->location;\n\t\t\t\tfree(newserv);\n\t\t\t\tnewserv = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* Inserting new service */\n\t\tLIST_INSERT_HEAD(&servicelisthead, newserv, entries);\n\t\tnewserv = NULL;\n\t\t/*rbuf[0] = '\\0';\n\t\tif(write(req->socket, rbuf, 1) < 0)\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t*/\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"Unknown request type %d\", type);\n\t\trbuf[0] = '\\0';\n\t\tif(write(req->socket, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn;\nerror:\n\tif(newserv) {\n\t\tfree(newserv->st);\n\t\tfree(newserv->usn);\n\t\tfree(newserv->server);\n\t\tfree(newserv->location);\n\t\tfree(newserv);\n\t\tnewserv = NULL;\n\t}\n\tclose(req->socket);\n\treq->socket = -1;\n\treturn;\n}\n\nstatic volatile sig_atomic_t quitting = 0;\n/* SIGTERM signal handler */\nstatic void\nsigterm(int sig)\n{\n\t(void)sig;\n\t/*int save_errno = errno;*/\n\t/*signal(sig, SIG_IGN);*/\n#if 0\n\t/* calling syslog() is forbidden in a signal handler according to\n\t * signal(3) */\n\tsyslog(LOG_NOTICE, \"received signal %d, good-bye\", sig);\n#endif\n\tquitting = 1;\n\t/*errno = save_errno;*/\n}\n\n#define PORT 1900\n#define XSTR(s) STR(s)\n#define STR(s) #s\n#define UPNP_MCAST_ADDR \"239.255.255.250\"\n/* for IPv6 */\n#define UPNP_MCAST_LL_ADDR \"FF02::C\" /* link-local */\n#define UPNP_MCAST_SL_ADDR \"FF05::C\" /* site-local */\n\n/* send the M-SEARCH request for all devices */\nvoid ssdpDiscoverAll(int s, int ipv6)\n{\n\tstatic const char MSearchMsgFmt[] =\n\t\"M-SEARCH * HTTP/1.1\\r\\n\"\n\t\"HOST: %s:\" XSTR(PORT) \"\\r\\n\"\n\t\"ST: ssdp:all\\r\\n\"\n\t\"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n\t\"MX: %u\\r\\n\"\n\t\"\\r\\n\";\n\tchar bufr[512];\n\tint n;\n\tint mx = 3;\n\tint linklocal = 1;\n\tstruct sockaddr_storage sockudp_w;\n\n\t{\n\t\tn = snprintf(bufr, sizeof(bufr),\n\t\t             MSearchMsgFmt,\n\t\t             ipv6 ?\n\t\t             (linklocal ? \"[\" UPNP_MCAST_LL_ADDR \"]\" :  \"[\" UPNP_MCAST_SL_ADDR \"]\")\n\t\t             : UPNP_MCAST_ADDR, mx);\n\t\tmemset(&sockudp_w, 0, sizeof(struct sockaddr_storage));\n\t\tif(ipv6) {\n\t\t\tstruct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockudp_w;\n\t\t\tp->sin6_family = AF_INET6;\n\t\t\tp->sin6_port = htons(PORT);\n\t\t\tinet_pton(AF_INET6,\n\t\t\t          linklocal ? UPNP_MCAST_LL_ADDR : UPNP_MCAST_SL_ADDR,\n\t\t\t          &(p->sin6_addr));\n\t\t} else {\n\t\t\tstruct sockaddr_in * p = (struct sockaddr_in *)&sockudp_w;\n\t\t\tp->sin_family = AF_INET;\n\t\t\tp->sin_port = htons(PORT);\n\t\t\tp->sin_addr.s_addr = inet_addr(UPNP_MCAST_ADDR);\n\t\t}\n\n\t\tn = sendto(s, bufr, n, 0, (const struct sockaddr *)&sockudp_w,\n\t\t           ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\t\tif (n < 0) {\n\t\t\t/* XXX : EINTR EWOULDBLOCK EAGAIN */\n\t\t\tsyslog(LOG_ERR, \"sendto: %m\");\n\t\t}\n\t}\n}\n\n/* main(): program entry point */\nint main(int argc, char * * argv)\n{\n\tint ret = 0;\n\tint pid;\n\tstruct sigaction sa;\n\tchar buf[1500];\n\tssize_t n;\n\tint s_ssdp = -1;\t/* udp socket receiving ssdp packets */\n#ifdef ENABLE_IPV6\n\tint s_ssdp6 = -1;\t/* udp socket receiving ssdp packets IPv6*/\n#else\n#define s_ssdp6 (-1)\n#endif\n\tint s_unix = -1;\t/* unix socket communicating with clients */\n\tint s_ifacewatch = -1;\t/* socket to receive Route / network interface config changes */\n\tint s;\n\tLIST_HEAD(reqstructhead, reqelem) reqlisthead;\n\tstruct reqelem * req;\n\tstruct reqelem * reqnext;\n\tfd_set readfds;\n\tconst char * if_addr[MAX_IF_ADDR];\n\tint n_if_addr = 0;\n\tint i;\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\tconst char * pidfilename = \"/var/run/minissdpd.pid\";\n\tint debug_flag = 0;\n\tint ipv6 = 0;\n\tint deltadev = 0;\n\tstruct sockaddr_in sendername;\n\tsocklen_t sendername_len;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_in6 sendername6;\n\tsocklen_t sendername6_len;\n#endif\n\n\tLIST_INIT(&reqlisthead);\n\tLIST_INIT(&servicelisthead);\n\t/* process command line */\n\tfor(i=1; i<argc; i++)\n\t{\n\t\tif(0==strcmp(argv[i], \"-i\")) {\n\t\t\tif(n_if_addr < MAX_IF_ADDR)\n\t\t\t\tif_addr[n_if_addr++] = argv[++i];\n\t\t\telse\n\t\t\t\tsyslog(LOG_WARNING, \"Max number of interface address set to %d, \"\n\t\t\t\t       \"ignoring %s\", MAX_IF_ADDR, argv[++i]);\n\t\t} else if(0==strcmp(argv[i], \"-d\"))\n\t\t\tdebug_flag = 1;\n\t\telse if(0==strcmp(argv[i], \"-s\"))\n\t\t\tsockpath = argv[++i];\n\t\telse if(0==strcmp(argv[i], \"-p\"))\n\t\t\tpidfilename = argv[++i];\n#ifdef ENABLE_IPV6\n\t\telse if(0==strcmp(argv[i], \"-6\"))\n\t\t\tipv6 = 1;\n#endif\n\t}\n\tif(n_if_addr < 1)\n\t{\n\t\tfprintf(stderr,\n\t\t        \"Usage: %s [-d] [-6] [-s socket] [-p pidfile] \"\n\t\t\t\t\"-i <interface> [-i <interface2>] ...\\n\",\n\t\t        argv[0]);\n\t\tfprintf(stderr,\n\t\t        \"\\n  <interface> is either an IPv4 address such as 192.168.1.42, or an\\ninterface name such as eth0.\\n\");\n\t\tfprintf(stderr,\n\t\t        \"\\n  By default, socket will be open as %s\\n\"\n\t\t        \"and pid written to file %s\\n\",\n\t\t        sockpath, pidfilename);\n\t\treturn 1;\n\t}\n\n\t/* open log */\n\topenlog(\"minissdpd\",\n\t        LOG_CONS|LOG_PID|(debug_flag?LOG_PERROR:0),\n\t\t\tLOG_MINISSDPD);\n\tif(!debug_flag) /* speed things up and ignore LOG_INFO and LOG_DEBUG */\n\t\tsetlogmask(LOG_UPTO(LOG_NOTICE));\n\n\tif(checkforrunning(pidfilename) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"MiniSSDPd is already running. EXITING\");\n\t\treturn 1;\n\t}\n\n\t/* set signal handlers */\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\tsa.sa_handler = sigterm;\n\tif(sigaction(SIGTERM, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGTERM handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\tif(sigaction(SIGINT, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGINT handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\t/* open route/interface config changes socket */\n\ts_ifacewatch = OpenAndConfInterfaceWatchSocket();\n\t/* open UDP socket(s) for receiving SSDP packets */\n\ts_ssdp = OpenAndConfSSDPReceiveSocket(n_if_addr, if_addr, 0);\n\tif(s_ssdp < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages, exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n#ifdef ENABLE_IPV6\n\tif(ipv6) {\n\t\ts_ssdp6 = OpenAndConfSSDPReceiveSocket(n_if_addr, if_addr, 1);\n\t\tif(s_ssdp6 < 0)\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages (IPv6), exiting\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\n\t/* Open Unix socket to communicate with other programs on\n\t * the same machine */\n\ts_unix = OpenUnixSocket(sockpath);\n\tif(s_unix < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open unix socket for communicating with clients. Exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\n\t/* drop privileges */\n#if 0\n\t/* if we drop privileges, how to unlink(/var/run/minissdpd.sock) ? */\n\tif(getuid() == 0) {\n\t\tstruct passwd * user;\n\t\tstruct group * group;\n\t\tuser = getpwnam(\"nobody\");\n\t\tif(!user) {\n\t\t\tsyslog(LOG_ERR, \"getpwnam(\\\"%s\\\") : %m\", \"nobody\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tgroup = getgrnam(\"nogroup\");\n\t\tif(!group) {\n\t\t\tsyslog(LOG_ERR, \"getgrnam(\\\"%s\\\") : %m\", \"nogroup\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setgid(group->gr_gid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setgit(%d) : %m\", group->gr_gid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setuid(user->pw_uid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setuid(%d) : %m\", user->pw_uid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\n\n\t/* daemonize or in any case get pid ! */\n\tif(debug_flag)\n\t\tpid = getpid();\n\telse {\n#ifdef USE_DAEMON\n\t\tif(daemon(0, 0) < 0)\n\t\t\tperror(\"daemon()\");\n\t\tpid = getpid();\n#else\n\t\tpid = daemonize();\n#endif\n\t}\n\n\twritepidfile(pidfilename, pid);\n\n\t/* send M-SEARCH ssdp:all Requests */\n\tssdpDiscoverAll(s_ssdp, 0);\n\tif(s_ssdp6 >= 0)\n\t\tssdpDiscoverAll(s_ssdp6, 1);\n\n\t/* Main loop */\n\twhile(!quitting)\n\t{\n\t\t/* fill readfds fd_set */\n\t\tFD_ZERO(&readfds);\n\t\tif(s_ssdp >= 0) {\n\t\t\tFD_SET(s_ssdp, &readfds);\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif(s_ssdp6 >= 0) {\n\t\t\tFD_SET(s_ssdp6, &readfds);\n\t\t}\n#endif\n\t\tif(s_ifacewatch >= 0) {\n\t\t\tFD_SET(s_ifacewatch, &readfds);\n\t\t}\n\t\tFD_SET(s_unix, &readfds);\n\t\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next)\n\t\t{\n\t\t\tif(req->socket >= 0)\n\t\t\t\tFD_SET(req->socket, &readfds);\n\t\t}\n\t\t/* select call */\n\t\tif(select(FD_SETSIZE, &readfds, 0, 0, 0) < 0)\n\t\t{\n\t\t\tif(errno != EINTR)\n\t\t\t{\n\t\t\t\tsyslog(LOG_ERR, \"select: %m\");\n\t\t\t\tbreak;\t/* quit */\n\t\t\t}\n\t\t\tcontinue;\t/* try again */\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif((s_ssdp6 >= 0) && FD_ISSET(s_ssdp6, &readfds))\n\t\t{\n\t\t\tsendername6_len = sizeof(struct sockaddr_in6);\n\t\t\tn = recvfrom(s_ssdp6, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername6, &sendername6_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\t /* EAGAIN, EWOULDBLOCK, EINTR : silently ignore (try again next time)\n\t\t\t\t  * other errors : log to LOG_ERR */\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Parse and process the packet received */\n\t\t\t\t/*printf(\"%.*s\", n, buf);*/\n\t\t\t\ti = ParseSSDPPacket(s_ssdp6, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername6);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\tif(FD_ISSET(s_ssdp, &readfds))\n\t\t{\n\t\t\tsendername_len = sizeof(struct sockaddr_in);\n\t\t\tn = recvfrom(s_ssdp, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername, &sendername_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\t /* EAGAIN, EWOULDBLOCK, EINTR : silently ignore (try again next time)\n\t\t\t\t  * other errors : log to LOG_ERR */\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Parse and process the packet received */\n\t\t\t\t/*printf(\"%.*s\", n, buf);*/\n\t\t\t\ti = ParseSSDPPacket(s_ssdp, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* processing unix socket requests */\n\t\tfor(req = reqlisthead.lh_first; req;)\n\t\t{\n\t\t\treqnext = req->entries.le_next;\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &readfds))\n\t\t\t{\n\t\t\t\tprocessRequest(req);\n\t\t\t}\n\t\t\tif(req->socket < 0)\n\t\t\t{\n\t\t\t\tLIST_REMOVE(req, entries);\n\t\t\t\tfree(req);\n\t\t\t}\n\t\t\treq = reqnext;\n\t\t}\n\t\t/* processing new requests */\n\t\tif(FD_ISSET(s_unix, &readfds))\n\t\t{\n\t\t\tstruct reqelem * tmp;\n\t\t\ts = accept(s_unix, NULL, NULL);\n\t\t\tif(s<0)\n\t\t\t{\n\t\t\t\tsyslog(LOG_ERR, \"accept(s_unix): %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsyslog(LOG_INFO, \"(s=%d) new request connection\", s);\n\t\t\t\tif(!set_non_blocking(s))\n\t\t\t\t\tsyslog(LOG_WARNING, \"Failed to set new socket non blocking : %m\");\n\t\t\t\ttmp = malloc(sizeof(struct reqelem));\n\t\t\t\tif(!tmp)\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"cannot allocate memory for request\");\n\t\t\t\t\tclose(s);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmp->socket = s;\n\t\t\t\t\tLIST_INSERT_HEAD(&reqlisthead, tmp, entries);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* processing route/network interface config changes */\n\t\tif((s_ifacewatch >= 0) && FD_ISSET(s_ifacewatch, &readfds)) {\n\t\t\tProcessInterfaceWatch(s_ifacewatch, s_ssdp, s_ssdp6, n_if_addr, if_addr);\n\t\t}\n\t}\n\n\t/* closing and cleaning everything */\nquit:\n\tif(s_ssdp >= 0) {\n\t\tclose(s_ssdp);\n\t\ts_ssdp = -1;\n\t}\n#ifdef ENABLE_IPV6\n\tif(s_ssdp6 >= 0) {\n\t\tclose(s_ssdp6);\n\t\ts_ssdp6 = -1;\n\t}\n#endif\n\tif(s_unix >= 0) {\n\t\tclose(s_unix);\n\t\ts_unix = -1;\n\t\tif(unlink(sockpath) < 0)\n\t\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", sockpath);\n\t}\n\tif(s_ifacewatch >= 0) {\n\t\tclose(s_ifacewatch);\n\t\ts_ifacewatch = -1;\n\t}\n\tif(unlink(pidfilename) < 0)\n\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", pidfilename);\n\tcloselog();\n\treturn ret;\n}\n\n"], "fixing_code": ["/* $Id: minissdpd.c,v 1.37 2014/02/28 18:39:11 nanard Exp $ */\n/* MiniUPnP project\n * (c) 2007-2014 Thomas Bernard\n * website : http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n * This software is subject to the conditions detailed\n * in the LICENCE file provided within the distribution */\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <syslog.h>\n#include <ctype.h>\n#include <time.h>\n#include <sys/queue.h>\n/* for chmod : */\n#include <sys/stat.h>\n/* unix sockets */\n#include <sys/un.h>\n/* for getpwnam() and getgrnam() */\n#include <pwd.h>\n#include <grp.h>\n\n#include \"upnputils.h\"\n#include \"openssdpsocket.h\"\n#include \"daemonize.h\"\n#include \"codelength.h\"\n#include \"ifacewatch.h\"\n\n/* current request management stucture */\nstruct reqelem {\n\tint socket;\n\tLIST_ENTRY(reqelem) entries;\n};\n\n/* divice data structures */\nstruct header {\n\tconst char * p; /* string pointer */\n\tint l;          /* string length */\n};\n\n#define HEADER_NT\t0\n#define HEADER_USN\t1\n#define HEADER_LOCATION\t2\n\nstruct device {\n\tstruct device * next;\n\ttime_t t;                 /* validity time */\n\tstruct header headers[3]; /* NT, USN and LOCATION headers */\n\tchar data[];\n};\n\n#define NTS_SSDP_ALIVE\t1\n#define NTS_SSDP_BYEBYE\t2\n#define NTS_SSDP_UPDATE\t3\n\n/* discovered device list kept in memory */\nstruct device * devlist = 0;\n\n/* bootid and configid */\nunsigned int upnp_bootid = 1;\nunsigned int upnp_configid = 1337;\n\nstatic const char *\nnts_to_str(int nts)\n{\n\tswitch(nts)\n\t{\n\tcase NTS_SSDP_ALIVE:\n\t\treturn \"ssdp:alive\";\n\tcase NTS_SSDP_BYEBYE:\n\t\treturn \"ssdp:byebye\";\n\tcase NTS_SSDP_UPDATE:\n\t\treturn \"ssdp:update\";\n\t}\n\treturn \"unknown\";\n}\n\n/* updateDevice() :\n * adds or updates the device to the list.\n * return value :\n *   0 : the device was updated (or nothing done)\n *   1 : the device was new    */\nstatic int\nupdateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist; */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t/*printf(\"found! %d\\n\", (int)(t - p->t));*/\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t/* update Location ! */\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tp = realloc(p, sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\t\t\tif(!p)\t/* allocation error */\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t/* add */\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t}\n\treturn 1;\n}\n\n/* removeDevice() :\n * remove a device from the list\n * return value :\n *    0 : no device removed\n *   -1 : device removed */\nstatic int\nremoveDevice(const struct header * headers)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t/* = devlist */\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_INFO, \"remove device : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\t*pp = p->next;\n\t\t\tfree(p);\n\t\t\treturn -1;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t/* p = p->next; */\n\t}\n\tsyslog(LOG_WARNING, \"device not found for removing : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\treturn 0;\n}\n\n/* SendSSDPMSEARCHResponse() :\n * build and send response to M-SEARCH SSDP packets. */\nstatic void\nSendSSDPMSEARCHResponse(int s, const struct sockaddr * sockname,\n                        const char * st, const char * usn,\n                        const char * server, const char * location)\n{\n\tint l, n;\n\tchar buf[512];\n\tsocklen_t sockname_len;\n\t/*\n\t * follow guideline from document \"UPnP Device Architecture 1.0\"\n\t * uppercase is recommended.\n\t * DATE: is recommended\n\t * SERVER: OS/ver UPnP/1.0 miniupnpd/1.0\n\t * - check what to put in the 'Cache-Control' header\n\t *\n\t * have a look at the document \"UPnP Device Architecture v1.1 */\n\tl = snprintf(buf, sizeof(buf), \"HTTP/1.1 200 OK\\r\\n\"\n\t\t\"CACHE-CONTROL: max-age=120\\r\\n\"\n\t\t/*\"DATE: ...\\r\\n\"*/\n\t\t\"ST: %s\\r\\n\"\n\t\t\"USN: %s\\r\\n\"\n\t\t\"EXT:\\r\\n\"\n\t\t\"SERVER: %s\\r\\n\"\n\t\t\"LOCATION: %s\\r\\n\"\n\t\t\"OPT: \\\"http://schemas.upnp.org/upnp/1/0/\\\"; ns=01\\r\\n\" /* UDA v1.1 */\n\t\t\"01-NLS: %u\\r\\n\" /* same as BOOTID. UDA v1.1 */\n\t\t\"BOOTID.UPNP.ORG: %u\\r\\n\" /* UDA v1.1 */\n\t\t\"CONFIGID.UPNP.ORG: %u\\r\\n\" /* UDA v1.1 */\n\t\t\"\\r\\n\",\n\t\tst, usn,\n\t\tserver, location,\n\t\tupnp_bootid, upnp_bootid, upnp_configid);\n#ifdef ENABLE_IPV6\n\tsockname_len = (sockname->sa_family == PF_INET6)\n\t             ? sizeof(struct sockaddr_in6)\n\t             : sizeof(struct sockaddr_in);\n#else\n\tsockname_len = sizeof(struct sockaddr_in);\n#endif\n\tn = sendto(s, buf, l, 0,\n\t           sockname, sockname_len );\n\tif(n < 0) {\n\t\t/* XXX handle EINTR, EAGAIN, EWOULDBLOCK */\n\t\tsyslog(LOG_ERR, \"sendto(udp): %m\");\n\t}\n}\n\n/* Services stored for answering to M-SEARCH */\nstruct service {\n\tchar * st;\t/* Service type */\n\tchar * usn;\t/* Unique identifier */\n\tchar * server;\t/* Server string */\n\tchar * location;\t/* URL */\n\tLIST_ENTRY(service) entries;\n};\nLIST_HEAD(servicehead, service) servicelisthead;\n\n/* Process M-SEARCH requests */\nstatic void\nprocessMSEARCH(int s, const char * st, int st_len,\n               const struct sockaddr * addr)\n{\n\tstruct service * serv;\n#ifdef ENABLE_IPV6\n\tchar buf[64];\n#endif\n\n\tif(!st || st_len==0)\n\t\treturn;\n#ifdef ENABLE_IPV6\n\tsockaddr_to_string(addr, buf, sizeof(buf));\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s ST:%.*s\",\n\t       buf, st_len, st);\n#else\n\tsyslog(LOG_INFO, \"SSDP M-SEARCH from %s:%d ST: %.*s\",\n\t       inet_ntoa(((const struct sockaddr_in *)addr)->sin_addr),\n\t       ntohs(((const struct sockaddr_in *)addr)->sin_port),\n\t       st_len, st);\n#endif\n\tif(st_len==8 && (0==memcmp(st, \"ssdp:all\", 8))) {\n\t\t/* send a response for all services */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t                        serv->st, serv->usn,\n\t\t\t                        serv->server, serv->location);\n\t\t}\n\t} else if(st_len > 5 && (0==memcmp(st, \"uuid:\", 5))) {\n\t\t/* find a matching UUID value */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->usn, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* find matching services */\n\t\t/* remove version at the end of the ST string */\n\t\tif(st[st_len-2]==':' && isdigit(st[st_len-1]))\n\t\t\tst_len -= 2;\n\t\t/* answer for each matching service */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strncmp(serv->st, st, st_len)) {\n\t\t\t\tSendSSDPMSEARCHResponse(s, addr,\n\t\t\t\t                        serv->st, serv->usn,\n\t\t\t\t                        serv->server, serv->location);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * helper function.\n * reject any non ASCII or non printable character.\n */\nstatic int\ncontainsForbiddenChars(const unsigned char * p, int len)\n{\n\twhile(len > 0) {\n\t\tif(*p < ' ' || *p >= '\\x7f')\n\t\t\treturn 1;\n\t\tp++;\n\t\tlen--;\n\t}\n\treturn 0;\n}\n\n#define METHOD_MSEARCH 1\n#define METHOD_NOTIFY 2\n\n/* ParseSSDPPacket() :\n * parse a received SSDP Packet and call\n * updateDevice() or removeDevice() as needed\n * return value :\n *    -1 : a device was removed\n *     0 : no device removed nor added\n *     1 : a device was added.  */\nstatic int\nParseSSDPPacket(int s, const char * p, ssize_t n,\n                const struct sockaddr * addr)\n{\n\tconst char * linestart;\n\tconst char * lineend;\n\tconst char * nameend;\n\tconst char * valuestart;\n\tstruct header headers[3];\n\tint i, r = 0;\n\tint methodlen;\n\tint nts = -1;\n\tint method = -1;\n\tunsigned int lifetime = 180;\t/* 3 minutes by default */\n\tconst char * st = NULL;\n\tint st_len = 0;\n\n\tmemset(headers, 0, sizeof(headers));\n\tfor(methodlen = 0;\n\t    methodlen < n && (isalpha(p[methodlen]) || p[methodlen]=='-');\n\t\tmethodlen++);\n\tif(methodlen==8 && 0==memcmp(p, \"M-SEARCH\", 8))\n\t\tmethod = METHOD_MSEARCH;\n\telse if(methodlen==6 && 0==memcmp(p, \"NOTIFY\", 6))\n\t\tmethod = METHOD_NOTIFY;\n\telse if(methodlen==4 && 0==memcmp(p, \"HTTP\", 4)) {\n\t\t/* answer to a M-SEARCH => process it as a NOTIFY\n\t\t * with NTS: ssdp:alive */\n\t\tmethod = METHOD_NOTIFY;\n\t\tnts = NTS_SSDP_ALIVE;\n\t}\n\tlinestart = p;\n\twhile(linestart < p + n - 2) {\n\t\t/* start parsing the line : detect line end */\n\t\tlineend = linestart;\n\t\twhile(lineend < p + n && *lineend != '\\n' && *lineend != '\\r')\n\t\t\tlineend++;\n\t\t/*printf(\"line: '%.*s'\\n\", lineend - linestart, linestart);*/\n\t\t/* detect name end : ':' character */\n\t\tnameend = linestart;\n\t\twhile(nameend < lineend && *nameend != ':')\n\t\t\tnameend++;\n\t\t/* detect value */\n\t\tif(nameend < lineend)\n\t\t\tvaluestart = nameend + 1;\n\t\telse\n\t\t\tvaluestart = nameend;\n\t\t/* trim spaces */\n\t\twhile(valuestart < lineend && isspace(*valuestart))\n\t\t\tvaluestart++;\n\t\t/* suppress leading \" if needed */\n\t\tif(valuestart < lineend && *valuestart=='\\\"')\n\t\t\tvaluestart++;\n\t\tif(nameend > linestart && valuestart < lineend) {\n\t\t\tint l = nameend - linestart;\t/* header name length */\n\t\t\tint m = lineend - valuestart;\t/* header value length */\n\t\t\t/* suppress tailing spaces */\n\t\t\twhile(m>0 && isspace(valuestart[m-1]))\n\t\t\t\tm--;\n\t\t\t/* suppress tailing ' if needed */\n\t\t\tif(m>0 && valuestart[m-1] == '\\\"')\n\t\t\t\tm--;\n\t\t\ti = -1;\n\t\t\t/*printf(\"--%.*s: (%d)%.*s--\\n\", l, linestart,\n\t\t\t                           m, m, valuestart);*/\n\t\t\tif(l==2 && 0==strncasecmp(linestart, \"nt\", 2))\n\t\t\t\ti = HEADER_NT;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"usn\", 3))\n\t\t\t\ti = HEADER_USN;\n\t\t\telse if(l==3 && 0==strncasecmp(linestart, \"nts\", 3)) {\n\t\t\t\tif(m==10 && 0==strncasecmp(valuestart, \"ssdp:alive\", 10))\n\t\t\t\t\tnts = NTS_SSDP_ALIVE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:byebye\", 11))\n\t\t\t\t\tnts = NTS_SSDP_BYEBYE;\n\t\t\t\telse if(m==11 && 0==strncasecmp(valuestart, \"ssdp:update\", 11))\n\t\t\t\t\tnts = NTS_SSDP_UPDATE;\n\t\t\t}\n\t\t\telse if(l==8 && 0==strncasecmp(linestart, \"location\", 8))\n\t\t\t\ti = HEADER_LOCATION;\n\t\t\telse if(l==13 && 0==strncasecmp(linestart, \"cache-control\", 13)) {\n\t\t\t\t/* parse \"name1=value1, name_alone, name2=value2\" string */\n\t\t\t\tconst char * name = valuestart;\t/* name */\n\t\t\t\tconst char * val;\t\t\t\t/* value */\n\t\t\t\tint rem = m;\t/* remaining bytes to process */\n\t\t\t\twhile(rem > 0) {\n\t\t\t\t\tval = name;\n\t\t\t\t\twhile(val < name + rem && *val != '=' && *val != ',')\n\t\t\t\t\t\tval++;\n\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif(*val == '=') {\n\t\t\t\t\t\twhile(val < name + rem && (*val == '=' || isspace(*val)))\n\t\t\t\t\t\t\tval++;\n\t\t\t\t\t\tif(val >= name + rem)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif(0==strncasecmp(name, \"max-age\", 7))\n\t\t\t\t\t\t\tlifetime = (unsigned int)strtoul(val, 0, 0);\n\t\t\t\t\t\t/* move to the next name=value pair */\n\t\t\t\t\t\twhile(rem > 0 && *name != ',') {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* skip spaces */\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trem -= (val - name);\n\t\t\t\t\t\tname = val;\n\t\t\t\t\t\twhile(rem > 0 && (*name == ',' || isspace(*name))) {\n\t\t\t\t\t\t\trem--;\n\t\t\t\t\t\t\tname++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*syslog(LOG_DEBUG, \"**%.*s**%u\", m, valuestart, lifetime);*/\n\t\t\t} else if(l==2 && 0==strncasecmp(linestart, \"st\", 2)) {\n\t\t\t\tst = valuestart;\n\t\t\t\tst_len = m;\n\t\t\t\tif(method == METHOD_NOTIFY)\n\t\t\t\t\ti = HEADER_NT;\t/* it was a M-SEARCH response */\n\t\t\t}\n\t\t\tif(i>=0) {\n\t\t\t\theaders[i].p = valuestart;\n\t\t\t\theaders[i].l = m;\n\t\t\t}\n\t\t}\n\t\tlinestart = lineend;\n\t\twhile((*linestart == '\\n' || *linestart == '\\r') && linestart < p + n)\n\t\t\tlinestart++;\n\t}\n#if 0\n\tprintf(\"NTS=%d\\n\", nts);\n\tfor(i=0; i<3; i++) {\n\t\tif(headers[i].p)\n\t\t\tprintf(\"%d-'%.*s'\\n\", i, headers[i].l, headers[i].p);\n\t}\n#endif\n\tsyslog(LOG_DEBUG,\"SSDP request: '%.*s' (%d) %s %s=%.*s\",\n\t       methodlen, p, method, nts_to_str(nts),\n\t       (method==METHOD_NOTIFY)?\"nt\":\"st\",\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].l:st_len,\n\t       (method==METHOD_NOTIFY)?headers[HEADER_NT].p:st);\n\tswitch(method) {\n\tcase METHOD_NOTIFY:\n\t\tif(headers[HEADER_NT].p && headers[HEADER_USN].p && headers[HEADER_LOCATION].p) {\n\t\t\tif(nts==NTS_SSDP_ALIVE) {\n\t\t\t\tr = updateDevice(headers, time(NULL) + lifetime);\n\t\t\t}\n\t\t\telse if(nts==NTS_SSDP_BYEBYE) {\n\t\t\t\tr = removeDevice(headers);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase METHOD_MSEARCH:\n\t\tprocessMSEARCH(s, st, st_len, addr);\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"method %.*s, don't know what to do\", methodlen, p);\n\t}\n\treturn r;\n}\n\n/* OpenUnixSocket()\n * open the unix socket and call bind() and listen()\n * return -1 in case of error */\nstatic int\nOpenUnixSocket(const char * path)\n{\n\tstruct sockaddr_un addr;\n\tint s;\n\tint rv;\n\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif(s < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"socket(AF_UNIX): %m\");\n\t\treturn -1;\n\t}\n\t/* unlink the socket pseudo file before binding */\n\trv = unlink(path);\n\tif(rv < 0 && errno != ENOENT)\n\t{\n\t\tsyslog(LOG_ERR, \"unlink(unixsocket, \\\"%s\\\"): %m\", path);\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\taddr.sun_family = AF_UNIX;\n\tstrncpy(addr.sun_path, path, sizeof(addr.sun_path));\n\tif(bind(s, (struct sockaddr *)&addr,\n\t           sizeof(struct sockaddr_un)) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"bind(unixsocket, \\\"%s\\\"): %m\", path);\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\telse if(listen(s, 5) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"listen(unixsocket): %m\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\t/* Change rights so everyone can communicate with us */\n\tif(chmod(path, 0666) < 0)\n\t{\n\t\tsyslog(LOG_WARNING, \"chmod(\\\"%s\\\"): %m\", path);\n\t}\n\treturn s;\n}\n\n/* processRequest() :\n * process the request coming from a unix socket */\nvoid processRequest(struct reqelem * req)\n{\n\tssize_t n;\n\tunsigned int l, m;\n\tunsigned char buf[2048];\n\tconst unsigned char * p;\n\tint type;\n\tstruct device * d = devlist;\n\tunsigned char rbuf[4096];\n\tunsigned char * rp = rbuf+1;\n\tunsigned char nrep = 0;\n\ttime_t t;\n\tstruct service * newserv = NULL;\n\tstruct service * serv;\n\n\tn = read(req->socket, buf, sizeof(buf));\n\tif(n<0) {\n\t\tif(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)\n\t\t\treturn;\t/* try again later */\n\t\tsyslog(LOG_ERR, \"(s=%d) processRequest(): read(): %m\", req->socket);\n\t\tgoto error;\n\t}\n\tif(n==0) {\n\t\tsyslog(LOG_INFO, \"(s=%d) request connection closed\", req->socket);\n\t\tgoto error;\n\t}\n\tt = time(NULL);\n\ttype = buf[0];\n\tp = buf + 1;\n\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\tif(p+l > buf+n) {\n\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\tgoto error;\n\t}\n\tif(l == 0 && type != 3) {\n\t\tsyslog(LOG_WARNING, \"bad request (length=0)\");\n\t\tgoto error;\n\t}\n\tsyslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\",\n\t       req->socket, type, l, p);\n\tswitch(type) {\n\tcase 1:\t/* request by type */\n\tcase 2:\t/* request by USN (unique id) */\n\tcase 3:\t/* everything */\n\t\twhile(d && (nrep < 255)) {\n\t\t\tif(d->t < t) {\n\t\t\t\tsyslog(LOG_INFO, \"outdated device\");\n\t\t\t} else {\n\t\t\t\t/* test if we can put more responses in the buffer */\n\t\t\t\tif(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l\n\t\t\t\t  + d->headers[HEADER_USN].l + 6\n\t\t\t\t  + (rp - rbuf) >= (int)sizeof(rbuf))\n\t\t\t\t\tbreak;\n\t\t\t\tif( (type==1 && 0==memcmp(d->headers[HEADER_NT].p, p, l))\n\t\t\t\t  ||(type==2 && 0==memcmp(d->headers[HEADER_USN].p, p, l))\n\t\t\t\t  ||(type==3) ) {\n\t\t\t\t\t/* response :\n\t\t\t\t\t * 1 - Location\n\t\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t\t * 3 - usn */\n\t\t\t\t\tm = d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);\n\t\t\t\t\trp += d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tm = d->headers[HEADER_NT].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);\n\t\t\t\t\trp += d->headers[HEADER_NT].l;\n\t\t\t\t\tm = d->headers[HEADER_USN].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);\n\t\t\t\t\trp += d->headers[HEADER_USN].l;\n\t\t\t\t\tnrep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = d->next;\n\t\t}\n\t\t/* Also look in service list */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv && (nrep < 255);\n\t\t    serv = serv->entries.le_next) {\n\t\t\t/* test if we can put more responses in the buffer */\n\t\t\tif(strlen(serv->location) + strlen(serv->st)\n\t\t\t  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))\n\t\t\t  \tbreak;\n\t\t\tif( (type==1 && 0==strncmp(serv->st, (const char *)p, l))\n\t\t\t  ||(type==2 && 0==strncmp(serv->usn, (const char *)p, l))\n\t\t\t  ||(type==3) ) {\n\t\t\t\t/* response :\n\t\t\t\t * 1 - Location\n\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t * 3 - usn */\n\t\t\t\tm = strlen(serv->location);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->location, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->st);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->st, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->usn);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\t\trp += m;\n\t\t\t\tnrep++;\n\t\t\t}\n\t\t}\n\t\trbuf[0] = nrep;\n\t\tsyslog(LOG_DEBUG, \"(s=%d) response : %d device%s\",\n\t\t       req->socket, nrep, (nrep > 1) ? \"s\" : \"\");\n\t\tif(write(req->socket, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase 4:\t/* submit service */\n\t\tnewserv = malloc(sizeof(struct service));\n\t\tif(!newserv) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemset(newserv, 0, sizeof(struct service));\t/* set pointers to NULL */\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (st contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tnewserv->st = malloc(l + 1);\n\t\tif(!newserv->st) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->st, p, l);\n\t\tnewserv->st[l] = '\\0';\n\t\tp += l;\n\t\tif(p >= buf + n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (missing usn)\");\n\t\t\tgoto error;\n\t\t}\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (usn contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"usn='%.*s'\", l, p);\n\t\tnewserv->usn = malloc(l + 1);\n\t\tif(!newserv->usn) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->usn, p, l);\n\t\tnewserv->usn[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (server contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"server='%.*s'\", l, p);\n\t\tnewserv->server = malloc(l + 1);\n\t\tif(!newserv->server) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->server, p, l);\n\t\tnewserv->server[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (location contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"location='%.*s'\", l, p);\n\t\tnewserv->location = malloc(l + 1);\n\t\tif(!newserv->location) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->location, p, l);\n\t\tnewserv->location[l] = '\\0';\n\t\t/* look in service list for duplicate */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strcmp(newserv->usn, serv->usn)\n\t\t\t  && 0 == strcmp(newserv->st, serv->st)) {\n\t\t\t\tsyslog(LOG_INFO, \"Service allready in the list. Updating...\");\n\t\t\t\tfree(newserv->st);\n\t\t\t\tfree(newserv->usn);\n\t\t\t\tfree(serv->server);\n\t\t\t\tserv->server = newserv->server;\n\t\t\t\tfree(serv->location);\n\t\t\t\tserv->location = newserv->location;\n\t\t\t\tfree(newserv);\n\t\t\t\tnewserv = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* Inserting new service */\n\t\tLIST_INSERT_HEAD(&servicelisthead, newserv, entries);\n\t\tnewserv = NULL;\n\t\t/*rbuf[0] = '\\0';\n\t\tif(write(req->socket, rbuf, 1) < 0)\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t*/\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"Unknown request type %d\", type);\n\t\trbuf[0] = '\\0';\n\t\tif(write(req->socket, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn;\nerror:\n\tif(newserv) {\n\t\tfree(newserv->st);\n\t\tfree(newserv->usn);\n\t\tfree(newserv->server);\n\t\tfree(newserv->location);\n\t\tfree(newserv);\n\t\tnewserv = NULL;\n\t}\n\tclose(req->socket);\n\treq->socket = -1;\n\treturn;\n}\n\nstatic volatile sig_atomic_t quitting = 0;\n/* SIGTERM signal handler */\nstatic void\nsigterm(int sig)\n{\n\t(void)sig;\n\t/*int save_errno = errno;*/\n\t/*signal(sig, SIG_IGN);*/\n#if 0\n\t/* calling syslog() is forbidden in a signal handler according to\n\t * signal(3) */\n\tsyslog(LOG_NOTICE, \"received signal %d, good-bye\", sig);\n#endif\n\tquitting = 1;\n\t/*errno = save_errno;*/\n}\n\n#define PORT 1900\n#define XSTR(s) STR(s)\n#define STR(s) #s\n#define UPNP_MCAST_ADDR \"239.255.255.250\"\n/* for IPv6 */\n#define UPNP_MCAST_LL_ADDR \"FF02::C\" /* link-local */\n#define UPNP_MCAST_SL_ADDR \"FF05::C\" /* site-local */\n\n/* send the M-SEARCH request for all devices */\nvoid ssdpDiscoverAll(int s, int ipv6)\n{\n\tstatic const char MSearchMsgFmt[] =\n\t\"M-SEARCH * HTTP/1.1\\r\\n\"\n\t\"HOST: %s:\" XSTR(PORT) \"\\r\\n\"\n\t\"ST: ssdp:all\\r\\n\"\n\t\"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n\t\"MX: %u\\r\\n\"\n\t\"\\r\\n\";\n\tchar bufr[512];\n\tint n;\n\tint mx = 3;\n\tint linklocal = 1;\n\tstruct sockaddr_storage sockudp_w;\n\n\t{\n\t\tn = snprintf(bufr, sizeof(bufr),\n\t\t             MSearchMsgFmt,\n\t\t             ipv6 ?\n\t\t             (linklocal ? \"[\" UPNP_MCAST_LL_ADDR \"]\" :  \"[\" UPNP_MCAST_SL_ADDR \"]\")\n\t\t             : UPNP_MCAST_ADDR, mx);\n\t\tmemset(&sockudp_w, 0, sizeof(struct sockaddr_storage));\n\t\tif(ipv6) {\n\t\t\tstruct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockudp_w;\n\t\t\tp->sin6_family = AF_INET6;\n\t\t\tp->sin6_port = htons(PORT);\n\t\t\tinet_pton(AF_INET6,\n\t\t\t          linklocal ? UPNP_MCAST_LL_ADDR : UPNP_MCAST_SL_ADDR,\n\t\t\t          &(p->sin6_addr));\n\t\t} else {\n\t\t\tstruct sockaddr_in * p = (struct sockaddr_in *)&sockudp_w;\n\t\t\tp->sin_family = AF_INET;\n\t\t\tp->sin_port = htons(PORT);\n\t\t\tp->sin_addr.s_addr = inet_addr(UPNP_MCAST_ADDR);\n\t\t}\n\n\t\tn = sendto(s, bufr, n, 0, (const struct sockaddr *)&sockudp_w,\n\t\t           ipv6 ? sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n\t\tif (n < 0) {\n\t\t\t/* XXX : EINTR EWOULDBLOCK EAGAIN */\n\t\t\tsyslog(LOG_ERR, \"sendto: %m\");\n\t\t}\n\t}\n}\n\n/* main(): program entry point */\nint main(int argc, char * * argv)\n{\n\tint ret = 0;\n\tint pid;\n\tstruct sigaction sa;\n\tchar buf[1500];\n\tssize_t n;\n\tint s_ssdp = -1;\t/* udp socket receiving ssdp packets */\n#ifdef ENABLE_IPV6\n\tint s_ssdp6 = -1;\t/* udp socket receiving ssdp packets IPv6*/\n#else\n#define s_ssdp6 (-1)\n#endif\n\tint s_unix = -1;\t/* unix socket communicating with clients */\n\tint s_ifacewatch = -1;\t/* socket to receive Route / network interface config changes */\n\tint s;\n\tLIST_HEAD(reqstructhead, reqelem) reqlisthead;\n\tstruct reqelem * req;\n\tstruct reqelem * reqnext;\n\tfd_set readfds;\n\tconst char * if_addr[MAX_IF_ADDR];\n\tint n_if_addr = 0;\n\tint i;\n\tconst char * sockpath = \"/var/run/minissdpd.sock\";\n\tconst char * pidfilename = \"/var/run/minissdpd.pid\";\n\tint debug_flag = 0;\n\tint ipv6 = 0;\n\tint deltadev = 0;\n\tstruct sockaddr_in sendername;\n\tsocklen_t sendername_len;\n#ifdef ENABLE_IPV6\n\tstruct sockaddr_in6 sendername6;\n\tsocklen_t sendername6_len;\n#endif\n\n\tLIST_INIT(&reqlisthead);\n\tLIST_INIT(&servicelisthead);\n\t/* process command line */\n\tfor(i=1; i<argc; i++)\n\t{\n\t\tif(0==strcmp(argv[i], \"-i\")) {\n\t\t\tif(n_if_addr < MAX_IF_ADDR)\n\t\t\t\tif_addr[n_if_addr++] = argv[++i];\n\t\t\telse\n\t\t\t\tsyslog(LOG_WARNING, \"Max number of interface address set to %d, \"\n\t\t\t\t       \"ignoring %s\", MAX_IF_ADDR, argv[++i]);\n\t\t} else if(0==strcmp(argv[i], \"-d\"))\n\t\t\tdebug_flag = 1;\n\t\telse if(0==strcmp(argv[i], \"-s\"))\n\t\t\tsockpath = argv[++i];\n\t\telse if(0==strcmp(argv[i], \"-p\"))\n\t\t\tpidfilename = argv[++i];\n#ifdef ENABLE_IPV6\n\t\telse if(0==strcmp(argv[i], \"-6\"))\n\t\t\tipv6 = 1;\n#endif\n\t}\n\tif(n_if_addr < 1)\n\t{\n\t\tfprintf(stderr,\n\t\t        \"Usage: %s [-d] [-6] [-s socket] [-p pidfile] \"\n\t\t\t\t\"-i <interface> [-i <interface2>] ...\\n\",\n\t\t        argv[0]);\n\t\tfprintf(stderr,\n\t\t        \"\\n  <interface> is either an IPv4 address such as 192.168.1.42, or an\\ninterface name such as eth0.\\n\");\n\t\tfprintf(stderr,\n\t\t        \"\\n  By default, socket will be open as %s\\n\"\n\t\t        \"and pid written to file %s\\n\",\n\t\t        sockpath, pidfilename);\n\t\treturn 1;\n\t}\n\n\t/* open log */\n\topenlog(\"minissdpd\",\n\t        LOG_CONS|LOG_PID|(debug_flag?LOG_PERROR:0),\n\t\t\tLOG_MINISSDPD);\n\tif(!debug_flag) /* speed things up and ignore LOG_INFO and LOG_DEBUG */\n\t\tsetlogmask(LOG_UPTO(LOG_NOTICE));\n\n\tif(checkforrunning(pidfilename) < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"MiniSSDPd is already running. EXITING\");\n\t\treturn 1;\n\t}\n\n\t/* set signal handlers */\n\tmemset(&sa, 0, sizeof(struct sigaction));\n\tsa.sa_handler = sigterm;\n\tif(sigaction(SIGTERM, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGTERM handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\tif(sigaction(SIGINT, &sa, NULL))\n\t{\n\t\tsyslog(LOG_ERR, \"Failed to set SIGINT handler. EXITING\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\t/* open route/interface config changes socket */\n\ts_ifacewatch = OpenAndConfInterfaceWatchSocket();\n\t/* open UDP socket(s) for receiving SSDP packets */\n\ts_ssdp = OpenAndConfSSDPReceiveSocket(n_if_addr, if_addr, 0);\n\tif(s_ssdp < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages, exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n#ifdef ENABLE_IPV6\n\tif(ipv6) {\n\t\ts_ssdp6 = OpenAndConfSSDPReceiveSocket(n_if_addr, if_addr, 1);\n\t\tif(s_ssdp6 < 0)\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Cannot open socket for receiving SSDP messages (IPv6), exiting\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\n\t/* Open Unix socket to communicate with other programs on\n\t * the same machine */\n\ts_unix = OpenUnixSocket(sockpath);\n\tif(s_unix < 0)\n\t{\n\t\tsyslog(LOG_ERR, \"Cannot open unix socket for communicating with clients. Exiting\");\n\t\tret = 1;\n\t\tgoto quit;\n\t}\n\n\t/* drop privileges */\n#if 0\n\t/* if we drop privileges, how to unlink(/var/run/minissdpd.sock) ? */\n\tif(getuid() == 0) {\n\t\tstruct passwd * user;\n\t\tstruct group * group;\n\t\tuser = getpwnam(\"nobody\");\n\t\tif(!user) {\n\t\t\tsyslog(LOG_ERR, \"getpwnam(\\\"%s\\\") : %m\", \"nobody\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tgroup = getgrnam(\"nogroup\");\n\t\tif(!group) {\n\t\t\tsyslog(LOG_ERR, \"getgrnam(\\\"%s\\\") : %m\", \"nogroup\");\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setgid(group->gr_gid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setgit(%d) : %m\", group->gr_gid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif(setuid(user->pw_uid) < 0) {\n\t\t\tsyslog(LOG_ERR, \"setuid(%d) : %m\", user->pw_uid);\n\t\t\tret = 1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n#endif\n\n\t/* daemonize or in any case get pid ! */\n\tif(debug_flag)\n\t\tpid = getpid();\n\telse {\n#ifdef USE_DAEMON\n\t\tif(daemon(0, 0) < 0)\n\t\t\tperror(\"daemon()\");\n\t\tpid = getpid();\n#else\n\t\tpid = daemonize();\n#endif\n\t}\n\n\twritepidfile(pidfilename, pid);\n\n\t/* send M-SEARCH ssdp:all Requests */\n\tssdpDiscoverAll(s_ssdp, 0);\n\tif(s_ssdp6 >= 0)\n\t\tssdpDiscoverAll(s_ssdp6, 1);\n\n\t/* Main loop */\n\twhile(!quitting)\n\t{\n\t\t/* fill readfds fd_set */\n\t\tFD_ZERO(&readfds);\n\t\tif(s_ssdp >= 0) {\n\t\t\tFD_SET(s_ssdp, &readfds);\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif(s_ssdp6 >= 0) {\n\t\t\tFD_SET(s_ssdp6, &readfds);\n\t\t}\n#endif\n\t\tif(s_ifacewatch >= 0) {\n\t\t\tFD_SET(s_ifacewatch, &readfds);\n\t\t}\n\t\tFD_SET(s_unix, &readfds);\n\t\tfor(req = reqlisthead.lh_first; req; req = req->entries.le_next)\n\t\t{\n\t\t\tif(req->socket >= 0)\n\t\t\t\tFD_SET(req->socket, &readfds);\n\t\t}\n\t\t/* select call */\n\t\tif(select(FD_SETSIZE, &readfds, 0, 0, 0) < 0)\n\t\t{\n\t\t\tif(errno != EINTR)\n\t\t\t{\n\t\t\t\tsyslog(LOG_ERR, \"select: %m\");\n\t\t\t\tbreak;\t/* quit */\n\t\t\t}\n\t\t\tcontinue;\t/* try again */\n\t\t}\n#ifdef ENABLE_IPV6\n\t\tif((s_ssdp6 >= 0) && FD_ISSET(s_ssdp6, &readfds))\n\t\t{\n\t\t\tsendername6_len = sizeof(struct sockaddr_in6);\n\t\t\tn = recvfrom(s_ssdp6, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername6, &sendername6_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\t /* EAGAIN, EWOULDBLOCK, EINTR : silently ignore (try again next time)\n\t\t\t\t  * other errors : log to LOG_ERR */\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Parse and process the packet received */\n\t\t\t\t/*printf(\"%.*s\", n, buf);*/\n\t\t\t\ti = ParseSSDPPacket(s_ssdp6, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername6);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\tif(FD_ISSET(s_ssdp, &readfds))\n\t\t{\n\t\t\tsendername_len = sizeof(struct sockaddr_in);\n\t\t\tn = recvfrom(s_ssdp, buf, sizeof(buf), 0,\n\t\t\t             (struct sockaddr *)&sendername, &sendername_len);\n\t\t\tif(n<0)\n\t\t\t{\n\t\t\t\t /* EAGAIN, EWOULDBLOCK, EINTR : silently ignore (try again next time)\n\t\t\t\t  * other errors : log to LOG_ERR */\n\t\t\t\tif(errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)\n\t\t\t\t\tsyslog(LOG_ERR, \"recvfrom: %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Parse and process the packet received */\n\t\t\t\t/*printf(\"%.*s\", n, buf);*/\n\t\t\t\ti = ParseSSDPPacket(s_ssdp, buf, n,\n\t\t\t\t                    (struct sockaddr *)&sendername);\n\t\t\t\tsyslog(LOG_DEBUG, \"** i=%d deltadev=%d **\", i, deltadev);\n\t\t\t\tif(i==0 || (i*deltadev < 0))\n\t\t\t\t{\n\t\t\t\t\tif(deltadev > 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d new devices added\", deltadev);\n\t\t\t\t\telse if(deltadev < 0)\n\t\t\t\t\t\tsyslog(LOG_NOTICE, \"%d devices removed (good-bye!)\", -deltadev);\n\t\t\t\t\tdeltadev = i;\n\t\t\t\t}\n\t\t\t\telse if((i*deltadev) >= 0)\n\t\t\t\t{\n\t\t\t\t\tdeltadev += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* processing unix socket requests */\n\t\tfor(req = reqlisthead.lh_first; req;)\n\t\t{\n\t\t\treqnext = req->entries.le_next;\n\t\t\tif((req->socket >= 0) && FD_ISSET(req->socket, &readfds))\n\t\t\t{\n\t\t\t\tprocessRequest(req);\n\t\t\t}\n\t\t\tif(req->socket < 0)\n\t\t\t{\n\t\t\t\tLIST_REMOVE(req, entries);\n\t\t\t\tfree(req);\n\t\t\t}\n\t\t\treq = reqnext;\n\t\t}\n\t\t/* processing new requests */\n\t\tif(FD_ISSET(s_unix, &readfds))\n\t\t{\n\t\t\tstruct reqelem * tmp;\n\t\t\ts = accept(s_unix, NULL, NULL);\n\t\t\tif(s<0)\n\t\t\t{\n\t\t\t\tsyslog(LOG_ERR, \"accept(s_unix): %m\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsyslog(LOG_INFO, \"(s=%d) new request connection\", s);\n\t\t\t\tif(!set_non_blocking(s))\n\t\t\t\t\tsyslog(LOG_WARNING, \"Failed to set new socket non blocking : %m\");\n\t\t\t\ttmp = malloc(sizeof(struct reqelem));\n\t\t\t\tif(!tmp)\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"cannot allocate memory for request\");\n\t\t\t\t\tclose(s);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmp->socket = s;\n\t\t\t\t\tLIST_INSERT_HEAD(&reqlisthead, tmp, entries);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* processing route/network interface config changes */\n\t\tif((s_ifacewatch >= 0) && FD_ISSET(s_ifacewatch, &readfds)) {\n\t\t\tProcessInterfaceWatch(s_ifacewatch, s_ssdp, s_ssdp6, n_if_addr, if_addr);\n\t\t}\n\t}\n\n\t/* closing and cleaning everything */\nquit:\n\tif(s_ssdp >= 0) {\n\t\tclose(s_ssdp);\n\t\ts_ssdp = -1;\n\t}\n#ifdef ENABLE_IPV6\n\tif(s_ssdp6 >= 0) {\n\t\tclose(s_ssdp6);\n\t\ts_ssdp6 = -1;\n\t}\n#endif\n\tif(s_unix >= 0) {\n\t\tclose(s_unix);\n\t\ts_unix = -1;\n\t\tif(unlink(sockpath) < 0)\n\t\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", sockpath);\n\t}\n\tif(s_ifacewatch >= 0) {\n\t\tclose(s_ifacewatch);\n\t\ts_ifacewatch = -1;\n\t}\n\tif(unlink(pidfilename) < 0)\n\t\tsyslog(LOG_ERR, \"unlink(%s): %m\", pidfilename);\n\tcloselog();\n\treturn ret;\n}\n\n"], "filenames": ["minissdpd/minissdpd.c"], "buggy_code_start_loc": [660], "buggy_code_end_loc": [660], "fixing_code_start_loc": [661], "fixing_code_end_loc": [662], "type": "CWE-416", "message": "The processRequest function in minissdpd.c in MiniSSDPd 1.2.20130907-3 allows local users to cause a denial of service (invalid free and daemon crash) via vectors related to error handling.", "other": {"cve": {"id": "CVE-2016-3179", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-24T15:59:00.637", "lastModified": "2021-04-19T15:06:22.410", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The processRequest function in minissdpd.c in MiniSSDPd 1.2.20130907-3 allows local users to cause a denial of service (invalid free and daemon crash) via vectors related to error handling."}, {"lang": "es", "value": "La funci\u00f3n processRequest en minissdpd.c en MiniSSDPd 1.2.20130907-3 permite a los usuarios locales causar una denegaci\u00f3n de servicio ((liberaci\u00f3n no valida y ca\u00edda) a trav\u00e9s de vectores relacionados con el manejo de errores."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:miniupnp_project:minissdpd:1.2.20130907-3:*:*:*:*:*:*:*", "matchCriteriaId": "7DC6953D-FC60-4181-AB76-4722408AC1E9"}]}]}], "references": [{"url": "http://speirofr.appspot.com/files/advisory/SPADV-2016-02.md", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/03/16/13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=816759", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/miniupnp/miniupnp/commit/140ee8d2204b383279f854802b27bdb41c1d5d1a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/miniupnp/miniupnp/commit/140ee8d2204b383279f854802b27bdb41c1d5d1a"}}