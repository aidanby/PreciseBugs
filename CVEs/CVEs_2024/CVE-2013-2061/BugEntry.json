{"buggy_code": ["/*\n *  OpenVPN -- An application to securely tunnel IP networks\n *             over a single UDP port, with support for SSL/TLS-based\n *             session authentication and key exchange,\n *             packet encryption, packet authentication, and\n *             packet compression.\n *\n *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program (see the file COPYING included with this\n *  distribution); if not, write to the Free Software Foundation, Inc.,\n *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef BUFFER_H\n#define BUFFER_H\n\n#include \"basic.h\"\n#include \"error.h\"\n\n#define BUF_SIZE_MAX 1000000\n\n/*\n * Define verify_align function, otherwise\n * it will be a noop.\n */\n/* #define VERIFY_ALIGNMENT */\n\n/*\n * Keep track of source file/line of buf_init calls\n */\n#ifdef VERIFY_ALIGNMENT\n#define BUF_INIT_TRACKING\n#endif\n\n/**************************************************************************/\n/**\n * Wrapper structure for dynamically allocated memory.\n *\n * The actual content stored in a \\c buffer structure starts at the memory\n * location \\c buffer.data \\c + \\c buffer.offset, and has a length of \\c\n * buffer.len bytes.  This, together with the space available before and\n * after the content, is represented in the pseudocode below:\n@code\nuint8_t *content_start    = buffer.data + buffer.offset;\nuint8_t *content_end      = buffer.data + buffer.offset + buffer.len;\nint      prepend_capacity = buffer.offset;\nint      append_capacity  = buffer.capacity - (buffer.offset + buffer.len);\n@endcode\n */\nstruct buffer\n{\n  int capacity;                 /**< Size in bytes of memory allocated by\n                                 *   \\c malloc(). */\n  int offset;                   /**< Offset in bytes of the actual content\n                                 *   within the allocated memory. */\n  int len;                      /**< Length in bytes of the actual content\n                                 *   within the allocated memory. */\n  uint8_t *data;                /**< Pointer to the allocated memory. */\n\n#ifdef BUF_INIT_TRACKING\n  const char *debug_file;\n  int debug_line;\n#endif\n};\n\n\n/**************************************************************************/\n/**\n * Garbage collection entry for one dynamically allocated block of memory.\n *\n * This structure represents one link in the linked list contained in a \\c\n * gc_arena structure.  Each time the \\c gc_malloc() function is called,\n * it allocates \\c sizeof(gc_entry) + the requested number of bytes.  The\n * \\c gc_entry is then stored as a header in front of the memory address\n * returned to the caller.\n */\nstruct gc_entry\n{\n  struct gc_entry *next;        /**< Pointer to the next item in the\n                                 *   linked list. */\n};\n\n\n/**\n * Garbage collection arena used to keep track of dynamically allocated\n * memory.\n *\n * This structure contains a linked list of \\c gc_entry structures.  When\n * a block of memory is allocated using the \\c gc_malloc() function, the\n * allocation is registered in the function's \\c gc_arena argument.  All\n * the dynamically allocated memory registered in a \\c gc_arena can be\n * freed using the \\c gc_free() function.\n */\nstruct gc_arena\n{\n  struct gc_entry *list;        /**< First element of the linked list of\n                                 *   \\c gc_entry structures. */\n};\n\n\n#define BPTR(buf)  (buf_bptr(buf))\n#define BEND(buf)  (buf_bend(buf))\n#define BLAST(buf) (buf_blast(buf))\n#define BLEN(buf)  (buf_len(buf))\n#define BDEF(buf)  (buf_defined(buf))\n#define BSTR(buf)  (buf_str(buf))\n#define BCAP(buf)  (buf_forward_capacity (buf))\n\nvoid buf_clear (struct buffer *buf);\n\nstruct buffer clear_buf (void);\nvoid free_buf (struct buffer *buf);\n\nbool buf_assign (struct buffer *dest, const struct buffer *src);\n\nvoid string_clear (char *str);\nint string_array_len (const char **array);\n\nsize_t array_mult_safe (const size_t m1, const size_t m2, const size_t extra);\n\n#define PA_BRACKET (1<<0)\nchar *print_argv (const char **p, struct gc_arena *gc, const unsigned int flags);\n\nvoid buf_size_error (const size_t size);\n\n/* for dmalloc debugging */\n\n#ifdef DMALLOC\n\n#define alloc_buf(size)               alloc_buf_debug (size, __FILE__, __LINE__)\n#define alloc_buf_gc(size, gc)        alloc_buf_gc_debug (size, gc, __FILE__, __LINE__);\n#define clone_buf(buf)                clone_buf_debug (buf, __FILE__, __LINE__);\n#define gc_malloc(size, clear, arena) gc_malloc_debug (size, clear, arena, __FILE__, __LINE__)\n#define string_alloc(str, gc)         string_alloc_debug (str, gc, __FILE__, __LINE__)\n#define string_alloc_buf(str, gc)     string_alloc_buf_debug (str, gc, __FILE__, __LINE__)\n\nstruct buffer alloc_buf_debug (size_t size, const char *file, int line);\nstruct buffer alloc_buf_gc_debug (size_t size, struct gc_arena *gc, const char *file, int line);\nstruct buffer clone_buf_debug (const struct buffer* buf, const char *file, int line);\nvoid *gc_malloc_debug (size_t size, bool clear, struct gc_arena *a, const char *file, int line);\nchar *string_alloc_debug (const char *str, struct gc_arena *gc, const char *file, int line);\nstruct buffer string_alloc_buf_debug (const char *str, struct gc_arena *gc, const char *file, int line);\n\n#else\n\nstruct buffer alloc_buf (size_t size);\nstruct buffer alloc_buf_gc (size_t size, struct gc_arena *gc); /* allocate buffer with garbage collection */\nstruct buffer clone_buf (const struct buffer* buf);\nvoid *gc_malloc (size_t size, bool clear, struct gc_arena *a);\nchar *string_alloc (const char *str, struct gc_arena *gc);\nstruct buffer string_alloc_buf (const char *str, struct gc_arena *gc);\n\n#endif\n\n#ifdef BUF_INIT_TRACKING\n#define buf_init(buf, offset) buf_init_debug (buf, offset, __FILE__, __LINE__)\nbool buf_init_debug (struct buffer *buf, int offset, const char *file, int line);\n#else\n#define buf_init(buf, offset) buf_init_dowork (buf, offset)\n#endif\n\n\n/* inline functions */\n\nstatic inline bool\nbuf_defined (const struct buffer *buf)\n{\n  return buf->data != NULL;\n}\n\nstatic inline bool\nbuf_valid (const struct buffer *buf)\n{\n  return likely (buf->data != NULL) && likely (buf->len >= 0);\n}\n\nstatic inline uint8_t *\nbuf_bptr (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    return buf->data + buf->offset;\n  else\n    return NULL;\n}\n\nstatic int\nbuf_len (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    return buf->len;\n  else\n    return 0;\n}\n\nstatic inline uint8_t *\nbuf_bend (const struct buffer *buf)\n{\n  return buf_bptr (buf) + buf_len (buf);\n}\n\nstatic inline uint8_t *\nbuf_blast (const struct buffer *buf)\n{\n  if (buf_len (buf) > 0)\n    return buf_bptr (buf) + buf_len (buf) - 1;\n  else\n    return NULL;\n}\n\nstatic inline bool\nbuf_size_valid (const size_t size)\n{\n  return likely (size < BUF_SIZE_MAX);\n}\n\nstatic inline bool\nbuf_size_valid_signed (const int size)\n{\n  return likely (size >= -BUF_SIZE_MAX) && likely (size < BUF_SIZE_MAX);\n}\n\nstatic inline char *\nbuf_str (const struct buffer *buf)\n{\n  return (char *)buf_bptr(buf);\n}\n\nstatic inline void\nbuf_reset (struct buffer *buf)\n{\n  buf->capacity = 0;\n  buf->offset = 0;\n  buf->len = 0;\n  buf->data = NULL;\n}\n\nstatic inline void\nbuf_reset_len (struct buffer *buf)\n{\n  buf->len = 0;\n  buf->offset = 0;\n}\n\nstatic inline bool\nbuf_init_dowork (struct buffer *buf, int offset)\n{\n  if (offset < 0 || offset > buf->capacity || buf->data == NULL)\n    return false;\n  buf->len = 0;\n  buf->offset = offset;\n  return true;\n}\n\nstatic inline void\nbuf_set_write (struct buffer *buf, uint8_t *data, int size)\n{\n  if (!buf_size_valid (size))\n    buf_size_error (size);\n  buf->len = 0;\n  buf->offset = 0;\n  buf->capacity = size;\n  buf->data = data;\n  if (size > 0 && data)\n    *data = 0;\n}\n\nstatic inline void\nbuf_set_read (struct buffer *buf, const uint8_t *data, int size)\n{\n  if (!buf_size_valid (size))\n    buf_size_error (size);\n  buf->len = buf->capacity = size;\n  buf->offset = 0;\n  buf->data = (uint8_t *)data;\n}\n\n/* Like strncpy but makes sure dest is always null terminated */\nstatic inline void\nstrncpynt (char *dest, const char *src, size_t maxlen)\n{\n  strncpy (dest, src, maxlen);\n  if (maxlen > 0)\n    dest[maxlen - 1] = 0;\n}\n\n/* return true if string contains at least one numerical digit */\nstatic inline bool\nhas_digit (const unsigned char* src)\n{\n  unsigned char c;\n  while ((c = *src++))\n    {\n      if (isdigit(c))\n\treturn true;\n    }\n  return false;\n}\n\n/*\n * printf append to a buffer with overflow check\n */\nbool buf_printf (struct buffer *buf, const char *format, ...)\n#ifdef __GNUC__\n#if __USE_MINGW_ANSI_STDIO\n\t__attribute__ ((format (gnu_printf, 2, 3)))\n#else\n\t__attribute__ ((format (__printf__, 2, 3)))\n#endif\n#endif\n    ;\n\n/*\n * puts append to a buffer with overflow check\n */\nbool buf_puts (struct buffer *buf, const char *str);\n\n/*\n * Like snprintf but guarantees null termination for size > 0\n */\nbool openvpn_snprintf(char *str, size_t size, const char *format, ...)\n#ifdef __GNUC__\n#if __USE_MINGW_ANSI_STDIO\n\t__attribute__ ((format (gnu_printf, 3, 4)))\n#else\n\t__attribute__ ((format (__printf__, 3, 4)))\n#endif\n#endif\n    ;\n\n/*\n * remove/add trailing characters\n */\n\nvoid buf_null_terminate (struct buffer *buf);\nvoid buf_chomp (struct buffer *buf);\nvoid buf_rmtail (struct buffer *buf, uint8_t remove);\n\n/*\n * non-buffer string functions\n */\nvoid chomp (char *str);\nvoid rm_trailing_chars (char *str, const char *what_to_delete);\nconst char *skip_leading_whitespace (const char *str);\nvoid string_null_terminate (char *str, int len, int capacity);\n\n/*\n * Write string in buf to file descriptor fd.\n * NOTE: requires that string be null terminated.\n */\nvoid buf_write_string_file (const struct buffer *buf, const char *filename, int fd);\n\n/*\n * write a string to the end of a buffer that was\n * truncated by buf_printf\n */\nvoid buf_catrunc (struct buffer *buf, const char *str);\n\n/*\n * convert a multi-line output to one line\n */\nvoid convert_to_one_line (struct buffer *buf);\n\n/*\n * Parse a string based on a given delimiter char\n */\nbool buf_parse (struct buffer *buf, const int delim, char *line, const int size);\n\n/*\n * Hex dump -- Output a binary buffer to a hex string and return it.\n */\nchar *\nformat_hex_ex (const uint8_t *data, int size, int maxoutput,\n\t       int space_break, const char* separator,\n\t       struct gc_arena *gc);\n\nstatic inline char *\nformat_hex (const uint8_t *data, int size, int maxoutput, struct gc_arena *gc)\n{\n  return format_hex_ex (data, size, maxoutput, 4, \" \", gc);\n}\n\n/*\n * Return a buffer that is a subset of another buffer.\n */\nstruct buffer buf_sub (struct buffer *buf, int size, bool prepend);\n\n/*\n * Check if sufficient space to append to buffer.\n */\n\nstatic inline bool\nbuf_safe (const struct buffer *buf, int len)\n{\n  return buf_valid (buf) && buf_size_valid (len)\n    && buf->offset + buf->len + len <= buf->capacity;\n}\n\nstatic inline bool\nbuf_safe_bidir (const struct buffer *buf, int len)\n{\n  if (buf_valid (buf) && buf_size_valid_signed (len))\n    {\n      const int newlen = buf->len + len;\n      return newlen >= 0 && buf->offset + newlen <= buf->capacity;\n    }\n  else\n    return false;\n}\n\nstatic inline int\nbuf_forward_capacity (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    {\n      int ret = buf->capacity - (buf->offset + buf->len);\n      if (ret < 0)\n\tret = 0;\n      return ret;\n    }\n  else\n    return 0;\n}\n\nstatic inline int\nbuf_forward_capacity_total (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    {\n      int ret = buf->capacity - buf->offset;\n      if (ret < 0)\n\tret = 0;\n      return ret;\n    }\n  else\n    return 0;\n}\n\nstatic inline int\nbuf_reverse_capacity (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    return buf->offset;\n  else\n    return 0;\n}\n\nstatic inline bool\nbuf_inc_len (struct buffer *buf, int inc)\n{\n  if (!buf_safe_bidir (buf, inc))\n    return false;\n  buf->len += inc;\n  return true;\n}\n\n/*\n * Make space to prepend to a buffer.\n * Return NULL if no space.\n */\n\nstatic inline uint8_t *\nbuf_prepend (struct buffer *buf, int size)\n{\n  if (!buf_valid (buf) || size < 0 || size > buf->offset)\n    return NULL;\n  buf->offset -= size;\n  buf->len += size;\n  return BPTR (buf);\n}\n\nstatic inline bool\nbuf_advance (struct buffer *buf, int size)\n{\n  if (!buf_valid (buf) || size < 0 || buf->len < size)\n    return false;\n  buf->offset += size;\n  buf->len -= size;\n  return true;\n}\n\n/*\n * Return a pointer to allocated space inside a buffer.\n * Return NULL if no space.\n */\n\nstatic inline uint8_t *\nbuf_write_alloc (struct buffer *buf, int size)\n{\n  uint8_t *ret;\n  if (!buf_safe (buf, size))\n    return NULL;\n  ret = BPTR (buf) + buf->len;\n  buf->len += size;\n  return ret;\n}\n\nstatic inline uint8_t *\nbuf_write_alloc_prepend (struct buffer *buf, int size, bool prepend)\n{\n  return prepend ? buf_prepend (buf, size) : buf_write_alloc (buf, size);\n}\n\nstatic inline uint8_t *\nbuf_read_alloc (struct buffer *buf, int size)\n{\n  uint8_t *ret;\n  if (size < 0 || buf->len < size)\n    return NULL;\n  ret = BPTR (buf);\n  buf->offset += size;\n  buf->len -= size;\n  return ret;\n}\n\nstatic inline bool\nbuf_write (struct buffer *dest, const void *src, int size)\n{\n  uint8_t *cp = buf_write_alloc (dest, size);\n  if (!cp)\n    return false;\n  memcpy (cp, src, size);\n  return true;\n}\n\nstatic inline bool\nbuf_write_prepend (struct buffer *dest, const void *src, int size)\n{\n  uint8_t *cp = buf_prepend (dest, size);\n  if (!cp)\n    return false;\n  memcpy (cp, src, size);\n  return true;\n}\n\nstatic inline bool\nbuf_write_u8 (struct buffer *dest, int data)\n{\n  uint8_t u8 = (uint8_t) data;\n  return buf_write (dest, &u8, sizeof (uint8_t));\n}\n\nstatic inline bool\nbuf_write_u16 (struct buffer *dest, int data)\n{\n  uint16_t u16 = htons ((uint16_t) data);\n  return buf_write (dest, &u16, sizeof (uint16_t));\n}\n\nstatic inline bool\nbuf_write_u32 (struct buffer *dest, int data)\n{\n  uint32_t u32 = htonl ((uint32_t) data);\n  return buf_write (dest, &u32, sizeof (uint32_t));\n}\n\nstatic inline bool\nbuf_copy (struct buffer *dest, const struct buffer *src)\n{\n  return buf_write (dest, BPTR (src), BLEN (src));\n}\n\nstatic inline bool\nbuf_copy_n (struct buffer *dest, struct buffer *src, int n)\n{\n  uint8_t *cp = buf_read_alloc (src, n);\n  if (!cp)\n    return false;\n  return buf_write (dest, cp, n);\n}\n\nstatic inline bool\nbuf_copy_range (struct buffer *dest,\n\t\tint dest_index,\n\t\tconst struct buffer *src,\n\t\tint src_index,\n\t\tint src_len)\n{\n  if (src_index < 0\n      || src_len < 0\n      || src_index + src_len > src->len\n      || dest_index < 0\n      || dest->offset + dest_index + src_len > dest->capacity)\n    return false;\n  memcpy (dest->data + dest->offset + dest_index, src->data + src->offset + src_index, src_len);\n  if (dest_index + src_len > dest->len)\n    dest->len = dest_index + src_len;\n  return true;\n}\n\n/* truncate src to len, copy excess data beyond len to dest */\nstatic inline bool\nbuf_copy_excess (struct buffer *dest,\n\t\t struct buffer *src,\n\t\t int len)\n{\n  if (len < 0)\n    return false;\n  if (src->len > len)\n    {\n      struct buffer b = *src;\n      src->len = len;\n      if (!buf_advance (&b, len))\n\treturn false;\n      return buf_copy (dest, &b);\n    }\n  else\n    {\n      return true;\n    }\n}\n\nstatic inline bool\nbuf_read (struct buffer *src, void *dest, int size)\n{\n  uint8_t *cp = buf_read_alloc (src, size);\n  if (!cp)\n    return false;\n  memcpy (dest, cp, size);\n  return true;\n}\n\nstatic inline int\nbuf_read_u8 (struct buffer *buf)\n{\n  int ret;\n  if (BLEN (buf) < 1)\n    return -1;\n  ret = *BPTR(buf);\n  buf_advance (buf, 1);\n  return ret;\n}\n\nstatic inline int\nbuf_read_u16 (struct buffer *buf)\n{\n  uint16_t ret;\n  if (!buf_read (buf, &ret, sizeof (uint16_t)))\n    return -1;\n  return ntohs (ret);\n}\n\nstatic inline uint32_t\nbuf_read_u32 (struct buffer *buf, bool *good)\n{\n  uint32_t ret;\n  if (!buf_read (buf, &ret, sizeof (uint32_t)))\n    {\n      if (good)\n\t*good = false;\n      return 0;\n    }\n  else\n    {\n      if (good)\n\t*good = true;\n      return ntohl (ret);\n    }\n}\n\nstatic inline bool\nbuf_string_match (const struct buffer *src, const void *match, int size)\n{\n  if (size != src->len)\n    return false;\n  return memcmp (BPTR (src), match, size) == 0;\n}\n\nstatic inline bool\nbuf_string_match_head (const struct buffer *src, const void *match, int size)\n{\n  if (size < 0 || size > src->len)\n    return false;\n  return memcmp (BPTR (src), match, size) == 0;\n}\n\nbool buf_string_match_head_str (const struct buffer *src, const char *match);\nbool buf_string_compare_advance (struct buffer *src, const char *match);\nint buf_substring_len (const struct buffer *buf, int delim);\n\n/*\n * Print a string which might be NULL\n */\nconst char *np (const char *str);\n\n/*#define CHARACTER_CLASS_DEBUG*/\n\n/* character classes */\n\n#define CC_ANY                (1<<0)\n#define CC_NULL               (1<<1)\n\n#define CC_ALNUM              (1<<2)\n#define CC_ALPHA              (1<<3)\n#define CC_ASCII              (1<<4)\n#define CC_CNTRL              (1<<5)\n#define CC_DIGIT              (1<<6)\n#define CC_PRINT              (1<<7)\n#define CC_PUNCT              (1<<8)\n#define CC_SPACE              (1<<9)\n#define CC_XDIGIT             (1<<10)\n\n#define CC_BLANK              (1<<11)\n#define CC_NEWLINE            (1<<12)\n#define CC_CR                 (1<<13)\n\n#define CC_BACKSLASH          (1<<14)\n#define CC_UNDERBAR           (1<<15)\n#define CC_DASH               (1<<16)\n#define CC_DOT                (1<<17)\n#define CC_COMMA              (1<<18)\n#define CC_COLON              (1<<19)\n#define CC_SLASH              (1<<20)\n#define CC_SINGLE_QUOTE       (1<<21)\n#define CC_DOUBLE_QUOTE       (1<<22)\n#define CC_REVERSE_QUOTE      (1<<23)\n#define CC_AT                 (1<<24)\n#define CC_EQUAL              (1<<25)\n#define CC_LESS_THAN          (1<<26)\n#define CC_GREATER_THAN       (1<<27)\n#define CC_PIPE               (1<<28)\n#define CC_QUESTION_MARK      (1<<29)\n#define CC_ASTERISK           (1<<30)\n\n/* macro classes */\n#define CC_NAME               (CC_ALNUM|CC_UNDERBAR)\n#define CC_CRLF               (CC_CR|CC_NEWLINE)\n\nbool char_class (const unsigned char c, const unsigned int flags);\nbool string_class (const char *str, const unsigned int inclusive, const unsigned int exclusive);\nbool string_mod (char *str, const unsigned int inclusive, const unsigned int exclusive, const char replace);\n\nconst char *string_mod_const (const char *str,\n\t\t\t      const unsigned int inclusive,\n\t\t\t      const unsigned int exclusive,\n\t\t\t      const char replace,\n\t\t\t      struct gc_arena *gc);\n\nvoid string_replace_leading (char *str, const char match, const char replace);\n\n#ifdef CHARACTER_CLASS_DEBUG\nvoid character_class_debug (void);\n#endif\n\n/*\n * Verify that a pointer is correctly aligned\n */\n#ifdef VERIFY_ALIGNMENT\n  void valign4 (const struct buffer *buf, const char *file, const int line);\n# define verify_align_4(ptr) valign4(buf, __FILE__, __LINE__)\n#else\n# define verify_align_4(ptr)\n#endif\n\n/*\n * Very basic garbage collection, mostly for routines that return\n * char ptrs to malloced strings.\n */\n\nvoid gc_transfer (struct gc_arena *dest, struct gc_arena *src);\n\nvoid x_gc_free (struct gc_arena *a);\n\nstatic inline bool\ngc_defined (struct gc_arena *a)\n{\n  return a->list != NULL;\n}\n\nstatic inline void\ngc_init (struct gc_arena *a)\n{\n  a->list = NULL;\n}\n\nstatic inline void\ngc_detach (struct gc_arena *a)\n{\n  gc_init (a);\n}\n\nstatic inline struct gc_arena\ngc_new (void)\n{\n  struct gc_arena ret;\n  ret.list = NULL;\n  return ret;\n}\n\nstatic inline void\ngc_free (struct gc_arena *a)\n{\n  if (a->list)\n    x_gc_free (a);\n}\n\nstatic inline void\ngc_reset (struct gc_arena *a)\n{\n  gc_free (a);\n}\n\n/*\n * Allocate memory to hold a structure\n */\n\n#define ALLOC_OBJ(dptr, type) \\\n{ \\\n  check_malloc_return ((dptr) = (type *) malloc (sizeof (type))); \\\n}\n\n#define ALLOC_OBJ_CLEAR(dptr, type) \\\n{ \\\n  ALLOC_OBJ (dptr, type); \\\n  memset ((dptr), 0, sizeof(type)); \\\n}\n\n#define ALLOC_ARRAY(dptr, type, n) \\\n{ \\\n  check_malloc_return ((dptr) = (type *) malloc (array_mult_safe (sizeof (type), (n), 0))); \\\n}\n\n#define ALLOC_ARRAY_GC(dptr, type, n, gc) \\\n{ \\\n  (dptr) = (type *) gc_malloc (array_mult_safe (sizeof (type), (n), 0), false, (gc)); \\\n}\n\n#define ALLOC_ARRAY_CLEAR(dptr, type, n) \\\n{ \\\n  ALLOC_ARRAY (dptr, type, n); \\\n  memset ((dptr), 0, (array_mult_safe (sizeof(type), (n), 0)));\t\\\n}\n\n#define ALLOC_ARRAY_CLEAR_GC(dptr, type, n, gc) \\\n{ \\\n  (dptr) = (type *) gc_malloc (array_mult_safe (sizeof (type), (n), 0), true, (gc)); \\\n}\n\n#define ALLOC_VAR_ARRAY_CLEAR_GC(dptr, type, atype, n, gc)\t\\\n{ \\\n  (dptr) = (type *) gc_malloc (array_mult_safe (sizeof (atype), (n), sizeof (type)), true, (gc)); \\\n}\n\n#define ALLOC_OBJ_GC(dptr, type, gc) \\\n{ \\\n  (dptr) = (type *) gc_malloc (sizeof (type), false, (gc)); \\\n}\n\n#define ALLOC_OBJ_CLEAR_GC(dptr, type, gc) \\\n{ \\\n  (dptr) = (type *) gc_malloc (sizeof (type), true, (gc)); \\\n}\n\nstatic inline void\ncheck_malloc_return (void *p)\n{\n  if (!p)\n    out_of_memory ();\n}\n\n/*\n * Manage lists of buffers\n */\n\n#ifdef ENABLE_BUFFER_LIST\n\nstruct buffer_entry\n{\n  struct buffer buf;\n  struct buffer_entry *next;\n};\n\nstruct buffer_list\n{\n  struct buffer_entry *head; /* next item to pop/peek */\n  struct buffer_entry *tail; /* last item pushed */\n  int size;                  /* current number of entries */\n  int max_size;              /* maximum size list should grow to */\n};\n\nstruct buffer_list *buffer_list_new (const int max_size);\nvoid buffer_list_free (struct buffer_list *ol);\n\nbool buffer_list_defined (const struct buffer_list *ol);\nvoid buffer_list_reset (struct buffer_list *ol);\n\nvoid buffer_list_push (struct buffer_list *ol, const unsigned char *str);\nstruct buffer_entry *buffer_list_push_data (struct buffer_list *ol, const uint8_t *data, size_t size);\nstruct buffer *buffer_list_peek (struct buffer_list *ol);\nvoid buffer_list_advance (struct buffer_list *ol, int n);\nvoid buffer_list_pop (struct buffer_list *ol);\n\nvoid buffer_list_aggregate (struct buffer_list *bl, const size_t max);\n\nstruct buffer_list *buffer_list_file (const char *fn, int max_line_len);\n\n#endif\n\n#endif /* BUFFER_H */\n", "/*\n *  OpenVPN -- An application to securely tunnel IP networks\n *             over a single TCP/UDP port, with support for SSL/TLS-based\n *             session authentication and key exchange,\n *             packet encryption, packet authentication, and\n *             packet compression.\n *\n *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>\n *  Copyright (C) 2010 Fox Crypto B.V. <openvpn@fox-it.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program (see the file COPYING included with this\n *  distribution); if not, write to the Free Software Foundation, Inc.,\n *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#elif defined(_MSC_VER)\n#include \"config-msvc.h\"\n#endif\n\n#include \"syshead.h\"\n\n#ifdef ENABLE_CRYPTO\n\n#include \"crypto.h\"\n#include \"error.h\"\n#include \"misc.h\"\n\n#include \"memdbg.h\"\n\n/*\n * Encryption and Compression Routines.\n *\n * On entry, buf contains the input data and length.\n * On exit, it should be set to the output data and length.\n *\n * If buf->len is <= 0 we should return\n * If buf->len is set to 0 on exit it tells the caller to ignore the packet.\n *\n * work is a workspace buffer we are given of size BUF_SIZE.\n * work may be used to return output data, or the input buffer\n * may be modified and returned as output.  If output data is\n * returned in work, the data should start after FRAME_HEADROOM bytes\n * of padding to leave room for downstream routines to prepend.\n *\n * Up to a total of FRAME_HEADROOM bytes may be prepended to the input buf\n * by all routines (encryption, decryption, compression, and decompression).\n *\n * Note that the buf_prepend return will assert if we try to\n * make a header bigger than FRAME_HEADROOM.  This should not\n * happen unless the frame parameters are wrong.\n */\n\n#define CRYPT_ERROR(format) \\\n  do { msg (D_CRYPT_ERRORS, \"%s: \" format, error_prefix); goto error_exit; } while (false)\n\nvoid\nopenvpn_encrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->encrypt;\n\n      /* Do Encrypt from buf -> work */\n      if (ctx->cipher)\n\t{\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  int outlen;\n\n\t  if (mode == OPENVPN_MODE_CBC)\n\t    {\n\t      CLEAR (iv_buf);\n\n\t      /* generate pseudo-random IV */\n\t      if (opt->flags & CO_USE_IV)\n\t\tprng_bytes (iv_buf, iv_size);\n\n\t      /* Put packet ID in plaintext buffer or IV, depending on cipher mode */\n\t      if (opt->packet_id)\n\t\t{\n\t\t  struct packet_id_net pin;\n\t\t  packet_id_alloc_outgoing (&opt->packet_id->send, &pin, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM));\n\t\t  ASSERT (packet_id_write (&pin, buf, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM), true));\n\t\t}\n\t    }\n\t  else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t    {\n\t      struct packet_id_net pin;\n\t      struct buffer b;\n\n\t      ASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t      ASSERT (opt->packet_id); /*  for this mode. */\n\n\t      packet_id_alloc_outgoing (&opt->packet_id->send, &pin, true);\n\t      memset (iv_buf, 0, iv_size);\n\t      buf_set_write (&b, iv_buf, iv_size);\n\t      ASSERT (packet_id_write (&pin, &b, true, false));\n\t    }\n\t  else /* We only support CBC, CFB, or OFB modes right now */\n\t    {\n\t      ASSERT (0);\n\t    }\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM (frame)));\n\n\t  /* set the IV pseudo-randomly */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"ENCRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  dmsg (D_PACKET_CONTENT, \"ENCRYPT FROM: %s\",\n\t       format_hex (BPTR (buf), BLEN (buf), 80, &gc));\n\n\t  /* cipher_ctx was already initialized with key & keylen */\n\t  ASSERT (cipher_ctx_reset(ctx->cipher, iv_buf));\n\n\t  /* Buffer overflow check */\n\t  if (!buf_safe (&work, buf->len + cipher_ctx_block_size(ctx->cipher)))\n\t    {\n\t      msg (D_CRYPT_ERRORS, \"ENCRYPT: buffer size error, bc=%d bo=%d bl=%d wc=%d wo=%d wl=%d cbs=%d\",\n\t\t   buf->capacity,\n\t\t   buf->offset,\n\t\t   buf->len,\n\t\t   work.capacity,\n\t\t   work.offset,\n\t\t   work.len,\n\t\t   cipher_ctx_block_size (ctx->cipher));\n\t      goto err;\n\t    }\n\n\t  /* Encrypt packet ID, payload */\n\t  ASSERT (cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)));\n\t  work.len += outlen;\n\n\t  /* Flush the encryption buffer */\n\t  ASSERT(cipher_ctx_final(ctx->cipher, BPTR (&work) + outlen, &outlen));\n\t  work.len += outlen;\n\t  ASSERT (outlen == iv_size);\n\n\t  /* prepend the IV to the ciphertext */\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      uint8_t *output = buf_prepend (&work, iv_size);\n\t      ASSERT (output);\n\t      memcpy (output, iv_buf, iv_size);\n\t    }\n\n\t  dmsg (D_PACKET_CONTENT, \"ENCRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\t}\n      else\t\t\t\t/* No Encryption */\n\t{\n\t  if (opt->packet_id)\n\t    {\n\t      struct packet_id_net pin;\n\t      packet_id_alloc_outgoing (&opt->packet_id->send, &pin, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM));\n\t      ASSERT (packet_id_write (&pin, buf, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM), true));\n\t    }\n\t  work = *buf;\n\t}\n\n      /* HMAC the ciphertext (or plaintext if !cipher) */\n      if (ctx->hmac)\n\t{\n\t  uint8_t *output = NULL;\n\n\t  hmac_ctx_reset (ctx->hmac);\n\t  hmac_ctx_update (ctx->hmac, BPTR(&work), BLEN(&work));\n\t  output = buf_prepend (&work, hmac_ctx_size(ctx->hmac));\n\t  ASSERT (output);\n\t  hmac_ctx_final (ctx->hmac, output);\n\t}\n\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return;\n\nerr:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return;\n}\n\n/*\n * If (opt->flags & CO_USE_IV) is not NULL, we will read an IV from the packet.\n *\n * Set buf->len to 0 and return false on decrypt error.\n *\n * On success, buf is set to point to plaintext, true\n * is returned.\n */\nbool\nopenvpn_decrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  static const char error_prefix[] = \"Authenticate/Decrypt packet error\";\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;\n      struct packet_id_net pin;\n      bool have_pin = false;\n\n      /* Verify the HMAC */\n      if (ctx->hmac)\n\t{\n\t  int hmac_len;\n\t  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */\n\n\t  hmac_ctx_reset(ctx->hmac);\n\n\t  /* Assume the length of the input HMAC */\n\t  hmac_len = hmac_ctx_size (ctx->hmac);\n\n\t  /* Authentication fails if insufficient data in packet for HMAC */\n\t  if (buf->len < hmac_len)\n\t    CRYPT_ERROR (\"missing authentication info\");\n\n\t  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);\n\t  hmac_ctx_final (ctx->hmac, local_hmac);\n\n\t  /* Compare locally computed HMAC with packet HMAC */\n\t  if (memcmp (local_hmac, BPTR (buf), hmac_len))\n\t    CRYPT_ERROR (\"packet HMAC authentication failed\");\n\n\t  ASSERT (buf_advance (buf, hmac_len));\n\t}\n\n      /* Decrypt packet ID + payload */\n\n      if (ctx->cipher)\n\t{\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  int outlen;\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));\n\n\t  /* use IV if user requested it */\n\t  CLEAR (iv_buf);\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      if (buf->len < iv_size)\n\t\tCRYPT_ERROR (\"missing IV info\");\n\t      memcpy (iv_buf, BPTR (buf), iv_size);\n\t      ASSERT (buf_advance (buf, iv_size));\n\t    }\n\n\t  /* show the IV's initial state */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"DECRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  if (buf->len < 1)\n\t    CRYPT_ERROR (\"missing payload\");\n\n\t  /* ctx->cipher was already initialized with key & keylen */\n\t  if (!cipher_ctx_reset (ctx->cipher, iv_buf))\n\t    CRYPT_ERROR (\"cipher init failed\");\n\n\t  /* Buffer overflow check (should never happen) */\n\t  if (!buf_safe (&work, buf->len))\n\t    CRYPT_ERROR (\"buffer overflow\");\n\n\t  /* Decrypt packet ID, payload */\n\t  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))\n\t    CRYPT_ERROR (\"cipher update failed\");\n\t  work.len += outlen;\n\n\t  /* Flush the decryption buffer */\n\t  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))\n\t    CRYPT_ERROR (\"cipher final failed\");\n\t  work.len += outlen;\n\n\t  dmsg (D_PACKET_CONTENT, \"DECRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\n\t  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */\n\t  {\n\t    if (mode == OPENVPN_MODE_CBC)\n\t      {\n\t\tif (opt->packet_id)\n\t\t  {\n\t\t    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\t      CRYPT_ERROR (\"error reading CBC packet-id\");\n\t\t    have_pin = true;\n\t\t  }\n\t      }\n\t    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t      {\n\t\tstruct buffer b;\n\n\t\tASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t\tASSERT (opt->packet_id); /*  for this mode. */\n\n\t\tbuf_set_read (&b, iv_buf, iv_size);\n\t\tif (!packet_id_read (&pin, &b, true))\n\t\t  CRYPT_ERROR (\"error reading CFB/OFB packet-id\");\n\t\thave_pin = true;\n\t      }\n\t    else /* We only support CBC, CFB, or OFB modes right now */\n\t      {\n\t\tASSERT (0);\n\t      }\n\t  }\n\t}\n      else\n\t{\n\t  work = *buf;\n\t  if (opt->packet_id)\n\t    {\n\t      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\tCRYPT_ERROR (\"error reading packet-id\");\n\t      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);\n\t    }\n\t}\n      \n      if (have_pin)\n\t{\n\t  packet_id_reap_test (&opt->packet_id->rec);\n\t  if (packet_id_test (&opt->packet_id->rec, &pin))\n\t    {\n\t      packet_id_add (&opt->packet_id->rec, &pin);\n\t      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))\n\t\tpacket_id_persist_save_obj (opt->pid_persist, opt->packet_id);\n\t    }\n\t  else\n\t    {\n\t      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))\n\t      msg (D_REPLAY_ERRORS, \"%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings\",\n\t\t   error_prefix, packet_id_net_print (&pin, true, &gc));\n\t      goto error_exit;\n\t    }\n\t}\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return true;\n\n error_exit:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return false;\n}\n\n/*\n * How many bytes will we add to frame buffer for a given\n * set of crypto options?\n */\nvoid\ncrypto_adjust_frame_parameters(struct frame *frame,\n\t\t\t       const struct key_type* kt,\n\t\t\t       bool cipher_defined,\n\t\t\t       bool use_iv,\n\t\t\t       bool packet_id,\n\t\t\t       bool packet_id_long_form)\n{\n  frame_add_to_extra_frame (frame,\n\t\t\t    (packet_id ? packet_id_size (packet_id_long_form) : 0) +\n\t\t\t    ((cipher_defined && use_iv) ? cipher_kt_iv_size (kt->cipher) : 0) +\n\t\t\t    (cipher_defined ? cipher_kt_block_size (kt->cipher) : 0) + /* worst case padding expansion */\n\t\t\t    kt->hmac_length);\n}\n\n/*\n * Build a struct key_type.\n */\nvoid\ninit_key_type (struct key_type *kt, const char *ciphername,\n\t       bool ciphername_defined, const char *authname,\n\t       bool authname_defined, int keysize,\n\t       bool cfb_ofb_allowed, bool warn)\n{\n  CLEAR (*kt);\n  if (ciphername && ciphername_defined)\n    {\n      kt->cipher = cipher_kt_get (translate_cipher_name_from_openvpn(ciphername));\n      kt->cipher_length = cipher_kt_key_size (kt->cipher);\n      if (keysize > 0 && keysize <= MAX_CIPHER_KEY_LENGTH)\n\tkt->cipher_length = keysize;\n\n      /* check legal cipher mode */\n      {\n\tconst unsigned int mode = cipher_kt_mode (kt->cipher);\n\tif (!(mode == OPENVPN_MODE_CBC\n#ifdef ALLOW_NON_CBC_CIPHERS\n\t      || (cfb_ofb_allowed && (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB))\n#endif\n\t      ))\n#ifdef ENABLE_SMALL\n\t  msg (M_FATAL, \"Cipher '%s' mode not supported\", ciphername);\n#else\n\t  msg (M_FATAL, \"Cipher '%s' uses a mode not supported by \" PACKAGE_NAME \" in your current configuration.  CBC mode is always supported, while CFB and OFB modes are supported only when using SSL/TLS authentication and key exchange mode, and when \" PACKAGE_NAME \" has been built with ALLOW_NON_CBC_CIPHERS.\", ciphername);\n#endif\n      }\n    }\n  else\n    {\n      if (warn)\n\tmsg (M_WARN, \"******* WARNING *******: null cipher specified, no encryption will be used\");\n    }\n  if (authname && authname_defined)\n    {\n      kt->digest = md_kt_get (authname);\n      kt->hmac_length = md_kt_size (kt->digest);\n    }\n  else\n    {\n      if (warn)\n\tmsg (M_WARN, \"******* WARNING *******: null MAC specified, no authentication will be used\");\n    }\n}\n\n/* given a key and key_type, build a key_ctx */\nvoid\ninit_key_ctx (struct key_ctx *ctx, struct key *key,\n\t      const struct key_type *kt, int enc,\n\t      const char *prefix)\n{\n  struct gc_arena gc = gc_new ();\n  CLEAR (*ctx);\n  if (kt->cipher && kt->cipher_length > 0)\n    {\n\n      ALLOC_OBJ(ctx->cipher, cipher_ctx_t);\n      cipher_ctx_init (ctx->cipher, key->cipher, kt->cipher_length,\n\t  kt->cipher, enc);\n\n      msg (D_HANDSHAKE, \"%s: Cipher '%s' initialized with %d bit key\",\n          prefix,\n          cipher_kt_name(kt->cipher),\n          kt->cipher_length *8);\n\n      dmsg (D_SHOW_KEYS, \"%s: CIPHER KEY: %s\", prefix,\n          format_hex (key->cipher, kt->cipher_length, 0, &gc));\n      dmsg (D_CRYPTO_DEBUG, \"%s: CIPHER block_size=%d iv_size=%d\",\n          prefix,\n          cipher_kt_block_size(kt->cipher),\n          cipher_kt_iv_size(kt->cipher));\n    }\n  if (kt->digest && kt->hmac_length > 0)\n    {\n      ALLOC_OBJ(ctx->hmac, hmac_ctx_t);\n      hmac_ctx_init (ctx->hmac, key->hmac, kt->hmac_length, kt->digest);\n\n      msg (D_HANDSHAKE,\n      \"%s: Using %d bit message hash '%s' for HMAC authentication\",\n      prefix, md_kt_size(kt->digest) * 8, md_kt_name(kt->digest));\n\n      dmsg (D_SHOW_KEYS, \"%s: HMAC KEY: %s\", prefix,\n\t  format_hex (key->hmac, kt->hmac_length, 0, &gc));\n\n      dmsg (D_CRYPTO_DEBUG, \"%s: HMAC size=%d block_size=%d\",\n\tprefix,\n\tmd_kt_size(kt->digest),\n\thmac_ctx_size(ctx->hmac));\n\n    }\n  gc_free (&gc);\n}\n\nvoid\nfree_key_ctx (struct key_ctx *ctx)\n{\n  if (ctx->cipher)\n    {\n      cipher_ctx_cleanup(ctx->cipher);\n      free(ctx->cipher);\n      ctx->cipher = NULL;\n    }\n  if (ctx->hmac)\n    {\n      hmac_ctx_cleanup(ctx->hmac);\n      free(ctx->hmac);\n      ctx->hmac = NULL;\n    }\n}\n\nvoid\nfree_key_ctx_bi (struct key_ctx_bi *ctx)\n{\n  free_key_ctx(&ctx->encrypt);\n  free_key_ctx(&ctx->decrypt);\n}\n\n\nstatic bool\nkey_is_zero (struct key *key, const struct key_type *kt)\n{\n  int i;\n  for (i = 0; i < kt->cipher_length; ++i)\n    if (key->cipher[i])\n      return false;\n  msg (D_CRYPT_ERRORS, \"CRYPTO INFO: WARNING: zero key detected\");\n  return true;\n}\n\n/*\n * Make sure that cipher key is a valid key for current key_type.\n */\nbool\ncheck_key (struct key *key, const struct key_type *kt)\n{\n  if (kt->cipher)\n    {\n      /*\n       * Check for zero key\n       */\n      if (key_is_zero(key, kt))\n\treturn false;\n\n      /*\n       * Check for weak or semi-weak DES keys.\n       */\n      {\n\tconst int ndc = key_des_num_cblocks (kt->cipher);\n\tif (ndc)\n\t  return key_des_check (key->cipher, kt->cipher_length, ndc);\n\telse\n\t  return true;\n      }\n    }\n  return true;\n}\n\n/*\n * Make safe mutations to key to ensure it is valid,\n * such as ensuring correct parity on DES keys.\n *\n * This routine cannot guarantee it will generate a good\n * key.  You must always call check_key after this routine\n * to make sure.\n */ \nvoid\nfixup_key (struct key *key, const struct key_type *kt)\n{\n  struct gc_arena gc = gc_new ();\n  if (kt->cipher)\n    {\n#ifdef ENABLE_DEBUG\n      const struct key orig = *key;\n#endif\n      const int ndc = key_des_num_cblocks (kt->cipher);\n\n      if (ndc)\n\tkey_des_fixup (key->cipher, kt->cipher_length, ndc);\n\n#ifdef ENABLE_DEBUG\n      if (check_debug_level (D_CRYPTO_DEBUG))\n\t{\n\t  if (memcmp (orig.cipher, key->cipher, kt->cipher_length))\n\t    dmsg (D_CRYPTO_DEBUG, \"CRYPTO INFO: fixup_key: before=%s after=%s\",\n\t\t format_hex (orig.cipher, kt->cipher_length, 0, &gc),\n\t\t format_hex (key->cipher, kt->cipher_length, 0, &gc));\n\t}\n#endif\n    }\n  gc_free (&gc);\n}\n\nvoid\ncheck_replay_iv_consistency (const struct key_type *kt, bool packet_id, bool use_iv)\n{\n  if (cfb_ofb_mode (kt) && !(packet_id && use_iv))\n    msg (M_FATAL, \"--no-replay or --no-iv cannot be used with a CFB or OFB mode cipher\");\n}\n\nbool\ncfb_ofb_mode (const struct key_type* kt)\n{\n  if (kt && kt->cipher) {\n      const unsigned int mode = cipher_kt_mode (kt->cipher);\n      return mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB;\n  }\n  return false;\n}\n\n/*\n * Generate a random key.  If key_type is provided, make\n * sure generated key is valid for key_type.\n */\nvoid\ngenerate_key_random (struct key *key, const struct key_type *kt)\n{\n  int cipher_len = MAX_CIPHER_KEY_LENGTH;\n  int hmac_len = MAX_HMAC_KEY_LENGTH;\n\n  struct gc_arena gc = gc_new ();\n\n  do {\n    CLEAR (*key);\n    if (kt)\n      {\n\tif (kt->cipher && kt->cipher_length > 0 && kt->cipher_length <= cipher_len)\n\t  cipher_len = kt->cipher_length;\n\n\tif (kt->digest && kt->hmac_length > 0 && kt->hmac_length <= hmac_len)\n\t  hmac_len = kt->hmac_length;\n      }\n    if (!rand_bytes (key->cipher, cipher_len)\n\t|| !rand_bytes (key->hmac, hmac_len))\n      msg (M_FATAL, \"ERROR: Random number generator cannot obtain entropy for key generation\");\n\n    dmsg (D_SHOW_KEY_SOURCE, \"Cipher source entropy: %s\", format_hex (key->cipher, cipher_len, 0, &gc));\n    dmsg (D_SHOW_KEY_SOURCE, \"HMAC source entropy: %s\", format_hex (key->hmac, hmac_len, 0, &gc));\n\n    if (kt)\n      fixup_key (key, kt);\n  } while (kt && !check_key (key, kt));\n\n  gc_free (&gc);\n}\n\n/*\n * Print key material\n */\nvoid\nkey2_print (const struct key2* k,\n\t    const struct key_type *kt,\n\t    const char* prefix0,\n\t    const char* prefix1)\n{\n  struct gc_arena gc = gc_new ();\n  ASSERT (k->n == 2);\n  dmsg (D_SHOW_KEY_SOURCE, \"%s (cipher): %s\",\n       prefix0,\n       format_hex (k->keys[0].cipher, kt->cipher_length, 0, &gc));\n  dmsg (D_SHOW_KEY_SOURCE, \"%s (hmac): %s\",\n       prefix0,\n       format_hex (k->keys[0].hmac, kt->hmac_length, 0, &gc));\n  dmsg (D_SHOW_KEY_SOURCE, \"%s (cipher): %s\",\n       prefix1,\n       format_hex (k->keys[1].cipher, kt->cipher_length, 0, &gc));\n  dmsg (D_SHOW_KEY_SOURCE, \"%s (hmac): %s\",\n       prefix1,\n       format_hex (k->keys[1].hmac, kt->hmac_length, 0, &gc));\n  gc_free (&gc);\n}\n\nvoid\ntest_crypto (const struct crypto_options *co, struct frame* frame)\n{\n  int i, j;\n  struct gc_arena gc = gc_new ();\n  struct buffer src = alloc_buf_gc (TUN_MTU_SIZE (frame), &gc);\n  struct buffer work = alloc_buf_gc (BUF_SIZE (frame), &gc);\n  struct buffer encrypt_workspace = alloc_buf_gc (BUF_SIZE (frame), &gc);\n  struct buffer decrypt_workspace = alloc_buf_gc (BUF_SIZE (frame), &gc);\n  struct buffer buf = clear_buf();\n\n  /* init work */\n  ASSERT (buf_init (&work, FRAME_HEADROOM (frame)));\n\n  msg (M_INFO, \"Entering \" PACKAGE_NAME \" crypto self-test mode.\");\n  for (i = 1; i <= TUN_MTU_SIZE (frame); ++i)\n    {\n      update_time ();\n\n      msg (M_INFO, \"TESTING ENCRYPT/DECRYPT of packet length=%d\", i);\n\n      /*\n       * Load src with random data.\n       */\n      ASSERT (buf_init (&src, 0));\n      ASSERT (i <= src.capacity);\n      src.len = i;\n      ASSERT (rand_bytes (BPTR (&src), BLEN (&src)));\n\n      /* copy source to input buf */\n      buf = work;\n      memcpy (buf_write_alloc (&buf, BLEN (&src)), BPTR (&src), BLEN (&src));\n\n      /* encrypt */\n      openvpn_encrypt (&buf, encrypt_workspace, co, frame);\n\n      /* decrypt */\n      openvpn_decrypt (&buf, decrypt_workspace, co, frame);\n\n      /* compare */\n      if (buf.len != src.len)\n\tmsg (M_FATAL, \"SELF TEST FAILED, src.len=%d buf.len=%d\", src.len, buf.len);\n      for (j = 0; j < i; ++j)\n\t{\n\t  const uint8_t in = *(BPTR (&src) + j);\n\t  const uint8_t out = *(BPTR (&buf) + j);\n\t  if (in != out)\n\t    msg (M_FATAL, \"SELF TEST FAILED, pos=%d in=%d out=%d\", j, in, out);\n\t}\n    }\n  msg (M_INFO, PACKAGE_NAME \" crypto self-test mode SUCCEEDED.\");\n  gc_free (&gc);\n}\n\n#ifdef ENABLE_SSL\n\nvoid\nget_tls_handshake_key (const struct key_type *key_type,\n\t\t       struct key_ctx_bi *ctx,\n\t\t       const char *passphrase_file,\n\t\t       const int key_direction,\n\t\t       const unsigned int flags)\n{\n  if (passphrase_file && key_type->hmac_length)\n    {\n      struct key2 key2;\n      struct key_type kt = *key_type;\n      struct key_direction_state kds;\n\n      /* for control channel we are only authenticating, not encrypting */\n      kt.cipher_length = 0;\n      kt.cipher = NULL;\n\n      if (flags & GHK_INLINE)\n\t{\n\t  /* key was specified inline, key text is in passphrase_file */\n\t  read_key_file (&key2, passphrase_file, RKF_INLINE|RKF_MUST_SUCCEED);\n\n\t  /* succeeded? */\n\t  if (key2.n == 2)\n\t    msg (M_INFO, \"Control Channel Authentication: tls-auth using INLINE static key file\");\n\t  else\n\t    msg (M_FATAL, \"INLINE tls-auth file lacks the requisite 2 keys\");\n\t}\n      else\n      {\n\t/* first try to parse as an OpenVPN static key file */\n\tread_key_file (&key2, passphrase_file, 0);\n\n\t/* succeeded? */\n\tif (key2.n == 2)\n\t  {\n\t    msg (M_INFO,\n\t\t \"Control Channel Authentication: using '%s' as a \" PACKAGE_NAME \" static key file\",\n\t\t passphrase_file);\n\t  }\n\telse\n\t  {\n\t    int hash_size;\n\n\t    CLEAR (key2);\n\n\t    /* failed, now try to get hash from a freeform file */\n\t    hash_size = read_passphrase_hash (passphrase_file,\n\t\t\t\t\t      kt.digest,\n\t\t\t\t\t      key2.keys[0].hmac,\n\t\t\t\t\t      MAX_HMAC_KEY_LENGTH);\n\t    ASSERT (hash_size == kt.hmac_length);\n\n\t    /* suceeded */\n\t    key2.n = 1;\n\n\t    msg (M_INFO,\n\t\t \"Control Channel Authentication: using '%s' as a free-form passphrase file\",\n\t\t passphrase_file);\n\t  }\n      }\n      /* handle key direction */\n\n      key_direction_state_init (&kds, key_direction);\n      must_have_n_keys (passphrase_file, \"tls-auth\", &key2, kds.need_keys);\n\n      /* initialize hmac key in both directions */\n\n      init_key_ctx (&ctx->encrypt, &key2.keys[kds.out_key], &kt, OPENVPN_OP_ENCRYPT,\n\t\t    \"Outgoing Control Channel Authentication\");\n      init_key_ctx (&ctx->decrypt, &key2.keys[kds.in_key], &kt, OPENVPN_OP_DECRYPT,\n\t\t    \"Incoming Control Channel Authentication\");\n\n      CLEAR (key2);\n    }\n  else\n    {\n      CLEAR (*ctx);\n    }\n}\n#endif\n\n/* header and footer for static key file */\nstatic const char static_key_head[] = \"-----BEGIN OpenVPN Static key V1-----\";\nstatic const char static_key_foot[] = \"-----END OpenVPN Static key V1-----\";\n\nstatic const char printable_char_fmt[] =\n  \"Non-Hex character ('%c') found at line %d in key file '%s' (%d/%d/%d bytes found/min/max)\";\n\nstatic const char unprintable_char_fmt[] =\n  \"Non-Hex, unprintable character (0x%02x) found at line %d in key file '%s' (%d/%d/%d bytes found/min/max)\";\n\n/* read key from file */\n\nvoid\nread_key_file (struct key2 *key2, const char *file, const unsigned int flags)\n{\n  struct gc_arena gc = gc_new ();\n  struct buffer in;\n  int fd, size;\n  uint8_t hex_byte[3] = {0, 0, 0};\n  const char *error_filename = file;\n\n  /* parse info */\n  const unsigned char *cp;\n  int hb_index = 0;\n  int line_num = 1;\n  int line_index = 0;\n  int match = 0;\n\n  /* output */\n  uint8_t* out = (uint8_t*) &key2->keys;\n  const int keylen = sizeof (key2->keys);\n  int count = 0;\n\n  /* parse states */\n# define PARSE_INITIAL        0\n# define PARSE_HEAD           1\n# define PARSE_DATA           2\n# define PARSE_DATA_COMPLETE  3\n# define PARSE_FOOT           4\n# define PARSE_FINISHED       5\n  int state = PARSE_INITIAL;\n\n  /* constants */\n  const int hlen = strlen (static_key_head);\n  const int flen = strlen (static_key_foot);\n  const int onekeylen = sizeof (key2->keys[0]);\n\n  CLEAR (*key2);\n\n  /*\n   * Key can be provided as a filename in 'file' or if RKF_INLINE\n   * is set, the actual key data itself in ascii form.\n   */\n  if (flags & RKF_INLINE) /* 'file' is a string containing ascii representation of key */\n    {\n      size = strlen (file) + 1;\n      buf_set_read (&in, (const uint8_t *)file, size);\n      error_filename = INLINE_FILE_TAG;\n    }\n  else /* 'file' is a filename which refers to a file containing the ascii key */\n    {\n      in = alloc_buf_gc (2048, &gc);\n      fd = platform_open (file, O_RDONLY, 0);\n      if (fd == -1)\n\tmsg (M_ERR, \"Cannot open file key file '%s'\", file);\n      size = read (fd, in.data, in.capacity);\n      if (size < 0)\n\tmsg (M_FATAL, \"Read error on key file ('%s')\", file);\n      if (size == in.capacity)\n\tmsg (M_FATAL, \"Key file ('%s') can be a maximum of %d bytes\", file, (int)in.capacity);\n      close (fd);\n    }\n\n  cp = (unsigned char *)in.data;\n  while (size > 0)\n    {\n      const unsigned char c = *cp;\n\n#if 0\n      msg (M_INFO, \"char='%c'[%d] s=%d ln=%d li=%d m=%d c=%d\",\n\t   c, (int)c, state, line_num, line_index, match, count);\n#endif\n\n      if (c == '\\n')\n\t{\n\t  line_index = match = 0;\n\t  ++line_num;\t      \n\t}\n      else\n\t{\n\t  /* first char of new line */\n\t  if (!line_index)\n\t    {\n\t      /* first char of line after header line? */\n\t      if (state == PARSE_HEAD)\n\t\tstate = PARSE_DATA;\n\n\t      /* first char of footer */\n\t      if ((state == PARSE_DATA || state == PARSE_DATA_COMPLETE) && c == '-')\n\t\tstate = PARSE_FOOT;\n\t    }\n\n\t  /* compare read chars with header line */\n\t  if (state == PARSE_INITIAL)\n\t    {\n\t      if (line_index < hlen && c == static_key_head[line_index])\n\t\t{\n\t\t  if (++match == hlen)\n\t\t    state = PARSE_HEAD;\n\t\t}\n\t    }\n\n\t  /* compare read chars with footer line */\n\t  if (state == PARSE_FOOT)\n\t    {\n\t      if (line_index < flen && c == static_key_foot[line_index])\n\t\t{\n\t\t  if (++match == flen)\n\t\t    state = PARSE_FINISHED;\n\t\t}\n\t    }\n\n\t  /* reading key */\n\t  if (state == PARSE_DATA)\n\t    {\n\t      if (isxdigit(c))\n\t\t{\n\t\t  ASSERT (hb_index >= 0 && hb_index < 2);\n\t\t  hex_byte[hb_index++] = c;\n\t\t  if (hb_index == 2)\n\t\t    {\n\t\t      unsigned int u;\n\t\t      ASSERT(sscanf((const char *)hex_byte, \"%x\", &u) == 1);\n\t\t      *out++ = u;\n\t\t      hb_index = 0;\n\t\t      if (++count == keylen)\n\t\t\tstate = PARSE_DATA_COMPLETE;\n\t\t    }\n\t\t}\n\t      else if (isspace(c))\n\t\t;\n\t      else\n\t\t{\n\t\t  msg (M_FATAL,\n\t\t       (isprint (c) ? printable_char_fmt : unprintable_char_fmt),\n\t\t       c, line_num, error_filename, count, onekeylen, keylen);\n\t\t}\n\t    }\n\t  ++line_index;\n\t}\n      ++cp;\n      --size;\n    }\n\n  /*\n   * Normally we will read either 1 or 2 keys from file.\n   */\n  key2->n = count / onekeylen;\n\n  ASSERT (key2->n >= 0 && key2->n <= (int) SIZE (key2->keys));\n\n  if (flags & RKF_MUST_SUCCEED)\n    {\n      if (!key2->n)\n\tmsg (M_FATAL, \"Insufficient key material or header text not found in file '%s' (%d/%d/%d bytes found/min/max)\",\n\t     error_filename, count, onekeylen, keylen);\n\n      if (state != PARSE_FINISHED)\n\tmsg (M_FATAL, \"Footer text not found in file '%s' (%d/%d/%d bytes found/min/max)\",\n\t     error_filename, count, onekeylen, keylen);\n    }\n\n  /* zero file read buffer if not an inline file */\n  if (!(flags & RKF_INLINE))\n    buf_clear (&in);\n\n  if (key2->n)\n    warn_if_group_others_accessible (error_filename);\n\n#if 0\n  /* DEBUGGING */\n  {\n    int i;\n    printf (\"KEY READ, n=%d\\n\", key2->n);\n    for (i = 0; i < (int) SIZE (key2->keys); ++i)\n      {\n\t/* format key as ascii */\n\tconst char *fmt = format_hex_ex ((const uint8_t*)&key2->keys[i],\n\t\t\t\t\t sizeof (key2->keys[i]),\n\t\t\t\t\t 0,\n\t\t\t\t\t 16,\n\t\t\t\t\t \"\\n\",\n\t\t\t\t\t &gc);\n\tprintf (\"[%d]\\n%s\\n\\n\", i, fmt);\n      }\n  }\n#endif\n\n  /* pop our garbage collection level */\n  gc_free (&gc);\n}\n\nint\nread_passphrase_hash (const char *passphrase_file,\n\t\t      const md_kt_t *digest,\n\t\t      uint8_t *output,\n\t\t      int len)\n{\n  unsigned int outlen = 0;\n  md_ctx_t md;\n\n  ASSERT (len >= md_kt_size(digest));\n  memset (output, 0, len);\n\n  md_ctx_init(&md, digest);\n\n  /* read passphrase file */\n  {\n    const int min_passphrase_size = 8;\n    uint8_t buf[64];\n    int total_size = 0;\n    int fd = platform_open (passphrase_file, O_RDONLY, 0);\n\n    if (fd == -1)\n      msg (M_ERR, \"Cannot open passphrase file: '%s'\", passphrase_file);\n\n    for (;;)\n      {\n\tint size = read (fd, buf, sizeof (buf));\n\tif (size == 0)\n\t  break;\n\tif (size == -1)\n\t  msg (M_ERR, \"Read error on passphrase file: '%s'\",\n\t       passphrase_file);\n\tmd_ctx_update(&md, buf, size);\n\ttotal_size += size;\n      }\n    close (fd);\n\n    warn_if_group_others_accessible (passphrase_file);\n\n    if (total_size < min_passphrase_size)\n      msg (M_FATAL,\n\t   \"Passphrase file '%s' is too small (must have at least %d characters)\",\n\t   passphrase_file, min_passphrase_size);\n  }\n  md_ctx_final(&md, output);\n  md_ctx_cleanup(&md);\n  return md_kt_size(digest);\n}\n\n/*\n * Write key to file, return number of random bits\n * written.\n */\nint\nwrite_key_file (const int nkeys, const char *filename)\n{\n  struct gc_arena gc = gc_new ();\n\n  int fd, i;\n  int nbits = 0;\n\n  /* must be large enough to hold full key file */\n  struct buffer out = alloc_buf_gc (2048, &gc);\n  struct buffer nbits_head_text = alloc_buf_gc (128, &gc);\n\n  /* how to format the ascii file representation of key */\n  const int bytes_per_line = 16;\n\n  /* open key file */\n  fd = platform_open (filename, O_CREAT | O_TRUNC | O_WRONLY, S_IRUSR | S_IWUSR);\n\n  if (fd == -1)\n    msg (M_ERR, \"Cannot open shared secret file '%s' for write\", filename);\n\n  buf_printf (&out, \"%s\\n\", static_key_head);\n\n  for (i = 0; i < nkeys; ++i)\n    {\n      struct key key;\n      char* fmt;\n\n      /* generate random bits */\n      generate_key_random (&key, NULL);\n\n      /* format key as ascii */\n      fmt = format_hex_ex ((const uint8_t*)&key,\n\t\t\t   sizeof (key),\n\t\t\t   0,\n\t\t\t   bytes_per_line,\n\t\t\t   \"\\n\",\n\t\t\t   &gc);\n\n      /* increment random bits counter */\n      nbits += sizeof (key) * 8;\n\n      /* write to holding buffer */\n      buf_printf (&out, \"%s\\n\", fmt);\n\n      /* zero memory which held key component (will be freed by GC) */\n      memset (fmt, 0, strlen(fmt));\n      CLEAR (key);\n    }\n\n  buf_printf (&out, \"%s\\n\", static_key_foot);\n\n  /* write number of bits */\n  buf_printf (&nbits_head_text, \"#\\n# %d bit OpenVPN static key\\n#\\n\", nbits);\n  buf_write_string_file (&nbits_head_text, filename, fd);\n\n  /* write key file, now formatted in out, to file */\n  buf_write_string_file (&out, filename, fd);\n\n  if (close (fd))\n    msg (M_ERR, \"Close error on shared secret file %s\", filename);\n\n  /* zero memory which held file content (memory will be freed by GC) */\n  buf_clear (&out);\n\n  /* pop our garbage collection level */\n  gc_free (&gc);\n\n  return nbits;\n}\n\nvoid\nmust_have_n_keys (const char *filename, const char *option, const struct key2 *key2, int n)\n{\n  if (key2->n < n)\n    {\n#ifdef ENABLE_SMALL\n      msg (M_FATAL, \"Key file '%s' used in --%s contains insufficient key material [keys found=%d required=%d]\", filename, option, key2->n, n);\n#else\n      msg (M_FATAL, \"Key file '%s' used in --%s contains insufficient key material [keys found=%d required=%d] -- try generating a new key file with '\" PACKAGE \" --genkey --secret [file]', or use the existing key file in bidirectional mode by specifying --%s without a key direction parameter\", filename, option, key2->n, n, option);\n#endif\n    }\n}\n\nint\nascii2keydirection (int msglevel, const char *str)\n{\n  if (!str)\n    return KEY_DIRECTION_BIDIRECTIONAL;\n  else if (!strcmp (str, \"0\"))\n    return KEY_DIRECTION_NORMAL;\n  else if (!strcmp (str, \"1\"))\n    return KEY_DIRECTION_INVERSE;\n  else\n    {\n      msg (msglevel, \"Unknown key direction '%s' -- must be '0' or '1'\", str);\n      return -1;\n    }\n  return KEY_DIRECTION_BIDIRECTIONAL; /* NOTREACHED */\n}\n\nconst char *\nkeydirection2ascii (int kd, bool remote)\n{\n  if (kd == KEY_DIRECTION_BIDIRECTIONAL)\n    return NULL;\n  else if (kd == KEY_DIRECTION_NORMAL)\n    return remote ? \"1\" : \"0\";\n  else if (kd == KEY_DIRECTION_INVERSE)\n    return remote ? \"0\" : \"1\";\n  else\n    {\n      ASSERT (0);\n    }\n  return NULL; /* NOTREACHED */\n}\n\nvoid\nkey_direction_state_init (struct key_direction_state *kds, int key_direction)\n{\n  CLEAR (*kds);\n  switch (key_direction)\n    {\n    case KEY_DIRECTION_NORMAL:\n      kds->out_key = 0;\n      kds->in_key = 1;\n      kds->need_keys = 2;\n      break;\n    case KEY_DIRECTION_INVERSE:\n      kds->out_key = 1;\n      kds->in_key = 0;\n      kds->need_keys = 2;\n      break;\n    case KEY_DIRECTION_BIDIRECTIONAL:\n      kds->out_key = 0;\n      kds->in_key = 0;\n      kds->need_keys = 1;\n      break;\n    default:\n      ASSERT (0);\n    }\n}\n\nvoid\nverify_fix_key2 (struct key2 *key2, const struct key_type *kt, const char *shared_secret_file)\n{\n  int i;\n\n  for (i = 0; i < key2->n; ++i)\n    {\n      /* Fix parity for DES keys and make sure not a weak key */\n      fixup_key (&key2->keys[i], kt);\n\n      /* This should be a very improbable failure */\n      if (!check_key (&key2->keys[i], kt))\n\tmsg (M_FATAL, \"Key #%d in '%s' is bad.  Try making a new key with --genkey.\",\n\t     i+1, shared_secret_file);\n    }\n}\n\n/* given a key and key_type, write key to buffer */\nbool\nwrite_key (const struct key *key, const struct key_type *kt,\n\t   struct buffer *buf)\n{\n  ASSERT (kt->cipher_length <= MAX_CIPHER_KEY_LENGTH\n\t  && kt->hmac_length <= MAX_HMAC_KEY_LENGTH);\n\n  if (!buf_write (buf, &kt->cipher_length, 1))\n    return false;\n  if (!buf_write (buf, &kt->hmac_length, 1))\n    return false;\n  if (!buf_write (buf, key->cipher, kt->cipher_length))\n    return false;\n  if (!buf_write (buf, key->hmac, kt->hmac_length))\n    return false;\n\n  return true;\n}\n\n/*\n * Given a key_type and buffer, read key from buffer.\n * Return: 1 on success\n *        -1 read failure\n *         0 on key length mismatch \n */\nint\nread_key (struct key *key, const struct key_type *kt, struct buffer *buf)\n{\n  uint8_t cipher_length;\n  uint8_t hmac_length;\n\n  CLEAR (*key);\n  if (!buf_read (buf, &cipher_length, 1))\n    goto read_err;\n  if (!buf_read (buf, &hmac_length, 1))\n    goto read_err;\n\n  if (!buf_read (buf, key->cipher, cipher_length))\n    goto read_err;\n  if (!buf_read (buf, key->hmac, hmac_length))\n    goto read_err;\n\n  if (cipher_length != kt->cipher_length || hmac_length != kt->hmac_length)\n    goto key_len_err;\n\n  return 1;\n\nread_err:\n  msg (D_TLS_ERRORS, \"TLS Error: error reading key from remote\");\n  return -1;\n\nkey_len_err:\n  msg (D_TLS_ERRORS,\n       \"TLS Error: key length mismatch, local cipher/hmac %d/%d, remote cipher/hmac %d/%d\",\n       kt->cipher_length, kt->hmac_length, cipher_length, hmac_length);\n  return 0;\n}\n\n/*\n * Random number functions, used in cases where we want\n * reasonably strong cryptographic random number generation\n * without depleting our entropy pool.  Used for random\n * IV values and a number of other miscellaneous tasks.\n */\n\nstatic uint8_t *nonce_data = NULL; /* GLOBAL */\nstatic const md_kt_t *nonce_md = NULL; /* GLOBAL */\nstatic int nonce_secret_len = 0; /* GLOBAL */\n\n/* Reset the nonce value, also done periodically to refresh entropy */\nstatic void\nprng_reset_nonce ()\n{\n  const int size = md_kt_size (nonce_md) + nonce_secret_len;\n#if 1 /* Must be 1 for real usage */\n  if (!rand_bytes (nonce_data, size))\n    msg (M_FATAL, \"ERROR: Random number generator cannot obtain entropy for PRNG\");\n#else\n    /* Only for testing -- will cause a predictable PRNG sequence */\n    {\n      int i;\n      for (i = 0; i < size; ++i)\n\tnonce_data[i] = (uint8_t) i;\n    }\n#endif\n}\n\nvoid\nprng_init (const char *md_name, const int nonce_secret_len_parm)\n{\n  prng_uninit ();\n  nonce_md = md_name ? md_kt_get (md_name) : NULL;\n  if (nonce_md)\n    {\n      ASSERT (nonce_secret_len_parm >= NONCE_SECRET_LEN_MIN && nonce_secret_len_parm <= NONCE_SECRET_LEN_MAX);\n      nonce_secret_len = nonce_secret_len_parm;\n      {\n\tconst int size = md_kt_size(nonce_md) + nonce_secret_len;\n\tdmsg (D_CRYPTO_DEBUG, \"PRNG init md=%s size=%d\", md_kt_name(nonce_md), size);\n\tnonce_data = (uint8_t*) malloc (size);\n\tcheck_malloc_return (nonce_data);\n\tprng_reset_nonce();\n      }\n    }\n}\n\nvoid\nprng_uninit (void)\n{\n  free (nonce_data);\n  nonce_data = NULL;\n  nonce_md = NULL;\n  nonce_secret_len = 0;\n}\n\nvoid\nprng_bytes (uint8_t *output, int len)\n{\n  static size_t processed = 0;\n\n  if (nonce_md)\n    {\n      const int md_size = md_kt_size (nonce_md);\n      while (len > 0)\n\t{\n\t  unsigned int outlen = 0;\n\t  const int blen = min_int (len, md_size);\n\t  md_full(nonce_md, nonce_data, md_size + nonce_secret_len, nonce_data);\n\t  memcpy (output, nonce_data, blen);\n\t  output += blen;\n\t  len -= blen;\n\n\t  /* Ensure that random data is reset regularly */\n\t  processed += blen;\n\t  if(processed > PRNG_NONCE_RESET_BYTES) {\n\t    prng_reset_nonce();\n\t    processed = 0;\n\t  }\n\t}\n    }\n  else\n    rand_bytes (output, len);\n}\n\n/* an analogue to the random() function, but use prng_bytes */\nlong int\nget_random()\n{\n  long int l;\n  prng_bytes ((unsigned char *)&l, sizeof(l));\n  if (l < 0)\n    l = -l;\n  return l;\n}\n\n#ifndef ENABLE_SSL\n\nvoid\ninit_ssl_lib (void)\n{\n  crypto_init_lib ();\n}\n\nvoid\nfree_ssl_lib (void)\n{\n  crypto_uninit_lib ();\n  prng_uninit();\n}\n\n#endif /* ENABLE_SSL */\n\n/*\n * md5 functions\n */\n\nconst char *\nmd5sum (uint8_t *buf, int len, int n_print_chars, struct gc_arena *gc)\n{\n  uint8_t digest[MD5_DIGEST_LENGTH];\n  const md_kt_t *md5_kt = md_kt_get(\"MD5\");\n\n  md_full(md5_kt, buf, len, digest);\n\n  return format_hex (digest, MD5_DIGEST_LENGTH, n_print_chars, gc);\n}\n\nvoid\nmd5_state_init (struct md5_state *s)\n{\n  const md_kt_t *md5_kt = md_kt_get(\"MD5\");\n\n  md_ctx_init(&s->ctx, md5_kt);\n}\n\nvoid\nmd5_state_update (struct md5_state *s, void *data, size_t len)\n{\n  md_ctx_update(&s->ctx, data, len);\n}\n\nvoid\nmd5_state_final (struct md5_state *s, struct md5_digest *out)\n{\n  md_ctx_final(&s->ctx, out->digest);\n  md_ctx_cleanup(&s->ctx);\n}\n\nvoid\nmd5_digest_clear (struct md5_digest *digest)\n{\n  CLEAR (*digest);\n}\n\nbool\nmd5_digest_defined (const struct md5_digest *digest)\n{\n  int i;\n  for (i = 0; i < MD5_DIGEST_LENGTH; ++i)\n    if (digest->digest[i])\n      return true;\n  return false;\n}\n\nbool\nmd5_digest_equal (const struct md5_digest *d1, const struct md5_digest *d2)\n{\n  return memcmp(d1->digest, d2->digest, MD5_DIGEST_LENGTH) == 0;\n}\n\n#endif /* ENABLE_CRYPTO */\n"], "fixing_code": ["/*\n *  OpenVPN -- An application to securely tunnel IP networks\n *             over a single UDP port, with support for SSL/TLS-based\n *             session authentication and key exchange,\n *             packet encryption, packet authentication, and\n *             packet compression.\n *\n *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program (see the file COPYING included with this\n *  distribution); if not, write to the Free Software Foundation, Inc.,\n *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifndef BUFFER_H\n#define BUFFER_H\n\n#include \"basic.h\"\n#include \"error.h\"\n\n#define BUF_SIZE_MAX 1000000\n\n/*\n * Define verify_align function, otherwise\n * it will be a noop.\n */\n/* #define VERIFY_ALIGNMENT */\n\n/*\n * Keep track of source file/line of buf_init calls\n */\n#ifdef VERIFY_ALIGNMENT\n#define BUF_INIT_TRACKING\n#endif\n\n/**************************************************************************/\n/**\n * Wrapper structure for dynamically allocated memory.\n *\n * The actual content stored in a \\c buffer structure starts at the memory\n * location \\c buffer.data \\c + \\c buffer.offset, and has a length of \\c\n * buffer.len bytes.  This, together with the space available before and\n * after the content, is represented in the pseudocode below:\n@code\nuint8_t *content_start    = buffer.data + buffer.offset;\nuint8_t *content_end      = buffer.data + buffer.offset + buffer.len;\nint      prepend_capacity = buffer.offset;\nint      append_capacity  = buffer.capacity - (buffer.offset + buffer.len);\n@endcode\n */\nstruct buffer\n{\n  int capacity;                 /**< Size in bytes of memory allocated by\n                                 *   \\c malloc(). */\n  int offset;                   /**< Offset in bytes of the actual content\n                                 *   within the allocated memory. */\n  int len;                      /**< Length in bytes of the actual content\n                                 *   within the allocated memory. */\n  uint8_t *data;                /**< Pointer to the allocated memory. */\n\n#ifdef BUF_INIT_TRACKING\n  const char *debug_file;\n  int debug_line;\n#endif\n};\n\n\n/**************************************************************************/\n/**\n * Garbage collection entry for one dynamically allocated block of memory.\n *\n * This structure represents one link in the linked list contained in a \\c\n * gc_arena structure.  Each time the \\c gc_malloc() function is called,\n * it allocates \\c sizeof(gc_entry) + the requested number of bytes.  The\n * \\c gc_entry is then stored as a header in front of the memory address\n * returned to the caller.\n */\nstruct gc_entry\n{\n  struct gc_entry *next;        /**< Pointer to the next item in the\n                                 *   linked list. */\n};\n\n\n/**\n * Garbage collection arena used to keep track of dynamically allocated\n * memory.\n *\n * This structure contains a linked list of \\c gc_entry structures.  When\n * a block of memory is allocated using the \\c gc_malloc() function, the\n * allocation is registered in the function's \\c gc_arena argument.  All\n * the dynamically allocated memory registered in a \\c gc_arena can be\n * freed using the \\c gc_free() function.\n */\nstruct gc_arena\n{\n  struct gc_entry *list;        /**< First element of the linked list of\n                                 *   \\c gc_entry structures. */\n};\n\n\n#define BPTR(buf)  (buf_bptr(buf))\n#define BEND(buf)  (buf_bend(buf))\n#define BLAST(buf) (buf_blast(buf))\n#define BLEN(buf)  (buf_len(buf))\n#define BDEF(buf)  (buf_defined(buf))\n#define BSTR(buf)  (buf_str(buf))\n#define BCAP(buf)  (buf_forward_capacity (buf))\n\nvoid buf_clear (struct buffer *buf);\n\nstruct buffer clear_buf (void);\nvoid free_buf (struct buffer *buf);\n\nbool buf_assign (struct buffer *dest, const struct buffer *src);\n\nvoid string_clear (char *str);\nint string_array_len (const char **array);\n\nsize_t array_mult_safe (const size_t m1, const size_t m2, const size_t extra);\n\n#define PA_BRACKET (1<<0)\nchar *print_argv (const char **p, struct gc_arena *gc, const unsigned int flags);\n\nvoid buf_size_error (const size_t size);\n\n/* for dmalloc debugging */\n\n#ifdef DMALLOC\n\n#define alloc_buf(size)               alloc_buf_debug (size, __FILE__, __LINE__)\n#define alloc_buf_gc(size, gc)        alloc_buf_gc_debug (size, gc, __FILE__, __LINE__);\n#define clone_buf(buf)                clone_buf_debug (buf, __FILE__, __LINE__);\n#define gc_malloc(size, clear, arena) gc_malloc_debug (size, clear, arena, __FILE__, __LINE__)\n#define string_alloc(str, gc)         string_alloc_debug (str, gc, __FILE__, __LINE__)\n#define string_alloc_buf(str, gc)     string_alloc_buf_debug (str, gc, __FILE__, __LINE__)\n\nstruct buffer alloc_buf_debug (size_t size, const char *file, int line);\nstruct buffer alloc_buf_gc_debug (size_t size, struct gc_arena *gc, const char *file, int line);\nstruct buffer clone_buf_debug (const struct buffer* buf, const char *file, int line);\nvoid *gc_malloc_debug (size_t size, bool clear, struct gc_arena *a, const char *file, int line);\nchar *string_alloc_debug (const char *str, struct gc_arena *gc, const char *file, int line);\nstruct buffer string_alloc_buf_debug (const char *str, struct gc_arena *gc, const char *file, int line);\n\n#else\n\nstruct buffer alloc_buf (size_t size);\nstruct buffer alloc_buf_gc (size_t size, struct gc_arena *gc); /* allocate buffer with garbage collection */\nstruct buffer clone_buf (const struct buffer* buf);\nvoid *gc_malloc (size_t size, bool clear, struct gc_arena *a);\nchar *string_alloc (const char *str, struct gc_arena *gc);\nstruct buffer string_alloc_buf (const char *str, struct gc_arena *gc);\n\n#endif\n\n#ifdef BUF_INIT_TRACKING\n#define buf_init(buf, offset) buf_init_debug (buf, offset, __FILE__, __LINE__)\nbool buf_init_debug (struct buffer *buf, int offset, const char *file, int line);\n#else\n#define buf_init(buf, offset) buf_init_dowork (buf, offset)\n#endif\n\n\n/* inline functions */\n\nstatic inline bool\nbuf_defined (const struct buffer *buf)\n{\n  return buf->data != NULL;\n}\n\nstatic inline bool\nbuf_valid (const struct buffer *buf)\n{\n  return likely (buf->data != NULL) && likely (buf->len >= 0);\n}\n\nstatic inline uint8_t *\nbuf_bptr (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    return buf->data + buf->offset;\n  else\n    return NULL;\n}\n\nstatic int\nbuf_len (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    return buf->len;\n  else\n    return 0;\n}\n\nstatic inline uint8_t *\nbuf_bend (const struct buffer *buf)\n{\n  return buf_bptr (buf) + buf_len (buf);\n}\n\nstatic inline uint8_t *\nbuf_blast (const struct buffer *buf)\n{\n  if (buf_len (buf) > 0)\n    return buf_bptr (buf) + buf_len (buf) - 1;\n  else\n    return NULL;\n}\n\nstatic inline bool\nbuf_size_valid (const size_t size)\n{\n  return likely (size < BUF_SIZE_MAX);\n}\n\nstatic inline bool\nbuf_size_valid_signed (const int size)\n{\n  return likely (size >= -BUF_SIZE_MAX) && likely (size < BUF_SIZE_MAX);\n}\n\nstatic inline char *\nbuf_str (const struct buffer *buf)\n{\n  return (char *)buf_bptr(buf);\n}\n\nstatic inline void\nbuf_reset (struct buffer *buf)\n{\n  buf->capacity = 0;\n  buf->offset = 0;\n  buf->len = 0;\n  buf->data = NULL;\n}\n\nstatic inline void\nbuf_reset_len (struct buffer *buf)\n{\n  buf->len = 0;\n  buf->offset = 0;\n}\n\nstatic inline bool\nbuf_init_dowork (struct buffer *buf, int offset)\n{\n  if (offset < 0 || offset > buf->capacity || buf->data == NULL)\n    return false;\n  buf->len = 0;\n  buf->offset = offset;\n  return true;\n}\n\nstatic inline void\nbuf_set_write (struct buffer *buf, uint8_t *data, int size)\n{\n  if (!buf_size_valid (size))\n    buf_size_error (size);\n  buf->len = 0;\n  buf->offset = 0;\n  buf->capacity = size;\n  buf->data = data;\n  if (size > 0 && data)\n    *data = 0;\n}\n\nstatic inline void\nbuf_set_read (struct buffer *buf, const uint8_t *data, int size)\n{\n  if (!buf_size_valid (size))\n    buf_size_error (size);\n  buf->len = buf->capacity = size;\n  buf->offset = 0;\n  buf->data = (uint8_t *)data;\n}\n\n/* Like strncpy but makes sure dest is always null terminated */\nstatic inline void\nstrncpynt (char *dest, const char *src, size_t maxlen)\n{\n  strncpy (dest, src, maxlen);\n  if (maxlen > 0)\n    dest[maxlen - 1] = 0;\n}\n\n/* return true if string contains at least one numerical digit */\nstatic inline bool\nhas_digit (const unsigned char* src)\n{\n  unsigned char c;\n  while ((c = *src++))\n    {\n      if (isdigit(c))\n\treturn true;\n    }\n  return false;\n}\n\n/*\n * printf append to a buffer with overflow check\n */\nbool buf_printf (struct buffer *buf, const char *format, ...)\n#ifdef __GNUC__\n#if __USE_MINGW_ANSI_STDIO\n\t__attribute__ ((format (gnu_printf, 2, 3)))\n#else\n\t__attribute__ ((format (__printf__, 2, 3)))\n#endif\n#endif\n    ;\n\n/*\n * puts append to a buffer with overflow check\n */\nbool buf_puts (struct buffer *buf, const char *str);\n\n/*\n * Like snprintf but guarantees null termination for size > 0\n */\nbool openvpn_snprintf(char *str, size_t size, const char *format, ...)\n#ifdef __GNUC__\n#if __USE_MINGW_ANSI_STDIO\n\t__attribute__ ((format (gnu_printf, 3, 4)))\n#else\n\t__attribute__ ((format (__printf__, 3, 4)))\n#endif\n#endif\n    ;\n\n/*\n * remove/add trailing characters\n */\n\nvoid buf_null_terminate (struct buffer *buf);\nvoid buf_chomp (struct buffer *buf);\nvoid buf_rmtail (struct buffer *buf, uint8_t remove);\n\n/*\n * non-buffer string functions\n */\nvoid chomp (char *str);\nvoid rm_trailing_chars (char *str, const char *what_to_delete);\nconst char *skip_leading_whitespace (const char *str);\nvoid string_null_terminate (char *str, int len, int capacity);\n\n/*\n * Write string in buf to file descriptor fd.\n * NOTE: requires that string be null terminated.\n */\nvoid buf_write_string_file (const struct buffer *buf, const char *filename, int fd);\n\n/*\n * write a string to the end of a buffer that was\n * truncated by buf_printf\n */\nvoid buf_catrunc (struct buffer *buf, const char *str);\n\n/*\n * convert a multi-line output to one line\n */\nvoid convert_to_one_line (struct buffer *buf);\n\n/*\n * Parse a string based on a given delimiter char\n */\nbool buf_parse (struct buffer *buf, const int delim, char *line, const int size);\n\n/*\n * Hex dump -- Output a binary buffer to a hex string and return it.\n */\nchar *\nformat_hex_ex (const uint8_t *data, int size, int maxoutput,\n\t       int space_break, const char* separator,\n\t       struct gc_arena *gc);\n\nstatic inline char *\nformat_hex (const uint8_t *data, int size, int maxoutput, struct gc_arena *gc)\n{\n  return format_hex_ex (data, size, maxoutput, 4, \" \", gc);\n}\n\n/*\n * Return a buffer that is a subset of another buffer.\n */\nstruct buffer buf_sub (struct buffer *buf, int size, bool prepend);\n\n/*\n * Check if sufficient space to append to buffer.\n */\n\nstatic inline bool\nbuf_safe (const struct buffer *buf, int len)\n{\n  return buf_valid (buf) && buf_size_valid (len)\n    && buf->offset + buf->len + len <= buf->capacity;\n}\n\nstatic inline bool\nbuf_safe_bidir (const struct buffer *buf, int len)\n{\n  if (buf_valid (buf) && buf_size_valid_signed (len))\n    {\n      const int newlen = buf->len + len;\n      return newlen >= 0 && buf->offset + newlen <= buf->capacity;\n    }\n  else\n    return false;\n}\n\nstatic inline int\nbuf_forward_capacity (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    {\n      int ret = buf->capacity - (buf->offset + buf->len);\n      if (ret < 0)\n\tret = 0;\n      return ret;\n    }\n  else\n    return 0;\n}\n\nstatic inline int\nbuf_forward_capacity_total (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    {\n      int ret = buf->capacity - buf->offset;\n      if (ret < 0)\n\tret = 0;\n      return ret;\n    }\n  else\n    return 0;\n}\n\nstatic inline int\nbuf_reverse_capacity (const struct buffer *buf)\n{\n  if (buf_valid (buf))\n    return buf->offset;\n  else\n    return 0;\n}\n\nstatic inline bool\nbuf_inc_len (struct buffer *buf, int inc)\n{\n  if (!buf_safe_bidir (buf, inc))\n    return false;\n  buf->len += inc;\n  return true;\n}\n\n/*\n * Make space to prepend to a buffer.\n * Return NULL if no space.\n */\n\nstatic inline uint8_t *\nbuf_prepend (struct buffer *buf, int size)\n{\n  if (!buf_valid (buf) || size < 0 || size > buf->offset)\n    return NULL;\n  buf->offset -= size;\n  buf->len += size;\n  return BPTR (buf);\n}\n\nstatic inline bool\nbuf_advance (struct buffer *buf, int size)\n{\n  if (!buf_valid (buf) || size < 0 || buf->len < size)\n    return false;\n  buf->offset += size;\n  buf->len -= size;\n  return true;\n}\n\n/*\n * Return a pointer to allocated space inside a buffer.\n * Return NULL if no space.\n */\n\nstatic inline uint8_t *\nbuf_write_alloc (struct buffer *buf, int size)\n{\n  uint8_t *ret;\n  if (!buf_safe (buf, size))\n    return NULL;\n  ret = BPTR (buf) + buf->len;\n  buf->len += size;\n  return ret;\n}\n\nstatic inline uint8_t *\nbuf_write_alloc_prepend (struct buffer *buf, int size, bool prepend)\n{\n  return prepend ? buf_prepend (buf, size) : buf_write_alloc (buf, size);\n}\n\nstatic inline uint8_t *\nbuf_read_alloc (struct buffer *buf, int size)\n{\n  uint8_t *ret;\n  if (size < 0 || buf->len < size)\n    return NULL;\n  ret = BPTR (buf);\n  buf->offset += size;\n  buf->len -= size;\n  return ret;\n}\n\nstatic inline bool\nbuf_write (struct buffer *dest, const void *src, int size)\n{\n  uint8_t *cp = buf_write_alloc (dest, size);\n  if (!cp)\n    return false;\n  memcpy (cp, src, size);\n  return true;\n}\n\nstatic inline bool\nbuf_write_prepend (struct buffer *dest, const void *src, int size)\n{\n  uint8_t *cp = buf_prepend (dest, size);\n  if (!cp)\n    return false;\n  memcpy (cp, src, size);\n  return true;\n}\n\nstatic inline bool\nbuf_write_u8 (struct buffer *dest, int data)\n{\n  uint8_t u8 = (uint8_t) data;\n  return buf_write (dest, &u8, sizeof (uint8_t));\n}\n\nstatic inline bool\nbuf_write_u16 (struct buffer *dest, int data)\n{\n  uint16_t u16 = htons ((uint16_t) data);\n  return buf_write (dest, &u16, sizeof (uint16_t));\n}\n\nstatic inline bool\nbuf_write_u32 (struct buffer *dest, int data)\n{\n  uint32_t u32 = htonl ((uint32_t) data);\n  return buf_write (dest, &u32, sizeof (uint32_t));\n}\n\nstatic inline bool\nbuf_copy (struct buffer *dest, const struct buffer *src)\n{\n  return buf_write (dest, BPTR (src), BLEN (src));\n}\n\nstatic inline bool\nbuf_copy_n (struct buffer *dest, struct buffer *src, int n)\n{\n  uint8_t *cp = buf_read_alloc (src, n);\n  if (!cp)\n    return false;\n  return buf_write (dest, cp, n);\n}\n\nstatic inline bool\nbuf_copy_range (struct buffer *dest,\n\t\tint dest_index,\n\t\tconst struct buffer *src,\n\t\tint src_index,\n\t\tint src_len)\n{\n  if (src_index < 0\n      || src_len < 0\n      || src_index + src_len > src->len\n      || dest_index < 0\n      || dest->offset + dest_index + src_len > dest->capacity)\n    return false;\n  memcpy (dest->data + dest->offset + dest_index, src->data + src->offset + src_index, src_len);\n  if (dest_index + src_len > dest->len)\n    dest->len = dest_index + src_len;\n  return true;\n}\n\n/* truncate src to len, copy excess data beyond len to dest */\nstatic inline bool\nbuf_copy_excess (struct buffer *dest,\n\t\t struct buffer *src,\n\t\t int len)\n{\n  if (len < 0)\n    return false;\n  if (src->len > len)\n    {\n      struct buffer b = *src;\n      src->len = len;\n      if (!buf_advance (&b, len))\n\treturn false;\n      return buf_copy (dest, &b);\n    }\n  else\n    {\n      return true;\n    }\n}\n\nstatic inline bool\nbuf_read (struct buffer *src, void *dest, int size)\n{\n  uint8_t *cp = buf_read_alloc (src, size);\n  if (!cp)\n    return false;\n  memcpy (dest, cp, size);\n  return true;\n}\n\nstatic inline int\nbuf_read_u8 (struct buffer *buf)\n{\n  int ret;\n  if (BLEN (buf) < 1)\n    return -1;\n  ret = *BPTR(buf);\n  buf_advance (buf, 1);\n  return ret;\n}\n\nstatic inline int\nbuf_read_u16 (struct buffer *buf)\n{\n  uint16_t ret;\n  if (!buf_read (buf, &ret, sizeof (uint16_t)))\n    return -1;\n  return ntohs (ret);\n}\n\nstatic inline uint32_t\nbuf_read_u32 (struct buffer *buf, bool *good)\n{\n  uint32_t ret;\n  if (!buf_read (buf, &ret, sizeof (uint32_t)))\n    {\n      if (good)\n\t*good = false;\n      return 0;\n    }\n  else\n    {\n      if (good)\n\t*good = true;\n      return ntohl (ret);\n    }\n}\n\n/**\n * Compare src buffer contents with match.\n * *NOT* constant time. Do not use when comparing HMACs.\n */\nstatic inline bool\nbuf_string_match (const struct buffer *src, const void *match, int size)\n{\n  if (size != src->len)\n    return false;\n  return memcmp (BPTR (src), match, size) == 0;\n}\n\n/**\n * Compare first size bytes of src buffer contents with match.\n * *NOT* constant time. Do not use when comparing HMACs.\n */\nstatic inline bool\nbuf_string_match_head (const struct buffer *src, const void *match, int size)\n{\n  if (size < 0 || size > src->len)\n    return false;\n  return memcmp (BPTR (src), match, size) == 0;\n}\n\nbool buf_string_match_head_str (const struct buffer *src, const char *match);\nbool buf_string_compare_advance (struct buffer *src, const char *match);\nint buf_substring_len (const struct buffer *buf, int delim);\n\n/*\n * Print a string which might be NULL\n */\nconst char *np (const char *str);\n\n/*#define CHARACTER_CLASS_DEBUG*/\n\n/* character classes */\n\n#define CC_ANY                (1<<0)\n#define CC_NULL               (1<<1)\n\n#define CC_ALNUM              (1<<2)\n#define CC_ALPHA              (1<<3)\n#define CC_ASCII              (1<<4)\n#define CC_CNTRL              (1<<5)\n#define CC_DIGIT              (1<<6)\n#define CC_PRINT              (1<<7)\n#define CC_PUNCT              (1<<8)\n#define CC_SPACE              (1<<9)\n#define CC_XDIGIT             (1<<10)\n\n#define CC_BLANK              (1<<11)\n#define CC_NEWLINE            (1<<12)\n#define CC_CR                 (1<<13)\n\n#define CC_BACKSLASH          (1<<14)\n#define CC_UNDERBAR           (1<<15)\n#define CC_DASH               (1<<16)\n#define CC_DOT                (1<<17)\n#define CC_COMMA              (1<<18)\n#define CC_COLON              (1<<19)\n#define CC_SLASH              (1<<20)\n#define CC_SINGLE_QUOTE       (1<<21)\n#define CC_DOUBLE_QUOTE       (1<<22)\n#define CC_REVERSE_QUOTE      (1<<23)\n#define CC_AT                 (1<<24)\n#define CC_EQUAL              (1<<25)\n#define CC_LESS_THAN          (1<<26)\n#define CC_GREATER_THAN       (1<<27)\n#define CC_PIPE               (1<<28)\n#define CC_QUESTION_MARK      (1<<29)\n#define CC_ASTERISK           (1<<30)\n\n/* macro classes */\n#define CC_NAME               (CC_ALNUM|CC_UNDERBAR)\n#define CC_CRLF               (CC_CR|CC_NEWLINE)\n\nbool char_class (const unsigned char c, const unsigned int flags);\nbool string_class (const char *str, const unsigned int inclusive, const unsigned int exclusive);\nbool string_mod (char *str, const unsigned int inclusive, const unsigned int exclusive, const char replace);\n\nconst char *string_mod_const (const char *str,\n\t\t\t      const unsigned int inclusive,\n\t\t\t      const unsigned int exclusive,\n\t\t\t      const char replace,\n\t\t\t      struct gc_arena *gc);\n\nvoid string_replace_leading (char *str, const char match, const char replace);\n\n#ifdef CHARACTER_CLASS_DEBUG\nvoid character_class_debug (void);\n#endif\n\n/*\n * Verify that a pointer is correctly aligned\n */\n#ifdef VERIFY_ALIGNMENT\n  void valign4 (const struct buffer *buf, const char *file, const int line);\n# define verify_align_4(ptr) valign4(buf, __FILE__, __LINE__)\n#else\n# define verify_align_4(ptr)\n#endif\n\n/*\n * Very basic garbage collection, mostly for routines that return\n * char ptrs to malloced strings.\n */\n\nvoid gc_transfer (struct gc_arena *dest, struct gc_arena *src);\n\nvoid x_gc_free (struct gc_arena *a);\n\nstatic inline bool\ngc_defined (struct gc_arena *a)\n{\n  return a->list != NULL;\n}\n\nstatic inline void\ngc_init (struct gc_arena *a)\n{\n  a->list = NULL;\n}\n\nstatic inline void\ngc_detach (struct gc_arena *a)\n{\n  gc_init (a);\n}\n\nstatic inline struct gc_arena\ngc_new (void)\n{\n  struct gc_arena ret;\n  ret.list = NULL;\n  return ret;\n}\n\nstatic inline void\ngc_free (struct gc_arena *a)\n{\n  if (a->list)\n    x_gc_free (a);\n}\n\nstatic inline void\ngc_reset (struct gc_arena *a)\n{\n  gc_free (a);\n}\n\n/*\n * Allocate memory to hold a structure\n */\n\n#define ALLOC_OBJ(dptr, type) \\\n{ \\\n  check_malloc_return ((dptr) = (type *) malloc (sizeof (type))); \\\n}\n\n#define ALLOC_OBJ_CLEAR(dptr, type) \\\n{ \\\n  ALLOC_OBJ (dptr, type); \\\n  memset ((dptr), 0, sizeof(type)); \\\n}\n\n#define ALLOC_ARRAY(dptr, type, n) \\\n{ \\\n  check_malloc_return ((dptr) = (type *) malloc (array_mult_safe (sizeof (type), (n), 0))); \\\n}\n\n#define ALLOC_ARRAY_GC(dptr, type, n, gc) \\\n{ \\\n  (dptr) = (type *) gc_malloc (array_mult_safe (sizeof (type), (n), 0), false, (gc)); \\\n}\n\n#define ALLOC_ARRAY_CLEAR(dptr, type, n) \\\n{ \\\n  ALLOC_ARRAY (dptr, type, n); \\\n  memset ((dptr), 0, (array_mult_safe (sizeof(type), (n), 0)));\t\\\n}\n\n#define ALLOC_ARRAY_CLEAR_GC(dptr, type, n, gc) \\\n{ \\\n  (dptr) = (type *) gc_malloc (array_mult_safe (sizeof (type), (n), 0), true, (gc)); \\\n}\n\n#define ALLOC_VAR_ARRAY_CLEAR_GC(dptr, type, atype, n, gc)\t\\\n{ \\\n  (dptr) = (type *) gc_malloc (array_mult_safe (sizeof (atype), (n), sizeof (type)), true, (gc)); \\\n}\n\n#define ALLOC_OBJ_GC(dptr, type, gc) \\\n{ \\\n  (dptr) = (type *) gc_malloc (sizeof (type), false, (gc)); \\\n}\n\n#define ALLOC_OBJ_CLEAR_GC(dptr, type, gc) \\\n{ \\\n  (dptr) = (type *) gc_malloc (sizeof (type), true, (gc)); \\\n}\n\nstatic inline void\ncheck_malloc_return (void *p)\n{\n  if (!p)\n    out_of_memory ();\n}\n\n/*\n * Manage lists of buffers\n */\n\n#ifdef ENABLE_BUFFER_LIST\n\nstruct buffer_entry\n{\n  struct buffer buf;\n  struct buffer_entry *next;\n};\n\nstruct buffer_list\n{\n  struct buffer_entry *head; /* next item to pop/peek */\n  struct buffer_entry *tail; /* last item pushed */\n  int size;                  /* current number of entries */\n  int max_size;              /* maximum size list should grow to */\n};\n\nstruct buffer_list *buffer_list_new (const int max_size);\nvoid buffer_list_free (struct buffer_list *ol);\n\nbool buffer_list_defined (const struct buffer_list *ol);\nvoid buffer_list_reset (struct buffer_list *ol);\n\nvoid buffer_list_push (struct buffer_list *ol, const unsigned char *str);\nstruct buffer_entry *buffer_list_push_data (struct buffer_list *ol, const uint8_t *data, size_t size);\nstruct buffer *buffer_list_peek (struct buffer_list *ol);\nvoid buffer_list_advance (struct buffer_list *ol, int n);\nvoid buffer_list_pop (struct buffer_list *ol);\n\nvoid buffer_list_aggregate (struct buffer_list *bl, const size_t max);\n\nstruct buffer_list *buffer_list_file (const char *fn, int max_line_len);\n\n#endif\n\n#endif /* BUFFER_H */\n", "/*\n *  OpenVPN -- An application to securely tunnel IP networks\n *             over a single TCP/UDP port, with support for SSL/TLS-based\n *             session authentication and key exchange,\n *             packet encryption, packet authentication, and\n *             packet compression.\n *\n *  Copyright (C) 2002-2010 OpenVPN Technologies, Inc. <sales@openvpn.net>\n *  Copyright (C) 2010 Fox Crypto B.V. <openvpn@fox-it.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program (see the file COPYING included with this\n *  distribution); if not, write to the Free Software Foundation, Inc.,\n *  59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#elif defined(_MSC_VER)\n#include \"config-msvc.h\"\n#endif\n\n#include \"syshead.h\"\n\n#ifdef ENABLE_CRYPTO\n\n#include \"crypto.h\"\n#include \"error.h\"\n#include \"misc.h\"\n\n#include \"memdbg.h\"\n\n/*\n * Encryption and Compression Routines.\n *\n * On entry, buf contains the input data and length.\n * On exit, it should be set to the output data and length.\n *\n * If buf->len is <= 0 we should return\n * If buf->len is set to 0 on exit it tells the caller to ignore the packet.\n *\n * work is a workspace buffer we are given of size BUF_SIZE.\n * work may be used to return output data, or the input buffer\n * may be modified and returned as output.  If output data is\n * returned in work, the data should start after FRAME_HEADROOM bytes\n * of padding to leave room for downstream routines to prepend.\n *\n * Up to a total of FRAME_HEADROOM bytes may be prepended to the input buf\n * by all routines (encryption, decryption, compression, and decompression).\n *\n * Note that the buf_prepend return will assert if we try to\n * make a header bigger than FRAME_HEADROOM.  This should not\n * happen unless the frame parameters are wrong.\n */\n\n#define CRYPT_ERROR(format) \\\n  do { msg (D_CRYPT_ERRORS, \"%s: \" format, error_prefix); goto error_exit; } while (false)\n\n/**\n * As memcmp(), but constant-time.\n * Returns 0 when data is equal, non-zero otherwise.\n */\nstatic int\nmemcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n\n  return ret;\n}\n\nvoid\nopenvpn_encrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->encrypt;\n\n      /* Do Encrypt from buf -> work */\n      if (ctx->cipher)\n\t{\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  int outlen;\n\n\t  if (mode == OPENVPN_MODE_CBC)\n\t    {\n\t      CLEAR (iv_buf);\n\n\t      /* generate pseudo-random IV */\n\t      if (opt->flags & CO_USE_IV)\n\t\tprng_bytes (iv_buf, iv_size);\n\n\t      /* Put packet ID in plaintext buffer or IV, depending on cipher mode */\n\t      if (opt->packet_id)\n\t\t{\n\t\t  struct packet_id_net pin;\n\t\t  packet_id_alloc_outgoing (&opt->packet_id->send, &pin, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM));\n\t\t  ASSERT (packet_id_write (&pin, buf, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM), true));\n\t\t}\n\t    }\n\t  else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t    {\n\t      struct packet_id_net pin;\n\t      struct buffer b;\n\n\t      ASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t      ASSERT (opt->packet_id); /*  for this mode. */\n\n\t      packet_id_alloc_outgoing (&opt->packet_id->send, &pin, true);\n\t      memset (iv_buf, 0, iv_size);\n\t      buf_set_write (&b, iv_buf, iv_size);\n\t      ASSERT (packet_id_write (&pin, &b, true, false));\n\t    }\n\t  else /* We only support CBC, CFB, or OFB modes right now */\n\t    {\n\t      ASSERT (0);\n\t    }\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM (frame)));\n\n\t  /* set the IV pseudo-randomly */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"ENCRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  dmsg (D_PACKET_CONTENT, \"ENCRYPT FROM: %s\",\n\t       format_hex (BPTR (buf), BLEN (buf), 80, &gc));\n\n\t  /* cipher_ctx was already initialized with key & keylen */\n\t  ASSERT (cipher_ctx_reset(ctx->cipher, iv_buf));\n\n\t  /* Buffer overflow check */\n\t  if (!buf_safe (&work, buf->len + cipher_ctx_block_size(ctx->cipher)))\n\t    {\n\t      msg (D_CRYPT_ERRORS, \"ENCRYPT: buffer size error, bc=%d bo=%d bl=%d wc=%d wo=%d wl=%d cbs=%d\",\n\t\t   buf->capacity,\n\t\t   buf->offset,\n\t\t   buf->len,\n\t\t   work.capacity,\n\t\t   work.offset,\n\t\t   work.len,\n\t\t   cipher_ctx_block_size (ctx->cipher));\n\t      goto err;\n\t    }\n\n\t  /* Encrypt packet ID, payload */\n\t  ASSERT (cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)));\n\t  work.len += outlen;\n\n\t  /* Flush the encryption buffer */\n\t  ASSERT(cipher_ctx_final(ctx->cipher, BPTR (&work) + outlen, &outlen));\n\t  work.len += outlen;\n\t  ASSERT (outlen == iv_size);\n\n\t  /* prepend the IV to the ciphertext */\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      uint8_t *output = buf_prepend (&work, iv_size);\n\t      ASSERT (output);\n\t      memcpy (output, iv_buf, iv_size);\n\t    }\n\n\t  dmsg (D_PACKET_CONTENT, \"ENCRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\t}\n      else\t\t\t\t/* No Encryption */\n\t{\n\t  if (opt->packet_id)\n\t    {\n\t      struct packet_id_net pin;\n\t      packet_id_alloc_outgoing (&opt->packet_id->send, &pin, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM));\n\t      ASSERT (packet_id_write (&pin, buf, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM), true));\n\t    }\n\t  work = *buf;\n\t}\n\n      /* HMAC the ciphertext (or plaintext if !cipher) */\n      if (ctx->hmac)\n\t{\n\t  uint8_t *output = NULL;\n\n\t  hmac_ctx_reset (ctx->hmac);\n\t  hmac_ctx_update (ctx->hmac, BPTR(&work), BLEN(&work));\n\t  output = buf_prepend (&work, hmac_ctx_size(ctx->hmac));\n\t  ASSERT (output);\n\t  hmac_ctx_final (ctx->hmac, output);\n\t}\n\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return;\n\nerr:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return;\n}\n\n/*\n * If (opt->flags & CO_USE_IV) is not NULL, we will read an IV from the packet.\n *\n * Set buf->len to 0 and return false on decrypt error.\n *\n * On success, buf is set to point to plaintext, true\n * is returned.\n */\nbool\nopenvpn_decrypt (struct buffer *buf, struct buffer work,\n\t\t const struct crypto_options *opt,\n\t\t const struct frame* frame)\n{\n  static const char error_prefix[] = \"Authenticate/Decrypt packet error\";\n  struct gc_arena gc;\n  gc_init (&gc);\n\n  if (buf->len > 0 && opt->key_ctx_bi)\n    {\n      struct key_ctx *ctx = &opt->key_ctx_bi->decrypt;\n      struct packet_id_net pin;\n      bool have_pin = false;\n\n      /* Verify the HMAC */\n      if (ctx->hmac)\n\t{\n\t  int hmac_len;\n\t  uint8_t local_hmac[MAX_HMAC_KEY_LENGTH]; /* HMAC of ciphertext computed locally */\n\n\t  hmac_ctx_reset(ctx->hmac);\n\n\t  /* Assume the length of the input HMAC */\n\t  hmac_len = hmac_ctx_size (ctx->hmac);\n\n\t  /* Authentication fails if insufficient data in packet for HMAC */\n\t  if (buf->len < hmac_len)\n\t    CRYPT_ERROR (\"missing authentication info\");\n\n\t  hmac_ctx_update (ctx->hmac, BPTR (buf) + hmac_len, BLEN (buf) - hmac_len);\n\t  hmac_ctx_final (ctx->hmac, local_hmac);\n\n\t  /* Compare locally computed HMAC with packet HMAC */\n\t  if (memcmp_constant_time (local_hmac, BPTR (buf), hmac_len))\n\t    CRYPT_ERROR (\"packet HMAC authentication failed\");\n\n\t  ASSERT (buf_advance (buf, hmac_len));\n\t}\n\n      /* Decrypt packet ID + payload */\n\n      if (ctx->cipher)\n\t{\n\t  const unsigned int mode = cipher_ctx_mode (ctx->cipher);\n\t  const int iv_size = cipher_ctx_iv_length (ctx->cipher);\n\t  uint8_t iv_buf[OPENVPN_MAX_IV_LENGTH];\n\t  int outlen;\n\n\t  /* initialize work buffer with FRAME_HEADROOM bytes of prepend capacity */\n\t  ASSERT (buf_init (&work, FRAME_HEADROOM_ADJ (frame, FRAME_HEADROOM_MARKER_DECRYPT)));\n\n\t  /* use IV if user requested it */\n\t  CLEAR (iv_buf);\n\t  if (opt->flags & CO_USE_IV)\n\t    {\n\t      if (buf->len < iv_size)\n\t\tCRYPT_ERROR (\"missing IV info\");\n\t      memcpy (iv_buf, BPTR (buf), iv_size);\n\t      ASSERT (buf_advance (buf, iv_size));\n\t    }\n\n\t  /* show the IV's initial state */\n\t  if (opt->flags & CO_USE_IV)\n\t    dmsg (D_PACKET_CONTENT, \"DECRYPT IV: %s\", format_hex (iv_buf, iv_size, 0, &gc));\n\n\t  if (buf->len < 1)\n\t    CRYPT_ERROR (\"missing payload\");\n\n\t  /* ctx->cipher was already initialized with key & keylen */\n\t  if (!cipher_ctx_reset (ctx->cipher, iv_buf))\n\t    CRYPT_ERROR (\"cipher init failed\");\n\n\t  /* Buffer overflow check (should never happen) */\n\t  if (!buf_safe (&work, buf->len))\n\t    CRYPT_ERROR (\"buffer overflow\");\n\n\t  /* Decrypt packet ID, payload */\n\t  if (!cipher_ctx_update (ctx->cipher, BPTR (&work), &outlen, BPTR (buf), BLEN (buf)))\n\t    CRYPT_ERROR (\"cipher update failed\");\n\t  work.len += outlen;\n\n\t  /* Flush the decryption buffer */\n\t  if (!cipher_ctx_final (ctx->cipher, BPTR (&work) + outlen, &outlen))\n\t    CRYPT_ERROR (\"cipher final failed\");\n\t  work.len += outlen;\n\n\t  dmsg (D_PACKET_CONTENT, \"DECRYPT TO: %s\",\n\t       format_hex (BPTR (&work), BLEN (&work), 80, &gc));\n\n\t  /* Get packet ID from plaintext buffer or IV, depending on cipher mode */\n\t  {\n\t    if (mode == OPENVPN_MODE_CBC)\n\t      {\n\t\tif (opt->packet_id)\n\t\t  {\n\t\t    if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\t      CRYPT_ERROR (\"error reading CBC packet-id\");\n\t\t    have_pin = true;\n\t\t  }\n\t      }\n\t    else if (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB)\n\t      {\n\t\tstruct buffer b;\n\n\t\tASSERT (opt->flags & CO_USE_IV);    /* IV and packet-ID required */\n\t\tASSERT (opt->packet_id); /*  for this mode. */\n\n\t\tbuf_set_read (&b, iv_buf, iv_size);\n\t\tif (!packet_id_read (&pin, &b, true))\n\t\t  CRYPT_ERROR (\"error reading CFB/OFB packet-id\");\n\t\thave_pin = true;\n\t      }\n\t    else /* We only support CBC, CFB, or OFB modes right now */\n\t      {\n\t\tASSERT (0);\n\t      }\n\t  }\n\t}\n      else\n\t{\n\t  work = *buf;\n\t  if (opt->packet_id)\n\t    {\n\t      if (!packet_id_read (&pin, &work, BOOL_CAST (opt->flags & CO_PACKET_ID_LONG_FORM)))\n\t\tCRYPT_ERROR (\"error reading packet-id\");\n\t      have_pin = !BOOL_CAST (opt->flags & CO_IGNORE_PACKET_ID);\n\t    }\n\t}\n      \n      if (have_pin)\n\t{\n\t  packet_id_reap_test (&opt->packet_id->rec);\n\t  if (packet_id_test (&opt->packet_id->rec, &pin))\n\t    {\n\t      packet_id_add (&opt->packet_id->rec, &pin);\n\t      if (opt->pid_persist && (opt->flags & CO_PACKET_ID_LONG_FORM))\n\t\tpacket_id_persist_save_obj (opt->pid_persist, opt->packet_id);\n\t    }\n\t  else\n\t    {\n\t      if (!(opt->flags & CO_MUTE_REPLAY_WARNINGS))\n\t      msg (D_REPLAY_ERRORS, \"%s: bad packet ID (may be a replay): %s -- see the man page entry for --no-replay and --replay-window for more info or silence this warning with --mute-replay-warnings\",\n\t\t   error_prefix, packet_id_net_print (&pin, true, &gc));\n\t      goto error_exit;\n\t    }\n\t}\n      *buf = work;\n    }\n\n  gc_free (&gc);\n  return true;\n\n error_exit:\n  crypto_clear_error();\n  buf->len = 0;\n  gc_free (&gc);\n  return false;\n}\n\n/*\n * How many bytes will we add to frame buffer for a given\n * set of crypto options?\n */\nvoid\ncrypto_adjust_frame_parameters(struct frame *frame,\n\t\t\t       const struct key_type* kt,\n\t\t\t       bool cipher_defined,\n\t\t\t       bool use_iv,\n\t\t\t       bool packet_id,\n\t\t\t       bool packet_id_long_form)\n{\n  frame_add_to_extra_frame (frame,\n\t\t\t    (packet_id ? packet_id_size (packet_id_long_form) : 0) +\n\t\t\t    ((cipher_defined && use_iv) ? cipher_kt_iv_size (kt->cipher) : 0) +\n\t\t\t    (cipher_defined ? cipher_kt_block_size (kt->cipher) : 0) + /* worst case padding expansion */\n\t\t\t    kt->hmac_length);\n}\n\n/*\n * Build a struct key_type.\n */\nvoid\ninit_key_type (struct key_type *kt, const char *ciphername,\n\t       bool ciphername_defined, const char *authname,\n\t       bool authname_defined, int keysize,\n\t       bool cfb_ofb_allowed, bool warn)\n{\n  CLEAR (*kt);\n  if (ciphername && ciphername_defined)\n    {\n      kt->cipher = cipher_kt_get (translate_cipher_name_from_openvpn(ciphername));\n      kt->cipher_length = cipher_kt_key_size (kt->cipher);\n      if (keysize > 0 && keysize <= MAX_CIPHER_KEY_LENGTH)\n\tkt->cipher_length = keysize;\n\n      /* check legal cipher mode */\n      {\n\tconst unsigned int mode = cipher_kt_mode (kt->cipher);\n\tif (!(mode == OPENVPN_MODE_CBC\n#ifdef ALLOW_NON_CBC_CIPHERS\n\t      || (cfb_ofb_allowed && (mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB))\n#endif\n\t      ))\n#ifdef ENABLE_SMALL\n\t  msg (M_FATAL, \"Cipher '%s' mode not supported\", ciphername);\n#else\n\t  msg (M_FATAL, \"Cipher '%s' uses a mode not supported by \" PACKAGE_NAME \" in your current configuration.  CBC mode is always supported, while CFB and OFB modes are supported only when using SSL/TLS authentication and key exchange mode, and when \" PACKAGE_NAME \" has been built with ALLOW_NON_CBC_CIPHERS.\", ciphername);\n#endif\n      }\n    }\n  else\n    {\n      if (warn)\n\tmsg (M_WARN, \"******* WARNING *******: null cipher specified, no encryption will be used\");\n    }\n  if (authname && authname_defined)\n    {\n      kt->digest = md_kt_get (authname);\n      kt->hmac_length = md_kt_size (kt->digest);\n    }\n  else\n    {\n      if (warn)\n\tmsg (M_WARN, \"******* WARNING *******: null MAC specified, no authentication will be used\");\n    }\n}\n\n/* given a key and key_type, build a key_ctx */\nvoid\ninit_key_ctx (struct key_ctx *ctx, struct key *key,\n\t      const struct key_type *kt, int enc,\n\t      const char *prefix)\n{\n  struct gc_arena gc = gc_new ();\n  CLEAR (*ctx);\n  if (kt->cipher && kt->cipher_length > 0)\n    {\n\n      ALLOC_OBJ(ctx->cipher, cipher_ctx_t);\n      cipher_ctx_init (ctx->cipher, key->cipher, kt->cipher_length,\n\t  kt->cipher, enc);\n\n      msg (D_HANDSHAKE, \"%s: Cipher '%s' initialized with %d bit key\",\n          prefix,\n          cipher_kt_name(kt->cipher),\n          kt->cipher_length *8);\n\n      dmsg (D_SHOW_KEYS, \"%s: CIPHER KEY: %s\", prefix,\n          format_hex (key->cipher, kt->cipher_length, 0, &gc));\n      dmsg (D_CRYPTO_DEBUG, \"%s: CIPHER block_size=%d iv_size=%d\",\n          prefix,\n          cipher_kt_block_size(kt->cipher),\n          cipher_kt_iv_size(kt->cipher));\n    }\n  if (kt->digest && kt->hmac_length > 0)\n    {\n      ALLOC_OBJ(ctx->hmac, hmac_ctx_t);\n      hmac_ctx_init (ctx->hmac, key->hmac, kt->hmac_length, kt->digest);\n\n      msg (D_HANDSHAKE,\n      \"%s: Using %d bit message hash '%s' for HMAC authentication\",\n      prefix, md_kt_size(kt->digest) * 8, md_kt_name(kt->digest));\n\n      dmsg (D_SHOW_KEYS, \"%s: HMAC KEY: %s\", prefix,\n\t  format_hex (key->hmac, kt->hmac_length, 0, &gc));\n\n      dmsg (D_CRYPTO_DEBUG, \"%s: HMAC size=%d block_size=%d\",\n\tprefix,\n\tmd_kt_size(kt->digest),\n\thmac_ctx_size(ctx->hmac));\n\n    }\n  gc_free (&gc);\n}\n\nvoid\nfree_key_ctx (struct key_ctx *ctx)\n{\n  if (ctx->cipher)\n    {\n      cipher_ctx_cleanup(ctx->cipher);\n      free(ctx->cipher);\n      ctx->cipher = NULL;\n    }\n  if (ctx->hmac)\n    {\n      hmac_ctx_cleanup(ctx->hmac);\n      free(ctx->hmac);\n      ctx->hmac = NULL;\n    }\n}\n\nvoid\nfree_key_ctx_bi (struct key_ctx_bi *ctx)\n{\n  free_key_ctx(&ctx->encrypt);\n  free_key_ctx(&ctx->decrypt);\n}\n\n\nstatic bool\nkey_is_zero (struct key *key, const struct key_type *kt)\n{\n  int i;\n  for (i = 0; i < kt->cipher_length; ++i)\n    if (key->cipher[i])\n      return false;\n  msg (D_CRYPT_ERRORS, \"CRYPTO INFO: WARNING: zero key detected\");\n  return true;\n}\n\n/*\n * Make sure that cipher key is a valid key for current key_type.\n */\nbool\ncheck_key (struct key *key, const struct key_type *kt)\n{\n  if (kt->cipher)\n    {\n      /*\n       * Check for zero key\n       */\n      if (key_is_zero(key, kt))\n\treturn false;\n\n      /*\n       * Check for weak or semi-weak DES keys.\n       */\n      {\n\tconst int ndc = key_des_num_cblocks (kt->cipher);\n\tif (ndc)\n\t  return key_des_check (key->cipher, kt->cipher_length, ndc);\n\telse\n\t  return true;\n      }\n    }\n  return true;\n}\n\n/*\n * Make safe mutations to key to ensure it is valid,\n * such as ensuring correct parity on DES keys.\n *\n * This routine cannot guarantee it will generate a good\n * key.  You must always call check_key after this routine\n * to make sure.\n */ \nvoid\nfixup_key (struct key *key, const struct key_type *kt)\n{\n  struct gc_arena gc = gc_new ();\n  if (kt->cipher)\n    {\n#ifdef ENABLE_DEBUG\n      const struct key orig = *key;\n#endif\n      const int ndc = key_des_num_cblocks (kt->cipher);\n\n      if (ndc)\n\tkey_des_fixup (key->cipher, kt->cipher_length, ndc);\n\n#ifdef ENABLE_DEBUG\n      if (check_debug_level (D_CRYPTO_DEBUG))\n\t{\n\t  if (memcmp (orig.cipher, key->cipher, kt->cipher_length))\n\t    dmsg (D_CRYPTO_DEBUG, \"CRYPTO INFO: fixup_key: before=%s after=%s\",\n\t\t format_hex (orig.cipher, kt->cipher_length, 0, &gc),\n\t\t format_hex (key->cipher, kt->cipher_length, 0, &gc));\n\t}\n#endif\n    }\n  gc_free (&gc);\n}\n\nvoid\ncheck_replay_iv_consistency (const struct key_type *kt, bool packet_id, bool use_iv)\n{\n  if (cfb_ofb_mode (kt) && !(packet_id && use_iv))\n    msg (M_FATAL, \"--no-replay or --no-iv cannot be used with a CFB or OFB mode cipher\");\n}\n\nbool\ncfb_ofb_mode (const struct key_type* kt)\n{\n  if (kt && kt->cipher) {\n      const unsigned int mode = cipher_kt_mode (kt->cipher);\n      return mode == OPENVPN_MODE_CFB || mode == OPENVPN_MODE_OFB;\n  }\n  return false;\n}\n\n/*\n * Generate a random key.  If key_type is provided, make\n * sure generated key is valid for key_type.\n */\nvoid\ngenerate_key_random (struct key *key, const struct key_type *kt)\n{\n  int cipher_len = MAX_CIPHER_KEY_LENGTH;\n  int hmac_len = MAX_HMAC_KEY_LENGTH;\n\n  struct gc_arena gc = gc_new ();\n\n  do {\n    CLEAR (*key);\n    if (kt)\n      {\n\tif (kt->cipher && kt->cipher_length > 0 && kt->cipher_length <= cipher_len)\n\t  cipher_len = kt->cipher_length;\n\n\tif (kt->digest && kt->hmac_length > 0 && kt->hmac_length <= hmac_len)\n\t  hmac_len = kt->hmac_length;\n      }\n    if (!rand_bytes (key->cipher, cipher_len)\n\t|| !rand_bytes (key->hmac, hmac_len))\n      msg (M_FATAL, \"ERROR: Random number generator cannot obtain entropy for key generation\");\n\n    dmsg (D_SHOW_KEY_SOURCE, \"Cipher source entropy: %s\", format_hex (key->cipher, cipher_len, 0, &gc));\n    dmsg (D_SHOW_KEY_SOURCE, \"HMAC source entropy: %s\", format_hex (key->hmac, hmac_len, 0, &gc));\n\n    if (kt)\n      fixup_key (key, kt);\n  } while (kt && !check_key (key, kt));\n\n  gc_free (&gc);\n}\n\n/*\n * Print key material\n */\nvoid\nkey2_print (const struct key2* k,\n\t    const struct key_type *kt,\n\t    const char* prefix0,\n\t    const char* prefix1)\n{\n  struct gc_arena gc = gc_new ();\n  ASSERT (k->n == 2);\n  dmsg (D_SHOW_KEY_SOURCE, \"%s (cipher): %s\",\n       prefix0,\n       format_hex (k->keys[0].cipher, kt->cipher_length, 0, &gc));\n  dmsg (D_SHOW_KEY_SOURCE, \"%s (hmac): %s\",\n       prefix0,\n       format_hex (k->keys[0].hmac, kt->hmac_length, 0, &gc));\n  dmsg (D_SHOW_KEY_SOURCE, \"%s (cipher): %s\",\n       prefix1,\n       format_hex (k->keys[1].cipher, kt->cipher_length, 0, &gc));\n  dmsg (D_SHOW_KEY_SOURCE, \"%s (hmac): %s\",\n       prefix1,\n       format_hex (k->keys[1].hmac, kt->hmac_length, 0, &gc));\n  gc_free (&gc);\n}\n\nvoid\ntest_crypto (const struct crypto_options *co, struct frame* frame)\n{\n  int i, j;\n  struct gc_arena gc = gc_new ();\n  struct buffer src = alloc_buf_gc (TUN_MTU_SIZE (frame), &gc);\n  struct buffer work = alloc_buf_gc (BUF_SIZE (frame), &gc);\n  struct buffer encrypt_workspace = alloc_buf_gc (BUF_SIZE (frame), &gc);\n  struct buffer decrypt_workspace = alloc_buf_gc (BUF_SIZE (frame), &gc);\n  struct buffer buf = clear_buf();\n\n  /* init work */\n  ASSERT (buf_init (&work, FRAME_HEADROOM (frame)));\n\n  msg (M_INFO, \"Entering \" PACKAGE_NAME \" crypto self-test mode.\");\n  for (i = 1; i <= TUN_MTU_SIZE (frame); ++i)\n    {\n      update_time ();\n\n      msg (M_INFO, \"TESTING ENCRYPT/DECRYPT of packet length=%d\", i);\n\n      /*\n       * Load src with random data.\n       */\n      ASSERT (buf_init (&src, 0));\n      ASSERT (i <= src.capacity);\n      src.len = i;\n      ASSERT (rand_bytes (BPTR (&src), BLEN (&src)));\n\n      /* copy source to input buf */\n      buf = work;\n      memcpy (buf_write_alloc (&buf, BLEN (&src)), BPTR (&src), BLEN (&src));\n\n      /* encrypt */\n      openvpn_encrypt (&buf, encrypt_workspace, co, frame);\n\n      /* decrypt */\n      openvpn_decrypt (&buf, decrypt_workspace, co, frame);\n\n      /* compare */\n      if (buf.len != src.len)\n\tmsg (M_FATAL, \"SELF TEST FAILED, src.len=%d buf.len=%d\", src.len, buf.len);\n      for (j = 0; j < i; ++j)\n\t{\n\t  const uint8_t in = *(BPTR (&src) + j);\n\t  const uint8_t out = *(BPTR (&buf) + j);\n\t  if (in != out)\n\t    msg (M_FATAL, \"SELF TEST FAILED, pos=%d in=%d out=%d\", j, in, out);\n\t}\n    }\n  msg (M_INFO, PACKAGE_NAME \" crypto self-test mode SUCCEEDED.\");\n  gc_free (&gc);\n}\n\n#ifdef ENABLE_SSL\n\nvoid\nget_tls_handshake_key (const struct key_type *key_type,\n\t\t       struct key_ctx_bi *ctx,\n\t\t       const char *passphrase_file,\n\t\t       const int key_direction,\n\t\t       const unsigned int flags)\n{\n  if (passphrase_file && key_type->hmac_length)\n    {\n      struct key2 key2;\n      struct key_type kt = *key_type;\n      struct key_direction_state kds;\n\n      /* for control channel we are only authenticating, not encrypting */\n      kt.cipher_length = 0;\n      kt.cipher = NULL;\n\n      if (flags & GHK_INLINE)\n\t{\n\t  /* key was specified inline, key text is in passphrase_file */\n\t  read_key_file (&key2, passphrase_file, RKF_INLINE|RKF_MUST_SUCCEED);\n\n\t  /* succeeded? */\n\t  if (key2.n == 2)\n\t    msg (M_INFO, \"Control Channel Authentication: tls-auth using INLINE static key file\");\n\t  else\n\t    msg (M_FATAL, \"INLINE tls-auth file lacks the requisite 2 keys\");\n\t}\n      else\n      {\n\t/* first try to parse as an OpenVPN static key file */\n\tread_key_file (&key2, passphrase_file, 0);\n\n\t/* succeeded? */\n\tif (key2.n == 2)\n\t  {\n\t    msg (M_INFO,\n\t\t \"Control Channel Authentication: using '%s' as a \" PACKAGE_NAME \" static key file\",\n\t\t passphrase_file);\n\t  }\n\telse\n\t  {\n\t    int hash_size;\n\n\t    CLEAR (key2);\n\n\t    /* failed, now try to get hash from a freeform file */\n\t    hash_size = read_passphrase_hash (passphrase_file,\n\t\t\t\t\t      kt.digest,\n\t\t\t\t\t      key2.keys[0].hmac,\n\t\t\t\t\t      MAX_HMAC_KEY_LENGTH);\n\t    ASSERT (hash_size == kt.hmac_length);\n\n\t    /* suceeded */\n\t    key2.n = 1;\n\n\t    msg (M_INFO,\n\t\t \"Control Channel Authentication: using '%s' as a free-form passphrase file\",\n\t\t passphrase_file);\n\t  }\n      }\n      /* handle key direction */\n\n      key_direction_state_init (&kds, key_direction);\n      must_have_n_keys (passphrase_file, \"tls-auth\", &key2, kds.need_keys);\n\n      /* initialize hmac key in both directions */\n\n      init_key_ctx (&ctx->encrypt, &key2.keys[kds.out_key], &kt, OPENVPN_OP_ENCRYPT,\n\t\t    \"Outgoing Control Channel Authentication\");\n      init_key_ctx (&ctx->decrypt, &key2.keys[kds.in_key], &kt, OPENVPN_OP_DECRYPT,\n\t\t    \"Incoming Control Channel Authentication\");\n\n      CLEAR (key2);\n    }\n  else\n    {\n      CLEAR (*ctx);\n    }\n}\n#endif\n\n/* header and footer for static key file */\nstatic const char static_key_head[] = \"-----BEGIN OpenVPN Static key V1-----\";\nstatic const char static_key_foot[] = \"-----END OpenVPN Static key V1-----\";\n\nstatic const char printable_char_fmt[] =\n  \"Non-Hex character ('%c') found at line %d in key file '%s' (%d/%d/%d bytes found/min/max)\";\n\nstatic const char unprintable_char_fmt[] =\n  \"Non-Hex, unprintable character (0x%02x) found at line %d in key file '%s' (%d/%d/%d bytes found/min/max)\";\n\n/* read key from file */\n\nvoid\nread_key_file (struct key2 *key2, const char *file, const unsigned int flags)\n{\n  struct gc_arena gc = gc_new ();\n  struct buffer in;\n  int fd, size;\n  uint8_t hex_byte[3] = {0, 0, 0};\n  const char *error_filename = file;\n\n  /* parse info */\n  const unsigned char *cp;\n  int hb_index = 0;\n  int line_num = 1;\n  int line_index = 0;\n  int match = 0;\n\n  /* output */\n  uint8_t* out = (uint8_t*) &key2->keys;\n  const int keylen = sizeof (key2->keys);\n  int count = 0;\n\n  /* parse states */\n# define PARSE_INITIAL        0\n# define PARSE_HEAD           1\n# define PARSE_DATA           2\n# define PARSE_DATA_COMPLETE  3\n# define PARSE_FOOT           4\n# define PARSE_FINISHED       5\n  int state = PARSE_INITIAL;\n\n  /* constants */\n  const int hlen = strlen (static_key_head);\n  const int flen = strlen (static_key_foot);\n  const int onekeylen = sizeof (key2->keys[0]);\n\n  CLEAR (*key2);\n\n  /*\n   * Key can be provided as a filename in 'file' or if RKF_INLINE\n   * is set, the actual key data itself in ascii form.\n   */\n  if (flags & RKF_INLINE) /* 'file' is a string containing ascii representation of key */\n    {\n      size = strlen (file) + 1;\n      buf_set_read (&in, (const uint8_t *)file, size);\n      error_filename = INLINE_FILE_TAG;\n    }\n  else /* 'file' is a filename which refers to a file containing the ascii key */\n    {\n      in = alloc_buf_gc (2048, &gc);\n      fd = platform_open (file, O_RDONLY, 0);\n      if (fd == -1)\n\tmsg (M_ERR, \"Cannot open file key file '%s'\", file);\n      size = read (fd, in.data, in.capacity);\n      if (size < 0)\n\tmsg (M_FATAL, \"Read error on key file ('%s')\", file);\n      if (size == in.capacity)\n\tmsg (M_FATAL, \"Key file ('%s') can be a maximum of %d bytes\", file, (int)in.capacity);\n      close (fd);\n    }\n\n  cp = (unsigned char *)in.data;\n  while (size > 0)\n    {\n      const unsigned char c = *cp;\n\n#if 0\n      msg (M_INFO, \"char='%c'[%d] s=%d ln=%d li=%d m=%d c=%d\",\n\t   c, (int)c, state, line_num, line_index, match, count);\n#endif\n\n      if (c == '\\n')\n\t{\n\t  line_index = match = 0;\n\t  ++line_num;\t      \n\t}\n      else\n\t{\n\t  /* first char of new line */\n\t  if (!line_index)\n\t    {\n\t      /* first char of line after header line? */\n\t      if (state == PARSE_HEAD)\n\t\tstate = PARSE_DATA;\n\n\t      /* first char of footer */\n\t      if ((state == PARSE_DATA || state == PARSE_DATA_COMPLETE) && c == '-')\n\t\tstate = PARSE_FOOT;\n\t    }\n\n\t  /* compare read chars with header line */\n\t  if (state == PARSE_INITIAL)\n\t    {\n\t      if (line_index < hlen && c == static_key_head[line_index])\n\t\t{\n\t\t  if (++match == hlen)\n\t\t    state = PARSE_HEAD;\n\t\t}\n\t    }\n\n\t  /* compare read chars with footer line */\n\t  if (state == PARSE_FOOT)\n\t    {\n\t      if (line_index < flen && c == static_key_foot[line_index])\n\t\t{\n\t\t  if (++match == flen)\n\t\t    state = PARSE_FINISHED;\n\t\t}\n\t    }\n\n\t  /* reading key */\n\t  if (state == PARSE_DATA)\n\t    {\n\t      if (isxdigit(c))\n\t\t{\n\t\t  ASSERT (hb_index >= 0 && hb_index < 2);\n\t\t  hex_byte[hb_index++] = c;\n\t\t  if (hb_index == 2)\n\t\t    {\n\t\t      unsigned int u;\n\t\t      ASSERT(sscanf((const char *)hex_byte, \"%x\", &u) == 1);\n\t\t      *out++ = u;\n\t\t      hb_index = 0;\n\t\t      if (++count == keylen)\n\t\t\tstate = PARSE_DATA_COMPLETE;\n\t\t    }\n\t\t}\n\t      else if (isspace(c))\n\t\t;\n\t      else\n\t\t{\n\t\t  msg (M_FATAL,\n\t\t       (isprint (c) ? printable_char_fmt : unprintable_char_fmt),\n\t\t       c, line_num, error_filename, count, onekeylen, keylen);\n\t\t}\n\t    }\n\t  ++line_index;\n\t}\n      ++cp;\n      --size;\n    }\n\n  /*\n   * Normally we will read either 1 or 2 keys from file.\n   */\n  key2->n = count / onekeylen;\n\n  ASSERT (key2->n >= 0 && key2->n <= (int) SIZE (key2->keys));\n\n  if (flags & RKF_MUST_SUCCEED)\n    {\n      if (!key2->n)\n\tmsg (M_FATAL, \"Insufficient key material or header text not found in file '%s' (%d/%d/%d bytes found/min/max)\",\n\t     error_filename, count, onekeylen, keylen);\n\n      if (state != PARSE_FINISHED)\n\tmsg (M_FATAL, \"Footer text not found in file '%s' (%d/%d/%d bytes found/min/max)\",\n\t     error_filename, count, onekeylen, keylen);\n    }\n\n  /* zero file read buffer if not an inline file */\n  if (!(flags & RKF_INLINE))\n    buf_clear (&in);\n\n  if (key2->n)\n    warn_if_group_others_accessible (error_filename);\n\n#if 0\n  /* DEBUGGING */\n  {\n    int i;\n    printf (\"KEY READ, n=%d\\n\", key2->n);\n    for (i = 0; i < (int) SIZE (key2->keys); ++i)\n      {\n\t/* format key as ascii */\n\tconst char *fmt = format_hex_ex ((const uint8_t*)&key2->keys[i],\n\t\t\t\t\t sizeof (key2->keys[i]),\n\t\t\t\t\t 0,\n\t\t\t\t\t 16,\n\t\t\t\t\t \"\\n\",\n\t\t\t\t\t &gc);\n\tprintf (\"[%d]\\n%s\\n\\n\", i, fmt);\n      }\n  }\n#endif\n\n  /* pop our garbage collection level */\n  gc_free (&gc);\n}\n\nint\nread_passphrase_hash (const char *passphrase_file,\n\t\t      const md_kt_t *digest,\n\t\t      uint8_t *output,\n\t\t      int len)\n{\n  unsigned int outlen = 0;\n  md_ctx_t md;\n\n  ASSERT (len >= md_kt_size(digest));\n  memset (output, 0, len);\n\n  md_ctx_init(&md, digest);\n\n  /* read passphrase file */\n  {\n    const int min_passphrase_size = 8;\n    uint8_t buf[64];\n    int total_size = 0;\n    int fd = platform_open (passphrase_file, O_RDONLY, 0);\n\n    if (fd == -1)\n      msg (M_ERR, \"Cannot open passphrase file: '%s'\", passphrase_file);\n\n    for (;;)\n      {\n\tint size = read (fd, buf, sizeof (buf));\n\tif (size == 0)\n\t  break;\n\tif (size == -1)\n\t  msg (M_ERR, \"Read error on passphrase file: '%s'\",\n\t       passphrase_file);\n\tmd_ctx_update(&md, buf, size);\n\ttotal_size += size;\n      }\n    close (fd);\n\n    warn_if_group_others_accessible (passphrase_file);\n\n    if (total_size < min_passphrase_size)\n      msg (M_FATAL,\n\t   \"Passphrase file '%s' is too small (must have at least %d characters)\",\n\t   passphrase_file, min_passphrase_size);\n  }\n  md_ctx_final(&md, output);\n  md_ctx_cleanup(&md);\n  return md_kt_size(digest);\n}\n\n/*\n * Write key to file, return number of random bits\n * written.\n */\nint\nwrite_key_file (const int nkeys, const char *filename)\n{\n  struct gc_arena gc = gc_new ();\n\n  int fd, i;\n  int nbits = 0;\n\n  /* must be large enough to hold full key file */\n  struct buffer out = alloc_buf_gc (2048, &gc);\n  struct buffer nbits_head_text = alloc_buf_gc (128, &gc);\n\n  /* how to format the ascii file representation of key */\n  const int bytes_per_line = 16;\n\n  /* open key file */\n  fd = platform_open (filename, O_CREAT | O_TRUNC | O_WRONLY, S_IRUSR | S_IWUSR);\n\n  if (fd == -1)\n    msg (M_ERR, \"Cannot open shared secret file '%s' for write\", filename);\n\n  buf_printf (&out, \"%s\\n\", static_key_head);\n\n  for (i = 0; i < nkeys; ++i)\n    {\n      struct key key;\n      char* fmt;\n\n      /* generate random bits */\n      generate_key_random (&key, NULL);\n\n      /* format key as ascii */\n      fmt = format_hex_ex ((const uint8_t*)&key,\n\t\t\t   sizeof (key),\n\t\t\t   0,\n\t\t\t   bytes_per_line,\n\t\t\t   \"\\n\",\n\t\t\t   &gc);\n\n      /* increment random bits counter */\n      nbits += sizeof (key) * 8;\n\n      /* write to holding buffer */\n      buf_printf (&out, \"%s\\n\", fmt);\n\n      /* zero memory which held key component (will be freed by GC) */\n      memset (fmt, 0, strlen(fmt));\n      CLEAR (key);\n    }\n\n  buf_printf (&out, \"%s\\n\", static_key_foot);\n\n  /* write number of bits */\n  buf_printf (&nbits_head_text, \"#\\n# %d bit OpenVPN static key\\n#\\n\", nbits);\n  buf_write_string_file (&nbits_head_text, filename, fd);\n\n  /* write key file, now formatted in out, to file */\n  buf_write_string_file (&out, filename, fd);\n\n  if (close (fd))\n    msg (M_ERR, \"Close error on shared secret file %s\", filename);\n\n  /* zero memory which held file content (memory will be freed by GC) */\n  buf_clear (&out);\n\n  /* pop our garbage collection level */\n  gc_free (&gc);\n\n  return nbits;\n}\n\nvoid\nmust_have_n_keys (const char *filename, const char *option, const struct key2 *key2, int n)\n{\n  if (key2->n < n)\n    {\n#ifdef ENABLE_SMALL\n      msg (M_FATAL, \"Key file '%s' used in --%s contains insufficient key material [keys found=%d required=%d]\", filename, option, key2->n, n);\n#else\n      msg (M_FATAL, \"Key file '%s' used in --%s contains insufficient key material [keys found=%d required=%d] -- try generating a new key file with '\" PACKAGE \" --genkey --secret [file]', or use the existing key file in bidirectional mode by specifying --%s without a key direction parameter\", filename, option, key2->n, n, option);\n#endif\n    }\n}\n\nint\nascii2keydirection (int msglevel, const char *str)\n{\n  if (!str)\n    return KEY_DIRECTION_BIDIRECTIONAL;\n  else if (!strcmp (str, \"0\"))\n    return KEY_DIRECTION_NORMAL;\n  else if (!strcmp (str, \"1\"))\n    return KEY_DIRECTION_INVERSE;\n  else\n    {\n      msg (msglevel, \"Unknown key direction '%s' -- must be '0' or '1'\", str);\n      return -1;\n    }\n  return KEY_DIRECTION_BIDIRECTIONAL; /* NOTREACHED */\n}\n\nconst char *\nkeydirection2ascii (int kd, bool remote)\n{\n  if (kd == KEY_DIRECTION_BIDIRECTIONAL)\n    return NULL;\n  else if (kd == KEY_DIRECTION_NORMAL)\n    return remote ? \"1\" : \"0\";\n  else if (kd == KEY_DIRECTION_INVERSE)\n    return remote ? \"0\" : \"1\";\n  else\n    {\n      ASSERT (0);\n    }\n  return NULL; /* NOTREACHED */\n}\n\nvoid\nkey_direction_state_init (struct key_direction_state *kds, int key_direction)\n{\n  CLEAR (*kds);\n  switch (key_direction)\n    {\n    case KEY_DIRECTION_NORMAL:\n      kds->out_key = 0;\n      kds->in_key = 1;\n      kds->need_keys = 2;\n      break;\n    case KEY_DIRECTION_INVERSE:\n      kds->out_key = 1;\n      kds->in_key = 0;\n      kds->need_keys = 2;\n      break;\n    case KEY_DIRECTION_BIDIRECTIONAL:\n      kds->out_key = 0;\n      kds->in_key = 0;\n      kds->need_keys = 1;\n      break;\n    default:\n      ASSERT (0);\n    }\n}\n\nvoid\nverify_fix_key2 (struct key2 *key2, const struct key_type *kt, const char *shared_secret_file)\n{\n  int i;\n\n  for (i = 0; i < key2->n; ++i)\n    {\n      /* Fix parity for DES keys and make sure not a weak key */\n      fixup_key (&key2->keys[i], kt);\n\n      /* This should be a very improbable failure */\n      if (!check_key (&key2->keys[i], kt))\n\tmsg (M_FATAL, \"Key #%d in '%s' is bad.  Try making a new key with --genkey.\",\n\t     i+1, shared_secret_file);\n    }\n}\n\n/* given a key and key_type, write key to buffer */\nbool\nwrite_key (const struct key *key, const struct key_type *kt,\n\t   struct buffer *buf)\n{\n  ASSERT (kt->cipher_length <= MAX_CIPHER_KEY_LENGTH\n\t  && kt->hmac_length <= MAX_HMAC_KEY_LENGTH);\n\n  if (!buf_write (buf, &kt->cipher_length, 1))\n    return false;\n  if (!buf_write (buf, &kt->hmac_length, 1))\n    return false;\n  if (!buf_write (buf, key->cipher, kt->cipher_length))\n    return false;\n  if (!buf_write (buf, key->hmac, kt->hmac_length))\n    return false;\n\n  return true;\n}\n\n/*\n * Given a key_type and buffer, read key from buffer.\n * Return: 1 on success\n *        -1 read failure\n *         0 on key length mismatch \n */\nint\nread_key (struct key *key, const struct key_type *kt, struct buffer *buf)\n{\n  uint8_t cipher_length;\n  uint8_t hmac_length;\n\n  CLEAR (*key);\n  if (!buf_read (buf, &cipher_length, 1))\n    goto read_err;\n  if (!buf_read (buf, &hmac_length, 1))\n    goto read_err;\n\n  if (!buf_read (buf, key->cipher, cipher_length))\n    goto read_err;\n  if (!buf_read (buf, key->hmac, hmac_length))\n    goto read_err;\n\n  if (cipher_length != kt->cipher_length || hmac_length != kt->hmac_length)\n    goto key_len_err;\n\n  return 1;\n\nread_err:\n  msg (D_TLS_ERRORS, \"TLS Error: error reading key from remote\");\n  return -1;\n\nkey_len_err:\n  msg (D_TLS_ERRORS,\n       \"TLS Error: key length mismatch, local cipher/hmac %d/%d, remote cipher/hmac %d/%d\",\n       kt->cipher_length, kt->hmac_length, cipher_length, hmac_length);\n  return 0;\n}\n\n/*\n * Random number functions, used in cases where we want\n * reasonably strong cryptographic random number generation\n * without depleting our entropy pool.  Used for random\n * IV values and a number of other miscellaneous tasks.\n */\n\nstatic uint8_t *nonce_data = NULL; /* GLOBAL */\nstatic const md_kt_t *nonce_md = NULL; /* GLOBAL */\nstatic int nonce_secret_len = 0; /* GLOBAL */\n\n/* Reset the nonce value, also done periodically to refresh entropy */\nstatic void\nprng_reset_nonce ()\n{\n  const int size = md_kt_size (nonce_md) + nonce_secret_len;\n#if 1 /* Must be 1 for real usage */\n  if (!rand_bytes (nonce_data, size))\n    msg (M_FATAL, \"ERROR: Random number generator cannot obtain entropy for PRNG\");\n#else\n    /* Only for testing -- will cause a predictable PRNG sequence */\n    {\n      int i;\n      for (i = 0; i < size; ++i)\n\tnonce_data[i] = (uint8_t) i;\n    }\n#endif\n}\n\nvoid\nprng_init (const char *md_name, const int nonce_secret_len_parm)\n{\n  prng_uninit ();\n  nonce_md = md_name ? md_kt_get (md_name) : NULL;\n  if (nonce_md)\n    {\n      ASSERT (nonce_secret_len_parm >= NONCE_SECRET_LEN_MIN && nonce_secret_len_parm <= NONCE_SECRET_LEN_MAX);\n      nonce_secret_len = nonce_secret_len_parm;\n      {\n\tconst int size = md_kt_size(nonce_md) + nonce_secret_len;\n\tdmsg (D_CRYPTO_DEBUG, \"PRNG init md=%s size=%d\", md_kt_name(nonce_md), size);\n\tnonce_data = (uint8_t*) malloc (size);\n\tcheck_malloc_return (nonce_data);\n\tprng_reset_nonce();\n      }\n    }\n}\n\nvoid\nprng_uninit (void)\n{\n  free (nonce_data);\n  nonce_data = NULL;\n  nonce_md = NULL;\n  nonce_secret_len = 0;\n}\n\nvoid\nprng_bytes (uint8_t *output, int len)\n{\n  static size_t processed = 0;\n\n  if (nonce_md)\n    {\n      const int md_size = md_kt_size (nonce_md);\n      while (len > 0)\n\t{\n\t  unsigned int outlen = 0;\n\t  const int blen = min_int (len, md_size);\n\t  md_full(nonce_md, nonce_data, md_size + nonce_secret_len, nonce_data);\n\t  memcpy (output, nonce_data, blen);\n\t  output += blen;\n\t  len -= blen;\n\n\t  /* Ensure that random data is reset regularly */\n\t  processed += blen;\n\t  if(processed > PRNG_NONCE_RESET_BYTES) {\n\t    prng_reset_nonce();\n\t    processed = 0;\n\t  }\n\t}\n    }\n  else\n    rand_bytes (output, len);\n}\n\n/* an analogue to the random() function, but use prng_bytes */\nlong int\nget_random()\n{\n  long int l;\n  prng_bytes ((unsigned char *)&l, sizeof(l));\n  if (l < 0)\n    l = -l;\n  return l;\n}\n\n#ifndef ENABLE_SSL\n\nvoid\ninit_ssl_lib (void)\n{\n  crypto_init_lib ();\n}\n\nvoid\nfree_ssl_lib (void)\n{\n  crypto_uninit_lib ();\n  prng_uninit();\n}\n\n#endif /* ENABLE_SSL */\n\n/*\n * md5 functions\n */\n\nconst char *\nmd5sum (uint8_t *buf, int len, int n_print_chars, struct gc_arena *gc)\n{\n  uint8_t digest[MD5_DIGEST_LENGTH];\n  const md_kt_t *md5_kt = md_kt_get(\"MD5\");\n\n  md_full(md5_kt, buf, len, digest);\n\n  return format_hex (digest, MD5_DIGEST_LENGTH, n_print_chars, gc);\n}\n\nvoid\nmd5_state_init (struct md5_state *s)\n{\n  const md_kt_t *md5_kt = md_kt_get(\"MD5\");\n\n  md_ctx_init(&s->ctx, md5_kt);\n}\n\nvoid\nmd5_state_update (struct md5_state *s, void *data, size_t len)\n{\n  md_ctx_update(&s->ctx, data, len);\n}\n\nvoid\nmd5_state_final (struct md5_state *s, struct md5_digest *out)\n{\n  md_ctx_final(&s->ctx, out->digest);\n  md_ctx_cleanup(&s->ctx);\n}\n\nvoid\nmd5_digest_clear (struct md5_digest *digest)\n{\n  CLEAR (*digest);\n}\n\nbool\nmd5_digest_defined (const struct md5_digest *digest)\n{\n  int i;\n  for (i = 0; i < MD5_DIGEST_LENGTH; ++i)\n    if (digest->digest[i])\n      return true;\n  return false;\n}\n\nbool\nmd5_digest_equal (const struct md5_digest *d1, const struct md5_digest *d2)\n{\n  return memcmp(d1->digest, d2->digest, MD5_DIGEST_LENGTH) == 0;\n}\n\n#endif /* ENABLE_CRYPTO */\n"], "filenames": ["src/openvpn/buffer.h", "src/openvpn/crypto.c"], "buggy_code_start_loc": [670, 67], "buggy_code_end_loc": [678, 248], "fixing_code_start_loc": [671, 68], "fixing_code_end_loc": [687, 266], "type": "CWE-200", "message": "The openvpn_decrypt function in crypto.c in OpenVPN 2.3.0 and earlier, when running in UDP mode, allows remote attackers to obtain sensitive information via a timing attack involving an HMAC comparison function that does not run in constant time and a padding oracle attack on the CBC mode cipher.", "other": {"cve": {"id": "CVE-2013-2061", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-18T02:55:07.530", "lastModified": "2020-05-12T14:21:12.937", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The openvpn_decrypt function in crypto.c in OpenVPN 2.3.0 and earlier, when running in UDP mode, allows remote attackers to obtain sensitive information via a timing attack involving an HMAC comparison function that does not run in constant time and a padding oracle attack on the CBC mode cipher."}, {"lang": "es", "value": "La funci\u00f3n openvpn_decrypt en el archivo crypto.c en OpenVPN versiones 2.3.0 y anteriores, cuando se ejecuta en modo UDP, permite a los atacantes remotos obtener informaci\u00f3n confidencial por medio de un ataque de sincronizaci\u00f3n que implica una funci\u00f3n de comparaci\u00f3n HMAC que no se ejecuta en tiempo constante y un ataque de tipo padding oracle en el cifrado en modo CBC."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.0", "matchCriteriaId": "EC35891F-BC4F-4DBB-8879-4952685D419E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "912E57A3-A4D0-4736-858F-51A500E886B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "13960B6E-F1E8-49E5-88A0-ECCC938AC4DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "862743EA-7B6E-4478-AD90-1F930E97BB2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "79114721-FA19-43FF-8030-74652FCF937B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "1A3AF5D2-21CC-4243-A2A4-99273B7AD9D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "B693F0CA-7A3A-42CA-A6BE-62D840CE336C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "345C3123-7E73-4094-8764-8BF881B6ABE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "F00F2FF1-9CC2-446B-9468-1FB7D40371E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "AB625AC3-B428-44BB-99F4-F0FE00DA1C5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "C25DDCBB-798B-43BF-88FF-2EDB57BEA01F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:1.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "F3F6FE9B-62E0-47E3-A977-DA51249A353B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:2.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "88C2922E-6E95-45BF-ABF1-B1D799769DB5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "1D915A07-3B93-4D7C-8D52-73B696392B46"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn_access_server:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "486CD3E2-1B1A-4A1D-98ED-0E2EEAB0A0CF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-May/105568.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2013-May/105609.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-11/msg00012.html", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-11/msg00016.html", "source": "secalert@redhat.com"}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:167", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/05/06/6", "source": "secalert@redhat.com"}, {"url": "https://bugs.gentoo.org/show_bug.cgi?id=468756", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=960192", "source": "secalert@redhat.com"}, {"url": "https://community.openvpn.net/openvpn/wiki/SecurityAnnouncement-f375aa67cc", "source": "secalert@redhat.com"}, {"url": "https://github.com/OpenVPN/openvpn/commit/11d21349a4e7e38a025849479b36ace7c2eec2ee", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/OpenVPN/openvpn/commit/11d21349a4e7e38a025849479b36ace7c2eec2ee"}}