{"buggy_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.kernel.security;\n\nimport org.opencastproject.security.api.JaxbOrganization;\nimport org.opencastproject.security.api.JaxbRole;\nimport org.opencastproject.security.api.JaxbUser;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.security.util.SecurityUtil;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * A Spring Security implementation of {@link SecurityService}.\n */\npublic class SecurityServiceSpringImpl implements SecurityService {\n\n  /** The logger */\n  private static final Logger logger = LoggerFactory.getLogger(SecurityServiceSpringImpl.class);\n\n  /** Holds delegates users for new threads that have been spawned from authenticated threads */\n  private static final ThreadLocal<User> delegatedUserHolder = new ThreadLocal<User>();\n\n  /** Holds the IP address for the delegated user for the current thread */\n  private static final ThreadLocal<String> delegatedUserIPHolder = new ThreadLocal<String>();\n\n  /** Holds organization responsible for the current thread */\n  private static final ThreadLocal<Organization> organization = new ThreadLocal<Organization>();\n\n  /** The user directory */\n  private UserDirectoryService userDirectory;\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#getOrganization()\n   */\n  @Override\n  public Organization getOrganization() {\n    return SecurityServiceSpringImpl.organization.get();\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#setOrganization(Organization)\n   */\n  @Override\n  public void setOrganization(Organization organization) {\n    SecurityServiceSpringImpl.organization.set(organization);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#getUser()\n   */\n  @Override\n  public User getUser() throws IllegalStateException {\n    Organization org = getOrganization();\n    if (org == null)\n      throw new IllegalStateException(\"No organization is set in security context\");\n\n    User delegatedUser = delegatedUserHolder.get();\n\n    if (delegatedUser != null) {\n      return delegatedUser;\n    }\n\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);\n    if (auth != null) {\n      Object principal = auth.getPrincipal();\n      if ((principal != null) && (principal instanceof UserDetails)) {\n        UserDetails userDetails = (UserDetails) principal;\n\n        User user = null;\n\n        // If user exists, fetch it from the userDirectory\n        if (userDirectory != null) {\n          user = userDirectory.loadUser(userDetails.getUsername());\n          if (user == null) {\n            logger.debug(\n                    \"Authenticated user '{}' could not be found in any of the current UserProviders. Continuing anyway...\",\n                    userDetails.getUsername());\n          }\n        } else {\n          logger.debug(\"No UserDirectory was found when trying to search for user '{}'\", userDetails.getUsername());\n        }\n\n        // Add the roles (authorities) in the security context\n        Set<JaxbRole> roles = new HashSet<JaxbRole>();\n        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n        if (authorities != null) {\n          for (GrantedAuthority ga : authorities) {\n            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));\n          }\n        }\n\n        if (user == null) {\n          // No user was found. Create one to hold the auth information from the security context\n          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);\n        } else {\n          // Combine the existing user with the roles in the security context\n          user = JaxbUser.fromUser(user, roles);\n        }\n\n        // Save the user to retrieve it quicker the next time(s) this method is called (by this thread)\n        delegatedUserHolder.set(user);\n\n        return user;\n      }\n    }\n\n    // Return the anonymous user by default\n    return SecurityUtil.createAnonymousUser(jaxbOrganization);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#setUser(User)\n   */\n  @Override\n  public void setUser(User user) {\n    delegatedUserHolder.set(user);\n  }\n\n  @Override\n  public String getUserIP() {\n    return delegatedUserIPHolder.get();\n  }\n\n  @Override\n  public void setUserIP(String userIP) {\n    delegatedUserIPHolder.set(userIP);\n  }\n\n  /**\n   * OSGi callback for setting the user directory.\n   *\n   * @param userDirectory\n   *          the user directory\n   */\n  void setUserDirectory(UserDirectoryService userDirectory) {\n    this.userDirectory = userDirectory;\n  }\n\n  /**\n   * OSGi callback for removing the user directory.\n   */\n  void removeUserDirectory() {\n    this.userDirectory = null;\n  }\n\n}\n"], "fixing_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.kernel.security;\n\nimport org.opencastproject.security.api.JaxbOrganization;\nimport org.opencastproject.security.api.JaxbRole;\nimport org.opencastproject.security.api.JaxbUser;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.security.util.SecurityUtil;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.security.authentication.AnonymousAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * A Spring Security implementation of {@link SecurityService}.\n */\npublic class SecurityServiceSpringImpl implements SecurityService {\n\n  /** The logger */\n  private static final Logger logger = LoggerFactory.getLogger(SecurityServiceSpringImpl.class);\n\n  /** Holds delegates users for new threads that have been spawned from authenticated threads */\n  private static final ThreadLocal<User> delegatedUserHolder = new ThreadLocal<User>();\n\n  /** Holds the IP address for the delegated user for the current thread */\n  private static final ThreadLocal<String> delegatedUserIPHolder = new ThreadLocal<String>();\n\n  /** Holds organization responsible for the current thread */\n  private static final ThreadLocal<Organization> organization = new ThreadLocal<Organization>();\n\n  /** The user directory */\n  private UserDirectoryService userDirectory;\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#getOrganization()\n   */\n  @Override\n  public Organization getOrganization() {\n    return SecurityServiceSpringImpl.organization.get();\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#setOrganization(Organization)\n   */\n  @Override\n  public void setOrganization(Organization organization) {\n    SecurityServiceSpringImpl.organization.set(organization);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#getUser()\n   */\n  @Override\n  public User getUser() throws IllegalStateException {\n    Organization org = getOrganization();\n    if (org == null)\n      throw new IllegalStateException(\"No organization is set in security context\");\n\n    User delegatedUser = delegatedUserHolder.get();\n\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    if (auth instanceof AnonymousAuthenticationToken) {\n      return SecurityUtil.createAnonymousUser(org);\n    }\n\n    if (delegatedUser != null) {\n      return delegatedUser;\n    }\n\n    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);\n    if (auth != null) {\n      Object principal = auth.getPrincipal();\n      if ((principal instanceof UserDetails)) {\n        UserDetails userDetails = (UserDetails) principal;\n\n        User user = null;\n\n        // If user exists, fetch it from the userDirectory\n        if (userDirectory != null) {\n          user = userDirectory.loadUser(userDetails.getUsername());\n          if (user == null) {\n            logger.debug(\"Authenticated user '{}' could not be found in any of the current UserProviders. \"\n                + \"Continuing anyway...\", userDetails.getUsername());\n          }\n        } else {\n          logger.debug(\"No UserDirectory was found when trying to search for user '{}'\", userDetails.getUsername());\n        }\n\n        // Add the roles (authorities) in the security context\n        Set<JaxbRole> roles = new HashSet<>();\n        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n        if (authorities != null) {\n          for (GrantedAuthority ga : authorities) {\n            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));\n          }\n        }\n\n        if (user == null) {\n          // No user was found. Create one to hold the auth information from the security context\n          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);\n        } else {\n          // Combine the existing user with the roles in the security context\n          user = JaxbUser.fromUser(user, roles);\n        }\n\n        // Save the user to retrieve it quicker the next time(s) this method is called (by this thread)\n        delegatedUserHolder.set(user);\n\n        return user;\n      }\n    }\n\n    // Return the anonymous user by default\n    return SecurityUtil.createAnonymousUser(jaxbOrganization);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.security.api.SecurityService#setUser(User)\n   */\n  @Override\n  public void setUser(User user) {\n    delegatedUserHolder.set(user);\n  }\n\n  @Override\n  public String getUserIP() {\n    return delegatedUserIPHolder.get();\n  }\n\n  @Override\n  public void setUserIP(String userIP) {\n    delegatedUserIPHolder.set(userIP);\n  }\n\n  /**\n   * OSGi callback for setting the user directory.\n   *\n   * @param userDirectory\n   *          the user directory\n   */\n  void setUserDirectory(UserDirectoryService userDirectory) {\n    this.userDirectory = userDirectory;\n  }\n\n  /**\n   * OSGi callback for removing the user directory.\n   */\n  void removeUserDirectory() {\n    this.userDirectory = null;\n  }\n\n}\n"], "filenames": ["modules/kernel/src/main/java/org/opencastproject/kernel/security/SecurityServiceSpringImpl.java"], "buggy_code_start_loc": [34], "buggy_code_end_loc": [124], "fixing_code_start_loc": [35], "fixing_code_end_loc": [128], "type": "CWE-287", "message": "In Opencast before 7.6 and 8.1, using a remember-me cookie with an arbitrary username can cause Opencast to assume proper authentication for that user even if the remember-me cookie was incorrect given that the attacked endpoint also allows anonymous access. This way, an attacker can, for example, fake a remember-me token, assume the identity of the global system administrator and request non-public content from the search service without ever providing any proper authentication. This problem is fixed in Opencast 7.6 and Opencast 8.1", "other": {"cve": {"id": "CVE-2020-5206", "sourceIdentifier": "security-advisories@github.com", "published": "2020-01-30T22:15:10.093", "lastModified": "2020-02-05T18:30:49.467", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Opencast before 7.6 and 8.1, using a remember-me cookie with an arbitrary username can cause Opencast to assume proper authentication for that user even if the remember-me cookie was incorrect given that the attacked endpoint also allows anonymous access. This way, an attacker can, for example, fake a remember-me token, assume the identity of the global system administrator and request non-public content from the search service without ever providing any proper authentication. This problem is fixed in Opencast 7.6 and Opencast 8.1"}, {"lang": "es", "value": "En Opencast versiones anteriores a 7.6 y 8.1, usando una cookie remember-me con un nombre de usuario arbitrario puede causar que Opencast asuma una autenticaci\u00f3n apropiada para ese usuario, inclusive si la cookie remember-me era incorrecta, dado que el endpoint atacado tambi\u00e9n permite el acceso an\u00f3nimo. De esta forma, un atacante puede, por ejemplo, falsificar un token de remember-me, asumir la identidad del administrador del sistema global y solicitar contenido no p\u00fablico desde el servicio de b\u00fasqueda sin proporcionar una autenticaci\u00f3n adecuada. Este problema se corrigi\u00f3 en Opencast versi\u00f3n 7.6 y Opencast versi\u00f3n 8.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apereo:opencast:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.6", "matchCriteriaId": "7056094F-6E63-4BFB-B8A3-125746BA882C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apereo:opencast:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "4A82AABB-ACF6-4017-99E8-4DA90CE416D7"}]}]}], "references": [{"url": "https://github.com/opencast/opencast/commit/b157e1fb3b35991ca7bf59f0730329fbe7ce82e8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/opencast/opencast/security/advisories/GHSA-vmm6-w4cf-7f3x", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencast/opencast/commit/b157e1fb3b35991ca7bf59f0730329fbe7ce82e8"}}