{"buggy_code": [".\\\" $OpenBSD: ssh-agent.1,v 1.62 2015/11/15 23:54:15 jmc Exp $\n.\\\"\n.\\\" Author: Tatu Ylonen <ylo@cs.hut.fi>\n.\\\" Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n.\\\"                    All rights reserved\n.\\\"\n.\\\" As far as I am concerned, the code I have written for this software\n.\\\" can be used freely for any purpose.  Any derived versions of this\n.\\\" software must be clearly marked as such, and if the derived work is\n.\\\" incompatible with the protocol description in the RFC file, it must be\n.\\\" called by a name other than \"ssh\" or \"Secure Shell\".\n.\\\"\n.\\\" Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.\n.\\\" Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n.\\\" Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that the following conditions\n.\\\" are met:\n.\\\" 1. Redistributions of source code must retain the above copyright\n.\\\"    notice, this list of conditions and the following disclaimer.\n.\\\" 2. Redistributions in binary form must reproduce the above copyright\n.\\\"    notice, this list of conditions and the following disclaimer in the\n.\\\"    documentation and/or other materials provided with the distribution.\n.\\\"\n.\\\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n.\\\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n.\\\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n.\\\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n.\\\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n.\\\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n.\\\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n.\\\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n.\\\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n.\\\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n.\\\"\n.Dd $Mdocdate: November 15 2015 $\n.Dt SSH-AGENT 1\n.Os\n.Sh NAME\n.Nm ssh-agent\n.Nd authentication agent\n.Sh SYNOPSIS\n.Nm ssh-agent\n.Op Fl c | s\n.Op Fl \\&Dd\n.Op Fl a Ar bind_address\n.Op Fl E Ar fingerprint_hash\n.Op Fl t Ar life\n.Op Ar command Op Ar arg ...\n.Nm ssh-agent\n.Op Fl c | s\n.Fl k\n.Sh DESCRIPTION\n.Nm\nis a program to hold private keys used for public key authentication\n(RSA, DSA, ECDSA, Ed25519).\n.Nm\nis usually started in the beginning of an X-session or a login session, and\nall other windows or programs are started as clients to the ssh-agent\nprogram.\nThrough use of environment variables the agent can be located\nand automatically used for authentication when logging in to other\nmachines using\n.Xr ssh 1 .\n.Pp\nThe agent initially does not have any private keys.\nKeys are added using\n.Xr ssh 1\n(see\n.Cm AddKeysToAgent\nin\n.Xr ssh_config 5\nfor details)\nor\n.Xr ssh-add 1 .\nMultiple identities may be stored in\n.Nm\nconcurrently and\n.Xr ssh 1\nwill automatically use them if present.\n.Xr ssh-add 1\nis also used to remove keys from\n.Nm\nand to query the keys that are held in one.\n.Pp\nThe options are as follows:\n.Bl -tag -width Ds\n.It Fl a Ar bind_address\nBind the agent to the\n.Ux Ns -domain\nsocket\n.Ar bind_address .\nThe default is\n.Pa $TMPDIR/ssh-XXXXXXXXXX/agent.\\*(Ltppid\\*(Gt .\n.It Fl c\nGenerate C-shell commands on\n.Dv stdout .\nThis is the default if\n.Ev SHELL\nlooks like it's a csh style of shell.\n.It Fl D\nForeground mode.\nWhen this option is specified\n.Nm\nwill not fork.\n.It Fl d\nDebug mode.\nWhen this option is specified\n.Nm\nwill not fork and will write debug information to standard error.\n.It Fl E Ar fingerprint_hash\nSpecifies the hash algorithm used when displaying key fingerprints.\nValid options are:\n.Dq md5\nand\n.Dq sha256 .\nThe default is\n.Dq sha256 .\n.It Fl k\nKill the current agent (given by the\n.Ev SSH_AGENT_PID\nenvironment variable).\n.It Fl s\nGenerate Bourne shell commands on\n.Dv stdout .\nThis is the default if\n.Ev SHELL\ndoes not look like it's a csh style of shell.\n.It Fl t Ar life\nSet a default value for the maximum lifetime of identities added to the agent.\nThe lifetime may be specified in seconds or in a time format specified in\n.Xr sshd_config 5 .\nA lifetime specified for an identity with\n.Xr ssh-add 1\noverrides this value.\nWithout this option the default maximum lifetime is forever.\n.El\n.Pp\nIf a command line is given, this is executed as a subprocess of the agent.\nWhen the command dies, so does the agent.\n.Pp\nThe idea is that the agent is run in the user's local PC, laptop, or\nterminal.\nAuthentication data need not be stored on any other\nmachine, and authentication passphrases never go over the network.\nHowever, the connection to the agent is forwarded over SSH\nremote logins, and the user can thus use the privileges given by the\nidentities anywhere in the network in a secure way.\n.Pp\nThere are two main ways to get an agent set up:\nThe first is that the agent starts a new subcommand into which some environment\nvariables are exported, eg\n.Cm ssh-agent xterm & .\nThe second is that the agent prints the needed shell commands (either\n.Xr sh 1\nor\n.Xr csh 1\nsyntax can be generated) which can be evaluated in the calling shell, eg\n.Cm eval `ssh-agent -s`\nfor Bourne-type shells such as\n.Xr sh 1\nor\n.Xr ksh 1\nand\n.Cm eval `ssh-agent -c`\nfor\n.Xr csh 1\nand derivatives.\n.Pp\nLater\n.Xr ssh 1\nlooks at these variables and uses them to establish a connection to the agent.\n.Pp\nThe agent will never send a private key over its request channel.\nInstead, operations that require a private key will be performed\nby the agent, and the result will be returned to the requester.\nThis way, private keys are not exposed to clients using the agent.\n.Pp\nA\n.Ux Ns -domain\nsocket is created and the name of this socket is stored in the\n.Ev SSH_AUTH_SOCK\nenvironment\nvariable.\nThe socket is made accessible only to the current user.\nThis method is easily abused by root or another instance of the same\nuser.\n.Pp\nThe\n.Ev SSH_AGENT_PID\nenvironment variable holds the agent's process ID.\n.Pp\nThe agent exits automatically when the command given on the command\nline terminates.\n.Sh FILES\n.Bl -tag -width Ds\n.It Pa $TMPDIR/ssh-XXXXXXXXXX/agent.\\*(Ltppid\\*(Gt\n.Ux Ns -domain\nsockets used to contain the connection to the authentication agent.\nThese sockets should only be readable by the owner.\nThe sockets should get automatically removed when the agent exits.\n.El\n.Sh SEE ALSO\n.Xr ssh 1 ,\n.Xr ssh-add 1 ,\n.Xr ssh-keygen 1 ,\n.Xr sshd 8\n.Sh AUTHORS\nOpenSSH is a derivative of the original and free\nssh 1.2.12 release by Tatu Ylonen.\nAaron Campbell, Bob Beck, Markus Friedl, Niels Provos,\nTheo de Raadt and Dug Song\nremoved many bugs, re-added newer features and\ncreated OpenSSH.\nMarkus Friedl contributed the support for SSH\nprotocol versions 1.5 and 2.0.\n", "/* $OpenBSD: ssh-agent.c,v 1.214 2016/09/12 01:22:38 deraadt Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * The authentication agent program.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/queue.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <time.h>\n#include <unistd.h>\n#include <util.h>\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"rsa.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"compat.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n\n#ifdef ENABLE_PKCS11\n#include \"ssh-pkcs11.h\"\n#endif\n\ntypedef enum {\n\tAUTH_UNUSED,\n\tAUTH_SOCKET,\n\tAUTH_CONNECTION\n} sock_type;\n\ntypedef struct {\n\tint fd;\n\tsock_type type;\n\tstruct sshbuf *input;\n\tstruct sshbuf *output;\n\tstruct sshbuf *request;\n} SocketEntry;\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\ntypedef struct identity {\n\tTAILQ_ENTRY(identity) next;\n\tstruct sshkey *key;\n\tchar *comment;\n\tchar *provider;\n\ttime_t death;\n\tu_int confirm;\n} Identity;\n\ntypedef struct {\n\tint nentries;\n\tTAILQ_HEAD(idqueue, identity) idlist;\n} Idtab;\n\n/* private key table, one per protocol version */\nIdtab idtable[3];\n\nint max_fd = 0;\n\n/* pid of shell == parent of agent */\npid_t parent_pid = -1;\ntime_t parent_alive_interval = 0;\n\n/* pid of process for which cleanup_socket is applicable */\npid_t cleanup_pid = 0;\n\n/* pathname and directory for AUTH_SOCKET */\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\n/* locking */\n#define LOCK_SIZE\t32\n#define LOCK_SALT_SIZE\t16\n#define LOCK_ROUNDS\t1\nint locked = 0;\nu_char lock_pwhash[LOCK_SIZE];\nu_char lock_salt[LOCK_SALT_SIZE];\n\nextern char *__progname;\n\n/* Default lifetime in seconds (0 == forever) */\nstatic long lifetime = 0;\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}\n\nstatic void\nidtab_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i <=2; i++) {\n\t\tTAILQ_INIT(&idtable[i].idlist);\n\t\tidtable[i].nentries = 0;\n\t}\n}\n\n/* return private key table for requested protocol version */\nstatic Idtab *\nidtab_lookup(int version)\n{\n\tif (version < 1 || version > 2)\n\t\tfatal(\"internal error, bad protocol version %d\", version);\n\treturn &idtable[version];\n}\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}\n\n/* return matching private key for given public key */\nstatic Identity *\nlookup_identity(struct sshkey *key, int version)\n{\n\tIdentity *id;\n\n\tIdtab *tab = idtab_lookup(version);\n\tTAILQ_FOREACH(id, &tab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}\n\n/* Check confirmation of keysign request */\nstatic int\nconfirm_key(Identity *id)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.\",\n\t    id->comment, p))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}\n\n/* send list of supported public keys to 'client' */\nstatic void\nprocess_request_identities(SocketEntry *e, int version)\n{\n\tIdtab *tab = idtab_lookup(version);\n\tIdentity *id;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, (version == 1) ?\n\t    SSH_AGENT_RSA_IDENTITIES_ANSWER :\n\t    SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, tab->nentries)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tTAILQ_FOREACH(id, &tab->idlist, next) {\n\t\tif (id->key->type == KEY_RSA1) {\n#ifdef WITH_SSH1\n\t\t\tif ((r = sshbuf_put_u32(msg,\n\t\t\t    BN_num_bits(id->key->rsa->n))) != 0 ||\n\t\t\t    (r = sshbuf_put_bignum1(msg,\n\t\t\t    id->key->rsa->e)) != 0 ||\n\t\t\t    (r = sshbuf_put_bignum1(msg,\n\t\t\t    id->key->rsa->n)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n#endif\n\t\t} else {\n\t\t\tu_char *blob;\n\t\t\tsize_t blen;\n\n\t\t\tif ((r = sshkey_to_blob(id->key, &blob, &blen)) != 0) {\n\t\t\t\terror(\"%s: sshkey_to_blob: %s\", __func__,\n\t\t\t\t    ssh_err(r));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((r = sshbuf_put_string(msg, blob, blen)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfree(blob);\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(msg, id->comment)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}\n\n#ifdef WITH_SSH1\n/* ssh1 only */\nstatic void\nprocess_authentication_challenge1(SocketEntry *e)\n{\n\tu_char buf[32], mdbuf[16], session_id[16];\n\tu_int response_type;\n\tBIGNUM *challenge;\n\tIdentity *id;\n\tint r, len;\n\tstruct sshbuf *msg;\n\tstruct ssh_digest_ctx *md;\n\tstruct sshkey *key;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((key = sshkey_new(KEY_RSA1)) == NULL)\n\t\tfatal(\"%s: sshkey_new failed\", __func__);\n\tif ((challenge = BN_new()) == NULL)\n\t\tfatal(\"%s: BN_new failed\", __func__);\n\n\tif ((r = sshbuf_get_u32(e->request, NULL)) != 0 || /* ignored */\n\t    (r = sshbuf_get_bignum1(e->request, key->rsa->e)) != 0 ||\n\t    (r = sshbuf_get_bignum1(e->request, key->rsa->n)) != 0 ||\n\t    (r = sshbuf_get_bignum1(e->request, challenge)))\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* Only protocol 1.1 is supported */\n\tif (sshbuf_len(e->request) == 0)\n\t\tgoto failure;\n\tif ((r = sshbuf_get(e->request, session_id, sizeof(session_id))) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &response_type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (response_type != 1)\n\t\tgoto failure;\n\n\tid = lookup_identity(key, 1);\n\tif (id != NULL && (!id->confirm || confirm_key(id) == 0)) {\n\t\tstruct sshkey *private = id->key;\n\t\t/* Decrypt the challenge using the private key. */\n\t\tif ((r = rsa_private_decrypt(challenge, challenge,\n\t\t    private->rsa) != 0)) {\n\t\t\tfatal(\"%s: rsa_public_encrypt: %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tgoto failure;\t/* XXX ? */\n\t\t}\n\n\t\t/* The response is MD5 of decrypted challenge plus session id */\n\t\tlen = BN_num_bytes(challenge);\n\t\tif (len <= 0 || len > 32) {\n\t\t\tlogit(\"%s: bad challenge length %d\", __func__, len);\n\t\t\tgoto failure;\n\t\t}\n\t\tmemset(buf, 0, 32);\n\t\tBN_bn2bin(challenge, buf + 32 - len);\n\t\tif ((md = ssh_digest_start(SSH_DIGEST_MD5)) == NULL ||\n\t\t    ssh_digest_update(md, buf, 32) < 0 ||\n\t\t    ssh_digest_update(md, session_id, 16) < 0 ||\n\t\t    ssh_digest_final(md, mdbuf, sizeof(mdbuf)) < 0)\n\t\t\tfatal(\"%s: md5 failed\", __func__);\n\t\tssh_digest_free(md);\n\n\t\t/* Send the response. */\n\t\tif ((r = sshbuf_put_u8(msg, SSH_AGENT_RSA_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put(msg, mdbuf, sizeof(mdbuf))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n failure:\n\t/* Unknown identity or protocol error.  Send failure. */\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n send:\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshkey_free(key);\n\tBN_clear_free(challenge);\n\tsshbuf_free(msg);\n}\n#endif\n\nstatic char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t}\n\treturn NULL;\n}\n\n/* ssh2 only */\nstatic void\nprocess_sign_request2(SocketEntry *e)\n{\n\tu_char *blob, *data, *signature = NULL;\n\tsize_t blen, dlen, slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1;\n\tstruct sshbuf *msg;\n\tstruct sshkey *key;\n\tstruct identity *id;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_get_string(e->request, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_get_string(e->request, &data, &dlen)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (flags & SSH_AGENT_OLD_SIGNATURE)\n\t\tcompat = SSH_BUG_SIGBLOB;\n\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\terror(\"%s: cannot parse key blob: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\tif ((id = lookup_identity(key, 2)) == NULL) {\n\t\tverbose(\"%s: %s key not found\", __func__, sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif (id->confirm && confirm_key(id) != 0) {\n\t\tverbose(\"%s: user refused key\", __func__);\n\t\tgoto send;\n\t}\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    data, dlen, agent_decode_alg(key, flags), compat)) != 0) {\n\t\terror(\"%s: sshkey_sign: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n send:\n\tsshkey_free(key);\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(msg);\n\tfree(data);\n\tfree(blob);\n\tfree(signature);\n}\n\n/* shared */\nstatic void\nprocess_remove_identity(SocketEntry *e, int version)\n{\n\tsize_t blen;\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tu_char *blob;\n#ifdef WITH_SSH1\n\tu_int bits;\n#endif /* WITH_SSH1 */\n\n\tswitch (version) {\n#ifdef WITH_SSH1\n\tcase 1:\n\t\tif ((key = sshkey_new(KEY_RSA1)) == NULL) {\n\t\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(e->request, &bits)) != 0 ||\n\t\t    (r = sshbuf_get_bignum1(e->request, key->rsa->e)) != 0 ||\n\t\t    (r = sshbuf_get_bignum1(e->request, key->rsa->n)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t\tif (bits != sshkey_size(key))\n\t\t\tlogit(\"Warning: identity keysize mismatch: \"\n\t\t\t    \"actual %u, announced %u\",\n\t\t\t    sshkey_size(key), bits);\n\t\tbreak;\n#endif /* WITH_SSH1 */\n\tcase 2:\n\t\tif ((r = sshbuf_get_string(e->request, &blob, &blen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0)\n\t\t\terror(\"%s: sshkey_from_blob failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tfree(blob);\n\t\tbreak;\n\t}\n\tif (key != NULL) {\n\t\tIdentity *id = lookup_identity(key, version);\n\t\tif (id != NULL) {\n\t\t\t/*\n\t\t\t * We have this key.  Free the old key.  Since we\n\t\t\t * don't want to leave empty slots in the middle of\n\t\t\t * the array, we actually free the key there and move\n\t\t\t * all the entries between the empty slot and the end\n\t\t\t * of the array.\n\t\t\t */\n\t\t\tIdtab *tab = idtab_lookup(version);\n\t\t\tif (tab->nentries < 1)\n\t\t\t\tfatal(\"process_remove_identity: \"\n\t\t\t\t    \"internal error: tab->nentries %d\",\n\t\t\t\t    tab->nentries);\n\t\t\tTAILQ_REMOVE(&tab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\ttab->nentries--;\n\t\t\tsuccess = 1;\n\t\t}\n\t\tsshkey_free(key);\n\t}\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_all_identities(SocketEntry *e, int version)\n{\n\tIdtab *tab = idtab_lookup(version);\n\tIdentity *id;\n\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&tab->idlist); id;\n\t    id = TAILQ_FIRST(&tab->idlist)) {\n\t\tTAILQ_REMOVE(&tab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\ttab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}\n\n/* removes expired keys and returns number of seconds until the next expiry */\nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\tint version;\n\tIdtab *tab;\n\n\tfor (version = 1; version < 3; version++) {\n\t\ttab = idtab_lookup(version);\n\t\tfor (id = TAILQ_FIRST(&tab->idlist); id; id = nxt) {\n\t\t\tnxt = TAILQ_NEXT(id, next);\n\t\t\tif (id->death == 0)\n\t\t\t\tcontinue;\n\t\t\tif (now >= id->death) {\n\t\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\t\tTAILQ_REMOVE(&tab->idlist, id, next);\n\t\t\t\tfree_identity(id);\n\t\t\t\ttab->nentries--;\n\t\t\t} else\n\t\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t\t    MINIMUM(deadline, id->death);\n\t\t}\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}\n\n/*\n * XXX this and the corresponding serialisation function probably belongs\n * in key.c\n */\n#ifdef WITH_SSH1\nstatic int\nagent_decode_rsa1(struct sshbuf *m, struct sshkey **kp)\n{\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*kp = NULL;\n\tif ((k = sshkey_new_private(KEY_RSA1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((r = sshbuf_get_u32(m, NULL)) != 0 ||\t\t/* ignored */\n\t    (r = sshbuf_get_bignum1(m, k->rsa->n)) != 0 ||\n\t    (r = sshbuf_get_bignum1(m, k->rsa->e)) != 0 ||\n\t    (r = sshbuf_get_bignum1(m, k->rsa->d)) != 0 ||\n\t    (r = sshbuf_get_bignum1(m, k->rsa->iqmp)) != 0 ||\n\t    /* SSH1 and SSL have p and q swapped */\n\t    (r = sshbuf_get_bignum1(m, k->rsa->q)) != 0 ||\t/* p */\n\t    (r = sshbuf_get_bignum1(m, k->rsa->p)) != 0) \t/* q */\n\t\tgoto out;\n\n\t/* Generate additional parameters */\n\tif ((r = rsa_generate_additional_parameters(k->rsa)) != 0)\n\t\tgoto out;\n\t/* enable blinding */\n\tif (RSA_blinding_on(k->rsa, NULL) != 1) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\tr = 0; /* success */\n out:\n\tif (r == 0)\n\t\t*kp = k;\n\telse\n\t\tsshkey_free(k);\n\treturn r;\n}\n#endif /* WITH_SSH1 */\n\nstatic void\nprocess_add_identity(SocketEntry *e, int version)\n{\n\tIdtab *tab = idtab_lookup(version);\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tu_int seconds;\n\tchar *comment = NULL;\n\ttime_t death = 0;\n\tstruct sshkey *k = NULL;\n\tu_char ctype;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tswitch (version) {\n#ifdef WITH_SSH1\n\tcase 1:\n\t\tr = agent_decode_rsa1(e->request, &k);\n\t\tbreak;\n#endif /* WITH_SSH1 */\n\tcase 2:\n\t\tr = sshkey_private_deserialize(e->request, &k);\n\t\tbreak;\n\t}\n\tif (r != 0 || k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror(\"%s: decode private key: %s\", __func__, ssh_err(r));\n\t\tgoto err;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &ctype)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto err;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: bad lifetime constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint %d\", __func__, ctype);\n err:\n\t\t\tsshbuf_reset(e->request);\n\t\t\tfree(comment);\n\t\t\tsshkey_free(k);\n\t\t\tgoto send;\n\t\t}\n\t}\n\n\tsuccess = 1;\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k, version)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tid->key = k;\n\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\ttab->nentries++;\n\t} else {\n\t\tsshkey_free(k);\n\t\tfree(id->comment);\n\t}\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\nsend:\n\tsend_status(e, success);\n}\n\n/* XXX todo: encrypt sensitive data with passphrase */\nstatic void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\texplicit_bzero(passwd, pwlen);\n\tfree(passwd);\n\tsend_status(e, success);\n}\n\nstatic void\nno_identities(SocketEntry *e, u_int type)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg,\n\t    (type == SSH_AGENTC_REQUEST_RSA_IDENTITIES) ?\n\t    SSH_AGENT_RSA_IDENTITIES_ANSWER :\n\t    SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}\n\n#ifdef ENABLE_PKCS11\nstatic void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin;\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(provider);\n\t\t\tid->comment = xstrdup(provider); /* XXX */\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL;\n\tint r, version, success = 0;\n\tIdentity *id, *nxt;\n\tIdtab *tab;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfree(pin);\n\n\tfor (version = 1; version < 3; version++) {\n\t\ttab = idtab_lookup(version);\n\t\tfor (id = TAILQ_FIRST(&tab->idlist); id; id = nxt) {\n\t\t\tnxt = TAILQ_NEXT(id, next);\n\t\t\t/* Skip file--based keys */\n\t\t\tif (id->provider == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (!strcmp(provider, id->provider)) {\n\t\t\t\tTAILQ_REMOVE(&tab->idlist, id, next);\n\t\t\t\tfree_identity(id);\n\t\t\t\ttab->nentries--;\n\t\t\t}\n\t\t}\n\t}\n\tif (pkcs11_del_provider(provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror(\"process_remove_smartcard_key:\"\n\t\t    \" pkcs11_del_provider failed\");\n\tfree(provider);\n\tsend_status(e, success);\n}\n#endif /* ENABLE_PKCS11 */\n\n/* dispatch incoming messages */\n\nstatic void\nprocess_message(SocketEntry *e)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn;\t\t/* Incomplete message. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > 256 * 1024) {\n\t\tclose_socket(e);\n\t\treturn;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn;\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* check wheter agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH_AGENTC_REQUEST_RSA_IDENTITIES:\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e, type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tdebug(\"type %d\", type);\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n#ifdef WITH_SSH1\n\t/* ssh1 */\n\tcase SSH_AGENTC_RSA_CHALLENGE:\n\t\tprocess_authentication_challenge1(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REQUEST_RSA_IDENTITIES:\n\t\tprocess_request_identities(e, 1);\n\t\tbreak;\n\tcase SSH_AGENTC_ADD_RSA_IDENTITY:\n\tcase SSH_AGENTC_ADD_RSA_ID_CONSTRAINED:\n\t\tprocess_add_identity(e, 1);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_RSA_IDENTITY:\n\t\tprocess_remove_identity(e, 1);\n\t\tbreak;\n#endif\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e, 1); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e, 2);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e, 2);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e, 2);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e, 2);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].output = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xreallocarray(sockets, new_alloc, sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].output = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsockets[old_alloc].type = type;\n}\n\nstatic int\nprepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, u_int *nallocp,\n    struct timeval **tvpp)\n{\n\tu_int i, sz;\n\tint n = 0;\n\tstatic struct timeval tv;\n\ttime_t deadline;\n\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tn = MAXIMUM(n, sockets[i].fd);\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsz = howmany(n+1, NFDBITS) * sizeof(fd_mask);\n\tif (*fdrp == NULL || sz > *nallocp) {\n\t\tfree(*fdrp);\n\t\tfree(*fdwp);\n\t\t*fdrp = xmalloc(sz);\n\t\t*fdwp = xmalloc(sz);\n\t\t*nallocp = sz;\n\t}\n\tif (n < *fdl)\n\t\tdebug(\"XXX shrink: %d < %d\", n, *fdl);\n\t*fdl = n;\n\tmemset(*fdrp, 0, sz);\n\tmemset(*fdwp, 0, sz);\n\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tFD_SET(sockets[i].fd, *fdrp);\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tFD_SET(sockets[i].fd, *fdwp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*tvpp = NULL;\n\t} else {\n\t\ttv.tv_sec = deadline;\n\t\ttv.tv_usec = 0;\n\t\t*tvpp = &tv;\n\t}\n\treturn (1);\n}\n\nstatic void\nafter_select(fd_set *readset, fd_set *writeset)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tchar buf[1024];\n\tint len, sock, r;\n\tu_int i, orig_alloc;\n\tuid_t euid;\n\tgid_t egid;\n\n\tfor (i = 0, orig_alloc = sockets_alloc; i < orig_alloc; i++)\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tcase AUTH_SOCKET:\n\t\t\tif (FD_ISSET(sockets[i].fd, readset)) {\n\t\t\t\tslen = sizeof(sunaddr);\n\t\t\t\tsock = accept(sockets[i].fd,\n\t\t\t\t    (struct sockaddr *)&sunaddr, &slen);\n\t\t\t\tif (sock < 0) {\n\t\t\t\t\terror(\"accept from AUTH_SOCKET: %s\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (getpeereid(sock, &euid, &egid) < 0) {\n\t\t\t\t\terror(\"getpeereid %d failed: %s\",\n\t\t\t\t\t    sock, strerror(errno));\n\t\t\t\t\tclose(sock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((euid != 0) && (getuid() != euid)) {\n\t\t\t\t\terror(\"uid mismatch: \"\n\t\t\t\t\t    \"peer euid %u != uid %u\",\n\t\t\t\t\t    (u_int) euid, (u_int) getuid());\n\t\t\t\t\tclose(sock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew_socket(AUTH_CONNECTION, sock);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif (sshbuf_len(sockets[i].output) > 0 &&\n\t\t\t    FD_ISSET(sockets[i].fd, writeset)) {\n\t\t\t\tlen = write(sockets[i].fd,\n\t\t\t\t    sshbuf_ptr(sockets[i].output),\n\t\t\t\t    sshbuf_len(sockets[i].output));\n\t\t\t\tif (len == -1 && (errno == EAGAIN ||\n\t\t\t\t    errno == EINTR))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (len <= 0) {\n\t\t\t\t\tclose_socket(&sockets[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((r = sshbuf_consume(sockets[i].output,\n\t\t\t\t    len)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t\tif (FD_ISSET(sockets[i].fd, readset)) {\n\t\t\t\tlen = read(sockets[i].fd, buf, sizeof(buf));\n\t\t\t\tif (len == -1 && (errno == EAGAIN ||\n\t\t\t\t    errno == EINTR))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (len <= 0) {\n\t\t\t\t\tclose_socket(&sockets[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((r = sshbuf_put(sockets[i].input,\n\t\t\t\t    buf, len)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\texplicit_bzero(buf, sizeof(buf));\n\t\t\t\tprocess_message(&sockets[i]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown type %d\", sockets[i].type);\n\t\t}\n}\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}\n\n/*ARGSUSED*/\nstatic void\ncleanup_handler(int sig)\n{\n\tcleanup_socket();\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\t_exit(2);\n}\n\nstatic void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}\n\nint\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, fd, ch, result, saved_errno;\n\tu_int nalloc;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tfd_set *readsetp = NULL, *writesetp = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tstruct timeval *tvp = NULL;\n\tsize_t len;\n\tmode_t prev_mask;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t/* XXX might close listen socket */\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\tclose(fd);\n\t}\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) < 0) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tsignal(SIGHUP, cleanup_handler);\n\tsignal(SIGTERM, cleanup_handler);\n\tnalloc = 0;\n\n\tif (pledge(\"stdio cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);\n\t\tresult = select(max_fd + 1, readsetp, writesetp, NULL, tvp);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result < 0) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"select: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_select(readsetp, writesetp);\n\t}\n\t/* NOTREACHED */\n}\n"], "fixing_code": [".\\\" $OpenBSD: ssh-agent.1,v 1.63 2016/11/30 03:07:37 djm Exp $\n.\\\"\n.\\\" Author: Tatu Ylonen <ylo@cs.hut.fi>\n.\\\" Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n.\\\"                    All rights reserved\n.\\\"\n.\\\" As far as I am concerned, the code I have written for this software\n.\\\" can be used freely for any purpose.  Any derived versions of this\n.\\\" software must be clearly marked as such, and if the derived work is\n.\\\" incompatible with the protocol description in the RFC file, it must be\n.\\\" called by a name other than \"ssh\" or \"Secure Shell\".\n.\\\"\n.\\\" Copyright (c) 1999,2000 Markus Friedl.  All rights reserved.\n.\\\" Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n.\\\" Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that the following conditions\n.\\\" are met:\n.\\\" 1. Redistributions of source code must retain the above copyright\n.\\\"    notice, this list of conditions and the following disclaimer.\n.\\\" 2. Redistributions in binary form must reproduce the above copyright\n.\\\"    notice, this list of conditions and the following disclaimer in the\n.\\\"    documentation and/or other materials provided with the distribution.\n.\\\"\n.\\\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n.\\\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n.\\\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n.\\\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n.\\\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n.\\\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n.\\\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n.\\\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n.\\\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n.\\\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n.\\\"\n.Dd $Mdocdate: November 30 2016 $\n.Dt SSH-AGENT 1\n.Os\n.Sh NAME\n.Nm ssh-agent\n.Nd authentication agent\n.Sh SYNOPSIS\n.Nm ssh-agent\n.Op Fl c | s\n.Op Fl \\&Dd\n.Op Fl a Ar bind_address\n.Op Fl E Ar fingerprint_hash\n.Op Fl t Ar life\n.Op Fl P Ar pkcs11_whitelist\n.Op Ar command Op Ar arg ...\n.Nm ssh-agent\n.Op Fl c | s\n.Fl k\n.Sh DESCRIPTION\n.Nm\nis a program to hold private keys used for public key authentication\n(RSA, DSA, ECDSA, Ed25519).\n.Nm\nis usually started in the beginning of an X-session or a login session, and\nall other windows or programs are started as clients to the ssh-agent\nprogram.\nThrough use of environment variables the agent can be located\nand automatically used for authentication when logging in to other\nmachines using\n.Xr ssh 1 .\n.Pp\nThe agent initially does not have any private keys.\nKeys are added using\n.Xr ssh 1\n(see\n.Cm AddKeysToAgent\nin\n.Xr ssh_config 5\nfor details)\nor\n.Xr ssh-add 1 .\nMultiple identities may be stored in\n.Nm\nconcurrently and\n.Xr ssh 1\nwill automatically use them if present.\n.Xr ssh-add 1\nis also used to remove keys from\n.Nm\nand to query the keys that are held in one.\n.Pp\nThe options are as follows:\n.Bl -tag -width Ds\n.It Fl a Ar bind_address\nBind the agent to the\n.Ux Ns -domain\nsocket\n.Ar bind_address .\nThe default is\n.Pa $TMPDIR/ssh-XXXXXXXXXX/agent.\\*(Ltppid\\*(Gt .\n.It Fl c\nGenerate C-shell commands on\n.Dv stdout .\nThis is the default if\n.Ev SHELL\nlooks like it's a csh style of shell.\n.It Fl D\nForeground mode.\nWhen this option is specified\n.Nm\nwill not fork.\n.It Fl d\nDebug mode.\nWhen this option is specified\n.Nm\nwill not fork and will write debug information to standard error.\n.It Fl E Ar fingerprint_hash\nSpecifies the hash algorithm used when displaying key fingerprints.\nValid options are:\n.Dq md5\nand\n.Dq sha256 .\nThe default is\n.Dq sha256 .\n.It Fl k\nKill the current agent (given by the\n.Ev SSH_AGENT_PID\nenvironment variable).\n.It Fl P\nSpecify a pattern-list of acceptable paths for PKCS#11 shared libraries\nthat may be added using the\n.Fl s\noption to\n.Xr ssh-add 1 .\nThe default is to allow loading PKCS#11 libraries from\n.Dq /usr/lib/*,/usr/local/lib/* .\nPKCS#11 libraries that do not match the whitelist will be refused.\nSee PATTERNS in\n.Xr ssh_config 5\nfor a description of pattern-list syntax.\n.It Fl s\nGenerate Bourne shell commands on\n.Dv stdout .\nThis is the default if\n.Ev SHELL\ndoes not look like it's a csh style of shell.\n.It Fl t Ar life\nSet a default value for the maximum lifetime of identities added to the agent.\nThe lifetime may be specified in seconds or in a time format specified in\n.Xr sshd_config 5 .\nA lifetime specified for an identity with\n.Xr ssh-add 1\noverrides this value.\nWithout this option the default maximum lifetime is forever.\n.El\n.Pp\nIf a command line is given, this is executed as a subprocess of the agent.\nWhen the command dies, so does the agent.\n.Pp\nThe idea is that the agent is run in the user's local PC, laptop, or\nterminal.\nAuthentication data need not be stored on any other\nmachine, and authentication passphrases never go over the network.\nHowever, the connection to the agent is forwarded over SSH\nremote logins, and the user can thus use the privileges given by the\nidentities anywhere in the network in a secure way.\n.Pp\nThere are two main ways to get an agent set up:\nThe first is that the agent starts a new subcommand into which some environment\nvariables are exported, eg\n.Cm ssh-agent xterm & .\nThe second is that the agent prints the needed shell commands (either\n.Xr sh 1\nor\n.Xr csh 1\nsyntax can be generated) which can be evaluated in the calling shell, eg\n.Cm eval `ssh-agent -s`\nfor Bourne-type shells such as\n.Xr sh 1\nor\n.Xr ksh 1\nand\n.Cm eval `ssh-agent -c`\nfor\n.Xr csh 1\nand derivatives.\n.Pp\nLater\n.Xr ssh 1\nlooks at these variables and uses them to establish a connection to the agent.\n.Pp\nThe agent will never send a private key over its request channel.\nInstead, operations that require a private key will be performed\nby the agent, and the result will be returned to the requester.\nThis way, private keys are not exposed to clients using the agent.\n.Pp\nA\n.Ux Ns -domain\nsocket is created and the name of this socket is stored in the\n.Ev SSH_AUTH_SOCK\nenvironment\nvariable.\nThe socket is made accessible only to the current user.\nThis method is easily abused by root or another instance of the same\nuser.\n.Pp\nThe\n.Ev SSH_AGENT_PID\nenvironment variable holds the agent's process ID.\n.Pp\nThe agent exits automatically when the command given on the command\nline terminates.\n.Sh FILES\n.Bl -tag -width Ds\n.It Pa $TMPDIR/ssh-XXXXXXXXXX/agent.\\*(Ltppid\\*(Gt\n.Ux Ns -domain\nsockets used to contain the connection to the authentication agent.\nThese sockets should only be readable by the owner.\nThe sockets should get automatically removed when the agent exits.\n.El\n.Sh SEE ALSO\n.Xr ssh 1 ,\n.Xr ssh-add 1 ,\n.Xr ssh-keygen 1 ,\n.Xr sshd 8\n.Sh AUTHORS\nOpenSSH is a derivative of the original and free\nssh 1.2.12 release by Tatu Ylonen.\nAaron Campbell, Bob Beck, Markus Friedl, Niels Provos,\nTheo de Raadt and Dug Song\nremoved many bugs, re-added newer features and\ncreated OpenSSH.\nMarkus Friedl contributed the support for SSH\nprotocol versions 1.5 and 2.0.\n", "/* $OpenBSD: ssh-agent.c,v 1.215 2016/11/30 03:07:37 djm Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * The authentication agent program.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/queue.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n\n#ifdef WITH_OPENSSL\n#include <openssl/evp.h>\n#endif\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <time.h>\n#include <unistd.h>\n#include <util.h>\n\n#include \"xmalloc.h\"\n#include \"ssh.h\"\n#include \"rsa.h\"\n#include \"sshbuf.h\"\n#include \"sshkey.h\"\n#include \"authfd.h\"\n#include \"compat.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"digest.h\"\n#include \"ssherr.h\"\n#include \"match.h\"\n\n#ifdef ENABLE_PKCS11\n#include \"ssh-pkcs11.h\"\n#endif\n\n#ifndef DEFAULT_PKCS11_WHITELIST\n# define DEFAULT_PKCS11_WHITELIST \"/usr/lib/*,/usr/local/lib/*\"\n#endif\n\ntypedef enum {\n\tAUTH_UNUSED,\n\tAUTH_SOCKET,\n\tAUTH_CONNECTION\n} sock_type;\n\ntypedef struct {\n\tint fd;\n\tsock_type type;\n\tstruct sshbuf *input;\n\tstruct sshbuf *output;\n\tstruct sshbuf *request;\n} SocketEntry;\n\nu_int sockets_alloc = 0;\nSocketEntry *sockets = NULL;\n\ntypedef struct identity {\n\tTAILQ_ENTRY(identity) next;\n\tstruct sshkey *key;\n\tchar *comment;\n\tchar *provider;\n\ttime_t death;\n\tu_int confirm;\n} Identity;\n\ntypedef struct {\n\tint nentries;\n\tTAILQ_HEAD(idqueue, identity) idlist;\n} Idtab;\n\n/* private key table, one per protocol version */\nIdtab idtable[3];\n\nint max_fd = 0;\n\n/* pid of shell == parent of agent */\npid_t parent_pid = -1;\ntime_t parent_alive_interval = 0;\n\n/* pid of process for which cleanup_socket is applicable */\npid_t cleanup_pid = 0;\n\n/* pathname and directory for AUTH_SOCKET */\nchar socket_name[PATH_MAX];\nchar socket_dir[PATH_MAX];\n\n/* PKCS#11 path whitelist */\nstatic char *pkcs11_whitelist;\n\n/* locking */\n#define LOCK_SIZE\t32\n#define LOCK_SALT_SIZE\t16\n#define LOCK_ROUNDS\t1\nint locked = 0;\nu_char lock_pwhash[LOCK_SIZE];\nu_char lock_salt[LOCK_SALT_SIZE];\n\nextern char *__progname;\n\n/* Default lifetime in seconds (0 == forever) */\nstatic long lifetime = 0;\n\nstatic int fingerprint_hash = SSH_FP_HASH_DEFAULT;\n\nstatic void\nclose_socket(SocketEntry *e)\n{\n\tclose(e->fd);\n\te->fd = -1;\n\te->type = AUTH_UNUSED;\n\tsshbuf_free(e->input);\n\tsshbuf_free(e->output);\n\tsshbuf_free(e->request);\n}\n\nstatic void\nidtab_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i <=2; i++) {\n\t\tTAILQ_INIT(&idtable[i].idlist);\n\t\tidtable[i].nentries = 0;\n\t}\n}\n\n/* return private key table for requested protocol version */\nstatic Idtab *\nidtab_lookup(int version)\n{\n\tif (version < 1 || version > 2)\n\t\tfatal(\"internal error, bad protocol version %d\", version);\n\treturn &idtable[version];\n}\n\nstatic void\nfree_identity(Identity *id)\n{\n\tsshkey_free(id->key);\n\tfree(id->provider);\n\tfree(id->comment);\n\tfree(id);\n}\n\n/* return matching private key for given public key */\nstatic Identity *\nlookup_identity(struct sshkey *key, int version)\n{\n\tIdentity *id;\n\n\tIdtab *tab = idtab_lookup(version);\n\tTAILQ_FOREACH(id, &tab->idlist, next) {\n\t\tif (sshkey_equal(key, id->key))\n\t\t\treturn (id);\n\t}\n\treturn (NULL);\n}\n\n/* Check confirmation of keysign request */\nstatic int\nconfirm_key(Identity *id)\n{\n\tchar *p;\n\tint ret = -1;\n\n\tp = sshkey_fingerprint(id->key, fingerprint_hash, SSH_FP_DEFAULT);\n\tif (p != NULL &&\n\t    ask_permission(\"Allow use of key %s?\\nKey fingerprint %s.\",\n\t    id->comment, p))\n\t\tret = 0;\n\tfree(p);\n\n\treturn (ret);\n}\n\nstatic void\nsend_status(SocketEntry *e, int success)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_u32(e->output, 1)) != 0 ||\n\t    (r = sshbuf_put_u8(e->output, success ?\n\t    SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n}\n\n/* send list of supported public keys to 'client' */\nstatic void\nprocess_request_identities(SocketEntry *e, int version)\n{\n\tIdtab *tab = idtab_lookup(version);\n\tIdentity *id;\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg, (version == 1) ?\n\t    SSH_AGENT_RSA_IDENTITIES_ANSWER :\n\t    SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, tab->nentries)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tTAILQ_FOREACH(id, &tab->idlist, next) {\n\t\tif (id->key->type == KEY_RSA1) {\n#ifdef WITH_SSH1\n\t\t\tif ((r = sshbuf_put_u32(msg,\n\t\t\t    BN_num_bits(id->key->rsa->n))) != 0 ||\n\t\t\t    (r = sshbuf_put_bignum1(msg,\n\t\t\t    id->key->rsa->e)) != 0 ||\n\t\t\t    (r = sshbuf_put_bignum1(msg,\n\t\t\t    id->key->rsa->n)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n#endif\n\t\t} else {\n\t\t\tu_char *blob;\n\t\t\tsize_t blen;\n\n\t\t\tif ((r = sshkey_to_blob(id->key, &blob, &blen)) != 0) {\n\t\t\t\terror(\"%s: sshkey_to_blob: %s\", __func__,\n\t\t\t\t    ssh_err(r));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((r = sshbuf_put_string(msg, blob, blen)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tfree(blob);\n\t\t}\n\t\tif ((r = sshbuf_put_cstring(msg, id->comment)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t}\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}\n\n#ifdef WITH_SSH1\n/* ssh1 only */\nstatic void\nprocess_authentication_challenge1(SocketEntry *e)\n{\n\tu_char buf[32], mdbuf[16], session_id[16];\n\tu_int response_type;\n\tBIGNUM *challenge;\n\tIdentity *id;\n\tint r, len;\n\tstruct sshbuf *msg;\n\tstruct ssh_digest_ctx *md;\n\tstruct sshkey *key;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((key = sshkey_new(KEY_RSA1)) == NULL)\n\t\tfatal(\"%s: sshkey_new failed\", __func__);\n\tif ((challenge = BN_new()) == NULL)\n\t\tfatal(\"%s: BN_new failed\", __func__);\n\n\tif ((r = sshbuf_get_u32(e->request, NULL)) != 0 || /* ignored */\n\t    (r = sshbuf_get_bignum1(e->request, key->rsa->e)) != 0 ||\n\t    (r = sshbuf_get_bignum1(e->request, key->rsa->n)) != 0 ||\n\t    (r = sshbuf_get_bignum1(e->request, challenge)))\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* Only protocol 1.1 is supported */\n\tif (sshbuf_len(e->request) == 0)\n\t\tgoto failure;\n\tif ((r = sshbuf_get(e->request, session_id, sizeof(session_id))) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &response_type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (response_type != 1)\n\t\tgoto failure;\n\n\tid = lookup_identity(key, 1);\n\tif (id != NULL && (!id->confirm || confirm_key(id) == 0)) {\n\t\tstruct sshkey *private = id->key;\n\t\t/* Decrypt the challenge using the private key. */\n\t\tif ((r = rsa_private_decrypt(challenge, challenge,\n\t\t    private->rsa) != 0)) {\n\t\t\tfatal(\"%s: rsa_public_encrypt: %s\", __func__,\n\t\t\t    ssh_err(r));\n\t\t\tgoto failure;\t/* XXX ? */\n\t\t}\n\n\t\t/* The response is MD5 of decrypted challenge plus session id */\n\t\tlen = BN_num_bytes(challenge);\n\t\tif (len <= 0 || len > 32) {\n\t\t\tlogit(\"%s: bad challenge length %d\", __func__, len);\n\t\t\tgoto failure;\n\t\t}\n\t\tmemset(buf, 0, 32);\n\t\tBN_bn2bin(challenge, buf + 32 - len);\n\t\tif ((md = ssh_digest_start(SSH_DIGEST_MD5)) == NULL ||\n\t\t    ssh_digest_update(md, buf, 32) < 0 ||\n\t\t    ssh_digest_update(md, session_id, 16) < 0 ||\n\t\t    ssh_digest_final(md, mdbuf, sizeof(mdbuf)) < 0)\n\t\t\tfatal(\"%s: md5 failed\", __func__);\n\t\tssh_digest_free(md);\n\n\t\t/* Send the response. */\n\t\tif ((r = sshbuf_put_u8(msg, SSH_AGENT_RSA_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put(msg, mdbuf, sizeof(mdbuf))) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\n failure:\n\t/* Unknown identity or protocol error.  Send failure. */\n\tif ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n send:\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshkey_free(key);\n\tBN_clear_free(challenge);\n\tsshbuf_free(msg);\n}\n#endif\n\nstatic char *\nagent_decode_alg(struct sshkey *key, u_int flags)\n{\n\tif (key->type == KEY_RSA) {\n\t\tif (flags & SSH_AGENT_RSA_SHA2_256)\n\t\t\treturn \"rsa-sha2-256\";\n\t\telse if (flags & SSH_AGENT_RSA_SHA2_512)\n\t\t\treturn \"rsa-sha2-512\";\n\t}\n\treturn NULL;\n}\n\n/* ssh2 only */\nstatic void\nprocess_sign_request2(SocketEntry *e)\n{\n\tu_char *blob, *data, *signature = NULL;\n\tsize_t blen, dlen, slen = 0;\n\tu_int compat = 0, flags;\n\tint r, ok = -1;\n\tstruct sshbuf *msg;\n\tstruct sshkey *key;\n\tstruct identity *id;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_get_string(e->request, &blob, &blen)) != 0 ||\n\t    (r = sshbuf_get_string(e->request, &data, &dlen)) != 0 ||\n\t    (r = sshbuf_get_u32(e->request, &flags)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (flags & SSH_AGENT_OLD_SIGNATURE)\n\t\tcompat = SSH_BUG_SIGBLOB;\n\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\terror(\"%s: cannot parse key blob: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\tif ((id = lookup_identity(key, 2)) == NULL) {\n\t\tverbose(\"%s: %s key not found\", __func__, sshkey_type(key));\n\t\tgoto send;\n\t}\n\tif (id->confirm && confirm_key(id) != 0) {\n\t\tverbose(\"%s: user refused key\", __func__);\n\t\tgoto send;\n\t}\n\tif ((r = sshkey_sign(id->key, &signature, &slen,\n\t    data, dlen, agent_decode_alg(key, flags), compat)) != 0) {\n\t\terror(\"%s: sshkey_sign: %s\", __func__, ssh_err(r));\n\t\tgoto send;\n\t}\n\t/* Success */\n\tok = 0;\n send:\n\tsshkey_free(key);\n\tif (ok == 0) {\n\t\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_SIGN_RESPONSE)) != 0 ||\n\t\t    (r = sshbuf_put_string(msg, signature, slen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t} else if ((r = sshbuf_put_u8(msg, SSH_AGENT_FAILURE)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tsshbuf_free(msg);\n\tfree(data);\n\tfree(blob);\n\tfree(signature);\n}\n\n/* shared */\nstatic void\nprocess_remove_identity(SocketEntry *e, int version)\n{\n\tsize_t blen;\n\tint r, success = 0;\n\tstruct sshkey *key = NULL;\n\tu_char *blob;\n#ifdef WITH_SSH1\n\tu_int bits;\n#endif /* WITH_SSH1 */\n\n\tswitch (version) {\n#ifdef WITH_SSH1\n\tcase 1:\n\t\tif ((key = sshkey_new(KEY_RSA1)) == NULL) {\n\t\t\terror(\"%s: sshkey_new failed\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif ((r = sshbuf_get_u32(e->request, &bits)) != 0 ||\n\t\t    (r = sshbuf_get_bignum1(e->request, key->rsa->e)) != 0 ||\n\t\t    (r = sshbuf_get_bignum1(e->request, key->rsa->n)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t\tif (bits != sshkey_size(key))\n\t\t\tlogit(\"Warning: identity keysize mismatch: \"\n\t\t\t    \"actual %u, announced %u\",\n\t\t\t    sshkey_size(key), bits);\n\t\tbreak;\n#endif /* WITH_SSH1 */\n\tcase 2:\n\t\tif ((r = sshbuf_get_string(e->request, &blob, &blen)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tif ((r = sshkey_from_blob(blob, blen, &key)) != 0)\n\t\t\terror(\"%s: sshkey_from_blob failed: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\tfree(blob);\n\t\tbreak;\n\t}\n\tif (key != NULL) {\n\t\tIdentity *id = lookup_identity(key, version);\n\t\tif (id != NULL) {\n\t\t\t/*\n\t\t\t * We have this key.  Free the old key.  Since we\n\t\t\t * don't want to leave empty slots in the middle of\n\t\t\t * the array, we actually free the key there and move\n\t\t\t * all the entries between the empty slot and the end\n\t\t\t * of the array.\n\t\t\t */\n\t\t\tIdtab *tab = idtab_lookup(version);\n\t\t\tif (tab->nentries < 1)\n\t\t\t\tfatal(\"process_remove_identity: \"\n\t\t\t\t    \"internal error: tab->nentries %d\",\n\t\t\t\t    tab->nentries);\n\t\t\tTAILQ_REMOVE(&tab->idlist, id, next);\n\t\t\tfree_identity(id);\n\t\t\ttab->nentries--;\n\t\t\tsuccess = 1;\n\t\t}\n\t\tsshkey_free(key);\n\t}\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_all_identities(SocketEntry *e, int version)\n{\n\tIdtab *tab = idtab_lookup(version);\n\tIdentity *id;\n\n\t/* Loop over all identities and clear the keys. */\n\tfor (id = TAILQ_FIRST(&tab->idlist); id;\n\t    id = TAILQ_FIRST(&tab->idlist)) {\n\t\tTAILQ_REMOVE(&tab->idlist, id, next);\n\t\tfree_identity(id);\n\t}\n\n\t/* Mark that there are no identities. */\n\ttab->nentries = 0;\n\n\t/* Send success. */\n\tsend_status(e, 1);\n}\n\n/* removes expired keys and returns number of seconds until the next expiry */\nstatic time_t\nreaper(void)\n{\n\ttime_t deadline = 0, now = monotime();\n\tIdentity *id, *nxt;\n\tint version;\n\tIdtab *tab;\n\n\tfor (version = 1; version < 3; version++) {\n\t\ttab = idtab_lookup(version);\n\t\tfor (id = TAILQ_FIRST(&tab->idlist); id; id = nxt) {\n\t\t\tnxt = TAILQ_NEXT(id, next);\n\t\t\tif (id->death == 0)\n\t\t\t\tcontinue;\n\t\t\tif (now >= id->death) {\n\t\t\t\tdebug(\"expiring key '%s'\", id->comment);\n\t\t\t\tTAILQ_REMOVE(&tab->idlist, id, next);\n\t\t\t\tfree_identity(id);\n\t\t\t\ttab->nentries--;\n\t\t\t} else\n\t\t\t\tdeadline = (deadline == 0) ? id->death :\n\t\t\t\t    MINIMUM(deadline, id->death);\n\t\t}\n\t}\n\tif (deadline == 0 || deadline <= now)\n\t\treturn 0;\n\telse\n\t\treturn (deadline - now);\n}\n\n/*\n * XXX this and the corresponding serialisation function probably belongs\n * in key.c\n */\n#ifdef WITH_SSH1\nstatic int\nagent_decode_rsa1(struct sshbuf *m, struct sshkey **kp)\n{\n\tstruct sshkey *k = NULL;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\t*kp = NULL;\n\tif ((k = sshkey_new_private(KEY_RSA1)) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\n\tif ((r = sshbuf_get_u32(m, NULL)) != 0 ||\t\t/* ignored */\n\t    (r = sshbuf_get_bignum1(m, k->rsa->n)) != 0 ||\n\t    (r = sshbuf_get_bignum1(m, k->rsa->e)) != 0 ||\n\t    (r = sshbuf_get_bignum1(m, k->rsa->d)) != 0 ||\n\t    (r = sshbuf_get_bignum1(m, k->rsa->iqmp)) != 0 ||\n\t    /* SSH1 and SSL have p and q swapped */\n\t    (r = sshbuf_get_bignum1(m, k->rsa->q)) != 0 ||\t/* p */\n\t    (r = sshbuf_get_bignum1(m, k->rsa->p)) != 0) \t/* q */\n\t\tgoto out;\n\n\t/* Generate additional parameters */\n\tif ((r = rsa_generate_additional_parameters(k->rsa)) != 0)\n\t\tgoto out;\n\t/* enable blinding */\n\tif (RSA_blinding_on(k->rsa, NULL) != 1) {\n\t\tr = SSH_ERR_LIBCRYPTO_ERROR;\n\t\tgoto out;\n\t}\n\n\tr = 0; /* success */\n out:\n\tif (r == 0)\n\t\t*kp = k;\n\telse\n\t\tsshkey_free(k);\n\treturn r;\n}\n#endif /* WITH_SSH1 */\n\nstatic void\nprocess_add_identity(SocketEntry *e, int version)\n{\n\tIdtab *tab = idtab_lookup(version);\n\tIdentity *id;\n\tint success = 0, confirm = 0;\n\tu_int seconds;\n\tchar *comment = NULL;\n\ttime_t death = 0;\n\tstruct sshkey *k = NULL;\n\tu_char ctype;\n\tint r = SSH_ERR_INTERNAL_ERROR;\n\n\tswitch (version) {\n#ifdef WITH_SSH1\n\tcase 1:\n\t\tr = agent_decode_rsa1(e->request, &k);\n\t\tbreak;\n#endif /* WITH_SSH1 */\n\tcase 2:\n\t\tr = sshkey_private_deserialize(e->request, &k);\n\t\tbreak;\n\t}\n\tif (r != 0 || k == NULL ||\n\t    (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) {\n\t\terror(\"%s: decode private key: %s\", __func__, ssh_err(r));\n\t\tgoto err;\n\t}\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &ctype)) != 0) {\n\t\t\terror(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\t\tgoto err;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0) {\n\t\t\t\terror(\"%s: bad lifetime constraint: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"%s: Unknown constraint %d\", __func__, ctype);\n err:\n\t\t\tsshbuf_reset(e->request);\n\t\t\tfree(comment);\n\t\t\tsshkey_free(k);\n\t\t\tgoto send;\n\t\t}\n\t}\n\n\tsuccess = 1;\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tif ((id = lookup_identity(k, version)) == NULL) {\n\t\tid = xcalloc(1, sizeof(Identity));\n\t\tid->key = k;\n\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t/* Increment the number of identities. */\n\t\ttab->nentries++;\n\t} else {\n\t\tsshkey_free(k);\n\t\tfree(id->comment);\n\t}\n\tid->comment = comment;\n\tid->death = death;\n\tid->confirm = confirm;\nsend:\n\tsend_status(e, success);\n}\n\n/* XXX todo: encrypt sensitive data with passphrase */\nstatic void\nprocess_lock_agent(SocketEntry *e, int lock)\n{\n\tint r, success = 0, delay;\n\tchar *passwd;\n\tu_char passwdhash[LOCK_SIZE];\n\tstatic u_int fail_count = 0;\n\tsize_t pwlen;\n\n\tif ((r = sshbuf_get_cstring(e->request, &passwd, &pwlen)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tif (pwlen == 0) {\n\t\tdebug(\"empty password not supported\");\n\t} else if (locked && !lock) {\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    passwdhash, sizeof(passwdhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tif (timingsafe_bcmp(passwdhash, lock_pwhash, LOCK_SIZE) == 0) {\n\t\t\tdebug(\"agent unlocked\");\n\t\t\tlocked = 0;\n\t\t\tfail_count = 0;\n\t\t\texplicit_bzero(lock_pwhash, sizeof(lock_pwhash));\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\t/* delay in 0.1s increments up to 10s */\n\t\t\tif (fail_count < 100)\n\t\t\t\tfail_count++;\n\t\t\tdelay = 100000 * fail_count;\n\t\t\tdebug(\"unlock failed, delaying %0.1lf seconds\",\n\t\t\t    (double)delay/1000000);\n\t\t\tusleep(delay);\n\t\t}\n\t\texplicit_bzero(passwdhash, sizeof(passwdhash));\n\t} else if (!locked && lock) {\n\t\tdebug(\"agent locked\");\n\t\tlocked = 1;\n\t\tarc4random_buf(lock_salt, sizeof(lock_salt));\n\t\tif (bcrypt_pbkdf(passwd, pwlen, lock_salt, sizeof(lock_salt),\n\t\t    lock_pwhash, sizeof(lock_pwhash), LOCK_ROUNDS) < 0)\n\t\t\tfatal(\"bcrypt_pbkdf\");\n\t\tsuccess = 1;\n\t}\n\texplicit_bzero(passwd, pwlen);\n\tfree(passwd);\n\tsend_status(e, success);\n}\n\nstatic void\nno_identities(SocketEntry *e, u_int type)\n{\n\tstruct sshbuf *msg;\n\tint r;\n\n\tif ((msg = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((r = sshbuf_put_u8(msg,\n\t    (type == SSH_AGENTC_REQUEST_RSA_IDENTITIES) ?\n\t    SSH_AGENT_RSA_IDENTITIES_ANSWER :\n\t    SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, 0)) != 0 ||\n\t    (r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_free(msg);\n}\n\n#ifdef ENABLE_PKCS11\nstatic void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin, canonical_provider[PATH_MAX];\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not whitelisted\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug(\"%s: add %.100s\", __func__, canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}\n\nstatic void\nprocess_remove_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin = NULL;\n\tint r, version, success = 0;\n\tIdentity *id, *nxt;\n\tIdtab *tab;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tfree(pin);\n\n\tfor (version = 1; version < 3; version++) {\n\t\ttab = idtab_lookup(version);\n\t\tfor (id = TAILQ_FIRST(&tab->idlist); id; id = nxt) {\n\t\t\tnxt = TAILQ_NEXT(id, next);\n\t\t\t/* Skip file--based keys */\n\t\t\tif (id->provider == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (!strcmp(provider, id->provider)) {\n\t\t\t\tTAILQ_REMOVE(&tab->idlist, id, next);\n\t\t\t\tfree_identity(id);\n\t\t\t\ttab->nentries--;\n\t\t\t}\n\t\t}\n\t}\n\tif (pkcs11_del_provider(provider) == 0)\n\t\tsuccess = 1;\n\telse\n\t\terror(\"process_remove_smartcard_key:\"\n\t\t    \" pkcs11_del_provider failed\");\n\tfree(provider);\n\tsend_status(e, success);\n}\n#endif /* ENABLE_PKCS11 */\n\n/* dispatch incoming messages */\n\nstatic void\nprocess_message(SocketEntry *e)\n{\n\tu_int msg_len;\n\tu_char type;\n\tconst u_char *cp;\n\tint r;\n\n\tif (sshbuf_len(e->input) < 5)\n\t\treturn;\t\t/* Incomplete message. */\n\tcp = sshbuf_ptr(e->input);\n\tmsg_len = PEEK_U32(cp);\n\tif (msg_len > 256 * 1024) {\n\t\tclose_socket(e);\n\t\treturn;\n\t}\n\tif (sshbuf_len(e->input) < msg_len + 4)\n\t\treturn;\n\n\t/* move the current input to e->request */\n\tsshbuf_reset(e->request);\n\tif ((r = sshbuf_get_stringb(e->input, e->request)) != 0 ||\n\t    (r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\t/* check wheter agent is locked */\n\tif (locked && type != SSH_AGENTC_UNLOCK) {\n\t\tsshbuf_reset(e->request);\n\t\tswitch (type) {\n\t\tcase SSH_AGENTC_REQUEST_RSA_IDENTITIES:\n\t\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\t\t/* send empty lists */\n\t\t\tno_identities(e, type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* send a fail message for all other request types */\n\t\t\tsend_status(e, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tdebug(\"type %d\", type);\n\tswitch (type) {\n\tcase SSH_AGENTC_LOCK:\n\tcase SSH_AGENTC_UNLOCK:\n\t\tprocess_lock_agent(e, type == SSH_AGENTC_LOCK);\n\t\tbreak;\n#ifdef WITH_SSH1\n\t/* ssh1 */\n\tcase SSH_AGENTC_RSA_CHALLENGE:\n\t\tprocess_authentication_challenge1(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REQUEST_RSA_IDENTITIES:\n\t\tprocess_request_identities(e, 1);\n\t\tbreak;\n\tcase SSH_AGENTC_ADD_RSA_IDENTITY:\n\tcase SSH_AGENTC_ADD_RSA_ID_CONSTRAINED:\n\t\tprocess_add_identity(e, 1);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_RSA_IDENTITY:\n\t\tprocess_remove_identity(e, 1);\n\t\tbreak;\n#endif\n\tcase SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:\n\t\tprocess_remove_all_identities(e, 1); /* safe for !WITH_SSH1 */\n\t\tbreak;\n\t/* ssh2 */\n\tcase SSH2_AGENTC_SIGN_REQUEST:\n\t\tprocess_sign_request2(e);\n\t\tbreak;\n\tcase SSH2_AGENTC_REQUEST_IDENTITIES:\n\t\tprocess_request_identities(e, 2);\n\t\tbreak;\n\tcase SSH2_AGENTC_ADD_IDENTITY:\n\tcase SSH2_AGENTC_ADD_ID_CONSTRAINED:\n\t\tprocess_add_identity(e, 2);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_IDENTITY:\n\t\tprocess_remove_identity(e, 2);\n\t\tbreak;\n\tcase SSH2_AGENTC_REMOVE_ALL_IDENTITIES:\n\t\tprocess_remove_all_identities(e, 2);\n\t\tbreak;\n#ifdef ENABLE_PKCS11\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY:\n\tcase SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:\n\t\tprocess_add_smartcard_key(e);\n\t\tbreak;\n\tcase SSH_AGENTC_REMOVE_SMARTCARD_KEY:\n\t\tprocess_remove_smartcard_key(e);\n\t\tbreak;\n#endif /* ENABLE_PKCS11 */\n\tdefault:\n\t\t/* Unknown message.  Respond with failure. */\n\t\terror(\"Unknown message %d\", type);\n\t\tsshbuf_reset(e->request);\n\t\tsend_status(e, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void\nnew_socket(sock_type type, int fd)\n{\n\tu_int i, old_alloc, new_alloc;\n\n\tset_nonblock(fd);\n\n\tif (fd > max_fd)\n\t\tmax_fd = fd;\n\n\tfor (i = 0; i < sockets_alloc; i++)\n\t\tif (sockets[i].type == AUTH_UNUSED) {\n\t\t\tsockets[i].fd = fd;\n\t\t\tif ((sockets[i].input = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].output = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tif ((sockets[i].request = sshbuf_new()) == NULL)\n\t\t\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\t\t\tsockets[i].type = type;\n\t\t\treturn;\n\t\t}\n\told_alloc = sockets_alloc;\n\tnew_alloc = sockets_alloc + 10;\n\tsockets = xreallocarray(sockets, new_alloc, sizeof(sockets[0]));\n\tfor (i = old_alloc; i < new_alloc; i++)\n\t\tsockets[i].type = AUTH_UNUSED;\n\tsockets_alloc = new_alloc;\n\tsockets[old_alloc].fd = fd;\n\tif ((sockets[old_alloc].input = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].output = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tif ((sockets[old_alloc].request = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n\tsockets[old_alloc].type = type;\n}\n\nstatic int\nprepare_select(fd_set **fdrp, fd_set **fdwp, int *fdl, u_int *nallocp,\n    struct timeval **tvpp)\n{\n\tu_int i, sz;\n\tint n = 0;\n\tstatic struct timeval tv;\n\ttime_t deadline;\n\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tn = MAXIMUM(n, sockets[i].fd);\n\t\t\tbreak;\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown socket type %d\", sockets[i].type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsz = howmany(n+1, NFDBITS) * sizeof(fd_mask);\n\tif (*fdrp == NULL || sz > *nallocp) {\n\t\tfree(*fdrp);\n\t\tfree(*fdwp);\n\t\t*fdrp = xmalloc(sz);\n\t\t*fdwp = xmalloc(sz);\n\t\t*nallocp = sz;\n\t}\n\tif (n < *fdl)\n\t\tdebug(\"XXX shrink: %d < %d\", n, *fdl);\n\t*fdl = n;\n\tmemset(*fdrp, 0, sz);\n\tmemset(*fdwp, 0, sz);\n\n\tfor (i = 0; i < sockets_alloc; i++) {\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_SOCKET:\n\t\tcase AUTH_CONNECTION:\n\t\t\tFD_SET(sockets[i].fd, *fdrp);\n\t\t\tif (sshbuf_len(sockets[i].output) > 0)\n\t\t\t\tFD_SET(sockets[i].fd, *fdwp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tdeadline = reaper();\n\tif (parent_alive_interval != 0)\n\t\tdeadline = (deadline == 0) ? parent_alive_interval :\n\t\t    MINIMUM(deadline, parent_alive_interval);\n\tif (deadline == 0) {\n\t\t*tvpp = NULL;\n\t} else {\n\t\ttv.tv_sec = deadline;\n\t\ttv.tv_usec = 0;\n\t\t*tvpp = &tv;\n\t}\n\treturn (1);\n}\n\nstatic void\nafter_select(fd_set *readset, fd_set *writeset)\n{\n\tstruct sockaddr_un sunaddr;\n\tsocklen_t slen;\n\tchar buf[1024];\n\tint len, sock, r;\n\tu_int i, orig_alloc;\n\tuid_t euid;\n\tgid_t egid;\n\n\tfor (i = 0, orig_alloc = sockets_alloc; i < orig_alloc; i++)\n\t\tswitch (sockets[i].type) {\n\t\tcase AUTH_UNUSED:\n\t\t\tbreak;\n\t\tcase AUTH_SOCKET:\n\t\t\tif (FD_ISSET(sockets[i].fd, readset)) {\n\t\t\t\tslen = sizeof(sunaddr);\n\t\t\t\tsock = accept(sockets[i].fd,\n\t\t\t\t    (struct sockaddr *)&sunaddr, &slen);\n\t\t\t\tif (sock < 0) {\n\t\t\t\t\terror(\"accept from AUTH_SOCKET: %s\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (getpeereid(sock, &euid, &egid) < 0) {\n\t\t\t\t\terror(\"getpeereid %d failed: %s\",\n\t\t\t\t\t    sock, strerror(errno));\n\t\t\t\t\tclose(sock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((euid != 0) && (getuid() != euid)) {\n\t\t\t\t\terror(\"uid mismatch: \"\n\t\t\t\t\t    \"peer euid %u != uid %u\",\n\t\t\t\t\t    (u_int) euid, (u_int) getuid());\n\t\t\t\t\tclose(sock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew_socket(AUTH_CONNECTION, sock);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUTH_CONNECTION:\n\t\t\tif (sshbuf_len(sockets[i].output) > 0 &&\n\t\t\t    FD_ISSET(sockets[i].fd, writeset)) {\n\t\t\t\tlen = write(sockets[i].fd,\n\t\t\t\t    sshbuf_ptr(sockets[i].output),\n\t\t\t\t    sshbuf_len(sockets[i].output));\n\t\t\t\tif (len == -1 && (errno == EAGAIN ||\n\t\t\t\t    errno == EINTR))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (len <= 0) {\n\t\t\t\t\tclose_socket(&sockets[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((r = sshbuf_consume(sockets[i].output,\n\t\t\t\t    len)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t}\n\t\t\tif (FD_ISSET(sockets[i].fd, readset)) {\n\t\t\t\tlen = read(sockets[i].fd, buf, sizeof(buf));\n\t\t\t\tif (len == -1 && (errno == EAGAIN ||\n\t\t\t\t    errno == EINTR))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (len <= 0) {\n\t\t\t\t\tclose_socket(&sockets[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((r = sshbuf_put(sockets[i].input,\n\t\t\t\t    buf, len)) != 0)\n\t\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t\t    __func__, ssh_err(r));\n\t\t\t\texplicit_bzero(buf, sizeof(buf));\n\t\t\t\tprocess_message(&sockets[i]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfatal(\"Unknown type %d\", sockets[i].type);\n\t\t}\n}\n\nstatic void\ncleanup_socket(void)\n{\n\tif (cleanup_pid != 0 && getpid() != cleanup_pid)\n\t\treturn;\n\tdebug(\"%s: cleanup\", __func__);\n\tif (socket_name[0])\n\t\tunlink(socket_name);\n\tif (socket_dir[0])\n\t\trmdir(socket_dir);\n}\n\nvoid\ncleanup_exit(int i)\n{\n\tcleanup_socket();\n\t_exit(i);\n}\n\n/*ARGSUSED*/\nstatic void\ncleanup_handler(int sig)\n{\n\tcleanup_socket();\n#ifdef ENABLE_PKCS11\n\tpkcs11_terminate();\n#endif\n\t_exit(2);\n}\n\nstatic void\ncheck_parent_exists(void)\n{\n\t/*\n\t * If our parent has exited then getppid() will return (pid_t)1,\n\t * so testing for that should be safe.\n\t */\n\tif (parent_pid != -1 && getppid() != parent_pid) {\n\t\t/* printf(\"Parent has died - Authentication agent exiting.\\n\"); */\n\t\tcleanup_socket();\n\t\t_exit(2);\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}\n\nint\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, fd, ch, result, saved_errno;\n\tu_int nalloc;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tfd_set *readsetp = NULL, *writesetp = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tstruct timeval *tvp = NULL;\n\tsize_t len;\n\tmode_t prev_mask;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (pkcs11_whitelist != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tpkcs11_whitelist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (pkcs11_whitelist == NULL)\n\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t/* XXX might close listen socket */\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\tclose(fd);\n\t}\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) < 0) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tsignal(SIGHUP, cleanup_handler);\n\tsignal(SIGTERM, cleanup_handler);\n\tnalloc = 0;\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);\n\t\tresult = select(max_fd + 1, readsetp, writesetp, NULL, tvp);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result < 0) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"select: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_select(readsetp, writesetp);\n\t}\n\t/* NOTREACHED */\n}\n"], "filenames": ["usr.bin/ssh/ssh-agent.1", "usr.bin/ssh/ssh-agent.c"], "buggy_code_start_loc": [1, 1], "buggy_code_end_loc": [123, 1389], "fixing_code_start_loc": [1, 1], "fixing_code_end_loc": [137, 1416], "type": "CWE-426", "message": "Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.", "other": {"cve": {"id": "CVE-2016-10009", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-05T02:59:03.057", "lastModified": "2022-12-13T12:15:19.877", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket."}, {"lang": "es", "value": "Vulnerabilidad de ruta de b\u00fasqueda no confiable en ssh-agent.c en ssh-agent en OpenSSH en versiones anteriores a 7.4 permite a atacantes remotos ejecutar modulos locales PKCS#11 arbitrarios aprovechando el control sobre un agent-socket reenviado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-426"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.3", "matchCriteriaId": "B5D52975-3CB0-4BF7-975F-66EF9BF42A06"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/140261/OpenSSH-Arbitrary-Library-Loading.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/19/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes"]}, {"url": "http://www.securityfocus.com/bid/94968", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1037490", "source": "cve@mitre.org"}, {"url": "http://www.slackware.com/security/viewer.php?l=slackware-security&y=2016&m=slackware-security.647637", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2029", "source": "cve@mitre.org"}, {"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1009", "source": "cve@mitre.org"}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-412672.pdf", "source": "cve@mitre.org"}, {"url": "https://github.com/openbsd/src/commit/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/09/msg00010.html", "source": "cve@mitre.org"}, {"url": "https://security.FreeBSD.org/advisories/FreeBSD-SA-17:01.openssh.asc", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20171130-0002/", "source": "cve@mitre.org"}, {"url": "https://support.hpe.com/hpsc/doc/public/display?docLocale=en_US&docId=emr_na-hpesbux03818en_us", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3538-1/", "source": "cve@mitre.org"}, {"url": "https://www.exploit-db.com/exploits/40963/", "source": "cve@mitre.org"}, {"url": "https://www.openssh.com/txt/release-7.4", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/openbsd/src/commit/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5"}}