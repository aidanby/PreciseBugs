{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                  M   M   OOO   DDDD   U   U  L      EEEEE                   %\n%                  MM MM  O   O  D   D  U   U  L      E                       %\n%                  M M M  O   O  D   D  U   U  L      EEE                     %\n%                  M   M  O   O  D   D  U   U  L      E                       %\n%                  M   M   OOO   DDDD    UUU   LLLLL  EEEEE                   %\n%                                                                             %\n%                                                                             %\n%                          MagickCore Module Methods                          %\n%                                                                             %\n%                              Software Design                                %\n%                              Bob Friesenhahn                                %\n%                                March 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/coder.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/module-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_MODULES_SUPPORT)\n#if defined(MAGICKCORE_LTDL_DELEGATE)\n#include \"ltdl.h\"\ntypedef lt_dlhandle ModuleHandle;\n#else\ntypedef void *ModuleHandle;\n#endif\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_LTDL_DELEGATE)\n#  define ModuleGlobExpression \"*.la\"\n#else\n#  if defined(_DEBUG)\n#    define ModuleGlobExpression \"IM_MOD_DB_*.dll\"\n#  else\n#    define ModuleGlobExpression \"IM_MOD_RL_*.dll\"\n#  endif\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic SemaphoreInfo\n  *module_semaphore = (SemaphoreInfo *) NULL;\n\nstatic SplayTreeInfo\n  *module_list = (SplayTreeInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic const ModuleInfo\n  *RegisterModule(const ModuleInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  GetMagickModulePath(const char *,MagickModuleType,char *,ExceptionInfo *),\n  IsModuleTreeInstantiated(),\n  UnregisterModule(const ModuleInfo *,ExceptionInfo *);\n\nstatic void\n  TagToCoderModuleName(const char *,char *),\n  TagToFilterModuleName(const char *,char *),\n  TagToModuleName(const char *,const char *,char *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e M o d u l e I n f o                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireModuleInfo() allocates the ModuleInfo structure.\n%\n%  The format of the AcquireModuleInfo method is:\n%\n%      ModuleInfo *AcquireModuleInfo(const char *path,const char *tag)\n%\n%  A description of each parameter follows:\n%\n%    o path: the path associated with the tag.\n%\n%    o tag: a character string that represents the image format we are\n%      looking for.\n%\n*/\nMagickExport ModuleInfo *AcquireModuleInfo(const char *path,const char *tag)\n{\n  ModuleInfo\n    *module_info;\n\n  module_info=(ModuleInfo *) AcquireCriticalMemory(sizeof(*module_info));\n  (void) memset(module_info,0,sizeof(*module_info));\n  if (path != (const char *) NULL)\n    module_info->path=ConstantString(path);\n  if (tag != (const char *) NULL)\n    module_info->tag=ConstantString(tag);\n  module_info->timestamp=time(0);\n  module_info->signature=MagickCoreSignature;\n  return(module_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y M o d u l e L i s t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyModuleList() unregisters any previously loaded modules and exits\n%  the module loaded environment.\n%\n%  The format of the DestroyModuleList module is:\n%\n%      void DestroyModuleList(void)\n%\n*/\nMagickExport void DestroyModuleList(void)\n{\n  /*\n    Destroy magick modules.\n  */\n  LockSemaphoreInfo(module_semaphore);\n#if defined(MAGICKCORE_MODULES_SUPPORT)\n  if (module_list != (SplayTreeInfo *) NULL)\n    module_list=DestroySplayTree(module_list);\n#endif\n  UnlockSemaphoreInfo(module_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M o d u l e I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetModuleInfo() returns a pointer to a ModuleInfo structure that matches the\n%  specified tag.  If tag is NULL, the head of the module list is returned. If\n%  no modules are loaded, or the requested module is not found, NULL is\n%  returned.\n%\n%  The format of the GetModuleInfo module is:\n%\n%      ModuleInfo *GetModuleInfo(const char *tag,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o tag: a character string that represents the image format we are\n%      looking for.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ModuleInfo *GetModuleInfo(const char *tag,ExceptionInfo *exception)\n{\n  ModuleInfo\n    *module_info;\n\n  if (IsModuleTreeInstantiated() == MagickFalse)\n    return((ModuleInfo *) NULL);\n  LockSemaphoreInfo(module_semaphore);\n  ResetSplayTreeIterator(module_list);\n  if ((tag == (const char *) NULL) || (LocaleCompare(tag,\"*\") == 0))\n    {\n#if defined(MAGICKCORE_MODULES_SUPPORT)\n      if (LocaleCompare(tag,\"*\") == 0)\n        (void) OpenModules(exception);\n#endif\n      module_info=(ModuleInfo *) GetNextValueInSplayTree(module_list);\n      UnlockSemaphoreInfo(module_semaphore);\n      return(module_info);\n    }\n  module_info=(ModuleInfo *) GetValueFromSplayTree(module_list,tag);\n  UnlockSemaphoreInfo(module_semaphore);\n  return(module_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M o d u l e I n f o L i s t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetModuleInfoList() returns any modules that match the specified pattern.\n%\n%  The format of the GetModuleInfoList function is:\n%\n%      const ModuleInfo **GetModuleInfoList(const char *pattern,\n%        size_t *number_modules,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o pattern: Specifies a pointer to a text string containing a pattern.\n%\n%    o number_modules:  This integer returns the number of modules in the list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int ModuleInfoCompare(const void *x,const void *y)\n{\n  const ModuleInfo\n    **p,\n    **q;\n\n  p=(const ModuleInfo **) x,\n  q=(const ModuleInfo **) y;\n  if (LocaleCompare((*p)->path,(*q)->path) == 0)\n    return(LocaleCompare((*p)->tag,(*q)->tag));\n  return(LocaleCompare((*p)->path,(*q)->path));\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport const ModuleInfo **GetModuleInfoList(const char *pattern,\n  size_t *number_modules,ExceptionInfo *exception)\n{\n  const ModuleInfo\n    **modules;\n\n  const ModuleInfo\n    *p;\n\n  ssize_t\n    i;\n\n  /*\n    Allocate module list.\n  */\n  assert(pattern != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",pattern);\n  assert(number_modules != (size_t *) NULL);\n  *number_modules=0;\n  p=GetModuleInfo(\"*\",exception);\n  if (p == (const ModuleInfo *) NULL)\n    return((const ModuleInfo **) NULL);\n  modules=(const ModuleInfo **) AcquireQuantumMemory((size_t)\n    GetNumberOfNodesInSplayTree(module_list)+1UL,sizeof(*modules));\n  if (modules == (const ModuleInfo **) NULL)\n    return((const ModuleInfo **) NULL);\n  /*\n    Generate module list.\n  */\n  LockSemaphoreInfo(module_semaphore);\n  ResetSplayTreeIterator(module_list);\n  p=(const ModuleInfo *) GetNextValueInSplayTree(module_list);\n  for (i=0; p != (const ModuleInfo *) NULL; )\n  {\n    if ((p->stealth == MagickFalse) &&\n        (GlobExpression(p->tag,pattern,MagickFalse) != MagickFalse))\n      modules[i++]=p;\n    p=(const ModuleInfo *) GetNextValueInSplayTree(module_list);\n  }\n  UnlockSemaphoreInfo(module_semaphore);\n  qsort((void *) modules,(size_t) i,sizeof(*modules),ModuleInfoCompare);\n  modules[i]=(ModuleInfo *) NULL;\n  *number_modules=(size_t) i;\n  return(modules);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M o d u l e L i s t                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetModuleList() returns any image format modules that match the specified\n%  pattern.\n%\n%  The format of the GetModuleList function is:\n%\n%      char **GetModuleList(const char *pattern,const MagickModuleType type,\n%        size_t *number_modules,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o pattern: Specifies a pointer to a text string containing a pattern.\n%\n%    o type: choose from MagickImageCoderModule or MagickImageFilterModule.\n%\n%    o number_modules:  This integer returns the number of modules in the\n%      list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int ModuleCompare(const void *x,const void *y)\n{\n  const char\n    **p,\n    **q;\n\n  p=(const char **) x;\n  q=(const char **) y;\n  return(LocaleCompare(*p,*q));\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport char **GetModuleList(const char *pattern,\n  const MagickModuleType type,size_t *number_modules,ExceptionInfo *exception)\n{\n#define MaxModules  511\n\n  char\n    **modules,\n    filename[MagickPathExtent],\n    module_path[MagickPathExtent],\n    path[MagickPathExtent];\n\n  DIR\n    *directory;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  size_t\n    max_entries;\n\n  struct dirent\n    *buffer,\n    *entry;\n\n  /*\n    Locate all modules in the image coder or filter path.\n  */\n  switch (type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      TagToCoderModuleName(\"magick\",filename);\n      status=GetMagickModulePath(filename,MagickImageCoderModule,module_path,\n        exception);\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      TagToFilterModuleName(\"analyze\",filename);\n      status=GetMagickModulePath(filename,MagickImageFilterModule,module_path,\n        exception);\n      break;\n    }\n  }\n  if (status == MagickFalse)\n    return((char **) NULL);\n  GetPathComponent(module_path,HeadPath,path);\n  max_entries=MaxModules;\n  modules=(char **) AcquireQuantumMemory((size_t) max_entries+1UL,\n    sizeof(*modules));\n  if (modules == (char **) NULL)\n    return((char **) NULL);\n  *modules=(char *) NULL;\n  directory=opendir(path);\n  if (directory == (DIR *) NULL)\n    {\n      modules=(char **) RelinquishMagickMemory(modules);\n      return((char **) NULL);\n    }\n  buffer=(struct dirent *) AcquireMagickMemory(sizeof(*buffer)+FILENAME_MAX+1);\n  if (buffer == (struct dirent *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  i=0;\n  while ((MagickReadDirectory(directory,buffer,&entry) == 0) &&\n         (entry != (struct dirent *) NULL))\n  {\n    status=GlobExpression(entry->d_name,ModuleGlobExpression,MagickFalse);\n    if (status == MagickFalse)\n      continue;\n    if (GlobExpression(entry->d_name,pattern,MagickFalse) == MagickFalse)\n      continue;\n    if (i >= (ssize_t) max_entries)\n      {\n        modules=(char **) NULL;\n        if (~max_entries > max_entries)\n          modules=(char **) ResizeQuantumMemory(modules,(size_t)\n            (max_entries << 1),sizeof(*modules));\n        max_entries<<=1;\n        if (modules == (char **) NULL)\n          break;\n      }\n    /*\n      Add new module name to list.\n    */\n    modules[i]=AcquireString((char *) NULL);\n    GetPathComponent(entry->d_name,BasePath,modules[i]);\n    if (LocaleNCompare(\"IM_MOD_\",modules[i],7) == 0)\n      {\n        (void) CopyMagickString(modules[i],modules[i]+10,MagickPathExtent);\n        modules[i][strlen(modules[i])-1]='\\0';\n      }\n    i++;\n  }\n  buffer=(struct dirent *) RelinquishMagickMemory(buffer);\n  (void) closedir(directory);\n  if (modules == (char **) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n        \"MemoryAllocationFailed\",\"`%s'\",pattern);\n      return((char **) NULL);\n    }\n  qsort((void *) modules,(size_t) i,sizeof(*modules),ModuleCompare);\n  modules[i]=(char *) NULL;\n  *number_modules=(size_t) i;\n  return(modules);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t M a g i c k M o d u l e P a t h                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickModulePath() finds a module with the specified module type and\n%  filename.\n%\n%  The format of the GetMagickModulePath module is:\n%\n%      MagickBooleanType GetMagickModulePath(const char *filename,\n%        MagickModuleType module_type,char *path,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o filename: the module file name.\n%\n%    o module_type: the module type: MagickImageCoderModule or\n%      MagickImageFilterModule.\n%\n%    o path: the path associated with the filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetMagickModulePath(const char *filename,\n  MagickModuleType module_type,char *path,ExceptionInfo *exception)\n{\n  char\n    *module_path;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(path != (char *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (strchr(filename,'/') != (char *) NULL)\n    return(MagickFalse);\n  (void) CopyMagickString(path,filename,MagickPathExtent);\n  module_path=(char *) NULL;\n  switch (module_type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for coder module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");\n#if defined(MAGICKCORE_CODER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_CODER_PATH);\n#endif\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for filter module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");\n#if defined(MAGICKCORE_FILTER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_FILTER_PATH);\n#endif\n      break;\n    }\n  }\n  if (module_path != (char *) NULL)\n    {\n      char\n        *p,\n        *q;\n\n      for (p=module_path-1; p != (char *) NULL; )\n      {\n        (void) CopyMagickString(path,p+1,MagickPathExtent);\n        q=strchr(path,DirectoryListSeparator);\n        if (q != (char *) NULL)\n          *q='\\0';\n        q=path+strlen(path)-1;\n        if ((q >= path) && (*q != *DirectorySeparator))\n          (void) ConcatenateMagickString(path,DirectorySeparator,\n            MagickPathExtent);\n        (void) ConcatenateMagickString(path,filename,MagickPathExtent);\n#if defined(MAGICKCORE_HAVE_REALPATH)\n        {\n          char\n            resolved_path[PATH_MAX+1];\n\n          if (realpath(path,resolved_path) != (char *) NULL)\n            (void) CopyMagickString(path,resolved_path,MagickPathExtent);\n        }\n#endif\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            module_path=DestroyString(module_path);\n            return(MagickTrue);\n          }\n        p=strchr(p+1,DirectoryListSeparator);\n      }\n      module_path=DestroyString(module_path);\n    }\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  else\n#if defined(MAGICKCORE_CODER_PATH)\n    {\n      const char\n        *directory;\n\n      /*\n        Search hard coded paths.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=MAGICKCORE_CODER_PATH;\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=MAGICKCORE_FILTER_PATH;\n          break;\n        }\n      }\n      (void) FormatLocaleString(path,MagickPathExtent,\"%s%s\",directory,\n        filename);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    {\n      const char\n        *registery_key;\n\n      unsigned char\n        *key_value;\n\n      /*\n        Locate path via registry key.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          registery_key=\"CoderModulesPath\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          registery_key=\"FilterModulesPath\";\n          break;\n        }\n      }\n      key_value=NTRegistryKeyLookup(registery_key);\n      if (key_value == (unsigned char *) NULL)\n        {\n          ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n            \"RegistryKeyLookupFailed\",\"`%s'\",registery_key);\n          return(MagickFalse);\n        }\n      (void) FormatLocaleString(path,MagickPathExtent,\"%s%s%s\",(char *)\n        key_value,DirectorySeparator,filename);\n      key_value=(unsigned char *) RelinquishMagickMemory(key_value);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#endif\n#endif\n#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)\n# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined\n#endif\n#else\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"MAGICK_HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search MAGICK_HOME.\n        */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%s%s\",home,\n          DirectorySeparator,filename);\n#else\n        const char\n          *directory;\n\n        switch (module_type)\n        {\n          case MagickImageCoderModule:\n          default:\n          {\n            directory=MAGICKCORE_CODER_RELATIVE_PATH;\n            break;\n          }\n          case MagickImageFilterModule:\n          {\n            directory=MAGICKCORE_FILTER_RELATIVE_PATH;\n            break;\n          }\n        }\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s/lib/%s/%s\",home,\n          directory,filename);\n#endif\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  if (*GetClientPath() != '\\0')\n    {\n      /*\n        Search based on executable directory.\n      */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n      (void) FormatLocaleString(path,MagickPathExtent,\"%s%s%s\",GetClientPath(),\n        DirectorySeparator,filename);\n#else\n      char\n        prefix[MagickPathExtent];\n\n      const char\n        *directory;\n\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=\"coders\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=\"filters\";\n          break;\n        }\n      }\n      (void) CopyMagickString(prefix,GetClientPath(),MagickPathExtent);\n      ChopPathComponents(prefix,1);\n      (void) FormatLocaleString(path,MagickPathExtent,\"%s/lib/%s/%s/%s\",prefix,\n        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);\n#endif\n      if (IsPathAccessible(path) != MagickFalse)\n        return(MagickTrue);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    /*\n      Search module path.\n    */\n    if ((NTGetModulePath(\"CORE_RL_MagickCore_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"CORE_DB_MagickCore_.dll\",path) != MagickFalse))\n      {\n        (void) ConcatenateMagickString(path,DirectorySeparator,\n          MagickPathExtent);\n        (void) ConcatenateMagickString(path,filename,MagickPathExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n#endif\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"XDG_CONFIG_HOME\");\n    if (home == (char *) NULL)\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__MINGW32__)\n      home=GetEnvironmentValue(\"LOCALAPPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"APPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"USERPROFILE\");\n#endif\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $XDG_CONFIG_HOME/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%sImageMagick%s%s\",\n          home,DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n    home=GetEnvironmentValue(\"HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $HOME/.config/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MagickPathExtent,\n          \"%s%s.config%sImageMagick%s%s\",home,DirectorySeparator,\n          DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  /*\n    Search current directory.\n  */\n  if (IsPathAccessible(path) != MagickFalse)\n    return(MagickTrue);\n  if (exception->severity < ConfigureError)\n    ThrowFileException(exception,ConfigureWarning,\"UnableToOpenModuleFile\",\n      path);\n#endif\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M o d u l e T r e e I n s t a n t i a t e d                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsModuleTreeInstantiated() determines if the module tree is instantiated.\n%  If not, it instantiates the tree and returns it.\n%\n%  The format of the IsModuleTreeInstantiated() method is:\n%\n%      IsModuleTreeInstantiated()\n%\n*/\n\nstatic void *DestroyModuleNode(void *module_info)\n{\n  ExceptionInfo\n    *exception;\n\n  ModuleInfo\n    *p;\n\n  exception=AcquireExceptionInfo();\n  p=(ModuleInfo *) module_info;\n  if (UnregisterModule(p,exception) == MagickFalse)\n    CatchException(exception);\n  if (p->tag != (char *) NULL)\n    p->tag=DestroyString(p->tag);\n  if (p->path != (char *) NULL)\n    p->path=DestroyString(p->path);\n  exception=DestroyExceptionInfo(exception);\n  return(RelinquishMagickMemory(p));\n}\n\nstatic MagickBooleanType IsModuleTreeInstantiated()\n{\n  if (module_list == (SplayTreeInfo *) NULL)\n    {\n      if (module_semaphore == (SemaphoreInfo *) NULL)\n        ActivateSemaphoreInfo(&module_semaphore);\n      LockSemaphoreInfo(module_semaphore);\n      if (module_list == (SplayTreeInfo *) NULL)\n        {\n          MagickBooleanType\n            status;\n\n          ModuleInfo\n            *module_info;\n\n          SplayTreeInfo\n            *splay_tree;\n\n          splay_tree=NewSplayTree(CompareSplayTreeString,\n            (void *(*)(void *)) NULL,DestroyModuleNode);\n          module_info=AcquireModuleInfo((const char *) NULL,\"[boot-strap]\");\n          module_info->stealth=MagickTrue;\n          status=AddValueToSplayTree(splay_tree,module_info->tag,module_info);\n          if (status == MagickFalse)\n            ThrowFatalException(ResourceLimitFatalError,\n              \"MemoryAllocationFailed\");\n          if (lt_dlinit() != 0)\n            ThrowFatalException(ModuleFatalError,\n              \"UnableToInitializeModuleLoader\");\n          module_list=splay_tree;\n        }\n      UnlockSemaphoreInfo(module_semaphore);\n    }\n  return(module_list != (SplayTreeInfo *) NULL ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n v o k e D y n a m i c I m a g e F i l t e r                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InvokeDynamicImageFilter() invokes a dynamic image filter.\n%\n%  The format of the InvokeDynamicImageFilter module is:\n%\n%      MagickBooleanType InvokeDynamicImageFilter(const char *tag,Image **image,\n%        const int argc,const char **argv,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o tag: a character string that represents the name of the particular\n%      module.\n%\n%    o image: the image.\n%\n%    o argc: a pointer to an integer describing the number of elements in the\n%      argument vector.\n%\n%    o argv: a pointer to a text array containing the command line arguments.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType InvokeDynamicImageFilter(const char *tag,\n  Image **images,const int argc,const char **argv,ExceptionInfo *exception)\n{\n  char\n    name[MagickPathExtent],\n    path[MagickPathExtent];\n\n  ImageFilterHandler\n    *image_filter;\n\n  MagickBooleanType\n    status;\n\n  ModuleHandle\n    handle;\n\n  PolicyRights\n    rights;\n\n  /*\n    Find the module.\n  */\n  assert(images != (Image **) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(FilterPolicyDomain,rights,tag) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",tag);\n      return(MagickFalse);\n    }\n#if !defined(MAGICKCORE_BUILD_MODULES)\n  {\n    MagickBooleanType\n      status;\n\n    status=InvokeStaticImageFilter(tag,images,argc,argv,exception);\n    if (status != MagickFalse)\n      return(status);\n  }\n#endif\n  TagToFilterModuleName(tag,name);\n  status=GetMagickModulePath(name,MagickImageFilterModule,path,exception);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"'%s': %s\",name,path);\n      return(MagickFalse);\n    }\n  /*\n    Open the module.\n  */\n  handle=(ModuleHandle) lt_dlopen(path);\n  if (handle == (ModuleHandle) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"'%s': %s\",name,lt_dlerror());\n      return(MagickFalse);\n    }\n  /*\n    Locate the module.\n  */\n#if !defined(MAGICKCORE_NAMESPACE_PREFIX)\n  (void) FormatLocaleString(name,MagickPathExtent,\"%sImage\",tag);\n#else\n  (void) FormatLocaleString(name,MagickPathExtent,\"%s%sImage\",\n    MAGICKCORE_NAMESPACE_PREFIX_TAG,tag);\n#endif\n  /*\n    Execute the module.\n  */\n  ClearMagickException(exception);\n  image_filter=(ImageFilterHandler *) lt_dlsym(handle,name);\n  if (image_filter == (ImageFilterHandler *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n      \"UnableToLoadModule\",\"'%s': %s\",name,lt_dlerror());\n  else\n    {\n      size_t\n        signature;\n\n      if ((*images)->debug != MagickFalse)\n        (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n          \"Invoking \\\"%s\\\" dynamic image filter\",tag);\n      signature=image_filter(images,argc,argv,exception);\n      if ((*images)->debug != MagickFalse)\n        (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\"\\\"%s\\\" completes\",\n          tag);\n      if (signature != MagickImageFilterSignature)\n        (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n          \"ImageFilterSignatureMismatch\",\"'%s': %8lx != %8lx\",tag,\n          (unsigned long) signature,(unsigned long) MagickImageFilterSignature);\n    }\n  /*\n    Close the module.\n  */\n  if (lt_dlclose(handle) != 0)\n    (void) ThrowMagickException(exception,GetMagickModule(),ModuleWarning,\n      \"UnableToCloseModule\",\"'%s': %s\",name,lt_dlerror());\n  return(exception->severity < ErrorException ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  L i s t M o d u l e I n f o                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListModuleInfo() lists the module info to a file.\n%\n%  The format of the ListModuleInfo module is:\n%\n%      MagickBooleanType ListModuleInfo(FILE *file,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to a FILE.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ListModuleInfo(FILE *file,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    module_path[MagickPathExtent],\n    **modules,\n    path[MagickPathExtent];\n\n  ssize_t\n    i;\n\n  size_t\n    number_modules;\n\n  if (file == (const FILE *) NULL)\n    file=stdout;\n  /*\n    List image coders.\n  */\n  modules=GetModuleList(\"*\",MagickImageCoderModule,&number_modules,exception);\n  if (modules == (char **) NULL)\n    return(MagickFalse);\n  TagToCoderModuleName(\"magick\",filename);\n  (void) GetMagickModulePath(filename,MagickImageCoderModule,module_path,\n    exception);\n  GetPathComponent(module_path,HeadPath,path);\n  (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",path);\n  (void) FormatLocaleFile(file,\"Image Coder\\n\");\n  (void) FormatLocaleFile(file,\n    \"-------------------------------------------------\"\n    \"------------------------------\\n\");\n  for (i=0; i < (ssize_t) number_modules; i++)\n  {\n    (void) FormatLocaleFile(file,\"%s\",modules[i]);\n    (void) FormatLocaleFile(file,\"\\n\");\n  }\n  (void) fflush(file);\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (ssize_t) number_modules; i++)\n    modules[i]=DestroyString(modules[i]);\n  modules=(char **) RelinquishMagickMemory(modules);\n  /*\n    List image filters.\n  */\n  modules=GetModuleList(\"*\",MagickImageFilterModule,&number_modules,exception);\n  if (modules == (char **) NULL)\n    return(MagickFalse);\n  TagToFilterModuleName(\"analyze\",filename);\n  (void) GetMagickModulePath(filename,MagickImageFilterModule,module_path,\n    exception);\n  GetPathComponent(module_path,HeadPath,path);\n  (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",path);\n  (void) FormatLocaleFile(file,\"Image Filter\\n\");\n  (void) FormatLocaleFile(file,\n    \"-------------------------------------------------\"\n    \"------------------------------\\n\");\n  for (i=0; i < (ssize_t) number_modules; i++)\n  {\n    (void) FormatLocaleFile(file,\"%s\",modules[i]);\n    (void) FormatLocaleFile(file,\"\\n\");\n  }\n  (void) fflush(file);\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (ssize_t) number_modules; i++)\n    modules[i]=DestroyString(modules[i]);\n  modules=(char **) RelinquishMagickMemory(modules);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M o d u l e C o m p o n e n t G e n e s i s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ModuleComponentGenesis() instantiates the module component.\n%\n%  The format of the ModuleComponentGenesis method is:\n%\n%      MagickBooleanType ModuleComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType ModuleComponentGenesis(void)\n{\n  MagickBooleanType\n    status;\n\n  if (module_semaphore == (SemaphoreInfo *) NULL)\n    module_semaphore=AcquireSemaphoreInfo();\n  status=IsModuleTreeInstantiated();\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M o d u l e C o m p o n e n t T e r m i n u s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ModuleComponentTerminus() destroys the module component.\n%\n%  The format of the ModuleComponentTerminus method is:\n%\n%      ModuleComponentTerminus(void)\n%\n*/\nMagickPrivate void ModuleComponentTerminus(void)\n{\n  if (module_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&module_semaphore);\n  DestroyModuleList();\n  RelinquishSemaphoreInfo(&module_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   O p e n M o d u l e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenModule() loads a module, and invokes its registration module.  It\n%  returns MagickTrue on success, and MagickFalse if there is an error.\n%\n%  The format of the OpenModule module is:\n%\n%      MagickBooleanType OpenModule(const char *module,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o module: a character string that indicates the module to load.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType OpenModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent],\n    name[MagickPathExtent],\n    path[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  ModuleHandle\n    handle;\n\n  ModuleInfo\n    *module_info;\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    signature;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  module_info=(ModuleInfo *) GetModuleInfo(module,exception);\n  if (module_info != (ModuleInfo *) NULL)\n    return(MagickTrue);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=AllPolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  if (GetValueFromSplayTree(module_list,module_name) != (void *) NULL)\n    return(MagickTrue);  /* module already opened, return */\n  /*\n    Locate module.\n  */\n  handle=(ModuleHandle) NULL;\n  TagToCoderModuleName(module_name,name);\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Searching for module \\\"%s\\\" using filename \\\"%s\\\"\",module_name,name);\n  *path='\\0';\n  status=GetMagickModulePath(name,MagickImageCoderModule,path,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n    Load module\n  */\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Opening module at path \\\"%s\\\"\",path);\n  handle=(ModuleHandle) lt_dlopen(path);\n  if (handle == (ModuleHandle) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"'%s': %s\",path,lt_dlerror());\n      return(MagickFalse);\n    }\n  /*\n    Register module.\n  */\n  module_info=AcquireModuleInfo(path,module_name);\n  module_info->handle=handle;\n  if (RegisterModule(module_info,exception) == (ModuleInfo *) NULL)\n    return(MagickFalse);\n  /*\n    Define RegisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Register%sImage\",name);\n  module_info->register_module=(size_t (*)(void)) lt_dlsym(handle,name);\n  if (module_info->register_module == (size_t (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->register_module);\n  /*\n    Define UnregisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Unregister%sImage\",name);\n  module_info->unregister_module=(void (*)(void)) lt_dlsym(handle,name);\n  if (module_info->unregister_module == (void (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->unregister_module);\n  signature=module_info->register_module();\n  if (signature != MagickImageCoderSignature)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"ImageCoderSignatureMismatch\",\"'%s': %8lx != %8lx\",module_name,\n        (unsigned long) signature,(unsigned long) MagickImageCoderSignature);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   O p e n M o d u l e s                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenModules() loads all available modules.\n%\n%  The format of the OpenModules module is:\n%\n%      MagickBooleanType OpenModules(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType OpenModules(ExceptionInfo *exception)\n{\n  char\n    **modules;\n\n  ssize_t\n    i;\n\n  size_t\n    number_modules;\n\n  /*\n    Load all modules.\n  */\n  (void) GetMagickInfo((char *) NULL,exception);\n  number_modules=0;\n  modules=GetModuleList(\"*\",MagickImageCoderModule,&number_modules,exception);\n  if ((modules == (char **) NULL) || (*modules == (char *) NULL))\n    {\n      if (modules != (char **) NULL)\n        modules=(char **) RelinquishMagickMemory(modules);\n      return(MagickFalse);\n    }\n  for (i=0; i < (ssize_t) number_modules; i++)\n    (void) OpenModule(modules[i],exception);\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (ssize_t) number_modules; i++)\n    modules[i]=DestroyString(modules[i]);\n  modules=(char **) RelinquishMagickMemory(modules);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M o d u l e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterModule() adds an entry to the module list.  It returns a pointer to\n%  the registered entry on success.\n%\n%  The format of the RegisterModule module is:\n%\n%      ModuleInfo *RegisterModule(const ModuleInfo *module_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o info: a pointer to the registered entry is returned.\n%\n%    o module_info: a pointer to the ModuleInfo structure to register.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const ModuleInfo *RegisterModule(const ModuleInfo *module_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  assert(module_info != (ModuleInfo *) NULL);\n  assert(module_info->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",module_info->tag);\n  if (module_list == (SplayTreeInfo *) NULL)\n    return((const ModuleInfo *) NULL);\n  status=AddValueToSplayTree(module_list,module_info->tag,module_info);\n  if (status == MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n      \"MemoryAllocationFailed\",\"`%s'\",module_info->tag);\n  return(module_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  T a g T o C o d e r M o d u l e N a m e                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TagToCoderModuleName() munges a module tag and obtains the filename of the\n%  corresponding module.\n%\n%  The format of the TagToCoderModuleName module is:\n%\n%      char *TagToCoderModuleName(const char *tag,char *name)\n%\n%  A description of each parameter follows:\n%\n%    o tag: a character string representing the module tag.\n%\n%    o name: return the module name here.\n%\n*/\nstatic void TagToCoderModuleName(const char *tag,char *name)\n{\n  assert(tag != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",tag);\n  assert(name != (char *) NULL);\n#if defined(MAGICKCORE_LTDL_DELEGATE)\n  (void) FormatLocaleString(name,MagickPathExtent,\"%s.la\",tag);\n  (void) LocaleLower(name);\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  if (LocaleNCompare(\"IM_MOD_\",tag,7) == 0)\n    (void) CopyMagickString(name,tag,MagickPathExtent);\n  else\n    {\n#if defined(_DEBUG)\n      (void) FormatLocaleString(name,MagickPathExtent,\"IM_MOD_DB_%s_.dll\",tag);\n#else\n      (void) FormatLocaleString(name,MagickPathExtent,\"IM_MOD_RL_%s_.dll\",tag);\n#endif\n    }\n#endif\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  T a g T o F i l t e r M o d u l e N a m e                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TagToFilterModuleName() munges a module tag and returns the filename of the\n%  corresponding filter module.\n%\n%  The format of the TagToFilterModuleName module is:\n%\n%      void TagToFilterModuleName(const char *tag,char name)\n%\n%  A description of each parameter follows:\n%\n%    o tag: a character string representing the module tag.\n%\n%    o name: return the filter name here.\n%\n*/\nstatic void TagToFilterModuleName(const char *tag,char *name)\n{\n  assert(tag != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",tag);\n  assert(name != (char *) NULL);\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  (void) FormatLocaleString(name,MagickPathExtent,\"FILTER_%s_.dll\",tag);\n#elif !defined(MAGICKCORE_LTDL_DELEGATE)\n  (void) FormatLocaleString(name,MagickPathExtent,\"%s.dll\",tag);\n#else\n  (void) FormatLocaleString(name,MagickPathExtent,\"%s.la\",tag);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T a g T o M o d u l e N a m e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TagToModuleName() munges the module tag name and returns an upper-case tag\n%  name as the input string, and a user-provided format.\n%\n%  The format of the TagToModuleName module is:\n%\n%      TagToModuleName(const char *tag,const char *format,char *module)\n%\n%  A description of each parameter follows:\n%\n%    o tag: the module tag.\n%\n%    o format: a sprintf-compatible format string containing %s where the\n%      upper-case tag name is to be inserted.\n%\n%    o module: pointer to a destination buffer for the formatted result.\n%\n*/\nstatic void TagToModuleName(const char *tag,const char *format,char *module)\n{\n  char\n    name[MagickPathExtent];\n\n  assert(tag != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",tag);\n  assert(format != (const char *) NULL);\n  assert(module != (char *) NULL);\n  (void) CopyMagickString(name,tag,MagickPathExtent);\n  LocaleUpper(name);\n#if !defined(MAGICKCORE_NAMESPACE_PREFIX)\n  (void) FormatLocaleString(module,MagickPathExtent,format,name);\n#else\n  {\n    char\n      prefix_format[MagickPathExtent];\n\n    (void) FormatLocaleString(prefix_format,MagickPathExtent,\"%s%s\",\n      MAGICKCORE_NAMESPACE_PREFIX_TAG,format);\n    (void) FormatLocaleString(module,MagickPathExtent,prefix_format,name);\n  }\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M o d u l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterModule() unloads a module, and invokes its de-registration module.\n%  Returns MagickTrue on success, and MagickFalse if there is an error.\n%\n%  The format of the UnregisterModule module is:\n%\n%      MagickBooleanType UnregisterModule(const ModuleInfo *module_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o module_info: the module info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType UnregisterModule(const ModuleInfo *module_info,\n  ExceptionInfo *exception)\n{\n  /*\n    Locate and execute UnregisterFORMATImage module.\n  */\n  assert(module_info != (const ModuleInfo *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",module_info->tag);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (module_info->unregister_module == NULL)\n    return(MagickTrue);\n  module_info->unregister_module();\n  if (lt_dlclose((ModuleHandle) module_info->handle) != 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleWarning,\n        \"UnableToCloseModule\",\"'%s': %s\",module_info->tag,lt_dlerror());\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n#else\n\n#if !defined(MAGICKCORE_BUILD_MODULES)\nextern size_t\n  analyzeImage(Image **,const int,const char **,ExceptionInfo *);\n#endif\n\nMagickExport MagickBooleanType ListModuleInfo(FILE *magick_unused(file),\n  ExceptionInfo *magick_unused(exception))\n{\n  return(MagickTrue);\n}\n\nMagickExport MagickBooleanType InvokeDynamicImageFilter(const char *tag,\n  Image **image,const int argc,const char **argv,ExceptionInfo *exception)\n{\n  PolicyRights\n    rights;\n\n  assert(image != (Image **) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(FilterPolicyDomain,rights,tag) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",tag);\n      return(MagickFalse);\n    }\n#if defined(MAGICKCORE_BUILD_MODULES)\n  (void) tag;\n  (void) argc;\n  (void) argv;\n  (void) exception;\n#else\n  {\n    ImageFilterHandler\n      *image_filter;\n\n    image_filter=(ImageFilterHandler *) NULL;\n    if (LocaleCompare(\"analyze\",tag) == 0)\n      image_filter=(ImageFilterHandler *) analyzeImage;\n    if (image_filter == (ImageFilterHandler *) NULL)\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"`%s'\",tag);\n    else\n      {\n        size_t\n          signature;\n\n        if ((*image)->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Invoking \\\"%s\\\" static image filter\",tag);\n        signature=image_filter(image,argc,argv,exception);\n        if ((*image)->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\\\"%s\\\" completes\",\n            tag);\n        if (signature != MagickImageFilterSignature)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n              \"ImageFilterSignatureMismatch\",\"'%s': %8lx != %8lx\",tag,\n              (unsigned long) signature,(unsigned long)\n              MagickImageFilterSignature);\n            return(MagickFalse);\n          }\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                  SSSSS  TTTTT   AAA   TTTTT  IIIII   CCCC                   %\n%                  SS       T    A   A    T      I    C                       %\n%                   SSS     T    AAAAA    T      I    C                       %\n%                     SS    T    A   A    T      I    C                       %\n%                  SSSSS    T    A   A    T    IIIII   CCCC                   %\n%                                                                             %\n%                                                                             %\n%                          MagickCore Static Methods                          %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/coder.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"coders/coders.h\"\n\f\n/*\n  Define declarations.\n*/\n#define AddMagickCoder(coder)  { #coder, MagickFalse, \\\n  Register ## coder ## Image, Unregister ## coder ## Image },\n\f\n/*\n  ImageMagick module stub.\n*/\nModuleExport size_t RegisterUndefinedImage(void)\n{\n  return(MagickImageCoderSignature);\n}\n\nModuleExport void UnregisterUndefinedImage(void)\n{\n}\n\f\n/*\n  ImageMagick modules.\n*/\nstatic struct\n{\n  const char\n    *module;\n\n  MagickBooleanType\n    registered;\n\n  size_t\n    (*register_module)(void);\n\n  void\n    (*unregister_module)(void);\n} MagickModules[] = {\n#if !defined(MAGICKCORE_BUILD_MODULES)\n  #include \"coders/coders-list.h\"\n#endif\n  { (const char *) NULL, MagickFalse, RegisterUndefinedImage, UnregisterUndefinedImage }\n};\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n v o k e S t a t i c I m a g e F i l t e r                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InvokeStaticImageFilter() invokes a static image filter.\n%\n%  The format of the InvokeStaticImageFilter method is:\n%\n%      MagickBooleanType InvokeStaticImageFilter(const char *tag,Image **image,\n%        const int argc,const char **argv)\n%\n%  A description of each parameter follows:\n%\n%    o tag: the module tag.\n%\n%    o image: the image.\n%\n%    o argc: the number of elements in the argument vector.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n#if defined(MAGICKCORE_MODULES_SUPPORT)\nMagickExport MagickBooleanType InvokeStaticImageFilter(const char *tag,\n  Image **image,const int argc,const char **argv,ExceptionInfo *exception)\n{\n  PolicyRights\n    rights;\n\n  assert(image != (Image **) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(FilterPolicyDomain,rights,tag) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",tag);\n      return(MagickFalse);\n    }\n#if defined(MAGICKCORE_MODULES_SUPPORT)\n  (void) tag;\n  (void) argc;\n  (void) argv;\n  (void) exception;\n#else\n  {\n    extern size_t\n      analyzeImage(Image **,const int,char **,ExceptionInfo *);\n\n    ImageFilterHandler\n      *image_filter;\n\n    image_filter=(ImageFilterHandler *) NULL;\n    if (LocaleCompare(\"analyze\",tag) == 0)\n      image_filter=(ImageFilterHandler *) analyzeImage;\n    if (image_filter == (ImageFilterHandler *) NULL)\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"`%s'\",tag);\n    else\n      {\n        size_t\n          signature;\n\n        if ((*image)->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Invoking \\\"%s\\\" static image filter\",tag);\n        signature=image_filter(image,argc,argv,exception);\n        if ((*image)->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\\\"%s\\\" completes\",\n            tag);\n        if (signature != MagickImageFilterSignature)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n              \"ImageFilterSignatureMismatch\",\"'%s': %8lx != %8lx\",tag,\n              (unsigned long) signature,(unsigned long)\n              MagickImageFilterSignature);\n            return(MagickFalse);\n          }\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S t a t i c M o d u l e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterStaticModule() statically registers a module.\n%\n%  The format of the RegisterStaticModule method is:\n%\n%      MagickBooleanType RegisterStaticModule(const char module,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o module: the want to register.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=AllPolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S t a t i c M o d u l e s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterStaticModules() statically registers all the available module\n%  handlers.\n%\n%  The format of the RegisterStaticModules method is:\n%\n%      (void) RegisterStaticModules(void)\n%\n*/\nMagickExport void RegisterStaticModules(void)\n{\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        if (IsRightsAuthorized(ModulePolicyDomain,AllPolicyRights,\n              MagickModules[i].module) == MagickFalse)\n          continue;\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S t a t i c M o d u l e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterStaticModule() statically unregisters the named module.\n%\n%  The format of the UnregisterStaticModule method is:\n%\n%      MagickBooleanType UnregisterStaticModule(const char *module)\n%\n%  A description of each parameter follows:\n%\n%    o module: the module we want to unregister.\n%\n*/\nMagickExport MagickBooleanType UnregisterStaticModule(const char *module)\n{\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module) == 0)\n      {\n        if (MagickModules[i].registered != MagickFalse)\n          {\n            (MagickModules[i].unregister_module)();\n            MagickModules[i].registered=MagickFalse;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S t a t i c M o d u l e s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterStaticModules() statically unregisters all the available module\n%  handlers.\n%\n%  The format of the UnregisterStaticModules method is:\n%\n%      UnregisterStaticModules(void)\n%\n*/\nMagickExport void UnregisterStaticModules(void)\n{\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered != MagickFalse)\n      {\n        (MagickModules[i].unregister_module)();\n        MagickModules[i].registered=MagickFalse;\n      }\n  }\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                  M   M   OOO   DDDD   U   U  L      EEEEE                   %\n%                  MM MM  O   O  D   D  U   U  L      E                       %\n%                  M M M  O   O  D   D  U   U  L      EEE                     %\n%                  M   M  O   O  D   D  U   U  L      E                       %\n%                  M   M   OOO   DDDD    UUU   LLLLL  EEEEE                   %\n%                                                                             %\n%                                                                             %\n%                          MagickCore Module Methods                          %\n%                                                                             %\n%                              Software Design                                %\n%                              Bob Friesenhahn                                %\n%                                March 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/coder.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/module-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_MODULES_SUPPORT)\n#if defined(MAGICKCORE_LTDL_DELEGATE)\n#include \"ltdl.h\"\ntypedef lt_dlhandle ModuleHandle;\n#else\ntypedef void *ModuleHandle;\n#endif\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_LTDL_DELEGATE)\n#  define ModuleGlobExpression \"*.la\"\n#else\n#  if defined(_DEBUG)\n#    define ModuleGlobExpression \"IM_MOD_DB_*.dll\"\n#  else\n#    define ModuleGlobExpression \"IM_MOD_RL_*.dll\"\n#  endif\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic SemaphoreInfo\n  *module_semaphore = (SemaphoreInfo *) NULL;\n\nstatic SplayTreeInfo\n  *module_list = (SplayTreeInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic const ModuleInfo\n  *RegisterModule(const ModuleInfo *,ExceptionInfo *);\n\nstatic MagickBooleanType\n  GetMagickModulePath(const char *,MagickModuleType,char *,ExceptionInfo *),\n  IsModuleTreeInstantiated(),\n  UnregisterModule(const ModuleInfo *,ExceptionInfo *);\n\nstatic void\n  TagToCoderModuleName(const char *,char *),\n  TagToFilterModuleName(const char *,char *),\n  TagToModuleName(const char *,const char *,char *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e M o d u l e I n f o                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireModuleInfo() allocates the ModuleInfo structure.\n%\n%  The format of the AcquireModuleInfo method is:\n%\n%      ModuleInfo *AcquireModuleInfo(const char *path,const char *tag)\n%\n%  A description of each parameter follows:\n%\n%    o path: the path associated with the tag.\n%\n%    o tag: a character string that represents the image format we are\n%      looking for.\n%\n*/\nMagickExport ModuleInfo *AcquireModuleInfo(const char *path,const char *tag)\n{\n  ModuleInfo\n    *module_info;\n\n  module_info=(ModuleInfo *) AcquireCriticalMemory(sizeof(*module_info));\n  (void) memset(module_info,0,sizeof(*module_info));\n  if (path != (const char *) NULL)\n    module_info->path=ConstantString(path);\n  if (tag != (const char *) NULL)\n    module_info->tag=ConstantString(tag);\n  module_info->timestamp=time(0);\n  module_info->signature=MagickCoreSignature;\n  return(module_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y M o d u l e L i s t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyModuleList() unregisters any previously loaded modules and exits\n%  the module loaded environment.\n%\n%  The format of the DestroyModuleList module is:\n%\n%      void DestroyModuleList(void)\n%\n*/\nMagickExport void DestroyModuleList(void)\n{\n  /*\n    Destroy magick modules.\n  */\n  LockSemaphoreInfo(module_semaphore);\n#if defined(MAGICKCORE_MODULES_SUPPORT)\n  if (module_list != (SplayTreeInfo *) NULL)\n    module_list=DestroySplayTree(module_list);\n#endif\n  UnlockSemaphoreInfo(module_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M o d u l e I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetModuleInfo() returns a pointer to a ModuleInfo structure that matches the\n%  specified tag.  If tag is NULL, the head of the module list is returned. If\n%  no modules are loaded, or the requested module is not found, NULL is\n%  returned.\n%\n%  The format of the GetModuleInfo module is:\n%\n%      ModuleInfo *GetModuleInfo(const char *tag,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o tag: a character string that represents the image format we are\n%      looking for.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ModuleInfo *GetModuleInfo(const char *tag,ExceptionInfo *exception)\n{\n  ModuleInfo\n    *module_info;\n\n  if (IsModuleTreeInstantiated() == MagickFalse)\n    return((ModuleInfo *) NULL);\n  LockSemaphoreInfo(module_semaphore);\n  ResetSplayTreeIterator(module_list);\n  if ((tag == (const char *) NULL) || (LocaleCompare(tag,\"*\") == 0))\n    {\n#if defined(MAGICKCORE_MODULES_SUPPORT)\n      if (LocaleCompare(tag,\"*\") == 0)\n        (void) OpenModules(exception);\n#endif\n      module_info=(ModuleInfo *) GetNextValueInSplayTree(module_list);\n      UnlockSemaphoreInfo(module_semaphore);\n      return(module_info);\n    }\n  module_info=(ModuleInfo *) GetValueFromSplayTree(module_list,tag);\n  UnlockSemaphoreInfo(module_semaphore);\n  return(module_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M o d u l e I n f o L i s t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetModuleInfoList() returns any modules that match the specified pattern.\n%\n%  The format of the GetModuleInfoList function is:\n%\n%      const ModuleInfo **GetModuleInfoList(const char *pattern,\n%        size_t *number_modules,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o pattern: Specifies a pointer to a text string containing a pattern.\n%\n%    o number_modules:  This integer returns the number of modules in the list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int ModuleInfoCompare(const void *x,const void *y)\n{\n  const ModuleInfo\n    **p,\n    **q;\n\n  p=(const ModuleInfo **) x,\n  q=(const ModuleInfo **) y;\n  if (LocaleCompare((*p)->path,(*q)->path) == 0)\n    return(LocaleCompare((*p)->tag,(*q)->tag));\n  return(LocaleCompare((*p)->path,(*q)->path));\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport const ModuleInfo **GetModuleInfoList(const char *pattern,\n  size_t *number_modules,ExceptionInfo *exception)\n{\n  const ModuleInfo\n    **modules;\n\n  const ModuleInfo\n    *p;\n\n  ssize_t\n    i;\n\n  /*\n    Allocate module list.\n  */\n  assert(pattern != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",pattern);\n  assert(number_modules != (size_t *) NULL);\n  *number_modules=0;\n  p=GetModuleInfo(\"*\",exception);\n  if (p == (const ModuleInfo *) NULL)\n    return((const ModuleInfo **) NULL);\n  modules=(const ModuleInfo **) AcquireQuantumMemory((size_t)\n    GetNumberOfNodesInSplayTree(module_list)+1UL,sizeof(*modules));\n  if (modules == (const ModuleInfo **) NULL)\n    return((const ModuleInfo **) NULL);\n  /*\n    Generate module list.\n  */\n  LockSemaphoreInfo(module_semaphore);\n  ResetSplayTreeIterator(module_list);\n  p=(const ModuleInfo *) GetNextValueInSplayTree(module_list);\n  for (i=0; p != (const ModuleInfo *) NULL; )\n  {\n    if ((p->stealth == MagickFalse) &&\n        (GlobExpression(p->tag,pattern,MagickFalse) != MagickFalse))\n      modules[i++]=p;\n    p=(const ModuleInfo *) GetNextValueInSplayTree(module_list);\n  }\n  UnlockSemaphoreInfo(module_semaphore);\n  qsort((void *) modules,(size_t) i,sizeof(*modules),ModuleInfoCompare);\n  modules[i]=(ModuleInfo *) NULL;\n  *number_modules=(size_t) i;\n  return(modules);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M o d u l e L i s t                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetModuleList() returns any image format modules that match the specified\n%  pattern.\n%\n%  The format of the GetModuleList function is:\n%\n%      char **GetModuleList(const char *pattern,const MagickModuleType type,\n%        size_t *number_modules,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o pattern: Specifies a pointer to a text string containing a pattern.\n%\n%    o type: choose from MagickImageCoderModule or MagickImageFilterModule.\n%\n%    o number_modules:  This integer returns the number of modules in the\n%      list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int ModuleCompare(const void *x,const void *y)\n{\n  const char\n    **p,\n    **q;\n\n  p=(const char **) x;\n  q=(const char **) y;\n  return(LocaleCompare(*p,*q));\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport char **GetModuleList(const char *pattern,\n  const MagickModuleType type,size_t *number_modules,ExceptionInfo *exception)\n{\n#define MaxModules  511\n\n  char\n    **modules,\n    filename[MagickPathExtent],\n    module_path[MagickPathExtent],\n    path[MagickPathExtent];\n\n  DIR\n    *directory;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  size_t\n    max_entries;\n\n  struct dirent\n    *buffer,\n    *entry;\n\n  /*\n    Locate all modules in the image coder or filter path.\n  */\n  switch (type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      TagToCoderModuleName(\"magick\",filename);\n      status=GetMagickModulePath(filename,MagickImageCoderModule,module_path,\n        exception);\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      TagToFilterModuleName(\"analyze\",filename);\n      status=GetMagickModulePath(filename,MagickImageFilterModule,module_path,\n        exception);\n      break;\n    }\n  }\n  if (status == MagickFalse)\n    return((char **) NULL);\n  GetPathComponent(module_path,HeadPath,path);\n  max_entries=MaxModules;\n  modules=(char **) AcquireQuantumMemory((size_t) max_entries+1UL,\n    sizeof(*modules));\n  if (modules == (char **) NULL)\n    return((char **) NULL);\n  *modules=(char *) NULL;\n  directory=opendir(path);\n  if (directory == (DIR *) NULL)\n    {\n      modules=(char **) RelinquishMagickMemory(modules);\n      return((char **) NULL);\n    }\n  buffer=(struct dirent *) AcquireMagickMemory(sizeof(*buffer)+FILENAME_MAX+1);\n  if (buffer == (struct dirent *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  i=0;\n  while ((MagickReadDirectory(directory,buffer,&entry) == 0) &&\n         (entry != (struct dirent *) NULL))\n  {\n    status=GlobExpression(entry->d_name,ModuleGlobExpression,MagickFalse);\n    if (status == MagickFalse)\n      continue;\n    if (GlobExpression(entry->d_name,pattern,MagickFalse) == MagickFalse)\n      continue;\n    if (i >= (ssize_t) max_entries)\n      {\n        modules=(char **) NULL;\n        if (~max_entries > max_entries)\n          modules=(char **) ResizeQuantumMemory(modules,(size_t)\n            (max_entries << 1),sizeof(*modules));\n        max_entries<<=1;\n        if (modules == (char **) NULL)\n          break;\n      }\n    /*\n      Add new module name to list.\n    */\n    modules[i]=AcquireString((char *) NULL);\n    GetPathComponent(entry->d_name,BasePath,modules[i]);\n    if (LocaleNCompare(\"IM_MOD_\",modules[i],7) == 0)\n      {\n        (void) CopyMagickString(modules[i],modules[i]+10,MagickPathExtent);\n        modules[i][strlen(modules[i])-1]='\\0';\n      }\n    i++;\n  }\n  buffer=(struct dirent *) RelinquishMagickMemory(buffer);\n  (void) closedir(directory);\n  if (modules == (char **) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n        \"MemoryAllocationFailed\",\"`%s'\",pattern);\n      return((char **) NULL);\n    }\n  qsort((void *) modules,(size_t) i,sizeof(*modules),ModuleCompare);\n  modules[i]=(char *) NULL;\n  *number_modules=(size_t) i;\n  return(modules);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t M a g i c k M o d u l e P a t h                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMagickModulePath() finds a module with the specified module type and\n%  filename.\n%\n%  The format of the GetMagickModulePath module is:\n%\n%      MagickBooleanType GetMagickModulePath(const char *filename,\n%        MagickModuleType module_type,char *path,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o filename: the module file name.\n%\n%    o module_type: the module type: MagickImageCoderModule or\n%      MagickImageFilterModule.\n%\n%    o path: the path associated with the filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetMagickModulePath(const char *filename,\n  MagickModuleType module_type,char *path,ExceptionInfo *exception)\n{\n  char\n    *module_path;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(path != (char *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (strchr(filename,'/') != (char *) NULL)\n    return(MagickFalse);\n  (void) CopyMagickString(path,filename,MagickPathExtent);\n  module_path=(char *) NULL;\n  switch (module_type)\n  {\n    case MagickImageCoderModule:\n    default:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for coder module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");\n#if defined(MAGICKCORE_CODER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_CODER_PATH);\n#endif\n      break;\n    }\n    case MagickImageFilterModule:\n    {\n      (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n        \"Searching for filter module file \\\"%s\\\" ...\",filename);\n      module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");\n#if defined(MAGICKCORE_FILTER_PATH)\n      if (module_path == (char *) NULL)\n        module_path=AcquireString(MAGICKCORE_FILTER_PATH);\n#endif\n      break;\n    }\n  }\n  if (module_path != (char *) NULL)\n    {\n      char\n        *p,\n        *q;\n\n      for (p=module_path-1; p != (char *) NULL; )\n      {\n        (void) CopyMagickString(path,p+1,MagickPathExtent);\n        q=strchr(path,DirectoryListSeparator);\n        if (q != (char *) NULL)\n          *q='\\0';\n        q=path+strlen(path)-1;\n        if ((q >= path) && (*q != *DirectorySeparator))\n          (void) ConcatenateMagickString(path,DirectorySeparator,\n            MagickPathExtent);\n        (void) ConcatenateMagickString(path,filename,MagickPathExtent);\n#if defined(MAGICKCORE_HAVE_REALPATH)\n        {\n          char\n            resolved_path[PATH_MAX+1];\n\n          if (realpath(path,resolved_path) != (char *) NULL)\n            (void) CopyMagickString(path,resolved_path,MagickPathExtent);\n        }\n#endif\n        if (IsPathAccessible(path) != MagickFalse)\n          {\n            module_path=DestroyString(module_path);\n            return(MagickTrue);\n          }\n        p=strchr(p+1,DirectoryListSeparator);\n      }\n      module_path=DestroyString(module_path);\n    }\n#if defined(MAGICKCORE_INSTALLED_SUPPORT)\n  else\n#if defined(MAGICKCORE_CODER_PATH)\n    {\n      const char\n        *directory;\n\n      /*\n        Search hard coded paths.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=MAGICKCORE_CODER_PATH;\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=MAGICKCORE_FILTER_PATH;\n          break;\n        }\n      }\n      (void) FormatLocaleString(path,MagickPathExtent,\"%s%s\",directory,\n        filename);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n    {\n      const char\n        *registery_key;\n\n      unsigned char\n        *key_value;\n\n      /*\n        Locate path via registry key.\n      */\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          registery_key=\"CoderModulesPath\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          registery_key=\"FilterModulesPath\";\n          break;\n        }\n      }\n      key_value=NTRegistryKeyLookup(registery_key);\n      if (key_value == (unsigned char *) NULL)\n        {\n          ThrowMagickException(exception,GetMagickModule(),ConfigureError,\n            \"RegistryKeyLookupFailed\",\"`%s'\",registery_key);\n          return(MagickFalse);\n        }\n      (void) FormatLocaleString(path,MagickPathExtent,\"%s%s%s\",(char *)\n        key_value,DirectorySeparator,filename);\n      key_value=(unsigned char *) RelinquishMagickMemory(key_value);\n      if (IsPathAccessible(path) == MagickFalse)\n        {\n          ThrowFileException(exception,ConfigureWarning,\n            \"UnableToOpenModuleFile\",path);\n          return(MagickFalse);\n        }\n      return(MagickTrue);\n    }\n#endif\n#endif\n#if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)\n# error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined\n#endif\n#else\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"MAGICK_HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search MAGICK_HOME.\n        */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%s%s\",home,\n          DirectorySeparator,filename);\n#else\n        const char\n          *directory;\n\n        switch (module_type)\n        {\n          case MagickImageCoderModule:\n          default:\n          {\n            directory=MAGICKCORE_CODER_RELATIVE_PATH;\n            break;\n          }\n          case MagickImageFilterModule:\n          {\n            directory=MAGICKCORE_FILTER_RELATIVE_PATH;\n            break;\n          }\n        }\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s/lib/%s/%s\",home,\n          directory,filename);\n#endif\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  if (*GetClientPath() != '\\0')\n    {\n      /*\n        Search based on executable directory.\n      */\n#if !defined(MAGICKCORE_POSIX_SUPPORT)\n      (void) FormatLocaleString(path,MagickPathExtent,\"%s%s%s\",GetClientPath(),\n        DirectorySeparator,filename);\n#else\n      char\n        prefix[MagickPathExtent];\n\n      const char\n        *directory;\n\n      switch (module_type)\n      {\n        case MagickImageCoderModule:\n        default:\n        {\n          directory=\"coders\";\n          break;\n        }\n        case MagickImageFilterModule:\n        {\n          directory=\"filters\";\n          break;\n        }\n      }\n      (void) CopyMagickString(prefix,GetClientPath(),MagickPathExtent);\n      ChopPathComponents(prefix,1);\n      (void) FormatLocaleString(path,MagickPathExtent,\"%s/lib/%s/%s/%s\",prefix,\n        MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);\n#endif\n      if (IsPathAccessible(path) != MagickFalse)\n        return(MagickTrue);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    /*\n      Search module path.\n    */\n    if ((NTGetModulePath(\"CORE_RL_MagickCore_.dll\",path) != MagickFalse) ||\n        (NTGetModulePath(\"CORE_DB_MagickCore_.dll\",path) != MagickFalse))\n      {\n        (void) ConcatenateMagickString(path,DirectorySeparator,\n          MagickPathExtent);\n        (void) ConcatenateMagickString(path,filename,MagickPathExtent);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n#endif\n  {\n    char\n      *home;\n\n    home=GetEnvironmentValue(\"XDG_CONFIG_HOME\");\n    if (home == (char *) NULL)\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__MINGW32__)\n      home=GetEnvironmentValue(\"LOCALAPPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"APPDATA\");\n    if (home == (char *) NULL)\n      home=GetEnvironmentValue(\"USERPROFILE\");\n#endif\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $XDG_CONFIG_HOME/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%sImageMagick%s%s\",\n          home,DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n    home=GetEnvironmentValue(\"HOME\");\n    if (home != (char *) NULL)\n      {\n        /*\n          Search $HOME/.config/ImageMagick.\n        */\n        (void) FormatLocaleString(path,MagickPathExtent,\n          \"%s%s.config%sImageMagick%s%s\",home,DirectorySeparator,\n          DirectorySeparator,DirectorySeparator,filename);\n        home=DestroyString(home);\n        if (IsPathAccessible(path) != MagickFalse)\n          return(MagickTrue);\n      }\n  }\n  /*\n    Search current directory.\n  */\n  if (IsPathAccessible(path) != MagickFalse)\n    return(MagickTrue);\n  if (exception->severity < ConfigureError)\n    ThrowFileException(exception,ConfigureWarning,\"UnableToOpenModuleFile\",\n      path);\n#endif\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s M o d u l e T r e e I n s t a n t i a t e d                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsModuleTreeInstantiated() determines if the module tree is instantiated.\n%  If not, it instantiates the tree and returns it.\n%\n%  The format of the IsModuleTreeInstantiated() method is:\n%\n%      IsModuleTreeInstantiated()\n%\n*/\n\nstatic void *DestroyModuleNode(void *module_info)\n{\n  ExceptionInfo\n    *exception;\n\n  ModuleInfo\n    *p;\n\n  exception=AcquireExceptionInfo();\n  p=(ModuleInfo *) module_info;\n  if (UnregisterModule(p,exception) == MagickFalse)\n    CatchException(exception);\n  if (p->tag != (char *) NULL)\n    p->tag=DestroyString(p->tag);\n  if (p->path != (char *) NULL)\n    p->path=DestroyString(p->path);\n  exception=DestroyExceptionInfo(exception);\n  return(RelinquishMagickMemory(p));\n}\n\nstatic MagickBooleanType IsModuleTreeInstantiated()\n{\n  if (module_list == (SplayTreeInfo *) NULL)\n    {\n      if (module_semaphore == (SemaphoreInfo *) NULL)\n        ActivateSemaphoreInfo(&module_semaphore);\n      LockSemaphoreInfo(module_semaphore);\n      if (module_list == (SplayTreeInfo *) NULL)\n        {\n          MagickBooleanType\n            status;\n\n          ModuleInfo\n            *module_info;\n\n          SplayTreeInfo\n            *splay_tree;\n\n          splay_tree=NewSplayTree(CompareSplayTreeString,\n            (void *(*)(void *)) NULL,DestroyModuleNode);\n          module_info=AcquireModuleInfo((const char *) NULL,\"[boot-strap]\");\n          module_info->stealth=MagickTrue;\n          status=AddValueToSplayTree(splay_tree,module_info->tag,module_info);\n          if (status == MagickFalse)\n            ThrowFatalException(ResourceLimitFatalError,\n              \"MemoryAllocationFailed\");\n          if (lt_dlinit() != 0)\n            ThrowFatalException(ModuleFatalError,\n              \"UnableToInitializeModuleLoader\");\n          module_list=splay_tree;\n        }\n      UnlockSemaphoreInfo(module_semaphore);\n    }\n  return(module_list != (SplayTreeInfo *) NULL ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n v o k e D y n a m i c I m a g e F i l t e r                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InvokeDynamicImageFilter() invokes a dynamic image filter.\n%\n%  The format of the InvokeDynamicImageFilter module is:\n%\n%      MagickBooleanType InvokeDynamicImageFilter(const char *tag,Image **image,\n%        const int argc,const char **argv,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o tag: a character string that represents the name of the particular\n%      module.\n%\n%    o image: the image.\n%\n%    o argc: a pointer to an integer describing the number of elements in the\n%      argument vector.\n%\n%    o argv: a pointer to a text array containing the command line arguments.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType InvokeDynamicImageFilter(const char *tag,\n  Image **images,const int argc,const char **argv,ExceptionInfo *exception)\n{\n  char\n    name[MagickPathExtent],\n    path[MagickPathExtent];\n\n  ImageFilterHandler\n    *image_filter;\n\n  MagickBooleanType\n    status;\n\n  ModuleHandle\n    handle;\n\n  PolicyRights\n    rights;\n\n  /*\n    Find the module.\n  */\n  assert(images != (Image **) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(FilterPolicyDomain,rights,tag) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",tag);\n      return(MagickFalse);\n    }\n#if !defined(MAGICKCORE_BUILD_MODULES)\n  {\n    MagickBooleanType\n      status;\n\n    status=InvokeStaticImageFilter(tag,images,argc,argv,exception);\n    if (status != MagickFalse)\n      return(status);\n  }\n#endif\n  TagToFilterModuleName(tag,name);\n  status=GetMagickModulePath(name,MagickImageFilterModule,path,exception);\n  if (status == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"'%s': %s\",name,path);\n      return(MagickFalse);\n    }\n  /*\n    Open the module.\n  */\n  handle=(ModuleHandle) lt_dlopen(path);\n  if (handle == (ModuleHandle) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"'%s': %s\",name,lt_dlerror());\n      return(MagickFalse);\n    }\n  /*\n    Locate the module.\n  */\n#if !defined(MAGICKCORE_NAMESPACE_PREFIX)\n  (void) FormatLocaleString(name,MagickPathExtent,\"%sImage\",tag);\n#else\n  (void) FormatLocaleString(name,MagickPathExtent,\"%s%sImage\",\n    MAGICKCORE_NAMESPACE_PREFIX_TAG,tag);\n#endif\n  /*\n    Execute the module.\n  */\n  ClearMagickException(exception);\n  image_filter=(ImageFilterHandler *) lt_dlsym(handle,name);\n  if (image_filter == (ImageFilterHandler *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n      \"UnableToLoadModule\",\"'%s': %s\",name,lt_dlerror());\n  else\n    {\n      size_t\n        signature;\n\n      if ((*images)->debug != MagickFalse)\n        (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n          \"Invoking \\\"%s\\\" dynamic image filter\",tag);\n      signature=image_filter(images,argc,argv,exception);\n      if ((*images)->debug != MagickFalse)\n        (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\"\\\"%s\\\" completes\",\n          tag);\n      if (signature != MagickImageFilterSignature)\n        (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n          \"ImageFilterSignatureMismatch\",\"'%s': %8lx != %8lx\",tag,\n          (unsigned long) signature,(unsigned long) MagickImageFilterSignature);\n    }\n  /*\n    Close the module.\n  */\n  if (lt_dlclose(handle) != 0)\n    (void) ThrowMagickException(exception,GetMagickModule(),ModuleWarning,\n      \"UnableToCloseModule\",\"'%s': %s\",name,lt_dlerror());\n  return(exception->severity < ErrorException ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  L i s t M o d u l e I n f o                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListModuleInfo() lists the module info to a file.\n%\n%  The format of the ListModuleInfo module is:\n%\n%      MagickBooleanType ListModuleInfo(FILE *file,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to a FILE.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ListModuleInfo(FILE *file,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    module_path[MagickPathExtent],\n    **modules,\n    path[MagickPathExtent];\n\n  ssize_t\n    i;\n\n  size_t\n    number_modules;\n\n  if (file == (const FILE *) NULL)\n    file=stdout;\n  /*\n    List image coders.\n  */\n  modules=GetModuleList(\"*\",MagickImageCoderModule,&number_modules,exception);\n  if (modules == (char **) NULL)\n    return(MagickFalse);\n  TagToCoderModuleName(\"magick\",filename);\n  (void) GetMagickModulePath(filename,MagickImageCoderModule,module_path,\n    exception);\n  GetPathComponent(module_path,HeadPath,path);\n  (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",path);\n  (void) FormatLocaleFile(file,\"Image Coder\\n\");\n  (void) FormatLocaleFile(file,\n    \"-------------------------------------------------\"\n    \"------------------------------\\n\");\n  for (i=0; i < (ssize_t) number_modules; i++)\n  {\n    (void) FormatLocaleFile(file,\"%s\",modules[i]);\n    (void) FormatLocaleFile(file,\"\\n\");\n  }\n  (void) fflush(file);\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (ssize_t) number_modules; i++)\n    modules[i]=DestroyString(modules[i]);\n  modules=(char **) RelinquishMagickMemory(modules);\n  /*\n    List image filters.\n  */\n  modules=GetModuleList(\"*\",MagickImageFilterModule,&number_modules,exception);\n  if (modules == (char **) NULL)\n    return(MagickFalse);\n  TagToFilterModuleName(\"analyze\",filename);\n  (void) GetMagickModulePath(filename,MagickImageFilterModule,module_path,\n    exception);\n  GetPathComponent(module_path,HeadPath,path);\n  (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",path);\n  (void) FormatLocaleFile(file,\"Image Filter\\n\");\n  (void) FormatLocaleFile(file,\n    \"-------------------------------------------------\"\n    \"------------------------------\\n\");\n  for (i=0; i < (ssize_t) number_modules; i++)\n  {\n    (void) FormatLocaleFile(file,\"%s\",modules[i]);\n    (void) FormatLocaleFile(file,\"\\n\");\n  }\n  (void) fflush(file);\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (ssize_t) number_modules; i++)\n    modules[i]=DestroyString(modules[i]);\n  modules=(char **) RelinquishMagickMemory(modules);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M o d u l e C o m p o n e n t G e n e s i s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ModuleComponentGenesis() instantiates the module component.\n%\n%  The format of the ModuleComponentGenesis method is:\n%\n%      MagickBooleanType ModuleComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType ModuleComponentGenesis(void)\n{\n  MagickBooleanType\n    status;\n\n  if (module_semaphore == (SemaphoreInfo *) NULL)\n    module_semaphore=AcquireSemaphoreInfo();\n  status=IsModuleTreeInstantiated();\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M o d u l e C o m p o n e n t T e r m i n u s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ModuleComponentTerminus() destroys the module component.\n%\n%  The format of the ModuleComponentTerminus method is:\n%\n%      ModuleComponentTerminus(void)\n%\n*/\nMagickPrivate void ModuleComponentTerminus(void)\n{\n  if (module_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&module_semaphore);\n  DestroyModuleList();\n  RelinquishSemaphoreInfo(&module_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   O p e n M o d u l e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenModule() loads a module, and invokes its registration module.  It\n%  returns MagickTrue on success, and MagickFalse if there is an error.\n%\n%  The format of the OpenModule module is:\n%\n%      MagickBooleanType OpenModule(const char *module,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o module: a character string that indicates the module to load.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType OpenModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent],\n    name[MagickPathExtent],\n    path[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  ModuleHandle\n    handle;\n\n  ModuleInfo\n    *module_info;\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    signature;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  module_info=(ModuleInfo *) GetModuleInfo(module,exception);\n  if (module_info != (ModuleInfo *) NULL)\n    return(MagickTrue);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights|WritePolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  if (GetValueFromSplayTree(module_list,module_name) != (void *) NULL)\n    return(MagickTrue);  /* module already opened, return */\n  /*\n    Locate module.\n  */\n  handle=(ModuleHandle) NULL;\n  TagToCoderModuleName(module_name,name);\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Searching for module \\\"%s\\\" using filename \\\"%s\\\"\",module_name,name);\n  *path='\\0';\n  status=GetMagickModulePath(name,MagickImageCoderModule,path,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n    Load module\n  */\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Opening module at path \\\"%s\\\"\",path);\n  handle=(ModuleHandle) lt_dlopen(path);\n  if (handle == (ModuleHandle) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"'%s': %s\",path,lt_dlerror());\n      return(MagickFalse);\n    }\n  /*\n    Register module.\n  */\n  module_info=AcquireModuleInfo(path,module_name);\n  module_info->handle=handle;\n  if (RegisterModule(module_info,exception) == (ModuleInfo *) NULL)\n    return(MagickFalse);\n  /*\n    Define RegisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Register%sImage\",name);\n  module_info->register_module=(size_t (*)(void)) lt_dlsym(handle,name);\n  if (module_info->register_module == (size_t (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->register_module);\n  /*\n    Define UnregisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Unregister%sImage\",name);\n  module_info->unregister_module=(void (*)(void)) lt_dlsym(handle,name);\n  if (module_info->unregister_module == (void (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->unregister_module);\n  signature=module_info->register_module();\n  if (signature != MagickImageCoderSignature)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"ImageCoderSignatureMismatch\",\"'%s': %8lx != %8lx\",module_name,\n        (unsigned long) signature,(unsigned long) MagickImageCoderSignature);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   O p e n M o d u l e s                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenModules() loads all available modules.\n%\n%  The format of the OpenModules module is:\n%\n%      MagickBooleanType OpenModules(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType OpenModules(ExceptionInfo *exception)\n{\n  char\n    **modules;\n\n  ssize_t\n    i;\n\n  size_t\n    number_modules;\n\n  /*\n    Load all modules.\n  */\n  (void) GetMagickInfo((char *) NULL,exception);\n  number_modules=0;\n  modules=GetModuleList(\"*\",MagickImageCoderModule,&number_modules,exception);\n  if ((modules == (char **) NULL) || (*modules == (char *) NULL))\n    {\n      if (modules != (char **) NULL)\n        modules=(char **) RelinquishMagickMemory(modules);\n      return(MagickFalse);\n    }\n  for (i=0; i < (ssize_t) number_modules; i++)\n    (void) OpenModule(modules[i],exception);\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (ssize_t) number_modules; i++)\n    modules[i]=DestroyString(modules[i]);\n  modules=(char **) RelinquishMagickMemory(modules);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r M o d u l e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterModule() adds an entry to the module list.  It returns a pointer to\n%  the registered entry on success.\n%\n%  The format of the RegisterModule module is:\n%\n%      ModuleInfo *RegisterModule(const ModuleInfo *module_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o info: a pointer to the registered entry is returned.\n%\n%    o module_info: a pointer to the ModuleInfo structure to register.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const ModuleInfo *RegisterModule(const ModuleInfo *module_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  assert(module_info != (ModuleInfo *) NULL);\n  assert(module_info->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",module_info->tag);\n  if (module_list == (SplayTreeInfo *) NULL)\n    return((const ModuleInfo *) NULL);\n  status=AddValueToSplayTree(module_list,module_info->tag,module_info);\n  if (status == MagickFalse)\n    (void) ThrowMagickException(exception,GetMagickModule(),ResourceLimitError,\n      \"MemoryAllocationFailed\",\"`%s'\",module_info->tag);\n  return(module_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  T a g T o C o d e r M o d u l e N a m e                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TagToCoderModuleName() munges a module tag and obtains the filename of the\n%  corresponding module.\n%\n%  The format of the TagToCoderModuleName module is:\n%\n%      char *TagToCoderModuleName(const char *tag,char *name)\n%\n%  A description of each parameter follows:\n%\n%    o tag: a character string representing the module tag.\n%\n%    o name: return the module name here.\n%\n*/\nstatic void TagToCoderModuleName(const char *tag,char *name)\n{\n  assert(tag != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",tag);\n  assert(name != (char *) NULL);\n#if defined(MAGICKCORE_LTDL_DELEGATE)\n  (void) FormatLocaleString(name,MagickPathExtent,\"%s.la\",tag);\n  (void) LocaleLower(name);\n#else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  if (LocaleNCompare(\"IM_MOD_\",tag,7) == 0)\n    (void) CopyMagickString(name,tag,MagickPathExtent);\n  else\n    {\n#if defined(_DEBUG)\n      (void) FormatLocaleString(name,MagickPathExtent,\"IM_MOD_DB_%s_.dll\",tag);\n#else\n      (void) FormatLocaleString(name,MagickPathExtent,\"IM_MOD_RL_%s_.dll\",tag);\n#endif\n    }\n#endif\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  T a g T o F i l t e r M o d u l e N a m e                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TagToFilterModuleName() munges a module tag and returns the filename of the\n%  corresponding filter module.\n%\n%  The format of the TagToFilterModuleName module is:\n%\n%      void TagToFilterModuleName(const char *tag,char name)\n%\n%  A description of each parameter follows:\n%\n%    o tag: a character string representing the module tag.\n%\n%    o name: return the filter name here.\n%\n*/\nstatic void TagToFilterModuleName(const char *tag,char *name)\n{\n  assert(tag != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",tag);\n  assert(name != (char *) NULL);\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  (void) FormatLocaleString(name,MagickPathExtent,\"FILTER_%s_.dll\",tag);\n#elif !defined(MAGICKCORE_LTDL_DELEGATE)\n  (void) FormatLocaleString(name,MagickPathExtent,\"%s.dll\",tag);\n#else\n  (void) FormatLocaleString(name,MagickPathExtent,\"%s.la\",tag);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   T a g T o M o d u l e N a m e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TagToModuleName() munges the module tag name and returns an upper-case tag\n%  name as the input string, and a user-provided format.\n%\n%  The format of the TagToModuleName module is:\n%\n%      TagToModuleName(const char *tag,const char *format,char *module)\n%\n%  A description of each parameter follows:\n%\n%    o tag: the module tag.\n%\n%    o format: a sprintf-compatible format string containing %s where the\n%      upper-case tag name is to be inserted.\n%\n%    o module: pointer to a destination buffer for the formatted result.\n%\n*/\nstatic void TagToModuleName(const char *tag,const char *format,char *module)\n{\n  char\n    name[MagickPathExtent];\n\n  assert(tag != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",tag);\n  assert(format != (const char *) NULL);\n  assert(module != (char *) NULL);\n  (void) CopyMagickString(name,tag,MagickPathExtent);\n  LocaleUpper(name);\n#if !defined(MAGICKCORE_NAMESPACE_PREFIX)\n  (void) FormatLocaleString(module,MagickPathExtent,format,name);\n#else\n  {\n    char\n      prefix_format[MagickPathExtent];\n\n    (void) FormatLocaleString(prefix_format,MagickPathExtent,\"%s%s\",\n      MAGICKCORE_NAMESPACE_PREFIX_TAG,format);\n    (void) FormatLocaleString(module,MagickPathExtent,prefix_format,name);\n  }\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r M o d u l e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterModule() unloads a module, and invokes its de-registration module.\n%  Returns MagickTrue on success, and MagickFalse if there is an error.\n%\n%  The format of the UnregisterModule module is:\n%\n%      MagickBooleanType UnregisterModule(const ModuleInfo *module_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o module_info: the module info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType UnregisterModule(const ModuleInfo *module_info,\n  ExceptionInfo *exception)\n{\n  /*\n    Locate and execute UnregisterFORMATImage module.\n  */\n  assert(module_info != (const ModuleInfo *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",module_info->tag);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (module_info->unregister_module == NULL)\n    return(MagickTrue);\n  module_info->unregister_module();\n  if (lt_dlclose((ModuleHandle) module_info->handle) != 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleWarning,\n        \"UnableToCloseModule\",\"'%s': %s\",module_info->tag,lt_dlerror());\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n#else\n\n#if !defined(MAGICKCORE_BUILD_MODULES)\nextern size_t\n  analyzeImage(Image **,const int,const char **,ExceptionInfo *);\n#endif\n\nMagickExport MagickBooleanType ListModuleInfo(FILE *magick_unused(file),\n  ExceptionInfo *magick_unused(exception))\n{\n  return(MagickTrue);\n}\n\nMagickExport MagickBooleanType InvokeDynamicImageFilter(const char *tag,\n  Image **image,const int argc,const char **argv,ExceptionInfo *exception)\n{\n  PolicyRights\n    rights;\n\n  assert(image != (Image **) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(FilterPolicyDomain,rights,tag) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",tag);\n      return(MagickFalse);\n    }\n#if defined(MAGICKCORE_BUILD_MODULES)\n  (void) tag;\n  (void) argc;\n  (void) argv;\n  (void) exception;\n#else\n  {\n    ImageFilterHandler\n      *image_filter;\n\n    image_filter=(ImageFilterHandler *) NULL;\n    if (LocaleCompare(\"analyze\",tag) == 0)\n      image_filter=(ImageFilterHandler *) analyzeImage;\n    if (image_filter == (ImageFilterHandler *) NULL)\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"`%s'\",tag);\n    else\n      {\n        size_t\n          signature;\n\n        if ((*image)->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Invoking \\\"%s\\\" static image filter\",tag);\n        signature=image_filter(image,argc,argv,exception);\n        if ((*image)->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\\\"%s\\\" completes\",\n            tag);\n        if (signature != MagickImageFilterSignature)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n              \"ImageFilterSignatureMismatch\",\"'%s': %8lx != %8lx\",tag,\n              (unsigned long) signature,(unsigned long)\n              MagickImageFilterSignature);\n            return(MagickFalse);\n          }\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                  SSSSS  TTTTT   AAA   TTTTT  IIIII   CCCC                   %\n%                  SS       T    A   A    T      I    C                       %\n%                   SSS     T    AAAAA    T      I    C                       %\n%                     SS    T    A   A    T      I    C                       %\n%                  SSSSS    T    A   A    T    IIIII   CCCC                   %\n%                                                                             %\n%                                                                             %\n%                          MagickCore Static Methods                          %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 March 2000                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2021 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/coder.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"coders/coders.h\"\n\f\n/*\n  Define declarations.\n*/\n#define AddMagickCoder(coder)  { #coder, MagickFalse, \\\n  Register ## coder ## Image, Unregister ## coder ## Image },\n\f\n/*\n  ImageMagick module stub.\n*/\nModuleExport size_t RegisterUndefinedImage(void)\n{\n  return(MagickImageCoderSignature);\n}\n\nModuleExport void UnregisterUndefinedImage(void)\n{\n}\n\f\n/*\n  ImageMagick modules.\n*/\nstatic struct\n{\n  const char\n    *module;\n\n  MagickBooleanType\n    registered;\n\n  size_t\n    (*register_module)(void);\n\n  void\n    (*unregister_module)(void);\n} MagickModules[] = {\n#if !defined(MAGICKCORE_BUILD_MODULES)\n  #include \"coders/coders-list.h\"\n#endif\n  { (const char *) NULL, MagickFalse, RegisterUndefinedImage, UnregisterUndefinedImage }\n};\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n v o k e S t a t i c I m a g e F i l t e r                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InvokeStaticImageFilter() invokes a static image filter.\n%\n%  The format of the InvokeStaticImageFilter method is:\n%\n%      MagickBooleanType InvokeStaticImageFilter(const char *tag,Image **image,\n%        const int argc,const char **argv)\n%\n%  A description of each parameter follows:\n%\n%    o tag: the module tag.\n%\n%    o image: the image.\n%\n%    o argc: the number of elements in the argument vector.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o argv: A text array containing the command line arguments.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n#if defined(MAGICKCORE_MODULES_SUPPORT)\nMagickExport MagickBooleanType InvokeStaticImageFilter(const char *tag,\n  Image **image,const int argc,const char **argv,ExceptionInfo *exception)\n{\n  PolicyRights\n    rights;\n\n  assert(image != (Image **) NULL);\n  assert((*image)->signature == MagickCoreSignature);\n  if ((*image)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*image)->filename);\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(FilterPolicyDomain,rights,tag) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",tag);\n      return(MagickFalse);\n    }\n#if defined(MAGICKCORE_MODULES_SUPPORT)\n  (void) tag;\n  (void) argc;\n  (void) argv;\n  (void) exception;\n#else\n  {\n    extern size_t\n      analyzeImage(Image **,const int,char **,ExceptionInfo *);\n\n    ImageFilterHandler\n      *image_filter;\n\n    image_filter=(ImageFilterHandler *) NULL;\n    if (LocaleCompare(\"analyze\",tag) == 0)\n      image_filter=(ImageFilterHandler *) analyzeImage;\n    if (image_filter == (ImageFilterHandler *) NULL)\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"`%s'\",tag);\n    else\n      {\n        size_t\n          signature;\n\n        if ((*image)->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"Invoking \\\"%s\\\" static image filter\",tag);\n        signature=image_filter(image,argc,argv,exception);\n        if ((*image)->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\\\"%s\\\" completes\",\n            tag);\n        if (signature != MagickImageFilterSignature)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n              \"ImageFilterSignatureMismatch\",\"'%s': %8lx != %8lx\",tag,\n              (unsigned long) signature,(unsigned long)\n              MagickImageFilterSignature);\n            return(MagickFalse);\n          }\n      }\n  }\n#endif\n  return(MagickTrue);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S t a t i c M o d u l e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterStaticModule() statically registers a module.\n%\n%  The format of the RegisterStaticModule method is:\n%\n%      MagickBooleanType RegisterStaticModule(const char module,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o module: the want to register.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights|WritePolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S t a t i c M o d u l e s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterStaticModules() statically registers all the available module\n%  handlers.\n%\n%  The format of the RegisterStaticModules method is:\n%\n%      (void) RegisterStaticModules(void)\n%\n*/\nMagickExport void RegisterStaticModules(void)\n{\n  PolicyRights\n    rights;\n\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  rights=ReadPolicyRights|WritePolicyRights;\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        if (IsRightsAuthorized(ModulePolicyDomain,rights,\n              MagickModules[i].module) == MagickFalse)\n          continue;\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S t a t i c M o d u l e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterStaticModule() statically unregisters the named module.\n%\n%  The format of the UnregisterStaticModule method is:\n%\n%      MagickBooleanType UnregisterStaticModule(const char *module)\n%\n%  A description of each parameter follows:\n%\n%    o module: the module we want to unregister.\n%\n*/\nMagickExport MagickBooleanType UnregisterStaticModule(const char *module)\n{\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module) == 0)\n      {\n        if (MagickModules[i].registered != MagickFalse)\n          {\n            (MagickModules[i].unregister_module)();\n            MagickModules[i].registered=MagickFalse;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S t a t i c M o d u l e s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterStaticModules() statically unregisters all the available module\n%  handlers.\n%\n%  The format of the UnregisterStaticModules method is:\n%\n%      UnregisterStaticModules(void)\n%\n*/\nMagickExport void UnregisterStaticModules(void)\n{\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered != MagickFalse)\n      {\n        (MagickModules[i].unregister_module)();\n        MagickModules[i].registered=MagickFalse;\n      }\n  }\n}\n"], "filenames": ["MagickCore/module.c", "MagickCore/static.c"], "buggy_code_start_loc": [1274, 249], "buggy_code_end_loc": [1275, 305], "fixing_code_start_loc": [1274, 249], "fixing_code_end_loc": [1275, 309], "type": "CWE-668", "message": "ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=\"module\" rights=\"none\" pattern=\"PS\" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=\"coder\" rights=\"none\" pattern=\"{PS,EPI,EPS,EPSF,EPSI}\" />.", "other": {"cve": {"id": "CVE-2021-39212", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-13T18:15:23.907", "lastModified": "2023-05-22T02:15:10.910", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=\"module\" rights=\"none\" pattern=\"PS\" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=\"coder\" rights=\"none\" pattern=\"{PS,EPI,EPS,EPSF,EPSI}\" />."}, {"lang": "es", "value": "ImageMagick es un software libre que se entrega como una distribuci\u00f3n binaria lista para ser ejecutada o como un c\u00f3digo fuente que se puede usar, copiar, modificar y distribuir tanto en aplicaciones abiertas como propietarias. En las versiones afectadas y en determinados casos, los archivos Postscript pod\u00edan leerse y escribirse cuando se exclu\u00edan espec\u00edficamente mediante una pol\u00edtica de \"module\" en \"policy.xml\". ex. (policy domain=\"module\" rights=\"none\" pattern=\"PS\" /). El problema ha sido resuelto en ImageMagick versiones 7.1.0-7 y en 6.9.12-22. Afortunadamente, en la naturaleza, pocos usuarios usan la pol\u00edtica \"module\" y en su lugar usan la pol\u00edtica \"coder\" que es tambi\u00e9n nuestra recomendaci\u00f3n de soluci\u00f3n: (policy domain=\"coder\" rights=\"none\" pattern=\"{PS,EPI,EPS,EPSF,EPSI}\" /)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.9.12-0", "versionEndExcluding": "6.9.12-22", "matchCriteriaId": "BF324E5C-BBC3-4F30-878E-EEBBAC19EBA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.1.0-0", "versionEndExcluding": "7.1.0-7", "matchCriteriaId": "11251438-4BED-4401-8033-B2F084031287"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/01faddbe2711a4156180c4a92837e2f23683cc68", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/35893e7cad78ce461fcaffa56076c11700ba5e4e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/security/advisories/GHSA-qvhr-jj4p-j2qr", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00020.html", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/01faddbe2711a4156180c4a92837e2f23683cc68"}}