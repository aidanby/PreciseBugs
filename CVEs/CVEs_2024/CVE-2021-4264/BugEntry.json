{"buggy_code": ["node_modules\n*.DS_Store\n.grunt\nindex.html\ntmp\nexamples/*/views/**/*.js\nexamples/*/lib/*\n!examples/*/lib/main.js\n", "language: node_js\nnode_js:\n  - \"0.12\"\n  - \"5\"\n  - \"6\"\nmatrix:\n  include:\n    - node_js: \"0.10\"\n      env:\n        - TEST=\"all\"\n        - CXX=g++-4.8\nnotifications:\n  email:\n    - jchan@linkedin.com\n    - skinast@linkedin.com\nbefore_install:\n  - npm install -g npm@3\nbefore_script:\n  - npm update\nsudo: false\ncache:\n  directories:\n    - node_modules\nenv:\n  - CXX=g++-4.8\naddons:\n  apt:\n    sources:\n      - ubuntu-toolchain-r-test\n    packages:\n      - g++-4.8\n", "/*! dustjs-linkedin - v2.7.2\n* http://dustjs.com/\n* Copyright (c) 2015 Aleksander Williams; Released under the MIT License */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd && define.amd.dust === true) {\n    define('dust.core', [], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.dust = factory();\n  }\n}(this, function() {\n  var dust = {\n        \"version\": \"2.7.2\"\n      },\n      NONE = 'NONE', ERROR = 'ERROR', WARN = 'WARN', INFO = 'INFO', DEBUG = 'DEBUG',\n      EMPTY_FUNC = function() {};\n\n  dust.config = {\n    whitespace: false,\n    amd: false,\n    cjs: false,\n    cache: true\n  };\n\n  // Directive aliases to minify code\n  dust._aliases = {\n    \"write\": \"w\",\n    \"end\": \"e\",\n    \"map\": \"m\",\n    \"render\": \"r\",\n    \"reference\": \"f\",\n    \"section\": \"s\",\n    \"exists\": \"x\",\n    \"notexists\": \"nx\",\n    \"block\": \"b\",\n    \"partial\": \"p\",\n    \"helper\": \"h\"\n  };\n\n  (function initLogging() {\n    /*global process, console*/\n    var loggingLevels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, NONE: 4 },\n        consoleLog,\n        log;\n\n    if (typeof console !== 'undefined' && console.log) {\n      consoleLog = console.log;\n      if(typeof consoleLog === 'function') {\n        log = function() {\n          consoleLog.apply(console, arguments);\n        };\n      } else {\n        log = function() {\n          consoleLog(Array.prototype.slice.apply(arguments).join(' '));\n        };\n      }\n    } else {\n      log = EMPTY_FUNC;\n    }\n\n    /**\n     * Filters messages based on `dust.debugLevel`.\n     * This default implementation will print to the console if it exists.\n     * @param {String|Error} message the message to print/throw\n     * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)\n     * @public\n     */\n    dust.log = function(message, type) {\n      type = type || INFO;\n      if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {\n        log('[DUST:' + type + ']', message);\n      }\n    };\n\n    dust.debugLevel = NONE;\n    if(typeof process !== 'undefined' && process.env && /\\bdust\\b/.test(process.env.DEBUG)) {\n      dust.debugLevel = DEBUG;\n    }\n\n  }());\n\n  dust.helpers = {};\n\n  dust.cache = {};\n\n  dust.register = function(name, tmpl) {\n    if (!name) {\n      return;\n    }\n    tmpl.templateName = name;\n    if (dust.config.cache !== false) {\n      dust.cache[name] = tmpl;\n    }\n  };\n\n  dust.render = function(nameOrTemplate, context, callback) {\n    var chunk = new Stub(callback).head;\n    try {\n      load(nameOrTemplate, chunk, context).end();\n    } catch (err) {\n      chunk.setError(err);\n    }\n  };\n\n  dust.stream = function(nameOrTemplate, context) {\n    var stream = new Stream(),\n        chunk = stream.head;\n    dust.nextTick(function() {\n      try {\n        load(nameOrTemplate, chunk, context).end();\n      } catch (err) {\n        chunk.setError(err);\n      }\n    });\n    return stream;\n  };\n\n  /**\n   * Extracts a template function (body_0) from whatever is passed.\n   * @param nameOrTemplate {*} Could be:\n   *   - the name of a template to load from cache\n   *   - a CommonJS-compiled template (a function with a `template` property)\n   *   - a template function\n   * @param loadFromCache {Boolean} if false, don't look in the cache\n   * @return {Function} a template function, if found\n   */\n  function getTemplate(nameOrTemplate, loadFromCache/*=true*/) {\n    if(!nameOrTemplate) {\n      return;\n    }\n    if(typeof nameOrTemplate === 'function' && nameOrTemplate.template) {\n      // Sugar away CommonJS module templates\n      return nameOrTemplate.template;\n    }\n    if(dust.isTemplateFn(nameOrTemplate)) {\n      // Template functions passed directly\n      return nameOrTemplate;\n    }\n    if(loadFromCache !== false) {\n      // Try loading a template with this name from cache\n      return dust.cache[nameOrTemplate];\n    }\n  }\n\n  function load(nameOrTemplate, chunk, context) {\n    if(!nameOrTemplate) {\n      return chunk.setError(new Error('No template or template name provided to render'));\n    }\n\n    var template = getTemplate(nameOrTemplate, dust.config.cache);\n\n    if (template) {\n      return template(chunk, Context.wrap(context, template.templateName));\n    } else {\n      if (dust.onLoad) {\n        return chunk.map(function(chunk) {\n          // Alias just so it's easier to read that this would always be a name\n          var name = nameOrTemplate;\n          // Three possible scenarios for a successful callback:\n          //   - `require(nameOrTemplate)(dust); cb()`\n          //   - `src = readFile('src.dust'); cb(null, src)`\n          //   - `compiledTemplate = require(nameOrTemplate)(dust); cb(null, compiledTemplate)`\n          function done(err, srcOrTemplate) {\n            var template;\n            if (err) {\n              return chunk.setError(err);\n            }\n            // Prefer a template that is passed via callback over the cached version.\n            template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);\n            if (!template) {\n              // It's a template string, compile it and register under `name`\n              if(dust.compile) {\n                template = dust.loadSource(dust.compile(srcOrTemplate, name));\n              } else {\n                return chunk.setError(new Error('Dust compiler not available'));\n              }\n            }\n            template(chunk, Context.wrap(context, template.templateName)).end();\n          }\n\n          if(dust.onLoad.length === 3) {\n            dust.onLoad(name, context.options, done);\n          } else {\n            dust.onLoad(name, done);\n          }\n        });\n      }\n      return chunk.setError(new Error('Template Not Found: ' + nameOrTemplate));\n    }\n  }\n\n  dust.loadSource = function(source) {\n    /*jshint evil:true*/\n    return eval(source);\n  };\n\n  if (Array.isArray) {\n    dust.isArray = Array.isArray;\n  } else {\n    dust.isArray = function(arr) {\n      return Object.prototype.toString.call(arr) === '[object Array]';\n    };\n  }\n\n  dust.nextTick = (function() {\n    return function(callback) {\n      setTimeout(callback, 0);\n    };\n  })();\n\n  /**\n   * Dust has its own rules for what is \"empty\"-- which is not the same as falsy.\n   * Empty arrays, null, and undefined are empty\n   */\n  dust.isEmpty = function(value) {\n    if (value === 0) {\n      return false;\n    }\n    if (dust.isArray(value) && !value.length) {\n      return true;\n    }\n    return !value;\n  };\n\n  dust.isEmptyObject = function(obj) {\n    var key;\n    if (obj === null) {\n      return false;\n    }\n    if (obj === undefined) {\n      return false;\n    }\n    if (obj.length > 0) {\n      return false;\n    }\n    for (key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  dust.isTemplateFn = function(elem) {\n    return typeof elem === 'function' &&\n           elem.__dustBody;\n  };\n\n  /**\n   * Decide somewhat-naively if something is a Thenable.\n   * @param elem {*} object to inspect\n   * @return {Boolean} is `elem` a Thenable?\n   */\n  dust.isThenable = function(elem) {\n    return elem &&\n           typeof elem === 'object' &&\n           typeof elem.then === 'function';\n  };\n\n  /**\n   * Decide very naively if something is a Stream.\n   * @param elem {*} object to inspect\n   * @return {Boolean} is `elem` a Stream?\n   */\n  dust.isStreamable = function(elem) {\n    return elem &&\n           typeof elem.on === 'function' &&\n           typeof elem.pipe === 'function';\n  };\n\n  // apply the filter chain and return the output string\n  dust.filter = function(string, auto, filters, context) {\n    var i, len, name, filter;\n    if (filters) {\n      for (i = 0, len = filters.length; i < len; i++) {\n        name = filters[i];\n        if (!name.length) {\n          continue;\n        }\n        filter = dust.filters[name];\n        if (name === 's') {\n          auto = null;\n        } else if (typeof filter === 'function') {\n          string = filter(string, context);\n        } else {\n          dust.log('Invalid filter `' + name + '`', WARN);\n        }\n      }\n    }\n    // by default always apply the h filter, unless asked to unescape with |s\n    if (auto) {\n      string = dust.filters[auto](string, context);\n    }\n    return string;\n  };\n\n  dust.filters = {\n    h: function(value) { return dust.escapeHtml(value); },\n    j: function(value) { return dust.escapeJs(value); },\n    u: encodeURI,\n    uc: encodeURIComponent,\n    js: function(value) { return dust.escapeJSON(value); },\n    jp: function(value) {\n      if (!JSON) {dust.log('JSON is undefined; could not parse `' + value + '`', WARN);\n        return value;\n      } else {\n        return JSON.parse(value);\n      }\n    }\n  };\n\n  function Context(stack, global, options, blocks, templateName) {\n    if(stack !== undefined && !(stack instanceof Stack)) {\n      stack = new Stack(stack);\n    }\n    this.stack = stack;\n    this.global = global;\n    this.options = options;\n    this.blocks = blocks;\n    this.templateName = templateName;\n  }\n\n  dust.makeBase = dust.context = function(global, options) {\n    return new Context(undefined, global, options);\n  };\n\n  /**\n   * Factory function that creates a closure scope around a Thenable-callback.\n   * Returns a function that can be passed to a Thenable that will resume a\n   * Context lookup once the Thenable resolves with new data, adding that new\n   * data to the lookup stack.\n   */\n  function getWithResolvedData(ctx, cur, down) {\n    return function(data) {\n      return ctx.push(data)._get(cur, down);\n    };\n  }\n\n  Context.wrap = function(context, name) {\n    if (context instanceof Context) {\n      return context;\n    }\n    return new Context(context, {}, {}, null, name);\n  };\n\n  /**\n   * Public API for getting a value from the context.\n   * @method get\n   * @param {string|array} path The path to the value. Supported formats are:\n   * 'key'\n   * 'path.to.key'\n   * '.path.to.key'\n   * ['path', 'to', 'key']\n   * ['key']\n   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the\n   * current context (true), or if get should search in parent contexts as well (false).\n   * @public\n   * @returns {string|object}\n   */\n  Context.prototype.get = function(path, cur) {\n    if (typeof path === 'string') {\n      if (path[0] === '.') {\n        cur = true;\n        path = path.substr(1);\n      }\n      path = path.split('.');\n    }\n    return this._get(cur, path);\n  };\n\n  /**\n   * Get a value from the context\n   * @method _get\n   * @param {boolean} cur Get only from the current context\n   * @param {array} down An array of each step in the path\n   * @private\n   * @return {string | object}\n   */\n  Context.prototype._get = function(cur, down) {\n    var ctx = this.stack || {},\n        i = 1,\n        value, first, len, ctxThis, fn;\n\n    first = down[0];\n    len = down.length;\n\n    if (cur && len === 0) {\n      ctxThis = ctx;\n      ctx = ctx.head;\n    } else {\n      if (!cur) {\n        // Search up the stack for the first value\n        while (ctx) {\n          if (ctx.isObject) {\n            ctxThis = ctx.head;\n            value = ctx.head[first];\n            if (value !== undefined) {\n              break;\n            }\n          }\n          ctx = ctx.tail;\n        }\n\n        // Try looking in the global context if we haven't found anything yet\n        if (value !== undefined) {\n          ctx = value;\n        } else {\n          ctx = this.global && this.global[first];\n        }\n      } else if (ctx) {\n        // if scope is limited by a leading dot, don't search up the tree\n        if(ctx.head) {\n          ctx = ctx.head[first];\n        } else {\n          // context's head is empty, value we are searching for is not defined\n          ctx = undefined;\n        }\n      }\n\n      while (ctx && i < len) {\n        if (dust.isThenable(ctx)) {\n          // Bail early by returning a Thenable for the remainder of the search tree\n          return ctx.then(getWithResolvedData(this, cur, down.slice(i)));\n        }\n        ctxThis = ctx;\n        ctx = ctx[down[i]];\n        i++;\n      }\n    }\n\n    if (typeof ctx === 'function') {\n      fn = function() {\n        try {\n          return ctx.apply(ctxThis, arguments);\n        } catch (err) {\n          dust.log(err, ERROR);\n          throw err;\n        }\n      };\n      fn.__dustBody = !!ctx.__dustBody;\n      return fn;\n    } else {\n      if (ctx === undefined) {\n        dust.log('Cannot find reference `{' + down.join('.') + '}` in template `' + this.getTemplateName() + '`', INFO);\n      }\n      return ctx;\n    }\n  };\n\n  Context.prototype.getPath = function(cur, down) {\n    return this._get(cur, down);\n  };\n\n  Context.prototype.push = function(head, idx, len) {\n    if(head === undefined) {\n      dust.log(\"Not pushing an undefined variable onto the context\", INFO);\n      return this;\n    }\n    return this.rebase(new Stack(head, this.stack, idx, len));\n  };\n\n  Context.prototype.pop = function() {\n    var head = this.current();\n    this.stack = this.stack && this.stack.tail;\n    return head;\n  };\n\n  Context.prototype.rebase = function(head) {\n    return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());\n  };\n\n  Context.prototype.clone = function() {\n    var context = this.rebase();\n    context.stack = this.stack;\n    return context;\n  };\n\n  Context.prototype.current = function() {\n    return this.stack && this.stack.head;\n  };\n\n  Context.prototype.getBlock = function(key) {\n    var blocks, len, fn;\n\n    if (typeof key === 'function') {\n      key = key(new Chunk(), this).data.join('');\n    }\n\n    blocks = this.blocks;\n\n    if (!blocks) {\n      dust.log('No blocks for context `' + key + '` in template `' + this.getTemplateName() + '`', DEBUG);\n      return false;\n    }\n\n    len = blocks.length;\n    while (len--) {\n      fn = blocks[len][key];\n      if (fn) {\n        return fn;\n      }\n    }\n\n    dust.log('Malformed template `' + this.getTemplateName() + '` was missing one or more blocks.');\n    return false;\n  };\n\n  Context.prototype.shiftBlocks = function(locals) {\n    var blocks = this.blocks,\n        newBlocks;\n\n    if (locals) {\n      if (!blocks) {\n        newBlocks = [locals];\n      } else {\n        newBlocks = blocks.concat([locals]);\n      }\n      return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());\n    }\n    return this;\n  };\n\n  Context.prototype.resolve = function(body) {\n    var chunk;\n\n    if(typeof body !== 'function') {\n      return body;\n    }\n    chunk = new Chunk().render(body, this);\n    if(chunk instanceof Chunk) {\n      return chunk.data.join(''); // ie7 perf\n    }\n    return chunk;\n  };\n\n  Context.prototype.getTemplateName = function() {\n    return this.templateName;\n  };\n\n  function Stack(head, tail, idx, len) {\n    this.tail = tail;\n    this.isObject = head && typeof head === 'object';\n    this.head = head;\n    this.index = idx;\n    this.of = len;\n  }\n\n  function Stub(callback) {\n    this.head = new Chunk(this);\n    this.callback = callback;\n    this.out = '';\n  }\n\n  Stub.prototype.flush = function() {\n    var chunk = this.head;\n\n    while (chunk) {\n      if (chunk.flushable) {\n        this.out += chunk.data.join(''); //ie7 perf\n      } else if (chunk.error) {\n        this.callback(chunk.error);\n        dust.log('Rendering failed with error `' + chunk.error + '`', ERROR);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.callback(null, this.out);\n  };\n\n  /**\n   * Creates an interface sort of like a Streams2 ReadableStream.\n   */\n  function Stream() {\n    this.head = new Chunk(this);\n  }\n\n  Stream.prototype.flush = function() {\n    var chunk = this.head;\n\n    while(chunk) {\n      if (chunk.flushable) {\n        this.emit('data', chunk.data.join('')); //ie7 perf\n      } else if (chunk.error) {\n        this.emit('error', chunk.error);\n        this.emit('end');\n        dust.log('Streaming failed with error `' + chunk.error + '`', ERROR);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.emit('end');\n  };\n\n  /**\n   * Executes listeners for `type` by passing data. Note that this is different from a\n   * Node stream, which can pass an arbitrary number of arguments\n   * @return `true` if event had listeners, `false` otherwise\n   */\n  Stream.prototype.emit = function(type, data) {\n    var events = this.events || {},\n        handlers = events[type] || [],\n        i, l;\n\n    if (!handlers.length) {\n      dust.log('Stream broadcasting, but no listeners for `' + type + '`', DEBUG);\n      return false;\n    }\n\n    handlers = handlers.slice(0);\n    for (i = 0, l = handlers.length; i < l; i++) {\n      handlers[i](data);\n    }\n    return true;\n  };\n\n  Stream.prototype.on = function(type, callback) {\n    var events = this.events = this.events || {},\n        handlers = events[type] = events[type] || [];\n\n    if(typeof callback !== 'function') {\n      dust.log('No callback function provided for `' + type + '` event listener', WARN);\n    } else {\n      handlers.push(callback);\n    }\n    return this;\n  };\n\n  /**\n   * Pipes to a WritableStream. Note that backpressure isn't implemented,\n   * so we just write as fast as we can.\n   * @param stream {WritableStream}\n   * @return self\n   */\n  Stream.prototype.pipe = function(stream) {\n    if(typeof stream.write !== 'function' ||\n       typeof stream.end !== 'function') {\n      dust.log('Incompatible stream passed to `pipe`', WARN);\n      return this;\n    }\n\n    var destEnded = false;\n\n    if(typeof stream.emit === 'function') {\n      stream.emit('pipe', this);\n    }\n\n    if(typeof stream.on === 'function') {\n      stream.on('error', function() {\n        destEnded = true;\n      });\n    }\n\n    return this\n    .on('data', function(data) {\n      if(destEnded) {\n        return;\n      }\n      try {\n        stream.write(data, 'utf8');\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    })\n    .on('end', function() {\n      if(destEnded) {\n        return;\n      }\n      try {\n        stream.end();\n        destEnded = true;\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    });\n  };\n\n  function Chunk(root, next, taps) {\n    this.root = root;\n    this.next = next;\n    this.data = []; //ie7 perf\n    this.flushable = false;\n    this.taps = taps;\n  }\n\n  Chunk.prototype.write = function(data) {\n    var taps = this.taps;\n\n    if (taps) {\n      data = taps.go(data);\n    }\n    this.data.push(data);\n    return this;\n  };\n\n  Chunk.prototype.end = function(data) {\n    if (data) {\n      this.write(data);\n    }\n    this.flushable = true;\n    this.root.flush();\n    return this;\n  };\n\n  Chunk.prototype.map = function(callback) {\n    var cursor = new Chunk(this.root, this.next, this.taps),\n        branch = new Chunk(this.root, cursor, this.taps);\n\n    this.next = branch;\n    this.flushable = true;\n    try {\n      callback(branch);\n    } catch(err) {\n      dust.log(err, ERROR);\n      branch.setError(err);\n    }\n    return cursor;\n  };\n\n  Chunk.prototype.tap = function(tap) {\n    var taps = this.taps;\n\n    if (taps) {\n      this.taps = taps.push(tap);\n    } else {\n      this.taps = new Tap(tap);\n    }\n    return this;\n  };\n\n  Chunk.prototype.untap = function() {\n    this.taps = this.taps.tail;\n    return this;\n  };\n\n  Chunk.prototype.render = function(body, context) {\n    return body(this, context);\n  };\n\n  Chunk.prototype.reference = function(elem, context, auto, filters) {\n    if (typeof elem === 'function') {\n      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);\n      if (elem instanceof Chunk) {\n        return elem;\n      } else {\n        return this.reference(elem, context, auto, filters);\n      }\n    }\n    if (dust.isThenable(elem)) {\n      return this.await(elem, context, null, auto, filters);\n    } else if (dust.isStreamable(elem)) {\n      return this.stream(elem, context, null, auto, filters);\n    } else if (!dust.isEmpty(elem)) {\n      return this.write(dust.filter(elem, auto, filters, context));\n    } else {\n      return this;\n    }\n  };\n\n  Chunk.prototype.section = function(elem, context, bodies, params) {\n    var body = bodies.block,\n        skip = bodies['else'],\n        chunk = this,\n        i, len, head;\n\n    if (typeof elem === 'function' && !dust.isTemplateFn(elem)) {\n      try {\n        elem = elem.apply(context.current(), [this, context, bodies, params]);\n      } catch(err) {\n        dust.log(err, ERROR);\n        return this.setError(err);\n      }\n      // Functions that return chunks are assumed to have handled the chunk manually.\n      // Make that chunk the current one and go to the next method in the chain.\n      if (elem instanceof Chunk) {\n        return elem;\n      }\n    }\n\n    if (dust.isEmptyObject(bodies)) {\n      // No bodies to render, and we've already invoked any function that was available in\n      // hopes of returning a Chunk.\n      return chunk;\n    }\n\n    if (!dust.isEmptyObject(params)) {\n      context = context.push(params);\n    }\n\n    /*\n    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.\n    When elem resolves to a value or object instead of an array, Dust sets the current context to the value\n    and renders the block one time.\n    */\n    if (dust.isArray(elem)) {\n      if (body) {\n        len = elem.length;\n        if (len > 0) {\n          head = context.stack && context.stack.head || {};\n          head.$len = len;\n          for (i = 0; i < len; i++) {\n            head.$idx = i;\n            chunk = body(chunk, context.push(elem[i], i, len));\n          }\n          head.$idx = undefined;\n          head.$len = undefined;\n          return chunk;\n        } else if (skip) {\n          return skip(this, context);\n        }\n      }\n    } else if (dust.isThenable(elem)) {\n      return this.await(elem, context, bodies);\n    } else if (dust.isStreamable(elem)) {\n      return this.stream(elem, context, bodies);\n    } else if (elem === true) {\n     // true is truthy but does not change context\n      if (body) {\n        return body(this, context);\n      }\n    } else if (elem || elem === 0) {\n       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )\n       // zero is truthy\n       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value\n      if (body) {\n        return body(this, context.push(elem));\n      }\n     // nonexistent, scalar false value, scalar empty string, null,\n     // undefined are all falsy\n    } else if (skip) {\n      return skip(this, context);\n    }\n    dust.log('Section without corresponding key in template `' + context.getTemplateName() + '`', DEBUG);\n    return this;\n  };\n\n  Chunk.prototype.exists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (!dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n      dust.log('No block for exists check in template `' + context.getTemplateName() + '`', DEBUG);\n    } else if (skip) {\n      return skip(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.notexists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n      dust.log('No block for not-exists check in template `' + context.getTemplateName() + '`', DEBUG);\n    } else if (skip) {\n      return skip(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.block = function(elem, context, bodies) {\n    var body = elem || bodies.block;\n\n    if (body) {\n      return body(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.partial = function(elem, context, partialContext, params) {\n    var head;\n\n    if(params === undefined) {\n      // Compatibility for < 2.7.0 where `partialContext` did not exist\n      params = partialContext;\n      partialContext = context;\n    }\n\n    if (!dust.isEmptyObject(params)) {\n      partialContext = partialContext.clone();\n      head = partialContext.pop();\n      partialContext = partialContext.push(params)\n                                     .push(head);\n    }\n\n    if (dust.isTemplateFn(elem)) {\n      // The eventual result of evaluating `elem` is a partial name\n      // Load the partial after getting its name and end the async chunk\n      return this.capture(elem, context, function(name, chunk) {\n        partialContext.templateName = name;\n        load(name, chunk, partialContext).end();\n      });\n    } else {\n      partialContext.templateName = elem;\n      return load(elem, this, partialContext);\n    }\n  };\n\n  Chunk.prototype.helper = function(name, context, bodies, params, auto) {\n    var chunk = this,\n        filters = params.filters,\n        ret;\n\n    // Pre-2.7.1 compat: if auto is undefined, it's an old template. Automatically escape\n    if (auto === undefined) {\n      auto = 'h';\n    }\n\n    // handle invalid helpers, similar to invalid filters\n    if(dust.helpers[name]) {\n      try {\n        ret = dust.helpers[name](chunk, context, bodies, params);\n        if (ret instanceof Chunk) {\n          return ret;\n        }\n        if(typeof filters === 'string') {\n          filters = filters.split('|');\n        }\n        if (!dust.isEmptyObject(bodies)) {\n          return chunk.section(ret, context, bodies, params);\n        }\n        // Helpers act slightly differently from functions in context in that they will act as\n        // a reference if they are self-closing (due to grammar limitations)\n        // In the Chunk.await function we check to make sure bodies is null before acting as a reference\n        return chunk.reference(ret, context, auto, filters);\n      } catch(err) {\n        dust.log('Error in helper `' + name + '`: ' + err.message, ERROR);\n        return chunk.setError(err);\n      }\n    } else {\n      dust.log('Helper `' + name + '` does not exist', WARN);\n      return chunk;\n    }\n  };\n\n  /**\n   * Reserve a chunk to be evaluated once a thenable is resolved or rejected\n   * @param thenable {Thenable} the target thenable to await\n   * @param context {Context} context to use to render the deferred chunk\n   * @param bodies {Object} must contain a \"body\", may contain an \"error\"\n   * @param auto {String} automatically apply this filter if the Thenable is a reference\n   * @param filters {Array} apply these filters if the Thenable is a reference\n   * @return {Chunk}\n   */\n  Chunk.prototype.await = function(thenable, context, bodies, auto, filters) {\n    return this.map(function(chunk) {\n      thenable.then(function(data) {\n        if (bodies) {\n          chunk = chunk.section(data, context, bodies);\n        } else {\n          // Actually a reference. Self-closing sections don't render\n          chunk = chunk.reference(data, context, auto, filters);\n        }\n        chunk.end();\n      }, function(err) {\n        var errorBody = bodies && bodies.error;\n        if(errorBody) {\n          chunk.render(errorBody, context.push(err)).end();\n        } else {\n          dust.log('Unhandled promise rejection in `' + context.getTemplateName() + '`', INFO);\n          chunk.end();\n        }\n      });\n    });\n  };\n\n  /**\n   * Reserve a chunk to be evaluated with the contents of a streamable.\n   * Currently an error event will bomb out the stream. Once an error\n   * is received, we push it to an {:error} block if one exists, and log otherwise,\n   * then stop listening to the stream.\n   * @param streamable {Streamable} the target streamable that will emit events\n   * @param context {Context} context to use to render each thunk\n   * @param bodies {Object} must contain a \"body\", may contain an \"error\"\n   * @return {Chunk}\n   */\n  Chunk.prototype.stream = function(stream, context, bodies, auto, filters) {\n    var body = bodies && bodies.block,\n        errorBody = bodies && bodies.error;\n    return this.map(function(chunk) {\n      var ended = false;\n      stream\n        .on('data', function data(thunk) {\n          if(ended) {\n            return;\n          }\n          if(body) {\n            // Fork a new chunk out of the blockstream so that we can flush it independently\n            chunk = chunk.map(function(chunk) {\n              chunk.render(body, context.push(thunk)).end();\n            });\n          } else if(!bodies) {\n            // When actually a reference, don't fork, just write into the master async chunk\n            chunk = chunk.reference(thunk, context, auto, filters);\n          }\n        })\n        .on('error', function error(err) {\n          if(ended) {\n            return;\n          }\n          if(errorBody) {\n            chunk.render(errorBody, context.push(err));\n          } else {\n            dust.log('Unhandled stream error in `' + context.getTemplateName() + '`', INFO);\n          }\n          if(!ended) {\n            ended = true;\n            chunk.end();\n          }\n        })\n        .on('end', function end() {\n          if(!ended) {\n            ended = true;\n            chunk.end();\n          }\n        });\n    });\n  };\n\n  Chunk.prototype.capture = function(body, context, callback) {\n    return this.map(function(chunk) {\n      var stub = new Stub(function(err, out) {\n        if (err) {\n          chunk.setError(err);\n        } else {\n          callback(out, chunk);\n        }\n      });\n      body(stub.head, context).end();\n    });\n  };\n\n  Chunk.prototype.setError = function(err) {\n    this.error = err;\n    this.root.flush();\n    return this;\n  };\n\n  // Chunk aliases\n  for(var f in Chunk.prototype) {\n    if(dust._aliases[f]) {\n      Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];\n    }\n  }\n\n  function Tap(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  Tap.prototype.push = function(tap) {\n    return new Tap(tap, this);\n  };\n\n  Tap.prototype.go = function(value) {\n    var tap = this;\n\n    while(tap) {\n      value = tap.head(value);\n      tap = tap.tail;\n    }\n    return value;\n  };\n\n  var HCHARS = /[&<>\"']/,\n      AMP    = /&/g,\n      LT     = /</g,\n      GT     = />/g,\n      QUOT   = /\\\"/g,\n      SQUOT  = /\\'/g;\n\n  dust.escapeHtml = function(s) {\n    if (typeof s === \"string\" || (s && typeof s.toString === \"function\")) {\n      if (typeof s !== \"string\") {\n        s = s.toString();\n      }\n      if (!HCHARS.test(s)) {\n        return s;\n      }\n      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');\n    }\n    return s;\n  };\n\n  var BS = /\\\\/g,\n      FS = /\\//g,\n      CR = /\\r/g,\n      LS = /\\u2028/g,\n      PS = /\\u2029/g,\n      NL = /\\n/g,\n      LF = /\\f/g,\n      SQ = /'/g,\n      DQ = /\"/g,\n      TB = /\\t/g;\n\n  dust.escapeJs = function(s) {\n    if (typeof s === 'string') {\n      return s\n        .replace(BS, '\\\\\\\\')\n        .replace(FS, '\\\\/')\n        .replace(DQ, '\\\\\"')\n        .replace(SQ, '\\\\\\'')\n        .replace(CR, '\\\\r')\n        .replace(LS, '\\\\u2028')\n        .replace(PS, '\\\\u2029')\n        .replace(NL, '\\\\n')\n        .replace(LF, '\\\\f')\n        .replace(TB, '\\\\t');\n    }\n    return s;\n  };\n\n  dust.escapeJSON = function(o) {\n    if (!JSON) {\n      dust.log('JSON is undefined; could not escape `' + o + '`', WARN);\n      return o;\n    } else {\n      return JSON.stringify(o)\n        .replace(LS, '\\\\u2028')\n        .replace(PS, '\\\\u2029')\n        .replace(LT, '\\\\u003c');\n    }\n  };\n\n  return dust;\n\n}));\n\nif (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define([\"require\", \"dust.core\"], function(require, dust) {\n        dust.onLoad = function(name, cb) {\n            require([name], function() {\n                cb();\n            });\n        };\n        return dust;\n    });\n}\n", "/*! dustjs-linkedin - v2.7.2\n* http://dustjs.com/\n* Copyright (c) 2015 Aleksander Williams; Released under the MIT License */\n!function(a,b){\"function\"==typeof define&&define.amd&&define.amd.dust===!0?define(\"dust.core\",[],b):\"object\"==typeof exports?module.exports=b():a.dust=b()}(this,function(){function getTemplate(a,b){return a?\"function\"==typeof a&&a.template?a.template:dust.isTemplateFn(a)?a:b!==!1?dust.cache[a]:void 0:void 0}function load(a,b,c){if(!a)return b.setError(new Error(\"No template or template name provided to render\"));var d=getTemplate(a,dust.config.cache);return d?d(b,Context.wrap(c,d.templateName)):dust.onLoad?b.map(function(b){function d(a,d){var f;if(a)return b.setError(a);if(f=getTemplate(d,!1)||getTemplate(e,dust.config.cache),!f){if(!dust.compile)return b.setError(new Error(\"Dust compiler not available\"));f=dust.loadSource(dust.compile(d,e))}f(b,Context.wrap(c,f.templateName)).end()}var e=a;3===dust.onLoad.length?dust.onLoad(e,c.options,d):dust.onLoad(e,d)}):b.setError(new Error(\"Template Not Found: \"+a))}function Context(a,b,c,d,e){void 0===a||a instanceof Stack||(a=new Stack(a)),this.stack=a,this.global=b,this.options=c,this.blocks=d,this.templateName=e}function getWithResolvedData(a,b,c){return function(d){return a.push(d)._get(b,c)}}function Stack(a,b,c,d){this.tail=b,this.isObject=a&&\"object\"==typeof a,this.head=a,this.index=c,this.of=d}function Stub(a){this.head=new Chunk(this),this.callback=a,this.out=\"\"}function Stream(){this.head=new Chunk(this)}function Chunk(a,b,c){this.root=a,this.next=b,this.data=[],this.flushable=!1,this.taps=c}function Tap(a,b){this.head=a,this.tail=b}var dust={version:\"2.7.2\"},NONE=\"NONE\",ERROR=\"ERROR\",WARN=\"WARN\",INFO=\"INFO\",DEBUG=\"DEBUG\",EMPTY_FUNC=function(){};dust.config={whitespace:!1,amd:!1,cjs:!1,cache:!0},dust._aliases={write:\"w\",end:\"e\",map:\"m\",render:\"r\",reference:\"f\",section:\"s\",exists:\"x\",notexists:\"nx\",block:\"b\",partial:\"p\",helper:\"h\"},function(){var a,b,c={DEBUG:0,INFO:1,WARN:2,ERROR:3,NONE:4};\"undefined\"!=typeof console&&console.log?(a=console.log,b=\"function\"==typeof a?function(){a.apply(console,arguments)}:function(){a(Array.prototype.slice.apply(arguments).join(\" \"))}):b=EMPTY_FUNC,dust.log=function(a,d){d=d||INFO,c[d]>=c[dust.debugLevel]&&b(\"[DUST:\"+d+\"]\",a)},dust.debugLevel=NONE,\"undefined\"!=typeof process&&process.env&&/\\bdust\\b/.test(process.env.DEBUG)&&(dust.debugLevel=DEBUG)}(),dust.helpers={},dust.cache={},dust.register=function(a,b){a&&(b.templateName=a,dust.config.cache!==!1&&(dust.cache[a]=b))},dust.render=function(a,b,c){var d=new Stub(c).head;try{load(a,d,b).end()}catch(e){d.setError(e)}},dust.stream=function(a,b){var c=new Stream,d=c.head;return dust.nextTick(function(){try{load(a,d,b).end()}catch(c){d.setError(c)}}),c},dust.loadSource=function(source){return eval(source)},dust.isArray=Array.isArray?Array.isArray:function(a){return\"[object Array]\"===Object.prototype.toString.call(a)},dust.nextTick=function(){return function(a){setTimeout(a,0)}}(),dust.isEmpty=function(a){return 0===a?!1:dust.isArray(a)&&!a.length?!0:!a},dust.isEmptyObject=function(a){var b;if(null===a)return!1;if(void 0===a)return!1;if(a.length>0)return!1;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b))return!1;return!0},dust.isTemplateFn=function(a){return\"function\"==typeof a&&a.__dustBody},dust.isThenable=function(a){return a&&\"object\"==typeof a&&\"function\"==typeof a.then},dust.isStreamable=function(a){return a&&\"function\"==typeof a.on&&\"function\"==typeof a.pipe},dust.filter=function(a,b,c,d){var e,f,g,h;if(c)for(e=0,f=c.length;f>e;e++)g=c[e],g.length&&(h=dust.filters[g],\"s\"===g?b=null:\"function\"==typeof h?a=h(a,d):dust.log(\"Invalid filter `\"+g+\"`\",WARN));return b&&(a=dust.filters[b](a,d)),a},dust.filters={h:function(a){return dust.escapeHtml(a)},j:function(a){return dust.escapeJs(a)},u:encodeURI,uc:encodeURIComponent,js:function(a){return dust.escapeJSON(a)},jp:function(a){return JSON?JSON.parse(a):(dust.log(\"JSON is undefined; could not parse `\"+a+\"`\",WARN),a)}},dust.makeBase=dust.context=function(a,b){return new Context(void 0,a,b)},Context.wrap=function(a,b){return a instanceof Context?a:new Context(a,{},{},null,b)},Context.prototype.get=function(a,b){return\"string\"==typeof a&&(\".\"===a[0]&&(b=!0,a=a.substr(1)),a=a.split(\".\")),this._get(b,a)},Context.prototype._get=function(a,b){var c,d,e,f,g,h=this.stack||{},i=1;if(d=b[0],e=b.length,a&&0===e)f=h,h=h.head;else{if(a)h&&(h=h.head?h.head[d]:void 0);else{for(;h&&(!h.isObject||(f=h.head,c=h.head[d],void 0===c));)h=h.tail;h=void 0!==c?c:this.global&&this.global[d]}for(;h&&e>i;){if(dust.isThenable(h))return h.then(getWithResolvedData(this,a,b.slice(i)));f=h,h=h[b[i]],i++}}return\"function\"==typeof h?(g=function(){try{return h.apply(f,arguments)}catch(a){throw dust.log(a,ERROR),a}},g.__dustBody=!!h.__dustBody,g):(void 0===h&&dust.log(\"Cannot find reference `{\"+b.join(\".\")+\"}` in template `\"+this.getTemplateName()+\"`\",INFO),h)},Context.prototype.getPath=function(a,b){return this._get(a,b)},Context.prototype.push=function(a,b,c){return void 0===a?(dust.log(\"Not pushing an undefined variable onto the context\",INFO),this):this.rebase(new Stack(a,this.stack,b,c))},Context.prototype.pop=function(){var a=this.current();return this.stack=this.stack&&this.stack.tail,a},Context.prototype.rebase=function(a){return new Context(a,this.global,this.options,this.blocks,this.getTemplateName())},Context.prototype.clone=function(){var a=this.rebase();return a.stack=this.stack,a},Context.prototype.current=function(){return this.stack&&this.stack.head},Context.prototype.getBlock=function(a){var b,c,d;if(\"function\"==typeof a&&(a=a(new Chunk,this).data.join(\"\")),b=this.blocks,!b)return dust.log(\"No blocks for context `\"+a+\"` in template `\"+this.getTemplateName()+\"`\",DEBUG),!1;for(c=b.length;c--;)if(d=b[c][a])return d;return dust.log(\"Malformed template `\"+this.getTemplateName()+\"` was missing one or more blocks.\"),!1},Context.prototype.shiftBlocks=function(a){var b,c=this.blocks;return a?(b=c?c.concat([a]):[a],new Context(this.stack,this.global,this.options,b,this.getTemplateName())):this},Context.prototype.resolve=function(a){var b;return\"function\"!=typeof a?a:(b=(new Chunk).render(a,this),b instanceof Chunk?b.data.join(\"\"):b)},Context.prototype.getTemplateName=function(){return this.templateName},Stub.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.callback(a.error),dust.log(\"Rendering failed with error `\"+a.error+\"`\",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.out+=a.data.join(\"\"),a=a.next,this.head=a}this.callback(null,this.out)},Stream.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.emit(\"error\",a.error),this.emit(\"end\"),dust.log(\"Streaming failed with error `\"+a.error+\"`\",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.emit(\"data\",a.data.join(\"\")),a=a.next,this.head=a}this.emit(\"end\")},Stream.prototype.emit=function(a,b){var c,d,e=this.events||{},f=e[a]||[];if(!f.length)return dust.log(\"Stream broadcasting, but no listeners for `\"+a+\"`\",DEBUG),!1;for(f=f.slice(0),c=0,d=f.length;d>c;c++)f[c](b);return!0},Stream.prototype.on=function(a,b){var c=this.events=this.events||{},d=c[a]=c[a]||[];return\"function\"!=typeof b?dust.log(\"No callback function provided for `\"+a+\"` event listener\",WARN):d.push(b),this},Stream.prototype.pipe=function(a){if(\"function\"!=typeof a.write||\"function\"!=typeof a.end)return dust.log(\"Incompatible stream passed to `pipe`\",WARN),this;var b=!1;return\"function\"==typeof a.emit&&a.emit(\"pipe\",this),\"function\"==typeof a.on&&a.on(\"error\",function(){b=!0}),this.on(\"data\",function(c){if(!b)try{a.write(c,\"utf8\")}catch(d){dust.log(d,ERROR)}}).on(\"end\",function(){if(!b)try{a.end(),b=!0}catch(c){dust.log(c,ERROR)}})},Chunk.prototype.write=function(a){var b=this.taps;return b&&(a=b.go(a)),this.data.push(a),this},Chunk.prototype.end=function(a){return a&&this.write(a),this.flushable=!0,this.root.flush(),this},Chunk.prototype.map=function(a){var b=new Chunk(this.root,this.next,this.taps),c=new Chunk(this.root,b,this.taps);this.next=c,this.flushable=!0;try{a(c)}catch(d){dust.log(d,ERROR),c.setError(d)}return b},Chunk.prototype.tap=function(a){var b=this.taps;return this.taps=b?b.push(a):new Tap(a),this},Chunk.prototype.untap=function(){return this.taps=this.taps.tail,this},Chunk.prototype.render=function(a,b){return a(this,b)},Chunk.prototype.reference=function(a,b,c,d){return\"function\"==typeof a?(a=a.apply(b.current(),[this,b,null,{auto:c,filters:d}]),a instanceof Chunk?a:this.reference(a,b,c,d)):dust.isThenable(a)?this.await(a,b,null,c,d):dust.isStreamable(a)?this.stream(a,b,null,c,d):dust.isEmpty(a)?this:this.write(dust.filter(a,c,d,b))},Chunk.prototype.section=function(a,b,c,d){var e,f,g,h=c.block,i=c[\"else\"],j=this;if(\"function\"==typeof a&&!dust.isTemplateFn(a)){try{a=a.apply(b.current(),[this,b,c,d])}catch(k){return dust.log(k,ERROR),this.setError(k)}if(a instanceof Chunk)return a}if(dust.isEmptyObject(c))return j;if(dust.isEmptyObject(d)||(b=b.push(d)),dust.isArray(a)){if(h){if(f=a.length,f>0){for(g=b.stack&&b.stack.head||{},g.$len=f,e=0;f>e;e++)g.$idx=e,j=h(j,b.push(a[e],e,f));return g.$idx=void 0,g.$len=void 0,j}if(i)return i(this,b)}}else{if(dust.isThenable(a))return this.await(a,b,c);if(dust.isStreamable(a))return this.stream(a,b,c);if(a===!0){if(h)return h(this,b)}else if(a||0===a){if(h)return h(this,b.push(a))}else if(i)return i(this,b)}return dust.log(\"Section without corresponding key in template `\"+b.getTemplateName()+\"`\",DEBUG),this},Chunk.prototype.exists=function(a,b,c){var d=c.block,e=c[\"else\"];if(dust.isEmpty(a)){if(e)return e(this,b)}else{if(d)return d(this,b);dust.log(\"No block for exists check in template `\"+b.getTemplateName()+\"`\",DEBUG)}return this},Chunk.prototype.notexists=function(a,b,c){var d=c.block,e=c[\"else\"];if(dust.isEmpty(a)){if(d)return d(this,b);dust.log(\"No block for not-exists check in template `\"+b.getTemplateName()+\"`\",DEBUG)}else if(e)return e(this,b);return this},Chunk.prototype.block=function(a,b,c){var d=a||c.block;return d?d(this,b):this},Chunk.prototype.partial=function(a,b,c,d){var e;return void 0===d&&(d=c,c=b),dust.isEmptyObject(d)||(c=c.clone(),e=c.pop(),c=c.push(d).push(e)),dust.isTemplateFn(a)?this.capture(a,b,function(a,b){c.templateName=a,load(a,b,c).end()}):(c.templateName=a,load(a,this,c))},Chunk.prototype.helper=function(a,b,c,d,e){var f,g=this,h=d.filters;if(void 0===e&&(e=\"h\"),!dust.helpers[a])return dust.log(\"Helper `\"+a+\"` does not exist\",WARN),g;try{return f=dust.helpers[a](g,b,c,d),f instanceof Chunk?f:(\"string\"==typeof h&&(h=h.split(\"|\")),dust.isEmptyObject(c)?g.reference(f,b,e,h):g.section(f,b,c,d))}catch(i){return dust.log(\"Error in helper `\"+a+\"`: \"+i.message,ERROR),g.setError(i)}},Chunk.prototype.await=function(a,b,c,d,e){return this.map(function(f){a.then(function(a){f=c?f.section(a,b,c):f.reference(a,b,d,e),f.end()},function(a){var d=c&&c.error;d?f.render(d,b.push(a)).end():(dust.log(\"Unhandled promise rejection in `\"+b.getTemplateName()+\"`\",INFO),f.end())})})},Chunk.prototype.stream=function(a,b,c,d,e){var f=c&&c.block,g=c&&c.error;return this.map(function(h){var i=!1;a.on(\"data\",function(a){i||(f?h=h.map(function(c){c.render(f,b.push(a)).end()}):c||(h=h.reference(a,b,d,e)))}).on(\"error\",function(a){i||(g?h.render(g,b.push(a)):dust.log(\"Unhandled stream error in `\"+b.getTemplateName()+\"`\",INFO),i||(i=!0,h.end()))}).on(\"end\",function(){i||(i=!0,h.end())})})},Chunk.prototype.capture=function(a,b,c){return this.map(function(d){var e=new Stub(function(a,b){a?d.setError(a):c(b,d)});a(e.head,b).end()})},Chunk.prototype.setError=function(a){return this.error=a,this.root.flush(),this};for(var f in Chunk.prototype)dust._aliases[f]&&(Chunk.prototype[dust._aliases[f]]=Chunk.prototype[f]);Tap.prototype.push=function(a){return new Tap(a,this)},Tap.prototype.go=function(a){for(var b=this;b;)a=b.head(a),b=b.tail;return a};var HCHARS=/[&<>\"']/,AMP=/&/g,LT=/</g,GT=/>/g,QUOT=/\\\"/g,SQUOT=/\\'/g;dust.escapeHtml=function(a){return\"string\"==typeof a||a&&\"function\"==typeof a.toString?(\"string\"!=typeof a&&(a=a.toString()),HCHARS.test(a)?a.replace(AMP,\"&amp;\").replace(LT,\"&lt;\").replace(GT,\"&gt;\").replace(QUOT,\"&quot;\").replace(SQUOT,\"&#39;\"):a):a};var BS=/\\\\/g,FS=/\\//g,CR=/\\r/g,LS=/\\u2028/g,PS=/\\u2029/g,NL=/\\n/g,LF=/\\f/g,SQ=/'/g,DQ=/\"/g,TB=/\\t/g;return dust.escapeJs=function(a){return\"string\"==typeof a?a.replace(BS,\"\\\\\\\\\").replace(FS,\"\\\\/\").replace(DQ,'\\\\\"').replace(SQ,\"\\\\'\").replace(CR,\"\\\\r\").replace(LS,\"\\\\u2028\").replace(PS,\"\\\\u2029\").replace(NL,\"\\\\n\").replace(LF,\"\\\\f\").replace(TB,\"\\\\t\"):a},dust.escapeJSON=function(a){return JSON?JSON.stringify(a).replace(LS,\"\\\\u2028\").replace(PS,\"\\\\u2029\").replace(LT,\"\\\\u003c\"):(dust.log(\"JSON is undefined; could not escape `\"+a+\"`\",WARN),a)},dust}),\"function\"==typeof define&&define.amd&&define.amd.dust===!0&&define([\"require\",\"dust.core\"],function(require,dust){return dust.onLoad=function(a,b){require([a],function(){b()})},dust});", "/*! dustjs-linkedin - v2.7.2\n* http://dustjs.com/\n* Copyright (c) 2015 Aleksander Williams; Released under the MIT License */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd && define.amd.dust === true) {\n    define('dust.core', [], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.dust = factory();\n  }\n}(this, function() {\n  var dust = {\n        \"version\": \"2.7.2\"\n      },\n      NONE = 'NONE', ERROR = 'ERROR', WARN = 'WARN', INFO = 'INFO', DEBUG = 'DEBUG',\n      EMPTY_FUNC = function() {};\n\n  dust.config = {\n    whitespace: false,\n    amd: false,\n    cjs: false,\n    cache: true\n  };\n\n  // Directive aliases to minify code\n  dust._aliases = {\n    \"write\": \"w\",\n    \"end\": \"e\",\n    \"map\": \"m\",\n    \"render\": \"r\",\n    \"reference\": \"f\",\n    \"section\": \"s\",\n    \"exists\": \"x\",\n    \"notexists\": \"nx\",\n    \"block\": \"b\",\n    \"partial\": \"p\",\n    \"helper\": \"h\"\n  };\n\n  (function initLogging() {\n    /*global process, console*/\n    var loggingLevels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, NONE: 4 },\n        consoleLog,\n        log;\n\n    if (typeof console !== 'undefined' && console.log) {\n      consoleLog = console.log;\n      if(typeof consoleLog === 'function') {\n        log = function() {\n          consoleLog.apply(console, arguments);\n        };\n      } else {\n        log = function() {\n          consoleLog(Array.prototype.slice.apply(arguments).join(' '));\n        };\n      }\n    } else {\n      log = EMPTY_FUNC;\n    }\n\n    /**\n     * Filters messages based on `dust.debugLevel`.\n     * This default implementation will print to the console if it exists.\n     * @param {String|Error} message the message to print/throw\n     * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)\n     * @public\n     */\n    dust.log = function(message, type) {\n      type = type || INFO;\n      if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {\n        log('[DUST:' + type + ']', message);\n      }\n    };\n\n    dust.debugLevel = NONE;\n    if(typeof process !== 'undefined' && process.env && /\\bdust\\b/.test(process.env.DEBUG)) {\n      dust.debugLevel = DEBUG;\n    }\n\n  }());\n\n  dust.helpers = {};\n\n  dust.cache = {};\n\n  dust.register = function(name, tmpl) {\n    if (!name) {\n      return;\n    }\n    tmpl.templateName = name;\n    if (dust.config.cache !== false) {\n      dust.cache[name] = tmpl;\n    }\n  };\n\n  dust.render = function(nameOrTemplate, context, callback) {\n    var chunk = new Stub(callback).head;\n    try {\n      load(nameOrTemplate, chunk, context).end();\n    } catch (err) {\n      chunk.setError(err);\n    }\n  };\n\n  dust.stream = function(nameOrTemplate, context) {\n    var stream = new Stream(),\n        chunk = stream.head;\n    dust.nextTick(function() {\n      try {\n        load(nameOrTemplate, chunk, context).end();\n      } catch (err) {\n        chunk.setError(err);\n      }\n    });\n    return stream;\n  };\n\n  /**\n   * Extracts a template function (body_0) from whatever is passed.\n   * @param nameOrTemplate {*} Could be:\n   *   - the name of a template to load from cache\n   *   - a CommonJS-compiled template (a function with a `template` property)\n   *   - a template function\n   * @param loadFromCache {Boolean} if false, don't look in the cache\n   * @return {Function} a template function, if found\n   */\n  function getTemplate(nameOrTemplate, loadFromCache/*=true*/) {\n    if(!nameOrTemplate) {\n      return;\n    }\n    if(typeof nameOrTemplate === 'function' && nameOrTemplate.template) {\n      // Sugar away CommonJS module templates\n      return nameOrTemplate.template;\n    }\n    if(dust.isTemplateFn(nameOrTemplate)) {\n      // Template functions passed directly\n      return nameOrTemplate;\n    }\n    if(loadFromCache !== false) {\n      // Try loading a template with this name from cache\n      return dust.cache[nameOrTemplate];\n    }\n  }\n\n  function load(nameOrTemplate, chunk, context) {\n    if(!nameOrTemplate) {\n      return chunk.setError(new Error('No template or template name provided to render'));\n    }\n\n    var template = getTemplate(nameOrTemplate, dust.config.cache);\n\n    if (template) {\n      return template(chunk, Context.wrap(context, template.templateName));\n    } else {\n      if (dust.onLoad) {\n        return chunk.map(function(chunk) {\n          // Alias just so it's easier to read that this would always be a name\n          var name = nameOrTemplate;\n          // Three possible scenarios for a successful callback:\n          //   - `require(nameOrTemplate)(dust); cb()`\n          //   - `src = readFile('src.dust'); cb(null, src)`\n          //   - `compiledTemplate = require(nameOrTemplate)(dust); cb(null, compiledTemplate)`\n          function done(err, srcOrTemplate) {\n            var template;\n            if (err) {\n              return chunk.setError(err);\n            }\n            // Prefer a template that is passed via callback over the cached version.\n            template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);\n            if (!template) {\n              // It's a template string, compile it and register under `name`\n              if(dust.compile) {\n                template = dust.loadSource(dust.compile(srcOrTemplate, name));\n              } else {\n                return chunk.setError(new Error('Dust compiler not available'));\n              }\n            }\n            template(chunk, Context.wrap(context, template.templateName)).end();\n          }\n\n          if(dust.onLoad.length === 3) {\n            dust.onLoad(name, context.options, done);\n          } else {\n            dust.onLoad(name, done);\n          }\n        });\n      }\n      return chunk.setError(new Error('Template Not Found: ' + nameOrTemplate));\n    }\n  }\n\n  dust.loadSource = function(source) {\n    /*jshint evil:true*/\n    return eval(source);\n  };\n\n  if (Array.isArray) {\n    dust.isArray = Array.isArray;\n  } else {\n    dust.isArray = function(arr) {\n      return Object.prototype.toString.call(arr) === '[object Array]';\n    };\n  }\n\n  dust.nextTick = (function() {\n    return function(callback) {\n      setTimeout(callback, 0);\n    };\n  })();\n\n  /**\n   * Dust has its own rules for what is \"empty\"-- which is not the same as falsy.\n   * Empty arrays, null, and undefined are empty\n   */\n  dust.isEmpty = function(value) {\n    if (value === 0) {\n      return false;\n    }\n    if (dust.isArray(value) && !value.length) {\n      return true;\n    }\n    return !value;\n  };\n\n  dust.isEmptyObject = function(obj) {\n    var key;\n    if (obj === null) {\n      return false;\n    }\n    if (obj === undefined) {\n      return false;\n    }\n    if (obj.length > 0) {\n      return false;\n    }\n    for (key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  dust.isTemplateFn = function(elem) {\n    return typeof elem === 'function' &&\n           elem.__dustBody;\n  };\n\n  /**\n   * Decide somewhat-naively if something is a Thenable.\n   * @param elem {*} object to inspect\n   * @return {Boolean} is `elem` a Thenable?\n   */\n  dust.isThenable = function(elem) {\n    return elem &&\n           typeof elem === 'object' &&\n           typeof elem.then === 'function';\n  };\n\n  /**\n   * Decide very naively if something is a Stream.\n   * @param elem {*} object to inspect\n   * @return {Boolean} is `elem` a Stream?\n   */\n  dust.isStreamable = function(elem) {\n    return elem &&\n           typeof elem.on === 'function' &&\n           typeof elem.pipe === 'function';\n  };\n\n  // apply the filter chain and return the output string\n  dust.filter = function(string, auto, filters, context) {\n    var i, len, name, filter;\n    if (filters) {\n      for (i = 0, len = filters.length; i < len; i++) {\n        name = filters[i];\n        if (!name.length) {\n          continue;\n        }\n        filter = dust.filters[name];\n        if (name === 's') {\n          auto = null;\n        } else if (typeof filter === 'function') {\n          string = filter(string, context);\n        } else {\n          dust.log('Invalid filter `' + name + '`', WARN);\n        }\n      }\n    }\n    // by default always apply the h filter, unless asked to unescape with |s\n    if (auto) {\n      string = dust.filters[auto](string, context);\n    }\n    return string;\n  };\n\n  dust.filters = {\n    h: function(value) { return dust.escapeHtml(value); },\n    j: function(value) { return dust.escapeJs(value); },\n    u: encodeURI,\n    uc: encodeURIComponent,\n    js: function(value) { return dust.escapeJSON(value); },\n    jp: function(value) {\n      if (!JSON) {dust.log('JSON is undefined; could not parse `' + value + '`', WARN);\n        return value;\n      } else {\n        return JSON.parse(value);\n      }\n    }\n  };\n\n  function Context(stack, global, options, blocks, templateName) {\n    if(stack !== undefined && !(stack instanceof Stack)) {\n      stack = new Stack(stack);\n    }\n    this.stack = stack;\n    this.global = global;\n    this.options = options;\n    this.blocks = blocks;\n    this.templateName = templateName;\n  }\n\n  dust.makeBase = dust.context = function(global, options) {\n    return new Context(undefined, global, options);\n  };\n\n  /**\n   * Factory function that creates a closure scope around a Thenable-callback.\n   * Returns a function that can be passed to a Thenable that will resume a\n   * Context lookup once the Thenable resolves with new data, adding that new\n   * data to the lookup stack.\n   */\n  function getWithResolvedData(ctx, cur, down) {\n    return function(data) {\n      return ctx.push(data)._get(cur, down);\n    };\n  }\n\n  Context.wrap = function(context, name) {\n    if (context instanceof Context) {\n      return context;\n    }\n    return new Context(context, {}, {}, null, name);\n  };\n\n  /**\n   * Public API for getting a value from the context.\n   * @method get\n   * @param {string|array} path The path to the value. Supported formats are:\n   * 'key'\n   * 'path.to.key'\n   * '.path.to.key'\n   * ['path', 'to', 'key']\n   * ['key']\n   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the\n   * current context (true), or if get should search in parent contexts as well (false).\n   * @public\n   * @returns {string|object}\n   */\n  Context.prototype.get = function(path, cur) {\n    if (typeof path === 'string') {\n      if (path[0] === '.') {\n        cur = true;\n        path = path.substr(1);\n      }\n      path = path.split('.');\n    }\n    return this._get(cur, path);\n  };\n\n  /**\n   * Get a value from the context\n   * @method _get\n   * @param {boolean} cur Get only from the current context\n   * @param {array} down An array of each step in the path\n   * @private\n   * @return {string | object}\n   */\n  Context.prototype._get = function(cur, down) {\n    var ctx = this.stack || {},\n        i = 1,\n        value, first, len, ctxThis, fn;\n\n    first = down[0];\n    len = down.length;\n\n    if (cur && len === 0) {\n      ctxThis = ctx;\n      ctx = ctx.head;\n    } else {\n      if (!cur) {\n        // Search up the stack for the first value\n        while (ctx) {\n          if (ctx.isObject) {\n            ctxThis = ctx.head;\n            value = ctx.head[first];\n            if (value !== undefined) {\n              break;\n            }\n          }\n          ctx = ctx.tail;\n        }\n\n        // Try looking in the global context if we haven't found anything yet\n        if (value !== undefined) {\n          ctx = value;\n        } else {\n          ctx = this.global && this.global[first];\n        }\n      } else if (ctx) {\n        // if scope is limited by a leading dot, don't search up the tree\n        if(ctx.head) {\n          ctx = ctx.head[first];\n        } else {\n          // context's head is empty, value we are searching for is not defined\n          ctx = undefined;\n        }\n      }\n\n      while (ctx && i < len) {\n        if (dust.isThenable(ctx)) {\n          // Bail early by returning a Thenable for the remainder of the search tree\n          return ctx.then(getWithResolvedData(this, cur, down.slice(i)));\n        }\n        ctxThis = ctx;\n        ctx = ctx[down[i]];\n        i++;\n      }\n    }\n\n    if (typeof ctx === 'function') {\n      fn = function() {\n        try {\n          return ctx.apply(ctxThis, arguments);\n        } catch (err) {\n          dust.log(err, ERROR);\n          throw err;\n        }\n      };\n      fn.__dustBody = !!ctx.__dustBody;\n      return fn;\n    } else {\n      if (ctx === undefined) {\n        dust.log('Cannot find reference `{' + down.join('.') + '}` in template `' + this.getTemplateName() + '`', INFO);\n      }\n      return ctx;\n    }\n  };\n\n  Context.prototype.getPath = function(cur, down) {\n    return this._get(cur, down);\n  };\n\n  Context.prototype.push = function(head, idx, len) {\n    if(head === undefined) {\n      dust.log(\"Not pushing an undefined variable onto the context\", INFO);\n      return this;\n    }\n    return this.rebase(new Stack(head, this.stack, idx, len));\n  };\n\n  Context.prototype.pop = function() {\n    var head = this.current();\n    this.stack = this.stack && this.stack.tail;\n    return head;\n  };\n\n  Context.prototype.rebase = function(head) {\n    return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());\n  };\n\n  Context.prototype.clone = function() {\n    var context = this.rebase();\n    context.stack = this.stack;\n    return context;\n  };\n\n  Context.prototype.current = function() {\n    return this.stack && this.stack.head;\n  };\n\n  Context.prototype.getBlock = function(key) {\n    var blocks, len, fn;\n\n    if (typeof key === 'function') {\n      key = key(new Chunk(), this).data.join('');\n    }\n\n    blocks = this.blocks;\n\n    if (!blocks) {\n      dust.log('No blocks for context `' + key + '` in template `' + this.getTemplateName() + '`', DEBUG);\n      return false;\n    }\n\n    len = blocks.length;\n    while (len--) {\n      fn = blocks[len][key];\n      if (fn) {\n        return fn;\n      }\n    }\n\n    dust.log('Malformed template `' + this.getTemplateName() + '` was missing one or more blocks.');\n    return false;\n  };\n\n  Context.prototype.shiftBlocks = function(locals) {\n    var blocks = this.blocks,\n        newBlocks;\n\n    if (locals) {\n      if (!blocks) {\n        newBlocks = [locals];\n      } else {\n        newBlocks = blocks.concat([locals]);\n      }\n      return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());\n    }\n    return this;\n  };\n\n  Context.prototype.resolve = function(body) {\n    var chunk;\n\n    if(typeof body !== 'function') {\n      return body;\n    }\n    chunk = new Chunk().render(body, this);\n    if(chunk instanceof Chunk) {\n      return chunk.data.join(''); // ie7 perf\n    }\n    return chunk;\n  };\n\n  Context.prototype.getTemplateName = function() {\n    return this.templateName;\n  };\n\n  function Stack(head, tail, idx, len) {\n    this.tail = tail;\n    this.isObject = head && typeof head === 'object';\n    this.head = head;\n    this.index = idx;\n    this.of = len;\n  }\n\n  function Stub(callback) {\n    this.head = new Chunk(this);\n    this.callback = callback;\n    this.out = '';\n  }\n\n  Stub.prototype.flush = function() {\n    var chunk = this.head;\n\n    while (chunk) {\n      if (chunk.flushable) {\n        this.out += chunk.data.join(''); //ie7 perf\n      } else if (chunk.error) {\n        this.callback(chunk.error);\n        dust.log('Rendering failed with error `' + chunk.error + '`', ERROR);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.callback(null, this.out);\n  };\n\n  /**\n   * Creates an interface sort of like a Streams2 ReadableStream.\n   */\n  function Stream() {\n    this.head = new Chunk(this);\n  }\n\n  Stream.prototype.flush = function() {\n    var chunk = this.head;\n\n    while(chunk) {\n      if (chunk.flushable) {\n        this.emit('data', chunk.data.join('')); //ie7 perf\n      } else if (chunk.error) {\n        this.emit('error', chunk.error);\n        this.emit('end');\n        dust.log('Streaming failed with error `' + chunk.error + '`', ERROR);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.emit('end');\n  };\n\n  /**\n   * Executes listeners for `type` by passing data. Note that this is different from a\n   * Node stream, which can pass an arbitrary number of arguments\n   * @return `true` if event had listeners, `false` otherwise\n   */\n  Stream.prototype.emit = function(type, data) {\n    var events = this.events || {},\n        handlers = events[type] || [],\n        i, l;\n\n    if (!handlers.length) {\n      dust.log('Stream broadcasting, but no listeners for `' + type + '`', DEBUG);\n      return false;\n    }\n\n    handlers = handlers.slice(0);\n    for (i = 0, l = handlers.length; i < l; i++) {\n      handlers[i](data);\n    }\n    return true;\n  };\n\n  Stream.prototype.on = function(type, callback) {\n    var events = this.events = this.events || {},\n        handlers = events[type] = events[type] || [];\n\n    if(typeof callback !== 'function') {\n      dust.log('No callback function provided for `' + type + '` event listener', WARN);\n    } else {\n      handlers.push(callback);\n    }\n    return this;\n  };\n\n  /**\n   * Pipes to a WritableStream. Note that backpressure isn't implemented,\n   * so we just write as fast as we can.\n   * @param stream {WritableStream}\n   * @return self\n   */\n  Stream.prototype.pipe = function(stream) {\n    if(typeof stream.write !== 'function' ||\n       typeof stream.end !== 'function') {\n      dust.log('Incompatible stream passed to `pipe`', WARN);\n      return this;\n    }\n\n    var destEnded = false;\n\n    if(typeof stream.emit === 'function') {\n      stream.emit('pipe', this);\n    }\n\n    if(typeof stream.on === 'function') {\n      stream.on('error', function() {\n        destEnded = true;\n      });\n    }\n\n    return this\n    .on('data', function(data) {\n      if(destEnded) {\n        return;\n      }\n      try {\n        stream.write(data, 'utf8');\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    })\n    .on('end', function() {\n      if(destEnded) {\n        return;\n      }\n      try {\n        stream.end();\n        destEnded = true;\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    });\n  };\n\n  function Chunk(root, next, taps) {\n    this.root = root;\n    this.next = next;\n    this.data = []; //ie7 perf\n    this.flushable = false;\n    this.taps = taps;\n  }\n\n  Chunk.prototype.write = function(data) {\n    var taps = this.taps;\n\n    if (taps) {\n      data = taps.go(data);\n    }\n    this.data.push(data);\n    return this;\n  };\n\n  Chunk.prototype.end = function(data) {\n    if (data) {\n      this.write(data);\n    }\n    this.flushable = true;\n    this.root.flush();\n    return this;\n  };\n\n  Chunk.prototype.map = function(callback) {\n    var cursor = new Chunk(this.root, this.next, this.taps),\n        branch = new Chunk(this.root, cursor, this.taps);\n\n    this.next = branch;\n    this.flushable = true;\n    try {\n      callback(branch);\n    } catch(err) {\n      dust.log(err, ERROR);\n      branch.setError(err);\n    }\n    return cursor;\n  };\n\n  Chunk.prototype.tap = function(tap) {\n    var taps = this.taps;\n\n    if (taps) {\n      this.taps = taps.push(tap);\n    } else {\n      this.taps = new Tap(tap);\n    }\n    return this;\n  };\n\n  Chunk.prototype.untap = function() {\n    this.taps = this.taps.tail;\n    return this;\n  };\n\n  Chunk.prototype.render = function(body, context) {\n    return body(this, context);\n  };\n\n  Chunk.prototype.reference = function(elem, context, auto, filters) {\n    if (typeof elem === 'function') {\n      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);\n      if (elem instanceof Chunk) {\n        return elem;\n      } else {\n        return this.reference(elem, context, auto, filters);\n      }\n    }\n    if (dust.isThenable(elem)) {\n      return this.await(elem, context, null, auto, filters);\n    } else if (dust.isStreamable(elem)) {\n      return this.stream(elem, context, null, auto, filters);\n    } else if (!dust.isEmpty(elem)) {\n      return this.write(dust.filter(elem, auto, filters, context));\n    } else {\n      return this;\n    }\n  };\n\n  Chunk.prototype.section = function(elem, context, bodies, params) {\n    var body = bodies.block,\n        skip = bodies['else'],\n        chunk = this,\n        i, len, head;\n\n    if (typeof elem === 'function' && !dust.isTemplateFn(elem)) {\n      try {\n        elem = elem.apply(context.current(), [this, context, bodies, params]);\n      } catch(err) {\n        dust.log(err, ERROR);\n        return this.setError(err);\n      }\n      // Functions that return chunks are assumed to have handled the chunk manually.\n      // Make that chunk the current one and go to the next method in the chain.\n      if (elem instanceof Chunk) {\n        return elem;\n      }\n    }\n\n    if (dust.isEmptyObject(bodies)) {\n      // No bodies to render, and we've already invoked any function that was available in\n      // hopes of returning a Chunk.\n      return chunk;\n    }\n\n    if (!dust.isEmptyObject(params)) {\n      context = context.push(params);\n    }\n\n    /*\n    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.\n    When elem resolves to a value or object instead of an array, Dust sets the current context to the value\n    and renders the block one time.\n    */\n    if (dust.isArray(elem)) {\n      if (body) {\n        len = elem.length;\n        if (len > 0) {\n          head = context.stack && context.stack.head || {};\n          head.$len = len;\n          for (i = 0; i < len; i++) {\n            head.$idx = i;\n            chunk = body(chunk, context.push(elem[i], i, len));\n          }\n          head.$idx = undefined;\n          head.$len = undefined;\n          return chunk;\n        } else if (skip) {\n          return skip(this, context);\n        }\n      }\n    } else if (dust.isThenable(elem)) {\n      return this.await(elem, context, bodies);\n    } else if (dust.isStreamable(elem)) {\n      return this.stream(elem, context, bodies);\n    } else if (elem === true) {\n     // true is truthy but does not change context\n      if (body) {\n        return body(this, context);\n      }\n    } else if (elem || elem === 0) {\n       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )\n       // zero is truthy\n       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value\n      if (body) {\n        return body(this, context.push(elem));\n      }\n     // nonexistent, scalar false value, scalar empty string, null,\n     // undefined are all falsy\n    } else if (skip) {\n      return skip(this, context);\n    }\n    dust.log('Section without corresponding key in template `' + context.getTemplateName() + '`', DEBUG);\n    return this;\n  };\n\n  Chunk.prototype.exists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (!dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n      dust.log('No block for exists check in template `' + context.getTemplateName() + '`', DEBUG);\n    } else if (skip) {\n      return skip(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.notexists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n      dust.log('No block for not-exists check in template `' + context.getTemplateName() + '`', DEBUG);\n    } else if (skip) {\n      return skip(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.block = function(elem, context, bodies) {\n    var body = elem || bodies.block;\n\n    if (body) {\n      return body(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.partial = function(elem, context, partialContext, params) {\n    var head;\n\n    if(params === undefined) {\n      // Compatibility for < 2.7.0 where `partialContext` did not exist\n      params = partialContext;\n      partialContext = context;\n    }\n\n    if (!dust.isEmptyObject(params)) {\n      partialContext = partialContext.clone();\n      head = partialContext.pop();\n      partialContext = partialContext.push(params)\n                                     .push(head);\n    }\n\n    if (dust.isTemplateFn(elem)) {\n      // The eventual result of evaluating `elem` is a partial name\n      // Load the partial after getting its name and end the async chunk\n      return this.capture(elem, context, function(name, chunk) {\n        partialContext.templateName = name;\n        load(name, chunk, partialContext).end();\n      });\n    } else {\n      partialContext.templateName = elem;\n      return load(elem, this, partialContext);\n    }\n  };\n\n  Chunk.prototype.helper = function(name, context, bodies, params, auto) {\n    var chunk = this,\n        filters = params.filters,\n        ret;\n\n    // Pre-2.7.1 compat: if auto is undefined, it's an old template. Automatically escape\n    if (auto === undefined) {\n      auto = 'h';\n    }\n\n    // handle invalid helpers, similar to invalid filters\n    if(dust.helpers[name]) {\n      try {\n        ret = dust.helpers[name](chunk, context, bodies, params);\n        if (ret instanceof Chunk) {\n          return ret;\n        }\n        if(typeof filters === 'string') {\n          filters = filters.split('|');\n        }\n        if (!dust.isEmptyObject(bodies)) {\n          return chunk.section(ret, context, bodies, params);\n        }\n        // Helpers act slightly differently from functions in context in that they will act as\n        // a reference if they are self-closing (due to grammar limitations)\n        // In the Chunk.await function we check to make sure bodies is null before acting as a reference\n        return chunk.reference(ret, context, auto, filters);\n      } catch(err) {\n        dust.log('Error in helper `' + name + '`: ' + err.message, ERROR);\n        return chunk.setError(err);\n      }\n    } else {\n      dust.log('Helper `' + name + '` does not exist', WARN);\n      return chunk;\n    }\n  };\n\n  /**\n   * Reserve a chunk to be evaluated once a thenable is resolved or rejected\n   * @param thenable {Thenable} the target thenable to await\n   * @param context {Context} context to use to render the deferred chunk\n   * @param bodies {Object} must contain a \"body\", may contain an \"error\"\n   * @param auto {String} automatically apply this filter if the Thenable is a reference\n   * @param filters {Array} apply these filters if the Thenable is a reference\n   * @return {Chunk}\n   */\n  Chunk.prototype.await = function(thenable, context, bodies, auto, filters) {\n    return this.map(function(chunk) {\n      thenable.then(function(data) {\n        if (bodies) {\n          chunk = chunk.section(data, context, bodies);\n        } else {\n          // Actually a reference. Self-closing sections don't render\n          chunk = chunk.reference(data, context, auto, filters);\n        }\n        chunk.end();\n      }, function(err) {\n        var errorBody = bodies && bodies.error;\n        if(errorBody) {\n          chunk.render(errorBody, context.push(err)).end();\n        } else {\n          dust.log('Unhandled promise rejection in `' + context.getTemplateName() + '`', INFO);\n          chunk.end();\n        }\n      });\n    });\n  };\n\n  /**\n   * Reserve a chunk to be evaluated with the contents of a streamable.\n   * Currently an error event will bomb out the stream. Once an error\n   * is received, we push it to an {:error} block if one exists, and log otherwise,\n   * then stop listening to the stream.\n   * @param streamable {Streamable} the target streamable that will emit events\n   * @param context {Context} context to use to render each thunk\n   * @param bodies {Object} must contain a \"body\", may contain an \"error\"\n   * @return {Chunk}\n   */\n  Chunk.prototype.stream = function(stream, context, bodies, auto, filters) {\n    var body = bodies && bodies.block,\n        errorBody = bodies && bodies.error;\n    return this.map(function(chunk) {\n      var ended = false;\n      stream\n        .on('data', function data(thunk) {\n          if(ended) {\n            return;\n          }\n          if(body) {\n            // Fork a new chunk out of the blockstream so that we can flush it independently\n            chunk = chunk.map(function(chunk) {\n              chunk.render(body, context.push(thunk)).end();\n            });\n          } else if(!bodies) {\n            // When actually a reference, don't fork, just write into the master async chunk\n            chunk = chunk.reference(thunk, context, auto, filters);\n          }\n        })\n        .on('error', function error(err) {\n          if(ended) {\n            return;\n          }\n          if(errorBody) {\n            chunk.render(errorBody, context.push(err));\n          } else {\n            dust.log('Unhandled stream error in `' + context.getTemplateName() + '`', INFO);\n          }\n          if(!ended) {\n            ended = true;\n            chunk.end();\n          }\n        })\n        .on('end', function end() {\n          if(!ended) {\n            ended = true;\n            chunk.end();\n          }\n        });\n    });\n  };\n\n  Chunk.prototype.capture = function(body, context, callback) {\n    return this.map(function(chunk) {\n      var stub = new Stub(function(err, out) {\n        if (err) {\n          chunk.setError(err);\n        } else {\n          callback(out, chunk);\n        }\n      });\n      body(stub.head, context).end();\n    });\n  };\n\n  Chunk.prototype.setError = function(err) {\n    this.error = err;\n    this.root.flush();\n    return this;\n  };\n\n  // Chunk aliases\n  for(var f in Chunk.prototype) {\n    if(dust._aliases[f]) {\n      Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];\n    }\n  }\n\n  function Tap(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  Tap.prototype.push = function(tap) {\n    return new Tap(tap, this);\n  };\n\n  Tap.prototype.go = function(value) {\n    var tap = this;\n\n    while(tap) {\n      value = tap.head(value);\n      tap = tap.tail;\n    }\n    return value;\n  };\n\n  var HCHARS = /[&<>\"']/,\n      AMP    = /&/g,\n      LT     = /</g,\n      GT     = />/g,\n      QUOT   = /\\\"/g,\n      SQUOT  = /\\'/g;\n\n  dust.escapeHtml = function(s) {\n    if (typeof s === \"string\" || (s && typeof s.toString === \"function\")) {\n      if (typeof s !== \"string\") {\n        s = s.toString();\n      }\n      if (!HCHARS.test(s)) {\n        return s;\n      }\n      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');\n    }\n    return s;\n  };\n\n  var BS = /\\\\/g,\n      FS = /\\//g,\n      CR = /\\r/g,\n      LS = /\\u2028/g,\n      PS = /\\u2029/g,\n      NL = /\\n/g,\n      LF = /\\f/g,\n      SQ = /'/g,\n      DQ = /\"/g,\n      TB = /\\t/g;\n\n  dust.escapeJs = function(s) {\n    if (typeof s === 'string') {\n      return s\n        .replace(BS, '\\\\\\\\')\n        .replace(FS, '\\\\/')\n        .replace(DQ, '\\\\\"')\n        .replace(SQ, '\\\\\\'')\n        .replace(CR, '\\\\r')\n        .replace(LS, '\\\\u2028')\n        .replace(PS, '\\\\u2029')\n        .replace(NL, '\\\\n')\n        .replace(LF, '\\\\f')\n        .replace(TB, '\\\\t');\n    }\n    return s;\n  };\n\n  dust.escapeJSON = function(o) {\n    if (!JSON) {\n      dust.log('JSON is undefined; could not escape `' + o + '`', WARN);\n      return o;\n    } else {\n      return JSON.stringify(o)\n        .replace(LS, '\\\\u2028')\n        .replace(PS, '\\\\u2029')\n        .replace(LT, '\\\\u003c');\n    }\n  };\n\n  return dust;\n\n}));\n\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define(\"dust.parse\", [\"dust.core\"], function(dust) {\n      return factory(dust).parse;\n    });\n  } else if (typeof exports === 'object') {\n    // in Node, require this file if we want to use the parser as a standalone module\n    module.exports = factory(require('./dust'));\n    // @see server file for parser methods exposed in node\n  } else {\n    // in the browser, store the factory output if we want to use the parser directly\n    factory(root.dust);\n  }\n}(this, function(dust) {\n  var parser = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = [],\n        peg$c1 = function(p) {\n            var body = [\"body\"].concat(p);\n            return withPosition(body);\n          },\n        peg$c2 = { type: \"other\", description: \"section\" },\n        peg$c3 = peg$FAILED,\n        peg$c4 = null,\n        peg$c5 = function(t, b, e, n) {\n            if( (!n) || (t[1].text !== n.text) ) {\n              error(\"Expected end tag for \"+t[1].text+\" but it was not found.\");\n            }\n            return true;\n          },\n        peg$c6 = void 0,\n        peg$c7 = function(t, b, e, n) {\n            e.push([\"param\", [\"literal\", \"block\"], b]);\n            t.push(e, [\"filters\"]);\n            return withPosition(t)\n          },\n        peg$c8 = \"/\",\n        peg$c9 = { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n        peg$c10 = function(t) {\n            t.push([\"bodies\"], [\"filters\"]);\n            return withPosition(t)\n          },\n        peg$c11 = /^[#?\\^<+@%]/,\n        peg$c12 = { type: \"class\", value: \"[#?\\\\^<+@%]\", description: \"[#?\\\\^<+@%]\" },\n        peg$c13 = function(t, n, c, p) { return [t, n, c, p] },\n        peg$c14 = { type: \"other\", description: \"end tag\" },\n        peg$c15 = function(n) { return n },\n        peg$c16 = \":\",\n        peg$c17 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c18 = function(n) {return n},\n        peg$c19 = function(n) { return n ? [\"context\", n] : [\"context\"] },\n        peg$c20 = { type: \"other\", description: \"params\" },\n        peg$c21 = \"=\",\n        peg$c22 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c23 = function(k, v) {return [\"param\", [\"literal\", k], v]},\n        peg$c24 = function(p) { return [\"params\"].concat(p) },\n        peg$c25 = { type: \"other\", description: \"bodies\" },\n        peg$c26 = function(p) { return [\"bodies\"].concat(p) },\n        peg$c27 = { type: \"other\", description: \"reference\" },\n        peg$c28 = function(n, f) { return withPosition([\"reference\", n, f]) },\n        peg$c29 = { type: \"other\", description: \"partial\" },\n        peg$c30 = \">\",\n        peg$c31 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n        peg$c32 = \"+\",\n        peg$c33 = { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n        peg$c34 = function(k) {return [\"literal\", k]},\n        peg$c35 = function(s, n, c, p) {\n            var key = (s === \">\") ? \"partial\" : s;\n            return withPosition([key, n, c, p])\n          },\n        peg$c36 = { type: \"other\", description: \"filters\" },\n        peg$c37 = \"|\",\n        peg$c38 = { type: \"literal\", value: \"|\", description: \"\\\"|\\\"\" },\n        peg$c39 = function(f) { return [\"filters\"].concat(f) },\n        peg$c40 = { type: \"other\", description: \"special\" },\n        peg$c41 = \"~\",\n        peg$c42 = { type: \"literal\", value: \"~\", description: \"\\\"~\\\"\" },\n        peg$c43 = function(k) { return withPosition([\"special\", k]) },\n        peg$c44 = { type: \"other\", description: \"identifier\" },\n        peg$c45 = function(p) {\n            var arr = [\"path\"].concat(p);\n            arr.text = p[1].join('.').replace(/,line,\\d+,col,\\d+/g,'');\n            return arr;\n          },\n        peg$c46 = function(k) {\n            var arr = [\"key\", k];\n            arr.text = k;\n            return arr;\n          },\n        peg$c47 = { type: \"other\", description: \"number\" },\n        peg$c48 = function(n) { return ['literal', n]; },\n        peg$c49 = { type: \"other\", description: \"float\" },\n        peg$c50 = \".\",\n        peg$c51 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n        peg$c52 = function(l, r) { return parseFloat(l + \".\" + r); },\n        peg$c53 = { type: \"other\", description: \"unsigned_integer\" },\n        peg$c54 = /^[0-9]/,\n        peg$c55 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c56 = function(digits) { return makeInteger(digits); },\n        peg$c57 = { type: \"other\", description: \"signed_integer\" },\n        peg$c58 = \"-\",\n        peg$c59 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n        peg$c60 = function(sign, n) { return n * -1; },\n        peg$c61 = { type: \"other\", description: \"integer\" },\n        peg$c62 = { type: \"other\", description: \"path\" },\n        peg$c63 = function(k, d) {\n            d = d[0];\n            if (k && d) {\n              d.unshift(k);\n              return withPosition([false, d])\n            }\n            return withPosition([true, d])\n          },\n        peg$c64 = function(d) {\n            if (d.length > 0) {\n              return withPosition([true, d[0]])\n            }\n            return withPosition([true, []])\n          },\n        peg$c65 = { type: \"other\", description: \"key\" },\n        peg$c66 = /^[a-zA-Z_$]/,\n        peg$c67 = { type: \"class\", value: \"[a-zA-Z_$]\", description: \"[a-zA-Z_$]\" },\n        peg$c68 = /^[0-9a-zA-Z_$\\-]/,\n        peg$c69 = { type: \"class\", value: \"[0-9a-zA-Z_$\\\\-]\", description: \"[0-9a-zA-Z_$\\\\-]\" },\n        peg$c70 = function(h, t) { return h + t.join('') },\n        peg$c71 = { type: \"other\", description: \"array\" },\n        peg$c72 = function(n) {return n.join('')},\n        peg$c73 = function(a) {return a; },\n        peg$c74 = function(i, nk) { if(nk) { nk.unshift(i); } else {nk = [i] } return nk; },\n        peg$c75 = { type: \"other\", description: \"array_part\" },\n        peg$c76 = function(k) {return k},\n        peg$c77 = function(d, a) { if (a) { return d.concat(a); } else { return d; } },\n        peg$c78 = { type: \"other\", description: \"inline\" },\n        peg$c79 = \"\\\"\",\n        peg$c80 = { type: \"literal\", value: \"\\\"\", description: \"\\\"\\\\\\\"\\\"\" },\n        peg$c81 = function() { return withPosition([\"literal\", \"\"]) },\n        peg$c82 = function(l) { return withPosition([\"literal\", l]) },\n        peg$c83 = function(p) { return withPosition([\"body\"].concat(p)) },\n        peg$c84 = function(l) { return [\"buffer\", l] },\n        peg$c85 = { type: \"other\", description: \"buffer\" },\n        peg$c86 = function(e, w) { return withPosition([\"format\", e, w.join('')]) },\n        peg$c87 = { type: \"any\", description: \"any character\" },\n        peg$c88 = function(c) {return c},\n        peg$c89 = function(b) { return withPosition([\"buffer\", b.join('')]) },\n        peg$c90 = { type: \"other\", description: \"literal\" },\n        peg$c91 = /^[^\"]/,\n        peg$c92 = { type: \"class\", value: \"[^\\\"]\", description: \"[^\\\"]\" },\n        peg$c93 = function(b) { return b.join('') },\n        peg$c94 = \"\\\\\\\"\",\n        peg$c95 = { type: \"literal\", value: \"\\\\\\\"\", description: \"\\\"\\\\\\\\\\\\\\\"\\\"\" },\n        peg$c96 = function() { return '\"' },\n        peg$c97 = { type: \"other\", description: \"raw\" },\n        peg$c98 = \"{`\",\n        peg$c99 = { type: \"literal\", value: \"{`\", description: \"\\\"{`\\\"\" },\n        peg$c100 = \"`}\",\n        peg$c101 = { type: \"literal\", value: \"`}\", description: \"\\\"`}\\\"\" },\n        peg$c102 = function(character) {return character},\n        peg$c103 = function(rawText) { return withPosition([\"raw\", rawText.join('')]) },\n        peg$c104 = { type: \"other\", description: \"comment\" },\n        peg$c105 = \"{!\",\n        peg$c106 = { type: \"literal\", value: \"{!\", description: \"\\\"{!\\\"\" },\n        peg$c107 = \"!}\",\n        peg$c108 = { type: \"literal\", value: \"!}\", description: \"\\\"!}\\\"\" },\n        peg$c109 = function(c) { return withPosition([\"comment\", c.join('')]) },\n        peg$c110 = /^[#?\\^><+%:@\\/~%]/,\n        peg$c111 = { type: \"class\", value: \"[#?\\\\^><+%:@\\\\/~%]\", description: \"[#?\\\\^><+%:@\\\\/~%]\" },\n        peg$c112 = \"{\",\n        peg$c113 = { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n        peg$c114 = \"}\",\n        peg$c115 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n        peg$c116 = \"[\",\n        peg$c117 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c118 = \"]\",\n        peg$c119 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c120 = \"\\n\",\n        peg$c121 = { type: \"literal\", value: \"\\n\", description: \"\\\"\\\\n\\\"\" },\n        peg$c122 = \"\\r\\n\",\n        peg$c123 = { type: \"literal\", value: \"\\r\\n\", description: \"\\\"\\\\r\\\\n\\\"\" },\n        peg$c124 = \"\\r\",\n        peg$c125 = { type: \"literal\", value: \"\\r\", description: \"\\\"\\\\r\\\"\" },\n        peg$c126 = \"\\u2028\",\n        peg$c127 = { type: \"literal\", value: \"\\u2028\", description: \"\\\"\\\\u2028\\\"\" },\n        peg$c128 = \"\\u2029\",\n        peg$c129 = { type: \"literal\", value: \"\\u2029\", description: \"\\\"\\\\u2029\\\"\" },\n        peg$c130 = /^[\\t\\x0B\\f \\xA0\\uFEFF]/,\n        peg$c131 = { type: \"class\", value: \"[\\\\t\\\\x0B\\\\f \\\\xA0\\\\uFEFF]\", description: \"[\\\\t\\\\x0B\\\\f \\\\xA0\\\\uFEFF]\" },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsestart() {\n      var s0;\n\n      s0 = peg$parsebody();\n\n      return s0;\n    }\n\n    function peg$parsebody() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsepart();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsepart();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c1(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsepart() {\n      var s0;\n\n      s0 = peg$parseraw();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsecomment();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsesection();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsepartial();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsespecial();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsereference();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsebuffer();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsesection() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsesec_tag_start();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsews();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsews();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parserd();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsebody();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsebodies();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseend_tag();\n                if (s6 === peg$FAILED) {\n                  s6 = peg$c4;\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$reportedPos = peg$currPos;\n                  s7 = peg$c5(s1, s4, s5, s6);\n                  if (s7) {\n                    s7 = peg$c6;\n                  } else {\n                    s7 = peg$c3;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$reportedPos = s0;\n                    s1 = peg$c7(s1, s4, s5, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c3;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c3;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c3;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsesec_tag_start();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parsews();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsews();\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c8;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c9); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parserd();\n              if (s4 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c10(s1);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c3;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c2); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsesec_tag_start() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        if (peg$c11.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c12); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsews();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsews();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseidentifier();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecontext();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseparams();\n                if (s6 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c13(s2, s4, s5, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c3;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c3;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n\n      return s0;\n    }\n\n    function peg$parseend_tag() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c8;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c9); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsews();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsews();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseidentifier();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parsews();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parsews();\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parserd();\n                if (s6 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c15(s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c3;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c3;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsecontext() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s2 = peg$c16;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c17); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseidentifier();\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s1;\n          s2 = peg$c18(s3);\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c3;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c3;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$c4;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseparams() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsews();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n      } else {\n        s3 = peg$c3;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsekey();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s5 = peg$c21;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c22); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsenumber();\n            if (s6 === peg$FAILED) {\n              s6 = peg$parseidentifier();\n              if (s6 === peg$FAILED) {\n                s6 = peg$parseinline();\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              peg$reportedPos = s2;\n              s3 = peg$c23(s4, s6);\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c3;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c3;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c3;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c3;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = [];\n        s4 = peg$parsews();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsews();\n          }\n        } else {\n          s3 = peg$c3;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsekey();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s5 = peg$c21;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c22); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsenumber();\n              if (s6 === peg$FAILED) {\n                s6 = peg$parseidentifier();\n                if (s6 === peg$FAILED) {\n                  s6 = peg$parseinline();\n                }\n              }\n              if (s6 !== peg$FAILED) {\n                peg$reportedPos = s2;\n                s3 = peg$c23(s4, s6);\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c3;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c3;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c3;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c3;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c24(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c20); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsebodies() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parseld();\n      if (s3 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s4 = peg$c16;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c17); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsekey();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parserd();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsebody();\n              if (s7 !== peg$FAILED) {\n                peg$reportedPos = s2;\n                s3 = peg$c23(s5, s7);\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c3;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c3;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c3;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c3;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c3;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parseld();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s4 = peg$c16;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsekey();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parserd();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebody();\n                if (s7 !== peg$FAILED) {\n                  peg$reportedPos = s2;\n                  s3 = peg$c23(s5, s7);\n                  s2 = s3;\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$c3;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c3;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c3;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c3;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c3;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsereference() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifier();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefilters();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parserd();\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c28(s2, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c27); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsepartial() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s2 = peg$c30;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c31); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s2 = peg$c32;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c33); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsews();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsews();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parsekey();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s4;\n              s5 = peg$c34(s5);\n            }\n            s4 = s5;\n            if (s4 === peg$FAILED) {\n              s4 = peg$parseinline();\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecontext();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseparams();\n                if (s6 !== peg$FAILED) {\n                  s7 = [];\n                  s8 = peg$parsews();\n                  while (s8 !== peg$FAILED) {\n                    s7.push(s8);\n                    s8 = peg$parsews();\n                  }\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 47) {\n                      s8 = peg$c8;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parserd();\n                      if (s9 !== peg$FAILED) {\n                        peg$reportedPos = s0;\n                        s1 = peg$c35(s2, s4, s5, s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c3;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c3;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c3;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c3;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c3;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsefilters() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 124) {\n        s3 = peg$c37;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c38); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsekey();\n        if (s4 !== peg$FAILED) {\n          peg$reportedPos = s2;\n          s3 = peg$c18(s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c3;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c3;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s3 = peg$c37;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsekey();\n          if (s4 !== peg$FAILED) {\n            peg$reportedPos = s2;\n            s3 = peg$c18(s4);\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c3;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c3;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c39(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsespecial() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 126) {\n          s2 = peg$c41;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsekey();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parserd();\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c43(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsepath();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c45(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsekey();\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c46(s1);\n        }\n        s0 = s1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsefloat();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseinteger();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c48(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c47); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsefloat() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseinteger();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c50;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseunsigned_integer();\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c52(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c49); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseunsigned_integer() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c54.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c55); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c54.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c55); }\n          }\n        }\n      } else {\n        s1 = peg$c3;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c56(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsesigned_integer() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s1 = peg$c58;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c59); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseunsigned_integer();\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c60(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c57); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseinteger() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = peg$parsesigned_integer();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseunsigned_integer();\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsekey();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c4;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsearray_part();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsearray();\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsearray_part();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsearray();\n            }\n          }\n        } else {\n          s2 = peg$c3;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c63(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s1 = peg$c50;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parsearray_part();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsearray();\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsearray_part();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsearray();\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c64(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c62); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsekey() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (peg$c66.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c67); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c68.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c69); }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c68.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c69); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c70(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsearray() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parselb();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = [];\n        if (peg$c54.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c55); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c54.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c55); }\n            }\n          }\n        } else {\n          s4 = peg$c3;\n        }\n        if (s4 !== peg$FAILED) {\n          peg$reportedPos = s3;\n          s4 = peg$c72(s4);\n        }\n        s3 = s4;\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseidentifier();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parserb();\n          if (s4 !== peg$FAILED) {\n            peg$reportedPos = s1;\n            s2 = peg$c73(s3);\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c3;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c3;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c3;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsearray_part();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c4;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c74(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c71); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsearray_part() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c50;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c51); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsekey();\n        if (s4 !== peg$FAILED) {\n          peg$reportedPos = s2;\n          s3 = peg$c76(s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c3;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c3;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s3 = peg$c50;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsekey();\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s2;\n              s3 = peg$c76(s4);\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c3;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c3;\n          }\n        }\n      } else {\n        s1 = peg$c3;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsearray();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c4;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c77(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c75); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseinline() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c79;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c80); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s2 = peg$c79;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c80); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c81();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s1 = peg$c79;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c80); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseliteral();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 34) {\n              s3 = peg$c79;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c80); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c82(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s1 = peg$c79;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c80); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseinline_part();\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parseinline_part();\n              }\n            } else {\n              s2 = peg$c3;\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 34) {\n                s3 = peg$c79;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c80); }\n              }\n              if (s3 !== peg$FAILED) {\n                peg$reportedPos = s0;\n                s1 = peg$c83(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c3;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c78); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseinline_part() {\n      var s0, s1;\n\n      s0 = peg$parsespecial();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsereference();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseliteral();\n          if (s1 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c84(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsebuffer() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseeol();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsews();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsews();\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c86(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsetag();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c6;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c3;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseraw();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c6;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c3;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsecomment();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c3;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parseeol();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = peg$c6;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$c3;\n              }\n              if (s6 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c87); }\n                }\n                if (s7 !== peg$FAILED) {\n                  peg$reportedPos = s2;\n                  s3 = peg$c88(s7);\n                  s2 = s3;\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$c3;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c3;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c3;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c3;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c3;\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$currPos;\n            s3 = peg$currPos;\n            peg$silentFails++;\n            s4 = peg$parsetag();\n            peg$silentFails--;\n            if (s4 === peg$FAILED) {\n              s3 = peg$c6;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c3;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parseraw();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = peg$c6;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c3;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$currPos;\n                peg$silentFails++;\n                s6 = peg$parsecomment();\n                peg$silentFails--;\n                if (s6 === peg$FAILED) {\n                  s5 = peg$c6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$c3;\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$currPos;\n                  peg$silentFails++;\n                  s7 = peg$parseeol();\n                  peg$silentFails--;\n                  if (s7 === peg$FAILED) {\n                    s6 = peg$c6;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$c3;\n                  }\n                  if (s6 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s7 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c87); }\n                    }\n                    if (s7 !== peg$FAILED) {\n                      peg$reportedPos = s2;\n                      s3 = peg$c88(s7);\n                      s2 = s3;\n                    } else {\n                      peg$currPos = s2;\n                      s2 = peg$c3;\n                    }\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$c3;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$c3;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$c3;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c3;\n            }\n          }\n        } else {\n          s1 = peg$c3;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c89(s1);\n        }\n        s0 = s1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c85); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseliteral() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parsetag();\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = peg$c6;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c3;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseesc();\n        if (s4 === peg$FAILED) {\n          if (peg$c91.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c92); }\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          peg$reportedPos = s2;\n          s3 = peg$c88(s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c3;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c3;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsetag();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c6;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c3;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseesc();\n            if (s4 === peg$FAILED) {\n              if (peg$c91.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c92); }\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s2;\n              s3 = peg$c88(s4);\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c3;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c3;\n          }\n        }\n      } else {\n        s1 = peg$c3;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c93(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c90); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseesc() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c94) {\n        s1 = peg$c94;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c95); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c96();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseraw() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c98) {\n        s1 = peg$c98;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c99); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c100) {\n          s5 = peg$c100;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c101); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = peg$c6;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c3;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c87); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$reportedPos = s3;\n            s4 = peg$c102(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c3;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c3;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 2) === peg$c100) {\n            s5 = peg$c100;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c101); }\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c6;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c3;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c87); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s3;\n              s4 = peg$c102(s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c3;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c3;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c100) {\n            s3 = peg$c100;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c101); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c103(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c97); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsecomment() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c105) {\n        s1 = peg$c105;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c106); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c107) {\n          s5 = peg$c107;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c108); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = peg$c6;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c3;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c87); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$reportedPos = s3;\n            s4 = peg$c88(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c3;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c3;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 2) === peg$c107) {\n            s5 = peg$c107;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c108); }\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c6;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c3;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c87); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s3;\n              s4 = peg$c88(s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c3;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c3;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c107) {\n            s3 = peg$c107;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c108); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c109(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c104); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsetag() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsews();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsews();\n        }\n        if (s2 !== peg$FAILED) {\n          if (peg$c110.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c111); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parsews();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parsews();\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$currPos;\n              s7 = peg$currPos;\n              peg$silentFails++;\n              s8 = peg$parserd();\n              peg$silentFails--;\n              if (s8 === peg$FAILED) {\n                s7 = peg$c6;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$c3;\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$currPos;\n                peg$silentFails++;\n                s9 = peg$parseeol();\n                peg$silentFails--;\n                if (s9 === peg$FAILED) {\n                  s8 = peg$c6;\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$c3;\n                }\n                if (s8 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s9 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c87); }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s7 = [s7, s8, s9];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$c3;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$c3;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$c3;\n              }\n              if (s6 !== peg$FAILED) {\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$currPos;\n                  s7 = peg$currPos;\n                  peg$silentFails++;\n                  s8 = peg$parserd();\n                  peg$silentFails--;\n                  if (s8 === peg$FAILED) {\n                    s7 = peg$c6;\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$c3;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$currPos;\n                    peg$silentFails++;\n                    s9 = peg$parseeol();\n                    peg$silentFails--;\n                    if (s9 === peg$FAILED) {\n                      s8 = peg$c6;\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$c3;\n                    }\n                    if (s8 !== peg$FAILED) {\n                      if (input.length > peg$currPos) {\n                        s9 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c87); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s7 = [s7, s8, s9];\n                        s6 = s7;\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$c3;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$c3;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$c3;\n                  }\n                }\n              } else {\n                s5 = peg$c3;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = [];\n                s7 = peg$parsews();\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  s7 = peg$parsews();\n                }\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parserd();\n                  if (s7 !== peg$FAILED) {\n                    s1 = [s1, s2, s3, s4, s5, s6, s7];\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c3;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c3;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c3;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c3;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c3;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c3;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c3;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsereference();\n      }\n\n      return s0;\n    }\n\n    function peg$parseld() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s0 = peg$c112;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c113); }\n      }\n\n      return s0;\n    }\n\n    function peg$parserd() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s0 = peg$c114;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c115); }\n      }\n\n      return s0;\n    }\n\n    function peg$parselb() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s0 = peg$c116;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c117); }\n      }\n\n      return s0;\n    }\n\n    function peg$parserb() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 93) {\n        s0 = peg$c118;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c119); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseeol() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s0 = peg$c120;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c121); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c122) {\n          s0 = peg$c122;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c123); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 13) {\n            s0 = peg$c124;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c125); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 8232) {\n              s0 = peg$c126;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c127); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 8233) {\n                s0 = peg$c128;\n                peg$currPos++;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c129); }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsews() {\n      var s0;\n\n      if (peg$c130.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c131); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseeol();\n      }\n\n      return s0;\n    }\n\n\n      function makeInteger(arr) {\n        return parseInt(arr.join(''), 10);\n      }\n      function withPosition(arr) {\n        return arr.concat([['line', line()], ['col', column()]]);\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();\n\n  // expose parser methods\n  dust.parse = parser.parse;\n\n  return parser;\n}));\n\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define(\"dust.compile\", [\"dust.core\", \"dust.parse\"], function(dust, parse) {\n      return factory(parse, dust).compile;\n    });\n  } else if (typeof exports === 'object') {\n    // in Node, require this file if we want to use the compiler as a standalone module\n    module.exports = factory(require('./parser').parse, require('./dust'));\n  } else {\n    // in the browser, store the factory output if we want to use the compiler directly\n    factory(root.dust.parse, root.dust);\n  }\n}(this, function(parse, dust) {\n  var compiler = {},\n      isArray = dust.isArray;\n\n\n  compiler.compile = function(source, name) {\n    // the name parameter is optional.\n    // this can happen for templates that are rendered immediately (renderSource which calls compileFn) or\n    // for templates that are compiled as a callable (compileFn)\n    //\n    // for the common case (using compile and render) a name is required so that templates will be cached by name and rendered later, by name.\n\n    try {\n      var ast = filterAST(parse(source));\n      return compile(ast, name);\n    }\n    catch (err)\n    {\n      if (!err.line || !err.column) {\n        throw err;\n      }\n      throw new SyntaxError(err.message + ' At line : ' + err.line + ', column : ' + err.column);\n    }\n  };\n\n  function filterAST(ast) {\n    var context = {};\n    return compiler.filterNode(context, ast);\n  }\n\n  compiler.filterNode = function(context, node) {\n    return compiler.optimizers[node[0]](context, node);\n  };\n\n  compiler.optimizers = {\n    body:      compactBuffers,\n    buffer:    noop,\n    special:   convertSpecial,\n    format:    format,\n    reference: visit,\n    '#':       visit,\n    '?':       visit,\n    '^':       visit,\n    '<':       visit,\n    '+':       visit,\n    '@':       visit,\n    '%':       visit,\n    partial:   visit,\n    context:   visit,\n    params:    visit,\n    bodies:    visit,\n    param:     visit,\n    filters:   noop,\n    key:       noop,\n    path:      noop,\n    literal:   noop,\n    raw:       noop,\n    comment:   nullify,\n    line:      nullify,\n    col:       nullify\n  };\n\n  compiler.pragmas = {\n    esc: function(compiler, context, bodies) {\n      var old = compiler.auto,\n          out;\n      if (!context) {\n        context = 'h';\n      }\n      compiler.auto = (context === 's') ? '' : context;\n      out = compileParts(compiler, bodies.block);\n      compiler.auto = old;\n      return out;\n    }\n  };\n\n  function visit(context, node) {\n    var out = [node[0]],\n        i, len, res;\n    for (i=1, len=node.length; i<len; i++) {\n      res = compiler.filterNode(context, node[i]);\n      if (res) {\n        out.push(res);\n      }\n    }\n    return out;\n  }\n\n  // Compacts consecutive buffer nodes into a single node\n  function compactBuffers(context, node) {\n    var out = [node[0]],\n        memo, i, len, res;\n    for (i=1, len=node.length; i<len; i++) {\n      res = compiler.filterNode(context, node[i]);\n      if (res) {\n        if (res[0] === 'buffer' || res[0] === 'format') {\n          if (memo) {\n            memo[0] = (res[0] === 'buffer') ? 'buffer' : memo[0];\n            memo[1] += res.slice(1, -2).join('');\n          } else {\n            memo = res;\n            out.push(res);\n          }\n        } else {\n          memo = null;\n          out.push(res);\n        }\n      }\n    }\n    return out;\n  }\n\n  var specialChars = {\n    's': ' ',\n    'n': '\\n',\n    'r': '\\r',\n    'lb': '{',\n    'rb': '}'\n  };\n\n  function convertSpecial(context, node) {\n    return ['buffer', specialChars[node[1]], node[2], node[3]];\n  }\n\n  function noop(context, node) {\n    return node;\n  }\n\n  function nullify(){}\n\n  function format(context, node) {\n    if(dust.config.whitespace) {\n      // Format nodes are in the form ['format', eol, whitespace, line, col],\n      // which is unlike other nodes in that there are two pieces of content\n      // Join eol and whitespace together to normalize the node format\n      node.splice(1, 2, node.slice(1, -2).join(''));\n      return node;\n    }\n    return null;\n  }\n\n  function compile(ast, name) {\n    var context = {\n      name: name,\n      bodies: [],\n      blocks: {},\n      index: 0,\n      auto: 'h'\n    },\n    escapedName = dust.escapeJs(name),\n    AMDName = name? '\"' + escapedName + '\",' : '',\n    compiled = 'function(dust){',\n    entry = compiler.compileNode(context, ast),\n    iife;\n\n    if(name) {\n      compiled += 'dust.register(\"' + escapedName + '\",' + entry + ');';\n    }\n\n    compiled += compileBlocks(context) +\n                compileBodies(context) +\n                'return ' + entry + '}';\n\n    iife = '(' + compiled + '(dust));';\n\n    if(dust.config.amd) {\n      return 'define(' + AMDName + '[\"dust.core\"],' + compiled + ');';\n    } else if(dust.config.cjs) {\n      return 'module.exports=function(dust){' +\n             'var tmpl=' + iife +\n             'var f=' + loaderFor().toString() + ';' +\n             'f.template=tmpl;return f}';\n    } else {\n      return iife;\n    }\n  }\n\n  function compileBlocks(context) {\n    var out = [],\n        blocks = context.blocks,\n        name;\n\n    for (name in blocks) {\n      out.push('\"' + name + '\":' + blocks[name]);\n    }\n    if (out.length) {\n      context.blocks = 'ctx=ctx.shiftBlocks(blocks);';\n      return 'var blocks={' + out.join(',') + '};';\n    } else {\n      context.blocks = '';\n    }\n    return context.blocks;\n  }\n\n  function compileBodies(context) {\n    var out = [],\n        bodies = context.bodies,\n        blx = context.blocks,\n        i, len;\n\n    for (i=0, len=bodies.length; i<len; i++) {\n      out[i] = 'function body_' + i + '(chk,ctx){' +\n          blx + 'return chk' + bodies[i] + ';}body_' + i + '.__dustBody=!0;';\n    }\n    return out.join('');\n  }\n\n  function compileParts(context, body) {\n    var parts = '',\n        i, len;\n    for (i=1, len=body.length; i<len; i++) {\n      parts += compiler.compileNode(context, body[i]);\n    }\n    return parts;\n  }\n\n  compiler.compileNode = function(context, node) {\n    return compiler.nodes[node[0]](context, node);\n  };\n\n  compiler.nodes = {\n    body: function(context, node) {\n      var id = context.index++,\n          name = 'body_' + id;\n      context.bodies[id] = compileParts(context, node);\n      return name;\n    },\n\n    buffer: function(context, node) {\n      return '.w(' + escape(node[1]) + ')';\n    },\n\n    format: function(context, node) {\n      return '.w(' + escape(node[1]) + ')';\n    },\n\n    reference: function(context, node) {\n      return '.f(' + compiler.compileNode(context, node[1]) +\n        ',ctx,' + compiler.compileNode(context, node[2]) + ')';\n    },\n\n    '#': function(context, node) {\n      return compileSection(context, node, 'section');\n    },\n\n    '?': function(context, node) {\n      return compileSection(context, node, 'exists');\n    },\n\n    '^': function(context, node) {\n      return compileSection(context, node, 'notexists');\n    },\n\n    '<': function(context, node) {\n      var bodies = node[4];\n      for (var i=1, len=bodies.length; i<len; i++) {\n        var param = bodies[i],\n            type = param[1][1];\n        if (type === 'block') {\n          context.blocks[node[1].text] = compiler.compileNode(context, param[2]);\n          return '';\n        }\n      }\n      return '';\n    },\n\n    '+': function(context, node) {\n      if (typeof(node[1].text) === 'undefined'  && typeof(node[4]) === 'undefined'){\n        return '.b(ctx.getBlock(' +\n              compiler.compileNode(context, node[1]) +\n              ',chk, ctx),' + compiler.compileNode(context, node[2]) + ', {},' +\n              compiler.compileNode(context, node[3]) +\n              ')';\n      } else {\n        return '.b(ctx.getBlock(' +\n            escape(node[1].text) +\n            '),' + compiler.compileNode(context, node[2]) + ',' +\n            compiler.compileNode(context, node[4]) + ',' +\n            compiler.compileNode(context, node[3]) +\n            ')';\n      }\n    },\n\n    '@': function(context, node) {\n      return '.h(' +\n        escape(node[1].text) +\n        ',' + compiler.compileNode(context, node[2]) + ',' +\n        compiler.compileNode(context, node[4]) + ',' +\n        compiler.compileNode(context, node[3]) + ',' +\n        compiler.compileNode(context, node[5]) +\n        ')';\n    },\n\n    '%': function(context, node) {\n      // TODO: Move these hacks into pragma precompiler\n      var name = node[1][1],\n          rawBodies,\n          bodies,\n          rawParams,\n          params,\n          ctx, b, p, i, len;\n      if (!compiler.pragmas[name]) {\n        return '';\n      }\n\n      rawBodies = node[4];\n      bodies = {};\n      for (i=1, len=rawBodies.length; i<len; i++) {\n        b = rawBodies[i];\n        bodies[b[1][1]] = b[2];\n      }\n\n      rawParams = node[3];\n      params = {};\n      for (i=1, len=rawParams.length; i<len; i++) {\n        p = rawParams[i];\n        params[p[1][1]] = p[2][1];\n      }\n\n      ctx = node[2][1] ? node[2][1].text : null;\n\n      return compiler.pragmas[name](context, ctx, bodies, params);\n    },\n\n    partial: function(context, node) {\n      return '.p(' +\n          compiler.compileNode(context, node[1]) +\n          ',ctx,' + compiler.compileNode(context, node[2]) +\n          ',' + compiler.compileNode(context, node[3]) + ')';\n    },\n\n    context: function(context, node) {\n      if (node[1]) {\n        return 'ctx.rebase(' + compiler.compileNode(context, node[1]) + ')';\n      }\n      return 'ctx';\n    },\n\n    params: function(context, node) {\n      var out = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        out.push(compiler.compileNode(context, node[i]));\n      }\n      if (out.length) {\n        return '{' + out.join(',') + '}';\n      }\n      return '{}';\n    },\n\n    bodies: function(context, node) {\n      var out = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        out.push(compiler.compileNode(context, node[i]));\n      }\n      return '{' + out.join(',') + '}';\n    },\n\n    param: function(context, node) {\n      return compiler.compileNode(context, node[1]) + ':' + compiler.compileNode(context, node[2]);\n    },\n\n    filters: function(context, node) {\n      var list = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        var filter = node[i];\n        list.push('\"' + filter + '\"');\n      }\n      return '\"' + context.auto + '\"' +\n        (list.length ? ',[' + list.join(',') + ']' : '');\n    },\n\n    key: function(context, node) {\n      return 'ctx.get([\"' + node[1] + '\"], false)';\n    },\n\n    path: function(context, node) {\n      var current = node[1],\n          keys = node[2],\n          list = [];\n\n      for (var i=0,len=keys.length; i<len; i++) {\n        if (isArray(keys[i])) {\n          list.push(compiler.compileNode(context, keys[i]));\n        } else {\n          list.push('\"' + keys[i] + '\"');\n        }\n      }\n      return 'ctx.getPath(' + current + ', [' + list.join(',') + '])';\n    },\n\n    literal: function(context, node) {\n      return escape(node[1]);\n    },\n    raw: function(context, node) {\n      return \".w(\" + escape(node[1]) + \")\";\n    }\n  };\n\n  function compileSection(context, node, cmd) {\n    return '.' + (dust._aliases[cmd] || cmd) + '(' +\n      compiler.compileNode(context, node[1]) +\n      ',' + compiler.compileNode(context, node[2]) + ',' +\n      compiler.compileNode(context, node[4]) + ',' +\n      compiler.compileNode(context, node[3]) +\n      ')';\n  }\n\n  var BS = /\\\\/g,\n      DQ = /\"/g,\n      LF = /\\f/g,\n      NL = /\\n/g,\n      CR = /\\r/g,\n      TB = /\\t/g;\n  function escapeToJsSafeString(str) {\n    return str.replace(BS, '\\\\\\\\')\n              .replace(DQ, '\\\\\"')\n              .replace(LF, '\\\\f')\n              .replace(NL, '\\\\n')\n              .replace(CR, '\\\\r')\n              .replace(TB, '\\\\t');\n  }\n\n  var escape = (typeof JSON === 'undefined') ?\n                  function(str) { return '\"' + escapeToJsSafeString(str) + '\"';} :\n                  JSON.stringify;\n\n  function renderSource(source, context, callback) {\n    var tmpl = dust.loadSource(dust.compile(source));\n    return loaderFor(tmpl)(context, callback);\n  }\n\n  function compileFn(source, name) {\n    var tmpl = dust.loadSource(dust.compile(source, name));\n    return loaderFor(tmpl);\n  }\n\n  function loaderFor(tmpl) {\n    return function load(ctx, cb) {\n      var fn = cb ? 'render' : 'stream';\n      return dust[fn](tmpl, ctx, cb);\n    };\n  }\n\n  // expose compiler methods\n  dust.compiler = compiler;\n  dust.compile = dust.compiler.compile;\n  dust.renderSource = renderSource;\n  dust.compileFn = compileFn;\n\n  // DEPRECATED legacy names. Removed in 2.8.0\n  dust.filterNode = compiler.filterNode;\n  dust.optimizers = compiler.optimizers;\n  dust.pragmas = compiler.pragmas;\n  dust.compileNode = compiler.compileNode;\n  dust.nodes = compiler.nodes;\n\n  return compiler;\n\n}));\n\nif (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define([\"require\", \"dust.core\", \"dust.compile\"], function(require, dust) {\n        dust.onLoad = function(name, cb) {\n            require([name], function() {\n                cb();\n            });\n        };\n        return dust;\n    });\n}\n", "/*! dustjs-linkedin - v2.7.2\n* http://dustjs.com/\n* Copyright (c) 2015 Aleksander Williams; Released under the MIT License */\n!function(a,b){\"function\"==typeof define&&define.amd&&define.amd.dust===!0?define(\"dust.core\",[],b):\"object\"==typeof exports?module.exports=b():a.dust=b()}(this,function(){function getTemplate(a,b){return a?\"function\"==typeof a&&a.template?a.template:dust.isTemplateFn(a)?a:b!==!1?dust.cache[a]:void 0:void 0}function load(a,b,c){if(!a)return b.setError(new Error(\"No template or template name provided to render\"));var d=getTemplate(a,dust.config.cache);return d?d(b,Context.wrap(c,d.templateName)):dust.onLoad?b.map(function(b){function d(a,d){var f;if(a)return b.setError(a);if(f=getTemplate(d,!1)||getTemplate(e,dust.config.cache),!f){if(!dust.compile)return b.setError(new Error(\"Dust compiler not available\"));f=dust.loadSource(dust.compile(d,e))}f(b,Context.wrap(c,f.templateName)).end()}var e=a;3===dust.onLoad.length?dust.onLoad(e,c.options,d):dust.onLoad(e,d)}):b.setError(new Error(\"Template Not Found: \"+a))}function Context(a,b,c,d,e){void 0===a||a instanceof Stack||(a=new Stack(a)),this.stack=a,this.global=b,this.options=c,this.blocks=d,this.templateName=e}function getWithResolvedData(a,b,c){return function(d){return a.push(d)._get(b,c)}}function Stack(a,b,c,d){this.tail=b,this.isObject=a&&\"object\"==typeof a,this.head=a,this.index=c,this.of=d}function Stub(a){this.head=new Chunk(this),this.callback=a,this.out=\"\"}function Stream(){this.head=new Chunk(this)}function Chunk(a,b,c){this.root=a,this.next=b,this.data=[],this.flushable=!1,this.taps=c}function Tap(a,b){this.head=a,this.tail=b}var dust={version:\"2.7.2\"},NONE=\"NONE\",ERROR=\"ERROR\",WARN=\"WARN\",INFO=\"INFO\",DEBUG=\"DEBUG\",EMPTY_FUNC=function(){};dust.config={whitespace:!1,amd:!1,cjs:!1,cache:!0},dust._aliases={write:\"w\",end:\"e\",map:\"m\",render:\"r\",reference:\"f\",section:\"s\",exists:\"x\",notexists:\"nx\",block:\"b\",partial:\"p\",helper:\"h\"},function(){var a,b,c={DEBUG:0,INFO:1,WARN:2,ERROR:3,NONE:4};\"undefined\"!=typeof console&&console.log?(a=console.log,b=\"function\"==typeof a?function(){a.apply(console,arguments)}:function(){a(Array.prototype.slice.apply(arguments).join(\" \"))}):b=EMPTY_FUNC,dust.log=function(a,d){d=d||INFO,c[d]>=c[dust.debugLevel]&&b(\"[DUST:\"+d+\"]\",a)},dust.debugLevel=NONE,\"undefined\"!=typeof process&&process.env&&/\\bdust\\b/.test(process.env.DEBUG)&&(dust.debugLevel=DEBUG)}(),dust.helpers={},dust.cache={},dust.register=function(a,b){a&&(b.templateName=a,dust.config.cache!==!1&&(dust.cache[a]=b))},dust.render=function(a,b,c){var d=new Stub(c).head;try{load(a,d,b).end()}catch(e){d.setError(e)}},dust.stream=function(a,b){var c=new Stream,d=c.head;return dust.nextTick(function(){try{load(a,d,b).end()}catch(c){d.setError(c)}}),c},dust.loadSource=function(source){return eval(source)},dust.isArray=Array.isArray?Array.isArray:function(a){return\"[object Array]\"===Object.prototype.toString.call(a)},dust.nextTick=function(){return function(a){setTimeout(a,0)}}(),dust.isEmpty=function(a){return 0===a?!1:dust.isArray(a)&&!a.length?!0:!a},dust.isEmptyObject=function(a){var b;if(null===a)return!1;if(void 0===a)return!1;if(a.length>0)return!1;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b))return!1;return!0},dust.isTemplateFn=function(a){return\"function\"==typeof a&&a.__dustBody},dust.isThenable=function(a){return a&&\"object\"==typeof a&&\"function\"==typeof a.then},dust.isStreamable=function(a){return a&&\"function\"==typeof a.on&&\"function\"==typeof a.pipe},dust.filter=function(a,b,c,d){var e,f,g,h;if(c)for(e=0,f=c.length;f>e;e++)g=c[e],g.length&&(h=dust.filters[g],\"s\"===g?b=null:\"function\"==typeof h?a=h(a,d):dust.log(\"Invalid filter `\"+g+\"`\",WARN));return b&&(a=dust.filters[b](a,d)),a},dust.filters={h:function(a){return dust.escapeHtml(a)},j:function(a){return dust.escapeJs(a)},u:encodeURI,uc:encodeURIComponent,js:function(a){return dust.escapeJSON(a)},jp:function(a){return JSON?JSON.parse(a):(dust.log(\"JSON is undefined; could not parse `\"+a+\"`\",WARN),a)}},dust.makeBase=dust.context=function(a,b){return new Context(void 0,a,b)},Context.wrap=function(a,b){return a instanceof Context?a:new Context(a,{},{},null,b)},Context.prototype.get=function(a,b){return\"string\"==typeof a&&(\".\"===a[0]&&(b=!0,a=a.substr(1)),a=a.split(\".\")),this._get(b,a)},Context.prototype._get=function(a,b){var c,d,e,f,g,h=this.stack||{},i=1;if(d=b[0],e=b.length,a&&0===e)f=h,h=h.head;else{if(a)h&&(h=h.head?h.head[d]:void 0);else{for(;h&&(!h.isObject||(f=h.head,c=h.head[d],void 0===c));)h=h.tail;h=void 0!==c?c:this.global&&this.global[d]}for(;h&&e>i;){if(dust.isThenable(h))return h.then(getWithResolvedData(this,a,b.slice(i)));f=h,h=h[b[i]],i++}}return\"function\"==typeof h?(g=function(){try{return h.apply(f,arguments)}catch(a){throw dust.log(a,ERROR),a}},g.__dustBody=!!h.__dustBody,g):(void 0===h&&dust.log(\"Cannot find reference `{\"+b.join(\".\")+\"}` in template `\"+this.getTemplateName()+\"`\",INFO),h)},Context.prototype.getPath=function(a,b){return this._get(a,b)},Context.prototype.push=function(a,b,c){return void 0===a?(dust.log(\"Not pushing an undefined variable onto the context\",INFO),this):this.rebase(new Stack(a,this.stack,b,c))},Context.prototype.pop=function(){var a=this.current();return this.stack=this.stack&&this.stack.tail,a},Context.prototype.rebase=function(a){return new Context(a,this.global,this.options,this.blocks,this.getTemplateName())},Context.prototype.clone=function(){var a=this.rebase();return a.stack=this.stack,a},Context.prototype.current=function(){return this.stack&&this.stack.head},Context.prototype.getBlock=function(a){var b,c,d;if(\"function\"==typeof a&&(a=a(new Chunk,this).data.join(\"\")),b=this.blocks,!b)return dust.log(\"No blocks for context `\"+a+\"` in template `\"+this.getTemplateName()+\"`\",DEBUG),!1;for(c=b.length;c--;)if(d=b[c][a])return d;return dust.log(\"Malformed template `\"+this.getTemplateName()+\"` was missing one or more blocks.\"),!1},Context.prototype.shiftBlocks=function(a){var b,c=this.blocks;return a?(b=c?c.concat([a]):[a],new Context(this.stack,this.global,this.options,b,this.getTemplateName())):this},Context.prototype.resolve=function(a){var b;return\"function\"!=typeof a?a:(b=(new Chunk).render(a,this),b instanceof Chunk?b.data.join(\"\"):b)},Context.prototype.getTemplateName=function(){return this.templateName},Stub.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.callback(a.error),dust.log(\"Rendering failed with error `\"+a.error+\"`\",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.out+=a.data.join(\"\"),a=a.next,this.head=a}this.callback(null,this.out)},Stream.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.emit(\"error\",a.error),this.emit(\"end\"),dust.log(\"Streaming failed with error `\"+a.error+\"`\",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.emit(\"data\",a.data.join(\"\")),a=a.next,this.head=a}this.emit(\"end\")},Stream.prototype.emit=function(a,b){var c,d,e=this.events||{},f=e[a]||[];if(!f.length)return dust.log(\"Stream broadcasting, but no listeners for `\"+a+\"`\",DEBUG),!1;for(f=f.slice(0),c=0,d=f.length;d>c;c++)f[c](b);return!0},Stream.prototype.on=function(a,b){var c=this.events=this.events||{},d=c[a]=c[a]||[];return\"function\"!=typeof b?dust.log(\"No callback function provided for `\"+a+\"` event listener\",WARN):d.push(b),this},Stream.prototype.pipe=function(a){if(\"function\"!=typeof a.write||\"function\"!=typeof a.end)return dust.log(\"Incompatible stream passed to `pipe`\",WARN),this;var b=!1;return\"function\"==typeof a.emit&&a.emit(\"pipe\",this),\"function\"==typeof a.on&&a.on(\"error\",function(){b=!0}),this.on(\"data\",function(c){if(!b)try{a.write(c,\"utf8\")}catch(d){dust.log(d,ERROR)}}).on(\"end\",function(){if(!b)try{a.end(),b=!0}catch(c){dust.log(c,ERROR)}})},Chunk.prototype.write=function(a){var b=this.taps;return b&&(a=b.go(a)),this.data.push(a),this},Chunk.prototype.end=function(a){return a&&this.write(a),this.flushable=!0,this.root.flush(),this},Chunk.prototype.map=function(a){var b=new Chunk(this.root,this.next,this.taps),c=new Chunk(this.root,b,this.taps);this.next=c,this.flushable=!0;try{a(c)}catch(d){dust.log(d,ERROR),c.setError(d)}return b},Chunk.prototype.tap=function(a){var b=this.taps;return this.taps=b?b.push(a):new Tap(a),this},Chunk.prototype.untap=function(){return this.taps=this.taps.tail,this},Chunk.prototype.render=function(a,b){return a(this,b)},Chunk.prototype.reference=function(a,b,c,d){return\"function\"==typeof a?(a=a.apply(b.current(),[this,b,null,{auto:c,filters:d}]),a instanceof Chunk?a:this.reference(a,b,c,d)):dust.isThenable(a)?this.await(a,b,null,c,d):dust.isStreamable(a)?this.stream(a,b,null,c,d):dust.isEmpty(a)?this:this.write(dust.filter(a,c,d,b))},Chunk.prototype.section=function(a,b,c,d){var e,f,g,h=c.block,i=c[\"else\"],j=this;if(\"function\"==typeof a&&!dust.isTemplateFn(a)){try{a=a.apply(b.current(),[this,b,c,d])}catch(k){return dust.log(k,ERROR),this.setError(k)}if(a instanceof Chunk)return a}if(dust.isEmptyObject(c))return j;if(dust.isEmptyObject(d)||(b=b.push(d)),dust.isArray(a)){if(h){if(f=a.length,f>0){for(g=b.stack&&b.stack.head||{},g.$len=f,e=0;f>e;e++)g.$idx=e,j=h(j,b.push(a[e],e,f));return g.$idx=void 0,g.$len=void 0,j}if(i)return i(this,b)}}else{if(dust.isThenable(a))return this.await(a,b,c);if(dust.isStreamable(a))return this.stream(a,b,c);if(a===!0){if(h)return h(this,b)}else if(a||0===a){if(h)return h(this,b.push(a))}else if(i)return i(this,b)}return dust.log(\"Section without corresponding key in template `\"+b.getTemplateName()+\"`\",DEBUG),this},Chunk.prototype.exists=function(a,b,c){var d=c.block,e=c[\"else\"];if(dust.isEmpty(a)){if(e)return e(this,b)}else{if(d)return d(this,b);dust.log(\"No block for exists check in template `\"+b.getTemplateName()+\"`\",DEBUG)}return this},Chunk.prototype.notexists=function(a,b,c){var d=c.block,e=c[\"else\"];if(dust.isEmpty(a)){if(d)return d(this,b);dust.log(\"No block for not-exists check in template `\"+b.getTemplateName()+\"`\",DEBUG)}else if(e)return e(this,b);return this},Chunk.prototype.block=function(a,b,c){var d=a||c.block;return d?d(this,b):this},Chunk.prototype.partial=function(a,b,c,d){var e;return void 0===d&&(d=c,c=b),dust.isEmptyObject(d)||(c=c.clone(),e=c.pop(),c=c.push(d).push(e)),dust.isTemplateFn(a)?this.capture(a,b,function(a,b){c.templateName=a,load(a,b,c).end()}):(c.templateName=a,load(a,this,c))},Chunk.prototype.helper=function(a,b,c,d,e){var f,g=this,h=d.filters;if(void 0===e&&(e=\"h\"),!dust.helpers[a])return dust.log(\"Helper `\"+a+\"` does not exist\",WARN),g;try{return f=dust.helpers[a](g,b,c,d),f instanceof Chunk?f:(\"string\"==typeof h&&(h=h.split(\"|\")),dust.isEmptyObject(c)?g.reference(f,b,e,h):g.section(f,b,c,d))}catch(i){return dust.log(\"Error in helper `\"+a+\"`: \"+i.message,ERROR),g.setError(i)}},Chunk.prototype.await=function(a,b,c,d,e){return this.map(function(f){a.then(function(a){f=c?f.section(a,b,c):f.reference(a,b,d,e),f.end()},function(a){var d=c&&c.error;d?f.render(d,b.push(a)).end():(dust.log(\"Unhandled promise rejection in `\"+b.getTemplateName()+\"`\",INFO),f.end())})})},Chunk.prototype.stream=function(a,b,c,d,e){var f=c&&c.block,g=c&&c.error;return this.map(function(h){var i=!1;a.on(\"data\",function(a){i||(f?h=h.map(function(c){c.render(f,b.push(a)).end()}):c||(h=h.reference(a,b,d,e)))}).on(\"error\",function(a){i||(g?h.render(g,b.push(a)):dust.log(\"Unhandled stream error in `\"+b.getTemplateName()+\"`\",INFO),i||(i=!0,h.end()))}).on(\"end\",function(){i||(i=!0,h.end())})})},Chunk.prototype.capture=function(a,b,c){return this.map(function(d){var e=new Stub(function(a,b){a?d.setError(a):c(b,d)});a(e.head,b).end()})},Chunk.prototype.setError=function(a){return this.error=a,this.root.flush(),this};for(var f in Chunk.prototype)dust._aliases[f]&&(Chunk.prototype[dust._aliases[f]]=Chunk.prototype[f]);Tap.prototype.push=function(a){return new Tap(a,this)},Tap.prototype.go=function(a){for(var b=this;b;)a=b.head(a),b=b.tail;return a};var HCHARS=/[&<>\"']/,AMP=/&/g,LT=/</g,GT=/>/g,QUOT=/\\\"/g,SQUOT=/\\'/g;dust.escapeHtml=function(a){return\"string\"==typeof a||a&&\"function\"==typeof a.toString?(\"string\"!=typeof a&&(a=a.toString()),HCHARS.test(a)?a.replace(AMP,\"&amp;\").replace(LT,\"&lt;\").replace(GT,\"&gt;\").replace(QUOT,\"&quot;\").replace(SQUOT,\"&#39;\"):a):a};var BS=/\\\\/g,FS=/\\//g,CR=/\\r/g,LS=/\\u2028/g,PS=/\\u2029/g,NL=/\\n/g,LF=/\\f/g,SQ=/'/g,DQ=/\"/g,TB=/\\t/g;return dust.escapeJs=function(a){return\"string\"==typeof a?a.replace(BS,\"\\\\\\\\\").replace(FS,\"\\\\/\").replace(DQ,'\\\\\"').replace(SQ,\"\\\\'\").replace(CR,\"\\\\r\").replace(LS,\"\\\\u2028\").replace(PS,\"\\\\u2029\").replace(NL,\"\\\\n\").replace(LF,\"\\\\f\").replace(TB,\"\\\\t\"):a},dust.escapeJSON=function(a){return JSON?JSON.stringify(a).replace(LS,\"\\\\u2028\").replace(PS,\"\\\\u2029\").replace(LT,\"\\\\u003c\"):(dust.log(\"JSON is undefined; could not escape `\"+a+\"`\",WARN),a)},dust}),function(a,b){\"function\"==typeof define&&define.amd&&define.amd.dust===!0?define(\"dust.parse\",[\"dust.core\"],function(dust){return b(dust).parse}):\"object\"==typeof exports?module.exports=b(require(\"./dust\")):b(a.dust)}(this,function(dust){var a=function(){function a(a,b){function c(){this.constructor=a}c.prototype=b.prototype,a.prototype=new c}function b(a,b,c,d,e,f){this.message=a,this.expected=b,this.found=c,this.offset=d,this.line=e,this.column=f,this.name=\"SyntaxError\"}function c(a){function c(){return f(wc).line}function d(){return f(wc).column}function e(a){throw h(a,null,wc)}function f(b){function c(b,c,d){var e,f;for(e=c;d>e;e++)f=a.charAt(e),\"\\n\"===f?(b.seenCR||b.line++,b.column=1,b.seenCR=!1):\"\\r\"===f||\"\\u2028\"===f||\"\\u2029\"===f?(b.line++,b.column=1,b.seenCR=!0):(b.column++,b.seenCR=!1)}return xc!==b&&(xc>b&&(xc=0,yc={line:1,column:1,seenCR:!1}),c(yc,xc,b),xc=b),yc}function g(a){zc>vc||(vc>zc&&(zc=vc,Ac=[]),Ac.push(a))}function h(c,d,e){function g(a){var b=1;for(a.sort(function(a,b){return a.description<b.description?-1:a.description>b.description?1:0});b<a.length;)a[b-1]===a[b]?a.splice(b,1):b++}function h(a,b){function c(a){function b(a){return a.charCodeAt(0).toString(16).toUpperCase()}return a.replace(/\\\\/g,\"\\\\\\\\\").replace(/\"/g,'\\\\\"').replace(/\\x08/g,\"\\\\b\").replace(/\\t/g,\"\\\\t\").replace(/\\n/g,\"\\\\n\").replace(/\\f/g,\"\\\\f\").replace(/\\r/g,\"\\\\r\").replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g,function(a){return\"\\\\x0\"+b(a)}).replace(/[\\x10-\\x1F\\x80-\\xFF]/g,function(a){return\"\\\\x\"+b(a)}).replace(/[\\u0180-\\u0FFF]/g,function(a){return\"\\\\u0\"+b(a)}).replace(/[\\u1080-\\uFFFF]/g,function(a){return\"\\\\u\"+b(a)})}var d,e,f,g=new Array(a.length);for(f=0;f<a.length;f++)g[f]=a[f].description;return d=a.length>1?g.slice(0,-1).join(\", \")+\" or \"+g[a.length-1]:g[0],e=b?'\"'+c(b)+'\"':\"end of input\",\"Expected \"+d+\" but \"+e+\" found.\"}var i=f(e),j=e<a.length?a.charAt(e):null;return null!==d&&g(d),new b(null!==c?c:h(d,j),d,j,e,i.line,i.column)}function i(){var a;return a=j()}function j(){var a,b,c;for(a=vc,b=[],c=k();c!==X;)b.push(c),c=k();return b!==X&&(wc=a,b=$(b)),a=b}function k(){var a;return a=K(),a===X&&(a=L(),a===X&&(a=l(),a===X&&(a=s(),a===X&&(a=u(),a===X&&(a=r(),a===X&&(a=H())))))),a}function l(){var b,c,d,e,f,h,i,k;if(Bc++,b=vc,c=m(),c!==X){for(d=[],e=S();e!==X;)d.push(e),e=S();d!==X?(e=O(),e!==X?(f=j(),f!==X?(h=q(),h!==X?(i=n(),i===X&&(i=ba),i!==X?(wc=vc,k=ca(c,f,h,i),k=k?da:aa,k!==X?(wc=b,c=ea(c,f,h,i),b=c):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa)}else vc=b,b=aa;if(b===X)if(b=vc,c=m(),c!==X){for(d=[],e=S();e!==X;)d.push(e),e=S();d!==X?(47===a.charCodeAt(vc)?(e=fa,vc++):(e=X,0===Bc&&g(ga)),e!==X?(f=O(),f!==X?(wc=b,c=ha(c),b=c):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa)}else vc=b,b=aa;return Bc--,b===X&&(c=X,0===Bc&&g(_)),b}function m(){var b,c,d,e,f,h,i;if(b=vc,c=N(),c!==X)if(ia.test(a.charAt(vc))?(d=a.charAt(vc),vc++):(d=X,0===Bc&&g(ja)),d!==X){for(e=[],f=S();f!==X;)e.push(f),f=S();e!==X?(f=v(),f!==X?(h=o(),h!==X?(i=p(),i!==X?(wc=b,c=ka(d,f,h,i),b=c):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa)}else vc=b,b=aa;else vc=b,b=aa;return b}function n(){var b,c,d,e,f,h,i;if(Bc++,b=vc,c=N(),c!==X)if(47===a.charCodeAt(vc)?(d=fa,vc++):(d=X,0===Bc&&g(ga)),d!==X){for(e=[],f=S();f!==X;)e.push(f),f=S();if(e!==X)if(f=v(),f!==X){for(h=[],i=S();i!==X;)h.push(i),i=S();h!==X?(i=O(),i!==X?(wc=b,c=ma(f),b=c):(vc=b,b=aa)):(vc=b,b=aa)}else vc=b,b=aa;else vc=b,b=aa}else vc=b,b=aa;else vc=b,b=aa;return Bc--,b===X&&(c=X,0===Bc&&g(la)),b}function o(){var b,c,d,e;return b=vc,c=vc,58===a.charCodeAt(vc)?(d=na,vc++):(d=X,0===Bc&&g(oa)),d!==X?(e=v(),e!==X?(wc=c,d=pa(e),c=d):(vc=c,c=aa)):(vc=c,c=aa),c===X&&(c=ba),c!==X&&(wc=b,c=qa(c)),b=c}function p(){var b,c,d,e,f,h,i;if(Bc++,b=vc,c=[],d=vc,e=[],f=S(),f!==X)for(;f!==X;)e.push(f),f=S();else e=aa;for(e!==X?(f=C(),f!==X?(61===a.charCodeAt(vc)?(h=sa,vc++):(h=X,0===Bc&&g(ta)),h!==X?(i=w(),i===X&&(i=v(),i===X&&(i=F())),i!==X?(wc=d,e=ua(f,i),d=e):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa);d!==X;){if(c.push(d),d=vc,e=[],f=S(),f!==X)for(;f!==X;)e.push(f),f=S();else e=aa;e!==X?(f=C(),f!==X?(61===a.charCodeAt(vc)?(h=sa,vc++):(h=X,0===Bc&&g(ta)),h!==X?(i=w(),i===X&&(i=v(),i===X&&(i=F())),i!==X?(wc=d,e=ua(f,i),d=e):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)}return c!==X&&(wc=b,c=va(c)),b=c,Bc--,b===X&&(c=X,0===Bc&&g(ra)),b}function q(){var b,c,d,e,f,h,i,k;for(Bc++,b=vc,c=[],d=vc,e=N(),e!==X?(58===a.charCodeAt(vc)?(f=na,vc++):(f=X,0===Bc&&g(oa)),f!==X?(h=C(),h!==X?(i=O(),i!==X?(k=j(),k!==X?(wc=d,e=ua(h,k),d=e):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa);d!==X;)c.push(d),d=vc,e=N(),e!==X?(58===a.charCodeAt(vc)?(f=na,vc++):(f=X,0===Bc&&g(oa)),f!==X?(h=C(),h!==X?(i=O(),i!==X?(k=j(),k!==X?(wc=d,e=ua(h,k),d=e):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa);return c!==X&&(wc=b,c=xa(c)),b=c,Bc--,b===X&&(c=X,0===Bc&&g(wa)),b}function r(){var a,b,c,d,e;return Bc++,a=vc,b=N(),b!==X?(c=v(),c!==X?(d=t(),d!==X?(e=O(),e!==X?(wc=a,b=za(c,d),a=b):(vc=a,a=aa)):(vc=a,a=aa)):(vc=a,a=aa)):(vc=a,a=aa),Bc--,a===X&&(b=X,0===Bc&&g(ya)),a}function s(){var b,c,d,e,f,h,i,j,k,l;if(Bc++,b=vc,c=N(),c!==X)if(62===a.charCodeAt(vc)?(d=Ba,vc++):(d=X,0===Bc&&g(Ca)),d===X&&(43===a.charCodeAt(vc)?(d=Da,vc++):(d=X,0===Bc&&g(Ea))),d!==X){for(e=[],f=S();f!==X;)e.push(f),f=S();if(e!==X)if(f=vc,h=C(),h!==X&&(wc=f,h=Fa(h)),f=h,f===X&&(f=F()),f!==X)if(h=o(),h!==X)if(i=p(),i!==X){for(j=[],k=S();k!==X;)j.push(k),k=S();j!==X?(47===a.charCodeAt(vc)?(k=fa,vc++):(k=X,0===Bc&&g(ga)),k!==X?(l=O(),l!==X?(wc=b,c=Ga(d,f,h,i),b=c):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa)}else vc=b,b=aa;else vc=b,b=aa;else vc=b,b=aa;else vc=b,b=aa}else vc=b,b=aa;else vc=b,b=aa;return Bc--,b===X&&(c=X,0===Bc&&g(Aa)),b}function t(){var b,c,d,e,f;for(Bc++,b=vc,c=[],d=vc,124===a.charCodeAt(vc)?(e=Ia,vc++):(e=X,0===Bc&&g(Ja)),e!==X?(f=C(),f!==X?(wc=d,e=pa(f),d=e):(vc=d,d=aa)):(vc=d,d=aa);d!==X;)c.push(d),d=vc,124===a.charCodeAt(vc)?(e=Ia,vc++):(e=X,0===Bc&&g(Ja)),e!==X?(f=C(),f!==X?(wc=d,e=pa(f),d=e):(vc=d,d=aa)):(vc=d,d=aa);return c!==X&&(wc=b,c=Ka(c)),b=c,Bc--,b===X&&(c=X,0===Bc&&g(Ha)),b}function u(){var b,c,d,e,f;return Bc++,b=vc,c=N(),c!==X?(126===a.charCodeAt(vc)?(d=Ma,vc++):(d=X,0===Bc&&g(Na)),d!==X?(e=C(),e!==X?(f=O(),f!==X?(wc=b,c=Oa(e),b=c):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa),Bc--,b===X&&(c=X,0===Bc&&g(La)),b}function v(){var a,b;return Bc++,a=vc,b=B(),b!==X&&(wc=a,b=Qa(b)),a=b,a===X&&(a=vc,b=C(),b!==X&&(wc=a,b=Ra(b)),a=b),Bc--,a===X&&(b=X,0===Bc&&g(Pa)),a}function w(){var a,b;return Bc++,a=vc,b=x(),b===X&&(b=A()),b!==X&&(wc=a,b=Ta(b)),a=b,Bc--,a===X&&(b=X,0===Bc&&g(Sa)),a}function x(){var b,c,d,e;return Bc++,b=vc,c=A(),c!==X?(46===a.charCodeAt(vc)?(d=Va,vc++):(d=X,0===Bc&&g(Wa)),d!==X?(e=y(),e!==X?(wc=b,c=Xa(c,e),b=c):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa),Bc--,b===X&&(c=X,0===Bc&&g(Ua)),b}function y(){var b,c,d;if(Bc++,b=vc,c=[],Za.test(a.charAt(vc))?(d=a.charAt(vc),vc++):(d=X,0===Bc&&g($a)),d!==X)for(;d!==X;)c.push(d),Za.test(a.charAt(vc))?(d=a.charAt(vc),vc++):(d=X,0===Bc&&g($a));else c=aa;return c!==X&&(wc=b,c=_a(c)),b=c,Bc--,b===X&&(c=X,0===Bc&&g(Ya)),b}function z(){var b,c,d;return Bc++,b=vc,45===a.charCodeAt(vc)?(c=bb,vc++):(c=X,0===Bc&&g(cb)),c!==X?(d=y(),d!==X?(wc=b,c=db(c,d),b=c):(vc=b,b=aa)):(vc=b,b=aa),Bc--,b===X&&(c=X,0===Bc&&g(ab)),b}function A(){var a,b;return Bc++,a=z(),a===X&&(a=y()),Bc--,a===X&&(b=X,0===Bc&&g(eb)),a}function B(){var b,c,d,e;if(Bc++,b=vc,c=C(),c===X&&(c=ba),c!==X){if(d=[],e=E(),e===X&&(e=D()),e!==X)for(;e!==X;)d.push(e),e=E(),e===X&&(e=D());else d=aa;d!==X?(wc=b,c=gb(c,d),b=c):(vc=b,b=aa)}else vc=b,b=aa;if(b===X)if(b=vc,46===a.charCodeAt(vc)?(c=Va,vc++):(c=X,0===Bc&&g(Wa)),c!==X){for(d=[],e=E(),e===X&&(e=D());e!==X;)d.push(e),e=E(),e===X&&(e=D());d!==X?(wc=b,c=hb(d),b=c):(vc=b,b=aa)}else vc=b,b=aa;return Bc--,b===X&&(c=X,0===Bc&&g(fb)),b}function C(){var b,c,d,e;if(Bc++,b=vc,jb.test(a.charAt(vc))?(c=a.charAt(vc),vc++):(c=X,0===Bc&&g(kb)),c!==X){for(d=[],lb.test(a.charAt(vc))?(e=a.charAt(vc),vc++):(e=X,0===Bc&&g(mb));e!==X;)d.push(e),lb.test(a.charAt(vc))?(e=a.charAt(vc),vc++):(e=X,0===Bc&&g(mb));d!==X?(wc=b,c=nb(c,d),b=c):(vc=b,b=aa)}else vc=b,b=aa;return Bc--,b===X&&(c=X,0===Bc&&g(ib)),b}function D(){var b,c,d,e,f,h;if(Bc++,b=vc,c=vc,d=P(),d!==X){if(e=vc,f=[],Za.test(a.charAt(vc))?(h=a.charAt(vc),vc++):(h=X,0===Bc&&g($a)),h!==X)for(;h!==X;)f.push(h),Za.test(a.charAt(vc))?(h=a.charAt(vc),vc++):(h=X,0===Bc&&g($a));else f=aa;f!==X&&(wc=e,f=pb(f)),e=f,e===X&&(e=v()),e!==X?(f=Q(),f!==X?(wc=c,d=qb(e),c=d):(vc=c,c=aa)):(vc=c,c=aa)}else vc=c,c=aa;return c!==X?(d=E(),d===X&&(d=ba),d!==X?(wc=b,c=rb(c,d),b=c):(vc=b,b=aa)):(vc=b,b=aa),Bc--,b===X&&(c=X,0===Bc&&g(ob)),b}function E(){var b,c,d,e,f;if(Bc++,b=vc,c=[],d=vc,46===a.charCodeAt(vc)?(e=Va,vc++):(e=X,0===Bc&&g(Wa)),e!==X?(f=C(),f!==X?(wc=d,e=tb(f),d=e):(vc=d,d=aa)):(vc=d,d=aa),d!==X)for(;d!==X;)c.push(d),d=vc,46===a.charCodeAt(vc)?(e=Va,vc++):(e=X,0===Bc&&g(Wa)),e!==X?(f=C(),f!==X?(wc=d,e=tb(f),d=e):(vc=d,d=aa)):(vc=d,d=aa);else c=aa;return c!==X?(d=D(),d===X&&(d=ba),d!==X?(wc=b,c=ub(c,d),b=c):(vc=b,b=aa)):(vc=b,b=aa),Bc--,b===X&&(c=X,0===Bc&&g(sb)),b}function F(){var b,c,d,e;if(Bc++,b=vc,34===a.charCodeAt(vc)?(c=wb,vc++):(c=X,0===Bc&&g(xb)),c!==X?(34===a.charCodeAt(vc)?(d=wb,vc++):(d=X,0===Bc&&g(xb)),d!==X?(wc=b,c=yb(),b=c):(vc=b,b=aa)):(vc=b,b=aa),b===X&&(b=vc,34===a.charCodeAt(vc)?(c=wb,vc++):(c=X,0===Bc&&g(xb)),c!==X?(d=I(),d!==X?(34===a.charCodeAt(vc)?(e=wb,vc++):(e=X,0===Bc&&g(xb)),e!==X?(wc=b,c=zb(d),b=c):(vc=b,b=aa)):(vc=b,b=aa)):(vc=b,b=aa),b===X))if(b=vc,34===a.charCodeAt(vc)?(c=wb,vc++):(c=X,0===Bc&&g(xb)),c!==X){if(d=[],e=G(),e!==X)for(;e!==X;)d.push(e),e=G();else d=aa;d!==X?(34===a.charCodeAt(vc)?(e=wb,vc++):(e=X,0===Bc&&g(xb)),e!==X?(wc=b,c=Ab(d),b=c):(vc=b,b=aa)):(vc=b,b=aa)}else vc=b,b=aa;return Bc--,b===X&&(c=X,0===Bc&&g(vb)),b}function G(){var a,b;return a=u(),a===X&&(a=r(),a===X&&(a=vc,b=I(),b!==X&&(wc=a,b=Bb(b)),a=b)),a}function H(){var b,c,d,e,f,h,i,j;if(Bc++,b=vc,c=R(),c!==X){for(d=[],e=S();e!==X;)d.push(e),e=S();d!==X?(wc=b,c=Db(c,d),b=c):(vc=b,b=aa)}else vc=b,b=aa;if(b===X){if(b=vc,c=[],d=vc,e=vc,Bc++,f=M(),Bc--,f===X?e=da:(vc=e,e=aa),e!==X?(f=vc,Bc++,h=K(),Bc--,h===X?f=da:(vc=f,f=aa),f!==X?(h=vc,Bc++,i=L(),Bc--,i===X?h=da:(vc=h,h=aa),h!==X?(i=vc,Bc++,j=R(),Bc--,j===X?i=da:(vc=i,i=aa),i!==X?(a.length>vc?(j=a.charAt(vc),vc++):(j=X,0===Bc&&g(Eb)),j!==X?(wc=d,e=Fb(j),d=e):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa),d!==X)for(;d!==X;)c.push(d),d=vc,e=vc,Bc++,f=M(),Bc--,f===X?e=da:(vc=e,e=aa),e!==X?(f=vc,Bc++,h=K(),Bc--,h===X?f=da:(vc=f,f=aa),f!==X?(h=vc,Bc++,i=L(),Bc--,i===X?h=da:(vc=h,h=aa),h!==X?(i=vc,Bc++,j=R(),Bc--,j===X?i=da:(vc=i,i=aa),i!==X?(a.length>vc?(j=a.charAt(vc),vc++):(j=X,0===Bc&&g(Eb)),j!==X?(wc=d,e=Fb(j),d=e):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa)):(vc=d,d=aa);else c=aa;c!==X&&(wc=b,c=Gb(c)),b=c}return Bc--,b===X&&(c=X,0===Bc&&g(Cb)),b}function I(){var b,c,d,e,f;if(Bc++,b=vc,c=[],d=vc,e=vc,Bc++,f=M(),Bc--,f===X?e=da:(vc=e,e=aa),e!==X?(f=J(),f===X&&(Ib.test(a.charAt(vc))?(f=a.charAt(vc),vc++):(f=X,0===Bc&&g(Jb))),f!==X?(wc=d,e=Fb(f),d=e):(vc=d,d=aa)):(vc=d,d=aa),d!==X)for(;d!==X;)c.push(d),d=vc,e=vc,Bc++,f=M(),Bc--,f===X?e=da:(vc=e,e=aa),e!==X?(f=J(),f===X&&(Ib.test(a.charAt(vc))?(f=a.charAt(vc),vc++):(f=X,0===Bc&&g(Jb))),f!==X?(wc=d,e=Fb(f),d=e):(vc=d,d=aa)):(vc=d,d=aa);else c=aa;return c!==X&&(wc=b,c=Kb(c)),b=c,Bc--,b===X&&(c=X,0===Bc&&g(Hb)),b}function J(){var b,c;return b=vc,a.substr(vc,2)===Lb?(c=Lb,vc+=2):(c=X,0===Bc&&g(Mb)),c!==X&&(wc=b,c=Nb()),b=c}function K(){var b,c,d,e,f,h;if(Bc++,b=vc,a.substr(vc,2)===Pb?(c=Pb,vc+=2):(c=X,0===Bc&&g(Qb)),c!==X){for(d=[],e=vc,f=vc,Bc++,a.substr(vc,2)===Rb?(h=Rb,vc+=2):(h=X,0===Bc&&g(Sb)),Bc--,h===X?f=da:(vc=f,f=aa),f!==X?(a.length>vc?(h=a.charAt(vc),vc++):(h=X,0===Bc&&g(Eb)),h!==X?(wc=e,f=Tb(h),e=f):(vc=e,e=aa)):(vc=e,e=aa);e!==X;)d.push(e),e=vc,f=vc,Bc++,a.substr(vc,2)===Rb?(h=Rb,vc+=2):(h=X,0===Bc&&g(Sb)),Bc--,h===X?f=da:(vc=f,f=aa),f!==X?(a.length>vc?(h=a.charAt(vc),vc++):(h=X,0===Bc&&g(Eb)),h!==X?(wc=e,f=Tb(h),e=f):(vc=e,e=aa)):(vc=e,e=aa);d!==X?(a.substr(vc,2)===Rb?(e=Rb,vc+=2):(e=X,0===Bc&&g(Sb)),e!==X?(wc=b,c=Ub(d),b=c):(vc=b,b=aa)):(vc=b,b=aa)}else vc=b,b=aa;return Bc--,b===X&&(c=X,0===Bc&&g(Ob)),b}function L(){var b,c,d,e,f,h;if(Bc++,b=vc,a.substr(vc,2)===Wb?(c=Wb,vc+=2):(c=X,0===Bc&&g(Xb)),c!==X){for(d=[],e=vc,f=vc,Bc++,a.substr(vc,2)===Yb?(h=Yb,vc+=2):(h=X,0===Bc&&g(Zb)),Bc--,h===X?f=da:(vc=f,f=aa),f!==X?(a.length>vc?(h=a.charAt(vc),vc++):(h=X,0===Bc&&g(Eb)),h!==X?(wc=e,f=Fb(h),e=f):(vc=e,e=aa)):(vc=e,e=aa);e!==X;)d.push(e),e=vc,f=vc,Bc++,a.substr(vc,2)===Yb?(h=Yb,vc+=2):(h=X,0===Bc&&g(Zb)),Bc--,h===X?f=da:(vc=f,f=aa),f!==X?(a.length>vc?(h=a.charAt(vc),vc++):(h=X,0===Bc&&g(Eb)),h!==X?(wc=e,f=Fb(h),e=f):(vc=e,e=aa)):(vc=e,e=aa);d!==X?(a.substr(vc,2)===Yb?(e=Yb,vc+=2):(e=X,0===Bc&&g(Zb)),e!==X?(wc=b,c=$b(d),b=c):(vc=b,b=aa)):(vc=b,b=aa)}else vc=b,b=aa;return Bc--,b===X&&(c=X,0===Bc&&g(Vb)),b}function M(){var b,c,d,e,f,h,i,j,k,l;if(b=vc,c=N(),c!==X){for(d=[],e=S();e!==X;)d.push(e),e=S();if(d!==X)if(_b.test(a.charAt(vc))?(e=a.charAt(vc),vc++):(e=X,0===Bc&&g(ac)),e!==X){for(f=[],h=S();h!==X;)f.push(h),h=S();if(f!==X){if(h=[],i=vc,j=vc,Bc++,k=O(),Bc--,k===X?j=da:(vc=j,j=aa),j!==X?(k=vc,Bc++,l=R(),Bc--,l===X?k=da:(vc=k,k=aa),k!==X?(a.length>vc?(l=a.charAt(vc),vc++):(l=X,0===Bc&&g(Eb)),l!==X?(j=[j,k,l],i=j):(vc=i,i=aa)):(vc=i,i=aa)):(vc=i,i=aa),i!==X)for(;i!==X;)h.push(i),i=vc,j=vc,Bc++,k=O(),Bc--,k===X?j=da:(vc=j,j=aa),j!==X?(k=vc,Bc++,l=R(),Bc--,l===X?k=da:(vc=k,k=aa),k!==X?(a.length>vc?(l=a.charAt(vc),vc++):(l=X,0===Bc&&g(Eb)),l!==X?(j=[j,k,l],i=j):(vc=i,i=aa)):(vc=i,i=aa)):(vc=i,i=aa);else h=aa;if(h!==X){for(i=[],j=S();j!==X;)i.push(j),j=S();i!==X?(j=O(),j!==X?(c=[c,d,e,f,h,i,j],b=c):(vc=b,b=aa)):(vc=b,b=aa)}else vc=b,b=aa}else vc=b,b=aa}else vc=b,b=aa;else vc=b,b=aa}else vc=b,b=aa;return b===X&&(b=r()),b}function N(){var b;return 123===a.charCodeAt(vc)?(b=bc,vc++):(b=X,0===Bc&&g(cc)),b}function O(){var b;return 125===a.charCodeAt(vc)?(b=dc,vc++):(b=X,0===Bc&&g(ec)),b}function P(){var b;return 91===a.charCodeAt(vc)?(b=fc,vc++):(b=X,0===Bc&&g(gc)),b}function Q(){var b;return 93===a.charCodeAt(vc)?(b=hc,vc++):(b=X,0===Bc&&g(ic)),b}function R(){var b;return 10===a.charCodeAt(vc)?(b=jc,vc++):(b=X,0===Bc&&g(kc)),b===X&&(a.substr(vc,2)===lc?(b=lc,vc+=2):(b=X,0===Bc&&g(mc)),b===X&&(13===a.charCodeAt(vc)?(b=nc,vc++):(b=X,0===Bc&&g(oc)),b===X&&(8232===a.charCodeAt(vc)?(b=pc,vc++):(b=X,0===Bc&&g(qc)),b===X&&(8233===a.charCodeAt(vc)?(b=rc,vc++):(b=X,0===Bc&&g(sc)))))),b}function S(){var b;return tc.test(a.charAt(vc))?(b=a.charAt(vc),vc++):(b=X,0===Bc&&g(uc)),b===X&&(b=R()),b}function T(a){return parseInt(a.join(\"\"),10)}function U(a){return a.concat([[\"line\",c()],[\"col\",d()]])}var V,W=arguments.length>1?arguments[1]:{},X={},Y={start:i},Z=i,$=function(a){var b=[\"body\"].concat(a);return U(b)},_={type:\"other\",description:\"section\"},aa=X,ba=null,ca=function(a,b,c,d){return d&&a[1].text===d.text||e(\"Expected end tag for \"+a[1].text+\" but it was not found.\"),!0},da=void 0,ea=function(a,b,c){return c.push([\"param\",[\"literal\",\"block\"],b]),a.push(c,[\"filters\"]),U(a)},fa=\"/\",ga={type:\"literal\",value:\"/\",description:'\"/\"'},ha=function(a){return a.push([\"bodies\"],[\"filters\"]),U(a)},ia=/^[#?\\^<+@%]/,ja={type:\"class\",value:\"[#?\\\\^<+@%]\",description:\"[#?\\\\^<+@%]\"},ka=function(a,b,c,d){return[a,b,c,d]},la={type:\"other\",description:\"end tag\"},ma=function(a){return a},na=\":\",oa={type:\"literal\",value:\":\",description:'\":\"'},pa=function(a){return a},qa=function(a){return a?[\"context\",a]:[\"context\"]},ra={type:\"other\",description:\"params\"},sa=\"=\",ta={type:\"literal\",value:\"=\",description:'\"=\"'},ua=function(a,b){return[\"param\",[\"literal\",a],b]},va=function(a){return[\"params\"].concat(a)},wa={type:\"other\",description:\"bodies\"},xa=function(a){return[\"bodies\"].concat(a)},ya={type:\"other\",description:\"reference\"},za=function(a,b){return U([\"reference\",a,b])},Aa={type:\"other\",description:\"partial\"},Ba=\">\",Ca={type:\"literal\",value:\">\",description:'\">\"'},Da=\"+\",Ea={type:\"literal\",value:\"+\",description:'\"+\"'},Fa=function(a){return[\"literal\",a]},Ga=function(a,b,c,d){var e=\">\"===a?\"partial\":a;return U([e,b,c,d])},Ha={type:\"other\",description:\"filters\"},Ia=\"|\",Ja={type:\"literal\",value:\"|\",description:'\"|\"'},Ka=function(a){return[\"filters\"].concat(a)},La={type:\"other\",description:\"special\"},Ma=\"~\",Na={type:\"literal\",value:\"~\",description:'\"~\"'},Oa=function(a){return U([\"special\",a])},Pa={type:\"other\",description:\"identifier\"},Qa=function(a){var b=[\"path\"].concat(a);return b.text=a[1].join(\".\").replace(/,line,\\d+,col,\\d+/g,\"\"),b},Ra=function(a){var b=[\"key\",a];return b.text=a,b},Sa={type:\"other\",description:\"number\"},Ta=function(a){return[\"literal\",a]},Ua={type:\"other\",description:\"float\"},Va=\".\",Wa={type:\"literal\",value:\".\",description:'\".\"'},Xa=function(a,b){return parseFloat(a+\".\"+b)},Ya={type:\"other\",description:\"unsigned_integer\"},Za=/^[0-9]/,$a={type:\"class\",value:\"[0-9]\",description:\"[0-9]\"},_a=function(a){return T(a)},ab={type:\"other\",description:\"signed_integer\"},bb=\"-\",cb={type:\"literal\",value:\"-\",description:'\"-\"'},db=function(a,b){return-1*b},eb={type:\"other\",description:\"integer\"},fb={type:\"other\",description:\"path\"},gb=function(a,b){return b=b[0],a&&b?(b.unshift(a),U([!1,b])):U([!0,b])},hb=function(a){return U(a.length>0?[!0,a[0]]:[!0,[]])},ib={type:\"other\",description:\"key\"},jb=/^[a-zA-Z_$]/,kb={type:\"class\",value:\"[a-zA-Z_$]\",description:\"[a-zA-Z_$]\"},lb=/^[0-9a-zA-Z_$\\-]/,mb={type:\"class\",value:\"[0-9a-zA-Z_$\\\\-]\",description:\"[0-9a-zA-Z_$\\\\-]\"},nb=function(a,b){return a+b.join(\"\")},ob={type:\"other\",description:\"array\"},pb=function(a){return a.join(\"\")},qb=function(a){return a},rb=function(a,b){return b?b.unshift(a):b=[a],b},sb={type:\"other\",description:\"array_part\"},tb=function(a){return a},ub=function(a,b){return b?a.concat(b):a},vb={type:\"other\",description:\"inline\"},wb='\"',xb={type:\"literal\",value:'\"',description:'\"\\\\\"\"'},yb=function(){return U([\"literal\",\"\"])},zb=function(a){return U([\"literal\",a])},Ab=function(a){return U([\"body\"].concat(a))},Bb=function(a){return[\"buffer\",a]},Cb={type:\"other\",description:\"buffer\"},Db=function(a,b){return U([\"format\",a,b.join(\"\")])},Eb={type:\"any\",description:\"any character\"},Fb=function(a){return a},Gb=function(a){return U([\"buffer\",a.join(\"\")])},Hb={type:\"other\",description:\"literal\"},Ib=/^[^\"]/,Jb={type:\"class\",value:'[^\"]',description:'[^\"]'},Kb=function(a){return a.join(\"\")},Lb='\\\\\"',Mb={type:\"literal\",value:'\\\\\"',description:'\"\\\\\\\\\\\\\"\"'},Nb=function(){return'\"'},Ob={type:\"other\",description:\"raw\"},Pb=\"{`\",Qb={type:\"literal\",value:\"{`\",description:'\"{`\"'},Rb=\"`}\",Sb={type:\"literal\",value:\"`}\",description:'\"`}\"'},Tb=function(a){return a},Ub=function(a){return U([\"raw\",a.join(\"\")])},Vb={type:\"other\",description:\"comment\"},Wb=\"{!\",Xb={type:\"literal\",value:\"{!\",description:'\"{!\"'},Yb=\"!}\",Zb={type:\"literal\",value:\"!}\",description:'\"!}\"'},$b=function(a){return U([\"comment\",a.join(\"\")])},_b=/^[#?\\^><+%:@\\/~%]/,ac={type:\"class\",value:\"[#?\\\\^><+%:@\\\\/~%]\",description:\"[#?\\\\^><+%:@\\\\/~%]\"},bc=\"{\",cc={type:\"literal\",value:\"{\",description:'\"{\"'},dc=\"}\",ec={type:\"literal\",value:\"}\",description:'\"}\"'},fc=\"[\",gc={type:\"literal\",value:\"[\",description:'\"[\"'},hc=\"]\",ic={type:\"literal\",value:\"]\",description:'\"]\"'},jc=\"\\n\",kc={type:\"literal\",value:\"\\n\",description:'\"\\\\n\"'},lc=\"\\r\\n\",mc={type:\"literal\",\nvalue:\"\\r\\n\",description:'\"\\\\r\\\\n\"'},nc=\"\\r\",oc={type:\"literal\",value:\"\\r\",description:'\"\\\\r\"'},pc=\"\\u2028\",qc={type:\"literal\",value:\"\\u2028\",description:'\"\\\\u2028\"'},rc=\"\\u2029\",sc={type:\"literal\",value:\"\\u2029\",description:'\"\\\\u2029\"'},tc=/^[\\t\\x0B\\f \\xA0\\uFEFF]/,uc={type:\"class\",value:\"[\\\\t\\\\x0B\\\\f \\\\xA0\\\\uFEFF]\",description:\"[\\\\t\\\\x0B\\\\f \\\\xA0\\\\uFEFF]\"},vc=0,wc=0,xc=0,yc={line:1,column:1,seenCR:!1},zc=0,Ac=[],Bc=0;if(\"startRule\"in W){if(!(W.startRule in Y))throw new Error(\"Can't start parsing from rule \\\"\"+W.startRule+'\".');Z=Y[W.startRule]}if(V=Z(),V!==X&&vc===a.length)return V;throw V!==X&&vc<a.length&&g({type:\"end\",description:\"end of input\"}),h(null,Ac,zc)}return a(b,Error),{SyntaxError:b,parse:c}}();return dust.parse=a.parse,a}),function(a,b){\"function\"==typeof define&&define.amd&&define.amd.dust===!0?define(\"dust.compile\",[\"dust.core\",\"dust.parse\"],function(dust,a){return b(a,dust).compile}):\"object\"==typeof exports?module.exports=b(require(\"./parser\").parse,require(\"./dust\")):b(a.dust.parse,a.dust)}(this,function(a,dust){function b(a){var b={};return r.filterNode(b,a)}function c(a,b){var c,d,e,f=[b[0]];for(c=1,d=b.length;d>c;c++)e=r.filterNode(a,b[c]),e&&f.push(e);return f}function d(a,b){var c,d,e,f,g=[b[0]];for(d=1,e=b.length;e>d;d++)f=r.filterNode(a,b[d]),f&&(\"buffer\"===f[0]||\"format\"===f[0]?c?(c[0]=\"buffer\"===f[0]?\"buffer\":c[0],c[1]+=f.slice(1,-2).join(\"\")):(c=f,g.push(f)):(c=null,g.push(f)));return g}function e(a,b){return[\"buffer\",t[b[1]],b[2],b[3]]}function f(a,b){return b}function g(){}function h(a,b){return dust.config.whitespace?(b.splice(1,2,b.slice(1,-2).join(\"\")),b):null}function i(a,b){var c,d={name:b,bodies:[],blocks:{},index:0,auto:\"h\"},e=dust.escapeJs(b),f=b?'\"'+e+'\",':\"\",g=\"function(dust){\",h=r.compileNode(d,a);return b&&(g+='dust.register(\"'+e+'\",'+h+\");\"),g+=j(d)+k(d)+\"return \"+h+\"}\",c=\"(\"+g+\"(dust));\",dust.config.amd?\"define(\"+f+'[\"dust.core\"],'+g+\");\":dust.config.cjs?\"module.exports=function(dust){var tmpl=\"+c+\"var f=\"+q().toString()+\";f.template=tmpl;return f}\":c}function j(a){var b,c=[],d=a.blocks;for(b in d)c.push('\"'+b+'\":'+d[b]);return c.length?(a.blocks=\"ctx=ctx.shiftBlocks(blocks);\",\"var blocks={\"+c.join(\",\")+\"};\"):(a.blocks=\"\",a.blocks)}function k(a){var b,c,d=[],e=a.bodies,f=a.blocks;for(b=0,c=e.length;c>b;b++)d[b]=\"function body_\"+b+\"(chk,ctx){\"+f+\"return chk\"+e[b]+\";}body_\"+b+\".__dustBody=!0;\";return d.join(\"\")}function l(a,b){var c,d,e=\"\";for(c=1,d=b.length;d>c;c++)e+=r.compileNode(a,b[c]);return e}function m(a,b,c){return\".\"+(dust._aliases[c]||c)+\"(\"+r.compileNode(a,b[1])+\",\"+r.compileNode(a,b[2])+\",\"+r.compileNode(a,b[4])+\",\"+r.compileNode(a,b[3])+\")\"}function n(a){return a.replace(u,\"\\\\\\\\\").replace(v,'\\\\\"').replace(w,\"\\\\f\").replace(x,\"\\\\n\").replace(y,\"\\\\r\").replace(z,\"\\\\t\")}function o(a,b,c){var d=dust.loadSource(dust.compile(a));return q(d)(b,c)}function p(a,b){var c=dust.loadSource(dust.compile(a,b));return q(c)}function q(a){return function(b,c){var d=c?\"render\":\"stream\";return dust[d](a,b,c)}}var r={},s=dust.isArray;r.compile=function(c,d){try{var e=b(a(c));return i(e,d)}catch(f){if(!f.line||!f.column)throw f;throw new SyntaxError(f.message+\" At line : \"+f.line+\", column : \"+f.column)}},r.filterNode=function(a,b){return r.optimizers[b[0]](a,b)},r.optimizers={body:d,buffer:f,special:e,format:h,reference:c,\"#\":c,\"?\":c,\"^\":c,\"<\":c,\"+\":c,\"@\":c,\"%\":c,partial:c,context:c,params:c,bodies:c,param:c,filters:f,key:f,path:f,literal:f,raw:f,comment:g,line:g,col:g},r.pragmas={esc:function(a,b,c){var d,e=a.auto;return b||(b=\"h\"),a.auto=\"s\"===b?\"\":b,d=l(a,c.block),a.auto=e,d}};var t={s:\" \",n:\"\\n\",r:\"\\r\",lb:\"{\",rb:\"}\"};r.compileNode=function(a,b){return r.nodes[b[0]](a,b)},r.nodes={body:function(a,b){var c=a.index++,d=\"body_\"+c;return a.bodies[c]=l(a,b),d},buffer:function(a,b){return\".w(\"+A(b[1])+\")\"},format:function(a,b){return\".w(\"+A(b[1])+\")\"},reference:function(a,b){return\".f(\"+r.compileNode(a,b[1])+\",ctx,\"+r.compileNode(a,b[2])+\")\"},\"#\":function(a,b){return m(a,b,\"section\")},\"?\":function(a,b){return m(a,b,\"exists\")},\"^\":function(a,b){return m(a,b,\"notexists\")},\"<\":function(a,b){for(var c=b[4],d=1,e=c.length;e>d;d++){var f=c[d],g=f[1][1];if(\"block\"===g)return a.blocks[b[1].text]=r.compileNode(a,f[2]),\"\"}return\"\"},\"+\":function(a,b){return\"undefined\"==typeof b[1].text&&\"undefined\"==typeof b[4]?\".b(ctx.getBlock(\"+r.compileNode(a,b[1])+\",chk, ctx),\"+r.compileNode(a,b[2])+\", {},\"+r.compileNode(a,b[3])+\")\":\".b(ctx.getBlock(\"+A(b[1].text)+\"),\"+r.compileNode(a,b[2])+\",\"+r.compileNode(a,b[4])+\",\"+r.compileNode(a,b[3])+\")\"},\"@\":function(a,b){return\".h(\"+A(b[1].text)+\",\"+r.compileNode(a,b[2])+\",\"+r.compileNode(a,b[4])+\",\"+r.compileNode(a,b[3])+\",\"+r.compileNode(a,b[5])+\")\"},\"%\":function(a,b){var c,d,e,f,g,h,i,j,k,l=b[1][1];if(!r.pragmas[l])return\"\";for(c=b[4],d={},j=1,k=c.length;k>j;j++)h=c[j],d[h[1][1]]=h[2];for(e=b[3],f={},j=1,k=e.length;k>j;j++)i=e[j],f[i[1][1]]=i[2][1];return g=b[2][1]?b[2][1].text:null,r.pragmas[l](a,g,d,f)},partial:function(a,b){return\".p(\"+r.compileNode(a,b[1])+\",ctx,\"+r.compileNode(a,b[2])+\",\"+r.compileNode(a,b[3])+\")\"},context:function(a,b){return b[1]?\"ctx.rebase(\"+r.compileNode(a,b[1])+\")\":\"ctx\"},params:function(a,b){for(var c=[],d=1,e=b.length;e>d;d++)c.push(r.compileNode(a,b[d]));return c.length?\"{\"+c.join(\",\")+\"}\":\"{}\"},bodies:function(a,b){for(var c=[],d=1,e=b.length;e>d;d++)c.push(r.compileNode(a,b[d]));return\"{\"+c.join(\",\")+\"}\"},param:function(a,b){return r.compileNode(a,b[1])+\":\"+r.compileNode(a,b[2])},filters:function(a,b){for(var c=[],d=1,e=b.length;e>d;d++){var f=b[d];c.push('\"'+f+'\"')}return'\"'+a.auto+'\"'+(c.length?\",[\"+c.join(\",\")+\"]\":\"\")},key:function(a,b){return'ctx.get([\"'+b[1]+'\"], false)'},path:function(a,b){for(var c=b[1],d=b[2],e=[],f=0,g=d.length;g>f;f++)e.push(s(d[f])?r.compileNode(a,d[f]):'\"'+d[f]+'\"');return\"ctx.getPath(\"+c+\", [\"+e.join(\",\")+\"])\"},literal:function(a,b){return A(b[1])},raw:function(a,b){return\".w(\"+A(b[1])+\")\"}};var u=/\\\\/g,v=/\"/g,w=/\\f/g,x=/\\n/g,y=/\\r/g,z=/\\t/g,A=\"undefined\"==typeof JSON?function(a){return'\"'+n(a)+'\"'}:JSON.stringify;return dust.compiler=r,dust.compile=dust.compiler.compile,dust.renderSource=o,dust.compileFn=p,dust.filterNode=r.filterNode,dust.optimizers=r.optimizers,dust.pragmas=r.pragmas,dust.compileNode=r.compileNode,dust.nodes=r.nodes,r}),\"function\"==typeof define&&define.amd&&define.amd.dust===!0&&define([\"require\",\"dust.core\",\"dust.compile\"],function(require,dust){return dust.onLoad=function(a,b){require([a],function(){b()})},dust});", "(function(root, factory) {\n  if (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define(\"dust.compile\", [\"dust.core\", \"dust.parse\"], function(dust, parse) {\n      return factory(parse, dust).compile;\n    });\n  } else if (typeof exports === 'object') {\n    // in Node, require this file if we want to use the compiler as a standalone module\n    module.exports = factory(require('./parser').parse, require('./dust'));\n  } else {\n    // in the browser, store the factory output if we want to use the compiler directly\n    factory(root.dust.parse, root.dust);\n  }\n}(this, function(parse, dust) {\n  var compiler = {},\n      isArray = dust.isArray;\n\n  var escape = (typeof JSON === 'undefined') ?\n                  function(str) { return '\"' + escapeToJsSafeString(str) + '\"';} :\n                  JSON.stringify;\n\n  compiler.compile = function(source, name) {\n    // the name parameter is optional.\n    // this can happen for templates that are rendered immediately (renderSource which calls compileFn) or\n    // for templates that are compiled as a callable (compileFn)\n    //\n    // for the common case (using compile and render) a name is required so that templates will be cached by name and rendered later, by name.\n\n    try {\n      var ast = filterAST(parse(source));\n      return compile(ast, name);\n    } catch (err) {\n      if (!err.location) {\n        throw err;\n      }\n      throw new SyntaxError(err.message + ' [' + name + ':' + err.location.start.line + ':' + err.location.start.column + ']');\n    }\n  };\n\n  function filterAST(ast) {\n    var context = {};\n    return compiler.filterNode(context, ast);\n  }\n\n  compiler.filterNode = function(context, node) {\n    return compiler.optimizers[node[0]](context, node);\n  };\n\n  compiler.optimizers = {\n    body:      compactBuffers,\n    buffer:    noop,\n    special:   convertSpecial,\n    format:    format,\n    reference: visit,\n    '#':       visit,\n    '?':       visit,\n    '^':       visit,\n    '<':       visit,\n    '+':       visit,\n    '@':       visit,\n    '%':       visit,\n    partial:   visit,\n    context:   visit,\n    params:    visit,\n    bodies:    visit,\n    param:     visit,\n    filters:   noop,\n    key:       noop,\n    path:      noop,\n    literal:   noop,\n    raw:       noop,\n    comment:   nullify\n  };\n\n  compiler.pragmas = {\n    esc: function(compiler, context, bodies) {\n      var old = compiler.auto,\n          out;\n      if (!context) {\n        context = 'h';\n      }\n      compiler.auto = (context === 's') ? '' : context;\n      out = compileParts(compiler, bodies.block);\n      compiler.auto = old;\n      return out;\n    }\n  };\n\n  function visit(context, node) {\n    var out = [node[0]],\n        i, len, res;\n    for (i=1, len=node.length; i<len; i++) {\n      res = compiler.filterNode(context, node[i]);\n      if (res) {\n        out.push(res);\n      }\n    }\n    return out;\n  }\n\n  // Compacts consecutive buffer nodes into a single node\n  function compactBuffers(context, node) {\n    var out = [node[0]],\n        memo, i, len, res;\n    for (i=1, len=node.length; i<len; i++) {\n      res = compiler.filterNode(context, node[i]);\n      if (res) {\n        if (res[0] === 'buffer' || res[0] === 'format') {\n          if (memo) {\n            memo[0] = (res[0] === 'buffer') ? 'buffer' : memo[0];\n            memo[1] += res.slice(1).join('');\n          } else {\n            memo = res;\n            out.push(res);\n          }\n        } else {\n          memo = null;\n          out.push(res);\n        }\n      }\n    }\n    return out;\n  }\n\n  var specialChars = {\n    's': ' ',\n    'n': '\\n',\n    'r': '\\r',\n    'lb': '{',\n    'rb': '}'\n  };\n\n  function convertSpecial(context, node) {\n    return ['buffer', specialChars[node[1]], node[2], node[3]];\n  }\n\n  function noop(context, node) {\n    return node;\n  }\n\n  function nullify(){}\n\n  function format(context, node) {\n    if(dust.config.whitespace) {\n      // Format nodes are in the form ['format', eol, whitespace],\n      // which is unlike other nodes in that there are two pieces of content\n      // Join eol and whitespace together to normalize the node format\n      node.splice(1, 2, node.slice(1).join(''));\n      return node;\n    }\n    return null;\n  }\n\n  function compile(ast, name) {\n    var context = {\n      name: name,\n      bodies: [],\n      blocks: {},\n      index: 0,\n      auto: 'h'\n    },\n    escapedName = dust.escapeJs(name),\n    AMDName = name? '\"' + escapedName + '\",' : '',\n    compiled = 'function(dust){',\n    entry = compiler.compileNode(context, ast),\n    iife;\n\n    if(name) {\n      compiled += 'dust.register(\"' + escapedName + '\",' + entry + ');';\n    }\n\n    compiled += compileBlocks(context) +\n                compileBodies(context) +\n                'return ' + entry + '}';\n\n    iife = '(' + compiled + '(dust));';\n\n    if(dust.config.amd) {\n      return 'define(' + AMDName + '[\"dust.core\"],' + compiled + ');';\n    } else if(dust.config.cjs) {\n      return 'module.exports=function(dust){' +\n             'var tmpl=' + iife +\n             'var f=' + loaderFor().toString() + ';' +\n             'f.template=tmpl;return f}';\n    } else {\n      return iife;\n    }\n  }\n\n  function compileBlocks(context) {\n    var out = [],\n        blocks = context.blocks,\n        name;\n\n    for (name in blocks) {\n      out.push('\"' + name + '\":' + blocks[name]);\n    }\n    if (out.length) {\n      context.blocks = 'ctx=ctx.shiftBlocks(blocks);';\n      return 'var blocks={' + out.join(',') + '};';\n    } else {\n      context.blocks = '';\n    }\n    return context.blocks;\n  }\n\n  function compileBodies(context) {\n    var out = [],\n        bodies = context.bodies,\n        blx = context.blocks,\n        i, len;\n\n    for (i=0, len=bodies.length; i<len; i++) {\n      out[i] = 'function body_' + i + '(chk,ctx){' +\n          blx + 'return chk' + bodies[i] + ';}body_' + i + '.__dustBody=!0;';\n    }\n    return out.join('');\n  }\n\n  function compileParts(context, body) {\n    var parts = '',\n        i, len;\n    for (i=1, len=body.length; i<len; i++) {\n      parts += compiler.compileNode(context, body[i]);\n    }\n    return parts;\n  }\n\n  compiler.compileNode = function(context, node) {\n    return compiler.nodes[node[0]](context, node);\n  };\n\n  compiler.nodes = {\n    body: function(context, node) {\n      var id = context.index++,\n          name = 'body_' + id;\n      context.bodies[id] = compileParts(context, node);\n      return name;\n    },\n\n    buffer: function(context, node) {\n      return '.w(' + escape(node[1]) + ')';\n    },\n\n    format: function(context, node) {\n      return '.w(' + escape(node[1]) + ')';\n    },\n\n    reference: function(context, node) {\n      return '.f(' + compiler.compileNode(context, node[1]) +\n        ',ctx,' + compiler.compileNode(context, node[2]) + ')';\n    },\n\n    '#': function(context, node) {\n      return compileSection(context, node, 'section');\n    },\n\n    '?': function(context, node) {\n      return compileSection(context, node, 'exists');\n    },\n\n    '^': function(context, node) {\n      return compileSection(context, node, 'notexists');\n    },\n\n    '<': function(context, node) {\n      var bodies = node[4];\n      for (var i=1, len=bodies.length; i<len; i++) {\n        var param = bodies[i],\n            type = param[1][1];\n        if (type === 'block') {\n          context.blocks[node[1].text] = compiler.compileNode(context, param[2]);\n          return '';\n        }\n      }\n      return '';\n    },\n\n    '+': function(context, node) {\n      if (typeof(node[1].text) === 'undefined'  && typeof(node[4]) === 'undefined'){\n        return '.b(ctx.getBlock(' +\n              compiler.compileNode(context, node[1]) +\n              ',chk, ctx),' + compiler.compileNode(context, node[2]) + ', {},' +\n              compiler.compileNode(context, node[3]) +\n              ')';\n      } else {\n        return '.b(ctx.getBlock(' +\n            escape(node[1].text) +\n            '),' + compiler.compileNode(context, node[2]) + ',' +\n            compiler.compileNode(context, node[4]) + ',' +\n            compiler.compileNode(context, node[3]) +\n            ')';\n      }\n    },\n\n    '@': function(context, node) {\n      return '.h(' +\n        escape(node[1].text) +\n        ',' + compiler.compileNode(context, node[2]) + ',' +\n        compiler.compileNode(context, node[4]) + ',' +\n        compiler.compileNode(context, node[3]) + ',' +\n        compiler.compileNode(context, node[5]) +\n        ')';\n    },\n\n    '%': function(context, node) {\n      // TODO: Move these hacks into pragma precompiler\n      var name = node[1][1],\n          rawBodies,\n          bodies,\n          rawParams,\n          params,\n          ctx, b, p, i, len;\n      if (!compiler.pragmas[name]) {\n        return '';\n      }\n\n      rawBodies = node[4];\n      bodies = {};\n      for (i=1, len=rawBodies.length; i<len; i++) {\n        b = rawBodies[i];\n        bodies[b[1][1]] = b[2];\n      }\n\n      rawParams = node[3];\n      params = {};\n      for (i=1, len=rawParams.length; i<len; i++) {\n        p = rawParams[i];\n        params[p[1][1]] = p[2][1];\n      }\n\n      ctx = node[2][1] ? node[2][1].text : null;\n\n      return compiler.pragmas[name](context, ctx, bodies, params);\n    },\n\n    partial: function(context, node) {\n      return '.p(' +\n          compiler.compileNode(context, node[1]) +\n          ',ctx,' + compiler.compileNode(context, node[2]) +\n          ',' + compiler.compileNode(context, node[3]) + ')';\n    },\n\n    context: function(context, node) {\n      if (node[1]) {\n        return 'ctx.rebase(' + compiler.compileNode(context, node[1]) + ')';\n      }\n      return 'ctx';\n    },\n\n    params: function(context, node) {\n      var out = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        out.push(compiler.compileNode(context, node[i]));\n      }\n      if (out.length) {\n        return '{' + out.join(',') + '}';\n      }\n      return '{}';\n    },\n\n    bodies: function(context, node) {\n      var out = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        out.push(compiler.compileNode(context, node[i]));\n      }\n      return '{' + out.join(',') + '}';\n    },\n\n    param: function(context, node) {\n      return compiler.compileNode(context, node[1]) + ':' + compiler.compileNode(context, node[2]);\n    },\n\n    filters: function(context, node) {\n      var list = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        var filter = node[i];\n        list.push('\"' + filter + '\"');\n      }\n      return '\"' + context.auto + '\"' +\n        (list.length ? ',[' + list.join(',') + ']' : '');\n    },\n\n    key: function(context, node) {\n      return 'ctx.get([\"' + node[1] + '\"], false)';\n    },\n\n    path: function(context, node) {\n      var current = node[1],\n          keys = node[2],\n          list = [];\n\n      for (var i=0,len=keys.length; i<len; i++) {\n        if (isArray(keys[i])) {\n          list.push(compiler.compileNode(context, keys[i]));\n        } else {\n          list.push('\"' + keys[i] + '\"');\n        }\n      }\n      return 'ctx.getPath(' + current + ', [' + list.join(',') + '])';\n    },\n\n    literal: function(context, node) {\n      return escape(node[1]);\n    },\n    raw: function(context, node) {\n      return \".w(\" + escape(node[1]) + \")\";\n    }\n  };\n\n  function compileSection(context, node, cmd) {\n    return '.' + (dust._aliases[cmd] || cmd) + '(' +\n      compiler.compileNode(context, node[1]) +\n      ',' + compiler.compileNode(context, node[2]) + ',' +\n      compiler.compileNode(context, node[4]) + ',' +\n      compiler.compileNode(context, node[3]) +\n      ')';\n  }\n\n  var BS = /\\\\/g,\n      DQ = /\"/g,\n      LF = /\\f/g,\n      NL = /\\n/g,\n      CR = /\\r/g,\n      TB = /\\t/g;\n  function escapeToJsSafeString(str) {\n    return str.replace(BS, '\\\\\\\\')\n              .replace(DQ, '\\\\\"')\n              .replace(LF, '\\\\f')\n              .replace(NL, '\\\\n')\n              .replace(CR, '\\\\r')\n              .replace(TB, '\\\\t');\n  }\n\n  function renderSource(source, context, callback) {\n    var tmpl = dust.loadSource(dust.compile(source));\n    return loaderFor(tmpl)(context, callback);\n  }\n\n  function compileFn(source, name) {\n    var tmpl = dust.loadSource(dust.compile(source, name));\n    return loaderFor(tmpl);\n  }\n\n  function loaderFor(tmpl) {\n    return function load(ctx, cb) {\n      var fn = cb ? 'render' : 'stream';\n      return dust[fn](tmpl, ctx, cb);\n    };\n  }\n\n  // expose compiler methods\n  dust.compiler = compiler;\n  dust.compile = dust.compiler.compile;\n  dust.renderSource = renderSource;\n  dust.compileFn = compileFn;\n\n  // DEPRECATED legacy names. Removed in 2.8.0\n  dust.filterNode = compiler.filterNode;\n  dust.optimizers = compiler.optimizers;\n  dust.pragmas = compiler.pragmas;\n  dust.compileNode = compiler.compileNode;\n  dust.nodes = compiler.nodes;\n\n  return compiler;\n\n}));\n", "{\n  \"name\": \"dustjs-linkedin\",\n  \"version\": \"2.7.2\",\n  \"author\": {\n    \"name\": \"Aleksander Williams\",\n    \"url\": \"http://akdubya.github.com/dustjs\"\n  },\n  \"homepage\": \"http://dustjs.com/\",\n  \"description\": \"Asynchronous templates for the browser and server (LinkedIn fork)\",\n  \"contributors\": [\n    \"Veena Basavaraj <vybs@users.noreply.github.com>\",\n    \"Tom Carchrae\",\n    \"Jimmy Chan <jchan@linkedin.com>\",\n    \"Steven Foote <sfoote@linkedin.com>\",\n    \"Prayrit Prash Jain <prjain@linkedin.com>\",\n    \"Seth Kinast <skinast@linkedin.com>\",\n    \"Jairo de Morais <jairodemorais@users.noreply.github.com>\",\n    \"Kate Odnous <kodnous@linkedin.com>\",\n    \"Richard Ragan <rragan@ebay.com>\"\n  ],\n  \"scripts\": {\n    \"test\": \"grunt travis\"\n  },\n  \"bin\": {\n    \"dustc\": \"./bin/dustc\"\n  },\n  \"main\": \"index.js\",\n  \"browser\": \"./lib/dust.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/linkedin/dustjs.git\"\n  },\n  \"keywords\": [\n    \"templates\",\n    \"views\",\n    \"dust\",\n    \"dustjs\",\n    \"dust.js\",\n    \"linkedin\"\n  ],\n  \"dependencies\": {\n    \"chokidar\": \"~1.5.1\",\n    \"cli\": \"^1.0.1\"\n  },\n  \"devDependencies\": {\n    \"ayepromise\": \"~1.1.1\",\n    \"grunt\": \"~1.0.1\",\n    \"grunt-bump\": \"~0.8.0\",\n    \"grunt-cli\": \"~1.2.0\",\n    \"grunt-contrib-clean\": \"~1.0.0\",\n    \"grunt-contrib-concat\": \"~1.0.1\",\n    \"grunt-contrib-connect\": \"~1.0.2\",\n    \"grunt-contrib-copy\": \"~1.0.0\",\n    \"grunt-contrib-jasmine\": \"~1.0.3\",\n    \"grunt-contrib-jshint\": \"~1.0.0\",\n    \"grunt-contrib-uglify\": \"~1.0.1\",\n    \"grunt-contrib-watch\": \"~1.0.0\",\n    \"grunt-execute\": \"~0.2.2\",\n    \"grunt-github-changes\": \"~0.1.0\",\n    \"grunt-jasmine-nodejs\": \"~1.5.3\",\n    \"grunt-peg\": \"~2.0.0\",\n    \"grunt-saucelabs\": \"~8.6.1\",\n    \"grunt-shell\": \"~1.3.0\",\n    \"grunt-template-jasmine-istanbul\": \"~0.4.0\",\n    \"highland\": \"2.8.1\",\n    \"pegjs\": \"0.9.0\",\n    \"rhino-1_7r3-bin\": \"~1.0.1\",\n    \"rhino-1_7r5-bin\": \"~1.0.1\",\n    \"tmp\": \"~0.0.25\"\n  },\n  \"license\": \"MIT\",\n  \"engine\": {\n    \"node\": \">=0.10\"\n  }\n}\n", "(function (root, factory) {\n  if (typeof exports === 'object') {\n    factory(require('../'));\n  } else {\n    factory(root.dust);\n  }\n}(this, function(dust) {\n\n  function extend(target, donor) {\n    donor = donor || {};\n    for(var prop in donor) {\n      target[prop] = donor[prop];\n    }\n    return target;\n  }\n\n  function renderIt(message, source, context, expected, config) {\n    var tmpl = dust.loadSource(dust.compile(source));\n    dust.config = extend({ whitespace: false, amd: false, cjs: false, cache: true }, config);\n    it(message, function(done) {\n      render(tmpl, context, expected)(done);\n    });\n  }\n\n  function render(tmpl, context, expected) {\n    return function(done) {\n      dust.render(tmpl, context, function(err, output) {\n        expect(err).toBe(null);\n        expect(output).toEqual(expected);\n        done();\n      });\n    };\n  }\n\n  function templateName(chunk, context) {\n    return context.getTemplateName();\n  }\n\n  describe('Context', function() {\n    describe(\"render\", function() {\n      var base = dust.makeBase({\n        sayHello: function() { return \"Hello!\"; },\n        names: [\"Alice\", \"Bob\", \"Dusty\"]\n      });\n      it(\"doesn't push onto the stack if data is undefined\", function() {\n        expect(base.push().push().push().push().stack).toBe(undefined);\n      });\n      renderIt(\"can read from both globals and context\", \"{sayHello} {foo}\", base.push({foo: \"bar\"}), \"Hello! bar\");\n      renderIt(\"doesn't error if globals are empty\", \"{sayHello} {foo}\", dust.makeBase().push({foo: \"bar\"}), \" bar\");\n      renderIt(\"doesn't error if context is undefined\", \"{sayHello} {foo}\", undefined, \" \");\n      renderIt(\"can iterate over an array in the globals\", \"{sayHello} {#names}{.} {/names}\", base, \"Hello! Alice Bob Dusty \");\n    });\n\n    describe('templateName', function() {\n      var context = {\n        templateName: templateName\n      };\n      var tmpl = dust.loadSource(dust.compile(\"template name is {templateName}\", \"templateNameTest\"));\n      it(\"sets the template name on context\",\n        render(tmpl, context, \"template name is templateNameTest\"));\n      it(\"sets the template name when provided a context\",\n        render(tmpl, dust.context(context), \"template name is templateNameTest\"));\n    });\n\n    describe('options', function() {\n      it('sets options using makeBase / context', function() {\n        var opts = { lang: \"fr\" },\n            globals = { hello: \"world\" };\n        var base = dust.context(globals, opts);\n        expect(base.options.lang).toEqual(opts.lang);\n        base = base.rebase();\n        expect(base.options.lang).toEqual(opts.lang);\n      });\n    });\n\n    describe('prototype', function() {\n      var base = dust.context({\n        sayHello: function() { return \"Hello!\"; }\n      }).push({ foo: 'bar' });\n      var context = extend({}, base);\n      renderIt('survives having its prototype destroyed', '{sayHello} {foo}', context, 'Hello! bar');\n    });\n  });\n\n  it(\"valid keys\", function() {\n    renderIt(\"Renders all valid keys\", \"{_foo}{$bar}{baz1}\", {_foo: 1, $bar: 2, baz1: 3}, \"123\");\n  });\n\n  describe('dust.onLoad', function() {\n    beforeEach(function() {\n      dust.cache.onLoad = null;\n    });\n    it(\"calls callback with source\", function(done) {\n      dust.onLoad = function(name, cb) {\n        cb(null, 'Loaded: ' + name + ', template name {templateName}');\n      };\n      render(\"onLoad\", {\n        templateName: templateName\n      }, \"Loaded: onLoad, template name onLoad\")(done);\n    });\n    it(\"calls callback with compiled template\", function(done) {\n      dust.onLoad = function(name, cb) {\n        var tmpl = dust.loadSource(dust.compile('Loaded: ' + name + ', template name {templateName}', 'foobar'));\n        cb(null, tmpl);\n      };\n      render(\"onLoad\", {\n        templateName: templateName\n      }, \"Loaded: onLoad, template name foobar\")(done);\n    });\n    it(\"calls callback with compiled template and can override template name\", function(done) {\n      dust.onLoad = function(name, cb) {\n        var tmpl = dust.loadSource(dust.compile('Loaded: ' + name + ', template name {templateName}', 'foobar'));\n        tmpl.templateName = 'override';\n        cb(null, dust.cache.foobar);\n      };\n      render(\"onLoad\", {\n        templateName: templateName\n      }, \"Loaded: onLoad, template name override\")(done);\n    });\n    it(\"receives context options\", function(done) {\n      dust.onLoad = function(name, opts, cb) {\n        cb(null, 'Loaded: ' + name + ', lang ' + opts.lang);\n      };\n      render(\"onLoad\", dust.makeBase(null, { lang: \"fr\" }), \"Loaded: onLoad, lang fr\")(done);\n    });\n  });\n\n  describe('dust.config.cache', function() {\n    beforeAll(function() {\n      dust.config.cache = false;\n    });\n    afterAll(function() {\n      dust.config.cache = true;\n    });\n    it('turns off cache registration', function() {\n      dust.loadSource(dust.compile('Not cached', 'test'));\n      expect(dust.cache.test).toBe(undefined);\n    });\n    it('calls onLoad every time for a template', function(done) {\n      var tmpl = \"Version 1\";\n      dust.onLoad = function(name, cb) {\n        cb(null, tmpl);\n      };\n      dust.render('test', undefined, function(err, out) {\n        expect(out).toEqual(tmpl);\n        tmpl = \"Version 2\";\n        dust.render('test', undefined, function(err, out) {\n          expect(out).toEqual(tmpl);\n          done();\n        });\n      });\n    });\n    it('does not clobber a cached template', function() {\n      dust.cache.test = 'test';\n      dust.loadSource(dust.compile('Not cached', 'test'));\n      expect(dust.cache.test).toEqual('test');\n    });\n  });\n\n  describe('renderSource', function() {\n    var template = \"Hello {world}!\",\n        expected = \"Hello world!\",\n        ctx = {world: \"world\"};\n\n    it('invokes a callback', function(done) {\n      dust.renderSource(template, ctx, function(err, out) {\n        expect(err).toBe(null);\n        expect(out).toBe(expected);\n        done();\n      });\n    });\n\n    it('streams', function(done) {\n      dust.renderSource(template, ctx).on('data', function(out) {\n        expect(out).toBe(expected);\n        done();\n      });\n    });\n\n    it('streams to every listener', function(done) {\n      var recipients = 0;\n      var stream = dust.renderSource(template, ctx);\n      var func = function(out) {\n        expect(out).toBe(expected);\n        recipients--;\n      };\n\n      while(recipients < 10) {\n        stream.on('data', func);\n        recipients++;\n      }\n\n      stream.on('end', function() {\n        expect(recipients).toBe(0);\n        done();\n      });\n    });\n\n    it('pipes', function(done) {\n      var gotData = false;\n      dust.renderSource(template, ctx).pipe({\n        write: function(out) {\n          expect(out).toBe(expected);\n          gotData = true;\n        },\n        end: function() {\n          expect(gotData).toBe(true);\n          done();\n        }\n      });\n    });\n  });\n\n  describe('compileFn', function() {\n    var ctx = {world:\"World\"},\n        expected = 'Hello World',\n        tmpl;\n    beforeAll(function() {\n      tmpl = dust.compileFn('Hello {world}');\n    });\n    it('can be invoked as a function', function(done) {\n      tmpl(ctx, function(err, out) {\n        expect(out).toEqual(expected);\n        done();\n      });\n    });\n    it('emits events like a stream', function(done) {\n      tmpl(ctx).on('data', function(out) {\n        expect(out).toEqual(expected);\n        done();\n      });\n    });\n  });\n\n}));\n"], "fixing_code": ["node_modules\n*.DS_Store\n.grunt\nindex.html\ntmp\nexamples/*/views/**/*.js\nexamples/*/lib/*\n!examples/*/lib/main.js\n.vscode\npackage-lock.json\n", "language: node_js\nnode_js:\n  - \"12\"\n  - \"14\"\n  - \"16\"\nmatrix:\n  include:\n    - node_js: \"12\"\n      env:\n        - TEST=\"all\"\n        - CXX=g++-4.8\nnotifications:\n  email:\n    - jchan@linkedin.com\n    - skinast@linkedin.com\nbefore_install:\n  - npm install -g npm@6\nbefore_script:\n  - npm update\nsudo: false\ncache:\n  directories:\n    - node_modules\nenv:\n  - CXX=g++-4.8\naddons:\n  apt:\n    sources:\n      - ubuntu-toolchain-r-test\n    packages:\n      - g++-4.8\n", "/*! dustjs-linkedin - v2.7.2\n* http://dustjs.com/\n* Copyright (c) 2021 Aleksander Williams; Released under the MIT License */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd && define.amd.dust === true) {\n    define('dust.core', [], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.dust = factory();\n  }\n}(this, function() {\n  var dust = {\n        \"version\": \"2.7.2\"\n      },\n      NONE = 'NONE', ERROR = 'ERROR', WARN = 'WARN', INFO = 'INFO', DEBUG = 'DEBUG',\n      EMPTY_FUNC = function() {};\n\n  dust.config = {\n    whitespace: false,\n    amd: false,\n    cjs: false,\n    cache: true\n  };\n\n  // Directive aliases to minify code\n  dust._aliases = {\n    \"write\": \"w\",\n    \"end\": \"e\",\n    \"map\": \"m\",\n    \"render\": \"r\",\n    \"reference\": \"f\",\n    \"section\": \"s\",\n    \"exists\": \"x\",\n    \"notexists\": \"nx\",\n    \"block\": \"b\",\n    \"partial\": \"p\",\n    \"helper\": \"h\"\n  };\n\n  (function initLogging() {\n    /*global process, console*/\n    var loggingLevels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, NONE: 4 },\n        consoleLog,\n        log;\n\n    if (typeof console !== 'undefined' && console.log) {\n      consoleLog = console.log;\n      if(typeof consoleLog === 'function') {\n        log = function() {\n          consoleLog.apply(console, arguments);\n        };\n      } else {\n        log = function() {\n          consoleLog(Array.prototype.slice.apply(arguments).join(' '));\n        };\n      }\n    } else {\n      log = EMPTY_FUNC;\n    }\n\n    /**\n     * Filters messages based on `dust.debugLevel`.\n     * This default implementation will print to the console if it exists.\n     * @param {String|Error} message the message to print/throw\n     * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)\n     * @public\n     */\n    dust.log = function(message, type) {\n      type = type || INFO;\n      if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {\n        log('[DUST:' + type + ']', message);\n        if (type === ERROR && dust.debugLevel === DEBUG && message instanceof Error && message.stack) {\n          log('[DUST:' + type + ']', message.stack);\n        }\n      }\n    };\n\n    dust.debugLevel = NONE;\n    if(typeof process !== 'undefined' && process.env && /\\bdust\\b/.test(process.env.DEBUG)) {\n      dust.debugLevel = DEBUG;\n    }\n\n  }());\n\n  dust.helpers = {};\n\n  dust.cache = {};\n\n  dust.register = function(name, tmpl) {\n    if (!name) {\n      return;\n    }\n    tmpl.templateName = name;\n    if (dust.config.cache !== false) {\n      dust.cache[name] = tmpl;\n    }\n  };\n\n  dust.render = function(nameOrTemplate, context, callback) {\n    var chunk = new Stub(callback).head;\n    try {\n      load(nameOrTemplate, chunk, context).end();\n    } catch (err) {\n      chunk.setError(err);\n    }\n  };\n\n  dust.stream = function(nameOrTemplate, context) {\n    var stream = new Stream(),\n        chunk = stream.head;\n    dust.nextTick(function() {\n      try {\n        load(nameOrTemplate, chunk, context).end();\n      } catch (err) {\n        chunk.setError(err);\n      }\n    });\n    return stream;\n  };\n\n  /**\n   * Extracts a template function (body_0) from whatever is passed.\n   * @param nameOrTemplate {*} Could be:\n   *   - the name of a template to load from cache\n   *   - a CommonJS-compiled template (a function with a `template` property)\n   *   - a template function\n   * @param loadFromCache {Boolean} if false, don't look in the cache\n   * @return {Function} a template function, if found\n   */\n  function getTemplate(nameOrTemplate, loadFromCache/*=true*/) {\n    if(!nameOrTemplate) {\n      return;\n    }\n    if(typeof nameOrTemplate === 'function' && nameOrTemplate.template) {\n      // Sugar away CommonJS module templates\n      return nameOrTemplate.template;\n    }\n    if(dust.isTemplateFn(nameOrTemplate)) {\n      // Template functions passed directly\n      return nameOrTemplate;\n    }\n    if(loadFromCache !== false) {\n      // Try loading a template with this name from cache\n      return dust.cache[nameOrTemplate];\n    }\n  }\n\n  function load(nameOrTemplate, chunk, context) {\n    if(!nameOrTemplate) {\n      return chunk.setError(new Error('No template or template name provided to render'));\n    }\n\n    var template = getTemplate(nameOrTemplate, dust.config.cache);\n\n    if (template) {\n      return template(chunk, Context.wrap(context, template.templateName));\n    } else {\n      if (dust.onLoad) {\n        return chunk.map(function(chunk) {\n          // Alias just so it's easier to read that this would always be a name\n          var name = nameOrTemplate;\n          // Three possible scenarios for a successful callback:\n          //   - `require(nameOrTemplate)(dust); cb()`\n          //   - `src = readFile('src.dust'); cb(null, src)`\n          //   - `compiledTemplate = require(nameOrTemplate)(dust); cb(null, compiledTemplate)`\n          function done(err, srcOrTemplate) {\n            var template;\n            if (err) {\n              return chunk.setError(err);\n            }\n            // Prefer a template that is passed via callback over the cached version.\n            template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);\n            if (!template) {\n              // It's a template string, compile it and register under `name`\n              if(dust.compile) {\n                template = dust.loadSource(dust.compile(srcOrTemplate, name));\n              } else {\n                return chunk.setError(new Error('Dust compiler not available'));\n              }\n            }\n            template(chunk, Context.wrap(context, template.templateName)).end();\n          }\n\n          if(dust.onLoad.length === 3) {\n            dust.onLoad(name, context.options, done);\n          } else {\n            dust.onLoad(name, done);\n          }\n        });\n      }\n      return chunk.setError(new Error('Template Not Found: ' + nameOrTemplate));\n    }\n  }\n\n  dust.loadSource = function(source) {\n    /*jshint evil:true*/\n    return eval(source);\n  };\n\n  if (Array.isArray) {\n    dust.isArray = Array.isArray;\n  } else {\n    dust.isArray = function(arr) {\n      return Object.prototype.toString.call(arr) === '[object Array]';\n    };\n  }\n\n  dust.nextTick = (function() {\n    return function(callback) {\n      setTimeout(callback, 0);\n    };\n  })();\n\n  /**\n   * Dust has its own rules for what is \"empty\"-- which is not the same as falsy.\n   * Empty arrays, null, and undefined are empty\n   */\n  dust.isEmpty = function(value) {\n    if (value === 0) {\n      return false;\n    }\n    if (dust.isArray(value) && !value.length) {\n      return true;\n    }\n    return !value;\n  };\n\n  dust.isEmptyObject = function(obj) {\n    var key;\n    if (obj === null) {\n      return false;\n    }\n    if (obj === undefined) {\n      return false;\n    }\n    if (obj.length > 0) {\n      return false;\n    }\n    for (key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  dust.isTemplateFn = function(elem) {\n    return typeof elem === 'function' &&\n           elem.__dustBody;\n  };\n\n  /**\n   * Decide somewhat-naively if something is a Thenable.  Matches Promises A+ Spec, section 1.2 \u201cthenable\u201d is an object or function that defines a then method.\"\n   * @param elem {*} object to inspect\n   * @return {Boolean} is `elem` a Thenable?\n   */\n  dust.isThenable = function(elem) {\n    return elem &&  /* Beware: `typeof null` is `object` */\n           (typeof elem === 'object' || typeof elem === 'function') &&\n           typeof elem.then === 'function';\n  };\n\n  /**\n   * Decide if an element is a function but not Thenable; it is prefereable to resolve a thenable function by its `.then` method.\n   * @param elem {*} target of inspection\n   * @return {Boolean} is `elem` a function without a `.then` property?\n   */\n  dust.isNonThenableFunction = function(elem) {\n    return typeof elem === 'function' && !dust.isThenable(elem);\n  };\n\n  /**\n   * Decide very naively if something is a Stream.\n   * @param elem {*} object to inspect\n   * @return {Boolean} is `elem` a Stream?\n   */\n  dust.isStreamable = function(elem) {\n    return elem &&\n           typeof elem.on === 'function' &&\n           typeof elem.pipe === 'function';\n  };\n\n  // apply the filter chain and return the output string\n  dust.filter = function(string, auto, filters, context) {\n    var i, len, name, filter;\n    if (filters) {\n      for (i = 0, len = filters.length; i < len; i++) {\n        name = filters[i];\n        if (!name.length) {\n          continue;\n        }\n        filter = dust.filters[name];\n        if (name === 's') {\n          auto = null;\n        } else if (typeof filter === 'function') {\n          string = filter(string, context);\n        } else {\n          dust.log('Invalid filter `' + name + '`', WARN);\n        }\n      }\n    }\n    // by default always apply the h filter, unless asked to unescape with |s\n    if (auto) {\n      string = dust.filters[auto](string, context);\n    }\n    return string;\n  };\n\n  dust.filters = {\n    h: function(value) { return dust.escapeHtml(value); },\n    j: function(value) { return dust.escapeJs(value); },\n    u: encodeURI,\n    uc: encodeURIComponent,\n    js: function(value) { return dust.escapeJSON(value); },\n    jp: function(value) {\n      if (!JSON) {dust.log('JSON is undefined; could not parse `' + value + '`', WARN);\n        return value;\n      } else {\n        return JSON.parse(value);\n      }\n    }\n  };\n\n  function Context(stack, global, options, blocks, templateName) {\n    if(stack !== undefined && !(stack instanceof Stack)) {\n      stack = new Stack(stack);\n    }\n    this.stack = stack;\n    this.global = global;\n    this.options = options;\n    this.blocks = blocks;\n    this.templateName = templateName;\n    this._isContext = true;\n  }\n\n  dust.makeBase = dust.context = function(global, options) {\n    return new Context(undefined, global, options);\n  };\n\n  dust.isContext = function(obj) {\n    return typeof obj === \"object\" && obj._isContext === true;\n  };\n\n  /**\n   * Factory function that creates a closure scope around a Thenable-callback.\n   * Returns a function that can be passed to a Thenable that will resume a\n   * Context lookup once the Thenable resolves with new data, adding that new\n   * data to the lookup stack.\n   */\n  function getWithResolvedData(ctx, cur, down) {\n    return function(data) {\n      return ctx.push(data)._get(cur, down);\n    };\n  }\n\n  Context.wrap = function(context, name) {\n    if (dust.isContext(context)) {\n      context.templateName = name;\n      return context;\n    }\n    return new Context(context, {}, {}, null, name);\n  };\n\n  /**\n   * Public API for getting a value from the context.\n   * @method get\n   * @param {string|array} path The path to the value. Supported formats are:\n   * 'key'\n   * 'path.to.key'\n   * '.path.to.key'\n   * ['path', 'to', 'key']\n   * ['key']\n   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the\n   * current context (true), or if get should search in parent contexts as well (false).\n   * @public\n   * @returns {string|object}\n   */\n  Context.prototype.get = function(path, cur) {\n    if (typeof path === 'string') {\n      if (path[0] === '.') {\n        cur = true;\n        path = path.substr(1);\n      }\n      path = path.split('.');\n    }\n    return this._get(cur, path);\n  };\n\n  /**\n   * Get a value from the context\n   * @method _get\n   * @param {boolean} cur Get only from the current context\n   * @param {array} down An array of each step in the path\n   * @private\n   * @return {string | object}\n   */\n  Context.prototype._get = function(cur, down) {\n    var ctx = this.stack || {},\n        i = 1,\n        value, first, len, ctxThis, fn;\n\n    first = down[0];\n    len = down.length;\n\n    if (cur && len === 0) {\n      ctxThis = ctx;\n      ctx = ctx.head;\n    } else {\n      if (!cur) {\n        // Search up the stack for the first value\n        while (ctx) {\n          if (ctx.isObject) {\n            ctxThis = ctx.head;\n            value = ctx.head[first];\n            if (value !== undefined) {\n              break;\n            }\n          }\n          ctx = ctx.tail;\n        }\n\n        // Try looking in the global context if we haven't found anything yet\n        if (value !== undefined) {\n          ctx = value;\n        } else {\n          ctx = this.global && this.global[first];\n        }\n      } else if (ctx) {\n        // if scope is limited by a leading dot, don't search up the tree\n        if(ctx.head) {\n          ctx = ctx.head[first];\n        } else {\n          // context's head is empty, value we are searching for is not defined\n          ctx = undefined;\n        }\n      }\n\n      while (ctx && i < len) {\n        if (dust.isThenable(ctx)) {\n          // Bail early by returning a Thenable for the remainder of the search tree\n          return ctx.then(getWithResolvedData(this, cur, down.slice(i)));\n        }\n        ctxThis = ctx;\n        ctx = ctx[down[i]];\n        i++;\n      }\n    }\n\n    if (dust.isNonThenableFunction(ctx)) {\n      fn = function() {\n        try {\n          return ctx.apply(ctxThis, arguments);\n        } catch (err) {\n          dust.log(err, ERROR);\n          throw err;\n        }\n      };\n      fn.__dustBody = !!ctx.__dustBody;\n      return fn;\n    } else {\n      if (ctx === undefined) {\n        dust.log('Cannot find reference `{' + down.join('.') + '}` in template `' + this.getTemplateName() + '`', INFO);\n      }\n      return ctx;\n    }\n  };\n\n  Context.prototype.getPath = function(cur, down) {\n    return this._get(cur, down);\n  };\n\n  Context.prototype.push = function(head, idx, len) {\n    if(head === undefined) {\n      dust.log(\"Not pushing an undefined variable onto the context\", INFO);\n      return this;\n    }\n    return this.rebase(new Stack(head, this.stack, idx, len));\n  };\n\n  Context.prototype.pop = function() {\n    var head = this.current();\n    this.stack = this.stack && this.stack.tail;\n    return head;\n  };\n\n  Context.prototype.rebase = function(head) {\n    return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());\n  };\n\n  Context.prototype.clone = function() {\n    var context = this.rebase();\n    context.stack = this.stack;\n    return context;\n  };\n\n  Context.prototype.current = function() {\n    return this.stack && this.stack.head;\n  };\n\n  Context.prototype.getBlock = function(key) {\n    var blocks, len, fn;\n\n    if (typeof key === 'function') {\n      key = key(new Chunk(), this).data.join('');\n    }\n\n    blocks = this.blocks;\n\n    if (!blocks) {\n      dust.log('No blocks for context `' + key + '` in template `' + this.getTemplateName() + '`', DEBUG);\n      return false;\n    }\n\n    len = blocks.length;\n    while (len--) {\n      fn = blocks[len][key];\n      if (fn) {\n        return fn;\n      }\n    }\n\n    dust.log('Malformed template `' + this.getTemplateName() + '` was missing one or more blocks.');\n    return false;\n  };\n\n  Context.prototype.shiftBlocks = function(locals) {\n    var blocks = this.blocks,\n        newBlocks;\n\n    if (locals) {\n      if (!blocks) {\n        newBlocks = [locals];\n      } else {\n        newBlocks = blocks.concat([locals]);\n      }\n      return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());\n    }\n    return this;\n  };\n\n  Context.prototype.resolve = function(body) {\n    var chunk;\n\n    if(typeof body !== 'function') {\n      return body;\n    }\n    chunk = new Chunk().render(body, this);\n    if(chunk instanceof Chunk) {\n      return chunk.data.join(''); // ie7 perf\n    }\n    return chunk;\n  };\n\n  Context.prototype.getTemplateName = function() {\n    return this.templateName;\n  };\n\n  function Stack(head, tail, idx, len) {\n    this.tail = tail;\n    this.isObject = head && typeof head === 'object';\n    this.head = head;\n    this.index = idx;\n    this.of = len;\n  }\n\n  function Stub(callback) {\n    this.head = new Chunk(this);\n    this.callback = callback;\n    this.out = '';\n  }\n\n  Stub.prototype.flush = function() {\n    var chunk = this.head;\n\n    while (chunk) {\n      if (chunk.flushable) {\n        this.out += chunk.data.join(''); //ie7 perf\n      } else if (chunk.error) {\n        this.callback(chunk.error);\n        dust.log('Rendering failed with error `' + chunk.error + '`', ERROR);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.callback(null, this.out);\n  };\n\n  /**\n   * Creates an interface sort of like a Streams2 ReadableStream.\n   */\n  function Stream() {\n    this.head = new Chunk(this);\n  }\n\n  Stream.prototype.flush = function() {\n    var chunk = this.head;\n\n    while(chunk) {\n      if (chunk.flushable) {\n        this.emit('data', chunk.data.join('')); //ie7 perf\n      } else if (chunk.error) {\n        this.emit('error', chunk.error);\n        this.emit('end');\n        dust.log('Streaming failed with error `' + chunk.error + '`', ERROR);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.emit('end');\n  };\n\n  /**\n   * Executes listeners for `type` by passing data. Note that this is different from a\n   * Node stream, which can pass an arbitrary number of arguments\n   * @return `true` if event had listeners, `false` otherwise\n   */\n  Stream.prototype.emit = function(type, data) {\n    var events = this.events || {},\n        handlers = events[type] || [],\n        i, l;\n\n    if (!handlers.length) {\n      dust.log('Stream broadcasting, but no listeners for `' + type + '`', DEBUG);\n      return false;\n    }\n\n    handlers = handlers.slice(0);\n    for (i = 0, l = handlers.length; i < l; i++) {\n      handlers[i](data);\n    }\n    return true;\n  };\n\n  Stream.prototype.on = function(type, callback) {\n    var events = this.events = this.events || {},\n        handlers = events[type] = events[type] || [];\n\n    if(typeof callback !== 'function') {\n      dust.log('No callback function provided for `' + type + '` event listener', WARN);\n    } else {\n      handlers.push(callback);\n    }\n    return this;\n  };\n\n  /**\n   * Pipes to a WritableStream. Note that backpressure isn't implemented,\n   * so we just write as fast as we can.\n   * @param stream {WritableStream}\n   * @return self\n   */\n  Stream.prototype.pipe = function(stream) {\n    if(typeof stream.write !== 'function' ||\n       typeof stream.end !== 'function') {\n      dust.log('Incompatible stream passed to `pipe`', WARN);\n      return this;\n    }\n\n    var destEnded = false;\n\n    if(typeof stream.emit === 'function') {\n      stream.emit('pipe', this);\n    }\n\n    if(typeof stream.on === 'function') {\n      stream.on('error', function() {\n        destEnded = true;\n      });\n    }\n\n    return this\n    .on('data', function(data) {\n      if(destEnded) {\n        return;\n      }\n      try {\n        stream.write(data, 'utf8');\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    })\n    .on('end', function() {\n      if(destEnded) {\n        return;\n      }\n      try {\n        stream.end();\n        destEnded = true;\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    });\n  };\n\n  function Chunk(root, next, taps) {\n    this.root = root;\n    this.next = next;\n    this.data = []; //ie7 perf\n    this.flushable = false;\n    this.taps = taps;\n  }\n\n  Chunk.prototype.write = function(data) {\n    var taps = this.taps;\n\n    if (taps) {\n      data = taps.go(data);\n    }\n    this.data.push(data);\n    return this;\n  };\n\n  Chunk.prototype.end = function(data) {\n    if (data) {\n      this.write(data);\n    }\n    this.flushable = true;\n    this.root.flush();\n    return this;\n  };\n\n  /**\n   * Inserts a new chunk that can be used to asynchronously render or write to it\n   * @param callback {Function} The function that will be called with the new chunk\n   * @returns {Chunk} A copy of this chunk instance in order to further chain function calls on the chunk\n   */\n  Chunk.prototype.map = function(callback) {\n    var cursor = new Chunk(this.root, this.next, this.taps),\n        branch = new Chunk(this.root, cursor, this.taps);\n\n    this.next = branch;\n    this.flushable = true;\n    try {\n      callback(branch);\n    } catch(err) {\n      dust.log(err, ERROR);\n      branch.setError(err);\n    }\n    return cursor;\n  };\n\n  /**\n   * Like Chunk#map but additionally resolves a thenable.  If the thenable succeeds the callback is invoked with\n   * a new chunk that can be used to asynchronously render or write to it, otherwise if the thenable is rejected \n   * then the error body is rendered if available, an error is logged, and the callback is never invoked.\n   * @param {Chunk} The current chunk to insert a new chunk\n   * @param thenable {Thenable} the target thenable to await\n   * @param context {Context} context to use to render the deferred chunk\n   * @param bodies {Object} may optionally contain an \"error\" for when the thenable is rejected\n   * @param callback {Function} The function that will be called with the new chunk\n   * @returns {Chunk} A copy of this chunk instance in order to further chain function calls on the chunk\n   */\n  function mapThenable(chunk, thenable, context, bodies, callback) {\n    return chunk.map(function(asyncChunk) {\n      thenable.then(function(data) {\n        try {\n          callback(asyncChunk, data);\n        } catch (err) {\n          // handle errors the same way Chunk#map would.  This logic is only here since the thenable defers \n          // logic such that the try / catch in Chunk#map would not capture it. \n          dust.log(err, ERROR);\n          asyncChunk.setError(err);\n        }\n      }, function(err) {\n        dust.log('Unhandled promise rejection in `' + context.getTemplateName() + '`', INFO);\n        asyncChunk.renderError(err, context, bodies).end();\n      });\n    });\n  }\n\n  Chunk.prototype.tap = function(tap) {\n    var taps = this.taps;\n\n    if (taps) {\n      this.taps = taps.push(tap);\n    } else {\n      this.taps = new Tap(tap);\n    }\n    return this;\n  };\n\n  Chunk.prototype.untap = function() {\n    this.taps = this.taps.tail;\n    return this;\n  };\n\n  Chunk.prototype.render = function(body, context) {\n    return body(this, context);\n  };\n\n  Chunk.prototype.reference = function(elem, context, auto, filters) {\n    if (dust.isNonThenableFunction(elem)) {\n      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);\n      if (elem instanceof Chunk) {\n        return elem;\n      } else {\n        return this.reference(elem, context, auto, filters);\n      }\n    }\n    if (dust.isThenable(elem)) {\n      return this.await(elem, context, null, auto, filters);\n    } else if (dust.isStreamable(elem)) {\n      return this.stream(elem, context, null, auto, filters);\n    } else if (!dust.isEmpty(elem)) {\n      return this.write(dust.filter(elem, auto, filters, context));\n    } else {\n      return this;\n    }\n  };\n\n  Chunk.prototype.section = function(elem, context, bodies, params) {\n    var body = bodies.block,\n        skip = bodies['else'],\n        chunk = this,\n        i, len, head;\n\n    if (dust.isNonThenableFunction(elem) && !dust.isTemplateFn(elem)) {\n      try {\n        elem = elem.apply(context.current(), [this, context, bodies, params]);\n      } catch(err) {\n        dust.log(err, ERROR);\n        return this.setError(err);\n      }\n      // Functions that return chunks are assumed to have handled the chunk manually.\n      // Make that chunk the current one and go to the next method in the chain.\n      if (elem instanceof Chunk) {\n        return elem;\n      }\n    }\n\n    if (dust.isEmptyObject(bodies)) {\n      // No bodies to render, and we've already invoked any function that was available in\n      // hopes of returning a Chunk.\n      return chunk;\n    }\n\n    if (!dust.isEmptyObject(params)) {\n      context = context.push(params);\n    }\n\n    /*\n    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.\n    When elem resolves to a value or object instead of an array, Dust sets the current context to the value\n    and renders the block one time.\n    */\n    if (dust.isArray(elem)) {\n      if (body) {\n        len = elem.length;\n        if (len > 0) {\n          head = context.stack && context.stack.head || {};\n          head.$len = len;\n          for (i = 0; i < len; i++) {\n            head.$idx = i;\n            chunk = body(chunk, context.push(elem[i], i, len));\n          }\n          head.$idx = undefined;\n          head.$len = undefined;\n          return chunk;\n        } else if (skip) {\n          return skip(this, context);\n        }\n      }\n    } else if (dust.isThenable(elem)) {\n      return this.await(elem, context, bodies);\n    } else if (dust.isStreamable(elem)) {\n      return this.stream(elem, context, bodies);\n    } else if (elem === true) {\n     // true is truthy but does not change context\n      if (body) {\n        return body(this, context);\n      }\n    } else if (elem || elem === 0) {\n       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )\n       // zero is truthy\n       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value\n      if (body) {\n        return body(this, context.push(elem));\n      }\n     // nonexistent, scalar false value, scalar empty string, null,\n     // undefined are all falsy\n    } else if (skip) {\n      return skip(this, context);\n    }\n    dust.log('Section without corresponding key in template `' + context.getTemplateName() + '`', DEBUG);\n    return this;\n  };\n\n  Chunk.prototype.exists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (dust.isThenable(elem)) {\n      return mapThenable(this, elem, context, bodies, function(chunk, data) {\n        chunk.exists(data, context, bodies).end();\n      });\n    }\n\n    if (!dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n      dust.log('No block for exists check in template `' + context.getTemplateName() + '`', DEBUG);\n    } else if (skip) {\n      return skip(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.notexists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (dust.isThenable(elem)) {\n      return mapThenable(this, elem, context, bodies, function(chunk, data) {\n        chunk.notexists(data, context, bodies).end();\n      });\n    }\n\n    if (dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n      dust.log('No block for not-exists check in template `' + context.getTemplateName() + '`', DEBUG);\n    } else if (skip) {\n      return skip(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.block = function(elem, context, bodies) {\n    var body = elem || bodies.block;\n\n    if (body) {\n      return body(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.partial = function(elem, context, partialContext, params) {\n    var head;\n\n    if(params === undefined) {\n      // Compatibility for < 2.7.0 where `partialContext` did not exist\n      params = partialContext;\n      partialContext = context;\n    }\n\n    if (!dust.isEmptyObject(params)) {\n      partialContext = partialContext.clone();\n      head = partialContext.pop();\n      partialContext = partialContext.push(params)\n                                     .push(head);\n    }\n\n    if (dust.isTemplateFn(elem)) {\n      // The eventual result of evaluating `elem` is a partial name\n      // Load the partial after getting its name and end the async chunk\n      return this.capture(elem, context, function(name, chunk) {\n        load(name, chunk, partialContext).end();\n      });\n    } else {\n      return load(elem, this, partialContext);\n    }\n  };\n\n  Chunk.prototype.helper = function(name, context, bodies, params, auto) {\n    var chunk = this,\n        filters = params.filters,\n        ret;\n\n    // Pre-2.7.1 compat: if auto is undefined, it's an old template. Automatically escape\n    if (auto === undefined) {\n      auto = 'h';\n    }\n\n    // handle invalid helpers, similar to invalid filters\n    if(dust.helpers[name]) {\n      try {\n        ret = dust.helpers[name](chunk, context, bodies, params);\n        if (ret instanceof Chunk) {\n          return ret;\n        }\n        if(typeof filters === 'string') {\n          filters = filters.split('|');\n        }\n        if (!dust.isEmptyObject(bodies)) {\n          return chunk.section(ret, context, bodies, params);\n        }\n        // Helpers act slightly differently from functions in context in that they will act as\n        // a reference if they are self-closing (due to grammar limitations)\n        // In the Chunk.await function we check to make sure bodies is null before acting as a reference\n        return chunk.reference(ret, context, auto, filters);\n      } catch(err) {\n        dust.log('Error in helper `' + name + '`: ' + err.message, ERROR);\n        return chunk.setError(err);\n      }\n    } else {\n      dust.log('Helper `' + name + '` does not exist', WARN);\n      return chunk;\n    }\n  };\n\n  /**\n   * Reserve a chunk to be evaluated once a thenable is resolved or rejected\n   * @param thenable {Thenable} the target thenable to await\n   * @param context {Context} context to use to render the deferred chunk\n   * @param bodies {Object} must contain a \"body\", may contain an \"error\"\n   * @param auto {String} automatically apply this filter if the Thenable is a reference\n   * @param filters {Array} apply these filters if the Thenable is a reference\n   * @return {Chunk}\n   */\n  Chunk.prototype.await = function(thenable, context, bodies, auto, filters) {\n    return mapThenable(this, thenable, context, bodies, function(chunk, data) {\n      if (bodies) {\n        chunk.section(data, context, bodies).end();\n      } else {\n        // Actually a reference. Self-closing sections don't render\n        chunk.reference(data, context, auto, filters).end();\n      }\n    });\n  };\n\n  /**\n   * Render an error body if available\n   * @param err {Error} error that occurred\n   * @param context {Context} context to use to render the error\n   * @param bodies {Object} may optionally contain an \"error\" which will be rendered\n   * @return {Chunk}\n   */\n  Chunk.prototype.renderError = function(err, context, bodies) {\n    var errorBody = bodies && bodies.error;\n    if (errorBody) {\n      return this.render(errorBody, context.push(err));\n    }\n    return this;\n  };\n\n  /**\n   * Reserve a chunk to be evaluated with the contents of a streamable.\n   * Currently an error event will bomb out the stream. Once an error\n   * is received, we push it to an {:error} block if one exists, and log otherwise,\n   * then stop listening to the stream.\n   * @param streamable {Streamable} the target streamable that will emit events\n   * @param context {Context} context to use to render each thunk\n   * @param bodies {Object} must contain a \"body\", may contain an \"error\"\n   * @return {Chunk}\n   */\n  Chunk.prototype.stream = function(stream, context, bodies, auto, filters) {\n    var body = bodies && bodies.block;\n    return this.map(function(chunk) {\n      var ended = false;\n      stream\n        .on('data', function data(thunk) {\n          if(ended) {\n            return;\n          }\n          if(body) {\n            // Fork a new chunk out of the blockstream so that we can flush it independently\n            chunk = chunk.map(function(chunk) {\n              chunk.render(body, context.push(thunk)).end();\n            });\n          } else if(!bodies) {\n            // When actually a reference, don't fork, just write into the master async chunk\n            chunk = chunk.reference(thunk, context, auto, filters);\n          }\n        })\n        .on('error', function error(err) {\n          if(ended) {\n            return;\n          }\n          chunk.renderError(err, context, bodies);\n          dust.log('Unhandled stream error in `' + context.getTemplateName() + '`', INFO);\n          if(!ended) {\n            ended = true;\n            chunk.end();\n          }\n        })\n        .on('end', function end() {\n          if(!ended) {\n            ended = true;\n            chunk.end();\n          }\n        });\n    });\n  };\n\n  Chunk.prototype.capture = function(body, context, callback) {\n    return this.map(function(chunk) {\n      var stub = new Stub(function(err, out) {\n        if (err) {\n          chunk.setError(err);\n        } else {\n          callback(out, chunk);\n        }\n      });\n      body(stub.head, context).end();\n    });\n  };\n\n  Chunk.prototype.setError = function(err) {\n    this.error = err;\n    this.root.flush();\n    return this;\n  };\n\n  // Chunk aliases\n  for(var f in Chunk.prototype) {\n    if(dust._aliases[f]) {\n      Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];\n    }\n  }\n\n  function Tap(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  Tap.prototype.push = function(tap) {\n    return new Tap(tap, this);\n  };\n\n  Tap.prototype.go = function(value) {\n    var tap = this;\n\n    while(tap) {\n      value = tap.head(value);\n      tap = tap.tail;\n    }\n    return value;\n  };\n\n  var HCHARS = /[&<>\"']/,\n      AMP    = /&/g,\n      LT     = /</g,\n      GT     = />/g,\n      QUOT   = /\\\"/g,\n      SQUOT  = /\\'/g;\n\n  dust.escapeHtml = function(s) {\n    if (typeof s === \"string\" || (s && typeof s.toString === \"function\")) {\n      if (typeof s !== \"string\") {\n        s = s.toString();\n      }\n      if (!HCHARS.test(s)) {\n        return s;\n      }\n      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');\n    }\n    return s;\n  };\n\n  var BS = /\\\\/g,\n      FS = /\\//g,\n      CR = /\\r/g,\n      LS = /\\u2028/g,\n      PS = /\\u2029/g,\n      NL = /\\n/g,\n      LF = /\\f/g,\n      SQ = /'/g,\n      DQ = /\"/g,\n      TB = /\\t/g;\n\n  dust.escapeJs = function(s) {\n    if (typeof s === 'string') {\n      return s\n        .replace(BS, '\\\\\\\\')\n        .replace(FS, '\\\\/')\n        .replace(DQ, '\\\\\"')\n        .replace(SQ, '\\\\\\'')\n        .replace(CR, '\\\\r')\n        .replace(LS, '\\\\u2028')\n        .replace(PS, '\\\\u2029')\n        .replace(NL, '\\\\n')\n        .replace(LF, '\\\\f')\n        .replace(TB, '\\\\t');\n    }\n    return s;\n  };\n\n  dust.escapeJSON = function(o) {\n    if (!JSON) {\n      dust.log('JSON is undefined; could not escape `' + o + '`', WARN);\n      return o;\n    } else {\n      return JSON.stringify(o)\n        .replace(LS, '\\\\u2028')\n        .replace(PS, '\\\\u2029')\n        .replace(LT, '\\\\u003c');\n    }\n  };\n\n  return dust;\n\n}));\n\nif (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define([\"require\", \"dust.core\"], function(require, dust) {\n        dust.onLoad = function(name, cb) {\n            require([name], function(tmpl) {\n                cb(null, tmpl);\n            });\n        };\n        return dust;\n    });\n}\n", "/*! dustjs-linkedin - v2.7.2\n* http://dustjs.com/\n* Copyright (c) 2021 Aleksander Williams; Released under the MIT License */\n!function(a,b){\"function\"==typeof define&&define.amd&&define.amd.dust===!0?define(\"dust.core\",[],b):\"object\"==typeof exports?module.exports=b():a.dust=b()}(this,function(){function getTemplate(a,b){if(a)return\"function\"==typeof a&&a.template?a.template:dust.isTemplateFn(a)?a:b!==!1?dust.cache[a]:void 0}function load(a,b,c){if(!a)return b.setError(new Error(\"No template or template name provided to render\"));var d=getTemplate(a,dust.config.cache);return d?d(b,Context.wrap(c,d.templateName)):dust.onLoad?b.map(function(b){function d(a,d){var f;if(a)return b.setError(a);if(f=getTemplate(d,!1)||getTemplate(e,dust.config.cache),!f){if(!dust.compile)return b.setError(new Error(\"Dust compiler not available\"));f=dust.loadSource(dust.compile(d,e))}f(b,Context.wrap(c,f.templateName)).end()}var e=a;3===dust.onLoad.length?dust.onLoad(e,c.options,d):dust.onLoad(e,d)}):b.setError(new Error(\"Template Not Found: \"+a))}function Context(a,b,c,d,e){void 0===a||a instanceof Stack||(a=new Stack(a)),this.stack=a,this.global=b,this.options=c,this.blocks=d,this.templateName=e,this._isContext=!0}function getWithResolvedData(a,b,c){return function(d){return a.push(d)._get(b,c)}}function Stack(a,b,c,d){this.tail=b,this.isObject=a&&\"object\"==typeof a,this.head=a,this.index=c,this.of=d}function Stub(a){this.head=new Chunk(this),this.callback=a,this.out=\"\"}function Stream(){this.head=new Chunk(this)}function Chunk(a,b,c){this.root=a,this.next=b,this.data=[],this.flushable=!1,this.taps=c}function mapThenable(a,b,c,d,e){return a.map(function(a){b.then(function(b){try{e(a,b)}catch(c){dust.log(c,ERROR),a.setError(c)}},function(b){dust.log(\"Unhandled promise rejection in `\"+c.getTemplateName()+\"`\",INFO),a.renderError(b,c,d).end()})})}function Tap(a,b){this.head=a,this.tail=b}var dust={version:\"2.7.2\"},NONE=\"NONE\",ERROR=\"ERROR\",WARN=\"WARN\",INFO=\"INFO\",DEBUG=\"DEBUG\",EMPTY_FUNC=function(){};dust.config={whitespace:!1,amd:!1,cjs:!1,cache:!0},dust._aliases={write:\"w\",end:\"e\",map:\"m\",render:\"r\",reference:\"f\",section:\"s\",exists:\"x\",notexists:\"nx\",block:\"b\",partial:\"p\",helper:\"h\"},function(){var a,b,c={DEBUG:0,INFO:1,WARN:2,ERROR:3,NONE:4};\"undefined\"!=typeof console&&console.log?(a=console.log,b=\"function\"==typeof a?function(){a.apply(console,arguments)}:function(){a(Array.prototype.slice.apply(arguments).join(\" \"))}):b=EMPTY_FUNC,dust.log=function(a,d){d=d||INFO,c[d]>=c[dust.debugLevel]&&(b(\"[DUST:\"+d+\"]\",a),d===ERROR&&dust.debugLevel===DEBUG&&a instanceof Error&&a.stack&&b(\"[DUST:\"+d+\"]\",a.stack))},dust.debugLevel=NONE,\"undefined\"!=typeof process&&process.env&&/\\bdust\\b/.test(process.env.DEBUG)&&(dust.debugLevel=DEBUG)}(),dust.helpers={},dust.cache={},dust.register=function(a,b){a&&(b.templateName=a,dust.config.cache!==!1&&(dust.cache[a]=b))},dust.render=function(a,b,c){var d=new Stub(c).head;try{load(a,d,b).end()}catch(e){d.setError(e)}},dust.stream=function(a,b){var c=new Stream,d=c.head;return dust.nextTick(function(){try{load(a,d,b).end()}catch(c){d.setError(c)}}),c},dust.loadSource=function(source){return eval(source)},Array.isArray?dust.isArray=Array.isArray:dust.isArray=function(a){return\"[object Array]\"===Object.prototype.toString.call(a)},dust.nextTick=function(){return function(a){setTimeout(a,0)}}(),dust.isEmpty=function(a){return 0!==a&&(!(!dust.isArray(a)||a.length)||!a)},dust.isEmptyObject=function(a){var b;if(null===a)return!1;if(void 0===a)return!1;if(a.length>0)return!1;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b))return!1;return!0},dust.isTemplateFn=function(a){return\"function\"==typeof a&&a.__dustBody},dust.isThenable=function(a){return a&&(\"object\"==typeof a||\"function\"==typeof a)&&\"function\"==typeof a.then},dust.isNonThenableFunction=function(a){return\"function\"==typeof a&&!dust.isThenable(a)},dust.isStreamable=function(a){return a&&\"function\"==typeof a.on&&\"function\"==typeof a.pipe},dust.filter=function(a,b,c,d){var e,f,g,h;if(c)for(e=0,f=c.length;e<f;e++)g=c[e],g.length&&(h=dust.filters[g],\"s\"===g?b=null:\"function\"==typeof h?a=h(a,d):dust.log(\"Invalid filter `\"+g+\"`\",WARN));return b&&(a=dust.filters[b](a,d)),a},dust.filters={h:function(a){return dust.escapeHtml(a)},j:function(a){return dust.escapeJs(a)},u:encodeURI,uc:encodeURIComponent,js:function(a){return dust.escapeJSON(a)},jp:function(a){return JSON?JSON.parse(a):(dust.log(\"JSON is undefined; could not parse `\"+a+\"`\",WARN),a)}},dust.makeBase=dust.context=function(a,b){return new Context((void 0),a,b)},dust.isContext=function(a){return\"object\"==typeof a&&a._isContext===!0},Context.wrap=function(a,b){return dust.isContext(a)?(a.templateName=b,a):new Context(a,{},{},null,b)},Context.prototype.get=function(a,b){return\"string\"==typeof a&&(\".\"===a[0]&&(b=!0,a=a.substr(1)),a=a.split(\".\")),this._get(b,a)},Context.prototype._get=function(a,b){var c,d,e,f,g,h=this.stack||{},i=1;if(d=b[0],e=b.length,a&&0===e)f=h,h=h.head;else{if(a)h&&(h=h.head?h.head[d]:void 0);else{for(;h&&(!h.isObject||(f=h.head,c=h.head[d],void 0===c));)h=h.tail;h=void 0!==c?c:this.global&&this.global[d]}for(;h&&i<e;){if(dust.isThenable(h))return h.then(getWithResolvedData(this,a,b.slice(i)));f=h,h=h[b[i]],i++}}return dust.isNonThenableFunction(h)?(g=function(){try{return h.apply(f,arguments)}catch(a){throw dust.log(a,ERROR),a}},g.__dustBody=!!h.__dustBody,g):(void 0===h&&dust.log(\"Cannot find reference `{\"+b.join(\".\")+\"}` in template `\"+this.getTemplateName()+\"`\",INFO),h)},Context.prototype.getPath=function(a,b){return this._get(a,b)},Context.prototype.push=function(a,b,c){return void 0===a?(dust.log(\"Not pushing an undefined variable onto the context\",INFO),this):this.rebase(new Stack(a,this.stack,b,c))},Context.prototype.pop=function(){var a=this.current();return this.stack=this.stack&&this.stack.tail,a},Context.prototype.rebase=function(a){return new Context(a,this.global,this.options,this.blocks,this.getTemplateName())},Context.prototype.clone=function(){var a=this.rebase();return a.stack=this.stack,a},Context.prototype.current=function(){return this.stack&&this.stack.head},Context.prototype.getBlock=function(a){var b,c,d;if(\"function\"==typeof a&&(a=a(new Chunk,this).data.join(\"\")),b=this.blocks,!b)return dust.log(\"No blocks for context `\"+a+\"` in template `\"+this.getTemplateName()+\"`\",DEBUG),!1;for(c=b.length;c--;)if(d=b[c][a])return d;return dust.log(\"Malformed template `\"+this.getTemplateName()+\"` was missing one or more blocks.\"),!1},Context.prototype.shiftBlocks=function(a){var b,c=this.blocks;return a?(b=c?c.concat([a]):[a],new Context(this.stack,this.global,this.options,b,this.getTemplateName())):this},Context.prototype.resolve=function(a){var b;return\"function\"!=typeof a?a:(b=(new Chunk).render(a,this),b instanceof Chunk?b.data.join(\"\"):b)},Context.prototype.getTemplateName=function(){return this.templateName},Stub.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.callback(a.error),dust.log(\"Rendering failed with error `\"+a.error+\"`\",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.out+=a.data.join(\"\"),a=a.next,this.head=a}this.callback(null,this.out)},Stream.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.emit(\"error\",a.error),this.emit(\"end\"),dust.log(\"Streaming failed with error `\"+a.error+\"`\",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.emit(\"data\",a.data.join(\"\")),a=a.next,this.head=a}this.emit(\"end\")},Stream.prototype.emit=function(a,b){var c,d,e=this.events||{},f=e[a]||[];if(!f.length)return dust.log(\"Stream broadcasting, but no listeners for `\"+a+\"`\",DEBUG),!1;for(f=f.slice(0),c=0,d=f.length;c<d;c++)f[c](b);return!0},Stream.prototype.on=function(a,b){var c=this.events=this.events||{},d=c[a]=c[a]||[];return\"function\"!=typeof b?dust.log(\"No callback function provided for `\"+a+\"` event listener\",WARN):d.push(b),this},Stream.prototype.pipe=function(a){if(\"function\"!=typeof a.write||\"function\"!=typeof a.end)return dust.log(\"Incompatible stream passed to `pipe`\",WARN),this;var b=!1;return\"function\"==typeof a.emit&&a.emit(\"pipe\",this),\"function\"==typeof a.on&&a.on(\"error\",function(){b=!0}),this.on(\"data\",function(c){if(!b)try{a.write(c,\"utf8\")}catch(d){dust.log(d,ERROR)}}).on(\"end\",function(){if(!b)try{a.end(),b=!0}catch(c){dust.log(c,ERROR)}})},Chunk.prototype.write=function(a){var b=this.taps;return b&&(a=b.go(a)),this.data.push(a),this},Chunk.prototype.end=function(a){return a&&this.write(a),this.flushable=!0,this.root.flush(),this},Chunk.prototype.map=function(a){var b=new Chunk(this.root,this.next,this.taps),c=new Chunk(this.root,b,this.taps);this.next=c,this.flushable=!0;try{a(c)}catch(d){dust.log(d,ERROR),c.setError(d)}return b},Chunk.prototype.tap=function(a){var b=this.taps;return b?this.taps=b.push(a):this.taps=new Tap(a),this},Chunk.prototype.untap=function(){return this.taps=this.taps.tail,this},Chunk.prototype.render=function(a,b){return a(this,b)},Chunk.prototype.reference=function(a,b,c,d){return dust.isNonThenableFunction(a)?(a=a.apply(b.current(),[this,b,null,{auto:c,filters:d}]),a instanceof Chunk?a:this.reference(a,b,c,d)):dust.isThenable(a)?this.await(a,b,null,c,d):dust.isStreamable(a)?this.stream(a,b,null,c,d):dust.isEmpty(a)?this:this.write(dust.filter(a,c,d,b))},Chunk.prototype.section=function(a,b,c,d){var e,f,g,h=c.block,i=c[\"else\"],j=this;if(dust.isNonThenableFunction(a)&&!dust.isTemplateFn(a)){try{a=a.apply(b.current(),[this,b,c,d])}catch(k){return dust.log(k,ERROR),this.setError(k)}if(a instanceof Chunk)return a}if(dust.isEmptyObject(c))return j;if(dust.isEmptyObject(d)||(b=b.push(d)),dust.isArray(a)){if(h){if(f=a.length,f>0){for(g=b.stack&&b.stack.head||{},g.$len=f,e=0;e<f;e++)g.$idx=e,j=h(j,b.push(a[e],e,f));return g.$idx=void 0,g.$len=void 0,j}if(i)return i(this,b)}}else{if(dust.isThenable(a))return this.await(a,b,c);if(dust.isStreamable(a))return this.stream(a,b,c);if(a===!0){if(h)return h(this,b)}else if(a||0===a){if(h)return h(this,b.push(a))}else if(i)return i(this,b)}return dust.log(\"Section without corresponding key in template `\"+b.getTemplateName()+\"`\",DEBUG),this},Chunk.prototype.exists=function(a,b,c){var d=c.block,e=c[\"else\"];if(dust.isThenable(a))return mapThenable(this,a,b,c,function(a,d){a.exists(d,b,c).end()});if(dust.isEmpty(a)){if(e)return e(this,b)}else{if(d)return d(this,b);dust.log(\"No block for exists check in template `\"+b.getTemplateName()+\"`\",DEBUG)}return this},Chunk.prototype.notexists=function(a,b,c){var d=c.block,e=c[\"else\"];if(dust.isThenable(a))return mapThenable(this,a,b,c,function(a,d){a.notexists(d,b,c).end()});if(dust.isEmpty(a)){if(d)return d(this,b);dust.log(\"No block for not-exists check in template `\"+b.getTemplateName()+\"`\",DEBUG)}else if(e)return e(this,b);return this},Chunk.prototype.block=function(a,b,c){var d=a||c.block;return d?d(this,b):this},Chunk.prototype.partial=function(a,b,c,d){var e;return void 0===d&&(d=c,c=b),dust.isEmptyObject(d)||(c=c.clone(),e=c.pop(),c=c.push(d).push(e)),dust.isTemplateFn(a)?this.capture(a,b,function(a,b){load(a,b,c).end()}):load(a,this,c)},Chunk.prototype.helper=function(a,b,c,d,e){var f,g=this,h=d.filters;if(void 0===e&&(e=\"h\"),!dust.helpers[a])return dust.log(\"Helper `\"+a+\"` does not exist\",WARN),g;try{return f=dust.helpers[a](g,b,c,d),f instanceof Chunk?f:(\"string\"==typeof h&&(h=h.split(\"|\")),dust.isEmptyObject(c)?g.reference(f,b,e,h):g.section(f,b,c,d))}catch(i){return dust.log(\"Error in helper `\"+a+\"`: \"+i.message,ERROR),g.setError(i)}},Chunk.prototype.await=function(a,b,c,d,e){return mapThenable(this,a,b,c,function(a,f){c?a.section(f,b,c).end():a.reference(f,b,d,e).end()})},Chunk.prototype.renderError=function(a,b,c){var d=c&&c.error;return d?this.render(d,b.push(a)):this},Chunk.prototype.stream=function(a,b,c,d,e){var f=c&&c.block;return this.map(function(g){var h=!1;a.on(\"data\",function(a){h||(f?g=g.map(function(c){c.render(f,b.push(a)).end()}):c||(g=g.reference(a,b,d,e)))}).on(\"error\",function(a){h||(g.renderError(a,b,c),dust.log(\"Unhandled stream error in `\"+b.getTemplateName()+\"`\",INFO),h||(h=!0,g.end()))}).on(\"end\",function(){h||(h=!0,g.end())})})},Chunk.prototype.capture=function(a,b,c){return this.map(function(d){var e=new Stub(function(a,b){a?d.setError(a):c(b,d)});a(e.head,b).end()})},Chunk.prototype.setError=function(a){return this.error=a,this.root.flush(),this};for(var f in Chunk.prototype)dust._aliases[f]&&(Chunk.prototype[dust._aliases[f]]=Chunk.prototype[f]);Tap.prototype.push=function(a){return new Tap(a,this)},Tap.prototype.go=function(a){for(var b=this;b;)a=b.head(a),b=b.tail;return a};var HCHARS=/[&<>\"']/,AMP=/&/g,LT=/</g,GT=/>/g,QUOT=/\\\"/g,SQUOT=/\\'/g;dust.escapeHtml=function(a){return\"string\"==typeof a||a&&\"function\"==typeof a.toString?(\"string\"!=typeof a&&(a=a.toString()),HCHARS.test(a)?a.replace(AMP,\"&amp;\").replace(LT,\"&lt;\").replace(GT,\"&gt;\").replace(QUOT,\"&quot;\").replace(SQUOT,\"&#39;\"):a):a};var BS=/\\\\/g,FS=/\\//g,CR=/\\r/g,LS=/\\u2028/g,PS=/\\u2029/g,NL=/\\n/g,LF=/\\f/g,SQ=/'/g,DQ=/\"/g,TB=/\\t/g;return dust.escapeJs=function(a){return\"string\"==typeof a?a.replace(BS,\"\\\\\\\\\").replace(FS,\"\\\\/\").replace(DQ,'\\\\\"').replace(SQ,\"\\\\'\").replace(CR,\"\\\\r\").replace(LS,\"\\\\u2028\").replace(PS,\"\\\\u2029\").replace(NL,\"\\\\n\").replace(LF,\"\\\\f\").replace(TB,\"\\\\t\"):a},dust.escapeJSON=function(a){return JSON?JSON.stringify(a).replace(LS,\"\\\\u2028\").replace(PS,\"\\\\u2029\").replace(LT,\"\\\\u003c\"):(dust.log(\"JSON is undefined; could not escape `\"+a+\"`\",WARN),a)},dust}),\"function\"==typeof define&&define.amd&&define.amd.dust===!0&&define([\"require\",\"dust.core\"],function(require,dust){return dust.onLoad=function(a,b){require([a],function(a){b(null,a)})},dust});", "/*! dustjs-linkedin - v2.7.2\n* http://dustjs.com/\n* Copyright (c) 2021 Aleksander Williams; Released under the MIT License */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd && define.amd.dust === true) {\n    define('dust.core', [], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.dust = factory();\n  }\n}(this, function() {\n  var dust = {\n        \"version\": \"2.7.2\"\n      },\n      NONE = 'NONE', ERROR = 'ERROR', WARN = 'WARN', INFO = 'INFO', DEBUG = 'DEBUG',\n      EMPTY_FUNC = function() {};\n\n  dust.config = {\n    whitespace: false,\n    amd: false,\n    cjs: false,\n    cache: true\n  };\n\n  // Directive aliases to minify code\n  dust._aliases = {\n    \"write\": \"w\",\n    \"end\": \"e\",\n    \"map\": \"m\",\n    \"render\": \"r\",\n    \"reference\": \"f\",\n    \"section\": \"s\",\n    \"exists\": \"x\",\n    \"notexists\": \"nx\",\n    \"block\": \"b\",\n    \"partial\": \"p\",\n    \"helper\": \"h\"\n  };\n\n  (function initLogging() {\n    /*global process, console*/\n    var loggingLevels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, NONE: 4 },\n        consoleLog,\n        log;\n\n    if (typeof console !== 'undefined' && console.log) {\n      consoleLog = console.log;\n      if(typeof consoleLog === 'function') {\n        log = function() {\n          consoleLog.apply(console, arguments);\n        };\n      } else {\n        log = function() {\n          consoleLog(Array.prototype.slice.apply(arguments).join(' '));\n        };\n      }\n    } else {\n      log = EMPTY_FUNC;\n    }\n\n    /**\n     * Filters messages based on `dust.debugLevel`.\n     * This default implementation will print to the console if it exists.\n     * @param {String|Error} message the message to print/throw\n     * @param {String} type the severity of the message(ERROR, WARN, INFO, or DEBUG)\n     * @public\n     */\n    dust.log = function(message, type) {\n      type = type || INFO;\n      if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {\n        log('[DUST:' + type + ']', message);\n        if (type === ERROR && dust.debugLevel === DEBUG && message instanceof Error && message.stack) {\n          log('[DUST:' + type + ']', message.stack);\n        }\n      }\n    };\n\n    dust.debugLevel = NONE;\n    if(typeof process !== 'undefined' && process.env && /\\bdust\\b/.test(process.env.DEBUG)) {\n      dust.debugLevel = DEBUG;\n    }\n\n  }());\n\n  dust.helpers = {};\n\n  dust.cache = {};\n\n  dust.register = function(name, tmpl) {\n    if (!name) {\n      return;\n    }\n    tmpl.templateName = name;\n    if (dust.config.cache !== false) {\n      dust.cache[name] = tmpl;\n    }\n  };\n\n  dust.render = function(nameOrTemplate, context, callback) {\n    var chunk = new Stub(callback).head;\n    try {\n      load(nameOrTemplate, chunk, context).end();\n    } catch (err) {\n      chunk.setError(err);\n    }\n  };\n\n  dust.stream = function(nameOrTemplate, context) {\n    var stream = new Stream(),\n        chunk = stream.head;\n    dust.nextTick(function() {\n      try {\n        load(nameOrTemplate, chunk, context).end();\n      } catch (err) {\n        chunk.setError(err);\n      }\n    });\n    return stream;\n  };\n\n  /**\n   * Extracts a template function (body_0) from whatever is passed.\n   * @param nameOrTemplate {*} Could be:\n   *   - the name of a template to load from cache\n   *   - a CommonJS-compiled template (a function with a `template` property)\n   *   - a template function\n   * @param loadFromCache {Boolean} if false, don't look in the cache\n   * @return {Function} a template function, if found\n   */\n  function getTemplate(nameOrTemplate, loadFromCache/*=true*/) {\n    if(!nameOrTemplate) {\n      return;\n    }\n    if(typeof nameOrTemplate === 'function' && nameOrTemplate.template) {\n      // Sugar away CommonJS module templates\n      return nameOrTemplate.template;\n    }\n    if(dust.isTemplateFn(nameOrTemplate)) {\n      // Template functions passed directly\n      return nameOrTemplate;\n    }\n    if(loadFromCache !== false) {\n      // Try loading a template with this name from cache\n      return dust.cache[nameOrTemplate];\n    }\n  }\n\n  function load(nameOrTemplate, chunk, context) {\n    if(!nameOrTemplate) {\n      return chunk.setError(new Error('No template or template name provided to render'));\n    }\n\n    var template = getTemplate(nameOrTemplate, dust.config.cache);\n\n    if (template) {\n      return template(chunk, Context.wrap(context, template.templateName));\n    } else {\n      if (dust.onLoad) {\n        return chunk.map(function(chunk) {\n          // Alias just so it's easier to read that this would always be a name\n          var name = nameOrTemplate;\n          // Three possible scenarios for a successful callback:\n          //   - `require(nameOrTemplate)(dust); cb()`\n          //   - `src = readFile('src.dust'); cb(null, src)`\n          //   - `compiledTemplate = require(nameOrTemplate)(dust); cb(null, compiledTemplate)`\n          function done(err, srcOrTemplate) {\n            var template;\n            if (err) {\n              return chunk.setError(err);\n            }\n            // Prefer a template that is passed via callback over the cached version.\n            template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);\n            if (!template) {\n              // It's a template string, compile it and register under `name`\n              if(dust.compile) {\n                template = dust.loadSource(dust.compile(srcOrTemplate, name));\n              } else {\n                return chunk.setError(new Error('Dust compiler not available'));\n              }\n            }\n            template(chunk, Context.wrap(context, template.templateName)).end();\n          }\n\n          if(dust.onLoad.length === 3) {\n            dust.onLoad(name, context.options, done);\n          } else {\n            dust.onLoad(name, done);\n          }\n        });\n      }\n      return chunk.setError(new Error('Template Not Found: ' + nameOrTemplate));\n    }\n  }\n\n  dust.loadSource = function(source) {\n    /*jshint evil:true*/\n    return eval(source);\n  };\n\n  if (Array.isArray) {\n    dust.isArray = Array.isArray;\n  } else {\n    dust.isArray = function(arr) {\n      return Object.prototype.toString.call(arr) === '[object Array]';\n    };\n  }\n\n  dust.nextTick = (function() {\n    return function(callback) {\n      setTimeout(callback, 0);\n    };\n  })();\n\n  /**\n   * Dust has its own rules for what is \"empty\"-- which is not the same as falsy.\n   * Empty arrays, null, and undefined are empty\n   */\n  dust.isEmpty = function(value) {\n    if (value === 0) {\n      return false;\n    }\n    if (dust.isArray(value) && !value.length) {\n      return true;\n    }\n    return !value;\n  };\n\n  dust.isEmptyObject = function(obj) {\n    var key;\n    if (obj === null) {\n      return false;\n    }\n    if (obj === undefined) {\n      return false;\n    }\n    if (obj.length > 0) {\n      return false;\n    }\n    for (key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  dust.isTemplateFn = function(elem) {\n    return typeof elem === 'function' &&\n           elem.__dustBody;\n  };\n\n  /**\n   * Decide somewhat-naively if something is a Thenable.  Matches Promises A+ Spec, section 1.2 \u201cthenable\u201d is an object or function that defines a then method.\"\n   * @param elem {*} object to inspect\n   * @return {Boolean} is `elem` a Thenable?\n   */\n  dust.isThenable = function(elem) {\n    return elem &&  /* Beware: `typeof null` is `object` */\n           (typeof elem === 'object' || typeof elem === 'function') &&\n           typeof elem.then === 'function';\n  };\n\n  /**\n   * Decide if an element is a function but not Thenable; it is prefereable to resolve a thenable function by its `.then` method.\n   * @param elem {*} target of inspection\n   * @return {Boolean} is `elem` a function without a `.then` property?\n   */\n  dust.isNonThenableFunction = function(elem) {\n    return typeof elem === 'function' && !dust.isThenable(elem);\n  };\n\n  /**\n   * Decide very naively if something is a Stream.\n   * @param elem {*} object to inspect\n   * @return {Boolean} is `elem` a Stream?\n   */\n  dust.isStreamable = function(elem) {\n    return elem &&\n           typeof elem.on === 'function' &&\n           typeof elem.pipe === 'function';\n  };\n\n  // apply the filter chain and return the output string\n  dust.filter = function(string, auto, filters, context) {\n    var i, len, name, filter;\n    if (filters) {\n      for (i = 0, len = filters.length; i < len; i++) {\n        name = filters[i];\n        if (!name.length) {\n          continue;\n        }\n        filter = dust.filters[name];\n        if (name === 's') {\n          auto = null;\n        } else if (typeof filter === 'function') {\n          string = filter(string, context);\n        } else {\n          dust.log('Invalid filter `' + name + '`', WARN);\n        }\n      }\n    }\n    // by default always apply the h filter, unless asked to unescape with |s\n    if (auto) {\n      string = dust.filters[auto](string, context);\n    }\n    return string;\n  };\n\n  dust.filters = {\n    h: function(value) { return dust.escapeHtml(value); },\n    j: function(value) { return dust.escapeJs(value); },\n    u: encodeURI,\n    uc: encodeURIComponent,\n    js: function(value) { return dust.escapeJSON(value); },\n    jp: function(value) {\n      if (!JSON) {dust.log('JSON is undefined; could not parse `' + value + '`', WARN);\n        return value;\n      } else {\n        return JSON.parse(value);\n      }\n    }\n  };\n\n  function Context(stack, global, options, blocks, templateName) {\n    if(stack !== undefined && !(stack instanceof Stack)) {\n      stack = new Stack(stack);\n    }\n    this.stack = stack;\n    this.global = global;\n    this.options = options;\n    this.blocks = blocks;\n    this.templateName = templateName;\n    this._isContext = true;\n  }\n\n  dust.makeBase = dust.context = function(global, options) {\n    return new Context(undefined, global, options);\n  };\n\n  dust.isContext = function(obj) {\n    return typeof obj === \"object\" && obj._isContext === true;\n  };\n\n  /**\n   * Factory function that creates a closure scope around a Thenable-callback.\n   * Returns a function that can be passed to a Thenable that will resume a\n   * Context lookup once the Thenable resolves with new data, adding that new\n   * data to the lookup stack.\n   */\n  function getWithResolvedData(ctx, cur, down) {\n    return function(data) {\n      return ctx.push(data)._get(cur, down);\n    };\n  }\n\n  Context.wrap = function(context, name) {\n    if (dust.isContext(context)) {\n      context.templateName = name;\n      return context;\n    }\n    return new Context(context, {}, {}, null, name);\n  };\n\n  /**\n   * Public API for getting a value from the context.\n   * @method get\n   * @param {string|array} path The path to the value. Supported formats are:\n   * 'key'\n   * 'path.to.key'\n   * '.path.to.key'\n   * ['path', 'to', 'key']\n   * ['key']\n   * @param {boolean} [cur=false] Boolean which determines if the search should be limited to the\n   * current context (true), or if get should search in parent contexts as well (false).\n   * @public\n   * @returns {string|object}\n   */\n  Context.prototype.get = function(path, cur) {\n    if (typeof path === 'string') {\n      if (path[0] === '.') {\n        cur = true;\n        path = path.substr(1);\n      }\n      path = path.split('.');\n    }\n    return this._get(cur, path);\n  };\n\n  /**\n   * Get a value from the context\n   * @method _get\n   * @param {boolean} cur Get only from the current context\n   * @param {array} down An array of each step in the path\n   * @private\n   * @return {string | object}\n   */\n  Context.prototype._get = function(cur, down) {\n    var ctx = this.stack || {},\n        i = 1,\n        value, first, len, ctxThis, fn;\n\n    first = down[0];\n    len = down.length;\n\n    if (cur && len === 0) {\n      ctxThis = ctx;\n      ctx = ctx.head;\n    } else {\n      if (!cur) {\n        // Search up the stack for the first value\n        while (ctx) {\n          if (ctx.isObject) {\n            ctxThis = ctx.head;\n            value = ctx.head[first];\n            if (value !== undefined) {\n              break;\n            }\n          }\n          ctx = ctx.tail;\n        }\n\n        // Try looking in the global context if we haven't found anything yet\n        if (value !== undefined) {\n          ctx = value;\n        } else {\n          ctx = this.global && this.global[first];\n        }\n      } else if (ctx) {\n        // if scope is limited by a leading dot, don't search up the tree\n        if(ctx.head) {\n          ctx = ctx.head[first];\n        } else {\n          // context's head is empty, value we are searching for is not defined\n          ctx = undefined;\n        }\n      }\n\n      while (ctx && i < len) {\n        if (dust.isThenable(ctx)) {\n          // Bail early by returning a Thenable for the remainder of the search tree\n          return ctx.then(getWithResolvedData(this, cur, down.slice(i)));\n        }\n        ctxThis = ctx;\n        ctx = ctx[down[i]];\n        i++;\n      }\n    }\n\n    if (dust.isNonThenableFunction(ctx)) {\n      fn = function() {\n        try {\n          return ctx.apply(ctxThis, arguments);\n        } catch (err) {\n          dust.log(err, ERROR);\n          throw err;\n        }\n      };\n      fn.__dustBody = !!ctx.__dustBody;\n      return fn;\n    } else {\n      if (ctx === undefined) {\n        dust.log('Cannot find reference `{' + down.join('.') + '}` in template `' + this.getTemplateName() + '`', INFO);\n      }\n      return ctx;\n    }\n  };\n\n  Context.prototype.getPath = function(cur, down) {\n    return this._get(cur, down);\n  };\n\n  Context.prototype.push = function(head, idx, len) {\n    if(head === undefined) {\n      dust.log(\"Not pushing an undefined variable onto the context\", INFO);\n      return this;\n    }\n    return this.rebase(new Stack(head, this.stack, idx, len));\n  };\n\n  Context.prototype.pop = function() {\n    var head = this.current();\n    this.stack = this.stack && this.stack.tail;\n    return head;\n  };\n\n  Context.prototype.rebase = function(head) {\n    return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());\n  };\n\n  Context.prototype.clone = function() {\n    var context = this.rebase();\n    context.stack = this.stack;\n    return context;\n  };\n\n  Context.prototype.current = function() {\n    return this.stack && this.stack.head;\n  };\n\n  Context.prototype.getBlock = function(key) {\n    var blocks, len, fn;\n\n    if (typeof key === 'function') {\n      key = key(new Chunk(), this).data.join('');\n    }\n\n    blocks = this.blocks;\n\n    if (!blocks) {\n      dust.log('No blocks for context `' + key + '` in template `' + this.getTemplateName() + '`', DEBUG);\n      return false;\n    }\n\n    len = blocks.length;\n    while (len--) {\n      fn = blocks[len][key];\n      if (fn) {\n        return fn;\n      }\n    }\n\n    dust.log('Malformed template `' + this.getTemplateName() + '` was missing one or more blocks.');\n    return false;\n  };\n\n  Context.prototype.shiftBlocks = function(locals) {\n    var blocks = this.blocks,\n        newBlocks;\n\n    if (locals) {\n      if (!blocks) {\n        newBlocks = [locals];\n      } else {\n        newBlocks = blocks.concat([locals]);\n      }\n      return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());\n    }\n    return this;\n  };\n\n  Context.prototype.resolve = function(body) {\n    var chunk;\n\n    if(typeof body !== 'function') {\n      return body;\n    }\n    chunk = new Chunk().render(body, this);\n    if(chunk instanceof Chunk) {\n      return chunk.data.join(''); // ie7 perf\n    }\n    return chunk;\n  };\n\n  Context.prototype.getTemplateName = function() {\n    return this.templateName;\n  };\n\n  function Stack(head, tail, idx, len) {\n    this.tail = tail;\n    this.isObject = head && typeof head === 'object';\n    this.head = head;\n    this.index = idx;\n    this.of = len;\n  }\n\n  function Stub(callback) {\n    this.head = new Chunk(this);\n    this.callback = callback;\n    this.out = '';\n  }\n\n  Stub.prototype.flush = function() {\n    var chunk = this.head;\n\n    while (chunk) {\n      if (chunk.flushable) {\n        this.out += chunk.data.join(''); //ie7 perf\n      } else if (chunk.error) {\n        this.callback(chunk.error);\n        dust.log('Rendering failed with error `' + chunk.error + '`', ERROR);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.callback(null, this.out);\n  };\n\n  /**\n   * Creates an interface sort of like a Streams2 ReadableStream.\n   */\n  function Stream() {\n    this.head = new Chunk(this);\n  }\n\n  Stream.prototype.flush = function() {\n    var chunk = this.head;\n\n    while(chunk) {\n      if (chunk.flushable) {\n        this.emit('data', chunk.data.join('')); //ie7 perf\n      } else if (chunk.error) {\n        this.emit('error', chunk.error);\n        this.emit('end');\n        dust.log('Streaming failed with error `' + chunk.error + '`', ERROR);\n        this.flush = EMPTY_FUNC;\n        return;\n      } else {\n        return;\n      }\n      chunk = chunk.next;\n      this.head = chunk;\n    }\n    this.emit('end');\n  };\n\n  /**\n   * Executes listeners for `type` by passing data. Note that this is different from a\n   * Node stream, which can pass an arbitrary number of arguments\n   * @return `true` if event had listeners, `false` otherwise\n   */\n  Stream.prototype.emit = function(type, data) {\n    var events = this.events || {},\n        handlers = events[type] || [],\n        i, l;\n\n    if (!handlers.length) {\n      dust.log('Stream broadcasting, but no listeners for `' + type + '`', DEBUG);\n      return false;\n    }\n\n    handlers = handlers.slice(0);\n    for (i = 0, l = handlers.length; i < l; i++) {\n      handlers[i](data);\n    }\n    return true;\n  };\n\n  Stream.prototype.on = function(type, callback) {\n    var events = this.events = this.events || {},\n        handlers = events[type] = events[type] || [];\n\n    if(typeof callback !== 'function') {\n      dust.log('No callback function provided for `' + type + '` event listener', WARN);\n    } else {\n      handlers.push(callback);\n    }\n    return this;\n  };\n\n  /**\n   * Pipes to a WritableStream. Note that backpressure isn't implemented,\n   * so we just write as fast as we can.\n   * @param stream {WritableStream}\n   * @return self\n   */\n  Stream.prototype.pipe = function(stream) {\n    if(typeof stream.write !== 'function' ||\n       typeof stream.end !== 'function') {\n      dust.log('Incompatible stream passed to `pipe`', WARN);\n      return this;\n    }\n\n    var destEnded = false;\n\n    if(typeof stream.emit === 'function') {\n      stream.emit('pipe', this);\n    }\n\n    if(typeof stream.on === 'function') {\n      stream.on('error', function() {\n        destEnded = true;\n      });\n    }\n\n    return this\n    .on('data', function(data) {\n      if(destEnded) {\n        return;\n      }\n      try {\n        stream.write(data, 'utf8');\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    })\n    .on('end', function() {\n      if(destEnded) {\n        return;\n      }\n      try {\n        stream.end();\n        destEnded = true;\n      } catch (err) {\n        dust.log(err, ERROR);\n      }\n    });\n  };\n\n  function Chunk(root, next, taps) {\n    this.root = root;\n    this.next = next;\n    this.data = []; //ie7 perf\n    this.flushable = false;\n    this.taps = taps;\n  }\n\n  Chunk.prototype.write = function(data) {\n    var taps = this.taps;\n\n    if (taps) {\n      data = taps.go(data);\n    }\n    this.data.push(data);\n    return this;\n  };\n\n  Chunk.prototype.end = function(data) {\n    if (data) {\n      this.write(data);\n    }\n    this.flushable = true;\n    this.root.flush();\n    return this;\n  };\n\n  /**\n   * Inserts a new chunk that can be used to asynchronously render or write to it\n   * @param callback {Function} The function that will be called with the new chunk\n   * @returns {Chunk} A copy of this chunk instance in order to further chain function calls on the chunk\n   */\n  Chunk.prototype.map = function(callback) {\n    var cursor = new Chunk(this.root, this.next, this.taps),\n        branch = new Chunk(this.root, cursor, this.taps);\n\n    this.next = branch;\n    this.flushable = true;\n    try {\n      callback(branch);\n    } catch(err) {\n      dust.log(err, ERROR);\n      branch.setError(err);\n    }\n    return cursor;\n  };\n\n  /**\n   * Like Chunk#map but additionally resolves a thenable.  If the thenable succeeds the callback is invoked with\n   * a new chunk that can be used to asynchronously render or write to it, otherwise if the thenable is rejected \n   * then the error body is rendered if available, an error is logged, and the callback is never invoked.\n   * @param {Chunk} The current chunk to insert a new chunk\n   * @param thenable {Thenable} the target thenable to await\n   * @param context {Context} context to use to render the deferred chunk\n   * @param bodies {Object} may optionally contain an \"error\" for when the thenable is rejected\n   * @param callback {Function} The function that will be called with the new chunk\n   * @returns {Chunk} A copy of this chunk instance in order to further chain function calls on the chunk\n   */\n  function mapThenable(chunk, thenable, context, bodies, callback) {\n    return chunk.map(function(asyncChunk) {\n      thenable.then(function(data) {\n        try {\n          callback(asyncChunk, data);\n        } catch (err) {\n          // handle errors the same way Chunk#map would.  This logic is only here since the thenable defers \n          // logic such that the try / catch in Chunk#map would not capture it. \n          dust.log(err, ERROR);\n          asyncChunk.setError(err);\n        }\n      }, function(err) {\n        dust.log('Unhandled promise rejection in `' + context.getTemplateName() + '`', INFO);\n        asyncChunk.renderError(err, context, bodies).end();\n      });\n    });\n  }\n\n  Chunk.prototype.tap = function(tap) {\n    var taps = this.taps;\n\n    if (taps) {\n      this.taps = taps.push(tap);\n    } else {\n      this.taps = new Tap(tap);\n    }\n    return this;\n  };\n\n  Chunk.prototype.untap = function() {\n    this.taps = this.taps.tail;\n    return this;\n  };\n\n  Chunk.prototype.render = function(body, context) {\n    return body(this, context);\n  };\n\n  Chunk.prototype.reference = function(elem, context, auto, filters) {\n    if (dust.isNonThenableFunction(elem)) {\n      elem = elem.apply(context.current(), [this, context, null, {auto: auto, filters: filters}]);\n      if (elem instanceof Chunk) {\n        return elem;\n      } else {\n        return this.reference(elem, context, auto, filters);\n      }\n    }\n    if (dust.isThenable(elem)) {\n      return this.await(elem, context, null, auto, filters);\n    } else if (dust.isStreamable(elem)) {\n      return this.stream(elem, context, null, auto, filters);\n    } else if (!dust.isEmpty(elem)) {\n      return this.write(dust.filter(elem, auto, filters, context));\n    } else {\n      return this;\n    }\n  };\n\n  Chunk.prototype.section = function(elem, context, bodies, params) {\n    var body = bodies.block,\n        skip = bodies['else'],\n        chunk = this,\n        i, len, head;\n\n    if (dust.isNonThenableFunction(elem) && !dust.isTemplateFn(elem)) {\n      try {\n        elem = elem.apply(context.current(), [this, context, bodies, params]);\n      } catch(err) {\n        dust.log(err, ERROR);\n        return this.setError(err);\n      }\n      // Functions that return chunks are assumed to have handled the chunk manually.\n      // Make that chunk the current one and go to the next method in the chain.\n      if (elem instanceof Chunk) {\n        return elem;\n      }\n    }\n\n    if (dust.isEmptyObject(bodies)) {\n      // No bodies to render, and we've already invoked any function that was available in\n      // hopes of returning a Chunk.\n      return chunk;\n    }\n\n    if (!dust.isEmptyObject(params)) {\n      context = context.push(params);\n    }\n\n    /*\n    Dust's default behavior is to enumerate over the array elem, passing each object in the array to the block.\n    When elem resolves to a value or object instead of an array, Dust sets the current context to the value\n    and renders the block one time.\n    */\n    if (dust.isArray(elem)) {\n      if (body) {\n        len = elem.length;\n        if (len > 0) {\n          head = context.stack && context.stack.head || {};\n          head.$len = len;\n          for (i = 0; i < len; i++) {\n            head.$idx = i;\n            chunk = body(chunk, context.push(elem[i], i, len));\n          }\n          head.$idx = undefined;\n          head.$len = undefined;\n          return chunk;\n        } else if (skip) {\n          return skip(this, context);\n        }\n      }\n    } else if (dust.isThenable(elem)) {\n      return this.await(elem, context, bodies);\n    } else if (dust.isStreamable(elem)) {\n      return this.stream(elem, context, bodies);\n    } else if (elem === true) {\n     // true is truthy but does not change context\n      if (body) {\n        return body(this, context);\n      }\n    } else if (elem || elem === 0) {\n       // everything that evaluates to true are truthy ( e.g. Non-empty strings and Empty objects are truthy. )\n       // zero is truthy\n       // for anonymous functions that did not returns a chunk, truthiness is evaluated based on the return value\n      if (body) {\n        return body(this, context.push(elem));\n      }\n     // nonexistent, scalar false value, scalar empty string, null,\n     // undefined are all falsy\n    } else if (skip) {\n      return skip(this, context);\n    }\n    dust.log('Section without corresponding key in template `' + context.getTemplateName() + '`', DEBUG);\n    return this;\n  };\n\n  Chunk.prototype.exists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (dust.isThenable(elem)) {\n      return mapThenable(this, elem, context, bodies, function(chunk, data) {\n        chunk.exists(data, context, bodies).end();\n      });\n    }\n\n    if (!dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n      dust.log('No block for exists check in template `' + context.getTemplateName() + '`', DEBUG);\n    } else if (skip) {\n      return skip(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.notexists = function(elem, context, bodies) {\n    var body = bodies.block,\n        skip = bodies['else'];\n\n    if (dust.isThenable(elem)) {\n      return mapThenable(this, elem, context, bodies, function(chunk, data) {\n        chunk.notexists(data, context, bodies).end();\n      });\n    }\n\n    if (dust.isEmpty(elem)) {\n      if (body) {\n        return body(this, context);\n      }\n      dust.log('No block for not-exists check in template `' + context.getTemplateName() + '`', DEBUG);\n    } else if (skip) {\n      return skip(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.block = function(elem, context, bodies) {\n    var body = elem || bodies.block;\n\n    if (body) {\n      return body(this, context);\n    }\n    return this;\n  };\n\n  Chunk.prototype.partial = function(elem, context, partialContext, params) {\n    var head;\n\n    if(params === undefined) {\n      // Compatibility for < 2.7.0 where `partialContext` did not exist\n      params = partialContext;\n      partialContext = context;\n    }\n\n    if (!dust.isEmptyObject(params)) {\n      partialContext = partialContext.clone();\n      head = partialContext.pop();\n      partialContext = partialContext.push(params)\n                                     .push(head);\n    }\n\n    if (dust.isTemplateFn(elem)) {\n      // The eventual result of evaluating `elem` is a partial name\n      // Load the partial after getting its name and end the async chunk\n      return this.capture(elem, context, function(name, chunk) {\n        load(name, chunk, partialContext).end();\n      });\n    } else {\n      return load(elem, this, partialContext);\n    }\n  };\n\n  Chunk.prototype.helper = function(name, context, bodies, params, auto) {\n    var chunk = this,\n        filters = params.filters,\n        ret;\n\n    // Pre-2.7.1 compat: if auto is undefined, it's an old template. Automatically escape\n    if (auto === undefined) {\n      auto = 'h';\n    }\n\n    // handle invalid helpers, similar to invalid filters\n    if(dust.helpers[name]) {\n      try {\n        ret = dust.helpers[name](chunk, context, bodies, params);\n        if (ret instanceof Chunk) {\n          return ret;\n        }\n        if(typeof filters === 'string') {\n          filters = filters.split('|');\n        }\n        if (!dust.isEmptyObject(bodies)) {\n          return chunk.section(ret, context, bodies, params);\n        }\n        // Helpers act slightly differently from functions in context in that they will act as\n        // a reference if they are self-closing (due to grammar limitations)\n        // In the Chunk.await function we check to make sure bodies is null before acting as a reference\n        return chunk.reference(ret, context, auto, filters);\n      } catch(err) {\n        dust.log('Error in helper `' + name + '`: ' + err.message, ERROR);\n        return chunk.setError(err);\n      }\n    } else {\n      dust.log('Helper `' + name + '` does not exist', WARN);\n      return chunk;\n    }\n  };\n\n  /**\n   * Reserve a chunk to be evaluated once a thenable is resolved or rejected\n   * @param thenable {Thenable} the target thenable to await\n   * @param context {Context} context to use to render the deferred chunk\n   * @param bodies {Object} must contain a \"body\", may contain an \"error\"\n   * @param auto {String} automatically apply this filter if the Thenable is a reference\n   * @param filters {Array} apply these filters if the Thenable is a reference\n   * @return {Chunk}\n   */\n  Chunk.prototype.await = function(thenable, context, bodies, auto, filters) {\n    return mapThenable(this, thenable, context, bodies, function(chunk, data) {\n      if (bodies) {\n        chunk.section(data, context, bodies).end();\n      } else {\n        // Actually a reference. Self-closing sections don't render\n        chunk.reference(data, context, auto, filters).end();\n      }\n    });\n  };\n\n  /**\n   * Render an error body if available\n   * @param err {Error} error that occurred\n   * @param context {Context} context to use to render the error\n   * @param bodies {Object} may optionally contain an \"error\" which will be rendered\n   * @return {Chunk}\n   */\n  Chunk.prototype.renderError = function(err, context, bodies) {\n    var errorBody = bodies && bodies.error;\n    if (errorBody) {\n      return this.render(errorBody, context.push(err));\n    }\n    return this;\n  };\n\n  /**\n   * Reserve a chunk to be evaluated with the contents of a streamable.\n   * Currently an error event will bomb out the stream. Once an error\n   * is received, we push it to an {:error} block if one exists, and log otherwise,\n   * then stop listening to the stream.\n   * @param streamable {Streamable} the target streamable that will emit events\n   * @param context {Context} context to use to render each thunk\n   * @param bodies {Object} must contain a \"body\", may contain an \"error\"\n   * @return {Chunk}\n   */\n  Chunk.prototype.stream = function(stream, context, bodies, auto, filters) {\n    var body = bodies && bodies.block;\n    return this.map(function(chunk) {\n      var ended = false;\n      stream\n        .on('data', function data(thunk) {\n          if(ended) {\n            return;\n          }\n          if(body) {\n            // Fork a new chunk out of the blockstream so that we can flush it independently\n            chunk = chunk.map(function(chunk) {\n              chunk.render(body, context.push(thunk)).end();\n            });\n          } else if(!bodies) {\n            // When actually a reference, don't fork, just write into the master async chunk\n            chunk = chunk.reference(thunk, context, auto, filters);\n          }\n        })\n        .on('error', function error(err) {\n          if(ended) {\n            return;\n          }\n          chunk.renderError(err, context, bodies);\n          dust.log('Unhandled stream error in `' + context.getTemplateName() + '`', INFO);\n          if(!ended) {\n            ended = true;\n            chunk.end();\n          }\n        })\n        .on('end', function end() {\n          if(!ended) {\n            ended = true;\n            chunk.end();\n          }\n        });\n    });\n  };\n\n  Chunk.prototype.capture = function(body, context, callback) {\n    return this.map(function(chunk) {\n      var stub = new Stub(function(err, out) {\n        if (err) {\n          chunk.setError(err);\n        } else {\n          callback(out, chunk);\n        }\n      });\n      body(stub.head, context).end();\n    });\n  };\n\n  Chunk.prototype.setError = function(err) {\n    this.error = err;\n    this.root.flush();\n    return this;\n  };\n\n  // Chunk aliases\n  for(var f in Chunk.prototype) {\n    if(dust._aliases[f]) {\n      Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];\n    }\n  }\n\n  function Tap(head, tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  Tap.prototype.push = function(tap) {\n    return new Tap(tap, this);\n  };\n\n  Tap.prototype.go = function(value) {\n    var tap = this;\n\n    while(tap) {\n      value = tap.head(value);\n      tap = tap.tail;\n    }\n    return value;\n  };\n\n  var HCHARS = /[&<>\"']/,\n      AMP    = /&/g,\n      LT     = /</g,\n      GT     = />/g,\n      QUOT   = /\\\"/g,\n      SQUOT  = /\\'/g;\n\n  dust.escapeHtml = function(s) {\n    if (typeof s === \"string\" || (s && typeof s.toString === \"function\")) {\n      if (typeof s !== \"string\") {\n        s = s.toString();\n      }\n      if (!HCHARS.test(s)) {\n        return s;\n      }\n      return s.replace(AMP,'&amp;').replace(LT,'&lt;').replace(GT,'&gt;').replace(QUOT,'&quot;').replace(SQUOT, '&#39;');\n    }\n    return s;\n  };\n\n  var BS = /\\\\/g,\n      FS = /\\//g,\n      CR = /\\r/g,\n      LS = /\\u2028/g,\n      PS = /\\u2029/g,\n      NL = /\\n/g,\n      LF = /\\f/g,\n      SQ = /'/g,\n      DQ = /\"/g,\n      TB = /\\t/g;\n\n  dust.escapeJs = function(s) {\n    if (typeof s === 'string') {\n      return s\n        .replace(BS, '\\\\\\\\')\n        .replace(FS, '\\\\/')\n        .replace(DQ, '\\\\\"')\n        .replace(SQ, '\\\\\\'')\n        .replace(CR, '\\\\r')\n        .replace(LS, '\\\\u2028')\n        .replace(PS, '\\\\u2029')\n        .replace(NL, '\\\\n')\n        .replace(LF, '\\\\f')\n        .replace(TB, '\\\\t');\n    }\n    return s;\n  };\n\n  dust.escapeJSON = function(o) {\n    if (!JSON) {\n      dust.log('JSON is undefined; could not escape `' + o + '`', WARN);\n      return o;\n    } else {\n      return JSON.stringify(o)\n        .replace(LS, '\\\\u2028')\n        .replace(PS, '\\\\u2029')\n        .replace(LT, '\\\\u003c');\n    }\n  };\n\n  return dust;\n\n}));\n\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define(\"dust.parse\", [\"dust.core\"], function(dust) {\n      return factory(dust).parse;\n    });\n  } else if (typeof exports === 'object') {\n    // in Node, require this file if we want to use the parser as a standalone module\n    module.exports = factory(require('./dust'));\n    // @see server file for parser methods exposed in node\n  } else {\n    // in the browser, store the factory output if we want to use the parser directly\n    factory(root.dust);\n  }\n}(this, function(dust) {\n  var parser = (function() {\n  \"use strict\";\n\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n        parser  = this,\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(p) {\n            var body = [\"body\"].concat(p);\n            return withPosition(body);\n          },\n        peg$c1 = { type: \"other\", description: \"section\" },\n        peg$c2 = function(t, b, e, n) {\n            if( (!n) || (t[1].text !== n.text) ) {\n              error(\"Expected end tag for \"+t[1].text+\" but it was not found.\");\n            }\n            return true;\n          },\n        peg$c3 = function(t, b, e, n) {\n            e.push([\"param\", [\"literal\", \"block\"], b]);\n            t.push(e, [\"filters\"]);\n            return withPosition(t)\n          },\n        peg$c4 = \"/\",\n        peg$c5 = { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n        peg$c6 = function(t) {\n            t.push([\"bodies\"], [\"filters\"]);\n            return withPosition(t)\n          },\n        peg$c7 = /^[#?\\^<+@%]/,\n        peg$c8 = { type: \"class\", value: \"[#?^<+@%]\", description: \"[#?^<+@%]\" },\n        peg$c9 = function(t, n, c, p) { return [t, n, c, p] },\n        peg$c10 = { type: \"other\", description: \"end tag\" },\n        peg$c11 = function(n) { return n },\n        peg$c12 = \":\",\n        peg$c13 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c14 = function(n) {return n},\n        peg$c15 = function(n) { return n ? [\"context\", n] : [\"context\"] },\n        peg$c16 = { type: \"other\", description: \"params\" },\n        peg$c17 = \"=\",\n        peg$c18 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c19 = function(k, v) {return [\"param\", [\"literal\", k], v]},\n        peg$c20 = function(p) { return [\"params\"].concat(p) },\n        peg$c21 = { type: \"other\", description: \"bodies\" },\n        peg$c22 = function(p) { return [\"bodies\"].concat(p) },\n        peg$c23 = { type: \"other\", description: \"reference\" },\n        peg$c24 = function(n, f) { return withPosition([\"reference\", n, f]) },\n        peg$c25 = { type: \"other\", description: \"partial\" },\n        peg$c26 = \">\",\n        peg$c27 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n        peg$c28 = \"+\",\n        peg$c29 = { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n        peg$c30 = function(s, k) {return [\"literal\", k]},\n        peg$c31 = function(s, n, c, p) {\n            var key = (s === \">\") ? \"partial\" : s;\n            return withPosition([key, n, c, p])\n          },\n        peg$c32 = { type: \"other\", description: \"filters\" },\n        peg$c33 = \"|\",\n        peg$c34 = { type: \"literal\", value: \"|\", description: \"\\\"|\\\"\" },\n        peg$c35 = function(f) { return [\"filters\"].concat(f) },\n        peg$c36 = { type: \"other\", description: \"special\" },\n        peg$c37 = \"~\",\n        peg$c38 = { type: \"literal\", value: \"~\", description: \"\\\"~\\\"\" },\n        peg$c39 = function(k) { return withPosition([\"special\", k]) },\n        peg$c40 = { type: \"other\", description: \"identifier\" },\n        peg$c41 = function(p) {\n            var arr = [\"path\"].concat(p);\n            arr.text = p[1].join('.');\n            return arr;\n          },\n        peg$c42 = function(k) {\n            var arr = [\"key\", k];\n            arr.text = k;\n            return arr;\n          },\n        peg$c43 = { type: \"other\", description: \"number\" },\n        peg$c44 = function(n) { return ['literal', n]; },\n        peg$c45 = { type: \"other\", description: \"float\" },\n        peg$c46 = \".\",\n        peg$c47 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n        peg$c48 = function(l, r) { return parseFloat(l + \".\" + r); },\n        peg$c49 = { type: \"other\", description: \"unsigned_integer\" },\n        peg$c50 = /^[0-9]/,\n        peg$c51 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c52 = function(digits) { return makeInteger(digits); },\n        peg$c53 = { type: \"other\", description: \"signed_integer\" },\n        peg$c54 = \"-\",\n        peg$c55 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n        peg$c56 = function(sign, n) { return n * -1; },\n        peg$c57 = { type: \"other\", description: \"integer\" },\n        peg$c58 = { type: \"other\", description: \"path\" },\n        peg$c59 = function(k, d) {\n            d = d[0];\n            if (k && d) {\n              d.unshift(k);\n              return withPosition([false, d])\n            }\n            return withPosition([true, d])\n          },\n        peg$c60 = function(d) {\n            if (d.length > 0) {\n              return withPosition([true, d[0]])\n            }\n            return withPosition([true, []])\n          },\n        peg$c61 = { type: \"other\", description: \"key\" },\n        peg$c62 = /^[a-zA-Z_$]/,\n        peg$c63 = { type: \"class\", value: \"[a-zA-Z_$]\", description: \"[a-zA-Z_$]\" },\n        peg$c64 = /^[0-9a-zA-Z_$\\-]/,\n        peg$c65 = { type: \"class\", value: \"[0-9a-zA-Z_$-]\", description: \"[0-9a-zA-Z_$-]\" },\n        peg$c66 = function(h, t) { return h + t.join('') },\n        peg$c67 = { type: \"other\", description: \"array\" },\n        peg$c68 = function(n) {return n.join('')},\n        peg$c69 = function(a) {return a; },\n        peg$c70 = function(i, nk) { if(nk) { nk.unshift(i); } else {nk = [i] } return nk; },\n        peg$c71 = { type: \"other\", description: \"array_part\" },\n        peg$c72 = function(k) {return k},\n        peg$c73 = function(d, a) { if (a) { return d.concat(a); } else { return d; } },\n        peg$c74 = { type: \"other\", description: \"inline\" },\n        peg$c75 = \"\\\"\",\n        peg$c76 = { type: \"literal\", value: \"\\\"\", description: \"\\\"\\\\\\\"\\\"\" },\n        peg$c77 = function() { return withPosition([\"literal\", \"\"]) },\n        peg$c78 = function(l) { return withPosition([\"literal\", l]) },\n        peg$c79 = function(p) { return withPosition([\"body\"].concat(p)) },\n        peg$c80 = function(l) { return [\"buffer\", l] },\n        peg$c81 = { type: \"other\", description: \"buffer\" },\n        peg$c82 = function(e, w) { return withPosition([\"format\", e, w.join('')]) },\n        peg$c83 = { type: \"any\", description: \"any character\" },\n        peg$c84 = function(c) {return c},\n        peg$c85 = function(b) { return withPosition([\"buffer\", b.join('')]) },\n        peg$c86 = { type: \"other\", description: \"literal\" },\n        peg$c87 = /^[^\"]/,\n        peg$c88 = { type: \"class\", value: \"[^\\\"]\", description: \"[^\\\"]\" },\n        peg$c89 = function(b) { return b.join('') },\n        peg$c90 = \"\\\\\\\"\",\n        peg$c91 = { type: \"literal\", value: \"\\\\\\\"\", description: \"\\\"\\\\\\\\\\\\\\\"\\\"\" },\n        peg$c92 = function() { return '\"' },\n        peg$c93 = { type: \"other\", description: \"raw\" },\n        peg$c94 = \"{`\",\n        peg$c95 = { type: \"literal\", value: \"{`\", description: \"\\\"{`\\\"\" },\n        peg$c96 = \"`}\",\n        peg$c97 = { type: \"literal\", value: \"`}\", description: \"\\\"`}\\\"\" },\n        peg$c98 = function(character) {return character},\n        peg$c99 = function(rawText) { return withPosition([\"raw\", rawText.join('')]) },\n        peg$c100 = { type: \"other\", description: \"comment\" },\n        peg$c101 = \"{!\",\n        peg$c102 = { type: \"literal\", value: \"{!\", description: \"\\\"{!\\\"\" },\n        peg$c103 = \"!}\",\n        peg$c104 = { type: \"literal\", value: \"!}\", description: \"\\\"!}\\\"\" },\n        peg$c105 = function(c) { return withPosition([\"comment\", c.join('')]) },\n        peg$c106 = /^[#?\\^><+%:@\\/~%]/,\n        peg$c107 = { type: \"class\", value: \"[#?^><+%:@/~%]\", description: \"[#?^><+%:@/~%]\" },\n        peg$c108 = \"{\",\n        peg$c109 = { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n        peg$c110 = \"}\",\n        peg$c111 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n        peg$c112 = \"[\",\n        peg$c113 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c114 = \"]\",\n        peg$c115 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c116 = \"\\n\",\n        peg$c117 = { type: \"literal\", value: \"\\n\", description: \"\\\"\\\\n\\\"\" },\n        peg$c118 = \"\\r\\n\",\n        peg$c119 = { type: \"literal\", value: \"\\r\\n\", description: \"\\\"\\\\r\\\\n\\\"\" },\n        peg$c120 = \"\\r\",\n        peg$c121 = { type: \"literal\", value: \"\\r\", description: \"\\\"\\\\r\\\"\" },\n        peg$c122 = \"\\u2028\",\n        peg$c123 = { type: \"literal\", value: \"\\u2028\", description: \"\\\"\\\\u2028\\\"\" },\n        peg$c124 = \"\\u2029\",\n        peg$c125 = { type: \"literal\", value: \"\\u2029\", description: \"\\\"\\\\u2029\\\"\" },\n        peg$c126 = /^[\\t\\x0B\\f \\xA0\\uFEFF]/,\n        peg$c127 = { type: \"class\", value: \"[\\\\t\\\\v\\\\f \\\\u00A0\\\\uFEFF]\", description: \"[\\\\t\\\\v\\\\f \\\\u00A0\\\\uFEFF]\" },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(\n        message,\n        null,\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n          p, ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0;\n\n      s0 = peg$parsebody();\n\n      return s0;\n    }\n\n    function peg$parsebody() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsepart();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsepart();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsepart() {\n      var s0;\n\n      s0 = peg$parseraw();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsecomment();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsesection();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsepartial();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsespecial();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsereference();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsebuffer();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsesection() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsesec_tag_start();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsews();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsews();\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parserd();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsebody();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsebodies();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseend_tag();\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = peg$currPos;\n                  s7 = peg$c2(s1, s4, s5, s6);\n                  if (s7) {\n                    s7 = void 0;\n                  } else {\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c3(s1, s4, s5, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsesec_tag_start();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parsews();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsews();\n          }\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s3 = peg$c4;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c5); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parserd();\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c6(s1);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c1); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsesec_tag_start() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        if (peg$c7.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsews();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsews();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseidentifier();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecontext();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseparams();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c9(s2, s4, s5, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseend_tag() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c4;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c5); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsews();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsews();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseidentifier();\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parsews();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parsews();\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parserd();\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c11(s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c10); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsecontext() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s2 = peg$c12;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c13); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseidentifier();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c14(s3);\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c15(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseparams() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsews();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsekey();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s5 = peg$c17;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsenumber();\n            if (s6 === peg$FAILED) {\n              s6 = peg$parseidentifier();\n              if (s6 === peg$FAILED) {\n                s6 = peg$parseinline();\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              peg$savedPos = s2;\n              s3 = peg$c19(s4, s6);\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = [];\n        s4 = peg$parsews();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsews();\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsekey();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s5 = peg$c17;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsenumber();\n              if (s6 === peg$FAILED) {\n                s6 = peg$parseidentifier();\n                if (s6 === peg$FAILED) {\n                  s6 = peg$parseinline();\n                }\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s2;\n                s3 = peg$c19(s4, s6);\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c20(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c16); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsebodies() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parseld();\n      if (s3 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s4 = peg$c12;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c13); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsekey();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parserd();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsebody();\n              if (s7 !== peg$FAILED) {\n                peg$savedPos = s2;\n                s3 = peg$c19(s5, s7);\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parseld();\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s4 = peg$c12;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c13); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsekey();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parserd();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebody();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s2;\n                  s3 = peg$c19(s5, s7);\n                  s2 = s3;\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c22(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsereference() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseidentifier();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefilters();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parserd();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c24(s2, s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c23); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsepartial() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s2 = peg$c26;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c27); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s2 = peg$c28;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c29); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parsews();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsews();\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            s5 = peg$parsekey();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s4;\n              s5 = peg$c30(s2, s5);\n            }\n            s4 = s5;\n            if (s4 === peg$FAILED) {\n              s4 = peg$parseinline();\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecontext();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseparams();\n                if (s6 !== peg$FAILED) {\n                  s7 = [];\n                  s8 = peg$parsews();\n                  while (s8 !== peg$FAILED) {\n                    s7.push(s8);\n                    s8 = peg$parsews();\n                  }\n                  if (s7 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 47) {\n                      s8 = peg$c4;\n                      peg$currPos++;\n                    } else {\n                      s8 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c5); }\n                    }\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parserd();\n                      if (s9 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c31(s2, s4, s5, s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsefilters() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 124) {\n        s3 = peg$c33;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c34); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsekey();\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c14(s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s3 = peg$c33;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c34); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsekey();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s2;\n            s3 = peg$c14(s4);\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c35(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsespecial() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 126) {\n          s2 = peg$c37;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsekey();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parserd();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c39(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseidentifier() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsepath();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c41(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsekey();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c42(s1);\n        }\n        s0 = s1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c40); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsefloat();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseinteger();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c44(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c43); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsefloat() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseinteger();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c46;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c47); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseunsigned_integer();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c48(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c45); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseunsigned_integer() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c50.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c51); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c50.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c51); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c52(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c49); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsesigned_integer() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s1 = peg$c54;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c55); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseunsigned_integer();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c56(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseinteger() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = peg$parsesigned_integer();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseunsigned_integer();\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c57); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parsekey();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsearray_part();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsearray();\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsearray_part();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsearray();\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c59(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s1 = peg$c46;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c47); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parsearray_part();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parsearray();\n          }\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsearray_part();\n            if (s3 === peg$FAILED) {\n              s3 = peg$parsearray();\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c60(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c58); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsekey() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (peg$c62.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c63); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c64.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c65); }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c64.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c65); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c66(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsearray() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parselb();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = [];\n        if (peg$c50.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c51); }\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c50.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c51); }\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c68(s4);\n        }\n        s3 = s4;\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseidentifier();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parserb();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c69(s3);\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsearray_part();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c70(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c67); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsearray_part() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c46;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c47); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsekey();\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c72(s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s3 = peg$c46;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c47); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsekey();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s2;\n              s3 = peg$c72(s4);\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsearray();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c73(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c71); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseinline() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c75;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c76); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s2 = peg$c75;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c77();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s1 = peg$c75;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseliteral();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 34) {\n              s3 = peg$c75;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c76); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c78(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s1 = peg$c75;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c76); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseinline_part();\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parseinline_part();\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 34) {\n                s3 = peg$c75;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c76); }\n              }\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c79(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseinline_part() {\n      var s0, s1;\n\n      s0 = peg$parsespecial();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsereference();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseliteral();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c80(s1);\n          }\n          s0 = s1;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsebuffer() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = peg$parseeol();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsews();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsews();\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c82(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$currPos;\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsetag();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = void 0;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseraw();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsecomment();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = void 0;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parseeol();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = void 0;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s7 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c83); }\n                }\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s2;\n                  s3 = peg$c84(s7);\n                  s2 = s3;\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$currPos;\n            s3 = peg$currPos;\n            peg$silentFails++;\n            s4 = peg$parsetag();\n            peg$silentFails--;\n            if (s4 === peg$FAILED) {\n              s3 = void 0;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$currPos;\n              peg$silentFails++;\n              s5 = peg$parseraw();\n              peg$silentFails--;\n              if (s5 === peg$FAILED) {\n                s4 = void 0;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = peg$currPos;\n                peg$silentFails++;\n                s6 = peg$parsecomment();\n                peg$silentFails--;\n                if (s6 === peg$FAILED) {\n                  s5 = void 0;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$currPos;\n                  peg$silentFails++;\n                  s7 = peg$parseeol();\n                  peg$silentFails--;\n                  if (s7 === peg$FAILED) {\n                    s6 = void 0;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                  if (s6 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s7 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c83); }\n                    }\n                    if (s7 !== peg$FAILED) {\n                      peg$savedPos = s2;\n                      s3 = peg$c84(s7);\n                      s2 = s3;\n                    } else {\n                      peg$currPos = s2;\n                      s2 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c85(s1);\n        }\n        s0 = s1;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c81); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseliteral() {\n      var s0, s1, s2, s3, s4;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parsetag();\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = void 0;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseesc();\n        if (s4 === peg$FAILED) {\n          if (peg$c87.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c88); }\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c84(s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsetag();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = void 0;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseesc();\n            if (s4 === peg$FAILED) {\n              if (peg$c87.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c88); }\n              }\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s2;\n              s3 = peg$c84(s4);\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c89(s1);\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c86); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseesc() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c90) {\n        s1 = peg$c90;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c91); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c92();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseraw() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c94) {\n        s1 = peg$c94;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c95); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c96) {\n          s5 = peg$c96;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c97); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c83); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c98(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 2) === peg$c96) {\n            s5 = peg$c96;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c97); }\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c83); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c98(s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c96) {\n            s3 = peg$c96;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c97); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c99(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c93); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsecomment() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c101) {\n        s1 = peg$c101;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c102); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c103) {\n          s5 = peg$c103;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c104); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c83); }\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c84(s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 2) === peg$c103) {\n            s5 = peg$c103;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c104); }\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c83); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c84(s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c103) {\n            s3 = peg$c103;\n            peg$currPos += 2;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c104); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c105(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c100); }\n      }\n\n      return s0;\n    }\n\n    function peg$parsetag() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      s1 = peg$parseld();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsews();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsews();\n        }\n        if (s2 !== peg$FAILED) {\n          if (peg$c106.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c107); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parsews();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parsews();\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$currPos;\n              s7 = peg$currPos;\n              peg$silentFails++;\n              s8 = peg$parserd();\n              peg$silentFails--;\n              if (s8 === peg$FAILED) {\n                s7 = void 0;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$currPos;\n                peg$silentFails++;\n                s9 = peg$parseeol();\n                peg$silentFails--;\n                if (s9 === peg$FAILED) {\n                  s8 = void 0;\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n                if (s8 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s9 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c83); }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s7 = [s7, s8, s9];\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$currPos;\n                  s7 = peg$currPos;\n                  peg$silentFails++;\n                  s8 = peg$parserd();\n                  peg$silentFails--;\n                  if (s8 === peg$FAILED) {\n                    s7 = void 0;\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$currPos;\n                    peg$silentFails++;\n                    s9 = peg$parseeol();\n                    peg$silentFails--;\n                    if (s9 === peg$FAILED) {\n                      s8 = void 0;\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                    if (s8 !== peg$FAILED) {\n                      if (input.length > peg$currPos) {\n                        s9 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c83); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s7 = [s7, s8, s9];\n                        s6 = s7;\n                      } else {\n                        peg$currPos = s6;\n                        s6 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                }\n              } else {\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = [];\n                s7 = peg$parsews();\n                while (s7 !== peg$FAILED) {\n                  s6.push(s7);\n                  s7 = peg$parsews();\n                }\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parserd();\n                  if (s7 !== peg$FAILED) {\n                    s1 = [s1, s2, s3, s4, s5, s6, s7];\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsereference();\n      }\n\n      return s0;\n    }\n\n    function peg$parseld() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s0 = peg$c108;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c109); }\n      }\n\n      return s0;\n    }\n\n    function peg$parserd() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s0 = peg$c110;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c111); }\n      }\n\n      return s0;\n    }\n\n    function peg$parselb() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s0 = peg$c112;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c113); }\n      }\n\n      return s0;\n    }\n\n    function peg$parserb() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 93) {\n        s0 = peg$c114;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c115); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseeol() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s0 = peg$c116;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c117); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c118) {\n          s0 = peg$c118;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c119); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 13) {\n            s0 = peg$c120;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c121); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 8232) {\n              s0 = peg$c122;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c123); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 8233) {\n                s0 = peg$c124;\n                peg$currPos++;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c125); }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsews() {\n      var s0;\n\n      if (peg$c126.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c127); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseeol();\n      }\n\n      return s0;\n    }\n\n\n      function makeInteger(arr) {\n        return parseInt(arr.join(''), 10);\n      }\n      function withPosition(arr) {\n        arr.location = location();\n        return arr;\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(\n        null,\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})();\n\n  // expose parser methods\n  dust.parse = parser.parse;\n\n  return parser;\n}));\n\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define(\"dust.compile\", [\"dust.core\", \"dust.parse\"], function(dust, parse) {\n      return factory(parse, dust).compile;\n    });\n  } else if (typeof exports === 'object') {\n    // in Node, require this file if we want to use the compiler as a standalone module\n    module.exports = factory(require('./parser').parse, require('./dust'));\n  } else {\n    // in the browser, store the factory output if we want to use the compiler directly\n    factory(root.dust.parse, root.dust);\n  }\n}(this, function(parse, dust) {\n  var compiler = {},\n      isArray = dust.isArray;\n\n  var escape = (typeof JSON === 'undefined') ?\n                  function(str) { return '\"' + escapeToJsSafeString(str) + '\"';} :\n                  JSON.stringify;\n\n  compiler.compile = function(source, name) {\n    // the name parameter is optional.\n    // this can happen for templates that are rendered immediately (renderSource which calls compileFn) or\n    // for templates that are compiled as a callable (compileFn)\n    //\n    // for the common case (using compile and render) a name is required so that templates will be cached by name and rendered later, by name.\n\n    try {\n      var ast = filterAST(parse(source));\n      return compile(ast, name);\n    } catch (err) {\n      if (!err.location) {\n        throw err;\n      }\n      throw new SyntaxError(err.message + ' [' + name + ':' + err.location.start.line + ':' + err.location.start.column + ']');\n    }\n  };\n\n  function filterAST(ast) {\n    var context = {};\n    return compiler.filterNode(context, ast);\n  }\n\n  compiler.filterNode = function(context, node) {\n    return compiler.optimizers[node[0]](context, node);\n  };\n\n  compiler.optimizers = {\n    body:      compactBuffers,\n    buffer:    noop,\n    special:   convertSpecial,\n    format:    format,\n    reference: visit,\n    '#':       visit,\n    '?':       visit,\n    '^':       visit,\n    '<':       visit,\n    '+':       visit,\n    '@':       visit,\n    '%':       visit,\n    partial:   visit,\n    context:   visit,\n    params:    visit,\n    bodies:    visit,\n    param:     visit,\n    filters:   noop,\n    key:       noop,\n    path:      noop,\n    literal:   noop,\n    raw:       noop,\n    comment:   nullify\n  };\n\n  compiler.pragmas = {\n    esc: function(compiler, context, bodies) {\n      var old = compiler.auto,\n          out;\n      if (!context) {\n        context = 'h';\n      }\n      compiler.auto = (context === 's') ? '' : context;\n      out = compileParts(compiler, bodies.block);\n      compiler.auto = old;\n      return out;\n    }\n  };\n\n  function visit(context, node) {\n    var out = [node[0]],\n        i, len, res;\n    for (i=1, len=node.length; i<len; i++) {\n      res = compiler.filterNode(context, node[i]);\n      if (res) {\n        out.push(res);\n      }\n    }\n    return out;\n  }\n\n  // Compacts consecutive buffer nodes into a single node\n  function compactBuffers(context, node) {\n    var out = [node[0]],\n        memo, i, len, res;\n    for (i=1, len=node.length; i<len; i++) {\n      res = compiler.filterNode(context, node[i]);\n      if (res) {\n        if (res[0] === 'buffer' || res[0] === 'format') {\n          if (memo) {\n            memo[0] = (res[0] === 'buffer') ? 'buffer' : memo[0];\n            memo[1] += res.slice(1).join('');\n          } else {\n            memo = res;\n            out.push(res);\n          }\n        } else {\n          memo = null;\n          out.push(res);\n        }\n      }\n    }\n    return out;\n  }\n\n  var specialChars = {\n    's': ' ',\n    'n': '\\n',\n    'r': '\\r',\n    'lb': '{',\n    'rb': '}'\n  };\n\n  function convertSpecial(context, node) {\n    return ['buffer', specialChars[node[1]], node[2], node[3]];\n  }\n\n  function noop(context, node) {\n    return node;\n  }\n\n  function nullify(){}\n\n  function format(context, node) {\n    if(dust.config.whitespace) {\n      // Format nodes are in the form ['format', eol, whitespace],\n      // which is unlike other nodes in that there are two pieces of content\n      // Join eol and whitespace together to normalize the node format\n      node.splice(1, 2, node.slice(1).join(''));\n      return node;\n    }\n    return null;\n  }\n\n  function compile(ast, name) {\n    var context = {\n      name: name,\n      bodies: [],\n      blocks: {},\n      index: 0,\n      auto: 'h'\n    },\n    escapedName = dust.escapeJs(name),\n    AMDName = name? '\"' + escapedName + '\",' : '',\n    compiled = 'function(dust){',\n    entry = compiler.compileNode(context, ast),\n    iife;\n\n    if(name) {\n      compiled += 'dust.register(\"' + escapedName + '\",' + entry + ');';\n    }\n\n    compiled += compileBlocks(context) +\n                compileBodies(context) +\n                'return ' + entry + '}';\n\n    iife = '(' + compiled + '(dust));';\n\n    if(dust.config.amd) {\n      return 'define(' + AMDName + '[\"dust.core\"],' + compiled + ');';\n    } else if(dust.config.cjs) {\n      return 'module.exports=function(dust){' +\n             'var tmpl=' + iife +\n             'var f=' + loaderFor().toString() + ';' +\n             'f.template=tmpl;return f}';\n    } else {\n      return iife;\n    }\n  }\n\n  function compileBlocks(context) {\n    var out = [],\n        blocks = context.blocks,\n        name;\n\n    for (name in blocks) {\n      if (Object.prototype.hasOwnProperty.call(blocks, name)) {\n        out.push('\"' + name + '\":' + blocks[name]);\n      }\n    }\n    if (out.length) {\n      context.blocks = 'ctx=ctx.shiftBlocks(blocks);';\n      return 'var blocks={' + out.join(',') + '};';\n    } else {\n      context.blocks = '';\n    }\n    return context.blocks;\n  }\n\n  function compileBodies(context) {\n    var out = [],\n        bodies = context.bodies,\n        blx = context.blocks,\n        i, len;\n\n    for (i=0, len=bodies.length; i<len; i++) {\n      out[i] = 'function body_' + i + '(chk,ctx){' +\n          blx + 'return chk' + bodies[i] + ';}body_' + i + '.__dustBody=!0;';\n    }\n    return out.join('');\n  }\n\n  function compileParts(context, body) {\n    var parts = '',\n        i, len;\n    for (i=1, len=body.length; i<len; i++) {\n      parts += compiler.compileNode(context, body[i]);\n    }\n    return parts;\n  }\n\n  compiler.compileNode = function(context, node) {\n    return compiler.nodes[node[0]](context, node);\n  };\n\n  compiler.nodes = {\n    body: function(context, node) {\n      var id = context.index++,\n          name = 'body_' + id;\n      context.bodies[id] = compileParts(context, node);\n      return name;\n    },\n\n    buffer: function(context, node) {\n      return '.w(' + escape(node[1]) + ')';\n    },\n\n    format: function(context, node) {\n      return '.w(' + escape(node[1]) + ')';\n    },\n\n    reference: function(context, node) {\n      return '.f(' + compiler.compileNode(context, node[1]) +\n        ',ctx,' + compiler.compileNode(context, node[2]) + ')';\n    },\n\n    '#': function(context, node) {\n      return compileSection(context, node, 'section');\n    },\n\n    '?': function(context, node) {\n      return compileSection(context, node, 'exists');\n    },\n\n    '^': function(context, node) {\n      return compileSection(context, node, 'notexists');\n    },\n\n    '<': function(context, node) {\n      var bodies = node[4];\n      for (var i=1, len=bodies.length; i<len; i++) {\n        var param = bodies[i],\n            type = param[1][1];\n        if (type === 'block') {\n          context.blocks[node[1].text] = compiler.compileNode(context, param[2]);\n          return '';\n        }\n      }\n      return '';\n    },\n\n    '+': function(context, node) {\n      if (typeof(node[1].text) === 'undefined'  && typeof(node[4]) === 'undefined'){\n        return '.b(ctx.getBlock(' +\n              compiler.compileNode(context, node[1]) +\n              ',chk, ctx),' + compiler.compileNode(context, node[2]) + ', {},' +\n              compiler.compileNode(context, node[3]) +\n              ')';\n      } else {\n        return '.b(ctx.getBlock(' +\n            escape(node[1].text) +\n            '),' + compiler.compileNode(context, node[2]) + ',' +\n            compiler.compileNode(context, node[4]) + ',' +\n            compiler.compileNode(context, node[3]) +\n            ')';\n      }\n    },\n\n    '@': function(context, node) {\n      return '.h(' +\n        escape(node[1].text) +\n        ',' + compiler.compileNode(context, node[2]) + ',' +\n        compiler.compileNode(context, node[4]) + ',' +\n        compiler.compileNode(context, node[3]) + ',' +\n        compiler.compileNode(context, node[5]) +\n        ')';\n    },\n\n    '%': function(context, node) {\n      // TODO: Move these hacks into pragma precompiler\n      var name = node[1][1],\n          rawBodies,\n          bodies,\n          rawParams,\n          params,\n          ctx, b, p, i, len;\n      if (!compiler.pragmas[name]) {\n        return '';\n      }\n\n      rawBodies = node[4];\n      bodies = {};\n      for (i=1, len=rawBodies.length; i<len; i++) {\n        b = rawBodies[i];\n        bodies[b[1][1]] = b[2];\n      }\n\n      rawParams = node[3];\n      params = {};\n      for (i=1, len=rawParams.length; i<len; i++) {\n        p = rawParams[i];\n        params[p[1][1]] = p[2][1];\n      }\n\n      ctx = node[2][1] ? node[2][1].text : null;\n\n      return compiler.pragmas[name](context, ctx, bodies, params);\n    },\n\n    partial: function(context, node) {\n      return '.p(' +\n          compiler.compileNode(context, node[1]) +\n          ',ctx,' + compiler.compileNode(context, node[2]) +\n          ',' + compiler.compileNode(context, node[3]) + ')';\n    },\n\n    context: function(context, node) {\n      if (node[1]) {\n        return 'ctx.rebase(' + compiler.compileNode(context, node[1]) + ')';\n      }\n      return 'ctx';\n    },\n\n    params: function(context, node) {\n      var out = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        out.push(compiler.compileNode(context, node[i]));\n      }\n      if (out.length) {\n        return '{' + out.join(',') + '}';\n      }\n      return '{}';\n    },\n\n    bodies: function(context, node) {\n      var out = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        out.push(compiler.compileNode(context, node[i]));\n      }\n      return '{' + out.join(',') + '}';\n    },\n\n    param: function(context, node) {\n      return compiler.compileNode(context, node[1]) + ':' + compiler.compileNode(context, node[2]);\n    },\n\n    filters: function(context, node) {\n      var list = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        var filter = node[i];\n        list.push('\"' + filter + '\"');\n      }\n      return '\"' + context.auto + '\"' +\n        (list.length ? ',[' + list.join(',') + ']' : '');\n    },\n\n    key: function(context, node) {\n      return 'ctx.get([\"' + node[1] + '\"], false)';\n    },\n\n    path: function(context, node) {\n      var current = node[1],\n          keys = node[2],\n          list = [];\n\n      for (var i=0,len=keys.length; i<len; i++) {\n        if (isArray(keys[i])) {\n          list.push(compiler.compileNode(context, keys[i]));\n        } else {\n          list.push('\"' + keys[i] + '\"');\n        }\n      }\n      return 'ctx.getPath(' + current + ', [' + list.join(',') + '])';\n    },\n\n    literal: function(context, node) {\n      return escape(node[1]);\n    },\n    raw: function(context, node) {\n      return \".w(\" + escape(node[1]) + \")\";\n    }\n  };\n\n  function compileSection(context, node, cmd) {\n    return '.' + (dust._aliases[cmd] || cmd) + '(' +\n      compiler.compileNode(context, node[1]) +\n      ',' + compiler.compileNode(context, node[2]) + ',' +\n      compiler.compileNode(context, node[4]) + ',' +\n      compiler.compileNode(context, node[3]) +\n      ')';\n  }\n\n  var BS = /\\\\/g,\n      DQ = /\"/g,\n      LF = /\\f/g,\n      NL = /\\n/g,\n      CR = /\\r/g,\n      TB = /\\t/g;\n  function escapeToJsSafeString(str) {\n    return str.replace(BS, '\\\\\\\\')\n              .replace(DQ, '\\\\\"')\n              .replace(LF, '\\\\f')\n              .replace(NL, '\\\\n')\n              .replace(CR, '\\\\r')\n              .replace(TB, '\\\\t');\n  }\n\n  function renderSource(source, context, callback) {\n    var tmpl = dust.loadSource(dust.compile(source));\n    return loaderFor(tmpl)(context, callback);\n  }\n\n  function compileFn(source, name) {\n    var tmpl = dust.loadSource(dust.compile(source, name));\n    return loaderFor(tmpl);\n  }\n\n  function loaderFor(tmpl) {\n    return function load(ctx, cb) {\n      var fn = cb ? 'render' : 'stream';\n      return dust[fn](tmpl, ctx, cb);\n    };\n  }\n\n  // expose compiler methods\n  dust.compiler = compiler;\n  dust.compile = dust.compiler.compile;\n  dust.renderSource = renderSource;\n  dust.compileFn = compileFn;\n\n  // DEPRECATED legacy names. Removed in 2.8.0\n  dust.filterNode = compiler.filterNode;\n  dust.optimizers = compiler.optimizers;\n  dust.pragmas = compiler.pragmas;\n  dust.compileNode = compiler.compileNode;\n  dust.nodes = compiler.nodes;\n\n  return compiler;\n\n}));\n\nif (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define([\"require\", \"dust.core\", \"dust.compile\"], function(require, dust) {\n        dust.onLoad = function(name, cb) {\n            require([name], function(tmpl) {\n                cb(null, tmpl);\n            });\n        };\n        return dust;\n    });\n}\n", "/*! dustjs-linkedin - v2.7.2\n* http://dustjs.com/\n* Copyright (c) 2021 Aleksander Williams; Released under the MIT License */\n!function(a,b){\"function\"==typeof define&&define.amd&&define.amd.dust===!0?define(\"dust.core\",[],b):\"object\"==typeof exports?module.exports=b():a.dust=b()}(this,function(){function getTemplate(a,b){if(a)return\"function\"==typeof a&&a.template?a.template:dust.isTemplateFn(a)?a:b!==!1?dust.cache[a]:void 0}function load(a,b,c){if(!a)return b.setError(new Error(\"No template or template name provided to render\"));var d=getTemplate(a,dust.config.cache);return d?d(b,Context.wrap(c,d.templateName)):dust.onLoad?b.map(function(b){function d(a,d){var f;if(a)return b.setError(a);if(f=getTemplate(d,!1)||getTemplate(e,dust.config.cache),!f){if(!dust.compile)return b.setError(new Error(\"Dust compiler not available\"));f=dust.loadSource(dust.compile(d,e))}f(b,Context.wrap(c,f.templateName)).end()}var e=a;3===dust.onLoad.length?dust.onLoad(e,c.options,d):dust.onLoad(e,d)}):b.setError(new Error(\"Template Not Found: \"+a))}function Context(a,b,c,d,e){void 0===a||a instanceof Stack||(a=new Stack(a)),this.stack=a,this.global=b,this.options=c,this.blocks=d,this.templateName=e,this._isContext=!0}function getWithResolvedData(a,b,c){return function(d){return a.push(d)._get(b,c)}}function Stack(a,b,c,d){this.tail=b,this.isObject=a&&\"object\"==typeof a,this.head=a,this.index=c,this.of=d}function Stub(a){this.head=new Chunk(this),this.callback=a,this.out=\"\"}function Stream(){this.head=new Chunk(this)}function Chunk(a,b,c){this.root=a,this.next=b,this.data=[],this.flushable=!1,this.taps=c}function mapThenable(a,b,c,d,e){return a.map(function(a){b.then(function(b){try{e(a,b)}catch(c){dust.log(c,ERROR),a.setError(c)}},function(b){dust.log(\"Unhandled promise rejection in `\"+c.getTemplateName()+\"`\",INFO),a.renderError(b,c,d).end()})})}function Tap(a,b){this.head=a,this.tail=b}var dust={version:\"2.7.2\"},NONE=\"NONE\",ERROR=\"ERROR\",WARN=\"WARN\",INFO=\"INFO\",DEBUG=\"DEBUG\",EMPTY_FUNC=function(){};dust.config={whitespace:!1,amd:!1,cjs:!1,cache:!0},dust._aliases={write:\"w\",end:\"e\",map:\"m\",render:\"r\",reference:\"f\",section:\"s\",exists:\"x\",notexists:\"nx\",block:\"b\",partial:\"p\",helper:\"h\"},function(){var a,b,c={DEBUG:0,INFO:1,WARN:2,ERROR:3,NONE:4};\"undefined\"!=typeof console&&console.log?(a=console.log,b=\"function\"==typeof a?function(){a.apply(console,arguments)}:function(){a(Array.prototype.slice.apply(arguments).join(\" \"))}):b=EMPTY_FUNC,dust.log=function(a,d){d=d||INFO,c[d]>=c[dust.debugLevel]&&(b(\"[DUST:\"+d+\"]\",a),d===ERROR&&dust.debugLevel===DEBUG&&a instanceof Error&&a.stack&&b(\"[DUST:\"+d+\"]\",a.stack))},dust.debugLevel=NONE,\"undefined\"!=typeof process&&process.env&&/\\bdust\\b/.test(process.env.DEBUG)&&(dust.debugLevel=DEBUG)}(),dust.helpers={},dust.cache={},dust.register=function(a,b){a&&(b.templateName=a,dust.config.cache!==!1&&(dust.cache[a]=b))},dust.render=function(a,b,c){var d=new Stub(c).head;try{load(a,d,b).end()}catch(e){d.setError(e)}},dust.stream=function(a,b){var c=new Stream,d=c.head;return dust.nextTick(function(){try{load(a,d,b).end()}catch(c){d.setError(c)}}),c},dust.loadSource=function(source){return eval(source)},Array.isArray?dust.isArray=Array.isArray:dust.isArray=function(a){return\"[object Array]\"===Object.prototype.toString.call(a)},dust.nextTick=function(){return function(a){setTimeout(a,0)}}(),dust.isEmpty=function(a){return 0!==a&&(!(!dust.isArray(a)||a.length)||!a)},dust.isEmptyObject=function(a){var b;if(null===a)return!1;if(void 0===a)return!1;if(a.length>0)return!1;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b))return!1;return!0},dust.isTemplateFn=function(a){return\"function\"==typeof a&&a.__dustBody},dust.isThenable=function(a){return a&&(\"object\"==typeof a||\"function\"==typeof a)&&\"function\"==typeof a.then},dust.isNonThenableFunction=function(a){return\"function\"==typeof a&&!dust.isThenable(a)},dust.isStreamable=function(a){return a&&\"function\"==typeof a.on&&\"function\"==typeof a.pipe},dust.filter=function(a,b,c,d){var e,f,g,h;if(c)for(e=0,f=c.length;e<f;e++)g=c[e],g.length&&(h=dust.filters[g],\"s\"===g?b=null:\"function\"==typeof h?a=h(a,d):dust.log(\"Invalid filter `\"+g+\"`\",WARN));return b&&(a=dust.filters[b](a,d)),a},dust.filters={h:function(a){return dust.escapeHtml(a)},j:function(a){return dust.escapeJs(a)},u:encodeURI,uc:encodeURIComponent,js:function(a){return dust.escapeJSON(a)},jp:function(a){return JSON?JSON.parse(a):(dust.log(\"JSON is undefined; could not parse `\"+a+\"`\",WARN),a)}},dust.makeBase=dust.context=function(a,b){return new Context((void 0),a,b)},dust.isContext=function(a){return\"object\"==typeof a&&a._isContext===!0},Context.wrap=function(a,b){return dust.isContext(a)?(a.templateName=b,a):new Context(a,{},{},null,b)},Context.prototype.get=function(a,b){return\"string\"==typeof a&&(\".\"===a[0]&&(b=!0,a=a.substr(1)),a=a.split(\".\")),this._get(b,a)},Context.prototype._get=function(a,b){var c,d,e,f,g,h=this.stack||{},i=1;if(d=b[0],e=b.length,a&&0===e)f=h,h=h.head;else{if(a)h&&(h=h.head?h.head[d]:void 0);else{for(;h&&(!h.isObject||(f=h.head,c=h.head[d],void 0===c));)h=h.tail;h=void 0!==c?c:this.global&&this.global[d]}for(;h&&i<e;){if(dust.isThenable(h))return h.then(getWithResolvedData(this,a,b.slice(i)));f=h,h=h[b[i]],i++}}return dust.isNonThenableFunction(h)?(g=function(){try{return h.apply(f,arguments)}catch(a){throw dust.log(a,ERROR),a}},g.__dustBody=!!h.__dustBody,g):(void 0===h&&dust.log(\"Cannot find reference `{\"+b.join(\".\")+\"}` in template `\"+this.getTemplateName()+\"`\",INFO),h)},Context.prototype.getPath=function(a,b){return this._get(a,b)},Context.prototype.push=function(a,b,c){return void 0===a?(dust.log(\"Not pushing an undefined variable onto the context\",INFO),this):this.rebase(new Stack(a,this.stack,b,c))},Context.prototype.pop=function(){var a=this.current();return this.stack=this.stack&&this.stack.tail,a},Context.prototype.rebase=function(a){return new Context(a,this.global,this.options,this.blocks,this.getTemplateName())},Context.prototype.clone=function(){var a=this.rebase();return a.stack=this.stack,a},Context.prototype.current=function(){return this.stack&&this.stack.head},Context.prototype.getBlock=function(a){var b,c,d;if(\"function\"==typeof a&&(a=a(new Chunk,this).data.join(\"\")),b=this.blocks,!b)return dust.log(\"No blocks for context `\"+a+\"` in template `\"+this.getTemplateName()+\"`\",DEBUG),!1;for(c=b.length;c--;)if(d=b[c][a])return d;return dust.log(\"Malformed template `\"+this.getTemplateName()+\"` was missing one or more blocks.\"),!1},Context.prototype.shiftBlocks=function(a){var b,c=this.blocks;return a?(b=c?c.concat([a]):[a],new Context(this.stack,this.global,this.options,b,this.getTemplateName())):this},Context.prototype.resolve=function(a){var b;return\"function\"!=typeof a?a:(b=(new Chunk).render(a,this),b instanceof Chunk?b.data.join(\"\"):b)},Context.prototype.getTemplateName=function(){return this.templateName},Stub.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.callback(a.error),dust.log(\"Rendering failed with error `\"+a.error+\"`\",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.out+=a.data.join(\"\"),a=a.next,this.head=a}this.callback(null,this.out)},Stream.prototype.flush=function(){for(var a=this.head;a;){if(!a.flushable)return a.error?(this.emit(\"error\",a.error),this.emit(\"end\"),dust.log(\"Streaming failed with error `\"+a.error+\"`\",ERROR),void(this.flush=EMPTY_FUNC)):void 0;this.emit(\"data\",a.data.join(\"\")),a=a.next,this.head=a}this.emit(\"end\")},Stream.prototype.emit=function(a,b){var c,d,e=this.events||{},f=e[a]||[];if(!f.length)return dust.log(\"Stream broadcasting, but no listeners for `\"+a+\"`\",DEBUG),!1;for(f=f.slice(0),c=0,d=f.length;c<d;c++)f[c](b);return!0},Stream.prototype.on=function(a,b){var c=this.events=this.events||{},d=c[a]=c[a]||[];return\"function\"!=typeof b?dust.log(\"No callback function provided for `\"+a+\"` event listener\",WARN):d.push(b),this},Stream.prototype.pipe=function(a){if(\"function\"!=typeof a.write||\"function\"!=typeof a.end)return dust.log(\"Incompatible stream passed to `pipe`\",WARN),this;var b=!1;return\"function\"==typeof a.emit&&a.emit(\"pipe\",this),\"function\"==typeof a.on&&a.on(\"error\",function(){b=!0}),this.on(\"data\",function(c){if(!b)try{a.write(c,\"utf8\")}catch(d){dust.log(d,ERROR)}}).on(\"end\",function(){if(!b)try{a.end(),b=!0}catch(c){dust.log(c,ERROR)}})},Chunk.prototype.write=function(a){var b=this.taps;return b&&(a=b.go(a)),this.data.push(a),this},Chunk.prototype.end=function(a){return a&&this.write(a),this.flushable=!0,this.root.flush(),this},Chunk.prototype.map=function(a){var b=new Chunk(this.root,this.next,this.taps),c=new Chunk(this.root,b,this.taps);this.next=c,this.flushable=!0;try{a(c)}catch(d){dust.log(d,ERROR),c.setError(d)}return b},Chunk.prototype.tap=function(a){var b=this.taps;return b?this.taps=b.push(a):this.taps=new Tap(a),this},Chunk.prototype.untap=function(){return this.taps=this.taps.tail,this},Chunk.prototype.render=function(a,b){return a(this,b)},Chunk.prototype.reference=function(a,b,c,d){return dust.isNonThenableFunction(a)?(a=a.apply(b.current(),[this,b,null,{auto:c,filters:d}]),a instanceof Chunk?a:this.reference(a,b,c,d)):dust.isThenable(a)?this.await(a,b,null,c,d):dust.isStreamable(a)?this.stream(a,b,null,c,d):dust.isEmpty(a)?this:this.write(dust.filter(a,c,d,b))},Chunk.prototype.section=function(a,b,c,d){var e,f,g,h=c.block,i=c[\"else\"],j=this;if(dust.isNonThenableFunction(a)&&!dust.isTemplateFn(a)){try{a=a.apply(b.current(),[this,b,c,d])}catch(k){return dust.log(k,ERROR),this.setError(k)}if(a instanceof Chunk)return a}if(dust.isEmptyObject(c))return j;if(dust.isEmptyObject(d)||(b=b.push(d)),dust.isArray(a)){if(h){if(f=a.length,f>0){for(g=b.stack&&b.stack.head||{},g.$len=f,e=0;e<f;e++)g.$idx=e,j=h(j,b.push(a[e],e,f));return g.$idx=void 0,g.$len=void 0,j}if(i)return i(this,b)}}else{if(dust.isThenable(a))return this.await(a,b,c);if(dust.isStreamable(a))return this.stream(a,b,c);if(a===!0){if(h)return h(this,b)}else if(a||0===a){if(h)return h(this,b.push(a))}else if(i)return i(this,b)}return dust.log(\"Section without corresponding key in template `\"+b.getTemplateName()+\"`\",DEBUG),this},Chunk.prototype.exists=function(a,b,c){var d=c.block,e=c[\"else\"];if(dust.isThenable(a))return mapThenable(this,a,b,c,function(a,d){a.exists(d,b,c).end()});if(dust.isEmpty(a)){if(e)return e(this,b)}else{if(d)return d(this,b);dust.log(\"No block for exists check in template `\"+b.getTemplateName()+\"`\",DEBUG)}return this},Chunk.prototype.notexists=function(a,b,c){var d=c.block,e=c[\"else\"];if(dust.isThenable(a))return mapThenable(this,a,b,c,function(a,d){a.notexists(d,b,c).end()});if(dust.isEmpty(a)){if(d)return d(this,b);dust.log(\"No block for not-exists check in template `\"+b.getTemplateName()+\"`\",DEBUG)}else if(e)return e(this,b);return this},Chunk.prototype.block=function(a,b,c){var d=a||c.block;return d?d(this,b):this},Chunk.prototype.partial=function(a,b,c,d){var e;return void 0===d&&(d=c,c=b),dust.isEmptyObject(d)||(c=c.clone(),e=c.pop(),c=c.push(d).push(e)),dust.isTemplateFn(a)?this.capture(a,b,function(a,b){load(a,b,c).end()}):load(a,this,c)},Chunk.prototype.helper=function(a,b,c,d,e){var f,g=this,h=d.filters;if(void 0===e&&(e=\"h\"),!dust.helpers[a])return dust.log(\"Helper `\"+a+\"` does not exist\",WARN),g;try{return f=dust.helpers[a](g,b,c,d),f instanceof Chunk?f:(\"string\"==typeof h&&(h=h.split(\"|\")),dust.isEmptyObject(c)?g.reference(f,b,e,h):g.section(f,b,c,d))}catch(i){return dust.log(\"Error in helper `\"+a+\"`: \"+i.message,ERROR),g.setError(i)}},Chunk.prototype.await=function(a,b,c,d,e){return mapThenable(this,a,b,c,function(a,f){c?a.section(f,b,c).end():a.reference(f,b,d,e).end()})},Chunk.prototype.renderError=function(a,b,c){var d=c&&c.error;return d?this.render(d,b.push(a)):this},Chunk.prototype.stream=function(a,b,c,d,e){var f=c&&c.block;return this.map(function(g){var h=!1;a.on(\"data\",function(a){h||(f?g=g.map(function(c){c.render(f,b.push(a)).end()}):c||(g=g.reference(a,b,d,e)))}).on(\"error\",function(a){h||(g.renderError(a,b,c),dust.log(\"Unhandled stream error in `\"+b.getTemplateName()+\"`\",INFO),h||(h=!0,g.end()))}).on(\"end\",function(){h||(h=!0,g.end())})})},Chunk.prototype.capture=function(a,b,c){return this.map(function(d){var e=new Stub(function(a,b){a?d.setError(a):c(b,d)});a(e.head,b).end()})},Chunk.prototype.setError=function(a){return this.error=a,this.root.flush(),this};for(var f in Chunk.prototype)dust._aliases[f]&&(Chunk.prototype[dust._aliases[f]]=Chunk.prototype[f]);Tap.prototype.push=function(a){return new Tap(a,this)},Tap.prototype.go=function(a){for(var b=this;b;)a=b.head(a),b=b.tail;return a};var HCHARS=/[&<>\"']/,AMP=/&/g,LT=/</g,GT=/>/g,QUOT=/\\\"/g,SQUOT=/\\'/g;dust.escapeHtml=function(a){return\"string\"==typeof a||a&&\"function\"==typeof a.toString?(\"string\"!=typeof a&&(a=a.toString()),HCHARS.test(a)?a.replace(AMP,\"&amp;\").replace(LT,\"&lt;\").replace(GT,\"&gt;\").replace(QUOT,\"&quot;\").replace(SQUOT,\"&#39;\"):a):a};var BS=/\\\\/g,FS=/\\//g,CR=/\\r/g,LS=/\\u2028/g,PS=/\\u2029/g,NL=/\\n/g,LF=/\\f/g,SQ=/'/g,DQ=/\"/g,TB=/\\t/g;return dust.escapeJs=function(a){return\"string\"==typeof a?a.replace(BS,\"\\\\\\\\\").replace(FS,\"\\\\/\").replace(DQ,'\\\\\"').replace(SQ,\"\\\\'\").replace(CR,\"\\\\r\").replace(LS,\"\\\\u2028\").replace(PS,\"\\\\u2029\").replace(NL,\"\\\\n\").replace(LF,\"\\\\f\").replace(TB,\"\\\\t\"):a},dust.escapeJSON=function(a){return JSON?JSON.stringify(a).replace(LS,\"\\\\u2028\").replace(PS,\"\\\\u2029\").replace(LT,\"\\\\u003c\"):(dust.log(\"JSON is undefined; could not escape `\"+a+\"`\",WARN),a)},dust}),function(a,b){\"function\"==typeof define&&define.amd&&define.amd.dust===!0?define(\"dust.parse\",[\"dust.core\"],function(dust){return b(dust).parse}):\"object\"==typeof exports?module.exports=b(require(\"./dust\")):b(a.dust)}(this,function(dust){var a=function(){\"use strict\";function a(a,b){function c(){this.constructor=a}c.prototype=b.prototype,a.prototype=new c}function b(a,c,d,e){this.message=a,this.expected=c,this.found=d,this.location=e,this.name=\"SyntaxError\",\"function\"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,b)}function c(a){function c(){return f(tc,sc)}function d(b){throw h(b,null,a.substring(tc,sc),f(tc,sc))}function e(b){var c,d,e=uc[b];if(e)return e;for(c=b-1;!uc[c];)c--;for(e=uc[c],e={line:e.line,column:e.column,seenCR:e.seenCR};c<b;)d=a.charAt(c),\"\\n\"===d?(e.seenCR||e.line++,e.column=1,e.seenCR=!1):\"\\r\"===d||\"\\u2028\"===d||\"\\u2029\"===d?(e.line++,e.column=1,e.seenCR=!0):(e.column++,e.seenCR=!1),c++;return uc[b]=e,e}function f(a,b){var c=e(a),d=e(b);return{start:{offset:a,line:c.line,column:c.column},end:{offset:b,line:d.line,column:d.column}}}function g(a){sc<vc||(sc>vc&&(vc=sc,wc=[]),wc.push(a))}function h(a,c,d,e){function f(a){var b=1;for(a.sort(function(a,b){return a.description<b.description?-1:a.description>b.description?1:0});b<a.length;)a[b-1]===a[b]?a.splice(b,1):b++}function g(a,b){function c(a){function b(a){return a.charCodeAt(0).toString(16).toUpperCase()}return a.replace(/\\\\/g,\"\\\\\\\\\").replace(/\"/g,'\\\\\"').replace(/\\x08/g,\"\\\\b\").replace(/\\t/g,\"\\\\t\").replace(/\\n/g,\"\\\\n\").replace(/\\f/g,\"\\\\f\").replace(/\\r/g,\"\\\\r\").replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g,function(a){return\"\\\\x0\"+b(a)}).replace(/[\\x10-\\x1F\\x80-\\xFF]/g,function(a){return\"\\\\x\"+b(a)}).replace(/[\\u0100-\\u0FFF]/g,function(a){return\"\\\\u0\"+b(a)}).replace(/[\\u1000-\\uFFFF]/g,function(a){return\"\\\\u\"+b(a)})}var d,e,f,g=new Array(a.length);for(f=0;f<a.length;f++)g[f]=a[f].description;return d=a.length>1?g.slice(0,-1).join(\", \")+\" or \"+g[a.length-1]:g[0],e=b?'\"'+c(b)+'\"':\"end of input\",\"Expected \"+d+\" but \"+e+\" found.\"}return null!==c&&f(c),new b(null!==a?a:g(c,d),c,d,e)}function i(){var a;return a=j()}function j(){var a,b,c;for(a=sc,b=[],c=k();c!==X;)b.push(c),c=k();return b!==X&&(tc=a,b=$(b)),a=b}function k(){var a;return a=K(),a===X&&(a=L(),a===X&&(a=l(),a===X&&(a=s(),a===X&&(a=u(),a===X&&(a=r(),a===X&&(a=H())))))),a}function l(){var b,c,d,e,f,h,i,k;if(xc++,b=sc,c=m(),c!==X){for(d=[],e=S();e!==X;)d.push(e),e=S();d!==X?(e=O(),e!==X?(f=j(),f!==X?(h=q(),h!==X?(i=n(),i===X&&(i=null),i!==X?(tc=sc,k=aa(c,f,h,i),k=k?void 0:X,k!==X?(tc=b,c=ba(c,f,h,i),b=c):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X)}else sc=b,b=X;if(b===X)if(b=sc,c=m(),c!==X){for(d=[],e=S();e!==X;)d.push(e),e=S();d!==X?(47===a.charCodeAt(sc)?(e=ca,sc++):(e=X,0===xc&&g(da)),e!==X?(f=O(),f!==X?(tc=b,c=ea(c),b=c):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X)}else sc=b,b=X;return xc--,b===X&&(c=X,0===xc&&g(_)),b}function m(){var b,c,d,e,f,h,i;if(b=sc,c=N(),c!==X)if(fa.test(a.charAt(sc))?(d=a.charAt(sc),sc++):(d=X,0===xc&&g(ga)),d!==X){for(e=[],f=S();f!==X;)e.push(f),f=S();e!==X?(f=v(),f!==X?(h=o(),h!==X?(i=p(),i!==X?(tc=b,c=ha(d,f,h,i),b=c):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X)}else sc=b,b=X;else sc=b,b=X;return b}function n(){var b,c,d,e,f,h,i;if(xc++,b=sc,c=N(),c!==X)if(47===a.charCodeAt(sc)?(d=ca,sc++):(d=X,0===xc&&g(da)),d!==X){for(e=[],f=S();f!==X;)e.push(f),f=S();if(e!==X)if(f=v(),f!==X){for(h=[],i=S();i!==X;)h.push(i),i=S();h!==X?(i=O(),i!==X?(tc=b,c=ja(f),b=c):(sc=b,b=X)):(sc=b,b=X)}else sc=b,b=X;else sc=b,b=X}else sc=b,b=X;else sc=b,b=X;return xc--,b===X&&(c=X,0===xc&&g(ia)),b}function o(){var b,c,d,e;return b=sc,c=sc,58===a.charCodeAt(sc)?(d=ka,sc++):(d=X,0===xc&&g(la)),d!==X?(e=v(),e!==X?(tc=c,d=ma(e),c=d):(sc=c,c=X)):(sc=c,c=X),c===X&&(c=null),c!==X&&(tc=b,c=na(c)),b=c}function p(){var b,c,d,e,f,h,i;if(xc++,b=sc,c=[],d=sc,e=[],f=S(),f!==X)for(;f!==X;)e.push(f),f=S();else e=X;for(e!==X?(f=C(),f!==X?(61===a.charCodeAt(sc)?(h=pa,sc++):(h=X,0===xc&&g(qa)),h!==X?(i=w(),i===X&&(i=v(),i===X&&(i=F())),i!==X?(tc=d,e=ra(f,i),d=e):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X);d!==X;){if(c.push(d),d=sc,e=[],f=S(),f!==X)for(;f!==X;)e.push(f),f=S();else e=X;e!==X?(f=C(),f!==X?(61===a.charCodeAt(sc)?(h=pa,sc++):(h=X,0===xc&&g(qa)),h!==X?(i=w(),i===X&&(i=v(),i===X&&(i=F())),i!==X?(tc=d,e=ra(f,i),d=e):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)}return c!==X&&(tc=b,c=sa(c)),b=c,xc--,b===X&&(c=X,0===xc&&g(oa)),b}function q(){var b,c,d,e,f,h,i,k;for(xc++,b=sc,c=[],d=sc,e=N(),e!==X?(58===a.charCodeAt(sc)?(f=ka,sc++):(f=X,0===xc&&g(la)),f!==X?(h=C(),h!==X?(i=O(),i!==X?(k=j(),k!==X?(tc=d,e=ra(h,k),d=e):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X);d!==X;)c.push(d),d=sc,e=N(),e!==X?(58===a.charCodeAt(sc)?(f=ka,sc++):(f=X,0===xc&&g(la)),f!==X?(h=C(),h!==X?(i=O(),i!==X?(k=j(),k!==X?(tc=d,e=ra(h,k),d=e):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X);return c!==X&&(tc=b,c=ua(c)),b=c,xc--,b===X&&(c=X,0===xc&&g(ta)),b}function r(){var a,b,c,d,e;return xc++,a=sc,b=N(),b!==X?(c=v(),c!==X?(d=t(),d!==X?(e=O(),e!==X?(tc=a,b=wa(c,d),a=b):(sc=a,a=X)):(sc=a,a=X)):(sc=a,a=X)):(sc=a,a=X),xc--,a===X&&(b=X,0===xc&&g(va)),a}function s(){var b,c,d,e,f,h,i,j,k,l;if(xc++,b=sc,c=N(),c!==X)if(62===a.charCodeAt(sc)?(d=ya,sc++):(d=X,0===xc&&g(za)),d===X&&(43===a.charCodeAt(sc)?(d=Aa,sc++):(d=X,0===xc&&g(Ba))),d!==X){for(e=[],f=S();f!==X;)e.push(f),f=S();if(e!==X)if(f=sc,h=C(),h!==X&&(tc=f,h=Ca(d,h)),f=h,f===X&&(f=F()),f!==X)if(h=o(),h!==X)if(i=p(),i!==X){for(j=[],k=S();k!==X;)j.push(k),k=S();j!==X?(47===a.charCodeAt(sc)?(k=ca,sc++):(k=X,0===xc&&g(da)),k!==X?(l=O(),l!==X?(tc=b,c=Da(d,f,h,i),b=c):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X)}else sc=b,b=X;else sc=b,b=X;else sc=b,b=X;else sc=b,b=X}else sc=b,b=X;else sc=b,b=X;return xc--,b===X&&(c=X,0===xc&&g(xa)),b}function t(){var b,c,d,e,f;for(xc++,b=sc,c=[],d=sc,124===a.charCodeAt(sc)?(e=Fa,sc++):(e=X,0===xc&&g(Ga)),e!==X?(f=C(),f!==X?(tc=d,e=ma(f),d=e):(sc=d,d=X)):(sc=d,d=X);d!==X;)c.push(d),d=sc,124===a.charCodeAt(sc)?(e=Fa,sc++):(e=X,0===xc&&g(Ga)),e!==X?(f=C(),f!==X?(tc=d,e=ma(f),d=e):(sc=d,d=X)):(sc=d,d=X);return c!==X&&(tc=b,c=Ha(c)),b=c,xc--,b===X&&(c=X,0===xc&&g(Ea)),b}function u(){var b,c,d,e,f;return xc++,b=sc,c=N(),c!==X?(126===a.charCodeAt(sc)?(d=Ja,sc++):(d=X,0===xc&&g(Ka)),d!==X?(e=C(),e!==X?(f=O(),f!==X?(tc=b,c=La(e),b=c):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X),xc--,b===X&&(c=X,0===xc&&g(Ia)),b}function v(){var a,b;return xc++,a=sc,b=B(),b!==X&&(tc=a,b=Na(b)),a=b,a===X&&(a=sc,b=C(),b!==X&&(tc=a,b=Oa(b)),a=b),xc--,a===X&&(b=X,0===xc&&g(Ma)),a}function w(){var a,b;return xc++,a=sc,b=x(),b===X&&(b=A()),b!==X&&(tc=a,b=Qa(b)),a=b,xc--,a===X&&(b=X,0===xc&&g(Pa)),a}function x(){var b,c,d,e;return xc++,b=sc,c=A(),c!==X?(46===a.charCodeAt(sc)?(d=Sa,sc++):(d=X,0===xc&&g(Ta)),d!==X?(e=y(),e!==X?(tc=b,c=Ua(c,e),b=c):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X),xc--,b===X&&(c=X,0===xc&&g(Ra)),b}function y(){var b,c,d;if(xc++,b=sc,c=[],Wa.test(a.charAt(sc))?(d=a.charAt(sc),sc++):(d=X,0===xc&&g(Xa)),d!==X)for(;d!==X;)c.push(d),Wa.test(a.charAt(sc))?(d=a.charAt(sc),sc++):(d=X,0===xc&&g(Xa));else c=X;return c!==X&&(tc=b,c=Ya(c)),b=c,xc--,b===X&&(c=X,0===xc&&g(Va)),b}function z(){var b,c,d;return xc++,b=sc,45===a.charCodeAt(sc)?(c=$a,sc++):(c=X,0===xc&&g(_a)),c!==X?(d=y(),d!==X?(tc=b,c=ab(c,d),b=c):(sc=b,b=X)):(sc=b,b=X),xc--,b===X&&(c=X,0===xc&&g(Za)),b}function A(){var a,b;return xc++,a=z(),a===X&&(a=y()),xc--,a===X&&(b=X,0===xc&&g(bb)),a}function B(){var b,c,d,e;if(xc++,b=sc,c=C(),c===X&&(c=null),c!==X){if(d=[],e=E(),e===X&&(e=D()),e!==X)for(;e!==X;)d.push(e),e=E(),e===X&&(e=D());else d=X;d!==X?(tc=b,c=db(c,d),b=c):(sc=b,b=X)}else sc=b,b=X;if(b===X)if(b=sc,46===a.charCodeAt(sc)?(c=Sa,sc++):(c=X,0===xc&&g(Ta)),c!==X){for(d=[],e=E(),e===X&&(e=D());e!==X;)d.push(e),e=E(),e===X&&(e=D());d!==X?(tc=b,c=eb(d),b=c):(sc=b,b=X)}else sc=b,b=X;return xc--,b===X&&(c=X,0===xc&&g(cb)),b}function C(){var b,c,d,e;if(xc++,b=sc,gb.test(a.charAt(sc))?(c=a.charAt(sc),sc++):(c=X,0===xc&&g(hb)),c!==X){for(d=[],ib.test(a.charAt(sc))?(e=a.charAt(sc),sc++):(e=X,0===xc&&g(jb));e!==X;)d.push(e),ib.test(a.charAt(sc))?(e=a.charAt(sc),sc++):(e=X,0===xc&&g(jb));d!==X?(tc=b,c=kb(c,d),b=c):(sc=b,b=X)}else sc=b,b=X;return xc--,b===X&&(c=X,0===xc&&g(fb)),b}function D(){var b,c,d,e,f,h;if(xc++,b=sc,c=sc,d=P(),d!==X){if(e=sc,f=[],Wa.test(a.charAt(sc))?(h=a.charAt(sc),sc++):(h=X,0===xc&&g(Xa)),h!==X)for(;h!==X;)f.push(h),Wa.test(a.charAt(sc))?(h=a.charAt(sc),sc++):(h=X,0===xc&&g(Xa));else f=X;f!==X&&(tc=e,f=mb(f)),e=f,e===X&&(e=v()),e!==X?(f=Q(),f!==X?(tc=c,d=nb(e),c=d):(sc=c,c=X)):(sc=c,c=X)}else sc=c,c=X;return c!==X?(d=E(),d===X&&(d=null),d!==X?(tc=b,c=ob(c,d),b=c):(sc=b,b=X)):(sc=b,b=X),xc--,b===X&&(c=X,0===xc&&g(lb)),b}function E(){var b,c,d,e,f;if(xc++,b=sc,c=[],d=sc,46===a.charCodeAt(sc)?(e=Sa,sc++):(e=X,0===xc&&g(Ta)),e!==X?(f=C(),f!==X?(tc=d,e=qb(f),d=e):(sc=d,d=X)):(sc=d,d=X),d!==X)for(;d!==X;)c.push(d),d=sc,46===a.charCodeAt(sc)?(e=Sa,sc++):(e=X,0===xc&&g(Ta)),e!==X?(f=C(),f!==X?(tc=d,e=qb(f),d=e):(sc=d,d=X)):(sc=d,d=X);else c=X;return c!==X?(d=D(),d===X&&(d=null),d!==X?(tc=b,c=rb(c,d),b=c):(sc=b,b=X)):(sc=b,b=X),xc--,b===X&&(c=X,0===xc&&g(pb)),b}function F(){var b,c,d,e;if(xc++,b=sc,34===a.charCodeAt(sc)?(c=tb,sc++):(c=X,0===xc&&g(ub)),c!==X?(34===a.charCodeAt(sc)?(d=tb,sc++):(d=X,0===xc&&g(ub)),d!==X?(tc=b,c=vb(),b=c):(sc=b,b=X)):(sc=b,b=X),b===X&&(b=sc,34===a.charCodeAt(sc)?(c=tb,sc++):(c=X,0===xc&&g(ub)),c!==X?(d=I(),d!==X?(34===a.charCodeAt(sc)?(e=tb,sc++):(e=X,0===xc&&g(ub)),e!==X?(tc=b,c=wb(d),b=c):(sc=b,b=X)):(sc=b,b=X)):(sc=b,b=X),b===X))if(b=sc,34===a.charCodeAt(sc)?(c=tb,sc++):(c=X,0===xc&&g(ub)),c!==X){if(d=[],e=G(),e!==X)for(;e!==X;)d.push(e),e=G();else d=X;d!==X?(34===a.charCodeAt(sc)?(e=tb,sc++):(e=X,0===xc&&g(ub)),e!==X?(tc=b,c=xb(d),b=c):(sc=b,b=X)):(sc=b,b=X)}else sc=b,b=X;return xc--,b===X&&(c=X,0===xc&&g(sb)),b}function G(){var a,b;return a=u(),a===X&&(a=r(),a===X&&(a=sc,b=I(),b!==X&&(tc=a,b=yb(b)),a=b)),a}function H(){var b,c,d,e,f,h,i,j;if(xc++,b=sc,c=R(),c!==X){for(d=[],e=S();e!==X;)d.push(e),e=S();d!==X?(tc=b,c=Ab(c,d),b=c):(sc=b,b=X)}else sc=b,b=X;if(b===X){if(b=sc,c=[],d=sc,e=sc,xc++,f=M(),xc--,f===X?e=void 0:(sc=e,e=X),e!==X?(f=sc,xc++,h=K(),xc--,h===X?f=void 0:(sc=f,f=X),f!==X?(h=sc,xc++,i=L(),xc--,i===X?h=void 0:(sc=h,h=X),h!==X?(i=sc,xc++,j=R(),xc--,j===X?i=void 0:(sc=i,i=X),i!==X?(a.length>sc?(j=a.charAt(sc),sc++):(j=X,0===xc&&g(Bb)),j!==X?(tc=d,e=Cb(j),d=e):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X),d!==X)for(;d!==X;)c.push(d),d=sc,e=sc,xc++,f=M(),xc--,f===X?e=void 0:(sc=e,e=X),e!==X?(f=sc,xc++,h=K(),xc--,h===X?f=void 0:(sc=f,f=X),f!==X?(h=sc,xc++,i=L(),xc--,i===X?h=void 0:(sc=h,h=X),h!==X?(i=sc,xc++,j=R(),xc--,j===X?i=void 0:(sc=i,i=X),i!==X?(a.length>sc?(j=a.charAt(sc),sc++):(j=X,0===xc&&g(Bb)),j!==X?(tc=d,e=Cb(j),d=e):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X)):(sc=d,d=X);else c=X;c!==X&&(tc=b,c=Db(c)),b=c}return xc--,b===X&&(c=X,0===xc&&g(zb)),b}function I(){var b,c,d,e,f;if(xc++,b=sc,c=[],d=sc,e=sc,xc++,f=M(),xc--,f===X?e=void 0:(sc=e,e=X),e!==X?(f=J(),f===X&&(Fb.test(a.charAt(sc))?(f=a.charAt(sc),sc++):(f=X,0===xc&&g(Gb))),f!==X?(tc=d,e=Cb(f),d=e):(sc=d,d=X)):(sc=d,d=X),d!==X)for(;d!==X;)c.push(d),d=sc,e=sc,xc++,f=M(),xc--,f===X?e=void 0:(sc=e,e=X),e!==X?(f=J(),f===X&&(Fb.test(a.charAt(sc))?(f=a.charAt(sc),sc++):(f=X,0===xc&&g(Gb))),f!==X?(tc=d,e=Cb(f),d=e):(sc=d,d=X)):(sc=d,d=X);else c=X;return c!==X&&(tc=b,c=Hb(c)),b=c,xc--,b===X&&(c=X,0===xc&&g(Eb)),b}function J(){var b,c;return b=sc,a.substr(sc,2)===Ib?(c=Ib,sc+=2):(c=X,0===xc&&g(Jb)),c!==X&&(tc=b,c=Kb()),b=c}function K(){var b,c,d,e,f,h;if(xc++,b=sc,a.substr(sc,2)===Mb?(c=Mb,sc+=2):(c=X,0===xc&&g(Nb)),c!==X){for(d=[],e=sc,f=sc,xc++,a.substr(sc,2)===Ob?(h=Ob,sc+=2):(h=X,0===xc&&g(Pb)),xc--,h===X?f=void 0:(sc=f,f=X),f!==X?(a.length>sc?(h=a.charAt(sc),sc++):(h=X,0===xc&&g(Bb)),h!==X?(tc=e,f=Qb(h),e=f):(sc=e,e=X)):(sc=e,e=X);e!==X;)d.push(e),e=sc,f=sc,xc++,a.substr(sc,2)===Ob?(h=Ob,sc+=2):(h=X,0===xc&&g(Pb)),xc--,h===X?f=void 0:(sc=f,f=X),f!==X?(a.length>sc?(h=a.charAt(sc),sc++):(h=X,0===xc&&g(Bb)),h!==X?(tc=e,f=Qb(h),e=f):(sc=e,e=X)):(sc=e,e=X);d!==X?(a.substr(sc,2)===Ob?(e=Ob,sc+=2):(e=X,0===xc&&g(Pb)),e!==X?(tc=b,c=Rb(d),b=c):(sc=b,b=X)):(sc=b,b=X)}else sc=b,b=X;return xc--,b===X&&(c=X,0===xc&&g(Lb)),b}function L(){var b,c,d,e,f,h;if(xc++,b=sc,a.substr(sc,2)===Tb?(c=Tb,sc+=2):(c=X,0===xc&&g(Ub)),c!==X){for(d=[],e=sc,f=sc,xc++,a.substr(sc,2)===Vb?(h=Vb,sc+=2):(h=X,0===xc&&g(Wb)),xc--,h===X?f=void 0:(sc=f,f=X),f!==X?(a.length>sc?(h=a.charAt(sc),sc++):(h=X,0===xc&&g(Bb)),h!==X?(tc=e,f=Cb(h),e=f):(sc=e,e=X)):(sc=e,e=X);e!==X;)d.push(e),e=sc,f=sc,xc++,a.substr(sc,2)===Vb?(h=Vb,sc+=2):(h=X,0===xc&&g(Wb)),xc--,h===X?f=void 0:(sc=f,f=X),f!==X?(a.length>sc?(h=a.charAt(sc),sc++):(h=X,0===xc&&g(Bb)),h!==X?(tc=e,f=Cb(h),e=f):(sc=e,e=X)):(sc=e,e=X);d!==X?(a.substr(sc,2)===Vb?(e=Vb,sc+=2):(e=X,0===xc&&g(Wb)),e!==X?(tc=b,c=Xb(d),b=c):(sc=b,b=X)):(sc=b,b=X)}else sc=b,b=X;return xc--,b===X&&(c=X,0===xc&&g(Sb)),b}function M(){var b,c,d,e,f,h,i,j,k,l;if(b=sc,c=N(),c!==X){for(d=[],e=S();e!==X;)d.push(e),e=S();if(d!==X)if(Yb.test(a.charAt(sc))?(e=a.charAt(sc),sc++):(e=X,0===xc&&g(Zb)),e!==X){for(f=[],h=S();h!==X;)f.push(h),h=S();if(f!==X){if(h=[],i=sc,j=sc,xc++,k=O(),xc--,k===X?j=void 0:(sc=j,j=X),j!==X?(k=sc,xc++,l=R(),xc--,l===X?k=void 0:(sc=k,k=X),k!==X?(a.length>sc?(l=a.charAt(sc),sc++):(l=X,0===xc&&g(Bb)),l!==X?(j=[j,k,l],i=j):(sc=i,i=X)):(sc=i,i=X)):(sc=i,i=X),i!==X)for(;i!==X;)h.push(i),i=sc,j=sc,xc++,k=O(),xc--,k===X?j=void 0:(sc=j,j=X),j!==X?(k=sc,xc++,l=R(),xc--,l===X?k=void 0:(sc=k,k=X),k!==X?(a.length>sc?(l=a.charAt(sc),sc++):(l=X,0===xc&&g(Bb)),l!==X?(j=[j,k,l],i=j):(sc=i,i=X)):(sc=i,i=X)):(sc=i,i=X);else h=X;if(h!==X){for(i=[],j=S();j!==X;)i.push(j),j=S();i!==X?(j=O(),j!==X?(c=[c,d,e,f,h,i,j],b=c):(sc=b,b=X)):(sc=b,b=X)}else sc=b,b=X}else sc=b,b=X}else sc=b,b=X;else sc=b,b=X}else sc=b,b=X;return b===X&&(b=r()),b}function N(){var b;return 123===a.charCodeAt(sc)?(b=$b,sc++):(b=X,0===xc&&g(_b)),b}function O(){var b;return 125===a.charCodeAt(sc)?(b=ac,sc++):(b=X,0===xc&&g(bc)),b}function P(){var b;return 91===a.charCodeAt(sc)?(b=cc,sc++):(b=X,0===xc&&g(dc)),b}function Q(){var b;return 93===a.charCodeAt(sc)?(b=ec,sc++):(b=X,0===xc&&g(fc)),b}function R(){var b;return 10===a.charCodeAt(sc)?(b=gc,sc++):(b=X,0===xc&&g(hc)),b===X&&(a.substr(sc,2)===ic?(b=ic,sc+=2):(b=X,0===xc&&g(jc)),b===X&&(13===a.charCodeAt(sc)?(b=kc,sc++):(b=X,0===xc&&g(lc)),b===X&&(8232===a.charCodeAt(sc)?(b=mc,sc++):(b=X,0===xc&&g(nc)),b===X&&(8233===a.charCodeAt(sc)?(b=oc,sc++):(b=X,0===xc&&g(pc)))))),b}function S(){var b;return qc.test(a.charAt(sc))?(b=a.charAt(sc),sc++):(b=X,0===xc&&g(rc)),b===X&&(b=R()),b}function T(a){return parseInt(a.join(\"\"),10)}function U(a){return a.location=c(),a}var V,W=arguments.length>1?arguments[1]:{},X={},Y={start:i},Z=i,$=function(a){var b=[\"body\"].concat(a);return U(b)},_={type:\"other\",description:\"section\"},aa=function(a,b,c,e){return e&&a[1].text===e.text||d(\"Expected end tag for \"+a[1].text+\" but it was not found.\"),!0},ba=function(a,b,c,d){return c.push([\"param\",[\"literal\",\"block\"],b]),a.push(c,[\"filters\"]),U(a)},ca=\"/\",da={type:\"literal\",value:\"/\",description:'\"/\"'},ea=function(a){return a.push([\"bodies\"],[\"filters\"]),U(a)},fa=/^[#?\\^<+@%]/,ga={type:\"class\",value:\"[#?^<+@%]\",description:\"[#?^<+@%]\"},ha=function(a,b,c,d){return[a,b,c,d]},ia={type:\"other\",description:\"end tag\"},ja=function(a){return a},ka=\":\",la={type:\"literal\",value:\":\",description:'\":\"'},ma=function(a){return a},na=function(a){return a?[\"context\",a]:[\"context\"]},oa={type:\"other\",description:\"params\"},pa=\"=\",qa={type:\"literal\",value:\"=\",description:'\"=\"'},ra=function(a,b){return[\"param\",[\"literal\",a],b]},sa=function(a){return[\"params\"].concat(a)},ta={type:\"other\",description:\"bodies\"},ua=function(a){return[\"bodies\"].concat(a)},va={type:\"other\",description:\"reference\"},wa=function(a,b){return U([\"reference\",a,b])},xa={type:\"other\",description:\"partial\"},ya=\">\",za={type:\"literal\",value:\">\",description:'\">\"'},Aa=\"+\",Ba={type:\"literal\",value:\"+\",description:'\"+\"'},Ca=function(a,b){return[\"literal\",b]},Da=function(a,b,c,d){var e=\">\"===a?\"partial\":a;return U([e,b,c,d])},Ea={type:\"other\",description:\"filters\"},Fa=\"|\",Ga={type:\"literal\",value:\"|\",description:'\"|\"'},Ha=function(a){return[\"filters\"].concat(a)},Ia={type:\"other\",description:\"special\"},Ja=\"~\",Ka={type:\"literal\",value:\"~\",description:'\"~\"'},La=function(a){return U([\"special\",a])},Ma={type:\"other\",description:\"identifier\"},Na=function(a){var b=[\"path\"].concat(a);return b.text=a[1].join(\".\"),b},Oa=function(a){var b=[\"key\",a];return b.text=a,b},Pa={type:\"other\",description:\"number\"},Qa=function(a){return[\"literal\",a]},Ra={type:\"other\",description:\"float\"},Sa=\".\",Ta={type:\"literal\",value:\".\",description:'\".\"'},Ua=function(a,b){return parseFloat(a+\".\"+b)},Va={type:\"other\",description:\"unsigned_integer\"},Wa=/^[0-9]/,Xa={type:\"class\",value:\"[0-9]\",description:\"[0-9]\"},Ya=function(a){return T(a)},Za={type:\"other\",description:\"signed_integer\"},$a=\"-\",_a={type:\"literal\",value:\"-\",description:'\"-\"'},ab=function(a,b){return b*-1},bb={type:\"other\",description:\"integer\"},cb={type:\"other\",description:\"path\"},db=function(a,b){return b=b[0],a&&b?(b.unshift(a),U([!1,b])):U([!0,b])},eb=function(a){return U(a.length>0?[!0,a[0]]:[!0,[]])},fb={type:\"other\",description:\"key\"},gb=/^[a-zA-Z_$]/,hb={type:\"class\",value:\"[a-zA-Z_$]\",description:\"[a-zA-Z_$]\"},ib=/^[0-9a-zA-Z_$\\-]/,jb={type:\"class\",value:\"[0-9a-zA-Z_$-]\",description:\"[0-9a-zA-Z_$-]\"},kb=function(a,b){return a+b.join(\"\")},lb={type:\"other\",description:\"array\"},mb=function(a){return a.join(\"\")},nb=function(a){return a},ob=function(a,b){return b?b.unshift(a):b=[a],b},pb={type:\"other\",description:\"array_part\"},qb=function(a){return a},rb=function(a,b){return b?a.concat(b):a},sb={type:\"other\",description:\"inline\"},tb='\"',ub={type:\"literal\",value:'\"',description:'\"\\\\\"\"'},vb=function(){return U([\"literal\",\"\"])},wb=function(a){return U([\"literal\",a])},xb=function(a){return U([\"body\"].concat(a))},yb=function(a){return[\"buffer\",a]},zb={type:\"other\",description:\"buffer\"},Ab=function(a,b){return U([\"format\",a,b.join(\"\")])},Bb={type:\"any\",description:\"any character\"},Cb=function(a){return a},Db=function(a){return U([\"buffer\",a.join(\"\")])},Eb={type:\"other\",description:\"literal\"},Fb=/^[^\"]/,Gb={type:\"class\",value:'[^\"]',description:'[^\"]'},Hb=function(a){return a.join(\"\")},Ib='\\\\\"',Jb={type:\"literal\",value:'\\\\\"',description:'\"\\\\\\\\\\\\\"\"'},Kb=function(){return'\"'},Lb={type:\"other\",description:\"raw\"},Mb=\"{`\",Nb={type:\"literal\",value:\"{`\",description:'\"{`\"'},Ob=\"`}\",Pb={type:\"literal\",value:\"`}\",description:'\"`}\"'\n},Qb=function(a){return a},Rb=function(a){return U([\"raw\",a.join(\"\")])},Sb={type:\"other\",description:\"comment\"},Tb=\"{!\",Ub={type:\"literal\",value:\"{!\",description:'\"{!\"'},Vb=\"!}\",Wb={type:\"literal\",value:\"!}\",description:'\"!}\"'},Xb=function(a){return U([\"comment\",a.join(\"\")])},Yb=/^[#?\\^><+%:@\\/~%]/,Zb={type:\"class\",value:\"[#?^><+%:@/~%]\",description:\"[#?^><+%:@/~%]\"},$b=\"{\",_b={type:\"literal\",value:\"{\",description:'\"{\"'},ac=\"}\",bc={type:\"literal\",value:\"}\",description:'\"}\"'},cc=\"[\",dc={type:\"literal\",value:\"[\",description:'\"[\"'},ec=\"]\",fc={type:\"literal\",value:\"]\",description:'\"]\"'},gc=\"\\n\",hc={type:\"literal\",value:\"\\n\",description:'\"\\\\n\"'},ic=\"\\r\\n\",jc={type:\"literal\",value:\"\\r\\n\",description:'\"\\\\r\\\\n\"'},kc=\"\\r\",lc={type:\"literal\",value:\"\\r\",description:'\"\\\\r\"'},mc=\"\\u2028\",nc={type:\"literal\",value:\"\\u2028\",description:'\"\\\\u2028\"'},oc=\"\\u2029\",pc={type:\"literal\",value:\"\\u2029\",description:'\"\\\\u2029\"'},qc=/^[\\t\\x0B\\f \\xA0\\uFEFF]/,rc={type:\"class\",value:\"[\\\\t\\\\v\\\\f \\\\u00A0\\\\uFEFF]\",description:\"[\\\\t\\\\v\\\\f \\\\u00A0\\\\uFEFF]\"},sc=0,tc=0,uc=[{line:1,column:1,seenCR:!1}],vc=0,wc=[],xc=0;if(\"startRule\"in W){if(!(W.startRule in Y))throw new Error(\"Can't start parsing from rule \\\"\"+W.startRule+'\".');Z=Y[W.startRule]}if(V=Z(),V!==X&&sc===a.length)return V;throw V!==X&&sc<a.length&&g({type:\"end\",description:\"end of input\"}),h(null,wc,vc<a.length?a.charAt(vc):null,vc<a.length?f(vc,vc+1):f(vc,vc))}return a(b,Error),{SyntaxError:b,parse:c}}();return dust.parse=a.parse,a}),function(a,b){\"function\"==typeof define&&define.amd&&define.amd.dust===!0?define(\"dust.compile\",[\"dust.core\",\"dust.parse\"],function(dust,a){return b(a,dust).compile}):\"object\"==typeof exports?module.exports=b(require(\"./parser\").parse,require(\"./dust\")):b(a.dust.parse,a.dust)}(this,function(a,dust){function b(a){var b={};return r.filterNode(b,a)}function c(a,b){var c,d,e,f=[b[0]];for(c=1,d=b.length;c<d;c++)e=r.filterNode(a,b[c]),e&&f.push(e);return f}function d(a,b){var c,d,e,f,g=[b[0]];for(d=1,e=b.length;d<e;d++)f=r.filterNode(a,b[d]),f&&(\"buffer\"===f[0]||\"format\"===f[0]?c?(c[0]=\"buffer\"===f[0]?\"buffer\":c[0],c[1]+=f.slice(1).join(\"\")):(c=f,g.push(f)):(c=null,g.push(f)));return g}function e(a,b){return[\"buffer\",u[b[1]],b[2],b[3]]}function f(a,b){return b}function g(){}function h(a,b){return dust.config.whitespace?(b.splice(1,2,b.slice(1).join(\"\")),b):null}function i(a,b){var c,d={name:b,bodies:[],blocks:{},index:0,auto:\"h\"},e=dust.escapeJs(b),f=b?'\"'+e+'\",':\"\",g=\"function(dust){\",h=r.compileNode(d,a);return b&&(g+='dust.register(\"'+e+'\",'+h+\");\"),g+=j(d)+k(d)+\"return \"+h+\"}\",c=\"(\"+g+\"(dust));\",dust.config.amd?\"define(\"+f+'[\"dust.core\"],'+g+\");\":dust.config.cjs?\"module.exports=function(dust){var tmpl=\"+c+\"var f=\"+q().toString()+\";f.template=tmpl;return f}\":c}function j(a){var b,c=[],d=a.blocks;for(b in d)Object.prototype.hasOwnProperty.call(d,b)&&c.push('\"'+b+'\":'+d[b]);return c.length?(a.blocks=\"ctx=ctx.shiftBlocks(blocks);\",\"var blocks={\"+c.join(\",\")+\"};\"):(a.blocks=\"\",a.blocks)}function k(a){var b,c,d=[],e=a.bodies,f=a.blocks;for(b=0,c=e.length;b<c;b++)d[b]=\"function body_\"+b+\"(chk,ctx){\"+f+\"return chk\"+e[b]+\";}body_\"+b+\".__dustBody=!0;\";return d.join(\"\")}function l(a,b){var c,d,e=\"\";for(c=1,d=b.length;c<d;c++)e+=r.compileNode(a,b[c]);return e}function m(a,b,c){return\".\"+(dust._aliases[c]||c)+\"(\"+r.compileNode(a,b[1])+\",\"+r.compileNode(a,b[2])+\",\"+r.compileNode(a,b[4])+\",\"+r.compileNode(a,b[3])+\")\"}function n(a){return a.replace(v,\"\\\\\\\\\").replace(w,'\\\\\"').replace(x,\"\\\\f\").replace(y,\"\\\\n\").replace(z,\"\\\\r\").replace(A,\"\\\\t\")}function o(a,b,c){var d=dust.loadSource(dust.compile(a));return q(d)(b,c)}function p(a,b){var c=dust.loadSource(dust.compile(a,b));return q(c)}function q(a){return function(b,c){var d=c?\"render\":\"stream\";return dust[d](a,b,c)}}var r={},s=dust.isArray,t=\"undefined\"==typeof JSON?function(a){return'\"'+n(a)+'\"'}:JSON.stringify;r.compile=function(c,d){try{var e=b(a(c));return i(e,d)}catch(f){if(!f.location)throw f;throw new SyntaxError(f.message+\" [\"+d+\":\"+f.location.start.line+\":\"+f.location.start.column+\"]\")}},r.filterNode=function(a,b){return r.optimizers[b[0]](a,b)},r.optimizers={body:d,buffer:f,special:e,format:h,reference:c,\"#\":c,\"?\":c,\"^\":c,\"<\":c,\"+\":c,\"@\":c,\"%\":c,partial:c,context:c,params:c,bodies:c,param:c,filters:f,key:f,path:f,literal:f,raw:f,comment:g},r.pragmas={esc:function(a,b,c){var d,e=a.auto;return b||(b=\"h\"),a.auto=\"s\"===b?\"\":b,d=l(a,c.block),a.auto=e,d}};var u={s:\" \",n:\"\\n\",r:\"\\r\",lb:\"{\",rb:\"}\"};r.compileNode=function(a,b){return r.nodes[b[0]](a,b)},r.nodes={body:function(a,b){var c=a.index++,d=\"body_\"+c;return a.bodies[c]=l(a,b),d},buffer:function(a,b){return\".w(\"+t(b[1])+\")\"},format:function(a,b){return\".w(\"+t(b[1])+\")\"},reference:function(a,b){return\".f(\"+r.compileNode(a,b[1])+\",ctx,\"+r.compileNode(a,b[2])+\")\"},\"#\":function(a,b){return m(a,b,\"section\")},\"?\":function(a,b){return m(a,b,\"exists\")},\"^\":function(a,b){return m(a,b,\"notexists\")},\"<\":function(a,b){for(var c=b[4],d=1,e=c.length;d<e;d++){var f=c[d],g=f[1][1];if(\"block\"===g)return a.blocks[b[1].text]=r.compileNode(a,f[2]),\"\"}return\"\"},\"+\":function(a,b){return\"undefined\"==typeof b[1].text&&\"undefined\"==typeof b[4]?\".b(ctx.getBlock(\"+r.compileNode(a,b[1])+\",chk, ctx),\"+r.compileNode(a,b[2])+\", {},\"+r.compileNode(a,b[3])+\")\":\".b(ctx.getBlock(\"+t(b[1].text)+\"),\"+r.compileNode(a,b[2])+\",\"+r.compileNode(a,b[4])+\",\"+r.compileNode(a,b[3])+\")\"},\"@\":function(a,b){return\".h(\"+t(b[1].text)+\",\"+r.compileNode(a,b[2])+\",\"+r.compileNode(a,b[4])+\",\"+r.compileNode(a,b[3])+\",\"+r.compileNode(a,b[5])+\")\"},\"%\":function(a,b){var c,d,e,f,g,h,i,j,k,l=b[1][1];if(!r.pragmas[l])return\"\";for(c=b[4],d={},j=1,k=c.length;j<k;j++)h=c[j],d[h[1][1]]=h[2];for(e=b[3],f={},j=1,k=e.length;j<k;j++)i=e[j],f[i[1][1]]=i[2][1];return g=b[2][1]?b[2][1].text:null,r.pragmas[l](a,g,d,f)},partial:function(a,b){return\".p(\"+r.compileNode(a,b[1])+\",ctx,\"+r.compileNode(a,b[2])+\",\"+r.compileNode(a,b[3])+\")\"},context:function(a,b){return b[1]?\"ctx.rebase(\"+r.compileNode(a,b[1])+\")\":\"ctx\"},params:function(a,b){for(var c=[],d=1,e=b.length;d<e;d++)c.push(r.compileNode(a,b[d]));return c.length?\"{\"+c.join(\",\")+\"}\":\"{}\"},bodies:function(a,b){for(var c=[],d=1,e=b.length;d<e;d++)c.push(r.compileNode(a,b[d]));return\"{\"+c.join(\",\")+\"}\"},param:function(a,b){return r.compileNode(a,b[1])+\":\"+r.compileNode(a,b[2])},filters:function(a,b){for(var c=[],d=1,e=b.length;d<e;d++){var f=b[d];c.push('\"'+f+'\"')}return'\"'+a.auto+'\"'+(c.length?\",[\"+c.join(\",\")+\"]\":\"\")},key:function(a,b){return'ctx.get([\"'+b[1]+'\"], false)'},path:function(a,b){for(var c=b[1],d=b[2],e=[],f=0,g=d.length;f<g;f++)s(d[f])?e.push(r.compileNode(a,d[f])):e.push('\"'+d[f]+'\"');return\"ctx.getPath(\"+c+\", [\"+e.join(\",\")+\"])\"},literal:function(a,b){return t(b[1])},raw:function(a,b){return\".w(\"+t(b[1])+\")\"}};var v=/\\\\/g,w=/\"/g,x=/\\f/g,y=/\\n/g,z=/\\r/g,A=/\\t/g;return dust.compiler=r,dust.compile=dust.compiler.compile,dust.renderSource=o,dust.compileFn=p,dust.filterNode=r.filterNode,dust.optimizers=r.optimizers,dust.pragmas=r.pragmas,dust.compileNode=r.compileNode,dust.nodes=r.nodes,r}),\"function\"==typeof define&&define.amd&&define.amd.dust===!0&&define([\"require\",\"dust.core\",\"dust.compile\"],function(require,dust){return dust.onLoad=function(a,b){require([a],function(a){b(null,a)})},dust});", "(function(root, factory) {\n  if (typeof define === \"function\" && define.amd && define.amd.dust === true) {\n    define(\"dust.compile\", [\"dust.core\", \"dust.parse\"], function(dust, parse) {\n      return factory(parse, dust).compile;\n    });\n  } else if (typeof exports === 'object') {\n    // in Node, require this file if we want to use the compiler as a standalone module\n    module.exports = factory(require('./parser').parse, require('./dust'));\n  } else {\n    // in the browser, store the factory output if we want to use the compiler directly\n    factory(root.dust.parse, root.dust);\n  }\n}(this, function(parse, dust) {\n  var compiler = {},\n      isArray = dust.isArray;\n\n  var escape = (typeof JSON === 'undefined') ?\n                  function(str) { return '\"' + escapeToJsSafeString(str) + '\"';} :\n                  JSON.stringify;\n\n  compiler.compile = function(source, name) {\n    // the name parameter is optional.\n    // this can happen for templates that are rendered immediately (renderSource which calls compileFn) or\n    // for templates that are compiled as a callable (compileFn)\n    //\n    // for the common case (using compile and render) a name is required so that templates will be cached by name and rendered later, by name.\n\n    try {\n      var ast = filterAST(parse(source));\n      return compile(ast, name);\n    } catch (err) {\n      if (!err.location) {\n        throw err;\n      }\n      throw new SyntaxError(err.message + ' [' + name + ':' + err.location.start.line + ':' + err.location.start.column + ']');\n    }\n  };\n\n  function filterAST(ast) {\n    var context = {};\n    return compiler.filterNode(context, ast);\n  }\n\n  compiler.filterNode = function(context, node) {\n    return compiler.optimizers[node[0]](context, node);\n  };\n\n  compiler.optimizers = {\n    body:      compactBuffers,\n    buffer:    noop,\n    special:   convertSpecial,\n    format:    format,\n    reference: visit,\n    '#':       visit,\n    '?':       visit,\n    '^':       visit,\n    '<':       visit,\n    '+':       visit,\n    '@':       visit,\n    '%':       visit,\n    partial:   visit,\n    context:   visit,\n    params:    visit,\n    bodies:    visit,\n    param:     visit,\n    filters:   noop,\n    key:       noop,\n    path:      noop,\n    literal:   noop,\n    raw:       noop,\n    comment:   nullify\n  };\n\n  compiler.pragmas = {\n    esc: function(compiler, context, bodies) {\n      var old = compiler.auto,\n          out;\n      if (!context) {\n        context = 'h';\n      }\n      compiler.auto = (context === 's') ? '' : context;\n      out = compileParts(compiler, bodies.block);\n      compiler.auto = old;\n      return out;\n    }\n  };\n\n  function visit(context, node) {\n    var out = [node[0]],\n        i, len, res;\n    for (i=1, len=node.length; i<len; i++) {\n      res = compiler.filterNode(context, node[i]);\n      if (res) {\n        out.push(res);\n      }\n    }\n    return out;\n  }\n\n  // Compacts consecutive buffer nodes into a single node\n  function compactBuffers(context, node) {\n    var out = [node[0]],\n        memo, i, len, res;\n    for (i=1, len=node.length; i<len; i++) {\n      res = compiler.filterNode(context, node[i]);\n      if (res) {\n        if (res[0] === 'buffer' || res[0] === 'format') {\n          if (memo) {\n            memo[0] = (res[0] === 'buffer') ? 'buffer' : memo[0];\n            memo[1] += res.slice(1).join('');\n          } else {\n            memo = res;\n            out.push(res);\n          }\n        } else {\n          memo = null;\n          out.push(res);\n        }\n      }\n    }\n    return out;\n  }\n\n  var specialChars = {\n    's': ' ',\n    'n': '\\n',\n    'r': '\\r',\n    'lb': '{',\n    'rb': '}'\n  };\n\n  function convertSpecial(context, node) {\n    return ['buffer', specialChars[node[1]], node[2], node[3]];\n  }\n\n  function noop(context, node) {\n    return node;\n  }\n\n  function nullify(){}\n\n  function format(context, node) {\n    if(dust.config.whitespace) {\n      // Format nodes are in the form ['format', eol, whitespace],\n      // which is unlike other nodes in that there are two pieces of content\n      // Join eol and whitespace together to normalize the node format\n      node.splice(1, 2, node.slice(1).join(''));\n      return node;\n    }\n    return null;\n  }\n\n  function compile(ast, name) {\n    var context = {\n      name: name,\n      bodies: [],\n      blocks: {},\n      index: 0,\n      auto: 'h'\n    },\n    escapedName = dust.escapeJs(name),\n    AMDName = name? '\"' + escapedName + '\",' : '',\n    compiled = 'function(dust){',\n    entry = compiler.compileNode(context, ast),\n    iife;\n\n    if(name) {\n      compiled += 'dust.register(\"' + escapedName + '\",' + entry + ');';\n    }\n\n    compiled += compileBlocks(context) +\n                compileBodies(context) +\n                'return ' + entry + '}';\n\n    iife = '(' + compiled + '(dust));';\n\n    if(dust.config.amd) {\n      return 'define(' + AMDName + '[\"dust.core\"],' + compiled + ');';\n    } else if(dust.config.cjs) {\n      return 'module.exports=function(dust){' +\n             'var tmpl=' + iife +\n             'var f=' + loaderFor().toString() + ';' +\n             'f.template=tmpl;return f}';\n    } else {\n      return iife;\n    }\n  }\n\n  function compileBlocks(context) {\n    var out = [],\n        blocks = context.blocks,\n        name;\n\n    for (name in blocks) {\n      if (Object.prototype.hasOwnProperty.call(blocks, name)) {\n        out.push('\"' + name + '\":' + blocks[name]);\n      }\n    }\n    if (out.length) {\n      context.blocks = 'ctx=ctx.shiftBlocks(blocks);';\n      return 'var blocks={' + out.join(',') + '};';\n    } else {\n      context.blocks = '';\n    }\n    return context.blocks;\n  }\n\n  function compileBodies(context) {\n    var out = [],\n        bodies = context.bodies,\n        blx = context.blocks,\n        i, len;\n\n    for (i=0, len=bodies.length; i<len; i++) {\n      out[i] = 'function body_' + i + '(chk,ctx){' +\n          blx + 'return chk' + bodies[i] + ';}body_' + i + '.__dustBody=!0;';\n    }\n    return out.join('');\n  }\n\n  function compileParts(context, body) {\n    var parts = '',\n        i, len;\n    for (i=1, len=body.length; i<len; i++) {\n      parts += compiler.compileNode(context, body[i]);\n    }\n    return parts;\n  }\n\n  compiler.compileNode = function(context, node) {\n    return compiler.nodes[node[0]](context, node);\n  };\n\n  compiler.nodes = {\n    body: function(context, node) {\n      var id = context.index++,\n          name = 'body_' + id;\n      context.bodies[id] = compileParts(context, node);\n      return name;\n    },\n\n    buffer: function(context, node) {\n      return '.w(' + escape(node[1]) + ')';\n    },\n\n    format: function(context, node) {\n      return '.w(' + escape(node[1]) + ')';\n    },\n\n    reference: function(context, node) {\n      return '.f(' + compiler.compileNode(context, node[1]) +\n        ',ctx,' + compiler.compileNode(context, node[2]) + ')';\n    },\n\n    '#': function(context, node) {\n      return compileSection(context, node, 'section');\n    },\n\n    '?': function(context, node) {\n      return compileSection(context, node, 'exists');\n    },\n\n    '^': function(context, node) {\n      return compileSection(context, node, 'notexists');\n    },\n\n    '<': function(context, node) {\n      var bodies = node[4];\n      for (var i=1, len=bodies.length; i<len; i++) {\n        var param = bodies[i],\n            type = param[1][1];\n        if (type === 'block') {\n          context.blocks[node[1].text] = compiler.compileNode(context, param[2]);\n          return '';\n        }\n      }\n      return '';\n    },\n\n    '+': function(context, node) {\n      if (typeof(node[1].text) === 'undefined'  && typeof(node[4]) === 'undefined'){\n        return '.b(ctx.getBlock(' +\n              compiler.compileNode(context, node[1]) +\n              ',chk, ctx),' + compiler.compileNode(context, node[2]) + ', {},' +\n              compiler.compileNode(context, node[3]) +\n              ')';\n      } else {\n        return '.b(ctx.getBlock(' +\n            escape(node[1].text) +\n            '),' + compiler.compileNode(context, node[2]) + ',' +\n            compiler.compileNode(context, node[4]) + ',' +\n            compiler.compileNode(context, node[3]) +\n            ')';\n      }\n    },\n\n    '@': function(context, node) {\n      return '.h(' +\n        escape(node[1].text) +\n        ',' + compiler.compileNode(context, node[2]) + ',' +\n        compiler.compileNode(context, node[4]) + ',' +\n        compiler.compileNode(context, node[3]) + ',' +\n        compiler.compileNode(context, node[5]) +\n        ')';\n    },\n\n    '%': function(context, node) {\n      // TODO: Move these hacks into pragma precompiler\n      var name = node[1][1],\n          rawBodies,\n          bodies,\n          rawParams,\n          params,\n          ctx, b, p, i, len;\n      if (!compiler.pragmas[name]) {\n        return '';\n      }\n\n      rawBodies = node[4];\n      bodies = {};\n      for (i=1, len=rawBodies.length; i<len; i++) {\n        b = rawBodies[i];\n        bodies[b[1][1]] = b[2];\n      }\n\n      rawParams = node[3];\n      params = {};\n      for (i=1, len=rawParams.length; i<len; i++) {\n        p = rawParams[i];\n        params[p[1][1]] = p[2][1];\n      }\n\n      ctx = node[2][1] ? node[2][1].text : null;\n\n      return compiler.pragmas[name](context, ctx, bodies, params);\n    },\n\n    partial: function(context, node) {\n      return '.p(' +\n          compiler.compileNode(context, node[1]) +\n          ',ctx,' + compiler.compileNode(context, node[2]) +\n          ',' + compiler.compileNode(context, node[3]) + ')';\n    },\n\n    context: function(context, node) {\n      if (node[1]) {\n        return 'ctx.rebase(' + compiler.compileNode(context, node[1]) + ')';\n      }\n      return 'ctx';\n    },\n\n    params: function(context, node) {\n      var out = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        out.push(compiler.compileNode(context, node[i]));\n      }\n      if (out.length) {\n        return '{' + out.join(',') + '}';\n      }\n      return '{}';\n    },\n\n    bodies: function(context, node) {\n      var out = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        out.push(compiler.compileNode(context, node[i]));\n      }\n      return '{' + out.join(',') + '}';\n    },\n\n    param: function(context, node) {\n      return compiler.compileNode(context, node[1]) + ':' + compiler.compileNode(context, node[2]);\n    },\n\n    filters: function(context, node) {\n      var list = [];\n      for (var i=1, len=node.length; i<len; i++) {\n        var filter = node[i];\n        list.push('\"' + filter + '\"');\n      }\n      return '\"' + context.auto + '\"' +\n        (list.length ? ',[' + list.join(',') + ']' : '');\n    },\n\n    key: function(context, node) {\n      return 'ctx.get([\"' + node[1] + '\"], false)';\n    },\n\n    path: function(context, node) {\n      var current = node[1],\n          keys = node[2],\n          list = [];\n\n      for (var i=0,len=keys.length; i<len; i++) {\n        if (isArray(keys[i])) {\n          list.push(compiler.compileNode(context, keys[i]));\n        } else {\n          list.push('\"' + keys[i] + '\"');\n        }\n      }\n      return 'ctx.getPath(' + current + ', [' + list.join(',') + '])';\n    },\n\n    literal: function(context, node) {\n      return escape(node[1]);\n    },\n    raw: function(context, node) {\n      return \".w(\" + escape(node[1]) + \")\";\n    }\n  };\n\n  function compileSection(context, node, cmd) {\n    return '.' + (dust._aliases[cmd] || cmd) + '(' +\n      compiler.compileNode(context, node[1]) +\n      ',' + compiler.compileNode(context, node[2]) + ',' +\n      compiler.compileNode(context, node[4]) + ',' +\n      compiler.compileNode(context, node[3]) +\n      ')';\n  }\n\n  var BS = /\\\\/g,\n      DQ = /\"/g,\n      LF = /\\f/g,\n      NL = /\\n/g,\n      CR = /\\r/g,\n      TB = /\\t/g;\n  function escapeToJsSafeString(str) {\n    return str.replace(BS, '\\\\\\\\')\n              .replace(DQ, '\\\\\"')\n              .replace(LF, '\\\\f')\n              .replace(NL, '\\\\n')\n              .replace(CR, '\\\\r')\n              .replace(TB, '\\\\t');\n  }\n\n  function renderSource(source, context, callback) {\n    var tmpl = dust.loadSource(dust.compile(source));\n    return loaderFor(tmpl)(context, callback);\n  }\n\n  function compileFn(source, name) {\n    var tmpl = dust.loadSource(dust.compile(source, name));\n    return loaderFor(tmpl);\n  }\n\n  function loaderFor(tmpl) {\n    return function load(ctx, cb) {\n      var fn = cb ? 'render' : 'stream';\n      return dust[fn](tmpl, ctx, cb);\n    };\n  }\n\n  // expose compiler methods\n  dust.compiler = compiler;\n  dust.compile = dust.compiler.compile;\n  dust.renderSource = renderSource;\n  dust.compileFn = compileFn;\n\n  // DEPRECATED legacy names. Removed in 2.8.0\n  dust.filterNode = compiler.filterNode;\n  dust.optimizers = compiler.optimizers;\n  dust.pragmas = compiler.pragmas;\n  dust.compileNode = compiler.compileNode;\n  dust.nodes = compiler.nodes;\n\n  return compiler;\n\n}));\n", "{\n  \"name\": \"dustjs-linkedin\",\n  \"version\": \"2.7.2\",\n  \"author\": {\n    \"name\": \"Aleksander Williams\",\n    \"url\": \"http://akdubya.github.com/dustjs\"\n  },\n  \"homepage\": \"http://dustjs.com/\",\n  \"description\": \"Asynchronous templates for the browser and server (LinkedIn fork)\",\n  \"contributors\": [\n    \"Veena Basavaraj <vybs@users.noreply.github.com>\",\n    \"Tom Carchrae\",\n    \"Jimmy Chan <jchan@linkedin.com>\",\n    \"Steven Foote <sfoote@linkedin.com>\",\n    \"Prayrit Prash Jain <prjain@linkedin.com>\",\n    \"Seth Kinast <skinast@linkedin.com>\",\n    \"Jairo de Morais <jairodemorais@users.noreply.github.com>\",\n    \"Kate Odnous <kodnous@linkedin.com>\",\n    \"Richard Ragan <rragan@ebay.com>\"\n  ],\n  \"scripts\": {\n    \"test\": \"grunt travis\"\n  },\n  \"bin\": {\n    \"dustc\": \"./bin/dustc\"\n  },\n  \"main\": \"index.js\",\n  \"browser\": \"./lib/dust.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/linkedin/dustjs.git\"\n  },\n  \"keywords\": [\n    \"templates\",\n    \"views\",\n    \"dust\",\n    \"dustjs\",\n    \"dust.js\",\n    \"linkedin\"\n  ],\n  \"dependencies\": {\n    \"chokidar\": \"~1.5.1\",\n    \"cli\": \"^1.0.1\"\n  },\n  \"devDependencies\": {\n    \"ayepromise\": \"~1.1.1\",\n    \"grunt\": \"~1.4.1\",\n    \"grunt-bump\": \"~0.8.0\",\n    \"grunt-cli\": \"~1.4.3\",\n    \"grunt-contrib-clean\": \"~2.0.0\",\n    \"grunt-contrib-concat\": \"~1.0.1\",\n    \"grunt-contrib-connect\": \"~3.0.0\",\n    \"grunt-contrib-copy\": \"~1.0.0\",\n    \"grunt-contrib-jasmine\": \"~1.2.0\",\n    \"grunt-contrib-jshint\": \"~3.0.0\",\n    \"grunt-contrib-uglify\": \"~1.0.1\",\n    \"grunt-contrib-watch\": \"~1.1.0\",\n    \"grunt-execute\": \"~0.2.2\",\n    \"grunt-github-changes\": \"~0.1.0\",\n    \"grunt-jasmine-nodejs\": \"~1.6.1\",\n    \"grunt-peg\": \"~2.0.0\",\n    \"grunt-saucelabs\": \"~8.6.1\",\n    \"grunt-shell\": \"~1.3.0\",\n    \"grunt-template-jasmine-istanbul\": \"~0.4.0\",\n    \"highland\": \"2.8.1\",\n    \"pegjs\": \"0.9.0\",\n    \"rhino-1_7r3-bin\": \"~1.0.1\",\n    \"rhino-1_7r5-bin\": \"~1.0.1\",\n    \"tmp\": \"~0.0.25\"\n  },\n  \"license\": \"MIT\",\n  \"engine\": {\n    \"node\": \">=0.10\"\n  }\n}\n", "(function (root, factory) {\n  if (typeof exports === 'object') {\n    factory(require('../'));\n  } else {\n    factory(root.dust);\n  }\n}(this, function(dust) {\n\n  function extend(target, donor) {\n    donor = donor || {};\n    for(var prop in donor) {\n      target[prop] = donor[prop];\n    }\n    return target;\n  }\n\n  function renderIt(message, source, context, expected, config) {\n    var tmpl = dust.loadSource(dust.compile(source));\n    dust.config = extend({ whitespace: false, amd: false, cjs: false, cache: true }, config);\n    it(message, function(done) {\n      render(tmpl, context, expected)(done);\n    });\n  }\n\n  function render(tmpl, context, expected) {\n    return function(done) {\n      dust.render(tmpl, context, function(err, output) {\n        expect(err).toBe(null);\n        expect(output).toEqual(expected);\n        done();\n      });\n    };\n  }\n\n  function templateName(chunk, context) {\n    return context.getTemplateName();\n  }\n\n  describe('Context', function() {\n    describe(\"render\", function() {\n      var base = dust.makeBase({\n        sayHello: function() { return \"Hello!\"; },\n        names: [\"Alice\", \"Bob\", \"Dusty\"]\n      });\n      it(\"doesn't push onto the stack if data is undefined\", function() {\n        expect(base.push().push().push().push().stack).toBe(undefined);\n      });\n      renderIt(\"can read from both globals and context\", \"{sayHello} {foo}\", base.push({foo: \"bar\"}), \"Hello! bar\");\n      renderIt(\"doesn't error if globals are empty\", \"{sayHello} {foo}\", dust.makeBase().push({foo: \"bar\"}), \" bar\");\n      renderIt(\"doesn't error if context is undefined\", \"{sayHello} {foo}\", undefined, \" \");\n      renderIt(\"can iterate over an array in the globals\", \"{sayHello} {#names}{.} {/names}\", base, \"Hello! Alice Bob Dusty \");\n    });\n\n    describe('templateName', function() {\n      var context = {\n        templateName: templateName\n      };\n      var tmpl = dust.loadSource(dust.compile(\"template name is {templateName}\", \"templateNameTest\"));\n      it(\"sets the template name on context\",\n        render(tmpl, context, \"template name is templateNameTest\"));\n      it(\"sets the template name when provided a context\",\n        render(tmpl, dust.context(context), \"template name is templateNameTest\"));\n    });\n\n    describe('options', function() {\n      it('sets options using makeBase / context', function() {\n        var opts = { lang: \"fr\" },\n            globals = { hello: \"world\" };\n        var base = dust.context(globals, opts);\n        expect(base.options.lang).toEqual(opts.lang);\n        base = base.rebase();\n        expect(base.options.lang).toEqual(opts.lang);\n      });\n    });\n\n    describe('prototype', function() {\n      var base = dust.context({\n        sayHello: function() { return \"Hello!\"; }\n      }).push({ foo: 'bar' });\n      var context = extend({}, base);\n      renderIt('survives having its prototype destroyed', '{sayHello} {foo}', context, 'Hello! bar');\n    });\n  });\n\n  describe(\"valid keys\", function() {\n    renderIt(\"Renders all valid keys\", \"{_foo}{$bar}{baz1}\", {_foo: 1, $bar: 2, baz1: 3}, \"123\");\n  });\n\n  describe('dust.onLoad', function() {\n    beforeEach(function() {\n      dust.cache.onLoad = null;\n    });\n    it(\"calls callback with source\", function(done) {\n      dust.onLoad = function(name, cb) {\n        cb(null, 'Loaded: ' + name + ', template name {templateName}');\n      };\n      render(\"onLoad\", {\n        templateName: templateName\n      }, \"Loaded: onLoad, template name onLoad\")(done);\n    });\n    it(\"calls callback with compiled template\", function(done) {\n      dust.onLoad = function(name, cb) {\n        var tmpl = dust.loadSource(dust.compile('Loaded: ' + name + ', template name {templateName}', 'foobar'));\n        cb(null, tmpl);\n      };\n      render(\"onLoad\", {\n        templateName: templateName\n      }, \"Loaded: onLoad, template name foobar\")(done);\n    });\n    it(\"calls callback with compiled template and can override template name\", function(done) {\n      dust.onLoad = function(name, cb) {\n        var tmpl = dust.loadSource(dust.compile('Loaded: ' + name + ', template name {templateName}', 'foobar'));\n        tmpl.templateName = 'override';\n        cb(null, dust.cache.foobar);\n      };\n      render(\"onLoad\", {\n        templateName: templateName\n      }, \"Loaded: onLoad, template name override\")(done);\n    });\n    it(\"receives context options\", function(done) {\n      dust.onLoad = function(name, opts, cb) {\n        cb(null, 'Loaded: ' + name + ', lang ' + opts.lang);\n      };\n      render(\"onLoad\", dust.makeBase(null, { lang: \"fr\" }), \"Loaded: onLoad, lang fr\")(done);\n    });\n  });\n\n  describe('dust.config.cache', function() {\n    beforeAll(function() {\n      dust.config.cache = false;\n    });\n    afterAll(function() {\n      dust.config.cache = true;\n    });\n    it('turns off cache registration', function() {\n      dust.loadSource(dust.compile('Not cached', 'test'));\n      expect(dust.cache.test).toBe(undefined);\n    });\n    it('calls onLoad every time for a template', function(done) {\n      var tmpl = \"Version 1\";\n      dust.onLoad = function(name, cb) {\n        cb(null, tmpl);\n      };\n      dust.render('test', undefined, function(err, out) {\n        expect(out).toEqual(tmpl);\n        tmpl = \"Version 2\";\n        dust.render('test', undefined, function(err, out) {\n          expect(out).toEqual(tmpl);\n          done();\n        });\n      });\n    });\n    it('does not clobber a cached template', function() {\n      dust.cache.test = 'test';\n      dust.loadSource(dust.compile('Not cached', 'test'));\n      expect(dust.cache.test).toEqual('test');\n    });\n  });\n\n  describe('renderSource', function() {\n    var template = \"Hello {world}!\",\n        expected = \"Hello world!\",\n        ctx = {world: \"world\"};\n\n    it('invokes a callback', function(done) {\n      dust.renderSource(template, ctx, function(err, out) {\n        expect(err).toBe(null);\n        expect(out).toBe(expected);\n        done();\n      });\n    });\n\n    it('streams', function(done) {\n      dust.renderSource(template, ctx).on('data', function(out) {\n        expect(out).toBe(expected);\n        done();\n      });\n    });\n\n    it('streams to every listener', function(done) {\n      var recipients = 0;\n      var stream = dust.renderSource(template, ctx);\n      var func = function(out) {\n        expect(out).toBe(expected);\n        recipients--;\n      };\n\n      while(recipients < 10) {\n        stream.on('data', func);\n        recipients++;\n      }\n\n      stream.on('end', function() {\n        expect(recipients).toBe(0);\n        done();\n      });\n    });\n\n    it('pipes', function(done) {\n      var gotData = false;\n      dust.renderSource(template, ctx).pipe({\n        write: function(out) {\n          expect(out).toBe(expected);\n          gotData = true;\n        },\n        end: function() {\n          expect(gotData).toBe(true);\n          done();\n        }\n      });\n    });\n  });\n\n  describe('compileFn', function() {\n    var ctx = {world:\"World\"},\n        expected = 'Hello World',\n        tmpl;\n    beforeAll(function() {\n      tmpl = dust.compileFn('Hello {world}');\n    });\n    it('can be invoked as a function', function(done) {\n      tmpl(ctx, function(err, out) {\n        expect(out).toEqual(expected);\n        done();\n      });\n    });\n    it('emits events like a stream', function(done) {\n      tmpl(ctx).on('data', function(out) {\n        expect(out).toEqual(expected);\n        done();\n      });\n    });\n  });\n\n  describe('vulnerabilities', function() {\n    it('has no prototype pollution vulnerability', function() {\n      const malicious = `this.constructor.constructor('return process')().mainModule.require('child_process').execSync('curl 127.0.0.1')`;\n      Object.prototype.MAL_CODE= [ malicious ];\n      const compiled = dust.compile('{username} is an important person.{~n}');\n      const tmpl = dust.loadSource(compiled);\n      dust.render(tmpl, { username: 'Jane Doe' }, (err, output) => {\n        delete Object.prototype.MAL_CODE;\n        expect(err).toBe(null);\n        expect(output).toEqual('Jane Doe is an important person.\\n');\n      });\n    });\n  });\n\n}));\n"], "filenames": [".gitignore", ".travis.yml", "dist/dust-core.js", "dist/dust-core.min.js", "dist/dust-full.js", "dist/dust-full.min.js", "lib/compiler.js", "package.json", "test/core.spec.js"], "buggy_code_start_loc": [8, 3, 3, 3, 3, 3, 195, 47, 85], "buggy_code_end_loc": [8, 18, 1148, 5, 4350, 6, 196, 61, 234], "fixing_code_start_loc": [9, 3, 3, 3, 3, 3, 195, 47, 85], "fixing_code_end_loc": [11, 18, 1210, 5, 4436, 6, 198, 61, 249], "type": "CWE-1321", "message": "A vulnerability was found in LinkedIn dustjs up to 2.x and classified as problematic. Affected by this issue is some unknown functionality. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). The attack may be launched remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 3.0.0 is able to address this issue. The name of the patch is ddb6523832465d38c9d80189e9de60519ac307c3. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216464.", "other": {"cve": {"id": "CVE-2021-4264", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-21T19:15:12.520", "lastModified": "2022-12-28T18:48:46.470", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in LinkedIn dustjs up to 2.x and classified as problematic. Affected by this issue is some unknown functionality. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). The attack may be launched remotely. The exploit has been disclosed to the public and may be used. Upgrading to version 3.0.0 is able to address this issue. The name of the patch is ddb6523832465d38c9d80189e9de60519ac307c3. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216464."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linkedin:dustjs:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.0", "matchCriteriaId": "C1F928D6-5422-4F4F-B6B4-281A48D31745"}]}]}], "references": [{"url": "https://github.com/linkedin/dustjs/commit/ddb6523832465d38c9d80189e9de60519ac307c3", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/linkedin/dustjs/issues/804", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/linkedin/dustjs/pull/805", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/linkedin/dustjs/releases/tag/v3.0.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216464", "source": "cna@vuldb.com", "tags": ["VDB Entry"]}, {"url": "https://vuldb.com/?id.216464", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/linkedin/dustjs/commit/ddb6523832465d38c9d80189e9de60519ac307c3"}}