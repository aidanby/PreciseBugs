{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * f_midi.c -- USB MIDI class function driver\n *\n * Copyright (C) 2006 Thumtronics Pty Ltd.\n * Developed for Thumtronics by Grey Innovation\n * Ben Williamson <ben.williamson@greyinnovation.com>\n *\n * Rewritten for the composite framework\n *   Copyright (C) 2011 Daniel Mack <zonque@gmail.com>\n *\n * Based on drivers/usb/gadget/f_audio.c,\n *   Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>\n *   Copyright (C) 2008 Analog Devices, Inc\n *\n * and drivers/usb/gadget/midi.c,\n *   Copyright (C) 2006 Thumtronics Pty Ltd.\n *   Ben Williamson <ben.williamson@greyinnovation.com>\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/kfifo.h>\n#include <linux/spinlock.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/rawmidi.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/midi.h>\n\n#include \"u_f.h\"\n#include \"u_midi.h\"\n\nMODULE_AUTHOR(\"Ben Williamson\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic const char f_midi_shortname[] = \"f_midi\";\nstatic const char f_midi_longname[] = \"MIDI Gadget\";\n\n/*\n * We can only handle 16 cables on one single endpoint, as cable numbers are\n * stored in 4-bit fields. And as the interface currently only holds one\n * single endpoint, this is the maximum number of ports we can allow.\n */\n#define MAX_PORTS 16\n\n/* MIDI message states */\nenum {\n\tSTATE_INITIAL = 0,\t/* pseudo state */\n\tSTATE_1PARAM,\n\tSTATE_2PARAM_1,\n\tSTATE_2PARAM_2,\n\tSTATE_SYSEX_0,\n\tSTATE_SYSEX_1,\n\tSTATE_SYSEX_2,\n\tSTATE_REAL_TIME,\n\tSTATE_FINISHED,\t\t/* pseudo state */\n};\n\n/*\n * This is a gadget, and the IN/OUT naming is from the host's perspective.\n * USB -> OUT endpoint -> rawmidi\n * USB <- IN endpoint  <- rawmidi\n */\nstruct gmidi_in_port {\n\tstruct snd_rawmidi_substream *substream;\n\tint active;\n\tuint8_t cable;\n\tuint8_t state;\n\tuint8_t data[2];\n};\n\nstruct f_midi {\n\tstruct usb_function\tfunc;\n\tstruct usb_gadget\t*gadget;\n\tstruct usb_ep\t\t*in_ep, *out_ep;\n\tstruct snd_card\t\t*card;\n\tstruct snd_rawmidi\t*rmidi;\n\tu8\t\t\tms_id;\n\n\tstruct snd_rawmidi_substream *out_substream[MAX_PORTS];\n\n\tunsigned long\t\tout_triggered;\n\tstruct tasklet_struct\ttasklet;\n\tunsigned int in_ports;\n\tunsigned int out_ports;\n\tint index;\n\tchar *id;\n\tunsigned int buflen, qlen;\n\t/* This fifo is used as a buffer ring for pre-allocated IN usb_requests */\n\tDECLARE_KFIFO_PTR(in_req_fifo, struct usb_request *);\n\tspinlock_t transmit_lock;\n\tunsigned int in_last_port;\n\tunsigned char free_ref;\n\n\tstruct gmidi_in_port\tin_ports_array[/* in_ports */];\n};\n\nstatic inline struct f_midi *func_to_midi(struct usb_function *f)\n{\n\treturn container_of(f, struct f_midi, func);\n}\n\nstatic void f_midi_transmit(struct f_midi *midi);\nstatic void f_midi_rmidi_free(struct snd_rawmidi *rmidi);\n\nDECLARE_UAC_AC_HEADER_DESCRIPTOR(1);\nDECLARE_USB_MIDI_OUT_JACK_DESCRIPTOR(1);\nDECLARE_USB_MS_ENDPOINT_DESCRIPTOR(16);\n\n/* B.3.1  Standard AC Interface Descriptor */\nstatic struct usb_interface_descriptor ac_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t/* .bInterfaceNumber =\tDYNAMIC */\n\t/* .bNumEndpoints =\tDYNAMIC */\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOCONTROL,\n\t/* .iInterface =\tDYNAMIC */\n};\n\n/* B.3.2  Class-Specific AC Interface Descriptor */\nstatic struct uac1_ac_header_descriptor_1 ac_header_desc = {\n\t.bLength =\t\tUAC_DT_AC_HEADER_SIZE(1),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUSB_MS_HEADER,\n\t.bcdADC =\t\tcpu_to_le16(0x0100),\n\t.wTotalLength =\t\tcpu_to_le16(UAC_DT_AC_HEADER_SIZE(1)),\n\t.bInCollection =\t1,\n\t/* .baInterfaceNr =\tDYNAMIC */\n};\n\n/* B.4.1  Standard MS Interface Descriptor */\nstatic struct usb_interface_descriptor ms_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t/* .bInterfaceNumber =\tDYNAMIC */\n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_MIDISTREAMING,\n\t/* .iInterface =\tDYNAMIC */\n};\n\n/* B.4.2  Class-Specific MS Interface Descriptor */\nstatic struct usb_ms_header_descriptor ms_header_desc = {\n\t.bLength =\t\tUSB_DT_MS_HEADER_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUSB_MS_HEADER,\n\t.bcdMSC =\t\tcpu_to_le16(0x0100),\n\t/* .wTotalLength =\tDYNAMIC */\n};\n\n/* B.5.1  Standard Bulk OUT Endpoint Descriptor */\nstatic struct usb_endpoint_descriptor bulk_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_ss_ep_comp_descriptor bulk_out_ss_comp_desc = {\n\t.bLength                = sizeof(bulk_out_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\t/* .bMaxBurst           = 0, */\n\t/* .bmAttributes        = 0, */\n};\n\n/* B.5.2  Class-specific MS Bulk OUT Endpoint Descriptor */\nstatic struct usb_ms_endpoint_descriptor_16 ms_out_desc = {\n\t/* .bLength =\t\tDYNAMIC */\n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUSB_MS_GENERAL,\n\t/* .bNumEmbMIDIJack =\tDYNAMIC */\n\t/* .baAssocJackID =\tDYNAMIC */\n};\n\n/* B.6.1  Standard Bulk IN Endpoint Descriptor */\nstatic struct usb_endpoint_descriptor bulk_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_ss_ep_comp_descriptor bulk_in_ss_comp_desc = {\n\t.bLength                = sizeof(bulk_in_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\t/* .bMaxBurst           = 0, */\n\t/* .bmAttributes        = 0, */\n};\n\n/* B.6.2  Class-specific MS Bulk IN Endpoint Descriptor */\nstatic struct usb_ms_endpoint_descriptor_16 ms_in_desc = {\n\t/* .bLength =\t\tDYNAMIC */\n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUSB_MS_GENERAL,\n\t/* .bNumEmbMIDIJack =\tDYNAMIC */\n\t/* .baAssocJackID =\tDYNAMIC */\n};\n\n/* string IDs are assigned dynamically */\n\n#define STRING_FUNC_IDX\t\t\t0\n\nstatic struct usb_string midi_string_defs[] = {\n\t[STRING_FUNC_IDX].s = \"MIDI function\",\n\t{  } /* end of list */\n};\n\nstatic struct usb_gadget_strings midi_stringtab = {\n\t.language\t= 0x0409,\t/* en-us */\n\t.strings\t= midi_string_defs,\n};\n\nstatic struct usb_gadget_strings *midi_strings[] = {\n\t&midi_stringtab,\n\tNULL,\n};\n\nstatic inline struct usb_request *midi_alloc_ep_req(struct usb_ep *ep,\n\t\t\t\t\t\t    unsigned length)\n{\n\treturn alloc_ep_req(ep, length);\n}\n\nstatic const uint8_t f_midi_cin_length[] = {\n\t0, 0, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 2, 2, 3, 1\n};\n\n/*\n * Receives a chunk of MIDI data.\n */\nstatic void f_midi_read_data(struct usb_ep *ep, int cable,\n\t\t\t     uint8_t *data, int length)\n{\n\tstruct f_midi *midi = ep->driver_data;\n\tstruct snd_rawmidi_substream *substream = midi->out_substream[cable];\n\n\tif (!substream)\n\t\t/* Nobody is listening - throw it on the floor. */\n\t\treturn;\n\n\tif (!test_bit(cable, &midi->out_triggered))\n\t\treturn;\n\n\tsnd_rawmidi_receive(substream, data, length);\n}\n\nstatic void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req)\n{\n\tunsigned int i;\n\tu8 *buf = req->buf;\n\n\tfor (i = 0; i + 3 < req->actual; i += 4)\n\t\tif (buf[i] != 0) {\n\t\t\tint cable = buf[i] >> 4;\n\t\t\tint length = f_midi_cin_length[buf[i] & 0x0f];\n\t\t\tf_midi_read_data(ep, cable, &buf[i + 1], length);\n\t\t}\n}\n\nstatic void\nf_midi_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_midi *midi = ep->driver_data;\n\tstruct usb_composite_dev *cdev = midi->func.config->cdev;\n\tint status = req->status;\n\n\tswitch (status) {\n\tcase 0:\t\t\t /* normal completion */\n\t\tif (ep == midi->out_ep) {\n\t\t\t/* We received stuff. req is queued again, below */\n\t\t\tf_midi_handle_out_data(ep, req);\n\t\t} else if (ep == midi->in_ep) {\n\t\t\t/* Our transmit completed. See if there's more to go.\n\t\t\t * f_midi_transmit eats req, don't queue it again. */\n\t\t\treq->length = 0;\n\t\t\tf_midi_transmit(midi);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\t/* this endpoint is normally active while we're configured */\n\tcase -ECONNABORTED:\t/* hardware forced ep reset */\n\tcase -ECONNRESET:\t/* request dequeued */\n\tcase -ESHUTDOWN:\t/* disconnect from host */\n\t\tVDBG(cdev, \"%s gone (%d), %d/%d\\n\", ep->name, status,\n\t\t\t\treq->actual, req->length);\n\t\tif (ep == midi->out_ep) {\n\t\t\tf_midi_handle_out_data(ep, req);\n\t\t\t/* We don't need to free IN requests because it's handled\n\t\t\t * by the midi->in_req_fifo. */\n\t\t\tfree_ep_req(ep, req);\n\t\t}\n\t\treturn;\n\n\tcase -EOVERFLOW:\t/* buffer overrun on read means that\n\t\t\t\t * we didn't provide a big enough buffer.\n\t\t\t\t */\n\tdefault:\n\t\tDBG(cdev, \"%s complete --> %d, %d/%d\\n\", ep->name,\n\t\t\t\tstatus, req->actual, req->length);\n\t\tbreak;\n\tcase -EREMOTEIO:\t/* short read */\n\t\tbreak;\n\t}\n\n\tstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (status) {\n\t\tERROR(cdev, \"kill %s:  resubmit %d bytes --> %d\\n\",\n\t\t\t\tep->name, req->length, status);\n\t\tusb_ep_set_halt(ep);\n\t\t/* FIXME recover later ... somehow */\n\t}\n}\n\nstatic void f_midi_drop_out_substreams(struct f_midi *midi)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < midi->in_ports; i++) {\n\t\tstruct gmidi_in_port *port = midi->in_ports_array + i;\n\t\tstruct snd_rawmidi_substream *substream = port->substream;\n\n\t\tif (port->active && substream)\n\t\t\tsnd_rawmidi_drop_output(substream);\n\t}\n}\n\nstatic int f_midi_start_ep(struct f_midi *midi,\n\t\t\t   struct usb_function *f,\n\t\t\t   struct usb_ep *ep)\n{\n\tint err;\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tusb_ep_disable(ep);\n\n\terr = config_ep_by_speed(midi->gadget, f, ep);\n\tif (err) {\n\t\tERROR(cdev, \"can't configure %s: %d\\n\", ep->name, err);\n\t\treturn err;\n\t}\n\n\terr = usb_ep_enable(ep);\n\tif (err) {\n\t\tERROR(cdev, \"can't start %s: %d\\n\", ep->name, err);\n\t\treturn err;\n\t}\n\n\tep->driver_data = midi;\n\n\treturn 0;\n}\n\nstatic int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t/* we only set alt for MIDIStreaming interface */\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\n\t/* pre-allocate write usb requests to use on f_midi_transmit. */\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\n\t/* allocate a bunch of read buffers and queue them all at once. */\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void f_midi_disable(struct usb_function *f)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request *req = NULL;\n\n\tDBG(cdev, \"disable\\n\");\n\n\t/*\n\t * just disable endpoints, forcing completion of pending i/o.\n\t * all our completion handlers free their requests in this case.\n\t */\n\tusb_ep_disable(midi->in_ep);\n\tusb_ep_disable(midi->out_ep);\n\n\t/* release IN requests */\n\twhile (kfifo_get(&midi->in_req_fifo, &req))\n\t\tfree_ep_req(midi->in_ep, req);\n\n\tf_midi_drop_out_substreams(midi);\n}\n\nstatic int f_midi_snd_free(struct snd_device *device)\n{\n\treturn 0;\n}\n\n/*\n * Converts MIDI commands to USB MIDI packets.\n */\nstatic void f_midi_transmit_byte(struct usb_request *req,\n\t\t\t\t struct gmidi_in_port *port, uint8_t b)\n{\n\tuint8_t p[4] = { port->cable << 4, 0, 0, 0 };\n\tuint8_t next_state = STATE_INITIAL;\n\n\tswitch (b) {\n\tcase 0xf8 ... 0xff:\n\t\t/* System Real-Time Messages */\n\t\tp[0] |= 0x0f;\n\t\tp[1] = b;\n\t\tnext_state = port->state;\n\t\tport->state = STATE_REAL_TIME;\n\t\tbreak;\n\n\tcase 0xf7:\n\t\t/* End of SysEx */\n\t\tswitch (port->state) {\n\t\tcase STATE_SYSEX_0:\n\t\t\tp[0] |= 0x05;\n\t\t\tp[1] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tp[0] |= 0x06;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\tp[0] |= 0x07;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Ignore byte */\n\t\t\tnext_state = port->state;\n\t\t\tport->state = STATE_INITIAL;\n\t\t}\n\t\tbreak;\n\n\tcase 0xf0 ... 0xf6:\n\t\t/* System Common Messages */\n\t\tport->data[0] = port->data[1] = 0;\n\t\tport->state = STATE_INITIAL;\n\t\tswitch (b) {\n\t\tcase 0xf0:\n\t\t\tport->data[0] = b;\n\t\t\tport->data[1] = 0;\n\t\t\tnext_state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase 0xf1:\n\t\tcase 0xf3:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase 0xf4:\n\t\tcase 0xf5:\n\t\t\tnext_state = STATE_INITIAL;\n\t\t\tbreak;\n\t\tcase 0xf6:\n\t\t\tp[0] |= 0x05;\n\t\t\tp[1] = 0xf6;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x80 ... 0xef:\n\t\t/*\n\t\t * Channel Voice Messages, Channel Mode Messages\n\t\t * and Control Change Messages.\n\t\t */\n\t\tport->data[0] = b;\n\t\tport->data[1] = 0;\n\t\tport->state = STATE_INITIAL;\n\t\tif (b >= 0xc0 && b <= 0xdf)\n\t\t\tnext_state = STATE_1PARAM;\n\t\telse\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\tbreak;\n\n\tcase 0x00 ... 0x7f:\n\t\t/* Message parameters */\n\t\tswitch (port->state) {\n\t\tcase STATE_1PARAM:\n\t\t\tif (port->data[0] < 0xf0)\n\t\t\t\tp[0] |= port->data[0] >> 4;\n\t\t\telse\n\t\t\t\tp[0] |= 0x02;\n\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = b;\n\t\t\t/* This is to allow Running State Messages */\n\t\t\tnext_state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_1:\n\t\t\tport->data[1] = b;\n\t\t\tnext_state = STATE_2PARAM_2;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_2:\n\t\t\tif (port->data[0] < 0xf0)\n\t\t\t\tp[0] |= port->data[0] >> 4;\n\t\t\telse\n\t\t\t\tp[0] |= 0x03;\n\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = b;\n\t\t\t/* This is to allow Running State Messages */\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_0:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tport->data[1] = b;\n\t\t\tnext_state = STATE_SYSEX_2;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\tp[0] |= 0x04;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = b;\n\t\t\tnext_state = STATE_SYSEX_0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* States where we have to write into the USB request */\n\tif (next_state == STATE_FINISHED ||\n\t    port->state == STATE_SYSEX_2 ||\n\t    port->state == STATE_1PARAM ||\n\t    port->state == STATE_2PARAM_2 ||\n\t    port->state == STATE_REAL_TIME) {\n\n\t\tunsigned int length = req->length;\n\t\tu8 *buf = (u8 *)req->buf + length;\n\n\t\tmemcpy(buf, p, sizeof(p));\n\t\treq->length = length + sizeof(p);\n\n\t\tif (next_state == STATE_FINISHED) {\n\t\t\tnext_state = STATE_INITIAL;\n\t\t\tport->data[0] = port->data[1] = 0;\n\t\t}\n\t}\n\n\tport->state = next_state;\n}\n\nstatic int f_midi_do_transmit(struct f_midi *midi, struct usb_ep *ep)\n{\n\tstruct usb_request *req = NULL;\n\tunsigned int len, i;\n\tbool active = false;\n\tint err;\n\n\t/*\n\t * We peek the request in order to reuse it if it fails to enqueue on\n\t * its endpoint\n\t */\n\tlen = kfifo_peek(&midi->in_req_fifo, &req);\n\tif (len != 1) {\n\t\tERROR(midi, \"%s: Couldn't get usb request\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If buffer overrun, then we ignore this transmission.\n\t * IMPORTANT: This will cause the user-space rawmidi device to block\n\t * until a) usb requests have been completed or b) snd_rawmidi_write()\n\t * times out.\n\t */\n\tif (req->length > 0)\n\t\treturn 0;\n\n\tfor (i = midi->in_last_port; i < midi->in_ports; ++i) {\n\t\tstruct gmidi_in_port *port = midi->in_ports_array + i;\n\t\tstruct snd_rawmidi_substream *substream = port->substream;\n\n\t\tif (!port->active || !substream)\n\t\t\tcontinue;\n\n\t\twhile (req->length + 3 < midi->buflen) {\n\t\t\tuint8_t b;\n\n\t\t\tif (snd_rawmidi_transmit(substream, &b, 1) != 1) {\n\t\t\t\tport->active = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf_midi_transmit_byte(req, port, b);\n\t\t}\n\n\t\tactive = !!port->active;\n\t\tif (active)\n\t\t\tbreak;\n\t}\n\tmidi->in_last_port = active ? i : 0;\n\n\tif (req->length <= 0)\n\t\tgoto done;\n\n\terr = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tERROR(midi, \"%s failed to queue req: %d\\n\",\n\t\t      midi->in_ep->name, err);\n\t\treq->length = 0; /* Re-use request next time. */\n\t} else {\n\t\t/* Upon success, put request at the back of the queue. */\n\t\tkfifo_skip(&midi->in_req_fifo);\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\ndone:\n\treturn active;\n}\n\nstatic void f_midi_transmit(struct f_midi *midi)\n{\n\tstruct usb_ep *ep = midi->in_ep;\n\tint ret;\n\tunsigned long flags;\n\n\t/* We only care about USB requests if IN endpoint is enabled */\n\tif (!ep || !ep->enabled)\n\t\tgoto drop_out;\n\n\tspin_lock_irqsave(&midi->transmit_lock, flags);\n\n\tdo {\n\t\tret = f_midi_do_transmit(midi, ep);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock_irqrestore(&midi->transmit_lock, flags);\n\t\t\tgoto drop_out;\n\t\t}\n\t} while (ret);\n\n\tspin_unlock_irqrestore(&midi->transmit_lock, flags);\n\n\treturn;\n\ndrop_out:\n\tf_midi_drop_out_substreams(midi);\n}\n\nstatic void f_midi_in_tasklet(unsigned long data)\n{\n\tstruct f_midi *midi = (struct f_midi *) data;\n\tf_midi_transmit(midi);\n}\n\nstatic int f_midi_in_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\tstruct gmidi_in_port *port;\n\n\tif (substream->number >= midi->in_ports)\n\t\treturn -EINVAL;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\tport = midi->in_ports_array + substream->number;\n\tport->substream = substream;\n\tport->state = STATE_INITIAL;\n\treturn 0;\n}\n\nstatic int f_midi_in_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\treturn 0;\n}\n\nstatic void f_midi_in_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tif (substream->number >= midi->in_ports)\n\t\treturn;\n\n\tVDBG(midi, \"%s() %d\\n\", __func__, up);\n\tmidi->in_ports_array[substream->number].active = up;\n\tif (up)\n\t\ttasklet_hi_schedule(&midi->tasklet);\n}\n\nstatic int f_midi_out_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tif (substream->number >= MAX_PORTS)\n\t\treturn -EINVAL;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\tmidi->out_substream[substream->number] = substream;\n\treturn 0;\n}\n\nstatic int f_midi_out_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\treturn 0;\n}\n\nstatic void f_midi_out_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\n\tif (up)\n\t\tset_bit(substream->number, &midi->out_triggered);\n\telse\n\t\tclear_bit(substream->number, &midi->out_triggered);\n}\n\nstatic const struct snd_rawmidi_ops gmidi_in_ops = {\n\t.open = f_midi_in_open,\n\t.close = f_midi_in_close,\n\t.trigger = f_midi_in_trigger,\n};\n\nstatic const struct snd_rawmidi_ops gmidi_out_ops = {\n\t.open = f_midi_out_open,\n\t.close = f_midi_out_close,\n\t.trigger = f_midi_out_trigger\n};\n\nstatic inline void f_midi_unregister_card(struct f_midi *midi)\n{\n\tif (midi->card) {\n\t\tsnd_card_free(midi->card);\n\t\tmidi->card = NULL;\n\t}\n}\n\n/* register as a sound \"card\" */\nstatic int f_midi_register_card(struct f_midi *midi)\n{\n\tstruct snd_card *card;\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = f_midi_snd_free,\n\t};\n\n\terr = snd_card_new(&midi->gadget->dev, midi->index, midi->id,\n\t\t\t   THIS_MODULE, 0, &card);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_card_new() failed\\n\");\n\t\tgoto fail;\n\t}\n\tmidi->card = card;\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, midi, &ops);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_device_new() failed: error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\tstrcpy(card->driver, f_midi_longname);\n\tstrcpy(card->longname, f_midi_longname);\n\tstrcpy(card->shortname, f_midi_shortname);\n\n\t/* Set up rawmidi */\n\tsnd_component_add(card, \"MIDI\");\n\terr = snd_rawmidi_new(card, card->longname, 0,\n\t\t\t      midi->out_ports, midi->in_ports, &rmidi);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_rawmidi_new() failed: error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\tmidi->rmidi = rmidi;\n\tmidi->in_last_port = 0;\n\tstrcpy(rmidi->name, card->shortname);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = midi;\n\trmidi->private_free = f_midi_rmidi_free;\n\tmidi->free_ref++;\n\n\t/*\n\t * Yes, rawmidi OUTPUT = USB IN, and rawmidi INPUT = USB OUT.\n\t * It's an upside-down world being a gadget.\n\t */\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &gmidi_in_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &gmidi_out_ops);\n\n\t/* register it - we're ready to go */\n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_card_register() failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tVDBG(midi, \"%s() finished ok\\n\", __func__);\n\treturn 0;\n\nfail:\n\tf_midi_unregister_card(midi);\n\treturn err;\n}\n\n/* MIDI function driver setup/binding */\n\nstatic int f_midi_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_descriptor_header **midi_function;\n\tstruct usb_midi_in_jack_descriptor jack_in_ext_desc[MAX_PORTS];\n\tstruct usb_midi_in_jack_descriptor jack_in_emb_desc[MAX_PORTS];\n\tstruct usb_midi_out_jack_descriptor_1 jack_out_ext_desc[MAX_PORTS];\n\tstruct usb_midi_out_jack_descriptor_1 jack_out_emb_desc[MAX_PORTS];\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_midi *midi = func_to_midi(f);\n\tstruct usb_string *us;\n\tint status, n, jack = 1, i = 0, endpoint_descriptor_index = 0;\n\n\tmidi->gadget = cdev->gadget;\n\ttasklet_init(&midi->tasklet, f_midi_in_tasklet, (unsigned long) midi);\n\tstatus = f_midi_register_card(midi);\n\tif (status < 0)\n\t\tgoto fail_register;\n\n\t/* maybe allocate device-global string ID */\n\tus = usb_gstrings_attach(c->cdev, midi_strings,\n\t\t\t\t ARRAY_SIZE(midi_string_defs));\n\tif (IS_ERR(us)) {\n\t\tstatus = PTR_ERR(us);\n\t\tgoto fail;\n\t}\n\tac_interface_desc.iInterface = us[STRING_FUNC_IDX].id;\n\n\t/* We have two interfaces, AudioControl and MIDIStreaming */\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tac_interface_desc.bInterfaceNumber = status;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tms_interface_desc.bInterfaceNumber = status;\n\tac_header_desc.baInterfaceNr[0] = status;\n\tmidi->ms_id = status;\n\n\tstatus = -ENODEV;\n\n\t/* allocate instance-specific endpoints */\n\tmidi->in_ep = usb_ep_autoconfig(cdev->gadget, &bulk_in_desc);\n\tif (!midi->in_ep)\n\t\tgoto fail;\n\n\tmidi->out_ep = usb_ep_autoconfig(cdev->gadget, &bulk_out_desc);\n\tif (!midi->out_ep)\n\t\tgoto fail;\n\n\t/* allocate temporary function list */\n\tmidi_function = kcalloc((MAX_PORTS * 4) + 11, sizeof(*midi_function),\n\t\t\t\tGFP_KERNEL);\n\tif (!midi_function) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * construct the function's descriptor set. As the number of\n\t * input and output MIDI ports is configurable, we have to do\n\t * it that way.\n\t */\n\n\t/* add the headers - these are always the same */\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ac_interface_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ac_header_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_interface_desc;\n\n\t/* calculate the header's wTotalLength */\n\tn = USB_DT_MS_HEADER_SIZE\n\t\t+ (midi->in_ports + midi->out_ports) *\n\t\t\t(USB_DT_MIDI_IN_SIZE + USB_DT_MIDI_OUT_SIZE(1));\n\tms_header_desc.wTotalLength = cpu_to_le16(n);\n\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_header_desc;\n\n\t/* configure the external IN jacks, each linked to an embedded OUT jack */\n\tfor (n = 0; n < midi->in_ports; n++) {\n\t\tstruct usb_midi_in_jack_descriptor *in_ext = &jack_in_ext_desc[n];\n\t\tstruct usb_midi_out_jack_descriptor_1 *out_emb = &jack_out_emb_desc[n];\n\n\t\tin_ext->bLength\t\t\t= USB_DT_MIDI_IN_SIZE;\n\t\tin_ext->bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\t\tin_ext->bDescriptorSubtype\t= USB_MS_MIDI_IN_JACK;\n\t\tin_ext->bJackType\t\t= USB_MS_EXTERNAL;\n\t\tin_ext->bJackID\t\t\t= jack++;\n\t\tin_ext->iJack\t\t\t= 0;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) in_ext;\n\n\t\tout_emb->bLength\t\t= USB_DT_MIDI_OUT_SIZE(1);\n\t\tout_emb->bDescriptorType\t= USB_DT_CS_INTERFACE;\n\t\tout_emb->bDescriptorSubtype\t= USB_MS_MIDI_OUT_JACK;\n\t\tout_emb->bJackType\t\t= USB_MS_EMBEDDED;\n\t\tout_emb->bJackID\t\t= jack++;\n\t\tout_emb->bNrInputPins\t\t= 1;\n\t\tout_emb->pins[0].baSourcePin\t= 1;\n\t\tout_emb->pins[0].baSourceID\t= in_ext->bJackID;\n\t\tout_emb->iJack\t\t\t= 0;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) out_emb;\n\n\t\t/* link it to the endpoint */\n\t\tms_in_desc.baAssocJackID[n] = out_emb->bJackID;\n\t}\n\n\t/* configure the external OUT jacks, each linked to an embedded IN jack */\n\tfor (n = 0; n < midi->out_ports; n++) {\n\t\tstruct usb_midi_in_jack_descriptor *in_emb = &jack_in_emb_desc[n];\n\t\tstruct usb_midi_out_jack_descriptor_1 *out_ext = &jack_out_ext_desc[n];\n\n\t\tin_emb->bLength\t\t\t= USB_DT_MIDI_IN_SIZE;\n\t\tin_emb->bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\t\tin_emb->bDescriptorSubtype\t= USB_MS_MIDI_IN_JACK;\n\t\tin_emb->bJackType\t\t= USB_MS_EMBEDDED;\n\t\tin_emb->bJackID\t\t\t= jack++;\n\t\tin_emb->iJack\t\t\t= 0;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) in_emb;\n\n\t\tout_ext->bLength =\t\tUSB_DT_MIDI_OUT_SIZE(1);\n\t\tout_ext->bDescriptorType =\tUSB_DT_CS_INTERFACE;\n\t\tout_ext->bDescriptorSubtype =\tUSB_MS_MIDI_OUT_JACK;\n\t\tout_ext->bJackType =\t\tUSB_MS_EXTERNAL;\n\t\tout_ext->bJackID =\t\tjack++;\n\t\tout_ext->bNrInputPins =\t\t1;\n\t\tout_ext->iJack =\t\t0;\n\t\tout_ext->pins[0].baSourceID =\tin_emb->bJackID;\n\t\tout_ext->pins[0].baSourcePin =\t1;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) out_ext;\n\n\t\t/* link it to the endpoint */\n\t\tms_out_desc.baAssocJackID[n] = in_emb->bJackID;\n\t}\n\n\t/* configure the endpoint descriptors ... */\n\tms_out_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->in_ports);\n\tms_out_desc.bNumEmbMIDIJack = midi->in_ports;\n\n\tms_in_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->out_ports);\n\tms_in_desc.bNumEmbMIDIJack = midi->out_ports;\n\n\t/* ... and add them to the list */\n\tendpoint_descriptor_index = i;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &bulk_out_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_out_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &bulk_in_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_in_desc;\n\tmidi_function[i++] = NULL;\n\n\t/*\n\t * support all relevant hardware speeds... we expect that when\n\t * hardware is dual speed, all bulk-capable endpoints work at\n\t * both speeds\n\t */\n\t/* copy descriptors, and track endpoint copies */\n\tf->fs_descriptors = usb_copy_descriptors(midi_function);\n\tif (!f->fs_descriptors)\n\t\tgoto fail_f_midi;\n\n\tif (gadget_is_dualspeed(c->cdev->gadget)) {\n\t\tbulk_in_desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tbulk_out_desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tf->hs_descriptors = usb_copy_descriptors(midi_function);\n\t\tif (!f->hs_descriptors)\n\t\t\tgoto fail_f_midi;\n\t}\n\n\tif (gadget_is_superspeed(c->cdev->gadget)) {\n\t\tbulk_in_desc.wMaxPacketSize = cpu_to_le16(1024);\n\t\tbulk_out_desc.wMaxPacketSize = cpu_to_le16(1024);\n\t\ti = endpoint_descriptor_index;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &bulk_out_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &bulk_out_ss_comp_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &ms_out_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &bulk_in_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &bulk_in_ss_comp_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &ms_in_desc;\n\t\tf->ss_descriptors = usb_copy_descriptors(midi_function);\n\t\tif (!f->ss_descriptors)\n\t\t\tgoto fail_f_midi;\n\t}\n\n\tkfree(midi_function);\n\n\treturn 0;\n\nfail_f_midi:\n\tkfree(midi_function);\n\tusb_free_all_descriptors(f);\nfail:\n\tf_midi_unregister_card(midi);\nfail_register:\n\tERROR(cdev, \"%s: can't bind, err %d\\n\", f->name, status);\n\n\treturn status;\n}\n\nstatic inline struct f_midi_opts *to_f_midi_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_midi_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void midi_attr_release(struct config_item *item)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations midi_item_ops = {\n\t.release\t= midi_attr_release,\n};\n\n#define F_MIDI_OPT(name, test_limit, limit)\t\t\t\t\\\nstatic ssize_t f_midi_opts_##name##_show(struct config_item *item, char *page) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%d\\n\", opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_midi_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu32 num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou32(page, 0, &num);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (test_limit && num > limit) {\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\topts->name = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_midi_opts_, name);\n\nF_MIDI_OPT(index, true, SNDRV_CARDS);\nF_MIDI_OPT(buflen, false, 0);\nF_MIDI_OPT(qlen, false, 0);\nF_MIDI_OPT(in_ports, true, MAX_PORTS);\nF_MIDI_OPT(out_ports, true, MAX_PORTS);\n\nstatic ssize_t f_midi_opts_id_show(struct config_item *item, char *page)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->id) {\n\t\tresult = strlcpy(page, opts->id, PAGE_SIZE);\n\t} else {\n\t\tpage[0] = 0;\n\t\tresult = 0;\n\t}\n\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_midi_opts_id_store(struct config_item *item,\n\t\t\t\t    const char *page, size_t len)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\tint ret;\n\tchar *c;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tc = kstrndup(page, len, GFP_KERNEL);\n\tif (!c) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\tif (opts->id_allocated)\n\t\tkfree(opts->id);\n\topts->id = c;\n\topts->id_allocated = true;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_midi_opts_, id);\n\nstatic struct configfs_attribute *midi_attrs[] = {\n\t&f_midi_opts_attr_index,\n\t&f_midi_opts_attr_buflen,\n\t&f_midi_opts_attr_qlen,\n\t&f_midi_opts_attr_in_ports,\n\t&f_midi_opts_attr_out_ports,\n\t&f_midi_opts_attr_id,\n\tNULL,\n};\n\nstatic const struct config_item_type midi_func_type = {\n\t.ct_item_ops\t= &midi_item_ops,\n\t.ct_attrs\t= midi_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void f_midi_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_midi_opts *opts;\n\n\topts = container_of(f, struct f_midi_opts, func_inst);\n\n\tif (opts->id_allocated)\n\t\tkfree(opts->id);\n\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *f_midi_alloc_inst(void)\n{\n\tstruct f_midi_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = f_midi_free_inst;\n\topts->index = SNDRV_DEFAULT_IDX1;\n\topts->id = SNDRV_DEFAULT_STR1;\n\topts->buflen = 512;\n\topts->qlen = 32;\n\topts->in_ports = 1;\n\topts->out_ports = 1;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &midi_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void f_midi_free(struct usb_function *f)\n{\n\tstruct f_midi *midi;\n\tstruct f_midi_opts *opts;\n\n\tmidi = func_to_midi(f);\n\topts = container_of(f->fi, struct f_midi_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\tif (!--midi->free_ref) {\n\t\tkfree(midi->id);\n\t\tkfifo_free(&midi->in_req_fifo);\n\t\tkfree(midi);\n\t\t--opts->refcnt;\n\t}\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void f_midi_rmidi_free(struct snd_rawmidi *rmidi)\n{\n\tf_midi_free(rmidi->private_data);\n}\n\nstatic void f_midi_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct f_midi *midi = func_to_midi(f);\n\tstruct snd_card *card;\n\n\tDBG(cdev, \"unbind\\n\");\n\n\t/* just to be sure */\n\tf_midi_disable(f);\n\n\tcard = midi->card;\n\tmidi->card = NULL;\n\tif (card)\n\t\tsnd_card_free_when_closed(card);\n\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *f_midi_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_midi *midi = NULL;\n\tstruct f_midi_opts *opts;\n\tint status, i;\n\n\topts = container_of(fi, struct f_midi_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\t/* sanity check */\n\tif (opts->in_ports > MAX_PORTS || opts->out_ports > MAX_PORTS) {\n\t\tstatus = -EINVAL;\n\t\tgoto setup_fail;\n\t}\n\n\t/* allocate and initialize one new instance */\n\tmidi = kzalloc(\n\t\tsizeof(*midi) + opts->in_ports * sizeof(*midi->in_ports_array),\n\t\tGFP_KERNEL);\n\tif (!midi) {\n\t\tstatus = -ENOMEM;\n\t\tgoto setup_fail;\n\t}\n\n\tfor (i = 0; i < opts->in_ports; i++)\n\t\tmidi->in_ports_array[i].cable = i;\n\n\t/* set up ALSA midi devices */\n\tmidi->id = kstrdup(opts->id, GFP_KERNEL);\n\tif (opts->id && !midi->id) {\n\t\tstatus = -ENOMEM;\n\t\tgoto setup_fail;\n\t}\n\tmidi->in_ports = opts->in_ports;\n\tmidi->out_ports = opts->out_ports;\n\tmidi->index = opts->index;\n\tmidi->buflen = opts->buflen;\n\tmidi->qlen = opts->qlen;\n\tmidi->in_last_port = 0;\n\tmidi->free_ref = 1;\n\n\tstatus = kfifo_alloc(&midi->in_req_fifo, midi->qlen, GFP_KERNEL);\n\tif (status)\n\t\tgoto setup_fail;\n\n\tspin_lock_init(&midi->transmit_lock);\n\n\t++opts->refcnt;\n\tmutex_unlock(&opts->lock);\n\n\tmidi->func.name\t\t= \"gmidi function\";\n\tmidi->func.bind\t\t= f_midi_bind;\n\tmidi->func.unbind\t= f_midi_unbind;\n\tmidi->func.set_alt\t= f_midi_set_alt;\n\tmidi->func.disable\t= f_midi_disable;\n\tmidi->func.free_func\t= f_midi_free;\n\n\treturn &midi->func;\n\nsetup_fail:\n\tmutex_unlock(&opts->lock);\n\tkfree(midi);\n\treturn ERR_PTR(status);\n}\n\nDECLARE_USB_FUNCTION_INIT(midi, f_midi_alloc_inst, f_midi_alloc);\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * u_f.h\n *\n * Utility definitions for USB functions\n *\n * Copyright (c) 2013 Samsung Electronics Co., Ltd.\n *\t\thttp://www.samsung.com\n *\n * Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>\n */\n\n#ifndef __U_F_H__\n#define __U_F_H__\n\n#include <linux/usb/gadget.h>\n\n/* Variable Length Array Macros **********************************************/\n#define vla_group(groupname) size_t groupname##__next = 0\n#define vla_group_size(groupname) groupname##__next\n\n#define vla_item(groupname, type, name, n) \\\n\tsize_t groupname##_##name##__offset = ({\t\t\t       \\\n\t\tsize_t align_mask = __alignof__(type) - 1;\t\t       \\\n\t\tsize_t offset = (groupname##__next + align_mask) & ~align_mask;\\\n\t\tsize_t size = (n) * sizeof(type);\t\t\t       \\\n\t\tgroupname##__next = offset + size;\t\t\t       \\\n\t\toffset;\t\t\t\t\t\t\t       \\\n\t})\n\n#define vla_item_with_sz(groupname, type, name, n) \\\n\tsize_t groupname##_##name##__sz = (n) * sizeof(type);\t\t       \\\n\tsize_t groupname##_##name##__offset = ({\t\t\t       \\\n\t\tsize_t align_mask = __alignof__(type) - 1;\t\t       \\\n\t\tsize_t offset = (groupname##__next + align_mask) & ~align_mask;\\\n\t\tsize_t size = groupname##_##name##__sz;\t\t\t       \\\n\t\tgroupname##__next = offset + size;\t\t\t       \\\n\t\toffset;\t\t\t\t\t\t\t       \\\n\t})\n\n#define vla_ptr(ptr, groupname, name) \\\n\t((void *) ((char *)ptr + groupname##_##name##__offset))\n\nstruct usb_ep;\nstruct usb_request;\n\n/**\n * alloc_ep_req - returns a usb_request allocated by the gadget driver and\n * allocates the request's buffer.\n *\n * @ep: the endpoint to allocate a usb_request\n * @len: usb_requests's buffer suggested size\n *\n * In case @ep direction is OUT, the @len will be aligned to ep's\n * wMaxPacketSize. In order to avoid memory leaks or drops, *always* use\n * usb_requests's length (req->length) to refer to the allocated buffer size.\n * Requests allocated via alloc_ep_req() *must* be freed by free_ep_req().\n */\nstruct usb_request *alloc_ep_req(struct usb_ep *ep, size_t len);\n\n/* Frees a usb_request previously allocated by alloc_ep_req() */\nstatic inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tkfree(req->buf);\n\tusb_ep_free_request(ep, req);\n}\n\n#endif /* __U_F_H__ */\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * f_midi.c -- USB MIDI class function driver\n *\n * Copyright (C) 2006 Thumtronics Pty Ltd.\n * Developed for Thumtronics by Grey Innovation\n * Ben Williamson <ben.williamson@greyinnovation.com>\n *\n * Rewritten for the composite framework\n *   Copyright (C) 2011 Daniel Mack <zonque@gmail.com>\n *\n * Based on drivers/usb/gadget/f_audio.c,\n *   Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>\n *   Copyright (C) 2008 Analog Devices, Inc\n *\n * and drivers/usb/gadget/midi.c,\n *   Copyright (C) 2006 Thumtronics Pty Ltd.\n *   Ben Williamson <ben.williamson@greyinnovation.com>\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/kfifo.h>\n#include <linux/spinlock.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/rawmidi.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/midi.h>\n\n#include \"u_f.h\"\n#include \"u_midi.h\"\n\nMODULE_AUTHOR(\"Ben Williamson\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic const char f_midi_shortname[] = \"f_midi\";\nstatic const char f_midi_longname[] = \"MIDI Gadget\";\n\n/*\n * We can only handle 16 cables on one single endpoint, as cable numbers are\n * stored in 4-bit fields. And as the interface currently only holds one\n * single endpoint, this is the maximum number of ports we can allow.\n */\n#define MAX_PORTS 16\n\n/* MIDI message states */\nenum {\n\tSTATE_INITIAL = 0,\t/* pseudo state */\n\tSTATE_1PARAM,\n\tSTATE_2PARAM_1,\n\tSTATE_2PARAM_2,\n\tSTATE_SYSEX_0,\n\tSTATE_SYSEX_1,\n\tSTATE_SYSEX_2,\n\tSTATE_REAL_TIME,\n\tSTATE_FINISHED,\t\t/* pseudo state */\n};\n\n/*\n * This is a gadget, and the IN/OUT naming is from the host's perspective.\n * USB -> OUT endpoint -> rawmidi\n * USB <- IN endpoint  <- rawmidi\n */\nstruct gmidi_in_port {\n\tstruct snd_rawmidi_substream *substream;\n\tint active;\n\tuint8_t cable;\n\tuint8_t state;\n\tuint8_t data[2];\n};\n\nstruct f_midi {\n\tstruct usb_function\tfunc;\n\tstruct usb_gadget\t*gadget;\n\tstruct usb_ep\t\t*in_ep, *out_ep;\n\tstruct snd_card\t\t*card;\n\tstruct snd_rawmidi\t*rmidi;\n\tu8\t\t\tms_id;\n\n\tstruct snd_rawmidi_substream *out_substream[MAX_PORTS];\n\n\tunsigned long\t\tout_triggered;\n\tstruct tasklet_struct\ttasklet;\n\tunsigned int in_ports;\n\tunsigned int out_ports;\n\tint index;\n\tchar *id;\n\tunsigned int buflen, qlen;\n\t/* This fifo is used as a buffer ring for pre-allocated IN usb_requests */\n\tDECLARE_KFIFO_PTR(in_req_fifo, struct usb_request *);\n\tspinlock_t transmit_lock;\n\tunsigned int in_last_port;\n\tunsigned char free_ref;\n\n\tstruct gmidi_in_port\tin_ports_array[/* in_ports */];\n};\n\nstatic inline struct f_midi *func_to_midi(struct usb_function *f)\n{\n\treturn container_of(f, struct f_midi, func);\n}\n\nstatic void f_midi_transmit(struct f_midi *midi);\nstatic void f_midi_rmidi_free(struct snd_rawmidi *rmidi);\n\nDECLARE_UAC_AC_HEADER_DESCRIPTOR(1);\nDECLARE_USB_MIDI_OUT_JACK_DESCRIPTOR(1);\nDECLARE_USB_MS_ENDPOINT_DESCRIPTOR(16);\n\n/* B.3.1  Standard AC Interface Descriptor */\nstatic struct usb_interface_descriptor ac_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t/* .bInterfaceNumber =\tDYNAMIC */\n\t/* .bNumEndpoints =\tDYNAMIC */\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOCONTROL,\n\t/* .iInterface =\tDYNAMIC */\n};\n\n/* B.3.2  Class-Specific AC Interface Descriptor */\nstatic struct uac1_ac_header_descriptor_1 ac_header_desc = {\n\t.bLength =\t\tUAC_DT_AC_HEADER_SIZE(1),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUSB_MS_HEADER,\n\t.bcdADC =\t\tcpu_to_le16(0x0100),\n\t.wTotalLength =\t\tcpu_to_le16(UAC_DT_AC_HEADER_SIZE(1)),\n\t.bInCollection =\t1,\n\t/* .baInterfaceNr =\tDYNAMIC */\n};\n\n/* B.4.1  Standard MS Interface Descriptor */\nstatic struct usb_interface_descriptor ms_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t/* .bInterfaceNumber =\tDYNAMIC */\n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_MIDISTREAMING,\n\t/* .iInterface =\tDYNAMIC */\n};\n\n/* B.4.2  Class-Specific MS Interface Descriptor */\nstatic struct usb_ms_header_descriptor ms_header_desc = {\n\t.bLength =\t\tUSB_DT_MS_HEADER_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUSB_MS_HEADER,\n\t.bcdMSC =\t\tcpu_to_le16(0x0100),\n\t/* .wTotalLength =\tDYNAMIC */\n};\n\n/* B.5.1  Standard Bulk OUT Endpoint Descriptor */\nstatic struct usb_endpoint_descriptor bulk_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_ss_ep_comp_descriptor bulk_out_ss_comp_desc = {\n\t.bLength                = sizeof(bulk_out_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\t/* .bMaxBurst           = 0, */\n\t/* .bmAttributes        = 0, */\n};\n\n/* B.5.2  Class-specific MS Bulk OUT Endpoint Descriptor */\nstatic struct usb_ms_endpoint_descriptor_16 ms_out_desc = {\n\t/* .bLength =\t\tDYNAMIC */\n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUSB_MS_GENERAL,\n\t/* .bNumEmbMIDIJack =\tDYNAMIC */\n\t/* .baAssocJackID =\tDYNAMIC */\n};\n\n/* B.6.1  Standard Bulk IN Endpoint Descriptor */\nstatic struct usb_endpoint_descriptor bulk_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_ss_ep_comp_descriptor bulk_in_ss_comp_desc = {\n\t.bLength                = sizeof(bulk_in_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\t/* .bMaxBurst           = 0, */\n\t/* .bmAttributes        = 0, */\n};\n\n/* B.6.2  Class-specific MS Bulk IN Endpoint Descriptor */\nstatic struct usb_ms_endpoint_descriptor_16 ms_in_desc = {\n\t/* .bLength =\t\tDYNAMIC */\n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUSB_MS_GENERAL,\n\t/* .bNumEmbMIDIJack =\tDYNAMIC */\n\t/* .baAssocJackID =\tDYNAMIC */\n};\n\n/* string IDs are assigned dynamically */\n\n#define STRING_FUNC_IDX\t\t\t0\n\nstatic struct usb_string midi_string_defs[] = {\n\t[STRING_FUNC_IDX].s = \"MIDI function\",\n\t{  } /* end of list */\n};\n\nstatic struct usb_gadget_strings midi_stringtab = {\n\t.language\t= 0x0409,\t/* en-us */\n\t.strings\t= midi_string_defs,\n};\n\nstatic struct usb_gadget_strings *midi_strings[] = {\n\t&midi_stringtab,\n\tNULL,\n};\n\nstatic inline struct usb_request *midi_alloc_ep_req(struct usb_ep *ep,\n\t\t\t\t\t\t    unsigned length)\n{\n\treturn alloc_ep_req(ep, length);\n}\n\nstatic const uint8_t f_midi_cin_length[] = {\n\t0, 0, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 2, 2, 3, 1\n};\n\n/*\n * Receives a chunk of MIDI data.\n */\nstatic void f_midi_read_data(struct usb_ep *ep, int cable,\n\t\t\t     uint8_t *data, int length)\n{\n\tstruct f_midi *midi = ep->driver_data;\n\tstruct snd_rawmidi_substream *substream = midi->out_substream[cable];\n\n\tif (!substream)\n\t\t/* Nobody is listening - throw it on the floor. */\n\t\treturn;\n\n\tif (!test_bit(cable, &midi->out_triggered))\n\t\treturn;\n\n\tsnd_rawmidi_receive(substream, data, length);\n}\n\nstatic void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req)\n{\n\tunsigned int i;\n\tu8 *buf = req->buf;\n\n\tfor (i = 0; i + 3 < req->actual; i += 4)\n\t\tif (buf[i] != 0) {\n\t\t\tint cable = buf[i] >> 4;\n\t\t\tint length = f_midi_cin_length[buf[i] & 0x0f];\n\t\t\tf_midi_read_data(ep, cable, &buf[i + 1], length);\n\t\t}\n}\n\nstatic void\nf_midi_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_midi *midi = ep->driver_data;\n\tstruct usb_composite_dev *cdev = midi->func.config->cdev;\n\tint status = req->status;\n\n\tswitch (status) {\n\tcase 0:\t\t\t /* normal completion */\n\t\tif (ep == midi->out_ep) {\n\t\t\t/* We received stuff. req is queued again, below */\n\t\t\tf_midi_handle_out_data(ep, req);\n\t\t} else if (ep == midi->in_ep) {\n\t\t\t/* Our transmit completed. See if there's more to go.\n\t\t\t * f_midi_transmit eats req, don't queue it again. */\n\t\t\treq->length = 0;\n\t\t\tf_midi_transmit(midi);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\t/* this endpoint is normally active while we're configured */\n\tcase -ECONNABORTED:\t/* hardware forced ep reset */\n\tcase -ECONNRESET:\t/* request dequeued */\n\tcase -ESHUTDOWN:\t/* disconnect from host */\n\t\tVDBG(cdev, \"%s gone (%d), %d/%d\\n\", ep->name, status,\n\t\t\t\treq->actual, req->length);\n\t\tif (ep == midi->out_ep) {\n\t\t\tf_midi_handle_out_data(ep, req);\n\t\t\t/* We don't need to free IN requests because it's handled\n\t\t\t * by the midi->in_req_fifo. */\n\t\t\tfree_ep_req(ep, req);\n\t\t}\n\t\treturn;\n\n\tcase -EOVERFLOW:\t/* buffer overrun on read means that\n\t\t\t\t * we didn't provide a big enough buffer.\n\t\t\t\t */\n\tdefault:\n\t\tDBG(cdev, \"%s complete --> %d, %d/%d\\n\", ep->name,\n\t\t\t\tstatus, req->actual, req->length);\n\t\tbreak;\n\tcase -EREMOTEIO:\t/* short read */\n\t\tbreak;\n\t}\n\n\tstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (status) {\n\t\tERROR(cdev, \"kill %s:  resubmit %d bytes --> %d\\n\",\n\t\t\t\tep->name, req->length, status);\n\t\tusb_ep_set_halt(ep);\n\t\t/* FIXME recover later ... somehow */\n\t}\n}\n\nstatic void f_midi_drop_out_substreams(struct f_midi *midi)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < midi->in_ports; i++) {\n\t\tstruct gmidi_in_port *port = midi->in_ports_array + i;\n\t\tstruct snd_rawmidi_substream *substream = port->substream;\n\n\t\tif (port->active && substream)\n\t\t\tsnd_rawmidi_drop_output(substream);\n\t}\n}\n\nstatic int f_midi_start_ep(struct f_midi *midi,\n\t\t\t   struct usb_function *f,\n\t\t\t   struct usb_ep *ep)\n{\n\tint err;\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tusb_ep_disable(ep);\n\n\terr = config_ep_by_speed(midi->gadget, f, ep);\n\tif (err) {\n\t\tERROR(cdev, \"can't configure %s: %d\\n\", ep->name, err);\n\t\treturn err;\n\t}\n\n\terr = usb_ep_enable(ep);\n\tif (err) {\n\t\tERROR(cdev, \"can't start %s: %d\\n\", ep->name, err);\n\t\treturn err;\n\t}\n\n\tep->driver_data = midi;\n\n\treturn 0;\n}\n\nstatic int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t/* we only set alt for MIDIStreaming interface */\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\n\t/* pre-allocate write usb requests to use on f_midi_transmit. */\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\n\t/* allocate a bunch of read buffers and queue them all at once. */\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tif (req->buf != NULL)\n\t\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void f_midi_disable(struct usb_function *f)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request *req = NULL;\n\n\tDBG(cdev, \"disable\\n\");\n\n\t/*\n\t * just disable endpoints, forcing completion of pending i/o.\n\t * all our completion handlers free their requests in this case.\n\t */\n\tusb_ep_disable(midi->in_ep);\n\tusb_ep_disable(midi->out_ep);\n\n\t/* release IN requests */\n\twhile (kfifo_get(&midi->in_req_fifo, &req))\n\t\tfree_ep_req(midi->in_ep, req);\n\n\tf_midi_drop_out_substreams(midi);\n}\n\nstatic int f_midi_snd_free(struct snd_device *device)\n{\n\treturn 0;\n}\n\n/*\n * Converts MIDI commands to USB MIDI packets.\n */\nstatic void f_midi_transmit_byte(struct usb_request *req,\n\t\t\t\t struct gmidi_in_port *port, uint8_t b)\n{\n\tuint8_t p[4] = { port->cable << 4, 0, 0, 0 };\n\tuint8_t next_state = STATE_INITIAL;\n\n\tswitch (b) {\n\tcase 0xf8 ... 0xff:\n\t\t/* System Real-Time Messages */\n\t\tp[0] |= 0x0f;\n\t\tp[1] = b;\n\t\tnext_state = port->state;\n\t\tport->state = STATE_REAL_TIME;\n\t\tbreak;\n\n\tcase 0xf7:\n\t\t/* End of SysEx */\n\t\tswitch (port->state) {\n\t\tcase STATE_SYSEX_0:\n\t\t\tp[0] |= 0x05;\n\t\t\tp[1] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tp[0] |= 0x06;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\tp[0] |= 0x07;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Ignore byte */\n\t\t\tnext_state = port->state;\n\t\t\tport->state = STATE_INITIAL;\n\t\t}\n\t\tbreak;\n\n\tcase 0xf0 ... 0xf6:\n\t\t/* System Common Messages */\n\t\tport->data[0] = port->data[1] = 0;\n\t\tport->state = STATE_INITIAL;\n\t\tswitch (b) {\n\t\tcase 0xf0:\n\t\t\tport->data[0] = b;\n\t\t\tport->data[1] = 0;\n\t\t\tnext_state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase 0xf1:\n\t\tcase 0xf3:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase 0xf4:\n\t\tcase 0xf5:\n\t\t\tnext_state = STATE_INITIAL;\n\t\t\tbreak;\n\t\tcase 0xf6:\n\t\t\tp[0] |= 0x05;\n\t\t\tp[1] = 0xf6;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x80 ... 0xef:\n\t\t/*\n\t\t * Channel Voice Messages, Channel Mode Messages\n\t\t * and Control Change Messages.\n\t\t */\n\t\tport->data[0] = b;\n\t\tport->data[1] = 0;\n\t\tport->state = STATE_INITIAL;\n\t\tif (b >= 0xc0 && b <= 0xdf)\n\t\t\tnext_state = STATE_1PARAM;\n\t\telse\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\tbreak;\n\n\tcase 0x00 ... 0x7f:\n\t\t/* Message parameters */\n\t\tswitch (port->state) {\n\t\tcase STATE_1PARAM:\n\t\t\tif (port->data[0] < 0xf0)\n\t\t\t\tp[0] |= port->data[0] >> 4;\n\t\t\telse\n\t\t\t\tp[0] |= 0x02;\n\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = b;\n\t\t\t/* This is to allow Running State Messages */\n\t\t\tnext_state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_1:\n\t\t\tport->data[1] = b;\n\t\t\tnext_state = STATE_2PARAM_2;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_2:\n\t\t\tif (port->data[0] < 0xf0)\n\t\t\t\tp[0] |= port->data[0] >> 4;\n\t\t\telse\n\t\t\t\tp[0] |= 0x03;\n\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = b;\n\t\t\t/* This is to allow Running State Messages */\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_0:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tport->data[1] = b;\n\t\t\tnext_state = STATE_SYSEX_2;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\tp[0] |= 0x04;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = b;\n\t\t\tnext_state = STATE_SYSEX_0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* States where we have to write into the USB request */\n\tif (next_state == STATE_FINISHED ||\n\t    port->state == STATE_SYSEX_2 ||\n\t    port->state == STATE_1PARAM ||\n\t    port->state == STATE_2PARAM_2 ||\n\t    port->state == STATE_REAL_TIME) {\n\n\t\tunsigned int length = req->length;\n\t\tu8 *buf = (u8 *)req->buf + length;\n\n\t\tmemcpy(buf, p, sizeof(p));\n\t\treq->length = length + sizeof(p);\n\n\t\tif (next_state == STATE_FINISHED) {\n\t\t\tnext_state = STATE_INITIAL;\n\t\t\tport->data[0] = port->data[1] = 0;\n\t\t}\n\t}\n\n\tport->state = next_state;\n}\n\nstatic int f_midi_do_transmit(struct f_midi *midi, struct usb_ep *ep)\n{\n\tstruct usb_request *req = NULL;\n\tunsigned int len, i;\n\tbool active = false;\n\tint err;\n\n\t/*\n\t * We peek the request in order to reuse it if it fails to enqueue on\n\t * its endpoint\n\t */\n\tlen = kfifo_peek(&midi->in_req_fifo, &req);\n\tif (len != 1) {\n\t\tERROR(midi, \"%s: Couldn't get usb request\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If buffer overrun, then we ignore this transmission.\n\t * IMPORTANT: This will cause the user-space rawmidi device to block\n\t * until a) usb requests have been completed or b) snd_rawmidi_write()\n\t * times out.\n\t */\n\tif (req->length > 0)\n\t\treturn 0;\n\n\tfor (i = midi->in_last_port; i < midi->in_ports; ++i) {\n\t\tstruct gmidi_in_port *port = midi->in_ports_array + i;\n\t\tstruct snd_rawmidi_substream *substream = port->substream;\n\n\t\tif (!port->active || !substream)\n\t\t\tcontinue;\n\n\t\twhile (req->length + 3 < midi->buflen) {\n\t\t\tuint8_t b;\n\n\t\t\tif (snd_rawmidi_transmit(substream, &b, 1) != 1) {\n\t\t\t\tport->active = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf_midi_transmit_byte(req, port, b);\n\t\t}\n\n\t\tactive = !!port->active;\n\t\tif (active)\n\t\t\tbreak;\n\t}\n\tmidi->in_last_port = active ? i : 0;\n\n\tif (req->length <= 0)\n\t\tgoto done;\n\n\terr = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tERROR(midi, \"%s failed to queue req: %d\\n\",\n\t\t      midi->in_ep->name, err);\n\t\treq->length = 0; /* Re-use request next time. */\n\t} else {\n\t\t/* Upon success, put request at the back of the queue. */\n\t\tkfifo_skip(&midi->in_req_fifo);\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\ndone:\n\treturn active;\n}\n\nstatic void f_midi_transmit(struct f_midi *midi)\n{\n\tstruct usb_ep *ep = midi->in_ep;\n\tint ret;\n\tunsigned long flags;\n\n\t/* We only care about USB requests if IN endpoint is enabled */\n\tif (!ep || !ep->enabled)\n\t\tgoto drop_out;\n\n\tspin_lock_irqsave(&midi->transmit_lock, flags);\n\n\tdo {\n\t\tret = f_midi_do_transmit(midi, ep);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock_irqrestore(&midi->transmit_lock, flags);\n\t\t\tgoto drop_out;\n\t\t}\n\t} while (ret);\n\n\tspin_unlock_irqrestore(&midi->transmit_lock, flags);\n\n\treturn;\n\ndrop_out:\n\tf_midi_drop_out_substreams(midi);\n}\n\nstatic void f_midi_in_tasklet(unsigned long data)\n{\n\tstruct f_midi *midi = (struct f_midi *) data;\n\tf_midi_transmit(midi);\n}\n\nstatic int f_midi_in_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\tstruct gmidi_in_port *port;\n\n\tif (substream->number >= midi->in_ports)\n\t\treturn -EINVAL;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\tport = midi->in_ports_array + substream->number;\n\tport->substream = substream;\n\tport->state = STATE_INITIAL;\n\treturn 0;\n}\n\nstatic int f_midi_in_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\treturn 0;\n}\n\nstatic void f_midi_in_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tif (substream->number >= midi->in_ports)\n\t\treturn;\n\n\tVDBG(midi, \"%s() %d\\n\", __func__, up);\n\tmidi->in_ports_array[substream->number].active = up;\n\tif (up)\n\t\ttasklet_hi_schedule(&midi->tasklet);\n}\n\nstatic int f_midi_out_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tif (substream->number >= MAX_PORTS)\n\t\treturn -EINVAL;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\tmidi->out_substream[substream->number] = substream;\n\treturn 0;\n}\n\nstatic int f_midi_out_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\treturn 0;\n}\n\nstatic void f_midi_out_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\n\tif (up)\n\t\tset_bit(substream->number, &midi->out_triggered);\n\telse\n\t\tclear_bit(substream->number, &midi->out_triggered);\n}\n\nstatic const struct snd_rawmidi_ops gmidi_in_ops = {\n\t.open = f_midi_in_open,\n\t.close = f_midi_in_close,\n\t.trigger = f_midi_in_trigger,\n};\n\nstatic const struct snd_rawmidi_ops gmidi_out_ops = {\n\t.open = f_midi_out_open,\n\t.close = f_midi_out_close,\n\t.trigger = f_midi_out_trigger\n};\n\nstatic inline void f_midi_unregister_card(struct f_midi *midi)\n{\n\tif (midi->card) {\n\t\tsnd_card_free(midi->card);\n\t\tmidi->card = NULL;\n\t}\n}\n\n/* register as a sound \"card\" */\nstatic int f_midi_register_card(struct f_midi *midi)\n{\n\tstruct snd_card *card;\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = f_midi_snd_free,\n\t};\n\n\terr = snd_card_new(&midi->gadget->dev, midi->index, midi->id,\n\t\t\t   THIS_MODULE, 0, &card);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_card_new() failed\\n\");\n\t\tgoto fail;\n\t}\n\tmidi->card = card;\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, midi, &ops);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_device_new() failed: error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\tstrcpy(card->driver, f_midi_longname);\n\tstrcpy(card->longname, f_midi_longname);\n\tstrcpy(card->shortname, f_midi_shortname);\n\n\t/* Set up rawmidi */\n\tsnd_component_add(card, \"MIDI\");\n\terr = snd_rawmidi_new(card, card->longname, 0,\n\t\t\t      midi->out_ports, midi->in_ports, &rmidi);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_rawmidi_new() failed: error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\tmidi->rmidi = rmidi;\n\tmidi->in_last_port = 0;\n\tstrcpy(rmidi->name, card->shortname);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = midi;\n\trmidi->private_free = f_midi_rmidi_free;\n\tmidi->free_ref++;\n\n\t/*\n\t * Yes, rawmidi OUTPUT = USB IN, and rawmidi INPUT = USB OUT.\n\t * It's an upside-down world being a gadget.\n\t */\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &gmidi_in_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &gmidi_out_ops);\n\n\t/* register it - we're ready to go */\n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_card_register() failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tVDBG(midi, \"%s() finished ok\\n\", __func__);\n\treturn 0;\n\nfail:\n\tf_midi_unregister_card(midi);\n\treturn err;\n}\n\n/* MIDI function driver setup/binding */\n\nstatic int f_midi_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_descriptor_header **midi_function;\n\tstruct usb_midi_in_jack_descriptor jack_in_ext_desc[MAX_PORTS];\n\tstruct usb_midi_in_jack_descriptor jack_in_emb_desc[MAX_PORTS];\n\tstruct usb_midi_out_jack_descriptor_1 jack_out_ext_desc[MAX_PORTS];\n\tstruct usb_midi_out_jack_descriptor_1 jack_out_emb_desc[MAX_PORTS];\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_midi *midi = func_to_midi(f);\n\tstruct usb_string *us;\n\tint status, n, jack = 1, i = 0, endpoint_descriptor_index = 0;\n\n\tmidi->gadget = cdev->gadget;\n\ttasklet_init(&midi->tasklet, f_midi_in_tasklet, (unsigned long) midi);\n\tstatus = f_midi_register_card(midi);\n\tif (status < 0)\n\t\tgoto fail_register;\n\n\t/* maybe allocate device-global string ID */\n\tus = usb_gstrings_attach(c->cdev, midi_strings,\n\t\t\t\t ARRAY_SIZE(midi_string_defs));\n\tif (IS_ERR(us)) {\n\t\tstatus = PTR_ERR(us);\n\t\tgoto fail;\n\t}\n\tac_interface_desc.iInterface = us[STRING_FUNC_IDX].id;\n\n\t/* We have two interfaces, AudioControl and MIDIStreaming */\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tac_interface_desc.bInterfaceNumber = status;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tms_interface_desc.bInterfaceNumber = status;\n\tac_header_desc.baInterfaceNr[0] = status;\n\tmidi->ms_id = status;\n\n\tstatus = -ENODEV;\n\n\t/* allocate instance-specific endpoints */\n\tmidi->in_ep = usb_ep_autoconfig(cdev->gadget, &bulk_in_desc);\n\tif (!midi->in_ep)\n\t\tgoto fail;\n\n\tmidi->out_ep = usb_ep_autoconfig(cdev->gadget, &bulk_out_desc);\n\tif (!midi->out_ep)\n\t\tgoto fail;\n\n\t/* allocate temporary function list */\n\tmidi_function = kcalloc((MAX_PORTS * 4) + 11, sizeof(*midi_function),\n\t\t\t\tGFP_KERNEL);\n\tif (!midi_function) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * construct the function's descriptor set. As the number of\n\t * input and output MIDI ports is configurable, we have to do\n\t * it that way.\n\t */\n\n\t/* add the headers - these are always the same */\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ac_interface_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ac_header_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_interface_desc;\n\n\t/* calculate the header's wTotalLength */\n\tn = USB_DT_MS_HEADER_SIZE\n\t\t+ (midi->in_ports + midi->out_ports) *\n\t\t\t(USB_DT_MIDI_IN_SIZE + USB_DT_MIDI_OUT_SIZE(1));\n\tms_header_desc.wTotalLength = cpu_to_le16(n);\n\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_header_desc;\n\n\t/* configure the external IN jacks, each linked to an embedded OUT jack */\n\tfor (n = 0; n < midi->in_ports; n++) {\n\t\tstruct usb_midi_in_jack_descriptor *in_ext = &jack_in_ext_desc[n];\n\t\tstruct usb_midi_out_jack_descriptor_1 *out_emb = &jack_out_emb_desc[n];\n\n\t\tin_ext->bLength\t\t\t= USB_DT_MIDI_IN_SIZE;\n\t\tin_ext->bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\t\tin_ext->bDescriptorSubtype\t= USB_MS_MIDI_IN_JACK;\n\t\tin_ext->bJackType\t\t= USB_MS_EXTERNAL;\n\t\tin_ext->bJackID\t\t\t= jack++;\n\t\tin_ext->iJack\t\t\t= 0;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) in_ext;\n\n\t\tout_emb->bLength\t\t= USB_DT_MIDI_OUT_SIZE(1);\n\t\tout_emb->bDescriptorType\t= USB_DT_CS_INTERFACE;\n\t\tout_emb->bDescriptorSubtype\t= USB_MS_MIDI_OUT_JACK;\n\t\tout_emb->bJackType\t\t= USB_MS_EMBEDDED;\n\t\tout_emb->bJackID\t\t= jack++;\n\t\tout_emb->bNrInputPins\t\t= 1;\n\t\tout_emb->pins[0].baSourcePin\t= 1;\n\t\tout_emb->pins[0].baSourceID\t= in_ext->bJackID;\n\t\tout_emb->iJack\t\t\t= 0;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) out_emb;\n\n\t\t/* link it to the endpoint */\n\t\tms_in_desc.baAssocJackID[n] = out_emb->bJackID;\n\t}\n\n\t/* configure the external OUT jacks, each linked to an embedded IN jack */\n\tfor (n = 0; n < midi->out_ports; n++) {\n\t\tstruct usb_midi_in_jack_descriptor *in_emb = &jack_in_emb_desc[n];\n\t\tstruct usb_midi_out_jack_descriptor_1 *out_ext = &jack_out_ext_desc[n];\n\n\t\tin_emb->bLength\t\t\t= USB_DT_MIDI_IN_SIZE;\n\t\tin_emb->bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\t\tin_emb->bDescriptorSubtype\t= USB_MS_MIDI_IN_JACK;\n\t\tin_emb->bJackType\t\t= USB_MS_EMBEDDED;\n\t\tin_emb->bJackID\t\t\t= jack++;\n\t\tin_emb->iJack\t\t\t= 0;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) in_emb;\n\n\t\tout_ext->bLength =\t\tUSB_DT_MIDI_OUT_SIZE(1);\n\t\tout_ext->bDescriptorType =\tUSB_DT_CS_INTERFACE;\n\t\tout_ext->bDescriptorSubtype =\tUSB_MS_MIDI_OUT_JACK;\n\t\tout_ext->bJackType =\t\tUSB_MS_EXTERNAL;\n\t\tout_ext->bJackID =\t\tjack++;\n\t\tout_ext->bNrInputPins =\t\t1;\n\t\tout_ext->iJack =\t\t0;\n\t\tout_ext->pins[0].baSourceID =\tin_emb->bJackID;\n\t\tout_ext->pins[0].baSourcePin =\t1;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) out_ext;\n\n\t\t/* link it to the endpoint */\n\t\tms_out_desc.baAssocJackID[n] = in_emb->bJackID;\n\t}\n\n\t/* configure the endpoint descriptors ... */\n\tms_out_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->in_ports);\n\tms_out_desc.bNumEmbMIDIJack = midi->in_ports;\n\n\tms_in_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->out_ports);\n\tms_in_desc.bNumEmbMIDIJack = midi->out_ports;\n\n\t/* ... and add them to the list */\n\tendpoint_descriptor_index = i;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &bulk_out_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_out_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &bulk_in_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_in_desc;\n\tmidi_function[i++] = NULL;\n\n\t/*\n\t * support all relevant hardware speeds... we expect that when\n\t * hardware is dual speed, all bulk-capable endpoints work at\n\t * both speeds\n\t */\n\t/* copy descriptors, and track endpoint copies */\n\tf->fs_descriptors = usb_copy_descriptors(midi_function);\n\tif (!f->fs_descriptors)\n\t\tgoto fail_f_midi;\n\n\tif (gadget_is_dualspeed(c->cdev->gadget)) {\n\t\tbulk_in_desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tbulk_out_desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tf->hs_descriptors = usb_copy_descriptors(midi_function);\n\t\tif (!f->hs_descriptors)\n\t\t\tgoto fail_f_midi;\n\t}\n\n\tif (gadget_is_superspeed(c->cdev->gadget)) {\n\t\tbulk_in_desc.wMaxPacketSize = cpu_to_le16(1024);\n\t\tbulk_out_desc.wMaxPacketSize = cpu_to_le16(1024);\n\t\ti = endpoint_descriptor_index;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &bulk_out_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &bulk_out_ss_comp_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &ms_out_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &bulk_in_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &bulk_in_ss_comp_desc;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t\t     &ms_in_desc;\n\t\tf->ss_descriptors = usb_copy_descriptors(midi_function);\n\t\tif (!f->ss_descriptors)\n\t\t\tgoto fail_f_midi;\n\t}\n\n\tkfree(midi_function);\n\n\treturn 0;\n\nfail_f_midi:\n\tkfree(midi_function);\n\tusb_free_all_descriptors(f);\nfail:\n\tf_midi_unregister_card(midi);\nfail_register:\n\tERROR(cdev, \"%s: can't bind, err %d\\n\", f->name, status);\n\n\treturn status;\n}\n\nstatic inline struct f_midi_opts *to_f_midi_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_midi_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void midi_attr_release(struct config_item *item)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations midi_item_ops = {\n\t.release\t= midi_attr_release,\n};\n\n#define F_MIDI_OPT(name, test_limit, limit)\t\t\t\t\\\nstatic ssize_t f_midi_opts_##name##_show(struct config_item *item, char *page) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%d\\n\", opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_midi_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu32 num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou32(page, 0, &num);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (test_limit && num > limit) {\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\topts->name = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_midi_opts_, name);\n\nF_MIDI_OPT(index, true, SNDRV_CARDS);\nF_MIDI_OPT(buflen, false, 0);\nF_MIDI_OPT(qlen, false, 0);\nF_MIDI_OPT(in_ports, true, MAX_PORTS);\nF_MIDI_OPT(out_ports, true, MAX_PORTS);\n\nstatic ssize_t f_midi_opts_id_show(struct config_item *item, char *page)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->id) {\n\t\tresult = strlcpy(page, opts->id, PAGE_SIZE);\n\t} else {\n\t\tpage[0] = 0;\n\t\tresult = 0;\n\t}\n\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_midi_opts_id_store(struct config_item *item,\n\t\t\t\t    const char *page, size_t len)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\tint ret;\n\tchar *c;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tc = kstrndup(page, len, GFP_KERNEL);\n\tif (!c) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\tif (opts->id_allocated)\n\t\tkfree(opts->id);\n\topts->id = c;\n\topts->id_allocated = true;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_midi_opts_, id);\n\nstatic struct configfs_attribute *midi_attrs[] = {\n\t&f_midi_opts_attr_index,\n\t&f_midi_opts_attr_buflen,\n\t&f_midi_opts_attr_qlen,\n\t&f_midi_opts_attr_in_ports,\n\t&f_midi_opts_attr_out_ports,\n\t&f_midi_opts_attr_id,\n\tNULL,\n};\n\nstatic const struct config_item_type midi_func_type = {\n\t.ct_item_ops\t= &midi_item_ops,\n\t.ct_attrs\t= midi_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void f_midi_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_midi_opts *opts;\n\n\topts = container_of(f, struct f_midi_opts, func_inst);\n\n\tif (opts->id_allocated)\n\t\tkfree(opts->id);\n\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *f_midi_alloc_inst(void)\n{\n\tstruct f_midi_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = f_midi_free_inst;\n\topts->index = SNDRV_DEFAULT_IDX1;\n\topts->id = SNDRV_DEFAULT_STR1;\n\topts->buflen = 512;\n\topts->qlen = 32;\n\topts->in_ports = 1;\n\topts->out_ports = 1;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &midi_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void f_midi_free(struct usb_function *f)\n{\n\tstruct f_midi *midi;\n\tstruct f_midi_opts *opts;\n\n\tmidi = func_to_midi(f);\n\topts = container_of(f->fi, struct f_midi_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\tif (!--midi->free_ref) {\n\t\tkfree(midi->id);\n\t\tkfifo_free(&midi->in_req_fifo);\n\t\tkfree(midi);\n\t\t--opts->refcnt;\n\t}\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void f_midi_rmidi_free(struct snd_rawmidi *rmidi)\n{\n\tf_midi_free(rmidi->private_data);\n}\n\nstatic void f_midi_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct f_midi *midi = func_to_midi(f);\n\tstruct snd_card *card;\n\n\tDBG(cdev, \"unbind\\n\");\n\n\t/* just to be sure */\n\tf_midi_disable(f);\n\n\tcard = midi->card;\n\tmidi->card = NULL;\n\tif (card)\n\t\tsnd_card_free_when_closed(card);\n\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *f_midi_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_midi *midi = NULL;\n\tstruct f_midi_opts *opts;\n\tint status, i;\n\n\topts = container_of(fi, struct f_midi_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\t/* sanity check */\n\tif (opts->in_ports > MAX_PORTS || opts->out_ports > MAX_PORTS) {\n\t\tstatus = -EINVAL;\n\t\tgoto setup_fail;\n\t}\n\n\t/* allocate and initialize one new instance */\n\tmidi = kzalloc(\n\t\tsizeof(*midi) + opts->in_ports * sizeof(*midi->in_ports_array),\n\t\tGFP_KERNEL);\n\tif (!midi) {\n\t\tstatus = -ENOMEM;\n\t\tgoto setup_fail;\n\t}\n\n\tfor (i = 0; i < opts->in_ports; i++)\n\t\tmidi->in_ports_array[i].cable = i;\n\n\t/* set up ALSA midi devices */\n\tmidi->id = kstrdup(opts->id, GFP_KERNEL);\n\tif (opts->id && !midi->id) {\n\t\tstatus = -ENOMEM;\n\t\tgoto setup_fail;\n\t}\n\tmidi->in_ports = opts->in_ports;\n\tmidi->out_ports = opts->out_ports;\n\tmidi->index = opts->index;\n\tmidi->buflen = opts->buflen;\n\tmidi->qlen = opts->qlen;\n\tmidi->in_last_port = 0;\n\tmidi->free_ref = 1;\n\n\tstatus = kfifo_alloc(&midi->in_req_fifo, midi->qlen, GFP_KERNEL);\n\tif (status)\n\t\tgoto setup_fail;\n\n\tspin_lock_init(&midi->transmit_lock);\n\n\t++opts->refcnt;\n\tmutex_unlock(&opts->lock);\n\n\tmidi->func.name\t\t= \"gmidi function\";\n\tmidi->func.bind\t\t= f_midi_bind;\n\tmidi->func.unbind\t= f_midi_unbind;\n\tmidi->func.set_alt\t= f_midi_set_alt;\n\tmidi->func.disable\t= f_midi_disable;\n\tmidi->func.free_func\t= f_midi_free;\n\n\treturn &midi->func;\n\nsetup_fail:\n\tmutex_unlock(&opts->lock);\n\tkfree(midi);\n\treturn ERR_PTR(status);\n}\n\nDECLARE_USB_FUNCTION_INIT(midi, f_midi_alloc_inst, f_midi_alloc);\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * u_f.h\n *\n * Utility definitions for USB functions\n *\n * Copyright (c) 2013 Samsung Electronics Co., Ltd.\n *\t\thttp://www.samsung.com\n *\n * Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>\n */\n\n#ifndef __U_F_H__\n#define __U_F_H__\n\n#include <linux/usb/gadget.h>\n\n/* Variable Length Array Macros **********************************************/\n#define vla_group(groupname) size_t groupname##__next = 0\n#define vla_group_size(groupname) groupname##__next\n\n#define vla_item(groupname, type, name, n) \\\n\tsize_t groupname##_##name##__offset = ({\t\t\t       \\\n\t\tsize_t align_mask = __alignof__(type) - 1;\t\t       \\\n\t\tsize_t offset = (groupname##__next + align_mask) & ~align_mask;\\\n\t\tsize_t size = (n) * sizeof(type);\t\t\t       \\\n\t\tgroupname##__next = offset + size;\t\t\t       \\\n\t\toffset;\t\t\t\t\t\t\t       \\\n\t})\n\n#define vla_item_with_sz(groupname, type, name, n) \\\n\tsize_t groupname##_##name##__sz = (n) * sizeof(type);\t\t       \\\n\tsize_t groupname##_##name##__offset = ({\t\t\t       \\\n\t\tsize_t align_mask = __alignof__(type) - 1;\t\t       \\\n\t\tsize_t offset = (groupname##__next + align_mask) & ~align_mask;\\\n\t\tsize_t size = groupname##_##name##__sz;\t\t\t       \\\n\t\tgroupname##__next = offset + size;\t\t\t       \\\n\t\toffset;\t\t\t\t\t\t\t       \\\n\t})\n\n#define vla_ptr(ptr, groupname, name) \\\n\t((void *) ((char *)ptr + groupname##_##name##__offset))\n\nstruct usb_ep;\nstruct usb_request;\n\n/**\n * alloc_ep_req - returns a usb_request allocated by the gadget driver and\n * allocates the request's buffer.\n *\n * @ep: the endpoint to allocate a usb_request\n * @len: usb_requests's buffer suggested size\n *\n * In case @ep direction is OUT, the @len will be aligned to ep's\n * wMaxPacketSize. In order to avoid memory leaks or drops, *always* use\n * usb_requests's length (req->length) to refer to the allocated buffer size.\n * Requests allocated via alloc_ep_req() *must* be freed by free_ep_req().\n */\nstruct usb_request *alloc_ep_req(struct usb_ep *ep, size_t len);\n\n/* Frees a usb_request previously allocated by alloc_ep_req() */\nstatic inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tWARN_ON(req->buf == NULL);\n\tkfree(req->buf);\n\treq->buf = NULL;\n\tusb_ep_free_request(ep, req);\n}\n\n#endif /* __U_F_H__ */\n"], "filenames": ["drivers/usb/gadget/function/f_midi.c", "drivers/usb/gadget/u_f.h"], "buggy_code_start_loc": [407, 63], "buggy_code_end_loc": [408, 64], "fixing_code_start_loc": [407, 64], "fixing_code_end_loc": [409, 67], "type": "CWE-415", "message": "In the Linux kernel before 4.16.4, a double free vulnerability in the f_midi_set_alt function of drivers/usb/gadget/function/f_midi.c in the f_midi driver may allow attackers to cause a denial of service or possibly have unspecified other impact.", "other": {"cve": {"id": "CVE-2018-20961", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-07T15:15:11.970", "lastModified": "2023-01-19T16:14:19.863", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.16.4, a double free vulnerability in the f_midi_set_alt function of drivers/usb/gadget/function/f_midi.c in the f_midi driver may allow attackers to cause a denial of service or possibly have unspecified other impact."}, {"lang": "es", "value": "En el kernel de Linux anterior a versi\u00f3n 4.16.4, una vulnerabilidad de doble liberaci\u00f3n en la funci\u00f3n f_midi_set_alt en el archivo drivers/usb/gadget/function/f_midi.c en el controlador f_midi puede permitir a los atacantes causar una denegaci\u00f3n de servicio o posiblemente tener otro impacto no especificado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4", "versionEndExcluding": "4.4.190", "matchCriteriaId": "B4959A27-4B2B-4E3B-BCD0-3FCD1D8C01BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.96", "matchCriteriaId": "B53B1E59-4500-4053-B7B7-FEF7DA398159"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.36", "matchCriteriaId": "3DE6B7F5-D741-4FC4-BA49-744A448BFDEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15.0", "versionEndExcluding": "4.16.4", "matchCriteriaId": "DFDF4D5A-6D0D-4548-9DB8-B799D018C6E2"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/154228/Slackware-Security-Advisory-Slackware-14.2-kernel-Updates.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/154951/Kernel-Live-Patch-Security-Notice-LSN-0058-1.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.16.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=7fafcfdf6377b18b2a726ea554d6e593ba44349f", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/7fafcfdf6377b18b2a726ea554d6e593ba44349f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Aug/48", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190905-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K58502654", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K58502654?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4145-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7fafcfdf6377b18b2a726ea554d6e593ba44349f"}}