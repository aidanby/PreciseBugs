{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ErrorHandler\\ErrorRenderer;\n\nuse Symfony\\Component\\ErrorHandler\\Exception\\FlattenException;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\Serializer\\Exception\\NotEncodableValueException;\nuse Symfony\\Component\\Serializer\\SerializerInterface;\n\n/**\n * Formats an exception using Serializer for rendering.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass SerializerErrorRenderer implements ErrorRendererInterface\n{\n    private $serializer;\n    private $format;\n    private $fallbackErrorRenderer;\n    private $debug;\n\n    /**\n     * @param string|callable(FlattenException) $format The format as a string or a callable that should return it\n     * @param bool|callable                     $debug  The debugging mode as a boolean or a callable that should return it\n     */\n    public function __construct(SerializerInterface $serializer, $format, ErrorRendererInterface $fallbackErrorRenderer = null, $debug = false)\n    {\n        if (!\\is_string($format) && !\\is_callable($format)) {\n            throw new \\TypeError(sprintf('Argument 2 passed to \"%s()\" must be a string or a callable, \"%s\" given.', __METHOD__, \\is_object($format) ? \\get_class($format) : \\gettype($format)));\n        }\n\n        if (!\\is_bool($debug) && !\\is_callable($debug)) {\n            throw new \\TypeError(sprintf('Argument 4 passed to \"%s()\" must be a boolean or a callable, \"%s\" given.', __METHOD__, \\is_object($debug) ? \\get_class($debug) : \\gettype($debug)));\n        }\n\n        $this->serializer = $serializer;\n        $this->format = $format;\n        $this->fallbackErrorRenderer = $fallbackErrorRenderer ?? new HtmlErrorRenderer();\n        $this->debug = $debug;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function render(\\Throwable $exception): FlattenException\n    {\n        $flattenException = FlattenException::createFromThrowable($exception);\n\n        try {\n            $format = \\is_string($this->format) ? $this->format : ($this->format)($flattenException);\n\n            return $flattenException->setAsString($this->serializer->serialize($flattenException, $format, [\n                'exception' => $exception,\n                'debug' => \\is_bool($this->debug) ? $this->debug : ($this->debug)($exception),\n            ]));\n        } catch (NotEncodableValueException $e) {\n            return $this->fallbackErrorRenderer->render($exception);\n        }\n    }\n\n    public static function getPreferredFormat(RequestStack $requestStack): \\Closure\n    {\n        return static function () use ($requestStack) {\n            if (!$request = $requestStack->getCurrentRequest()) {\n                throw new NotEncodableValueException();\n            }\n\n            return $request->getPreferredFormat();\n        };\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\SuspiciousOperationException;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(AcceptHeader::class);\nclass_exists(FileBag::class);\nclass_exists(HeaderBag::class);\nclass_exists(HeaderUtils::class);\nclass_exists(ParameterBag::class);\nclass_exists(ServerBag::class);\n\n/**\n * Request represents an HTTP request.\n *\n * The methods dealing with URL accept / return a raw path (% encoded):\n *   * getBasePath\n *   * getBaseUrl\n *   * getPathInfo\n *   * getRequestUri\n *   * getUri\n *   * getUriForPath\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Request\n{\n    const HEADER_FORWARDED = 0b00001; // When using RFC 7239\n    const HEADER_X_FORWARDED_FOR = 0b00010;\n    const HEADER_X_FORWARDED_HOST = 0b00100;\n    const HEADER_X_FORWARDED_PROTO = 0b01000;\n    const HEADER_X_FORWARDED_PORT = 0b10000;\n    const HEADER_X_FORWARDED_ALL = 0b11110; // All \"X-Forwarded-*\" headers\n    const HEADER_X_FORWARDED_AWS_ELB = 0b11010; // AWS ELB doesn't send X-Forwarded-Host\n\n    const METHOD_HEAD = 'HEAD';\n    const METHOD_GET = 'GET';\n    const METHOD_POST = 'POST';\n    const METHOD_PUT = 'PUT';\n    const METHOD_PATCH = 'PATCH';\n    const METHOD_DELETE = 'DELETE';\n    const METHOD_PURGE = 'PURGE';\n    const METHOD_OPTIONS = 'OPTIONS';\n    const METHOD_TRACE = 'TRACE';\n    const METHOD_CONNECT = 'CONNECT';\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedProxies = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHostPatterns = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHosts = [];\n\n    protected static $httpMethodParameterOverride = false;\n\n    /**\n     * Custom parameters.\n     *\n     * @var ParameterBag\n     */\n    public $attributes;\n\n    /**\n     * Request body parameters ($_POST).\n     *\n     * @var ParameterBag\n     */\n    public $request;\n\n    /**\n     * Query string parameters ($_GET).\n     *\n     * @var ParameterBag\n     */\n    public $query;\n\n    /**\n     * Server and execution environment parameters ($_SERVER).\n     *\n     * @var ServerBag\n     */\n    public $server;\n\n    /**\n     * Uploaded files ($_FILES).\n     *\n     * @var FileBag\n     */\n    public $files;\n\n    /**\n     * Cookies ($_COOKIE).\n     *\n     * @var ParameterBag\n     */\n    public $cookies;\n\n    /**\n     * Headers (taken from the $_SERVER).\n     *\n     * @var HeaderBag\n     */\n    public $headers;\n\n    /**\n     * @var string|resource|false|null\n     */\n    protected $content;\n\n    /**\n     * @var array\n     */\n    protected $languages;\n\n    /**\n     * @var array\n     */\n    protected $charsets;\n\n    /**\n     * @var array\n     */\n    protected $encodings;\n\n    /**\n     * @var array\n     */\n    protected $acceptableContentTypes;\n\n    /**\n     * @var string\n     */\n    protected $pathInfo;\n\n    /**\n     * @var string\n     */\n    protected $requestUri;\n\n    /**\n     * @var string\n     */\n    protected $baseUrl;\n\n    /**\n     * @var string\n     */\n    protected $basePath;\n\n    /**\n     * @var string\n     */\n    protected $method;\n\n    /**\n     * @var string\n     */\n    protected $format;\n\n    /**\n     * @var SessionInterface\n     */\n    protected $session;\n\n    /**\n     * @var string\n     */\n    protected $locale;\n\n    /**\n     * @var string\n     */\n    protected $defaultLocale = 'en';\n\n    /**\n     * @var array\n     */\n    protected static $formats;\n\n    protected static $requestFactory;\n\n    /**\n     * @var string|null\n     */\n    private $preferredFormat;\n    private $isHostValid = true;\n    private $isForwardedValid = true;\n\n    private static $trustedHeaderSet = -1;\n\n    private static $forwardedParams = [\n        self::HEADER_X_FORWARDED_FOR => 'for',\n        self::HEADER_X_FORWARDED_HOST => 'host',\n        self::HEADER_X_FORWARDED_PROTO => 'proto',\n        self::HEADER_X_FORWARDED_PORT => 'host',\n    ];\n\n    /**\n     * Names for headers that can be trusted when\n     * using trusted proxies.\n     *\n     * The FORWARDED header is the standard as of rfc7239.\n     *\n     * The other headers are non-standard, but widely used\n     * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).\n     */\n    private static $trustedHeaders = [\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_X_FORWARDED_FOR => 'X_FORWARDED_FOR',\n        self::HEADER_X_FORWARDED_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_X_FORWARDED_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_X_FORWARDED_PORT => 'X_FORWARDED_PORT',\n    ];\n\n    /**\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function __construct(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets the parameters for this request.\n     *\n     * This method also re-initializes all properties.\n     *\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function initialize(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->request = new ParameterBag($request);\n        $this->query = new ParameterBag($query);\n        $this->attributes = new ParameterBag($attributes);\n        $this->cookies = new ParameterBag($cookies);\n        $this->files = new FileBag($files);\n        $this->server = new ServerBag($server);\n        $this->headers = new HeaderBag($this->server->getHeaders());\n\n        $this->content = $content;\n        $this->languages = null;\n        $this->charsets = null;\n        $this->encodings = null;\n        $this->acceptableContentTypes = null;\n        $this->pathInfo = null;\n        $this->requestUri = null;\n        $this->baseUrl = null;\n        $this->basePath = null;\n        $this->method = null;\n        $this->format = null;\n    }\n\n    /**\n     * Creates a new request with values from PHP's super globals.\n     *\n     * @return static\n     */\n    public static function createFromGlobals()\n    {\n        $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);\n\n        if (0 === strpos($request->headers->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded')\n            && \\in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])\n        ) {\n            parse_str($request->getContent(), $data);\n            $request->request = new ParameterBag($data);\n        }\n\n        return $request;\n    }\n\n    /**\n     * Creates a Request based on a given URI and configuration.\n     *\n     * The information contained in the URI always take precedence\n     * over the other information (server and parameters).\n     *\n     * @param string               $uri        The URI\n     * @param string               $method     The HTTP method\n     * @param array                $parameters The query (GET) or request (POST) parameters\n     * @param array                $cookies    The request cookies ($_COOKIE)\n     * @param array                $files      The request files ($_FILES)\n     * @param array                $server     The server parameters ($_SERVER)\n     * @param string|resource|null $content    The raw body data\n     *\n     * @return static\n     */\n    public static function create($uri, $method = 'GET', $parameters = [], $cookies = [], $files = [], $server = [], $content = null)\n    {\n        $server = array_replace([\n            'SERVER_NAME' => 'localhost',\n            'SERVER_PORT' => 80,\n            'HTTP_HOST' => 'localhost',\n            'HTTP_USER_AGENT' => 'Symfony',\n            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',\n            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '',\n            'SCRIPT_FILENAME' => '',\n            'SERVER_PROTOCOL' => 'HTTP/1.1',\n            'REQUEST_TIME' => time(),\n        ], $server);\n\n        $server['PATH_INFO'] = '';\n        $server['REQUEST_METHOD'] = strtoupper($method);\n\n        $components = parse_url($uri);\n        if (isset($components['host'])) {\n            $server['SERVER_NAME'] = $components['host'];\n            $server['HTTP_HOST'] = $components['host'];\n        }\n\n        if (isset($components['scheme'])) {\n            if ('https' === $components['scheme']) {\n                $server['HTTPS'] = 'on';\n                $server['SERVER_PORT'] = 443;\n            } else {\n                unset($server['HTTPS']);\n                $server['SERVER_PORT'] = 80;\n            }\n        }\n\n        if (isset($components['port'])) {\n            $server['SERVER_PORT'] = $components['port'];\n            $server['HTTP_HOST'] .= ':'.$components['port'];\n        }\n\n        if (isset($components['user'])) {\n            $server['PHP_AUTH_USER'] = $components['user'];\n        }\n\n        if (isset($components['pass'])) {\n            $server['PHP_AUTH_PW'] = $components['pass'];\n        }\n\n        if (!isset($components['path'])) {\n            $components['path'] = '/';\n        }\n\n        switch (strtoupper($method)) {\n            case 'POST':\n            case 'PUT':\n            case 'DELETE':\n                if (!isset($server['CONTENT_TYPE'])) {\n                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n                }\n                // no break\n            case 'PATCH':\n                $request = $parameters;\n                $query = [];\n                break;\n            default:\n                $request = [];\n                $query = $parameters;\n                break;\n        }\n\n        $queryString = '';\n        if (isset($components['query'])) {\n            parse_str(html_entity_decode($components['query']), $qs);\n\n            if ($query) {\n                $query = array_replace($qs, $query);\n                $queryString = http_build_query($query, '', '&');\n            } else {\n                $query = $qs;\n                $queryString = $components['query'];\n            }\n        } elseif ($query) {\n            $queryString = http_build_query($query, '', '&');\n        }\n\n        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');\n        $server['QUERY_STRING'] = $queryString;\n\n        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets a callable able to create a Request instance.\n     *\n     * This is mainly useful when you need to override the Request class\n     * to keep BC with an existing system. It should not be used for any\n     * other purpose.\n     *\n     * @param callable|null $callable A PHP callable\n     */\n    public static function setFactory($callable)\n    {\n        self::$requestFactory = $callable;\n    }\n\n    /**\n     * Clones a request and overrides some of its parameters.\n     *\n     * @param array $query      The GET parameters\n     * @param array $request    The POST parameters\n     * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array $cookies    The COOKIE parameters\n     * @param array $files      The FILES parameters\n     * @param array $server     The SERVER parameters\n     *\n     * @return static\n     */\n    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)\n    {\n        $dup = clone $this;\n        if (null !== $query) {\n            $dup->query = new ParameterBag($query);\n        }\n        if (null !== $request) {\n            $dup->request = new ParameterBag($request);\n        }\n        if (null !== $attributes) {\n            $dup->attributes = new ParameterBag($attributes);\n        }\n        if (null !== $cookies) {\n            $dup->cookies = new ParameterBag($cookies);\n        }\n        if (null !== $files) {\n            $dup->files = new FileBag($files);\n        }\n        if (null !== $server) {\n            $dup->server = new ServerBag($server);\n            $dup->headers = new HeaderBag($dup->server->getHeaders());\n        }\n        $dup->languages = null;\n        $dup->charsets = null;\n        $dup->encodings = null;\n        $dup->acceptableContentTypes = null;\n        $dup->pathInfo = null;\n        $dup->requestUri = null;\n        $dup->baseUrl = null;\n        $dup->basePath = null;\n        $dup->method = null;\n        $dup->format = null;\n\n        if (!$dup->get('_format') && $this->get('_format')) {\n            $dup->attributes->set('_format', $this->get('_format'));\n        }\n\n        if (!$dup->getRequestFormat(null)) {\n            $dup->setRequestFormat($this->getRequestFormat(null));\n        }\n\n        return $dup;\n    }\n\n    /**\n     * Clones the current request.\n     *\n     * Note that the session is not cloned as duplicated requests\n     * are most of the time sub-requests of the main one.\n     */\n    public function __clone()\n    {\n        $this->query = clone $this->query;\n        $this->request = clone $this->request;\n        $this->attributes = clone $this->attributes;\n        $this->cookies = clone $this->cookies;\n        $this->files = clone $this->files;\n        $this->server = clone $this->server;\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Returns the request as a string.\n     *\n     * @return string The request\n     */\n    public function __toString()\n    {\n        try {\n            $content = $this->getContent();\n        } catch (\\LogicException $e) {\n            if (\\PHP_VERSION_ID >= 70400) {\n                throw $e;\n            }\n\n            return trigger_error($e, E_USER_ERROR);\n        }\n\n        $cookieHeader = '';\n        $cookies = [];\n\n        foreach ($this->cookies as $k => $v) {\n            $cookies[] = $k.'='.$v;\n        }\n\n        if (!empty($cookies)) {\n            $cookieHeader = 'Cookie: '.implode('; ', $cookies).\"\\r\\n\";\n        }\n\n        return\n            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).\"\\r\\n\".\n            $this->headers.\n            $cookieHeader.\"\\r\\n\".\n            $content;\n    }\n\n    /**\n     * Overrides the PHP global variables according to this request instance.\n     *\n     * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n     * $_FILES is never overridden, see rfc1867\n     */\n    public function overrideGlobals()\n    {\n        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));\n\n        $_GET = $this->query->all();\n        $_POST = $this->request->all();\n        $_SERVER = $this->server->all();\n        $_COOKIE = $this->cookies->all();\n\n        foreach ($this->headers->all() as $key => $value) {\n            $key = strtoupper(str_replace('-', '_', $key));\n            if (\\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {\n                $_SERVER[$key] = implode(', ', $value);\n            } else {\n                $_SERVER['HTTP_'.$key] = implode(', ', $value);\n            }\n        }\n\n        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];\n\n        $requestOrder = ini_get('request_order') ?: ini_get('variables_order');\n        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';\n\n        $_REQUEST = [[]];\n\n        foreach (str_split($requestOrder) as $order) {\n            $_REQUEST[] = $request[$order];\n        }\n\n        $_REQUEST = array_merge(...$_REQUEST);\n    }\n\n    /**\n     * Sets a list of trusted proxies.\n     *\n     * You should only list the reverse proxies that you manage directly.\n     *\n     * @param array $proxies          A list of trusted proxies, the string 'REMOTE_ADDR' will be replaced with $_SERVER['REMOTE_ADDR']\n     * @param int   $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies\n     *\n     * @throws \\InvalidArgumentException When $trustedHeaderSet is invalid\n     */\n    public static function setTrustedProxies(array $proxies, int $trustedHeaderSet)\n    {\n        self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {\n            if ('REMOTE_ADDR' !== $proxy) {\n                $proxies[] = $proxy;\n            } elseif (isset($_SERVER['REMOTE_ADDR'])) {\n                $proxies[] = $_SERVER['REMOTE_ADDR'];\n            }\n\n            return $proxies;\n        }, []);\n        self::$trustedHeaderSet = $trustedHeaderSet;\n    }\n\n    /**\n     * Gets the list of trusted proxies.\n     *\n     * @return array An array of trusted proxies\n     */\n    public static function getTrustedProxies()\n    {\n        return self::$trustedProxies;\n    }\n\n    /**\n     * Gets the set of trusted headers from trusted proxies.\n     *\n     * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies\n     */\n    public static function getTrustedHeaderSet()\n    {\n        return self::$trustedHeaderSet;\n    }\n\n    /**\n     * Sets a list of trusted host patterns.\n     *\n     * You should only list the hosts you manage using regexs.\n     *\n     * @param array $hostPatterns A list of trusted host patterns\n     */\n    public static function setTrustedHosts(array $hostPatterns)\n    {\n        self::$trustedHostPatterns = array_map(function ($hostPattern) {\n            return sprintf('{%s}i', $hostPattern);\n        }, $hostPatterns);\n        // we need to reset trusted hosts on trusted host patterns change\n        self::$trustedHosts = [];\n    }\n\n    /**\n     * Gets the list of trusted host patterns.\n     *\n     * @return array An array of trusted host patterns\n     */\n    public static function getTrustedHosts()\n    {\n        return self::$trustedHostPatterns;\n    }\n\n    /**\n     * Normalizes a query string.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized,\n     * have consistent escaping and unneeded delimiters are removed.\n     *\n     * @param string $qs Query string\n     *\n     * @return string A normalized query string for the Request\n     */\n    public static function normalizeQueryString($qs)\n    {\n        if ('' === ($qs ?? '')) {\n            return '';\n        }\n\n        parse_str($qs, $qs);\n        ksort($qs);\n\n        return http_build_query($qs, '', '&', PHP_QUERY_RFC3986);\n    }\n\n    /**\n     * Enables support for the _method request parameter to determine the intended HTTP method.\n     *\n     * Be warned that enabling this feature might lead to CSRF issues in your code.\n     * Check that you are using CSRF tokens when required.\n     * If the HTTP method parameter override is enabled, an html-form with method \"POST\" can be altered\n     * and used to send a \"PUT\" or \"DELETE\" request via the _method request parameter.\n     * If these methods are not protected against CSRF, this presents a possible vulnerability.\n     *\n     * The HTTP method can only be overridden when the real HTTP method is POST.\n     */\n    public static function enableHttpMethodParameterOverride()\n    {\n        self::$httpMethodParameterOverride = true;\n    }\n\n    /**\n     * Checks whether support for the _method request parameter is enabled.\n     *\n     * @return bool True when the _method request parameter is enabled, false otherwise\n     */\n    public static function getHttpMethodParameterOverride()\n    {\n        return self::$httpMethodParameterOverride;\n    }\n\n    /**\n     * Gets a \"parameter\" value from any bag.\n     *\n     * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the\n     * flexibility in controllers, it is better to explicitly get request parameters from the appropriate\n     * public property instead (attributes, query, request).\n     *\n     * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY\n     *\n     * @param string $key     The key\n     * @param mixed  $default The default value if the parameter key does not exist\n     *\n     * @return mixed\n     */\n    public function get($key, $default = null)\n    {\n        if ($this !== $result = $this->attributes->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->query->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->request->get($key, $this)) {\n            return $result;\n        }\n\n        return $default;\n    }\n\n    /**\n     * Gets the Session.\n     *\n     * @return SessionInterface The session\n     */\n    public function getSession()\n    {\n        $session = $this->session;\n        if (!$session instanceof SessionInterface && null !== $session) {\n            $this->setSession($session = $session());\n        }\n\n        if (null === $session) {\n            @trigger_error(sprintf('Calling \"%s()\" when no session has been set is deprecated since Symfony 4.1 and will throw an exception in 5.0. Use \"hasSession()\" instead.', __METHOD__), E_USER_DEPRECATED);\n            // throw new \\BadMethodCallException('Session has not been set.');\n        }\n\n        return $session;\n    }\n\n    /**\n     * Whether the request contains a Session which was started in one of the\n     * previous requests.\n     *\n     * @return bool\n     */\n    public function hasPreviousSession()\n    {\n        // the check for $this->session avoids malicious users trying to fake a session cookie with proper name\n        return $this->hasSession() && $this->cookies->has($this->getSession()->getName());\n    }\n\n    /**\n     * Whether the request contains a Session object.\n     *\n     * This method does not give any information about the state of the session object,\n     * like whether the session is started or not. It is just a way to check if this Request\n     * is associated with a Session instance.\n     *\n     * @return bool true when the Request contains a Session object, false otherwise\n     */\n    public function hasSession()\n    {\n        return null !== $this->session;\n    }\n\n    public function setSession(SessionInterface $session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * @internal\n     */\n    public function setSessionFactory(callable $factory)\n    {\n        $this->session = $factory;\n    }\n\n    /**\n     * Returns the client IP addresses.\n     *\n     * In the returned array the most trusted IP address is first, and the\n     * least trusted one last. The \"real\" client IP address is the last one,\n     * but this is also the least trusted one. Trusted proxies are stripped.\n     *\n     * Use this method carefully; you should use getClientIp() instead.\n     *\n     * @return array The client IP addresses\n     *\n     * @see getClientIp()\n     */\n    public function getClientIps()\n    {\n        $ip = $this->server->get('REMOTE_ADDR');\n\n        if (!$this->isFromTrustedProxy()) {\n            return [$ip];\n        }\n\n        return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];\n    }\n\n    /**\n     * Returns the client IP address.\n     *\n     * This method can read the client IP address from the \"X-Forwarded-For\" header\n     * when trusted proxies were set via \"setTrustedProxies()\". The \"X-Forwarded-For\"\n     * header value is a comma+space separated list of IP addresses, the left-most\n     * being the original client, and each successive proxy that passed the request\n     * adding the IP address where it received the request from.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-For\",\n     * (\"Client-Ip\" for instance), configure it via the $trustedHeaderSet\n     * argument of the Request::setTrustedProxies() method instead.\n     *\n     * @return string|null The client IP address\n     *\n     * @see getClientIps()\n     * @see https://wikipedia.org/wiki/X-Forwarded-For\n     */\n    public function getClientIp()\n    {\n        $ipAddresses = $this->getClientIps();\n\n        return $ipAddresses[0];\n    }\n\n    /**\n     * Returns current script name.\n     *\n     * @return string\n     */\n    public function getScriptName()\n    {\n        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));\n    }\n\n    /**\n     * Returns the path being requested relative to the executed script.\n     *\n     * The path info always starts with a /.\n     *\n     * Suppose this request is instantiated from /mysite on localhost:\n     *\n     *  * http://localhost/mysite              returns an empty string\n     *  * http://localhost/mysite/about        returns '/about'\n     *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'\n     *  * http://localhost/mysite/about?var=1  returns '/about'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getPathInfo()\n    {\n        if (null === $this->pathInfo) {\n            $this->pathInfo = $this->preparePathInfo();\n        }\n\n        return $this->pathInfo;\n    }\n\n    /**\n     * Returns the root path from which this request is executed.\n     *\n     * Suppose that an index.php file instantiates this request object:\n     *\n     *  * http://localhost/index.php         returns an empty string\n     *  * http://localhost/index.php/page    returns an empty string\n     *  * http://localhost/web/index.php     returns '/web'\n     *  * http://localhost/we%20b/index.php  returns '/we%20b'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getBasePath()\n    {\n        if (null === $this->basePath) {\n            $this->basePath = $this->prepareBasePath();\n        }\n\n        return $this->basePath;\n    }\n\n    /**\n     * Returns the root URL from which this request is executed.\n     *\n     * The base URL never ends with a /.\n     *\n     * This is similar to getBasePath(), except that it also includes the\n     * script filename (e.g. index.php) if one exists.\n     *\n     * @return string The raw URL (i.e. not urldecoded)\n     */\n    public function getBaseUrl()\n    {\n        if (null === $this->baseUrl) {\n            $this->baseUrl = $this->prepareBaseUrl();\n        }\n\n        return $this->baseUrl;\n    }\n\n    /**\n     * Gets the request's scheme.\n     *\n     * @return string\n     */\n    public function getScheme()\n    {\n        return $this->isSecure() ? 'https' : 'http';\n    }\n\n    /**\n     * Returns the port on which the request is made.\n     *\n     * This method can read the client port from the \"X-Forwarded-Port\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Port\" header must contain the client port.\n     *\n     * @return int|string can be a string if fetched from the server bag\n     */\n    public function getPort()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {\n            $host = $host[0];\n        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            return $this->server->get('SERVER_PORT');\n        }\n\n        if ('[' === $host[0]) {\n            $pos = strpos($host, ':', strrpos($host, ']'));\n        } else {\n            $pos = strrpos($host, ':');\n        }\n\n        if (false !== $pos && $port = substr($host, $pos + 1)) {\n            return (int) $port;\n        }\n\n        return 'https' === $this->getScheme() ? 443 : 80;\n    }\n\n    /**\n     * Returns the user.\n     *\n     * @return string|null\n     */\n    public function getUser()\n    {\n        return $this->headers->get('PHP_AUTH_USER');\n    }\n\n    /**\n     * Returns the password.\n     *\n     * @return string|null\n     */\n    public function getPassword()\n    {\n        return $this->headers->get('PHP_AUTH_PW');\n    }\n\n    /**\n     * Gets the user info.\n     *\n     * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server\n     */\n    public function getUserInfo()\n    {\n        $userinfo = $this->getUser();\n\n        $pass = $this->getPassword();\n        if ('' != $pass) {\n            $userinfo .= \":$pass\";\n        }\n\n        return $userinfo;\n    }\n\n    /**\n     * Returns the HTTP host being requested.\n     *\n     * The port name will be appended to the host if it's non-standard.\n     *\n     * @return string\n     */\n    public function getHttpHost()\n    {\n        $scheme = $this->getScheme();\n        $port = $this->getPort();\n\n        if (('http' == $scheme && 80 == $port) || ('https' == $scheme && 443 == $port)) {\n            return $this->getHost();\n        }\n\n        return $this->getHost().':'.$port;\n    }\n\n    /**\n     * Returns the requested URI (path and query string).\n     *\n     * @return string The raw URI (i.e. not URI decoded)\n     */\n    public function getRequestUri()\n    {\n        if (null === $this->requestUri) {\n            $this->requestUri = $this->prepareRequestUri();\n        }\n\n        return $this->requestUri;\n    }\n\n    /**\n     * Gets the scheme and HTTP host.\n     *\n     * If the URL was called with basic authentication, the user\n     * and the password are not added to the generated string.\n     *\n     * @return string The scheme and HTTP host\n     */\n    public function getSchemeAndHttpHost()\n    {\n        return $this->getScheme().'://'.$this->getHttpHost();\n    }\n\n    /**\n     * Generates a normalized URI (URL) for the Request.\n     *\n     * @return string A normalized URI (URL) for the Request\n     *\n     * @see getQueryString()\n     */\n    public function getUri()\n    {\n        if (null !== $qs = $this->getQueryString()) {\n            $qs = '?'.$qs;\n        }\n\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;\n    }\n\n    /**\n     * Generates a normalized URI for the given path.\n     *\n     * @param string $path A path to use instead of the current one\n     *\n     * @return string The normalized URI for the path\n     */\n    public function getUriForPath($path)\n    {\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;\n    }\n\n    /**\n     * Returns the path as relative reference from the current Request path.\n     *\n     * Only the URIs path component (no schema, host etc.) is relevant and must be given.\n     * Both paths must be absolute and not contain relative parts.\n     * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n     * Furthermore, they can be used to reduce the link size in documents.\n     *\n     * Example target paths, given a base path of \"/a/b/c/d\":\n     * - \"/a/b/c/d\"     -> \"\"\n     * - \"/a/b/c/\"      -> \"./\"\n     * - \"/a/b/\"        -> \"../\"\n     * - \"/a/b/c/other\" -> \"other\"\n     * - \"/a/x/y\"       -> \"../../x/y\"\n     *\n     * @param string $path The target path\n     *\n     * @return string The relative target path\n     */\n    public function getRelativeUriForPath($path)\n    {\n        // be sure that we are dealing with an absolute path\n        if (!isset($path[0]) || '/' !== $path[0]) {\n            return $path;\n        }\n\n        if ($path === $basePath = $this->getPathInfo()) {\n            return '';\n        }\n\n        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);\n        $targetDirs = explode('/', substr($path, 1));\n        array_pop($sourceDirs);\n        $targetFile = array_pop($targetDirs);\n\n        foreach ($sourceDirs as $i => $dir) {\n            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {\n                unset($sourceDirs[$i], $targetDirs[$i]);\n            } else {\n                break;\n            }\n        }\n\n        $targetDirs[] = $targetFile;\n        $path = str_repeat('../', \\count($sourceDirs)).implode('/', $targetDirs);\n\n        // A reference to the same base directory or an empty subdirectory must be prefixed with \"./\".\n        // This also applies to a segment with a colon character (e.g., \"file:colon\") that cannot be used\n        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name\n        // (see https://tools.ietf.org/html/rfc3986#section-4.2).\n        return !isset($path[0]) || '/' === $path[0]\n            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)\n            ? \"./$path\" : $path;\n    }\n\n    /**\n     * Generates the normalized query string for the Request.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized\n     * and have consistent escaping.\n     *\n     * @return string|null A normalized query string for the Request\n     */\n    public function getQueryString()\n    {\n        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));\n\n        return '' === $qs ? null : $qs;\n    }\n\n    /**\n     * Checks whether the request is secure or not.\n     *\n     * This method can read the client protocol from the \"X-Forwarded-Proto\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Proto\" header must contain the protocol: \"https\" or \"http\".\n     *\n     * @return bool\n     */\n    public function isSecure()\n    {\n        if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_X_FORWARDED_PROTO)) {\n            return \\in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);\n        }\n\n        $https = $this->server->get('HTTPS');\n\n        return !empty($https) && 'off' !== strtolower($https);\n    }\n\n    /**\n     * Returns the host name.\n     *\n     * This method can read the client host name from the \"X-Forwarded-Host\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Host\" header must contain the client host name.\n     *\n     * @return string\n     *\n     * @throws SuspiciousOperationException when the host name is invalid or not trusted\n     */\n    public function getHost()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            if (!$host = $this->server->get('SERVER_NAME')) {\n                $host = $this->server->get('SERVER_ADDR', '');\n            }\n        }\n\n        // trim and remove port number from host\n        // host is lowercase as per RFC 952/2181\n        $host = strtolower(preg_replace('/:\\d+$/', '', trim($host)));\n\n        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)\n        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)\n        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names\n        if ($host && '' !== preg_replace('/(?:^\\[)?[a-zA-Z0-9-:\\]_]+\\.?/', '', $host)) {\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Invalid Host \"%s\".', $host));\n        }\n\n        if (\\count(self::$trustedHostPatterns) > 0) {\n            // to avoid host header injection attacks, you should provide a list of trusted host patterns\n\n            if (\\in_array($host, self::$trustedHosts)) {\n                return $host;\n            }\n\n            foreach (self::$trustedHostPatterns as $pattern) {\n                if (preg_match($pattern, $host)) {\n                    self::$trustedHosts[] = $host;\n\n                    return $host;\n                }\n            }\n\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Untrusted Host \"%s\".', $host));\n        }\n\n        return $host;\n    }\n\n    /**\n     * Sets the request method.\n     *\n     * @param string $method\n     */\n    public function setMethod($method)\n    {\n        $this->method = null;\n        $this->server->set('REQUEST_METHOD', $method);\n    }\n\n    /**\n     * Gets the request \"intended\" method.\n     *\n     * If the X-HTTP-Method-Override header is set, and if the method is a POST,\n     * then it is used to determine the \"real\" intended HTTP method.\n     *\n     * The _method request parameter can also be used to determine the HTTP method,\n     * but only if enableHttpMethodParameterOverride() has been called.\n     *\n     * The method is always an uppercased string.\n     *\n     * @return string The request method\n     *\n     * @see getRealMethod()\n     */\n    public function getMethod()\n    {\n        if (null !== $this->method) {\n            return $this->method;\n        }\n\n        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n\n        if ('POST' !== $this->method) {\n            return $this->method;\n        }\n\n        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');\n\n        if (!$method && self::$httpMethodParameterOverride) {\n            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));\n        }\n\n        if (!\\is_string($method)) {\n            return $this->method;\n        }\n\n        $method = strtoupper($method);\n\n        if (\\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {\n            return $this->method = $method;\n        }\n\n        if (!preg_match('/^[A-Z]++$/D', $method)) {\n            throw new SuspiciousOperationException(sprintf('Invalid method override \"%s\".', $method));\n        }\n\n        return $this->method = $method;\n    }\n\n    /**\n     * Gets the \"real\" request method.\n     *\n     * @return string The request method\n     *\n     * @see getMethod()\n     */\n    public function getRealMethod()\n    {\n        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n    }\n\n    /**\n     * Gets the mime type associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return string|null The associated mime type (null if not found)\n     */\n    public function getMimeType($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;\n    }\n\n    /**\n     * Gets the mime types associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return array The associated mime types\n     */\n    public static function getMimeTypes($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format] : [];\n    }\n\n    /**\n     * Gets the format associated with the mime type.\n     *\n     * @param string $mimeType The associated mime type\n     *\n     * @return string|null The format (null if not found)\n     */\n    public function getFormat($mimeType)\n    {\n        $canonicalMimeType = null;\n        if (false !== $pos = strpos($mimeType, ';')) {\n            $canonicalMimeType = trim(substr($mimeType, 0, $pos));\n        }\n\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        foreach (static::$formats as $format => $mimeTypes) {\n            if (\\in_array($mimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n            if (null !== $canonicalMimeType && \\in_array($canonicalMimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Associates a format with mime types.\n     *\n     * @param string       $format    The format\n     * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)\n     */\n    public function setFormat($format, $mimeTypes)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        static::$formats[$format] = \\is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];\n    }\n\n    /**\n     * Gets the request format.\n     *\n     * Here is the process to determine the format:\n     *\n     *  * format defined by the user (with setRequestFormat())\n     *  * _format request attribute\n     *  * $default\n     *\n     * @see getPreferredFormat\n     *\n     * @param string|null $default The default format\n     *\n     * @return string|null The request format\n     */\n    public function getRequestFormat($default = 'html')\n    {\n        if (null === $this->format) {\n            $this->format = $this->attributes->get('_format');\n        }\n\n        return null === $this->format ? $default : $this->format;\n    }\n\n    /**\n     * Sets the request format.\n     *\n     * @param string $format The request format\n     */\n    public function setRequestFormat($format)\n    {\n        $this->format = $format;\n    }\n\n    /**\n     * Gets the format associated with the request.\n     *\n     * @return string|null The format (null if no content type is present)\n     */\n    public function getContentType()\n    {\n        return $this->getFormat($this->headers->get('CONTENT_TYPE'));\n    }\n\n    /**\n     * Sets the default locale.\n     *\n     * @param string $locale\n     */\n    public function setDefaultLocale($locale)\n    {\n        $this->defaultLocale = $locale;\n\n        if (null === $this->locale) {\n            $this->setPhpDefaultLocale($locale);\n        }\n    }\n\n    /**\n     * Get the default locale.\n     *\n     * @return string\n     */\n    public function getDefaultLocale()\n    {\n        return $this->defaultLocale;\n    }\n\n    /**\n     * Sets the locale.\n     *\n     * @param string $locale\n     */\n    public function setLocale($locale)\n    {\n        $this->setPhpDefaultLocale($this->locale = $locale);\n    }\n\n    /**\n     * Get the locale.\n     *\n     * @return string\n     */\n    public function getLocale()\n    {\n        return null === $this->locale ? $this->defaultLocale : $this->locale;\n    }\n\n    /**\n     * Checks if the request method is of specified type.\n     *\n     * @param string $method Uppercase request method (GET, POST etc)\n     *\n     * @return bool\n     */\n    public function isMethod($method)\n    {\n        return $this->getMethod() === strtoupper($method);\n    }\n\n    /**\n     * Checks whether or not the method is safe.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.1\n     *\n     * @return bool\n     */\n    public function isMethodSafe()\n    {\n        if (\\func_num_args() > 0) {\n            @trigger_error(sprintf('Passing arguments to \"%s()\" has been deprecated since Symfony 4.4; use \"%s::isMethodCacheable()\" to check if the method is cacheable instead.', __METHOD__, __CLASS__), E_USER_DEPRECATED);\n        }\n\n        return \\in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);\n    }\n\n    /**\n     * Checks whether or not the method is idempotent.\n     *\n     * @return bool\n     */\n    public function isMethodIdempotent()\n    {\n        return \\in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);\n    }\n\n    /**\n     * Checks whether the method is cacheable or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.3\n     *\n     * @return bool True for GET and HEAD, false otherwise\n     */\n    public function isMethodCacheable()\n    {\n        return \\in_array($this->getMethod(), ['GET', 'HEAD']);\n    }\n\n    /**\n     * Returns the protocol version.\n     *\n     * If the application is behind a proxy, the protocol version used in the\n     * requests between the client and the proxy and between the proxy and the\n     * server might be different. This returns the former (from the \"Via\" header)\n     * if the proxy is trusted (see \"setTrustedProxies()\"), otherwise it returns\n     * the latter (from the \"SERVER_PROTOCOL\" server parameter).\n     *\n     * @return string\n     */\n    public function getProtocolVersion()\n    {\n        if ($this->isFromTrustedProxy()) {\n            preg_match('~^(HTTP/)?([1-9]\\.[0-9]) ~', $this->headers->get('Via'), $matches);\n\n            if ($matches) {\n                return 'HTTP/'.$matches[2];\n            }\n        }\n\n        return $this->server->get('SERVER_PROTOCOL');\n    }\n\n    /**\n     * Returns the request body content.\n     *\n     * @param bool $asResource If true, a resource will be returned\n     *\n     * @return string|resource The request body content or a resource to read the body stream\n     *\n     * @throws \\LogicException\n     */\n    public function getContent($asResource = false)\n    {\n        $currentContentIsResource = \\is_resource($this->content);\n\n        if (true === $asResource) {\n            if ($currentContentIsResource) {\n                rewind($this->content);\n\n                return $this->content;\n            }\n\n            // Content passed in parameter (test)\n            if (\\is_string($this->content)) {\n                $resource = fopen('php://temp', 'r+');\n                fwrite($resource, $this->content);\n                rewind($resource);\n\n                return $resource;\n            }\n\n            $this->content = false;\n\n            return fopen('php://input', 'rb');\n        }\n\n        if ($currentContentIsResource) {\n            rewind($this->content);\n\n            return stream_get_contents($this->content);\n        }\n\n        if (null === $this->content || false === $this->content) {\n            $this->content = file_get_contents('php://input');\n        }\n\n        return $this->content;\n    }\n\n    /**\n     * Gets the Etags.\n     *\n     * @return array The entity tags\n     */\n    public function getETags()\n    {\n        return preg_split('/\\s*,\\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY);\n    }\n\n    /**\n     * @return bool\n     */\n    public function isNoCache()\n    {\n        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');\n    }\n\n    /**\n     * Gets the preferred format for the response by inspecting, in the following order:\n     *   * the request format set using setRequestFormat\n     *   * the values of the Accept HTTP header\n     *   * the content type of the body of the request.\n     */\n    public function getPreferredFormat(?string $default = 'html'): ?string\n    {\n        if (null !== $this->preferredFormat || null !== $this->preferredFormat = $this->getRequestFormat(null)) {\n            return $this->preferredFormat;\n        }\n\n        foreach ($this->getAcceptableContentTypes() as $mimeType) {\n            if ($this->preferredFormat = $this->getFormat($mimeType)) {\n                return $this->preferredFormat;\n            }\n        }\n\n        return $default;\n    }\n\n    /**\n     * Returns the preferred language.\n     *\n     * @param string[] $locales An array of ordered available locales\n     *\n     * @return string|null The preferred locale\n     */\n    public function getPreferredLanguage(array $locales = null)\n    {\n        $preferredLanguages = $this->getLanguages();\n\n        if (empty($locales)) {\n            return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;\n        }\n\n        if (!$preferredLanguages) {\n            return $locales[0];\n        }\n\n        $extendedPreferredLanguages = [];\n        foreach ($preferredLanguages as $language) {\n            $extendedPreferredLanguages[] = $language;\n            if (false !== $position = strpos($language, '_')) {\n                $superLanguage = substr($language, 0, $position);\n                if (!\\in_array($superLanguage, $preferredLanguages)) {\n                    $extendedPreferredLanguages[] = $superLanguage;\n                }\n            }\n        }\n\n        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));\n\n        return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];\n    }\n\n    /**\n     * Gets a list of languages acceptable by the client browser.\n     *\n     * @return array Languages ordered in the user browser preferences\n     */\n    public function getLanguages()\n    {\n        if (null !== $this->languages) {\n            return $this->languages;\n        }\n\n        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();\n        $this->languages = [];\n        foreach ($languages as $lang => $acceptHeaderItem) {\n            if (false !== strpos($lang, '-')) {\n                $codes = explode('-', $lang);\n                if ('i' === $codes[0]) {\n                    // Language not listed in ISO 639 that are not variants\n                    // of any listed language, which can be registered with the\n                    // i-prefix, such as i-cherokee\n                    if (\\count($codes) > 1) {\n                        $lang = $codes[1];\n                    }\n                } else {\n                    for ($i = 0, $max = \\count($codes); $i < $max; ++$i) {\n                        if (0 === $i) {\n                            $lang = strtolower($codes[0]);\n                        } else {\n                            $lang .= '_'.strtoupper($codes[$i]);\n                        }\n                    }\n                }\n            }\n\n            $this->languages[] = $lang;\n        }\n\n        return $this->languages;\n    }\n\n    /**\n     * Gets a list of charsets acceptable by the client browser.\n     *\n     * @return array List of charsets in preferable order\n     */\n    public function getCharsets()\n    {\n        if (null !== $this->charsets) {\n            return $this->charsets;\n        }\n\n        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());\n    }\n\n    /**\n     * Gets a list of encodings acceptable by the client browser.\n     *\n     * @return array List of encodings in preferable order\n     */\n    public function getEncodings()\n    {\n        if (null !== $this->encodings) {\n            return $this->encodings;\n        }\n\n        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());\n    }\n\n    /**\n     * Gets a list of content types acceptable by the client browser.\n     *\n     * @return array List of content types in preferable order\n     */\n    public function getAcceptableContentTypes()\n    {\n        if (null !== $this->acceptableContentTypes) {\n            return $this->acceptableContentTypes;\n        }\n\n        return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all());\n    }\n\n    /**\n     * Returns true if the request is a XMLHttpRequest.\n     *\n     * It works if your JavaScript library sets an X-Requested-With HTTP header.\n     * It is known to work with common JavaScript frameworks:\n     *\n     * @see https://wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n     *\n     * @return bool true if the request is an XMLHttpRequest, false otherwise\n     */\n    public function isXmlHttpRequest()\n    {\n        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');\n    }\n\n    /*\n     * The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24)\n     *\n     * Code subject to the new BSD license (https://framework.zend.com/license).\n     *\n     * Copyright (c) 2005-2010 Zend Technologies USA Inc. (https://www.zend.com/)\n     */\n\n    protected function prepareRequestUri()\n    {\n        $requestUri = '';\n\n        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {\n            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)\n            $requestUri = $this->server->get('UNENCODED_URL');\n            $this->server->remove('UNENCODED_URL');\n            $this->server->remove('IIS_WasUrlRewritten');\n        } elseif ($this->server->has('REQUEST_URI')) {\n            $requestUri = $this->server->get('REQUEST_URI');\n\n            if ('' !== $requestUri && '/' === $requestUri[0]) {\n                // To only use path and query remove the fragment.\n                if (false !== $pos = strpos($requestUri, '#')) {\n                    $requestUri = substr($requestUri, 0, $pos);\n                }\n            } else {\n                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,\n                // only use URL path.\n                $uriComponents = parse_url($requestUri);\n\n                if (isset($uriComponents['path'])) {\n                    $requestUri = $uriComponents['path'];\n                }\n\n                if (isset($uriComponents['query'])) {\n                    $requestUri .= '?'.$uriComponents['query'];\n                }\n            }\n        } elseif ($this->server->has('ORIG_PATH_INFO')) {\n            // IIS 5.0, PHP as CGI\n            $requestUri = $this->server->get('ORIG_PATH_INFO');\n            if ('' != $this->server->get('QUERY_STRING')) {\n                $requestUri .= '?'.$this->server->get('QUERY_STRING');\n            }\n            $this->server->remove('ORIG_PATH_INFO');\n        }\n\n        // normalize the request URI to ease creating sub-requests from this request\n        $this->server->set('REQUEST_URI', $requestUri);\n\n        return $requestUri;\n    }\n\n    /**\n     * Prepares the base URL.\n     *\n     * @return string\n     */\n    protected function prepareBaseUrl()\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n\n        if (basename($this->server->get('SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('SCRIPT_NAME');\n        } elseif (basename($this->server->get('PHP_SELF')) === $filename) {\n            $baseUrl = $this->server->get('PHP_SELF');\n        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility\n        } else {\n            // Backtrack up the script_filename to find the portion matching\n            // php_self\n            $path = $this->server->get('PHP_SELF', '');\n            $file = $this->server->get('SCRIPT_FILENAME', '');\n            $segs = explode('/', trim($file, '/'));\n            $segs = array_reverse($segs);\n            $index = 0;\n            $last = \\count($segs);\n            $baseUrl = '';\n            do {\n                $seg = $segs[$index];\n                $baseUrl = '/'.$seg.$baseUrl;\n                ++$index;\n            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);\n        }\n\n        // Does the baseUrl have anything in common with the request_uri?\n        $requestUri = $this->getRequestUri();\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {\n            // full $baseUrl matches\n            return $prefix;\n        }\n\n        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\\dirname($baseUrl), '/'.\\DIRECTORY_SEPARATOR).'/')) {\n            // directory portion of $baseUrl matches\n            return rtrim($prefix, '/'.\\DIRECTORY_SEPARATOR);\n        }\n\n        $truncatedRequestUri = $requestUri;\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $truncatedRequestUri = substr($requestUri, 0, $pos);\n        }\n\n        $basename = basename($baseUrl);\n        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {\n            // no match whatsoever; set it blank\n            return '';\n        }\n\n        // If using mod_rewrite or ISAPI_Rewrite strip the script filename\n        // out of baseUrl. $pos !== 0 makes sure it is not matching a value\n        // from PATH_INFO or QUERY_STRING\n        if (\\strlen($requestUri) >= \\strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {\n            $baseUrl = substr($requestUri, 0, $pos + \\strlen($baseUrl));\n        }\n\n        return rtrim($baseUrl, '/'.\\DIRECTORY_SEPARATOR);\n    }\n\n    /**\n     * Prepares the base path.\n     *\n     * @return string base path\n     */\n    protected function prepareBasePath()\n    {\n        $baseUrl = $this->getBaseUrl();\n        if (empty($baseUrl)) {\n            return '';\n        }\n\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n        if (basename($baseUrl) === $filename) {\n            $basePath = \\dirname($baseUrl);\n        } else {\n            $basePath = $baseUrl;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $basePath = str_replace('\\\\', '/', $basePath);\n        }\n\n        return rtrim($basePath, '/');\n    }\n\n    /**\n     * Prepares the path info.\n     *\n     * @return string path info\n     */\n    protected function preparePathInfo()\n    {\n        if (null === ($requestUri = $this->getRequestUri())) {\n            return '/';\n        }\n\n        // Remove the query string from REQUEST_URI\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $requestUri = substr($requestUri, 0, $pos);\n        }\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if (null === ($baseUrl = $this->getBaseUrl())) {\n            return $requestUri;\n        }\n\n        $pathInfo = substr($requestUri, \\strlen($baseUrl));\n        if (false === $pathInfo || '' === $pathInfo) {\n            // If substr() returns false then PATH_INFO is set to an empty string\n            return '/';\n        }\n\n        return (string) $pathInfo;\n    }\n\n    /**\n     * Initializes HTTP request formats.\n     */\n    protected static function initializeFormats()\n    {\n        static::$formats = [\n            'html' => ['text/html', 'application/xhtml+xml'],\n            'txt' => ['text/plain'],\n            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],\n            'css' => ['text/css'],\n            'json' => ['application/json', 'application/x-json'],\n            'jsonld' => ['application/ld+json'],\n            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],\n            'rdf' => ['application/rdf+xml'],\n            'atom' => ['application/atom+xml'],\n            'rss' => ['application/rss+xml'],\n            'form' => ['application/x-www-form-urlencoded'],\n        ];\n    }\n\n    private function setPhpDefaultLocale(string $locale): void\n    {\n        // if either the class Locale doesn't exist, or an exception is thrown when\n        // setting the default locale, the intl module is not installed, and\n        // the call can be ignored:\n        try {\n            if (class_exists('Locale', false)) {\n                \\Locale::setDefault($locale);\n            }\n        } catch (\\Exception $e) {\n        }\n    }\n\n    /**\n     * Returns the prefix as encoded in the string when the string starts with\n     * the given prefix, null otherwise.\n     */\n    private function getUrlencodedPrefix(string $string, string $prefix): ?string\n    {\n        if (0 !== strpos(rawurldecode($string), $prefix)) {\n            return null;\n        }\n\n        $len = \\strlen($prefix);\n\n        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {\n            return $match[0];\n        }\n\n        return null;\n    }\n\n    private static function createRequestFromFactory(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null): self\n    {\n        if (self::$requestFactory) {\n            $request = (self::$requestFactory)($query, $request, $attributes, $cookies, $files, $server, $content);\n\n            if (!$request instanceof self) {\n                throw new \\LogicException('The Request factory must return an instance of Symfony\\Component\\HttpFoundation\\Request.');\n            }\n\n            return $request;\n        }\n\n        return new static($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Indicates whether this request originated from a trusted proxy.\n     *\n     * This can be useful to determine whether or not to trust the\n     * contents of a proxy-specific header.\n     *\n     * @return bool true if the request came from a trusted proxy, false otherwise\n     */\n    public function isFromTrustedProxy()\n    {\n        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR'), self::$trustedProxies);\n    }\n\n    private function getTrustedValues(int $type, string $ip = null): array\n    {\n        $clientValues = [];\n        $forwardedValues = [];\n\n        if ((self::$trustedHeaderSet & $type) && $this->headers->has(self::$trustedHeaders[$type])) {\n            foreach (explode(',', $this->headers->get(self::$trustedHeaders[$type])) as $v) {\n                $clientValues[] = (self::HEADER_X_FORWARDED_PORT === $type ? '0.0.0.0:' : '').trim($v);\n            }\n        }\n\n        if ((self::$trustedHeaderSet & self::HEADER_FORWARDED) && $this->headers->has(self::$trustedHeaders[self::HEADER_FORWARDED])) {\n            $forwarded = $this->headers->get(self::$trustedHeaders[self::HEADER_FORWARDED]);\n            $parts = HeaderUtils::split($forwarded, ',;=');\n            $forwardedValues = [];\n            $param = self::$forwardedParams[$type];\n            foreach ($parts as $subParts) {\n                if (null === $v = HeaderUtils::combine($subParts)[$param] ?? null) {\n                    continue;\n                }\n                if (self::HEADER_X_FORWARDED_PORT === $type) {\n                    if (']' === substr($v, -1) || false === $v = strrchr($v, ':')) {\n                        $v = $this->isSecure() ? ':443' : ':80';\n                    }\n                    $v = '0.0.0.0'.$v;\n                }\n                $forwardedValues[] = $v;\n            }\n        }\n\n        if (null !== $ip) {\n            $clientValues = $this->normalizeAndFilterClientIps($clientValues, $ip);\n            $forwardedValues = $this->normalizeAndFilterClientIps($forwardedValues, $ip);\n        }\n\n        if ($forwardedValues === $clientValues || !$clientValues) {\n            return $forwardedValues;\n        }\n\n        if (!$forwardedValues) {\n            return $clientValues;\n        }\n\n        if (!$this->isForwardedValid) {\n            return null !== $ip ? ['0.0.0.0', $ip] : [];\n        }\n        $this->isForwardedValid = false;\n\n        throw new ConflictingHeadersException(sprintf('The request has both a trusted \"%s\" header and a trusted \"%s\" header, conflicting with each other. You should either configure your proxy to remove one of them, or configure your project to distrust the offending one.', self::$trustedHeaders[self::HEADER_FORWARDED], self::$trustedHeaders[$type]));\n    }\n\n    private function normalizeAndFilterClientIps(array $clientIps, string $ip): array\n    {\n        if (!$clientIps) {\n            return [];\n        }\n        $clientIps[] = $ip; // Complete the IP chain with the IP the request actually came from\n        $firstTrustedIp = null;\n\n        foreach ($clientIps as $key => $clientIp) {\n            if (strpos($clientIp, '.')) {\n                // Strip :port from IPv4 addresses. This is allowed in Forwarded\n                // and may occur in X-Forwarded-For.\n                $i = strpos($clientIp, ':');\n                if ($i) {\n                    $clientIps[$key] = $clientIp = substr($clientIp, 0, $i);\n                }\n            } elseif (0 === strpos($clientIp, '[')) {\n                // Strip brackets and :port from IPv6 addresses.\n                $i = strpos($clientIp, ']', 1);\n                $clientIps[$key] = $clientIp = substr($clientIp, 1, $i - 1);\n            }\n\n            if (!filter_var($clientIp, FILTER_VALIDATE_IP)) {\n                unset($clientIps[$key]);\n\n                continue;\n            }\n\n            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {\n                unset($clientIps[$key]);\n\n                // Fallback to this when the client IP falls into the range of trusted proxies\n                if (null === $firstTrustedIp) {\n                    $firstTrustedIp = $clientIp;\n                }\n            }\n        }\n\n        // Now the IP chain contains only untrusted proxies and the client IP\n        return $clientIps ? array_reverse($clientIps) : [$firstTrustedIp];\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(ResponseHeaderBag::class);\n\n/**\n * Response represents an HTTP response.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Response\n{\n    const HTTP_CONTINUE = 100;\n    const HTTP_SWITCHING_PROTOCOLS = 101;\n    const HTTP_PROCESSING = 102;            // RFC2518\n    const HTTP_EARLY_HINTS = 103;           // RFC8297\n    const HTTP_OK = 200;\n    const HTTP_CREATED = 201;\n    const HTTP_ACCEPTED = 202;\n    const HTTP_NON_AUTHORITATIVE_INFORMATION = 203;\n    const HTTP_NO_CONTENT = 204;\n    const HTTP_RESET_CONTENT = 205;\n    const HTTP_PARTIAL_CONTENT = 206;\n    const HTTP_MULTI_STATUS = 207;          // RFC4918\n    const HTTP_ALREADY_REPORTED = 208;      // RFC5842\n    const HTTP_IM_USED = 226;               // RFC3229\n    const HTTP_MULTIPLE_CHOICES = 300;\n    const HTTP_MOVED_PERMANENTLY = 301;\n    const HTTP_FOUND = 302;\n    const HTTP_SEE_OTHER = 303;\n    const HTTP_NOT_MODIFIED = 304;\n    const HTTP_USE_PROXY = 305;\n    const HTTP_RESERVED = 306;\n    const HTTP_TEMPORARY_REDIRECT = 307;\n    const HTTP_PERMANENTLY_REDIRECT = 308;  // RFC7238\n    const HTTP_BAD_REQUEST = 400;\n    const HTTP_UNAUTHORIZED = 401;\n    const HTTP_PAYMENT_REQUIRED = 402;\n    const HTTP_FORBIDDEN = 403;\n    const HTTP_NOT_FOUND = 404;\n    const HTTP_METHOD_NOT_ALLOWED = 405;\n    const HTTP_NOT_ACCEPTABLE = 406;\n    const HTTP_PROXY_AUTHENTICATION_REQUIRED = 407;\n    const HTTP_REQUEST_TIMEOUT = 408;\n    const HTTP_CONFLICT = 409;\n    const HTTP_GONE = 410;\n    const HTTP_LENGTH_REQUIRED = 411;\n    const HTTP_PRECONDITION_FAILED = 412;\n    const HTTP_REQUEST_ENTITY_TOO_LARGE = 413;\n    const HTTP_REQUEST_URI_TOO_LONG = 414;\n    const HTTP_UNSUPPORTED_MEDIA_TYPE = 415;\n    const HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n    const HTTP_EXPECTATION_FAILED = 417;\n    const HTTP_I_AM_A_TEAPOT = 418;                                               // RFC2324\n    const HTTP_MISDIRECTED_REQUEST = 421;                                         // RFC7540\n    const HTTP_UNPROCESSABLE_ENTITY = 422;                                        // RFC4918\n    const HTTP_LOCKED = 423;                                                      // RFC4918\n    const HTTP_FAILED_DEPENDENCY = 424;                                           // RFC4918\n\n    /**\n     * @deprecated\n     */\n    const HTTP_RESERVED_FOR_WEBDAV_ADVANCED_COLLECTIONS_EXPIRED_PROPOSAL = 425;   // RFC2817\n    const HTTP_TOO_EARLY = 425;                                                   // RFC-ietf-httpbis-replay-04\n    const HTTP_UPGRADE_REQUIRED = 426;                                            // RFC2817\n    const HTTP_PRECONDITION_REQUIRED = 428;                                       // RFC6585\n    const HTTP_TOO_MANY_REQUESTS = 429;                                           // RFC6585\n    const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;                             // RFC6585\n    const HTTP_UNAVAILABLE_FOR_LEGAL_REASONS = 451;\n    const HTTP_INTERNAL_SERVER_ERROR = 500;\n    const HTTP_NOT_IMPLEMENTED = 501;\n    const HTTP_BAD_GATEWAY = 502;\n    const HTTP_SERVICE_UNAVAILABLE = 503;\n    const HTTP_GATEWAY_TIMEOUT = 504;\n    const HTTP_VERSION_NOT_SUPPORTED = 505;\n    const HTTP_VARIANT_ALSO_NEGOTIATES_EXPERIMENTAL = 506;                        // RFC2295\n    const HTTP_INSUFFICIENT_STORAGE = 507;                                        // RFC4918\n    const HTTP_LOOP_DETECTED = 508;                                               // RFC5842\n    const HTTP_NOT_EXTENDED = 510;                                                // RFC2774\n    const HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511;                             // RFC6585\n\n    /**\n     * @var ResponseHeaderBag\n     */\n    public $headers;\n\n    /**\n     * @var string\n     */\n    protected $content;\n\n    /**\n     * @var string\n     */\n    protected $version;\n\n    /**\n     * @var int\n     */\n    protected $statusCode;\n\n    /**\n     * @var string\n     */\n    protected $statusText;\n\n    /**\n     * @var string\n     */\n    protected $charset;\n\n    /**\n     * Status codes translation table.\n     *\n     * The list of codes is complete according to the\n     * {@link https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml Hypertext Transfer Protocol (HTTP) Status Code Registry}\n     * (last updated 2016-03-01).\n     *\n     * Unless otherwise noted, the status code is defined in RFC2616.\n     *\n     * @var array\n     */\n    public static $statusTexts = [\n        100 => 'Continue',\n        101 => 'Switching Protocols',\n        102 => 'Processing',            // RFC2518\n        103 => 'Early Hints',\n        200 => 'OK',\n        201 => 'Created',\n        202 => 'Accepted',\n        203 => 'Non-Authoritative Information',\n        204 => 'No Content',\n        205 => 'Reset Content',\n        206 => 'Partial Content',\n        207 => 'Multi-Status',          // RFC4918\n        208 => 'Already Reported',      // RFC5842\n        226 => 'IM Used',               // RFC3229\n        300 => 'Multiple Choices',\n        301 => 'Moved Permanently',\n        302 => 'Found',\n        303 => 'See Other',\n        304 => 'Not Modified',\n        305 => 'Use Proxy',\n        307 => 'Temporary Redirect',\n        308 => 'Permanent Redirect',    // RFC7238\n        400 => 'Bad Request',\n        401 => 'Unauthorized',\n        402 => 'Payment Required',\n        403 => 'Forbidden',\n        404 => 'Not Found',\n        405 => 'Method Not Allowed',\n        406 => 'Not Acceptable',\n        407 => 'Proxy Authentication Required',\n        408 => 'Request Timeout',\n        409 => 'Conflict',\n        410 => 'Gone',\n        411 => 'Length Required',\n        412 => 'Precondition Failed',\n        413 => 'Payload Too Large',\n        414 => 'URI Too Long',\n        415 => 'Unsupported Media Type',\n        416 => 'Range Not Satisfiable',\n        417 => 'Expectation Failed',\n        418 => 'I\\'m a teapot',                                               // RFC2324\n        421 => 'Misdirected Request',                                         // RFC7540\n        422 => 'Unprocessable Entity',                                        // RFC4918\n        423 => 'Locked',                                                      // RFC4918\n        424 => 'Failed Dependency',                                           // RFC4918\n        425 => 'Too Early',                                                   // RFC-ietf-httpbis-replay-04\n        426 => 'Upgrade Required',                                            // RFC2817\n        428 => 'Precondition Required',                                       // RFC6585\n        429 => 'Too Many Requests',                                           // RFC6585\n        431 => 'Request Header Fields Too Large',                             // RFC6585\n        451 => 'Unavailable For Legal Reasons',                               // RFC7725\n        500 => 'Internal Server Error',\n        501 => 'Not Implemented',\n        502 => 'Bad Gateway',\n        503 => 'Service Unavailable',\n        504 => 'Gateway Timeout',\n        505 => 'HTTP Version Not Supported',\n        506 => 'Variant Also Negotiates',                                     // RFC2295\n        507 => 'Insufficient Storage',                                        // RFC4918\n        508 => 'Loop Detected',                                               // RFC5842\n        510 => 'Not Extended',                                                // RFC2774\n        511 => 'Network Authentication Required',                             // RFC6585\n    ];\n\n    /**\n     * @throws \\InvalidArgumentException When the HTTP status code is not valid\n     */\n    public function __construct($content = '', int $status = 200, array $headers = [])\n    {\n        $this->headers = new ResponseHeaderBag($headers);\n        $this->setContent($content);\n        $this->setStatusCode($status);\n        $this->setProtocolVersion('1.0');\n    }\n\n    /**\n     * Factory method for chainability.\n     *\n     * Example:\n     *\n     *     return Response::create($body, 200)\n     *         ->setSharedMaxAge(300);\n     *\n     * @param mixed $content The response content, see setContent()\n     * @param int   $status  The response status code\n     * @param array $headers An array of response headers\n     *\n     * @return static\n     */\n    public static function create($content = '', $status = 200, $headers = [])\n    {\n        return new static($content, $status, $headers);\n    }\n\n    /**\n     * Returns the Response as an HTTP string.\n     *\n     * The string representation of the Response is the same as the\n     * one that will be sent to the client only if the prepare() method\n     * has been called before.\n     *\n     * @return string The Response as an HTTP string\n     *\n     * @see prepare()\n     */\n    public function __toString()\n    {\n        return\n            sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText).\"\\r\\n\".\n            $this->headers.\"\\r\\n\".\n            $this->getContent();\n    }\n\n    /**\n     * Clones the current Response instance.\n     */\n    public function __clone()\n    {\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Prepares the Response before it is sent to the client.\n     *\n     * This method tweaks the Response to ensure that it is\n     * compliant with RFC 2616. Most of the changes are based on\n     * the Request that is \"associated\" with this Response.\n     *\n     * @return $this\n     */\n    public function prepare(Request $request)\n    {\n        $headers = $this->headers;\n\n        if ($this->isInformational() || $this->isEmpty()) {\n            $this->setContent(null);\n            $headers->remove('Content-Type');\n            $headers->remove('Content-Length');\n            // prevent PHP from sending the Content-Type header based on default_mimetype\n            ini_set('default_mimetype', '');\n        } else {\n            // Content-type based on the Request\n            if (!$headers->has('Content-Type')) {\n                $format = $request->getPreferredFormat(null);\n                if (null !== $format && $mimeType = $request->getMimeType($format)) {\n                    $headers->set('Content-Type', $mimeType);\n                }\n            }\n\n            // Fix Content-Type\n            $charset = $this->charset ?: 'UTF-8';\n            if (!$headers->has('Content-Type')) {\n                $headers->set('Content-Type', 'text/html; charset='.$charset);\n            } elseif (0 === stripos($headers->get('Content-Type'), 'text/') && false === stripos($headers->get('Content-Type'), 'charset')) {\n                // add the charset\n                $headers->set('Content-Type', $headers->get('Content-Type').'; charset='.$charset);\n            }\n\n            // Fix Content-Length\n            if ($headers->has('Transfer-Encoding')) {\n                $headers->remove('Content-Length');\n            }\n\n            if ($request->isMethod('HEAD')) {\n                // cf. RFC2616 14.13\n                $length = $headers->get('Content-Length');\n                $this->setContent(null);\n                if ($length) {\n                    $headers->set('Content-Length', $length);\n                }\n            }\n        }\n\n        // Fix protocol\n        if ('HTTP/1.0' != $request->server->get('SERVER_PROTOCOL')) {\n            $this->setProtocolVersion('1.1');\n        }\n\n        // Check if we need to send extra expire info headers\n        if ('1.0' == $this->getProtocolVersion() && false !== strpos($headers->get('Cache-Control'), 'no-cache')) {\n            $headers->set('pragma', 'no-cache');\n            $headers->set('expires', -1);\n        }\n\n        $this->ensureIEOverSSLCompatibility($request);\n\n        if ($request->isSecure()) {\n            foreach ($headers->getCookies() as $cookie) {\n                $cookie->setSecureDefault(true);\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sends HTTP headers.\n     *\n     * @return $this\n     */\n    public function sendHeaders()\n    {\n        // headers have already been sent by the developer\n        if (headers_sent()) {\n            return $this;\n        }\n\n        // headers\n        foreach ($this->headers->allPreserveCaseWithoutCookies() as $name => $values) {\n            $replace = 0 === strcasecmp($name, 'Content-Type');\n            foreach ($values as $value) {\n                header($name.': '.$value, $replace, $this->statusCode);\n            }\n        }\n\n        // cookies\n        foreach ($this->headers->getCookies() as $cookie) {\n            header('Set-Cookie: '.$cookie, false, $this->statusCode);\n        }\n\n        // status\n        header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText), true, $this->statusCode);\n\n        return $this;\n    }\n\n    /**\n     * Sends content for the current web response.\n     *\n     * @return $this\n     */\n    public function sendContent()\n    {\n        echo $this->content;\n\n        return $this;\n    }\n\n    /**\n     * Sends HTTP headers and content.\n     *\n     * @return $this\n     */\n    public function send()\n    {\n        $this->sendHeaders();\n        $this->sendContent();\n\n        if (\\function_exists('fastcgi_finish_request')) {\n            fastcgi_finish_request();\n        } elseif (!\\in_array(\\PHP_SAPI, ['cli', 'phpdbg'], true)) {\n            static::closeOutputBuffers(0, true);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the response content.\n     *\n     * Valid types are strings, numbers, null, and objects that implement a __toString() method.\n     *\n     * @param mixed $content Content that can be cast to string\n     *\n     * @return $this\n     *\n     * @throws \\UnexpectedValueException\n     */\n    public function setContent($content)\n    {\n        if (null !== $content && !\\is_string($content) && !is_numeric($content) && !\\is_callable([$content, '__toString'])) {\n            throw new \\UnexpectedValueException(sprintf('The Response content must be a string or object implementing __toString(), \"%s\" given.', \\gettype($content)));\n        }\n\n        $this->content = (string) $content;\n\n        return $this;\n    }\n\n    /**\n     * Gets the current response content.\n     *\n     * @return string|false\n     */\n    public function getContent()\n    {\n        return $this->content;\n    }\n\n    /**\n     * Sets the HTTP protocol version (1.0 or 1.1).\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setProtocolVersion(string $version)\n    {\n        $this->version = $version;\n\n        return $this;\n    }\n\n    /**\n     * Gets the HTTP protocol version.\n     *\n     * @final\n     */\n    public function getProtocolVersion(): string\n    {\n        return $this->version;\n    }\n\n    /**\n     * Sets the response status code.\n     *\n     * If the status text is null it will be automatically populated for the known\n     * status codes and left empty otherwise.\n     *\n     * @return $this\n     *\n     * @throws \\InvalidArgumentException When the HTTP status code is not valid\n     *\n     * @final\n     */\n    public function setStatusCode(int $code, $text = null)\n    {\n        $this->statusCode = $code;\n        if ($this->isInvalid()) {\n            throw new \\InvalidArgumentException(sprintf('The HTTP status code \"%s\" is not valid.', $code));\n        }\n\n        if (null === $text) {\n            $this->statusText = isset(self::$statusTexts[$code]) ? self::$statusTexts[$code] : 'unknown status';\n\n            return $this;\n        }\n\n        if (false === $text) {\n            $this->statusText = '';\n\n            return $this;\n        }\n\n        $this->statusText = $text;\n\n        return $this;\n    }\n\n    /**\n     * Retrieves the status code for the current web response.\n     *\n     * @final\n     */\n    public function getStatusCode(): int\n    {\n        return $this->statusCode;\n    }\n\n    /**\n     * Sets the response charset.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setCharset(string $charset)\n    {\n        $this->charset = $charset;\n\n        return $this;\n    }\n\n    /**\n     * Retrieves the response charset.\n     *\n     * @final\n     */\n    public function getCharset(): ?string\n    {\n        return $this->charset;\n    }\n\n    /**\n     * Returns true if the response may safely be kept in a shared (surrogate) cache.\n     *\n     * Responses marked \"private\" with an explicit Cache-Control directive are\n     * considered uncacheable.\n     *\n     * Responses with neither a freshness lifetime (Expires, max-age) nor cache\n     * validator (Last-Modified, ETag) are considered uncacheable because there is\n     * no way to tell when or how to remove them from the cache.\n     *\n     * Note that RFC 7231 and RFC 7234 possibly allow for a more permissive implementation,\n     * for example \"status codes that are defined as cacheable by default [...]\n     * can be reused by a cache with heuristic expiration unless otherwise indicated\"\n     * (https://tools.ietf.org/html/rfc7231#section-6.1)\n     *\n     * @final\n     */\n    public function isCacheable(): bool\n    {\n        if (!\\in_array($this->statusCode, [200, 203, 300, 301, 302, 404, 410])) {\n            return false;\n        }\n\n        if ($this->headers->hasCacheControlDirective('no-store') || $this->headers->getCacheControlDirective('private')) {\n            return false;\n        }\n\n        return $this->isValidateable() || $this->isFresh();\n    }\n\n    /**\n     * Returns true if the response is \"fresh\".\n     *\n     * Fresh responses may be served from cache without any interaction with the\n     * origin. A response is considered fresh when it includes a Cache-Control/max-age\n     * indicator or Expires header and the calculated age is less than the freshness lifetime.\n     *\n     * @final\n     */\n    public function isFresh(): bool\n    {\n        return $this->getTtl() > 0;\n    }\n\n    /**\n     * Returns true if the response includes headers that can be used to validate\n     * the response with the origin server using a conditional GET request.\n     *\n     * @final\n     */\n    public function isValidateable(): bool\n    {\n        return $this->headers->has('Last-Modified') || $this->headers->has('ETag');\n    }\n\n    /**\n     * Marks the response as \"private\".\n     *\n     * It makes the response ineligible for serving other clients.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setPrivate()\n    {\n        $this->headers->removeCacheControlDirective('public');\n        $this->headers->addCacheControlDirective('private');\n\n        return $this;\n    }\n\n    /**\n     * Marks the response as \"public\".\n     *\n     * It makes the response eligible for serving other clients.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setPublic()\n    {\n        $this->headers->addCacheControlDirective('public');\n        $this->headers->removeCacheControlDirective('private');\n\n        return $this;\n    }\n\n    /**\n     * Marks the response as \"immutable\".\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setImmutable(bool $immutable = true)\n    {\n        if ($immutable) {\n            $this->headers->addCacheControlDirective('immutable');\n        } else {\n            $this->headers->removeCacheControlDirective('immutable');\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns true if the response is marked as \"immutable\".\n     *\n     * @final\n     */\n    public function isImmutable(): bool\n    {\n        return $this->headers->hasCacheControlDirective('immutable');\n    }\n\n    /**\n     * Returns true if the response must be revalidated by shared caches once it has become stale.\n     *\n     * This method indicates that the response must not be served stale by a\n     * cache in any circumstance without first revalidating with the origin.\n     * When present, the TTL of the response should not be overridden to be\n     * greater than the value provided by the origin.\n     *\n     * @final\n     */\n    public function mustRevalidate(): bool\n    {\n        return $this->headers->hasCacheControlDirective('must-revalidate') || $this->headers->hasCacheControlDirective('proxy-revalidate');\n    }\n\n    /**\n     * Returns the Date header as a DateTime instance.\n     *\n     * @throws \\RuntimeException When the header is not parseable\n     *\n     * @final\n     */\n    public function getDate(): ?\\DateTimeInterface\n    {\n        return $this->headers->getDate('Date');\n    }\n\n    /**\n     * Sets the Date header.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setDate(\\DateTimeInterface $date)\n    {\n        if ($date instanceof \\DateTime) {\n            $date = \\DateTimeImmutable::createFromMutable($date);\n        }\n\n        $date = $date->setTimezone(new \\DateTimeZone('UTC'));\n        $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT');\n\n        return $this;\n    }\n\n    /**\n     * Returns the age of the response in seconds.\n     *\n     * @final\n     */\n    public function getAge(): int\n    {\n        if (null !== $age = $this->headers->get('Age')) {\n            return (int) $age;\n        }\n\n        return max(time() - (int) $this->getDate()->format('U'), 0);\n    }\n\n    /**\n     * Marks the response stale by setting the Age header to be equal to the maximum age of the response.\n     *\n     * @return $this\n     */\n    public function expire()\n    {\n        if ($this->isFresh()) {\n            $this->headers->set('Age', $this->getMaxAge());\n            $this->headers->remove('Expires');\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns the value of the Expires header as a DateTime instance.\n     *\n     * @final\n     */\n    public function getExpires(): ?\\DateTimeInterface\n    {\n        try {\n            return $this->headers->getDate('Expires');\n        } catch (\\RuntimeException $e) {\n            // according to RFC 2616 invalid date formats (e.g. \"0\" and \"-1\") must be treated as in the past\n            return \\DateTime::createFromFormat('U', time() - 172800);\n        }\n    }\n\n    /**\n     * Sets the Expires HTTP header with a DateTime instance.\n     *\n     * Passing null as value will remove the header.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setExpires(\\DateTimeInterface $date = null)\n    {\n        if (null === $date) {\n            $this->headers->remove('Expires');\n\n            return $this;\n        }\n\n        if ($date instanceof \\DateTime) {\n            $date = \\DateTimeImmutable::createFromMutable($date);\n        }\n\n        $date = $date->setTimezone(new \\DateTimeZone('UTC'));\n        $this->headers->set('Expires', $date->format('D, d M Y H:i:s').' GMT');\n\n        return $this;\n    }\n\n    /**\n     * Returns the number of seconds after the time specified in the response's Date\n     * header when the response should no longer be considered fresh.\n     *\n     * First, it checks for a s-maxage directive, then a max-age directive, and then it falls\n     * back on an expires header. It returns null when no maximum age can be established.\n     *\n     * @final\n     */\n    public function getMaxAge(): ?int\n    {\n        if ($this->headers->hasCacheControlDirective('s-maxage')) {\n            return (int) $this->headers->getCacheControlDirective('s-maxage');\n        }\n\n        if ($this->headers->hasCacheControlDirective('max-age')) {\n            return (int) $this->headers->getCacheControlDirective('max-age');\n        }\n\n        if (null !== $this->getExpires()) {\n            return (int) $this->getExpires()->format('U') - (int) $this->getDate()->format('U');\n        }\n\n        return null;\n    }\n\n    /**\n     * Sets the number of seconds after which the response should no longer be considered fresh.\n     *\n     * This methods sets the Cache-Control max-age directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setMaxAge(int $value)\n    {\n        $this->headers->addCacheControlDirective('max-age', $value);\n\n        return $this;\n    }\n\n    /**\n     * Sets the number of seconds after which the response should no longer be considered fresh by shared caches.\n     *\n     * This methods sets the Cache-Control s-maxage directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setSharedMaxAge(int $value)\n    {\n        $this->setPublic();\n        $this->headers->addCacheControlDirective('s-maxage', $value);\n\n        return $this;\n    }\n\n    /**\n     * Returns the response's time-to-live in seconds.\n     *\n     * It returns null when no freshness information is present in the response.\n     *\n     * When the responses TTL is <= 0, the response may not be served from cache without first\n     * revalidating with the origin.\n     *\n     * @final\n     */\n    public function getTtl(): ?int\n    {\n        $maxAge = $this->getMaxAge();\n\n        return null !== $maxAge ? $maxAge - $this->getAge() : null;\n    }\n\n    /**\n     * Sets the response's time-to-live for shared caches in seconds.\n     *\n     * This method adjusts the Cache-Control/s-maxage directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setTtl(int $seconds)\n    {\n        $this->setSharedMaxAge($this->getAge() + $seconds);\n\n        return $this;\n    }\n\n    /**\n     * Sets the response's time-to-live for private/client caches in seconds.\n     *\n     * This method adjusts the Cache-Control/max-age directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setClientTtl(int $seconds)\n    {\n        $this->setMaxAge($this->getAge() + $seconds);\n\n        return $this;\n    }\n\n    /**\n     * Returns the Last-Modified HTTP header as a DateTime instance.\n     *\n     * @throws \\RuntimeException When the HTTP header is not parseable\n     *\n     * @final\n     */\n    public function getLastModified(): ?\\DateTimeInterface\n    {\n        return $this->headers->getDate('Last-Modified');\n    }\n\n    /**\n     * Sets the Last-Modified HTTP header with a DateTime instance.\n     *\n     * Passing null as value will remove the header.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setLastModified(\\DateTimeInterface $date = null)\n    {\n        if (null === $date) {\n            $this->headers->remove('Last-Modified');\n\n            return $this;\n        }\n\n        if ($date instanceof \\DateTime) {\n            $date = \\DateTimeImmutable::createFromMutable($date);\n        }\n\n        $date = $date->setTimezone(new \\DateTimeZone('UTC'));\n        $this->headers->set('Last-Modified', $date->format('D, d M Y H:i:s').' GMT');\n\n        return $this;\n    }\n\n    /**\n     * Returns the literal value of the ETag HTTP header.\n     *\n     * @final\n     */\n    public function getEtag(): ?string\n    {\n        return $this->headers->get('ETag');\n    }\n\n    /**\n     * Sets the ETag value.\n     *\n     * @param string|null $etag The ETag unique identifier or null to remove the header\n     * @param bool        $weak Whether you want a weak ETag or not\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setEtag(string $etag = null, bool $weak = false)\n    {\n        if (null === $etag) {\n            $this->headers->remove('Etag');\n        } else {\n            if (0 !== strpos($etag, '\"')) {\n                $etag = '\"'.$etag.'\"';\n            }\n\n            $this->headers->set('ETag', (true === $weak ? 'W/' : '').$etag);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the response's cache headers (validation and/or expiration).\n     *\n     * Available options are: etag, last_modified, max_age, s_maxage, private, public and immutable.\n     *\n     * @return $this\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @final\n     */\n    public function setCache(array $options)\n    {\n        if ($diff = array_diff(array_keys($options), ['etag', 'last_modified', 'max_age', 's_maxage', 'private', 'public', 'immutable'])) {\n            throw new \\InvalidArgumentException(sprintf('Response does not support the following options: \"%s\".', implode('\", \"', $diff)));\n        }\n\n        if (isset($options['etag'])) {\n            $this->setEtag($options['etag']);\n        }\n\n        if (isset($options['last_modified'])) {\n            $this->setLastModified($options['last_modified']);\n        }\n\n        if (isset($options['max_age'])) {\n            $this->setMaxAge($options['max_age']);\n        }\n\n        if (isset($options['s_maxage'])) {\n            $this->setSharedMaxAge($options['s_maxage']);\n        }\n\n        if (isset($options['public'])) {\n            if ($options['public']) {\n                $this->setPublic();\n            } else {\n                $this->setPrivate();\n            }\n        }\n\n        if (isset($options['private'])) {\n            if ($options['private']) {\n                $this->setPrivate();\n            } else {\n                $this->setPublic();\n            }\n        }\n\n        if (isset($options['immutable'])) {\n            $this->setImmutable((bool) $options['immutable']);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Modifies the response so that it conforms to the rules defined for a 304 status code.\n     *\n     * This sets the status, removes the body, and discards any headers\n     * that MUST NOT be included in 304 responses.\n     *\n     * @return $this\n     *\n     * @see https://tools.ietf.org/html/rfc2616#section-10.3.5\n     *\n     * @final\n     */\n    public function setNotModified()\n    {\n        $this->setStatusCode(304);\n        $this->setContent(null);\n\n        // remove headers that MUST NOT be included with 304 Not Modified responses\n        foreach (['Allow', 'Content-Encoding', 'Content-Language', 'Content-Length', 'Content-MD5', 'Content-Type', 'Last-Modified'] as $header) {\n            $this->headers->remove($header);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns true if the response includes a Vary header.\n     *\n     * @final\n     */\n    public function hasVary(): bool\n    {\n        return null !== $this->headers->get('Vary');\n    }\n\n    /**\n     * Returns an array of header names given in the Vary header.\n     *\n     * @final\n     */\n    public function getVary(): array\n    {\n        if (!$vary = $this->headers->all('Vary')) {\n            return [];\n        }\n\n        $ret = [];\n        foreach ($vary as $item) {\n            $ret = array_merge($ret, preg_split('/[\\s,]+/', $item));\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Sets the Vary header.\n     *\n     * @param string|array $headers\n     * @param bool         $replace Whether to replace the actual value or not (true by default)\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setVary($headers, bool $replace = true)\n    {\n        $this->headers->set('Vary', $headers, $replace);\n\n        return $this;\n    }\n\n    /**\n     * Determines if the Response validators (ETag, Last-Modified) match\n     * a conditional value specified in the Request.\n     *\n     * If the Response is not modified, it sets the status code to 304 and\n     * removes the actual content by calling the setNotModified() method.\n     *\n     * @return bool true if the Response validators match the Request, false otherwise\n     *\n     * @final\n     */\n    public function isNotModified(Request $request): bool\n    {\n        if (!$request->isMethodCacheable()) {\n            return false;\n        }\n\n        $notModified = false;\n        $lastModified = $this->headers->get('Last-Modified');\n        $modifiedSince = $request->headers->get('If-Modified-Since');\n\n        if ($etags = $request->getETags()) {\n            $notModified = \\in_array($this->getEtag(), $etags) || \\in_array('*', $etags);\n        }\n\n        if ($modifiedSince && $lastModified) {\n            $notModified = strtotime($modifiedSince) >= strtotime($lastModified) && (!$etags || $notModified);\n        }\n\n        if ($notModified) {\n            $this->setNotModified();\n        }\n\n        return $notModified;\n    }\n\n    /**\n     * Is response invalid?\n     *\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n     *\n     * @final\n     */\n    public function isInvalid(): bool\n    {\n        return $this->statusCode < 100 || $this->statusCode >= 600;\n    }\n\n    /**\n     * Is response informative?\n     *\n     * @final\n     */\n    public function isInformational(): bool\n    {\n        return $this->statusCode >= 100 && $this->statusCode < 200;\n    }\n\n    /**\n     * Is response successful?\n     *\n     * @final\n     */\n    public function isSuccessful(): bool\n    {\n        return $this->statusCode >= 200 && $this->statusCode < 300;\n    }\n\n    /**\n     * Is the response a redirect?\n     *\n     * @final\n     */\n    public function isRedirection(): bool\n    {\n        return $this->statusCode >= 300 && $this->statusCode < 400;\n    }\n\n    /**\n     * Is there a client error?\n     *\n     * @final\n     */\n    public function isClientError(): bool\n    {\n        return $this->statusCode >= 400 && $this->statusCode < 500;\n    }\n\n    /**\n     * Was there a server side error?\n     *\n     * @final\n     */\n    public function isServerError(): bool\n    {\n        return $this->statusCode >= 500 && $this->statusCode < 600;\n    }\n\n    /**\n     * Is the response OK?\n     *\n     * @final\n     */\n    public function isOk(): bool\n    {\n        return 200 === $this->statusCode;\n    }\n\n    /**\n     * Is the response forbidden?\n     *\n     * @final\n     */\n    public function isForbidden(): bool\n    {\n        return 403 === $this->statusCode;\n    }\n\n    /**\n     * Is the response a not found error?\n     *\n     * @final\n     */\n    public function isNotFound(): bool\n    {\n        return 404 === $this->statusCode;\n    }\n\n    /**\n     * Is the response a redirect of some form?\n     *\n     * @final\n     */\n    public function isRedirect(string $location = null): bool\n    {\n        return \\in_array($this->statusCode, [201, 301, 302, 303, 307, 308]) && (null === $location ?: $location == $this->headers->get('Location'));\n    }\n\n    /**\n     * Is the response empty?\n     *\n     * @final\n     */\n    public function isEmpty(): bool\n    {\n        return \\in_array($this->statusCode, [204, 304]);\n    }\n\n    /**\n     * Cleans or flushes output buffers up to target level.\n     *\n     * Resulting level can be greater than target level if a non-removable buffer has been encountered.\n     *\n     * @final\n     */\n    public static function closeOutputBuffers(int $targetLevel, bool $flush): void\n    {\n        $status = ob_get_status(true);\n        $level = \\count($status);\n        $flags = PHP_OUTPUT_HANDLER_REMOVABLE | ($flush ? PHP_OUTPUT_HANDLER_FLUSHABLE : PHP_OUTPUT_HANDLER_CLEANABLE);\n\n        while ($level-- > $targetLevel && ($s = $status[$level]) && (!isset($s['del']) ? !isset($s['flags']) || ($s['flags'] & $flags) === $flags : $s['del'])) {\n            if ($flush) {\n                ob_end_flush();\n            } else {\n                ob_end_clean();\n            }\n        }\n    }\n\n    /**\n     * Checks if we need to remove Cache-Control for SSL encrypted downloads when using IE < 9.\n     *\n     * @see http://support.microsoft.com/kb/323308\n     *\n     * @final\n     */\n    protected function ensureIEOverSSLCompatibility(Request $request): void\n    {\n        if (false !== stripos($this->headers->get('Content-Disposition'), 'attachment') && 1 == preg_match('/MSIE (.*?);/i', $request->server->get('HTTP_USER_AGENT'), $match) && true === $request->isSecure()) {\n            if ((int) preg_replace('/(MSIE )(.*?);/', '$2', $match[0]) < 9) {\n                $this->headers->remove('Cache-Control');\n            }\n        }\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation\\Tests;\n\nuse Symfony\\Component\\HttpFoundation\\Cookie;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * @group time-sensitive\n */\nclass ResponseTest extends ResponseTestCase\n{\n    public function testCreate()\n    {\n        $response = Response::create('foo', 301, ['Foo' => 'bar']);\n\n        $this->assertInstanceOf('Symfony\\Component\\HttpFoundation\\Response', $response);\n        $this->assertEquals(301, $response->getStatusCode());\n        $this->assertEquals('bar', $response->headers->get('foo'));\n    }\n\n    public function testToString()\n    {\n        $response = new Response();\n        $response = explode(\"\\r\\n\", $response);\n        $this->assertEquals('HTTP/1.0 200 OK', $response[0]);\n        $this->assertEquals('Cache-Control: no-cache, private', $response[1]);\n    }\n\n    public function testClone()\n    {\n        $response = new Response();\n        $responseClone = clone $response;\n        $this->assertEquals($response, $responseClone);\n    }\n\n    public function testSendHeaders()\n    {\n        $response = new Response();\n        $headers = $response->sendHeaders();\n        $this->assertObjectHasAttribute('headers', $headers);\n        $this->assertObjectHasAttribute('content', $headers);\n        $this->assertObjectHasAttribute('version', $headers);\n        $this->assertObjectHasAttribute('statusCode', $headers);\n        $this->assertObjectHasAttribute('statusText', $headers);\n        $this->assertObjectHasAttribute('charset', $headers);\n    }\n\n    public function testSend()\n    {\n        $response = new Response();\n        $responseSend = $response->send();\n        $this->assertObjectHasAttribute('headers', $responseSend);\n        $this->assertObjectHasAttribute('content', $responseSend);\n        $this->assertObjectHasAttribute('version', $responseSend);\n        $this->assertObjectHasAttribute('statusCode', $responseSend);\n        $this->assertObjectHasAttribute('statusText', $responseSend);\n        $this->assertObjectHasAttribute('charset', $responseSend);\n    }\n\n    public function testGetCharset()\n    {\n        $response = new Response();\n        $charsetOrigin = 'UTF-8';\n        $response->setCharset($charsetOrigin);\n        $charset = $response->getCharset();\n        $this->assertEquals($charsetOrigin, $charset);\n    }\n\n    public function testIsCacheable()\n    {\n        $response = new Response();\n        $this->assertFalse($response->isCacheable());\n    }\n\n    public function testIsCacheableWithErrorCode()\n    {\n        $response = new Response('', 500);\n        $this->assertFalse($response->isCacheable());\n    }\n\n    public function testIsCacheableWithNoStoreDirective()\n    {\n        $response = new Response();\n        $response->headers->set('cache-control', 'private');\n        $this->assertFalse($response->isCacheable());\n    }\n\n    public function testIsCacheableWithSetTtl()\n    {\n        $response = new Response();\n        $response->setTtl(10);\n        $this->assertTrue($response->isCacheable());\n    }\n\n    public function testMustRevalidate()\n    {\n        $response = new Response();\n        $this->assertFalse($response->mustRevalidate());\n    }\n\n    public function testMustRevalidateWithMustRevalidateCacheControlHeader()\n    {\n        $response = new Response();\n        $response->headers->set('cache-control', 'must-revalidate');\n\n        $this->assertTrue($response->mustRevalidate());\n    }\n\n    public function testMustRevalidateWithProxyRevalidateCacheControlHeader()\n    {\n        $response = new Response();\n        $response->headers->set('cache-control', 'proxy-revalidate');\n\n        $this->assertTrue($response->mustRevalidate());\n    }\n\n    public function testSetNotModified()\n    {\n        $response = new Response('foo');\n        $modified = $response->setNotModified();\n        $this->assertObjectHasAttribute('headers', $modified);\n        $this->assertObjectHasAttribute('content', $modified);\n        $this->assertObjectHasAttribute('version', $modified);\n        $this->assertObjectHasAttribute('statusCode', $modified);\n        $this->assertObjectHasAttribute('statusText', $modified);\n        $this->assertObjectHasAttribute('charset', $modified);\n        $this->assertEquals(304, $modified->getStatusCode());\n\n        ob_start();\n        $modified->sendContent();\n        $string = ob_get_clean();\n        $this->assertEmpty($string);\n    }\n\n    public function testIsSuccessful()\n    {\n        $response = new Response();\n        $this->assertTrue($response->isSuccessful());\n    }\n\n    public function testIsNotModified()\n    {\n        $response = new Response();\n        $modified = $response->isNotModified(new Request());\n        $this->assertFalse($modified);\n    }\n\n    public function testIsNotModifiedNotSafe()\n    {\n        $request = Request::create('/homepage', 'POST');\n\n        $response = new Response();\n        $this->assertFalse($response->isNotModified($request));\n    }\n\n    public function testIsNotModifiedLastModified()\n    {\n        $before = 'Sun, 25 Aug 2013 18:32:31 GMT';\n        $modified = 'Sun, 25 Aug 2013 18:33:31 GMT';\n        $after = 'Sun, 25 Aug 2013 19:33:31 GMT';\n\n        $request = new Request();\n        $request->headers->set('If-Modified-Since', $modified);\n\n        $response = new Response();\n\n        $response->headers->set('Last-Modified', $modified);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('Last-Modified', $before);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('Last-Modified', $after);\n        $this->assertFalse($response->isNotModified($request));\n\n        $response->headers->set('Last-Modified', '');\n        $this->assertFalse($response->isNotModified($request));\n    }\n\n    public function testIsNotModifiedEtag()\n    {\n        $etagOne = 'randomly_generated_etag';\n        $etagTwo = 'randomly_generated_etag_2';\n\n        $request = new Request();\n        $request->headers->set('if_none_match', sprintf('%s, %s, %s', $etagOne, $etagTwo, 'etagThree'));\n\n        $response = new Response();\n\n        $response->headers->set('ETag', $etagOne);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('ETag', $etagTwo);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('ETag', '');\n        $this->assertFalse($response->isNotModified($request));\n    }\n\n    public function testIsNotModifiedLastModifiedAndEtag()\n    {\n        $before = 'Sun, 25 Aug 2013 18:32:31 GMT';\n        $modified = 'Sun, 25 Aug 2013 18:33:31 GMT';\n        $after = 'Sun, 25 Aug 2013 19:33:31 GMT';\n        $etag = 'randomly_generated_etag';\n\n        $request = new Request();\n        $request->headers->set('if_none_match', sprintf('%s, %s', $etag, 'etagThree'));\n        $request->headers->set('If-Modified-Since', $modified);\n\n        $response = new Response();\n\n        $response->headers->set('ETag', $etag);\n        $response->headers->set('Last-Modified', $after);\n        $this->assertFalse($response->isNotModified($request));\n\n        $response->headers->set('ETag', 'non-existent-etag');\n        $response->headers->set('Last-Modified', $before);\n        $this->assertFalse($response->isNotModified($request));\n\n        $response->headers->set('ETag', $etag);\n        $response->headers->set('Last-Modified', $modified);\n        $this->assertTrue($response->isNotModified($request));\n    }\n\n    public function testIsNotModifiedIfModifiedSinceAndEtagWithoutLastModified()\n    {\n        $modified = 'Sun, 25 Aug 2013 18:33:31 GMT';\n        $etag = 'randomly_generated_etag';\n\n        $request = new Request();\n        $request->headers->set('if_none_match', sprintf('%s, %s', $etag, 'etagThree'));\n        $request->headers->set('If-Modified-Since', $modified);\n\n        $response = new Response();\n\n        $response->headers->set('ETag', $etag);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('ETag', 'non-existent-etag');\n        $this->assertFalse($response->isNotModified($request));\n    }\n\n    public function testIsValidateable()\n    {\n        $response = new Response('', 200, ['Last-Modified' => $this->createDateTimeOneHourAgo()->format(DATE_RFC2822)]);\n        $this->assertTrue($response->isValidateable(), '->isValidateable() returns true if Last-Modified is present');\n\n        $response = new Response('', 200, ['ETag' => '\"12345\"']);\n        $this->assertTrue($response->isValidateable(), '->isValidateable() returns true if ETag is present');\n\n        $response = new Response();\n        $this->assertFalse($response->isValidateable(), '->isValidateable() returns false when no validator is present');\n    }\n\n    public function testGetDate()\n    {\n        $oneHourAgo = $this->createDateTimeOneHourAgo();\n        $response = new Response('', 200, ['Date' => $oneHourAgo->format(DATE_RFC2822)]);\n        $date = $response->getDate();\n        $this->assertEquals($oneHourAgo->getTimestamp(), $date->getTimestamp(), '->getDate() returns the Date header if present');\n\n        $response = new Response();\n        $date = $response->getDate();\n        $this->assertEquals(time(), $date->getTimestamp(), '->getDate() returns the current Date if no Date header present');\n\n        $response = new Response('', 200, ['Date' => $this->createDateTimeOneHourAgo()->format(DATE_RFC2822)]);\n        $now = $this->createDateTimeNow();\n        $response->headers->set('Date', $now->format(DATE_RFC2822));\n        $date = $response->getDate();\n        $this->assertEquals($now->getTimestamp(), $date->getTimestamp(), '->getDate() returns the date when the header has been modified');\n\n        $response = new Response('', 200);\n        $now = $this->createDateTimeNow();\n        $response->headers->remove('Date');\n        $date = $response->getDate();\n        $this->assertEquals($now->getTimestamp(), $date->getTimestamp(), '->getDate() returns the current Date when the header has previously been removed');\n    }\n\n    public function testGetMaxAge()\n    {\n        $response = new Response();\n        $response->headers->set('Cache-Control', 's-maxage=600, max-age=0');\n        $this->assertEquals(600, $response->getMaxAge(), '->getMaxAge() uses s-maxage cache control directive when present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=600');\n        $this->assertEquals(600, $response->getMaxAge(), '->getMaxAge() falls back to max-age when no s-maxage directive present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'must-revalidate');\n        $response->headers->set('Expires', $this->createDateTimeOneHourLater()->format(DATE_RFC2822));\n        $this->assertEquals(3600, $response->getMaxAge(), '->getMaxAge() falls back to Expires when no max-age or s-maxage directive present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'must-revalidate');\n        $response->headers->set('Expires', -1);\n        $this->assertLessThanOrEqual(time() - 2 * 86400, $response->getExpires()->format('U'));\n\n        $response = new Response();\n        $this->assertNull($response->getMaxAge(), '->getMaxAge() returns null if no freshness information available');\n    }\n\n    public function testSetSharedMaxAge()\n    {\n        $response = new Response();\n        $response->setSharedMaxAge(20);\n\n        $cacheControl = $response->headers->get('Cache-Control');\n        $this->assertEquals('public, s-maxage=20', $cacheControl);\n    }\n\n    public function testIsPrivate()\n    {\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=100');\n        $response->setPrivate();\n        $this->assertEquals(100, $response->headers->getCacheControlDirective('max-age'), '->isPrivate() adds the private Cache-Control directive when set to true');\n        $this->assertTrue($response->headers->getCacheControlDirective('private'), '->isPrivate() adds the private Cache-Control directive when set to true');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'public, max-age=100');\n        $response->setPrivate();\n        $this->assertEquals(100, $response->headers->getCacheControlDirective('max-age'), '->isPrivate() adds the private Cache-Control directive when set to true');\n        $this->assertTrue($response->headers->getCacheControlDirective('private'), '->isPrivate() adds the private Cache-Control directive when set to true');\n        $this->assertFalse($response->headers->hasCacheControlDirective('public'), '->isPrivate() removes the public Cache-Control directive');\n    }\n\n    public function testExpire()\n    {\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=100');\n        $response->expire();\n        $this->assertEquals(100, $response->headers->get('Age'), '->expire() sets the Age to max-age when present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=100, s-maxage=500');\n        $response->expire();\n        $this->assertEquals(500, $response->headers->get('Age'), '->expire() sets the Age to s-maxage when both max-age and s-maxage are present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=5, s-maxage=500');\n        $response->headers->set('Age', '1000');\n        $response->expire();\n        $this->assertEquals(1000, $response->headers->get('Age'), '->expire() does nothing when the response is already stale/expired');\n\n        $response = new Response();\n        $response->expire();\n        $this->assertFalse($response->headers->has('Age'), '->expire() does nothing when the response does not include freshness information');\n\n        $response = new Response();\n        $response->headers->set('Expires', -1);\n        $response->expire();\n        $this->assertNull($response->headers->get('Age'), '->expire() does not set the Age when the response is expired');\n\n        $response = new Response();\n        $response->headers->set('Expires', date(DATE_RFC2822, time() + 600));\n        $response->expire();\n        $this->assertNull($response->headers->get('Expires'), '->expire() removes the Expires header when the response is fresh');\n    }\n\n    public function testNullExpireHeader()\n    {\n        $response = new Response(null, 200, ['Expires' => null]);\n        $this->assertNull($response->getExpires());\n    }\n\n    public function testGetTtl()\n    {\n        $response = new Response();\n        $this->assertNull($response->getTtl(), '->getTtl() returns null when no Expires or Cache-Control headers are present');\n\n        $response = new Response();\n        $response->headers->set('Expires', $this->createDateTimeOneHourLater()->format(DATE_RFC2822));\n        $this->assertEquals(3600, $response->getTtl(), '->getTtl() uses the Expires header when no max-age is present');\n\n        $response = new Response();\n        $response->headers->set('Expires', $this->createDateTimeOneHourAgo()->format(DATE_RFC2822));\n        $this->assertLessThan(0, $response->getTtl(), '->getTtl() returns negative values when Expires is in past');\n\n        $response = new Response();\n        $response->headers->set('Expires', $response->getDate()->format(DATE_RFC2822));\n        $response->headers->set('Age', 0);\n        $this->assertSame(0, $response->getTtl(), '->getTtl() correctly handles zero');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=60');\n        $this->assertEquals(60, $response->getTtl(), '->getTtl() uses Cache-Control max-age when present');\n    }\n\n    public function testSetClientTtl()\n    {\n        $response = new Response();\n        $response->setClientTtl(10);\n\n        $this->assertEquals($response->getMaxAge(), $response->getAge() + 10);\n    }\n\n    public function testGetSetProtocolVersion()\n    {\n        $response = new Response();\n\n        $this->assertEquals('1.0', $response->getProtocolVersion());\n\n        $response->setProtocolVersion('1.1');\n\n        $this->assertEquals('1.1', $response->getProtocolVersion());\n    }\n\n    public function testGetVary()\n    {\n        $response = new Response();\n        $this->assertEquals([], $response->getVary(), '->getVary() returns an empty array if no Vary header is present');\n\n        $response = new Response();\n        $response->headers->set('Vary', 'Accept-Language');\n        $this->assertEquals(['Accept-Language'], $response->getVary(), '->getVary() parses a single header name value');\n\n        $response = new Response();\n        $response->headers->set('Vary', 'Accept-Language User-Agent    X-Foo');\n        $this->assertEquals(['Accept-Language', 'User-Agent', 'X-Foo'], $response->getVary(), '->getVary() parses multiple header name values separated by spaces');\n\n        $response = new Response();\n        $response->headers->set('Vary', 'Accept-Language,User-Agent,    X-Foo');\n        $this->assertEquals(['Accept-Language', 'User-Agent', 'X-Foo'], $response->getVary(), '->getVary() parses multiple header name values separated by commas');\n\n        $vary = ['Accept-Language', 'User-Agent', 'X-foo'];\n\n        $response = new Response();\n        $response->headers->set('Vary', $vary);\n        $this->assertEquals($vary, $response->getVary(), '->getVary() parses multiple header name values in arrays');\n\n        $response = new Response();\n        $response->headers->set('Vary', 'Accept-Language, User-Agent, X-foo');\n        $this->assertEquals($vary, $response->getVary(), '->getVary() parses multiple header name values in arrays');\n    }\n\n    public function testSetVary()\n    {\n        $response = new Response();\n        $response->setVary('Accept-Language');\n        $this->assertEquals(['Accept-Language'], $response->getVary());\n\n        $response->setVary('Accept-Language, User-Agent');\n        $this->assertEquals(['Accept-Language', 'User-Agent'], $response->getVary(), '->setVary() replace the vary header by default');\n\n        $response->setVary('X-Foo', false);\n        $this->assertEquals(['Accept-Language', 'User-Agent', 'X-Foo'], $response->getVary(), '->setVary() doesn\\'t wipe out earlier Vary headers if replace is set to false');\n    }\n\n    public function testDefaultContentType()\n    {\n        $response = new Response('foo');\n        $response->prepare(new Request());\n\n        $this->assertSame('text/html; charset=UTF-8', $response->headers->get('Content-Type'));\n    }\n\n    public function testContentTypeCharset()\n    {\n        $response = new Response();\n        $response->headers->set('Content-Type', 'text/css');\n\n        // force fixContentType() to be called\n        $response->prepare(new Request());\n\n        $this->assertEquals('text/css; charset=UTF-8', $response->headers->get('Content-Type'));\n    }\n\n    public function testPrepareDoesNothingIfContentTypeIsSet()\n    {\n        $response = new Response('foo');\n        $response->headers->set('Content-Type', 'text/plain');\n\n        $response->prepare(new Request());\n\n        $this->assertEquals('text/plain; charset=UTF-8', $response->headers->get('content-type'));\n    }\n\n    public function testPrepareDoesNothingIfRequestFormatIsNotDefined()\n    {\n        $response = new Response('foo');\n\n        $response->prepare(new Request());\n\n        $this->assertEquals('text/html; charset=UTF-8', $response->headers->get('content-type'));\n    }\n\n    public function testPrepareSetContentType()\n    {\n        $response = new Response('foo');\n        $request = Request::create('/');\n        $request->setRequestFormat('json');\n        $request->headers->remove('accept');\n\n        $response->prepare($request);\n\n        $this->assertEquals('application/json', $response->headers->get('content-type'));\n    }\n\n    public function testPrepareRemovesContentForHeadRequests()\n    {\n        $response = new Response('foo');\n        $request = Request::create('/', 'HEAD');\n\n        $length = 12345;\n        $response->headers->set('Content-Length', $length);\n        $response->prepare($request);\n\n        $this->assertEquals('', $response->getContent());\n        $this->assertEquals($length, $response->headers->get('Content-Length'), 'Content-Length should be as if it was GET; see RFC2616 14.13');\n    }\n\n    public function testPrepareRemovesContentForInformationalResponse()\n    {\n        $response = new Response('foo');\n        $request = Request::create('/');\n\n        $response->setContent('content');\n        $response->setStatusCode(101);\n        $response->prepare($request);\n        $this->assertEquals('', $response->getContent());\n        $this->assertFalse($response->headers->has('Content-Type'));\n\n        $response->setContent('content');\n        $response->setStatusCode(304);\n        $response->prepare($request);\n        $this->assertEquals('', $response->getContent());\n        $this->assertFalse($response->headers->has('Content-Type'));\n        $this->assertFalse($response->headers->has('Content-Length'));\n    }\n\n    public function testPrepareRemovesContentLength()\n    {\n        $response = new Response('foo');\n        $request = Request::create('/');\n\n        $response->headers->set('Content-Length', 12345);\n        $response->prepare($request);\n        $this->assertEquals(12345, $response->headers->get('Content-Length'));\n\n        $response->headers->set('Transfer-Encoding', 'chunked');\n        $response->prepare($request);\n        $this->assertFalse($response->headers->has('Content-Length'));\n    }\n\n    public function testPrepareSetsPragmaOnHttp10Only()\n    {\n        $request = Request::create('/', 'GET');\n        $request->server->set('SERVER_PROTOCOL', 'HTTP/1.0');\n\n        $response = new Response('foo');\n        $response->prepare($request);\n        $this->assertEquals('no-cache', $response->headers->get('pragma'));\n        $this->assertEquals('-1', $response->headers->get('expires'));\n\n        $request->server->set('SERVER_PROTOCOL', 'HTTP/1.1');\n        $response = new Response('foo');\n        $response->prepare($request);\n        $this->assertFalse($response->headers->has('pragma'));\n        $this->assertFalse($response->headers->has('expires'));\n    }\n\n    public function testPrepareSetsCookiesSecure()\n    {\n        $cookie = Cookie::create('foo', 'bar');\n\n        $response = new Response('foo');\n        $response->headers->setCookie($cookie);\n\n        $request = Request::create('/', 'GET');\n        $response->prepare($request);\n\n        $this->assertFalse($cookie->isSecure());\n\n        $request = Request::create('https://localhost/', 'GET');\n        $response->prepare($request);\n\n        $this->assertTrue($cookie->isSecure());\n    }\n\n    public function testSetCache()\n    {\n        $response = new Response();\n        // ['etag', 'last_modified', 'max_age', 's_maxage', 'private', 'public']\n        try {\n            $response->setCache(['wrong option' => 'value']);\n            $this->fail('->setCache() throws an InvalidArgumentException if an option is not supported');\n        } catch (\\Exception $e) {\n            $this->assertInstanceOf('InvalidArgumentException', $e, '->setCache() throws an InvalidArgumentException if an option is not supported');\n            $this->assertStringContainsString('\"wrong option\"', $e->getMessage());\n        }\n\n        $options = ['etag' => '\"whatever\"'];\n        $response->setCache($options);\n        $this->assertEquals($response->getEtag(), '\"whatever\"');\n\n        $now = $this->createDateTimeNow();\n        $options = ['last_modified' => $now];\n        $response->setCache($options);\n        $this->assertEquals($response->getLastModified()->getTimestamp(), $now->getTimestamp());\n\n        $options = ['max_age' => 100];\n        $response->setCache($options);\n        $this->assertEquals($response->getMaxAge(), 100);\n\n        $options = ['s_maxage' => 200];\n        $response->setCache($options);\n        $this->assertEquals($response->getMaxAge(), 200);\n\n        $this->assertTrue($response->headers->hasCacheControlDirective('public'));\n        $this->assertFalse($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['public' => true]);\n        $this->assertTrue($response->headers->hasCacheControlDirective('public'));\n        $this->assertFalse($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['public' => false]);\n        $this->assertFalse($response->headers->hasCacheControlDirective('public'));\n        $this->assertTrue($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['private' => true]);\n        $this->assertFalse($response->headers->hasCacheControlDirective('public'));\n        $this->assertTrue($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['private' => false]);\n        $this->assertTrue($response->headers->hasCacheControlDirective('public'));\n        $this->assertFalse($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['immutable' => true]);\n        $this->assertTrue($response->headers->hasCacheControlDirective('immutable'));\n\n        $response->setCache(['immutable' => false]);\n        $this->assertFalse($response->headers->hasCacheControlDirective('immutable'));\n    }\n\n    public function testSendContent()\n    {\n        $response = new Response('test response rendering', 200);\n\n        ob_start();\n        $response->sendContent();\n        $string = ob_get_clean();\n        $this->assertStringContainsString('test response rendering', $string);\n    }\n\n    public function testSetPublic()\n    {\n        $response = new Response();\n        $response->setPublic();\n\n        $this->assertTrue($response->headers->hasCacheControlDirective('public'));\n        $this->assertFalse($response->headers->hasCacheControlDirective('private'));\n    }\n\n    public function testSetImmutable()\n    {\n        $response = new Response();\n        $response->setImmutable();\n\n        $this->assertTrue($response->headers->hasCacheControlDirective('immutable'));\n    }\n\n    public function testIsImmutable()\n    {\n        $response = new Response();\n        $response->setImmutable();\n\n        $this->assertTrue($response->isImmutable());\n    }\n\n    public function testSetDate()\n    {\n        $response = new Response();\n        $response->setDate(\\DateTime::createFromFormat(\\DateTime::ATOM, '2013-01-26T09:21:56+0100', new \\DateTimeZone('Europe/Berlin')));\n\n        $this->assertEquals('2013-01-26T08:21:56+00:00', $response->getDate()->format(\\DateTime::ATOM));\n    }\n\n    public function testSetDateWithImmutable()\n    {\n        $response = new Response();\n        $response->setDate(\\DateTimeImmutable::createFromFormat(\\DateTime::ATOM, '2013-01-26T09:21:56+0100', new \\DateTimeZone('Europe/Berlin')));\n\n        $this->assertEquals('2013-01-26T08:21:56+00:00', $response->getDate()->format(\\DateTime::ATOM));\n    }\n\n    public function testSetExpires()\n    {\n        $response = new Response();\n        $response->setExpires(null);\n\n        $this->assertNull($response->getExpires(), '->setExpires() remove the header when passed null');\n\n        $now = $this->createDateTimeNow();\n        $response->setExpires($now);\n\n        $this->assertEquals($response->getExpires()->getTimestamp(), $now->getTimestamp());\n    }\n\n    public function testSetExpiresWithImmutable()\n    {\n        $response = new Response();\n\n        $now = $this->createDateTimeImmutableNow();\n        $response->setExpires($now);\n\n        $this->assertEquals($response->getExpires()->getTimestamp(), $now->getTimestamp());\n    }\n\n    public function testSetLastModified()\n    {\n        $response = new Response();\n        $response->setLastModified($this->createDateTimeNow());\n        $this->assertNotNull($response->getLastModified());\n\n        $response->setLastModified(null);\n        $this->assertNull($response->getLastModified());\n    }\n\n    public function testSetLastModifiedWithImmutable()\n    {\n        $response = new Response();\n        $response->setLastModified($this->createDateTimeImmutableNow());\n        $this->assertNotNull($response->getLastModified());\n\n        $response->setLastModified(null);\n        $this->assertNull($response->getLastModified());\n    }\n\n    public function testIsInvalid()\n    {\n        $response = new Response();\n\n        try {\n            $response->setStatusCode(99);\n            $this->fail();\n        } catch (\\InvalidArgumentException $e) {\n            $this->assertTrue($response->isInvalid());\n        }\n\n        try {\n            $response->setStatusCode(650);\n            $this->fail();\n        } catch (\\InvalidArgumentException $e) {\n            $this->assertTrue($response->isInvalid());\n        }\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isInvalid());\n    }\n\n    /**\n     * @dataProvider getStatusCodeFixtures\n     */\n    public function testSetStatusCode($code, $text, $expectedText)\n    {\n        $response = new Response();\n\n        $response->setStatusCode($code, $text);\n\n        $statusText = new \\ReflectionProperty($response, 'statusText');\n        $statusText->setAccessible(true);\n\n        $this->assertEquals($expectedText, $statusText->getValue($response));\n    }\n\n    public function getStatusCodeFixtures()\n    {\n        return [\n            ['200', null, 'OK'],\n            ['200', false, ''],\n            ['200', 'foo', 'foo'],\n            ['199', null, 'unknown status'],\n            ['199', false, ''],\n            ['199', 'foo', 'foo'],\n        ];\n    }\n\n    public function testIsInformational()\n    {\n        $response = new Response('', 100);\n        $this->assertTrue($response->isInformational());\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isInformational());\n    }\n\n    public function testIsRedirectRedirection()\n    {\n        foreach ([301, 302, 303, 307] as $code) {\n            $response = new Response('', $code);\n            $this->assertTrue($response->isRedirection());\n            $this->assertTrue($response->isRedirect());\n        }\n\n        $response = new Response('', 304);\n        $this->assertTrue($response->isRedirection());\n        $this->assertFalse($response->isRedirect());\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isRedirection());\n        $this->assertFalse($response->isRedirect());\n\n        $response = new Response('', 404);\n        $this->assertFalse($response->isRedirection());\n        $this->assertFalse($response->isRedirect());\n\n        $response = new Response('', 301, ['Location' => '/good-uri']);\n        $this->assertFalse($response->isRedirect('/bad-uri'));\n        $this->assertTrue($response->isRedirect('/good-uri'));\n    }\n\n    public function testIsNotFound()\n    {\n        $response = new Response('', 404);\n        $this->assertTrue($response->isNotFound());\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isNotFound());\n    }\n\n    public function testIsEmpty()\n    {\n        foreach ([204, 304] as $code) {\n            $response = new Response('', $code);\n            $this->assertTrue($response->isEmpty());\n        }\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isEmpty());\n    }\n\n    public function testIsForbidden()\n    {\n        $response = new Response('', 403);\n        $this->assertTrue($response->isForbidden());\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isForbidden());\n    }\n\n    public function testIsOk()\n    {\n        $response = new Response('', 200);\n        $this->assertTrue($response->isOk());\n\n        $response = new Response('', 404);\n        $this->assertFalse($response->isOk());\n    }\n\n    public function testIsServerOrClientError()\n    {\n        $response = new Response('', 404);\n        $this->assertTrue($response->isClientError());\n        $this->assertFalse($response->isServerError());\n\n        $response = new Response('', 500);\n        $this->assertFalse($response->isClientError());\n        $this->assertTrue($response->isServerError());\n    }\n\n    public function testHasVary()\n    {\n        $response = new Response();\n        $this->assertFalse($response->hasVary());\n\n        $response->setVary('User-Agent');\n        $this->assertTrue($response->hasVary());\n    }\n\n    public function testSetEtag()\n    {\n        $response = new Response('', 200, ['ETag' => '\"12345\"']);\n        $response->setEtag();\n\n        $this->assertNull($response->headers->get('Etag'), '->setEtag() removes Etags when call with null');\n    }\n\n    /**\n     * @dataProvider validContentProvider\n     */\n    public function testSetContent($content)\n    {\n        $response = new Response();\n        $response->setContent($content);\n        $this->assertEquals((string) $content, $response->getContent());\n    }\n\n    /**\n     * @dataProvider invalidContentProvider\n     */\n    public function testSetContentInvalid($content)\n    {\n        $this->expectException('UnexpectedValueException');\n        $response = new Response();\n        $response->setContent($content);\n    }\n\n    public function testSettersAreChainable()\n    {\n        $response = new Response();\n\n        $setters = [\n            'setProtocolVersion' => '1.0',\n            'setCharset' => 'UTF-8',\n            'setPublic' => null,\n            'setPrivate' => null,\n            'setDate' => $this->createDateTimeNow(),\n            'expire' => null,\n            'setMaxAge' => 1,\n            'setSharedMaxAge' => 1,\n            'setTtl' => 1,\n            'setClientTtl' => 1,\n        ];\n\n        foreach ($setters as $setter => $arg) {\n            $this->assertEquals($response, $response->{$setter}($arg));\n        }\n    }\n\n    public function testNoDeprecationsAreTriggered()\n    {\n        new DefaultResponse();\n        $this->getMockBuilder(Response::class)->getMock();\n\n        // we just need to ensure that subclasses of Response can be created without any deprecations\n        // being triggered if the subclass does not override any final methods\n        $this->addToAssertionCount(1);\n    }\n\n    public function validContentProvider()\n    {\n        return [\n            'obj' => [new StringableObject()],\n            'string' => ['Foo'],\n            'int' => [2],\n        ];\n    }\n\n    public function invalidContentProvider()\n    {\n        return [\n            'obj' => [new \\stdClass()],\n            'array' => [[]],\n            'bool' => [true, '1'],\n        ];\n    }\n\n    protected function createDateTimeOneHourAgo()\n    {\n        return $this->createDateTimeNow()->sub(new \\DateInterval('PT1H'));\n    }\n\n    protected function createDateTimeOneHourLater()\n    {\n        return $this->createDateTimeNow()->add(new \\DateInterval('PT1H'));\n    }\n\n    protected function createDateTimeNow()\n    {\n        $date = new \\DateTime();\n\n        return $date->setTimestamp(time());\n    }\n\n    protected function createDateTimeImmutableNow()\n    {\n        $date = new \\DateTimeImmutable();\n\n        return $date->setTimestamp(time());\n    }\n\n    protected function provideResponse()\n    {\n        return new Response();\n    }\n\n    /**\n     * @see http://github.com/zendframework/zend-diactoros for the canonical source repository\n     *\n     * @author F\u00e1bio Pacheco\n     * @copyright Copyright (c) 2015-2016 Zend Technologies USA Inc. (http://www.zend.com)\n     * @license https://github.com/zendframework/zend-diactoros/blob/master/LICENSE.md New BSD License\n     */\n    public function ianaCodesReasonPhrasesProvider()\n    {\n        if (!\\in_array('https', stream_get_wrappers(), true)) {\n            $this->markTestSkipped('The \"https\" wrapper is not available');\n        }\n\n        $ianaHttpStatusCodes = new \\DOMDocument();\n\n        $context = stream_context_create([\n            'http' => [\n                'method' => 'GET',\n                'timeout' => 30,\n                'user_agent' => __METHOD__,\n            ],\n        ]);\n\n        $ianaHttpStatusCodes->loadXML(file_get_contents('https://www.iana.org/assignments/http-status-codes/http-status-codes.xml', false, $context));\n        if (!$ianaHttpStatusCodes->relaxNGValidate(__DIR__.'/schema/http-status-codes.rng')) {\n            self::fail('Invalid IANA\\'s HTTP status code list.');\n        }\n\n        $ianaCodesReasonPhrases = [];\n\n        $xpath = new \\DOMXPath($ianaHttpStatusCodes);\n        $xpath->registerNamespace('ns', 'http://www.iana.org/assignments');\n\n        $records = $xpath->query('//ns:record');\n        foreach ($records as $record) {\n            $value = $xpath->query('.//ns:value', $record)->item(0)->nodeValue;\n            $description = $xpath->query('.//ns:description', $record)->item(0)->nodeValue;\n\n            if (\\in_array($description, ['Unassigned', '(Unused)'], true)) {\n                continue;\n            }\n\n            if (preg_match('/^([0-9]+)\\s*\\-\\s*([0-9]+)$/', $value, $matches)) {\n                for ($value = $matches[1]; $value <= $matches[2]; ++$value) {\n                    $ianaCodesReasonPhrases[] = [$value, $description];\n                }\n            } else {\n                $ianaCodesReasonPhrases[] = [$value, $description];\n            }\n        }\n\n        return $ianaCodesReasonPhrases;\n    }\n\n    /**\n     * @dataProvider ianaCodesReasonPhrasesProvider\n     */\n    public function testReasonPhraseDefaultsAgainstIana($code, $reasonPhrase)\n    {\n        $this->assertEquals($reasonPhrase, Response::$statusTexts[$code]);\n    }\n}\n\nclass StringableObject\n{\n    public function __toString(): string\n    {\n        return 'Foo';\n    }\n}\n\nclass DefaultResponse extends Response\n{\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\ErrorHandler\\ErrorRenderer;\n\nuse Symfony\\Component\\ErrorHandler\\Exception\\FlattenException;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\Serializer\\Exception\\NotEncodableValueException;\nuse Symfony\\Component\\Serializer\\SerializerInterface;\n\n/**\n * Formats an exception using Serializer for rendering.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n */\nclass SerializerErrorRenderer implements ErrorRendererInterface\n{\n    private $serializer;\n    private $format;\n    private $fallbackErrorRenderer;\n    private $debug;\n\n    /**\n     * @param string|callable(FlattenException) $format The format as a string or a callable that should return it\n     *                                                  formats not supported by Request::getMimeTypes() should be given as mime types\n     * @param bool|callable                     $debug  The debugging mode as a boolean or a callable that should return it\n     */\n    public function __construct(SerializerInterface $serializer, $format, ErrorRendererInterface $fallbackErrorRenderer = null, $debug = false)\n    {\n        if (!\\is_string($format) && !\\is_callable($format)) {\n            throw new \\TypeError(sprintf('Argument 2 passed to \"%s()\" must be a string or a callable, \"%s\" given.', __METHOD__, \\is_object($format) ? \\get_class($format) : \\gettype($format)));\n        }\n\n        if (!\\is_bool($debug) && !\\is_callable($debug)) {\n            throw new \\TypeError(sprintf('Argument 4 passed to \"%s()\" must be a boolean or a callable, \"%s\" given.', __METHOD__, \\is_object($debug) ? \\get_class($debug) : \\gettype($debug)));\n        }\n\n        $this->serializer = $serializer;\n        $this->format = $format;\n        $this->fallbackErrorRenderer = $fallbackErrorRenderer ?? new HtmlErrorRenderer();\n        $this->debug = $debug;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function render(\\Throwable $exception): FlattenException\n    {\n        $flattenException = FlattenException::createFromThrowable($exception);\n\n        try {\n            $format = \\is_string($this->format) ? $this->format : ($this->format)($flattenException);\n            $headers = [\n                'Content-Type' => Request::getMimeTypes($format)[0] ?? $format,\n                'Vary' => 'Accept',\n            ];\n\n            return $flattenException->setAsString($this->serializer->serialize($flattenException, $format, [\n                'exception' => $exception,\n                'debug' => \\is_bool($this->debug) ? $this->debug : ($this->debug)($exception),\n            ]))\n            ->setHeaders($flattenException->getHeaders() + $headers);\n        } catch (NotEncodableValueException $e) {\n            return $this->fallbackErrorRenderer->render($exception);\n        }\n    }\n\n    public static function getPreferredFormat(RequestStack $requestStack): \\Closure\n    {\n        return static function () use ($requestStack) {\n            if (!$request = $requestStack->getCurrentRequest()) {\n                throw new NotEncodableValueException();\n            }\n\n            return $request->getPreferredFormat();\n        };\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\nuse Symfony\\Component\\HttpFoundation\\Exception\\ConflictingHeadersException;\nuse Symfony\\Component\\HttpFoundation\\Exception\\SuspiciousOperationException;\nuse Symfony\\Component\\HttpFoundation\\Session\\SessionInterface;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(AcceptHeader::class);\nclass_exists(FileBag::class);\nclass_exists(HeaderBag::class);\nclass_exists(HeaderUtils::class);\nclass_exists(ParameterBag::class);\nclass_exists(ServerBag::class);\n\n/**\n * Request represents an HTTP request.\n *\n * The methods dealing with URL accept / return a raw path (% encoded):\n *   * getBasePath\n *   * getBaseUrl\n *   * getPathInfo\n *   * getRequestUri\n *   * getUri\n *   * getUriForPath\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Request\n{\n    const HEADER_FORWARDED = 0b00001; // When using RFC 7239\n    const HEADER_X_FORWARDED_FOR = 0b00010;\n    const HEADER_X_FORWARDED_HOST = 0b00100;\n    const HEADER_X_FORWARDED_PROTO = 0b01000;\n    const HEADER_X_FORWARDED_PORT = 0b10000;\n    const HEADER_X_FORWARDED_ALL = 0b11110; // All \"X-Forwarded-*\" headers\n    const HEADER_X_FORWARDED_AWS_ELB = 0b11010; // AWS ELB doesn't send X-Forwarded-Host\n\n    const METHOD_HEAD = 'HEAD';\n    const METHOD_GET = 'GET';\n    const METHOD_POST = 'POST';\n    const METHOD_PUT = 'PUT';\n    const METHOD_PATCH = 'PATCH';\n    const METHOD_DELETE = 'DELETE';\n    const METHOD_PURGE = 'PURGE';\n    const METHOD_OPTIONS = 'OPTIONS';\n    const METHOD_TRACE = 'TRACE';\n    const METHOD_CONNECT = 'CONNECT';\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedProxies = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHostPatterns = [];\n\n    /**\n     * @var string[]\n     */\n    protected static $trustedHosts = [];\n\n    protected static $httpMethodParameterOverride = false;\n\n    /**\n     * Custom parameters.\n     *\n     * @var ParameterBag\n     */\n    public $attributes;\n\n    /**\n     * Request body parameters ($_POST).\n     *\n     * @var ParameterBag\n     */\n    public $request;\n\n    /**\n     * Query string parameters ($_GET).\n     *\n     * @var ParameterBag\n     */\n    public $query;\n\n    /**\n     * Server and execution environment parameters ($_SERVER).\n     *\n     * @var ServerBag\n     */\n    public $server;\n\n    /**\n     * Uploaded files ($_FILES).\n     *\n     * @var FileBag\n     */\n    public $files;\n\n    /**\n     * Cookies ($_COOKIE).\n     *\n     * @var ParameterBag\n     */\n    public $cookies;\n\n    /**\n     * Headers (taken from the $_SERVER).\n     *\n     * @var HeaderBag\n     */\n    public $headers;\n\n    /**\n     * @var string|resource|false|null\n     */\n    protected $content;\n\n    /**\n     * @var array\n     */\n    protected $languages;\n\n    /**\n     * @var array\n     */\n    protected $charsets;\n\n    /**\n     * @var array\n     */\n    protected $encodings;\n\n    /**\n     * @var array\n     */\n    protected $acceptableContentTypes;\n\n    /**\n     * @var string\n     */\n    protected $pathInfo;\n\n    /**\n     * @var string\n     */\n    protected $requestUri;\n\n    /**\n     * @var string\n     */\n    protected $baseUrl;\n\n    /**\n     * @var string\n     */\n    protected $basePath;\n\n    /**\n     * @var string\n     */\n    protected $method;\n\n    /**\n     * @var string\n     */\n    protected $format;\n\n    /**\n     * @var SessionInterface\n     */\n    protected $session;\n\n    /**\n     * @var string\n     */\n    protected $locale;\n\n    /**\n     * @var string\n     */\n    protected $defaultLocale = 'en';\n\n    /**\n     * @var array\n     */\n    protected static $formats;\n\n    protected static $requestFactory;\n\n    /**\n     * @var string|null\n     */\n    private $preferredFormat;\n    private $isHostValid = true;\n    private $isForwardedValid = true;\n\n    private static $trustedHeaderSet = -1;\n\n    private static $forwardedParams = [\n        self::HEADER_X_FORWARDED_FOR => 'for',\n        self::HEADER_X_FORWARDED_HOST => 'host',\n        self::HEADER_X_FORWARDED_PROTO => 'proto',\n        self::HEADER_X_FORWARDED_PORT => 'host',\n    ];\n\n    /**\n     * Names for headers that can be trusted when\n     * using trusted proxies.\n     *\n     * The FORWARDED header is the standard as of rfc7239.\n     *\n     * The other headers are non-standard, but widely used\n     * by popular reverse proxies (like Apache mod_proxy or Amazon EC2).\n     */\n    private static $trustedHeaders = [\n        self::HEADER_FORWARDED => 'FORWARDED',\n        self::HEADER_X_FORWARDED_FOR => 'X_FORWARDED_FOR',\n        self::HEADER_X_FORWARDED_HOST => 'X_FORWARDED_HOST',\n        self::HEADER_X_FORWARDED_PROTO => 'X_FORWARDED_PROTO',\n        self::HEADER_X_FORWARDED_PORT => 'X_FORWARDED_PORT',\n    ];\n\n    /**\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function __construct(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->initialize($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets the parameters for this request.\n     *\n     * This method also re-initializes all properties.\n     *\n     * @param array                $query      The GET parameters\n     * @param array                $request    The POST parameters\n     * @param array                $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array                $cookies    The COOKIE parameters\n     * @param array                $files      The FILES parameters\n     * @param array                $server     The SERVER parameters\n     * @param string|resource|null $content    The raw body data\n     */\n    public function initialize(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null)\n    {\n        $this->request = new ParameterBag($request);\n        $this->query = new ParameterBag($query);\n        $this->attributes = new ParameterBag($attributes);\n        $this->cookies = new ParameterBag($cookies);\n        $this->files = new FileBag($files);\n        $this->server = new ServerBag($server);\n        $this->headers = new HeaderBag($this->server->getHeaders());\n\n        $this->content = $content;\n        $this->languages = null;\n        $this->charsets = null;\n        $this->encodings = null;\n        $this->acceptableContentTypes = null;\n        $this->pathInfo = null;\n        $this->requestUri = null;\n        $this->baseUrl = null;\n        $this->basePath = null;\n        $this->method = null;\n        $this->format = null;\n    }\n\n    /**\n     * Creates a new request with values from PHP's super globals.\n     *\n     * @return static\n     */\n    public static function createFromGlobals()\n    {\n        $request = self::createRequestFromFactory($_GET, $_POST, [], $_COOKIE, $_FILES, $_SERVER);\n\n        if (0 === strpos($request->headers->get('CONTENT_TYPE'), 'application/x-www-form-urlencoded')\n            && \\in_array(strtoupper($request->server->get('REQUEST_METHOD', 'GET')), ['PUT', 'DELETE', 'PATCH'])\n        ) {\n            parse_str($request->getContent(), $data);\n            $request->request = new ParameterBag($data);\n        }\n\n        return $request;\n    }\n\n    /**\n     * Creates a Request based on a given URI and configuration.\n     *\n     * The information contained in the URI always take precedence\n     * over the other information (server and parameters).\n     *\n     * @param string               $uri        The URI\n     * @param string               $method     The HTTP method\n     * @param array                $parameters The query (GET) or request (POST) parameters\n     * @param array                $cookies    The request cookies ($_COOKIE)\n     * @param array                $files      The request files ($_FILES)\n     * @param array                $server     The server parameters ($_SERVER)\n     * @param string|resource|null $content    The raw body data\n     *\n     * @return static\n     */\n    public static function create($uri, $method = 'GET', $parameters = [], $cookies = [], $files = [], $server = [], $content = null)\n    {\n        $server = array_replace([\n            'SERVER_NAME' => 'localhost',\n            'SERVER_PORT' => 80,\n            'HTTP_HOST' => 'localhost',\n            'HTTP_USER_AGENT' => 'Symfony',\n            'HTTP_ACCEPT' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n            'HTTP_ACCEPT_LANGUAGE' => 'en-us,en;q=0.5',\n            'HTTP_ACCEPT_CHARSET' => 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',\n            'REMOTE_ADDR' => '127.0.0.1',\n            'SCRIPT_NAME' => '',\n            'SCRIPT_FILENAME' => '',\n            'SERVER_PROTOCOL' => 'HTTP/1.1',\n            'REQUEST_TIME' => time(),\n        ], $server);\n\n        $server['PATH_INFO'] = '';\n        $server['REQUEST_METHOD'] = strtoupper($method);\n\n        $components = parse_url($uri);\n        if (isset($components['host'])) {\n            $server['SERVER_NAME'] = $components['host'];\n            $server['HTTP_HOST'] = $components['host'];\n        }\n\n        if (isset($components['scheme'])) {\n            if ('https' === $components['scheme']) {\n                $server['HTTPS'] = 'on';\n                $server['SERVER_PORT'] = 443;\n            } else {\n                unset($server['HTTPS']);\n                $server['SERVER_PORT'] = 80;\n            }\n        }\n\n        if (isset($components['port'])) {\n            $server['SERVER_PORT'] = $components['port'];\n            $server['HTTP_HOST'] .= ':'.$components['port'];\n        }\n\n        if (isset($components['user'])) {\n            $server['PHP_AUTH_USER'] = $components['user'];\n        }\n\n        if (isset($components['pass'])) {\n            $server['PHP_AUTH_PW'] = $components['pass'];\n        }\n\n        if (!isset($components['path'])) {\n            $components['path'] = '/';\n        }\n\n        switch (strtoupper($method)) {\n            case 'POST':\n            case 'PUT':\n            case 'DELETE':\n                if (!isset($server['CONTENT_TYPE'])) {\n                    $server['CONTENT_TYPE'] = 'application/x-www-form-urlencoded';\n                }\n                // no break\n            case 'PATCH':\n                $request = $parameters;\n                $query = [];\n                break;\n            default:\n                $request = [];\n                $query = $parameters;\n                break;\n        }\n\n        $queryString = '';\n        if (isset($components['query'])) {\n            parse_str(html_entity_decode($components['query']), $qs);\n\n            if ($query) {\n                $query = array_replace($qs, $query);\n                $queryString = http_build_query($query, '', '&');\n            } else {\n                $query = $qs;\n                $queryString = $components['query'];\n            }\n        } elseif ($query) {\n            $queryString = http_build_query($query, '', '&');\n        }\n\n        $server['REQUEST_URI'] = $components['path'].('' !== $queryString ? '?'.$queryString : '');\n        $server['QUERY_STRING'] = $queryString;\n\n        return self::createRequestFromFactory($query, $request, [], $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Sets a callable able to create a Request instance.\n     *\n     * This is mainly useful when you need to override the Request class\n     * to keep BC with an existing system. It should not be used for any\n     * other purpose.\n     *\n     * @param callable|null $callable A PHP callable\n     */\n    public static function setFactory($callable)\n    {\n        self::$requestFactory = $callable;\n    }\n\n    /**\n     * Clones a request and overrides some of its parameters.\n     *\n     * @param array $query      The GET parameters\n     * @param array $request    The POST parameters\n     * @param array $attributes The request attributes (parameters parsed from the PATH_INFO, ...)\n     * @param array $cookies    The COOKIE parameters\n     * @param array $files      The FILES parameters\n     * @param array $server     The SERVER parameters\n     *\n     * @return static\n     */\n    public function duplicate(array $query = null, array $request = null, array $attributes = null, array $cookies = null, array $files = null, array $server = null)\n    {\n        $dup = clone $this;\n        if (null !== $query) {\n            $dup->query = new ParameterBag($query);\n        }\n        if (null !== $request) {\n            $dup->request = new ParameterBag($request);\n        }\n        if (null !== $attributes) {\n            $dup->attributes = new ParameterBag($attributes);\n        }\n        if (null !== $cookies) {\n            $dup->cookies = new ParameterBag($cookies);\n        }\n        if (null !== $files) {\n            $dup->files = new FileBag($files);\n        }\n        if (null !== $server) {\n            $dup->server = new ServerBag($server);\n            $dup->headers = new HeaderBag($dup->server->getHeaders());\n        }\n        $dup->languages = null;\n        $dup->charsets = null;\n        $dup->encodings = null;\n        $dup->acceptableContentTypes = null;\n        $dup->pathInfo = null;\n        $dup->requestUri = null;\n        $dup->baseUrl = null;\n        $dup->basePath = null;\n        $dup->method = null;\n        $dup->format = null;\n\n        if (!$dup->get('_format') && $this->get('_format')) {\n            $dup->attributes->set('_format', $this->get('_format'));\n        }\n\n        if (!$dup->getRequestFormat(null)) {\n            $dup->setRequestFormat($this->getRequestFormat(null));\n        }\n\n        return $dup;\n    }\n\n    /**\n     * Clones the current request.\n     *\n     * Note that the session is not cloned as duplicated requests\n     * are most of the time sub-requests of the main one.\n     */\n    public function __clone()\n    {\n        $this->query = clone $this->query;\n        $this->request = clone $this->request;\n        $this->attributes = clone $this->attributes;\n        $this->cookies = clone $this->cookies;\n        $this->files = clone $this->files;\n        $this->server = clone $this->server;\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Returns the request as a string.\n     *\n     * @return string The request\n     */\n    public function __toString()\n    {\n        try {\n            $content = $this->getContent();\n        } catch (\\LogicException $e) {\n            if (\\PHP_VERSION_ID >= 70400) {\n                throw $e;\n            }\n\n            return trigger_error($e, E_USER_ERROR);\n        }\n\n        $cookieHeader = '';\n        $cookies = [];\n\n        foreach ($this->cookies as $k => $v) {\n            $cookies[] = $k.'='.$v;\n        }\n\n        if (!empty($cookies)) {\n            $cookieHeader = 'Cookie: '.implode('; ', $cookies).\"\\r\\n\";\n        }\n\n        return\n            sprintf('%s %s %s', $this->getMethod(), $this->getRequestUri(), $this->server->get('SERVER_PROTOCOL')).\"\\r\\n\".\n            $this->headers.\n            $cookieHeader.\"\\r\\n\".\n            $content;\n    }\n\n    /**\n     * Overrides the PHP global variables according to this request instance.\n     *\n     * It overrides $_GET, $_POST, $_REQUEST, $_SERVER, $_COOKIE.\n     * $_FILES is never overridden, see rfc1867\n     */\n    public function overrideGlobals()\n    {\n        $this->server->set('QUERY_STRING', static::normalizeQueryString(http_build_query($this->query->all(), '', '&')));\n\n        $_GET = $this->query->all();\n        $_POST = $this->request->all();\n        $_SERVER = $this->server->all();\n        $_COOKIE = $this->cookies->all();\n\n        foreach ($this->headers->all() as $key => $value) {\n            $key = strtoupper(str_replace('-', '_', $key));\n            if (\\in_array($key, ['CONTENT_TYPE', 'CONTENT_LENGTH', 'CONTENT_MD5'], true)) {\n                $_SERVER[$key] = implode(', ', $value);\n            } else {\n                $_SERVER['HTTP_'.$key] = implode(', ', $value);\n            }\n        }\n\n        $request = ['g' => $_GET, 'p' => $_POST, 'c' => $_COOKIE];\n\n        $requestOrder = ini_get('request_order') ?: ini_get('variables_order');\n        $requestOrder = preg_replace('#[^cgp]#', '', strtolower($requestOrder)) ?: 'gp';\n\n        $_REQUEST = [[]];\n\n        foreach (str_split($requestOrder) as $order) {\n            $_REQUEST[] = $request[$order];\n        }\n\n        $_REQUEST = array_merge(...$_REQUEST);\n    }\n\n    /**\n     * Sets a list of trusted proxies.\n     *\n     * You should only list the reverse proxies that you manage directly.\n     *\n     * @param array $proxies          A list of trusted proxies, the string 'REMOTE_ADDR' will be replaced with $_SERVER['REMOTE_ADDR']\n     * @param int   $trustedHeaderSet A bit field of Request::HEADER_*, to set which headers to trust from your proxies\n     *\n     * @throws \\InvalidArgumentException When $trustedHeaderSet is invalid\n     */\n    public static function setTrustedProxies(array $proxies, int $trustedHeaderSet)\n    {\n        self::$trustedProxies = array_reduce($proxies, function ($proxies, $proxy) {\n            if ('REMOTE_ADDR' !== $proxy) {\n                $proxies[] = $proxy;\n            } elseif (isset($_SERVER['REMOTE_ADDR'])) {\n                $proxies[] = $_SERVER['REMOTE_ADDR'];\n            }\n\n            return $proxies;\n        }, []);\n        self::$trustedHeaderSet = $trustedHeaderSet;\n    }\n\n    /**\n     * Gets the list of trusted proxies.\n     *\n     * @return array An array of trusted proxies\n     */\n    public static function getTrustedProxies()\n    {\n        return self::$trustedProxies;\n    }\n\n    /**\n     * Gets the set of trusted headers from trusted proxies.\n     *\n     * @return int A bit field of Request::HEADER_* that defines which headers are trusted from your proxies\n     */\n    public static function getTrustedHeaderSet()\n    {\n        return self::$trustedHeaderSet;\n    }\n\n    /**\n     * Sets a list of trusted host patterns.\n     *\n     * You should only list the hosts you manage using regexs.\n     *\n     * @param array $hostPatterns A list of trusted host patterns\n     */\n    public static function setTrustedHosts(array $hostPatterns)\n    {\n        self::$trustedHostPatterns = array_map(function ($hostPattern) {\n            return sprintf('{%s}i', $hostPattern);\n        }, $hostPatterns);\n        // we need to reset trusted hosts on trusted host patterns change\n        self::$trustedHosts = [];\n    }\n\n    /**\n     * Gets the list of trusted host patterns.\n     *\n     * @return array An array of trusted host patterns\n     */\n    public static function getTrustedHosts()\n    {\n        return self::$trustedHostPatterns;\n    }\n\n    /**\n     * Normalizes a query string.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized,\n     * have consistent escaping and unneeded delimiters are removed.\n     *\n     * @param string $qs Query string\n     *\n     * @return string A normalized query string for the Request\n     */\n    public static function normalizeQueryString($qs)\n    {\n        if ('' === ($qs ?? '')) {\n            return '';\n        }\n\n        parse_str($qs, $qs);\n        ksort($qs);\n\n        return http_build_query($qs, '', '&', PHP_QUERY_RFC3986);\n    }\n\n    /**\n     * Enables support for the _method request parameter to determine the intended HTTP method.\n     *\n     * Be warned that enabling this feature might lead to CSRF issues in your code.\n     * Check that you are using CSRF tokens when required.\n     * If the HTTP method parameter override is enabled, an html-form with method \"POST\" can be altered\n     * and used to send a \"PUT\" or \"DELETE\" request via the _method request parameter.\n     * If these methods are not protected against CSRF, this presents a possible vulnerability.\n     *\n     * The HTTP method can only be overridden when the real HTTP method is POST.\n     */\n    public static function enableHttpMethodParameterOverride()\n    {\n        self::$httpMethodParameterOverride = true;\n    }\n\n    /**\n     * Checks whether support for the _method request parameter is enabled.\n     *\n     * @return bool True when the _method request parameter is enabled, false otherwise\n     */\n    public static function getHttpMethodParameterOverride()\n    {\n        return self::$httpMethodParameterOverride;\n    }\n\n    /**\n     * Gets a \"parameter\" value from any bag.\n     *\n     * This method is mainly useful for libraries that want to provide some flexibility. If you don't need the\n     * flexibility in controllers, it is better to explicitly get request parameters from the appropriate\n     * public property instead (attributes, query, request).\n     *\n     * Order of precedence: PATH (routing placeholders or custom attributes), GET, BODY\n     *\n     * @param string $key     The key\n     * @param mixed  $default The default value if the parameter key does not exist\n     *\n     * @return mixed\n     */\n    public function get($key, $default = null)\n    {\n        if ($this !== $result = $this->attributes->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->query->get($key, $this)) {\n            return $result;\n        }\n\n        if ($this !== $result = $this->request->get($key, $this)) {\n            return $result;\n        }\n\n        return $default;\n    }\n\n    /**\n     * Gets the Session.\n     *\n     * @return SessionInterface The session\n     */\n    public function getSession()\n    {\n        $session = $this->session;\n        if (!$session instanceof SessionInterface && null !== $session) {\n            $this->setSession($session = $session());\n        }\n\n        if (null === $session) {\n            @trigger_error(sprintf('Calling \"%s()\" when no session has been set is deprecated since Symfony 4.1 and will throw an exception in 5.0. Use \"hasSession()\" instead.', __METHOD__), E_USER_DEPRECATED);\n            // throw new \\BadMethodCallException('Session has not been set.');\n        }\n\n        return $session;\n    }\n\n    /**\n     * Whether the request contains a Session which was started in one of the\n     * previous requests.\n     *\n     * @return bool\n     */\n    public function hasPreviousSession()\n    {\n        // the check for $this->session avoids malicious users trying to fake a session cookie with proper name\n        return $this->hasSession() && $this->cookies->has($this->getSession()->getName());\n    }\n\n    /**\n     * Whether the request contains a Session object.\n     *\n     * This method does not give any information about the state of the session object,\n     * like whether the session is started or not. It is just a way to check if this Request\n     * is associated with a Session instance.\n     *\n     * @return bool true when the Request contains a Session object, false otherwise\n     */\n    public function hasSession()\n    {\n        return null !== $this->session;\n    }\n\n    public function setSession(SessionInterface $session)\n    {\n        $this->session = $session;\n    }\n\n    /**\n     * @internal\n     */\n    public function setSessionFactory(callable $factory)\n    {\n        $this->session = $factory;\n    }\n\n    /**\n     * Returns the client IP addresses.\n     *\n     * In the returned array the most trusted IP address is first, and the\n     * least trusted one last. The \"real\" client IP address is the last one,\n     * but this is also the least trusted one. Trusted proxies are stripped.\n     *\n     * Use this method carefully; you should use getClientIp() instead.\n     *\n     * @return array The client IP addresses\n     *\n     * @see getClientIp()\n     */\n    public function getClientIps()\n    {\n        $ip = $this->server->get('REMOTE_ADDR');\n\n        if (!$this->isFromTrustedProxy()) {\n            return [$ip];\n        }\n\n        return $this->getTrustedValues(self::HEADER_X_FORWARDED_FOR, $ip) ?: [$ip];\n    }\n\n    /**\n     * Returns the client IP address.\n     *\n     * This method can read the client IP address from the \"X-Forwarded-For\" header\n     * when trusted proxies were set via \"setTrustedProxies()\". The \"X-Forwarded-For\"\n     * header value is a comma+space separated list of IP addresses, the left-most\n     * being the original client, and each successive proxy that passed the request\n     * adding the IP address where it received the request from.\n     *\n     * If your reverse proxy uses a different header name than \"X-Forwarded-For\",\n     * (\"Client-Ip\" for instance), configure it via the $trustedHeaderSet\n     * argument of the Request::setTrustedProxies() method instead.\n     *\n     * @return string|null The client IP address\n     *\n     * @see getClientIps()\n     * @see https://wikipedia.org/wiki/X-Forwarded-For\n     */\n    public function getClientIp()\n    {\n        $ipAddresses = $this->getClientIps();\n\n        return $ipAddresses[0];\n    }\n\n    /**\n     * Returns current script name.\n     *\n     * @return string\n     */\n    public function getScriptName()\n    {\n        return $this->server->get('SCRIPT_NAME', $this->server->get('ORIG_SCRIPT_NAME', ''));\n    }\n\n    /**\n     * Returns the path being requested relative to the executed script.\n     *\n     * The path info always starts with a /.\n     *\n     * Suppose this request is instantiated from /mysite on localhost:\n     *\n     *  * http://localhost/mysite              returns an empty string\n     *  * http://localhost/mysite/about        returns '/about'\n     *  * http://localhost/mysite/enco%20ded   returns '/enco%20ded'\n     *  * http://localhost/mysite/about?var=1  returns '/about'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getPathInfo()\n    {\n        if (null === $this->pathInfo) {\n            $this->pathInfo = $this->preparePathInfo();\n        }\n\n        return $this->pathInfo;\n    }\n\n    /**\n     * Returns the root path from which this request is executed.\n     *\n     * Suppose that an index.php file instantiates this request object:\n     *\n     *  * http://localhost/index.php         returns an empty string\n     *  * http://localhost/index.php/page    returns an empty string\n     *  * http://localhost/web/index.php     returns '/web'\n     *  * http://localhost/we%20b/index.php  returns '/we%20b'\n     *\n     * @return string The raw path (i.e. not urldecoded)\n     */\n    public function getBasePath()\n    {\n        if (null === $this->basePath) {\n            $this->basePath = $this->prepareBasePath();\n        }\n\n        return $this->basePath;\n    }\n\n    /**\n     * Returns the root URL from which this request is executed.\n     *\n     * The base URL never ends with a /.\n     *\n     * This is similar to getBasePath(), except that it also includes the\n     * script filename (e.g. index.php) if one exists.\n     *\n     * @return string The raw URL (i.e. not urldecoded)\n     */\n    public function getBaseUrl()\n    {\n        if (null === $this->baseUrl) {\n            $this->baseUrl = $this->prepareBaseUrl();\n        }\n\n        return $this->baseUrl;\n    }\n\n    /**\n     * Gets the request's scheme.\n     *\n     * @return string\n     */\n    public function getScheme()\n    {\n        return $this->isSecure() ? 'https' : 'http';\n    }\n\n    /**\n     * Returns the port on which the request is made.\n     *\n     * This method can read the client port from the \"X-Forwarded-Port\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Port\" header must contain the client port.\n     *\n     * @return int|string can be a string if fetched from the server bag\n     */\n    public function getPort()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_PORT)) {\n            $host = $host[0];\n        } elseif ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            return $this->server->get('SERVER_PORT');\n        }\n\n        if ('[' === $host[0]) {\n            $pos = strpos($host, ':', strrpos($host, ']'));\n        } else {\n            $pos = strrpos($host, ':');\n        }\n\n        if (false !== $pos && $port = substr($host, $pos + 1)) {\n            return (int) $port;\n        }\n\n        return 'https' === $this->getScheme() ? 443 : 80;\n    }\n\n    /**\n     * Returns the user.\n     *\n     * @return string|null\n     */\n    public function getUser()\n    {\n        return $this->headers->get('PHP_AUTH_USER');\n    }\n\n    /**\n     * Returns the password.\n     *\n     * @return string|null\n     */\n    public function getPassword()\n    {\n        return $this->headers->get('PHP_AUTH_PW');\n    }\n\n    /**\n     * Gets the user info.\n     *\n     * @return string A user name and, optionally, scheme-specific information about how to gain authorization to access the server\n     */\n    public function getUserInfo()\n    {\n        $userinfo = $this->getUser();\n\n        $pass = $this->getPassword();\n        if ('' != $pass) {\n            $userinfo .= \":$pass\";\n        }\n\n        return $userinfo;\n    }\n\n    /**\n     * Returns the HTTP host being requested.\n     *\n     * The port name will be appended to the host if it's non-standard.\n     *\n     * @return string\n     */\n    public function getHttpHost()\n    {\n        $scheme = $this->getScheme();\n        $port = $this->getPort();\n\n        if (('http' == $scheme && 80 == $port) || ('https' == $scheme && 443 == $port)) {\n            return $this->getHost();\n        }\n\n        return $this->getHost().':'.$port;\n    }\n\n    /**\n     * Returns the requested URI (path and query string).\n     *\n     * @return string The raw URI (i.e. not URI decoded)\n     */\n    public function getRequestUri()\n    {\n        if (null === $this->requestUri) {\n            $this->requestUri = $this->prepareRequestUri();\n        }\n\n        return $this->requestUri;\n    }\n\n    /**\n     * Gets the scheme and HTTP host.\n     *\n     * If the URL was called with basic authentication, the user\n     * and the password are not added to the generated string.\n     *\n     * @return string The scheme and HTTP host\n     */\n    public function getSchemeAndHttpHost()\n    {\n        return $this->getScheme().'://'.$this->getHttpHost();\n    }\n\n    /**\n     * Generates a normalized URI (URL) for the Request.\n     *\n     * @return string A normalized URI (URL) for the Request\n     *\n     * @see getQueryString()\n     */\n    public function getUri()\n    {\n        if (null !== $qs = $this->getQueryString()) {\n            $qs = '?'.$qs;\n        }\n\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$this->getPathInfo().$qs;\n    }\n\n    /**\n     * Generates a normalized URI for the given path.\n     *\n     * @param string $path A path to use instead of the current one\n     *\n     * @return string The normalized URI for the path\n     */\n    public function getUriForPath($path)\n    {\n        return $this->getSchemeAndHttpHost().$this->getBaseUrl().$path;\n    }\n\n    /**\n     * Returns the path as relative reference from the current Request path.\n     *\n     * Only the URIs path component (no schema, host etc.) is relevant and must be given.\n     * Both paths must be absolute and not contain relative parts.\n     * Relative URLs from one resource to another are useful when generating self-contained downloadable document archives.\n     * Furthermore, they can be used to reduce the link size in documents.\n     *\n     * Example target paths, given a base path of \"/a/b/c/d\":\n     * - \"/a/b/c/d\"     -> \"\"\n     * - \"/a/b/c/\"      -> \"./\"\n     * - \"/a/b/\"        -> \"../\"\n     * - \"/a/b/c/other\" -> \"other\"\n     * - \"/a/x/y\"       -> \"../../x/y\"\n     *\n     * @param string $path The target path\n     *\n     * @return string The relative target path\n     */\n    public function getRelativeUriForPath($path)\n    {\n        // be sure that we are dealing with an absolute path\n        if (!isset($path[0]) || '/' !== $path[0]) {\n            return $path;\n        }\n\n        if ($path === $basePath = $this->getPathInfo()) {\n            return '';\n        }\n\n        $sourceDirs = explode('/', isset($basePath[0]) && '/' === $basePath[0] ? substr($basePath, 1) : $basePath);\n        $targetDirs = explode('/', substr($path, 1));\n        array_pop($sourceDirs);\n        $targetFile = array_pop($targetDirs);\n\n        foreach ($sourceDirs as $i => $dir) {\n            if (isset($targetDirs[$i]) && $dir === $targetDirs[$i]) {\n                unset($sourceDirs[$i], $targetDirs[$i]);\n            } else {\n                break;\n            }\n        }\n\n        $targetDirs[] = $targetFile;\n        $path = str_repeat('../', \\count($sourceDirs)).implode('/', $targetDirs);\n\n        // A reference to the same base directory or an empty subdirectory must be prefixed with \"./\".\n        // This also applies to a segment with a colon character (e.g., \"file:colon\") that cannot be used\n        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name\n        // (see https://tools.ietf.org/html/rfc3986#section-4.2).\n        return !isset($path[0]) || '/' === $path[0]\n            || false !== ($colonPos = strpos($path, ':')) && ($colonPos < ($slashPos = strpos($path, '/')) || false === $slashPos)\n            ? \"./$path\" : $path;\n    }\n\n    /**\n     * Generates the normalized query string for the Request.\n     *\n     * It builds a normalized query string, where keys/value pairs are alphabetized\n     * and have consistent escaping.\n     *\n     * @return string|null A normalized query string for the Request\n     */\n    public function getQueryString()\n    {\n        $qs = static::normalizeQueryString($this->server->get('QUERY_STRING'));\n\n        return '' === $qs ? null : $qs;\n    }\n\n    /**\n     * Checks whether the request is secure or not.\n     *\n     * This method can read the client protocol from the \"X-Forwarded-Proto\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Proto\" header must contain the protocol: \"https\" or \"http\".\n     *\n     * @return bool\n     */\n    public function isSecure()\n    {\n        if ($this->isFromTrustedProxy() && $proto = $this->getTrustedValues(self::HEADER_X_FORWARDED_PROTO)) {\n            return \\in_array(strtolower($proto[0]), ['https', 'on', 'ssl', '1'], true);\n        }\n\n        $https = $this->server->get('HTTPS');\n\n        return !empty($https) && 'off' !== strtolower($https);\n    }\n\n    /**\n     * Returns the host name.\n     *\n     * This method can read the client host name from the \"X-Forwarded-Host\" header\n     * when trusted proxies were set via \"setTrustedProxies()\".\n     *\n     * The \"X-Forwarded-Host\" header must contain the client host name.\n     *\n     * @return string\n     *\n     * @throws SuspiciousOperationException when the host name is invalid or not trusted\n     */\n    public function getHost()\n    {\n        if ($this->isFromTrustedProxy() && $host = $this->getTrustedValues(self::HEADER_X_FORWARDED_HOST)) {\n            $host = $host[0];\n        } elseif (!$host = $this->headers->get('HOST')) {\n            if (!$host = $this->server->get('SERVER_NAME')) {\n                $host = $this->server->get('SERVER_ADDR', '');\n            }\n        }\n\n        // trim and remove port number from host\n        // host is lowercase as per RFC 952/2181\n        $host = strtolower(preg_replace('/:\\d+$/', '', trim($host)));\n\n        // as the host can come from the user (HTTP_HOST and depending on the configuration, SERVER_NAME too can come from the user)\n        // check that it does not contain forbidden characters (see RFC 952 and RFC 2181)\n        // use preg_replace() instead of preg_match() to prevent DoS attacks with long host names\n        if ($host && '' !== preg_replace('/(?:^\\[)?[a-zA-Z0-9-:\\]_]+\\.?/', '', $host)) {\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Invalid Host \"%s\".', $host));\n        }\n\n        if (\\count(self::$trustedHostPatterns) > 0) {\n            // to avoid host header injection attacks, you should provide a list of trusted host patterns\n\n            if (\\in_array($host, self::$trustedHosts)) {\n                return $host;\n            }\n\n            foreach (self::$trustedHostPatterns as $pattern) {\n                if (preg_match($pattern, $host)) {\n                    self::$trustedHosts[] = $host;\n\n                    return $host;\n                }\n            }\n\n            if (!$this->isHostValid) {\n                return '';\n            }\n            $this->isHostValid = false;\n\n            throw new SuspiciousOperationException(sprintf('Untrusted Host \"%s\".', $host));\n        }\n\n        return $host;\n    }\n\n    /**\n     * Sets the request method.\n     *\n     * @param string $method\n     */\n    public function setMethod($method)\n    {\n        $this->method = null;\n        $this->server->set('REQUEST_METHOD', $method);\n    }\n\n    /**\n     * Gets the request \"intended\" method.\n     *\n     * If the X-HTTP-Method-Override header is set, and if the method is a POST,\n     * then it is used to determine the \"real\" intended HTTP method.\n     *\n     * The _method request parameter can also be used to determine the HTTP method,\n     * but only if enableHttpMethodParameterOverride() has been called.\n     *\n     * The method is always an uppercased string.\n     *\n     * @return string The request method\n     *\n     * @see getRealMethod()\n     */\n    public function getMethod()\n    {\n        if (null !== $this->method) {\n            return $this->method;\n        }\n\n        $this->method = strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n\n        if ('POST' !== $this->method) {\n            return $this->method;\n        }\n\n        $method = $this->headers->get('X-HTTP-METHOD-OVERRIDE');\n\n        if (!$method && self::$httpMethodParameterOverride) {\n            $method = $this->request->get('_method', $this->query->get('_method', 'POST'));\n        }\n\n        if (!\\is_string($method)) {\n            return $this->method;\n        }\n\n        $method = strtoupper($method);\n\n        if (\\in_array($method, ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'CONNECT', 'OPTIONS', 'PATCH', 'PURGE', 'TRACE'], true)) {\n            return $this->method = $method;\n        }\n\n        if (!preg_match('/^[A-Z]++$/D', $method)) {\n            throw new SuspiciousOperationException(sprintf('Invalid method override \"%s\".', $method));\n        }\n\n        return $this->method = $method;\n    }\n\n    /**\n     * Gets the \"real\" request method.\n     *\n     * @return string The request method\n     *\n     * @see getMethod()\n     */\n    public function getRealMethod()\n    {\n        return strtoupper($this->server->get('REQUEST_METHOD', 'GET'));\n    }\n\n    /**\n     * Gets the mime type associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return string|null The associated mime type (null if not found)\n     */\n    public function getMimeType($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format][0] : null;\n    }\n\n    /**\n     * Gets the mime types associated with the format.\n     *\n     * @param string $format The format\n     *\n     * @return array The associated mime types\n     */\n    public static function getMimeTypes($format)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        return isset(static::$formats[$format]) ? static::$formats[$format] : [];\n    }\n\n    /**\n     * Gets the format associated with the mime type.\n     *\n     * @param string $mimeType The associated mime type\n     *\n     * @return string|null The format (null if not found)\n     */\n    public function getFormat($mimeType)\n    {\n        $canonicalMimeType = null;\n        if (false !== $pos = strpos($mimeType, ';')) {\n            $canonicalMimeType = trim(substr($mimeType, 0, $pos));\n        }\n\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        foreach (static::$formats as $format => $mimeTypes) {\n            if (\\in_array($mimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n            if (null !== $canonicalMimeType && \\in_array($canonicalMimeType, (array) $mimeTypes)) {\n                return $format;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Associates a format with mime types.\n     *\n     * @param string       $format    The format\n     * @param string|array $mimeTypes The associated mime types (the preferred one must be the first as it will be used as the content type)\n     */\n    public function setFormat($format, $mimeTypes)\n    {\n        if (null === static::$formats) {\n            static::initializeFormats();\n        }\n\n        static::$formats[$format] = \\is_array($mimeTypes) ? $mimeTypes : [$mimeTypes];\n    }\n\n    /**\n     * Gets the request format.\n     *\n     * Here is the process to determine the format:\n     *\n     *  * format defined by the user (with setRequestFormat())\n     *  * _format request attribute\n     *  * $default\n     *\n     * @see getPreferredFormat\n     *\n     * @param string|null $default The default format\n     *\n     * @return string|null The request format\n     */\n    public function getRequestFormat($default = 'html')\n    {\n        if (null === $this->format) {\n            $this->format = $this->attributes->get('_format');\n        }\n\n        return null === $this->format ? $default : $this->format;\n    }\n\n    /**\n     * Sets the request format.\n     *\n     * @param string $format The request format\n     */\n    public function setRequestFormat($format)\n    {\n        $this->format = $format;\n    }\n\n    /**\n     * Gets the format associated with the request.\n     *\n     * @return string|null The format (null if no content type is present)\n     */\n    public function getContentType()\n    {\n        return $this->getFormat($this->headers->get('CONTENT_TYPE'));\n    }\n\n    /**\n     * Sets the default locale.\n     *\n     * @param string $locale\n     */\n    public function setDefaultLocale($locale)\n    {\n        $this->defaultLocale = $locale;\n\n        if (null === $this->locale) {\n            $this->setPhpDefaultLocale($locale);\n        }\n    }\n\n    /**\n     * Get the default locale.\n     *\n     * @return string\n     */\n    public function getDefaultLocale()\n    {\n        return $this->defaultLocale;\n    }\n\n    /**\n     * Sets the locale.\n     *\n     * @param string $locale\n     */\n    public function setLocale($locale)\n    {\n        $this->setPhpDefaultLocale($this->locale = $locale);\n    }\n\n    /**\n     * Get the locale.\n     *\n     * @return string\n     */\n    public function getLocale()\n    {\n        return null === $this->locale ? $this->defaultLocale : $this->locale;\n    }\n\n    /**\n     * Checks if the request method is of specified type.\n     *\n     * @param string $method Uppercase request method (GET, POST etc)\n     *\n     * @return bool\n     */\n    public function isMethod($method)\n    {\n        return $this->getMethod() === strtoupper($method);\n    }\n\n    /**\n     * Checks whether or not the method is safe.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.1\n     *\n     * @return bool\n     */\n    public function isMethodSafe()\n    {\n        if (\\func_num_args() > 0) {\n            @trigger_error(sprintf('Passing arguments to \"%s()\" has been deprecated since Symfony 4.4; use \"%s::isMethodCacheable()\" to check if the method is cacheable instead.', __METHOD__, __CLASS__), E_USER_DEPRECATED);\n        }\n\n        return \\in_array($this->getMethod(), ['GET', 'HEAD', 'OPTIONS', 'TRACE']);\n    }\n\n    /**\n     * Checks whether or not the method is idempotent.\n     *\n     * @return bool\n     */\n    public function isMethodIdempotent()\n    {\n        return \\in_array($this->getMethod(), ['HEAD', 'GET', 'PUT', 'DELETE', 'TRACE', 'OPTIONS', 'PURGE']);\n    }\n\n    /**\n     * Checks whether the method is cacheable or not.\n     *\n     * @see https://tools.ietf.org/html/rfc7231#section-4.2.3\n     *\n     * @return bool True for GET and HEAD, false otherwise\n     */\n    public function isMethodCacheable()\n    {\n        return \\in_array($this->getMethod(), ['GET', 'HEAD']);\n    }\n\n    /**\n     * Returns the protocol version.\n     *\n     * If the application is behind a proxy, the protocol version used in the\n     * requests between the client and the proxy and between the proxy and the\n     * server might be different. This returns the former (from the \"Via\" header)\n     * if the proxy is trusted (see \"setTrustedProxies()\"), otherwise it returns\n     * the latter (from the \"SERVER_PROTOCOL\" server parameter).\n     *\n     * @return string\n     */\n    public function getProtocolVersion()\n    {\n        if ($this->isFromTrustedProxy()) {\n            preg_match('~^(HTTP/)?([1-9]\\.[0-9]) ~', $this->headers->get('Via'), $matches);\n\n            if ($matches) {\n                return 'HTTP/'.$matches[2];\n            }\n        }\n\n        return $this->server->get('SERVER_PROTOCOL');\n    }\n\n    /**\n     * Returns the request body content.\n     *\n     * @param bool $asResource If true, a resource will be returned\n     *\n     * @return string|resource The request body content or a resource to read the body stream\n     *\n     * @throws \\LogicException\n     */\n    public function getContent($asResource = false)\n    {\n        $currentContentIsResource = \\is_resource($this->content);\n\n        if (true === $asResource) {\n            if ($currentContentIsResource) {\n                rewind($this->content);\n\n                return $this->content;\n            }\n\n            // Content passed in parameter (test)\n            if (\\is_string($this->content)) {\n                $resource = fopen('php://temp', 'r+');\n                fwrite($resource, $this->content);\n                rewind($resource);\n\n                return $resource;\n            }\n\n            $this->content = false;\n\n            return fopen('php://input', 'rb');\n        }\n\n        if ($currentContentIsResource) {\n            rewind($this->content);\n\n            return stream_get_contents($this->content);\n        }\n\n        if (null === $this->content || false === $this->content) {\n            $this->content = file_get_contents('php://input');\n        }\n\n        return $this->content;\n    }\n\n    /**\n     * Gets the Etags.\n     *\n     * @return array The entity tags\n     */\n    public function getETags()\n    {\n        return preg_split('/\\s*,\\s*/', $this->headers->get('if_none_match'), null, PREG_SPLIT_NO_EMPTY);\n    }\n\n    /**\n     * @return bool\n     */\n    public function isNoCache()\n    {\n        return $this->headers->hasCacheControlDirective('no-cache') || 'no-cache' == $this->headers->get('Pragma');\n    }\n\n    /**\n     * Gets the preferred format for the response by inspecting, in the following order:\n     *   * the request format set using setRequestFormat\n     *   * the values of the Accept HTTP header\n     *\n     * Note that if you use this method, you should send the \"Vary: Accept\" header\n     * in the response to prevent any issues with intermediary HTTP caches.\n     */\n    public function getPreferredFormat(?string $default = 'html'): ?string\n    {\n        if (null !== $this->preferredFormat || null !== $this->preferredFormat = $this->getRequestFormat(null)) {\n            return $this->preferredFormat;\n        }\n\n        foreach ($this->getAcceptableContentTypes() as $mimeType) {\n            if ($this->preferredFormat = $this->getFormat($mimeType)) {\n                return $this->preferredFormat;\n            }\n        }\n\n        return $default;\n    }\n\n    /**\n     * Returns the preferred language.\n     *\n     * @param string[] $locales An array of ordered available locales\n     *\n     * @return string|null The preferred locale\n     */\n    public function getPreferredLanguage(array $locales = null)\n    {\n        $preferredLanguages = $this->getLanguages();\n\n        if (empty($locales)) {\n            return isset($preferredLanguages[0]) ? $preferredLanguages[0] : null;\n        }\n\n        if (!$preferredLanguages) {\n            return $locales[0];\n        }\n\n        $extendedPreferredLanguages = [];\n        foreach ($preferredLanguages as $language) {\n            $extendedPreferredLanguages[] = $language;\n            if (false !== $position = strpos($language, '_')) {\n                $superLanguage = substr($language, 0, $position);\n                if (!\\in_array($superLanguage, $preferredLanguages)) {\n                    $extendedPreferredLanguages[] = $superLanguage;\n                }\n            }\n        }\n\n        $preferredLanguages = array_values(array_intersect($extendedPreferredLanguages, $locales));\n\n        return isset($preferredLanguages[0]) ? $preferredLanguages[0] : $locales[0];\n    }\n\n    /**\n     * Gets a list of languages acceptable by the client browser.\n     *\n     * @return array Languages ordered in the user browser preferences\n     */\n    public function getLanguages()\n    {\n        if (null !== $this->languages) {\n            return $this->languages;\n        }\n\n        $languages = AcceptHeader::fromString($this->headers->get('Accept-Language'))->all();\n        $this->languages = [];\n        foreach ($languages as $lang => $acceptHeaderItem) {\n            if (false !== strpos($lang, '-')) {\n                $codes = explode('-', $lang);\n                if ('i' === $codes[0]) {\n                    // Language not listed in ISO 639 that are not variants\n                    // of any listed language, which can be registered with the\n                    // i-prefix, such as i-cherokee\n                    if (\\count($codes) > 1) {\n                        $lang = $codes[1];\n                    }\n                } else {\n                    for ($i = 0, $max = \\count($codes); $i < $max; ++$i) {\n                        if (0 === $i) {\n                            $lang = strtolower($codes[0]);\n                        } else {\n                            $lang .= '_'.strtoupper($codes[$i]);\n                        }\n                    }\n                }\n            }\n\n            $this->languages[] = $lang;\n        }\n\n        return $this->languages;\n    }\n\n    /**\n     * Gets a list of charsets acceptable by the client browser.\n     *\n     * @return array List of charsets in preferable order\n     */\n    public function getCharsets()\n    {\n        if (null !== $this->charsets) {\n            return $this->charsets;\n        }\n\n        return $this->charsets = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Charset'))->all());\n    }\n\n    /**\n     * Gets a list of encodings acceptable by the client browser.\n     *\n     * @return array List of encodings in preferable order\n     */\n    public function getEncodings()\n    {\n        if (null !== $this->encodings) {\n            return $this->encodings;\n        }\n\n        return $this->encodings = array_keys(AcceptHeader::fromString($this->headers->get('Accept-Encoding'))->all());\n    }\n\n    /**\n     * Gets a list of content types acceptable by the client browser.\n     *\n     * @return array List of content types in preferable order\n     */\n    public function getAcceptableContentTypes()\n    {\n        if (null !== $this->acceptableContentTypes) {\n            return $this->acceptableContentTypes;\n        }\n\n        return $this->acceptableContentTypes = array_keys(AcceptHeader::fromString($this->headers->get('Accept'))->all());\n    }\n\n    /**\n     * Returns true if the request is a XMLHttpRequest.\n     *\n     * It works if your JavaScript library sets an X-Requested-With HTTP header.\n     * It is known to work with common JavaScript frameworks:\n     *\n     * @see https://wikipedia.org/wiki/List_of_Ajax_frameworks#JavaScript\n     *\n     * @return bool true if the request is an XMLHttpRequest, false otherwise\n     */\n    public function isXmlHttpRequest()\n    {\n        return 'XMLHttpRequest' == $this->headers->get('X-Requested-With');\n    }\n\n    /*\n     * The following methods are derived from code of the Zend Framework (1.10dev - 2010-01-24)\n     *\n     * Code subject to the new BSD license (https://framework.zend.com/license).\n     *\n     * Copyright (c) 2005-2010 Zend Technologies USA Inc. (https://www.zend.com/)\n     */\n\n    protected function prepareRequestUri()\n    {\n        $requestUri = '';\n\n        if ('1' == $this->server->get('IIS_WasUrlRewritten') && '' != $this->server->get('UNENCODED_URL')) {\n            // IIS7 with URL Rewrite: make sure we get the unencoded URL (double slash problem)\n            $requestUri = $this->server->get('UNENCODED_URL');\n            $this->server->remove('UNENCODED_URL');\n            $this->server->remove('IIS_WasUrlRewritten');\n        } elseif ($this->server->has('REQUEST_URI')) {\n            $requestUri = $this->server->get('REQUEST_URI');\n\n            if ('' !== $requestUri && '/' === $requestUri[0]) {\n                // To only use path and query remove the fragment.\n                if (false !== $pos = strpos($requestUri, '#')) {\n                    $requestUri = substr($requestUri, 0, $pos);\n                }\n            } else {\n                // HTTP proxy reqs setup request URI with scheme and host [and port] + the URL path,\n                // only use URL path.\n                $uriComponents = parse_url($requestUri);\n\n                if (isset($uriComponents['path'])) {\n                    $requestUri = $uriComponents['path'];\n                }\n\n                if (isset($uriComponents['query'])) {\n                    $requestUri .= '?'.$uriComponents['query'];\n                }\n            }\n        } elseif ($this->server->has('ORIG_PATH_INFO')) {\n            // IIS 5.0, PHP as CGI\n            $requestUri = $this->server->get('ORIG_PATH_INFO');\n            if ('' != $this->server->get('QUERY_STRING')) {\n                $requestUri .= '?'.$this->server->get('QUERY_STRING');\n            }\n            $this->server->remove('ORIG_PATH_INFO');\n        }\n\n        // normalize the request URI to ease creating sub-requests from this request\n        $this->server->set('REQUEST_URI', $requestUri);\n\n        return $requestUri;\n    }\n\n    /**\n     * Prepares the base URL.\n     *\n     * @return string\n     */\n    protected function prepareBaseUrl()\n    {\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n\n        if (basename($this->server->get('SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('SCRIPT_NAME');\n        } elseif (basename($this->server->get('PHP_SELF')) === $filename) {\n            $baseUrl = $this->server->get('PHP_SELF');\n        } elseif (basename($this->server->get('ORIG_SCRIPT_NAME')) === $filename) {\n            $baseUrl = $this->server->get('ORIG_SCRIPT_NAME'); // 1and1 shared hosting compatibility\n        } else {\n            // Backtrack up the script_filename to find the portion matching\n            // php_self\n            $path = $this->server->get('PHP_SELF', '');\n            $file = $this->server->get('SCRIPT_FILENAME', '');\n            $segs = explode('/', trim($file, '/'));\n            $segs = array_reverse($segs);\n            $index = 0;\n            $last = \\count($segs);\n            $baseUrl = '';\n            do {\n                $seg = $segs[$index];\n                $baseUrl = '/'.$seg.$baseUrl;\n                ++$index;\n            } while ($last > $index && (false !== $pos = strpos($path, $baseUrl)) && 0 != $pos);\n        }\n\n        // Does the baseUrl have anything in common with the request_uri?\n        $requestUri = $this->getRequestUri();\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, $baseUrl)) {\n            // full $baseUrl matches\n            return $prefix;\n        }\n\n        if ($baseUrl && null !== $prefix = $this->getUrlencodedPrefix($requestUri, rtrim(\\dirname($baseUrl), '/'.\\DIRECTORY_SEPARATOR).'/')) {\n            // directory portion of $baseUrl matches\n            return rtrim($prefix, '/'.\\DIRECTORY_SEPARATOR);\n        }\n\n        $truncatedRequestUri = $requestUri;\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $truncatedRequestUri = substr($requestUri, 0, $pos);\n        }\n\n        $basename = basename($baseUrl);\n        if (empty($basename) || !strpos(rawurldecode($truncatedRequestUri), $basename)) {\n            // no match whatsoever; set it blank\n            return '';\n        }\n\n        // If using mod_rewrite or ISAPI_Rewrite strip the script filename\n        // out of baseUrl. $pos !== 0 makes sure it is not matching a value\n        // from PATH_INFO or QUERY_STRING\n        if (\\strlen($requestUri) >= \\strlen($baseUrl) && (false !== $pos = strpos($requestUri, $baseUrl)) && 0 !== $pos) {\n            $baseUrl = substr($requestUri, 0, $pos + \\strlen($baseUrl));\n        }\n\n        return rtrim($baseUrl, '/'.\\DIRECTORY_SEPARATOR);\n    }\n\n    /**\n     * Prepares the base path.\n     *\n     * @return string base path\n     */\n    protected function prepareBasePath()\n    {\n        $baseUrl = $this->getBaseUrl();\n        if (empty($baseUrl)) {\n            return '';\n        }\n\n        $filename = basename($this->server->get('SCRIPT_FILENAME'));\n        if (basename($baseUrl) === $filename) {\n            $basePath = \\dirname($baseUrl);\n        } else {\n            $basePath = $baseUrl;\n        }\n\n        if ('\\\\' === \\DIRECTORY_SEPARATOR) {\n            $basePath = str_replace('\\\\', '/', $basePath);\n        }\n\n        return rtrim($basePath, '/');\n    }\n\n    /**\n     * Prepares the path info.\n     *\n     * @return string path info\n     */\n    protected function preparePathInfo()\n    {\n        if (null === ($requestUri = $this->getRequestUri())) {\n            return '/';\n        }\n\n        // Remove the query string from REQUEST_URI\n        if (false !== $pos = strpos($requestUri, '?')) {\n            $requestUri = substr($requestUri, 0, $pos);\n        }\n        if ('' !== $requestUri && '/' !== $requestUri[0]) {\n            $requestUri = '/'.$requestUri;\n        }\n\n        if (null === ($baseUrl = $this->getBaseUrl())) {\n            return $requestUri;\n        }\n\n        $pathInfo = substr($requestUri, \\strlen($baseUrl));\n        if (false === $pathInfo || '' === $pathInfo) {\n            // If substr() returns false then PATH_INFO is set to an empty string\n            return '/';\n        }\n\n        return (string) $pathInfo;\n    }\n\n    /**\n     * Initializes HTTP request formats.\n     */\n    protected static function initializeFormats()\n    {\n        static::$formats = [\n            'html' => ['text/html', 'application/xhtml+xml'],\n            'txt' => ['text/plain'],\n            'js' => ['application/javascript', 'application/x-javascript', 'text/javascript'],\n            'css' => ['text/css'],\n            'json' => ['application/json', 'application/x-json'],\n            'jsonld' => ['application/ld+json'],\n            'xml' => ['text/xml', 'application/xml', 'application/x-xml'],\n            'rdf' => ['application/rdf+xml'],\n            'atom' => ['application/atom+xml'],\n            'rss' => ['application/rss+xml'],\n            'form' => ['application/x-www-form-urlencoded'],\n        ];\n    }\n\n    private function setPhpDefaultLocale(string $locale): void\n    {\n        // if either the class Locale doesn't exist, or an exception is thrown when\n        // setting the default locale, the intl module is not installed, and\n        // the call can be ignored:\n        try {\n            if (class_exists('Locale', false)) {\n                \\Locale::setDefault($locale);\n            }\n        } catch (\\Exception $e) {\n        }\n    }\n\n    /**\n     * Returns the prefix as encoded in the string when the string starts with\n     * the given prefix, null otherwise.\n     */\n    private function getUrlencodedPrefix(string $string, string $prefix): ?string\n    {\n        if (0 !== strpos(rawurldecode($string), $prefix)) {\n            return null;\n        }\n\n        $len = \\strlen($prefix);\n\n        if (preg_match(sprintf('#^(%%[[:xdigit:]]{2}|.){%d}#', $len), $string, $match)) {\n            return $match[0];\n        }\n\n        return null;\n    }\n\n    private static function createRequestFromFactory(array $query = [], array $request = [], array $attributes = [], array $cookies = [], array $files = [], array $server = [], $content = null): self\n    {\n        if (self::$requestFactory) {\n            $request = (self::$requestFactory)($query, $request, $attributes, $cookies, $files, $server, $content);\n\n            if (!$request instanceof self) {\n                throw new \\LogicException('The Request factory must return an instance of Symfony\\Component\\HttpFoundation\\Request.');\n            }\n\n            return $request;\n        }\n\n        return new static($query, $request, $attributes, $cookies, $files, $server, $content);\n    }\n\n    /**\n     * Indicates whether this request originated from a trusted proxy.\n     *\n     * This can be useful to determine whether or not to trust the\n     * contents of a proxy-specific header.\n     *\n     * @return bool true if the request came from a trusted proxy, false otherwise\n     */\n    public function isFromTrustedProxy()\n    {\n        return self::$trustedProxies && IpUtils::checkIp($this->server->get('REMOTE_ADDR'), self::$trustedProxies);\n    }\n\n    private function getTrustedValues(int $type, string $ip = null): array\n    {\n        $clientValues = [];\n        $forwardedValues = [];\n\n        if ((self::$trustedHeaderSet & $type) && $this->headers->has(self::$trustedHeaders[$type])) {\n            foreach (explode(',', $this->headers->get(self::$trustedHeaders[$type])) as $v) {\n                $clientValues[] = (self::HEADER_X_FORWARDED_PORT === $type ? '0.0.0.0:' : '').trim($v);\n            }\n        }\n\n        if ((self::$trustedHeaderSet & self::HEADER_FORWARDED) && $this->headers->has(self::$trustedHeaders[self::HEADER_FORWARDED])) {\n            $forwarded = $this->headers->get(self::$trustedHeaders[self::HEADER_FORWARDED]);\n            $parts = HeaderUtils::split($forwarded, ',;=');\n            $forwardedValues = [];\n            $param = self::$forwardedParams[$type];\n            foreach ($parts as $subParts) {\n                if (null === $v = HeaderUtils::combine($subParts)[$param] ?? null) {\n                    continue;\n                }\n                if (self::HEADER_X_FORWARDED_PORT === $type) {\n                    if (']' === substr($v, -1) || false === $v = strrchr($v, ':')) {\n                        $v = $this->isSecure() ? ':443' : ':80';\n                    }\n                    $v = '0.0.0.0'.$v;\n                }\n                $forwardedValues[] = $v;\n            }\n        }\n\n        if (null !== $ip) {\n            $clientValues = $this->normalizeAndFilterClientIps($clientValues, $ip);\n            $forwardedValues = $this->normalizeAndFilterClientIps($forwardedValues, $ip);\n        }\n\n        if ($forwardedValues === $clientValues || !$clientValues) {\n            return $forwardedValues;\n        }\n\n        if (!$forwardedValues) {\n            return $clientValues;\n        }\n\n        if (!$this->isForwardedValid) {\n            return null !== $ip ? ['0.0.0.0', $ip] : [];\n        }\n        $this->isForwardedValid = false;\n\n        throw new ConflictingHeadersException(sprintf('The request has both a trusted \"%s\" header and a trusted \"%s\" header, conflicting with each other. You should either configure your proxy to remove one of them, or configure your project to distrust the offending one.', self::$trustedHeaders[self::HEADER_FORWARDED], self::$trustedHeaders[$type]));\n    }\n\n    private function normalizeAndFilterClientIps(array $clientIps, string $ip): array\n    {\n        if (!$clientIps) {\n            return [];\n        }\n        $clientIps[] = $ip; // Complete the IP chain with the IP the request actually came from\n        $firstTrustedIp = null;\n\n        foreach ($clientIps as $key => $clientIp) {\n            if (strpos($clientIp, '.')) {\n                // Strip :port from IPv4 addresses. This is allowed in Forwarded\n                // and may occur in X-Forwarded-For.\n                $i = strpos($clientIp, ':');\n                if ($i) {\n                    $clientIps[$key] = $clientIp = substr($clientIp, 0, $i);\n                }\n            } elseif (0 === strpos($clientIp, '[')) {\n                // Strip brackets and :port from IPv6 addresses.\n                $i = strpos($clientIp, ']', 1);\n                $clientIps[$key] = $clientIp = substr($clientIp, 1, $i - 1);\n            }\n\n            if (!filter_var($clientIp, FILTER_VALIDATE_IP)) {\n                unset($clientIps[$key]);\n\n                continue;\n            }\n\n            if (IpUtils::checkIp($clientIp, self::$trustedProxies)) {\n                unset($clientIps[$key]);\n\n                // Fallback to this when the client IP falls into the range of trusted proxies\n                if (null === $firstTrustedIp) {\n                    $firstTrustedIp = $clientIp;\n                }\n            }\n        }\n\n        // Now the IP chain contains only untrusted proxies and the client IP\n        return $clientIps ? array_reverse($clientIps) : [$firstTrustedIp];\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation;\n\n// Help opcache.preload discover always-needed symbols\nclass_exists(ResponseHeaderBag::class);\n\n/**\n * Response represents an HTTP response.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Response\n{\n    const HTTP_CONTINUE = 100;\n    const HTTP_SWITCHING_PROTOCOLS = 101;\n    const HTTP_PROCESSING = 102;            // RFC2518\n    const HTTP_EARLY_HINTS = 103;           // RFC8297\n    const HTTP_OK = 200;\n    const HTTP_CREATED = 201;\n    const HTTP_ACCEPTED = 202;\n    const HTTP_NON_AUTHORITATIVE_INFORMATION = 203;\n    const HTTP_NO_CONTENT = 204;\n    const HTTP_RESET_CONTENT = 205;\n    const HTTP_PARTIAL_CONTENT = 206;\n    const HTTP_MULTI_STATUS = 207;          // RFC4918\n    const HTTP_ALREADY_REPORTED = 208;      // RFC5842\n    const HTTP_IM_USED = 226;               // RFC3229\n    const HTTP_MULTIPLE_CHOICES = 300;\n    const HTTP_MOVED_PERMANENTLY = 301;\n    const HTTP_FOUND = 302;\n    const HTTP_SEE_OTHER = 303;\n    const HTTP_NOT_MODIFIED = 304;\n    const HTTP_USE_PROXY = 305;\n    const HTTP_RESERVED = 306;\n    const HTTP_TEMPORARY_REDIRECT = 307;\n    const HTTP_PERMANENTLY_REDIRECT = 308;  // RFC7238\n    const HTTP_BAD_REQUEST = 400;\n    const HTTP_UNAUTHORIZED = 401;\n    const HTTP_PAYMENT_REQUIRED = 402;\n    const HTTP_FORBIDDEN = 403;\n    const HTTP_NOT_FOUND = 404;\n    const HTTP_METHOD_NOT_ALLOWED = 405;\n    const HTTP_NOT_ACCEPTABLE = 406;\n    const HTTP_PROXY_AUTHENTICATION_REQUIRED = 407;\n    const HTTP_REQUEST_TIMEOUT = 408;\n    const HTTP_CONFLICT = 409;\n    const HTTP_GONE = 410;\n    const HTTP_LENGTH_REQUIRED = 411;\n    const HTTP_PRECONDITION_FAILED = 412;\n    const HTTP_REQUEST_ENTITY_TOO_LARGE = 413;\n    const HTTP_REQUEST_URI_TOO_LONG = 414;\n    const HTTP_UNSUPPORTED_MEDIA_TYPE = 415;\n    const HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n    const HTTP_EXPECTATION_FAILED = 417;\n    const HTTP_I_AM_A_TEAPOT = 418;                                               // RFC2324\n    const HTTP_MISDIRECTED_REQUEST = 421;                                         // RFC7540\n    const HTTP_UNPROCESSABLE_ENTITY = 422;                                        // RFC4918\n    const HTTP_LOCKED = 423;                                                      // RFC4918\n    const HTTP_FAILED_DEPENDENCY = 424;                                           // RFC4918\n\n    /**\n     * @deprecated\n     */\n    const HTTP_RESERVED_FOR_WEBDAV_ADVANCED_COLLECTIONS_EXPIRED_PROPOSAL = 425;   // RFC2817\n    const HTTP_TOO_EARLY = 425;                                                   // RFC-ietf-httpbis-replay-04\n    const HTTP_UPGRADE_REQUIRED = 426;                                            // RFC2817\n    const HTTP_PRECONDITION_REQUIRED = 428;                                       // RFC6585\n    const HTTP_TOO_MANY_REQUESTS = 429;                                           // RFC6585\n    const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;                             // RFC6585\n    const HTTP_UNAVAILABLE_FOR_LEGAL_REASONS = 451;\n    const HTTP_INTERNAL_SERVER_ERROR = 500;\n    const HTTP_NOT_IMPLEMENTED = 501;\n    const HTTP_BAD_GATEWAY = 502;\n    const HTTP_SERVICE_UNAVAILABLE = 503;\n    const HTTP_GATEWAY_TIMEOUT = 504;\n    const HTTP_VERSION_NOT_SUPPORTED = 505;\n    const HTTP_VARIANT_ALSO_NEGOTIATES_EXPERIMENTAL = 506;                        // RFC2295\n    const HTTP_INSUFFICIENT_STORAGE = 507;                                        // RFC4918\n    const HTTP_LOOP_DETECTED = 508;                                               // RFC5842\n    const HTTP_NOT_EXTENDED = 510;                                                // RFC2774\n    const HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511;                             // RFC6585\n\n    /**\n     * @var ResponseHeaderBag\n     */\n    public $headers;\n\n    /**\n     * @var string\n     */\n    protected $content;\n\n    /**\n     * @var string\n     */\n    protected $version;\n\n    /**\n     * @var int\n     */\n    protected $statusCode;\n\n    /**\n     * @var string\n     */\n    protected $statusText;\n\n    /**\n     * @var string\n     */\n    protected $charset;\n\n    /**\n     * Status codes translation table.\n     *\n     * The list of codes is complete according to the\n     * {@link https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml Hypertext Transfer Protocol (HTTP) Status Code Registry}\n     * (last updated 2016-03-01).\n     *\n     * Unless otherwise noted, the status code is defined in RFC2616.\n     *\n     * @var array\n     */\n    public static $statusTexts = [\n        100 => 'Continue',\n        101 => 'Switching Protocols',\n        102 => 'Processing',            // RFC2518\n        103 => 'Early Hints',\n        200 => 'OK',\n        201 => 'Created',\n        202 => 'Accepted',\n        203 => 'Non-Authoritative Information',\n        204 => 'No Content',\n        205 => 'Reset Content',\n        206 => 'Partial Content',\n        207 => 'Multi-Status',          // RFC4918\n        208 => 'Already Reported',      // RFC5842\n        226 => 'IM Used',               // RFC3229\n        300 => 'Multiple Choices',\n        301 => 'Moved Permanently',\n        302 => 'Found',\n        303 => 'See Other',\n        304 => 'Not Modified',\n        305 => 'Use Proxy',\n        307 => 'Temporary Redirect',\n        308 => 'Permanent Redirect',    // RFC7238\n        400 => 'Bad Request',\n        401 => 'Unauthorized',\n        402 => 'Payment Required',\n        403 => 'Forbidden',\n        404 => 'Not Found',\n        405 => 'Method Not Allowed',\n        406 => 'Not Acceptable',\n        407 => 'Proxy Authentication Required',\n        408 => 'Request Timeout',\n        409 => 'Conflict',\n        410 => 'Gone',\n        411 => 'Length Required',\n        412 => 'Precondition Failed',\n        413 => 'Payload Too Large',\n        414 => 'URI Too Long',\n        415 => 'Unsupported Media Type',\n        416 => 'Range Not Satisfiable',\n        417 => 'Expectation Failed',\n        418 => 'I\\'m a teapot',                                               // RFC2324\n        421 => 'Misdirected Request',                                         // RFC7540\n        422 => 'Unprocessable Entity',                                        // RFC4918\n        423 => 'Locked',                                                      // RFC4918\n        424 => 'Failed Dependency',                                           // RFC4918\n        425 => 'Too Early',                                                   // RFC-ietf-httpbis-replay-04\n        426 => 'Upgrade Required',                                            // RFC2817\n        428 => 'Precondition Required',                                       // RFC6585\n        429 => 'Too Many Requests',                                           // RFC6585\n        431 => 'Request Header Fields Too Large',                             // RFC6585\n        451 => 'Unavailable For Legal Reasons',                               // RFC7725\n        500 => 'Internal Server Error',\n        501 => 'Not Implemented',\n        502 => 'Bad Gateway',\n        503 => 'Service Unavailable',\n        504 => 'Gateway Timeout',\n        505 => 'HTTP Version Not Supported',\n        506 => 'Variant Also Negotiates',                                     // RFC2295\n        507 => 'Insufficient Storage',                                        // RFC4918\n        508 => 'Loop Detected',                                               // RFC5842\n        510 => 'Not Extended',                                                // RFC2774\n        511 => 'Network Authentication Required',                             // RFC6585\n    ];\n\n    /**\n     * @throws \\InvalidArgumentException When the HTTP status code is not valid\n     */\n    public function __construct($content = '', int $status = 200, array $headers = [])\n    {\n        $this->headers = new ResponseHeaderBag($headers);\n        $this->setContent($content);\n        $this->setStatusCode($status);\n        $this->setProtocolVersion('1.0');\n    }\n\n    /**\n     * Factory method for chainability.\n     *\n     * Example:\n     *\n     *     return Response::create($body, 200)\n     *         ->setSharedMaxAge(300);\n     *\n     * @param mixed $content The response content, see setContent()\n     * @param int   $status  The response status code\n     * @param array $headers An array of response headers\n     *\n     * @return static\n     */\n    public static function create($content = '', $status = 200, $headers = [])\n    {\n        return new static($content, $status, $headers);\n    }\n\n    /**\n     * Returns the Response as an HTTP string.\n     *\n     * The string representation of the Response is the same as the\n     * one that will be sent to the client only if the prepare() method\n     * has been called before.\n     *\n     * @return string The Response as an HTTP string\n     *\n     * @see prepare()\n     */\n    public function __toString()\n    {\n        return\n            sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText).\"\\r\\n\".\n            $this->headers.\"\\r\\n\".\n            $this->getContent();\n    }\n\n    /**\n     * Clones the current Response instance.\n     */\n    public function __clone()\n    {\n        $this->headers = clone $this->headers;\n    }\n\n    /**\n     * Prepares the Response before it is sent to the client.\n     *\n     * This method tweaks the Response to ensure that it is\n     * compliant with RFC 2616. Most of the changes are based on\n     * the Request that is \"associated\" with this Response.\n     *\n     * @return $this\n     */\n    public function prepare(Request $request)\n    {\n        $headers = $this->headers;\n\n        if ($this->isInformational() || $this->isEmpty()) {\n            $this->setContent(null);\n            $headers->remove('Content-Type');\n            $headers->remove('Content-Length');\n            // prevent PHP from sending the Content-Type header based on default_mimetype\n            ini_set('default_mimetype', '');\n        } else {\n            // Content-type based on the Request\n            if (!$headers->has('Content-Type')) {\n                $format = $request->getRequestFormat(null);\n                if (null !== $format && $mimeType = $request->getMimeType($format)) {\n                    $headers->set('Content-Type', $mimeType);\n                }\n            }\n\n            // Fix Content-Type\n            $charset = $this->charset ?: 'UTF-8';\n            if (!$headers->has('Content-Type')) {\n                $headers->set('Content-Type', 'text/html; charset='.$charset);\n            } elseif (0 === stripos($headers->get('Content-Type'), 'text/') && false === stripos($headers->get('Content-Type'), 'charset')) {\n                // add the charset\n                $headers->set('Content-Type', $headers->get('Content-Type').'; charset='.$charset);\n            }\n\n            // Fix Content-Length\n            if ($headers->has('Transfer-Encoding')) {\n                $headers->remove('Content-Length');\n            }\n\n            if ($request->isMethod('HEAD')) {\n                // cf. RFC2616 14.13\n                $length = $headers->get('Content-Length');\n                $this->setContent(null);\n                if ($length) {\n                    $headers->set('Content-Length', $length);\n                }\n            }\n        }\n\n        // Fix protocol\n        if ('HTTP/1.0' != $request->server->get('SERVER_PROTOCOL')) {\n            $this->setProtocolVersion('1.1');\n        }\n\n        // Check if we need to send extra expire info headers\n        if ('1.0' == $this->getProtocolVersion() && false !== strpos($headers->get('Cache-Control'), 'no-cache')) {\n            $headers->set('pragma', 'no-cache');\n            $headers->set('expires', -1);\n        }\n\n        $this->ensureIEOverSSLCompatibility($request);\n\n        if ($request->isSecure()) {\n            foreach ($headers->getCookies() as $cookie) {\n                $cookie->setSecureDefault(true);\n            }\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sends HTTP headers.\n     *\n     * @return $this\n     */\n    public function sendHeaders()\n    {\n        // headers have already been sent by the developer\n        if (headers_sent()) {\n            return $this;\n        }\n\n        // headers\n        foreach ($this->headers->allPreserveCaseWithoutCookies() as $name => $values) {\n            $replace = 0 === strcasecmp($name, 'Content-Type');\n            foreach ($values as $value) {\n                header($name.': '.$value, $replace, $this->statusCode);\n            }\n        }\n\n        // cookies\n        foreach ($this->headers->getCookies() as $cookie) {\n            header('Set-Cookie: '.$cookie, false, $this->statusCode);\n        }\n\n        // status\n        header(sprintf('HTTP/%s %s %s', $this->version, $this->statusCode, $this->statusText), true, $this->statusCode);\n\n        return $this;\n    }\n\n    /**\n     * Sends content for the current web response.\n     *\n     * @return $this\n     */\n    public function sendContent()\n    {\n        echo $this->content;\n\n        return $this;\n    }\n\n    /**\n     * Sends HTTP headers and content.\n     *\n     * @return $this\n     */\n    public function send()\n    {\n        $this->sendHeaders();\n        $this->sendContent();\n\n        if (\\function_exists('fastcgi_finish_request')) {\n            fastcgi_finish_request();\n        } elseif (!\\in_array(\\PHP_SAPI, ['cli', 'phpdbg'], true)) {\n            static::closeOutputBuffers(0, true);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the response content.\n     *\n     * Valid types are strings, numbers, null, and objects that implement a __toString() method.\n     *\n     * @param mixed $content Content that can be cast to string\n     *\n     * @return $this\n     *\n     * @throws \\UnexpectedValueException\n     */\n    public function setContent($content)\n    {\n        if (null !== $content && !\\is_string($content) && !is_numeric($content) && !\\is_callable([$content, '__toString'])) {\n            throw new \\UnexpectedValueException(sprintf('The Response content must be a string or object implementing __toString(), \"%s\" given.', \\gettype($content)));\n        }\n\n        $this->content = (string) $content;\n\n        return $this;\n    }\n\n    /**\n     * Gets the current response content.\n     *\n     * @return string|false\n     */\n    public function getContent()\n    {\n        return $this->content;\n    }\n\n    /**\n     * Sets the HTTP protocol version (1.0 or 1.1).\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setProtocolVersion(string $version)\n    {\n        $this->version = $version;\n\n        return $this;\n    }\n\n    /**\n     * Gets the HTTP protocol version.\n     *\n     * @final\n     */\n    public function getProtocolVersion(): string\n    {\n        return $this->version;\n    }\n\n    /**\n     * Sets the response status code.\n     *\n     * If the status text is null it will be automatically populated for the known\n     * status codes and left empty otherwise.\n     *\n     * @return $this\n     *\n     * @throws \\InvalidArgumentException When the HTTP status code is not valid\n     *\n     * @final\n     */\n    public function setStatusCode(int $code, $text = null)\n    {\n        $this->statusCode = $code;\n        if ($this->isInvalid()) {\n            throw new \\InvalidArgumentException(sprintf('The HTTP status code \"%s\" is not valid.', $code));\n        }\n\n        if (null === $text) {\n            $this->statusText = isset(self::$statusTexts[$code]) ? self::$statusTexts[$code] : 'unknown status';\n\n            return $this;\n        }\n\n        if (false === $text) {\n            $this->statusText = '';\n\n            return $this;\n        }\n\n        $this->statusText = $text;\n\n        return $this;\n    }\n\n    /**\n     * Retrieves the status code for the current web response.\n     *\n     * @final\n     */\n    public function getStatusCode(): int\n    {\n        return $this->statusCode;\n    }\n\n    /**\n     * Sets the response charset.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setCharset(string $charset)\n    {\n        $this->charset = $charset;\n\n        return $this;\n    }\n\n    /**\n     * Retrieves the response charset.\n     *\n     * @final\n     */\n    public function getCharset(): ?string\n    {\n        return $this->charset;\n    }\n\n    /**\n     * Returns true if the response may safely be kept in a shared (surrogate) cache.\n     *\n     * Responses marked \"private\" with an explicit Cache-Control directive are\n     * considered uncacheable.\n     *\n     * Responses with neither a freshness lifetime (Expires, max-age) nor cache\n     * validator (Last-Modified, ETag) are considered uncacheable because there is\n     * no way to tell when or how to remove them from the cache.\n     *\n     * Note that RFC 7231 and RFC 7234 possibly allow for a more permissive implementation,\n     * for example \"status codes that are defined as cacheable by default [...]\n     * can be reused by a cache with heuristic expiration unless otherwise indicated\"\n     * (https://tools.ietf.org/html/rfc7231#section-6.1)\n     *\n     * @final\n     */\n    public function isCacheable(): bool\n    {\n        if (!\\in_array($this->statusCode, [200, 203, 300, 301, 302, 404, 410])) {\n            return false;\n        }\n\n        if ($this->headers->hasCacheControlDirective('no-store') || $this->headers->getCacheControlDirective('private')) {\n            return false;\n        }\n\n        return $this->isValidateable() || $this->isFresh();\n    }\n\n    /**\n     * Returns true if the response is \"fresh\".\n     *\n     * Fresh responses may be served from cache without any interaction with the\n     * origin. A response is considered fresh when it includes a Cache-Control/max-age\n     * indicator or Expires header and the calculated age is less than the freshness lifetime.\n     *\n     * @final\n     */\n    public function isFresh(): bool\n    {\n        return $this->getTtl() > 0;\n    }\n\n    /**\n     * Returns true if the response includes headers that can be used to validate\n     * the response with the origin server using a conditional GET request.\n     *\n     * @final\n     */\n    public function isValidateable(): bool\n    {\n        return $this->headers->has('Last-Modified') || $this->headers->has('ETag');\n    }\n\n    /**\n     * Marks the response as \"private\".\n     *\n     * It makes the response ineligible for serving other clients.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setPrivate()\n    {\n        $this->headers->removeCacheControlDirective('public');\n        $this->headers->addCacheControlDirective('private');\n\n        return $this;\n    }\n\n    /**\n     * Marks the response as \"public\".\n     *\n     * It makes the response eligible for serving other clients.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setPublic()\n    {\n        $this->headers->addCacheControlDirective('public');\n        $this->headers->removeCacheControlDirective('private');\n\n        return $this;\n    }\n\n    /**\n     * Marks the response as \"immutable\".\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setImmutable(bool $immutable = true)\n    {\n        if ($immutable) {\n            $this->headers->addCacheControlDirective('immutable');\n        } else {\n            $this->headers->removeCacheControlDirective('immutable');\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns true if the response is marked as \"immutable\".\n     *\n     * @final\n     */\n    public function isImmutable(): bool\n    {\n        return $this->headers->hasCacheControlDirective('immutable');\n    }\n\n    /**\n     * Returns true if the response must be revalidated by shared caches once it has become stale.\n     *\n     * This method indicates that the response must not be served stale by a\n     * cache in any circumstance without first revalidating with the origin.\n     * When present, the TTL of the response should not be overridden to be\n     * greater than the value provided by the origin.\n     *\n     * @final\n     */\n    public function mustRevalidate(): bool\n    {\n        return $this->headers->hasCacheControlDirective('must-revalidate') || $this->headers->hasCacheControlDirective('proxy-revalidate');\n    }\n\n    /**\n     * Returns the Date header as a DateTime instance.\n     *\n     * @throws \\RuntimeException When the header is not parseable\n     *\n     * @final\n     */\n    public function getDate(): ?\\DateTimeInterface\n    {\n        return $this->headers->getDate('Date');\n    }\n\n    /**\n     * Sets the Date header.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setDate(\\DateTimeInterface $date)\n    {\n        if ($date instanceof \\DateTime) {\n            $date = \\DateTimeImmutable::createFromMutable($date);\n        }\n\n        $date = $date->setTimezone(new \\DateTimeZone('UTC'));\n        $this->headers->set('Date', $date->format('D, d M Y H:i:s').' GMT');\n\n        return $this;\n    }\n\n    /**\n     * Returns the age of the response in seconds.\n     *\n     * @final\n     */\n    public function getAge(): int\n    {\n        if (null !== $age = $this->headers->get('Age')) {\n            return (int) $age;\n        }\n\n        return max(time() - (int) $this->getDate()->format('U'), 0);\n    }\n\n    /**\n     * Marks the response stale by setting the Age header to be equal to the maximum age of the response.\n     *\n     * @return $this\n     */\n    public function expire()\n    {\n        if ($this->isFresh()) {\n            $this->headers->set('Age', $this->getMaxAge());\n            $this->headers->remove('Expires');\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns the value of the Expires header as a DateTime instance.\n     *\n     * @final\n     */\n    public function getExpires(): ?\\DateTimeInterface\n    {\n        try {\n            return $this->headers->getDate('Expires');\n        } catch (\\RuntimeException $e) {\n            // according to RFC 2616 invalid date formats (e.g. \"0\" and \"-1\") must be treated as in the past\n            return \\DateTime::createFromFormat('U', time() - 172800);\n        }\n    }\n\n    /**\n     * Sets the Expires HTTP header with a DateTime instance.\n     *\n     * Passing null as value will remove the header.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setExpires(\\DateTimeInterface $date = null)\n    {\n        if (null === $date) {\n            $this->headers->remove('Expires');\n\n            return $this;\n        }\n\n        if ($date instanceof \\DateTime) {\n            $date = \\DateTimeImmutable::createFromMutable($date);\n        }\n\n        $date = $date->setTimezone(new \\DateTimeZone('UTC'));\n        $this->headers->set('Expires', $date->format('D, d M Y H:i:s').' GMT');\n\n        return $this;\n    }\n\n    /**\n     * Returns the number of seconds after the time specified in the response's Date\n     * header when the response should no longer be considered fresh.\n     *\n     * First, it checks for a s-maxage directive, then a max-age directive, and then it falls\n     * back on an expires header. It returns null when no maximum age can be established.\n     *\n     * @final\n     */\n    public function getMaxAge(): ?int\n    {\n        if ($this->headers->hasCacheControlDirective('s-maxage')) {\n            return (int) $this->headers->getCacheControlDirective('s-maxage');\n        }\n\n        if ($this->headers->hasCacheControlDirective('max-age')) {\n            return (int) $this->headers->getCacheControlDirective('max-age');\n        }\n\n        if (null !== $this->getExpires()) {\n            return (int) $this->getExpires()->format('U') - (int) $this->getDate()->format('U');\n        }\n\n        return null;\n    }\n\n    /**\n     * Sets the number of seconds after which the response should no longer be considered fresh.\n     *\n     * This methods sets the Cache-Control max-age directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setMaxAge(int $value)\n    {\n        $this->headers->addCacheControlDirective('max-age', $value);\n\n        return $this;\n    }\n\n    /**\n     * Sets the number of seconds after which the response should no longer be considered fresh by shared caches.\n     *\n     * This methods sets the Cache-Control s-maxage directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setSharedMaxAge(int $value)\n    {\n        $this->setPublic();\n        $this->headers->addCacheControlDirective('s-maxage', $value);\n\n        return $this;\n    }\n\n    /**\n     * Returns the response's time-to-live in seconds.\n     *\n     * It returns null when no freshness information is present in the response.\n     *\n     * When the responses TTL is <= 0, the response may not be served from cache without first\n     * revalidating with the origin.\n     *\n     * @final\n     */\n    public function getTtl(): ?int\n    {\n        $maxAge = $this->getMaxAge();\n\n        return null !== $maxAge ? $maxAge - $this->getAge() : null;\n    }\n\n    /**\n     * Sets the response's time-to-live for shared caches in seconds.\n     *\n     * This method adjusts the Cache-Control/s-maxage directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setTtl(int $seconds)\n    {\n        $this->setSharedMaxAge($this->getAge() + $seconds);\n\n        return $this;\n    }\n\n    /**\n     * Sets the response's time-to-live for private/client caches in seconds.\n     *\n     * This method adjusts the Cache-Control/max-age directive.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setClientTtl(int $seconds)\n    {\n        $this->setMaxAge($this->getAge() + $seconds);\n\n        return $this;\n    }\n\n    /**\n     * Returns the Last-Modified HTTP header as a DateTime instance.\n     *\n     * @throws \\RuntimeException When the HTTP header is not parseable\n     *\n     * @final\n     */\n    public function getLastModified(): ?\\DateTimeInterface\n    {\n        return $this->headers->getDate('Last-Modified');\n    }\n\n    /**\n     * Sets the Last-Modified HTTP header with a DateTime instance.\n     *\n     * Passing null as value will remove the header.\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setLastModified(\\DateTimeInterface $date = null)\n    {\n        if (null === $date) {\n            $this->headers->remove('Last-Modified');\n\n            return $this;\n        }\n\n        if ($date instanceof \\DateTime) {\n            $date = \\DateTimeImmutable::createFromMutable($date);\n        }\n\n        $date = $date->setTimezone(new \\DateTimeZone('UTC'));\n        $this->headers->set('Last-Modified', $date->format('D, d M Y H:i:s').' GMT');\n\n        return $this;\n    }\n\n    /**\n     * Returns the literal value of the ETag HTTP header.\n     *\n     * @final\n     */\n    public function getEtag(): ?string\n    {\n        return $this->headers->get('ETag');\n    }\n\n    /**\n     * Sets the ETag value.\n     *\n     * @param string|null $etag The ETag unique identifier or null to remove the header\n     * @param bool        $weak Whether you want a weak ETag or not\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setEtag(string $etag = null, bool $weak = false)\n    {\n        if (null === $etag) {\n            $this->headers->remove('Etag');\n        } else {\n            if (0 !== strpos($etag, '\"')) {\n                $etag = '\"'.$etag.'\"';\n            }\n\n            $this->headers->set('ETag', (true === $weak ? 'W/' : '').$etag);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the response's cache headers (validation and/or expiration).\n     *\n     * Available options are: etag, last_modified, max_age, s_maxage, private, public and immutable.\n     *\n     * @return $this\n     *\n     * @throws \\InvalidArgumentException\n     *\n     * @final\n     */\n    public function setCache(array $options)\n    {\n        if ($diff = array_diff(array_keys($options), ['etag', 'last_modified', 'max_age', 's_maxage', 'private', 'public', 'immutable'])) {\n            throw new \\InvalidArgumentException(sprintf('Response does not support the following options: \"%s\".', implode('\", \"', $diff)));\n        }\n\n        if (isset($options['etag'])) {\n            $this->setEtag($options['etag']);\n        }\n\n        if (isset($options['last_modified'])) {\n            $this->setLastModified($options['last_modified']);\n        }\n\n        if (isset($options['max_age'])) {\n            $this->setMaxAge($options['max_age']);\n        }\n\n        if (isset($options['s_maxage'])) {\n            $this->setSharedMaxAge($options['s_maxage']);\n        }\n\n        if (isset($options['public'])) {\n            if ($options['public']) {\n                $this->setPublic();\n            } else {\n                $this->setPrivate();\n            }\n        }\n\n        if (isset($options['private'])) {\n            if ($options['private']) {\n                $this->setPrivate();\n            } else {\n                $this->setPublic();\n            }\n        }\n\n        if (isset($options['immutable'])) {\n            $this->setImmutable((bool) $options['immutable']);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Modifies the response so that it conforms to the rules defined for a 304 status code.\n     *\n     * This sets the status, removes the body, and discards any headers\n     * that MUST NOT be included in 304 responses.\n     *\n     * @return $this\n     *\n     * @see https://tools.ietf.org/html/rfc2616#section-10.3.5\n     *\n     * @final\n     */\n    public function setNotModified()\n    {\n        $this->setStatusCode(304);\n        $this->setContent(null);\n\n        // remove headers that MUST NOT be included with 304 Not Modified responses\n        foreach (['Allow', 'Content-Encoding', 'Content-Language', 'Content-Length', 'Content-MD5', 'Content-Type', 'Last-Modified'] as $header) {\n            $this->headers->remove($header);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns true if the response includes a Vary header.\n     *\n     * @final\n     */\n    public function hasVary(): bool\n    {\n        return null !== $this->headers->get('Vary');\n    }\n\n    /**\n     * Returns an array of header names given in the Vary header.\n     *\n     * @final\n     */\n    public function getVary(): array\n    {\n        if (!$vary = $this->headers->all('Vary')) {\n            return [];\n        }\n\n        $ret = [];\n        foreach ($vary as $item) {\n            $ret = array_merge($ret, preg_split('/[\\s,]+/', $item));\n        }\n\n        return $ret;\n    }\n\n    /**\n     * Sets the Vary header.\n     *\n     * @param string|array $headers\n     * @param bool         $replace Whether to replace the actual value or not (true by default)\n     *\n     * @return $this\n     *\n     * @final\n     */\n    public function setVary($headers, bool $replace = true)\n    {\n        $this->headers->set('Vary', $headers, $replace);\n\n        return $this;\n    }\n\n    /**\n     * Determines if the Response validators (ETag, Last-Modified) match\n     * a conditional value specified in the Request.\n     *\n     * If the Response is not modified, it sets the status code to 304 and\n     * removes the actual content by calling the setNotModified() method.\n     *\n     * @return bool true if the Response validators match the Request, false otherwise\n     *\n     * @final\n     */\n    public function isNotModified(Request $request): bool\n    {\n        if (!$request->isMethodCacheable()) {\n            return false;\n        }\n\n        $notModified = false;\n        $lastModified = $this->headers->get('Last-Modified');\n        $modifiedSince = $request->headers->get('If-Modified-Since');\n\n        if ($etags = $request->getETags()) {\n            $notModified = \\in_array($this->getEtag(), $etags) || \\in_array('*', $etags);\n        }\n\n        if ($modifiedSince && $lastModified) {\n            $notModified = strtotime($modifiedSince) >= strtotime($lastModified) && (!$etags || $notModified);\n        }\n\n        if ($notModified) {\n            $this->setNotModified();\n        }\n\n        return $notModified;\n    }\n\n    /**\n     * Is response invalid?\n     *\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n     *\n     * @final\n     */\n    public function isInvalid(): bool\n    {\n        return $this->statusCode < 100 || $this->statusCode >= 600;\n    }\n\n    /**\n     * Is response informative?\n     *\n     * @final\n     */\n    public function isInformational(): bool\n    {\n        return $this->statusCode >= 100 && $this->statusCode < 200;\n    }\n\n    /**\n     * Is response successful?\n     *\n     * @final\n     */\n    public function isSuccessful(): bool\n    {\n        return $this->statusCode >= 200 && $this->statusCode < 300;\n    }\n\n    /**\n     * Is the response a redirect?\n     *\n     * @final\n     */\n    public function isRedirection(): bool\n    {\n        return $this->statusCode >= 300 && $this->statusCode < 400;\n    }\n\n    /**\n     * Is there a client error?\n     *\n     * @final\n     */\n    public function isClientError(): bool\n    {\n        return $this->statusCode >= 400 && $this->statusCode < 500;\n    }\n\n    /**\n     * Was there a server side error?\n     *\n     * @final\n     */\n    public function isServerError(): bool\n    {\n        return $this->statusCode >= 500 && $this->statusCode < 600;\n    }\n\n    /**\n     * Is the response OK?\n     *\n     * @final\n     */\n    public function isOk(): bool\n    {\n        return 200 === $this->statusCode;\n    }\n\n    /**\n     * Is the response forbidden?\n     *\n     * @final\n     */\n    public function isForbidden(): bool\n    {\n        return 403 === $this->statusCode;\n    }\n\n    /**\n     * Is the response a not found error?\n     *\n     * @final\n     */\n    public function isNotFound(): bool\n    {\n        return 404 === $this->statusCode;\n    }\n\n    /**\n     * Is the response a redirect of some form?\n     *\n     * @final\n     */\n    public function isRedirect(string $location = null): bool\n    {\n        return \\in_array($this->statusCode, [201, 301, 302, 303, 307, 308]) && (null === $location ?: $location == $this->headers->get('Location'));\n    }\n\n    /**\n     * Is the response empty?\n     *\n     * @final\n     */\n    public function isEmpty(): bool\n    {\n        return \\in_array($this->statusCode, [204, 304]);\n    }\n\n    /**\n     * Cleans or flushes output buffers up to target level.\n     *\n     * Resulting level can be greater than target level if a non-removable buffer has been encountered.\n     *\n     * @final\n     */\n    public static function closeOutputBuffers(int $targetLevel, bool $flush): void\n    {\n        $status = ob_get_status(true);\n        $level = \\count($status);\n        $flags = PHP_OUTPUT_HANDLER_REMOVABLE | ($flush ? PHP_OUTPUT_HANDLER_FLUSHABLE : PHP_OUTPUT_HANDLER_CLEANABLE);\n\n        while ($level-- > $targetLevel && ($s = $status[$level]) && (!isset($s['del']) ? !isset($s['flags']) || ($s['flags'] & $flags) === $flags : $s['del'])) {\n            if ($flush) {\n                ob_end_flush();\n            } else {\n                ob_end_clean();\n            }\n        }\n    }\n\n    /**\n     * Checks if we need to remove Cache-Control for SSL encrypted downloads when using IE < 9.\n     *\n     * @see http://support.microsoft.com/kb/323308\n     *\n     * @final\n     */\n    protected function ensureIEOverSSLCompatibility(Request $request): void\n    {\n        if (false !== stripos($this->headers->get('Content-Disposition'), 'attachment') && 1 == preg_match('/MSIE (.*?);/i', $request->server->get('HTTP_USER_AGENT'), $match) && true === $request->isSecure()) {\n            if ((int) preg_replace('/(MSIE )(.*?);/', '$2', $match[0]) < 9) {\n                $this->headers->remove('Cache-Control');\n            }\n        }\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpFoundation\\Tests;\n\nuse Symfony\\Component\\HttpFoundation\\Cookie;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * @group time-sensitive\n */\nclass ResponseTest extends ResponseTestCase\n{\n    public function testCreate()\n    {\n        $response = Response::create('foo', 301, ['Foo' => 'bar']);\n\n        $this->assertInstanceOf('Symfony\\Component\\HttpFoundation\\Response', $response);\n        $this->assertEquals(301, $response->getStatusCode());\n        $this->assertEquals('bar', $response->headers->get('foo'));\n    }\n\n    public function testToString()\n    {\n        $response = new Response();\n        $response = explode(\"\\r\\n\", $response);\n        $this->assertEquals('HTTP/1.0 200 OK', $response[0]);\n        $this->assertEquals('Cache-Control: no-cache, private', $response[1]);\n    }\n\n    public function testClone()\n    {\n        $response = new Response();\n        $responseClone = clone $response;\n        $this->assertEquals($response, $responseClone);\n    }\n\n    public function testSendHeaders()\n    {\n        $response = new Response();\n        $headers = $response->sendHeaders();\n        $this->assertObjectHasAttribute('headers', $headers);\n        $this->assertObjectHasAttribute('content', $headers);\n        $this->assertObjectHasAttribute('version', $headers);\n        $this->assertObjectHasAttribute('statusCode', $headers);\n        $this->assertObjectHasAttribute('statusText', $headers);\n        $this->assertObjectHasAttribute('charset', $headers);\n    }\n\n    public function testSend()\n    {\n        $response = new Response();\n        $responseSend = $response->send();\n        $this->assertObjectHasAttribute('headers', $responseSend);\n        $this->assertObjectHasAttribute('content', $responseSend);\n        $this->assertObjectHasAttribute('version', $responseSend);\n        $this->assertObjectHasAttribute('statusCode', $responseSend);\n        $this->assertObjectHasAttribute('statusText', $responseSend);\n        $this->assertObjectHasAttribute('charset', $responseSend);\n    }\n\n    public function testGetCharset()\n    {\n        $response = new Response();\n        $charsetOrigin = 'UTF-8';\n        $response->setCharset($charsetOrigin);\n        $charset = $response->getCharset();\n        $this->assertEquals($charsetOrigin, $charset);\n    }\n\n    public function testIsCacheable()\n    {\n        $response = new Response();\n        $this->assertFalse($response->isCacheable());\n    }\n\n    public function testIsCacheableWithErrorCode()\n    {\n        $response = new Response('', 500);\n        $this->assertFalse($response->isCacheable());\n    }\n\n    public function testIsCacheableWithNoStoreDirective()\n    {\n        $response = new Response();\n        $response->headers->set('cache-control', 'private');\n        $this->assertFalse($response->isCacheable());\n    }\n\n    public function testIsCacheableWithSetTtl()\n    {\n        $response = new Response();\n        $response->setTtl(10);\n        $this->assertTrue($response->isCacheable());\n    }\n\n    public function testMustRevalidate()\n    {\n        $response = new Response();\n        $this->assertFalse($response->mustRevalidate());\n    }\n\n    public function testMustRevalidateWithMustRevalidateCacheControlHeader()\n    {\n        $response = new Response();\n        $response->headers->set('cache-control', 'must-revalidate');\n\n        $this->assertTrue($response->mustRevalidate());\n    }\n\n    public function testMustRevalidateWithProxyRevalidateCacheControlHeader()\n    {\n        $response = new Response();\n        $response->headers->set('cache-control', 'proxy-revalidate');\n\n        $this->assertTrue($response->mustRevalidate());\n    }\n\n    public function testSetNotModified()\n    {\n        $response = new Response('foo');\n        $modified = $response->setNotModified();\n        $this->assertObjectHasAttribute('headers', $modified);\n        $this->assertObjectHasAttribute('content', $modified);\n        $this->assertObjectHasAttribute('version', $modified);\n        $this->assertObjectHasAttribute('statusCode', $modified);\n        $this->assertObjectHasAttribute('statusText', $modified);\n        $this->assertObjectHasAttribute('charset', $modified);\n        $this->assertEquals(304, $modified->getStatusCode());\n\n        ob_start();\n        $modified->sendContent();\n        $string = ob_get_clean();\n        $this->assertEmpty($string);\n    }\n\n    public function testIsSuccessful()\n    {\n        $response = new Response();\n        $this->assertTrue($response->isSuccessful());\n    }\n\n    public function testIsNotModified()\n    {\n        $response = new Response();\n        $modified = $response->isNotModified(new Request());\n        $this->assertFalse($modified);\n    }\n\n    public function testIsNotModifiedNotSafe()\n    {\n        $request = Request::create('/homepage', 'POST');\n\n        $response = new Response();\n        $this->assertFalse($response->isNotModified($request));\n    }\n\n    public function testIsNotModifiedLastModified()\n    {\n        $before = 'Sun, 25 Aug 2013 18:32:31 GMT';\n        $modified = 'Sun, 25 Aug 2013 18:33:31 GMT';\n        $after = 'Sun, 25 Aug 2013 19:33:31 GMT';\n\n        $request = new Request();\n        $request->headers->set('If-Modified-Since', $modified);\n\n        $response = new Response();\n\n        $response->headers->set('Last-Modified', $modified);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('Last-Modified', $before);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('Last-Modified', $after);\n        $this->assertFalse($response->isNotModified($request));\n\n        $response->headers->set('Last-Modified', '');\n        $this->assertFalse($response->isNotModified($request));\n    }\n\n    public function testIsNotModifiedEtag()\n    {\n        $etagOne = 'randomly_generated_etag';\n        $etagTwo = 'randomly_generated_etag_2';\n\n        $request = new Request();\n        $request->headers->set('if_none_match', sprintf('%s, %s, %s', $etagOne, $etagTwo, 'etagThree'));\n\n        $response = new Response();\n\n        $response->headers->set('ETag', $etagOne);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('ETag', $etagTwo);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('ETag', '');\n        $this->assertFalse($response->isNotModified($request));\n    }\n\n    public function testIsNotModifiedLastModifiedAndEtag()\n    {\n        $before = 'Sun, 25 Aug 2013 18:32:31 GMT';\n        $modified = 'Sun, 25 Aug 2013 18:33:31 GMT';\n        $after = 'Sun, 25 Aug 2013 19:33:31 GMT';\n        $etag = 'randomly_generated_etag';\n\n        $request = new Request();\n        $request->headers->set('if_none_match', sprintf('%s, %s', $etag, 'etagThree'));\n        $request->headers->set('If-Modified-Since', $modified);\n\n        $response = new Response();\n\n        $response->headers->set('ETag', $etag);\n        $response->headers->set('Last-Modified', $after);\n        $this->assertFalse($response->isNotModified($request));\n\n        $response->headers->set('ETag', 'non-existent-etag');\n        $response->headers->set('Last-Modified', $before);\n        $this->assertFalse($response->isNotModified($request));\n\n        $response->headers->set('ETag', $etag);\n        $response->headers->set('Last-Modified', $modified);\n        $this->assertTrue($response->isNotModified($request));\n    }\n\n    public function testIsNotModifiedIfModifiedSinceAndEtagWithoutLastModified()\n    {\n        $modified = 'Sun, 25 Aug 2013 18:33:31 GMT';\n        $etag = 'randomly_generated_etag';\n\n        $request = new Request();\n        $request->headers->set('if_none_match', sprintf('%s, %s', $etag, 'etagThree'));\n        $request->headers->set('If-Modified-Since', $modified);\n\n        $response = new Response();\n\n        $response->headers->set('ETag', $etag);\n        $this->assertTrue($response->isNotModified($request));\n\n        $response->headers->set('ETag', 'non-existent-etag');\n        $this->assertFalse($response->isNotModified($request));\n    }\n\n    public function testIsValidateable()\n    {\n        $response = new Response('', 200, ['Last-Modified' => $this->createDateTimeOneHourAgo()->format(DATE_RFC2822)]);\n        $this->assertTrue($response->isValidateable(), '->isValidateable() returns true if Last-Modified is present');\n\n        $response = new Response('', 200, ['ETag' => '\"12345\"']);\n        $this->assertTrue($response->isValidateable(), '->isValidateable() returns true if ETag is present');\n\n        $response = new Response();\n        $this->assertFalse($response->isValidateable(), '->isValidateable() returns false when no validator is present');\n    }\n\n    public function testGetDate()\n    {\n        $oneHourAgo = $this->createDateTimeOneHourAgo();\n        $response = new Response('', 200, ['Date' => $oneHourAgo->format(DATE_RFC2822)]);\n        $date = $response->getDate();\n        $this->assertEquals($oneHourAgo->getTimestamp(), $date->getTimestamp(), '->getDate() returns the Date header if present');\n\n        $response = new Response();\n        $date = $response->getDate();\n        $this->assertEquals(time(), $date->getTimestamp(), '->getDate() returns the current Date if no Date header present');\n\n        $response = new Response('', 200, ['Date' => $this->createDateTimeOneHourAgo()->format(DATE_RFC2822)]);\n        $now = $this->createDateTimeNow();\n        $response->headers->set('Date', $now->format(DATE_RFC2822));\n        $date = $response->getDate();\n        $this->assertEquals($now->getTimestamp(), $date->getTimestamp(), '->getDate() returns the date when the header has been modified');\n\n        $response = new Response('', 200);\n        $now = $this->createDateTimeNow();\n        $response->headers->remove('Date');\n        $date = $response->getDate();\n        $this->assertEquals($now->getTimestamp(), $date->getTimestamp(), '->getDate() returns the current Date when the header has previously been removed');\n    }\n\n    public function testGetMaxAge()\n    {\n        $response = new Response();\n        $response->headers->set('Cache-Control', 's-maxage=600, max-age=0');\n        $this->assertEquals(600, $response->getMaxAge(), '->getMaxAge() uses s-maxage cache control directive when present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=600');\n        $this->assertEquals(600, $response->getMaxAge(), '->getMaxAge() falls back to max-age when no s-maxage directive present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'must-revalidate');\n        $response->headers->set('Expires', $this->createDateTimeOneHourLater()->format(DATE_RFC2822));\n        $this->assertEquals(3600, $response->getMaxAge(), '->getMaxAge() falls back to Expires when no max-age or s-maxage directive present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'must-revalidate');\n        $response->headers->set('Expires', -1);\n        $this->assertLessThanOrEqual(time() - 2 * 86400, $response->getExpires()->format('U'));\n\n        $response = new Response();\n        $this->assertNull($response->getMaxAge(), '->getMaxAge() returns null if no freshness information available');\n    }\n\n    public function testSetSharedMaxAge()\n    {\n        $response = new Response();\n        $response->setSharedMaxAge(20);\n\n        $cacheControl = $response->headers->get('Cache-Control');\n        $this->assertEquals('public, s-maxage=20', $cacheControl);\n    }\n\n    public function testIsPrivate()\n    {\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=100');\n        $response->setPrivate();\n        $this->assertEquals(100, $response->headers->getCacheControlDirective('max-age'), '->isPrivate() adds the private Cache-Control directive when set to true');\n        $this->assertTrue($response->headers->getCacheControlDirective('private'), '->isPrivate() adds the private Cache-Control directive when set to true');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'public, max-age=100');\n        $response->setPrivate();\n        $this->assertEquals(100, $response->headers->getCacheControlDirective('max-age'), '->isPrivate() adds the private Cache-Control directive when set to true');\n        $this->assertTrue($response->headers->getCacheControlDirective('private'), '->isPrivate() adds the private Cache-Control directive when set to true');\n        $this->assertFalse($response->headers->hasCacheControlDirective('public'), '->isPrivate() removes the public Cache-Control directive');\n    }\n\n    public function testExpire()\n    {\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=100');\n        $response->expire();\n        $this->assertEquals(100, $response->headers->get('Age'), '->expire() sets the Age to max-age when present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=100, s-maxage=500');\n        $response->expire();\n        $this->assertEquals(500, $response->headers->get('Age'), '->expire() sets the Age to s-maxage when both max-age and s-maxage are present');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=5, s-maxage=500');\n        $response->headers->set('Age', '1000');\n        $response->expire();\n        $this->assertEquals(1000, $response->headers->get('Age'), '->expire() does nothing when the response is already stale/expired');\n\n        $response = new Response();\n        $response->expire();\n        $this->assertFalse($response->headers->has('Age'), '->expire() does nothing when the response does not include freshness information');\n\n        $response = new Response();\n        $response->headers->set('Expires', -1);\n        $response->expire();\n        $this->assertNull($response->headers->get('Age'), '->expire() does not set the Age when the response is expired');\n\n        $response = new Response();\n        $response->headers->set('Expires', date(DATE_RFC2822, time() + 600));\n        $response->expire();\n        $this->assertNull($response->headers->get('Expires'), '->expire() removes the Expires header when the response is fresh');\n    }\n\n    public function testNullExpireHeader()\n    {\n        $response = new Response(null, 200, ['Expires' => null]);\n        $this->assertNull($response->getExpires());\n    }\n\n    public function testGetTtl()\n    {\n        $response = new Response();\n        $this->assertNull($response->getTtl(), '->getTtl() returns null when no Expires or Cache-Control headers are present');\n\n        $response = new Response();\n        $response->headers->set('Expires', $this->createDateTimeOneHourLater()->format(DATE_RFC2822));\n        $this->assertEquals(3600, $response->getTtl(), '->getTtl() uses the Expires header when no max-age is present');\n\n        $response = new Response();\n        $response->headers->set('Expires', $this->createDateTimeOneHourAgo()->format(DATE_RFC2822));\n        $this->assertLessThan(0, $response->getTtl(), '->getTtl() returns negative values when Expires is in past');\n\n        $response = new Response();\n        $response->headers->set('Expires', $response->getDate()->format(DATE_RFC2822));\n        $response->headers->set('Age', 0);\n        $this->assertSame(0, $response->getTtl(), '->getTtl() correctly handles zero');\n\n        $response = new Response();\n        $response->headers->set('Cache-Control', 'max-age=60');\n        $this->assertEquals(60, $response->getTtl(), '->getTtl() uses Cache-Control max-age when present');\n    }\n\n    public function testSetClientTtl()\n    {\n        $response = new Response();\n        $response->setClientTtl(10);\n\n        $this->assertEquals($response->getMaxAge(), $response->getAge() + 10);\n    }\n\n    public function testGetSetProtocolVersion()\n    {\n        $response = new Response();\n\n        $this->assertEquals('1.0', $response->getProtocolVersion());\n\n        $response->setProtocolVersion('1.1');\n\n        $this->assertEquals('1.1', $response->getProtocolVersion());\n    }\n\n    public function testGetVary()\n    {\n        $response = new Response();\n        $this->assertEquals([], $response->getVary(), '->getVary() returns an empty array if no Vary header is present');\n\n        $response = new Response();\n        $response->headers->set('Vary', 'Accept-Language');\n        $this->assertEquals(['Accept-Language'], $response->getVary(), '->getVary() parses a single header name value');\n\n        $response = new Response();\n        $response->headers->set('Vary', 'Accept-Language User-Agent    X-Foo');\n        $this->assertEquals(['Accept-Language', 'User-Agent', 'X-Foo'], $response->getVary(), '->getVary() parses multiple header name values separated by spaces');\n\n        $response = new Response();\n        $response->headers->set('Vary', 'Accept-Language,User-Agent,    X-Foo');\n        $this->assertEquals(['Accept-Language', 'User-Agent', 'X-Foo'], $response->getVary(), '->getVary() parses multiple header name values separated by commas');\n\n        $vary = ['Accept-Language', 'User-Agent', 'X-foo'];\n\n        $response = new Response();\n        $response->headers->set('Vary', $vary);\n        $this->assertEquals($vary, $response->getVary(), '->getVary() parses multiple header name values in arrays');\n\n        $response = new Response();\n        $response->headers->set('Vary', 'Accept-Language, User-Agent, X-foo');\n        $this->assertEquals($vary, $response->getVary(), '->getVary() parses multiple header name values in arrays');\n    }\n\n    public function testSetVary()\n    {\n        $response = new Response();\n        $response->setVary('Accept-Language');\n        $this->assertEquals(['Accept-Language'], $response->getVary());\n\n        $response->setVary('Accept-Language, User-Agent');\n        $this->assertEquals(['Accept-Language', 'User-Agent'], $response->getVary(), '->setVary() replace the vary header by default');\n\n        $response->setVary('X-Foo', false);\n        $this->assertEquals(['Accept-Language', 'User-Agent', 'X-Foo'], $response->getVary(), '->setVary() doesn\\'t wipe out earlier Vary headers if replace is set to false');\n    }\n\n    public function testDefaultContentType()\n    {\n        $response = new Response('foo');\n        $response->prepare(new Request());\n\n        $this->assertSame('text/html; charset=UTF-8', $response->headers->get('Content-Type'));\n    }\n\n    public function testContentTypeCharset()\n    {\n        $response = new Response();\n        $response->headers->set('Content-Type', 'text/css');\n\n        // force fixContentType() to be called\n        $response->prepare(new Request());\n\n        $this->assertEquals('text/css; charset=UTF-8', $response->headers->get('Content-Type'));\n    }\n\n    public function testPrepareDoesNothingIfContentTypeIsSet()\n    {\n        $response = new Response('foo');\n        $response->headers->set('Content-Type', 'text/plain');\n\n        $response->prepare(new Request());\n\n        $this->assertEquals('text/plain; charset=UTF-8', $response->headers->get('content-type'));\n    }\n\n    public function testPrepareDoesNothingIfRequestFormatIsNotDefined()\n    {\n        $response = new Response('foo');\n\n        $response->prepare(new Request());\n\n        $this->assertEquals('text/html; charset=UTF-8', $response->headers->get('content-type'));\n    }\n\n    /**\n     * Same URL cannot produce different Content-Type based on the value of the Accept header,\n     * unless explicitly stated in the response object.\n     */\n    public function testPrepareDoesNotSetContentTypeBasedOnRequestAcceptHeader()\n    {\n        $response = new Response('foo');\n        $request = Request::create('/');\n        $request->headers->set('Accept', 'application/json');\n        $response->prepare($request);\n\n        $this->assertSame('text/html; charset=UTF-8', $response->headers->get('content-type'));\n    }\n\n    public function testPrepareSetContentType()\n    {\n        $response = new Response('foo');\n        $request = Request::create('/');\n        $request->setRequestFormat('json');\n\n        $response->prepare($request);\n\n        $this->assertEquals('application/json', $response->headers->get('content-type'));\n    }\n\n    public function testPrepareRemovesContentForHeadRequests()\n    {\n        $response = new Response('foo');\n        $request = Request::create('/', 'HEAD');\n\n        $length = 12345;\n        $response->headers->set('Content-Length', $length);\n        $response->prepare($request);\n\n        $this->assertEquals('', $response->getContent());\n        $this->assertEquals($length, $response->headers->get('Content-Length'), 'Content-Length should be as if it was GET; see RFC2616 14.13');\n    }\n\n    public function testPrepareRemovesContentForInformationalResponse()\n    {\n        $response = new Response('foo');\n        $request = Request::create('/');\n\n        $response->setContent('content');\n        $response->setStatusCode(101);\n        $response->prepare($request);\n        $this->assertEquals('', $response->getContent());\n        $this->assertFalse($response->headers->has('Content-Type'));\n\n        $response->setContent('content');\n        $response->setStatusCode(304);\n        $response->prepare($request);\n        $this->assertEquals('', $response->getContent());\n        $this->assertFalse($response->headers->has('Content-Type'));\n        $this->assertFalse($response->headers->has('Content-Length'));\n    }\n\n    public function testPrepareRemovesContentLength()\n    {\n        $response = new Response('foo');\n        $request = Request::create('/');\n\n        $response->headers->set('Content-Length', 12345);\n        $response->prepare($request);\n        $this->assertEquals(12345, $response->headers->get('Content-Length'));\n\n        $response->headers->set('Transfer-Encoding', 'chunked');\n        $response->prepare($request);\n        $this->assertFalse($response->headers->has('Content-Length'));\n    }\n\n    public function testPrepareSetsPragmaOnHttp10Only()\n    {\n        $request = Request::create('/', 'GET');\n        $request->server->set('SERVER_PROTOCOL', 'HTTP/1.0');\n\n        $response = new Response('foo');\n        $response->prepare($request);\n        $this->assertEquals('no-cache', $response->headers->get('pragma'));\n        $this->assertEquals('-1', $response->headers->get('expires'));\n\n        $request->server->set('SERVER_PROTOCOL', 'HTTP/1.1');\n        $response = new Response('foo');\n        $response->prepare($request);\n        $this->assertFalse($response->headers->has('pragma'));\n        $this->assertFalse($response->headers->has('expires'));\n    }\n\n    public function testPrepareSetsCookiesSecure()\n    {\n        $cookie = Cookie::create('foo', 'bar');\n\n        $response = new Response('foo');\n        $response->headers->setCookie($cookie);\n\n        $request = Request::create('/', 'GET');\n        $response->prepare($request);\n\n        $this->assertFalse($cookie->isSecure());\n\n        $request = Request::create('https://localhost/', 'GET');\n        $response->prepare($request);\n\n        $this->assertTrue($cookie->isSecure());\n    }\n\n    public function testSetCache()\n    {\n        $response = new Response();\n        // ['etag', 'last_modified', 'max_age', 's_maxage', 'private', 'public']\n        try {\n            $response->setCache(['wrong option' => 'value']);\n            $this->fail('->setCache() throws an InvalidArgumentException if an option is not supported');\n        } catch (\\Exception $e) {\n            $this->assertInstanceOf('InvalidArgumentException', $e, '->setCache() throws an InvalidArgumentException if an option is not supported');\n            $this->assertStringContainsString('\"wrong option\"', $e->getMessage());\n        }\n\n        $options = ['etag' => '\"whatever\"'];\n        $response->setCache($options);\n        $this->assertEquals($response->getEtag(), '\"whatever\"');\n\n        $now = $this->createDateTimeNow();\n        $options = ['last_modified' => $now];\n        $response->setCache($options);\n        $this->assertEquals($response->getLastModified()->getTimestamp(), $now->getTimestamp());\n\n        $options = ['max_age' => 100];\n        $response->setCache($options);\n        $this->assertEquals($response->getMaxAge(), 100);\n\n        $options = ['s_maxage' => 200];\n        $response->setCache($options);\n        $this->assertEquals($response->getMaxAge(), 200);\n\n        $this->assertTrue($response->headers->hasCacheControlDirective('public'));\n        $this->assertFalse($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['public' => true]);\n        $this->assertTrue($response->headers->hasCacheControlDirective('public'));\n        $this->assertFalse($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['public' => false]);\n        $this->assertFalse($response->headers->hasCacheControlDirective('public'));\n        $this->assertTrue($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['private' => true]);\n        $this->assertFalse($response->headers->hasCacheControlDirective('public'));\n        $this->assertTrue($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['private' => false]);\n        $this->assertTrue($response->headers->hasCacheControlDirective('public'));\n        $this->assertFalse($response->headers->hasCacheControlDirective('private'));\n\n        $response->setCache(['immutable' => true]);\n        $this->assertTrue($response->headers->hasCacheControlDirective('immutable'));\n\n        $response->setCache(['immutable' => false]);\n        $this->assertFalse($response->headers->hasCacheControlDirective('immutable'));\n    }\n\n    public function testSendContent()\n    {\n        $response = new Response('test response rendering', 200);\n\n        ob_start();\n        $response->sendContent();\n        $string = ob_get_clean();\n        $this->assertStringContainsString('test response rendering', $string);\n    }\n\n    public function testSetPublic()\n    {\n        $response = new Response();\n        $response->setPublic();\n\n        $this->assertTrue($response->headers->hasCacheControlDirective('public'));\n        $this->assertFalse($response->headers->hasCacheControlDirective('private'));\n    }\n\n    public function testSetImmutable()\n    {\n        $response = new Response();\n        $response->setImmutable();\n\n        $this->assertTrue($response->headers->hasCacheControlDirective('immutable'));\n    }\n\n    public function testIsImmutable()\n    {\n        $response = new Response();\n        $response->setImmutable();\n\n        $this->assertTrue($response->isImmutable());\n    }\n\n    public function testSetDate()\n    {\n        $response = new Response();\n        $response->setDate(\\DateTime::createFromFormat(\\DateTime::ATOM, '2013-01-26T09:21:56+0100', new \\DateTimeZone('Europe/Berlin')));\n\n        $this->assertEquals('2013-01-26T08:21:56+00:00', $response->getDate()->format(\\DateTime::ATOM));\n    }\n\n    public function testSetDateWithImmutable()\n    {\n        $response = new Response();\n        $response->setDate(\\DateTimeImmutable::createFromFormat(\\DateTime::ATOM, '2013-01-26T09:21:56+0100', new \\DateTimeZone('Europe/Berlin')));\n\n        $this->assertEquals('2013-01-26T08:21:56+00:00', $response->getDate()->format(\\DateTime::ATOM));\n    }\n\n    public function testSetExpires()\n    {\n        $response = new Response();\n        $response->setExpires(null);\n\n        $this->assertNull($response->getExpires(), '->setExpires() remove the header when passed null');\n\n        $now = $this->createDateTimeNow();\n        $response->setExpires($now);\n\n        $this->assertEquals($response->getExpires()->getTimestamp(), $now->getTimestamp());\n    }\n\n    public function testSetExpiresWithImmutable()\n    {\n        $response = new Response();\n\n        $now = $this->createDateTimeImmutableNow();\n        $response->setExpires($now);\n\n        $this->assertEquals($response->getExpires()->getTimestamp(), $now->getTimestamp());\n    }\n\n    public function testSetLastModified()\n    {\n        $response = new Response();\n        $response->setLastModified($this->createDateTimeNow());\n        $this->assertNotNull($response->getLastModified());\n\n        $response->setLastModified(null);\n        $this->assertNull($response->getLastModified());\n    }\n\n    public function testSetLastModifiedWithImmutable()\n    {\n        $response = new Response();\n        $response->setLastModified($this->createDateTimeImmutableNow());\n        $this->assertNotNull($response->getLastModified());\n\n        $response->setLastModified(null);\n        $this->assertNull($response->getLastModified());\n    }\n\n    public function testIsInvalid()\n    {\n        $response = new Response();\n\n        try {\n            $response->setStatusCode(99);\n            $this->fail();\n        } catch (\\InvalidArgumentException $e) {\n            $this->assertTrue($response->isInvalid());\n        }\n\n        try {\n            $response->setStatusCode(650);\n            $this->fail();\n        } catch (\\InvalidArgumentException $e) {\n            $this->assertTrue($response->isInvalid());\n        }\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isInvalid());\n    }\n\n    /**\n     * @dataProvider getStatusCodeFixtures\n     */\n    public function testSetStatusCode($code, $text, $expectedText)\n    {\n        $response = new Response();\n\n        $response->setStatusCode($code, $text);\n\n        $statusText = new \\ReflectionProperty($response, 'statusText');\n        $statusText->setAccessible(true);\n\n        $this->assertEquals($expectedText, $statusText->getValue($response));\n    }\n\n    public function getStatusCodeFixtures()\n    {\n        return [\n            ['200', null, 'OK'],\n            ['200', false, ''],\n            ['200', 'foo', 'foo'],\n            ['199', null, 'unknown status'],\n            ['199', false, ''],\n            ['199', 'foo', 'foo'],\n        ];\n    }\n\n    public function testIsInformational()\n    {\n        $response = new Response('', 100);\n        $this->assertTrue($response->isInformational());\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isInformational());\n    }\n\n    public function testIsRedirectRedirection()\n    {\n        foreach ([301, 302, 303, 307] as $code) {\n            $response = new Response('', $code);\n            $this->assertTrue($response->isRedirection());\n            $this->assertTrue($response->isRedirect());\n        }\n\n        $response = new Response('', 304);\n        $this->assertTrue($response->isRedirection());\n        $this->assertFalse($response->isRedirect());\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isRedirection());\n        $this->assertFalse($response->isRedirect());\n\n        $response = new Response('', 404);\n        $this->assertFalse($response->isRedirection());\n        $this->assertFalse($response->isRedirect());\n\n        $response = new Response('', 301, ['Location' => '/good-uri']);\n        $this->assertFalse($response->isRedirect('/bad-uri'));\n        $this->assertTrue($response->isRedirect('/good-uri'));\n    }\n\n    public function testIsNotFound()\n    {\n        $response = new Response('', 404);\n        $this->assertTrue($response->isNotFound());\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isNotFound());\n    }\n\n    public function testIsEmpty()\n    {\n        foreach ([204, 304] as $code) {\n            $response = new Response('', $code);\n            $this->assertTrue($response->isEmpty());\n        }\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isEmpty());\n    }\n\n    public function testIsForbidden()\n    {\n        $response = new Response('', 403);\n        $this->assertTrue($response->isForbidden());\n\n        $response = new Response('', 200);\n        $this->assertFalse($response->isForbidden());\n    }\n\n    public function testIsOk()\n    {\n        $response = new Response('', 200);\n        $this->assertTrue($response->isOk());\n\n        $response = new Response('', 404);\n        $this->assertFalse($response->isOk());\n    }\n\n    public function testIsServerOrClientError()\n    {\n        $response = new Response('', 404);\n        $this->assertTrue($response->isClientError());\n        $this->assertFalse($response->isServerError());\n\n        $response = new Response('', 500);\n        $this->assertFalse($response->isClientError());\n        $this->assertTrue($response->isServerError());\n    }\n\n    public function testHasVary()\n    {\n        $response = new Response();\n        $this->assertFalse($response->hasVary());\n\n        $response->setVary('User-Agent');\n        $this->assertTrue($response->hasVary());\n    }\n\n    public function testSetEtag()\n    {\n        $response = new Response('', 200, ['ETag' => '\"12345\"']);\n        $response->setEtag();\n\n        $this->assertNull($response->headers->get('Etag'), '->setEtag() removes Etags when call with null');\n    }\n\n    /**\n     * @dataProvider validContentProvider\n     */\n    public function testSetContent($content)\n    {\n        $response = new Response();\n        $response->setContent($content);\n        $this->assertEquals((string) $content, $response->getContent());\n    }\n\n    /**\n     * @dataProvider invalidContentProvider\n     */\n    public function testSetContentInvalid($content)\n    {\n        $this->expectException('UnexpectedValueException');\n        $response = new Response();\n        $response->setContent($content);\n    }\n\n    public function testSettersAreChainable()\n    {\n        $response = new Response();\n\n        $setters = [\n            'setProtocolVersion' => '1.0',\n            'setCharset' => 'UTF-8',\n            'setPublic' => null,\n            'setPrivate' => null,\n            'setDate' => $this->createDateTimeNow(),\n            'expire' => null,\n            'setMaxAge' => 1,\n            'setSharedMaxAge' => 1,\n            'setTtl' => 1,\n            'setClientTtl' => 1,\n        ];\n\n        foreach ($setters as $setter => $arg) {\n            $this->assertEquals($response, $response->{$setter}($arg));\n        }\n    }\n\n    public function testNoDeprecationsAreTriggered()\n    {\n        new DefaultResponse();\n        $this->getMockBuilder(Response::class)->getMock();\n\n        // we just need to ensure that subclasses of Response can be created without any deprecations\n        // being triggered if the subclass does not override any final methods\n        $this->addToAssertionCount(1);\n    }\n\n    public function validContentProvider()\n    {\n        return [\n            'obj' => [new StringableObject()],\n            'string' => ['Foo'],\n            'int' => [2],\n        ];\n    }\n\n    public function invalidContentProvider()\n    {\n        return [\n            'obj' => [new \\stdClass()],\n            'array' => [[]],\n            'bool' => [true, '1'],\n        ];\n    }\n\n    protected function createDateTimeOneHourAgo()\n    {\n        return $this->createDateTimeNow()->sub(new \\DateInterval('PT1H'));\n    }\n\n    protected function createDateTimeOneHourLater()\n    {\n        return $this->createDateTimeNow()->add(new \\DateInterval('PT1H'));\n    }\n\n    protected function createDateTimeNow()\n    {\n        $date = new \\DateTime();\n\n        return $date->setTimestamp(time());\n    }\n\n    protected function createDateTimeImmutableNow()\n    {\n        $date = new \\DateTimeImmutable();\n\n        return $date->setTimestamp(time());\n    }\n\n    protected function provideResponse()\n    {\n        return new Response();\n    }\n\n    /**\n     * @see http://github.com/zendframework/zend-diactoros for the canonical source repository\n     *\n     * @author F\u00e1bio Pacheco\n     * @copyright Copyright (c) 2015-2016 Zend Technologies USA Inc. (http://www.zend.com)\n     * @license https://github.com/zendframework/zend-diactoros/blob/master/LICENSE.md New BSD License\n     */\n    public function ianaCodesReasonPhrasesProvider()\n    {\n        if (!\\in_array('https', stream_get_wrappers(), true)) {\n            $this->markTestSkipped('The \"https\" wrapper is not available');\n        }\n\n        $ianaHttpStatusCodes = new \\DOMDocument();\n\n        $context = stream_context_create([\n            'http' => [\n                'method' => 'GET',\n                'timeout' => 30,\n                'user_agent' => __METHOD__,\n            ],\n        ]);\n\n        $ianaHttpStatusCodes->loadXML(file_get_contents('https://www.iana.org/assignments/http-status-codes/http-status-codes.xml', false, $context));\n        if (!$ianaHttpStatusCodes->relaxNGValidate(__DIR__.'/schema/http-status-codes.rng')) {\n            self::fail('Invalid IANA\\'s HTTP status code list.');\n        }\n\n        $ianaCodesReasonPhrases = [];\n\n        $xpath = new \\DOMXPath($ianaHttpStatusCodes);\n        $xpath->registerNamespace('ns', 'http://www.iana.org/assignments');\n\n        $records = $xpath->query('//ns:record');\n        foreach ($records as $record) {\n            $value = $xpath->query('.//ns:value', $record)->item(0)->nodeValue;\n            $description = $xpath->query('.//ns:description', $record)->item(0)->nodeValue;\n\n            if (\\in_array($description, ['Unassigned', '(Unused)'], true)) {\n                continue;\n            }\n\n            if (preg_match('/^([0-9]+)\\s*\\-\\s*([0-9]+)$/', $value, $matches)) {\n                for ($value = $matches[1]; $value <= $matches[2]; ++$value) {\n                    $ianaCodesReasonPhrases[] = [$value, $description];\n                }\n            } else {\n                $ianaCodesReasonPhrases[] = [$value, $description];\n            }\n        }\n\n        return $ianaCodesReasonPhrases;\n    }\n\n    /**\n     * @dataProvider ianaCodesReasonPhrasesProvider\n     */\n    public function testReasonPhraseDefaultsAgainstIana($code, $reasonPhrase)\n    {\n        $this->assertEquals($reasonPhrase, Response::$statusTexts[$code]);\n    }\n}\n\nclass StringableObject\n{\n    public function __toString(): string\n    {\n        return 'Foo';\n    }\n}\n\nclass DefaultResponse extends Response\n{\n}\n"], "filenames": ["src/Symfony/Component/ErrorHandler/ErrorRenderer/SerializerErrorRenderer.php", "src/Symfony/Component/HttpFoundation/Request.php", "src/Symfony/Component/HttpFoundation/Response.php", "src/Symfony/Component/HttpFoundation/Tests/ResponseTest.php"], "buggy_code_start_loc": [14, 1593, 278, 499], "buggy_code_end_loc": [65, 1594, 279, 506], "fixing_code_start_loc": [15, 1593, 278, 500], "fixing_code_end_loc": [72, 1596, 279, 518], "type": "CWE-20", "message": "In Symfony before versions 4.4.7 and 5.0.7, when a `Response` does not contain a `Content-Type` header, affected versions of Symfony can fallback to the format defined in the `Accept` header of the request, leading to a possible mismatch between the response&#39;s content and `Content-Type` header. When the response is cached, this can prevent the use of the website by other users. This has been patched in versions 4.4.7 and 5.0.7.", "other": {"cve": {"id": "CVE-2020-5255", "sourceIdentifier": "security-advisories@github.com", "published": "2020-03-30T20:15:19.570", "lastModified": "2020-04-09T17:15:13.237", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Symfony before versions 4.4.7 and 5.0.7, when a `Response` does not contain a `Content-Type` header, affected versions of Symfony can fallback to the format defined in the `Accept` header of the request, leading to a possible mismatch between the response&#39;s content and `Content-Type` header. When the response is cached, this can prevent the use of the website by other users. This has been patched in versions 4.4.7 and 5.0.7."}, {"lang": "es", "value": "En Symfony en versiones anteriores a las versiones 4.4.7 y 5.0.7, cuando una \"Response\" no contiene un encabezado \"Content-Type\", las versiones afectadas de Symfony pueden retroceder al formato definido en el encabezado \"Accept\" de la petici\u00f3n, conllevando a una posible falta de coincidencia entre el contenido response's y el encabezado \"Content-Type\". Cuando la respuesta es almacenada en cach\u00e9, esto puede impedir el uso del sitio web por otros usuarios. Esto ha sido parcheado en las versiones 4.4.7 y 5.0.7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-435"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4.0", "versionEndExcluding": "4.4.7", "matchCriteriaId": "95F04BAB-4B76-4142-B000-67FA0A9F73F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.7", "matchCriteriaId": "A656BCAC-1974-4E5D-B7E3-4162A6153A4B"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/dca343442e6a954f96a2609e7b4e9c21ed6d74e6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/security/advisories/GHSA-mcx4-f5f5-4859", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/C36JLPHUPKDFAX6D5WYFC4ALO2K7RDUQ/", "source": "security-advisories@github.com"}, {"url": "https://symfony.com/blog/cve-2020-5255-prevent-cache-poisoning-via-a-response-content-type-header", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/dca343442e6a954f96a2609e7b4e9c21ed6d74e6"}}