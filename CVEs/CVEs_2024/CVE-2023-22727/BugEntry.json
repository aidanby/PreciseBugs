{"buggy_code": ["<?php\ndeclare(strict_types=1);\n\n/**\n * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)\n * @link          https://cakephp.org CakePHP(tm) Project\n * @since         3.0.0\n * @license       https://opensource.org/licenses/mit-license.php MIT License\n */\nnamespace Cake\\Database;\n\nuse Cake\\Database\\Exception\\DatabaseException;\nuse Cake\\Database\\Expression\\CommonTableExpression;\nuse Cake\\Database\\Expression\\IdentifierExpression;\nuse Cake\\Database\\Expression\\OrderByExpression;\nuse Cake\\Database\\Expression\\OrderClauseExpression;\nuse Cake\\Database\\Expression\\QueryExpression;\nuse Cake\\Database\\Expression\\ValuesExpression;\nuse Cake\\Database\\Expression\\WindowExpression;\nuse Cake\\Database\\Statement\\CallbackStatement;\nuse Closure;\nuse InvalidArgumentException;\nuse IteratorAggregate;\nuse RuntimeException;\n\n/**\n * This class represents a Relational database SQL Query. A query can be of\n * different types like select, update, insert and delete. Exposes the methods\n * for dynamically constructing each query part, execute it and transform it\n * to a specific SQL dialect.\n */\nclass Query implements ExpressionInterface, IteratorAggregate\n{\n    use TypeMapTrait;\n\n    /**\n     * @var string\n     */\n    public const JOIN_TYPE_INNER = 'INNER';\n\n    /**\n     * @var string\n     */\n    public const JOIN_TYPE_LEFT = 'LEFT';\n\n    /**\n     * @var string\n     */\n    public const JOIN_TYPE_RIGHT = 'RIGHT';\n\n    /**\n     * Connection instance to be used to execute this query.\n     *\n     * @var \\Cake\\Database\\Connection\n     */\n    protected $_connection;\n\n    /**\n     * Type of this query (select, insert, update, delete).\n     *\n     * @var string\n     */\n    protected $_type = 'select';\n\n    /**\n     * List of SQL parts that will be used to build this query.\n     *\n     * @var array<string, mixed>\n     */\n    protected $_parts = [\n        'delete' => true,\n        'update' => [],\n        'set' => [],\n        'insert' => [],\n        'values' => [],\n        'with' => [],\n        'select' => [],\n        'distinct' => false,\n        'modifier' => [],\n        'from' => [],\n        'join' => [],\n        'where' => null,\n        'group' => [],\n        'having' => null,\n        'window' => [],\n        'order' => null,\n        'limit' => null,\n        'offset' => null,\n        'union' => [],\n        'epilog' => null,\n    ];\n\n    /**\n     * The list of query clauses to traverse for generating a SELECT statement\n     *\n     * @var array<string>\n     * @deprecated 4.4.3 This property is unused.\n     */\n    protected $_selectParts = [\n        'with', 'select', 'from', 'join', 'where', 'group', 'having', 'order', 'limit',\n        'offset', 'union', 'epilog',\n    ];\n\n    /**\n     * The list of query clauses to traverse for generating an UPDATE statement\n     *\n     * @var array<string>\n     * @deprecated 4.4.3 This property is unused.\n     */\n    protected $_updateParts = ['with', 'update', 'set', 'where', 'epilog'];\n\n    /**\n     * The list of query clauses to traverse for generating a DELETE statement\n     *\n     * @var array<string>\n     * @deprecated 4.4.3 This property is unused.\n     */\n    protected $_deleteParts = ['with', 'delete', 'modifier', 'from', 'where', 'epilog'];\n\n    /**\n     * The list of query clauses to traverse for generating an INSERT statement\n     *\n     * @var array<string>\n     * @deprecated 4.4.3 This property is unused.\n     */\n    protected $_insertParts = ['with', 'insert', 'values', 'epilog'];\n\n    /**\n     * Indicates whether internal state of this query was changed, this is used to\n     * discard internal cached objects such as the transformed query or the reference\n     * to the executed statement.\n     *\n     * @var bool\n     */\n    protected $_dirty = false;\n\n    /**\n     * A list of callback functions to be called to alter each row from resulting\n     * statement upon retrieval. Each one of the callback function will receive\n     * the row array as first argument.\n     *\n     * @var array<callable>\n     */\n    protected $_resultDecorators = [];\n\n    /**\n     * Statement object resulting from executing this query.\n     *\n     * @var \\Cake\\Database\\StatementInterface|null\n     */\n    protected $_iterator;\n\n    /**\n     * The object responsible for generating query placeholders and temporarily store values\n     * associated to each of those.\n     *\n     * @var \\Cake\\Database\\ValueBinder|null\n     */\n    protected $_valueBinder;\n\n    /**\n     * Instance of functions builder object used for generating arbitrary SQL functions.\n     *\n     * @var \\Cake\\Database\\FunctionsBuilder|null\n     */\n    protected $_functionsBuilder;\n\n    /**\n     * Boolean for tracking whether buffered results\n     * are enabled.\n     *\n     * @var bool\n     */\n    protected $_useBufferedResults = true;\n\n    /**\n     * The Type map for fields in the select clause\n     *\n     * @var \\Cake\\Database\\TypeMap|null\n     */\n    protected $_selectTypeMap;\n\n    /**\n     * Tracking flag to disable casting\n     *\n     * @var bool\n     */\n    protected $typeCastEnabled = true;\n\n    /**\n     * Constructor.\n     *\n     * @param \\Cake\\Database\\Connection $connection The connection\n     * object to be used for transforming and executing this query\n     */\n    public function __construct(Connection $connection)\n    {\n        $this->setConnection($connection);\n    }\n\n    /**\n     * Sets the connection instance to be used for executing and transforming this query.\n     *\n     * @param \\Cake\\Database\\Connection $connection Connection instance\n     * @return $this\n     */\n    public function setConnection(Connection $connection)\n    {\n        $this->_dirty();\n        $this->_connection = $connection;\n\n        return $this;\n    }\n\n    /**\n     * Gets the connection instance to be used for executing and transforming this query.\n     *\n     * @return \\Cake\\Database\\Connection\n     */\n    public function getConnection(): Connection\n    {\n        return $this->_connection;\n    }\n\n    /**\n     * Compiles the SQL representation of this query and executes it using the\n     * configured connection object. Returns the resulting statement object.\n     *\n     * Executing a query internally executes several steps, the first one is\n     * letting the connection transform this object to fit its particular dialect,\n     * this might result in generating a different Query object that will be the one\n     * to actually be executed. Immediately after, literal values are passed to the\n     * connection so they are bound to the query in a safe way. Finally, the resulting\n     * statement is decorated with custom objects to execute callbacks for each row\n     * retrieved if necessary.\n     *\n     * Resulting statement is traversable, so it can be used in any loop as you would\n     * with an array.\n     *\n     * This method can be overridden in query subclasses to decorate behavior\n     * around query execution.\n     *\n     * @return \\Cake\\Database\\StatementInterface\n     */\n    public function execute(): StatementInterface\n    {\n        $statement = $this->_connection->run($this);\n        $this->_iterator = $this->_decorateStatement($statement);\n        $this->_dirty = false;\n\n        return $this->_iterator;\n    }\n\n    /**\n     * Executes the SQL of this query and immediately closes the statement before returning the row count of records\n     * changed.\n     *\n     * This method can be used with UPDATE and DELETE queries, but is not recommended for SELECT queries and is not\n     * used to count records.\n     *\n     * ## Example\n     *\n     * ```\n     * $rowCount = $query->update('articles')\n     *                 ->set(['published'=>true])\n     *                 ->where(['published'=>false])\n     *                 ->rowCountAndClose();\n     * ```\n     *\n     * The above example will change the published column to true for all false records, and return the number of\n     * records that were updated.\n     *\n     * @return int\n     */\n    public function rowCountAndClose(): int\n    {\n        $statement = $this->execute();\n        try {\n            return $statement->rowCount();\n        } finally {\n            $statement->closeCursor();\n        }\n    }\n\n    /**\n     * Returns the SQL representation of this object.\n     *\n     * This function will compile this query to make it compatible\n     * with the SQL dialect that is used by the connection, This process might\n     * add, remove or alter any query part or internal expression to make it\n     * executable in the target platform.\n     *\n     * The resulting query may have placeholders that will be replaced with the actual\n     * values when the query is executed, hence it is most suitable to use with\n     * prepared statements.\n     *\n     * @param \\Cake\\Database\\ValueBinder|null $binder Value binder that generates parameter placeholders\n     * @return string\n     */\n    public function sql(?ValueBinder $binder = null): string\n    {\n        if (!$binder) {\n            $binder = $this->getValueBinder();\n            $binder->resetCount();\n        }\n\n        return $this->getConnection()->compileQuery($this, $binder);\n    }\n\n    /**\n     * Will iterate over every specified part. Traversing functions can aggregate\n     * results using variables in the closure or instance variables. This function\n     * is commonly used as a way for traversing all query parts that\n     * are going to be used for constructing a query.\n     *\n     * The callback will receive 2 parameters, the first one is the value of the query\n     * part that is being iterated and the second the name of such part.\n     *\n     * ### Example\n     * ```\n     * $query->select(['title'])->from('articles')->traverse(function ($value, $clause) {\n     *     if ($clause === 'select') {\n     *         var_dump($value);\n     *     }\n     * });\n     * ```\n     *\n     * @param callable $callback A function or callable to be executed for each part\n     * @return $this\n     */\n    public function traverse($callback)\n    {\n        foreach ($this->_parts as $name => $part) {\n            $callback($part, $name);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Will iterate over the provided parts.\n     *\n     * Traversing functions can aggregate results using variables in the closure\n     * or instance variables. This method can be used to traverse a subset of\n     * query parts in order to render a SQL query.\n     *\n     * The callback will receive 2 parameters, the first one is the value of the query\n     * part that is being iterated and the second the name of such part.\n     *\n     * ### Example\n     *\n     * ```\n     * $query->select(['title'])->from('articles')->traverse(function ($value, $clause) {\n     *     if ($clause === 'select') {\n     *         var_dump($value);\n     *     }\n     * }, ['select', 'from']);\n     * ```\n     *\n     * @param callable $visitor A function or callable to be executed for each part\n     * @param array<string> $parts The list of query parts to traverse\n     * @return $this\n     */\n    public function traverseParts(callable $visitor, array $parts)\n    {\n        foreach ($parts as $name) {\n            $visitor($this->_parts[$name], $name);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Adds a new common table expression (CTE) to the query.\n     *\n     * ### Examples:\n     *\n     * Common table expressions can either be passed as preconstructed expression\n     * objects:\n     *\n     * ```\n     * $cte = new \\Cake\\Database\\Expression\\CommonTableExpression(\n     *     'cte',\n     *     $connection\n     *         ->newQuery()\n     *         ->select('*')\n     *         ->from('articles')\n     * );\n     *\n     * $query->with($cte);\n     * ```\n     *\n     * or returned from a closure, which will receive a new common table expression\n     * object as the first argument, and a new blank query object as\n     * the second argument:\n     *\n     * ```\n     * $query->with(function (\n     *     \\Cake\\Database\\Expression\\CommonTableExpression $cte,\n     *     \\Cake\\Database\\Query $query\n     *  ) {\n     *     $cteQuery = $query\n     *         ->select('*')\n     *         ->from('articles');\n     *\n     *     return $cte\n     *         ->name('cte')\n     *         ->query($cteQuery);\n     * });\n     * ```\n     *\n     * @param \\Cake\\Database\\Expression\\CommonTableExpression|\\Closure $cte The CTE to add.\n     * @param bool $overwrite Whether to reset the list of CTEs.\n     * @return $this\n     */\n    public function with($cte, bool $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['with'] = [];\n        }\n\n        if ($cte instanceof Closure) {\n            $query = $this->getConnection()->newQuery();\n            $cte = $cte(new CommonTableExpression(), $query);\n            if (!($cte instanceof CommonTableExpression)) {\n                throw new RuntimeException(\n                    'You must return a `CommonTableExpression` from a Closure passed to `with()`.'\n                );\n            }\n        }\n\n        $this->_parts['with'][] = $cte;\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds new fields to be returned by a `SELECT` statement when this query is\n     * executed. Fields can be passed as an array of strings, array of expression\n     * objects, a single expression or a single string.\n     *\n     * If an array is passed, keys will be used to alias fields using the value as the\n     * real field to be aliased. It is possible to alias strings, Expression objects or\n     * even other Query objects.\n     *\n     * If a callable function is passed, the returning array of the function will\n     * be used as the list of fields.\n     *\n     * By default this function will append any passed argument to the list of fields\n     * to be selected, unless the second argument is set to true.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $query->select(['id', 'title']); // Produces SELECT id, title\n     * $query->select(['author' => 'author_id']); // Appends author: SELECT id, title, author_id as author\n     * $query->select('id', true); // Resets the list: SELECT id\n     * $query->select(['total' => $countQuery]); // SELECT id, (SELECT ...) AS total\n     * $query->select(function ($query) {\n     *     return ['article_id', 'total' => $query->count('*')];\n     * })\n     * ```\n     *\n     * By default no fields are selected, if you have an instance of `Cake\\ORM\\Query` and try to append\n     * fields you should also call `Cake\\ORM\\Query::enableAutoFields()` to select the default fields\n     * from the table.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|callable|array|string $fields fields to be added to the list.\n     * @param bool $overwrite whether to reset fields with passed list or not\n     * @return $this\n     */\n    public function select($fields = [], bool $overwrite = false)\n    {\n        if (!is_string($fields) && is_callable($fields)) {\n            $fields = $fields($this);\n        }\n\n        if (!is_array($fields)) {\n            $fields = [$fields];\n        }\n\n        if ($overwrite) {\n            $this->_parts['select'] = $fields;\n        } else {\n            $this->_parts['select'] = array_merge($this->_parts['select'], $fields);\n        }\n\n        $this->_dirty();\n        $this->_type = 'select';\n\n        return $this;\n    }\n\n    /**\n     * Adds a `DISTINCT` clause to the query to remove duplicates from the result set.\n     * This clause can only be used for select statements.\n     *\n     * If you wish to filter duplicates based of those rows sharing a particular field\n     * or set of fields, you may pass an array of fields to filter on. Beware that\n     * this option might not be fully supported in all database systems.\n     *\n     * ### Examples:\n     *\n     * ```\n     * // Filters products with the same name and city\n     * $query->select(['name', 'city'])->from('products')->distinct();\n     *\n     * // Filters products in the same city\n     * $query->distinct(['city']);\n     * $query->distinct('city');\n     *\n     * // Filter products with the same name\n     * $query->distinct(['name'], true);\n     * $query->distinct('name', true);\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string|bool $on Enable/disable distinct class\n     * or list of fields to be filtered on\n     * @param bool $overwrite whether to reset fields with passed list or not\n     * @return $this\n     */\n    public function distinct($on = [], $overwrite = false)\n    {\n        if ($on === []) {\n            $on = true;\n        } elseif (is_string($on)) {\n            $on = [$on];\n        }\n\n        if (is_array($on)) {\n            $merge = [];\n            if (is_array($this->_parts['distinct'])) {\n                $merge = $this->_parts['distinct'];\n            }\n            $on = $overwrite ? array_values($on) : array_merge($merge, array_values($on));\n        }\n\n        $this->_parts['distinct'] = $on;\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple `SELECT` modifiers to be used in the `SELECT`.\n     *\n     * By default this function will append any passed argument to the list of modifiers\n     * to be applied, unless the second argument is set to true.\n     *\n     * ### Example:\n     *\n     * ```\n     * // Ignore cache query in MySQL\n     * $query->select(['name', 'city'])->from('products')->modifier('SQL_NO_CACHE');\n     * // It will produce the SQL: SELECT SQL_NO_CACHE name, city FROM products\n     *\n     * // Or with multiple modifiers\n     * $query->select(['name', 'city'])->from('products')->modifier(['HIGH_PRIORITY', 'SQL_NO_CACHE']);\n     * // It will produce the SQL: SELECT HIGH_PRIORITY SQL_NO_CACHE name, city FROM products\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $modifiers modifiers to be applied to the query\n     * @param bool $overwrite whether to reset order with field list or not\n     * @return $this\n     */\n    public function modifier($modifiers, $overwrite = false)\n    {\n        $this->_dirty();\n        if ($overwrite) {\n            $this->_parts['modifier'] = [];\n        }\n        if (!is_array($modifiers)) {\n            $modifiers = [$modifiers];\n        }\n        $this->_parts['modifier'] = array_merge($this->_parts['modifier'], $modifiers);\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple tables to be used in the FROM clause for this query.\n     * Tables can be passed as an array of strings, array of expression\n     * objects, a single expression or a single string.\n     *\n     * If an array is passed, keys will be used to alias tables using the value as the\n     * real field to be aliased. It is possible to alias strings, ExpressionInterface objects or\n     * even other Query objects.\n     *\n     * By default this function will append any passed argument to the list of tables\n     * to be selected from, unless the second argument is set to true.\n     *\n     * This method can be used for select, update and delete statements.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $query->from(['p' => 'posts']); // Produces FROM posts p\n     * $query->from('authors'); // Appends authors: FROM posts p, authors\n     * $query->from(['products'], true); // Resets the list: FROM products\n     * $query->from(['sub' => $countQuery]); // FROM (SELECT ...) sub\n     * ```\n     *\n     * @param array|string $tables tables to be added to the list. This argument, can be\n     *  passed as an array of strings, array of expression objects, or a single string. See\n     *  the examples above for the valid call types.\n     * @param bool $overwrite whether to reset tables with passed list or not\n     * @return $this\n     */\n    public function from($tables = [], $overwrite = false)\n    {\n        $tables = (array)$tables;\n\n        if ($overwrite) {\n            $this->_parts['from'] = $tables;\n        } else {\n            $this->_parts['from'] = array_merge($this->_parts['from'], $tables);\n        }\n\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple tables to be used as JOIN clauses to this query.\n     * Tables can be passed as an array of strings, an array describing the\n     * join parts, an array with multiple join descriptions, or a single string.\n     *\n     * By default this function will append any passed argument to the list of tables\n     * to be joined, unless the third argument is set to true.\n     *\n     * When no join type is specified an `INNER JOIN` is used by default:\n     * `$query->join(['authors'])` will produce `INNER JOIN authors ON 1 = 1`\n     *\n     * It is also possible to alias joins using the array key:\n     * `$query->join(['a' => 'authors'])` will produce `INNER JOIN authors a ON 1 = 1`\n     *\n     * A join can be fully described and aliased using the array notation:\n     *\n     * ```\n     * $query->join([\n     *     'a' => [\n     *         'table' => 'authors',\n     *         'type' => 'LEFT',\n     *         'conditions' => 'a.id = b.author_id'\n     *     ]\n     * ]);\n     * // Produces LEFT JOIN authors a ON a.id = b.author_id\n     * ```\n     *\n     * You can even specify multiple joins in an array, including the full description:\n     *\n     * ```\n     * $query->join([\n     *     'a' => [\n     *         'table' => 'authors',\n     *         'type' => 'LEFT',\n     *         'conditions' => 'a.id = b.author_id'\n     *     ],\n     *     'p' => [\n     *         'table' => 'publishers',\n     *         'type' => 'INNER',\n     *         'conditions' => 'p.id = b.publisher_id AND p.name = \"Cake Software Foundation\"'\n     *     ]\n     * ]);\n     * // LEFT JOIN authors a ON a.id = b.author_id\n     * // INNER JOIN publishers p ON p.id = b.publisher_id AND p.name = \"Cake Software Foundation\"\n     * ```\n     *\n     * ### Using conditions and types\n     *\n     * Conditions can be expressed, as in the examples above, using a string for comparing\n     * columns, or string with already quoted literal values. Additionally it is\n     * possible to use conditions expressed in arrays or expression objects.\n     *\n     * When using arrays for expressing conditions, it is often desirable to convert\n     * the literal values to the correct database representation. This is achieved\n     * using the second parameter of this function.\n     *\n     * ```\n     * $query->join(['a' => [\n     *     'table' => 'articles',\n     *     'conditions' => [\n     *         'a.posted >=' => new DateTime('-3 days'),\n     *         'a.published' => true,\n     *         'a.author_id = authors.id'\n     *     ]\n     * ]], ['a.posted' => 'datetime', 'a.published' => 'boolean'])\n     * ```\n     *\n     * ### Overwriting joins\n     *\n     * When creating aliased joins using the array notation, you can override\n     * previous join definitions by using the same alias in consequent\n     * calls to this function or you can replace all previously defined joins\n     * with another list if the third parameter for this function is set to true.\n     *\n     * ```\n     * $query->join(['alias' => 'table']); // joins table with as alias\n     * $query->join(['alias' => 'another_table']); // joins another_table with as alias\n     * $query->join(['something' => 'different_table'], [], true); // resets joins list\n     * ```\n     *\n     * @param array<string, mixed>|string $tables list of tables to be joined in the query\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @param bool $overwrite whether to reset joins with passed list or not\n     * @see \\Cake\\Database\\TypeFactory\n     * @return $this\n     */\n    public function join($tables, $types = [], $overwrite = false)\n    {\n        if (is_string($tables) || isset($tables['table'])) {\n            $tables = [$tables];\n        }\n\n        $joins = [];\n        $i = count($this->_parts['join']);\n        foreach ($tables as $alias => $t) {\n            if (!is_array($t)) {\n                $t = ['table' => $t, 'conditions' => $this->newExpr()];\n            }\n\n            if (!is_string($t['conditions']) && is_callable($t['conditions'])) {\n                $t['conditions'] = $t['conditions']($this->newExpr(), $this);\n            }\n\n            if (!($t['conditions'] instanceof ExpressionInterface)) {\n                $t['conditions'] = $this->newExpr()->add($t['conditions'], $types);\n            }\n            $alias = is_string($alias) ? $alias : null;\n            $joins[$alias ?: $i++] = $t + ['type' => static::JOIN_TYPE_INNER, 'alias' => $alias];\n        }\n\n        if ($overwrite) {\n            $this->_parts['join'] = $joins;\n        } else {\n            $this->_parts['join'] = array_merge($this->_parts['join'], $joins);\n        }\n\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Remove a join if it has been defined.\n     *\n     * Useful when you are redefining joins or want to re-order\n     * the join clauses.\n     *\n     * @param string $name The alias/name of the join to remove.\n     * @return $this\n     */\n    public function removeJoin(string $name)\n    {\n        unset($this->_parts['join'][$name]);\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a single `LEFT JOIN` clause to the query.\n     *\n     * This is a shorthand method for building joins via `join()`.\n     *\n     * The table name can be passed as a string, or as an array in case it needs to\n     * be aliased:\n     *\n     * ```\n     * // LEFT JOIN authors ON authors.id = posts.author_id\n     * $query->leftJoin('authors', 'authors.id = posts.author_id');\n     *\n     * // LEFT JOIN authors a ON a.id = posts.author_id\n     * $query->leftJoin(['a' => 'authors'], 'a.id = posts.author_id');\n     * ```\n     *\n     * Conditions can be passed as strings, arrays, or expression objects. When\n     * using arrays it is possible to combine them with the `$types` parameter\n     * in order to define how to convert the values:\n     *\n     * ```\n     * $query->leftJoin(['a' => 'articles'], [\n     *      'a.posted >=' => new DateTime('-3 days'),\n     *      'a.published' => true,\n     *      'a.author_id = authors.id'\n     * ], ['a.posted' => 'datetime', 'a.published' => 'boolean']);\n     * ```\n     *\n     * See `join()` for further details on conditions and types.\n     *\n     * @param array<string, mixed>|string $table The table to join with\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $conditions The conditions\n     * to use for joining.\n     * @param array $types a list of types associated to the conditions used for converting\n     * values to the corresponding database representation.\n     * @return $this\n     */\n    public function leftJoin($table, $conditions = [], $types = [])\n    {\n        $this->join($this->_makeJoin($table, $conditions, static::JOIN_TYPE_LEFT), $types);\n\n        return $this;\n    }\n\n    /**\n     * Adds a single `RIGHT JOIN` clause to the query.\n     *\n     * This is a shorthand method for building joins via `join()`.\n     *\n     * The arguments of this method are identical to the `leftJoin()` shorthand, please refer\n     * to that methods description for further details.\n     *\n     * @param array<string, mixed>|string $table The table to join with\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $conditions The conditions\n     * to use for joining.\n     * @param array $types a list of types associated to the conditions used for converting\n     * values to the corresponding database representation.\n     * @return $this\n     */\n    public function rightJoin($table, $conditions = [], $types = [])\n    {\n        $this->join($this->_makeJoin($table, $conditions, static::JOIN_TYPE_RIGHT), $types);\n\n        return $this;\n    }\n\n    /**\n     * Adds a single `INNER JOIN` clause to the query.\n     *\n     * This is a shorthand method for building joins via `join()`.\n     *\n     * The arguments of this method are identical to the `leftJoin()` shorthand, please refer\n     * to that method's description for further details.\n     *\n     * @param array<string, mixed>|string $table The table to join with\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $conditions The conditions\n     * to use for joining.\n     * @param array<string, string> $types a list of types associated to the conditions used for converting\n     * values to the corresponding database representation.\n     * @return $this\n     */\n    public function innerJoin($table, $conditions = [], $types = [])\n    {\n        $this->join($this->_makeJoin($table, $conditions, static::JOIN_TYPE_INNER), $types);\n\n        return $this;\n    }\n\n    /**\n     * Returns an array that can be passed to the join method describing a single join clause\n     *\n     * @param array<string, mixed>|string $table The table to join with\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $conditions The conditions\n     * to use for joining.\n     * @param string $type the join type to use\n     * @return array\n     * @psalm-suppress InvalidReturnType\n     */\n    protected function _makeJoin($table, $conditions, $type): array\n    {\n        $alias = $table;\n\n        if (is_array($table)) {\n            $alias = key($table);\n            $table = current($table);\n        }\n\n        /**\n         * @psalm-suppress InvalidArrayOffset\n         * @psalm-suppress InvalidReturnStatement\n         */\n        return [\n            $alias => [\n                'table' => $table,\n                'conditions' => $conditions,\n                'type' => $type,\n            ],\n        ];\n    }\n\n    /**\n     * Adds a condition or set of conditions to be used in the WHERE clause for this\n     * query. Conditions can be expressed as an array of fields as keys with\n     * comparison operators in it, the values for the array will be used for comparing\n     * the field to such literal. Finally, conditions can be expressed as a single\n     * string or an array of strings.\n     *\n     * When using arrays, each entry will be joined to the rest of the conditions using\n     * an `AND` operator. Consecutive calls to this function will also join the new\n     * conditions specified using the AND operator. Additionally, values can be\n     * expressed using expression objects which can include other query objects.\n     *\n     * Any conditions created with this methods can be used with any `SELECT`, `UPDATE`\n     * and `DELETE` type of queries.\n     *\n     * ### Conditions using operators:\n     *\n     * ```\n     * $query->where([\n     *     'posted >=' => new DateTime('3 days ago'),\n     *     'title LIKE' => 'Hello W%',\n     *     'author_id' => 1,\n     * ], ['posted' => 'datetime']);\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE posted >= 2012-01-27 AND title LIKE 'Hello W%' AND author_id = 1`\n     *\n     * Second parameter is used to specify what type is expected for each passed\n     * key. Valid types can be used from the mapped with Database\\Type class.\n     *\n     * ### Nesting conditions with conjunctions:\n     *\n     * ```\n     * $query->where([\n     *     'author_id !=' => 1,\n     *     'OR' => ['published' => true, 'posted <' => new DateTime('now')],\n     *     'NOT' => ['title' => 'Hello']\n     * ], ['published' => boolean, 'posted' => 'datetime']\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE author_id = 1 AND (published = 1 OR posted < '2012-02-01') AND NOT (title = 'Hello')`\n     *\n     * You can nest conditions using conjunctions as much as you like. Sometimes, you\n     * may want to define 2 different options for the same key, in that case, you can\n     * wrap each condition inside a new array:\n     *\n     * `$query->where(['OR' => [['published' => false], ['published' => true]])`\n     *\n     * Would result in:\n     *\n     * `WHERE (published = false) OR (published = true)`\n     *\n     * Keep in mind that every time you call where() with the third param set to false\n     * (default), it will join the passed conditions to the previous stored list using\n     * the `AND` operator. Also, using the same array key twice in consecutive calls to\n     * this method will not override the previous value.\n     *\n     * ### Using expressions objects:\n     *\n     * ```\n     * $exp = $query->newExpr()->add(['id !=' => 100, 'author_id' != 1])->tieWith('OR');\n     * $query->where(['published' => true], ['published' => 'boolean'])->where($exp);\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE (id != 100 OR author_id != 1) AND published = 1`\n     *\n     * Other Query objects that be used as conditions for any field.\n     *\n     * ### Adding conditions in multiple steps:\n     *\n     * You can use callable functions to construct complex expressions, functions\n     * receive as first argument a new QueryExpression object and this query instance\n     * as second argument. Functions must return an expression object, that will be\n     * added the list of conditions for the query using the `AND` operator.\n     *\n     * ```\n     * $query\n     *   ->where(['title !=' => 'Hello World'])\n     *   ->where(function ($exp, $query) {\n     *     $or = $exp->or(['id' => 1]);\n     *     $and = $exp->and(['id >' => 2, 'id <' => 10]);\n     *    return $or->add($and);\n     *   });\n     * ```\n     *\n     * * The previous example produces:\n     *\n     * `WHERE title != 'Hello World' AND (id = 1 OR (id > 2 AND id < 10))`\n     *\n     * ### Conditions as strings:\n     *\n     * ```\n     * $query->where(['articles.author_id = authors.id', 'modified IS NULL']);\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE articles.author_id = authors.id AND modified IS NULL`\n     *\n     * Please note that when using the array notation or the expression objects, all\n     * *values* will be correctly quoted and transformed to the correspondent database\n     * data type automatically for you, thus securing your application from SQL injections.\n     * The keys however, are not treated as unsafe input, and should be validated/sanitized.\n     *\n     * If you use string conditions make sure that your values are correctly quoted.\n     * The safest thing you can do is to never use string conditions.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string|null $conditions The conditions to filter on.\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @param bool $overwrite whether to reset conditions with passed list or not\n     * @see \\Cake\\Database\\TypeFactory\n     * @see \\Cake\\Database\\Expression\\QueryExpression\n     * @return $this\n     */\n    public function where($conditions = null, array $types = [], bool $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['where'] = $this->newExpr();\n        }\n        $this->_conjugate('where', $conditions, 'AND', $types);\n\n        return $this;\n    }\n\n    /**\n     * Convenience method that adds a NOT NULL condition to the query\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $fields A single field or expressions or a list of them\n     *  that should be not null.\n     * @return $this\n     */\n    public function whereNotNull($fields)\n    {\n        if (!is_array($fields)) {\n            $fields = [$fields];\n        }\n\n        $exp = $this->newExpr();\n\n        foreach ($fields as $field) {\n            $exp->isNotNull($field);\n        }\n\n        return $this->where($exp);\n    }\n\n    /**\n     * Convenience method that adds a IS NULL condition to the query\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $fields A single field or expressions or a list of them\n     *   that should be null.\n     * @return $this\n     */\n    public function whereNull($fields)\n    {\n        if (!is_array($fields)) {\n            $fields = [$fields];\n        }\n\n        $exp = $this->newExpr();\n\n        foreach ($fields as $field) {\n            $exp->isNull($field);\n        }\n\n        return $this->where($exp);\n    }\n\n    /**\n     * Adds an IN condition or set of conditions to be used in the WHERE clause for this\n     * query.\n     *\n     * This method does allow empty inputs in contrast to where() if you set\n     * 'allowEmpty' to true.\n     * Be careful about using it without proper sanity checks.\n     *\n     * Options:\n     *\n     * - `types` - Associative array of type names used to bind values to query\n     * - `allowEmpty` - Allow empty array.\n     *\n     * @param string $field Field\n     * @param array $values Array of values\n     * @param array<string, mixed> $options Options\n     * @return $this\n     */\n    public function whereInList(string $field, array $values, array $options = [])\n    {\n        $options += [\n            'types' => [],\n            'allowEmpty' => false,\n        ];\n\n        if ($options['allowEmpty'] && !$values) {\n            return $this->where('1=0');\n        }\n\n        return $this->where([$field . ' IN' => $values], $options['types']);\n    }\n\n    /**\n     * Adds a NOT IN condition or set of conditions to be used in the WHERE clause for this\n     * query.\n     *\n     * This method does allow empty inputs in contrast to where() if you set\n     * 'allowEmpty' to true.\n     * Be careful about using it without proper sanity checks.\n     *\n     * @param string $field Field\n     * @param array $values Array of values\n     * @param array<string, mixed> $options Options\n     * @return $this\n     */\n    public function whereNotInList(string $field, array $values, array $options = [])\n    {\n        $options += [\n            'types' => [],\n            'allowEmpty' => false,\n        ];\n\n        if ($options['allowEmpty'] && !$values) {\n            return $this->where([$field . ' IS NOT' => null]);\n        }\n\n        return $this->where([$field . ' NOT IN' => $values], $options['types']);\n    }\n\n    /**\n     * Adds a NOT IN condition or set of conditions to be used in the WHERE clause for this\n     * query. This also allows the field to be null with a IS NULL condition since the null\n     * value would cause the NOT IN condition to always fail.\n     *\n     * This method does allow empty inputs in contrast to where() if you set\n     * 'allowEmpty' to true.\n     * Be careful about using it without proper sanity checks.\n     *\n     * @param string $field Field\n     * @param array $values Array of values\n     * @param array<string, mixed> $options Options\n     * @return $this\n     */\n    public function whereNotInListOrNull(string $field, array $values, array $options = [])\n    {\n        $options += [\n            'types' => [],\n            'allowEmpty' => false,\n        ];\n\n        if ($options['allowEmpty'] && !$values) {\n            return $this->where([$field . ' IS NOT' => null]);\n        }\n\n        return $this->where(\n            [\n                'OR' => [$field . ' NOT IN' => $values, $field . ' IS' => null],\n            ],\n            $options['types']\n        );\n    }\n\n    /**\n     * Connects any previously defined set of conditions to the provided list\n     * using the AND operator. This function accepts the conditions list in the same\n     * format as the method `where` does, hence you can use arrays, expression objects\n     * callback functions or strings.\n     *\n     * It is important to notice that when calling this function, any previous set\n     * of conditions defined for this query will be treated as a single argument for\n     * the AND operator. This function will not only operate the most recently defined\n     * condition, but all the conditions as a whole.\n     *\n     * When using an array for defining conditions, creating constraints form each\n     * array entry will use the same logic as with the `where()` function. This means\n     * that each array entry will be joined to the other using the AND operator, unless\n     * you nest the conditions in the array using other operator.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $query->where(['title' => 'Hello World')->andWhere(['author_id' => 1]);\n     * ```\n     *\n     * Will produce:\n     *\n     * `WHERE title = 'Hello World' AND author_id = 1`\n     *\n     * ```\n     * $query\n     *   ->where(['OR' => ['published' => false, 'published is NULL']])\n     *   ->andWhere(['author_id' => 1, 'comments_count >' => 10])\n     * ```\n     *\n     * Produces:\n     *\n     * `WHERE (published = 0 OR published IS NULL) AND author_id = 1 AND comments_count > 10`\n     *\n     * ```\n     * $query\n     *   ->where(['title' => 'Foo'])\n     *   ->andWhere(function ($exp, $query) {\n     *     return $exp\n     *       ->or(['author_id' => 1])\n     *       ->add(['author_id' => 2]);\n     *   });\n     * ```\n     *\n     * Generates the following conditions:\n     *\n     * `WHERE (title = 'Foo') AND (author_id = 1 OR author_id = 2)`\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string $conditions The conditions to add with AND.\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @see \\Cake\\Database\\Query::where()\n     * @see \\Cake\\Database\\TypeFactory\n     * @return $this\n     */\n    public function andWhere($conditions, array $types = [])\n    {\n        $this->_conjugate('where', $conditions, 'AND', $types);\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple fields to be used in the ORDER clause for this query.\n     * Fields can be passed as an array of strings, array of expression\n     * objects, a single expression or a single string.\n     *\n     * If an array is passed, keys will be used as the field itself and the value will\n     * represent the order in which such field should be ordered. When called multiple\n     * times with the same fields as key, the last order definition will prevail over\n     * the others.\n     *\n     * By default this function will append any passed argument to the list of fields\n     * to be selected, unless the second argument is set to true.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $query->order(['title' => 'DESC', 'author_id' => 'ASC']);\n     * ```\n     *\n     * Produces:\n     *\n     * `ORDER BY title DESC, author_id ASC`\n     *\n     * ```\n     * $query\n     *     ->order(['title' => $query->newExpr('DESC NULLS FIRST')])\n     *     ->order('author_id');\n     * ```\n     *\n     * Will generate:\n     *\n     * `ORDER BY title DESC NULLS FIRST, author_id`\n     *\n     * ```\n     * $expression = $query->newExpr()->add(['id % 2 = 0']);\n     * $query->order($expression)->order(['title' => 'ASC']);\n     * ```\n     *\n     * and\n     *\n     * ```\n     * $query->order(function ($exp, $query) {\n     *     return [$exp->add(['id % 2 = 0']), 'title' => 'ASC'];\n     * });\n     * ```\n     *\n     * Will both become:\n     *\n     * `ORDER BY (id %2 = 0), title ASC`\n     *\n     * Order fields/directions are not sanitized by the query builder.\n     * You should use an allowed list of fields/directions when passing\n     * in user-supplied data to `order()`.\n     *\n     * If you need to set complex expressions as order conditions, you\n     * should use `orderAsc()` or `orderDesc()`.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string $fields fields to be added to the list\n     * @param bool $overwrite whether to reset order with field list or not\n     * @return $this\n     */\n    public function order($fields, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['order'] = null;\n        }\n\n        if (!$fields) {\n            return $this;\n        }\n\n        if (!$this->_parts['order']) {\n            $this->_parts['order'] = new OrderByExpression();\n        }\n        $this->_conjugate('order', $fields, '', []);\n\n        return $this;\n    }\n\n    /**\n     * Add an ORDER BY clause with an ASC direction.\n     *\n     * This method allows you to set complex expressions\n     * as order conditions unlike order()\n     *\n     * Order fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|string $field The field to order on.\n     * @param bool $overwrite Whether to reset the order clauses.\n     * @return $this\n     */\n    public function orderAsc($field, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['order'] = null;\n        }\n        if (!$field) {\n            return $this;\n        }\n\n        if ($field instanceof Closure) {\n            $field = $field($this->newExpr(), $this);\n        }\n\n        if (!$this->_parts['order']) {\n            $this->_parts['order'] = new OrderByExpression();\n        }\n        $this->_parts['order']->add(new OrderClauseExpression($field, 'ASC'));\n\n        return $this;\n    }\n\n    /**\n     * Add an ORDER BY clause with a DESC direction.\n     *\n     * This method allows you to set complex expressions\n     * as order conditions unlike order()\n     *\n     * Order fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|string $field The field to order on.\n     * @param bool $overwrite Whether to reset the order clauses.\n     * @return $this\n     */\n    public function orderDesc($field, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['order'] = null;\n        }\n        if (!$field) {\n            return $this;\n        }\n\n        if ($field instanceof Closure) {\n            $field = $field($this->newExpr(), $this);\n        }\n\n        if (!$this->_parts['order']) {\n            $this->_parts['order'] = new OrderByExpression();\n        }\n        $this->_parts['order']->add(new OrderClauseExpression($field, 'DESC'));\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple fields to be used in the GROUP BY clause for this query.\n     * Fields can be passed as an array of strings, array of expression\n     * objects, a single expression or a single string.\n     *\n     * By default this function will append any passed argument to the list of fields\n     * to be grouped, unless the second argument is set to true.\n     *\n     * ### Examples:\n     *\n     * ```\n     * // Produces GROUP BY id, title\n     * $query->group(['id', 'title']);\n     *\n     * // Produces GROUP BY title\n     * $query->group('title');\n     * ```\n     *\n     * Group fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $fields fields to be added to the list\n     * @param bool $overwrite whether to reset fields with passed list or not\n     * @return $this\n     */\n    public function group($fields, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['group'] = [];\n        }\n\n        if (!is_array($fields)) {\n            $fields = [$fields];\n        }\n\n        $this->_parts['group'] = array_merge($this->_parts['group'], array_values($fields));\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a condition or set of conditions to be used in the `HAVING` clause for this\n     * query. This method operates in exactly the same way as the method `where()`\n     * does. Please refer to its documentation for an insight on how to using each\n     * parameter.\n     *\n     * Having fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string|null $conditions The having conditions.\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @param bool $overwrite whether to reset conditions with passed list or not\n     * @see \\Cake\\Database\\Query::where()\n     * @return $this\n     */\n    public function having($conditions = null, $types = [], $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['having'] = $this->newExpr();\n        }\n        $this->_conjugate('having', $conditions, 'AND', $types);\n\n        return $this;\n    }\n\n    /**\n     * Connects any previously defined set of conditions to the provided list\n     * using the AND operator in the HAVING clause. This method operates in exactly\n     * the same way as the method `andWhere()` does. Please refer to its\n     * documentation for an insight on how to using each parameter.\n     *\n     * Having fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string $conditions The AND conditions for HAVING.\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @see \\Cake\\Database\\Query::andWhere()\n     * @return $this\n     */\n    public function andHaving($conditions, $types = [])\n    {\n        $this->_conjugate('having', $conditions, 'AND', $types);\n\n        return $this;\n    }\n\n    /**\n     * Adds a named window expression.\n     *\n     * You are responsible for adding windows in the order your database requires.\n     *\n     * @param string $name Window name\n     * @param \\Cake\\Database\\Expression\\WindowExpression|\\Closure $window Window expression\n     * @param bool $overwrite Clear all previous query window expressions\n     * @return $this\n     */\n    public function window(string $name, $window, bool $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['window'] = [];\n        }\n\n        if ($window instanceof Closure) {\n            $window = $window(new WindowExpression(), $this);\n            if (!($window instanceof WindowExpression)) {\n                throw new RuntimeException('You must return a `WindowExpression` from a Closure passed to `window()`.');\n            }\n        }\n\n        $this->_parts['window'][] = ['name' => new IdentifierExpression($name), 'window' => $window];\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Set the page of results you want.\n     *\n     * This method provides an easier to use interface to set the limit + offset\n     * in the record set you want as results. If empty the limit will default to\n     * the existing limit clause, and if that too is empty, then `25` will be used.\n     *\n     * Pages must start at 1.\n     *\n     * @param int $num The page number you want.\n     * @param int|null $limit The number of rows you want in the page. If null\n     *  the current limit clause will be used.\n     * @return $this\n     * @throws \\InvalidArgumentException If page number < 1.\n     */\n    public function page(int $num, ?int $limit = null)\n    {\n        if ($num < 1) {\n            throw new InvalidArgumentException('Pages must start at 1.');\n        }\n        if ($limit !== null) {\n            $this->limit($limit);\n        }\n        $limit = $this->clause('limit');\n        if ($limit === null) {\n            $limit = 25;\n            $this->limit($limit);\n        }\n        $offset = ($num - 1) * $limit;\n        if (PHP_INT_MAX <= $offset) {\n            $offset = PHP_INT_MAX;\n        }\n        $this->offset((int)$offset);\n\n        return $this;\n    }\n\n    /**\n     * Sets the number of records that should be retrieved from database,\n     * accepts an integer or an expression object that evaluates to an integer.\n     * In some databases, this operation might not be supported or will require\n     * the query to be transformed in order to limit the result set size.\n     *\n     * ### Examples\n     *\n     * ```\n     * $query->limit(10) // generates LIMIT 10\n     * $query->limit($query->newExpr()->add(['1 + 1'])); // LIMIT (1 + 1)\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|int|null $limit number of records to be returned\n     * @return $this\n     */\n    public function limit($limit)\n    {\n        $this->_dirty();\n        $this->_parts['limit'] = $limit;\n\n        return $this;\n    }\n\n    /**\n     * Sets the number of records that should be skipped from the original result set\n     * This is commonly used for paginating large results. Accepts an integer or an\n     * expression object that evaluates to an integer.\n     *\n     * In some databases, this operation might not be supported or will require\n     * the query to be transformed in order to limit the result set size.\n     *\n     * ### Examples\n     *\n     * ```\n     * $query->offset(10) // generates OFFSET 10\n     * $query->offset($query->newExpr()->add(['1 + 1'])); // OFFSET (1 + 1)\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|int|null $offset number of records to be skipped\n     * @return $this\n     */\n    public function offset($offset)\n    {\n        $this->_dirty();\n        $this->_parts['offset'] = $offset;\n\n        return $this;\n    }\n\n    /**\n     * Adds a complete query to be used in conjunction with an UNION operator with\n     * this query. This is used to combine the result set of this query with the one\n     * that will be returned by the passed query. You can add as many queries as you\n     * required by calling multiple times this method with different queries.\n     *\n     * By default, the UNION operator will remove duplicate rows, if you wish to include\n     * every row for all queries, use unionAll().\n     *\n     * ### Examples\n     *\n     * ```\n     * $union = (new Query($conn))->select(['id', 'title'])->from(['a' => 'articles']);\n     * $query->select(['id', 'name'])->from(['d' => 'things'])->union($union);\n     * ```\n     *\n     * Will produce:\n     *\n     * `SELECT id, name FROM things d UNION SELECT id, title FROM articles a`\n     *\n     * @param \\Cake\\Database\\Query|string $query full SQL query to be used in UNION operator\n     * @param bool $overwrite whether to reset the list of queries to be operated or not\n     * @return $this\n     */\n    public function union($query, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['union'] = [];\n        }\n        $this->_parts['union'][] = [\n            'all' => false,\n            'query' => $query,\n        ];\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a complete query to be used in conjunction with the UNION ALL operator with\n     * this query. This is used to combine the result set of this query with the one\n     * that will be returned by the passed query. You can add as many queries as you\n     * required by calling multiple times this method with different queries.\n     *\n     * Unlike UNION, UNION ALL will not remove duplicate rows.\n     *\n     * ```\n     * $union = (new Query($conn))->select(['id', 'title'])->from(['a' => 'articles']);\n     * $query->select(['id', 'name'])->from(['d' => 'things'])->unionAll($union);\n     * ```\n     *\n     * Will produce:\n     *\n     * `SELECT id, name FROM things d UNION ALL SELECT id, title FROM articles a`\n     *\n     * @param \\Cake\\Database\\Query|string $query full SQL query to be used in UNION operator\n     * @param bool $overwrite whether to reset the list of queries to be operated or not\n     * @return $this\n     */\n    public function unionAll($query, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['union'] = [];\n        }\n        $this->_parts['union'][] = [\n            'all' => true,\n            'query' => $query,\n        ];\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Create an insert query.\n     *\n     * Note calling this method will reset any data previously set\n     * with Query::values().\n     *\n     * @param array $columns The columns to insert into.\n     * @param array<int|string, string> $types A map between columns & their datatypes.\n     * @return $this\n     * @throws \\RuntimeException When there are 0 columns.\n     */\n    public function insert(array $columns, array $types = [])\n    {\n        if (empty($columns)) {\n            throw new RuntimeException('At least 1 column is required to perform an insert.');\n        }\n        $this->_dirty();\n        $this->_type = 'insert';\n        $this->_parts['insert'][1] = $columns;\n        if (!$this->_parts['values']) {\n            $this->_parts['values'] = new ValuesExpression($columns, $this->getTypeMap()->setTypes($types));\n        } else {\n            $this->_parts['values']->setColumns($columns);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Set the table name for insert queries.\n     *\n     * @param string $table The table name to insert into.\n     * @return $this\n     */\n    public function into(string $table)\n    {\n        $this->_dirty();\n        $this->_type = 'insert';\n        $this->_parts['insert'][0] = $table;\n\n        return $this;\n    }\n\n    /**\n     * Creates an expression that refers to an identifier. Identifiers are used to refer to field names and allow\n     * the SQL compiler to apply quotes or escape the identifier.\n     *\n     * The value is used as is, and you might be required to use aliases or include the table reference in\n     * the identifier. Do not use this method to inject SQL methods or logical statements.\n     *\n     * ### Example\n     *\n     * ```\n     * $query->newExpr()->lte('count', $query->identifier('total'));\n     * ```\n     *\n     * @param string $identifier The identifier for an expression\n     * @return \\Cake\\Database\\ExpressionInterface\n     */\n    public function identifier(string $identifier): ExpressionInterface\n    {\n        return new IdentifierExpression($identifier);\n    }\n\n    /**\n     * Set the values for an insert query.\n     *\n     * Multi inserts can be performed by calling values() more than one time,\n     * or by providing an array of value sets. Additionally $data can be a Query\n     * instance to insert data from another SELECT statement.\n     *\n     * @param \\Cake\\Database\\Expression\\ValuesExpression|\\Cake\\Database\\Query|array $data The data to insert.\n     * @return $this\n     * @throws \\Cake\\Database\\Exception\\DatabaseException if you try to set values before declaring columns.\n     *   Or if you try to set values on non-insert queries.\n     */\n    public function values($data)\n    {\n        if ($this->_type !== 'insert') {\n            throw new DatabaseException(\n                'You cannot add values before defining columns to use.'\n            );\n        }\n        if (empty($this->_parts['insert'])) {\n            throw new DatabaseException(\n                'You cannot add values before defining columns to use.'\n            );\n        }\n\n        $this->_dirty();\n        if ($data instanceof ValuesExpression) {\n            $this->_parts['values'] = $data;\n\n            return $this;\n        }\n\n        $this->_parts['values']->add($data);\n\n        return $this;\n    }\n\n    /**\n     * Create an update query.\n     *\n     * Can be combined with set() and where() methods to create update queries.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|string $table The table you want to update.\n     * @return $this\n     */\n    public function update($table)\n    {\n        if (!is_string($table) && !($table instanceof ExpressionInterface)) {\n            $text = 'Table must be of type string or \"%s\", got \"%s\"';\n            $message = sprintf($text, ExpressionInterface::class, gettype($table));\n            throw new InvalidArgumentException($message);\n        }\n\n        $this->_dirty();\n        $this->_type = 'update';\n        $this->_parts['update'][0] = $table;\n\n        return $this;\n    }\n\n    /**\n     * Set one or many fields to update.\n     *\n     * ### Examples\n     *\n     * Passing a string:\n     *\n     * ```\n     * $query->update('articles')->set('title', 'The Title');\n     * ```\n     *\n     * Passing an array:\n     *\n     * ```\n     * $query->update('articles')->set(['title' => 'The Title'], ['title' => 'string']);\n     * ```\n     *\n     * Passing a callable:\n     *\n     * ```\n     * $query->update('articles')->set(function ($exp) {\n     *   return $exp->eq('title', 'The title', 'string');\n     * });\n     * ```\n     *\n     * @param \\Cake\\Database\\Expression\\QueryExpression|\\Closure|array|string $key The column name or array of keys\n     *    + values to set. This can also be a QueryExpression containing a SQL fragment.\n     *    It can also be a Closure, that is required to return an expression object.\n     * @param mixed $value The value to update $key to. Can be null if $key is an\n     *    array or QueryExpression. When $key is an array, this parameter will be\n     *    used as $types instead.\n     * @param array<string, string>|string $types The column types to treat data as.\n     * @return $this\n     */\n    public function set($key, $value = null, $types = [])\n    {\n        if (empty($this->_parts['set'])) {\n            $this->_parts['set'] = $this->newExpr()->setConjunction(',');\n        }\n\n        if ($key instanceof Closure) {\n            $exp = $this->newExpr()->setConjunction(',');\n            $this->_parts['set']->add($key($exp));\n\n            return $this;\n        }\n\n        if (is_array($key) || $key instanceof ExpressionInterface) {\n            $types = (array)$value;\n            $this->_parts['set']->add($key, $types);\n\n            return $this;\n        }\n\n        if (!is_string($types)) {\n            $types = null;\n        }\n        $this->_parts['set']->eq($key, $value, $types);\n\n        return $this;\n    }\n\n    /**\n     * Create a delete query.\n     *\n     * Can be combined with from(), where() and other methods to\n     * create delete queries with specific conditions.\n     *\n     * @param string|null $table The table to use when deleting.\n     * @return $this\n     */\n    public function delete(?string $table = null)\n    {\n        $this->_dirty();\n        $this->_type = 'delete';\n        if ($table !== null) {\n            $this->from($table);\n        }\n\n        return $this;\n    }\n\n    /**\n     * A string or expression that will be appended to the generated query\n     *\n     * ### Examples:\n     * ```\n     * $query->select('id')->where(['author_id' => 1])->epilog('FOR UPDATE');\n     * $query\n     *  ->insert('articles', ['title'])\n     *  ->values(['author_id' => 1])\n     *  ->epilog('RETURNING id');\n     * ```\n     *\n     * Epliog content is raw SQL and not suitable for use with user supplied data.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|string|null $expression The expression to be appended\n     * @return $this\n     */\n    public function epilog($expression = null)\n    {\n        $this->_dirty();\n        $this->_parts['epilog'] = $expression;\n\n        return $this;\n    }\n\n    /**\n     * Returns the type of this query (select, insert, update, delete)\n     *\n     * @return string\n     */\n    public function type(): string\n    {\n        return $this->_type;\n    }\n\n    /**\n     * Returns a new QueryExpression object. This is a handy function when\n     * building complex queries using a fluent interface. You can also override\n     * this function in subclasses to use a more specialized QueryExpression class\n     * if required.\n     *\n     * You can optionally pass a single raw SQL string or an array or expressions in\n     * any format accepted by \\Cake\\Database\\Expression\\QueryExpression:\n     *\n     * ```\n     * $expression = $query->expr(); // Returns an empty expression object\n     * $expression = $query->expr('Table.column = Table2.column'); // Return a raw SQL expression\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string|null $rawExpression A string, array or anything you want wrapped in an expression object\n     * @return \\Cake\\Database\\Expression\\QueryExpression\n     */\n    public function newExpr($rawExpression = null): QueryExpression\n    {\n        return $this->expr($rawExpression);\n    }\n\n    /**\n     * Returns a new QueryExpression object. This is a handy function when\n     * building complex queries using a fluent interface. You can also override\n     * this function in subclasses to use a more specialized QueryExpression class\n     * if required.\n     *\n     * You can optionally pass a single raw SQL string or an array or expressions in\n     * any format accepted by \\Cake\\Database\\Expression\\QueryExpression:\n     *\n     * ```\n     * $expression = $query->expr(); // Returns an empty expression object\n     * $expression = $query->expr('Table.column = Table2.column'); // Return a raw SQL expression\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string|null $rawExpression A string, array or anything you want wrapped in an expression object\n     * @return \\Cake\\Database\\Expression\\QueryExpression\n     */\n    public function expr($rawExpression = null): QueryExpression\n    {\n        $expression = new QueryExpression([], $this->getTypeMap());\n\n        if ($rawExpression !== null) {\n            $expression->add($rawExpression);\n        }\n\n        return $expression;\n    }\n\n    /**\n     * Returns an instance of a functions builder object that can be used for\n     * generating arbitrary SQL functions.\n     *\n     * ### Example:\n     *\n     * ```\n     * $query->func()->count('*');\n     * $query->func()->dateDiff(['2012-01-05', '2012-01-02'])\n     * ```\n     *\n     * @return \\Cake\\Database\\FunctionsBuilder\n     */\n    public function func(): FunctionsBuilder\n    {\n        if ($this->_functionsBuilder === null) {\n            $this->_functionsBuilder = new FunctionsBuilder();\n        }\n\n        return $this->_functionsBuilder;\n    }\n\n    /**\n     * Executes this query and returns a results iterator. This function is required\n     * for implementing the IteratorAggregate interface and allows the query to be\n     * iterated without having to call execute() manually, thus making it look like\n     * a result set instead of the query itself.\n     *\n     * @return \\Cake\\Database\\StatementInterface\n     * @psalm-suppress ImplementedReturnTypeMismatch\n     */\n    #[\\ReturnTypeWillChange]\n    public function getIterator()\n    {\n        if ($this->_iterator === null || $this->_dirty) {\n            $this->_iterator = $this->execute();\n        }\n\n        return $this->_iterator;\n    }\n\n    /**\n     * Returns any data that was stored in the specified clause. This is useful for\n     * modifying any internal part of the query and it is used by the SQL dialects\n     * to transform the query accordingly before it is executed. The valid clauses that\n     * can be retrieved are: delete, update, set, insert, values, select, distinct,\n     * from, join, set, where, group, having, order, limit, offset and union.\n     *\n     * The return value for each of those parts may vary. Some clauses use QueryExpression\n     * to internally store their state, some use arrays and others may use booleans or\n     * integers. This is summary of the return types for each clause.\n     *\n     * - update: string The name of the table to update\n     * - set: QueryExpression\n     * - insert: array, will return an array containing the table + columns.\n     * - values: ValuesExpression\n     * - select: array, will return empty array when no fields are set\n     * - distinct: boolean\n     * - from: array of tables\n     * - join: array\n     * - set: array\n     * - where: QueryExpression, returns null when not set\n     * - group: array\n     * - having: QueryExpression, returns null when not set\n     * - order: OrderByExpression, returns null when not set\n     * - limit: integer or QueryExpression, null when not set\n     * - offset: integer or QueryExpression, null when not set\n     * - union: array\n     *\n     * @param string $name name of the clause to be returned\n     * @return mixed\n     * @throws \\InvalidArgumentException When the named clause does not exist.\n     */\n    public function clause(string $name)\n    {\n        if (!array_key_exists($name, $this->_parts)) {\n            $clauses = implode(', ', array_keys($this->_parts));\n            throw new InvalidArgumentException(\"The '$name' clause is not defined. Valid clauses are: $clauses\");\n        }\n\n        return $this->_parts[$name];\n    }\n\n    /**\n     * Registers a callback to be executed for each result that is fetched from the\n     * result set, the callback function will receive as first parameter an array with\n     * the raw data from the database for every row that is fetched and must return the\n     * row with any possible modifications.\n     *\n     * Callbacks will be executed lazily, if only 3 rows are fetched for database it will\n     * called 3 times, event though there might be more rows to be fetched in the cursor.\n     *\n     * Callbacks are stacked in the order they are registered, if you wish to reset the stack\n     * the call this function with the second parameter set to true.\n     *\n     * If you wish to remove all decorators from the stack, set the first parameter\n     * to null and the second to true.\n     *\n     * ### Example\n     *\n     * ```\n     * $query->decorateResults(function ($row) {\n     *   $row['order_total'] = $row['subtotal'] + ($row['subtotal'] * $row['tax']);\n     *    return $row;\n     * });\n     * ```\n     *\n     * @param callable|null $callback The callback to invoke when results are fetched.\n     * @param bool $overwrite Whether this should append or replace all existing decorators.\n     * @return $this\n     */\n    public function decorateResults(?callable $callback, bool $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_resultDecorators = [];\n        }\n\n        if ($callback !== null) {\n            $this->_resultDecorators[] = $callback;\n        }\n\n        return $this;\n    }\n\n    /**\n     * This function works similar to the traverse() function, with the difference\n     * that it does a full depth traversal of the entire expression tree. This will execute\n     * the provided callback function for each ExpressionInterface object that is\n     * stored inside this query at any nesting depth in any part of the query.\n     *\n     * Callback will receive as first parameter the currently visited expression.\n     *\n     * @param callable $callback the function to be executed for each ExpressionInterface\n     *   found inside this query.\n     * @return $this\n     */\n    public function traverseExpressions(callable $callback)\n    {\n        if (!$callback instanceof Closure) {\n            $callback = Closure::fromCallable($callback);\n        }\n\n        foreach ($this->_parts as $part) {\n            $this->_expressionsVisitor($part, $callback);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Query parts traversal method used by traverseExpressions()\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array<\\Cake\\Database\\ExpressionInterface> $expression Query expression or\n     *   array of expressions.\n     * @param \\Closure $callback The callback to be executed for each ExpressionInterface\n     *   found inside this query.\n     * @return void\n     */\n    protected function _expressionsVisitor($expression, Closure $callback): void\n    {\n        if (is_array($expression)) {\n            foreach ($expression as $e) {\n                $this->_expressionsVisitor($e, $callback);\n            }\n\n            return;\n        }\n\n        if ($expression instanceof ExpressionInterface) {\n            $expression->traverse(function ($exp) use ($callback) {\n                $this->_expressionsVisitor($exp, $callback);\n            });\n\n            if (!$expression instanceof self) {\n                $callback($expression);\n            }\n        }\n    }\n\n    /**\n     * Associates a query placeholder to a value and a type.\n     *\n     * ```\n     * $query->bind(':id', 1, 'integer');\n     * ```\n     *\n     * @param string|int $param placeholder to be replaced with quoted version\n     *   of $value\n     * @param mixed $value The value to be bound\n     * @param string|int|null $type the mapped type name, used for casting when sending\n     *   to database\n     * @return $this\n     */\n    public function bind($param, $value, $type = null)\n    {\n        $this->getValueBinder()->bind($param, $value, $type);\n\n        return $this;\n    }\n\n    /**\n     * Returns the currently used ValueBinder instance.\n     *\n     * A ValueBinder is responsible for generating query placeholders and temporarily\n     * associate values to those placeholders so that they can be passed correctly\n     * to the statement object.\n     *\n     * @return \\Cake\\Database\\ValueBinder\n     */\n    public function getValueBinder(): ValueBinder\n    {\n        if ($this->_valueBinder === null) {\n            $this->_valueBinder = new ValueBinder();\n        }\n\n        return $this->_valueBinder;\n    }\n\n    /**\n     * Overwrite the current value binder\n     *\n     * A ValueBinder is responsible for generating query placeholders and temporarily\n     * associate values to those placeholders so that they can be passed correctly\n     * to the statement object.\n     *\n     * @param \\Cake\\Database\\ValueBinder|null $binder The binder or null to disable binding.\n     * @return $this\n     */\n    public function setValueBinder(?ValueBinder $binder)\n    {\n        $this->_valueBinder = $binder;\n\n        return $this;\n    }\n\n    /**\n     * Enables/Disables buffered results.\n     *\n     * When enabled the results returned by this Query will be\n     * buffered. This enables you to iterate a result set multiple times, or\n     * both cache and iterate it.\n     *\n     * When disabled it will consume less memory as fetched results are not\n     * remembered for future iterations.\n     *\n     * @param bool $enable Whether to enable buffering\n     * @return $this\n     */\n    public function enableBufferedResults(bool $enable = true)\n    {\n        $this->_dirty();\n        $this->_useBufferedResults = $enable;\n\n        return $this;\n    }\n\n    /**\n     * Disables buffered results.\n     *\n     * Disabling buffering will consume less memory as fetched results are not\n     * remembered for future iterations.\n     *\n     * @return $this\n     */\n    public function disableBufferedResults()\n    {\n        $this->_dirty();\n        $this->_useBufferedResults = false;\n\n        return $this;\n    }\n\n    /**\n     * Returns whether buffered results are enabled/disabled.\n     *\n     * When enabled the results returned by this Query will be\n     * buffered. This enables you to iterate a result set multiple times, or\n     * both cache and iterate it.\n     *\n     * When disabled it will consume less memory as fetched results are not\n     * remembered for future iterations.\n     *\n     * @return bool\n     */\n    public function isBufferedResultsEnabled(): bool\n    {\n        return $this->_useBufferedResults;\n    }\n\n    /**\n     * Sets the TypeMap class where the types for each of the fields in the\n     * select clause are stored.\n     *\n     * @param \\Cake\\Database\\TypeMap $typeMap The map object to use\n     * @return $this\n     */\n    public function setSelectTypeMap(TypeMap $typeMap)\n    {\n        $this->_selectTypeMap = $typeMap;\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Gets the TypeMap class where the types for each of the fields in the\n     * select clause are stored.\n     *\n     * @return \\Cake\\Database\\TypeMap\n     */\n    public function getSelectTypeMap(): TypeMap\n    {\n        if ($this->_selectTypeMap === null) {\n            $this->_selectTypeMap = new TypeMap();\n        }\n\n        return $this->_selectTypeMap;\n    }\n\n    /**\n     * Disables result casting.\n     *\n     * When disabled, the fields will be returned as received from the database\n     * driver (which in most environments means they are being returned as\n     * strings), which can improve performance with larger datasets.\n     *\n     * @return $this\n     */\n    public function disableResultsCasting()\n    {\n        $this->typeCastEnabled = false;\n\n        return $this;\n    }\n\n    /**\n     * Enables result casting.\n     *\n     * When enabled, the fields in the results returned by this Query will be\n     * cast to their corresponding PHP data type.\n     *\n     * @return $this\n     */\n    public function enableResultsCasting()\n    {\n        $this->typeCastEnabled = true;\n\n        return $this;\n    }\n\n    /**\n     * Returns whether result casting is enabled/disabled.\n     *\n     * When enabled, the fields in the results returned by this Query will be\n     * casted to their corresponding PHP data type.\n     *\n     * When disabled, the fields will be returned as received from the database\n     * driver (which in most environments means they are being returned as\n     * strings), which can improve performance with larger datasets.\n     *\n     * @return bool\n     */\n    public function isResultsCastingEnabled(): bool\n    {\n        return $this->typeCastEnabled;\n    }\n\n    /**\n     * Auxiliary function used to wrap the original statement from the driver with\n     * any registered callbacks.\n     *\n     * @param \\Cake\\Database\\StatementInterface $statement to be decorated\n     * @return \\Cake\\Database\\Statement\\CallbackStatement|\\Cake\\Database\\StatementInterface\n     */\n    protected function _decorateStatement(StatementInterface $statement)\n    {\n        $typeMap = $this->getSelectTypeMap();\n        $driver = $this->getConnection()->getDriver();\n\n        if ($this->typeCastEnabled && $typeMap->toArray()) {\n            $statement = new CallbackStatement($statement, $driver, new FieldTypeConverter($typeMap, $driver));\n        }\n\n        foreach ($this->_resultDecorators as $f) {\n            $statement = new CallbackStatement($statement, $driver, $f);\n        }\n\n        return $statement;\n    }\n\n    /**\n     * Helper function used to build conditions by composing QueryExpression objects.\n     *\n     * @param string $part Name of the query part to append the new part to\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string|null $append Expression or builder function to append.\n     *   to append.\n     * @param string $conjunction type of conjunction to be used to operate part\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @return void\n     */\n    protected function _conjugate(string $part, $append, $conjunction, array $types): void\n    {\n        $expression = $this->_parts[$part] ?: $this->newExpr();\n        if (empty($append)) {\n            $this->_parts[$part] = $expression;\n\n            return;\n        }\n\n        if ($append instanceof Closure) {\n            $append = $append($this->newExpr(), $this);\n        }\n\n        if ($expression->getConjunction() === $conjunction) {\n            $expression->add($append, $types);\n        } else {\n            $expression = $this->newExpr()\n                ->setConjunction($conjunction)\n                ->add([$expression, $append], $types);\n        }\n\n        $this->_parts[$part] = $expression;\n        $this->_dirty();\n    }\n\n    /**\n     * Marks a query as dirty, removing any preprocessed information\n     * from in memory caching.\n     *\n     * @return void\n     */\n    protected function _dirty(): void\n    {\n        $this->_dirty = true;\n\n        if ($this->_iterator && $this->_valueBinder) {\n            $this->getValueBinder()->reset();\n        }\n    }\n\n    /**\n     * Handles clearing iterator and cloning all expressions and value binders.\n     *\n     * @return void\n     */\n    public function __clone()\n    {\n        $this->_iterator = null;\n        if ($this->_valueBinder !== null) {\n            $this->_valueBinder = clone $this->_valueBinder;\n        }\n        if ($this->_selectTypeMap !== null) {\n            $this->_selectTypeMap = clone $this->_selectTypeMap;\n        }\n        foreach ($this->_parts as $name => $part) {\n            if (empty($part)) {\n                continue;\n            }\n            if (is_array($part)) {\n                foreach ($part as $i => $piece) {\n                    if (is_array($piece)) {\n                        foreach ($piece as $j => $value) {\n                            if ($value instanceof ExpressionInterface) {\n                                /** @psalm-suppress PossiblyUndefinedMethod */\n                                $this->_parts[$name][$i][$j] = clone $value;\n                            }\n                        }\n                    } elseif ($piece instanceof ExpressionInterface) {\n                        /** @psalm-suppress PossiblyUndefinedMethod */\n                        $this->_parts[$name][$i] = clone $piece;\n                    }\n                }\n            }\n            if ($part instanceof ExpressionInterface) {\n                $this->_parts[$name] = clone $part;\n            }\n        }\n    }\n\n    /**\n     * Returns string representation of this query (complete SQL statement).\n     *\n     * @return string\n     */\n    public function __toString(): string\n    {\n        return $this->sql();\n    }\n\n    /**\n     * Returns an array that can be used to describe the internal state of this\n     * object.\n     *\n     * @return array<string, mixed>\n     */\n    public function __debugInfo(): array\n    {\n        try {\n            set_error_handler(\n                /** @return no-return */\n                function ($errno, $errstr) {\n                    throw new RuntimeException($errstr, $errno);\n                },\n                E_ALL\n            );\n            $sql = $this->sql();\n            $params = $this->getValueBinder()->bindings();\n        } catch (RuntimeException $e) {\n            $sql = 'SQL could not be generated for this query as it is incomplete.';\n            $params = [];\n        } finally {\n            restore_error_handler();\n        }\n\n        return [\n            '(help)' => 'This is a Query object, to get the results execute or iterate it.',\n            'sql' => $sql,\n            'params' => $params,\n            'defaultTypes' => $this->getDefaultTypes(),\n            'decorators' => count($this->_resultDecorators),\n            'executed' => $this->_iterator ? true : false,\n        ];\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)\n * @link          https://cakephp.org CakePHP(tm) Project\n * @since         3.0.0\n * @license       https://opensource.org/licenses/mit-license.php MIT License\n */\nnamespace Cake\\Test\\TestCase\\Database;\n\nuse Cake\\Database\\Driver\\Mysql;\nuse Cake\\Database\\Driver\\Postgres;\nuse Cake\\Database\\Driver\\Sqlite;\nuse Cake\\Database\\Driver\\Sqlserver;\nuse Cake\\Database\\Exception\\DatabaseException;\nuse Cake\\Database\\Expression\\CommonTableExpression;\nuse Cake\\Database\\Expression\\IdentifierExpression;\nuse Cake\\Database\\Expression\\QueryExpression;\nuse Cake\\Database\\Expression\\StringExpression;\nuse Cake\\Database\\Expression\\TupleComparison;\nuse Cake\\Database\\Expression\\WindowExpression;\nuse Cake\\Database\\ExpressionInterface;\nuse Cake\\Database\\Query;\nuse Cake\\Database\\Statement\\StatementDecorator;\nuse Cake\\Database\\StatementInterface;\nuse Cake\\Database\\TypeFactory;\nuse Cake\\Database\\TypeMap;\nuse Cake\\Database\\ValueBinder;\nuse Cake\\Datasource\\ConnectionManager;\nuse Cake\\TestSuite\\TestCase;\nuse DateTime;\nuse DateTimeImmutable;\nuse InvalidArgumentException;\nuse ReflectionProperty;\nuse RuntimeException;\nuse stdClass;\nuse TestApp\\Database\\Type\\BarType;\n\n/**\n * Tests Query class\n */\nclass QueryTest extends TestCase\n{\n    protected $fixtures = [\n        'core.Articles',\n        'core.Authors',\n        'core.Comments',\n        'core.Profiles',\n        'core.MenuLinkTrees',\n    ];\n\n    /**\n     * @var int\n     */\n    public const ARTICLE_COUNT = 3;\n    /**\n     * @var int\n     */\n    public const AUTHOR_COUNT = 4;\n    /**\n     * @var int\n     */\n    public const COMMENT_COUNT = 6;\n\n    /**\n     * @var \\Cake\\Database\\Connection\n     */\n    protected $connection;\n\n    /**\n     * @var bool\n     */\n    protected $autoQuote;\n\n    public function setUp(): void\n    {\n        parent::setUp();\n        $this->connection = ConnectionManager::get('test');\n        $this->autoQuote = $this->connection->getDriver()->isAutoQuotingEnabled();\n    }\n\n    public function tearDown(): void\n    {\n        parent::tearDown();\n        $this->connection->getDriver()->enableAutoQuoting($this->autoQuote);\n        unset($this->connection);\n    }\n\n    /**\n     * Queries need a default type to prevent fatal errors\n     * when an uninitialized query has its sql() method called.\n     */\n    public function testDefaultType(): void\n    {\n        $query = new Query($this->connection);\n        $this->assertSame('', $query->sql());\n        $this->assertSame('select', $query->type());\n    }\n\n    /**\n     * Tests that it is possible to obtain expression results from a query\n     */\n    public function testSelectFieldsOnly(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(false);\n        $query = new Query($this->connection);\n        $result = $query->select('1 + 1')->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertEquals([2], $result->fetch());\n        $result->closeCursor();\n\n        //This new field should be appended\n        $result = $query->select(['1 + 3'])->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertEquals([2, 4], $result->fetch());\n        $result->closeCursor();\n\n        //This should now overwrite all previous fields\n        $result = $query->select(['1 + 2', '1 + 5'], true)->execute();\n        $this->assertEquals([3, 6], $result->fetch());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to pass a closure as fields in select()\n     */\n    public function testSelectClosure(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(false);\n        $query = new Query($this->connection);\n        $result = $query->select(function ($q) use ($query) {\n            $this->assertSame($query, $q);\n\n            return ['1 + 2', '1 + 5'];\n        })->execute();\n        $this->assertEquals([3, 6], $result->fetch());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to select fields from tables with no conditions\n     */\n    public function testSelectFieldsFromTable(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(['body', 'author_id'])->from('articles')->execute();\n        $this->assertEquals(['body' => 'First Article Body', 'author_id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['body' => 'Second Article Body', 'author_id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        //Append more tables to next execution\n        $result = $query->select('name')->from(['authors'])->order(['name' => 'desc', 'articles.id' => 'asc'])->execute();\n        $this->assertEquals(['body' => 'First Article Body', 'author_id' => 1, 'name' => 'nate'], $result->fetch('assoc'));\n        $this->assertEquals(['body' => 'Second Article Body', 'author_id' => 3, 'name' => 'nate'], $result->fetch('assoc'));\n        $this->assertEquals(['body' => 'Third Article Body', 'author_id' => 1, 'name' => 'nate'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        // Overwrite tables and only fetch from authors\n        $result = $query->select('name', true)->from('authors', true)->order(['name' => 'desc'], true)->execute();\n        $this->assertSame(['nate'], $result->fetch());\n        $this->assertSame(['mariano'], $result->fetch());\n        $this->assertCount(4, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to select aliased fields\n     */\n    public function testSelectAliasedFieldsFromTable(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(['text' => 'comment', 'article_id'])->from('comments')->execute();\n        $this->assertEquals(['text' => 'First Comment for First Article', 'article_id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['text' => 'Second Comment for First Article', 'article_id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query->select(['text' => 'comment', 'article' => 'article_id'])->from('comments')->execute();\n        $this->assertEquals(['text' => 'First Comment for First Article', 'article' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['text' => 'Second Comment for First Article', 'article' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $query->select(['text' => 'comment'])->select(['article_id', 'foo' => 'comment']);\n        $result = $query->from('comments')->execute();\n        $this->assertEquals(\n            ['foo' => 'First Comment for First Article', 'text' => 'First Comment for First Article', 'article_id' => 1],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $exp = $query->newExpr('1 + 1');\n        $comp = $query->newExpr(['article_id +' => 2]);\n        $result = $query->select(['text' => 'comment', 'two' => $exp, 'three' => $comp])\n            ->from('comments')->execute();\n        $this->assertEquals(['text' => 'First Comment for First Article', 'two' => 2, 'three' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that tables can also be aliased and referenced in the select clause using such alias\n     */\n    public function testSelectAliasedTables(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(['text' => 'a.body', 'a.author_id'])\n            ->from(['a' => 'articles'])->execute();\n\n        $this->assertEquals(['text' => 'First Article Body', 'author_id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['text' => 'Second Article Body', 'author_id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->select(['name' => 'b.name'])->from(['b' => 'authors'])\n            ->order(['text' => 'desc', 'name' => 'desc'])\n            ->execute();\n        $this->assertEquals(\n            ['text' => 'Third Article Body', 'author_id' => 1, 'name' => 'nate'],\n            $result->fetch('assoc')\n        );\n        $this->assertEquals(\n            ['text' => 'Third Article Body', 'author_id' => 1, 'name' => 'mariano'],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to add joins to a select query\n     */\n    public function testSelectWithJoins(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->order(['title' => 'asc'])\n            ->execute();\n\n        $this->assertCount(3, $result);\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->join('authors', [], true)->execute();\n        $this->assertCount(12, $result, 'Cross join results in 12 records');\n        $result->closeCursor();\n\n        $result = $query->join([\n            ['table' => 'authors', 'type' => 'INNER', 'conditions' => $query->newExpr()->equalFields('author_id', 'authors.id')],\n        ], [], true)->execute();\n        $this->assertCount(3, $result);\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to add joins to a select query using array or expression as conditions\n     */\n    public function testSelectWithJoinsConditions(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => [$query->newExpr()->equalFields('author_id ', 'a.id')]])\n            ->order(['title' => 'asc'])\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $conditions = $query->newExpr()->equalFields('author_id', 'a.id');\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $conditions])\n            ->order(['title' => 'asc'])\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'comment' => 'c.comment'])\n            ->from('articles')\n            ->join(['table' => 'comments', 'alias' => 'c', 'conditions' => ['created' => $time]], $types)\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'comment' => 'First Comment for First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that joins can be aliased using array keys\n     */\n    public function testSelectAliasedJoins(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['a' => 'authors'])\n            ->order(['name' => 'desc', 'articles.id' => 'asc'])\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'nate'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'nate'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $conditions = $query->newExpr('author_id = a.id');\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['a' => ['table' => 'authors', 'conditions' => $conditions]])\n            ->order(['title' => 'asc'])\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->join(['c' => ['table' => 'comments', 'conditions' => ['created' => $time]]], $types)\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'First Comment for First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests the leftJoin method\n     */\n    public function testSelectLeftJoin(): void\n    {\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->leftJoin(['c' => 'comments'], ['created <' => $time], $types)\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => null], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->leftJoin(['c' => 'comments'], ['created >' => $time], $types)\n            ->order(['created' => 'asc'])\n            ->execute();\n        $this->assertEquals(\n            ['title' => 'First Article', 'name' => 'Second Comment for First Article'],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests the innerJoin method\n     */\n    public function testSelectInnerJoin(): void\n    {\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $statement = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->innerJoin(['c' => 'comments'], ['created <' => $time], $types)\n            ->execute();\n        $this->assertCount(0, $statement->fetchAll());\n        $statement->closeCursor();\n    }\n\n    /**\n     * Tests the rightJoin method\n     */\n    public function testSelectRightJoin(): void\n    {\n        $this->skipIf(\n            $this->connection->getDriver() instanceof Sqlite,\n            'SQLite does not support RIGHT joins'\n        );\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->rightJoin(['c' => 'comments'], ['created <' => $time], $types)\n            ->execute();\n        $this->assertCount(6, $result);\n        $this->assertEquals(\n            ['title' => null, 'name' => 'First Comment for First Article'],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to pass a callable as conditions for a join\n     */\n    public function testSelectJoinWithCallback(): void\n    {\n        $query = new Query($this->connection);\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->innerJoin(['c' => 'comments'], function ($exp, $q) use ($query, $types) {\n                $this->assertSame($q, $query);\n                $exp->add(['created <' => new DateTime('2007-03-18 10:45:23')], $types);\n\n                return $exp;\n            })\n            ->execute();\n        $this->assertCount(0, $result->fetchAll());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to pass a callable as conditions for a join\n     */\n    public function testSelectJoinWithCallback2(): void\n    {\n        $query = new Query($this->connection);\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['name', 'commentary' => 'comments.comment'])\n            ->from('authors')\n            ->innerJoin('comments', function ($exp, $q) use ($query, $types) {\n                $this->assertSame($q, $query);\n                $exp->add(['created' => new DateTime('2007-03-18 10:47:23')], $types);\n\n                return $exp;\n            })\n            ->execute();\n        $this->assertEquals(\n            ['name' => 'mariano', 'commentary' => 'Second Comment for First Article'],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to filter a query by using simple AND joined conditions\n     */\n    public function testSelectSimpleWhere(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id' => 1, 'title' => 'First Article'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id' => 100], ['id' => 'integer'])\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorMoreThan(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['comment'])\n            ->from('comments')\n            ->where(['id >' => 4])\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['comment' => 'First Comment for Second Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorLessThan(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id <' => 2])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorLessThanEqual(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id <=' => 2])\n            ->execute();\n        $this->assertCount(2, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorMoreThanEqual(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id >=' => 1])\n            ->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorNotEqual(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id !=' => 2])\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorLike(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['title LIKE' => 'First Article'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorLikeExpansion(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['title like' => '%Article%'])\n            ->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorNotLike(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['title not like' => '%Article%'])\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test that unary expressions in selects are built correctly.\n     */\n    public function testSelectWhereUnary(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('articles')\n            ->where([\n                'title is not' => null,\n                'user_id is' => null,\n            ])\n            ->sql();\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\(\\(<title>\\) IS NOT NULL AND \\(<user_id>\\) IS NULL\\)',\n            $result,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests selecting with conditions and specifying types for those\n     */\n    public function testSelectWhereTypes(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created >' => new DateTime('2007-03-18 10:46:00')], ['created' => 'datetime'])\n            ->execute();\n        $this->assertCount(5, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(\n                [\n                    'created >' => new DateTime('2007-03-18 10:40:00'),\n                    'created <' => new DateTime('2007-03-18 10:46:00'),\n                ],\n                ['created' => 'datetime']\n            )\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(\n                [\n                    'id' => '3',\n                    'created <' => new DateTime('2013-01-01 12:00'),\n                ],\n                ['created' => 'datetime', 'id' => 'integer']\n            )\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(\n                [\n                    'id' => '1',\n                    'created <' => new DateTime('2013-01-01 12:00'),\n                ],\n                ['created' => 'datetime', 'id' => 'integer']\n            )\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests Query::whereNull()\n     */\n    public function testSelectWhereNull(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id', 'parent_id'])\n            ->from('menu_link_trees')\n            ->whereNull(['parent_id'])\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('menu_link_trees')\n            ->whereNull($this->connection->newQuery()->select('parent_id'))\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('menu_link_trees')\n            ->whereNull('parent_id')\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests Query::whereNotNull()\n     */\n    public function testSelectWhereNotNull(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id', 'parent_id'])\n            ->from('menu_link_trees')\n            ->whereNotNull(['parent_id'])\n            ->execute();\n        $this->assertCount(13, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('menu_link_trees')\n            ->whereNotNull($this->connection->newQuery()->select('parent_id'))\n            ->execute();\n        $this->assertCount(13, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('menu_link_trees')\n            ->whereNotNull('parent_id')\n            ->execute();\n        $this->assertCount(13, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that passing an array type to any where condition will replace\n     * the passed array accordingly as a proper IN condition\n     */\n    public function testSelectWhereArrayType(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['id' => ['1', '3']], ['id' => 'integer[]'])\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that passing an empty array type to any where condition will not\n     * result in a SQL error, but an internal exception\n     */\n    public function testSelectWhereArrayTypeEmpty(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $this->expectExceptionMessage('Impossible to generate condition with empty list of values for field');\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['id' => []], ['id' => 'integer[]'])\n            ->execute();\n    }\n\n    /**\n     * Tests exception message for impossible condition when using an expression\n     */\n    public function testSelectWhereArrayTypeEmptyWithExpression(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $this->expectExceptionMessage('with empty list of values for field (SELECT 1)');\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                return $exp->in($q->newExpr('SELECT 1'), []);\n            })\n            ->execute();\n    }\n\n    /**\n     * Tests that Query::andWhere() can be used to concatenate conditions with AND\n     */\n    public function testSelectAndWhere(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime'])\n            ->andWhere(['id' => 1])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created' => new DateTime('2007-03-18 10:50:55')], ['created' => 'datetime'])\n            ->andWhere(['id' => 2])\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that Query::andWhere() can be used without calling where() before\n     */\n    public function testSelectAndWhereNoPreviousCondition(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->andWhere(['created' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime'])\n            ->andWhere(['id' => 1])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to pass a closure to where() to build a set of\n     * conditions and return the expression to be used\n     */\n    public function testSelectWhereUsingClosure(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->eq('id', 1);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp\n                    ->eq('id', 1)\n                    ->eq('created', new DateTime('2007-03-18 10:45:23'), 'datetime');\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp\n                    ->eq('id', 1)\n                    ->eq('created', new DateTime('2021-12-30 15:00'), 'datetime');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests generating tuples in the values side containing closure expressions\n     */\n    public function testTupleWithClosureExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('comments')\n            ->where([\n                'OR' => [\n                    'id' => 1,\n                    function ($exp) {\n                        return $exp->eq('id', 2);\n                    },\n                ],\n            ]);\n\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <comments> WHERE \\(<id> = :c0 OR <id> = :c1\\)',\n            $result,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that it is possible to pass a closure to andWhere() to build a set of\n     * conditions and return the expression to be used\n     */\n    public function testSelectAndWhereUsingClosure(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['id' => '1'])\n            ->andWhere(function ($exp) {\n                return $exp->eq('created', new DateTime('2007-03-18 10:45:23'), 'datetime');\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['id' => '1'])\n            ->andWhere(function ($exp) {\n                return $exp->eq('created', new DateTime('2022-12-21 12:00'), 'datetime');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that expression objects can be used as the field in a comparison\n     * and the values will be bound correctly to the query\n     */\n    public function testSelectWhereUsingExpressionInField(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $field = clone $exp;\n                $field->add('SELECT min(id) FROM comments');\n\n                return $exp\n                    ->eq($field, 100, 'integer');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operator methods\n     */\n    public function testSelectWhereOperatorMethods(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->gt('id', 1);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['title' => 'Second Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->lt('id', 2);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->lte('id', 2);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->gte('id', 1);\n            })\n            ->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->lte('id', 1);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->notEq('id', 2);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->like('title', 'First Article');\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->like('title', '%Article%');\n            })\n            ->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->notLike('title', '%Article%');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->isNull('published');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->isNotNull('published');\n            })\n            ->execute();\n        $this->assertCount(6, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->in('published', ['Y', 'N']);\n            })\n            ->execute();\n        $this->assertCount(6, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->in(\n                    'created',\n                    [new DateTime('2007-03-18 10:45:23'), new DateTime('2007-03-18 10:47:23')],\n                    'datetime'\n                );\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->notIn(\n                    'created',\n                    [new DateTime('2007-03-18 10:45:23'), new DateTime('2007-03-18 10:47:23')],\n                    'datetime'\n                );\n            })\n            ->execute();\n        $this->assertCount(4, $result);\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that calling \"in\" and \"notIn\" will cast the passed values to an array\n     */\n    public function testInValueCast(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->in('created', '2007-03-18 10:45:23', 'datetime');\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->notIn('created', '2007-03-18 10:45:23', 'datetime');\n            })\n            ->execute();\n        $this->assertCount(5, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                return $exp->in(\n                    'created',\n                    $q->newExpr(\"'2007-03-18 10:45:23'\"),\n                    'datetime'\n                );\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                return $exp->notIn(\n                    'created',\n                    $q->newExpr(\"'2007-03-18 10:45:23'\"),\n                    'datetime'\n                );\n            })\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that calling \"in\" and \"notIn\" will cast the passed values to an array\n     */\n    public function testInValueCast2(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created IN' => '2007-03-18 10:45:23'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created NOT IN' => '2007-03-18 10:45:23'])\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that IN clauses generate correct placeholders\n     */\n    public function testInClausePlaceholderGeneration(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('comments')\n            ->where(['id IN' => [1, 2]])\n            ->sql();\n        $bindings = $query->getValueBinder()->bindings();\n        $this->assertArrayHasKey(':c0', $bindings);\n        $this->assertSame('c0', $bindings[':c0']['placeholder']);\n        $this->assertArrayHasKey(':c1', $bindings);\n        $this->assertSame('c1', $bindings[':c1']['placeholder']);\n    }\n\n    /**\n     * Tests where() with callable types.\n     */\n    public function testWhereCallables(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->where([\n                'id' => 'Cake\\Error\\Debugger::dump',\n                'title' => ['Cake\\Error\\Debugger', 'dump'],\n                'author_id' => function ($exp) {\n                    return 1;\n                },\n            ]);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\(<id> = :c0 AND <title> = :c1 AND <author_id> = :c2\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that empty values don't set where clauses.\n     */\n    public function testWhereEmptyValues(): void\n    {\n        $query = new Query($this->connection);\n        $query->from('comments')\n            ->where('');\n\n        $this->assertCount(0, $query->clause('where'));\n\n        $query->where([]);\n        $this->assertCount(0, $query->clause('where'));\n    }\n\n    /**\n     * Tests that it is possible to use a between expression\n     * in a where condition\n     */\n    public function testWhereWithBetween(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->between('id', 5, 6, 'integer');\n            })\n            ->execute();\n\n        $this->assertCount(2, $result);\n        $first = $result->fetch('assoc');\n        $this->assertEquals(5, $first['id']);\n\n        $second = $result->fetch('assoc');\n        $this->assertEquals(6, $second['id']);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to use a between expression\n     * in a where condition with a complex data type\n     */\n    public function testWhereWithBetweenComplex(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $from = new DateTime('2007-03-18 10:51:00');\n                $to = new DateTime('2007-03-18 10:54:00');\n\n                return $exp->between('created', $from, $to, 'datetime');\n            })\n            ->execute();\n\n        $this->assertCount(2, $result);\n        $first = $result->fetch('assoc');\n        $this->assertEquals(4, $first['id']);\n\n        $second = $result->fetch('assoc');\n        $this->assertEquals(5, $second['id']);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to use an expression object\n     * as the field for a between expression\n     */\n    public function testWhereWithBetweenWithExpressionField(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                $field = $q->func()->coalesce([new IdentifierExpression('id'), 1 => 'literal']);\n\n                return $exp->between($field, 5, 6, 'integer');\n            })\n            ->execute();\n\n        $this->assertCount(2, $result);\n        $first = $result->fetch('assoc');\n        $this->assertEquals(5, $first['id']);\n\n        $second = $result->fetch('assoc');\n        $this->assertEquals(6, $second['id']);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to use an expression object\n     * as any of the parts of the between expression\n     */\n    public function testWhereWithBetweenWithExpressionParts(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                $from = $q->newExpr(\"'2007-03-18 10:51:00'\");\n                $to = $q->newExpr(\"'2007-03-18 10:54:00'\");\n\n                return $exp->between('created', $from, $to);\n            })\n            ->execute();\n\n        $this->assertCount(2, $result);\n        $first = $result->fetch('assoc');\n        $this->assertEquals(4, $first['id']);\n\n        $second = $result->fetch('assoc');\n        $this->assertEquals(5, $second['id']);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests nesting query expressions both using arrays and closures\n     */\n    public function testSelectExpressionComposition(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $and = $exp->and(['id' => 2, 'id >' => 1]);\n\n                return $exp->add($and);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $and = $exp->and(['id' => 2, 'id <' => 2]);\n\n                return $exp->add($and);\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $and = $exp->and(function ($and) {\n                    return $and->eq('id', 1)->gt('id', 0);\n                });\n\n                return $exp->add($and);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $or = $exp->or(['id' => 1]);\n                $and = $exp->and(['id >' => 2, 'id <' => 4]);\n\n                return $or->add($and);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $or = $exp->or(function ($or) {\n                    return $or->eq('id', 1)->eq('id', 2);\n                });\n\n                return $or;\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that conditions can be nested with an unary operator using the array notation\n     * and the not() method\n     */\n    public function testSelectWhereNot(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->not(\n                    $exp->and(['id' => 2, 'created' => new DateTime('2007-03-18 10:47:23')], ['created' => 'datetime'])\n                );\n            })\n            ->execute();\n        $this->assertCount(5, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->not(\n                    $exp->and(['id' => 2, 'created' => new DateTime('2012-12-21 12:00')], ['created' => 'datetime'])\n                );\n            })\n            ->execute();\n        $this->assertCount(6, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that conditions can be nested with an unary operator using the array notation\n     * and the not() method\n     */\n    public function testSelectWhereNot2(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('articles')\n            ->where([\n                'not' => ['or' => ['id' => 1, 'id >' => 2], 'id' => 3],\n            ])\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests whereInArray() and its input types.\n     */\n    public function testWhereInArray(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereInList('id', [2, 3])\n            ->order(['id']);\n\n        $sql = $query->sql();\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE <id> in \\\\(:c0,:c1\\\\)',\n            $sql,\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '2'], $result[0]);\n    }\n\n    /**\n     * Tests whereInArray() and empty array input.\n     */\n    public function testWhereInArrayEmpty(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereInList('id', [], ['allowEmpty' => true]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE 1=0',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $statement = $query->execute();\n        $this->assertFalse($statement->fetch('assoc'));\n        $statement->closeCursor();\n    }\n\n    /**\n     * Tests whereNotInList() and its input types.\n     */\n    public function testWhereNotInList(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereNotInList('id', [1, 3]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE <id> not in \\\\(:c0,:c1\\\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '2'], $result[0]);\n    }\n\n    /**\n     * Tests whereNotInList() and empty array input.\n     */\n    public function testWhereNotInListEmpty(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereNotInList('id', [], ['allowEmpty' => true])\n            ->order(['id']);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\(<id>\\) IS NOT NULL',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '1'], $result[0]);\n    }\n\n    /**\n     * Tests whereNotInListOrNull() and its input types.\n     */\n    public function testWhereNotInListOrNull(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereNotInListOrNull('id', [1, 3]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\\\(<id> not in \\\\(:c0,:c1\\\\) OR \\\\(<id>\\\\) IS NULL\\\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '2'], $result[0]);\n    }\n\n    /**\n     * Tests whereNotInListOrNull() and empty array input.\n     */\n    public function testWhereNotInListOrNullEmpty(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereNotInListOrNull('id', [], ['allowEmpty' => true])\n            ->order(['id']);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\(<id>\\) IS NOT NULL',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '1'], $result[0]);\n    }\n\n    /**\n     * Tests order() method both with simple fields and expressions\n     */\n    public function testSelectOrderBy(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->order(['id' => 'desc'])\n            ->execute();\n        $this->assertEquals(['id' => 6], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->order(['id' => 'asc'])->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->order(['comment' => 'asc'])->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->order(['comment' => 'asc'], true)->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->order(['user_id' => 'asc', 'created' => 'desc'], true)\n            ->execute();\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $expression = $query->newExpr(['(id + :offset) % 2']);\n        $result = $query\n            ->order([$expression, 'id' => 'desc'], true)\n            ->bind(':offset', 1, null)\n            ->execute();\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query\n            ->order($expression, true)\n            ->order(['id' => 'asc'])\n            ->bind(':offset', 1, null)\n            ->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Test that order() being a string works.\n     */\n    public function testSelectOrderByString(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->order('id asc');\n        $result = $query->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Test exception for order() with an associative array which contains extra values.\n     */\n    public function testSelectOrderByAssociativeArrayContainingExtraExpressions(): void\n    {\n        $this->expectException('RuntimeException');\n        $this->expectExceptionMessage(\n            'Passing extra expressions by associative array (`\\'id\\' => \\'desc -- Comment\\'`) ' .\n            'is not allowed to avoid potential SQL injection. ' .\n            'Use QueryExpression or numeric array instead.'\n        );\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->order([\n                'id' => 'desc -- Comment',\n            ]);\n    }\n\n    /**\n     * Tests that order() works with closures.\n     */\n    public function testSelectOrderByClosure(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->select('*')\n            ->from('articles')\n            ->order(function ($exp, $q) use ($query) {\n                $this->assertInstanceOf(QueryExpression::class, $exp);\n                $this->assertSame($query, $q);\n\n                return ['id' => 'ASC'];\n            });\n\n        $this->assertQuotedQuery(\n            'SELECT \\* FROM <articles> ORDER BY <id> ASC',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query\n            ->select('*')\n            ->from('articles')\n            ->order(function ($exp) {\n                return [$exp->add(['id % 2 = 0']), 'title' => 'ASC'];\n            });\n\n        $this->assertQuotedQuery(\n            'SELECT \\* FROM <articles> ORDER BY id % 2 = 0, <title> ASC',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query\n            ->select('*')\n            ->from('articles')\n            ->order(function ($exp) {\n                return $exp->add('a + b');\n            });\n\n        $this->assertQuotedQuery(\n            'SELECT \\* FROM <articles> ORDER BY a \\+ b',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query\n            ->select('*')\n            ->from('articles')\n            ->order(function ($exp, $q) {\n                return $q->func()->sum('a');\n            });\n\n        $this->assertQuotedQuery(\n            'SELECT \\* FROM <articles> ORDER BY SUM\\(a\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test orderAsc() and its input types.\n     */\n    public function testSelectOrderAsc(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderAsc('id');\n\n        $sql = $query->sql();\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 1],\n            ['id' => 2],\n            ['id' => 3],\n        ];\n        $this->assertEquals($expected, $result);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY <id> ASC',\n            $sql,\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderAsc($query->func()->concat(['id' => 'identifier', '3']));\n\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 1],\n            ['id' => 2],\n            ['id' => 3],\n        ];\n        $this->assertEquals($expected, $result);\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderAsc(function (QueryExpression $exp, Query $query) {\n                return $exp\n                    ->case()\n                    ->when(['author_id' => 1])\n                    ->then(1)\n                    ->else($query->identifier('id'));\n            })\n            ->orderAsc('id');\n        $sql = $query->sql();\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 1],\n            ['id' => 3],\n            ['id' => 2],\n        ];\n        $this->assertEquals($expected, $result);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY CASE WHEN <author_id> = :c0 THEN :c1 ELSE <id> END ASC, <id> ASC',\n            $sql,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test orderDesc() and its input types.\n     */\n    public function testSelectOrderDesc(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderDesc('id');\n        $sql = $query->sql();\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 3],\n            ['id' => 2],\n            ['id' => 1],\n        ];\n        $this->assertEquals($expected, $result);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY <id> DESC',\n            $sql,\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderDesc($query->func()->concat(['id' => 'identifier', '3']));\n\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 3],\n            ['id' => 2],\n            ['id' => 1],\n        ];\n        $this->assertEquals($expected, $result);\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderDesc(function (QueryExpression $exp, Query $query) {\n                return $exp\n                    ->case()\n                    ->when(['author_id' => 1])\n                    ->then(1)\n                    ->else($query->identifier('id'));\n            })\n            ->orderDesc('id');\n        $sql = $query->sql();\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 2],\n            ['id' => 3],\n            ['id' => 1],\n        ];\n        $this->assertEquals($expected, $result);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY CASE WHEN <author_id> = :c0 THEN :c1 ELSE <id> END DESC, <id> DESC',\n            $sql,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that group by fields can be passed similar to select fields\n     * and that it sends the correct query to the database\n     */\n    public function testSelectGroup(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => 'author_id = a.id'])\n            ->group('author_id')\n            ->order(['total' => 'desc'])\n            ->execute();\n        $expected = [['total' => 2, 'author_id' => 1], ['total' => '1', 'author_id' => 3]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $result = $query->select(['total' => 'count(title)', 'name'], true)\n            ->group(['name'], true)\n            ->order(['total' => 'asc'])\n            ->execute();\n        $expected = [['total' => 1, 'name' => 'larry'], ['total' => 2, 'name' => 'mariano']];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $result = $query->select(['articles.id'])\n            ->group(['articles.id'])\n            ->execute();\n        $this->assertCount(3, $result);\n    }\n\n    /**\n     * Tests that it is possible to select distinct rows\n     */\n    public function testSelectDistinct(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['author_id'])\n            ->from(['a' => 'articles'])\n            ->execute();\n        $this->assertCount(3, $result);\n\n        $result = $query->distinct()->execute();\n        $this->assertCount(2, $result);\n\n        $result = $query->select(['id'])->distinct(false)->execute();\n        $this->assertCount(3, $result);\n    }\n\n    /**\n     * Tests distinct on a specific column reduces rows based on that column.\n     */\n    public function testSelectDistinctON(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['author_id'])\n            ->distinct(['author_id'])\n            ->from(['a' => 'articles'])\n            ->order(['author_id' => 'ASC'])\n            ->execute();\n        $this->assertCount(2, $result);\n        $results = $result->fetchAll('assoc');\n        $this->assertEquals(\n            [3, 1],\n            collection($results)->sortBy('author_id')->extract('author_id')->toList()\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['author_id'])\n            ->distinct('author_id')\n            ->from(['a' => 'articles'])\n            ->order(['author_id' => 'ASC'])\n            ->execute();\n        $this->assertCount(2, $result);\n        $results = $result->fetchAll('assoc');\n        $this->assertEquals(\n            [3, 1],\n            collection($results)->sortBy('author_id')->extract('author_id')->toList()\n        );\n    }\n\n    /**\n     * Test use of modifiers in the query\n     *\n     * Testing the generated SQL since the modifiers are usually different per driver\n     */\n    public function testSelectModifiers(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier('DISTINCTROW');\n        $this->assertQuotedQuery(\n            'SELECT DISTINCTROW <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier(['DISTINCTROW', 'SQL_NO_CACHE']);\n        $this->assertQuotedQuery(\n            'SELECT DISTINCTROW SQL_NO_CACHE <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier('DISTINCTROW')\n            ->modifier('SQL_NO_CACHE');\n        $this->assertQuotedQuery(\n            'SELECT DISTINCTROW SQL_NO_CACHE <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            true\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier(['TOP 10']);\n        $this->assertQuotedQuery(\n            'SELECT TOP 10 <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier($query->newExpr('EXPRESSION'));\n        $this->assertQuotedQuery(\n            'SELECT EXPRESSION <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that having() behaves pretty much the same as the where() method\n     */\n    public function testSelectHaving(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->group('author_id')\n            ->having(['count(author_id) <' => 2], ['count(author_id)' => 'integer'])\n            ->execute();\n        $expected = [['total' => 1, 'author_id' => 3]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $result = $query->having(['count(author_id)' => 2], ['count(author_id)' => 'integer'], true)\n            ->execute();\n        $expected = [['total' => 2, 'author_id' => 1]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $result = $query->having(function ($e) {\n            return $e->add('count(author_id) = 1 + 1');\n        }, [], true)\n            ->execute();\n        $expected = [['total' => 2, 'author_id' => 1]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n    }\n\n    /**\n     * Tests that Query::andHaving() can be used to concatenate conditions with AND\n     * in the having clause\n     */\n    public function testSelectAndHaving(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->group('author_id')\n            ->having(['count(author_id) >' => 2], ['count(author_id)' => 'integer'])\n            ->andHaving(['count(author_id) <' => 2], ['count(author_id)' => 'integer'])\n            ->execute();\n        $this->assertCount(0, $result);\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->group('author_id')\n            ->having(['count(author_id)' => 2], ['count(author_id)' => 'integer'])\n            ->andHaving(['count(author_id) >' => 1], ['count(author_id)' => 'integer'])\n            ->execute();\n        $expected = [['total' => 2, 'author_id' => 1]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->group('author_id')\n            ->andHaving(function ($e) {\n                return $e->add('count(author_id) = 2 - 1');\n            })\n            ->execute();\n        $expected = [['total' => 1, 'author_id' => 3]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n    }\n\n    /**\n     * Test having casing with string expressions\n     */\n    public function testHavingAliasCasingStringExpression(): void\n    {\n        $this->skipIf($this->autoQuote, 'Does not work when autoquoting is enabled.');\n        $query = new Query($this->connection);\n        $query\n            ->select(['id'])\n            ->from(['Authors' => 'authors'])\n            ->where([\n                'FUNC( Authors.id) =' => 1,\n                'FUNC( Authors.id) IS NOT' => null,\n            ])\n            ->having(['COUNT(DISTINCT Authors.id) =' => 1]);\n\n        $this->assertSame(\n            'SELECT id FROM authors Authors WHERE ' .\n            '(FUNC( Authors.id) = :c0 AND (FUNC( Authors.id)) IS NOT NULL) ' .\n            'HAVING COUNT(DISTINCT Authors.id) = :c1',\n            trim($query->sql())\n        );\n    }\n\n    /**\n     * Tests selecting rows using a limit clause\n     */\n    public function testSelectLimit(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('articles')->limit(1)->execute();\n        $this->assertCount(1, $result);\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('articles')->limit(2)->execute();\n        $this->assertCount(2, $result);\n    }\n\n    /**\n     * Tests selecting rows combining a limit and offset clause\n     */\n    public function testSelectOffset(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->offset(0)\n            ->order(['id' => 'ASC'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->offset(1)\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->offset(2)\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('articles')\n            ->order(['id' => 'DESC'])\n            ->limit(1)\n            ->offset(0)\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n\n        $result = $query->limit(2)->offset(1)->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $query->select('id')->from('comments')\n            ->limit(1)\n            ->offset(1)\n            ->execute()\n            ->closeCursor();\n\n        $reflect = new ReflectionProperty($query, '_dirty');\n        $reflect->setAccessible(true);\n        $this->assertFalse($reflect->getValue($query));\n\n        $query->offset(2);\n        $this->assertTrue($reflect->getValue($query));\n    }\n\n    /**\n     * Test Pages number.\n     */\n    public function testPageShouldStartAtOne(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage('Pages must start at 1.');\n\n        $query = new Query($this->connection);\n        $result = $query->from('comments')->page(0);\n    }\n\n    /**\n     * Test selecting rows using the page() method.\n     */\n    public function testSelectPage(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->page(1)\n            ->execute();\n\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->page(2)\n            ->order(['id' => 'asc'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $query->select('id')->from('comments')->page(3, 10);\n        $this->assertEquals(10, $query->clause('limit'));\n        $this->assertEquals(20, $query->clause('offset'));\n\n        $query = new Query($this->connection);\n        $query->select('id')->from('comments')->page(1);\n        $this->assertEquals(25, $query->clause('limit'));\n        $this->assertEquals(0, $query->clause('offset'));\n\n        $query->select('id')->from('comments')->page(2);\n        $this->assertEquals(25, $query->clause('limit'));\n        $this->assertEquals(25, $query->clause('offset'));\n    }\n\n    /**\n     * Test selecting rows using the page() method and ordering the results\n     * by a calculated column.\n     */\n    public function testSelectPageWithOrder(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select([\n                'id',\n                'ids_added' => $query->newExpr()->add('(user_id + article_id)'),\n            ])\n            ->from('comments')\n            ->order(['ids_added' => 'asc'])\n            ->limit(2)\n            ->page(3)\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(\n            [\n                ['id' => '6', 'ids_added' => '4'],\n                ['id' => '2', 'ids_added' => '5'],\n            ],\n            $result->fetchAll('assoc')\n        );\n    }\n\n    /**\n     * Tests that Query objects can be included inside the select clause\n     * and be used as a normal field, including binding any passed parameter\n     */\n    public function testSubqueryInSelect(): void\n    {\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select('name')\n            ->from(['b' => 'authors'])\n            ->where([$query->newExpr()->equalFields('b.id', 'a.id')]);\n        $result = $query\n            ->select(['id', 'name' => $subquery])\n            ->from(['a' => 'comments'])->execute();\n\n        $expected = [\n            ['id' => 1, 'name' => 'mariano'],\n            ['id' => 2, 'name' => 'nate'],\n            ['id' => 3, 'name' => 'larry'],\n            ['id' => 4, 'name' => 'garrett'],\n            ['id' => 5, 'name' => null],\n            ['id' => 6, 'name' => null],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select('name')\n            ->from(['b' => 'authors'])\n            ->where(['name' => 'mariano'], ['name' => 'string']);\n        $result = $query\n            ->select(['id', 'name' => $subquery])\n            ->from(['a' => 'articles'])->execute();\n\n        $expected = [\n            ['id' => 1, 'name' => 'mariano'],\n            ['id' => 2, 'name' => 'mariano'],\n            ['id' => 3, 'name' => 'mariano'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n    }\n\n    /**\n     * Tests that Query objects can be included inside the from clause\n     * and be used as a normal table, including binding any passed parameter\n     */\n    public function testSuqueryInFrom(): void\n    {\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select(['id', 'comment'])\n            ->from('comments')\n            ->where(['created >' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime']);\n        $result = $query\n            ->select(['say' => 'comment'])\n            ->from(['b' => $subquery])\n            ->where(['id !=' => 3])\n            ->execute();\n\n        $expected = [\n            ['say' => 'Second Comment for First Article'],\n            ['say' => 'Fourth Comment for First Article'],\n            ['say' => 'First Comment for Second Article'],\n            ['say' => 'Second Comment for Second Article'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n    }\n\n    /**\n     * Tests that Query objects can be included inside the where clause\n     * and be used as a normal condition, including binding any passed parameter\n     */\n    public function testSubqueryInWhere(): void\n    {\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('authors')\n            ->where(['id' => 1]);\n        $result = $query\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['id !=' => $subquery])\n            ->execute();\n\n        $expected = [\n            ['name' => 'nate'],\n            ['name' => 'larry'],\n            ['name' => 'garrett'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created >' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime']);\n        $result = $query\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['id not in' => $subquery])\n            ->execute();\n\n        $expected = [\n            ['name' => 'mariano'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that Query objects can be included inside the where clause\n     * and be used as a EXISTS and NOT EXISTS conditions\n     */\n    public function testSubqueryExistsWhere(): void\n    {\n        $query = new Query($this->connection);\n        $subQuery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->equalFields('authors.id', 'articles.author_id');\n            });\n        $result = $query\n            ->select(['id'])\n            ->from('authors')\n            ->where(function ($exp) use ($subQuery) {\n                return $exp->exists($subQuery);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $subQuery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->equalFields('authors.id', 'articles.author_id');\n            });\n        $result = $query\n            ->select(['id'])\n            ->from('authors')\n            ->where(function ($exp) use ($subQuery) {\n                return $exp->notExists($subQuery);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n    }\n\n    /**\n     * Tests that it is possible to use a subquery in a join clause\n     */\n    public function testSubqueryInJoin(): void\n    {\n        $subquery = (new Query($this->connection))->select('*')->from('authors');\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['b' => $subquery])\n            ->execute();\n        $this->assertCount(self::ARTICLE_COUNT * self::AUTHOR_COUNT, $result, 'Cross join causes multiplication');\n        $result->closeCursor();\n\n        $subquery->where(['id' => 1]);\n        $result = $query->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n\n        $query->join(['b' => ['table' => $subquery, 'conditions' => [$query->newExpr()->equalFields('b.id', 'articles.id')]]], [], true);\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to one or multiple UNION statements in a query\n     */\n    public function testUnion(): void\n    {\n        $union = (new Query($this->connection))->select(['id', 'title'])->from(['a' => 'articles']);\n        $query = new Query($this->connection);\n        $result = $query->select(['id', 'comment'])\n            ->from(['c' => 'comments'])\n            ->union($union)\n            ->execute();\n        $this->assertCount(self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n        $rows = $result->fetchAll();\n        $result->closeCursor();\n\n        $union->select(['foo' => 'id', 'bar' => 'title']);\n        $union = (new Query($this->connection))\n            ->select(['id', 'name', 'other' => 'id', 'nameish' => 'name'])\n            ->from(['b' => 'authors'])\n            ->where(['id ' => 1])\n            ->order(['id' => 'desc']);\n\n        $query->select(['foo' => 'id', 'bar' => 'comment'])->union($union);\n        $result = $query->execute();\n        $this->assertCount(self::COMMENT_COUNT + self::AUTHOR_COUNT, $result);\n        $this->assertNotEquals($rows, $result->fetchAll());\n        $result->closeCursor();\n\n        $union = (new Query($this->connection))\n            ->select(['id', 'title'])\n            ->from(['c' => 'articles']);\n        $query->select(['id', 'comment'], true)->union($union, true);\n        $result = $query->execute();\n        $this->assertCount(self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n        $this->assertEquals($rows, $result->fetchAll());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to run unions with order statements\n     */\n    public function testUnionOrderBy(): void\n    {\n        $this->skipIf(\n            ($this->connection->getDriver() instanceof Sqlite ||\n            $this->connection->getDriver() instanceof Sqlserver),\n            'Driver does not support ORDER BY in UNIONed queries.'\n        );\n        $union = (new Query($this->connection))\n            ->select(['id', 'title'])\n            ->from(['a' => 'articles'])\n            ->order(['a.id' => 'asc']);\n\n        $query = new Query($this->connection);\n        $result = $query->select(['id', 'comment'])\n            ->from(['c' => 'comments'])\n            ->order(['c.id' => 'asc'])\n            ->union($union)\n            ->execute();\n        $this->assertCount(self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n\n        $rows = $result->fetchAll();\n        $this->assertCount(self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n    }\n\n    /**\n     * Tests that UNION ALL can be built by setting the second param of union() to true\n     */\n    public function testUnionAll(): void\n    {\n        $union = (new Query($this->connection))->select(['id', 'title'])->from(['a' => 'articles']);\n        $query = new Query($this->connection);\n        $result = $query->select(['id', 'comment'])\n            ->from(['c' => 'comments'])\n            ->union($union)\n            ->execute();\n        $this->assertCount(self::ARTICLE_COUNT + self::COMMENT_COUNT, $result);\n        $rows = $result->fetchAll();\n        $result->closeCursor();\n\n        $union->select(['foo' => 'id', 'bar' => 'title']);\n        $union = (new Query($this->connection))\n            ->select(['id', 'name', 'other' => 'id', 'nameish' => 'name'])\n            ->from(['b' => 'authors'])\n            ->where(['id ' => 1])\n            ->order(['id' => 'desc']);\n\n        $query->select(['foo' => 'id', 'bar' => 'comment'])->unionAll($union);\n        $result = $query->execute();\n        $this->assertCount(1 + self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n        $this->assertNotEquals($rows, $result->fetchAll());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests stacking decorators for results and resetting the list of decorators\n     */\n    public function testDecorateResults(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id', 'title'])\n            ->from('articles')\n            ->order(['id' => 'ASC'])\n            ->decorateResults(function ($row) {\n                $row['modified_id'] = $row['id'] + 1;\n\n                return $row;\n            })\n            ->execute();\n\n        while ($row = $result->fetch('assoc')) {\n            $this->assertEquals($row['id'] + 1, $row['modified_id']);\n        }\n\n        $result = $query->decorateResults(function ($row) {\n            $row['modified_id']--;\n\n            return $row;\n        })->execute();\n\n        while ($row = $result->fetch('assoc')) {\n            $this->assertEquals($row['id'], $row['modified_id']);\n        }\n        $result->closeCursor();\n\n        $result = $query\n            ->decorateResults(function ($row) {\n                $row['foo'] = 'bar';\n\n                return $row;\n            }, true)\n            ->execute();\n\n        while ($row = $result->fetch('assoc')) {\n            $this->assertSame('bar', $row['foo']);\n            $this->assertArrayNotHasKey('modified_id', $row);\n        }\n\n        $results = $query->decorateResults(null, true)->execute();\n        while ($row = $results->fetch('assoc')) {\n            $this->assertArrayNotHasKey('foo', $row);\n            $this->assertArrayNotHasKey('modified_id', $row);\n        }\n        $results->closeCursor();\n    }\n\n    /**\n     * Test a basic delete using from()\n     */\n    public function testDeleteWithFrom(): void\n    {\n        $query = new Query($this->connection);\n\n        $query->delete()\n            ->from('authors')\n            ->where('1 = 1');\n\n        $result = $query->sql();\n        $this->assertQuotedQuery('DELETE FROM <authors>', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertCount(self::AUTHOR_COUNT, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test delete with from and alias.\n     */\n    public function testDeleteWithAliasedFrom(): void\n    {\n        $query = new Query($this->connection);\n\n        $query->delete()\n            ->from(['a ' => 'authors'])\n            ->where(['a.id !=' => 99]);\n\n        $result = $query->sql();\n        $this->assertQuotedQuery('DELETE FROM <authors> WHERE <id> != :c0', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertCount(self::AUTHOR_COUNT, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test a basic delete with no from() call.\n     */\n    public function testDeleteNoFrom(): void\n    {\n        $query = new Query($this->connection);\n\n        $query->delete('authors')\n            ->where('1 = 1');\n\n        $result = $query->sql();\n        $this->assertQuotedQuery('DELETE FROM <authors>', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertCount(self::AUTHOR_COUNT, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that delete queries that contain joins do trigger a notice,\n     * warning about possible incompatibilities with aliases being removed\n     * from the conditions.\n     */\n    public function testDeleteRemovingAliasesCanBreakJoins(): void\n    {\n        $this->expectException(RuntimeException::class);\n        $this->expectExceptionMessage('Aliases are being removed from conditions for UPDATE/DELETE queries, this can break references to joined tables.');\n        $query = new Query($this->connection);\n\n        $query\n            ->delete('authors')\n            ->from(['a ' => 'authors'])\n            ->innerJoin('articles')\n            ->where(['a.id' => 1]);\n\n        $query->sql();\n    }\n\n    /**\n     * Tests that aliases are stripped from delete query conditions\n     * where possible.\n     */\n    public function testDeleteStripAliasesFromConditions(): void\n    {\n        $query = new Query($this->connection);\n\n        $query\n            ->delete()\n            ->from(['a' => 'authors'])\n            ->where([\n                'OR' => [\n                    'a.id' => 1,\n                    'a.name IS' => null,\n                    'a.email IS NOT' => null,\n                    'AND' => [\n                        'b.name NOT IN' => ['foo', 'bar'],\n                        'OR' => [\n                            $query->newExpr()->eq(new IdentifierExpression('c.name'), 'zap'),\n                            'd.name' => 'baz',\n                            (new Query($this->connection))->select(['e.name'])->where(['e.name' => 'oof']),\n                        ],\n                    ],\n                ],\n            ]);\n\n        $this->assertQuotedQuery(\n            'DELETE FROM <authors> WHERE \\(' .\n                '<id> = :c0 OR \\(<name>\\) IS NULL OR \\(<email>\\) IS NOT NULL OR \\(' .\n                    '<name> not in \\(:c1,:c2\\) AND \\(' .\n                        '<name> = :c3 OR <name> = :c4 OR \\(SELECT <e>\\.<name> WHERE <e>\\.<name> = :c5\\)' .\n                    '\\)' .\n                '\\)' .\n            '\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test setting select() & delete() modes.\n     */\n    public function testSelectAndDeleteOnSameQuery(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select()\n            ->delete('authors')\n            ->where('1 = 1');\n        $result = $query->sql();\n\n        $this->assertQuotedQuery('DELETE FROM <authors>', $result, !$this->autoQuote);\n        $this->assertStringContainsString(' WHERE 1 = 1', $result);\n    }\n\n    /**\n     * Test a simple update.\n     */\n    public function testUpdateSimple(): void\n    {\n        $query = new Query($this->connection);\n        $query->update('authors')\n            ->set('name', 'mark')\n            ->where(['id' => 1]);\n        $result = $query->sql();\n        $this->assertQuotedQuery('UPDATE <authors> SET <name> = :', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test update with type checking\n     * by passing an array as table arg\n     */\n    public function testUpdateArgTypeChecking(): void\n    {\n        $this->expectException(\\InvalidArgumentException::class);\n        $query = new Query($this->connection);\n        $query->update(['Articles']);\n    }\n\n    /**\n     * Test update with multiple fields.\n     */\n    public function testUpdateMultipleFields(): void\n    {\n        $query = new Query($this->connection);\n        $query->update('articles')\n            ->set('title', 'mark', 'string')\n            ->set('body', 'some text', 'string')\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <articles> SET <title> = :c0 , <body> = :c1',\n            $result,\n            !$this->autoQuote\n        );\n\n        $this->assertQuotedQuery(' WHERE <id> = :c2$', $result, !$this->autoQuote);\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test updating multiple fields with an array.\n     */\n    public function testUpdateMultipleFieldsArray(): void\n    {\n        $query = new Query($this->connection);\n        $query->update('articles')\n            ->set([\n                'title' => 'mark',\n                'body' => 'some text',\n            ], ['title' => 'string', 'body' => 'string'])\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <articles> SET <title> = :c0 , <body> = :c1',\n            $result,\n            !$this->autoQuote\n        );\n        $this->assertQuotedQuery('WHERE <id> = :', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test updates with an expression.\n     */\n    public function testUpdateWithExpression(): void\n    {\n        $query = new Query($this->connection);\n\n        $expr = $query->newExpr()->equalFields('article_id', 'user_id');\n\n        $query->update('comments')\n            ->set($expr)\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <comments> SET <article_id> = <user_id> WHERE <id> = :',\n            $result,\n            !$this->autoQuote\n        );\n\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests update with subquery that references itself\n     */\n    public function testUpdateSubquery(): void\n    {\n        $this->skipIf($this->connection->getDriver() instanceof Mysql);\n\n        $subquery = new Query($this->connection);\n        $subquery\n            ->select('created')\n            ->from(['c' => 'comments'])\n            ->where(['c.id' => new IdentifierExpression('comments.id')]);\n\n        $query = new Query($this->connection);\n        $query->update('comments')\n            ->set('updated', $subquery);\n\n        $this->assertEqualsSql(\n            'UPDATE comments SET updated = (SELECT created FROM comments c WHERE c.id = comments.id)',\n            $query->sql(new ValueBinder())\n        );\n\n        $result = $query->execute();\n        $this->assertCount(6, $result);\n        $result->closeCursor();\n\n        $result = (new Query($this->connection))->select(['created', 'updated'])->from('comments')->execute();\n        foreach ($result->fetchAll('assoc') as $row) {\n            $this->assertSame($row['created'], $row['updated']);\n        }\n        $result->closeCursor();\n    }\n\n    /**\n     * Test update with array fields and types.\n     */\n    public function testUpdateArrayFields(): void\n    {\n        $query = new Query($this->connection);\n        $date = new DateTime();\n        $query->update('comments')\n            ->set(['comment' => 'mark', 'created' => $date], ['created' => 'date'])\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <comments> SET <comment> = :c0 , <created> = :c1',\n            $result,\n            !$this->autoQuote\n        );\n\n        $this->assertQuotedQuery(' WHERE <id> = :c2$', $result, !$this->autoQuote);\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n\n        $query = new Query($this->connection);\n        $result = $query->select('created')->from('comments')->where(['id' => 1])->execute();\n        $result = $result->fetchAll('assoc')[0]['created'];\n        $this->assertStringStartsWith($date->format('Y-m-d'), $result);\n    }\n\n    /**\n     * Test update with callable in set\n     */\n    public function testUpdateSetCallable(): void\n    {\n        $query = new Query($this->connection);\n        $date = new DateTime();\n        $query->update('comments')\n            ->set(function ($exp) use ($date) {\n                return $exp\n                    ->eq('comment', 'mark')\n                    ->eq('created', $date, 'date');\n            })\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <comments> SET <comment> = :c0 , <created> = :c1',\n            $result,\n            !$this->autoQuote\n        );\n\n        $this->assertQuotedQuery(' WHERE <id> = :c2$', $result, !$this->autoQuote);\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n    }\n\n    /**\n     * Tests that aliases are stripped from update query conditions\n     * where possible.\n     */\n    public function testUpdateStripAliasesFromConditions(): void\n    {\n        $query = new Query($this->connection);\n\n        $query\n            ->update('authors')\n            ->set(['name' => 'name'])\n            ->where([\n                'OR' => [\n                    'a.id' => 1,\n                    'a.name IS' => null,\n                    'a.email IS NOT' => null,\n                    'AND' => [\n                        'b.name NOT IN' => ['foo', 'bar'],\n                        'OR' => [\n                            $query->newExpr()->eq(new IdentifierExpression('c.name'), 'zap'),\n                            'd.name' => 'baz',\n                            (new Query($this->connection))->select(['e.name'])->where(['e.name' => 'oof']),\n                        ],\n                    ],\n                ],\n            ]);\n\n        $this->assertQuotedQuery(\n            'UPDATE <authors> SET <name> = :c0 WHERE \\(' .\n                '<id> = :c1 OR \\(<name>\\) IS NULL OR \\(<email>\\) IS NOT NULL OR \\(' .\n                    '<name> not in \\(:c2,:c3\\) AND \\(' .\n                        '<name> = :c4 OR <name> = :c5 OR \\(SELECT <e>\\.<name> WHERE <e>\\.<name> = :c6\\)' .\n                    '\\)' .\n                '\\)' .\n            '\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that update queries that contain joins do trigger a notice,\n     * warning about possible incompatibilities with aliases being removed\n     * from the conditions.\n     */\n    public function testUpdateRemovingAliasesCanBreakJoins(): void\n    {\n        $this->expectException(RuntimeException::class);\n        $this->expectExceptionMessage('Aliases are being removed from conditions for UPDATE/DELETE queries, this can break references to joined tables.');\n        $query = new Query($this->connection);\n\n        $query\n            ->update('authors')\n            ->set(['name' => 'name'])\n            ->innerJoin('articles')\n            ->where(['a.id' => 1]);\n\n        $query->sql();\n    }\n\n    /**\n     * You cannot call values() before insert() it causes all sorts of pain.\n     */\n    public function testInsertValuesBeforeInsertFailure(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $query = new Query($this->connection);\n        $query->select('*')->values([\n            'id' => 1,\n            'title' => 'mark',\n            'body' => 'test insert',\n        ]);\n    }\n\n    /**\n     * Inserting nothing should not generate an error.\n     */\n    public function testInsertNothing(): void\n    {\n        $this->expectException(RuntimeException::class);\n        $this->expectExceptionMessage('At least 1 column is required to perform an insert.');\n        $query = new Query($this->connection);\n        $query->insert([]);\n    }\n\n    /**\n     * Test insert() with no into()\n     */\n    public function testInsertNoInto(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $this->expectExceptionMessage('Could not compile insert query. No table was specified');\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])->sql();\n    }\n\n    /**\n     * Test insert overwrites values\n     */\n    public function testInsertOverwritesValues(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])\n            ->insert(['title'])\n            ->into('articles')\n            ->values([\n                'title' => 'mark',\n            ]);\n\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<title>\\) (OUTPUT INSERTED\\.\\* )?' .\n            'VALUES \\(:c0\\)',\n            $result,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test inserting a single row.\n     */\n    public function testInsertSimple(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])\n            ->into('articles')\n            ->values([\n                'title' => 'mark',\n                'body' => 'test insert',\n            ]);\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<title>, <body>\\) (OUTPUT INSERTED\\.\\* )?' .\n            'VALUES \\(:c0, :c1\\)',\n            $result,\n            !$this->autoQuote\n        );\n\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result, '1 row should be inserted');\n        }\n\n        $expected = [\n            [\n                'id' => 4,\n                'author_id' => null,\n                'title' => 'mark',\n                'body' => 'test insert',\n                'published' => 'N',\n            ],\n        ];\n        $this->assertTable('articles', 1, $expected, ['id >=' => 4]);\n    }\n\n    /**\n     * Test insert queries quote integer column names\n     */\n    public function testInsertQuoteColumns(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert([123])\n            ->into('articles')\n            ->values([\n                '123' => 'mark',\n            ]);\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<123>\\) (OUTPUT INSERTED\\.\\* )?' .\n            'VALUES \\(:c0\\)',\n            $result,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test an insert when not all the listed fields are provided.\n     * Columns should be matched up where possible.\n     */\n    public function testInsertSparseRow(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])\n            ->into('articles')\n            ->values([\n                'title' => 'mark',\n            ]);\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<title>, <body>\\) (OUTPUT INSERTED\\.\\* )?' .\n            'VALUES \\(:c0, :c1\\)',\n            $result,\n            !$this->autoQuote\n        );\n\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result, '1 row should be inserted');\n        }\n\n        $expected = [\n            [\n                'id' => 4,\n                'author_id' => null,\n                'title' => 'mark',\n                'body' => null,\n                'published' => 'N',\n            ],\n        ];\n        $this->assertTable('articles', 1, $expected, ['id >=' => 4]);\n    }\n\n    /**\n     * Test inserting multiple rows with sparse data.\n     */\n    public function testInsertMultipleRowsSparse(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])\n            ->into('articles')\n            ->values([\n                'body' => 'test insert',\n            ])\n            ->values([\n                'title' => 'jose',\n            ]);\n\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(2, $result, '2 rows should be inserted');\n        }\n\n        $expected = [\n            [\n                'id' => 4,\n                'author_id' => null,\n                'title' => null,\n                'body' => 'test insert',\n                'published' => 'N',\n            ],\n            [\n                'id' => 5,\n                'author_id' => null,\n                'title' => 'jose',\n                'body' => null,\n                'published' => 'N',\n            ],\n        ];\n        $this->assertTable('articles', 2, $expected, ['id >=' => 4]);\n    }\n\n    /**\n     * Test that INSERT INTO ... SELECT works.\n     */\n    public function testInsertFromSelect(): void\n    {\n        $select = (new Query($this->connection))->select(['name', \"'some text'\", 99])\n            ->from('authors')\n            ->where(['id' => 1]);\n\n        $query = new Query($this->connection);\n        $query->insert(\n            ['title', 'body', 'author_id'],\n            ['title' => 'string', 'body' => 'string', 'author_id' => 'integer']\n        )\n        ->into('articles')\n        ->values($select);\n\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<title>, <body>, <author_id>\\) (OUTPUT INSERTED\\.\\* )?SELECT',\n            $result,\n            !$this->autoQuote\n        );\n        $this->assertQuotedQuery(\n            'SELECT <name>, \\'some text\\', 99 FROM <authors>',\n            $result,\n            !$this->autoQuote\n        );\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result);\n        }\n\n        $result = (new Query($this->connection))->select('*')\n            ->from('articles')\n            ->where(['author_id' => 99])\n            ->execute();\n        $this->assertCount(1, $result);\n        $expected = [\n            'id' => 4,\n            'title' => 'mariano',\n            'body' => 'some text',\n            'author_id' => 99,\n            'published' => 'N',\n        ];\n        $this->assertEquals($expected, $result->fetch('assoc'));\n    }\n\n    /**\n     * Test that an exception is raised when mixing query + array types.\n     */\n    public function testInsertFailureMixingTypesArrayFirst(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $query = new Query($this->connection);\n        $query->insert(['name'])\n            ->into('articles')\n            ->values(['name' => 'mark'])\n            ->values(new Query($this->connection));\n    }\n\n    /**\n     * Test that an exception is raised when mixing query + array types.\n     */\n    public function testInsertFailureMixingTypesQueryFirst(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $query = new Query($this->connection);\n        $query->insert(['name'])\n            ->into('articles')\n            ->values(new Query($this->connection))\n            ->values(['name' => 'mark']);\n    }\n\n    /**\n     * Test that insert can use expression objects as values.\n     */\n    public function testInsertExpressionValues(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'author_id'])\n            ->into('articles')\n            ->values(['title' => $query->newExpr(\"SELECT 'jose'\"), 'author_id' => 99]);\n\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result);\n        }\n\n        $result = (new Query($this->connection))->select('*')\n            ->from('articles')\n            ->where(['author_id' => 99])\n            ->execute();\n        $this->assertCount(1, $result);\n        $expected = [\n            'id' => 4,\n            'title' => 'jose',\n            'body' => null,\n            'author_id' => '99',\n            'published' => 'N',\n        ];\n        $this->assertEquals($expected, $result->fetch('assoc'));\n\n        $subquery = new Query($this->connection);\n        $subquery->select(['name'])\n            ->from('authors')\n            ->where(['id' => 1]);\n\n        $query = new Query($this->connection);\n        $query->insert(['title', 'author_id'])\n            ->into('articles')\n            ->values(['title' => $subquery, 'author_id' => 100]);\n        $result = $query->execute();\n        $result->closeCursor();\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result);\n        }\n\n        $result = (new Query($this->connection))->select('*')\n            ->from('articles')\n            ->where(['author_id' => 100])\n            ->execute();\n        $this->assertCount(1, $result);\n        $expected = [\n            'id' => 5,\n            'title' => 'mariano',\n            'body' => null,\n            'author_id' => '100',\n            'published' => 'N',\n        ];\n        $this->assertEquals($expected, $result->fetch('assoc'));\n    }\n\n    /**\n     * Tests that the identifier method creates an expression object.\n     */\n    public function testIdentifierExpression(): void\n    {\n        $query = new Query($this->connection);\n        /** @var \\Cake\\Database\\Expression\\IdentifierExpression $identifier */\n        $identifier = $query->identifier('foo');\n\n        $this->assertInstanceOf(IdentifierExpression::class, $identifier);\n        $this->assertSame('foo', $identifier->getIdentifier());\n    }\n\n    /**\n     * Tests the interface contract of identifier\n     */\n    public function testIdentifierInterface(): void\n    {\n        $query = new Query($this->connection);\n        $identifier = $query->identifier('description');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $identifier);\n        $this->assertSame('description', $identifier->getIdentifier());\n\n        $identifier->setIdentifier('title');\n        $this->assertSame('title', $identifier->getIdentifier());\n    }\n\n    /**\n     * Tests that functions are correctly transformed and their parameters are bound\n     *\n     * @group FunctionExpression\n     */\n    public function testSQLFunctions(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(\n            function ($q) {\n                return ['total' => $q->func()->count('*')];\n            }\n        )\n            ->from('comments')\n            ->execute();\n        $expected = [['total' => 6]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select([\n                'c' => $query->func()->concat(['comment' => 'literal', ' is appended']),\n            ])\n            ->from('comments')\n            ->order(['c' => 'ASC'])\n            ->limit(1)\n            ->execute();\n        $expected = [\n            ['c' => 'First Comment for First Article is appended'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['d' => $query->func()->dateDiff(['2012-01-05', '2012-01-02'])])\n            ->execute()\n            ->fetchAll('assoc');\n        $this->assertEquals(3, abs((int)$result[0]['d']));\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['d' => $query->func()->now('date')])\n            ->execute();\n\n        $result = $result->fetchAll('assoc');\n        $this->assertEquals([['d' => date('Y-m-d')]], $result);\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['d' => $query->func()->now('time')])\n            ->execute();\n\n        $this->assertWithinRange(\n            date('U'),\n            (new DateTime($result->fetchAll('assoc')[0]['d']))->format('U'),\n            10\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['d' => $query->func()->now()])\n            ->execute();\n        $this->assertWithinRange(\n            date('U'),\n            (new DateTime($result->fetchAll('assoc')[0]['d']))->format('U'),\n            10\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select([\n                'd' => $query->func()->datePart('day', 'created'),\n                'm' => $query->func()->datePart('month', 'created'),\n                'y' => $query->func()->datePart('year', 'created'),\n                'de' => $query->func()->extract('day', 'created'),\n                'me' => $query->func()->extract('month', 'created'),\n                'ye' => $query->func()->extract('year', 'created'),\n                'wd' => $query->func()->weekday('created'),\n                'dow' => $query->func()->dayOfWeek('created'),\n                'addDays' => $query->func()->dateAdd('created', 2, 'day'),\n                'substractYears' => $query->func()->dateAdd('created', -2, 'year'),\n            ])\n            ->from('comments')\n            ->where(['created' => '2007-03-18 10:45:23'])\n            ->execute()\n            ->fetchAll('assoc');\n\n        $result[0]['addDays'] = substr($result[0]['addDays'], 0, 10);\n        $result[0]['substractYears'] = substr($result[0]['substractYears'], 0, 10);\n\n        if (PHP_VERSION_ID < 80100) {\n            $result[0]['m'] = ltrim($result[0]['m'], '0');\n            $result[0]['me'] = ltrim($result[0]['me'], '0');\n            $expected = [\n                'd' => '18',\n                'm' => '3',\n                'y' => '2007',\n                'de' => '18',\n                'me' => '3',\n                'ye' => '2007',\n                'wd' => '1', // Sunday\n                'dow' => '1',\n                'addDays' => '2007-03-20',\n                'substractYears' => '2005-03-18',\n            ];\n        } else {\n            $expected = [\n                'd' => 18,\n                'm' => 3,\n                'y' => 2007,\n                'de' => 18,\n                'me' => 3,\n                'ye' => 2007,\n                'wd' => 1, // Sunday\n                'dow' => 1,\n                'addDays' => '2007-03-20',\n                'substractYears' => '2005-03-18',\n            ];\n        }\n\n        $this->assertSame($expected, $result[0]);\n    }\n\n    /**\n     * Tests that the values in tuple comparison expression are being bound correctly,\n     * specifically for dialects that translate tuple comparisons.\n     *\n     * @see \\Cake\\Database\\Driver\\TupleComparisonTranslatorTrait::_transformTupleComparison()\n     * @see \\Cake\\Database\\Driver\\Sqlite::_expressionTranslators()\n     * @see \\Cake\\Database\\Driver\\Sqlserver::_expressionTranslators()\n     */\n    public function testTupleComparisonValuesAreBeingBoundCorrectly(): void\n    {\n        $this->skipIf(\n            $this->connection->getDriver() instanceof Sqlserver,\n            'This test fails sporadically in SQLServer'\n        );\n\n        $query = (new Query($this->connection))\n            ->select('*')\n            ->from('profiles')\n            ->where(\n                new TupleComparison(\n                    ['id', 'user_id'],\n                    [[1, 1]],\n                    ['integer', 'integer'],\n                    'IN'\n                )\n            );\n\n        $result = $query->execute()->fetch(StatementInterface::FETCH_TYPE_ASSOC);\n\n        $bindings = array_values($query->getValueBinder()->bindings());\n        $this->assertCount(2, $bindings);\n        $this->assertSame(1, $bindings[0]['value']);\n        $this->assertSame('integer', $bindings[0]['type']);\n        $this->assertSame(1, $bindings[1]['value']);\n        $this->assertSame('integer', $bindings[1]['type']);\n\n        $this->assertSame(1, (int)$result['id']);\n        $this->assertSame(1, (int)$result['user_id']);\n    }\n\n    /**\n     * Tests that the values in tuple comparison expressions are being bound as expected\n     * when types are omitted, specifically for dialects that translate tuple comparisons.\n     *\n     * @see \\Cake\\Database\\Driver\\TupleComparisonTranslatorTrait::_transformTupleComparison()\n     * @see \\Cake\\Database\\Driver\\Sqlite::_expressionTranslators()\n     * @see \\Cake\\Database\\Driver\\Sqlserver::_expressionTranslators()\n     */\n    public function testTupleComparisonTypesCanBeOmitted(): void\n    {\n        $this->skipIf(\n            $this->connection->getDriver() instanceof Sqlserver,\n            'This test fails sporadically in SQLServer'\n        );\n\n        $query = (new Query($this->connection))\n            ->select('*')\n            ->from('profiles')\n            ->where(\n                new TupleComparison(\n                    ['id', 'user_id'],\n                    [[1, 1]],\n                    [],\n                    'IN'\n                )\n            );\n        $result = $query->execute()->fetch(StatementInterface::FETCH_TYPE_ASSOC);\n\n        $bindings = array_values($query->getValueBinder()->bindings());\n        $this->assertCount(2, $bindings);\n        $this->assertSame(1, $bindings[0]['value']);\n        $this->assertNull($bindings[0]['type']);\n        $this->assertSame(1, $bindings[1]['value']);\n        $this->assertNull($bindings[1]['type']);\n\n        $this->assertSame(1, (int)$result['id']);\n        $this->assertSame(1, (int)$result['user_id']);\n    }\n\n    /**\n     * Tests that default types are passed to functions accepting a $types param\n     */\n    public function testDefaultTypes(): void\n    {\n        $query = new Query($this->connection);\n        $this->assertEquals([], $query->getDefaultTypes());\n        $types = ['id' => 'integer', 'created' => 'datetime'];\n        $this->assertSame($query, $query->setDefaultTypes($types));\n        $this->assertSame($types, $query->getDefaultTypes());\n\n        $results = $query->select(['id', 'comment'])\n            ->from('comments')\n            ->where(['created >=' => new DateTime('2007-03-18 10:55:00')])\n            ->execute();\n        $expected = [['id' => '6', 'comment' => 'Second Comment for Second Article']];\n        $this->assertEquals($expected, $results->fetchAll('assoc'));\n\n        // Now test default can be overridden\n        $types = ['created' => 'date'];\n        $results = $query\n            ->where(['created >=' => new DateTime('2007-03-18 10:50:00')], $types, true)\n            ->execute();\n        $this->assertCount(6, $results, 'All 6 rows should match.');\n    }\n\n    /**\n     * Tests parameter binding\n     */\n    public function testBind(): void\n    {\n        $query = new Query($this->connection);\n        $results = $query->select(['id', 'comment'])\n            ->from('comments')\n            ->where(['created BETWEEN :foo AND :bar'])\n            ->bind(':foo', new DateTime('2007-03-18 10:50:00'), 'datetime')\n            ->bind(':bar', new DateTime('2007-03-18 10:52:00'), 'datetime')\n            ->execute();\n        $expected = [['id' => '4', 'comment' => 'Fourth Comment for First Article']];\n        $this->assertEquals($expected, $results->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $results = $query->select(['id', 'comment'])\n            ->from('comments')\n            ->where(['created BETWEEN :foo AND :bar'])\n            ->bind(':foo', '2007-03-18 10:50:00')\n            ->bind(':bar', '2007-03-18 10:52:00')\n            ->execute();\n        $this->assertEquals($expected, $results->fetchAll('assoc'));\n    }\n\n    /**\n     * Test that epilog() will actually append a string to a select query\n     */\n    public function testAppendSelect(): void\n    {\n        $query = new Query($this->connection);\n        $sql = $query\n            ->select(['id', 'title'])\n            ->from('articles')\n            ->where(['id' => 1])\n            ->epilog('FOR UPDATE')\n            ->sql();\n        $this->assertStringContainsString('SELECT', $sql);\n        $this->assertStringContainsString('FROM', $sql);\n        $this->assertStringContainsString('WHERE', $sql);\n        $this->assertSame(' FOR UPDATE', substr($sql, -11));\n    }\n\n    /**\n     * Test that epilog() will actually append a string to an insert query\n     */\n    public function testAppendInsert(): void\n    {\n        $query = new Query($this->connection);\n        $sql = $query\n            ->insert(['id', 'title'])\n            ->into('articles')\n            ->values([1, 'a title'])\n            ->epilog('RETURNING id')\n            ->sql();\n        $this->assertStringContainsString('INSERT', $sql);\n        $this->assertStringContainsString('INTO', $sql);\n        $this->assertStringContainsString('VALUES', $sql);\n        $this->assertSame(' RETURNING id', substr($sql, -13));\n    }\n\n    /**\n     * Test that epilog() will actually append a string to an update query\n     */\n    public function testAppendUpdate(): void\n    {\n        $query = new Query($this->connection);\n        $sql = $query\n            ->update('articles')\n            ->set(['title' => 'foo'])\n            ->where(['id' => 1])\n            ->epilog('RETURNING id')\n            ->sql();\n        $this->assertStringContainsString('UPDATE', $sql);\n        $this->assertStringContainsString('SET', $sql);\n        $this->assertStringContainsString('WHERE', $sql);\n        $this->assertSame(' RETURNING id', substr($sql, -13));\n    }\n\n    /**\n     * Test that epilog() will actually append a string to a delete query\n     */\n    public function testAppendDelete(): void\n    {\n        $query = new Query($this->connection);\n        $sql = $query\n            ->delete('articles')\n            ->where(['id' => 1])\n            ->epilog('RETURNING id')\n            ->sql();\n        $this->assertStringContainsString('DELETE FROM', $sql);\n        $this->assertStringContainsString('WHERE', $sql);\n        $this->assertSame(' RETURNING id', substr($sql, -13));\n    }\n\n    /**\n     * Tests automatic identifier quoting in the select clause\n     */\n    public function testQuotingSelectFieldsAndAlias(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select(['something'])->sql();\n        $this->assertQuotedQuery('SELECT <something>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => 'something'])->sql();\n        $this->assertQuotedQuery('SELECT <something> AS <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => 1])->sql();\n        $this->assertQuotedQuery('SELECT 1 AS <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => '1 + 1'])->sql();\n        $this->assertQuotedQuery('SELECT <1 \\+ 1> AS <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => $query->newExpr('1 + 1')])->sql();\n        $this->assertQuotedQuery('SELECT \\(1 \\+ 1\\) AS <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => new IdentifierExpression('bar')])->sql();\n        $this->assertQuotedQuery('<bar>', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting in the from clause\n     */\n    public function testQuotingFromAndAlias(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->from(['something'])->sql();\n        $this->assertQuotedQuery('FROM <something>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->from(['foo' => 'something'])->sql();\n        $this->assertQuotedQuery('FROM <something> <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->from(['foo' => $query->newExpr('bar')])->sql();\n        $this->assertQuotedQuery('FROM \\(bar\\) <foo>$', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting for DISTINCT ON\n     */\n    public function testQuotingDistinctOn(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->distinct(['something'])->sql();\n        $this->assertQuotedQuery('<something>', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting in the join clause\n     */\n    public function testQuotingJoinsAndAlias(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->join(['something'])->sql();\n        $this->assertQuotedQuery('JOIN <something>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->join(['foo' => 'something'])->sql();\n        $this->assertQuotedQuery('JOIN <something> <foo>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->join(['foo' => $query->newExpr('bar')])->sql();\n        $this->assertQuotedQuery('JOIN \\(bar\\) <foo>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->join([\n            'alias' => 'orders',\n            'table' => 'Order',\n            'conditions' => ['1 = 1'],\n        ])->sql();\n        $this->assertQuotedQuery('JOIN <Order> <orders> ON 1 = 1', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting in the group by clause\n     */\n    public function testQuotingGroupBy(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->group(['something'])->sql();\n        $this->assertQuotedQuery('GROUP BY <something>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->group([$query->newExpr('bar')])->sql();\n        $this->assertQuotedQuery('GROUP BY \\(bar\\)', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->group([new IdentifierExpression('bar')])->sql();\n        $this->assertQuotedQuery('GROUP BY \\(<bar>\\)', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting strings inside conditions expressions\n     */\n    public function testQuotingExpressions(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')\n            ->where(['something' => 'value'])\n            ->sql();\n        $this->assertQuotedQuery('WHERE <something> = :c0', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')\n            ->where([\n                'something' => 'value',\n                'OR' => ['foo' => 'bar', 'baz' => 'cake'],\n            ])\n            ->sql();\n        $this->assertQuotedQuery('<something> = :c0 AND', $sql);\n        $this->assertQuotedQuery('\\(<foo> = :c1 OR <baz> = :c2\\)', $sql);\n    }\n\n    /**\n     * Tests that insert query parts get quoted automatically\n     */\n    public function testQuotingInsert(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->insert(['bar', 'baz'])\n            ->into('foo')\n            ->where(['something' => 'value'])\n            ->sql();\n        $this->assertQuotedQuery('INSERT INTO <foo> \\(<bar>, <baz>\\)', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->insert([$query->newExpr('bar')])\n            ->into('foo')\n            ->where(['something' => 'value'])\n            ->sql();\n        $this->assertQuotedQuery('INSERT INTO <foo> \\(\\(bar\\)\\)', $sql);\n    }\n\n    /**\n     * Tests converting a query to a string\n     */\n    public function testToString(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->select(['title'])\n            ->from('articles');\n        $result = (string)$query;\n        $this->assertQuotedQuery('SELECT <title> FROM <articles>', $result, !$this->autoQuote);\n    }\n\n    /**\n     * Tests __debugInfo\n     */\n    public function testDebugInfo(): void\n    {\n        $query = (new Query($this->connection))->select('*')\n            ->from('articles')\n            ->setDefaultTypes(['id' => 'integer'])\n            ->where(['id' => '1']);\n\n        $expected = [\n            '(help)' => 'This is a Query object, to get the results execute or iterate it.',\n            'sql' => $query->sql(),\n            'params' => [\n                ':c0' => ['value' => '1', 'type' => 'integer', 'placeholder' => 'c0'],\n            ],\n            'defaultTypes' => ['id' => 'integer'],\n            'decorators' => 0,\n            'executed' => false,\n        ];\n        $result = $query->__debugInfo();\n        $this->assertEquals($expected, $result);\n\n        $query->execute();\n        $expected = [\n            '(help)' => 'This is a Query object, to get the results execute or iterate it.',\n            'sql' => $query->sql(),\n            'params' => [\n                ':c0' => ['value' => '1', 'type' => 'integer', 'placeholder' => 'c0'],\n            ],\n            'defaultTypes' => ['id' => 'integer'],\n            'decorators' => 0,\n            'executed' => true,\n        ];\n        $result = $query->__debugInfo();\n        $this->assertEquals($expected, $result);\n    }\n\n    /**\n     * Tests __debugInfo on incomplete query\n     */\n    public function testDebugInfoIncompleteQuery(): void\n    {\n        $query = (new Query($this->connection))\n            ->insert(['title']);\n        $result = $query->__debugInfo();\n        $this->assertStringContainsString('incomplete', $result['sql']);\n        $this->assertSame([], $result['params']);\n    }\n\n    /**\n     * Tests that it is possible to pass ExpressionInterface to isNull and isNotNull\n     */\n    public function testIsNullWithExpressions(): void\n    {\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('authors')\n            ->where(['id' => 1]);\n\n        $result = $query\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(function ($exp) use ($subquery) {\n                return $exp->isNotNull($subquery);\n            })\n            ->execute();\n        $this->assertNotEmpty($result->fetchAll('assoc'));\n\n        $result = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(function ($exp) use ($subquery) {\n                return $exp->isNull($subquery);\n            })\n            ->execute();\n        $this->assertEmpty($result->fetchAll('assoc'));\n    }\n\n    /**\n     * Tests that strings passed to isNull and isNotNull will be treated as identifiers\n     * when using autoQuoting\n     */\n    public function testIsNullAutoQuoting(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $query->select('*')->from('things')->where(function ($exp) {\n            return $exp->isNull('field');\n        });\n        $this->assertQuotedQuery('WHERE \\(<field>\\) IS NULL', $query->sql());\n\n        $query = new Query($this->connection);\n        $query->select('*')->from('things')->where(function ($exp) {\n            return $exp->isNotNull('field');\n        });\n        $this->assertQuotedQuery('WHERE \\(<field>\\) IS NOT NULL', $query->sql());\n    }\n\n    /**\n     * Tests that using the IS operator will automatically translate to the best\n     * possible operator depending on the passed value\n     */\n    public function testDirectIsNull(): void\n    {\n        $sql = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name IS' => null])\n            ->sql();\n        $this->assertQuotedQuery('WHERE \\(<name>\\) IS NULL', $sql, !$this->autoQuote);\n\n        $results = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name IS' => 'larry'])\n            ->execute();\n        $this->assertCount(1, $results);\n        $this->assertEquals(['name' => 'larry'], $results->fetch('assoc'));\n    }\n\n    /**\n     * Tests that using the wrong NULL operator will throw meaningful exception instead of\n     * cloaking as always-empty result set.\n     */\n    public function testIsNullInvalid(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage('Expression `name` is missing operator (IS, IS NOT) with `null` value.');\n\n        (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name' => null])\n            ->sql();\n    }\n\n    /**\n     * Tests that using the wrong NULL operator will throw meaningful exception instead of\n     * cloaking as always-empty result set.\n     */\n    public function testIsNotNullInvalid(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n\n        (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name !=' => null])\n            ->sql();\n    }\n\n    /**\n     * Tests that using the IS NOT operator will automatically translate to the best\n     * possible operator depending on the passed value\n     */\n    public function testDirectIsNotNull(): void\n    {\n        $sql = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name IS NOT' => null])\n            ->sql();\n        $this->assertQuotedQuery('WHERE \\(<name>\\) IS NOT NULL', $sql, !$this->autoQuote);\n\n        $results = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name IS NOT' => 'larry'])\n            ->execute();\n        $this->assertCount(3, $results);\n        $this->assertNotEquals(['name' => 'larry'], $results->fetch('assoc'));\n    }\n\n    /**\n     * Performs the simple update query and verifies the row count.\n     */\n    public function testRowCountAndClose(): void\n    {\n        $statementMock = $this->getMockBuilder(StatementInterface::class)\n            ->onlyMethods(['rowCount', 'closeCursor'])\n            ->getMockForAbstractClass();\n\n        $statementMock->expects($this->once())\n            ->method('rowCount')\n            ->willReturn(500);\n\n        $statementMock->expects($this->once())\n            ->method('closeCursor');\n\n        /** @var \\Cake\\ORM\\Query|\\PHPUnit\\Framework\\MockObject\\MockObject $queryMock */\n        $queryMock = $this->getMockBuilder(Query::class)\n            ->onlyMethods(['execute'])\n            ->setConstructorArgs([$this->connection])\n            ->getMock();\n\n        $queryMock->expects($this->once())\n            ->method('execute')\n            ->willReturn($statementMock);\n\n        $rowCount = $queryMock->update('authors')\n            ->set('name', 'mark')\n            ->where(['id' => 1])\n            ->rowCountAndClose();\n\n        $this->assertEquals(500, $rowCount);\n    }\n\n    /**\n     * Tests that case statements work correctly for various use-cases.\n     *\n     * @deprecated\n     */\n    public function testSqlCaseStatement(): void\n    {\n        $query = new Query($this->connection);\n        $publishedCase = null;\n        $notPublishedCase = null;\n        $this->deprecated(function () use ($query, &$publishedCase, &$notPublishedCase) {\n            $publishedCase = $query\n                ->newExpr()\n                ->addCase(\n                    $query\n                        ->newExpr()\n                        ->add(['published' => 'Y']),\n                    1,\n                    'integer'\n                );\n            $notPublishedCase = $query\n                ->newExpr()\n                ->addCase(\n                    $query\n                        ->newExpr()\n                        ->add(['published' => 'N']),\n                    1,\n                    'integer'\n                );\n        });\n\n        // Postgres requires the case statement to be cast to a integer\n        if ($this->connection->getDriver() instanceof Postgres) {\n            $publishedCase = $query->func()->cast($publishedCase, 'integer');\n            $notPublishedCase = $query->func()->cast($notPublishedCase, 'integer');\n        }\n\n        $results = $query\n            ->select([\n                'published' => $query->func()->sum($publishedCase),\n                'not_published' => $query->func()->sum($notPublishedCase),\n            ])\n            ->from(['comments'])\n            ->execute()\n            ->fetchAll('assoc');\n\n        $this->assertEquals(5, $results[0]['published']);\n        $this->assertEquals(1, $results[0]['not_published']);\n\n        $query = new Query($this->connection);\n        $query\n            ->insert(['article_id', 'user_id', 'comment', 'published'])\n            ->into('comments')\n            ->values([\n                'article_id' => 2,\n                'user_id' => 1,\n                'comment' => 'In limbo',\n                'published' => 'L',\n            ])\n            ->execute()\n            ->closeCursor();\n\n        $query = new Query($this->connection);\n        $conditions = [\n            $query\n                ->newExpr()\n                ->add(['published' => 'Y']),\n            $query\n                ->newExpr()\n                ->add(['published' => 'N']),\n        ];\n        $values = [\n            'Published',\n            'Not published',\n            'None',\n        ];\n        $this->deprecated(function () use ($query, $conditions, $values) {\n            $query\n                ->select([\n                    'id',\n                    'comment',\n                    'status' => $query->newExpr()->addCase($conditions, $values),\n                ])\n                ->from(['comments']);\n        });\n        $results = $query\n            ->execute()\n            ->fetchAll('assoc');\n\n        $this->assertSame('Published', $results[2]['status']);\n        $this->assertSame('Not published', $results[3]['status']);\n        $this->assertSame('None', $results[6]['status']);\n\n        $query = new Query($this->connection);\n        $this->deprecated(function () use ($query) {\n            $query->select(['id'])\n                ->from('articles')\n                ->orderAsc(function (QueryExpression $exp, Query $query) {\n                    return $exp->addCase(\n                        [$query->newExpr()->add(['author_id' => 1])],\n                        [1, $query->identifier('id')],\n                        ['integer', null]\n                    );\n                })\n                ->orderAsc('id');\n        });\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 1],\n            ['id' => 3],\n            ['id' => 2],\n        ];\n        $this->assertEquals($expected, $result);\n    }\n\n    /**\n     * Shows that bufferResults(false) will prevent client-side results buffering\n     */\n    public function testUnbufferedQuery(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(['body', 'author_id'])\n            ->from('articles')\n            ->enableBufferedResults(false)\n            ->execute();\n\n        if (!method_exists($result, 'bufferResults')) {\n            $result->closeCursor();\n            $this->markTestSkipped('This driver does not support unbuffered queries');\n        }\n\n        $this->assertCount(0, $result, 'Unbuffered queries only have a count when results are fetched');\n\n        $list = $result->fetchAll('assoc');\n        $this->assertCount(3, $list);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query->select(['body', 'author_id'])\n            ->from('articles')\n            ->execute();\n\n        $this->assertCount(3, $result, 'Buffered queries can be counted any time.');\n        $list = $result->fetchAll('assoc');\n        $this->assertCount(3, $list);\n        $result->closeCursor();\n    }\n\n    public function testCloneUpdateExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->update($query->newExpr('update'));\n\n        $clause = $query->clause('update');\n        $clauseClone = (clone $query)->clause('update');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneSetExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->update('table')\n            ->set(['column' => $query->newExpr('value')]);\n\n        $clause = $query->clause('set');\n        $clauseClone = (clone $query)->clause('set');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneValuesExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->insert(['column'])\n            ->into('table')\n            ->values(['column' => $query->newExpr('value')]);\n\n        $clause = $query->clause('values');\n        $clauseClone = (clone $query)->clause('values');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneWithExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->with(\n                new CommonTableExpression(\n                    'cte',\n                    new Query($this->connection)\n                )\n            )\n            ->with(function (CommonTableExpression $cte, Query $query) {\n                return $cte\n                    ->name('cte2')\n                    ->query($query);\n            });\n\n        $clause = $query->clause('with');\n        $clauseClone = (clone $query)->clause('with');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneSelectExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->select($query->newExpr('select'))\n            ->select(['alias' => $query->newExpr('select')]);\n\n        $clause = $query->clause('select');\n        $clauseClone = (clone $query)->clause('select');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneDistinctExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->distinct($query->newExpr('distinct'));\n\n        $clause = $query->clause('distinct');\n        $clauseClone = (clone $query)->clause('distinct');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneModifierExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->modifier($query->newExpr('modifier'));\n\n        $clause = $query->clause('modifier');\n        $clauseClone = (clone $query)->clause('modifier');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneFromExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->from(['alias' => new Query($this->connection)]);\n\n        $clause = $query->clause('from');\n        $clauseClone = (clone $query)->clause('from');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneJoinExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->innerJoin(\n                ['alias_inner' => new Query($this->connection)],\n                ['alias_inner.fk = parent.pk']\n            )\n            ->leftJoin(\n                ['alias_left' => new Query($this->connection)],\n                ['alias_left.fk = parent.pk']\n            )\n            ->rightJoin(\n                ['alias_right' => new Query($this->connection)],\n                ['alias_right.fk = parent.pk']\n            );\n\n        $clause = $query->clause('join');\n        $clauseClone = (clone $query)->clause('join');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value['table'], $clauseClone[$key]['table']);\n            $this->assertNotSame($value['table'], $clauseClone[$key]['table']);\n\n            $this->assertEquals($value['conditions'], $clauseClone[$key]['conditions']);\n            $this->assertNotSame($value['conditions'], $clauseClone[$key]['conditions']);\n        }\n    }\n\n    public function testCloneWhereExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->where($query->newExpr('where'))\n            ->where(['field' => $query->newExpr('where')]);\n\n        $clause = $query->clause('where');\n        $clauseClone = (clone $query)->clause('where');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneGroupExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->group($query->newExpr('group'));\n\n        $clause = $query->clause('group');\n        $clauseClone = (clone $query)->clause('group');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneHavingExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->having($query->newExpr('having'));\n\n        $clause = $query->clause('having');\n        $clauseClone = (clone $query)->clause('having');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneWindowExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->window('window1', new WindowExpression())\n            ->window('window2', function (WindowExpression $window) {\n                return $window;\n            });\n\n        $clause = $query->clause('window');\n        $clauseClone = (clone $query)->clause('window');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value['name'], $clauseClone[$key]['name']);\n            $this->assertNotSame($value['name'], $clauseClone[$key]['name']);\n\n            $this->assertEquals($value['window'], $clauseClone[$key]['window']);\n            $this->assertNotSame($value['window'], $clauseClone[$key]['window']);\n        }\n    }\n\n    public function testCloneOrderExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->order($query->newExpr('order'))\n            ->orderAsc($query->newExpr('order_asc'))\n            ->orderDesc($query->newExpr('order_desc'));\n\n        $clause = $query->clause('order');\n        $clauseClone = (clone $query)->clause('order');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneLimitExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->limit($query->newExpr('1'));\n\n        $clause = $query->clause('limit');\n        $clauseClone = (clone $query)->clause('limit');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneOffsetExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->offset($query->newExpr('1'));\n\n        $clause = $query->clause('offset');\n        $clauseClone = (clone $query)->clause('offset');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneUnionExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->where(['id' => 1]);\n\n        $query2 = new Query($this->connection);\n        $query2->where(['id' => 2]);\n\n        $query->union($query2);\n\n        $clause = $query->clause('union');\n        $clauseClone = (clone $query)->clause('union');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value['query'], $clauseClone[$key]['query']);\n            $this->assertNotSame($value['query'], $clauseClone[$key]['query']);\n        }\n    }\n\n    public function testCloneEpilogExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->epilog($query->newExpr('epilog'));\n\n        $clause = $query->clause('epilog');\n        $clauseClone = (clone $query)->clause('epilog');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    /**\n     * Test that cloning goes deep.\n     */\n    public function testDeepClone(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id', 'title' => $query->func()->concat(['title' => 'literal', 'test'])])\n            ->from('articles')\n            ->where(['Articles.id' => 1])\n            ->offset(10)\n            ->limit(1)\n            ->order(['Articles.id' => 'DESC']);\n        $dupe = clone $query;\n\n        $this->assertEquals($query->clause('where'), $dupe->clause('where'));\n        $this->assertNotSame($query->clause('where'), $dupe->clause('where'));\n        $dupe->where(['Articles.title' => 'thinger']);\n        $this->assertNotEquals($query->clause('where'), $dupe->clause('where'));\n\n        $this->assertNotSame(\n            $query->clause('select')['title'],\n            $dupe->clause('select')['title']\n        );\n        $this->assertEquals($query->clause('order'), $dupe->clause('order'));\n        $this->assertNotSame($query->clause('order'), $dupe->clause('order'));\n\n        $query->order(['Articles.title' => 'ASC']);\n        $this->assertNotEquals($query->clause('order'), $dupe->clause('order'));\n\n        $this->assertNotSame(\n            $query->getSelectTypeMap(),\n            $dupe->getSelectTypeMap()\n        );\n    }\n\n    /**\n     * Tests the selectTypeMap method\n     */\n    public function testSelectTypeMap(): void\n    {\n        $query = new Query($this->connection);\n        $typeMap = $query->getSelectTypeMap();\n        $this->assertInstanceOf(TypeMap::class, $typeMap);\n        $another = clone $typeMap;\n        $query->setSelectTypeMap($another);\n        $this->assertSame($another, $query->getSelectTypeMap());\n    }\n\n    /**\n     * Tests the automatic type conversion for the fields in the result\n     */\n    public function testSelectTypeConversion(): void\n    {\n        TypeFactory::set('custom_datetime', new BarType('custom_datetime'));\n\n        $query = new Query($this->connection);\n        $query\n            ->select(['id', 'comment', 'the_date' => 'created', 'updated'])\n            ->from('comments')\n            ->limit(1)\n            ->getSelectTypeMap()\n                ->setTypes([\n                    'id' => 'integer',\n                    'the_date' => 'datetime',\n                    'updated' => 'custom_datetime',\n                ]);\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertIsInt($result[0]['id']);\n        $this->assertInstanceOf(DateTimeImmutable::class, $result[0]['the_date']);\n        $this->assertInstanceOf(DateTimeImmutable::class, $result[0]['updated']);\n    }\n\n    /**\n     * Tests that the JSON type can save and get data symmetrically\n     */\n    public function testSymmetricJsonType(): void\n    {\n        $query = new Query($this->connection);\n        $insert = $query\n            ->insert(['comment', 'article_id', 'user_id'], ['comment' => 'json'])\n            ->into('comments')\n            ->values([\n                'comment' => ['a' => 'b', 'c' => true],\n                'article_id' => 1,\n                'user_id' => 1,\n            ])\n            ->execute();\n\n        $id = $insert->lastInsertId('comments', 'id');\n        $insert->closeCursor();\n\n        $query = new Query($this->connection);\n        $query\n            ->select(['comment'])\n            ->from('comments')\n            ->where(['id' => $id])\n            ->getSelectTypeMap()->setTypes(['comment' => 'json']);\n\n        $result = $query->execute();\n        $comment = $result->fetchAll('assoc')[0]['comment'];\n        $result->closeCursor();\n        $this->assertSame(['a' => 'b', 'c' => true], $comment);\n    }\n\n    /**\n     * Test removeJoin().\n     */\n    public function testRemoveJoin(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id', 'title'])\n            ->from('articles')\n            ->join(['authors' => [\n                'type' => 'INNER',\n                'conditions' => ['articles.author_id = authors.id'],\n            ]]);\n        $this->assertArrayHasKey('authors', $query->clause('join'));\n\n        $this->assertSame($query, $query->removeJoin('authors'));\n        $this->assertArrayNotHasKey('authors', $query->clause('join'));\n    }\n\n    /**\n     * Tests that types in the type map are used in the\n     * specific comparison functions when using a callable\n     */\n    public function testBetweenExpressionAndTypeMap(): void\n    {\n        $query = new Query($this->connection);\n        $query->select('id')\n            ->from('comments')\n            ->setDefaultTypes(['created' => 'datetime'])\n            ->where(function ($expr) {\n                $from = new DateTime('2007-03-18 10:45:00');\n                $to = new DateTime('2007-03-18 10:48:00');\n\n                return $expr->between('created', $from, $to);\n            });\n        $this->assertCount(2, $query->execute()->fetchAll());\n    }\n\n    /**\n     * Test use of modifiers in a INSERT query\n     *\n     * Testing the generated SQL since the modifiers are usually different per driver\n     */\n    public function testInsertModifiers(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->insert(['title'])\n            ->into('articles')\n            ->values(['title' => 'foo'])\n            ->modifier('IGNORE');\n        $this->assertQuotedQuery(\n            'INSERT IGNORE INTO <articles> \\(<title>\\) (OUTPUT INSERTED\\.\\* )?',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->insert(['title'])\n            ->into('articles')\n            ->values(['title' => 'foo'])\n            ->modifier(['IGNORE', 'LOW_PRIORITY']);\n        $this->assertQuotedQuery(\n            'INSERT IGNORE LOW_PRIORITY INTO <articles> \\(<title>\\) (OUTPUT INSERTED\\.\\* )?',\n            $result->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test use of modifiers in a UPDATE query\n     *\n     * Testing the generated SQL since the modifiers are usually different per driver\n     */\n    public function testUpdateModifiers(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->update('authors')\n            ->set('name', 'mark')\n            ->modifier('TOP 10 PERCENT');\n        $this->assertQuotedQuery(\n            'UPDATE TOP 10 PERCENT <authors> SET <name> = :c0',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->update('authors')\n            ->set('name', 'mark')\n            ->modifier(['TOP 10 PERCENT', 'FOO']);\n        $this->assertQuotedQuery(\n            'UPDATE TOP 10 PERCENT FOO <authors> SET <name> = :c0',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->update('authors')\n            ->set('name', 'mark')\n            ->modifier([$query->newExpr('TOP 10 PERCENT')]);\n        $this->assertQuotedQuery(\n            'UPDATE TOP 10 PERCENT <authors> SET <name> = :c0',\n            $result->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test use of modifiers in a DELETE query\n     *\n     * Testing the generated SQL since the modifiers are usually different per driver\n     */\n    public function testDeleteModifiers(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->delete()\n            ->from('authors')\n            ->where('1 = 1')\n            ->modifier('IGNORE');\n        $this->assertQuotedQuery(\n            'DELETE IGNORE FROM <authors> WHERE 1 = 1',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query->delete()\n            ->from('authors')\n            ->where('1 = 1')\n            ->modifier(['IGNORE', 'QUICK']);\n        $this->assertQuotedQuery(\n            'DELETE IGNORE QUICK FROM <authors> WHERE 1 = 1',\n            $result->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test getValueBinder()\n     */\n    public function testGetValueBinder(): void\n    {\n        $query = new Query($this->connection);\n\n        $this->assertInstanceOf('Cake\\Database\\ValueBinder', $query->getValueBinder());\n    }\n\n    /**\n     * Test automatic results casting\n     */\n    public function testCastResults(): void\n    {\n        $query = new Query($this->connection);\n        $fields = [\n            'user_id' => 'integer',\n            'is_active' => 'boolean',\n        ];\n        $typeMap = new TypeMap($fields + ['a' => 'integer']);\n        $results = $query\n            ->select(array_keys($fields))\n            ->select(['a' => 'is_active'])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->where(['user_id' => 1])\n            ->execute()\n            ->fetchAll('assoc');\n        $this->assertSame([['user_id' => 1, 'is_active' => false, 'a' => 0]], $results);\n    }\n\n    /**\n     * Test disabling type casting\n     */\n    public function testCastResultsDisable(): void\n    {\n        $query = new Query($this->connection);\n        $typeMap = new TypeMap(['a' => 'datetime']);\n        $results = $query\n            ->select(['a' => 'id'])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->limit(1)\n            ->disableResultsCasting()\n            ->execute()\n            ->fetchAll('assoc');\n        $this->assertEquals([['a' => '1']], $results);\n    }\n\n    /**\n     * Test obtaining the current results casting mode.\n     */\n    public function testObtainingResultsCastingMode(): void\n    {\n        $query = new Query($this->connection);\n\n        $this->assertTrue($query->isResultsCastingEnabled());\n\n        $query->disableResultsCasting();\n        $this->assertFalse($query->isResultsCastingEnabled());\n    }\n\n    /**\n     * Test that type conversion is only applied once.\n     */\n    public function testAllNoDuplicateTypeCasting(): void\n    {\n        $this->skipIf($this->autoQuote, 'Produces bad SQL in postgres with autoQuoting');\n        $query = new Query($this->connection);\n        $query\n            ->select('1.5 AS a')\n            ->setSelectTypeMap(new TypeMap(['a' => 'integer']));\n\n        // Convert to an array and make the query dirty again.\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals([['a' => 1]], $result);\n\n        $query->setSelectTypeMap(new TypeMap(['a' => 'float']));\n        // Get results a second time.\n        $result = $query->execute()->fetchAll('assoc');\n\n        // Had the type casting being remembered from the first time,\n        // The value would be a truncated float (1.0)\n        $this->assertEquals([['a' => 1.5]], $result);\n    }\n\n    /**\n     * Test that reading an undefined clause does not emit an error.\n     */\n    public function testClauseUndefined(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage('The \\'nope\\' clause is not defined. Valid clauses are: delete, update');\n        $query = new Query($this->connection);\n        $this->assertEmpty($query->clause('where'));\n        $query->clause('nope');\n    }\n\n    /**\n     * Assertion for comparing a table's contents with what is in it.\n     *\n     * @param string $table\n     * @param int $count\n     * @param array $rows\n     * @param array $conditions\n     */\n    public function assertTable($table, $count, $rows, $conditions = []): void\n    {\n        $result = (new Query($this->connection))->select('*')\n            ->from($table)\n            ->where($conditions)\n            ->execute();\n        $this->assertCount($count, $result, 'Row count is incorrect');\n        $this->assertEquals($rows, $result->fetchAll('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Assertion for comparing a regex pattern against a query having its identifiers\n     * quoted. It accepts queries quoted with the characters `<` and `>`. If the third\n     * parameter is set to true, it will alter the pattern to both accept quoted and\n     * unquoted queries\n     *\n     * @param string $pattern\n     * @param string $query the result to compare against\n     * @param bool $optional\n     */\n    public function assertQuotedQuery($pattern, $query, $optional = false): void\n    {\n        if ($optional) {\n            $optional = '?';\n        }\n        $pattern = str_replace('<', '[`\"\\[]' . $optional, $pattern);\n        $pattern = str_replace('>', '[`\"\\]]' . $optional, $pattern);\n        $this->assertMatchesRegularExpression('#' . $pattern . '#', $query);\n    }\n\n    /**\n     * Test that calling fetchAssoc return an associated array.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchAssoc(): void\n    {\n        $query = new Query($this->connection);\n        $fields = [\n            'id' => 'integer',\n            'user_id' => 'integer',\n            'is_active' => 'boolean',\n        ];\n        $typeMap = new TypeMap($fields);\n        $statement = $query\n            ->select([\n                'id',\n                'user_id',\n                'is_active',\n            ])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->limit(1)\n            ->execute();\n\n        $this->assertSame(['id' => 1, 'user_id' => 1, 'is_active' => false], $statement->fetchAssoc());\n        $statement->closeCursor();\n    }\n\n    /**\n     * Test that calling fetchAssoc return an empty associated array.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchAssocWithEmptyResult(): void\n    {\n        $query = new Query($this->connection);\n\n        $results = $query\n            ->select(['id'])\n            ->from('profiles')\n            ->where(['id' => -1])\n            ->execute()\n            ->fetchAssoc();\n        $this->assertSame([], $results);\n    }\n\n    /**\n     * Test that calling fetch with with FETCH_TYPE_OBJ return stdClass object.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchObjects(): void\n    {\n        $query = new Query($this->connection);\n        $stmt = $query->select([\n                'id',\n                'user_id',\n                'is_active',\n            ])\n            ->from('profiles')\n            ->limit(1)\n            ->enableBufferedResults(false)\n            ->execute();\n        $results = $stmt->fetch(StatementDecorator::FETCH_TYPE_OBJ);\n        $stmt->closeCursor();\n\n        $this->assertInstanceOf(stdClass::class, $results);\n    }\n\n    /**\n     * Test that fetchColumn() will return the correct value at $position.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchColumn(): void\n    {\n        $query = new Query($this->connection);\n        $fields = [\n            'integer',\n            'integer',\n            'boolean',\n        ];\n        $typeMap = new TypeMap($fields);\n        $query\n            ->select([\n                'id',\n                'user_id',\n                'is_active',\n            ])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->where(['id' => 2])\n            ->limit(1);\n        $statement = $query->execute();\n        $results = $statement->fetchColumn(0);\n        $this->assertSame(2, $results);\n        $statement->closeCursor();\n\n        $statement = $query->execute();\n        $results = $statement->fetchColumn(1);\n        $this->assertSame(2, $results);\n        $statement->closeCursor();\n\n        $statement = $query->execute();\n        $results = $statement->fetchColumn(2);\n        $this->assertSame(false, $results);\n        $statement->closeCursor();\n    }\n\n    /**\n     * Test that fetchColumn() will return false if $position is not set.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchColumnReturnsFalse(): void\n    {\n        $query = new Query($this->connection);\n        $fields = [\n            'integer',\n            'integer',\n            'boolean',\n        ];\n        $typeMap = new TypeMap($fields);\n        $query\n            ->select([\n                'id',\n                'user_id',\n                'is_active',\n            ])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->where(['id' => 2])\n            ->limit(1);\n        $statement = $query->execute();\n        $results = $statement->fetchColumn(3);\n        $this->assertFalse($results);\n        $statement->closeCursor();\n    }\n\n    /**\n     * Tests that query expressions can be used for ordering.\n     */\n    public function testOrderBySubquery(): void\n    {\n        $this->autoQuote = true;\n        $this->connection->getDriver()->enableAutoQuoting($this->autoQuote);\n\n        $connection = $this->connection;\n\n        $query = new Query($connection);\n\n        $stmt = $connection->update('articles', ['published' => 'N'], ['id' => 3]);\n        $stmt->closeCursor();\n\n        $subquery = new Query($connection);\n        $subquery\n            ->select(\n                $subquery->newExpr()->case()->when(['a.published' => 'N'])->then(1)->else(0)\n            )\n            ->from(['a' => 'articles'])\n            ->where([\n                'a.id = articles.id',\n            ]);\n\n        $query\n            ->select(['id'])\n            ->from('articles')\n            ->orderDesc($subquery)\n            ->orderAsc('id')\n            ->setSelectTypeMap(new TypeMap([\n                'id' => 'integer',\n            ]));\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY \\(' .\n                'SELECT \\(CASE WHEN <a>\\.<published> = \\:c0 THEN \\:c1 ELSE \\:c2 END\\) ' .\n                'FROM <articles> <a> ' .\n                'WHERE a\\.id = articles\\.id' .\n            '\\) DESC, <id> ASC',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $this->assertEquals(\n            [\n                [\n                    'id' => 3,\n                ],\n                [\n                    'id' => 1,\n                ],\n                [\n                    'id' => 2,\n                ],\n            ],\n            $query->execute()->fetchAll('assoc')\n        );\n    }\n\n    /**\n     * Test that reusing expressions will duplicate bindings and run successfully.\n     *\n     * This replicates what the SQL Server driver would do for <= SQL Server 2008\n     * when ordering on fields that are expressions.\n     *\n     * @see \\Cake\\Database\\Driver\\Sqlserver::_pagingSubquery()\n     */\n    public function testReusingExpressions(): void\n    {\n        $connection = $this->connection;\n\n        $query = new Query($connection);\n\n        $stmt = $connection->update('articles', ['published' => 'N'], ['id' => 3]);\n        $stmt->closeCursor();\n\n        $subqueryA = new Query($connection);\n        $subqueryA\n            ->select('count(*)')\n            ->from(['a' => 'articles'])\n            ->where([\n                'a.id = articles.id',\n                'a.published' => 'Y',\n            ]);\n\n        $subqueryB = new Query($connection);\n        $subqueryB\n            ->select('count(*)')\n            ->from(['b' => 'articles'])\n            ->where([\n                'b.id = articles.id',\n                'b.published' => 'N',\n            ]);\n\n        $query\n            ->select([\n                'id',\n                'computedA' => $subqueryA,\n                'computedB' => $subqueryB,\n            ])\n            ->from('articles')\n            ->orderDesc($subqueryB)\n            ->orderAsc('id')\n            ->setSelectTypeMap(new TypeMap([\n                'id' => 'integer',\n                'computedA' => 'integer',\n                'computedB' => 'integer',\n            ]));\n\n        $this->assertQuotedQuery(\n            'SELECT <id>, ' .\n                '\\(SELECT count\\(\\*\\) FROM <articles> <a> WHERE \\(a\\.id = articles\\.id AND <a>\\.<published> = :c0\\)\\) AS <computedA>, ' .\n                '\\(SELECT count\\(\\*\\) FROM <articles> <b> WHERE \\(b\\.id = articles\\.id AND <b>\\.<published> = :c1\\)\\) AS <computedB> ' .\n            'FROM <articles> ' .\n            'ORDER BY \\(' .\n                'SELECT count\\(\\*\\) FROM <articles> <b> WHERE \\(b\\.id = articles\\.id AND <b>\\.<published> = :c2\\)' .\n            '\\) DESC, <id> ASC',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $this->assertSame(\n            [\n                [\n                    'id' => 3,\n                    'computedA' => 0,\n                    'computedB' => 1,\n                ],\n                [\n                    'id' => 1,\n                    'computedA' => 1,\n                    'computedB' => 0,\n                ],\n                [\n                    'id' => 2,\n                    'computedA' => 1,\n                    'computedB' => 0,\n                ],\n            ],\n            $query->execute()->fetchAll('assoc')\n        );\n\n        $this->assertSame(\n            [\n                ':c0' => [\n                    'value' => 'Y',\n                    'type' => null,\n                    'placeholder' => 'c0',\n                ],\n                ':c1' => [\n                    'value' => 'N',\n                    'type' => null,\n                    'placeholder' => 'c1',\n                ],\n                ':c2' => [\n                    'value' => 'N',\n                    'type' => null,\n                    'placeholder' => 'c2',\n                ],\n            ],\n            $query->getValueBinder()->bindings()\n        );\n    }\n\n    /**\n     * Tests creating StringExpression.\n     */\n    public function testStringExpression(): void\n    {\n        $driver = $this->connection->getDriver();\n        $collation = null;\n        if ($driver instanceof Mysql) {\n            if (version_compare($this->connection->getDriver()->version(), '5.7.0', '<')) {\n                $collation = 'utf8_general_ci';\n            } else {\n                $collation = 'utf8mb4_general_ci';\n            }\n        } elseif ($driver instanceof Postgres) {\n            $collation = 'en_US.utf8';\n        } elseif ($driver instanceof Sqlite) {\n            $collation = 'BINARY';\n        } elseif ($driver instanceof Sqlserver) {\n            $collation = 'Latin1_general_CI_AI';\n        }\n\n        $query = new Query($this->connection);\n        if ($driver instanceof Postgres) {\n            // Older postgres versions throw an error on the parameter type without a cast\n            $query->select(['test_string' => $query->func()->cast(new StringExpression('testString', $collation), 'text')]);\n            $expected = \"SELECT \\(CAST\\(:c0 COLLATE \\\"{$collation}\\\" AS text\\)\\) AS <test_string>\";\n        } else {\n            $query->select(['test_string' => new StringExpression('testString', $collation)]);\n            $expected = \"SELECT \\(:c0 COLLATE {$collation}\\) AS <test_string>\";\n        }\n        $this->assertRegExpSql($expected, $query->sql(new ValueBinder()), !$this->autoQuote);\n\n        $statement = $query->execute();\n        $this->assertSame('testString', $statement->fetchColumn(0));\n        $statement->closeCursor();\n    }\n\n    /**\n     * Tests setting identifier collation.\n     */\n    public function testIdentifierCollation(): void\n    {\n        $driver = $this->connection->getDriver();\n        $collation = null;\n        if ($driver instanceof Mysql) {\n            if (version_compare($this->connection->getDriver()->version(), '5.7.0', '<')) {\n                $collation = 'utf8_general_ci';\n            } else {\n                $collation = 'utf8mb4_general_ci';\n            }\n        } elseif ($driver instanceof Postgres) {\n            $collation = 'en_US.utf8';\n        } elseif ($driver instanceof Sqlite) {\n            $collation = 'BINARY';\n        } elseif ($driver instanceof Sqlserver) {\n            $collation = 'Latin1_general_CI_AI';\n        }\n\n        $query = (new Query($this->connection))\n            ->select(['test_string' => new IdentifierExpression('title', $collation)])\n            ->from('articles')\n            ->where(['id' => 1]);\n\n        if ($driver instanceof Postgres) {\n            // Older postgres versions throw an error on the parameter type without a cast\n            $expected = \"SELECT \\(<title> COLLATE \\\"{$collation}\\\"\\) AS <test_string>\";\n        } else {\n            $expected = \"SELECT \\(<title> COLLATE {$collation}\\) AS <test_string>\";\n        }\n        $this->assertRegExpSql($expected, $query->sql(new ValueBinder()), !$this->autoQuote);\n\n        $statement = $query->execute();\n        $this->assertSame('First Article', $statement->fetchColumn(0));\n        $statement->closeCursor();\n    }\n\n    /**\n     * Simple expressions from the point of view of the query expression\n     * object are expressions where the field contains one space at most.\n     */\n    public function testOperatorsInSimpleConditionsAreCaseInsensitive(): void\n    {\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('articles')\n            ->where(['id in' => [1, 2, 3]]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE <id> in \\(:c0,:c1,:c2\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('articles')\n            ->where(['id IN' => [1, 2, 3]]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE <id> in \\(:c0,:c1,:c2\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Complex expressions from the point of view of the query expression\n     * object are expressions where the field contains multiple spaces.\n     */\n    public function testOperatorsInComplexConditionsAreCaseInsensitive(): void\n    {\n        $this->skipIf($this->autoQuote, 'Does not work when autoquoting is enabled.');\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('profiles')\n            ->where(['CONCAT(first_name, \" \", last_name) in' => ['foo bar', 'baz 42']]);\n\n        $this->assertSame(\n            'SELECT id FROM profiles WHERE CONCAT\\(first_name, \" \", last_name\\) in \\(:c0,:c1\\)',\n            $query->sql()\n        );\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('profiles')\n            ->where(['CONCAT(first_name, \" \", last_name) IN' => ['foo bar', 'baz 42']]);\n\n        $this->assertSame(\n            'SELECT id FROM profiles WHERE CONCAT\\(first_name, \" \", last_name\\) in \\(:c0,:c1\\)',\n            $query->sql()\n        );\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('profiles')\n            ->where(['CONCAT(first_name, \" \", last_name) not in' => ['foo bar', 'baz 42']]);\n\n        $this->assertSame(\n            'SELECT id FROM profiles WHERE CONCAT\\(first_name, \" \", last_name\\) not in \\(:c0,:c1\\)',\n            $query->sql()\n        );\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('profiles')\n            ->where(['CONCAT(first_name, \" \", last_name) NOT IN' => ['foo bar', 'baz 42']]);\n\n        $this->assertSame(\n            'SELECT id FROM profiles WHERE CONCAT\\(first_name, \" \", last_name\\) not in \\(:c0,:c1\\)',\n            $query->sql()\n        );\n    }\n}\n"], "fixing_code": ["<?php\ndeclare(strict_types=1);\n\n/**\n * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)\n * @link          https://cakephp.org CakePHP(tm) Project\n * @since         3.0.0\n * @license       https://opensource.org/licenses/mit-license.php MIT License\n */\nnamespace Cake\\Database;\n\nuse Cake\\Database\\Exception\\DatabaseException;\nuse Cake\\Database\\Expression\\CommonTableExpression;\nuse Cake\\Database\\Expression\\IdentifierExpression;\nuse Cake\\Database\\Expression\\OrderByExpression;\nuse Cake\\Database\\Expression\\OrderClauseExpression;\nuse Cake\\Database\\Expression\\QueryExpression;\nuse Cake\\Database\\Expression\\ValuesExpression;\nuse Cake\\Database\\Expression\\WindowExpression;\nuse Cake\\Database\\Statement\\CallbackStatement;\nuse Closure;\nuse InvalidArgumentException;\nuse IteratorAggregate;\nuse RuntimeException;\n\n/**\n * This class represents a Relational database SQL Query. A query can be of\n * different types like select, update, insert and delete. Exposes the methods\n * for dynamically constructing each query part, execute it and transform it\n * to a specific SQL dialect.\n */\nclass Query implements ExpressionInterface, IteratorAggregate\n{\n    use TypeMapTrait;\n\n    /**\n     * @var string\n     */\n    public const JOIN_TYPE_INNER = 'INNER';\n\n    /**\n     * @var string\n     */\n    public const JOIN_TYPE_LEFT = 'LEFT';\n\n    /**\n     * @var string\n     */\n    public const JOIN_TYPE_RIGHT = 'RIGHT';\n\n    /**\n     * Connection instance to be used to execute this query.\n     *\n     * @var \\Cake\\Database\\Connection\n     */\n    protected $_connection;\n\n    /**\n     * Type of this query (select, insert, update, delete).\n     *\n     * @var string\n     */\n    protected $_type = 'select';\n\n    /**\n     * List of SQL parts that will be used to build this query.\n     *\n     * @var array<string, mixed>\n     */\n    protected $_parts = [\n        'delete' => true,\n        'update' => [],\n        'set' => [],\n        'insert' => [],\n        'values' => [],\n        'with' => [],\n        'select' => [],\n        'distinct' => false,\n        'modifier' => [],\n        'from' => [],\n        'join' => [],\n        'where' => null,\n        'group' => [],\n        'having' => null,\n        'window' => [],\n        'order' => null,\n        'limit' => null,\n        'offset' => null,\n        'union' => [],\n        'epilog' => null,\n    ];\n\n    /**\n     * The list of query clauses to traverse for generating a SELECT statement\n     *\n     * @var array<string>\n     * @deprecated 4.4.3 This property is unused.\n     */\n    protected $_selectParts = [\n        'with', 'select', 'from', 'join', 'where', 'group', 'having', 'order', 'limit',\n        'offset', 'union', 'epilog',\n    ];\n\n    /**\n     * The list of query clauses to traverse for generating an UPDATE statement\n     *\n     * @var array<string>\n     * @deprecated 4.4.3 This property is unused.\n     */\n    protected $_updateParts = ['with', 'update', 'set', 'where', 'epilog'];\n\n    /**\n     * The list of query clauses to traverse for generating a DELETE statement\n     *\n     * @var array<string>\n     * @deprecated 4.4.3 This property is unused.\n     */\n    protected $_deleteParts = ['with', 'delete', 'modifier', 'from', 'where', 'epilog'];\n\n    /**\n     * The list of query clauses to traverse for generating an INSERT statement\n     *\n     * @var array<string>\n     * @deprecated 4.4.3 This property is unused.\n     */\n    protected $_insertParts = ['with', 'insert', 'values', 'epilog'];\n\n    /**\n     * Indicates whether internal state of this query was changed, this is used to\n     * discard internal cached objects such as the transformed query or the reference\n     * to the executed statement.\n     *\n     * @var bool\n     */\n    protected $_dirty = false;\n\n    /**\n     * A list of callback functions to be called to alter each row from resulting\n     * statement upon retrieval. Each one of the callback function will receive\n     * the row array as first argument.\n     *\n     * @var array<callable>\n     */\n    protected $_resultDecorators = [];\n\n    /**\n     * Statement object resulting from executing this query.\n     *\n     * @var \\Cake\\Database\\StatementInterface|null\n     */\n    protected $_iterator;\n\n    /**\n     * The object responsible for generating query placeholders and temporarily store values\n     * associated to each of those.\n     *\n     * @var \\Cake\\Database\\ValueBinder|null\n     */\n    protected $_valueBinder;\n\n    /**\n     * Instance of functions builder object used for generating arbitrary SQL functions.\n     *\n     * @var \\Cake\\Database\\FunctionsBuilder|null\n     */\n    protected $_functionsBuilder;\n\n    /**\n     * Boolean for tracking whether buffered results\n     * are enabled.\n     *\n     * @var bool\n     */\n    protected $_useBufferedResults = true;\n\n    /**\n     * The Type map for fields in the select clause\n     *\n     * @var \\Cake\\Database\\TypeMap|null\n     */\n    protected $_selectTypeMap;\n\n    /**\n     * Tracking flag to disable casting\n     *\n     * @var bool\n     */\n    protected $typeCastEnabled = true;\n\n    /**\n     * Constructor.\n     *\n     * @param \\Cake\\Database\\Connection $connection The connection\n     * object to be used for transforming and executing this query\n     */\n    public function __construct(Connection $connection)\n    {\n        $this->setConnection($connection);\n    }\n\n    /**\n     * Sets the connection instance to be used for executing and transforming this query.\n     *\n     * @param \\Cake\\Database\\Connection $connection Connection instance\n     * @return $this\n     */\n    public function setConnection(Connection $connection)\n    {\n        $this->_dirty();\n        $this->_connection = $connection;\n\n        return $this;\n    }\n\n    /**\n     * Gets the connection instance to be used for executing and transforming this query.\n     *\n     * @return \\Cake\\Database\\Connection\n     */\n    public function getConnection(): Connection\n    {\n        return $this->_connection;\n    }\n\n    /**\n     * Compiles the SQL representation of this query and executes it using the\n     * configured connection object. Returns the resulting statement object.\n     *\n     * Executing a query internally executes several steps, the first one is\n     * letting the connection transform this object to fit its particular dialect,\n     * this might result in generating a different Query object that will be the one\n     * to actually be executed. Immediately after, literal values are passed to the\n     * connection so they are bound to the query in a safe way. Finally, the resulting\n     * statement is decorated with custom objects to execute callbacks for each row\n     * retrieved if necessary.\n     *\n     * Resulting statement is traversable, so it can be used in any loop as you would\n     * with an array.\n     *\n     * This method can be overridden in query subclasses to decorate behavior\n     * around query execution.\n     *\n     * @return \\Cake\\Database\\StatementInterface\n     */\n    public function execute(): StatementInterface\n    {\n        $statement = $this->_connection->run($this);\n        $this->_iterator = $this->_decorateStatement($statement);\n        $this->_dirty = false;\n\n        return $this->_iterator;\n    }\n\n    /**\n     * Executes the SQL of this query and immediately closes the statement before returning the row count of records\n     * changed.\n     *\n     * This method can be used with UPDATE and DELETE queries, but is not recommended for SELECT queries and is not\n     * used to count records.\n     *\n     * ## Example\n     *\n     * ```\n     * $rowCount = $query->update('articles')\n     *                 ->set(['published'=>true])\n     *                 ->where(['published'=>false])\n     *                 ->rowCountAndClose();\n     * ```\n     *\n     * The above example will change the published column to true for all false records, and return the number of\n     * records that were updated.\n     *\n     * @return int\n     */\n    public function rowCountAndClose(): int\n    {\n        $statement = $this->execute();\n        try {\n            return $statement->rowCount();\n        } finally {\n            $statement->closeCursor();\n        }\n    }\n\n    /**\n     * Returns the SQL representation of this object.\n     *\n     * This function will compile this query to make it compatible\n     * with the SQL dialect that is used by the connection, This process might\n     * add, remove or alter any query part or internal expression to make it\n     * executable in the target platform.\n     *\n     * The resulting query may have placeholders that will be replaced with the actual\n     * values when the query is executed, hence it is most suitable to use with\n     * prepared statements.\n     *\n     * @param \\Cake\\Database\\ValueBinder|null $binder Value binder that generates parameter placeholders\n     * @return string\n     */\n    public function sql(?ValueBinder $binder = null): string\n    {\n        if (!$binder) {\n            $binder = $this->getValueBinder();\n            $binder->resetCount();\n        }\n\n        return $this->getConnection()->compileQuery($this, $binder);\n    }\n\n    /**\n     * Will iterate over every specified part. Traversing functions can aggregate\n     * results using variables in the closure or instance variables. This function\n     * is commonly used as a way for traversing all query parts that\n     * are going to be used for constructing a query.\n     *\n     * The callback will receive 2 parameters, the first one is the value of the query\n     * part that is being iterated and the second the name of such part.\n     *\n     * ### Example\n     * ```\n     * $query->select(['title'])->from('articles')->traverse(function ($value, $clause) {\n     *     if ($clause === 'select') {\n     *         var_dump($value);\n     *     }\n     * });\n     * ```\n     *\n     * @param callable $callback A function or callable to be executed for each part\n     * @return $this\n     */\n    public function traverse($callback)\n    {\n        foreach ($this->_parts as $name => $part) {\n            $callback($part, $name);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Will iterate over the provided parts.\n     *\n     * Traversing functions can aggregate results using variables in the closure\n     * or instance variables. This method can be used to traverse a subset of\n     * query parts in order to render a SQL query.\n     *\n     * The callback will receive 2 parameters, the first one is the value of the query\n     * part that is being iterated and the second the name of such part.\n     *\n     * ### Example\n     *\n     * ```\n     * $query->select(['title'])->from('articles')->traverse(function ($value, $clause) {\n     *     if ($clause === 'select') {\n     *         var_dump($value);\n     *     }\n     * }, ['select', 'from']);\n     * ```\n     *\n     * @param callable $visitor A function or callable to be executed for each part\n     * @param array<string> $parts The list of query parts to traverse\n     * @return $this\n     */\n    public function traverseParts(callable $visitor, array $parts)\n    {\n        foreach ($parts as $name) {\n            $visitor($this->_parts[$name], $name);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Adds a new common table expression (CTE) to the query.\n     *\n     * ### Examples:\n     *\n     * Common table expressions can either be passed as preconstructed expression\n     * objects:\n     *\n     * ```\n     * $cte = new \\Cake\\Database\\Expression\\CommonTableExpression(\n     *     'cte',\n     *     $connection\n     *         ->newQuery()\n     *         ->select('*')\n     *         ->from('articles')\n     * );\n     *\n     * $query->with($cte);\n     * ```\n     *\n     * or returned from a closure, which will receive a new common table expression\n     * object as the first argument, and a new blank query object as\n     * the second argument:\n     *\n     * ```\n     * $query->with(function (\n     *     \\Cake\\Database\\Expression\\CommonTableExpression $cte,\n     *     \\Cake\\Database\\Query $query\n     *  ) {\n     *     $cteQuery = $query\n     *         ->select('*')\n     *         ->from('articles');\n     *\n     *     return $cte\n     *         ->name('cte')\n     *         ->query($cteQuery);\n     * });\n     * ```\n     *\n     * @param \\Cake\\Database\\Expression\\CommonTableExpression|\\Closure $cte The CTE to add.\n     * @param bool $overwrite Whether to reset the list of CTEs.\n     * @return $this\n     */\n    public function with($cte, bool $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['with'] = [];\n        }\n\n        if ($cte instanceof Closure) {\n            $query = $this->getConnection()->newQuery();\n            $cte = $cte(new CommonTableExpression(), $query);\n            if (!($cte instanceof CommonTableExpression)) {\n                throw new RuntimeException(\n                    'You must return a `CommonTableExpression` from a Closure passed to `with()`.'\n                );\n            }\n        }\n\n        $this->_parts['with'][] = $cte;\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds new fields to be returned by a `SELECT` statement when this query is\n     * executed. Fields can be passed as an array of strings, array of expression\n     * objects, a single expression or a single string.\n     *\n     * If an array is passed, keys will be used to alias fields using the value as the\n     * real field to be aliased. It is possible to alias strings, Expression objects or\n     * even other Query objects.\n     *\n     * If a callable function is passed, the returning array of the function will\n     * be used as the list of fields.\n     *\n     * By default this function will append any passed argument to the list of fields\n     * to be selected, unless the second argument is set to true.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $query->select(['id', 'title']); // Produces SELECT id, title\n     * $query->select(['author' => 'author_id']); // Appends author: SELECT id, title, author_id as author\n     * $query->select('id', true); // Resets the list: SELECT id\n     * $query->select(['total' => $countQuery]); // SELECT id, (SELECT ...) AS total\n     * $query->select(function ($query) {\n     *     return ['article_id', 'total' => $query->count('*')];\n     * })\n     * ```\n     *\n     * By default no fields are selected, if you have an instance of `Cake\\ORM\\Query` and try to append\n     * fields you should also call `Cake\\ORM\\Query::enableAutoFields()` to select the default fields\n     * from the table.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|callable|array|string $fields fields to be added to the list.\n     * @param bool $overwrite whether to reset fields with passed list or not\n     * @return $this\n     */\n    public function select($fields = [], bool $overwrite = false)\n    {\n        if (!is_string($fields) && is_callable($fields)) {\n            $fields = $fields($this);\n        }\n\n        if (!is_array($fields)) {\n            $fields = [$fields];\n        }\n\n        if ($overwrite) {\n            $this->_parts['select'] = $fields;\n        } else {\n            $this->_parts['select'] = array_merge($this->_parts['select'], $fields);\n        }\n\n        $this->_dirty();\n        $this->_type = 'select';\n\n        return $this;\n    }\n\n    /**\n     * Adds a `DISTINCT` clause to the query to remove duplicates from the result set.\n     * This clause can only be used for select statements.\n     *\n     * If you wish to filter duplicates based of those rows sharing a particular field\n     * or set of fields, you may pass an array of fields to filter on. Beware that\n     * this option might not be fully supported in all database systems.\n     *\n     * ### Examples:\n     *\n     * ```\n     * // Filters products with the same name and city\n     * $query->select(['name', 'city'])->from('products')->distinct();\n     *\n     * // Filters products in the same city\n     * $query->distinct(['city']);\n     * $query->distinct('city');\n     *\n     * // Filter products with the same name\n     * $query->distinct(['name'], true);\n     * $query->distinct('name', true);\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string|bool $on Enable/disable distinct class\n     * or list of fields to be filtered on\n     * @param bool $overwrite whether to reset fields with passed list or not\n     * @return $this\n     */\n    public function distinct($on = [], $overwrite = false)\n    {\n        if ($on === []) {\n            $on = true;\n        } elseif (is_string($on)) {\n            $on = [$on];\n        }\n\n        if (is_array($on)) {\n            $merge = [];\n            if (is_array($this->_parts['distinct'])) {\n                $merge = $this->_parts['distinct'];\n            }\n            $on = $overwrite ? array_values($on) : array_merge($merge, array_values($on));\n        }\n\n        $this->_parts['distinct'] = $on;\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple `SELECT` modifiers to be used in the `SELECT`.\n     *\n     * By default this function will append any passed argument to the list of modifiers\n     * to be applied, unless the second argument is set to true.\n     *\n     * ### Example:\n     *\n     * ```\n     * // Ignore cache query in MySQL\n     * $query->select(['name', 'city'])->from('products')->modifier('SQL_NO_CACHE');\n     * // It will produce the SQL: SELECT SQL_NO_CACHE name, city FROM products\n     *\n     * // Or with multiple modifiers\n     * $query->select(['name', 'city'])->from('products')->modifier(['HIGH_PRIORITY', 'SQL_NO_CACHE']);\n     * // It will produce the SQL: SELECT HIGH_PRIORITY SQL_NO_CACHE name, city FROM products\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $modifiers modifiers to be applied to the query\n     * @param bool $overwrite whether to reset order with field list or not\n     * @return $this\n     */\n    public function modifier($modifiers, $overwrite = false)\n    {\n        $this->_dirty();\n        if ($overwrite) {\n            $this->_parts['modifier'] = [];\n        }\n        if (!is_array($modifiers)) {\n            $modifiers = [$modifiers];\n        }\n        $this->_parts['modifier'] = array_merge($this->_parts['modifier'], $modifiers);\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple tables to be used in the FROM clause for this query.\n     * Tables can be passed as an array of strings, array of expression\n     * objects, a single expression or a single string.\n     *\n     * If an array is passed, keys will be used to alias tables using the value as the\n     * real field to be aliased. It is possible to alias strings, ExpressionInterface objects or\n     * even other Query objects.\n     *\n     * By default this function will append any passed argument to the list of tables\n     * to be selected from, unless the second argument is set to true.\n     *\n     * This method can be used for select, update and delete statements.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $query->from(['p' => 'posts']); // Produces FROM posts p\n     * $query->from('authors'); // Appends authors: FROM posts p, authors\n     * $query->from(['products'], true); // Resets the list: FROM products\n     * $query->from(['sub' => $countQuery]); // FROM (SELECT ...) sub\n     * ```\n     *\n     * @param array|string $tables tables to be added to the list. This argument, can be\n     *  passed as an array of strings, array of expression objects, or a single string. See\n     *  the examples above for the valid call types.\n     * @param bool $overwrite whether to reset tables with passed list or not\n     * @return $this\n     */\n    public function from($tables = [], $overwrite = false)\n    {\n        $tables = (array)$tables;\n\n        if ($overwrite) {\n            $this->_parts['from'] = $tables;\n        } else {\n            $this->_parts['from'] = array_merge($this->_parts['from'], $tables);\n        }\n\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple tables to be used as JOIN clauses to this query.\n     * Tables can be passed as an array of strings, an array describing the\n     * join parts, an array with multiple join descriptions, or a single string.\n     *\n     * By default this function will append any passed argument to the list of tables\n     * to be joined, unless the third argument is set to true.\n     *\n     * When no join type is specified an `INNER JOIN` is used by default:\n     * `$query->join(['authors'])` will produce `INNER JOIN authors ON 1 = 1`\n     *\n     * It is also possible to alias joins using the array key:\n     * `$query->join(['a' => 'authors'])` will produce `INNER JOIN authors a ON 1 = 1`\n     *\n     * A join can be fully described and aliased using the array notation:\n     *\n     * ```\n     * $query->join([\n     *     'a' => [\n     *         'table' => 'authors',\n     *         'type' => 'LEFT',\n     *         'conditions' => 'a.id = b.author_id'\n     *     ]\n     * ]);\n     * // Produces LEFT JOIN authors a ON a.id = b.author_id\n     * ```\n     *\n     * You can even specify multiple joins in an array, including the full description:\n     *\n     * ```\n     * $query->join([\n     *     'a' => [\n     *         'table' => 'authors',\n     *         'type' => 'LEFT',\n     *         'conditions' => 'a.id = b.author_id'\n     *     ],\n     *     'p' => [\n     *         'table' => 'publishers',\n     *         'type' => 'INNER',\n     *         'conditions' => 'p.id = b.publisher_id AND p.name = \"Cake Software Foundation\"'\n     *     ]\n     * ]);\n     * // LEFT JOIN authors a ON a.id = b.author_id\n     * // INNER JOIN publishers p ON p.id = b.publisher_id AND p.name = \"Cake Software Foundation\"\n     * ```\n     *\n     * ### Using conditions and types\n     *\n     * Conditions can be expressed, as in the examples above, using a string for comparing\n     * columns, or string with already quoted literal values. Additionally it is\n     * possible to use conditions expressed in arrays or expression objects.\n     *\n     * When using arrays for expressing conditions, it is often desirable to convert\n     * the literal values to the correct database representation. This is achieved\n     * using the second parameter of this function.\n     *\n     * ```\n     * $query->join(['a' => [\n     *     'table' => 'articles',\n     *     'conditions' => [\n     *         'a.posted >=' => new DateTime('-3 days'),\n     *         'a.published' => true,\n     *         'a.author_id = authors.id'\n     *     ]\n     * ]], ['a.posted' => 'datetime', 'a.published' => 'boolean'])\n     * ```\n     *\n     * ### Overwriting joins\n     *\n     * When creating aliased joins using the array notation, you can override\n     * previous join definitions by using the same alias in consequent\n     * calls to this function or you can replace all previously defined joins\n     * with another list if the third parameter for this function is set to true.\n     *\n     * ```\n     * $query->join(['alias' => 'table']); // joins table with as alias\n     * $query->join(['alias' => 'another_table']); // joins another_table with as alias\n     * $query->join(['something' => 'different_table'], [], true); // resets joins list\n     * ```\n     *\n     * @param array<string, mixed>|string $tables list of tables to be joined in the query\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @param bool $overwrite whether to reset joins with passed list or not\n     * @see \\Cake\\Database\\TypeFactory\n     * @return $this\n     */\n    public function join($tables, $types = [], $overwrite = false)\n    {\n        if (is_string($tables) || isset($tables['table'])) {\n            $tables = [$tables];\n        }\n\n        $joins = [];\n        $i = count($this->_parts['join']);\n        foreach ($tables as $alias => $t) {\n            if (!is_array($t)) {\n                $t = ['table' => $t, 'conditions' => $this->newExpr()];\n            }\n\n            if (!is_string($t['conditions']) && is_callable($t['conditions'])) {\n                $t['conditions'] = $t['conditions']($this->newExpr(), $this);\n            }\n\n            if (!($t['conditions'] instanceof ExpressionInterface)) {\n                $t['conditions'] = $this->newExpr()->add($t['conditions'], $types);\n            }\n            $alias = is_string($alias) ? $alias : null;\n            $joins[$alias ?: $i++] = $t + ['type' => static::JOIN_TYPE_INNER, 'alias' => $alias];\n        }\n\n        if ($overwrite) {\n            $this->_parts['join'] = $joins;\n        } else {\n            $this->_parts['join'] = array_merge($this->_parts['join'], $joins);\n        }\n\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Remove a join if it has been defined.\n     *\n     * Useful when you are redefining joins or want to re-order\n     * the join clauses.\n     *\n     * @param string $name The alias/name of the join to remove.\n     * @return $this\n     */\n    public function removeJoin(string $name)\n    {\n        unset($this->_parts['join'][$name]);\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a single `LEFT JOIN` clause to the query.\n     *\n     * This is a shorthand method for building joins via `join()`.\n     *\n     * The table name can be passed as a string, or as an array in case it needs to\n     * be aliased:\n     *\n     * ```\n     * // LEFT JOIN authors ON authors.id = posts.author_id\n     * $query->leftJoin('authors', 'authors.id = posts.author_id');\n     *\n     * // LEFT JOIN authors a ON a.id = posts.author_id\n     * $query->leftJoin(['a' => 'authors'], 'a.id = posts.author_id');\n     * ```\n     *\n     * Conditions can be passed as strings, arrays, or expression objects. When\n     * using arrays it is possible to combine them with the `$types` parameter\n     * in order to define how to convert the values:\n     *\n     * ```\n     * $query->leftJoin(['a' => 'articles'], [\n     *      'a.posted >=' => new DateTime('-3 days'),\n     *      'a.published' => true,\n     *      'a.author_id = authors.id'\n     * ], ['a.posted' => 'datetime', 'a.published' => 'boolean']);\n     * ```\n     *\n     * See `join()` for further details on conditions and types.\n     *\n     * @param array<string, mixed>|string $table The table to join with\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $conditions The conditions\n     * to use for joining.\n     * @param array $types a list of types associated to the conditions used for converting\n     * values to the corresponding database representation.\n     * @return $this\n     */\n    public function leftJoin($table, $conditions = [], $types = [])\n    {\n        $this->join($this->_makeJoin($table, $conditions, static::JOIN_TYPE_LEFT), $types);\n\n        return $this;\n    }\n\n    /**\n     * Adds a single `RIGHT JOIN` clause to the query.\n     *\n     * This is a shorthand method for building joins via `join()`.\n     *\n     * The arguments of this method are identical to the `leftJoin()` shorthand, please refer\n     * to that methods description for further details.\n     *\n     * @param array<string, mixed>|string $table The table to join with\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $conditions The conditions\n     * to use for joining.\n     * @param array $types a list of types associated to the conditions used for converting\n     * values to the corresponding database representation.\n     * @return $this\n     */\n    public function rightJoin($table, $conditions = [], $types = [])\n    {\n        $this->join($this->_makeJoin($table, $conditions, static::JOIN_TYPE_RIGHT), $types);\n\n        return $this;\n    }\n\n    /**\n     * Adds a single `INNER JOIN` clause to the query.\n     *\n     * This is a shorthand method for building joins via `join()`.\n     *\n     * The arguments of this method are identical to the `leftJoin()` shorthand, please refer\n     * to that method's description for further details.\n     *\n     * @param array<string, mixed>|string $table The table to join with\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $conditions The conditions\n     * to use for joining.\n     * @param array<string, string> $types a list of types associated to the conditions used for converting\n     * values to the corresponding database representation.\n     * @return $this\n     */\n    public function innerJoin($table, $conditions = [], $types = [])\n    {\n        $this->join($this->_makeJoin($table, $conditions, static::JOIN_TYPE_INNER), $types);\n\n        return $this;\n    }\n\n    /**\n     * Returns an array that can be passed to the join method describing a single join clause\n     *\n     * @param array<string, mixed>|string $table The table to join with\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $conditions The conditions\n     * to use for joining.\n     * @param string $type the join type to use\n     * @return array\n     * @psalm-suppress InvalidReturnType\n     */\n    protected function _makeJoin($table, $conditions, $type): array\n    {\n        $alias = $table;\n\n        if (is_array($table)) {\n            $alias = key($table);\n            $table = current($table);\n        }\n\n        /**\n         * @psalm-suppress InvalidArrayOffset\n         * @psalm-suppress InvalidReturnStatement\n         */\n        return [\n            $alias => [\n                'table' => $table,\n                'conditions' => $conditions,\n                'type' => $type,\n            ],\n        ];\n    }\n\n    /**\n     * Adds a condition or set of conditions to be used in the WHERE clause for this\n     * query. Conditions can be expressed as an array of fields as keys with\n     * comparison operators in it, the values for the array will be used for comparing\n     * the field to such literal. Finally, conditions can be expressed as a single\n     * string or an array of strings.\n     *\n     * When using arrays, each entry will be joined to the rest of the conditions using\n     * an `AND` operator. Consecutive calls to this function will also join the new\n     * conditions specified using the AND operator. Additionally, values can be\n     * expressed using expression objects which can include other query objects.\n     *\n     * Any conditions created with this methods can be used with any `SELECT`, `UPDATE`\n     * and `DELETE` type of queries.\n     *\n     * ### Conditions using operators:\n     *\n     * ```\n     * $query->where([\n     *     'posted >=' => new DateTime('3 days ago'),\n     *     'title LIKE' => 'Hello W%',\n     *     'author_id' => 1,\n     * ], ['posted' => 'datetime']);\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE posted >= 2012-01-27 AND title LIKE 'Hello W%' AND author_id = 1`\n     *\n     * Second parameter is used to specify what type is expected for each passed\n     * key. Valid types can be used from the mapped with Database\\Type class.\n     *\n     * ### Nesting conditions with conjunctions:\n     *\n     * ```\n     * $query->where([\n     *     'author_id !=' => 1,\n     *     'OR' => ['published' => true, 'posted <' => new DateTime('now')],\n     *     'NOT' => ['title' => 'Hello']\n     * ], ['published' => boolean, 'posted' => 'datetime']\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE author_id = 1 AND (published = 1 OR posted < '2012-02-01') AND NOT (title = 'Hello')`\n     *\n     * You can nest conditions using conjunctions as much as you like. Sometimes, you\n     * may want to define 2 different options for the same key, in that case, you can\n     * wrap each condition inside a new array:\n     *\n     * `$query->where(['OR' => [['published' => false], ['published' => true]])`\n     *\n     * Would result in:\n     *\n     * `WHERE (published = false) OR (published = true)`\n     *\n     * Keep in mind that every time you call where() with the third param set to false\n     * (default), it will join the passed conditions to the previous stored list using\n     * the `AND` operator. Also, using the same array key twice in consecutive calls to\n     * this method will not override the previous value.\n     *\n     * ### Using expressions objects:\n     *\n     * ```\n     * $exp = $query->newExpr()->add(['id !=' => 100, 'author_id' != 1])->tieWith('OR');\n     * $query->where(['published' => true], ['published' => 'boolean'])->where($exp);\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE (id != 100 OR author_id != 1) AND published = 1`\n     *\n     * Other Query objects that be used as conditions for any field.\n     *\n     * ### Adding conditions in multiple steps:\n     *\n     * You can use callable functions to construct complex expressions, functions\n     * receive as first argument a new QueryExpression object and this query instance\n     * as second argument. Functions must return an expression object, that will be\n     * added the list of conditions for the query using the `AND` operator.\n     *\n     * ```\n     * $query\n     *   ->where(['title !=' => 'Hello World'])\n     *   ->where(function ($exp, $query) {\n     *     $or = $exp->or(['id' => 1]);\n     *     $and = $exp->and(['id >' => 2, 'id <' => 10]);\n     *    return $or->add($and);\n     *   });\n     * ```\n     *\n     * * The previous example produces:\n     *\n     * `WHERE title != 'Hello World' AND (id = 1 OR (id > 2 AND id < 10))`\n     *\n     * ### Conditions as strings:\n     *\n     * ```\n     * $query->where(['articles.author_id = authors.id', 'modified IS NULL']);\n     * ```\n     *\n     * The previous example produces:\n     *\n     * `WHERE articles.author_id = authors.id AND modified IS NULL`\n     *\n     * Please note that when using the array notation or the expression objects, all\n     * *values* will be correctly quoted and transformed to the correspondent database\n     * data type automatically for you, thus securing your application from SQL injections.\n     * The keys however, are not treated as unsafe input, and should be validated/sanitized.\n     *\n     * If you use string conditions make sure that your values are correctly quoted.\n     * The safest thing you can do is to never use string conditions.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string|null $conditions The conditions to filter on.\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @param bool $overwrite whether to reset conditions with passed list or not\n     * @see \\Cake\\Database\\TypeFactory\n     * @see \\Cake\\Database\\Expression\\QueryExpression\n     * @return $this\n     */\n    public function where($conditions = null, array $types = [], bool $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['where'] = $this->newExpr();\n        }\n        $this->_conjugate('where', $conditions, 'AND', $types);\n\n        return $this;\n    }\n\n    /**\n     * Convenience method that adds a NOT NULL condition to the query\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $fields A single field or expressions or a list of them\n     *  that should be not null.\n     * @return $this\n     */\n    public function whereNotNull($fields)\n    {\n        if (!is_array($fields)) {\n            $fields = [$fields];\n        }\n\n        $exp = $this->newExpr();\n\n        foreach ($fields as $field) {\n            $exp->isNotNull($field);\n        }\n\n        return $this->where($exp);\n    }\n\n    /**\n     * Convenience method that adds a IS NULL condition to the query\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $fields A single field or expressions or a list of them\n     *   that should be null.\n     * @return $this\n     */\n    public function whereNull($fields)\n    {\n        if (!is_array($fields)) {\n            $fields = [$fields];\n        }\n\n        $exp = $this->newExpr();\n\n        foreach ($fields as $field) {\n            $exp->isNull($field);\n        }\n\n        return $this->where($exp);\n    }\n\n    /**\n     * Adds an IN condition or set of conditions to be used in the WHERE clause for this\n     * query.\n     *\n     * This method does allow empty inputs in contrast to where() if you set\n     * 'allowEmpty' to true.\n     * Be careful about using it without proper sanity checks.\n     *\n     * Options:\n     *\n     * - `types` - Associative array of type names used to bind values to query\n     * - `allowEmpty` - Allow empty array.\n     *\n     * @param string $field Field\n     * @param array $values Array of values\n     * @param array<string, mixed> $options Options\n     * @return $this\n     */\n    public function whereInList(string $field, array $values, array $options = [])\n    {\n        $options += [\n            'types' => [],\n            'allowEmpty' => false,\n        ];\n\n        if ($options['allowEmpty'] && !$values) {\n            return $this->where('1=0');\n        }\n\n        return $this->where([$field . ' IN' => $values], $options['types']);\n    }\n\n    /**\n     * Adds a NOT IN condition or set of conditions to be used in the WHERE clause for this\n     * query.\n     *\n     * This method does allow empty inputs in contrast to where() if you set\n     * 'allowEmpty' to true.\n     * Be careful about using it without proper sanity checks.\n     *\n     * @param string $field Field\n     * @param array $values Array of values\n     * @param array<string, mixed> $options Options\n     * @return $this\n     */\n    public function whereNotInList(string $field, array $values, array $options = [])\n    {\n        $options += [\n            'types' => [],\n            'allowEmpty' => false,\n        ];\n\n        if ($options['allowEmpty'] && !$values) {\n            return $this->where([$field . ' IS NOT' => null]);\n        }\n\n        return $this->where([$field . ' NOT IN' => $values], $options['types']);\n    }\n\n    /**\n     * Adds a NOT IN condition or set of conditions to be used in the WHERE clause for this\n     * query. This also allows the field to be null with a IS NULL condition since the null\n     * value would cause the NOT IN condition to always fail.\n     *\n     * This method does allow empty inputs in contrast to where() if you set\n     * 'allowEmpty' to true.\n     * Be careful about using it without proper sanity checks.\n     *\n     * @param string $field Field\n     * @param array $values Array of values\n     * @param array<string, mixed> $options Options\n     * @return $this\n     */\n    public function whereNotInListOrNull(string $field, array $values, array $options = [])\n    {\n        $options += [\n            'types' => [],\n            'allowEmpty' => false,\n        ];\n\n        if ($options['allowEmpty'] && !$values) {\n            return $this->where([$field . ' IS NOT' => null]);\n        }\n\n        return $this->where(\n            [\n                'OR' => [$field . ' NOT IN' => $values, $field . ' IS' => null],\n            ],\n            $options['types']\n        );\n    }\n\n    /**\n     * Connects any previously defined set of conditions to the provided list\n     * using the AND operator. This function accepts the conditions list in the same\n     * format as the method `where` does, hence you can use arrays, expression objects\n     * callback functions or strings.\n     *\n     * It is important to notice that when calling this function, any previous set\n     * of conditions defined for this query will be treated as a single argument for\n     * the AND operator. This function will not only operate the most recently defined\n     * condition, but all the conditions as a whole.\n     *\n     * When using an array for defining conditions, creating constraints form each\n     * array entry will use the same logic as with the `where()` function. This means\n     * that each array entry will be joined to the other using the AND operator, unless\n     * you nest the conditions in the array using other operator.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $query->where(['title' => 'Hello World')->andWhere(['author_id' => 1]);\n     * ```\n     *\n     * Will produce:\n     *\n     * `WHERE title = 'Hello World' AND author_id = 1`\n     *\n     * ```\n     * $query\n     *   ->where(['OR' => ['published' => false, 'published is NULL']])\n     *   ->andWhere(['author_id' => 1, 'comments_count >' => 10])\n     * ```\n     *\n     * Produces:\n     *\n     * `WHERE (published = 0 OR published IS NULL) AND author_id = 1 AND comments_count > 10`\n     *\n     * ```\n     * $query\n     *   ->where(['title' => 'Foo'])\n     *   ->andWhere(function ($exp, $query) {\n     *     return $exp\n     *       ->or(['author_id' => 1])\n     *       ->add(['author_id' => 2]);\n     *   });\n     * ```\n     *\n     * Generates the following conditions:\n     *\n     * `WHERE (title = 'Foo') AND (author_id = 1 OR author_id = 2)`\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string $conditions The conditions to add with AND.\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @see \\Cake\\Database\\Query::where()\n     * @see \\Cake\\Database\\TypeFactory\n     * @return $this\n     */\n    public function andWhere($conditions, array $types = [])\n    {\n        $this->_conjugate('where', $conditions, 'AND', $types);\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple fields to be used in the ORDER clause for this query.\n     * Fields can be passed as an array of strings, array of expression\n     * objects, a single expression or a single string.\n     *\n     * If an array is passed, keys will be used as the field itself and the value will\n     * represent the order in which such field should be ordered. When called multiple\n     * times with the same fields as key, the last order definition will prevail over\n     * the others.\n     *\n     * By default this function will append any passed argument to the list of fields\n     * to be selected, unless the second argument is set to true.\n     *\n     * ### Examples:\n     *\n     * ```\n     * $query->order(['title' => 'DESC', 'author_id' => 'ASC']);\n     * ```\n     *\n     * Produces:\n     *\n     * `ORDER BY title DESC, author_id ASC`\n     *\n     * ```\n     * $query\n     *     ->order(['title' => $query->newExpr('DESC NULLS FIRST')])\n     *     ->order('author_id');\n     * ```\n     *\n     * Will generate:\n     *\n     * `ORDER BY title DESC NULLS FIRST, author_id`\n     *\n     * ```\n     * $expression = $query->newExpr()->add(['id % 2 = 0']);\n     * $query->order($expression)->order(['title' => 'ASC']);\n     * ```\n     *\n     * and\n     *\n     * ```\n     * $query->order(function ($exp, $query) {\n     *     return [$exp->add(['id % 2 = 0']), 'title' => 'ASC'];\n     * });\n     * ```\n     *\n     * Will both become:\n     *\n     * `ORDER BY (id %2 = 0), title ASC`\n     *\n     * Order fields/directions are not sanitized by the query builder.\n     * You should use an allowed list of fields/directions when passing\n     * in user-supplied data to `order()`.\n     *\n     * If you need to set complex expressions as order conditions, you\n     * should use `orderAsc()` or `orderDesc()`.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string $fields fields to be added to the list\n     * @param bool $overwrite whether to reset order with field list or not\n     * @return $this\n     */\n    public function order($fields, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['order'] = null;\n        }\n\n        if (!$fields) {\n            return $this;\n        }\n\n        if (!$this->_parts['order']) {\n            $this->_parts['order'] = new OrderByExpression();\n        }\n        $this->_conjugate('order', $fields, '', []);\n\n        return $this;\n    }\n\n    /**\n     * Add an ORDER BY clause with an ASC direction.\n     *\n     * This method allows you to set complex expressions\n     * as order conditions unlike order()\n     *\n     * Order fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|string $field The field to order on.\n     * @param bool $overwrite Whether to reset the order clauses.\n     * @return $this\n     */\n    public function orderAsc($field, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['order'] = null;\n        }\n        if (!$field) {\n            return $this;\n        }\n\n        if ($field instanceof Closure) {\n            $field = $field($this->newExpr(), $this);\n        }\n\n        if (!$this->_parts['order']) {\n            $this->_parts['order'] = new OrderByExpression();\n        }\n        $this->_parts['order']->add(new OrderClauseExpression($field, 'ASC'));\n\n        return $this;\n    }\n\n    /**\n     * Add an ORDER BY clause with a DESC direction.\n     *\n     * This method allows you to set complex expressions\n     * as order conditions unlike order()\n     *\n     * Order fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|string $field The field to order on.\n     * @param bool $overwrite Whether to reset the order clauses.\n     * @return $this\n     */\n    public function orderDesc($field, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['order'] = null;\n        }\n        if (!$field) {\n            return $this;\n        }\n\n        if ($field instanceof Closure) {\n            $field = $field($this->newExpr(), $this);\n        }\n\n        if (!$this->_parts['order']) {\n            $this->_parts['order'] = new OrderByExpression();\n        }\n        $this->_parts['order']->add(new OrderClauseExpression($field, 'DESC'));\n\n        return $this;\n    }\n\n    /**\n     * Adds a single or multiple fields to be used in the GROUP BY clause for this query.\n     * Fields can be passed as an array of strings, array of expression\n     * objects, a single expression or a single string.\n     *\n     * By default this function will append any passed argument to the list of fields\n     * to be grouped, unless the second argument is set to true.\n     *\n     * ### Examples:\n     *\n     * ```\n     * // Produces GROUP BY id, title\n     * $query->group(['id', 'title']);\n     *\n     * // Produces GROUP BY title\n     * $query->group('title');\n     * ```\n     *\n     * Group fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string $fields fields to be added to the list\n     * @param bool $overwrite whether to reset fields with passed list or not\n     * @return $this\n     */\n    public function group($fields, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['group'] = [];\n        }\n\n        if (!is_array($fields)) {\n            $fields = [$fields];\n        }\n\n        $this->_parts['group'] = array_merge($this->_parts['group'], array_values($fields));\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a condition or set of conditions to be used in the `HAVING` clause for this\n     * query. This method operates in exactly the same way as the method `where()`\n     * does. Please refer to its documentation for an insight on how to using each\n     * parameter.\n     *\n     * Having fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string|null $conditions The having conditions.\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @param bool $overwrite whether to reset conditions with passed list or not\n     * @see \\Cake\\Database\\Query::where()\n     * @return $this\n     */\n    public function having($conditions = null, $types = [], $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['having'] = $this->newExpr();\n        }\n        $this->_conjugate('having', $conditions, 'AND', $types);\n\n        return $this;\n    }\n\n    /**\n     * Connects any previously defined set of conditions to the provided list\n     * using the AND operator in the HAVING clause. This method operates in exactly\n     * the same way as the method `andWhere()` does. Please refer to its\n     * documentation for an insight on how to using each parameter.\n     *\n     * Having fields are not suitable for use with user supplied data as they are\n     * not sanitized by the query builder.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string $conditions The AND conditions for HAVING.\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @see \\Cake\\Database\\Query::andWhere()\n     * @return $this\n     */\n    public function andHaving($conditions, $types = [])\n    {\n        $this->_conjugate('having', $conditions, 'AND', $types);\n\n        return $this;\n    }\n\n    /**\n     * Adds a named window expression.\n     *\n     * You are responsible for adding windows in the order your database requires.\n     *\n     * @param string $name Window name\n     * @param \\Cake\\Database\\Expression\\WindowExpression|\\Closure $window Window expression\n     * @param bool $overwrite Clear all previous query window expressions\n     * @return $this\n     */\n    public function window(string $name, $window, bool $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['window'] = [];\n        }\n\n        if ($window instanceof Closure) {\n            $window = $window(new WindowExpression(), $this);\n            if (!($window instanceof WindowExpression)) {\n                throw new RuntimeException('You must return a `WindowExpression` from a Closure passed to `window()`.');\n            }\n        }\n\n        $this->_parts['window'][] = ['name' => new IdentifierExpression($name), 'window' => $window];\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Set the page of results you want.\n     *\n     * This method provides an easier to use interface to set the limit + offset\n     * in the record set you want as results. If empty the limit will default to\n     * the existing limit clause, and if that too is empty, then `25` will be used.\n     *\n     * Pages must start at 1.\n     *\n     * @param int $num The page number you want.\n     * @param int|null $limit The number of rows you want in the page. If null\n     *  the current limit clause will be used.\n     * @return $this\n     * @throws \\InvalidArgumentException If page number < 1.\n     */\n    public function page(int $num, ?int $limit = null)\n    {\n        if ($num < 1) {\n            throw new InvalidArgumentException('Pages must start at 1.');\n        }\n        if ($limit !== null) {\n            $this->limit($limit);\n        }\n        $limit = $this->clause('limit');\n        if ($limit === null) {\n            $limit = 25;\n            $this->limit($limit);\n        }\n        $offset = ($num - 1) * $limit;\n        if (PHP_INT_MAX <= $offset) {\n            $offset = PHP_INT_MAX;\n        }\n        $this->offset((int)$offset);\n\n        return $this;\n    }\n\n    /**\n     * Sets the number of records that should be retrieved from database,\n     * accepts an integer or an expression object that evaluates to an integer.\n     * In some databases, this operation might not be supported or will require\n     * the query to be transformed in order to limit the result set size.\n     *\n     * ### Examples\n     *\n     * ```\n     * $query->limit(10) // generates LIMIT 10\n     * $query->limit($query->newExpr()->add(['1 + 1'])); // LIMIT (1 + 1)\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|int|null $limit number of records to be returned\n     * @return $this\n     */\n    public function limit($limit)\n    {\n        if (is_string($limit) && !is_numeric($limit)) {\n            throw new InvalidArgumentException('Invalid value for `limit()`');\n        }\n        $this->_dirty();\n        $this->_parts['limit'] = $limit;\n\n        return $this;\n    }\n\n    /**\n     * Sets the number of records that should be skipped from the original result set\n     * This is commonly used for paginating large results. Accepts an integer or an\n     * expression object that evaluates to an integer.\n     *\n     * In some databases, this operation might not be supported or will require\n     * the query to be transformed in order to limit the result set size.\n     *\n     * ### Examples\n     *\n     * ```\n     * $query->offset(10) // generates OFFSET 10\n     * $query->offset($query->newExpr()->add(['1 + 1'])); // OFFSET (1 + 1)\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|int|null $offset number of records to be skipped\n     * @return $this\n     */\n    public function offset($offset)\n    {\n        if (is_string($offset) && !is_numeric($offset)) {\n            throw new InvalidArgumentException('Invalid value for `offset()`');\n        }\n        $this->_dirty();\n        $this->_parts['offset'] = $offset;\n\n        return $this;\n    }\n\n    /**\n     * Adds a complete query to be used in conjunction with an UNION operator with\n     * this query. This is used to combine the result set of this query with the one\n     * that will be returned by the passed query. You can add as many queries as you\n     * required by calling multiple times this method with different queries.\n     *\n     * By default, the UNION operator will remove duplicate rows, if you wish to include\n     * every row for all queries, use unionAll().\n     *\n     * ### Examples\n     *\n     * ```\n     * $union = (new Query($conn))->select(['id', 'title'])->from(['a' => 'articles']);\n     * $query->select(['id', 'name'])->from(['d' => 'things'])->union($union);\n     * ```\n     *\n     * Will produce:\n     *\n     * `SELECT id, name FROM things d UNION SELECT id, title FROM articles a`\n     *\n     * @param \\Cake\\Database\\Query|string $query full SQL query to be used in UNION operator\n     * @param bool $overwrite whether to reset the list of queries to be operated or not\n     * @return $this\n     */\n    public function union($query, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['union'] = [];\n        }\n        $this->_parts['union'][] = [\n            'all' => false,\n            'query' => $query,\n        ];\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Adds a complete query to be used in conjunction with the UNION ALL operator with\n     * this query. This is used to combine the result set of this query with the one\n     * that will be returned by the passed query. You can add as many queries as you\n     * required by calling multiple times this method with different queries.\n     *\n     * Unlike UNION, UNION ALL will not remove duplicate rows.\n     *\n     * ```\n     * $union = (new Query($conn))->select(['id', 'title'])->from(['a' => 'articles']);\n     * $query->select(['id', 'name'])->from(['d' => 'things'])->unionAll($union);\n     * ```\n     *\n     * Will produce:\n     *\n     * `SELECT id, name FROM things d UNION ALL SELECT id, title FROM articles a`\n     *\n     * @param \\Cake\\Database\\Query|string $query full SQL query to be used in UNION operator\n     * @param bool $overwrite whether to reset the list of queries to be operated or not\n     * @return $this\n     */\n    public function unionAll($query, $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_parts['union'] = [];\n        }\n        $this->_parts['union'][] = [\n            'all' => true,\n            'query' => $query,\n        ];\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Create an insert query.\n     *\n     * Note calling this method will reset any data previously set\n     * with Query::values().\n     *\n     * @param array $columns The columns to insert into.\n     * @param array<int|string, string> $types A map between columns & their datatypes.\n     * @return $this\n     * @throws \\RuntimeException When there are 0 columns.\n     */\n    public function insert(array $columns, array $types = [])\n    {\n        if (empty($columns)) {\n            throw new RuntimeException('At least 1 column is required to perform an insert.');\n        }\n        $this->_dirty();\n        $this->_type = 'insert';\n        $this->_parts['insert'][1] = $columns;\n        if (!$this->_parts['values']) {\n            $this->_parts['values'] = new ValuesExpression($columns, $this->getTypeMap()->setTypes($types));\n        } else {\n            $this->_parts['values']->setColumns($columns);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Set the table name for insert queries.\n     *\n     * @param string $table The table name to insert into.\n     * @return $this\n     */\n    public function into(string $table)\n    {\n        $this->_dirty();\n        $this->_type = 'insert';\n        $this->_parts['insert'][0] = $table;\n\n        return $this;\n    }\n\n    /**\n     * Creates an expression that refers to an identifier. Identifiers are used to refer to field names and allow\n     * the SQL compiler to apply quotes or escape the identifier.\n     *\n     * The value is used as is, and you might be required to use aliases or include the table reference in\n     * the identifier. Do not use this method to inject SQL methods or logical statements.\n     *\n     * ### Example\n     *\n     * ```\n     * $query->newExpr()->lte('count', $query->identifier('total'));\n     * ```\n     *\n     * @param string $identifier The identifier for an expression\n     * @return \\Cake\\Database\\ExpressionInterface\n     */\n    public function identifier(string $identifier): ExpressionInterface\n    {\n        return new IdentifierExpression($identifier);\n    }\n\n    /**\n     * Set the values for an insert query.\n     *\n     * Multi inserts can be performed by calling values() more than one time,\n     * or by providing an array of value sets. Additionally $data can be a Query\n     * instance to insert data from another SELECT statement.\n     *\n     * @param \\Cake\\Database\\Expression\\ValuesExpression|\\Cake\\Database\\Query|array $data The data to insert.\n     * @return $this\n     * @throws \\Cake\\Database\\Exception\\DatabaseException if you try to set values before declaring columns.\n     *   Or if you try to set values on non-insert queries.\n     */\n    public function values($data)\n    {\n        if ($this->_type !== 'insert') {\n            throw new DatabaseException(\n                'You cannot add values before defining columns to use.'\n            );\n        }\n        if (empty($this->_parts['insert'])) {\n            throw new DatabaseException(\n                'You cannot add values before defining columns to use.'\n            );\n        }\n\n        $this->_dirty();\n        if ($data instanceof ValuesExpression) {\n            $this->_parts['values'] = $data;\n\n            return $this;\n        }\n\n        $this->_parts['values']->add($data);\n\n        return $this;\n    }\n\n    /**\n     * Create an update query.\n     *\n     * Can be combined with set() and where() methods to create update queries.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|string $table The table you want to update.\n     * @return $this\n     */\n    public function update($table)\n    {\n        if (!is_string($table) && !($table instanceof ExpressionInterface)) {\n            $text = 'Table must be of type string or \"%s\", got \"%s\"';\n            $message = sprintf($text, ExpressionInterface::class, gettype($table));\n            throw new InvalidArgumentException($message);\n        }\n\n        $this->_dirty();\n        $this->_type = 'update';\n        $this->_parts['update'][0] = $table;\n\n        return $this;\n    }\n\n    /**\n     * Set one or many fields to update.\n     *\n     * ### Examples\n     *\n     * Passing a string:\n     *\n     * ```\n     * $query->update('articles')->set('title', 'The Title');\n     * ```\n     *\n     * Passing an array:\n     *\n     * ```\n     * $query->update('articles')->set(['title' => 'The Title'], ['title' => 'string']);\n     * ```\n     *\n     * Passing a callable:\n     *\n     * ```\n     * $query->update('articles')->set(function ($exp) {\n     *   return $exp->eq('title', 'The title', 'string');\n     * });\n     * ```\n     *\n     * @param \\Cake\\Database\\Expression\\QueryExpression|\\Closure|array|string $key The column name or array of keys\n     *    + values to set. This can also be a QueryExpression containing a SQL fragment.\n     *    It can also be a Closure, that is required to return an expression object.\n     * @param mixed $value The value to update $key to. Can be null if $key is an\n     *    array or QueryExpression. When $key is an array, this parameter will be\n     *    used as $types instead.\n     * @param array<string, string>|string $types The column types to treat data as.\n     * @return $this\n     */\n    public function set($key, $value = null, $types = [])\n    {\n        if (empty($this->_parts['set'])) {\n            $this->_parts['set'] = $this->newExpr()->setConjunction(',');\n        }\n\n        if ($key instanceof Closure) {\n            $exp = $this->newExpr()->setConjunction(',');\n            $this->_parts['set']->add($key($exp));\n\n            return $this;\n        }\n\n        if (is_array($key) || $key instanceof ExpressionInterface) {\n            $types = (array)$value;\n            $this->_parts['set']->add($key, $types);\n\n            return $this;\n        }\n\n        if (!is_string($types)) {\n            $types = null;\n        }\n        $this->_parts['set']->eq($key, $value, $types);\n\n        return $this;\n    }\n\n    /**\n     * Create a delete query.\n     *\n     * Can be combined with from(), where() and other methods to\n     * create delete queries with specific conditions.\n     *\n     * @param string|null $table The table to use when deleting.\n     * @return $this\n     */\n    public function delete(?string $table = null)\n    {\n        $this->_dirty();\n        $this->_type = 'delete';\n        if ($table !== null) {\n            $this->from($table);\n        }\n\n        return $this;\n    }\n\n    /**\n     * A string or expression that will be appended to the generated query\n     *\n     * ### Examples:\n     * ```\n     * $query->select('id')->where(['author_id' => 1])->epilog('FOR UPDATE');\n     * $query\n     *  ->insert('articles', ['title'])\n     *  ->values(['author_id' => 1])\n     *  ->epilog('RETURNING id');\n     * ```\n     *\n     * Epliog content is raw SQL and not suitable for use with user supplied data.\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|string|null $expression The expression to be appended\n     * @return $this\n     */\n    public function epilog($expression = null)\n    {\n        $this->_dirty();\n        $this->_parts['epilog'] = $expression;\n\n        return $this;\n    }\n\n    /**\n     * Returns the type of this query (select, insert, update, delete)\n     *\n     * @return string\n     */\n    public function type(): string\n    {\n        return $this->_type;\n    }\n\n    /**\n     * Returns a new QueryExpression object. This is a handy function when\n     * building complex queries using a fluent interface. You can also override\n     * this function in subclasses to use a more specialized QueryExpression class\n     * if required.\n     *\n     * You can optionally pass a single raw SQL string or an array or expressions in\n     * any format accepted by \\Cake\\Database\\Expression\\QueryExpression:\n     *\n     * ```\n     * $expression = $query->expr(); // Returns an empty expression object\n     * $expression = $query->expr('Table.column = Table2.column'); // Return a raw SQL expression\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string|null $rawExpression A string, array or anything you want wrapped in an expression object\n     * @return \\Cake\\Database\\Expression\\QueryExpression\n     */\n    public function newExpr($rawExpression = null): QueryExpression\n    {\n        return $this->expr($rawExpression);\n    }\n\n    /**\n     * Returns a new QueryExpression object. This is a handy function when\n     * building complex queries using a fluent interface. You can also override\n     * this function in subclasses to use a more specialized QueryExpression class\n     * if required.\n     *\n     * You can optionally pass a single raw SQL string or an array or expressions in\n     * any format accepted by \\Cake\\Database\\Expression\\QueryExpression:\n     *\n     * ```\n     * $expression = $query->expr(); // Returns an empty expression object\n     * $expression = $query->expr('Table.column = Table2.column'); // Return a raw SQL expression\n     * ```\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array|string|null $rawExpression A string, array or anything you want wrapped in an expression object\n     * @return \\Cake\\Database\\Expression\\QueryExpression\n     */\n    public function expr($rawExpression = null): QueryExpression\n    {\n        $expression = new QueryExpression([], $this->getTypeMap());\n\n        if ($rawExpression !== null) {\n            $expression->add($rawExpression);\n        }\n\n        return $expression;\n    }\n\n    /**\n     * Returns an instance of a functions builder object that can be used for\n     * generating arbitrary SQL functions.\n     *\n     * ### Example:\n     *\n     * ```\n     * $query->func()->count('*');\n     * $query->func()->dateDiff(['2012-01-05', '2012-01-02'])\n     * ```\n     *\n     * @return \\Cake\\Database\\FunctionsBuilder\n     */\n    public function func(): FunctionsBuilder\n    {\n        if ($this->_functionsBuilder === null) {\n            $this->_functionsBuilder = new FunctionsBuilder();\n        }\n\n        return $this->_functionsBuilder;\n    }\n\n    /**\n     * Executes this query and returns a results iterator. This function is required\n     * for implementing the IteratorAggregate interface and allows the query to be\n     * iterated without having to call execute() manually, thus making it look like\n     * a result set instead of the query itself.\n     *\n     * @return \\Cake\\Database\\StatementInterface\n     * @psalm-suppress ImplementedReturnTypeMismatch\n     */\n    #[\\ReturnTypeWillChange]\n    public function getIterator()\n    {\n        if ($this->_iterator === null || $this->_dirty) {\n            $this->_iterator = $this->execute();\n        }\n\n        return $this->_iterator;\n    }\n\n    /**\n     * Returns any data that was stored in the specified clause. This is useful for\n     * modifying any internal part of the query and it is used by the SQL dialects\n     * to transform the query accordingly before it is executed. The valid clauses that\n     * can be retrieved are: delete, update, set, insert, values, select, distinct,\n     * from, join, set, where, group, having, order, limit, offset and union.\n     *\n     * The return value for each of those parts may vary. Some clauses use QueryExpression\n     * to internally store their state, some use arrays and others may use booleans or\n     * integers. This is summary of the return types for each clause.\n     *\n     * - update: string The name of the table to update\n     * - set: QueryExpression\n     * - insert: array, will return an array containing the table + columns.\n     * - values: ValuesExpression\n     * - select: array, will return empty array when no fields are set\n     * - distinct: boolean\n     * - from: array of tables\n     * - join: array\n     * - set: array\n     * - where: QueryExpression, returns null when not set\n     * - group: array\n     * - having: QueryExpression, returns null when not set\n     * - order: OrderByExpression, returns null when not set\n     * - limit: integer or QueryExpression, null when not set\n     * - offset: integer or QueryExpression, null when not set\n     * - union: array\n     *\n     * @param string $name name of the clause to be returned\n     * @return mixed\n     * @throws \\InvalidArgumentException When the named clause does not exist.\n     */\n    public function clause(string $name)\n    {\n        if (!array_key_exists($name, $this->_parts)) {\n            $clauses = implode(', ', array_keys($this->_parts));\n            throw new InvalidArgumentException(\"The '$name' clause is not defined. Valid clauses are: $clauses\");\n        }\n\n        return $this->_parts[$name];\n    }\n\n    /**\n     * Registers a callback to be executed for each result that is fetched from the\n     * result set, the callback function will receive as first parameter an array with\n     * the raw data from the database for every row that is fetched and must return the\n     * row with any possible modifications.\n     *\n     * Callbacks will be executed lazily, if only 3 rows are fetched for database it will\n     * called 3 times, event though there might be more rows to be fetched in the cursor.\n     *\n     * Callbacks are stacked in the order they are registered, if you wish to reset the stack\n     * the call this function with the second parameter set to true.\n     *\n     * If you wish to remove all decorators from the stack, set the first parameter\n     * to null and the second to true.\n     *\n     * ### Example\n     *\n     * ```\n     * $query->decorateResults(function ($row) {\n     *   $row['order_total'] = $row['subtotal'] + ($row['subtotal'] * $row['tax']);\n     *    return $row;\n     * });\n     * ```\n     *\n     * @param callable|null $callback The callback to invoke when results are fetched.\n     * @param bool $overwrite Whether this should append or replace all existing decorators.\n     * @return $this\n     */\n    public function decorateResults(?callable $callback, bool $overwrite = false)\n    {\n        if ($overwrite) {\n            $this->_resultDecorators = [];\n        }\n\n        if ($callback !== null) {\n            $this->_resultDecorators[] = $callback;\n        }\n\n        return $this;\n    }\n\n    /**\n     * This function works similar to the traverse() function, with the difference\n     * that it does a full depth traversal of the entire expression tree. This will execute\n     * the provided callback function for each ExpressionInterface object that is\n     * stored inside this query at any nesting depth in any part of the query.\n     *\n     * Callback will receive as first parameter the currently visited expression.\n     *\n     * @param callable $callback the function to be executed for each ExpressionInterface\n     *   found inside this query.\n     * @return $this\n     */\n    public function traverseExpressions(callable $callback)\n    {\n        if (!$callback instanceof Closure) {\n            $callback = Closure::fromCallable($callback);\n        }\n\n        foreach ($this->_parts as $part) {\n            $this->_expressionsVisitor($part, $callback);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Query parts traversal method used by traverseExpressions()\n     *\n     * @param \\Cake\\Database\\ExpressionInterface|array<\\Cake\\Database\\ExpressionInterface> $expression Query expression or\n     *   array of expressions.\n     * @param \\Closure $callback The callback to be executed for each ExpressionInterface\n     *   found inside this query.\n     * @return void\n     */\n    protected function _expressionsVisitor($expression, Closure $callback): void\n    {\n        if (is_array($expression)) {\n            foreach ($expression as $e) {\n                $this->_expressionsVisitor($e, $callback);\n            }\n\n            return;\n        }\n\n        if ($expression instanceof ExpressionInterface) {\n            $expression->traverse(function ($exp) use ($callback) {\n                $this->_expressionsVisitor($exp, $callback);\n            });\n\n            if (!$expression instanceof self) {\n                $callback($expression);\n            }\n        }\n    }\n\n    /**\n     * Associates a query placeholder to a value and a type.\n     *\n     * ```\n     * $query->bind(':id', 1, 'integer');\n     * ```\n     *\n     * @param string|int $param placeholder to be replaced with quoted version\n     *   of $value\n     * @param mixed $value The value to be bound\n     * @param string|int|null $type the mapped type name, used for casting when sending\n     *   to database\n     * @return $this\n     */\n    public function bind($param, $value, $type = null)\n    {\n        $this->getValueBinder()->bind($param, $value, $type);\n\n        return $this;\n    }\n\n    /**\n     * Returns the currently used ValueBinder instance.\n     *\n     * A ValueBinder is responsible for generating query placeholders and temporarily\n     * associate values to those placeholders so that they can be passed correctly\n     * to the statement object.\n     *\n     * @return \\Cake\\Database\\ValueBinder\n     */\n    public function getValueBinder(): ValueBinder\n    {\n        if ($this->_valueBinder === null) {\n            $this->_valueBinder = new ValueBinder();\n        }\n\n        return $this->_valueBinder;\n    }\n\n    /**\n     * Overwrite the current value binder\n     *\n     * A ValueBinder is responsible for generating query placeholders and temporarily\n     * associate values to those placeholders so that they can be passed correctly\n     * to the statement object.\n     *\n     * @param \\Cake\\Database\\ValueBinder|null $binder The binder or null to disable binding.\n     * @return $this\n     */\n    public function setValueBinder(?ValueBinder $binder)\n    {\n        $this->_valueBinder = $binder;\n\n        return $this;\n    }\n\n    /**\n     * Enables/Disables buffered results.\n     *\n     * When enabled the results returned by this Query will be\n     * buffered. This enables you to iterate a result set multiple times, or\n     * both cache and iterate it.\n     *\n     * When disabled it will consume less memory as fetched results are not\n     * remembered for future iterations.\n     *\n     * @param bool $enable Whether to enable buffering\n     * @return $this\n     */\n    public function enableBufferedResults(bool $enable = true)\n    {\n        $this->_dirty();\n        $this->_useBufferedResults = $enable;\n\n        return $this;\n    }\n\n    /**\n     * Disables buffered results.\n     *\n     * Disabling buffering will consume less memory as fetched results are not\n     * remembered for future iterations.\n     *\n     * @return $this\n     */\n    public function disableBufferedResults()\n    {\n        $this->_dirty();\n        $this->_useBufferedResults = false;\n\n        return $this;\n    }\n\n    /**\n     * Returns whether buffered results are enabled/disabled.\n     *\n     * When enabled the results returned by this Query will be\n     * buffered. This enables you to iterate a result set multiple times, or\n     * both cache and iterate it.\n     *\n     * When disabled it will consume less memory as fetched results are not\n     * remembered for future iterations.\n     *\n     * @return bool\n     */\n    public function isBufferedResultsEnabled(): bool\n    {\n        return $this->_useBufferedResults;\n    }\n\n    /**\n     * Sets the TypeMap class where the types for each of the fields in the\n     * select clause are stored.\n     *\n     * @param \\Cake\\Database\\TypeMap $typeMap The map object to use\n     * @return $this\n     */\n    public function setSelectTypeMap(TypeMap $typeMap)\n    {\n        $this->_selectTypeMap = $typeMap;\n        $this->_dirty();\n\n        return $this;\n    }\n\n    /**\n     * Gets the TypeMap class where the types for each of the fields in the\n     * select clause are stored.\n     *\n     * @return \\Cake\\Database\\TypeMap\n     */\n    public function getSelectTypeMap(): TypeMap\n    {\n        if ($this->_selectTypeMap === null) {\n            $this->_selectTypeMap = new TypeMap();\n        }\n\n        return $this->_selectTypeMap;\n    }\n\n    /**\n     * Disables result casting.\n     *\n     * When disabled, the fields will be returned as received from the database\n     * driver (which in most environments means they are being returned as\n     * strings), which can improve performance with larger datasets.\n     *\n     * @return $this\n     */\n    public function disableResultsCasting()\n    {\n        $this->typeCastEnabled = false;\n\n        return $this;\n    }\n\n    /**\n     * Enables result casting.\n     *\n     * When enabled, the fields in the results returned by this Query will be\n     * cast to their corresponding PHP data type.\n     *\n     * @return $this\n     */\n    public function enableResultsCasting()\n    {\n        $this->typeCastEnabled = true;\n\n        return $this;\n    }\n\n    /**\n     * Returns whether result casting is enabled/disabled.\n     *\n     * When enabled, the fields in the results returned by this Query will be\n     * casted to their corresponding PHP data type.\n     *\n     * When disabled, the fields will be returned as received from the database\n     * driver (which in most environments means they are being returned as\n     * strings), which can improve performance with larger datasets.\n     *\n     * @return bool\n     */\n    public function isResultsCastingEnabled(): bool\n    {\n        return $this->typeCastEnabled;\n    }\n\n    /**\n     * Auxiliary function used to wrap the original statement from the driver with\n     * any registered callbacks.\n     *\n     * @param \\Cake\\Database\\StatementInterface $statement to be decorated\n     * @return \\Cake\\Database\\Statement\\CallbackStatement|\\Cake\\Database\\StatementInterface\n     */\n    protected function _decorateStatement(StatementInterface $statement)\n    {\n        $typeMap = $this->getSelectTypeMap();\n        $driver = $this->getConnection()->getDriver();\n\n        if ($this->typeCastEnabled && $typeMap->toArray()) {\n            $statement = new CallbackStatement($statement, $driver, new FieldTypeConverter($typeMap, $driver));\n        }\n\n        foreach ($this->_resultDecorators as $f) {\n            $statement = new CallbackStatement($statement, $driver, $f);\n        }\n\n        return $statement;\n    }\n\n    /**\n     * Helper function used to build conditions by composing QueryExpression objects.\n     *\n     * @param string $part Name of the query part to append the new part to\n     * @param \\Cake\\Database\\ExpressionInterface|\\Closure|array|string|null $append Expression or builder function to append.\n     *   to append.\n     * @param string $conjunction type of conjunction to be used to operate part\n     * @param array<string, string> $types Associative array of type names used to bind values to query\n     * @return void\n     */\n    protected function _conjugate(string $part, $append, $conjunction, array $types): void\n    {\n        $expression = $this->_parts[$part] ?: $this->newExpr();\n        if (empty($append)) {\n            $this->_parts[$part] = $expression;\n\n            return;\n        }\n\n        if ($append instanceof Closure) {\n            $append = $append($this->newExpr(), $this);\n        }\n\n        if ($expression->getConjunction() === $conjunction) {\n            $expression->add($append, $types);\n        } else {\n            $expression = $this->newExpr()\n                ->setConjunction($conjunction)\n                ->add([$expression, $append], $types);\n        }\n\n        $this->_parts[$part] = $expression;\n        $this->_dirty();\n    }\n\n    /**\n     * Marks a query as dirty, removing any preprocessed information\n     * from in memory caching.\n     *\n     * @return void\n     */\n    protected function _dirty(): void\n    {\n        $this->_dirty = true;\n\n        if ($this->_iterator && $this->_valueBinder) {\n            $this->getValueBinder()->reset();\n        }\n    }\n\n    /**\n     * Handles clearing iterator and cloning all expressions and value binders.\n     *\n     * @return void\n     */\n    public function __clone()\n    {\n        $this->_iterator = null;\n        if ($this->_valueBinder !== null) {\n            $this->_valueBinder = clone $this->_valueBinder;\n        }\n        if ($this->_selectTypeMap !== null) {\n            $this->_selectTypeMap = clone $this->_selectTypeMap;\n        }\n        foreach ($this->_parts as $name => $part) {\n            if (empty($part)) {\n                continue;\n            }\n            if (is_array($part)) {\n                foreach ($part as $i => $piece) {\n                    if (is_array($piece)) {\n                        foreach ($piece as $j => $value) {\n                            if ($value instanceof ExpressionInterface) {\n                                /** @psalm-suppress PossiblyUndefinedMethod */\n                                $this->_parts[$name][$i][$j] = clone $value;\n                            }\n                        }\n                    } elseif ($piece instanceof ExpressionInterface) {\n                        /** @psalm-suppress PossiblyUndefinedMethod */\n                        $this->_parts[$name][$i] = clone $piece;\n                    }\n                }\n            }\n            if ($part instanceof ExpressionInterface) {\n                $this->_parts[$name] = clone $part;\n            }\n        }\n    }\n\n    /**\n     * Returns string representation of this query (complete SQL statement).\n     *\n     * @return string\n     */\n    public function __toString(): string\n    {\n        return $this->sql();\n    }\n\n    /**\n     * Returns an array that can be used to describe the internal state of this\n     * object.\n     *\n     * @return array<string, mixed>\n     */\n    public function __debugInfo(): array\n    {\n        try {\n            set_error_handler(\n                /** @return no-return */\n                function ($errno, $errstr) {\n                    throw new RuntimeException($errstr, $errno);\n                },\n                E_ALL\n            );\n            $sql = $this->sql();\n            $params = $this->getValueBinder()->bindings();\n        } catch (RuntimeException $e) {\n            $sql = 'SQL could not be generated for this query as it is incomplete.';\n            $params = [];\n        } finally {\n            restore_error_handler();\n        }\n\n        return [\n            '(help)' => 'This is a Query object, to get the results execute or iterate it.',\n            'sql' => $sql,\n            'params' => $params,\n            'defaultTypes' => $this->getDefaultTypes(),\n            'decorators' => count($this->_resultDecorators),\n            'executed' => $this->_iterator ? true : false,\n        ];\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)\n * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)\n *\n * Licensed under The MIT License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)\n * @link          https://cakephp.org CakePHP(tm) Project\n * @since         3.0.0\n * @license       https://opensource.org/licenses/mit-license.php MIT License\n */\nnamespace Cake\\Test\\TestCase\\Database;\n\nuse Cake\\Database\\Driver\\Mysql;\nuse Cake\\Database\\Driver\\Postgres;\nuse Cake\\Database\\Driver\\Sqlite;\nuse Cake\\Database\\Driver\\Sqlserver;\nuse Cake\\Database\\Exception\\DatabaseException;\nuse Cake\\Database\\Expression\\CommonTableExpression;\nuse Cake\\Database\\Expression\\IdentifierExpression;\nuse Cake\\Database\\Expression\\QueryExpression;\nuse Cake\\Database\\Expression\\StringExpression;\nuse Cake\\Database\\Expression\\TupleComparison;\nuse Cake\\Database\\Expression\\WindowExpression;\nuse Cake\\Database\\ExpressionInterface;\nuse Cake\\Database\\Query;\nuse Cake\\Database\\Statement\\StatementDecorator;\nuse Cake\\Database\\StatementInterface;\nuse Cake\\Database\\TypeFactory;\nuse Cake\\Database\\TypeMap;\nuse Cake\\Database\\ValueBinder;\nuse Cake\\Datasource\\ConnectionManager;\nuse Cake\\TestSuite\\TestCase;\nuse DateTime;\nuse DateTimeImmutable;\nuse InvalidArgumentException;\nuse ReflectionProperty;\nuse RuntimeException;\nuse stdClass;\nuse TestApp\\Database\\Type\\BarType;\n\n/**\n * Tests Query class\n */\nclass QueryTest extends TestCase\n{\n    protected $fixtures = [\n        'core.Articles',\n        'core.Authors',\n        'core.Comments',\n        'core.Profiles',\n        'core.MenuLinkTrees',\n    ];\n\n    /**\n     * @var int\n     */\n    public const ARTICLE_COUNT = 3;\n    /**\n     * @var int\n     */\n    public const AUTHOR_COUNT = 4;\n    /**\n     * @var int\n     */\n    public const COMMENT_COUNT = 6;\n\n    /**\n     * @var \\Cake\\Database\\Connection\n     */\n    protected $connection;\n\n    /**\n     * @var bool\n     */\n    protected $autoQuote;\n\n    public function setUp(): void\n    {\n        parent::setUp();\n        $this->connection = ConnectionManager::get('test');\n        $this->autoQuote = $this->connection->getDriver()->isAutoQuotingEnabled();\n    }\n\n    public function tearDown(): void\n    {\n        parent::tearDown();\n        $this->connection->getDriver()->enableAutoQuoting($this->autoQuote);\n        unset($this->connection);\n    }\n\n    /**\n     * Queries need a default type to prevent fatal errors\n     * when an uninitialized query has its sql() method called.\n     */\n    public function testDefaultType(): void\n    {\n        $query = new Query($this->connection);\n        $this->assertSame('', $query->sql());\n        $this->assertSame('select', $query->type());\n    }\n\n    /**\n     * Tests that it is possible to obtain expression results from a query\n     */\n    public function testSelectFieldsOnly(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(false);\n        $query = new Query($this->connection);\n        $result = $query->select('1 + 1')->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertEquals([2], $result->fetch());\n        $result->closeCursor();\n\n        //This new field should be appended\n        $result = $query->select(['1 + 3'])->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertEquals([2, 4], $result->fetch());\n        $result->closeCursor();\n\n        //This should now overwrite all previous fields\n        $result = $query->select(['1 + 2', '1 + 5'], true)->execute();\n        $this->assertEquals([3, 6], $result->fetch());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to pass a closure as fields in select()\n     */\n    public function testSelectClosure(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(false);\n        $query = new Query($this->connection);\n        $result = $query->select(function ($q) use ($query) {\n            $this->assertSame($query, $q);\n\n            return ['1 + 2', '1 + 5'];\n        })->execute();\n        $this->assertEquals([3, 6], $result->fetch());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to select fields from tables with no conditions\n     */\n    public function testSelectFieldsFromTable(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(['body', 'author_id'])->from('articles')->execute();\n        $this->assertEquals(['body' => 'First Article Body', 'author_id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['body' => 'Second Article Body', 'author_id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        //Append more tables to next execution\n        $result = $query->select('name')->from(['authors'])->order(['name' => 'desc', 'articles.id' => 'asc'])->execute();\n        $this->assertEquals(['body' => 'First Article Body', 'author_id' => 1, 'name' => 'nate'], $result->fetch('assoc'));\n        $this->assertEquals(['body' => 'Second Article Body', 'author_id' => 3, 'name' => 'nate'], $result->fetch('assoc'));\n        $this->assertEquals(['body' => 'Third Article Body', 'author_id' => 1, 'name' => 'nate'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        // Overwrite tables and only fetch from authors\n        $result = $query->select('name', true)->from('authors', true)->order(['name' => 'desc'], true)->execute();\n        $this->assertSame(['nate'], $result->fetch());\n        $this->assertSame(['mariano'], $result->fetch());\n        $this->assertCount(4, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to select aliased fields\n     */\n    public function testSelectAliasedFieldsFromTable(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(['text' => 'comment', 'article_id'])->from('comments')->execute();\n        $this->assertEquals(['text' => 'First Comment for First Article', 'article_id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['text' => 'Second Comment for First Article', 'article_id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query->select(['text' => 'comment', 'article' => 'article_id'])->from('comments')->execute();\n        $this->assertEquals(['text' => 'First Comment for First Article', 'article' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['text' => 'Second Comment for First Article', 'article' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $query->select(['text' => 'comment'])->select(['article_id', 'foo' => 'comment']);\n        $result = $query->from('comments')->execute();\n        $this->assertEquals(\n            ['foo' => 'First Comment for First Article', 'text' => 'First Comment for First Article', 'article_id' => 1],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $exp = $query->newExpr('1 + 1');\n        $comp = $query->newExpr(['article_id +' => 2]);\n        $result = $query->select(['text' => 'comment', 'two' => $exp, 'three' => $comp])\n            ->from('comments')->execute();\n        $this->assertEquals(['text' => 'First Comment for First Article', 'two' => 2, 'three' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that tables can also be aliased and referenced in the select clause using such alias\n     */\n    public function testSelectAliasedTables(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(['text' => 'a.body', 'a.author_id'])\n            ->from(['a' => 'articles'])->execute();\n\n        $this->assertEquals(['text' => 'First Article Body', 'author_id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['text' => 'Second Article Body', 'author_id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->select(['name' => 'b.name'])->from(['b' => 'authors'])\n            ->order(['text' => 'desc', 'name' => 'desc'])\n            ->execute();\n        $this->assertEquals(\n            ['text' => 'Third Article Body', 'author_id' => 1, 'name' => 'nate'],\n            $result->fetch('assoc')\n        );\n        $this->assertEquals(\n            ['text' => 'Third Article Body', 'author_id' => 1, 'name' => 'mariano'],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to add joins to a select query\n     */\n    public function testSelectWithJoins(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->order(['title' => 'asc'])\n            ->execute();\n\n        $this->assertCount(3, $result);\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->join('authors', [], true)->execute();\n        $this->assertCount(12, $result, 'Cross join results in 12 records');\n        $result->closeCursor();\n\n        $result = $query->join([\n            ['table' => 'authors', 'type' => 'INNER', 'conditions' => $query->newExpr()->equalFields('author_id', 'authors.id')],\n        ], [], true)->execute();\n        $this->assertCount(3, $result);\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to add joins to a select query using array or expression as conditions\n     */\n    public function testSelectWithJoinsConditions(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => [$query->newExpr()->equalFields('author_id ', 'a.id')]])\n            ->order(['title' => 'asc'])\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $conditions = $query->newExpr()->equalFields('author_id', 'a.id');\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $conditions])\n            ->order(['title' => 'asc'])\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'comment' => 'c.comment'])\n            ->from('articles')\n            ->join(['table' => 'comments', 'alias' => 'c', 'conditions' => ['created' => $time]], $types)\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'comment' => 'First Comment for First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that joins can be aliased using array keys\n     */\n    public function testSelectAliasedJoins(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['a' => 'authors'])\n            ->order(['name' => 'desc', 'articles.id' => 'asc'])\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'nate'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'nate'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $conditions = $query->newExpr('author_id = a.id');\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['a' => ['table' => 'authors', 'conditions' => $conditions]])\n            ->order(['title' => 'asc'])\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'mariano'], $result->fetch('assoc'));\n        $this->assertEquals(['title' => 'Second Article', 'name' => 'larry'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->join(['c' => ['table' => 'comments', 'conditions' => ['created' => $time]]], $types)\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => 'First Comment for First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests the leftJoin method\n     */\n    public function testSelectLeftJoin(): void\n    {\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->leftJoin(['c' => 'comments'], ['created <' => $time], $types)\n            ->execute();\n        $this->assertEquals(['title' => 'First Article', 'name' => null], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->leftJoin(['c' => 'comments'], ['created >' => $time], $types)\n            ->order(['created' => 'asc'])\n            ->execute();\n        $this->assertEquals(\n            ['title' => 'First Article', 'name' => 'Second Comment for First Article'],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests the innerJoin method\n     */\n    public function testSelectInnerJoin(): void\n    {\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $statement = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->innerJoin(['c' => 'comments'], ['created <' => $time], $types)\n            ->execute();\n        $this->assertCount(0, $statement->fetchAll());\n        $statement->closeCursor();\n    }\n\n    /**\n     * Tests the rightJoin method\n     */\n    public function testSelectRightJoin(): void\n    {\n        $this->skipIf(\n            $this->connection->getDriver() instanceof Sqlite,\n            'SQLite does not support RIGHT joins'\n        );\n        $query = new Query($this->connection);\n        $time = new DateTime('2007-03-18 10:45:23');\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->rightJoin(['c' => 'comments'], ['created <' => $time], $types)\n            ->execute();\n        $this->assertCount(6, $result);\n        $this->assertEquals(\n            ['title' => null, 'name' => 'First Comment for First Article'],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to pass a callable as conditions for a join\n     */\n    public function testSelectJoinWithCallback(): void\n    {\n        $query = new Query($this->connection);\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['title', 'name' => 'c.comment'])\n            ->from('articles')\n            ->innerJoin(['c' => 'comments'], function ($exp, $q) use ($query, $types) {\n                $this->assertSame($q, $query);\n                $exp->add(['created <' => new DateTime('2007-03-18 10:45:23')], $types);\n\n                return $exp;\n            })\n            ->execute();\n        $this->assertCount(0, $result->fetchAll());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to pass a callable as conditions for a join\n     */\n    public function testSelectJoinWithCallback2(): void\n    {\n        $query = new Query($this->connection);\n        $types = ['created' => 'datetime'];\n        $result = $query\n            ->select(['name', 'commentary' => 'comments.comment'])\n            ->from('authors')\n            ->innerJoin('comments', function ($exp, $q) use ($query, $types) {\n                $this->assertSame($q, $query);\n                $exp->add(['created' => new DateTime('2007-03-18 10:47:23')], $types);\n\n                return $exp;\n            })\n            ->execute();\n        $this->assertEquals(\n            ['name' => 'mariano', 'commentary' => 'Second Comment for First Article'],\n            $result->fetch('assoc')\n        );\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests it is possible to filter a query by using simple AND joined conditions\n     */\n    public function testSelectSimpleWhere(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id' => 1, 'title' => 'First Article'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id' => 100], ['id' => 'integer'])\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorMoreThan(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['comment'])\n            ->from('comments')\n            ->where(['id >' => 4])\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['comment' => 'First Comment for Second Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorLessThan(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id <' => 2])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorLessThanEqual(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id <=' => 2])\n            ->execute();\n        $this->assertCount(2, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorMoreThanEqual(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id >=' => 1])\n            ->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorNotEqual(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['id !=' => 2])\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorLike(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['title LIKE' => 'First Article'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorLikeExpansion(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['title like' => '%Article%'])\n            ->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operators and scalar values works\n     */\n    public function testSelectWhereOperatorNotLike(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(['title not like' => '%Article%'])\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test that unary expressions in selects are built correctly.\n     */\n    public function testSelectWhereUnary(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('articles')\n            ->where([\n                'title is not' => null,\n                'user_id is' => null,\n            ])\n            ->sql();\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\(\\(<title>\\) IS NOT NULL AND \\(<user_id>\\) IS NULL\\)',\n            $result,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests selecting with conditions and specifying types for those\n     */\n    public function testSelectWhereTypes(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created >' => new DateTime('2007-03-18 10:46:00')], ['created' => 'datetime'])\n            ->execute();\n        $this->assertCount(5, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(\n                [\n                    'created >' => new DateTime('2007-03-18 10:40:00'),\n                    'created <' => new DateTime('2007-03-18 10:46:00'),\n                ],\n                ['created' => 'datetime']\n            )\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(\n                [\n                    'id' => '3',\n                    'created <' => new DateTime('2013-01-01 12:00'),\n                ],\n                ['created' => 'datetime', 'id' => 'integer']\n            )\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(\n                [\n                    'id' => '1',\n                    'created <' => new DateTime('2013-01-01 12:00'),\n                ],\n                ['created' => 'datetime', 'id' => 'integer']\n            )\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests Query::whereNull()\n     */\n    public function testSelectWhereNull(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id', 'parent_id'])\n            ->from('menu_link_trees')\n            ->whereNull(['parent_id'])\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('menu_link_trees')\n            ->whereNull($this->connection->newQuery()->select('parent_id'))\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('menu_link_trees')\n            ->whereNull('parent_id')\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests Query::whereNotNull()\n     */\n    public function testSelectWhereNotNull(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id', 'parent_id'])\n            ->from('menu_link_trees')\n            ->whereNotNull(['parent_id'])\n            ->execute();\n        $this->assertCount(13, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('menu_link_trees')\n            ->whereNotNull($this->connection->newQuery()->select('parent_id'))\n            ->execute();\n        $this->assertCount(13, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('menu_link_trees')\n            ->whereNotNull('parent_id')\n            ->execute();\n        $this->assertCount(13, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that passing an array type to any where condition will replace\n     * the passed array accordingly as a proper IN condition\n     */\n    public function testSelectWhereArrayType(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['id' => ['1', '3']], ['id' => 'integer[]'])\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that passing an empty array type to any where condition will not\n     * result in a SQL error, but an internal exception\n     */\n    public function testSelectWhereArrayTypeEmpty(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $this->expectExceptionMessage('Impossible to generate condition with empty list of values for field');\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['id' => []], ['id' => 'integer[]'])\n            ->execute();\n    }\n\n    /**\n     * Tests exception message for impossible condition when using an expression\n     */\n    public function testSelectWhereArrayTypeEmptyWithExpression(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $this->expectExceptionMessage('with empty list of values for field (SELECT 1)');\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                return $exp->in($q->newExpr('SELECT 1'), []);\n            })\n            ->execute();\n    }\n\n    /**\n     * Tests that Query::andWhere() can be used to concatenate conditions with AND\n     */\n    public function testSelectAndWhere(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime'])\n            ->andWhere(['id' => 1])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created' => new DateTime('2007-03-18 10:50:55')], ['created' => 'datetime'])\n            ->andWhere(['id' => 2])\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that Query::andWhere() can be used without calling where() before\n     */\n    public function testSelectAndWhereNoPreviousCondition(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->andWhere(['created' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime'])\n            ->andWhere(['id' => 1])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to pass a closure to where() to build a set of\n     * conditions and return the expression to be used\n     */\n    public function testSelectWhereUsingClosure(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->eq('id', 1);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp\n                    ->eq('id', 1)\n                    ->eq('created', new DateTime('2007-03-18 10:45:23'), 'datetime');\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp\n                    ->eq('id', 1)\n                    ->eq('created', new DateTime('2021-12-30 15:00'), 'datetime');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests generating tuples in the values side containing closure expressions\n     */\n    public function testTupleWithClosureExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('comments')\n            ->where([\n                'OR' => [\n                    'id' => 1,\n                    function ($exp) {\n                        return $exp->eq('id', 2);\n                    },\n                ],\n            ]);\n\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <comments> WHERE \\(<id> = :c0 OR <id> = :c1\\)',\n            $result,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that it is possible to pass a closure to andWhere() to build a set of\n     * conditions and return the expression to be used\n     */\n    public function testSelectAndWhereUsingClosure(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['id' => '1'])\n            ->andWhere(function ($exp) {\n                return $exp->eq('created', new DateTime('2007-03-18 10:45:23'), 'datetime');\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['id' => '1'])\n            ->andWhere(function ($exp) {\n                return $exp->eq('created', new DateTime('2022-12-21 12:00'), 'datetime');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that expression objects can be used as the field in a comparison\n     * and the values will be bound correctly to the query\n     */\n    public function testSelectWhereUsingExpressionInField(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $field = clone $exp;\n                $field->add('SELECT min(id) FROM comments');\n\n                return $exp\n                    ->eq($field, 100, 'integer');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests using where conditions with operator methods\n     */\n    public function testSelectWhereOperatorMethods(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->gt('id', 1);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['title' => 'Second Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->lt('id', 2);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->lte('id', 2);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->gte('id', 1);\n            })\n            ->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->lte('id', 1);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->notEq('id', 2);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->like('title', 'First Article');\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['title' => 'First Article'], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->like('title', '%Article%');\n            })\n            ->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->notLike('title', '%Article%');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->isNull('published');\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->isNotNull('published');\n            })\n            ->execute();\n        $this->assertCount(6, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->in('published', ['Y', 'N']);\n            })\n            ->execute();\n        $this->assertCount(6, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->in(\n                    'created',\n                    [new DateTime('2007-03-18 10:45:23'), new DateTime('2007-03-18 10:47:23')],\n                    'datetime'\n                );\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->notIn(\n                    'created',\n                    [new DateTime('2007-03-18 10:45:23'), new DateTime('2007-03-18 10:47:23')],\n                    'datetime'\n                );\n            })\n            ->execute();\n        $this->assertCount(4, $result);\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that calling \"in\" and \"notIn\" will cast the passed values to an array\n     */\n    public function testInValueCast(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->in('created', '2007-03-18 10:45:23', 'datetime');\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->notIn('created', '2007-03-18 10:45:23', 'datetime');\n            })\n            ->execute();\n        $this->assertCount(5, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                return $exp->in(\n                    'created',\n                    $q->newExpr(\"'2007-03-18 10:45:23'\"),\n                    'datetime'\n                );\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                return $exp->notIn(\n                    'created',\n                    $q->newExpr(\"'2007-03-18 10:45:23'\"),\n                    'datetime'\n                );\n            })\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that calling \"in\" and \"notIn\" will cast the passed values to an array\n     */\n    public function testInValueCast2(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created IN' => '2007-03-18 10:45:23'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created NOT IN' => '2007-03-18 10:45:23'])\n            ->execute();\n        $this->assertCount(5, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that IN clauses generate correct placeholders\n     */\n    public function testInClausePlaceholderGeneration(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('comments')\n            ->where(['id IN' => [1, 2]])\n            ->sql();\n        $bindings = $query->getValueBinder()->bindings();\n        $this->assertArrayHasKey(':c0', $bindings);\n        $this->assertSame('c0', $bindings[':c0']['placeholder']);\n        $this->assertArrayHasKey(':c1', $bindings);\n        $this->assertSame('c1', $bindings[':c1']['placeholder']);\n    }\n\n    /**\n     * Tests where() with callable types.\n     */\n    public function testWhereCallables(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->where([\n                'id' => 'Cake\\Error\\Debugger::dump',\n                'title' => ['Cake\\Error\\Debugger', 'dump'],\n                'author_id' => function ($exp) {\n                    return 1;\n                },\n            ]);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\(<id> = :c0 AND <title> = :c1 AND <author_id> = :c2\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that empty values don't set where clauses.\n     */\n    public function testWhereEmptyValues(): void\n    {\n        $query = new Query($this->connection);\n        $query->from('comments')\n            ->where('');\n\n        $this->assertCount(0, $query->clause('where'));\n\n        $query->where([]);\n        $this->assertCount(0, $query->clause('where'));\n    }\n\n    /**\n     * Tests that it is possible to use a between expression\n     * in a where condition\n     */\n    public function testWhereWithBetween(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->between('id', 5, 6, 'integer');\n            })\n            ->execute();\n\n        $this->assertCount(2, $result);\n        $first = $result->fetch('assoc');\n        $this->assertEquals(5, $first['id']);\n\n        $second = $result->fetch('assoc');\n        $this->assertEquals(6, $second['id']);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to use a between expression\n     * in a where condition with a complex data type\n     */\n    public function testWhereWithBetweenComplex(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $from = new DateTime('2007-03-18 10:51:00');\n                $to = new DateTime('2007-03-18 10:54:00');\n\n                return $exp->between('created', $from, $to, 'datetime');\n            })\n            ->execute();\n\n        $this->assertCount(2, $result);\n        $first = $result->fetch('assoc');\n        $this->assertEquals(4, $first['id']);\n\n        $second = $result->fetch('assoc');\n        $this->assertEquals(5, $second['id']);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to use an expression object\n     * as the field for a between expression\n     */\n    public function testWhereWithBetweenWithExpressionField(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                $field = $q->func()->coalesce([new IdentifierExpression('id'), 1 => 'literal']);\n\n                return $exp->between($field, 5, 6, 'integer');\n            })\n            ->execute();\n\n        $this->assertCount(2, $result);\n        $first = $result->fetch('assoc');\n        $this->assertEquals(5, $first['id']);\n\n        $second = $result->fetch('assoc');\n        $this->assertEquals(6, $second['id']);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to use an expression object\n     * as any of the parts of the between expression\n     */\n    public function testWhereWithBetweenWithExpressionParts(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp, $q) {\n                $from = $q->newExpr(\"'2007-03-18 10:51:00'\");\n                $to = $q->newExpr(\"'2007-03-18 10:54:00'\");\n\n                return $exp->between('created', $from, $to);\n            })\n            ->execute();\n\n        $this->assertCount(2, $result);\n        $first = $result->fetch('assoc');\n        $this->assertEquals(4, $first['id']);\n\n        $second = $result->fetch('assoc');\n        $this->assertEquals(5, $second['id']);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests nesting query expressions both using arrays and closures\n     */\n    public function testSelectExpressionComposition(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $and = $exp->and(['id' => 2, 'id >' => 1]);\n\n                return $exp->add($and);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $and = $exp->and(['id' => 2, 'id <' => 2]);\n\n                return $exp->add($and);\n            })\n            ->execute();\n        $this->assertCount(0, $result);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $and = $exp->and(function ($and) {\n                    return $and->eq('id', 1)->gt('id', 0);\n                });\n\n                return $exp->add($and);\n            })\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $or = $exp->or(['id' => 1]);\n                $and = $exp->and(['id >' => 2, 'id <' => 4]);\n\n                return $or->add($and);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                $or = $exp->or(function ($or) {\n                    return $or->eq('id', 1)->eq('id', 2);\n                });\n\n                return $or;\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that conditions can be nested with an unary operator using the array notation\n     * and the not() method\n     */\n    public function testSelectWhereNot(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->not(\n                    $exp->and(['id' => 2, 'created' => new DateTime('2007-03-18 10:47:23')], ['created' => 'datetime'])\n                );\n            })\n            ->execute();\n        $this->assertCount(5, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->where(function ($exp) {\n                return $exp->not(\n                    $exp->and(['id' => 2, 'created' => new DateTime('2012-12-21 12:00')], ['created' => 'datetime'])\n                );\n            })\n            ->execute();\n        $this->assertCount(6, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that conditions can be nested with an unary operator using the array notation\n     * and the not() method\n     */\n    public function testSelectWhereNot2(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('articles')\n            ->where([\n                'not' => ['or' => ['id' => 1, 'id >' => 2], 'id' => 3],\n            ])\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests whereInArray() and its input types.\n     */\n    public function testWhereInArray(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereInList('id', [2, 3])\n            ->order(['id']);\n\n        $sql = $query->sql();\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE <id> in \\\\(:c0,:c1\\\\)',\n            $sql,\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '2'], $result[0]);\n    }\n\n    /**\n     * Tests whereInArray() and empty array input.\n     */\n    public function testWhereInArrayEmpty(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereInList('id', [], ['allowEmpty' => true]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE 1=0',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $statement = $query->execute();\n        $this->assertFalse($statement->fetch('assoc'));\n        $statement->closeCursor();\n    }\n\n    /**\n     * Tests whereNotInList() and its input types.\n     */\n    public function testWhereNotInList(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereNotInList('id', [1, 3]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE <id> not in \\\\(:c0,:c1\\\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '2'], $result[0]);\n    }\n\n    /**\n     * Tests whereNotInList() and empty array input.\n     */\n    public function testWhereNotInListEmpty(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereNotInList('id', [], ['allowEmpty' => true])\n            ->order(['id']);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\(<id>\\) IS NOT NULL',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '1'], $result[0]);\n    }\n\n    /**\n     * Tests whereNotInListOrNull() and its input types.\n     */\n    public function testWhereNotInListOrNull(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereNotInListOrNull('id', [1, 3]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\\\(<id> not in \\\\(:c0,:c1\\\\) OR \\\\(<id>\\\\) IS NULL\\\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '2'], $result[0]);\n    }\n\n    /**\n     * Tests whereNotInListOrNull() and empty array input.\n     */\n    public function testWhereNotInListOrNullEmpty(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->whereNotInListOrNull('id', [], ['allowEmpty' => true])\n            ->order(['id']);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE \\(<id>\\) IS NOT NULL',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals(['id' => '1'], $result[0]);\n    }\n\n    /**\n     * Tests order() method both with simple fields and expressions\n     */\n    public function testSelectOrderBy(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id'])\n            ->from('comments')\n            ->order(['id' => 'desc'])\n            ->execute();\n        $this->assertEquals(['id' => 6], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->order(['id' => 'asc'])->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->order(['comment' => 'asc'])->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->order(['comment' => 'asc'], true)->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query->order(['user_id' => 'asc', 'created' => 'desc'], true)\n            ->execute();\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $expression = $query->newExpr(['(id + :offset) % 2']);\n        $result = $query\n            ->order([$expression, 'id' => 'desc'], true)\n            ->bind(':offset', 1, null)\n            ->execute();\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $result->closeCursor();\n\n        $result = $query\n            ->order($expression, true)\n            ->order(['id' => 'asc'])\n            ->bind(':offset', 1, null)\n            ->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 5], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Test that order() being a string works.\n     */\n    public function testSelectOrderByString(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->order('id asc');\n        $result = $query->execute();\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Test exception for order() with an associative array which contains extra values.\n     */\n    public function testSelectOrderByAssociativeArrayContainingExtraExpressions(): void\n    {\n        $this->expectException('RuntimeException');\n        $this->expectExceptionMessage(\n            'Passing extra expressions by associative array (`\\'id\\' => \\'desc -- Comment\\'`) ' .\n            'is not allowed to avoid potential SQL injection. ' .\n            'Use QueryExpression or numeric array instead.'\n        );\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->order([\n                'id' => 'desc -- Comment',\n            ]);\n    }\n\n    /**\n     * Tests that order() works with closures.\n     */\n    public function testSelectOrderByClosure(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->select('*')\n            ->from('articles')\n            ->order(function ($exp, $q) use ($query) {\n                $this->assertInstanceOf(QueryExpression::class, $exp);\n                $this->assertSame($query, $q);\n\n                return ['id' => 'ASC'];\n            });\n\n        $this->assertQuotedQuery(\n            'SELECT \\* FROM <articles> ORDER BY <id> ASC',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query\n            ->select('*')\n            ->from('articles')\n            ->order(function ($exp) {\n                return [$exp->add(['id % 2 = 0']), 'title' => 'ASC'];\n            });\n\n        $this->assertQuotedQuery(\n            'SELECT \\* FROM <articles> ORDER BY id % 2 = 0, <title> ASC',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query\n            ->select('*')\n            ->from('articles')\n            ->order(function ($exp) {\n                return $exp->add('a + b');\n            });\n\n        $this->assertQuotedQuery(\n            'SELECT \\* FROM <articles> ORDER BY a \\+ b',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query\n            ->select('*')\n            ->from('articles')\n            ->order(function ($exp, $q) {\n                return $q->func()->sum('a');\n            });\n\n        $this->assertQuotedQuery(\n            'SELECT \\* FROM <articles> ORDER BY SUM\\(a\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test orderAsc() and its input types.\n     */\n    public function testSelectOrderAsc(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderAsc('id');\n\n        $sql = $query->sql();\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 1],\n            ['id' => 2],\n            ['id' => 3],\n        ];\n        $this->assertEquals($expected, $result);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY <id> ASC',\n            $sql,\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderAsc($query->func()->concat(['id' => 'identifier', '3']));\n\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 1],\n            ['id' => 2],\n            ['id' => 3],\n        ];\n        $this->assertEquals($expected, $result);\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderAsc(function (QueryExpression $exp, Query $query) {\n                return $exp\n                    ->case()\n                    ->when(['author_id' => 1])\n                    ->then(1)\n                    ->else($query->identifier('id'));\n            })\n            ->orderAsc('id');\n        $sql = $query->sql();\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 1],\n            ['id' => 3],\n            ['id' => 2],\n        ];\n        $this->assertEquals($expected, $result);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY CASE WHEN <author_id> = :c0 THEN :c1 ELSE <id> END ASC, <id> ASC',\n            $sql,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test orderDesc() and its input types.\n     */\n    public function testSelectOrderDesc(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderDesc('id');\n        $sql = $query->sql();\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 3],\n            ['id' => 2],\n            ['id' => 1],\n        ];\n        $this->assertEquals($expected, $result);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY <id> DESC',\n            $sql,\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderDesc($query->func()->concat(['id' => 'identifier', '3']));\n\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 3],\n            ['id' => 2],\n            ['id' => 1],\n        ];\n        $this->assertEquals($expected, $result);\n\n        $query = new Query($this->connection);\n        $query->select(['id'])\n            ->from('articles')\n            ->orderDesc(function (QueryExpression $exp, Query $query) {\n                return $exp\n                    ->case()\n                    ->when(['author_id' => 1])\n                    ->then(1)\n                    ->else($query->identifier('id'));\n            })\n            ->orderDesc('id');\n        $sql = $query->sql();\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 2],\n            ['id' => 3],\n            ['id' => 1],\n        ];\n        $this->assertEquals($expected, $result);\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY CASE WHEN <author_id> = :c0 THEN :c1 ELSE <id> END DESC, <id> DESC',\n            $sql,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that group by fields can be passed similar to select fields\n     * and that it sends the correct query to the database\n     */\n    public function testSelectGroup(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => 'author_id = a.id'])\n            ->group('author_id')\n            ->order(['total' => 'desc'])\n            ->execute();\n        $expected = [['total' => 2, 'author_id' => 1], ['total' => '1', 'author_id' => 3]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $result = $query->select(['total' => 'count(title)', 'name'], true)\n            ->group(['name'], true)\n            ->order(['total' => 'asc'])\n            ->execute();\n        $expected = [['total' => 1, 'name' => 'larry'], ['total' => 2, 'name' => 'mariano']];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $result = $query->select(['articles.id'])\n            ->group(['articles.id'])\n            ->execute();\n        $this->assertCount(3, $result);\n    }\n\n    /**\n     * Tests that it is possible to select distinct rows\n     */\n    public function testSelectDistinct(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['author_id'])\n            ->from(['a' => 'articles'])\n            ->execute();\n        $this->assertCount(3, $result);\n\n        $result = $query->distinct()->execute();\n        $this->assertCount(2, $result);\n\n        $result = $query->select(['id'])->distinct(false)->execute();\n        $this->assertCount(3, $result);\n    }\n\n    /**\n     * Tests distinct on a specific column reduces rows based on that column.\n     */\n    public function testSelectDistinctON(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['author_id'])\n            ->distinct(['author_id'])\n            ->from(['a' => 'articles'])\n            ->order(['author_id' => 'ASC'])\n            ->execute();\n        $this->assertCount(2, $result);\n        $results = $result->fetchAll('assoc');\n        $this->assertEquals(\n            [3, 1],\n            collection($results)->sortBy('author_id')->extract('author_id')->toList()\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['author_id'])\n            ->distinct('author_id')\n            ->from(['a' => 'articles'])\n            ->order(['author_id' => 'ASC'])\n            ->execute();\n        $this->assertCount(2, $result);\n        $results = $result->fetchAll('assoc');\n        $this->assertEquals(\n            [3, 1],\n            collection($results)->sortBy('author_id')->extract('author_id')->toList()\n        );\n    }\n\n    /**\n     * Test use of modifiers in the query\n     *\n     * Testing the generated SQL since the modifiers are usually different per driver\n     */\n    public function testSelectModifiers(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier('DISTINCTROW');\n        $this->assertQuotedQuery(\n            'SELECT DISTINCTROW <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier(['DISTINCTROW', 'SQL_NO_CACHE']);\n        $this->assertQuotedQuery(\n            'SELECT DISTINCTROW SQL_NO_CACHE <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier('DISTINCTROW')\n            ->modifier('SQL_NO_CACHE');\n        $this->assertQuotedQuery(\n            'SELECT DISTINCTROW SQL_NO_CACHE <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            true\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier(['TOP 10']);\n        $this->assertQuotedQuery(\n            'SELECT TOP 10 <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['city', 'state', 'country'])\n            ->from(['addresses'])\n            ->modifier($query->newExpr('EXPRESSION'));\n        $this->assertQuotedQuery(\n            'SELECT EXPRESSION <city>, <state>, <country> FROM <addresses>',\n            $result->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that having() behaves pretty much the same as the where() method\n     */\n    public function testSelectHaving(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->group('author_id')\n            ->having(['count(author_id) <' => 2], ['count(author_id)' => 'integer'])\n            ->execute();\n        $expected = [['total' => 1, 'author_id' => 3]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $result = $query->having(['count(author_id)' => 2], ['count(author_id)' => 'integer'], true)\n            ->execute();\n        $expected = [['total' => 2, 'author_id' => 1]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $result = $query->having(function ($e) {\n            return $e->add('count(author_id) = 1 + 1');\n        }, [], true)\n            ->execute();\n        $expected = [['total' => 2, 'author_id' => 1]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n    }\n\n    /**\n     * Tests that Query::andHaving() can be used to concatenate conditions with AND\n     * in the having clause\n     */\n    public function testSelectAndHaving(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->group('author_id')\n            ->having(['count(author_id) >' => 2], ['count(author_id)' => 'integer'])\n            ->andHaving(['count(author_id) <' => 2], ['count(author_id)' => 'integer'])\n            ->execute();\n        $this->assertCount(0, $result);\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->group('author_id')\n            ->having(['count(author_id)' => 2], ['count(author_id)' => 'integer'])\n            ->andHaving(['count(author_id) >' => 1], ['count(author_id)' => 'integer'])\n            ->execute();\n        $expected = [['total' => 2, 'author_id' => 1]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['total' => 'count(author_id)', 'author_id'])\n            ->from('articles')\n            ->join(['table' => 'authors', 'alias' => 'a', 'conditions' => $query->newExpr()->equalFields('author_id', 'a.id')])\n            ->group('author_id')\n            ->andHaving(function ($e) {\n                return $e->add('count(author_id) = 2 - 1');\n            })\n            ->execute();\n        $expected = [['total' => 1, 'author_id' => 3]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n    }\n\n    /**\n     * Test having casing with string expressions\n     */\n    public function testHavingAliasCasingStringExpression(): void\n    {\n        $this->skipIf($this->autoQuote, 'Does not work when autoquoting is enabled.');\n        $query = new Query($this->connection);\n        $query\n            ->select(['id'])\n            ->from(['Authors' => 'authors'])\n            ->where([\n                'FUNC( Authors.id) =' => 1,\n                'FUNC( Authors.id) IS NOT' => null,\n            ])\n            ->having(['COUNT(DISTINCT Authors.id) =' => 1]);\n\n        $this->assertSame(\n            'SELECT id FROM authors Authors WHERE ' .\n            '(FUNC( Authors.id) = :c0 AND (FUNC( Authors.id)) IS NOT NULL) ' .\n            'HAVING COUNT(DISTINCT Authors.id) = :c1',\n            trim($query->sql())\n        );\n    }\n\n    /**\n     * Tests selecting rows using a limit clause\n     */\n    public function testSelectLimit(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('articles')->limit(1)->execute();\n        $this->assertCount(1, $result);\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('articles')->limit(2)->execute();\n        $this->assertCount(2, $result);\n    }\n\n    /**\n     * Tests selecting rows with string offset/limit\n     */\n    public function testSelectLimitInvalid(): void\n    {\n        $query = new Query($this->connection);\n        $this->expectException(InvalidArgumentException::class);\n        $query->select('id')->from('comments')\n            ->limit('1 --more')\n            ->order(['id' => 'ASC'])\n            ->execute();\n    }\n\n    /**\n     * Tests selecting rows with string offset/limit\n     */\n    public function testSelectOffsetInvalid(): void\n    {\n        $query = new Query($this->connection);\n        $this->expectException(InvalidArgumentException::class);\n        $query->select('id')->from('comments')\n            ->offset('1 --more')\n            ->order(['id' => 'ASC'])\n            ->execute();\n    }\n\n    /**\n     * Tests selecting rows combining a limit and offset clause\n     */\n    public function testSelectOffset(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->offset(0)\n            ->order(['id' => 'ASC'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->offset(1)\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->offset(2)\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('articles')\n            ->order(['id' => 'DESC'])\n            ->limit(1)\n            ->offset(0)\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n\n        $result = $query->limit(2)->offset(1)->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $query->select('id')->from('comments')\n            ->limit(1)\n            ->offset(1)\n            ->execute()\n            ->closeCursor();\n\n        $reflect = new ReflectionProperty($query, '_dirty');\n        $reflect->setAccessible(true);\n        $this->assertFalse($reflect->getValue($query));\n\n        $query->offset(2);\n        $this->assertTrue($reflect->getValue($query));\n    }\n\n    /**\n     * Test Pages number.\n     */\n    public function testPageShouldStartAtOne(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage('Pages must start at 1.');\n\n        $query = new Query($this->connection);\n        $result = $query->from('comments')->page(0);\n    }\n\n    /**\n     * Test selecting rows using the page() method.\n     */\n    public function testSelectPage(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->page(1)\n            ->execute();\n\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select('id')->from('comments')\n            ->limit(1)\n            ->page(2)\n            ->order(['id' => 'asc'])\n            ->execute();\n        $this->assertCount(1, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $query->select('id')->from('comments')->page(3, 10);\n        $this->assertEquals(10, $query->clause('limit'));\n        $this->assertEquals(20, $query->clause('offset'));\n\n        $query = new Query($this->connection);\n        $query->select('id')->from('comments')->page(1);\n        $this->assertEquals(25, $query->clause('limit'));\n        $this->assertEquals(0, $query->clause('offset'));\n\n        $query->select('id')->from('comments')->page(2);\n        $this->assertEquals(25, $query->clause('limit'));\n        $this->assertEquals(25, $query->clause('offset'));\n    }\n\n    /**\n     * Test selecting rows using the page() method and ordering the results\n     * by a calculated column.\n     */\n    public function testSelectPageWithOrder(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select([\n                'id',\n                'ids_added' => $query->newExpr()->add('(user_id + article_id)'),\n            ])\n            ->from('comments')\n            ->order(['ids_added' => 'asc'])\n            ->limit(2)\n            ->page(3)\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(\n            [\n                ['id' => '6', 'ids_added' => '4'],\n                ['id' => '2', 'ids_added' => '5'],\n            ],\n            $result->fetchAll('assoc')\n        );\n    }\n\n    /**\n     * Tests that Query objects can be included inside the select clause\n     * and be used as a normal field, including binding any passed parameter\n     */\n    public function testSubqueryInSelect(): void\n    {\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select('name')\n            ->from(['b' => 'authors'])\n            ->where([$query->newExpr()->equalFields('b.id', 'a.id')]);\n        $result = $query\n            ->select(['id', 'name' => $subquery])\n            ->from(['a' => 'comments'])->execute();\n\n        $expected = [\n            ['id' => 1, 'name' => 'mariano'],\n            ['id' => 2, 'name' => 'nate'],\n            ['id' => 3, 'name' => 'larry'],\n            ['id' => 4, 'name' => 'garrett'],\n            ['id' => 5, 'name' => null],\n            ['id' => 6, 'name' => null],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select('name')\n            ->from(['b' => 'authors'])\n            ->where(['name' => 'mariano'], ['name' => 'string']);\n        $result = $query\n            ->select(['id', 'name' => $subquery])\n            ->from(['a' => 'articles'])->execute();\n\n        $expected = [\n            ['id' => 1, 'name' => 'mariano'],\n            ['id' => 2, 'name' => 'mariano'],\n            ['id' => 3, 'name' => 'mariano'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n    }\n\n    /**\n     * Tests that Query objects can be included inside the from clause\n     * and be used as a normal table, including binding any passed parameter\n     */\n    public function testSuqueryInFrom(): void\n    {\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select(['id', 'comment'])\n            ->from('comments')\n            ->where(['created >' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime']);\n        $result = $query\n            ->select(['say' => 'comment'])\n            ->from(['b' => $subquery])\n            ->where(['id !=' => 3])\n            ->execute();\n\n        $expected = [\n            ['say' => 'Second Comment for First Article'],\n            ['say' => 'Fourth Comment for First Article'],\n            ['say' => 'First Comment for Second Article'],\n            ['say' => 'Second Comment for Second Article'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n    }\n\n    /**\n     * Tests that Query objects can be included inside the where clause\n     * and be used as a normal condition, including binding any passed parameter\n     */\n    public function testSubqueryInWhere(): void\n    {\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('authors')\n            ->where(['id' => 1]);\n        $result = $query\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['id !=' => $subquery])\n            ->execute();\n\n        $expected = [\n            ['name' => 'nate'],\n            ['name' => 'larry'],\n            ['name' => 'garrett'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('comments')\n            ->where(['created >' => new DateTime('2007-03-18 10:45:23')], ['created' => 'datetime']);\n        $result = $query\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['id not in' => $subquery])\n            ->execute();\n\n        $expected = [\n            ['name' => 'mariano'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that Query objects can be included inside the where clause\n     * and be used as a EXISTS and NOT EXISTS conditions\n     */\n    public function testSubqueryExistsWhere(): void\n    {\n        $query = new Query($this->connection);\n        $subQuery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->equalFields('authors.id', 'articles.author_id');\n            });\n        $result = $query\n            ->select(['id'])\n            ->from('authors')\n            ->where(function ($exp) use ($subQuery) {\n                return $exp->exists($subQuery);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 1], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 3], $result->fetch('assoc'));\n\n        $query = new Query($this->connection);\n        $subQuery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('articles')\n            ->where(function ($exp) {\n                return $exp->equalFields('authors.id', 'articles.author_id');\n            });\n        $result = $query\n            ->select(['id'])\n            ->from('authors')\n            ->where(function ($exp) use ($subQuery) {\n                return $exp->notExists($subQuery);\n            })\n            ->execute();\n        $this->assertCount(2, $result);\n        $this->assertEquals(['id' => 2], $result->fetch('assoc'));\n        $this->assertEquals(['id' => 4], $result->fetch('assoc'));\n    }\n\n    /**\n     * Tests that it is possible to use a subquery in a join clause\n     */\n    public function testSubqueryInJoin(): void\n    {\n        $subquery = (new Query($this->connection))->select('*')->from('authors');\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['title', 'name'])\n            ->from('articles')\n            ->join(['b' => $subquery])\n            ->execute();\n        $this->assertCount(self::ARTICLE_COUNT * self::AUTHOR_COUNT, $result, 'Cross join causes multiplication');\n        $result->closeCursor();\n\n        $subquery->where(['id' => 1]);\n        $result = $query->execute();\n        $this->assertCount(3, $result);\n        $result->closeCursor();\n\n        $query->join(['b' => ['table' => $subquery, 'conditions' => [$query->newExpr()->equalFields('b.id', 'articles.id')]]], [], true);\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to one or multiple UNION statements in a query\n     */\n    public function testUnion(): void\n    {\n        $union = (new Query($this->connection))->select(['id', 'title'])->from(['a' => 'articles']);\n        $query = new Query($this->connection);\n        $result = $query->select(['id', 'comment'])\n            ->from(['c' => 'comments'])\n            ->union($union)\n            ->execute();\n        $this->assertCount(self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n        $rows = $result->fetchAll();\n        $result->closeCursor();\n\n        $union->select(['foo' => 'id', 'bar' => 'title']);\n        $union = (new Query($this->connection))\n            ->select(['id', 'name', 'other' => 'id', 'nameish' => 'name'])\n            ->from(['b' => 'authors'])\n            ->where(['id ' => 1])\n            ->order(['id' => 'desc']);\n\n        $query->select(['foo' => 'id', 'bar' => 'comment'])->union($union);\n        $result = $query->execute();\n        $this->assertCount(self::COMMENT_COUNT + self::AUTHOR_COUNT, $result);\n        $this->assertNotEquals($rows, $result->fetchAll());\n        $result->closeCursor();\n\n        $union = (new Query($this->connection))\n            ->select(['id', 'title'])\n            ->from(['c' => 'articles']);\n        $query->select(['id', 'comment'], true)->union($union, true);\n        $result = $query->execute();\n        $this->assertCount(self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n        $this->assertEquals($rows, $result->fetchAll());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that it is possible to run unions with order statements\n     */\n    public function testUnionOrderBy(): void\n    {\n        $this->skipIf(\n            ($this->connection->getDriver() instanceof Sqlite ||\n            $this->connection->getDriver() instanceof Sqlserver),\n            'Driver does not support ORDER BY in UNIONed queries.'\n        );\n        $union = (new Query($this->connection))\n            ->select(['id', 'title'])\n            ->from(['a' => 'articles'])\n            ->order(['a.id' => 'asc']);\n\n        $query = new Query($this->connection);\n        $result = $query->select(['id', 'comment'])\n            ->from(['c' => 'comments'])\n            ->order(['c.id' => 'asc'])\n            ->union($union)\n            ->execute();\n        $this->assertCount(self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n\n        $rows = $result->fetchAll();\n        $this->assertCount(self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n    }\n\n    /**\n     * Tests that UNION ALL can be built by setting the second param of union() to true\n     */\n    public function testUnionAll(): void\n    {\n        $union = (new Query($this->connection))->select(['id', 'title'])->from(['a' => 'articles']);\n        $query = new Query($this->connection);\n        $result = $query->select(['id', 'comment'])\n            ->from(['c' => 'comments'])\n            ->union($union)\n            ->execute();\n        $this->assertCount(self::ARTICLE_COUNT + self::COMMENT_COUNT, $result);\n        $rows = $result->fetchAll();\n        $result->closeCursor();\n\n        $union->select(['foo' => 'id', 'bar' => 'title']);\n        $union = (new Query($this->connection))\n            ->select(['id', 'name', 'other' => 'id', 'nameish' => 'name'])\n            ->from(['b' => 'authors'])\n            ->where(['id ' => 1])\n            ->order(['id' => 'desc']);\n\n        $query->select(['foo' => 'id', 'bar' => 'comment'])->unionAll($union);\n        $result = $query->execute();\n        $this->assertCount(1 + self::COMMENT_COUNT + self::ARTICLE_COUNT, $result);\n        $this->assertNotEquals($rows, $result->fetchAll());\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests stacking decorators for results and resetting the list of decorators\n     */\n    public function testDecorateResults(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['id', 'title'])\n            ->from('articles')\n            ->order(['id' => 'ASC'])\n            ->decorateResults(function ($row) {\n                $row['modified_id'] = $row['id'] + 1;\n\n                return $row;\n            })\n            ->execute();\n\n        while ($row = $result->fetch('assoc')) {\n            $this->assertEquals($row['id'] + 1, $row['modified_id']);\n        }\n\n        $result = $query->decorateResults(function ($row) {\n            $row['modified_id']--;\n\n            return $row;\n        })->execute();\n\n        while ($row = $result->fetch('assoc')) {\n            $this->assertEquals($row['id'], $row['modified_id']);\n        }\n        $result->closeCursor();\n\n        $result = $query\n            ->decorateResults(function ($row) {\n                $row['foo'] = 'bar';\n\n                return $row;\n            }, true)\n            ->execute();\n\n        while ($row = $result->fetch('assoc')) {\n            $this->assertSame('bar', $row['foo']);\n            $this->assertArrayNotHasKey('modified_id', $row);\n        }\n\n        $results = $query->decorateResults(null, true)->execute();\n        while ($row = $results->fetch('assoc')) {\n            $this->assertArrayNotHasKey('foo', $row);\n            $this->assertArrayNotHasKey('modified_id', $row);\n        }\n        $results->closeCursor();\n    }\n\n    /**\n     * Test a basic delete using from()\n     */\n    public function testDeleteWithFrom(): void\n    {\n        $query = new Query($this->connection);\n\n        $query->delete()\n            ->from('authors')\n            ->where('1 = 1');\n\n        $result = $query->sql();\n        $this->assertQuotedQuery('DELETE FROM <authors>', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertCount(self::AUTHOR_COUNT, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test delete with from and alias.\n     */\n    public function testDeleteWithAliasedFrom(): void\n    {\n        $query = new Query($this->connection);\n\n        $query->delete()\n            ->from(['a ' => 'authors'])\n            ->where(['a.id !=' => 99]);\n\n        $result = $query->sql();\n        $this->assertQuotedQuery('DELETE FROM <authors> WHERE <id> != :c0', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertCount(self::AUTHOR_COUNT, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test a basic delete with no from() call.\n     */\n    public function testDeleteNoFrom(): void\n    {\n        $query = new Query($this->connection);\n\n        $query->delete('authors')\n            ->where('1 = 1');\n\n        $result = $query->sql();\n        $this->assertQuotedQuery('DELETE FROM <authors>', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertInstanceOf('Cake\\Database\\StatementInterface', $result);\n        $this->assertCount(self::AUTHOR_COUNT, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests that delete queries that contain joins do trigger a notice,\n     * warning about possible incompatibilities with aliases being removed\n     * from the conditions.\n     */\n    public function testDeleteRemovingAliasesCanBreakJoins(): void\n    {\n        $this->expectException(RuntimeException::class);\n        $this->expectExceptionMessage('Aliases are being removed from conditions for UPDATE/DELETE queries, this can break references to joined tables.');\n        $query = new Query($this->connection);\n\n        $query\n            ->delete('authors')\n            ->from(['a ' => 'authors'])\n            ->innerJoin('articles')\n            ->where(['a.id' => 1]);\n\n        $query->sql();\n    }\n\n    /**\n     * Tests that aliases are stripped from delete query conditions\n     * where possible.\n     */\n    public function testDeleteStripAliasesFromConditions(): void\n    {\n        $query = new Query($this->connection);\n\n        $query\n            ->delete()\n            ->from(['a' => 'authors'])\n            ->where([\n                'OR' => [\n                    'a.id' => 1,\n                    'a.name IS' => null,\n                    'a.email IS NOT' => null,\n                    'AND' => [\n                        'b.name NOT IN' => ['foo', 'bar'],\n                        'OR' => [\n                            $query->newExpr()->eq(new IdentifierExpression('c.name'), 'zap'),\n                            'd.name' => 'baz',\n                            (new Query($this->connection))->select(['e.name'])->where(['e.name' => 'oof']),\n                        ],\n                    ],\n                ],\n            ]);\n\n        $this->assertQuotedQuery(\n            'DELETE FROM <authors> WHERE \\(' .\n                '<id> = :c0 OR \\(<name>\\) IS NULL OR \\(<email>\\) IS NOT NULL OR \\(' .\n                    '<name> not in \\(:c1,:c2\\) AND \\(' .\n                        '<name> = :c3 OR <name> = :c4 OR \\(SELECT <e>\\.<name> WHERE <e>\\.<name> = :c5\\)' .\n                    '\\)' .\n                '\\)' .\n            '\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test setting select() & delete() modes.\n     */\n    public function testSelectAndDeleteOnSameQuery(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select()\n            ->delete('authors')\n            ->where('1 = 1');\n        $result = $query->sql();\n\n        $this->assertQuotedQuery('DELETE FROM <authors>', $result, !$this->autoQuote);\n        $this->assertStringContainsString(' WHERE 1 = 1', $result);\n    }\n\n    /**\n     * Test a simple update.\n     */\n    public function testUpdateSimple(): void\n    {\n        $query = new Query($this->connection);\n        $query->update('authors')\n            ->set('name', 'mark')\n            ->where(['id' => 1]);\n        $result = $query->sql();\n        $this->assertQuotedQuery('UPDATE <authors> SET <name> = :', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test update with type checking\n     * by passing an array as table arg\n     */\n    public function testUpdateArgTypeChecking(): void\n    {\n        $this->expectException(\\InvalidArgumentException::class);\n        $query = new Query($this->connection);\n        $query->update(['Articles']);\n    }\n\n    /**\n     * Test update with multiple fields.\n     */\n    public function testUpdateMultipleFields(): void\n    {\n        $query = new Query($this->connection);\n        $query->update('articles')\n            ->set('title', 'mark', 'string')\n            ->set('body', 'some text', 'string')\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <articles> SET <title> = :c0 , <body> = :c1',\n            $result,\n            !$this->autoQuote\n        );\n\n        $this->assertQuotedQuery(' WHERE <id> = :c2$', $result, !$this->autoQuote);\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test updating multiple fields with an array.\n     */\n    public function testUpdateMultipleFieldsArray(): void\n    {\n        $query = new Query($this->connection);\n        $query->update('articles')\n            ->set([\n                'title' => 'mark',\n                'body' => 'some text',\n            ], ['title' => 'string', 'body' => 'string'])\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <articles> SET <title> = :c0 , <body> = :c1',\n            $result,\n            !$this->autoQuote\n        );\n        $this->assertQuotedQuery('WHERE <id> = :', $result, !$this->autoQuote);\n\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Test updates with an expression.\n     */\n    public function testUpdateWithExpression(): void\n    {\n        $query = new Query($this->connection);\n\n        $expr = $query->newExpr()->equalFields('article_id', 'user_id');\n\n        $query->update('comments')\n            ->set($expr)\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <comments> SET <article_id> = <user_id> WHERE <id> = :',\n            $result,\n            !$this->autoQuote\n        );\n\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n        $result->closeCursor();\n    }\n\n    /**\n     * Tests update with subquery that references itself\n     */\n    public function testUpdateSubquery(): void\n    {\n        $this->skipIf($this->connection->getDriver() instanceof Mysql);\n\n        $subquery = new Query($this->connection);\n        $subquery\n            ->select('created')\n            ->from(['c' => 'comments'])\n            ->where(['c.id' => new IdentifierExpression('comments.id')]);\n\n        $query = new Query($this->connection);\n        $query->update('comments')\n            ->set('updated', $subquery);\n\n        $this->assertEqualsSql(\n            'UPDATE comments SET updated = (SELECT created FROM comments c WHERE c.id = comments.id)',\n            $query->sql(new ValueBinder())\n        );\n\n        $result = $query->execute();\n        $this->assertCount(6, $result);\n        $result->closeCursor();\n\n        $result = (new Query($this->connection))->select(['created', 'updated'])->from('comments')->execute();\n        foreach ($result->fetchAll('assoc') as $row) {\n            $this->assertSame($row['created'], $row['updated']);\n        }\n        $result->closeCursor();\n    }\n\n    /**\n     * Test update with array fields and types.\n     */\n    public function testUpdateArrayFields(): void\n    {\n        $query = new Query($this->connection);\n        $date = new DateTime();\n        $query->update('comments')\n            ->set(['comment' => 'mark', 'created' => $date], ['created' => 'date'])\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <comments> SET <comment> = :c0 , <created> = :c1',\n            $result,\n            !$this->autoQuote\n        );\n\n        $this->assertQuotedQuery(' WHERE <id> = :c2$', $result, !$this->autoQuote);\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n\n        $query = new Query($this->connection);\n        $result = $query->select('created')->from('comments')->where(['id' => 1])->execute();\n        $result = $result->fetchAll('assoc')[0]['created'];\n        $this->assertStringStartsWith($date->format('Y-m-d'), $result);\n    }\n\n    /**\n     * Test update with callable in set\n     */\n    public function testUpdateSetCallable(): void\n    {\n        $query = new Query($this->connection);\n        $date = new DateTime();\n        $query->update('comments')\n            ->set(function ($exp) use ($date) {\n                return $exp\n                    ->eq('comment', 'mark')\n                    ->eq('created', $date, 'date');\n            })\n            ->where(['id' => 1]);\n        $result = $query->sql();\n\n        $this->assertQuotedQuery(\n            'UPDATE <comments> SET <comment> = :c0 , <created> = :c1',\n            $result,\n            !$this->autoQuote\n        );\n\n        $this->assertQuotedQuery(' WHERE <id> = :c2$', $result, !$this->autoQuote);\n        $result = $query->execute();\n        $this->assertCount(1, $result);\n    }\n\n    /**\n     * Tests that aliases are stripped from update query conditions\n     * where possible.\n     */\n    public function testUpdateStripAliasesFromConditions(): void\n    {\n        $query = new Query($this->connection);\n\n        $query\n            ->update('authors')\n            ->set(['name' => 'name'])\n            ->where([\n                'OR' => [\n                    'a.id' => 1,\n                    'a.name IS' => null,\n                    'a.email IS NOT' => null,\n                    'AND' => [\n                        'b.name NOT IN' => ['foo', 'bar'],\n                        'OR' => [\n                            $query->newExpr()->eq(new IdentifierExpression('c.name'), 'zap'),\n                            'd.name' => 'baz',\n                            (new Query($this->connection))->select(['e.name'])->where(['e.name' => 'oof']),\n                        ],\n                    ],\n                ],\n            ]);\n\n        $this->assertQuotedQuery(\n            'UPDATE <authors> SET <name> = :c0 WHERE \\(' .\n                '<id> = :c1 OR \\(<name>\\) IS NULL OR \\(<email>\\) IS NOT NULL OR \\(' .\n                    '<name> not in \\(:c2,:c3\\) AND \\(' .\n                        '<name> = :c4 OR <name> = :c5 OR \\(SELECT <e>\\.<name> WHERE <e>\\.<name> = :c6\\)' .\n                    '\\)' .\n                '\\)' .\n            '\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Tests that update queries that contain joins do trigger a notice,\n     * warning about possible incompatibilities with aliases being removed\n     * from the conditions.\n     */\n    public function testUpdateRemovingAliasesCanBreakJoins(): void\n    {\n        $this->expectException(RuntimeException::class);\n        $this->expectExceptionMessage('Aliases are being removed from conditions for UPDATE/DELETE queries, this can break references to joined tables.');\n        $query = new Query($this->connection);\n\n        $query\n            ->update('authors')\n            ->set(['name' => 'name'])\n            ->innerJoin('articles')\n            ->where(['a.id' => 1]);\n\n        $query->sql();\n    }\n\n    /**\n     * You cannot call values() before insert() it causes all sorts of pain.\n     */\n    public function testInsertValuesBeforeInsertFailure(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $query = new Query($this->connection);\n        $query->select('*')->values([\n            'id' => 1,\n            'title' => 'mark',\n            'body' => 'test insert',\n        ]);\n    }\n\n    /**\n     * Inserting nothing should not generate an error.\n     */\n    public function testInsertNothing(): void\n    {\n        $this->expectException(RuntimeException::class);\n        $this->expectExceptionMessage('At least 1 column is required to perform an insert.');\n        $query = new Query($this->connection);\n        $query->insert([]);\n    }\n\n    /**\n     * Test insert() with no into()\n     */\n    public function testInsertNoInto(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $this->expectExceptionMessage('Could not compile insert query. No table was specified');\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])->sql();\n    }\n\n    /**\n     * Test insert overwrites values\n     */\n    public function testInsertOverwritesValues(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])\n            ->insert(['title'])\n            ->into('articles')\n            ->values([\n                'title' => 'mark',\n            ]);\n\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<title>\\) (OUTPUT INSERTED\\.\\* )?' .\n            'VALUES \\(:c0\\)',\n            $result,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test inserting a single row.\n     */\n    public function testInsertSimple(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])\n            ->into('articles')\n            ->values([\n                'title' => 'mark',\n                'body' => 'test insert',\n            ]);\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<title>, <body>\\) (OUTPUT INSERTED\\.\\* )?' .\n            'VALUES \\(:c0, :c1\\)',\n            $result,\n            !$this->autoQuote\n        );\n\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result, '1 row should be inserted');\n        }\n\n        $expected = [\n            [\n                'id' => 4,\n                'author_id' => null,\n                'title' => 'mark',\n                'body' => 'test insert',\n                'published' => 'N',\n            ],\n        ];\n        $this->assertTable('articles', 1, $expected, ['id >=' => 4]);\n    }\n\n    /**\n     * Test insert queries quote integer column names\n     */\n    public function testInsertQuoteColumns(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert([123])\n            ->into('articles')\n            ->values([\n                '123' => 'mark',\n            ]);\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<123>\\) (OUTPUT INSERTED\\.\\* )?' .\n            'VALUES \\(:c0\\)',\n            $result,\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test an insert when not all the listed fields are provided.\n     * Columns should be matched up where possible.\n     */\n    public function testInsertSparseRow(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])\n            ->into('articles')\n            ->values([\n                'title' => 'mark',\n            ]);\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<title>, <body>\\) (OUTPUT INSERTED\\.\\* )?' .\n            'VALUES \\(:c0, :c1\\)',\n            $result,\n            !$this->autoQuote\n        );\n\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result, '1 row should be inserted');\n        }\n\n        $expected = [\n            [\n                'id' => 4,\n                'author_id' => null,\n                'title' => 'mark',\n                'body' => null,\n                'published' => 'N',\n            ],\n        ];\n        $this->assertTable('articles', 1, $expected, ['id >=' => 4]);\n    }\n\n    /**\n     * Test inserting multiple rows with sparse data.\n     */\n    public function testInsertMultipleRowsSparse(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'body'])\n            ->into('articles')\n            ->values([\n                'body' => 'test insert',\n            ])\n            ->values([\n                'title' => 'jose',\n            ]);\n\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(2, $result, '2 rows should be inserted');\n        }\n\n        $expected = [\n            [\n                'id' => 4,\n                'author_id' => null,\n                'title' => null,\n                'body' => 'test insert',\n                'published' => 'N',\n            ],\n            [\n                'id' => 5,\n                'author_id' => null,\n                'title' => 'jose',\n                'body' => null,\n                'published' => 'N',\n            ],\n        ];\n        $this->assertTable('articles', 2, $expected, ['id >=' => 4]);\n    }\n\n    /**\n     * Test that INSERT INTO ... SELECT works.\n     */\n    public function testInsertFromSelect(): void\n    {\n        $select = (new Query($this->connection))->select(['name', \"'some text'\", 99])\n            ->from('authors')\n            ->where(['id' => 1]);\n\n        $query = new Query($this->connection);\n        $query->insert(\n            ['title', 'body', 'author_id'],\n            ['title' => 'string', 'body' => 'string', 'author_id' => 'integer']\n        )\n        ->into('articles')\n        ->values($select);\n\n        $result = $query->sql();\n        $this->assertQuotedQuery(\n            'INSERT INTO <articles> \\(<title>, <body>, <author_id>\\) (OUTPUT INSERTED\\.\\* )?SELECT',\n            $result,\n            !$this->autoQuote\n        );\n        $this->assertQuotedQuery(\n            'SELECT <name>, \\'some text\\', 99 FROM <authors>',\n            $result,\n            !$this->autoQuote\n        );\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result);\n        }\n\n        $result = (new Query($this->connection))->select('*')\n            ->from('articles')\n            ->where(['author_id' => 99])\n            ->execute();\n        $this->assertCount(1, $result);\n        $expected = [\n            'id' => 4,\n            'title' => 'mariano',\n            'body' => 'some text',\n            'author_id' => 99,\n            'published' => 'N',\n        ];\n        $this->assertEquals($expected, $result->fetch('assoc'));\n    }\n\n    /**\n     * Test that an exception is raised when mixing query + array types.\n     */\n    public function testInsertFailureMixingTypesArrayFirst(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $query = new Query($this->connection);\n        $query->insert(['name'])\n            ->into('articles')\n            ->values(['name' => 'mark'])\n            ->values(new Query($this->connection));\n    }\n\n    /**\n     * Test that an exception is raised when mixing query + array types.\n     */\n    public function testInsertFailureMixingTypesQueryFirst(): void\n    {\n        $this->expectException(DatabaseException::class);\n        $query = new Query($this->connection);\n        $query->insert(['name'])\n            ->into('articles')\n            ->values(new Query($this->connection))\n            ->values(['name' => 'mark']);\n    }\n\n    /**\n     * Test that insert can use expression objects as values.\n     */\n    public function testInsertExpressionValues(): void\n    {\n        $query = new Query($this->connection);\n        $query->insert(['title', 'author_id'])\n            ->into('articles')\n            ->values(['title' => $query->newExpr(\"SELECT 'jose'\"), 'author_id' => 99]);\n\n        $result = $query->execute();\n        $result->closeCursor();\n\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result);\n        }\n\n        $result = (new Query($this->connection))->select('*')\n            ->from('articles')\n            ->where(['author_id' => 99])\n            ->execute();\n        $this->assertCount(1, $result);\n        $expected = [\n            'id' => 4,\n            'title' => 'jose',\n            'body' => null,\n            'author_id' => '99',\n            'published' => 'N',\n        ];\n        $this->assertEquals($expected, $result->fetch('assoc'));\n\n        $subquery = new Query($this->connection);\n        $subquery->select(['name'])\n            ->from('authors')\n            ->where(['id' => 1]);\n\n        $query = new Query($this->connection);\n        $query->insert(['title', 'author_id'])\n            ->into('articles')\n            ->values(['title' => $subquery, 'author_id' => 100]);\n        $result = $query->execute();\n        $result->closeCursor();\n        //PDO_SQLSRV returns -1 for successful inserts when using INSERT ... OUTPUT\n        if (!$this->connection->getDriver() instanceof Sqlserver) {\n            $this->assertCount(1, $result);\n        }\n\n        $result = (new Query($this->connection))->select('*')\n            ->from('articles')\n            ->where(['author_id' => 100])\n            ->execute();\n        $this->assertCount(1, $result);\n        $expected = [\n            'id' => 5,\n            'title' => 'mariano',\n            'body' => null,\n            'author_id' => '100',\n            'published' => 'N',\n        ];\n        $this->assertEquals($expected, $result->fetch('assoc'));\n    }\n\n    /**\n     * Tests that the identifier method creates an expression object.\n     */\n    public function testIdentifierExpression(): void\n    {\n        $query = new Query($this->connection);\n        /** @var \\Cake\\Database\\Expression\\IdentifierExpression $identifier */\n        $identifier = $query->identifier('foo');\n\n        $this->assertInstanceOf(IdentifierExpression::class, $identifier);\n        $this->assertSame('foo', $identifier->getIdentifier());\n    }\n\n    /**\n     * Tests the interface contract of identifier\n     */\n    public function testIdentifierInterface(): void\n    {\n        $query = new Query($this->connection);\n        $identifier = $query->identifier('description');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $identifier);\n        $this->assertSame('description', $identifier->getIdentifier());\n\n        $identifier->setIdentifier('title');\n        $this->assertSame('title', $identifier->getIdentifier());\n    }\n\n    /**\n     * Tests that functions are correctly transformed and their parameters are bound\n     *\n     * @group FunctionExpression\n     */\n    public function testSQLFunctions(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(\n            function ($q) {\n                return ['total' => $q->func()->count('*')];\n            }\n        )\n            ->from('comments')\n            ->execute();\n        $expected = [['total' => 6]];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query->select([\n                'c' => $query->func()->concat(['comment' => 'literal', ' is appended']),\n            ])\n            ->from('comments')\n            ->order(['c' => 'ASC'])\n            ->limit(1)\n            ->execute();\n        $expected = [\n            ['c' => 'First Comment for First Article is appended'],\n        ];\n        $this->assertEquals($expected, $result->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['d' => $query->func()->dateDiff(['2012-01-05', '2012-01-02'])])\n            ->execute()\n            ->fetchAll('assoc');\n        $this->assertEquals(3, abs((int)$result[0]['d']));\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['d' => $query->func()->now('date')])\n            ->execute();\n\n        $result = $result->fetchAll('assoc');\n        $this->assertEquals([['d' => date('Y-m-d')]], $result);\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['d' => $query->func()->now('time')])\n            ->execute();\n\n        $this->assertWithinRange(\n            date('U'),\n            (new DateTime($result->fetchAll('assoc')[0]['d']))->format('U'),\n            10\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select(['d' => $query->func()->now()])\n            ->execute();\n        $this->assertWithinRange(\n            date('U'),\n            (new DateTime($result->fetchAll('assoc')[0]['d']))->format('U'),\n            10\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->select([\n                'd' => $query->func()->datePart('day', 'created'),\n                'm' => $query->func()->datePart('month', 'created'),\n                'y' => $query->func()->datePart('year', 'created'),\n                'de' => $query->func()->extract('day', 'created'),\n                'me' => $query->func()->extract('month', 'created'),\n                'ye' => $query->func()->extract('year', 'created'),\n                'wd' => $query->func()->weekday('created'),\n                'dow' => $query->func()->dayOfWeek('created'),\n                'addDays' => $query->func()->dateAdd('created', 2, 'day'),\n                'substractYears' => $query->func()->dateAdd('created', -2, 'year'),\n            ])\n            ->from('comments')\n            ->where(['created' => '2007-03-18 10:45:23'])\n            ->execute()\n            ->fetchAll('assoc');\n\n        $result[0]['addDays'] = substr($result[0]['addDays'], 0, 10);\n        $result[0]['substractYears'] = substr($result[0]['substractYears'], 0, 10);\n\n        if (PHP_VERSION_ID < 80100) {\n            $result[0]['m'] = ltrim($result[0]['m'], '0');\n            $result[0]['me'] = ltrim($result[0]['me'], '0');\n            $expected = [\n                'd' => '18',\n                'm' => '3',\n                'y' => '2007',\n                'de' => '18',\n                'me' => '3',\n                'ye' => '2007',\n                'wd' => '1', // Sunday\n                'dow' => '1',\n                'addDays' => '2007-03-20',\n                'substractYears' => '2005-03-18',\n            ];\n        } else {\n            $expected = [\n                'd' => 18,\n                'm' => 3,\n                'y' => 2007,\n                'de' => 18,\n                'me' => 3,\n                'ye' => 2007,\n                'wd' => 1, // Sunday\n                'dow' => 1,\n                'addDays' => '2007-03-20',\n                'substractYears' => '2005-03-18',\n            ];\n        }\n\n        $this->assertSame($expected, $result[0]);\n    }\n\n    /**\n     * Tests that the values in tuple comparison expression are being bound correctly,\n     * specifically for dialects that translate tuple comparisons.\n     *\n     * @see \\Cake\\Database\\Driver\\TupleComparisonTranslatorTrait::_transformTupleComparison()\n     * @see \\Cake\\Database\\Driver\\Sqlite::_expressionTranslators()\n     * @see \\Cake\\Database\\Driver\\Sqlserver::_expressionTranslators()\n     */\n    public function testTupleComparisonValuesAreBeingBoundCorrectly(): void\n    {\n        $this->skipIf(\n            $this->connection->getDriver() instanceof Sqlserver,\n            'This test fails sporadically in SQLServer'\n        );\n\n        $query = (new Query($this->connection))\n            ->select('*')\n            ->from('profiles')\n            ->where(\n                new TupleComparison(\n                    ['id', 'user_id'],\n                    [[1, 1]],\n                    ['integer', 'integer'],\n                    'IN'\n                )\n            );\n\n        $result = $query->execute()->fetch(StatementInterface::FETCH_TYPE_ASSOC);\n\n        $bindings = array_values($query->getValueBinder()->bindings());\n        $this->assertCount(2, $bindings);\n        $this->assertSame(1, $bindings[0]['value']);\n        $this->assertSame('integer', $bindings[0]['type']);\n        $this->assertSame(1, $bindings[1]['value']);\n        $this->assertSame('integer', $bindings[1]['type']);\n\n        $this->assertSame(1, (int)$result['id']);\n        $this->assertSame(1, (int)$result['user_id']);\n    }\n\n    /**\n     * Tests that the values in tuple comparison expressions are being bound as expected\n     * when types are omitted, specifically for dialects that translate tuple comparisons.\n     *\n     * @see \\Cake\\Database\\Driver\\TupleComparisonTranslatorTrait::_transformTupleComparison()\n     * @see \\Cake\\Database\\Driver\\Sqlite::_expressionTranslators()\n     * @see \\Cake\\Database\\Driver\\Sqlserver::_expressionTranslators()\n     */\n    public function testTupleComparisonTypesCanBeOmitted(): void\n    {\n        $this->skipIf(\n            $this->connection->getDriver() instanceof Sqlserver,\n            'This test fails sporadically in SQLServer'\n        );\n\n        $query = (new Query($this->connection))\n            ->select('*')\n            ->from('profiles')\n            ->where(\n                new TupleComparison(\n                    ['id', 'user_id'],\n                    [[1, 1]],\n                    [],\n                    'IN'\n                )\n            );\n        $result = $query->execute()->fetch(StatementInterface::FETCH_TYPE_ASSOC);\n\n        $bindings = array_values($query->getValueBinder()->bindings());\n        $this->assertCount(2, $bindings);\n        $this->assertSame(1, $bindings[0]['value']);\n        $this->assertNull($bindings[0]['type']);\n        $this->assertSame(1, $bindings[1]['value']);\n        $this->assertNull($bindings[1]['type']);\n\n        $this->assertSame(1, (int)$result['id']);\n        $this->assertSame(1, (int)$result['user_id']);\n    }\n\n    /**\n     * Tests that default types are passed to functions accepting a $types param\n     */\n    public function testDefaultTypes(): void\n    {\n        $query = new Query($this->connection);\n        $this->assertEquals([], $query->getDefaultTypes());\n        $types = ['id' => 'integer', 'created' => 'datetime'];\n        $this->assertSame($query, $query->setDefaultTypes($types));\n        $this->assertSame($types, $query->getDefaultTypes());\n\n        $results = $query->select(['id', 'comment'])\n            ->from('comments')\n            ->where(['created >=' => new DateTime('2007-03-18 10:55:00')])\n            ->execute();\n        $expected = [['id' => '6', 'comment' => 'Second Comment for Second Article']];\n        $this->assertEquals($expected, $results->fetchAll('assoc'));\n\n        // Now test default can be overridden\n        $types = ['created' => 'date'];\n        $results = $query\n            ->where(['created >=' => new DateTime('2007-03-18 10:50:00')], $types, true)\n            ->execute();\n        $this->assertCount(6, $results, 'All 6 rows should match.');\n    }\n\n    /**\n     * Tests parameter binding\n     */\n    public function testBind(): void\n    {\n        $query = new Query($this->connection);\n        $results = $query->select(['id', 'comment'])\n            ->from('comments')\n            ->where(['created BETWEEN :foo AND :bar'])\n            ->bind(':foo', new DateTime('2007-03-18 10:50:00'), 'datetime')\n            ->bind(':bar', new DateTime('2007-03-18 10:52:00'), 'datetime')\n            ->execute();\n        $expected = [['id' => '4', 'comment' => 'Fourth Comment for First Article']];\n        $this->assertEquals($expected, $results->fetchAll('assoc'));\n\n        $query = new Query($this->connection);\n        $results = $query->select(['id', 'comment'])\n            ->from('comments')\n            ->where(['created BETWEEN :foo AND :bar'])\n            ->bind(':foo', '2007-03-18 10:50:00')\n            ->bind(':bar', '2007-03-18 10:52:00')\n            ->execute();\n        $this->assertEquals($expected, $results->fetchAll('assoc'));\n    }\n\n    /**\n     * Test that epilog() will actually append a string to a select query\n     */\n    public function testAppendSelect(): void\n    {\n        $query = new Query($this->connection);\n        $sql = $query\n            ->select(['id', 'title'])\n            ->from('articles')\n            ->where(['id' => 1])\n            ->epilog('FOR UPDATE')\n            ->sql();\n        $this->assertStringContainsString('SELECT', $sql);\n        $this->assertStringContainsString('FROM', $sql);\n        $this->assertStringContainsString('WHERE', $sql);\n        $this->assertSame(' FOR UPDATE', substr($sql, -11));\n    }\n\n    /**\n     * Test that epilog() will actually append a string to an insert query\n     */\n    public function testAppendInsert(): void\n    {\n        $query = new Query($this->connection);\n        $sql = $query\n            ->insert(['id', 'title'])\n            ->into('articles')\n            ->values([1, 'a title'])\n            ->epilog('RETURNING id')\n            ->sql();\n        $this->assertStringContainsString('INSERT', $sql);\n        $this->assertStringContainsString('INTO', $sql);\n        $this->assertStringContainsString('VALUES', $sql);\n        $this->assertSame(' RETURNING id', substr($sql, -13));\n    }\n\n    /**\n     * Test that epilog() will actually append a string to an update query\n     */\n    public function testAppendUpdate(): void\n    {\n        $query = new Query($this->connection);\n        $sql = $query\n            ->update('articles')\n            ->set(['title' => 'foo'])\n            ->where(['id' => 1])\n            ->epilog('RETURNING id')\n            ->sql();\n        $this->assertStringContainsString('UPDATE', $sql);\n        $this->assertStringContainsString('SET', $sql);\n        $this->assertStringContainsString('WHERE', $sql);\n        $this->assertSame(' RETURNING id', substr($sql, -13));\n    }\n\n    /**\n     * Test that epilog() will actually append a string to a delete query\n     */\n    public function testAppendDelete(): void\n    {\n        $query = new Query($this->connection);\n        $sql = $query\n            ->delete('articles')\n            ->where(['id' => 1])\n            ->epilog('RETURNING id')\n            ->sql();\n        $this->assertStringContainsString('DELETE FROM', $sql);\n        $this->assertStringContainsString('WHERE', $sql);\n        $this->assertSame(' RETURNING id', substr($sql, -13));\n    }\n\n    /**\n     * Tests automatic identifier quoting in the select clause\n     */\n    public function testQuotingSelectFieldsAndAlias(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select(['something'])->sql();\n        $this->assertQuotedQuery('SELECT <something>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => 'something'])->sql();\n        $this->assertQuotedQuery('SELECT <something> AS <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => 1])->sql();\n        $this->assertQuotedQuery('SELECT 1 AS <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => '1 + 1'])->sql();\n        $this->assertQuotedQuery('SELECT <1 \\+ 1> AS <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => $query->newExpr('1 + 1')])->sql();\n        $this->assertQuotedQuery('SELECT \\(1 \\+ 1\\) AS <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select(['foo' => new IdentifierExpression('bar')])->sql();\n        $this->assertQuotedQuery('<bar>', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting in the from clause\n     */\n    public function testQuotingFromAndAlias(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->from(['something'])->sql();\n        $this->assertQuotedQuery('FROM <something>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->from(['foo' => 'something'])->sql();\n        $this->assertQuotedQuery('FROM <something> <foo>$', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->from(['foo' => $query->newExpr('bar')])->sql();\n        $this->assertQuotedQuery('FROM \\(bar\\) <foo>$', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting for DISTINCT ON\n     */\n    public function testQuotingDistinctOn(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->distinct(['something'])->sql();\n        $this->assertQuotedQuery('<something>', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting in the join clause\n     */\n    public function testQuotingJoinsAndAlias(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->join(['something'])->sql();\n        $this->assertQuotedQuery('JOIN <something>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->join(['foo' => 'something'])->sql();\n        $this->assertQuotedQuery('JOIN <something> <foo>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->join(['foo' => $query->newExpr('bar')])->sql();\n        $this->assertQuotedQuery('JOIN \\(bar\\) <foo>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->join([\n            'alias' => 'orders',\n            'table' => 'Order',\n            'conditions' => ['1 = 1'],\n        ])->sql();\n        $this->assertQuotedQuery('JOIN <Order> <orders> ON 1 = 1', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting in the group by clause\n     */\n    public function testQuotingGroupBy(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->group(['something'])->sql();\n        $this->assertQuotedQuery('GROUP BY <something>', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->group([$query->newExpr('bar')])->sql();\n        $this->assertQuotedQuery('GROUP BY \\(bar\\)', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')->group([new IdentifierExpression('bar')])->sql();\n        $this->assertQuotedQuery('GROUP BY \\(<bar>\\)', $sql);\n    }\n\n    /**\n     * Tests automatic identifier quoting strings inside conditions expressions\n     */\n    public function testQuotingExpressions(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->select('*')\n            ->where(['something' => 'value'])\n            ->sql();\n        $this->assertQuotedQuery('WHERE <something> = :c0', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->select('*')\n            ->where([\n                'something' => 'value',\n                'OR' => ['foo' => 'bar', 'baz' => 'cake'],\n            ])\n            ->sql();\n        $this->assertQuotedQuery('<something> = :c0 AND', $sql);\n        $this->assertQuotedQuery('\\(<foo> = :c1 OR <baz> = :c2\\)', $sql);\n    }\n\n    /**\n     * Tests that insert query parts get quoted automatically\n     */\n    public function testQuotingInsert(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $sql = $query->insert(['bar', 'baz'])\n            ->into('foo')\n            ->where(['something' => 'value'])\n            ->sql();\n        $this->assertQuotedQuery('INSERT INTO <foo> \\(<bar>, <baz>\\)', $sql);\n\n        $query = new Query($this->connection);\n        $sql = $query->insert([$query->newExpr('bar')])\n            ->into('foo')\n            ->where(['something' => 'value'])\n            ->sql();\n        $this->assertQuotedQuery('INSERT INTO <foo> \\(\\(bar\\)\\)', $sql);\n    }\n\n    /**\n     * Tests converting a query to a string\n     */\n    public function testToString(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->select(['title'])\n            ->from('articles');\n        $result = (string)$query;\n        $this->assertQuotedQuery('SELECT <title> FROM <articles>', $result, !$this->autoQuote);\n    }\n\n    /**\n     * Tests __debugInfo\n     */\n    public function testDebugInfo(): void\n    {\n        $query = (new Query($this->connection))->select('*')\n            ->from('articles')\n            ->setDefaultTypes(['id' => 'integer'])\n            ->where(['id' => '1']);\n\n        $expected = [\n            '(help)' => 'This is a Query object, to get the results execute or iterate it.',\n            'sql' => $query->sql(),\n            'params' => [\n                ':c0' => ['value' => '1', 'type' => 'integer', 'placeholder' => 'c0'],\n            ],\n            'defaultTypes' => ['id' => 'integer'],\n            'decorators' => 0,\n            'executed' => false,\n        ];\n        $result = $query->__debugInfo();\n        $this->assertEquals($expected, $result);\n\n        $query->execute();\n        $expected = [\n            '(help)' => 'This is a Query object, to get the results execute or iterate it.',\n            'sql' => $query->sql(),\n            'params' => [\n                ':c0' => ['value' => '1', 'type' => 'integer', 'placeholder' => 'c0'],\n            ],\n            'defaultTypes' => ['id' => 'integer'],\n            'decorators' => 0,\n            'executed' => true,\n        ];\n        $result = $query->__debugInfo();\n        $this->assertEquals($expected, $result);\n    }\n\n    /**\n     * Tests __debugInfo on incomplete query\n     */\n    public function testDebugInfoIncompleteQuery(): void\n    {\n        $query = (new Query($this->connection))\n            ->insert(['title']);\n        $result = $query->__debugInfo();\n        $this->assertStringContainsString('incomplete', $result['sql']);\n        $this->assertSame([], $result['params']);\n    }\n\n    /**\n     * Tests that it is possible to pass ExpressionInterface to isNull and isNotNull\n     */\n    public function testIsNullWithExpressions(): void\n    {\n        $query = new Query($this->connection);\n        $subquery = (new Query($this->connection))\n            ->select(['id'])\n            ->from('authors')\n            ->where(['id' => 1]);\n\n        $result = $query\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(function ($exp) use ($subquery) {\n                return $exp->isNotNull($subquery);\n            })\n            ->execute();\n        $this->assertNotEmpty($result->fetchAll('assoc'));\n\n        $result = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(function ($exp) use ($subquery) {\n                return $exp->isNull($subquery);\n            })\n            ->execute();\n        $this->assertEmpty($result->fetchAll('assoc'));\n    }\n\n    /**\n     * Tests that strings passed to isNull and isNotNull will be treated as identifiers\n     * when using autoQuoting\n     */\n    public function testIsNullAutoQuoting(): void\n    {\n        $this->connection->getDriver()->enableAutoQuoting(true);\n        $query = new Query($this->connection);\n        $query->select('*')->from('things')->where(function ($exp) {\n            return $exp->isNull('field');\n        });\n        $this->assertQuotedQuery('WHERE \\(<field>\\) IS NULL', $query->sql());\n\n        $query = new Query($this->connection);\n        $query->select('*')->from('things')->where(function ($exp) {\n            return $exp->isNotNull('field');\n        });\n        $this->assertQuotedQuery('WHERE \\(<field>\\) IS NOT NULL', $query->sql());\n    }\n\n    /**\n     * Tests that using the IS operator will automatically translate to the best\n     * possible operator depending on the passed value\n     */\n    public function testDirectIsNull(): void\n    {\n        $sql = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name IS' => null])\n            ->sql();\n        $this->assertQuotedQuery('WHERE \\(<name>\\) IS NULL', $sql, !$this->autoQuote);\n\n        $results = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name IS' => 'larry'])\n            ->execute();\n        $this->assertCount(1, $results);\n        $this->assertEquals(['name' => 'larry'], $results->fetch('assoc'));\n    }\n\n    /**\n     * Tests that using the wrong NULL operator will throw meaningful exception instead of\n     * cloaking as always-empty result set.\n     */\n    public function testIsNullInvalid(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage('Expression `name` is missing operator (IS, IS NOT) with `null` value.');\n\n        (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name' => null])\n            ->sql();\n    }\n\n    /**\n     * Tests that using the wrong NULL operator will throw meaningful exception instead of\n     * cloaking as always-empty result set.\n     */\n    public function testIsNotNullInvalid(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n\n        (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name !=' => null])\n            ->sql();\n    }\n\n    /**\n     * Tests that using the IS NOT operator will automatically translate to the best\n     * possible operator depending on the passed value\n     */\n    public function testDirectIsNotNull(): void\n    {\n        $sql = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name IS NOT' => null])\n            ->sql();\n        $this->assertQuotedQuery('WHERE \\(<name>\\) IS NOT NULL', $sql, !$this->autoQuote);\n\n        $results = (new Query($this->connection))\n            ->select(['name'])\n            ->from(['authors'])\n            ->where(['name IS NOT' => 'larry'])\n            ->execute();\n        $this->assertCount(3, $results);\n        $this->assertNotEquals(['name' => 'larry'], $results->fetch('assoc'));\n    }\n\n    /**\n     * Performs the simple update query and verifies the row count.\n     */\n    public function testRowCountAndClose(): void\n    {\n        $statementMock = $this->getMockBuilder(StatementInterface::class)\n            ->onlyMethods(['rowCount', 'closeCursor'])\n            ->getMockForAbstractClass();\n\n        $statementMock->expects($this->once())\n            ->method('rowCount')\n            ->willReturn(500);\n\n        $statementMock->expects($this->once())\n            ->method('closeCursor');\n\n        /** @var \\Cake\\ORM\\Query|\\PHPUnit\\Framework\\MockObject\\MockObject $queryMock */\n        $queryMock = $this->getMockBuilder(Query::class)\n            ->onlyMethods(['execute'])\n            ->setConstructorArgs([$this->connection])\n            ->getMock();\n\n        $queryMock->expects($this->once())\n            ->method('execute')\n            ->willReturn($statementMock);\n\n        $rowCount = $queryMock->update('authors')\n            ->set('name', 'mark')\n            ->where(['id' => 1])\n            ->rowCountAndClose();\n\n        $this->assertEquals(500, $rowCount);\n    }\n\n    /**\n     * Tests that case statements work correctly for various use-cases.\n     *\n     * @deprecated\n     */\n    public function testSqlCaseStatement(): void\n    {\n        $query = new Query($this->connection);\n        $publishedCase = null;\n        $notPublishedCase = null;\n        $this->deprecated(function () use ($query, &$publishedCase, &$notPublishedCase) {\n            $publishedCase = $query\n                ->newExpr()\n                ->addCase(\n                    $query\n                        ->newExpr()\n                        ->add(['published' => 'Y']),\n                    1,\n                    'integer'\n                );\n            $notPublishedCase = $query\n                ->newExpr()\n                ->addCase(\n                    $query\n                        ->newExpr()\n                        ->add(['published' => 'N']),\n                    1,\n                    'integer'\n                );\n        });\n\n        // Postgres requires the case statement to be cast to a integer\n        if ($this->connection->getDriver() instanceof Postgres) {\n            $publishedCase = $query->func()->cast($publishedCase, 'integer');\n            $notPublishedCase = $query->func()->cast($notPublishedCase, 'integer');\n        }\n\n        $results = $query\n            ->select([\n                'published' => $query->func()->sum($publishedCase),\n                'not_published' => $query->func()->sum($notPublishedCase),\n            ])\n            ->from(['comments'])\n            ->execute()\n            ->fetchAll('assoc');\n\n        $this->assertEquals(5, $results[0]['published']);\n        $this->assertEquals(1, $results[0]['not_published']);\n\n        $query = new Query($this->connection);\n        $query\n            ->insert(['article_id', 'user_id', 'comment', 'published'])\n            ->into('comments')\n            ->values([\n                'article_id' => 2,\n                'user_id' => 1,\n                'comment' => 'In limbo',\n                'published' => 'L',\n            ])\n            ->execute()\n            ->closeCursor();\n\n        $query = new Query($this->connection);\n        $conditions = [\n            $query\n                ->newExpr()\n                ->add(['published' => 'Y']),\n            $query\n                ->newExpr()\n                ->add(['published' => 'N']),\n        ];\n        $values = [\n            'Published',\n            'Not published',\n            'None',\n        ];\n        $this->deprecated(function () use ($query, $conditions, $values) {\n            $query\n                ->select([\n                    'id',\n                    'comment',\n                    'status' => $query->newExpr()->addCase($conditions, $values),\n                ])\n                ->from(['comments']);\n        });\n        $results = $query\n            ->execute()\n            ->fetchAll('assoc');\n\n        $this->assertSame('Published', $results[2]['status']);\n        $this->assertSame('Not published', $results[3]['status']);\n        $this->assertSame('None', $results[6]['status']);\n\n        $query = new Query($this->connection);\n        $this->deprecated(function () use ($query) {\n            $query->select(['id'])\n                ->from('articles')\n                ->orderAsc(function (QueryExpression $exp, Query $query) {\n                    return $exp->addCase(\n                        [$query->newExpr()->add(['author_id' => 1])],\n                        [1, $query->identifier('id')],\n                        ['integer', null]\n                    );\n                })\n                ->orderAsc('id');\n        });\n        $result = $query->execute()->fetchAll('assoc');\n        $expected = [\n            ['id' => 1],\n            ['id' => 3],\n            ['id' => 2],\n        ];\n        $this->assertEquals($expected, $result);\n    }\n\n    /**\n     * Shows that bufferResults(false) will prevent client-side results buffering\n     */\n    public function testUnbufferedQuery(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->select(['body', 'author_id'])\n            ->from('articles')\n            ->enableBufferedResults(false)\n            ->execute();\n\n        if (!method_exists($result, 'bufferResults')) {\n            $result->closeCursor();\n            $this->markTestSkipped('This driver does not support unbuffered queries');\n        }\n\n        $this->assertCount(0, $result, 'Unbuffered queries only have a count when results are fetched');\n\n        $list = $result->fetchAll('assoc');\n        $this->assertCount(3, $list);\n        $result->closeCursor();\n\n        $query = new Query($this->connection);\n        $result = $query->select(['body', 'author_id'])\n            ->from('articles')\n            ->execute();\n\n        $this->assertCount(3, $result, 'Buffered queries can be counted any time.');\n        $list = $result->fetchAll('assoc');\n        $this->assertCount(3, $list);\n        $result->closeCursor();\n    }\n\n    public function testCloneUpdateExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->update($query->newExpr('update'));\n\n        $clause = $query->clause('update');\n        $clauseClone = (clone $query)->clause('update');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneSetExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->update('table')\n            ->set(['column' => $query->newExpr('value')]);\n\n        $clause = $query->clause('set');\n        $clauseClone = (clone $query)->clause('set');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneValuesExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->insert(['column'])\n            ->into('table')\n            ->values(['column' => $query->newExpr('value')]);\n\n        $clause = $query->clause('values');\n        $clauseClone = (clone $query)->clause('values');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneWithExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->with(\n                new CommonTableExpression(\n                    'cte',\n                    new Query($this->connection)\n                )\n            )\n            ->with(function (CommonTableExpression $cte, Query $query) {\n                return $cte\n                    ->name('cte2')\n                    ->query($query);\n            });\n\n        $clause = $query->clause('with');\n        $clauseClone = (clone $query)->clause('with');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneSelectExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->select($query->newExpr('select'))\n            ->select(['alias' => $query->newExpr('select')]);\n\n        $clause = $query->clause('select');\n        $clauseClone = (clone $query)->clause('select');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneDistinctExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->distinct($query->newExpr('distinct'));\n\n        $clause = $query->clause('distinct');\n        $clauseClone = (clone $query)->clause('distinct');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneModifierExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->modifier($query->newExpr('modifier'));\n\n        $clause = $query->clause('modifier');\n        $clauseClone = (clone $query)->clause('modifier');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneFromExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->from(['alias' => new Query($this->connection)]);\n\n        $clause = $query->clause('from');\n        $clauseClone = (clone $query)->clause('from');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneJoinExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->innerJoin(\n                ['alias_inner' => new Query($this->connection)],\n                ['alias_inner.fk = parent.pk']\n            )\n            ->leftJoin(\n                ['alias_left' => new Query($this->connection)],\n                ['alias_left.fk = parent.pk']\n            )\n            ->rightJoin(\n                ['alias_right' => new Query($this->connection)],\n                ['alias_right.fk = parent.pk']\n            );\n\n        $clause = $query->clause('join');\n        $clauseClone = (clone $query)->clause('join');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value['table'], $clauseClone[$key]['table']);\n            $this->assertNotSame($value['table'], $clauseClone[$key]['table']);\n\n            $this->assertEquals($value['conditions'], $clauseClone[$key]['conditions']);\n            $this->assertNotSame($value['conditions'], $clauseClone[$key]['conditions']);\n        }\n    }\n\n    public function testCloneWhereExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->where($query->newExpr('where'))\n            ->where(['field' => $query->newExpr('where')]);\n\n        $clause = $query->clause('where');\n        $clauseClone = (clone $query)->clause('where');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneGroupExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->group($query->newExpr('group'));\n\n        $clause = $query->clause('group');\n        $clauseClone = (clone $query)->clause('group');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value, $clauseClone[$key]);\n            $this->assertNotSame($value, $clauseClone[$key]);\n        }\n    }\n\n    public function testCloneHavingExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->having($query->newExpr('having'));\n\n        $clause = $query->clause('having');\n        $clauseClone = (clone $query)->clause('having');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneWindowExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->window('window1', new WindowExpression())\n            ->window('window2', function (WindowExpression $window) {\n                return $window;\n            });\n\n        $clause = $query->clause('window');\n        $clauseClone = (clone $query)->clause('window');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value['name'], $clauseClone[$key]['name']);\n            $this->assertNotSame($value['name'], $clauseClone[$key]['name']);\n\n            $this->assertEquals($value['window'], $clauseClone[$key]['window']);\n            $this->assertNotSame($value['window'], $clauseClone[$key]['window']);\n        }\n    }\n\n    public function testCloneOrderExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query\n            ->order($query->newExpr('order'))\n            ->orderAsc($query->newExpr('order_asc'))\n            ->orderDesc($query->newExpr('order_desc'));\n\n        $clause = $query->clause('order');\n        $clauseClone = (clone $query)->clause('order');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneLimitExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->limit($query->newExpr('1'));\n\n        $clause = $query->clause('limit');\n        $clauseClone = (clone $query)->clause('limit');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneOffsetExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->offset($query->newExpr('1'));\n\n        $clause = $query->clause('offset');\n        $clauseClone = (clone $query)->clause('offset');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    public function testCloneUnionExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->where(['id' => 1]);\n\n        $query2 = new Query($this->connection);\n        $query2->where(['id' => 2]);\n\n        $query->union($query2);\n\n        $clause = $query->clause('union');\n        $clauseClone = (clone $query)->clause('union');\n\n        $this->assertIsArray($clause);\n\n        foreach ($clause as $key => $value) {\n            $this->assertEquals($value['query'], $clauseClone[$key]['query']);\n            $this->assertNotSame($value['query'], $clauseClone[$key]['query']);\n        }\n    }\n\n    public function testCloneEpilogExpression(): void\n    {\n        $query = new Query($this->connection);\n        $query->epilog($query->newExpr('epilog'));\n\n        $clause = $query->clause('epilog');\n        $clauseClone = (clone $query)->clause('epilog');\n\n        $this->assertInstanceOf(ExpressionInterface::class, $clause);\n\n        $this->assertEquals($clause, $clauseClone);\n        $this->assertNotSame($clause, $clauseClone);\n    }\n\n    /**\n     * Test that cloning goes deep.\n     */\n    public function testDeepClone(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id', 'title' => $query->func()->concat(['title' => 'literal', 'test'])])\n            ->from('articles')\n            ->where(['Articles.id' => 1])\n            ->offset(10)\n            ->limit(1)\n            ->order(['Articles.id' => 'DESC']);\n        $dupe = clone $query;\n\n        $this->assertEquals($query->clause('where'), $dupe->clause('where'));\n        $this->assertNotSame($query->clause('where'), $dupe->clause('where'));\n        $dupe->where(['Articles.title' => 'thinger']);\n        $this->assertNotEquals($query->clause('where'), $dupe->clause('where'));\n\n        $this->assertNotSame(\n            $query->clause('select')['title'],\n            $dupe->clause('select')['title']\n        );\n        $this->assertEquals($query->clause('order'), $dupe->clause('order'));\n        $this->assertNotSame($query->clause('order'), $dupe->clause('order'));\n\n        $query->order(['Articles.title' => 'ASC']);\n        $this->assertNotEquals($query->clause('order'), $dupe->clause('order'));\n\n        $this->assertNotSame(\n            $query->getSelectTypeMap(),\n            $dupe->getSelectTypeMap()\n        );\n    }\n\n    /**\n     * Tests the selectTypeMap method\n     */\n    public function testSelectTypeMap(): void\n    {\n        $query = new Query($this->connection);\n        $typeMap = $query->getSelectTypeMap();\n        $this->assertInstanceOf(TypeMap::class, $typeMap);\n        $another = clone $typeMap;\n        $query->setSelectTypeMap($another);\n        $this->assertSame($another, $query->getSelectTypeMap());\n    }\n\n    /**\n     * Tests the automatic type conversion for the fields in the result\n     */\n    public function testSelectTypeConversion(): void\n    {\n        TypeFactory::set('custom_datetime', new BarType('custom_datetime'));\n\n        $query = new Query($this->connection);\n        $query\n            ->select(['id', 'comment', 'the_date' => 'created', 'updated'])\n            ->from('comments')\n            ->limit(1)\n            ->getSelectTypeMap()\n                ->setTypes([\n                    'id' => 'integer',\n                    'the_date' => 'datetime',\n                    'updated' => 'custom_datetime',\n                ]);\n\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertIsInt($result[0]['id']);\n        $this->assertInstanceOf(DateTimeImmutable::class, $result[0]['the_date']);\n        $this->assertInstanceOf(DateTimeImmutable::class, $result[0]['updated']);\n    }\n\n    /**\n     * Tests that the JSON type can save and get data symmetrically\n     */\n    public function testSymmetricJsonType(): void\n    {\n        $query = new Query($this->connection);\n        $insert = $query\n            ->insert(['comment', 'article_id', 'user_id'], ['comment' => 'json'])\n            ->into('comments')\n            ->values([\n                'comment' => ['a' => 'b', 'c' => true],\n                'article_id' => 1,\n                'user_id' => 1,\n            ])\n            ->execute();\n\n        $id = $insert->lastInsertId('comments', 'id');\n        $insert->closeCursor();\n\n        $query = new Query($this->connection);\n        $query\n            ->select(['comment'])\n            ->from('comments')\n            ->where(['id' => $id])\n            ->getSelectTypeMap()->setTypes(['comment' => 'json']);\n\n        $result = $query->execute();\n        $comment = $result->fetchAll('assoc')[0]['comment'];\n        $result->closeCursor();\n        $this->assertSame(['a' => 'b', 'c' => true], $comment);\n    }\n\n    /**\n     * Test removeJoin().\n     */\n    public function testRemoveJoin(): void\n    {\n        $query = new Query($this->connection);\n        $query->select(['id', 'title'])\n            ->from('articles')\n            ->join(['authors' => [\n                'type' => 'INNER',\n                'conditions' => ['articles.author_id = authors.id'],\n            ]]);\n        $this->assertArrayHasKey('authors', $query->clause('join'));\n\n        $this->assertSame($query, $query->removeJoin('authors'));\n        $this->assertArrayNotHasKey('authors', $query->clause('join'));\n    }\n\n    /**\n     * Tests that types in the type map are used in the\n     * specific comparison functions when using a callable\n     */\n    public function testBetweenExpressionAndTypeMap(): void\n    {\n        $query = new Query($this->connection);\n        $query->select('id')\n            ->from('comments')\n            ->setDefaultTypes(['created' => 'datetime'])\n            ->where(function ($expr) {\n                $from = new DateTime('2007-03-18 10:45:00');\n                $to = new DateTime('2007-03-18 10:48:00');\n\n                return $expr->between('created', $from, $to);\n            });\n        $this->assertCount(2, $query->execute()->fetchAll());\n    }\n\n    /**\n     * Test use of modifiers in a INSERT query\n     *\n     * Testing the generated SQL since the modifiers are usually different per driver\n     */\n    public function testInsertModifiers(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->insert(['title'])\n            ->into('articles')\n            ->values(['title' => 'foo'])\n            ->modifier('IGNORE');\n        $this->assertQuotedQuery(\n            'INSERT IGNORE INTO <articles> \\(<title>\\) (OUTPUT INSERTED\\.\\* )?',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->insert(['title'])\n            ->into('articles')\n            ->values(['title' => 'foo'])\n            ->modifier(['IGNORE', 'LOW_PRIORITY']);\n        $this->assertQuotedQuery(\n            'INSERT IGNORE LOW_PRIORITY INTO <articles> \\(<title>\\) (OUTPUT INSERTED\\.\\* )?',\n            $result->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test use of modifiers in a UPDATE query\n     *\n     * Testing the generated SQL since the modifiers are usually different per driver\n     */\n    public function testUpdateModifiers(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query\n            ->update('authors')\n            ->set('name', 'mark')\n            ->modifier('TOP 10 PERCENT');\n        $this->assertQuotedQuery(\n            'UPDATE TOP 10 PERCENT <authors> SET <name> = :c0',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->update('authors')\n            ->set('name', 'mark')\n            ->modifier(['TOP 10 PERCENT', 'FOO']);\n        $this->assertQuotedQuery(\n            'UPDATE TOP 10 PERCENT FOO <authors> SET <name> = :c0',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query\n            ->update('authors')\n            ->set('name', 'mark')\n            ->modifier([$query->newExpr('TOP 10 PERCENT')]);\n        $this->assertQuotedQuery(\n            'UPDATE TOP 10 PERCENT <authors> SET <name> = :c0',\n            $result->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test use of modifiers in a DELETE query\n     *\n     * Testing the generated SQL since the modifiers are usually different per driver\n     */\n    public function testDeleteModifiers(): void\n    {\n        $query = new Query($this->connection);\n        $result = $query->delete()\n            ->from('authors')\n            ->where('1 = 1')\n            ->modifier('IGNORE');\n        $this->assertQuotedQuery(\n            'DELETE IGNORE FROM <authors> WHERE 1 = 1',\n            $result->sql(),\n            !$this->autoQuote\n        );\n\n        $query = new Query($this->connection);\n        $result = $query->delete()\n            ->from('authors')\n            ->where('1 = 1')\n            ->modifier(['IGNORE', 'QUICK']);\n        $this->assertQuotedQuery(\n            'DELETE IGNORE QUICK FROM <authors> WHERE 1 = 1',\n            $result->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Test getValueBinder()\n     */\n    public function testGetValueBinder(): void\n    {\n        $query = new Query($this->connection);\n\n        $this->assertInstanceOf('Cake\\Database\\ValueBinder', $query->getValueBinder());\n    }\n\n    /**\n     * Test automatic results casting\n     */\n    public function testCastResults(): void\n    {\n        $query = new Query($this->connection);\n        $fields = [\n            'user_id' => 'integer',\n            'is_active' => 'boolean',\n        ];\n        $typeMap = new TypeMap($fields + ['a' => 'integer']);\n        $results = $query\n            ->select(array_keys($fields))\n            ->select(['a' => 'is_active'])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->where(['user_id' => 1])\n            ->execute()\n            ->fetchAll('assoc');\n        $this->assertSame([['user_id' => 1, 'is_active' => false, 'a' => 0]], $results);\n    }\n\n    /**\n     * Test disabling type casting\n     */\n    public function testCastResultsDisable(): void\n    {\n        $query = new Query($this->connection);\n        $typeMap = new TypeMap(['a' => 'datetime']);\n        $results = $query\n            ->select(['a' => 'id'])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->limit(1)\n            ->disableResultsCasting()\n            ->execute()\n            ->fetchAll('assoc');\n        $this->assertEquals([['a' => '1']], $results);\n    }\n\n    /**\n     * Test obtaining the current results casting mode.\n     */\n    public function testObtainingResultsCastingMode(): void\n    {\n        $query = new Query($this->connection);\n\n        $this->assertTrue($query->isResultsCastingEnabled());\n\n        $query->disableResultsCasting();\n        $this->assertFalse($query->isResultsCastingEnabled());\n    }\n\n    /**\n     * Test that type conversion is only applied once.\n     */\n    public function testAllNoDuplicateTypeCasting(): void\n    {\n        $this->skipIf($this->autoQuote, 'Produces bad SQL in postgres with autoQuoting');\n        $query = new Query($this->connection);\n        $query\n            ->select('1.5 AS a')\n            ->setSelectTypeMap(new TypeMap(['a' => 'integer']));\n\n        // Convert to an array and make the query dirty again.\n        $result = $query->execute()->fetchAll('assoc');\n        $this->assertEquals([['a' => 1]], $result);\n\n        $query->setSelectTypeMap(new TypeMap(['a' => 'float']));\n        // Get results a second time.\n        $result = $query->execute()->fetchAll('assoc');\n\n        // Had the type casting being remembered from the first time,\n        // The value would be a truncated float (1.0)\n        $this->assertEquals([['a' => 1.5]], $result);\n    }\n\n    /**\n     * Test that reading an undefined clause does not emit an error.\n     */\n    public function testClauseUndefined(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage('The \\'nope\\' clause is not defined. Valid clauses are: delete, update');\n        $query = new Query($this->connection);\n        $this->assertEmpty($query->clause('where'));\n        $query->clause('nope');\n    }\n\n    /**\n     * Assertion for comparing a table's contents with what is in it.\n     *\n     * @param string $table\n     * @param int $count\n     * @param array $rows\n     * @param array $conditions\n     */\n    public function assertTable($table, $count, $rows, $conditions = []): void\n    {\n        $result = (new Query($this->connection))->select('*')\n            ->from($table)\n            ->where($conditions)\n            ->execute();\n        $this->assertCount($count, $result, 'Row count is incorrect');\n        $this->assertEquals($rows, $result->fetchAll('assoc'));\n        $result->closeCursor();\n    }\n\n    /**\n     * Assertion for comparing a regex pattern against a query having its identifiers\n     * quoted. It accepts queries quoted with the characters `<` and `>`. If the third\n     * parameter is set to true, it will alter the pattern to both accept quoted and\n     * unquoted queries\n     *\n     * @param string $pattern\n     * @param string $query the result to compare against\n     * @param bool $optional\n     */\n    public function assertQuotedQuery($pattern, $query, $optional = false): void\n    {\n        if ($optional) {\n            $optional = '?';\n        }\n        $pattern = str_replace('<', '[`\"\\[]' . $optional, $pattern);\n        $pattern = str_replace('>', '[`\"\\]]' . $optional, $pattern);\n        $this->assertMatchesRegularExpression('#' . $pattern . '#', $query);\n    }\n\n    /**\n     * Test that calling fetchAssoc return an associated array.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchAssoc(): void\n    {\n        $query = new Query($this->connection);\n        $fields = [\n            'id' => 'integer',\n            'user_id' => 'integer',\n            'is_active' => 'boolean',\n        ];\n        $typeMap = new TypeMap($fields);\n        $statement = $query\n            ->select([\n                'id',\n                'user_id',\n                'is_active',\n            ])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->limit(1)\n            ->execute();\n\n        $this->assertSame(['id' => 1, 'user_id' => 1, 'is_active' => false], $statement->fetchAssoc());\n        $statement->closeCursor();\n    }\n\n    /**\n     * Test that calling fetchAssoc return an empty associated array.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchAssocWithEmptyResult(): void\n    {\n        $query = new Query($this->connection);\n\n        $results = $query\n            ->select(['id'])\n            ->from('profiles')\n            ->where(['id' => -1])\n            ->execute()\n            ->fetchAssoc();\n        $this->assertSame([], $results);\n    }\n\n    /**\n     * Test that calling fetch with with FETCH_TYPE_OBJ return stdClass object.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchObjects(): void\n    {\n        $query = new Query($this->connection);\n        $stmt = $query->select([\n                'id',\n                'user_id',\n                'is_active',\n            ])\n            ->from('profiles')\n            ->limit(1)\n            ->enableBufferedResults(false)\n            ->execute();\n        $results = $stmt->fetch(StatementDecorator::FETCH_TYPE_OBJ);\n        $stmt->closeCursor();\n\n        $this->assertInstanceOf(stdClass::class, $results);\n    }\n\n    /**\n     * Test that fetchColumn() will return the correct value at $position.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchColumn(): void\n    {\n        $query = new Query($this->connection);\n        $fields = [\n            'integer',\n            'integer',\n            'boolean',\n        ];\n        $typeMap = new TypeMap($fields);\n        $query\n            ->select([\n                'id',\n                'user_id',\n                'is_active',\n            ])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->where(['id' => 2])\n            ->limit(1);\n        $statement = $query->execute();\n        $results = $statement->fetchColumn(0);\n        $this->assertSame(2, $results);\n        $statement->closeCursor();\n\n        $statement = $query->execute();\n        $results = $statement->fetchColumn(1);\n        $this->assertSame(2, $results);\n        $statement->closeCursor();\n\n        $statement = $query->execute();\n        $results = $statement->fetchColumn(2);\n        $this->assertSame(false, $results);\n        $statement->closeCursor();\n    }\n\n    /**\n     * Test that fetchColumn() will return false if $position is not set.\n     *\n     * @throws \\Exception\n     */\n    public function testFetchColumnReturnsFalse(): void\n    {\n        $query = new Query($this->connection);\n        $fields = [\n            'integer',\n            'integer',\n            'boolean',\n        ];\n        $typeMap = new TypeMap($fields);\n        $query\n            ->select([\n                'id',\n                'user_id',\n                'is_active',\n            ])\n            ->from('profiles')\n            ->setSelectTypeMap($typeMap)\n            ->where(['id' => 2])\n            ->limit(1);\n        $statement = $query->execute();\n        $results = $statement->fetchColumn(3);\n        $this->assertFalse($results);\n        $statement->closeCursor();\n    }\n\n    /**\n     * Tests that query expressions can be used for ordering.\n     */\n    public function testOrderBySubquery(): void\n    {\n        $this->autoQuote = true;\n        $this->connection->getDriver()->enableAutoQuoting($this->autoQuote);\n\n        $connection = $this->connection;\n\n        $query = new Query($connection);\n\n        $stmt = $connection->update('articles', ['published' => 'N'], ['id' => 3]);\n        $stmt->closeCursor();\n\n        $subquery = new Query($connection);\n        $subquery\n            ->select(\n                $subquery->newExpr()->case()->when(['a.published' => 'N'])->then(1)->else(0)\n            )\n            ->from(['a' => 'articles'])\n            ->where([\n                'a.id = articles.id',\n            ]);\n\n        $query\n            ->select(['id'])\n            ->from('articles')\n            ->orderDesc($subquery)\n            ->orderAsc('id')\n            ->setSelectTypeMap(new TypeMap([\n                'id' => 'integer',\n            ]));\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> ORDER BY \\(' .\n                'SELECT \\(CASE WHEN <a>\\.<published> = \\:c0 THEN \\:c1 ELSE \\:c2 END\\) ' .\n                'FROM <articles> <a> ' .\n                'WHERE a\\.id = articles\\.id' .\n            '\\) DESC, <id> ASC',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $this->assertEquals(\n            [\n                [\n                    'id' => 3,\n                ],\n                [\n                    'id' => 1,\n                ],\n                [\n                    'id' => 2,\n                ],\n            ],\n            $query->execute()->fetchAll('assoc')\n        );\n    }\n\n    /**\n     * Test that reusing expressions will duplicate bindings and run successfully.\n     *\n     * This replicates what the SQL Server driver would do for <= SQL Server 2008\n     * when ordering on fields that are expressions.\n     *\n     * @see \\Cake\\Database\\Driver\\Sqlserver::_pagingSubquery()\n     */\n    public function testReusingExpressions(): void\n    {\n        $connection = $this->connection;\n\n        $query = new Query($connection);\n\n        $stmt = $connection->update('articles', ['published' => 'N'], ['id' => 3]);\n        $stmt->closeCursor();\n\n        $subqueryA = new Query($connection);\n        $subqueryA\n            ->select('count(*)')\n            ->from(['a' => 'articles'])\n            ->where([\n                'a.id = articles.id',\n                'a.published' => 'Y',\n            ]);\n\n        $subqueryB = new Query($connection);\n        $subqueryB\n            ->select('count(*)')\n            ->from(['b' => 'articles'])\n            ->where([\n                'b.id = articles.id',\n                'b.published' => 'N',\n            ]);\n\n        $query\n            ->select([\n                'id',\n                'computedA' => $subqueryA,\n                'computedB' => $subqueryB,\n            ])\n            ->from('articles')\n            ->orderDesc($subqueryB)\n            ->orderAsc('id')\n            ->setSelectTypeMap(new TypeMap([\n                'id' => 'integer',\n                'computedA' => 'integer',\n                'computedB' => 'integer',\n            ]));\n\n        $this->assertQuotedQuery(\n            'SELECT <id>, ' .\n                '\\(SELECT count\\(\\*\\) FROM <articles> <a> WHERE \\(a\\.id = articles\\.id AND <a>\\.<published> = :c0\\)\\) AS <computedA>, ' .\n                '\\(SELECT count\\(\\*\\) FROM <articles> <b> WHERE \\(b\\.id = articles\\.id AND <b>\\.<published> = :c1\\)\\) AS <computedB> ' .\n            'FROM <articles> ' .\n            'ORDER BY \\(' .\n                'SELECT count\\(\\*\\) FROM <articles> <b> WHERE \\(b\\.id = articles\\.id AND <b>\\.<published> = :c2\\)' .\n            '\\) DESC, <id> ASC',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $this->assertSame(\n            [\n                [\n                    'id' => 3,\n                    'computedA' => 0,\n                    'computedB' => 1,\n                ],\n                [\n                    'id' => 1,\n                    'computedA' => 1,\n                    'computedB' => 0,\n                ],\n                [\n                    'id' => 2,\n                    'computedA' => 1,\n                    'computedB' => 0,\n                ],\n            ],\n            $query->execute()->fetchAll('assoc')\n        );\n\n        $this->assertSame(\n            [\n                ':c0' => [\n                    'value' => 'Y',\n                    'type' => null,\n                    'placeholder' => 'c0',\n                ],\n                ':c1' => [\n                    'value' => 'N',\n                    'type' => null,\n                    'placeholder' => 'c1',\n                ],\n                ':c2' => [\n                    'value' => 'N',\n                    'type' => null,\n                    'placeholder' => 'c2',\n                ],\n            ],\n            $query->getValueBinder()->bindings()\n        );\n    }\n\n    /**\n     * Tests creating StringExpression.\n     */\n    public function testStringExpression(): void\n    {\n        $driver = $this->connection->getDriver();\n        $collation = null;\n        if ($driver instanceof Mysql) {\n            if (version_compare($this->connection->getDriver()->version(), '5.7.0', '<')) {\n                $collation = 'utf8_general_ci';\n            } else {\n                $collation = 'utf8mb4_general_ci';\n            }\n        } elseif ($driver instanceof Postgres) {\n            $collation = 'en_US.utf8';\n        } elseif ($driver instanceof Sqlite) {\n            $collation = 'BINARY';\n        } elseif ($driver instanceof Sqlserver) {\n            $collation = 'Latin1_general_CI_AI';\n        }\n\n        $query = new Query($this->connection);\n        if ($driver instanceof Postgres) {\n            // Older postgres versions throw an error on the parameter type without a cast\n            $query->select(['test_string' => $query->func()->cast(new StringExpression('testString', $collation), 'text')]);\n            $expected = \"SELECT \\(CAST\\(:c0 COLLATE \\\"{$collation}\\\" AS text\\)\\) AS <test_string>\";\n        } else {\n            $query->select(['test_string' => new StringExpression('testString', $collation)]);\n            $expected = \"SELECT \\(:c0 COLLATE {$collation}\\) AS <test_string>\";\n        }\n        $this->assertRegExpSql($expected, $query->sql(new ValueBinder()), !$this->autoQuote);\n\n        $statement = $query->execute();\n        $this->assertSame('testString', $statement->fetchColumn(0));\n        $statement->closeCursor();\n    }\n\n    /**\n     * Tests setting identifier collation.\n     */\n    public function testIdentifierCollation(): void\n    {\n        $driver = $this->connection->getDriver();\n        $collation = null;\n        if ($driver instanceof Mysql) {\n            if (version_compare($this->connection->getDriver()->version(), '5.7.0', '<')) {\n                $collation = 'utf8_general_ci';\n            } else {\n                $collation = 'utf8mb4_general_ci';\n            }\n        } elseif ($driver instanceof Postgres) {\n            $collation = 'en_US.utf8';\n        } elseif ($driver instanceof Sqlite) {\n            $collation = 'BINARY';\n        } elseif ($driver instanceof Sqlserver) {\n            $collation = 'Latin1_general_CI_AI';\n        }\n\n        $query = (new Query($this->connection))\n            ->select(['test_string' => new IdentifierExpression('title', $collation)])\n            ->from('articles')\n            ->where(['id' => 1]);\n\n        if ($driver instanceof Postgres) {\n            // Older postgres versions throw an error on the parameter type without a cast\n            $expected = \"SELECT \\(<title> COLLATE \\\"{$collation}\\\"\\) AS <test_string>\";\n        } else {\n            $expected = \"SELECT \\(<title> COLLATE {$collation}\\) AS <test_string>\";\n        }\n        $this->assertRegExpSql($expected, $query->sql(new ValueBinder()), !$this->autoQuote);\n\n        $statement = $query->execute();\n        $this->assertSame('First Article', $statement->fetchColumn(0));\n        $statement->closeCursor();\n    }\n\n    /**\n     * Simple expressions from the point of view of the query expression\n     * object are expressions where the field contains one space at most.\n     */\n    public function testOperatorsInSimpleConditionsAreCaseInsensitive(): void\n    {\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('articles')\n            ->where(['id in' => [1, 2, 3]]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE <id> in \\(:c0,:c1,:c2\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('articles')\n            ->where(['id IN' => [1, 2, 3]]);\n\n        $this->assertQuotedQuery(\n            'SELECT <id> FROM <articles> WHERE <id> in \\(:c0,:c1,:c2\\)',\n            $query->sql(),\n            !$this->autoQuote\n        );\n    }\n\n    /**\n     * Complex expressions from the point of view of the query expression\n     * object are expressions where the field contains multiple spaces.\n     */\n    public function testOperatorsInComplexConditionsAreCaseInsensitive(): void\n    {\n        $this->skipIf($this->autoQuote, 'Does not work when autoquoting is enabled.');\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('profiles')\n            ->where(['CONCAT(first_name, \" \", last_name) in' => ['foo bar', 'baz 42']]);\n\n        $this->assertSame(\n            'SELECT id FROM profiles WHERE CONCAT\\(first_name, \" \", last_name\\) in \\(:c0,:c1\\)',\n            $query->sql()\n        );\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('profiles')\n            ->where(['CONCAT(first_name, \" \", last_name) IN' => ['foo bar', 'baz 42']]);\n\n        $this->assertSame(\n            'SELECT id FROM profiles WHERE CONCAT\\(first_name, \" \", last_name\\) in \\(:c0,:c1\\)',\n            $query->sql()\n        );\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('profiles')\n            ->where(['CONCAT(first_name, \" \", last_name) not in' => ['foo bar', 'baz 42']]);\n\n        $this->assertSame(\n            'SELECT id FROM profiles WHERE CONCAT\\(first_name, \" \", last_name\\) not in \\(:c0,:c1\\)',\n            $query->sql()\n        );\n\n        $query = (new Query($this->connection))\n            ->select('id')\n            ->from('profiles')\n            ->where(['CONCAT(first_name, \" \", last_name) NOT IN' => ['foo bar', 'baz 42']]);\n\n        $this->assertSame(\n            'SELECT id FROM profiles WHERE CONCAT\\(first_name, \" \", last_name\\) not in \\(:c0,:c1\\)',\n            $query->sql()\n        );\n    }\n}\n"], "filenames": ["src/Database/Query.php", "tests/TestCase/Database/QueryTest.php"], "buggy_code_start_loc": [1536, 2218], "buggy_code_end_loc": [1562, 2218], "fixing_code_start_loc": [1537, 2219], "fixing_code_end_loc": [1569, 2245], "type": "CWE-89", "message": "CakePHP is a development framework for PHP web apps. In affected versions the `Cake\\Database\\Query::limit()` and `Cake\\Database\\Query::offset()` methods are vulnerable to SQL injection if passed un-sanitized user request data. This issue has been fixed in 4.2.12, 4.3.11, 4.4.10. Users are advised to upgrade. Users unable to upgrade may mitigate this issue by using CakePHP's Pagination library. Manually validating or casting parameters to these methods will also mitigate the issue.", "other": {"cve": {"id": "CVE-2023-22727", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-17T21:15:16.550", "lastModified": "2023-01-25T02:23:22.650", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CakePHP is a development framework for PHP web apps. In affected versions the `Cake\\Database\\Query::limit()` and `Cake\\Database\\Query::offset()` methods are vulnerable to SQL injection if passed un-sanitized user request data. This issue has been fixed in 4.2.12, 4.3.11, 4.4.10. Users are advised to upgrade. Users unable to upgrade may mitigate this issue by using CakePHP's Pagination library. Manually validating or casting parameters to these methods will also mitigate the issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cakephp:cakephp:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2.0", "versionEndExcluding": "4.2.12", "matchCriteriaId": "54CC7CDF-D3A7-427B-B734-89E0E47778C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakephp:cakephp:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.3.0", "versionEndExcluding": "4.3.11", "matchCriteriaId": "09F4E6E5-91F9-4496-88A1-2B9DCC6D9656"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cakephp:cakephp:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4.0", "versionEndExcluding": "4.4.10", "matchCriteriaId": "45326B61-AA4E-4D7C-8B29-ACE4AA9951E5"}]}]}], "references": [{"url": "https://bakery.cakephp.org/2023/01/06/cakephp_4211_4311_4410_released.html", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/cakephp/cakephp/commit/3f463e7084b5a15e67205ced3a622577cca7a239", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cakephp/cakephp/security/advisories/GHSA-6g8q-qfpv-57wp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cakephp/cakephp/commit/3f463e7084b5a15e67205ced3a622577cca7a239"}}