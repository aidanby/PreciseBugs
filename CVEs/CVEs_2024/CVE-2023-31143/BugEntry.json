{"buggy_code": ["import Ansi from 'ansi-to-react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport ClickOutside from '@oracle/components/ClickOutside';\nimport Text from '@oracle/elements/Text';\nimport {\n  CharacterStyle,\n  ContainerStyle,\n  InnerStyle,\n  InputStyle,\n  LineStyle,\n} from './index.style';\nimport {\n  DataTypeEnum,\n  DATA_TYPE_TEXTLIKE,\n} from '@interfaces/KernelOutputType';\nimport {\n  KEY_CODE_ARROW_DOWN,\n  KEY_CODE_ARROW_LEFT,\n  KEY_CODE_ARROW_RIGHT,\n  KEY_CODE_ARROW_UP,\n  KEY_CODE_BACKSPACE,\n  KEY_CODE_C,\n  KEY_CODE_CONTROL,\n  KEY_CODE_ENTER,\n  KEY_CODE_META,\n  KEY_CODE_V,\n} from '@utils/hooks/keyboardShortcuts/constants';\nimport { onlyKeysPresent } from '@utils/hooks/keyboardShortcuts/utils';\nimport { pauseEvent } from '@utils/events';\nimport { useKeyboardContext } from '@context/Keyboard';\n\nexport const DEFAULT_TERMINAL_UUID = 'terminal';\n\ntype TerminalProps = {\n  lastMessage: WebSocketEventMap['message'] | null;\n  onFocus?: () => void;\n  sendMessage: (message: string, keep?: boolean) => void;\n  uuid?: string;\n  width?: number;\n};\n\nfunction Terminal({\n  lastMessage,\n  onFocus,\n  sendMessage,\n  uuid: terminalUUID = DEFAULT_TERMINAL_UUID,\n  width,\n}: TerminalProps) {\n  const refContainer = useRef(null);\n  const refInner = useRef(null);\n\n  const [command, setCommand] = useState<string>('');\n  const [commandIndex, setCommandIndex] = useState<number>(0);\n  const [cursorIndex, setCursorIndex] = useState<number>(0);\n  const [commandHistory, setCommandHistory] = useState<string[]>([]);\n  const [focus, setFocus] = useState<boolean>(false);\n\n  const [stdout, setStdout] = useState<string>();\n\n  useEffect(() => {\n    if (lastMessage) {\n      const msg = JSON.parse(lastMessage.data);\n\n      setStdout(prev => {\n        const p = prev || '';\n        if (msg[0] === 'stdout') {\n          const out = msg[1];\n          return p + out;\n        }\n        return p;\n      });\n    }\n  }, [\n    lastMessage,\n  ]);\n\n  const kernelOutputsUpdated = useMemo(() => {\n    if (!stdout) {\n      return [];\n    }\n    \n    // Filter out commands to configure settings\n    const splitStdout =\n      stdout\n        .split('\\n')\n        .filter(d => !d.includes('# Mage terminal settings command'));\n\n    return splitStdout.map(d => ({\n      data: d,\n      type: DataTypeEnum.TEXT,\n    }));\n  }, [stdout]);\n\n  useEffect(() => {\n    if (refContainer.current && refInner.current) {\n      const height = refInner.current.getBoundingClientRect().height;\n      refContainer.current.scrollTo(0, height);\n    }\n  }, [\n    command,\n    kernelOutputsUpdated,\n    refContainer,\n    refInner,\n  ]);\n\n  const {\n    registerOnKeyDown,\n    setDisableGlobalKeyboardShortcuts,\n    unregisterOnKeyDown,\n  } = useKeyboardContext();\n\n  useEffect(() => () => {\n    unregisterOnKeyDown(terminalUUID);\n  }, [unregisterOnKeyDown, terminalUUID]);\n\n  const decreaseCursorIndex = useCallback(() => {\n    setCursorIndex(currIdx => currIdx > 0 ? currIdx - 1 : currIdx);\n  }, []);\n  const increaseCursorIndex = useCallback(() => {\n    setCursorIndex(currIdx => (currIdx < command.length) ? currIdx + 1 : currIdx);\n  }, [command]);\n\n  const sendCommand = useCallback((cmd) => {\n    sendMessage(JSON.stringify([\n      'stdin', cmd,\n    ]));\n    sendMessage(JSON.stringify([\n      'stdin', '\\r',\n    ]));\n    if (cmd?.length >= 2) {\n      setCommandIndex(commandHistory.length + 1);\n      setCommandHistory(prev => prev.concat(cmd));\n      setCursorIndex(0);\n    }\n    setCommand('');\n  }, [\n    commandHistory,\n    sendMessage,\n    setCommand,\n    setCommandHistory,\n    setCommandIndex,\n    setCursorIndex,\n  ]);\n\n  const handleCopiedText = useCallback((clipText) => {\n    const lines = clipText?.split(/\\n/) || [];\n    if (lines.length > 1) {\n      const enteredLines = lines.slice(0, -1);\n      sendCommand(command + enteredLines.join('\\n'));\n      const currentCommand = (lines.slice(-1)[0] || '').trim();\n      setCommand(currentCommand);\n      setCursorIndex(currentCommand.length);\n    } else {\n      setCommand(prev => prev + clipText);\n      setCursorIndex(command.length + clipText.length);\n    }\n  }, [\n    command,\n    sendCommand,\n    setCommand,\n    setCursorIndex,\n  ]);\n\n  registerOnKeyDown(\n    terminalUUID,\n    (event, keyMapping, keyHistory) => {\n      const {\n        code,\n        key,\n      } = event;\n\n      if (focus) {\n        pauseEvent(event);\n        if (onlyKeysPresent([KEY_CODE_CONTROL, KEY_CODE_C], keyMapping)) {\n          if (command?.length >= 0) {\n            sendMessage(JSON.stringify([\n              'stdin', command,\n            ]));\n            sendMessage(JSON.stringify([\n              'stdin', '\\x03',\n            ]));\n            setCursorIndex(0);\n          }\n          setCommand('');\n        } else {\n          if (KEY_CODE_BACKSPACE === code && !keyMapping[KEY_CODE_META]) {\n            const minIdx = Math.max(0, cursorIndex - 1);\n            setCommand(prev => prev.slice(0, minIdx) + prev.slice(cursorIndex));\n            setCursorIndex(currIdx => Math.max(0, currIdx - 1));\n          } else if (onlyKeysPresent([KEY_CODE_ARROW_LEFT], keyMapping)) {\n            decreaseCursorIndex();\n          } else if (onlyKeysPresent([KEY_CODE_ARROW_RIGHT], keyMapping)) {\n            increaseCursorIndex();\n          } else if (onlyKeysPresent([KEY_CODE_ARROW_UP], keyMapping)) {\n            if (commandHistory.length >= 1) {\n              const idx = Math.max(0, commandIndex - 1);\n              setCommand(commandHistory[idx]);\n              setCommandIndex(idx);\n              setCursorIndex(commandHistory[idx]?.length || 0);\n            }\n          } else if (onlyKeysPresent([KEY_CODE_ARROW_DOWN], keyMapping)) {\n            if (commandHistory.length >= 1) {\n              const idx = Math.min(commandHistory.length, commandIndex + 1);\n              const nextCommand = commandHistory[idx] || '';\n              setCommand(nextCommand);\n              setCommandIndex(idx);\n              setCursorIndex(nextCommand.length);\n            }\n          } else if (onlyKeysPresent([KEY_CODE_ENTER], keyMapping)) {\n            sendCommand(command);\n          } else if (onlyKeysPresent([KEY_CODE_META, KEY_CODE_C], keyMapping)) {\n            navigator.clipboard.writeText(window.getSelection().toString());\n          } else if (onlyKeysPresent([KEY_CODE_META, KEY_CODE_V], keyMapping)\n            || onlyKeysPresent([KEY_CODE_CONTROL, KEY_CODE_V], keyMapping)) {\n            if (typeof navigator?.clipboard === 'undefined') {\n              alert('Clipboard pasting is not allowed in insecure contexts. If your Mage '\n                + 'deployment is not secure but you still want to use clipboard paste, you '\n                + 'can override this setting (which should only be done temporarily) '\n                + 'on Chrome browsers by going to '\n                + '\"chrome://flags/#unsafely-treat-insecure-origin-as-secure\", '\n                + 'adding your origin to \"Insecure origins treated as secure\", '\n                + 'and enabling that setting.');\n            } else if (navigator?.clipboard?.readText) {\n              navigator.clipboard.readText()\n                .then(handleCopiedText)\n                .catch(err => alert(`${err}\n    For Chrome, users need to allow clipboard permissions for this site under \\\n\"Privacy and security\" -> \"Site settings\".\n    For Safari, users need to allow the clipboard paste by clicking \"Paste\" \\\nin the context menu that appears.`),\n                );\n            } else if (navigator?.clipboard?.read) {\n              navigator.clipboard.read()\n                .then(clipboardItems => {\n                  for (const clipboardItem of clipboardItems) {\n                    for (const type of clipboardItem.types) {\n                      if (type === 'text/plain') {\n                        return clipboardItem.getType(type);\n                      }\n                    }\n                  }\n                }).then(blob => blob.text())\n                .then(handleCopiedText)\n                .catch(err => alert(`${err}\n    For Firefox, users need to allow clipboard paste by setting the \"dom.events.asyncClipboard.read\" \\\npreference in \"about:config\" to \"true\" and clicking \"Paste\" in the context menu that appears.`),\n                );\n            } else {\n              alert(`If pasting is not working properly, you may need to adjust some settings in your browser.\n\n    For Firefox, users need to allow clipboard paste by setting both the \"dom.events.asyncClipboard.clipboardItem\" \\\nand \"dom.events.asyncClipboard.read\" preferences in \"about:config\" to \"true\" and clicking \"Paste\" in the context \\\nmenu that appears.\n    For Chrome, users need to allow clipboard permissions for this site under \\\n\"Privacy and security\" -> \"Site settings\".\n    For Safari, users need to allow the clipboard paste by clicking \"Paste\" \\\nin the context menu that appears.\n`);\n            }\n          } else if (!keyMapping[KEY_CODE_META] && !keyMapping[KEY_CODE_CONTROL] && key.length === 1) {\n            setCommand(prev => prev.slice(0, cursorIndex) + key + prev.slice(cursorIndex));\n            setCursorIndex(currIdx => currIdx + 1);\n          }\n        }\n      }\n    },\n    [\n      command,\n      commandHistory,\n      commandIndex,\n      focus,\n      setCommand,\n      setCommandHistory,\n      setCommandIndex,\n      terminalUUID,\n    ],\n  );\n\n  const lastCommand = useMemo(\n    () => kernelOutputsUpdated[kernelOutputsUpdated.length - 1]?.data,\n    [kernelOutputsUpdated],\n  );\n\n  return (\n    <ContainerStyle\n      ref={refContainer}\n      width={width}\n    >\n      <ClickOutside\n        isOpen\n        onClick={() => {\n          onFocus?.();\n          setFocus(true);\n          setDisableGlobalKeyboardShortcuts(true);\n        }}\n        onClickOutside={() => {\n          setFocus(false);\n          setDisableGlobalKeyboardShortcuts(false);\n        }}\n        style={{\n          minHeight: '100%',\n        }}\n      >\n        <InnerStyle\n          ref={refInner}\n          width={width}\n        >\n          {kernelOutputsUpdated?.reduce((acc, kernelOutput: {\n            command?: string;\n            data: string;\n            type: DataTypeEnum;\n          }, idx: number) => {\n            if (idx == kernelOutputsUpdated.length - 1) {\n              return acc;\n            }\n            const {\n              command,\n              data: dataInit,\n              type: dataType,\n            } = kernelOutput || {};\n\n            let dataArray: string[] = [];\n            if (Array.isArray(dataInit)) {\n              dataArray = dataInit;\n            } else {\n              dataArray = [dataInit];\n            }\n            dataArray = dataArray.filter(d => d);\n\n            const arr = [];\n\n            dataArray.forEach((data: string, idxInner: number) => {\n              let displayElement;\n              if (DATA_TYPE_TEXTLIKE.includes(dataType)) {\n                displayElement = (\n                  <Text\n                    monospace\n                    preWrap\n                    // This used to be a no wrap Text component, but changing it\n                    // to no wrap for now. Please change it back if you see any issues.\n                  >\n                    {data && (\n                      <Ansi>\n                        {data}\n                      </Ansi>\n                    )}\n                  </Text>\n                );\n              }\n\n              if (displayElement) {\n                const key = `command-${idx}-${idxInner}-${data}`;\n\n                if (!command) {\n                  arr.push(\n                    // <LineStyle key={key}>\n                    <div key={key}>\n                      {displayElement}\n                    </div>,\n                    // </LineStyle>,\n                  );\n                }\n              }\n            });\n\n            return acc.concat(arr);\n          }, [])}\n\n          {(\n            <InputStyle\n              focused={focus\n                && (command?.length === 0)}\n            >\n              <Text monospace>\n                <Text inline monospace>\n                  {lastCommand && (\n                    <Ansi>\n                      {lastCommand}\n                    </Ansi>\n                  )}\n                </Text>\n                {command?.split('').map(((char: string, idx: number, arr: string[]) => (\n                  <CharacterStyle\n                    focusBeginning={focus && cursorIndex === 0 && idx === 0}\n                    focused={\n                      focus && \n                        (cursorIndex === idx + 1 ||\n                          cursorIndex >= arr.length && idx === arr.length - 1)\n                    }\n                    key={`command-${idx}-${char}`}\n                  >\n                    {char === ' ' && <>&nbsp;</>}\n                    {char === '\\n' && <br />}\n                    {char !== ' ' && char}\n                  </CharacterStyle>\n                )))}\n              </Text>\n            </InputStyle>\n          )}\n        </InnerStyle>\n      </ClickOutside>\n    </ContainerStyle>\n  );\n}\n\nexport default Terminal;\n", "from mage_ai.api.utils import authenticate_client_and_token\nfrom mage_ai.orchestration.db.models.oauth import Oauth2Application\nfrom mage_ai.settings import REQUIRE_USER_AUTHENTICATION\nimport terminado\nimport tornado.websocket\nimport re\n\n\nclass MageTermManager(terminado.NamedTermManager):\n    def get_terminal(self, term_name: str, **kwargs):\n        assert term_name is not None\n\n        if term_name in self.terminals:\n            return self.terminals[term_name]\n\n        if self.max_terminals and len(self.terminals) >= self.max_terminals:\n            raise terminado.management.MaxTerminalsReached(self.max_terminals)\n\n        # Create new terminal\n        self.log.info(\"New terminal with specified name: %s\", term_name)\n        term = self.new_terminal(**kwargs)\n        term.term_name = term_name\n        self.terminals[term_name] = term\n        self.start_reading(term)\n        return term\n\n\nclass MageUniqueTermManager(terminado.UniqueTermManager):\n    def get_terminal(self, url_component=None, **kwargs):\n        if self.max_terminals and len(self.ptys_by_fd) >= self.max_terminals:\n            raise terminado.management.MaxTerminalsReached(self.max_terminals)\n\n        term = self.new_terminal(**kwargs)\n        self.start_reading(term)\n        return term\n\n\nclass TerminalWebsocketServer(terminado.TermSocket):\n    @property\n    def term_command(self):\n        return next(iter(self.term_manager.shell_command))\n\n    def check_origin(self, origin):\n        return True\n\n    def on_pty_read(self, text):\n        \"\"\"Data read from pty; send to frontend\"\"\"\n        updated_text = text\n        if self.term_command == 'cmd':\n            xterm_escape = re.compile(r'(?:\\x1B\\]0;).*\\x07')\n            updated_text = xterm_escape.sub('', text)\n        self.send_json_message([\"stdout\", updated_text])\n\n    def open(self, *args, **kwargs):\n        \"\"\"Websocket connection opened.\n\n        Call our terminal manager to get a terminal, and connect to it as a\n        client.\n        \"\"\"\n        # Jupyter has a mixin to ping websockets and keep connections through\n        # proxies alive. Call super() to allow that to set up:\n        tornado.websocket.WebSocketHandler.open(self, *args, **kwargs)\n        api_key = self.get_argument('api_key', None, True)\n        token = self.get_argument('token', None, True)\n\n        cwd = self.get_argument('cwd', None, True)\n        term_name = self.get_argument('term_name', None, True)\n\n        user = None\n        if REQUIRE_USER_AUTHENTICATION and api_key and token:\n            oauth_client = Oauth2Application.query.filter(\n                Oauth2Application.client_id == api_key,\n            ).first()\n            if oauth_client:\n                oauth_token, valid = authenticate_client_and_token(oauth_client.id, token)\n                valid = valid and \\\n                    oauth_token and \\\n                    oauth_token.user\n                if valid:\n                    user = oauth_token.user\n                else:\n                    raise Exception('Invalid token')\n\n        self.term_name = term_name if term_name else 'tty'\n        if user:\n            self.term_name = f'{self.term_name}_{user.id}'\n\n        self._logger.info(\"TermSocket.open: %s\", self.term_name)\n\n        self.terminal = self.term_manager.get_terminal(self.term_name, cwd=cwd)\n        self.terminal.clients.append(self)\n        self.__initiate_terminal(self.terminal)\n\n    def __initiate_terminal(self, terminal):\n        self.send_json_message([\"setup\", {}])\n        self._logger.info(\"TermSocket.open: Opened %s\", self.term_name)\n        # Now drain the preopen buffer, if reconnect.\n        buffered = \"\"\n        preopen_buffer = terminal.read_buffer.copy()\n        while True:\n            if not preopen_buffer:\n                break\n            s = preopen_buffer.popleft()\n            buffered += s\n        if buffered:\n            self.on_pty_read(buffered)\n\n        # Turn enable-bracketed-paste off since it can mess up the output.\n        if self.term_command == 'bash':\n            terminal.ptyproc.write(\n                \"bind 'set enable-bracketed-paste off' # Mage terminal settings command\\r\")\n        terminal.read_buffer.clear()\n"], "fixing_code": ["import Ansi from 'ansi-to-react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport AuthToken from '@api/utils/AuthToken';\nimport ClickOutside from '@oracle/components/ClickOutside';\nimport Text from '@oracle/elements/Text';\nimport {\n  CharacterStyle,\n  ContainerStyle,\n  InnerStyle,\n  InputStyle,\n  LineStyle,\n} from './index.style';\nimport {\n  DataTypeEnum,\n  DATA_TYPE_TEXTLIKE,\n} from '@interfaces/KernelOutputType';\nimport {\n  KEY_CODE_ARROW_DOWN,\n  KEY_CODE_ARROW_LEFT,\n  KEY_CODE_ARROW_RIGHT,\n  KEY_CODE_ARROW_UP,\n  KEY_CODE_BACKSPACE,\n  KEY_CODE_C,\n  KEY_CODE_CONTROL,\n  KEY_CODE_ENTER,\n  KEY_CODE_META,\n  KEY_CODE_V,\n} from '@utils/hooks/keyboardShortcuts/constants';\nimport { OAUTH2_APPLICATION_CLIENT_ID } from '@api/constants';\nimport { onlyKeysPresent } from '@utils/hooks/keyboardShortcuts/utils';\nimport { pauseEvent } from '@utils/events';\nimport { useKeyboardContext } from '@context/Keyboard';\n\nexport const DEFAULT_TERMINAL_UUID = 'terminal';\n\ntype TerminalProps = {\n  lastMessage: WebSocketEventMap['message'] | null;\n  onFocus?: () => void;\n  sendMessage: (message: string, keep?: boolean) => void;\n  uuid?: string;\n  width?: number;\n};\n\nfunction Terminal({\n  lastMessage,\n  onFocus,\n  sendMessage,\n  uuid: terminalUUID = DEFAULT_TERMINAL_UUID,\n  width,\n}: TerminalProps) {\n  const refContainer = useRef(null);\n  const refInner = useRef(null);\n\n  const [command, setCommand] = useState<string>('');\n  const [commandIndex, setCommandIndex] = useState<number>(0);\n  const [cursorIndex, setCursorIndex] = useState<number>(0);\n  const [commandHistory, setCommandHistory] = useState<string[]>([]);\n  const [focus, setFocus] = useState<boolean>(false);\n\n  const [stdout, setStdout] = useState<string>();\n\n  const token = useMemo(() => new AuthToken(), []);\n  const oauthWebsocketData = useMemo(() => ({\n    api_key: OAUTH2_APPLICATION_CLIENT_ID,\n    token: token.decodedToken.token,\n  }), [\n    token,\n  ]);\n\n  useEffect(() => {\n    if (lastMessage) {\n      const msg = JSON.parse(lastMessage.data);\n\n      setStdout(prev => {\n        const p = prev || '';\n        if (msg[0] === 'stdout') {\n          const out = msg[1];\n          return p + out;\n        }\n        return p;\n      });\n    }\n  }, [\n    lastMessage,\n  ]);\n\n  const kernelOutputsUpdated = useMemo(() => {\n    if (!stdout) {\n      return [];\n    }\n    \n    // Filter out commands to configure settings\n    const splitStdout =\n      stdout\n        .split('\\n')\n        .filter(d => !d.includes('# Mage terminal settings command'));\n\n    return splitStdout.map(d => ({\n      data: d,\n      type: DataTypeEnum.TEXT,\n    }));\n  }, [stdout]);\n\n  useEffect(() => {\n    if (refContainer.current && refInner.current) {\n      const height = refInner.current.getBoundingClientRect().height;\n      refContainer.current.scrollTo(0, height);\n    }\n  }, [\n    command,\n    kernelOutputsUpdated,\n    refContainer,\n    refInner,\n  ]);\n\n  const {\n    registerOnKeyDown,\n    setDisableGlobalKeyboardShortcuts,\n    unregisterOnKeyDown,\n  } = useKeyboardContext();\n\n  useEffect(() => () => {\n    unregisterOnKeyDown(terminalUUID);\n  }, [unregisterOnKeyDown, terminalUUID]);\n\n  const decreaseCursorIndex = useCallback(() => {\n    setCursorIndex(currIdx => currIdx > 0 ? currIdx - 1 : currIdx);\n  }, []);\n  const increaseCursorIndex = useCallback(() => {\n    setCursorIndex(currIdx => (currIdx < command.length) ? currIdx + 1 : currIdx);\n  }, [command]);\n\n  const sendCommand = useCallback((cmd) => {\n    sendMessage(JSON.stringify({\n      ...oauthWebsocketData,\n      command: ['stdin', cmd + '\\r'],\n    }));\n    if (cmd?.length >= 2) {\n      setCommandIndex(commandHistory.length + 1);\n      setCommandHistory(prev => prev.concat(cmd));\n      setCursorIndex(0);\n    }\n    setCommand('');\n  }, [\n    commandHistory,\n    sendMessage,\n    setCommand,\n    setCommandHistory,\n    setCommandIndex,\n    setCursorIndex,\n  ]);\n\n  const handleCopiedText = useCallback((clipText) => {\n    const lines = clipText?.split(/\\n/) || [];\n    if (lines.length > 1) {\n      const enteredLines = lines.slice(0, -1);\n      sendCommand(command + enteredLines.join('\\n'));\n      const currentCommand = (lines.slice(-1)[0] || '').trim();\n      setCommand(currentCommand);\n      setCursorIndex(currentCommand.length);\n    } else {\n      setCommand(prev => prev + clipText);\n      setCursorIndex(command.length + clipText.length);\n    }\n  }, [\n    command,\n    sendCommand,\n    setCommand,\n    setCursorIndex,\n  ]);\n\n  registerOnKeyDown(\n    terminalUUID,\n    (event, keyMapping, keyHistory) => {\n      const {\n        code,\n        key,\n      } = event;\n\n      if (focus) {\n        pauseEvent(event);\n        if (onlyKeysPresent([KEY_CODE_CONTROL, KEY_CODE_C], keyMapping)) {\n          if (command?.length >= 0) {\n            sendMessage(JSON.stringify({\n              ...oauthWebsocketData,\n              command: ['stdin', command],\n            }));\n            sendMessage(JSON.stringify({\n              ...oauthWebsocketData,\n              command: ['stdin', '\\x03'],\n            }));\n            setCursorIndex(0);\n          }\n          setCommand('');\n        } else {\n          if (KEY_CODE_BACKSPACE === code && !keyMapping[KEY_CODE_META]) {\n            const minIdx = Math.max(0, cursorIndex - 1);\n            setCommand(prev => prev.slice(0, minIdx) + prev.slice(cursorIndex));\n            setCursorIndex(currIdx => Math.max(0, currIdx - 1));\n          } else if (onlyKeysPresent([KEY_CODE_ARROW_LEFT], keyMapping)) {\n            decreaseCursorIndex();\n          } else if (onlyKeysPresent([KEY_CODE_ARROW_RIGHT], keyMapping)) {\n            increaseCursorIndex();\n          } else if (onlyKeysPresent([KEY_CODE_ARROW_UP], keyMapping)) {\n            if (commandHistory.length >= 1) {\n              const idx = Math.max(0, commandIndex - 1);\n              setCommand(commandHistory[idx]);\n              setCommandIndex(idx);\n              setCursorIndex(commandHistory[idx]?.length || 0);\n            }\n          } else if (onlyKeysPresent([KEY_CODE_ARROW_DOWN], keyMapping)) {\n            if (commandHistory.length >= 1) {\n              const idx = Math.min(commandHistory.length, commandIndex + 1);\n              const nextCommand = commandHistory[idx] || '';\n              setCommand(nextCommand);\n              setCommandIndex(idx);\n              setCursorIndex(nextCommand.length);\n            }\n          } else if (onlyKeysPresent([KEY_CODE_ENTER], keyMapping)) {\n            sendCommand(command);\n          } else if (onlyKeysPresent([KEY_CODE_META, KEY_CODE_C], keyMapping)) {\n            navigator.clipboard.writeText(window.getSelection().toString());\n          } else if (onlyKeysPresent([KEY_CODE_META, KEY_CODE_V], keyMapping)\n            || onlyKeysPresent([KEY_CODE_CONTROL, KEY_CODE_V], keyMapping)) {\n            if (typeof navigator?.clipboard === 'undefined') {\n              alert('Clipboard pasting is not allowed in insecure contexts. If your Mage '\n                + 'deployment is not secure but you still want to use clipboard paste, you '\n                + 'can override this setting (which should only be done temporarily) '\n                + 'on Chrome browsers by going to '\n                + '\"chrome://flags/#unsafely-treat-insecure-origin-as-secure\", '\n                + 'adding your origin to \"Insecure origins treated as secure\", '\n                + 'and enabling that setting.');\n            } else if (navigator?.clipboard?.readText) {\n              navigator.clipboard.readText()\n                .then(handleCopiedText)\n                .catch(err => alert(`${err}\n    For Chrome, users need to allow clipboard permissions for this site under \\\n\"Privacy and security\" -> \"Site settings\".\n    For Safari, users need to allow the clipboard paste by clicking \"Paste\" \\\nin the context menu that appears.`),\n                );\n            } else if (navigator?.clipboard?.read) {\n              navigator.clipboard.read()\n                .then(clipboardItems => {\n                  for (const clipboardItem of clipboardItems) {\n                    for (const type of clipboardItem.types) {\n                      if (type === 'text/plain') {\n                        return clipboardItem.getType(type);\n                      }\n                    }\n                  }\n                }).then(blob => blob.text())\n                .then(handleCopiedText)\n                .catch(err => alert(`${err}\n    For Firefox, users need to allow clipboard paste by setting the \"dom.events.asyncClipboard.read\" \\\npreference in \"about:config\" to \"true\" and clicking \"Paste\" in the context menu that appears.`),\n                );\n            } else {\n              alert(`If pasting is not working properly, you may need to adjust some settings in your browser.\n\n    For Firefox, users need to allow clipboard paste by setting both the \"dom.events.asyncClipboard.clipboardItem\" \\\nand \"dom.events.asyncClipboard.read\" preferences in \"about:config\" to \"true\" and clicking \"Paste\" in the context \\\nmenu that appears.\n    For Chrome, users need to allow clipboard permissions for this site under \\\n\"Privacy and security\" -> \"Site settings\".\n    For Safari, users need to allow the clipboard paste by clicking \"Paste\" \\\nin the context menu that appears.\n`);\n            }\n          } else if (!keyMapping[KEY_CODE_META] && !keyMapping[KEY_CODE_CONTROL] && key.length === 1) {\n            setCommand(prev => prev.slice(0, cursorIndex) + key + prev.slice(cursorIndex));\n            setCursorIndex(currIdx => currIdx + 1);\n          }\n        }\n      }\n    },\n    [\n      command,\n      commandHistory,\n      commandIndex,\n      focus,\n      setCommand,\n      setCommandHistory,\n      setCommandIndex,\n      terminalUUID,\n    ],\n  );\n\n  const lastCommand = useMemo(\n    () => kernelOutputsUpdated[kernelOutputsUpdated.length - 1]?.data,\n    [kernelOutputsUpdated],\n  );\n\n  return (\n    <ContainerStyle\n      ref={refContainer}\n      width={width}\n    >\n      <ClickOutside\n        isOpen\n        onClick={() => {\n          onFocus?.();\n          setFocus(true);\n          setDisableGlobalKeyboardShortcuts(true);\n        }}\n        onClickOutside={() => {\n          setFocus(false);\n          setDisableGlobalKeyboardShortcuts(false);\n        }}\n        style={{\n          minHeight: '100%',\n        }}\n      >\n        <InnerStyle\n          ref={refInner}\n          width={width}\n        >\n          {kernelOutputsUpdated?.reduce((acc, kernelOutput: {\n            command?: string;\n            data: string;\n            type: DataTypeEnum;\n          }, idx: number) => {\n            if (idx == kernelOutputsUpdated.length - 1) {\n              return acc;\n            }\n            const {\n              command,\n              data: dataInit,\n              type: dataType,\n            } = kernelOutput || {};\n\n            let dataArray: string[] = [];\n            if (Array.isArray(dataInit)) {\n              dataArray = dataInit;\n            } else {\n              dataArray = [dataInit];\n            }\n            dataArray = dataArray.filter(d => d);\n\n            const arr = [];\n\n            dataArray.forEach((data: string, idxInner: number) => {\n              let displayElement;\n              if (DATA_TYPE_TEXTLIKE.includes(dataType)) {\n                displayElement = (\n                  <Text\n                    monospace\n                    preWrap\n                    // This used to be a no wrap Text component, but changing it\n                    // to no wrap for now. Please change it back if you see any issues.\n                  >\n                    {data && (\n                      <Ansi>\n                        {data}\n                      </Ansi>\n                    )}\n                  </Text>\n                );\n              }\n\n              if (displayElement) {\n                const key = `command-${idx}-${idxInner}-${data}`;\n\n                if (!command) {\n                  arr.push(\n                    // <LineStyle key={key}>\n                    <div key={key}>\n                      {displayElement}\n                    </div>,\n                    // </LineStyle>,\n                  );\n                }\n              }\n            });\n\n            return acc.concat(arr);\n          }, [])}\n\n          {(\n            <InputStyle\n              focused={focus\n                && (command?.length === 0)}\n            >\n              <Text monospace>\n                <Text inline monospace>\n                  {lastCommand && (\n                    <Ansi>\n                      {lastCommand}\n                    </Ansi>\n                  )}\n                </Text>\n                {command?.split('').map(((char: string, idx: number, arr: string[]) => (\n                  <CharacterStyle\n                    focusBeginning={focus && cursorIndex === 0 && idx === 0}\n                    focused={\n                      focus && \n                        (cursorIndex === idx + 1 ||\n                          cursorIndex >= arr.length && idx === arr.length - 1)\n                    }\n                    key={`command-${idx}-${char}`}\n                  >\n                    {char === ' ' && <>&nbsp;</>}\n                    {char === '\\n' && <br />}\n                    {char !== ' ' && char}\n                  </CharacterStyle>\n                )))}\n              </Text>\n            </InputStyle>\n          )}\n        </InnerStyle>\n      </ClickOutside>\n    </ContainerStyle>\n  );\n}\n\nexport default Terminal;\n", "from mage_ai.api.utils import (\n    authenticate_client_and_token,\n    has_at_least_editor_role,\n)\nfrom mage_ai.orchestration.db.models.oauth import Oauth2Application\nfrom mage_ai.settings import (\n    is_disable_pipeline_edit_access,\n    REQUIRE_USER_AUTHENTICATION,\n)\nfrom tornado import gen\nimport json\nimport terminado\nimport tornado.websocket\nimport re\n\n\nclass MageTermManager(terminado.NamedTermManager):\n    def get_terminal(self, term_name: str, **kwargs):\n        assert term_name is not None\n\n        if term_name in self.terminals:\n            return self.terminals[term_name]\n\n        if self.max_terminals and len(self.terminals) >= self.max_terminals:\n            raise terminado.management.MaxTerminalsReached(self.max_terminals)\n\n        # Create new terminal\n        self.log.info(\"New terminal with specified name: %s\", term_name)\n        term = self.new_terminal(**kwargs)\n        term.term_name = term_name\n        self.terminals[term_name] = term\n        self.start_reading(term)\n        return term\n\n\nclass MageUniqueTermManager(terminado.UniqueTermManager):\n    def get_terminal(self, url_component=None, **kwargs):\n        if self.max_terminals and len(self.ptys_by_fd) >= self.max_terminals:\n            raise terminado.management.MaxTerminalsReached(self.max_terminals)\n\n        term = self.new_terminal(**kwargs)\n        self.start_reading(term)\n        return term\n\n\nclass TerminalWebsocketServer(terminado.TermSocket):\n    @property\n    def term_command(self):\n        return next(iter(self.term_manager.shell_command))\n\n    def check_origin(self, origin):\n        return True\n\n    def on_pty_read(self, text):\n        \"\"\"Data read from pty; send to frontend\"\"\"\n        updated_text = text\n        if self.term_command == 'cmd':\n            xterm_escape = re.compile(r'(?:\\x1B\\]0;).*\\x07')\n            updated_text = xterm_escape.sub('', text)\n        self.send_json_message([\"stdout\", updated_text])\n\n    def open(self, *args, **kwargs):\n        \"\"\"Websocket connection opened.\n\n        Call our terminal manager to get a terminal, and connect to it as a\n        client.\n        \"\"\"\n        # Jupyter has a mixin to ping websockets and keep connections through\n        # proxies alive. Call super() to allow that to set up:\n        tornado.websocket.WebSocketHandler.open(self, *args, **kwargs)\n        api_key = self.get_argument('api_key', None, True)\n        token = self.get_argument('token', None, True)\n\n        cwd = self.get_argument('cwd', None, True)\n        term_name = self.get_argument('term_name', None, True)\n\n        user = None\n        if REQUIRE_USER_AUTHENTICATION and api_key and token:\n            oauth_client = Oauth2Application.query.filter(\n                Oauth2Application.client_id == api_key,\n            ).first()\n            if oauth_client:\n                oauth_token, valid = authenticate_client_and_token(oauth_client.id, token)\n                valid = valid and \\\n                    oauth_token and \\\n                    oauth_token.user\n                if valid:\n                    user = oauth_token.user\n\n        self.term_name = term_name if term_name else 'tty'\n        if user:\n            self.term_name = f'{self.term_name}_{user.id}'\n\n        self._logger.info(\"TermSocket.open: %s\", self.term_name)\n\n        self.terminal = self.term_manager.get_terminal(self.term_name, cwd=cwd)\n        self.terminal.clients.append(self)\n        self.__initiate_terminal(self.terminal)\n\n    @gen.coroutine\n    def on_message(self, raw_message):\n        message = json.loads(raw_message)\n\n        api_key = message.get('api_key')\n        token = message.get('token')\n        command = message.get('command')\n\n        if REQUIRE_USER_AUTHENTICATION or is_disable_pipeline_edit_access():\n            valid = False\n\n            if api_key and token:\n                oauth_client = Oauth2Application.query.filter(\n                    Oauth2Application.client_id == api_key,\n                ).first()\n                if oauth_client:\n                    oauth_token, valid = authenticate_client_and_token(oauth_client.id, token)\n                    valid = valid and \\\n                        oauth_token and \\\n                        oauth_token.user and \\\n                        has_at_least_editor_role(oauth_token.user)\n            if not valid or is_disable_pipeline_edit_access():\n                return self.send_json_message(\n                    ['stdout', f'{command[1]}\\nUnauthorized access to the terminal.'])\n\n        super().on_message(json.dumps(command))\n\n    def __initiate_terminal(self, terminal):\n        self.send_json_message([\"setup\", {}])\n        self._logger.info(\"TermSocket.open: Opened %s\", self.term_name)\n        # Now drain the preopen buffer, if reconnect.\n        buffered = \"\"\n        preopen_buffer = terminal.read_buffer.copy()\n        while True:\n            if not preopen_buffer:\n                break\n            s = preopen_buffer.popleft()\n            buffered += s\n        if buffered:\n            self.on_pty_read(buffered)\n\n        # Turn enable-bracketed-paste off since it can mess up the output.\n        if self.term_command == 'bash':\n            terminal.ptyproc.write(\n                \"bind 'set enable-bracketed-paste off' # Mage terminal settings command\\r\")\n        terminal.read_buffer.clear()\n"], "filenames": ["mage_ai/frontend/components/Terminal/index.tsx", "mage_ai/server/terminal_server.py"], "buggy_code_start_loc": [3, 1], "buggy_code_end_loc": [183, 92], "fixing_code_start_loc": [4, 1], "fixing_code_end_loc": [193, 126], "type": "CWE-306", "message": "mage-ai is an open-source data pipeline tool for transforming and integrating data. Those who use Mage starting in version 0.8.34 and prior to 0.8.72 with user authentication enabled may be affected by a vulnerability. The terminal could be accessed by users who are not signed in or do not have editor permissions. Version 0.8.72 contains a fix for this issue.", "other": {"cve": {"id": "CVE-2023-31143", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-09T15:15:10.303", "lastModified": "2023-05-16T16:56:16.440", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mage-ai is an open-source data pipeline tool for transforming and integrating data. Those who use Mage starting in version 0.8.34 and prior to 0.8.72 with user authentication enabled may be affected by a vulnerability. The terminal could be accessed by users who are not signed in or do not have editor permissions. Version 0.8.72 contains a fix for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-306"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mage:mage-ai:*:*:*:*:*:python:*:*", "versionStartIncluding": "0.8.34", "versionEndExcluding": "0.8.72", "matchCriteriaId": "ADC4138D-0C19-4231-AB14-FBF575748E57"}]}]}], "references": [{"url": "https://github.com/mage-ai/mage-ai/commit/f63cd00f6a3be372397d37a4c9a49bfaf50d7650", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mage-ai/mage-ai/security/advisories/GHSA-c6mm-2g84-v4m7", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mage-ai/mage-ai/commit/f63cd00f6a3be372397d37a4c9a49bfaf50d7650"}}