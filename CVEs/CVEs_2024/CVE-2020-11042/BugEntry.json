{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Windowing Alternate Secondary Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2011 Roman Barabanov <romanbarabanov@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include <freerdp/log.h>\n\n#include \"window.h\"\n\n#define TAG FREERDP_TAG(\"core.window\")\n\nstatic void update_free_window_icon_info(ICON_INFO* iconInfo);\n\nBOOL rail_read_unicode_string(wStream* s, RAIL_UNICODE_STRING* unicode_string)\n{\n\tUINT16 new_len;\n\tBYTE* new_str;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, new_len); /* cbString (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\treturn FALSE;\n\n\tif (!new_len)\n\t{\n\t\tfree(unicode_string->string);\n\t\tunicode_string->string = NULL;\n\t\tunicode_string->length = 0;\n\t\treturn TRUE;\n\t}\n\n\tnew_str = (BYTE*)realloc(unicode_string->string, new_len);\n\n\tif (!new_str)\n\t{\n\t\tfree(unicode_string->string);\n\t\tunicode_string->string = NULL;\n\t\treturn FALSE;\n\t}\n\n\tunicode_string->string = new_str;\n\tunicode_string->length = new_len;\n\tStream_Read(s, unicode_string->string, unicode_string->length);\n\treturn TRUE;\n}\n\nBOOL utf8_string_to_rail_string(const char* string, RAIL_UNICODE_STRING* unicode_string)\n{\n\tWCHAR* buffer = NULL;\n\tint length = 0;\n\tfree(unicode_string->string);\n\tunicode_string->string = NULL;\n\tunicode_string->length = 0;\n\n\tif (!string || strlen(string) < 1)\n\t\treturn TRUE;\n\n\tlength = ConvertToUnicode(CP_UTF8, 0, string, -1, &buffer, 0);\n\n\tif ((length < 0) || ((size_t)length * sizeof(WCHAR) > UINT16_MAX))\n\t{\n\t\tfree(buffer);\n\t\treturn FALSE;\n\t}\n\n\tunicode_string->string = (BYTE*)buffer;\n\tunicode_string->length = (UINT16)length * sizeof(WCHAR);\n\treturn TRUE;\n}\n\n/* See [MS-RDPERP] 2.2.1.2.3 Icon Info (TS_ICON_INFO) */\nstatic BOOL update_read_icon_info(wStream* s, ICON_INFO* iconInfo)\n{\n\tBYTE* newBitMask;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cacheEntry); /* cacheEntry (2 bytes) */\n\tStream_Read_UINT8(s, iconInfo->cacheId);     /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, iconInfo->bpp);         /* bpp (1 byte) */\n\n\tif ((iconInfo->bpp < 1) || (iconInfo->bpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", iconInfo->bpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, iconInfo->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->height); /* height (2 bytes) */\n\n\t/* cbColorTable is only present when bpp is 1, 4 or 8 */\n\tswitch (iconInfo->bpp)\n\t{\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s, iconInfo->cbColorTable); /* cbColorTable (2 bytes) */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ticonInfo->cbColorTable = 0;\n\t\t\tbreak;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask + iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\n\t/* bitsMask */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t/* colorTable */\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tif (iconInfo->cbColorTable)\n\t\t{\n\t\t\ticonInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);\n\n\t\t\tif (!iconInfo->colorTable)\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse if (iconInfo->cbColorTable)\n\t{\n\t\tBYTE* new_tab;\n\t\tnew_tab = (BYTE*)realloc(iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t\tif (!new_tab)\n\t\t{\n\t\t\tfree(iconInfo->colorTable);\n\t\t\ticonInfo->colorTable = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\ticonInfo->colorTable = new_tab;\n\t}\n\telse\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t/* bitsColor */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}\n\nstatic BOOL update_read_cached_icon_info(wStream* s, CACHED_ICON_INFO* cachedIconInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, cachedIconInfo->cacheEntry); /* cacheEntry (2 bytes) */\n\tStream_Read_UINT8(s, cachedIconInfo->cacheId);     /* cacheId (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_read_notify_icon_infotip(wStream* s, NOTIFY_ICON_INFOTIP* notifyIconInfoTip)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, notifyIconInfoTip->timeout);              /* timeout (4 bytes) */\n\tStream_Read_UINT32(s, notifyIconInfoTip->flags);                /* infoFlags (4 bytes) */\n\treturn rail_read_unicode_string(s, &notifyIconInfoTip->text) && /* infoTipText */\n\t       rail_read_unicode_string(s, &notifyIconInfoTip->title);  /* title */\n}\n\nstatic BOOL update_read_window_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                           WINDOW_STATE_ORDER* windowState)\n{\n\tUINT32 i;\n\tsize_t size;\n\tRECTANGLE_16* newRect;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->ownerWindowId); /* ownerWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->style);         /* style (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->extendedStyle); /* extendedStyle (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->showState); /* showState (1 byte) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE)\n\t{\n\t\tif (!rail_read_unicode_string(s, &windowState->titleInfo)) /* titleInfo */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->clientOffsetX); /* clientOffsetX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->clientOffsetY); /* clientOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->clientAreaWidth);  /* clientAreaWidth (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->clientAreaHeight); /* clientAreaHeight (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->resizeMarginLeft);\n\t\tStream_Read_UINT32(s, windowState->resizeMarginRight);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->resizeMarginTop);\n\t\tStream_Read_UINT32(s, windowState->resizeMarginBottom);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->RPContent); /* RPContent (1 byte) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->rootParentHandle); /* rootParentHandle (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->windowOffsetX); /* windowOffsetX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->windowOffsetY); /* windowOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->windowClientDeltaX); /* windowClientDeltaX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->windowClientDeltaY); /* windowClientDeltaY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->windowWidth);  /* windowWidth (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->windowHeight); /* windowHeight (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, windowState->numWindowRects); /* numWindowRects (2 bytes) */\n\n\t\tif (windowState->numWindowRects == 0)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tsize = sizeof(RECTANGLE_16) * windowState->numWindowRects;\n\t\tnewRect = (RECTANGLE_16*)realloc(windowState->windowRects, size);\n\n\t\tif (!newRect)\n\t\t{\n\t\t\tfree(windowState->windowRects);\n\t\t\twindowState->windowRects = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\twindowState->windowRects = newRect;\n\n\t\tif (Stream_GetRemainingLength(s) < 8 * windowState->numWindowRects)\n\t\t\treturn FALSE;\n\n\t\t/* windowRects */\n\t\tfor (i = 0; i < windowState->numWindowRects; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].left);   /* left (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].top);    /* top (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].right);  /* right (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].bottom); /* bottom (2 bytes) */\n\t\t}\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->visibleOffsetX); /* visibleOffsetX (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->visibleOffsetY); /* visibleOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, windowState->numVisibilityRects); /* numVisibilityRects (2 bytes) */\n\n\t\tif (windowState->numVisibilityRects != 0)\n\t\t{\n\t\t\tsize = sizeof(RECTANGLE_16) * windowState->numVisibilityRects;\n\t\t\tnewRect = (RECTANGLE_16*)realloc(windowState->visibilityRects, size);\n\n\t\t\tif (!newRect)\n\t\t\t{\n\t\t\t\tfree(windowState->visibilityRects);\n\t\t\t\twindowState->visibilityRects = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\twindowState->visibilityRects = newRect;\n\n\t\t\tif (Stream_GetRemainingLength(s) < windowState->numVisibilityRects * 8)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* visibilityRects */\n\t\t\tfor (i = 0; i < windowState->numVisibilityRects; i++)\n\t\t\t{\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].left);  /* left (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].top);   /* top (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].right); /* right (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s,\n\t\t\t\t                   windowState->visibilityRects[i].bottom); /* bottom (2 bytes) */\n\t\t\t}\n\t\t}\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)\n\t{\n\t\tif (!rail_read_unicode_string(s, &windowState->OverlayDescription))\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)\n\t{\n\t\t/* no data to be read here */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->TaskbarButton);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->EnforceServerZOrder);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->AppBarState);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->AppBarEdge);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_window_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                          WINDOW_ICON_ORDER* window_icon)\n{\n\tWINPR_UNUSED(orderInfo);\n\twindow_icon->iconInfo = (ICON_INFO*)calloc(1, sizeof(ICON_INFO));\n\n\tif (!window_icon->iconInfo)\n\t\treturn FALSE;\n\n\treturn update_read_icon_info(s, window_icon->iconInfo); /* iconInfo (ICON_INFO) */\n}\n\nstatic BOOL update_read_window_cached_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                 WINDOW_CACHED_ICON_ORDER* window_cached_icon)\n{\n\tWINPR_UNUSED(orderInfo);\n\treturn update_read_cached_icon_info(\n\t    s, &window_cached_icon->cachedIcon); /* cachedIcon (CACHED_ICON_INFO) */\n}\n\nstatic void update_read_window_delete_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* window deletion event */\n}\n\nstatic BOOL window_order_supported(const rdpSettings* settings, UINT32 fieldFlags)\n{\n\tconst UINT32 mask = (WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE | WINDOW_ORDER_FIELD_RP_CONTENT |\n\t                     WINDOW_ORDER_FIELD_ROOT_PARENT);\n\tBOOL dresult;\n\n\tif (!settings)\n\t\treturn FALSE;\n\n\t/* See [MS-RDPERP] 2.2.1.1.2 Window List Capability Set */\n\tdresult = settings->AllowUnanouncedOrdersFromServer;\n\n\tswitch (settings->RemoteWndSupportLevel)\n\t{\n\t\tcase WINDOW_LEVEL_SUPPORTED_EX:\n\t\t\treturn TRUE;\n\n\t\tcase WINDOW_LEVEL_SUPPORTED:\n\t\t\treturn ((fieldFlags & mask) == 0) || dresult;\n\n\t\tcase WINDOW_LEVEL_NOT_SUPPORTED:\n\t\t\treturn dresult;\n\n\t\tdefault:\n\t\t\treturn dresult;\n\t}\n}\n\n#define DUMP_APPEND(buffer, size, ...)            \\\n\tdo                                            \\\n\t{                                             \\\n\t\tchar* b = (buffer);                       \\\n\t\tsize_t s = (size);                        \\\n\t\tsize_t pos = strnlen(b, s);               \\\n\t\t_snprintf(&b[pos], s - pos, __VA_ARGS__); \\\n\t} while (0)\n\nstatic void dump_window_state_order(wLog* log, const char* msg, const WINDOW_ORDER_INFO* order,\n                                    const WINDOW_STATE_ORDER* state)\n{\n\tchar buffer[3000] = { 0 };\n\tconst size_t bufferSize = sizeof(buffer) - 1;\n\n\t_snprintf(buffer, bufferSize, \"%s windowId=0x%\" PRIu32 \"\", msg, order->windowId);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_OWNER)\n\t\tDUMP_APPEND(buffer, bufferSize, \" owner=0x%\" PRIx32 \"\", state->ownerWindowId);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_STYLE)\n\t{\n\t\tDUMP_APPEND(buffer, bufferSize, \" [ex]style=<0x%\" PRIx32 \", 0x%\" PRIx32 \"\", state->style,\n\t\t            state->extendedStyle);\n\t\tif (state->style & WS_POPUP)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" popup\");\n\t\tif (state->style & WS_VISIBLE)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" visible\");\n\t\tif (state->style & WS_THICKFRAME)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" thickframe\");\n\t\tif (state->style & WS_BORDER)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" border\");\n\t\tif (state->style & WS_CAPTION)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" caption\");\n\n\t\tif (state->extendedStyle & WS_EX_NOACTIVATE)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" noactivate\");\n\t\tif (state->extendedStyle & WS_EX_TOOLWINDOW)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" toolWindow\");\n\t\tif (state->extendedStyle & WS_EX_TOPMOST)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" topMost\");\n\n\t\tDUMP_APPEND(buffer, bufferSize, \">\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_SHOW)\n\t{\n\t\tconst char* showStr;\n\t\tswitch (state->showState)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tshowStr = \"hidden\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tshowStr = \"minimized\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tshowStr = \"maximized\";\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tshowStr = \"current\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tshowStr = \"<unknown>\";\n\t\t\t\tbreak;\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \" show=%s\", showStr);\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_TITLE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" title\");\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" clientOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->clientOffsetX, state->clientOffsetY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" clientAreaWidth=%\" PRIu32 \" clientAreaHeight=%\" PRIu32 \"\",\n\t\t            state->clientAreaWidth, state->clientAreaHeight);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)\n\t\tDUMP_APPEND(buffer, bufferSize,\n\t\t            \" resizeMarginLeft=%\" PRIu32 \" resizeMarginRight=%\" PRIu32 \"\",\n\t\t            state->resizeMarginLeft, state->resizeMarginRight);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)\n\t\tDUMP_APPEND(buffer, bufferSize,\n\t\t            \" resizeMarginTop=%\" PRIu32 \" resizeMarginBottom=%\" PRIu32 \"\",\n\t\t            state->resizeMarginTop, state->resizeMarginBottom);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)\n\t\tDUMP_APPEND(buffer, bufferSize, \" rpContent=0x%\" PRIx32 \"\", state->RPContent);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT)\n\t\tDUMP_APPEND(buffer, bufferSize, \" rootParent=0x%\" PRIx32 \"\", state->rootParentHandle);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->windowOffsetX, state->windowOffsetY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowClientDelta=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->windowClientDeltaX, state->windowClientDeltaY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowWidth=%\" PRIu32 \" windowHeight=%\" PRIu32 \"\",\n\t\t            state->windowWidth, state->windowHeight);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS)\n\t{\n\t\tUINT32 i;\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowRects=(\");\n\t\tfor (i = 0; i < state->numWindowRects; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"(%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \")\",\n\t\t\t            state->windowRects[i].left, state->windowRects[i].top,\n\t\t\t            state->windowRects[i].right, state->windowRects[i].bottom);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" visibleOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->visibleOffsetX, state->visibleOffsetY);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY)\n\t{\n\t\tUINT32 i;\n\t\tDUMP_APPEND(buffer, bufferSize, \" visibilityRects=(\");\n\t\tfor (i = 0; i < state->numVisibilityRects; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"(%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \")\",\n\t\t\t            state->visibilityRects[i].left, state->visibilityRects[i].top,\n\t\t\t            state->visibilityRects[i].right, state->visibilityRects[i].bottom);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)\n\t\tDUMP_APPEND(buffer, bufferSize, \" overlayDescr\");\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)\n\t\tDUMP_APPEND(buffer, bufferSize, \" iconOverlayNull\");\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)\n\t\tDUMP_APPEND(buffer, bufferSize, \" taskBarButton=0x%\" PRIx8 \"\", state->TaskbarButton);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)\n\t\tDUMP_APPEND(buffer, bufferSize, \" enforceServerZOrder=0x%\" PRIx8 \"\",\n\t\t            state->EnforceServerZOrder);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" appBarState=0x%\" PRIx8 \"\", state->AppBarState);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)\n\t{\n\t\tconst char* appBarEdgeStr;\n\t\tswitch (state->AppBarEdge)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tappBarEdgeStr = \"left\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tappBarEdgeStr = \"top\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tappBarEdgeStr = \"right\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tappBarEdgeStr = \"bottom\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappBarEdgeStr = \"<unknown>\";\n\t\t\t\tbreak;\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \" appBarEdge=%s\", appBarEdgeStr);\n\t}\n\n\tWLog_Print(log, WLOG_DEBUG, buffer);\n}\n\nstatic BOOL update_recv_window_info_order(rdpUpdate* update, wStream* s,\n                                          WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, orderInfo->windowId); /* windowId (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_ICON)\n\t{\n\t\tWINDOW_ICON_ORDER window_icon = { 0 };\n\t\tresult = update_read_window_icon_order(s, orderInfo, &window_icon);\n\n\t\tif (result)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowIcon windowId=0x%\" PRIx32 \"\",\n\t\t\t           orderInfo->windowId);\n\t\t\tIFCALLRET(window->WindowIcon, result, context, orderInfo, &window_icon);\n\t\t}\n\n\t\tupdate_free_window_icon_info(window_icon.iconInfo);\n\t\tfree(window_icon.iconInfo);\n\t}\n\telse if (orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON)\n\t{\n\t\tWINDOW_CACHED_ICON_ORDER window_cached_icon = { 0 };\n\t\tresult = update_read_window_cached_icon_order(s, orderInfo, &window_cached_icon);\n\n\t\tif (result)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowCachedIcon windowId=0x%\" PRIx32 \"\",\n\t\t\t           orderInfo->windowId);\n\t\t\tIFCALLRET(window->WindowCachedIcon, result, context, orderInfo, &window_cached_icon);\n\t\t}\n\t}\n\telse if (orderInfo->fieldFlags & WINDOW_ORDER_STATE_DELETED)\n\t{\n\t\tupdate_read_window_delete_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowDelete windowId=0x%\" PRIx32 \"\",\n\t\t           orderInfo->windowId);\n\t\tIFCALLRET(window->WindowDelete, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tWINDOW_STATE_ORDER windowState = { 0 };\n\t\tresult = update_read_window_state_order(s, orderInfo, &windowState);\n\n\t\tif (result)\n\t\t{\n\t\t\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)\n\t\t\t{\n\t\t\t\tdump_window_state_order(update->log, \"WindowCreate\", orderInfo, &windowState);\n\t\t\t\tIFCALLRET(window->WindowCreate, result, context, orderInfo, &windowState);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdump_window_state_order(update->log, \"WindowUpdate\", orderInfo, &windowState);\n\t\t\t\tIFCALLRET(window->WindowUpdate, result, context, orderInfo, &windowState);\n\t\t\t}\n\n\t\t\tupdate_free_window_state(&windowState);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic void update_notify_icon_state_order_free(NOTIFY_ICON_STATE_ORDER* notify)\n{\n\tfree(notify->toolTip.string);\n\tfree(notify->infoTip.text.string);\n\tfree(notify->infoTip.title.string);\n\tupdate_free_window_icon_info(&notify->icon);\n\tmemset(notify, 0, sizeof(NOTIFY_ICON_STATE_ORDER));\n}\n\nstatic BOOL update_read_notification_icon_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                      NOTIFY_ICON_STATE_ORDER* notify_icon_state)\n{\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, notify_icon_state->version); /* version (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP)\n\t{\n\t\tif (!rail_read_unicode_string(s,\n\t\t                              &notify_icon_state->toolTip)) /* toolTip (UNICODE_STRING) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP)\n\t{\n\t\tif (!update_read_notify_icon_infotip(\n\t\t        s, &notify_icon_state->infoTip)) /* infoTip (NOTIFY_ICON_INFOTIP) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, notify_icon_state->state); /* state (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_ICON)\n\t{\n\t\tif (!update_read_icon_info(s, &notify_icon_state->icon)) /* icon (ICON_INFO) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON)\n\t{\n\t\tif (!update_read_cached_icon_info(\n\t\t        s, &notify_icon_state->cachedIcon)) /* cachedIcon (CACHED_ICON_INFO) */\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_read_notification_icon_delete_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* notification icon deletion event */\n}\n\nstatic BOOL update_recv_notification_icon_info_order(rdpUpdate* update, wStream* s,\n                                                     WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, orderInfo->windowId);     /* windowId (4 bytes) */\n\tStream_Read_UINT32(s, orderInfo->notifyIconId); /* notifyIconId (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_DELETED)\n\t{\n\t\tupdate_read_notification_icon_delete_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconDelete\");\n\t\tIFCALLRET(window->NotifyIconDelete, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tNOTIFY_ICON_STATE_ORDER notify_icon_state = { 0 };\n\t\tresult = update_read_notification_icon_state_order(s, orderInfo, &notify_icon_state);\n\n\t\tif (!result)\n\t\t\tgoto fail;\n\n\t\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconCreate\");\n\t\t\tIFCALLRET(window->NotifyIconCreate, result, context, orderInfo, &notify_icon_state);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconUpdate\");\n\t\t\tIFCALLRET(window->NotifyIconUpdate, result, context, orderInfo, &notify_icon_state);\n\t\t}\n\tfail:\n\t\tupdate_notify_icon_state_order_free(&notify_icon_state);\n\t}\n\n\treturn result;\n}\n\nstatic BOOL update_read_desktop_actively_monitored_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                         MONITORED_DESKTOP_ORDER* monitored_desktop)\n{\n\tint i;\n\tint size;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, monitored_desktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tUINT32* newid;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, monitored_desktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\tif (Stream_GetRemainingLength(s) < 4 * monitored_desktop->numWindowIds)\n\t\t\treturn FALSE;\n\n\t\tif (monitored_desktop->numWindowIds > 0)\n\t\t{\n\t\t\tsize = sizeof(UINT32) * monitored_desktop->numWindowIds;\n\t\t\tnewid = (UINT32*)realloc(monitored_desktop->windowIds, size);\n\n\t\t\tif (!newid)\n\t\t\t{\n\t\t\t\tfree(monitored_desktop->windowIds);\n\t\t\t\tmonitored_desktop->windowIds = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tmonitored_desktop->windowIds = newid;\n\n\t\t\t/* windowIds */\n\t\t\tfor (i = 0; i < (int)monitored_desktop->numWindowIds; i++)\n\t\t\t{\n\t\t\t\tStream_Read_UINT32(s, monitored_desktop->windowIds[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_read_desktop_non_monitored_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* non-monitored desktop notification event */\n}\n\nstatic void dump_monitored_desktop(wLog* log, const char* msg, const WINDOW_ORDER_INFO* orderInfo,\n                                   const MONITORED_DESKTOP_ORDER* monitored)\n{\n\tchar buffer[1000] = { 0 };\n\tconst size_t bufferSize = sizeof(buffer) - 1;\n\n\tDUMP_APPEND(buffer, bufferSize, \"%s\", msg);\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t\tDUMP_APPEND(buffer, bufferSize, \" activeWindowId=0x%\" PRIx32 \"\", monitored->activeWindowId);\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tUINT32 i;\n\n\t\tDUMP_APPEND(buffer, bufferSize, \" windows=(\");\n\t\tfor (i = 0; i < monitored->numWindowIds; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"0x%\" PRIx32 \",\", monitored->windowIds[i]);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\tWLog_Print(log, WLOG_DEBUG, buffer);\n}\n\nstatic BOOL update_recv_desktop_info_order(rdpUpdate* update, wStream* s,\n                                           WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_NONE)\n\t{\n\t\tupdate_read_desktop_non_monitored_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"NonMonitoredDesktop, windowId=0x%\" PRIx32 \"\",\n\t\t           orderInfo->windowId);\n\t\tIFCALLRET(window->NonMonitoredDesktop, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tMONITORED_DESKTOP_ORDER monitored_desktop = { 0 };\n\t\tresult = update_read_desktop_actively_monitored_order(s, orderInfo, &monitored_desktop);\n\n\t\tif (result)\n\t\t{\n\t\t\tdump_monitored_desktop(update->log, \"ActivelyMonitoredDesktop\", orderInfo,\n\t\t\t                       &monitored_desktop);\n\t\t\tIFCALLRET(window->MonitoredDesktop, result, context, orderInfo, &monitored_desktop);\n\t\t}\n\n\t\tfree(monitored_desktop.windowIds);\n\t}\n\n\treturn result;\n}\n\nvoid update_free_window_icon_info(ICON_INFO* iconInfo)\n{\n\tif (!iconInfo)\n\t\treturn;\n\n\tfree(iconInfo->bitsColor);\n\ticonInfo->bitsColor = NULL;\n\tfree(iconInfo->bitsMask);\n\ticonInfo->bitsMask = NULL;\n\tfree(iconInfo->colorTable);\n\ticonInfo->colorTable = NULL;\n}\n\nBOOL update_recv_altsec_window_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = TRUE;\n\tsize_t remaining;\n\tUINT16 orderSize;\n\tWINDOW_ORDER_INFO orderInfo = { 0 };\n\tremaining = Stream_GetRemainingLength(s);\n\n\tif (remaining < 6)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream short\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderSize);            /* orderSize (2 bytes) */\n\tStream_Read_UINT32(s, orderInfo.fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (remaining + 1 < orderSize)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream short orderSize\");\n\t\treturn FALSE;\n\t}\n\n\tif (!window_order_supported(update->context->settings, orderInfo.fieldFlags))\n\t{\n\t\tWLog_INFO(TAG, \"Window order %08\" PRIx32 \" not supported!\", orderInfo.fieldFlags);\n\t\treturn FALSE;\n\t}\n\n\tif (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_WINDOW)\n\t\trc = update_recv_window_info_order(update, s, &orderInfo);\n\telse if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_NOTIFY)\n\t\trc = update_recv_notification_icon_info_order(update, s, &orderInfo);\n\telse if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_DESKTOP)\n\t\trc = update_recv_desktop_info_order(update, s, &orderInfo);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"windoworder flags %08\" PRIx32 \" failed\",\n\t\t           orderInfo.fieldFlags);\n\n\treturn rc;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Windowing Alternate Secondary Orders\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2011 Roman Barabanov <romanbarabanov@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include <freerdp/log.h>\n\n#include \"window.h\"\n\n#define TAG FREERDP_TAG(\"core.window\")\n\nstatic void update_free_window_icon_info(ICON_INFO* iconInfo);\n\nBOOL rail_read_unicode_string(wStream* s, RAIL_UNICODE_STRING* unicode_string)\n{\n\tUINT16 new_len;\n\tBYTE* new_str;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, new_len); /* cbString (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\treturn FALSE;\n\n\tif (!new_len)\n\t{\n\t\tfree(unicode_string->string);\n\t\tunicode_string->string = NULL;\n\t\tunicode_string->length = 0;\n\t\treturn TRUE;\n\t}\n\n\tnew_str = (BYTE*)realloc(unicode_string->string, new_len);\n\n\tif (!new_str)\n\t{\n\t\tfree(unicode_string->string);\n\t\tunicode_string->string = NULL;\n\t\treturn FALSE;\n\t}\n\n\tunicode_string->string = new_str;\n\tunicode_string->length = new_len;\n\tStream_Read(s, unicode_string->string, unicode_string->length);\n\treturn TRUE;\n}\n\nBOOL utf8_string_to_rail_string(const char* string, RAIL_UNICODE_STRING* unicode_string)\n{\n\tWCHAR* buffer = NULL;\n\tint length = 0;\n\tfree(unicode_string->string);\n\tunicode_string->string = NULL;\n\tunicode_string->length = 0;\n\n\tif (!string || strlen(string) < 1)\n\t\treturn TRUE;\n\n\tlength = ConvertToUnicode(CP_UTF8, 0, string, -1, &buffer, 0);\n\n\tif ((length < 0) || ((size_t)length * sizeof(WCHAR) > UINT16_MAX))\n\t{\n\t\tfree(buffer);\n\t\treturn FALSE;\n\t}\n\n\tunicode_string->string = (BYTE*)buffer;\n\tunicode_string->length = (UINT16)length * sizeof(WCHAR);\n\treturn TRUE;\n}\n\n/* See [MS-RDPERP] 2.2.1.2.3 Icon Info (TS_ICON_INFO) */\nstatic BOOL update_read_icon_info(wStream* s, ICON_INFO* iconInfo)\n{\n\tBYTE* newBitMask;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cacheEntry); /* cacheEntry (2 bytes) */\n\tStream_Read_UINT8(s, iconInfo->cacheId);     /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, iconInfo->bpp);         /* bpp (1 byte) */\n\n\tif ((iconInfo->bpp < 1) || (iconInfo->bpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid bpp value %\" PRIu32 \"\", iconInfo->bpp);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, iconInfo->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->height); /* height (2 bytes) */\n\n\t/* cbColorTable is only present when bpp is 1, 4 or 8 */\n\tswitch (iconInfo->bpp)\n\t{\n\t\tcase 1:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s, iconInfo->cbColorTable); /* cbColorTable (2 bytes) */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\ticonInfo->cbColorTable = 0;\n\t\t\tbreak;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */\n\n\t/* bitsMask */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t/* colorTable */\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tif (iconInfo->cbColorTable)\n\t\t{\n\t\t\ticonInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);\n\n\t\t\tif (!iconInfo->colorTable)\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse if (iconInfo->cbColorTable)\n\t{\n\t\tBYTE* new_tab;\n\t\tnew_tab = (BYTE*)realloc(iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t\tif (!new_tab)\n\t\t{\n\t\t\tfree(iconInfo->colorTable);\n\t\t\ticonInfo->colorTable = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\ticonInfo->colorTable = new_tab;\n\t}\n\telse\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < iconInfo->cbColorTable)\n\t\t\treturn FALSE;\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\t}\n\n\t/* bitsColor */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}\n\nstatic BOOL update_read_cached_icon_info(wStream* s, CACHED_ICON_INFO* cachedIconInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, cachedIconInfo->cacheEntry); /* cacheEntry (2 bytes) */\n\tStream_Read_UINT8(s, cachedIconInfo->cacheId);     /* cacheId (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_read_notify_icon_infotip(wStream* s, NOTIFY_ICON_INFOTIP* notifyIconInfoTip)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, notifyIconInfoTip->timeout);              /* timeout (4 bytes) */\n\tStream_Read_UINT32(s, notifyIconInfoTip->flags);                /* infoFlags (4 bytes) */\n\treturn rail_read_unicode_string(s, &notifyIconInfoTip->text) && /* infoTipText */\n\t       rail_read_unicode_string(s, &notifyIconInfoTip->title);  /* title */\n}\n\nstatic BOOL update_read_window_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                           WINDOW_STATE_ORDER* windowState)\n{\n\tUINT32 i;\n\tsize_t size;\n\tRECTANGLE_16* newRect;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->ownerWindowId); /* ownerWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->style);         /* style (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->extendedStyle); /* extendedStyle (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->showState); /* showState (1 byte) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE)\n\t{\n\t\tif (!rail_read_unicode_string(s, &windowState->titleInfo)) /* titleInfo */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->clientOffsetX); /* clientOffsetX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->clientOffsetY); /* clientOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->clientAreaWidth);  /* clientAreaWidth (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->clientAreaHeight); /* clientAreaHeight (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->resizeMarginLeft);\n\t\tStream_Read_UINT32(s, windowState->resizeMarginRight);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->resizeMarginTop);\n\t\tStream_Read_UINT32(s, windowState->resizeMarginBottom);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->RPContent); /* RPContent (1 byte) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->rootParentHandle); /* rootParentHandle (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->windowOffsetX); /* windowOffsetX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->windowOffsetY); /* windowOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_INT32(s, windowState->windowClientDeltaX); /* windowClientDeltaX (4 bytes) */\n\t\tStream_Read_INT32(s, windowState->windowClientDeltaY); /* windowClientDeltaY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->windowWidth);  /* windowWidth (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->windowHeight); /* windowHeight (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, windowState->numWindowRects); /* numWindowRects (2 bytes) */\n\n\t\tif (windowState->numWindowRects == 0)\n\t\t{\n\t\t\treturn TRUE;\n\t\t}\n\n\t\tsize = sizeof(RECTANGLE_16) * windowState->numWindowRects;\n\t\tnewRect = (RECTANGLE_16*)realloc(windowState->windowRects, size);\n\n\t\tif (!newRect)\n\t\t{\n\t\t\tfree(windowState->windowRects);\n\t\t\twindowState->windowRects = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\twindowState->windowRects = newRect;\n\n\t\tif (Stream_GetRemainingLength(s) < 8 * windowState->numWindowRects)\n\t\t\treturn FALSE;\n\n\t\t/* windowRects */\n\t\tfor (i = 0; i < windowState->numWindowRects; i++)\n\t\t{\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].left);   /* left (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].top);    /* top (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].right);  /* right (2 bytes) */\n\t\t\tStream_Read_UINT16(s, windowState->windowRects[i].bottom); /* bottom (2 bytes) */\n\t\t}\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, windowState->visibleOffsetX); /* visibleOffsetX (4 bytes) */\n\t\tStream_Read_UINT32(s, windowState->visibleOffsetY); /* visibleOffsetY (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT16(s, windowState->numVisibilityRects); /* numVisibilityRects (2 bytes) */\n\n\t\tif (windowState->numVisibilityRects != 0)\n\t\t{\n\t\t\tsize = sizeof(RECTANGLE_16) * windowState->numVisibilityRects;\n\t\t\tnewRect = (RECTANGLE_16*)realloc(windowState->visibilityRects, size);\n\n\t\t\tif (!newRect)\n\t\t\t{\n\t\t\t\tfree(windowState->visibilityRects);\n\t\t\t\twindowState->visibilityRects = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\twindowState->visibilityRects = newRect;\n\n\t\t\tif (Stream_GetRemainingLength(s) < windowState->numVisibilityRects * 8)\n\t\t\t\treturn FALSE;\n\n\t\t\t/* visibilityRects */\n\t\t\tfor (i = 0; i < windowState->numVisibilityRects; i++)\n\t\t\t{\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].left);  /* left (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].top);   /* top (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s, windowState->visibilityRects[i].right); /* right (2 bytes) */\n\t\t\t\tStream_Read_UINT16(s,\n\t\t\t\t                   windowState->visibilityRects[i].bottom); /* bottom (2 bytes) */\n\t\t\t}\n\t\t}\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)\n\t{\n\t\tif (!rail_read_unicode_string(s, &windowState->OverlayDescription))\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)\n\t{\n\t\t/* no data to be read here */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->TaskbarButton);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->EnforceServerZOrder);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->AppBarState);\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, windowState->AppBarEdge);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_window_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                          WINDOW_ICON_ORDER* window_icon)\n{\n\tWINPR_UNUSED(orderInfo);\n\twindow_icon->iconInfo = (ICON_INFO*)calloc(1, sizeof(ICON_INFO));\n\n\tif (!window_icon->iconInfo)\n\t\treturn FALSE;\n\n\treturn update_read_icon_info(s, window_icon->iconInfo); /* iconInfo (ICON_INFO) */\n}\n\nstatic BOOL update_read_window_cached_icon_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                 WINDOW_CACHED_ICON_ORDER* window_cached_icon)\n{\n\tWINPR_UNUSED(orderInfo);\n\treturn update_read_cached_icon_info(\n\t    s, &window_cached_icon->cachedIcon); /* cachedIcon (CACHED_ICON_INFO) */\n}\n\nstatic void update_read_window_delete_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* window deletion event */\n}\n\nstatic BOOL window_order_supported(const rdpSettings* settings, UINT32 fieldFlags)\n{\n\tconst UINT32 mask = (WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE | WINDOW_ORDER_FIELD_RP_CONTENT |\n\t                     WINDOW_ORDER_FIELD_ROOT_PARENT);\n\tBOOL dresult;\n\n\tif (!settings)\n\t\treturn FALSE;\n\n\t/* See [MS-RDPERP] 2.2.1.1.2 Window List Capability Set */\n\tdresult = settings->AllowUnanouncedOrdersFromServer;\n\n\tswitch (settings->RemoteWndSupportLevel)\n\t{\n\t\tcase WINDOW_LEVEL_SUPPORTED_EX:\n\t\t\treturn TRUE;\n\n\t\tcase WINDOW_LEVEL_SUPPORTED:\n\t\t\treturn ((fieldFlags & mask) == 0) || dresult;\n\n\t\tcase WINDOW_LEVEL_NOT_SUPPORTED:\n\t\t\treturn dresult;\n\n\t\tdefault:\n\t\t\treturn dresult;\n\t}\n}\n\n#define DUMP_APPEND(buffer, size, ...)            \\\n\tdo                                            \\\n\t{                                             \\\n\t\tchar* b = (buffer);                       \\\n\t\tsize_t s = (size);                        \\\n\t\tsize_t pos = strnlen(b, s);               \\\n\t\t_snprintf(&b[pos], s - pos, __VA_ARGS__); \\\n\t} while (0)\n\nstatic void dump_window_state_order(wLog* log, const char* msg, const WINDOW_ORDER_INFO* order,\n                                    const WINDOW_STATE_ORDER* state)\n{\n\tchar buffer[3000] = { 0 };\n\tconst size_t bufferSize = sizeof(buffer) - 1;\n\n\t_snprintf(buffer, bufferSize, \"%s windowId=0x%\" PRIu32 \"\", msg, order->windowId);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_OWNER)\n\t\tDUMP_APPEND(buffer, bufferSize, \" owner=0x%\" PRIx32 \"\", state->ownerWindowId);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_STYLE)\n\t{\n\t\tDUMP_APPEND(buffer, bufferSize, \" [ex]style=<0x%\" PRIx32 \", 0x%\" PRIx32 \"\", state->style,\n\t\t            state->extendedStyle);\n\t\tif (state->style & WS_POPUP)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" popup\");\n\t\tif (state->style & WS_VISIBLE)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" visible\");\n\t\tif (state->style & WS_THICKFRAME)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" thickframe\");\n\t\tif (state->style & WS_BORDER)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" border\");\n\t\tif (state->style & WS_CAPTION)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" caption\");\n\n\t\tif (state->extendedStyle & WS_EX_NOACTIVATE)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" noactivate\");\n\t\tif (state->extendedStyle & WS_EX_TOOLWINDOW)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" toolWindow\");\n\t\tif (state->extendedStyle & WS_EX_TOPMOST)\n\t\t\tDUMP_APPEND(buffer, bufferSize, \" topMost\");\n\n\t\tDUMP_APPEND(buffer, bufferSize, \">\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_SHOW)\n\t{\n\t\tconst char* showStr;\n\t\tswitch (state->showState)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tshowStr = \"hidden\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tshowStr = \"minimized\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tshowStr = \"maximized\";\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tshowStr = \"current\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tshowStr = \"<unknown>\";\n\t\t\t\tbreak;\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \" show=%s\", showStr);\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_TITLE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" title\");\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" clientOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->clientOffsetX, state->clientOffsetY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" clientAreaWidth=%\" PRIu32 \" clientAreaHeight=%\" PRIu32 \"\",\n\t\t            state->clientAreaWidth, state->clientAreaHeight);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X)\n\t\tDUMP_APPEND(buffer, bufferSize,\n\t\t            \" resizeMarginLeft=%\" PRIu32 \" resizeMarginRight=%\" PRIu32 \"\",\n\t\t            state->resizeMarginLeft, state->resizeMarginRight);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y)\n\t\tDUMP_APPEND(buffer, bufferSize,\n\t\t            \" resizeMarginTop=%\" PRIu32 \" resizeMarginBottom=%\" PRIu32 \"\",\n\t\t            state->resizeMarginTop, state->resizeMarginBottom);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT)\n\t\tDUMP_APPEND(buffer, bufferSize, \" rpContent=0x%\" PRIx32 \"\", state->RPContent);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT)\n\t\tDUMP_APPEND(buffer, bufferSize, \" rootParent=0x%\" PRIx32 \"\", state->rootParentHandle);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->windowOffsetX, state->windowOffsetY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowClientDelta=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->windowClientDeltaX, state->windowClientDeltaY);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowWidth=%\" PRIu32 \" windowHeight=%\" PRIu32 \"\",\n\t\t            state->windowWidth, state->windowHeight);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS)\n\t{\n\t\tUINT32 i;\n\t\tDUMP_APPEND(buffer, bufferSize, \" windowRects=(\");\n\t\tfor (i = 0; i < state->numWindowRects; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"(%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \")\",\n\t\t\t            state->windowRects[i].left, state->windowRects[i].top,\n\t\t\t            state->windowRects[i].right, state->windowRects[i].bottom);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET)\n\t\tDUMP_APPEND(buffer, bufferSize, \" visibleOffset=(%\" PRId32 \",%\" PRId32 \")\",\n\t\t            state->visibleOffsetX, state->visibleOffsetY);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY)\n\t{\n\t\tUINT32 i;\n\t\tDUMP_APPEND(buffer, bufferSize, \" visibilityRects=(\");\n\t\tfor (i = 0; i < state->numVisibilityRects; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"(%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \",%\" PRIu16 \")\",\n\t\t\t            state->visibilityRects[i].left, state->visibilityRects[i].top,\n\t\t\t            state->visibilityRects[i].right, state->visibilityRects[i].bottom);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION)\n\t\tDUMP_APPEND(buffer, bufferSize, \" overlayDescr\");\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL)\n\t\tDUMP_APPEND(buffer, bufferSize, \" iconOverlayNull\");\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON)\n\t\tDUMP_APPEND(buffer, bufferSize, \" taskBarButton=0x%\" PRIx8 \"\", state->TaskbarButton);\n\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER)\n\t\tDUMP_APPEND(buffer, bufferSize, \" enforceServerZOrder=0x%\" PRIx8 \"\",\n\t\t            state->EnforceServerZOrder);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE)\n\t\tDUMP_APPEND(buffer, bufferSize, \" appBarState=0x%\" PRIx8 \"\", state->AppBarState);\n\tif (order->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE)\n\t{\n\t\tconst char* appBarEdgeStr;\n\t\tswitch (state->AppBarEdge)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tappBarEdgeStr = \"left\";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tappBarEdgeStr = \"top\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tappBarEdgeStr = \"right\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tappBarEdgeStr = \"bottom\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tappBarEdgeStr = \"<unknown>\";\n\t\t\t\tbreak;\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \" appBarEdge=%s\", appBarEdgeStr);\n\t}\n\n\tWLog_Print(log, WLOG_DEBUG, buffer);\n}\n\nstatic BOOL update_recv_window_info_order(rdpUpdate* update, wStream* s,\n                                          WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, orderInfo->windowId); /* windowId (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_ICON)\n\t{\n\t\tWINDOW_ICON_ORDER window_icon = { 0 };\n\t\tresult = update_read_window_icon_order(s, orderInfo, &window_icon);\n\n\t\tif (result)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowIcon windowId=0x%\" PRIx32 \"\",\n\t\t\t           orderInfo->windowId);\n\t\t\tIFCALLRET(window->WindowIcon, result, context, orderInfo, &window_icon);\n\t\t}\n\n\t\tupdate_free_window_icon_info(window_icon.iconInfo);\n\t\tfree(window_icon.iconInfo);\n\t}\n\telse if (orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON)\n\t{\n\t\tWINDOW_CACHED_ICON_ORDER window_cached_icon = { 0 };\n\t\tresult = update_read_window_cached_icon_order(s, orderInfo, &window_cached_icon);\n\n\t\tif (result)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowCachedIcon windowId=0x%\" PRIx32 \"\",\n\t\t\t           orderInfo->windowId);\n\t\t\tIFCALLRET(window->WindowCachedIcon, result, context, orderInfo, &window_cached_icon);\n\t\t}\n\t}\n\telse if (orderInfo->fieldFlags & WINDOW_ORDER_STATE_DELETED)\n\t{\n\t\tupdate_read_window_delete_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"WindowDelete windowId=0x%\" PRIx32 \"\",\n\t\t           orderInfo->windowId);\n\t\tIFCALLRET(window->WindowDelete, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tWINDOW_STATE_ORDER windowState = { 0 };\n\t\tresult = update_read_window_state_order(s, orderInfo, &windowState);\n\n\t\tif (result)\n\t\t{\n\t\t\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)\n\t\t\t{\n\t\t\t\tdump_window_state_order(update->log, \"WindowCreate\", orderInfo, &windowState);\n\t\t\t\tIFCALLRET(window->WindowCreate, result, context, orderInfo, &windowState);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdump_window_state_order(update->log, \"WindowUpdate\", orderInfo, &windowState);\n\t\t\t\tIFCALLRET(window->WindowUpdate, result, context, orderInfo, &windowState);\n\t\t\t}\n\n\t\t\tupdate_free_window_state(&windowState);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic void update_notify_icon_state_order_free(NOTIFY_ICON_STATE_ORDER* notify)\n{\n\tfree(notify->toolTip.string);\n\tfree(notify->infoTip.text.string);\n\tfree(notify->infoTip.title.string);\n\tupdate_free_window_icon_info(&notify->icon);\n\tmemset(notify, 0, sizeof(NOTIFY_ICON_STATE_ORDER));\n}\n\nstatic BOOL update_read_notification_icon_state_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                      NOTIFY_ICON_STATE_ORDER* notify_icon_state)\n{\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, notify_icon_state->version); /* version (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP)\n\t{\n\t\tif (!rail_read_unicode_string(s,\n\t\t                              &notify_icon_state->toolTip)) /* toolTip (UNICODE_STRING) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP)\n\t{\n\t\tif (!update_read_notify_icon_infotip(\n\t\t        s, &notify_icon_state->infoTip)) /* infoTip (NOTIFY_ICON_INFOTIP) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, notify_icon_state->state); /* state (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_ICON)\n\t{\n\t\tif (!update_read_icon_info(s, &notify_icon_state->icon)) /* icon (ICON_INFO) */\n\t\t\treturn FALSE;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON)\n\t{\n\t\tif (!update_read_cached_icon_info(\n\t\t        s, &notify_icon_state->cachedIcon)) /* cachedIcon (CACHED_ICON_INFO) */\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_read_notification_icon_delete_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* notification icon deletion event */\n}\n\nstatic BOOL update_recv_notification_icon_info_order(rdpUpdate* update, wStream* s,\n                                                     WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, orderInfo->windowId);     /* windowId (4 bytes) */\n\tStream_Read_UINT32(s, orderInfo->notifyIconId); /* notifyIconId (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_DELETED)\n\t{\n\t\tupdate_read_notification_icon_delete_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconDelete\");\n\t\tIFCALLRET(window->NotifyIconDelete, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tNOTIFY_ICON_STATE_ORDER notify_icon_state = { 0 };\n\t\tresult = update_read_notification_icon_state_order(s, orderInfo, &notify_icon_state);\n\n\t\tif (!result)\n\t\t\tgoto fail;\n\n\t\tif (orderInfo->fieldFlags & WINDOW_ORDER_STATE_NEW)\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconCreate\");\n\t\t\tIFCALLRET(window->NotifyIconCreate, result, context, orderInfo, &notify_icon_state);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(update->log, WLOG_DEBUG, \"NotifyIconUpdate\");\n\t\t\tIFCALLRET(window->NotifyIconUpdate, result, context, orderInfo, &notify_icon_state);\n\t\t}\n\tfail:\n\t\tupdate_notify_icon_state_order_free(&notify_icon_state);\n\t}\n\n\treturn result;\n}\n\nstatic BOOL update_read_desktop_actively_monitored_order(wStream* s, WINDOW_ORDER_INFO* orderInfo,\n                                                         MONITORED_DESKTOP_ORDER* monitored_desktop)\n{\n\tint i;\n\tint size;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT32(s, monitored_desktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tUINT32* newid;\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\n\t\tStream_Read_UINT8(s, monitored_desktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\tif (Stream_GetRemainingLength(s) < 4 * monitored_desktop->numWindowIds)\n\t\t\treturn FALSE;\n\n\t\tif (monitored_desktop->numWindowIds > 0)\n\t\t{\n\t\t\tsize = sizeof(UINT32) * monitored_desktop->numWindowIds;\n\t\t\tnewid = (UINT32*)realloc(monitored_desktop->windowIds, size);\n\n\t\t\tif (!newid)\n\t\t\t{\n\t\t\t\tfree(monitored_desktop->windowIds);\n\t\t\t\tmonitored_desktop->windowIds = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tmonitored_desktop->windowIds = newid;\n\n\t\t\t/* windowIds */\n\t\t\tfor (i = 0; i < (int)monitored_desktop->numWindowIds; i++)\n\t\t\t{\n\t\t\t\tStream_Read_UINT32(s, monitored_desktop->windowIds[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_read_desktop_non_monitored_order(wStream* s, WINDOW_ORDER_INFO* orderInfo)\n{\n\t/* non-monitored desktop notification event */\n}\n\nstatic void dump_monitored_desktop(wLog* log, const char* msg, const WINDOW_ORDER_INFO* orderInfo,\n                                   const MONITORED_DESKTOP_ORDER* monitored)\n{\n\tchar buffer[1000] = { 0 };\n\tconst size_t bufferSize = sizeof(buffer) - 1;\n\n\tDUMP_APPEND(buffer, bufferSize, \"%s\", msg);\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t\tDUMP_APPEND(buffer, bufferSize, \" activeWindowId=0x%\" PRIx32 \"\", monitored->activeWindowId);\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tUINT32 i;\n\n\t\tDUMP_APPEND(buffer, bufferSize, \" windows=(\");\n\t\tfor (i = 0; i < monitored->numWindowIds; i++)\n\t\t{\n\t\t\tDUMP_APPEND(buffer, bufferSize, \"0x%\" PRIx32 \",\", monitored->windowIds[i]);\n\t\t}\n\t\tDUMP_APPEND(buffer, bufferSize, \")\");\n\t}\n\tWLog_Print(log, WLOG_DEBUG, buffer);\n}\n\nstatic BOOL update_recv_desktop_info_order(rdpUpdate* update, wStream* s,\n                                           WINDOW_ORDER_INFO* orderInfo)\n{\n\trdpContext* context = update->context;\n\trdpWindowUpdate* window = update->window;\n\tBOOL result = TRUE;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_NONE)\n\t{\n\t\tupdate_read_desktop_non_monitored_order(s, orderInfo);\n\t\tWLog_Print(update->log, WLOG_DEBUG, \"NonMonitoredDesktop, windowId=0x%\" PRIx32 \"\",\n\t\t           orderInfo->windowId);\n\t\tIFCALLRET(window->NonMonitoredDesktop, result, context, orderInfo);\n\t}\n\telse\n\t{\n\t\tMONITORED_DESKTOP_ORDER monitored_desktop = { 0 };\n\t\tresult = update_read_desktop_actively_monitored_order(s, orderInfo, &monitored_desktop);\n\n\t\tif (result)\n\t\t{\n\t\t\tdump_monitored_desktop(update->log, \"ActivelyMonitoredDesktop\", orderInfo,\n\t\t\t                       &monitored_desktop);\n\t\t\tIFCALLRET(window->MonitoredDesktop, result, context, orderInfo, &monitored_desktop);\n\t\t}\n\n\t\tfree(monitored_desktop.windowIds);\n\t}\n\n\treturn result;\n}\n\nvoid update_free_window_icon_info(ICON_INFO* iconInfo)\n{\n\tif (!iconInfo)\n\t\treturn;\n\n\tfree(iconInfo->bitsColor);\n\ticonInfo->bitsColor = NULL;\n\tfree(iconInfo->bitsMask);\n\ticonInfo->bitsMask = NULL;\n\tfree(iconInfo->colorTable);\n\ticonInfo->colorTable = NULL;\n}\n\nBOOL update_recv_altsec_window_order(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = TRUE;\n\tsize_t remaining;\n\tUINT16 orderSize;\n\tWINDOW_ORDER_INFO orderInfo = { 0 };\n\tremaining = Stream_GetRemainingLength(s);\n\n\tif (remaining < 6)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream short\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderSize);            /* orderSize (2 bytes) */\n\tStream_Read_UINT32(s, orderInfo.fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (remaining + 1 < orderSize)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream short orderSize\");\n\t\treturn FALSE;\n\t}\n\n\tif (!window_order_supported(update->context->settings, orderInfo.fieldFlags))\n\t{\n\t\tWLog_INFO(TAG, \"Window order %08\" PRIx32 \" not supported!\", orderInfo.fieldFlags);\n\t\treturn FALSE;\n\t}\n\n\tif (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_WINDOW)\n\t\trc = update_recv_window_info_order(update, s, &orderInfo);\n\telse if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_NOTIFY)\n\t\trc = update_recv_notification_icon_info_order(update, s, &orderInfo);\n\telse if (orderInfo.fieldFlags & WINDOW_ORDER_TYPE_DESKTOP)\n\t\trc = update_recv_desktop_info_order(update, s, &orderInfo);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"windoworder flags %08\" PRIx32 \" failed\",\n\t\t           orderInfo.fieldFlags);\n\n\treturn rc;\n}\n"], "filenames": ["libfreerdp/core/window.c"], "buggy_code_start_loc": [139], "buggy_code_end_loc": [199], "fixing_code_start_loc": [138], "fixing_code_end_loc": [205], "type": "CWE-125", "message": "In FreeRDP greater than 1.1 and before 2.0.0, there is an out-of-bounds read in update_read_icon_info. It allows reading a attacker-defined amount of client memory (32bit unsigned -> 4GB) to an intermediate buffer. This can be used to crash the client or store information for later retrieval. This has been patched in 2.0.0.", "other": {"cve": {"id": "CVE-2020-11042", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-07T19:15:11.673", "lastModified": "2022-07-01T17:21:30.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP greater than 1.1 and before 2.0.0, there is an out-of-bounds read in update_read_icon_info. It allows reading a attacker-defined amount of client memory (32bit unsigned -> 4GB) to an intermediate buffer. This can be used to crash the client or store information for later retrieval. This has been patched in 2.0.0."}, {"lang": "es", "value": "En FreeRDP versiones superiores a 1.2 y versiones anteriores a 2.0.0, se presenta una lectura fuera de l\u00edmites en update_read_icon_info. Permite leer una cantidad de memoria del cliente definida por el atacante (32 bits sin signo -) 4 GB) en un b\u00fafer intermedio. Esto puede ser usado para bloquear el cliente o almacenar informaci\u00f3n para su posterior recuperaci\u00f3n. Esto ha sido parcheado en la versi\u00f3n 2.0.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionStartExcluding": "1.1.0", "versionEndExcluding": "2.0.0", "matchCriteriaId": "F953BF38-4A6C-41EE-B646-37702989F524"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/6b2bc41935e53b0034fe5948aeeab4f32e80f30f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/issues/6010", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-9jp6-5vf2-cx2q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00054.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4379-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4382-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/6b2bc41935e53b0034fe5948aeeab4f32e80f30f"}}