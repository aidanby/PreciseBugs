{"buggy_code": ["import type { Params } from '../../router.ts'\nimport { METHOD_NAME_ALL } from '../../router.ts'\nimport type { Pattern } from '../../utils/url.ts'\nimport { splitPath, splitRoutingPath, getPattern } from '../../utils/url.ts'\n\ntype HandlerSet<T> = {\n  handler: T\n  params: Record<string, string>\n  possibleKeys: string[]\n  score: number\n  name: string // For debug\n}\n\nexport class Node<T> {\n  methods: Record<string, HandlerSet<T>>[]\n\n  children: Record<string, Node<T>>\n  patterns: Pattern[]\n  order: number = 0\n  name: string\n  params: Record<string, string> = {}\n\n  constructor(method?: string, handler?: T, children?: Record<string, Node<T>>) {\n    this.children = children || {}\n    this.methods = []\n    this.name = ''\n    if (method && handler) {\n      const m: Record<string, HandlerSet<T>> = {}\n      m[method] = { handler, params: {}, possibleKeys: [], score: 0, name: this.name }\n      this.methods = [m]\n    }\n    this.patterns = []\n  }\n\n  insert(method: string, path: string, handler: T): Node<T> {\n    this.name = `${method} ${path}`\n    this.order = ++this.order\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let curNode: Node<T> = this\n    const parts = splitRoutingPath(path)\n\n    const possibleKeys: string[] = []\n    const parentPatterns: Pattern[] = []\n\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const p: string = parts[i]\n\n      if (Object.keys(curNode.children).includes(p)) {\n        parentPatterns.push(...curNode.patterns)\n        curNode = curNode.children[p]\n        const pattern = getPattern(p)\n        if (pattern) possibleKeys.push(pattern[1])\n        continue\n      }\n\n      curNode.children[p] = new Node()\n\n      const pattern = getPattern(p)\n      if (pattern) {\n        curNode.patterns.push(pattern)\n        parentPatterns.push(...curNode.patterns)\n        possibleKeys.push(pattern[1])\n      }\n      parentPatterns.push(...curNode.patterns)\n      curNode = curNode.children[p]\n    }\n\n    if (!curNode.methods.length) {\n      curNode.methods = []\n    }\n\n    const m: Record<string, HandlerSet<T>> = {}\n\n    const handlerSet: HandlerSet<T> = {\n      handler,\n      params: {},\n      possibleKeys,\n      name: this.name,\n      score: this.order,\n    }\n\n    m[method] = handlerSet\n    curNode.methods.push(m)\n\n    return curNode\n  }\n\n  // getHandlerSets\n  private gHSets(node: Node<T>, method: string, params: Record<string, string>): HandlerSet<T>[] {\n    const handlerSets: HandlerSet<T>[] = []\n    for (let i = 0, len = node.methods.length; i < len; i++) {\n      const m = node.methods[i]\n      const handlerSet = m[method] || m[METHOD_NAME_ALL]\n      if (handlerSet !== undefined) {\n        handlerSet.possibleKeys.map((key) => {\n          handlerSet.params[key] = params[key]\n        })\n        handlerSets.push(handlerSet)\n      }\n    }\n    return handlerSets\n  }\n\n  search(method: string, path: string): [[T, Params][]] {\n    const handlerSets: HandlerSet<T>[] = []\n\n    const params: Record<string, string> = {}\n    this.params = {}\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const curNode: Node<T> = this\n    let curNodes = [curNode]\n    const parts = splitPath(path)\n\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const part: string = parts[i]\n      const isLast = i === len - 1\n      const tempNodes: Node<T>[] = []\n\n      for (let j = 0, len2 = curNodes.length; j < len2; j++) {\n        const node = curNodes[j]\n        const nextNode = node.children[part]\n\n        if (nextNode) {\n          if (isLast === true) {\n            // '/hello/*' => match '/hello'\n            if (nextNode.children['*']) {\n              handlerSets.push(\n                ...this.gHSets(nextNode.children['*'], method, { ...params, ...node.params })\n              )\n            }\n            handlerSets.push(...this.gHSets(nextNode, method, { ...params, ...node.params }))\n          } else {\n            tempNodes.push(nextNode)\n          }\n        }\n\n        for (let k = 0, len3 = node.patterns.length; k < len3; k++) {\n          const pattern = node.patterns[k]\n\n          // Wildcard\n          // '/hello/*/foo' => match /hello/bar/foo\n          if (pattern === '*') {\n            const astNode = node.children['*']\n            if (astNode) {\n              handlerSets.push(...this.gHSets(astNode, method, { ...params, ...node.params }))\n              tempNodes.push(astNode)\n            }\n            continue\n          }\n\n          if (part === '') continue\n\n          const [key, name, matcher] = pattern\n\n          const child = node.children[key]\n\n          // `/js/:filename{[a-z]+.js}` => match /js/chunk/123.js\n          const restPathString = parts.slice(i).join('/')\n          if (matcher instanceof RegExp && matcher.test(restPathString)) {\n            params[name] = restPathString\n            handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }))\n            continue\n          }\n\n          if (matcher === true || (matcher instanceof RegExp && matcher.test(part))) {\n            if (typeof key === 'string') {\n              params[name] = part\n              if (isLast === true) {\n                handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }))\n                if (child.children['*']) {\n                  handlerSets.push(\n                    ...this.gHSets(child.children['*'], method, { ...params, ...node.params })\n                  )\n                }\n              } else {\n                child.params = { ...params }\n                tempNodes.push(child)\n              }\n            }\n          }\n        }\n      }\n\n      curNodes = tempNodes\n    }\n    const results = handlerSets.sort((a, b) => {\n      return a.score - b.score\n    })\n\n    return [results.map(({ handler, params }) => [handler, params] as [T, Params])]\n  }\n}\n", "import { Node } from './node'\n\ndescribe('Root Node', () => {\n  const node = new Node()\n  node.insert('get', '/', 'get root')\n  it('get /', () => {\n    const [res] = node.search('get', '/')\n    expect(res).not.toBeNull()\n    expect(res[0][0]).toEqual('get root')\n    expect(node.search('get', '/hello')[0].length).toBe(0)\n  })\n})\n\ndescribe('Root Node is not defined', () => {\n  const node = new Node()\n  node.insert('get', '/hello', 'get hello')\n  it('get /', () => {\n    expect(node.search('get', '/')[0]).toEqual([])\n  })\n})\n\ndescribe('Get with *', () => {\n  const node = new Node()\n  node.insert('get', '*', 'get all')\n  it('get /', () => {\n    expect(node.search('get', '/')[0].length).toBe(1)\n    expect(node.search('get', '/hello')[0].length).toBe(1)\n  })\n})\n\ndescribe('Basic Usage', () => {\n  const node = new Node()\n  node.insert('get', '/hello', 'get hello')\n  node.insert('post', '/hello', 'post hello')\n  node.insert('get', '/hello/foo', 'get hello foo')\n\n  it('get, post /hello', () => {\n    expect(node.search('get', '/')[0].length).toBe(0)\n    expect(node.search('post', '/')[0].length).toBe(0)\n\n    expect(node.search('get', '/hello')[0][0][0]).toEqual('get hello')\n    expect(node.search('post', '/hello')[0][0][0]).toEqual('post hello')\n    expect(node.search('put', '/hello')[0].length).toBe(0)\n  })\n  it('get /nothing', () => {\n    expect(node.search('get', '/nothing')[0].length).toBe(0)\n  })\n  it('/hello/foo, /hello/bar', () => {\n    expect(node.search('get', '/hello/foo')[0][0][0]).toEqual('get hello foo')\n    expect(node.search('post', '/hello/foo')[0].length).toBe(0)\n    expect(node.search('get', '/hello/bar')[0].length).toBe(0)\n  })\n  it('/hello/foo/bar', () => {\n    expect(node.search('get', '/hello/foo/bar')[0].length).toBe(0)\n  })\n})\n\ndescribe('Name path', () => {\n  const node = new Node()\n  node.insert('get', '/entry/:id', 'get entry')\n  node.insert('get', '/entry/:id/comment/:comment_id', 'get comment')\n  node.insert('get', '/map/:location/events', 'get events')\n\n  it('get /entry/123', () => {\n    const [res] = node.search('get', '/entry/123')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('get entry')\n    expect(res[0][1]).not.toBeNull()\n    expect(res[0][1]['id']).toBe('123')\n    expect(res[0][1]['id']).not.toBe('1234')\n  })\n\n  it('get /entry/456/comment', () => {\n    const [res] = node.search('get', '/entry/456/comment')\n    expect(res.length).toBe(0)\n  })\n\n  it('get /entry/789/comment/123', () => {\n    const [res] = node.search('get', '/entry/789/comment/123')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('get comment')\n    expect(res[0][1]['id']).toBe('789')\n    expect(res[0][1]['comment_id']).toBe('123')\n  })\n\n  it('get /map/:location/events', () => {\n    const [res] = node.search('get', '/map/yokohama/events')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('get events')\n    expect(res[0][1]['location']).toBe('yokohama')\n  })\n})\n\ndescribe('Name path - Multiple route', () => {\n  const node = new Node()\n\n  node.insert('get', '/:type/:id', 'common')\n  node.insert('get', '/posts/:id', 'specialized')\n\n  it('get /posts/123', () => {\n    const [res] = node.search('get', '/posts/123')\n    expect(res.length).toBe(2)\n    expect(res[0][0]).toEqual('common')\n    expect(res[0][1]['id']).toBe('123')\n    expect(res[1][0]).toEqual('specialized')\n    expect(res[1][1]['id']).toBe('123')\n  })\n})\n\ndescribe('Param prefix', () => {\n  const node = new Node()\n\n  node.insert('get', '/:foo', 'onepart')\n  node.insert('get', '/:bar/:baz', 'twopart')\n\n  it('get /hello', () => {\n    const [res] = node.search('get', '/hello')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('onepart')\n    expect(res[0][1]['foo']).toBe('hello')\n  })\n\n  it('get /hello/world', () => {\n    const [res] = node.search('get', '/hello/world')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('twopart')\n    expect(res[0][1]['bar']).toBe('hello')\n    expect(res[0][1]['baz']).toBe('world')\n  })\n})\n\ndescribe('Named params and a wildcard', () => {\n  const node = new Node()\n\n  node.insert('get', '/:id/*', 'onepart')\n\n  it('get /', () => {\n    const [res] = node.search('get', '/')\n    expect(res.length).toBe(0)\n  })\n\n  it('get /foo', () => {\n    const [res] = node.search('get', '/foo')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('onepart')\n    expect(res[0][1]['id']).toEqual('foo')\n  })\n\n  it('get /foo/bar', () => {\n    const [res] = node.search('get', '/foo/bar')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('onepart')\n    expect(res[0][1]['id']).toEqual('foo')\n  })\n})\n\ndescribe('Wildcard', () => {\n  const node = new Node()\n  node.insert('get', '/wildcard-abc/*/wildcard-efg', 'wildcard')\n  it('/wildcard-abc/xxxxxx/wildcard-efg', () => {\n    const [res] = node.search('get', '/wildcard-abc/xxxxxx/wildcard-efg')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('wildcard')\n  })\n  node.insert('get', '/wildcard-abc/*/wildcard-efg/hijk', 'wildcard')\n  it('/wildcard-abc/xxxxxx/wildcard-efg/hijk', () => {\n    const [res] = node.search('get', '/wildcard-abc/xxxxxx/wildcard-efg/hijk')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('wildcard')\n  })\n})\n\ndescribe('Regexp', () => {\n  const node = new Node()\n  node.insert('get', '/regex-abc/:id{[0-9]+}/comment/:comment_id{[a-z]+}', 'regexp')\n  it('/regexp-abc/123/comment/abc', () => {\n    const [res] = node.search('get', '/regex-abc/123/comment/abc')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('regexp')\n    expect(res[0][1]['id']).toBe('123')\n    expect(res[0][1]['comment_id']).toBe('abc')\n  })\n  it('/regexp-abc/abc', () => {\n    const [res] = node.search('get', '/regex-abc/abc')\n    expect(res.length).toBe(0)\n  })\n  it('/regexp-abc/123/comment/123', () => {\n    const [res] = node.search('get', '/regex-abc/123/comment/123')\n    expect(res.length).toBe(0)\n  })\n})\n\ndescribe('All', () => {\n  const node = new Node()\n  node.insert('ALL', '/all-methods', 'all methods') // ALL\n  it('/all-methods', () => {\n    let [res] = node.search('get', '/all-methods')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('all methods')\n    ;[res] = node.search('put', '/all-methods')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('all methods')\n  })\n})\n\ndescribe('Special Wildcard', () => {\n  const node = new Node()\n  node.insert('ALL', '*', 'match all')\n\n  it('/foo', () => {\n    const [res] = node.search('get', '/foo')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match all')\n  })\n  it('/hello', () => {\n    const [res] = node.search('get', '/hello')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match all')\n  })\n  it('/hello/foo', () => {\n    const [res] = node.search('get', '/hello/foo')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match all')\n  })\n})\n\ndescribe('Special Wildcard deeply', () => {\n  const node = new Node()\n  node.insert('ALL', '/hello/*', 'match hello')\n  it('/hello', () => {\n    const [res] = node.search('get', '/hello')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match hello')\n  })\n  it('/hello/foo', () => {\n    const [res] = node.search('get', '/hello/foo')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match hello')\n  })\n})\n\ndescribe('Default with wildcard', () => {\n  const node = new Node()\n  node.insert('ALL', '/api/*', 'fallback')\n  node.insert('ALL', '/api/abc', 'match api')\n  it('/api/abc', () => {\n    const [res] = node.search('get', '/api/abc')\n    expect(res.length).toBe(2)\n    expect(res[0][0]).toEqual('fallback')\n    expect(res[1][0]).toEqual('match api')\n  })\n  it('/api/def', () => {\n    const [res] = node.search('get', '/api/def')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('fallback')\n  })\n})\n\ndescribe('Multi match', () => {\n  describe('Basic', () => {\n    const node = new Node()\n    node.insert('get', '*', 'GET *')\n    node.insert('get', '/abc/*', 'GET /abc/*')\n    node.insert('get', '/abc/*/edf', 'GET /abc/*/edf')\n    node.insert('get', '/abc/edf', 'GET /abc/edf')\n    node.insert('get', '/abc/*/ghi/jkl', 'GET /abc/*/ghi/jkl')\n    it('get /abc/edf', () => {\n      const [res] = node.search('get', '/abc/edf')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('GET *')\n      expect(res[1][0]).toEqual('GET /abc/*')\n      expect(res[2][0]).toEqual('GET /abc/edf')\n    })\n    it('get /abc/xxx/edf', () => {\n      const [res] = node.search('get', '/abc/xxx/edf')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('GET *')\n      expect(res[1][0]).toEqual('GET /abc/*')\n      expect(res[2][0]).toEqual('GET /abc/*/edf')\n    })\n    it('get /', () => {\n      const [res] = node.search('get', '/')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('GET *')\n    })\n    it('post /', () => {\n      const [res] = node.search('post', '/')\n      expect(res.length).toBe(0)\n    })\n    it('get /abc/edf/ghi', () => {\n      const [res] = node.search('get', '/abc/edf/ghi')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('GET *')\n      expect(res[1][0]).toEqual('GET /abc/*')\n    })\n  })\n  describe('Blog', () => {\n    const node = new Node()\n    node.insert('get', '*', 'middleware a') // 0.1\n    node.insert('ALL', '*', 'middleware b') // 0.2 <===\n    node.insert('get', '/entry', 'get entries') // 1.3\n    node.insert('post', '/entry/*', 'middleware c') // 1.4 <===\n    node.insert('post', '/entry', 'post entry') // 1.5 <===\n    node.insert('get', '/entry/:id', 'get entry') // 2.6\n    node.insert('get', '/entry/:id/comment/:comment_id', 'get comment') // 4.7\n    it('get /entry/123', async () => {\n      const [res] = node.search('get', '/entry/123')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('middleware a')\n      expect(res[0][1]['id']).toBe(undefined)\n      expect(res[1][0]).toEqual('middleware b')\n      expect(res[1][1]['id']).toBe(undefined)\n      expect(res[2][0]).toEqual('get entry')\n      expect(res[2][1]['id']).toBe('123')\n    })\n    it('get /entry/123/comment/456', async () => {\n      const [res] = node.search('get', '/entry/123/comment/456')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('middleware a')\n      expect(res[0][1]['id']).toBe(undefined)\n      expect(res[0][1]['comment_id']).toBe(undefined)\n      expect(res[1][0]).toEqual('middleware b')\n      expect(res[1][1]['id']).toBe(undefined)\n      expect(res[1][1]['comment_id']).toBe(undefined)\n      expect(res[2][0]).toEqual('get comment')\n      expect(res[2][1]['id']).toBe('123')\n      expect(res[2][1]['comment_id']).toBe('456')\n    })\n    it('post /entry', async () => {\n      const [res] = node.search('post', '/entry')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('middleware b')\n      expect(res[1][0]).toEqual('middleware c')\n      expect(res[2][0]).toEqual('post entry')\n    })\n    it('delete /entry', async () => {\n      const [res] = node.search('delete', '/entry')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('middleware b')\n    })\n  })\n  describe('ALL', () => {\n    const node = new Node()\n    node.insert('ALL', '*', 'ALL *')\n    node.insert('ALL', '/abc/*', 'ALL /abc/*')\n    node.insert('ALL', '/abc/*/def', 'ALL /abc/*/def')\n    it('get /', () => {\n      const [res] = node.search('get', '/')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('ALL *')\n    })\n    it('post /abc', () => {\n      const [res] = node.search('post', '/abc')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('ALL *')\n      expect(res[1][0]).toEqual('ALL /abc/*')\n    })\n    it('delete /abc/xxx/def', () => {\n      const [res] = node.search('post', '/abc/xxx/def')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('ALL *')\n      expect(res[1][0]).toEqual('ALL /abc/*')\n      expect(res[2][0]).toEqual('ALL /abc/*/def')\n    })\n  })\n  describe('Regexp', () => {\n    const node = new Node()\n    node.insert('get', '/regex-abc/:id{[0-9]+}/*', 'middleware a')\n    node.insert('get', '/regex-abc/:id{[0-9]+}/def', 'regexp')\n    it('/regexp-abc/123/def', () => {\n      const [res] = node.search('get', '/regex-abc/123/def')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('middleware a')\n      expect(res[0][1]['id']).toBe('123')\n      expect(res[1][0]).toEqual('regexp')\n      expect(res[1][1]['id']).toBe('123')\n    })\n    it('/regexp-abc/123', () => {\n      const [res] = node.search('get', '/regex-abc/123/ghi')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('middleware a')\n    })\n  })\n  describe('Trailing slash', () => {\n    const node = new Node()\n    node.insert('get', '/book', 'GET /book')\n    node.insert('get', '/book/:id', 'GET /book/:id')\n    it('get /book', () => {\n      const [res] = node.search('get', '/book')\n      expect(res.length).toBe(1)\n    })\n    it('get /book/', () => {\n      const [res] = node.search('get', '/book/')\n      expect(res.length).toBe(0)\n    })\n  })\n  describe('Same path', () => {\n    const node = new Node()\n    node.insert('get', '/hey', 'Middleware A')\n    node.insert('get', '/hey', 'Middleware B')\n    it('get /hey', () => {\n      const [res] = node.search('get', '/hey')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('Middleware A')\n      expect(res[1][0]).toEqual('Middleware B')\n    })\n  })\n  describe('Including slashes', () => {\n    const node = new Node()\n    node.insert('get', '/js/:filename{[a-z0-9/]+.js}', 'any file')\n    node.insert('get', '/js/main.js', 'main.js')\n    it('get /js/main.js', () => {\n      const [res] = node.search('get', '/js/main.js')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('any file')\n      expect(res[0][1]).toEqual({ filename: 'main.js' })\n      expect(res[1][0]).toEqual('main.js')\n      expect(res[1][1]).toEqual({})\n    })\n    it('get /js/chunk/123.js', () => {\n      const [res] = node.search('get', '/js/chunk/123.js')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('any file')\n      expect(res[0][1]).toEqual({ filename: 'chunk/123.js' })\n    })\n    it('get /js/chunk/nest/123.js', () => {\n      const [res] = node.search('get', '/js/chunk/nest/123.js')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('any file')\n      expect(res[0][1]).toEqual({ filename: 'chunk/nest/123.js' })\n    })\n  })\n  describe('REST API', () => {\n    const node = new Node()\n    node.insert('get', '/users/:username{[a-z]+}', 'profile')\n    node.insert('get', '/users/:username{[a-z]+}/posts', 'posts')\n    it('get /users/hono', () => {\n      const [res] = node.search('get', '/users/hono')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('profile')\n    })\n    it('get /users/hono/posts', () => {\n      const [res] = node.search('get', '/users/hono/posts')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('posts')\n    })\n  })\n})\n\ndescribe('Duplicate param name', () => {\n  it('self', () => {\n    const node = new Node()\n    node.insert('get', '/:id/:id', 'foo')\n    const [res] = node.search('get', '/123/456')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toBe('foo')\n    expect(res[0][1]['id']).toBe('123')\n  })\n\n  describe('parent', () => {\n    const node = new Node()\n    node.insert('get', '/:id/:action', 'foo')\n    node.insert('get', '/posts/:id', 'bar')\n    node.insert('get', '/posts/:id/comments/:comment_id', 'comment')\n\n    it('get /123/action', () => {\n      const [res] = node.search('get', '/123/action')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toBe('foo')\n      expect(res[0][1]).toEqual({ id: '123', action: 'action' })\n    })\n\n    it('get /posts/456', () => {\n      const [res] = node.search('get', '/posts/456')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toBe('foo')\n      expect(res[0][1]).toEqual({ id: 'posts', action: '456' })\n      expect(res[1][0]).toBe('bar')\n      expect(res[1][1]).toEqual({ id: '456' })\n\n      it('get /posts/456', () => {\n        const [res] = node.search('get', '/posts/abc/comments/edf')\n        expect(res.length).toBe(1)\n        expect(res[0][0]).toBe('comment')\n        expect(res[0][1]).toEqual({ id: 'abc', comment_id: 'edf' })\n      })\n    })\n  })\n\n  describe('child', () => {\n    const node = new Node()\n    node.insert('get', '/posts/:id', 'foo')\n    node.insert('get', '/:id/:action', 'bar')\n    it('get /posts/action', () => {\n      const [res] = node.search('get', '/posts/action')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toBe('foo')\n      expect(res[0][1]).toEqual({ id: 'action' })\n      expect(res[1][0]).toBe('bar')\n      expect(res[1][1]).toEqual({ id: 'posts', action: 'action' })\n    })\n  })\n\n  describe('regular expression', () => {\n    const node = new Node()\n    node.insert('get', '/:id/:action{create|update}', 'foo')\n    node.insert('get', '/:id/:action{delete}', 'bar')\n    it('get /123/create', () => {\n      const [res] = node.search('get', '/123/create')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toBe('foo')\n      expect(res[0][1]).toEqual({ id: '123', action: 'create' })\n    })\n    it('get /123/delete', () => {\n      const [res] = node.search('get', '/123/delete')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toBe('bar')\n      expect(res[0][1]).toEqual({ id: '123', action: 'delete' })\n    })\n  })\n})\n\ndescribe('Sort Order', () => {\n  describe('Basic', () => {\n    const node = new Node()\n    node.insert('get', '*', 'a')\n    node.insert('get', '/page', '/page')\n    node.insert('get', '/:slug', '/:slug')\n\n    it('get /page', () => {\n      const [res] = node.search('get', '/page')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('a')\n      expect(res[1][0]).toEqual('/page')\n      expect(res[2][0]).toEqual('/:slug')\n    })\n  })\n\n  describe('With Named path', () => {\n    const node = new Node()\n    node.insert('get', '*', 'a')\n    node.insert('get', '/posts/:id', '/posts/:id')\n    node.insert('get', '/:type/:id', '/:type/:id')\n\n    it('get /posts/123', () => {\n      const [res] = node.search('get', '/posts/123')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('a')\n      expect(res[1][0]).toEqual('/posts/:id')\n      expect(res[2][0]).toEqual('/:type/:id')\n    })\n  })\n\n  describe('With Wildcards', () => {\n    const node = new Node()\n    node.insert('get', '/api/*', '1st')\n    node.insert('get', '/api/*', '2nd')\n    node.insert('get', '/api/posts/:id', '3rd')\n    node.insert('get', '/api/*', '4th')\n\n    it('get /api/posts/123', () => {\n      const [res] = node.search('get', '/api/posts/123')\n      expect(res.length).toBe(4)\n      expect(res[0][0]).toEqual('1st')\n      expect(res[1][0]).toEqual('2nd')\n      expect(res[2][0]).toEqual('3rd')\n      expect(res[3][0]).toEqual('4th')\n    })\n  })\n\n  describe('With special Wildcard', () => {\n    const node = new Node()\n    node.insert('get', '/posts', '/posts') // 1.1\n    node.insert('get', '/posts/*', '/posts/*') // 1.2\n    node.insert('get', '/posts/:id', '/posts/:id') // 2.3\n\n    it('get /posts', () => {\n      const [res] = node.search('get', '/posts')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('/posts')\n      expect(res[1][0]).toEqual('/posts/*')\n    })\n  })\n\n  describe('Complex', () => {\n    const node = new Node()\n    node.insert('get', '/api', 'a') // not match\n    node.insert('get', '/api/*', 'b') // match\n    node.insert('get', '/api/:type', 'c') // not match\n    node.insert('get', '/api/:type/:id', 'd') // match\n    node.insert('get', '/api/posts/:id', 'e') // match\n    node.insert('get', '/api/posts/123', 'f') // match\n    node.insert('get', '/*/*/:id', 'g') // match\n    node.insert('get', '/api/posts/*/comment', 'h') // not match\n    node.insert('get', '*', 'i') // match\n    node.insert('get', '*', 'j') // match\n\n    it('get /api/posts/123', () => {\n      const [res] = node.search('get', '/api/posts/123')\n      expect(res.length).toBe(7)\n      expect(res[0][0]).toEqual('b')\n      expect(res[1][0]).toEqual('d')\n      expect(res[2][0]).toEqual('e')\n      expect(res[3][0]).toEqual('f')\n      expect(res[4][0]).toEqual('g')\n      expect(res[5][0]).toEqual('i')\n      expect(res[6][0]).toEqual('j')\n    })\n  })\n\n  describe('Multi match', () => {\n    const node = new Node()\n    node.insert('get', '*', 'GET *') // 0.1\n    node.insert('get', '/abc/*', 'GET /abc/*') // 1.2\n    node.insert('get', '/abc/edf', 'GET /abc/edf') // 2.3\n    node.insert('get', '/abc/*/ghi/jkl', 'GET /abc/*/ghi/jkl') // 4.4\n    it('get /abc/edf', () => {\n      const [res] = node.search('get', '/abc/edf')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('GET *')\n      expect(res[1][0]).toEqual('GET /abc/*')\n      expect(res[2][0]).toEqual('GET /abc/edf')\n    })\n  })\n\n  describe('Multi match', () => {\n    const node = new Node()\n\n    node.insert('get', '/api/*', 'a') // 2.1 for /api/entry\n    node.insert('get', '/api/entry', 'entry') // 2.2\n    node.insert('ALL', '/api/*', 'b') // 2.3 for /api/entry\n\n    it('get /api/entry', async () => {\n      const [res] = node.search('get', '/api/entry')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('a')\n      expect(res[1][0]).toEqual('entry')\n      expect(res[2][0]).toEqual('b')\n    })\n  })\n\n  describe('fallback', () => {\n    describe('Blog - failed', () => {\n      const node = new Node()\n      node.insert('post', '/entry', 'post entry') // 1.1\n      node.insert('post', '/entry/*', 'fallback') // 1.2\n      node.insert('get', '/entry/:id', 'get entry') // 2.3\n      it('post /entry', async () => {\n        const [res] = node.search('post', '/entry')\n        expect(res.length).toBe(2)\n        expect(res[0][0]).toEqual('post entry')\n        expect(res[1][0]).toEqual('fallback')\n      })\n    })\n  })\n  describe('page', () => {\n    const node = new Node()\n    node.insert('get', '/page', 'page') // 1.1\n    node.insert('ALL', '/*', 'fallback') // 1.2\n    it('get /page', async () => {\n      const [res] = node.search('get', '/page')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('page')\n      expect(res[1][0]).toEqual('fallback')\n    })\n  })\n})\n\ndescribe('star', () => {\n  const node = new Node()\n  node.insert('get', '/', '/')\n  node.insert('get', '/*', '/*')\n  node.insert('get', '*', '*')\n\n  node.insert('get', '/x', '/x')\n  node.insert('get', '/x/*', '/x/*')\n\n  it('top', async () => {\n    const [res] = node.search('get', '/')\n    expect(res.length).toBe(3)\n    expect(res[0][0]).toEqual('/')\n    expect(res[1][0]).toEqual('/*')\n    expect(res[2][0]).toEqual('*')\n  })\n\n  it('Under a certain path', async () => {\n    const [res] = node.search('get', '/x')\n    expect(res.length).toBe(4)\n    expect(res[0][0]).toEqual('/*')\n    expect(res[1][0]).toEqual('*')\n    expect(res[2][0]).toEqual('/x')\n    expect(res[3][0]).toEqual('/x/*')\n  })\n})\n\ndescribe('Routing order With named parameters', () => {\n  const node = new Node()\n  node.insert('get', '/book/a', 'no-slug')\n  node.insert('get', '/book/:slug', 'slug')\n  node.insert('get', '/book/b', 'no-slug-b')\n  it('/book/a', () => {\n    const [res] = node.search('get', '/book/a')\n    expect(res).not.toBeNull()\n    expect(res.length).toBe(2)\n    expect(res[0][0]).toEqual('no-slug')\n    expect(res[0][1]).toEqual({})\n    expect(res[1][0]).toEqual('slug')\n    expect(res[1][1]).toEqual({ slug: 'a' })\n  })\n  it('/book/foo', () => {\n    const [res] = node.search('get', '/book/foo')\n    expect(res).not.toBeNull()\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('slug')\n    expect(res[0][1]).toEqual({ slug: 'foo' })\n    expect(res[0][1]['slug']).toBe('foo')\n  })\n  it('/book/b', () => {\n    const [res] = node.search('get', '/book/b')\n    expect(res).not.toBeNull()\n    expect(res.length).toBe(2)\n    expect(res[0][0]).toEqual('slug')\n    expect(res[0][1]).toEqual({ slug: 'b' })\n    expect(res[1][0]).toEqual('no-slug-b')\n    expect(res[1][1]).toEqual({})\n  })\n})\n", "import type { Params } from '../../router'\nimport { METHOD_NAME_ALL } from '../../router'\nimport type { Pattern } from '../../utils/url'\nimport { splitPath, splitRoutingPath, getPattern } from '../../utils/url'\n\ntype HandlerSet<T> = {\n  handler: T\n  params: Record<string, string>\n  possibleKeys: string[]\n  score: number\n  name: string // For debug\n}\n\nexport class Node<T> {\n  methods: Record<string, HandlerSet<T>>[]\n\n  children: Record<string, Node<T>>\n  patterns: Pattern[]\n  order: number = 0\n  name: string\n  params: Record<string, string> = {}\n\n  constructor(method?: string, handler?: T, children?: Record<string, Node<T>>) {\n    this.children = children || {}\n    this.methods = []\n    this.name = ''\n    if (method && handler) {\n      const m: Record<string, HandlerSet<T>> = {}\n      m[method] = { handler, params: {}, possibleKeys: [], score: 0, name: this.name }\n      this.methods = [m]\n    }\n    this.patterns = []\n  }\n\n  insert(method: string, path: string, handler: T): Node<T> {\n    this.name = `${method} ${path}`\n    this.order = ++this.order\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let curNode: Node<T> = this\n    const parts = splitRoutingPath(path)\n\n    const possibleKeys: string[] = []\n    const parentPatterns: Pattern[] = []\n\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const p: string = parts[i]\n\n      if (Object.keys(curNode.children).includes(p)) {\n        parentPatterns.push(...curNode.patterns)\n        curNode = curNode.children[p]\n        const pattern = getPattern(p)\n        if (pattern) possibleKeys.push(pattern[1])\n        continue\n      }\n\n      curNode.children[p] = new Node()\n\n      const pattern = getPattern(p)\n      if (pattern) {\n        curNode.patterns.push(pattern)\n        parentPatterns.push(...curNode.patterns)\n        possibleKeys.push(pattern[1])\n      }\n      parentPatterns.push(...curNode.patterns)\n      curNode = curNode.children[p]\n    }\n\n    if (!curNode.methods.length) {\n      curNode.methods = []\n    }\n\n    const m: Record<string, HandlerSet<T>> = {}\n\n    const handlerSet: HandlerSet<T> = {\n      handler,\n      params: {},\n      possibleKeys,\n      name: this.name,\n      score: this.order,\n    }\n\n    m[method] = handlerSet\n    curNode.methods.push(m)\n\n    return curNode\n  }\n\n  // getHandlerSets\n  private gHSets(node: Node<T>, method: string, params: Record<string, string>): HandlerSet<T>[] {\n    const handlerSets: HandlerSet<T>[] = []\n    for (let i = 0, len = node.methods.length; i < len; i++) {\n      const m = node.methods[i]\n      const handlerSet = m[method] || m[METHOD_NAME_ALL]\n      if (handlerSet !== undefined) {\n        handlerSet.possibleKeys.map((key) => {\n          handlerSet.params[key] = params[key]\n        })\n        handlerSets.push(handlerSet)\n      }\n    }\n    return handlerSets\n  }\n\n  search(method: string, path: string): [[T, Params][]] {\n    const handlerSets: HandlerSet<T>[] = []\n\n    const params: Record<string, string> = {}\n    this.params = {}\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const curNode: Node<T> = this\n    let curNodes = [curNode]\n    const parts = splitPath(path)\n\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const part: string = parts[i]\n      const isLast = i === len - 1\n      const tempNodes: Node<T>[] = []\n\n      for (let j = 0, len2 = curNodes.length; j < len2; j++) {\n        const node = curNodes[j]\n        const nextNode = node.children[part]\n\n        if (nextNode) {\n          if (isLast === true) {\n            // '/hello/*' => match '/hello'\n            if (nextNode.children['*']) {\n              handlerSets.push(\n                ...this.gHSets(nextNode.children['*'], method, { ...params, ...node.params })\n              )\n            }\n            handlerSets.push(...this.gHSets(nextNode, method, { ...params, ...node.params }))\n          } else {\n            tempNodes.push(nextNode)\n          }\n        }\n\n        for (let k = 0, len3 = node.patterns.length; k < len3; k++) {\n          const pattern = node.patterns[k]\n\n          // Wildcard\n          // '/hello/*/foo' => match /hello/bar/foo\n          if (pattern === '*') {\n            const astNode = node.children['*']\n            if (astNode) {\n              handlerSets.push(...this.gHSets(astNode, method, { ...params, ...node.params }))\n              tempNodes.push(astNode)\n            }\n            continue\n          }\n\n          if (part === '') continue\n\n          const [key, name, matcher] = pattern\n\n          const child = node.children[key]\n\n          // `/js/:filename{[a-z]+.js}` => match /js/chunk/123.js\n          const restPathString = parts.slice(i).join('/')\n          if (matcher instanceof RegExp && matcher.test(restPathString)) {\n            params[name] = restPathString\n            handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }))\n            continue\n          }\n\n          if (matcher === true || (matcher instanceof RegExp && matcher.test(part))) {\n            if (typeof key === 'string') {\n              params[name] = part\n              if (isLast === true) {\n                handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }))\n                if (child.children['*']) {\n                  handlerSets.push(\n                    ...this.gHSets(child.children['*'], method, { ...params, ...node.params })\n                  )\n                }\n              } else {\n                child.params = { ...params }\n                tempNodes.push(child)\n              }\n            }\n          }\n        }\n      }\n\n      curNodes = tempNodes\n    }\n    const results = handlerSets.sort((a, b) => {\n      return a.score - b.score\n    })\n\n    return [results.map(({ handler, params }) => [handler, params] as [T, Params])]\n  }\n}\n"], "fixing_code": ["import type { Params } from '../../router.ts'\nimport { METHOD_NAME_ALL } from '../../router.ts'\nimport type { Pattern } from '../../utils/url.ts'\nimport { splitPath, splitRoutingPath, getPattern } from '../../utils/url.ts'\n\ntype HandlerSet<T> = {\n  handler: T\n  possibleKeys: string[]\n  score: number\n  name: string // For debug\n}\n\ntype HandlerParamsSet<T> = HandlerSet<T> & {\n  params: Record<string, string>\n}\n\nexport class Node<T> {\n  methods: Record<string, HandlerSet<T>>[]\n\n  children: Record<string, Node<T>>\n  patterns: Pattern[]\n  order: number = 0\n  name: string\n  params: Record<string, string> = {}\n\n  constructor(method?: string, handler?: T, children?: Record<string, Node<T>>) {\n    this.children = children || {}\n    this.methods = []\n    this.name = ''\n    if (method && handler) {\n      const m: Record<string, HandlerSet<T>> = {}\n      m[method] = { handler, possibleKeys: [], score: 0, name: this.name }\n      this.methods = [m]\n    }\n    this.patterns = []\n  }\n\n  insert(method: string, path: string, handler: T): Node<T> {\n    this.name = `${method} ${path}`\n    this.order = ++this.order\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let curNode: Node<T> = this\n    const parts = splitRoutingPath(path)\n\n    const possibleKeys: string[] = []\n    const parentPatterns: Pattern[] = []\n\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const p: string = parts[i]\n\n      if (Object.keys(curNode.children).includes(p)) {\n        parentPatterns.push(...curNode.patterns)\n        curNode = curNode.children[p]\n        const pattern = getPattern(p)\n        if (pattern) possibleKeys.push(pattern[1])\n        continue\n      }\n\n      curNode.children[p] = new Node()\n\n      const pattern = getPattern(p)\n      if (pattern) {\n        curNode.patterns.push(pattern)\n        parentPatterns.push(...curNode.patterns)\n        possibleKeys.push(pattern[1])\n      }\n      parentPatterns.push(...curNode.patterns)\n      curNode = curNode.children[p]\n    }\n\n    if (!curNode.methods.length) {\n      curNode.methods = []\n    }\n\n    const m: Record<string, HandlerSet<T>> = {}\n\n    const handlerSet: HandlerSet<T> = {\n      handler,\n      possibleKeys,\n      name: this.name,\n      score: this.order,\n    }\n\n    m[method] = handlerSet\n    curNode.methods.push(m)\n\n    return curNode\n  }\n\n  // getHandlerSets\n  private gHSets(\n    node: Node<T>,\n    method: string,\n    params: Record<string, string>\n  ): HandlerParamsSet<T>[] {\n    const handlerSets: HandlerParamsSet<T>[] = []\n    for (let i = 0, len = node.methods.length; i < len; i++) {\n      const m = node.methods[i]\n      const handlerSet = (m[method] || m[METHOD_NAME_ALL]) as HandlerParamsSet<T>\n      if (handlerSet !== undefined) {\n        handlerSet.params = {}\n        handlerSet.possibleKeys.map((key) => {\n          handlerSet.params[key] = params[key]\n        })\n        handlerSets.push(handlerSet)\n      }\n    }\n    return handlerSets\n  }\n\n  search(method: string, path: string): [[T, Params][]] {\n    const handlerSets: HandlerParamsSet<T>[] = []\n\n    const params: Record<string, string> = {}\n    this.params = {}\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const curNode: Node<T> = this\n    let curNodes = [curNode]\n    const parts = splitPath(path)\n\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const part: string = parts[i]\n      const isLast = i === len - 1\n      const tempNodes: Node<T>[] = []\n\n      for (let j = 0, len2 = curNodes.length; j < len2; j++) {\n        const node = curNodes[j]\n        const nextNode = node.children[part]\n\n        if (nextNode) {\n          if (isLast === true) {\n            // '/hello/*' => match '/hello'\n            if (nextNode.children['*']) {\n              handlerSets.push(...this.gHSets(nextNode.children['*'], method, node.params))\n            }\n            handlerSets.push(...this.gHSets(nextNode, method, node.params))\n          } else {\n            tempNodes.push(nextNode)\n          }\n        }\n\n        for (let k = 0, len3 = node.patterns.length; k < len3; k++) {\n          const pattern = node.patterns[k]\n\n          // Wildcard\n          // '/hello/*/foo' => match /hello/bar/foo\n          if (pattern === '*') {\n            const astNode = node.children['*']\n            if (astNode) {\n              handlerSets.push(...this.gHSets(astNode, method, node.params))\n              tempNodes.push(astNode)\n            }\n            continue\n          }\n\n          if (part === '') continue\n\n          const [key, name, matcher] = pattern\n\n          const child = node.children[key]\n\n          // `/js/:filename{[a-z]+.js}` => match /js/chunk/123.js\n          const restPathString = parts.slice(i).join('/')\n          if (matcher instanceof RegExp && matcher.test(restPathString)) {\n            params[name] = restPathString\n            handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }))\n            continue\n          }\n\n          if (matcher === true || (matcher instanceof RegExp && matcher.test(part))) {\n            if (typeof key === 'string') {\n              params[name] = part\n              if (isLast === true) {\n                handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }))\n                if (child.children['*']) {\n                  handlerSets.push(\n                    ...this.gHSets(child.children['*'], method, { ...params, ...node.params })\n                  )\n                }\n              } else {\n                child.params = { ...params }\n                tempNodes.push(child)\n              }\n            }\n          }\n        }\n      }\n\n      curNodes = tempNodes\n    }\n    const results = handlerSets.sort((a, b) => {\n      return a.score - b.score\n    })\n\n    return [results.map(({ handler, params }) => [handler, params] as [T, Params])]\n  }\n}\n", "import { Node } from './node'\n\ndescribe('Root Node', () => {\n  const node = new Node()\n  node.insert('get', '/', 'get root')\n  it('get /', () => {\n    const [res] = node.search('get', '/')\n    expect(res).not.toBeNull()\n    expect(res[0][0]).toEqual('get root')\n    expect(node.search('get', '/hello')[0].length).toBe(0)\n  })\n})\n\ndescribe('Root Node is not defined', () => {\n  const node = new Node()\n  node.insert('get', '/hello', 'get hello')\n  it('get /', () => {\n    expect(node.search('get', '/')[0]).toEqual([])\n  })\n})\n\ndescribe('Get with *', () => {\n  const node = new Node()\n  node.insert('get', '*', 'get all')\n  it('get /', () => {\n    expect(node.search('get', '/')[0].length).toBe(1)\n    expect(node.search('get', '/hello')[0].length).toBe(1)\n  })\n})\n\ndescribe('Basic Usage', () => {\n  const node = new Node()\n  node.insert('get', '/hello', 'get hello')\n  node.insert('post', '/hello', 'post hello')\n  node.insert('get', '/hello/foo', 'get hello foo')\n\n  it('get, post /hello', () => {\n    expect(node.search('get', '/')[0].length).toBe(0)\n    expect(node.search('post', '/')[0].length).toBe(0)\n\n    expect(node.search('get', '/hello')[0][0][0]).toEqual('get hello')\n    expect(node.search('post', '/hello')[0][0][0]).toEqual('post hello')\n    expect(node.search('put', '/hello')[0].length).toBe(0)\n  })\n  it('get /nothing', () => {\n    expect(node.search('get', '/nothing')[0].length).toBe(0)\n  })\n  it('/hello/foo, /hello/bar', () => {\n    expect(node.search('get', '/hello/foo')[0][0][0]).toEqual('get hello foo')\n    expect(node.search('post', '/hello/foo')[0].length).toBe(0)\n    expect(node.search('get', '/hello/bar')[0].length).toBe(0)\n  })\n  it('/hello/foo/bar', () => {\n    expect(node.search('get', '/hello/foo/bar')[0].length).toBe(0)\n  })\n})\n\ndescribe('Name path', () => {\n  const node = new Node()\n  node.insert('get', '/entry/:id', 'get entry')\n  node.insert('get', '/entry/:id/comment/:comment_id', 'get comment')\n  node.insert('get', '/map/:location/events', 'get events')\n\n  it('get /entry/123', () => {\n    const [res] = node.search('get', '/entry/123')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('get entry')\n    expect(res[0][1]).not.toBeNull()\n    expect(res[0][1]['id']).toBe('123')\n    expect(res[0][1]['id']).not.toBe('1234')\n  })\n\n  it('get /entry/456/comment', () => {\n    const [res] = node.search('get', '/entry/456/comment')\n    expect(res.length).toBe(0)\n  })\n\n  it('get /entry/789/comment/123', () => {\n    const [res] = node.search('get', '/entry/789/comment/123')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('get comment')\n    expect(res[0][1]['id']).toBe('789')\n    expect(res[0][1]['comment_id']).toBe('123')\n  })\n\n  it('get /map/:location/events', () => {\n    const [res] = node.search('get', '/map/yokohama/events')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('get events')\n    expect(res[0][1]['location']).toBe('yokohama')\n  })\n\n  it('Should not return a previous param value', () => {\n    const node = new Node()\n    node.insert('delete', '/resource/:id', 'resource')\n    const [resA] = node.search('delete', '/resource/a')\n    const [resB] = node.search('delete', '/resource/b')\n    expect(resA).not.toBeNull()\n    expect(resA.length).toBe(1)\n    expect(resA[0][0]).toEqual('resource')\n    expect(resA[0][1]).toEqual({ id: 'a' })\n    expect(resB).not.toBeNull()\n    expect(resB.length).toBe(1)\n    expect(resB[0][0]).toEqual('resource')\n    expect(resB[0][1]).toEqual({ id: 'b' })\n  })\n})\n\ndescribe('Name path - Multiple route', () => {\n  const node = new Node()\n\n  node.insert('get', '/:type/:id', 'common')\n  node.insert('get', '/posts/:id', 'specialized')\n\n  it('get /posts/123', () => {\n    const [res] = node.search('get', '/posts/123')\n    expect(res.length).toBe(2)\n    expect(res[0][0]).toEqual('common')\n    expect(res[0][1]['id']).toBe('123')\n    expect(res[1][0]).toEqual('specialized')\n    expect(res[1][1]['id']).toBe('123')\n  })\n})\n\ndescribe('Param prefix', () => {\n  const node = new Node()\n\n  node.insert('get', '/:foo', 'onepart')\n  node.insert('get', '/:bar/:baz', 'twopart')\n\n  it('get /hello', () => {\n    const [res] = node.search('get', '/hello')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('onepart')\n    expect(res[0][1]['foo']).toBe('hello')\n  })\n\n  it('get /hello/world', () => {\n    const [res] = node.search('get', '/hello/world')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('twopart')\n    expect(res[0][1]['bar']).toBe('hello')\n    expect(res[0][1]['baz']).toBe('world')\n  })\n})\n\ndescribe('Named params and a wildcard', () => {\n  const node = new Node()\n\n  node.insert('get', '/:id/*', 'onepart')\n\n  it('get /', () => {\n    const [res] = node.search('get', '/')\n    expect(res.length).toBe(0)\n  })\n\n  it('get /foo', () => {\n    const [res] = node.search('get', '/foo')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('onepart')\n    expect(res[0][1]['id']).toEqual('foo')\n  })\n\n  it('get /foo/bar', () => {\n    const [res] = node.search('get', '/foo/bar')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('onepart')\n    expect(res[0][1]['id']).toEqual('foo')\n  })\n})\n\ndescribe('Wildcard', () => {\n  const node = new Node()\n  node.insert('get', '/wildcard-abc/*/wildcard-efg', 'wildcard')\n  it('/wildcard-abc/xxxxxx/wildcard-efg', () => {\n    const [res] = node.search('get', '/wildcard-abc/xxxxxx/wildcard-efg')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('wildcard')\n  })\n  node.insert('get', '/wildcard-abc/*/wildcard-efg/hijk', 'wildcard')\n  it('/wildcard-abc/xxxxxx/wildcard-efg/hijk', () => {\n    const [res] = node.search('get', '/wildcard-abc/xxxxxx/wildcard-efg/hijk')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('wildcard')\n  })\n})\n\ndescribe('Regexp', () => {\n  const node = new Node()\n  node.insert('get', '/regex-abc/:id{[0-9]+}/comment/:comment_id{[a-z]+}', 'regexp')\n  it('/regexp-abc/123/comment/abc', () => {\n    const [res] = node.search('get', '/regex-abc/123/comment/abc')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('regexp')\n    expect(res[0][1]['id']).toBe('123')\n    expect(res[0][1]['comment_id']).toBe('abc')\n  })\n  it('/regexp-abc/abc', () => {\n    const [res] = node.search('get', '/regex-abc/abc')\n    expect(res.length).toBe(0)\n  })\n  it('/regexp-abc/123/comment/123', () => {\n    const [res] = node.search('get', '/regex-abc/123/comment/123')\n    expect(res.length).toBe(0)\n  })\n})\n\ndescribe('All', () => {\n  const node = new Node()\n  node.insert('ALL', '/all-methods', 'all methods') // ALL\n  it('/all-methods', () => {\n    let [res] = node.search('get', '/all-methods')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('all methods')\n    ;[res] = node.search('put', '/all-methods')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('all methods')\n  })\n})\n\ndescribe('Special Wildcard', () => {\n  const node = new Node()\n  node.insert('ALL', '*', 'match all')\n\n  it('/foo', () => {\n    const [res] = node.search('get', '/foo')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match all')\n  })\n  it('/hello', () => {\n    const [res] = node.search('get', '/hello')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match all')\n  })\n  it('/hello/foo', () => {\n    const [res] = node.search('get', '/hello/foo')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match all')\n  })\n})\n\ndescribe('Special Wildcard deeply', () => {\n  const node = new Node()\n  node.insert('ALL', '/hello/*', 'match hello')\n  it('/hello', () => {\n    const [res] = node.search('get', '/hello')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match hello')\n  })\n  it('/hello/foo', () => {\n    const [res] = node.search('get', '/hello/foo')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('match hello')\n  })\n})\n\ndescribe('Default with wildcard', () => {\n  const node = new Node()\n  node.insert('ALL', '/api/*', 'fallback')\n  node.insert('ALL', '/api/abc', 'match api')\n  it('/api/abc', () => {\n    const [res] = node.search('get', '/api/abc')\n    expect(res.length).toBe(2)\n    expect(res[0][0]).toEqual('fallback')\n    expect(res[1][0]).toEqual('match api')\n  })\n  it('/api/def', () => {\n    const [res] = node.search('get', '/api/def')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('fallback')\n  })\n})\n\ndescribe('Multi match', () => {\n  describe('Basic', () => {\n    const node = new Node()\n    node.insert('get', '*', 'GET *')\n    node.insert('get', '/abc/*', 'GET /abc/*')\n    node.insert('get', '/abc/*/edf', 'GET /abc/*/edf')\n    node.insert('get', '/abc/edf', 'GET /abc/edf')\n    node.insert('get', '/abc/*/ghi/jkl', 'GET /abc/*/ghi/jkl')\n    it('get /abc/edf', () => {\n      const [res] = node.search('get', '/abc/edf')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('GET *')\n      expect(res[1][0]).toEqual('GET /abc/*')\n      expect(res[2][0]).toEqual('GET /abc/edf')\n    })\n    it('get /abc/xxx/edf', () => {\n      const [res] = node.search('get', '/abc/xxx/edf')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('GET *')\n      expect(res[1][0]).toEqual('GET /abc/*')\n      expect(res[2][0]).toEqual('GET /abc/*/edf')\n    })\n    it('get /', () => {\n      const [res] = node.search('get', '/')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('GET *')\n    })\n    it('post /', () => {\n      const [res] = node.search('post', '/')\n      expect(res.length).toBe(0)\n    })\n    it('get /abc/edf/ghi', () => {\n      const [res] = node.search('get', '/abc/edf/ghi')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('GET *')\n      expect(res[1][0]).toEqual('GET /abc/*')\n    })\n  })\n  describe('Blog', () => {\n    const node = new Node()\n    node.insert('get', '*', 'middleware a') // 0.1\n    node.insert('ALL', '*', 'middleware b') // 0.2 <===\n    node.insert('get', '/entry', 'get entries') // 1.3\n    node.insert('post', '/entry/*', 'middleware c') // 1.4 <===\n    node.insert('post', '/entry', 'post entry') // 1.5 <===\n    node.insert('get', '/entry/:id', 'get entry') // 2.6\n    node.insert('get', '/entry/:id/comment/:comment_id', 'get comment') // 4.7\n    it('get /entry/123', async () => {\n      const [res] = node.search('get', '/entry/123')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('middleware a')\n      expect(res[0][1]['id']).toBe(undefined)\n      expect(res[1][0]).toEqual('middleware b')\n      expect(res[1][1]['id']).toBe(undefined)\n      expect(res[2][0]).toEqual('get entry')\n      expect(res[2][1]['id']).toBe('123')\n    })\n    it('get /entry/123/comment/456', async () => {\n      const [res] = node.search('get', '/entry/123/comment/456')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('middleware a')\n      expect(res[0][1]['id']).toBe(undefined)\n      expect(res[0][1]['comment_id']).toBe(undefined)\n      expect(res[1][0]).toEqual('middleware b')\n      expect(res[1][1]['id']).toBe(undefined)\n      expect(res[1][1]['comment_id']).toBe(undefined)\n      expect(res[2][0]).toEqual('get comment')\n      expect(res[2][1]['id']).toBe('123')\n      expect(res[2][1]['comment_id']).toBe('456')\n    })\n    it('post /entry', async () => {\n      const [res] = node.search('post', '/entry')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('middleware b')\n      expect(res[1][0]).toEqual('middleware c')\n      expect(res[2][0]).toEqual('post entry')\n    })\n    it('delete /entry', async () => {\n      const [res] = node.search('delete', '/entry')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('middleware b')\n    })\n  })\n  describe('ALL', () => {\n    const node = new Node()\n    node.insert('ALL', '*', 'ALL *')\n    node.insert('ALL', '/abc/*', 'ALL /abc/*')\n    node.insert('ALL', '/abc/*/def', 'ALL /abc/*/def')\n    it('get /', () => {\n      const [res] = node.search('get', '/')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('ALL *')\n    })\n    it('post /abc', () => {\n      const [res] = node.search('post', '/abc')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('ALL *')\n      expect(res[1][0]).toEqual('ALL /abc/*')\n    })\n    it('delete /abc/xxx/def', () => {\n      const [res] = node.search('post', '/abc/xxx/def')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('ALL *')\n      expect(res[1][0]).toEqual('ALL /abc/*')\n      expect(res[2][0]).toEqual('ALL /abc/*/def')\n    })\n  })\n  describe('Regexp', () => {\n    const node = new Node()\n    node.insert('get', '/regex-abc/:id{[0-9]+}/*', 'middleware a')\n    node.insert('get', '/regex-abc/:id{[0-9]+}/def', 'regexp')\n    it('/regexp-abc/123/def', () => {\n      const [res] = node.search('get', '/regex-abc/123/def')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('middleware a')\n      expect(res[0][1]['id']).toBe('123')\n      expect(res[1][0]).toEqual('regexp')\n      expect(res[1][1]['id']).toBe('123')\n    })\n    it('/regexp-abc/123', () => {\n      const [res] = node.search('get', '/regex-abc/123/ghi')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('middleware a')\n    })\n  })\n  describe('Trailing slash', () => {\n    const node = new Node()\n    node.insert('get', '/book', 'GET /book')\n    node.insert('get', '/book/:id', 'GET /book/:id')\n    it('get /book', () => {\n      const [res] = node.search('get', '/book')\n      expect(res.length).toBe(1)\n    })\n    it('get /book/', () => {\n      const [res] = node.search('get', '/book/')\n      expect(res.length).toBe(0)\n    })\n  })\n  describe('Same path', () => {\n    const node = new Node()\n    node.insert('get', '/hey', 'Middleware A')\n    node.insert('get', '/hey', 'Middleware B')\n    it('get /hey', () => {\n      const [res] = node.search('get', '/hey')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('Middleware A')\n      expect(res[1][0]).toEqual('Middleware B')\n    })\n  })\n  describe('Including slashes', () => {\n    const node = new Node()\n    node.insert('get', '/js/:filename{[a-z0-9/]+.js}', 'any file')\n    node.insert('get', '/js/main.js', 'main.js')\n    it('get /js/main.js', () => {\n      const [res] = node.search('get', '/js/main.js')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('any file')\n      expect(res[0][1]).toEqual({ filename: 'main.js' })\n      expect(res[1][0]).toEqual('main.js')\n      expect(res[1][1]).toEqual({})\n    })\n    it('get /js/chunk/123.js', () => {\n      const [res] = node.search('get', '/js/chunk/123.js')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('any file')\n      expect(res[0][1]).toEqual({ filename: 'chunk/123.js' })\n    })\n    it('get /js/chunk/nest/123.js', () => {\n      const [res] = node.search('get', '/js/chunk/nest/123.js')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('any file')\n      expect(res[0][1]).toEqual({ filename: 'chunk/nest/123.js' })\n    })\n  })\n  describe('REST API', () => {\n    const node = new Node()\n    node.insert('get', '/users/:username{[a-z]+}', 'profile')\n    node.insert('get', '/users/:username{[a-z]+}/posts', 'posts')\n    it('get /users/hono', () => {\n      const [res] = node.search('get', '/users/hono')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('profile')\n    })\n    it('get /users/hono/posts', () => {\n      const [res] = node.search('get', '/users/hono/posts')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toEqual('posts')\n    })\n  })\n})\n\ndescribe('Duplicate param name', () => {\n  it('self', () => {\n    const node = new Node()\n    node.insert('get', '/:id/:id', 'foo')\n    const [res] = node.search('get', '/123/456')\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toBe('foo')\n    expect(res[0][1]['id']).toBe('123')\n  })\n\n  describe('parent', () => {\n    const node = new Node()\n    node.insert('get', '/:id/:action', 'foo')\n    node.insert('get', '/posts/:id', 'bar')\n    node.insert('get', '/posts/:id/comments/:comment_id', 'comment')\n\n    it('get /123/action', () => {\n      const [res] = node.search('get', '/123/action')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toBe('foo')\n      expect(res[0][1]).toEqual({ id: '123', action: 'action' })\n    })\n\n    it('get /posts/456', () => {\n      const [res] = node.search('get', '/posts/456')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toBe('foo')\n      expect(res[0][1]).toEqual({ id: 'posts', action: '456' })\n      expect(res[1][0]).toBe('bar')\n      expect(res[1][1]).toEqual({ id: '456' })\n\n      it('get /posts/456', () => {\n        const [res] = node.search('get', '/posts/abc/comments/edf')\n        expect(res.length).toBe(1)\n        expect(res[0][0]).toBe('comment')\n        expect(res[0][1]).toEqual({ id: 'abc', comment_id: 'edf' })\n      })\n    })\n  })\n\n  describe('child', () => {\n    const node = new Node()\n    node.insert('get', '/posts/:id', 'foo')\n    node.insert('get', '/:id/:action', 'bar')\n    it('get /posts/action', () => {\n      const [res] = node.search('get', '/posts/action')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toBe('foo')\n      expect(res[0][1]).toEqual({ id: 'action' })\n      expect(res[1][0]).toBe('bar')\n      expect(res[1][1]).toEqual({ id: 'posts', action: 'action' })\n    })\n  })\n\n  describe('regular expression', () => {\n    const node = new Node()\n    node.insert('get', '/:id/:action{create|update}', 'foo')\n    node.insert('get', '/:id/:action{delete}', 'bar')\n    it('get /123/create', () => {\n      const [res] = node.search('get', '/123/create')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toBe('foo')\n      expect(res[0][1]).toEqual({ id: '123', action: 'create' })\n    })\n    it('get /123/delete', () => {\n      const [res] = node.search('get', '/123/delete')\n      expect(res.length).toBe(1)\n      expect(res[0][0]).toBe('bar')\n      expect(res[0][1]).toEqual({ id: '123', action: 'delete' })\n    })\n  })\n})\n\ndescribe('Sort Order', () => {\n  describe('Basic', () => {\n    const node = new Node()\n    node.insert('get', '*', 'a')\n    node.insert('get', '/page', '/page')\n    node.insert('get', '/:slug', '/:slug')\n\n    it('get /page', () => {\n      const [res] = node.search('get', '/page')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('a')\n      expect(res[1][0]).toEqual('/page')\n      expect(res[2][0]).toEqual('/:slug')\n    })\n  })\n\n  describe('With Named path', () => {\n    const node = new Node()\n    node.insert('get', '*', 'a')\n    node.insert('get', '/posts/:id', '/posts/:id')\n    node.insert('get', '/:type/:id', '/:type/:id')\n\n    it('get /posts/123', () => {\n      const [res] = node.search('get', '/posts/123')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('a')\n      expect(res[1][0]).toEqual('/posts/:id')\n      expect(res[2][0]).toEqual('/:type/:id')\n    })\n  })\n\n  describe('With Wildcards', () => {\n    const node = new Node()\n    node.insert('get', '/api/*', '1st')\n    node.insert('get', '/api/*', '2nd')\n    node.insert('get', '/api/posts/:id', '3rd')\n    node.insert('get', '/api/*', '4th')\n\n    it('get /api/posts/123', () => {\n      const [res] = node.search('get', '/api/posts/123')\n      expect(res.length).toBe(4)\n      expect(res[0][0]).toEqual('1st')\n      expect(res[1][0]).toEqual('2nd')\n      expect(res[2][0]).toEqual('3rd')\n      expect(res[3][0]).toEqual('4th')\n    })\n  })\n\n  describe('With special Wildcard', () => {\n    const node = new Node()\n    node.insert('get', '/posts', '/posts') // 1.1\n    node.insert('get', '/posts/*', '/posts/*') // 1.2\n    node.insert('get', '/posts/:id', '/posts/:id') // 2.3\n\n    it('get /posts', () => {\n      const [res] = node.search('get', '/posts')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('/posts')\n      expect(res[1][0]).toEqual('/posts/*')\n    })\n  })\n\n  describe('Complex', () => {\n    const node = new Node()\n    node.insert('get', '/api', 'a') // not match\n    node.insert('get', '/api/*', 'b') // match\n    node.insert('get', '/api/:type', 'c') // not match\n    node.insert('get', '/api/:type/:id', 'd') // match\n    node.insert('get', '/api/posts/:id', 'e') // match\n    node.insert('get', '/api/posts/123', 'f') // match\n    node.insert('get', '/*/*/:id', 'g') // match\n    node.insert('get', '/api/posts/*/comment', 'h') // not match\n    node.insert('get', '*', 'i') // match\n    node.insert('get', '*', 'j') // match\n\n    it('get /api/posts/123', () => {\n      const [res] = node.search('get', '/api/posts/123')\n      expect(res.length).toBe(7)\n      expect(res[0][0]).toEqual('b')\n      expect(res[1][0]).toEqual('d')\n      expect(res[2][0]).toEqual('e')\n      expect(res[3][0]).toEqual('f')\n      expect(res[4][0]).toEqual('g')\n      expect(res[5][0]).toEqual('i')\n      expect(res[6][0]).toEqual('j')\n    })\n  })\n\n  describe('Multi match', () => {\n    const node = new Node()\n    node.insert('get', '*', 'GET *') // 0.1\n    node.insert('get', '/abc/*', 'GET /abc/*') // 1.2\n    node.insert('get', '/abc/edf', 'GET /abc/edf') // 2.3\n    node.insert('get', '/abc/*/ghi/jkl', 'GET /abc/*/ghi/jkl') // 4.4\n    it('get /abc/edf', () => {\n      const [res] = node.search('get', '/abc/edf')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('GET *')\n      expect(res[1][0]).toEqual('GET /abc/*')\n      expect(res[2][0]).toEqual('GET /abc/edf')\n    })\n  })\n\n  describe('Multi match', () => {\n    const node = new Node()\n\n    node.insert('get', '/api/*', 'a') // 2.1 for /api/entry\n    node.insert('get', '/api/entry', 'entry') // 2.2\n    node.insert('ALL', '/api/*', 'b') // 2.3 for /api/entry\n\n    it('get /api/entry', async () => {\n      const [res] = node.search('get', '/api/entry')\n      expect(res.length).toBe(3)\n      expect(res[0][0]).toEqual('a')\n      expect(res[1][0]).toEqual('entry')\n      expect(res[2][0]).toEqual('b')\n    })\n  })\n\n  describe('fallback', () => {\n    describe('Blog - failed', () => {\n      const node = new Node()\n      node.insert('post', '/entry', 'post entry') // 1.1\n      node.insert('post', '/entry/*', 'fallback') // 1.2\n      node.insert('get', '/entry/:id', 'get entry') // 2.3\n      it('post /entry', async () => {\n        const [res] = node.search('post', '/entry')\n        expect(res.length).toBe(2)\n        expect(res[0][0]).toEqual('post entry')\n        expect(res[1][0]).toEqual('fallback')\n      })\n    })\n  })\n  describe('page', () => {\n    const node = new Node()\n    node.insert('get', '/page', 'page') // 1.1\n    node.insert('ALL', '/*', 'fallback') // 1.2\n    it('get /page', async () => {\n      const [res] = node.search('get', '/page')\n      expect(res.length).toBe(2)\n      expect(res[0][0]).toEqual('page')\n      expect(res[1][0]).toEqual('fallback')\n    })\n  })\n})\n\ndescribe('star', () => {\n  const node = new Node()\n  node.insert('get', '/', '/')\n  node.insert('get', '/*', '/*')\n  node.insert('get', '*', '*')\n\n  node.insert('get', '/x', '/x')\n  node.insert('get', '/x/*', '/x/*')\n\n  it('top', async () => {\n    const [res] = node.search('get', '/')\n    expect(res.length).toBe(3)\n    expect(res[0][0]).toEqual('/')\n    expect(res[1][0]).toEqual('/*')\n    expect(res[2][0]).toEqual('*')\n  })\n\n  it('Under a certain path', async () => {\n    const [res] = node.search('get', '/x')\n    expect(res.length).toBe(4)\n    expect(res[0][0]).toEqual('/*')\n    expect(res[1][0]).toEqual('*')\n    expect(res[2][0]).toEqual('/x')\n    expect(res[3][0]).toEqual('/x/*')\n  })\n})\n\ndescribe('Routing order With named parameters', () => {\n  const node = new Node()\n  node.insert('get', '/book/a', 'no-slug')\n  node.insert('get', '/book/:slug', 'slug')\n  node.insert('get', '/book/b', 'no-slug-b')\n  it('/book/a', () => {\n    const [res] = node.search('get', '/book/a')\n    expect(res).not.toBeNull()\n    expect(res.length).toBe(2)\n    expect(res[0][0]).toEqual('no-slug')\n    expect(res[0][1]).toEqual({})\n    expect(res[1][0]).toEqual('slug')\n    expect(res[1][1]).toEqual({ slug: 'a' })\n  })\n  it('/book/foo', () => {\n    const [res] = node.search('get', '/book/foo')\n    expect(res).not.toBeNull()\n    expect(res.length).toBe(1)\n    expect(res[0][0]).toEqual('slug')\n    expect(res[0][1]).toEqual({ slug: 'foo' })\n    expect(res[0][1]['slug']).toBe('foo')\n  })\n  it('/book/b', () => {\n    const [res] = node.search('get', '/book/b')\n    expect(res).not.toBeNull()\n    expect(res.length).toBe(2)\n    expect(res[0][0]).toEqual('slug')\n    expect(res[0][1]).toEqual({ slug: 'b' })\n    expect(res[1][0]).toEqual('no-slug-b')\n    expect(res[1][1]).toEqual({})\n  })\n})\n", "import type { Params } from '../../router'\nimport { METHOD_NAME_ALL } from '../../router'\nimport type { Pattern } from '../../utils/url'\nimport { splitPath, splitRoutingPath, getPattern } from '../../utils/url'\n\ntype HandlerSet<T> = {\n  handler: T\n  possibleKeys: string[]\n  score: number\n  name: string // For debug\n}\n\ntype HandlerParamsSet<T> = HandlerSet<T> & {\n  params: Record<string, string>\n}\n\nexport class Node<T> {\n  methods: Record<string, HandlerSet<T>>[]\n\n  children: Record<string, Node<T>>\n  patterns: Pattern[]\n  order: number = 0\n  name: string\n  params: Record<string, string> = {}\n\n  constructor(method?: string, handler?: T, children?: Record<string, Node<T>>) {\n    this.children = children || {}\n    this.methods = []\n    this.name = ''\n    if (method && handler) {\n      const m: Record<string, HandlerSet<T>> = {}\n      m[method] = { handler, possibleKeys: [], score: 0, name: this.name }\n      this.methods = [m]\n    }\n    this.patterns = []\n  }\n\n  insert(method: string, path: string, handler: T): Node<T> {\n    this.name = `${method} ${path}`\n    this.order = ++this.order\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let curNode: Node<T> = this\n    const parts = splitRoutingPath(path)\n\n    const possibleKeys: string[] = []\n    const parentPatterns: Pattern[] = []\n\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const p: string = parts[i]\n\n      if (Object.keys(curNode.children).includes(p)) {\n        parentPatterns.push(...curNode.patterns)\n        curNode = curNode.children[p]\n        const pattern = getPattern(p)\n        if (pattern) possibleKeys.push(pattern[1])\n        continue\n      }\n\n      curNode.children[p] = new Node()\n\n      const pattern = getPattern(p)\n      if (pattern) {\n        curNode.patterns.push(pattern)\n        parentPatterns.push(...curNode.patterns)\n        possibleKeys.push(pattern[1])\n      }\n      parentPatterns.push(...curNode.patterns)\n      curNode = curNode.children[p]\n    }\n\n    if (!curNode.methods.length) {\n      curNode.methods = []\n    }\n\n    const m: Record<string, HandlerSet<T>> = {}\n\n    const handlerSet: HandlerSet<T> = {\n      handler,\n      possibleKeys,\n      name: this.name,\n      score: this.order,\n    }\n\n    m[method] = handlerSet\n    curNode.methods.push(m)\n\n    return curNode\n  }\n\n  // getHandlerSets\n  private gHSets(\n    node: Node<T>,\n    method: string,\n    params: Record<string, string>\n  ): HandlerParamsSet<T>[] {\n    const handlerSets: HandlerParamsSet<T>[] = []\n    for (let i = 0, len = node.methods.length; i < len; i++) {\n      const m = node.methods[i]\n      const handlerSet = (m[method] || m[METHOD_NAME_ALL]) as HandlerParamsSet<T>\n      if (handlerSet !== undefined) {\n        handlerSet.params = {}\n        handlerSet.possibleKeys.map((key) => {\n          handlerSet.params[key] = params[key]\n        })\n        handlerSets.push(handlerSet)\n      }\n    }\n    return handlerSets\n  }\n\n  search(method: string, path: string): [[T, Params][]] {\n    const handlerSets: HandlerParamsSet<T>[] = []\n\n    const params: Record<string, string> = {}\n    this.params = {}\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const curNode: Node<T> = this\n    let curNodes = [curNode]\n    const parts = splitPath(path)\n\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const part: string = parts[i]\n      const isLast = i === len - 1\n      const tempNodes: Node<T>[] = []\n\n      for (let j = 0, len2 = curNodes.length; j < len2; j++) {\n        const node = curNodes[j]\n        const nextNode = node.children[part]\n\n        if (nextNode) {\n          if (isLast === true) {\n            // '/hello/*' => match '/hello'\n            if (nextNode.children['*']) {\n              handlerSets.push(...this.gHSets(nextNode.children['*'], method, node.params))\n            }\n            handlerSets.push(...this.gHSets(nextNode, method, node.params))\n          } else {\n            tempNodes.push(nextNode)\n          }\n        }\n\n        for (let k = 0, len3 = node.patterns.length; k < len3; k++) {\n          const pattern = node.patterns[k]\n\n          // Wildcard\n          // '/hello/*/foo' => match /hello/bar/foo\n          if (pattern === '*') {\n            const astNode = node.children['*']\n            if (astNode) {\n              handlerSets.push(...this.gHSets(astNode, method, node.params))\n              tempNodes.push(astNode)\n            }\n            continue\n          }\n\n          if (part === '') continue\n\n          const [key, name, matcher] = pattern\n\n          const child = node.children[key]\n\n          // `/js/:filename{[a-z]+.js}` => match /js/chunk/123.js\n          const restPathString = parts.slice(i).join('/')\n          if (matcher instanceof RegExp && matcher.test(restPathString)) {\n            params[name] = restPathString\n            handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }))\n            continue\n          }\n\n          if (matcher === true || (matcher instanceof RegExp && matcher.test(part))) {\n            if (typeof key === 'string') {\n              params[name] = part\n              if (isLast === true) {\n                handlerSets.push(...this.gHSets(child, method, { ...params, ...node.params }))\n                if (child.children['*']) {\n                  handlerSets.push(\n                    ...this.gHSets(child.children['*'], method, { ...params, ...node.params })\n                  )\n                }\n              } else {\n                child.params = { ...params }\n                tempNodes.push(child)\n              }\n            }\n          }\n        }\n      }\n\n      curNodes = tempNodes\n    }\n    const results = handlerSets.sort((a, b) => {\n      return a.score - b.score\n    })\n\n    return [results.map(({ handler, params }) => [handler, params] as [T, Params])]\n  }\n}\n"], "filenames": ["deno_dist/router/trie-router/node.ts", "src/router/trie-router/node.test.ts", "src/router/trie-router/node.ts"], "buggy_code_start_loc": [8, 90, 8], "buggy_code_end_loc": [148, 90, 148], "fixing_code_start_loc": [7, 91, 7], "fixing_code_end_loc": [153, 106, 153], "type": "CWE-94", "message": "Hono is a web framework written in TypeScript. Prior to version 3.11.7, clients may override named path parameter values from previous requests if the application is using TrieRouter. So, there is a risk that a privileged user may use unintended parameters when deleting REST API resources. TrieRouter is used either explicitly or when the application matches a pattern that is not supported by the default RegExpRouter. Version 3.11.7 includes the change to fix this issue. As a workaround, avoid using TrieRouter directly.", "other": {"cve": {"id": "CVE-2023-50710", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-14T18:15:45.270", "lastModified": "2023-12-19T19:44:37.647", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Hono is a web framework written in TypeScript. Prior to version 3.11.7, clients may override named path parameter values from previous requests if the application is using TrieRouter. So, there is a risk that a privileged user may use unintended parameters when deleting REST API resources. TrieRouter is used either explicitly or when the application matches a pattern that is not supported by the default RegExpRouter. Version 3.11.7 includes the change to fix this issue. As a workaround, avoid using TrieRouter directly."}, {"lang": "es", "value": "Hono es un framework web escrito en TypeScript. Antes de la versi\u00f3n 3.11.7, los clientes pueden anular los valores de los par\u00e1metros de ruta con nombre de solicitudes anteriores si la aplicaci\u00f3n utiliza TrieRouter. Por lo tanto, existe el riesgo de que un usuario privilegiado utilice par\u00e1metros no deseados al eliminar recursos de la API REST. TrieRouter se usa expl\u00edcitamente o cuando la aplicaci\u00f3n coincide con un patr\u00f3n que no es compatible con el RegExpRouter predeterminado. La versi\u00f3n 3.11.7 incluye el cambio para solucionar este problema. Como workaround, evite utilizar TrieRouter directamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hono:hono:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.11.7", "matchCriteriaId": "74A7A157-DE4D-4445-9670-2EBF795FAB11"}]}]}], "references": [{"url": "https://github.com/honojs/hono/commit/8e2b6b08518998783f66d31db4f21b1b1eecc4c8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/honojs/hono/releases/tag/v3.11.7", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/honojs/hono/security/advisories/GHSA-f6gv-hh8j-q8vq", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/honojs/hono/commit/8e2b6b08518998783f66d31db4f21b1b1eecc4c8"}}