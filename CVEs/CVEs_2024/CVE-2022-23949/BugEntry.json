{"buggy_code": ["#!/usr/bin/python3\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\nimport signal\nimport traceback\nimport sys\nimport functools\nimport asyncio\n\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm.exc import NoResultFound\nimport tornado.ioloop\nimport tornado.web\n\nfrom keylime import config\nfrom keylime import json\nfrom keylime import registrar_client\nfrom keylime.agentstates import AgentAttestStates\nfrom keylime.common import states\nfrom keylime.db.verifier_db import VerfierMain\nfrom keylime.db.verifier_db import VerifierAllowlist\nfrom keylime.db.keylime_db import DBEngineManager, SessionManager\nfrom keylime import keylime_logging\nfrom keylime import cloud_verifier_common\nfrom keylime import revocation_notifier\nfrom keylime import web_util\nfrom keylime import tornado_requests\nfrom keylime import api_version as keylime_api_version\nfrom keylime.failure import MAX_SEVERITY_LABEL, Failure, Component\n\nlogger = keylime_logging.init_logging('cloudverifier')\n\n\ntry:\n    engine = DBEngineManager().make_engine('cloud_verifier')\nexcept SQLAlchemyError as err:\n    logger.error('Error creating SQL engine or session: %s', err)\n    sys.exit(1)\n\n\ndef get_session():\n    return SessionManager().make_session(engine)\n\n\ndef get_AgentAttestStates():\n    return AgentAttestStates.get_instance()\n\n\n# The \"exclude_db\" dict values are removed from the response before adding the dict to the DB\n# This is because we want these values to remain ephemeral and not stored in the database.\nexclude_db = {\n    'registrar_data': '',\n    'nonce': '',\n    'b64_encrypted_V': '',\n    'provide_V': True,\n    'num_retries': 0,\n    'pending_event': None,\n    'first_verified': False,\n    # the following 3 items are updated to VerifierDB only when the AgentState is stored\n    'boottime': '',\n    'ima_pcrs': [],\n    'pcr10': '',\n    'next_ima_ml_entry': 0,\n    'learned_ima_keyrings': {},\n    'ssl_context': None,\n}\n\n\ndef _from_db_obj(agent_db_obj):\n    fields = [ 'agent_id', \\\n                'v', \\\n                'ip', \\\n                'port', \\\n                'operational_state', \\\n                'public_key', \\\n                'tpm_policy', \\\n                'vtpm_policy', \\\n                'meta_data', \\\n                'mb_refstate', \\\n                'allowlist', \\\n                'ima_sign_verification_keys', \\\n                'revocation_key', \\\n                'accept_tpm_hash_algs', \\\n                'accept_tpm_encryption_algs', \\\n                'accept_tpm_signing_algs', \\\n                'hash_alg', \\\n                'enc_alg', \\\n                'sign_alg', \\\n                'boottime', \\\n                'ima_pcrs', \\\n                'pcr10', \\\n                'next_ima_ml_entry', \\\n                'learned_ima_keyrings',\n                'supported_version',\n                'mtls_cert',\n                'ak_tpm',\n               ]\n    agent_dict = {}\n    for field in fields:\n        agent_dict[field] = getattr(agent_db_obj, field, None)\n    return agent_dict\n\n\ndef verifier_db_delete_agent(session, agent_id):\n    get_AgentAttestStates().delete_by_agent_id(agent_id)\n    session.query(VerfierMain).filter_by(\n                  agent_id=agent_id).delete()\n    session.commit()\n\n\ndef store_attestation_state(agentAttestState):\n    # Only store if IMA log was evaluated\n    if agentAttestState.get_ima_pcrs():\n        session = get_session()\n        try:\n            update_agent = session.query(VerfierMain).get(agentAttestState.get_agent_id())\n            update_agent.boottime = agentAttestState.get_boottime()\n            update_agent.next_ima_ml_entry = agentAttestState.get_next_ima_ml_entry()\n            ima_pcrs_dict = agentAttestState.get_ima_pcrs()\n            update_agent.ima_pcrs = list(ima_pcrs_dict.keys())\n            for pcr_num, value in ima_pcrs_dict.items():\n                setattr(update_agent, 'pcr%d' % pcr_num, value)\n            update_agent.learned_ima_keyrings = agentAttestState.get_ima_keyrings().to_json()\n            try:\n                session.add(update_agent)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error on storing attestation state: %s', e)\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error on storing attestation state: %s', e)\n\n\nclass BaseHandler(tornado.web.RequestHandler):\n    def prepare(self):  # pylint: disable=W0235\n        super().prepare()\n\n    def write_error(self, status_code, **kwargs):\n\n        self.set_header('Content-Type', 'text/json')\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            lines = []\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                lines.append(line)\n            self.finish(json.dumps({\n                'code': status_code,\n                'status': self._reason,\n                'traceback': lines,\n                'results': {},\n            }))\n        else:\n            self.finish(json.dumps({\n                'code': status_code,\n                'status': self._reason,\n                'results': {},\n            }))\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def get(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\nclass VersionHandler(BaseHandler):\n\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def get(self):\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(self, 405, \"Not Implemented\")\n            return\n\n        if \"version\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning('GET returning 400 response. URI not supported: %s', self.request.path)\n            return\n\n        version_info = {\n            \"current_version\": keylime_api_version.current_version(),\n            \"supported_versions\": keylime_api_version.all_versions(),\n        }\n\n        web_util.echo_json_response(self, 200, \"Success\", version_info)\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AgentsHandler(BaseHandler):\n    mtls_options = None  # Stores the cert, key and password used by the verifier for mTLS connections\n\n    def initialize(self, mtls_options):\n        self.mtls_options = mtls_options\n\n    def head(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def get(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for GETing, i.e. /agents. All other GET uri's\n        will return errors. Agents requests require a single agent_id parameter which identifies the\n        agent to be returned. If the agent_id is not found, a 404 response is returned.  If the agent_id\n        was not found, it either completed successfully, or failed.  If found, the agent_id is still polling\n        to contact the Cloud Agent.\n        \"\"\"\n        session = get_session()\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('GET returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if (agent_id is not None) and (agent_id != ''):\n            try:\n                agent = session.query(VerfierMain).filter_by(\n                    agent_id=agent_id).one_or_none()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n            if agent is not None:\n                response = cloud_verifier_common.process_get_status(agent)\n                web_util.echo_json_response(self, 200, \"Success\", response)\n            else:\n                web_util.echo_json_response(self, 404, \"agent id not found\")\n        else:\n            json_response = None\n            if \"bulk\" in rest_params.keys():\n                agent_list = None\n\n                if (\"verifier\" in rest_params.keys()) and (rest_params[\"verifier\"] != ''):\n                    agent_list = session.query(VerfierMain).filter_by(verifier_id=rest_params[\"verifier\"]).all()\n                else:\n                    agent_list = session.query(VerfierMain).all()\n\n                json_response = {}\n                for agent in agent_list:\n                    json_response[agent.agent_id] = cloud_verifier_common.process_get_status(agent)\n\n                web_util.echo_json_response(self, 200, \"Success\", json_response)\n            else:\n                if (\"verifier\" in rest_params.keys()) and (rest_params[\"verifier\"] != ''):\n                    json_response = session.query(VerfierMain.agent_id).filter_by(\n                        verifier_id=rest_params[\"verifier\"]).all()\n                else:\n                    json_response = session.query(VerfierMain.agent_id).all()\n\n                web_util.echo_json_response(self, 200, \"Success\", {\n                    'uuids': json_response})\n\n            logger.info('GET returning 200 response for agent_id list')\n\n    def delete(self):\n        \"\"\"This method handles the DELETE requests to remove agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n        session = get_session()\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('DELETE returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        try:\n            agent = session.query(VerfierMain).filter_by(\n                agent_id=agent_id).first()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        if agent is None:\n            web_util.echo_json_response(self, 404, \"agent id not found\")\n            logger.info('DELETE returning 404 response. agent id: %s not found.', agent_id)\n            return\n\n        verifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n        if verifier_id != agent.verifier_id:\n            web_util.echo_json_response(self, 404, \"agent id associated to this verifier\")\n            logger.info('DELETE returning 404 response. agent id: %s not associated to this verifer.', agent_id)\n            return\n\n        op_state = agent.operational_state\n        if op_state in (states.SAVED, states.FAILED, states.TERMINATED,\n                        states.TENANT_FAILED, states.INVALID_QUOTE):\n            try:\n                verifier_db_delete_agent(session, agent_id)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 200, \"Success\")\n            logger.info('DELETE returning 200 response for agent id: %s', agent_id)\n        else:\n            try:\n                update_agent = session.query(VerfierMain).get(agent_id)\n                update_agent.operational_state = states.TERMINATED\n                try:\n                    session.add(update_agent)\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                session.commit()\n                web_util.echo_json_response(self, 202, \"Accepted\")\n                logger.info('DELETE returning 202 response for agent id: %s', agent_id)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n    def post(self):\n        \"\"\"This method handles the POST requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's will return errors.\n        agents requests require a json block sent in the body\n        \"\"\"\n        session = get_session()\n        try:\n            rest_params = web_util.get_restful_params(self.request.uri)\n            if rest_params is None:\n                web_util.echo_json_response(\n                    self, 405, \"Not Implemented: Use /agents/ interface\")\n                return\n\n            if not rest_params[\"api_version\"]:\n                web_util.echo_json_response(self, 400, \"API Version not supported\")\n                return\n\n            if \"agents\" not in rest_params:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning('POST returning 400 response. uri not supported: %s', self.request.path)\n                return\n\n            agent_id = rest_params[\"agents\"]\n\n            if agent_id is not None:\n                content_length = len(self.request.body)\n                if content_length == 0:\n                    web_util.echo_json_response(\n                        self, 400, \"Expected non zero content length\")\n                    logger.warning('POST returning 400 response. Expected non zero content length.')\n                else:\n                    json_body = json.loads(self.request.body)\n                    agent_data = {}\n                    agent_data['v'] = json_body['v']\n                    agent_data['ip'] = json_body['cloudagent_ip']\n                    agent_data['port'] = int(json_body['cloudagent_port'])\n                    agent_data['operational_state'] = states.START\n                    agent_data['public_key'] = \"\"\n                    agent_data['tpm_policy'] = json_body['tpm_policy']\n                    agent_data['vtpm_policy'] = json_body['vtpm_policy']\n                    agent_data['meta_data'] = json_body['metadata']\n                    agent_data['allowlist'] = json_body['allowlist']\n                    agent_data['mb_refstate'] = json_body['mb_refstate']\n                    agent_data['ima_sign_verification_keys'] = json_body['ima_sign_verification_keys']\n                    agent_data['revocation_key'] = json_body['revocation_key']\n                    agent_data['accept_tpm_hash_algs'] = json_body['accept_tpm_hash_algs']\n                    agent_data['accept_tpm_encryption_algs'] = json_body['accept_tpm_encryption_algs']\n                    agent_data['accept_tpm_signing_algs'] = json_body['accept_tpm_signing_algs']\n                    agent_data['supported_version'] = json_body['supported_version']\n                    agent_data['hash_alg'] = \"\"\n                    agent_data['enc_alg'] = \"\"\n                    agent_data['sign_alg'] = \"\"\n                    agent_data['agent_id'] = agent_id\n                    agent_data['boottime'] = 0\n                    agent_data['ima_pcrs'] = []\n                    agent_data['pcr10'] = None\n                    agent_data['next_ima_ml_entry'] = 0\n                    agent_data['learned_ima_keyrings'] = {}\n                    agent_data['verifier_id'] = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n                    agent_data['verifier_ip'] = config.get('cloud_verifier', 'cloudverifier_ip')\n                    agent_data['verifier_port'] = config.get('cloud_verifier', 'cloudverifier_port')\n\n                    # We fetch the registrar data directly here because we require it for connecting to the agent\n                    # using mTLS\n                    registrar_client.init_client_tls('cloud_verifier')\n                    registrar_data = registrar_client.getData(config.get(\"cloud_verifier\", \"registrar_ip\"),\n                                                              config.get(\"cloud_verifier\", \"registrar_port\"), agent_id)\n                    if registrar_data is None:\n                        web_util.echo_json_response(self, 400,\n                                                    f\"Data for agent {agent_id} could not be found in registrar!\")\n                        logger.warning(f\"Data for agent {agent_id} could not be found in registrar!\")\n                        return\n\n                    agent_data['mtls_cert'] = registrar_data.get('mtls_cert', None)\n                    agent_data['ak_tpm'] = registrar_data['aik_tpm']\n\n                    # TODO: Always error for v1.0 version after initial upgrade\n                    if registrar_data.get('mtls_cert', None) is None and agent_data['supported_version'] != \"1.0\":\n                        web_util.echo_json_response(self, 400, \"mTLS certificate for agent is required!\")\n                        return\n\n                    is_valid, err_msg = cloud_verifier_common.validate_agent_data(agent_data)\n                    if not is_valid:\n                        web_util.echo_json_response(self, 400, err_msg)\n                        logger.warning(err_msg)\n                        return\n\n                    try:\n                        new_agent_count = session.query(\n                            VerfierMain).filter_by(agent_id=agent_id).count()\n                    except SQLAlchemyError as e:\n                        logger.error('SQLAlchemy Error: %s', e)\n                        raise e\n\n                    # don't allow overwriting\n\n                    if new_agent_count > 0:\n                        web_util.echo_json_response(\n                            self, 409, \"Agent of uuid %s already exists\" % (agent_id))\n                        logger.warning(\"Agent of uuid %s already exists\", agent_id)\n                    else:\n                        try:\n                            # Add the agent and data\n                            session.add(VerfierMain(**agent_data))\n                            session.commit()\n                        except SQLAlchemyError as e:\n                            logger.error('SQLAlchemy Error: %s', e)\n                            raise e\n\n                        for key in list(exclude_db.keys()):\n                            agent_data[key] = exclude_db[key]\n\n                        # Prepare SSLContext for mTLS connections\n                        # TODO: drop special handling after initial upgrade\n                        mtls_cert = registrar_data.get('mtls_cert', None)\n                        agent_data['ssl_context'] = None\n                        if mtls_cert:\n                            agent_data['ssl_context'] = web_util.generate_agent_mtls_context(mtls_cert,\n                                                                                             self.mtls_options)\n\n                        if agent_data['ssl_context'] is None:\n                            logger.warning('Connecting to agent without mTLS: %s', agent_id)\n\n                        asyncio.ensure_future(\n                            process_agent(agent_data, states.GET_QUOTE))\n                        web_util.echo_json_response(self, 200, \"Success\")\n                        logger.info('POST returning 200 response for adding agent id: %s', agent_id)\n            else:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"POST returning 400 response. uri not supported\")\n        except Exception as e:\n            web_util.echo_json_response(self, 400, \"Exception error: %s\" % e)\n            logger.warning(\"POST returning 400 response. Exception error: %s\", e)\n            logger.exception(e)\n\n    def put(self):\n        \"\"\"This method handles the PUT requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's will return errors.\n        agents requests require a json block sent in the body\n        \"\"\"\n        session = get_session()\n        try:\n            rest_params = web_util.get_restful_params(self.request.uri)\n            if rest_params is None:\n                web_util.echo_json_response(\n                    self, 405, \"Not Implemented: Use /agents/ interface\")\n                return\n\n            if not rest_params[\"api_version\"]:\n                web_util.echo_json_response(self, 400, \"API Version not supported\")\n                return\n\n            if \"agents\" not in rest_params:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning('PUT returning 400 response. uri not supported: %s', self.request.path)\n                return\n\n            agent_id = rest_params[\"agents\"]\n\n            if agent_id is None:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"PUT returning 400 response. uri not supported\")\n            try:\n                verifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n                agent = session.query(VerfierMain).filter_by(\n                    agent_id=agent_id, verifier_id=verifier_id).one()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise e\n\n            if agent is None:\n                web_util.echo_json_response(self, 404, \"agent id not found\")\n                logger.info('PUT returning 404 response. agent id: %s not found.', agent_id)\n                return\n\n            if \"reactivate\" in rest_params:\n                if not isinstance(agent, dict):\n                    agent = _from_db_obj(agent)\n                if agent[\"mtls_cert\"]:\n                    agent['ssl_context'] = web_util.generate_agent_mtls_context(agent[\"mtls_cert\"], self.mtls_options)\n                agent[\"operational_state\"] = states.START\n                asyncio.ensure_future(\n                    process_agent(agent, states.GET_QUOTE))\n                web_util.echo_json_response(self, 200, \"Success\")\n                logger.info('PUT returning 200 response for agent id: %s', agent_id)\n            elif \"stop\" in rest_params:\n                # do stuff for terminate\n                logger.debug(\"Stopping polling on %s\", agent_id)\n                try:\n                    session.query(VerfierMain).filter(VerfierMain.agent_id == agent_id).update(\n                        {'operational_state': states.TENANT_FAILED})\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n\n                web_util.echo_json_response(self, 200, \"Success\")\n                logger.info('PUT returning 200 response for agent id: %s', agent_id)\n            else:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"PUT returning 400 response. uri not supported\")\n\n        except Exception as e:\n            web_util.echo_json_response(self, 400, \"Exception error: %s\" % e)\n            logger.warning(\"PUT returning 400 response. Exception error: %s\", e)\n            logger.exception(e)\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AllowlistHandler(BaseHandler):\n    def head(self):\n        web_util.echo_json_response(\n            self, 400, \"Allowlist handler: HEAD Not Implemented\")\n\n    def get(self):\n        \"\"\"Get an allowlist\n\n        GET /allowlists/{name}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            logger.warning(\n                'GET returning 400 response: ' + self.request.path)\n            return\n\n        session = get_session()\n        try:\n            allowlist = session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).one()\n        except NoResultFound:\n            web_util.echo_json_response(self, 404, \"Allowlist %s not found\" % allowlist_name)\n            return\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        response = {}\n        for field in ('name', 'tpm_policy', 'vtpm_policy', 'ima_policy'):\n            response[field] = getattr(allowlist, field, None)\n        web_util.echo_json_response(self, 200, 'Success', response)\n\n    def delete(self):\n        \"\"\"Delete an allowlist\n\n        DELETE /allowlists/{name}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            logger.warning(\n                'DELETE returning 400 response: ' + self.request.path)\n            return\n\n        session = get_session()\n        try:\n            session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).one()\n        except NoResultFound:\n            web_util.echo_json_response(self, 404, \"Allowlist %s not found\" % allowlist_name)\n            return\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        try:\n            session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).delete()\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        # NOTE(kaifeng) 204 Can not have response body, but current helper\n        # doesn't support this case.\n        self.set_status(204)\n        self.set_header('Content-Type', 'application/json')\n        self.finish()\n        logger.info(\n            'DELETE returning 204 response for allowlist: ' + allowlist_name)\n\n    def post(self):\n        \"\"\"Create an allowlist\n\n        POST /allowlists/{name}\n        body: {\"tpm_policy\": {..}, \"vtpm_policy\": {..}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        content_length = len(self.request.body)\n        if content_length == 0:\n            web_util.echo_json_response(\n                self, 400, \"Expected non zero content length\")\n            logger.warning(\n                'POST returning 400 response. Expected non zero content length.')\n            return\n\n        allowlist = {}\n        json_body = json.loads(self.request.body)\n        allowlist['name'] = allowlist_name\n        tpm_policy = json_body.get('tpm_policy')\n        if tpm_policy:\n            allowlist['tpm_policy'] = tpm_policy\n        vtpm_policy = json_body.get('vtpm_policy')\n        if vtpm_policy:\n            allowlist['vtpm_policy'] = vtpm_policy\n        ima_policy = json_body.get('ima_policy')\n        if ima_policy:\n            allowlist['ima_policy'] = ima_policy\n\n        session = get_session()\n        # don't allow overwritting\n        try:\n            al_count = session.query(\n                VerifierAllowlist).filter_by(name=allowlist_name).count()\n            if al_count > 0:\n                web_util.echo_json_response(\n                    self, 409, \"Allowlist with name %s already exists\" % allowlist_name)\n                logger.warning(\n                    \"Allowlist with name %s already exists\" % allowlist_name)\n                return\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            raise\n\n        try:\n            # Add the agent and data\n            session.add(VerifierAllowlist(**allowlist))\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            raise\n\n        web_util.echo_json_response(self, 201)\n        logger.info('POST returning 201')\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 400, \"Allowlist handler: PUT Not Implemented\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nasync def invoke_get_quote(agent, need_pubkey):\n    failure = Failure(Component.INTERNAL, [\"verifier\"])\n    if agent is None:\n        raise Exception(\"agent deleted while being processed\")\n    params = cloud_verifier_common.prepare_get_quote(agent)\n\n    partial_req = \"1\"\n    if need_pubkey:\n        partial_req = \"0\"\n\n    # TODO: remove special handling after initial upgrade\n    if agent['ssl_context']:\n        res = tornado_requests.request(\"GET\",\n                                       \"https://%s:%d/v%s/quotes/integrity?nonce=%s&mask=%s&vmask=%s&partial=%s&ima_ml_entry=%d\" %\n                                       (agent['ip'], agent['port'], agent['supported_version'], params[\"nonce\"], params[\"mask\"], params['vmask'], partial_req, params['ima_ml_entry']),\n                                       context=agent['ssl_context'])\n    else:\n        res = tornado_requests.request(\"GET\",\n                                       \"http://%s:%d/v%s/quotes/integrity?nonce=%s&mask=%s&vmask=%s&partial=%s&ima_ml_entry=%d\" %\n                                       (agent['ip'], agent['port'], agent['supported_version'], params[\"nonce\"], params[\"mask\"],\n                                        params['vmask'], partial_req, params['ima_ml_entry']))\n    response = await res\n\n    if response.status_code != 200:\n        # this is a connection error, retry get quote\n        if response.status_code in [500, 599]:\n            asyncio.ensure_future(process_agent(\n                agent, states.GET_QUOTE_RETRY))\n        else:\n            # catastrophic error, do not continue\n            logger.critical(\"Unexpected Get Quote response error for cloud agent %s, Error: %s\", agent['agent_id'], response.status_code)\n            failure.add_event(\"no_quote\", \"Unexpected Get Quote reponse from agent\", False)\n            asyncio.ensure_future(process_agent(agent, states.FAILED, failure))\n    else:\n        try:\n            json_response = json.loads(response.body)\n\n            # validate the cloud agent response\n            if 'provide_V' not in agent :\n                agent['provide_V'] = True\n            agentAttestState = get_AgentAttestStates().get_by_agent_id(agent['agent_id'])\n            failure = cloud_verifier_common.process_quote_response(agent, json_response['results'], agentAttestState)\n            if not failure:\n                if agent['provide_V']:\n                    asyncio.ensure_future(process_agent(agent, states.PROVIDE_V))\n                else:\n                    asyncio.ensure_future(process_agent(agent, states.GET_QUOTE))\n            else:\n                asyncio.ensure_future(process_agent(agent, states.INVALID_QUOTE, failure))\n\n            # store the attestation state\n            store_attestation_state(agentAttestState)\n\n        except Exception as e:\n            logger.exception(e)\n\n\nasync def invoke_provide_v(agent):\n    failure = Failure(Component.INTERNAL, [\"verifier\"])\n    if agent is None:\n        raise Exception(\"Agent deleted while being processed\")\n    try:\n        if agent['pending_event'] is not None:\n            agent['pending_event'] = None\n    except KeyError:\n        pass\n    v_json_message = cloud_verifier_common.prepare_v(agent)\n\n    # TODO: remove special handling after initial upgrade\n    if agent['ssl_context']:\n        res = tornado_requests.request(\n            \"POST\", \"https://%s:%d/v%s/keys/vkey\" % (agent['ip'], agent['port'], agent['supported_version']),\n            data=v_json_message, context=agent['ssl_context'])\n    else:\n        res = tornado_requests.request(\n            \"POST\", \"http://%s:%d/v%s/keys/vkey\" % (agent['ip'], agent['port'], agent['supported_version']),\n            data=v_json_message)\n\n    response = await res\n\n    if response.status_code != 200:\n        if response.status_code in [500, 599]:\n            asyncio.ensure_future(\n                process_agent(agent, states.PROVIDE_V_RETRY))\n        else:\n            # catastrophic error, do not continue\n            logger.critical(\"Unexpected Provide V response error for cloud agent %s, Error: %s\", agent['agent_id'], response.status_code)\n            failure.add_event(\"no_v\", {\"message\": \"Unexpected provide V response\", \"data\": response.status_code}, False)\n            asyncio.ensure_future(process_agent(agent, states.FAILED, failure))\n    else:\n        asyncio.ensure_future(process_agent(agent, states.GET_QUOTE))\n\n\nasync def process_agent(agent, new_operational_state, failure=Failure(Component.INTERNAL, [\"verifier\"])):\n    # Convert to dict if the agent arg is a db object\n    if not isinstance(agent, dict):\n        agent = _from_db_obj(agent)\n\n    session = get_session()\n    try:  # pylint: disable=R1702\n        main_agent_operational_state = agent['operational_state']\n        try:\n            stored_agent = session.query(VerfierMain).filter_by(\n                agent_id=str(agent['agent_id'])).first()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        # if the user did terminated this agent\n        if stored_agent.operational_state == states.TERMINATED:\n            logger.warning(\"Agent %s terminated by user.\", agent['agent_id'])\n            if agent['pending_event'] is not None:\n                tornado.ioloop.IOLoop.current().remove_timeout(\n                    agent['pending_event'])\n            verifier_db_delete_agent(session, agent['agent_id'])\n            return\n\n        # if the user tells us to stop polling because the tenant quote check failed\n        if stored_agent.operational_state == states.TENANT_FAILED:\n            logger.warning(\"Agent %s has failed tenant quote. Stopping polling\",  agent['agent_id'])\n            if agent['pending_event'] is not None:\n                tornado.ioloop.IOLoop.current().remove_timeout(\n                    agent['pending_event'])\n            return\n\n        # If failed during processing, log regardless and drop it on the floor\n        # The administration application (tenant) can GET the status and act accordingly (delete/retry/etc).\n        if new_operational_state in (states.FAILED, states.INVALID_QUOTE):\n            assert failure, \"States FAILED and INVALID QUOTE should only be reached with a failure message\"\n\n            if agent.get('severity_level') is None or agent['severity_level'] < failure.highest_severity.severity:\n                agent['severity_level'] = failure.highest_severity.severity\n                agent['last_event_id'] = failure.highest_severity_event.event_id\n                agent['operational_state'] = new_operational_state\n\n                # issue notification for invalid quotes\n                if new_operational_state == states.INVALID_QUOTE:\n                    cloud_verifier_common.notify_error(agent, event=failure.highest_severity_event)\n\n                # When the failure is irrecoverable we stop polling the agent\n                if not failure.recoverable or failure.highest_severity == MAX_SEVERITY_LABEL:\n                    if agent['pending_event'] is not None:\n                        tornado.ioloop.IOLoop.current().remove_timeout(\n                            agent['pending_event'])\n                    for key in exclude_db:\n                        if key in agent:\n                            del agent[key]\n                    session.query(VerfierMain).filter_by(\n                        agent_id=agent['agent_id']).update(agent)\n                    session.commit()\n\n        # propagate all state, but remove none DB keys first (using exclude_db)\n        try:\n            agent_db = dict(agent)\n            for key in exclude_db:\n                if key in agent_db:\n                    del agent_db[key]\n\n            session.query(VerfierMain).filter_by(\n                agent_id=agent_db['agent_id']).update(agent_db)\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        # If agent was in a failed state we check if we either stop polling\n        # or just add it again to the event loop\n        if new_operational_state in [states.FAILED, states.INVALID_QUOTE]:\n            if not failure.recoverable or failure.highest_severity == MAX_SEVERITY_LABEL:\n                logger.warning(\"Agent %s failed, stopping polling\", agent['agent_id'])\n                return\n\n            await invoke_get_quote(agent, False)\n            return\n\n        # if new, get a quote\n        if (main_agent_operational_state == states.START and\n                new_operational_state == states.GET_QUOTE):\n            agent['num_retries'] = 0\n            agent['operational_state'] = states.GET_QUOTE\n            await invoke_get_quote(agent, True)\n            return\n\n        if (main_agent_operational_state == states.GET_QUOTE and\n                new_operational_state == states.PROVIDE_V):\n            agent['num_retries'] = 0\n            agent['operational_state'] = states.PROVIDE_V\n            await invoke_provide_v(agent)\n            return\n\n        if (main_agent_operational_state in (states.PROVIDE_V, states.GET_QUOTE) and\n                new_operational_state == states.GET_QUOTE):\n            agent['num_retries'] = 0\n            interval = config.getfloat('cloud_verifier', 'quote_interval')\n            agent['operational_state'] = states.GET_QUOTE\n            if interval == 0:\n                await invoke_get_quote(agent, False)\n            else:\n                logger.debug(\"Setting up callback to check again in %f seconds\", interval)\n                # set up a call back to check again\n                cb = functools.partial(invoke_get_quote, agent, False)\n                pending = tornado.ioloop.IOLoop.current().call_later(interval, cb)\n                agent['pending_event'] = pending\n            return\n\n        maxr = config.getint('cloud_verifier', 'max_retries')\n        retry = config.getfloat('cloud_verifier', 'retry_interval')\n        if (main_agent_operational_state == states.GET_QUOTE and\n                new_operational_state == states.GET_QUOTE_RETRY):\n            if agent['num_retries'] >= maxr:\n                logger.warning(\"Agent %s was not reachable for quote in %d tries, setting state to FAILED\", agent['agent_id'], maxr)\n                failure.add_event(\"not_reachable\", \"agent was not reachable from verifier\", False)\n                if agent['first_verified']:  # only notify on previously good agents\n                    cloud_verifier_common.notify_error(\n                        agent, msgtype='comm_error', event=failure.highest_severity_event)\n                else:\n                    logger.debug(\"Communication error for new agent. No notification will be sent\")\n                await process_agent(agent, states.FAILED, failure)\n            else:\n                agent['operational_state'] = states.GET_QUOTE\n                cb = functools.partial(invoke_get_quote, agent, True)\n                agent['num_retries'] += 1\n                logger.info(\"Connection to %s refused after %d/%d tries, trying again in %f seconds\", agent['ip'], agent['num_retries'], maxr, retry)\n                tornado.ioloop.IOLoop.current().call_later(retry, cb)\n            return\n\n        if (main_agent_operational_state == states.PROVIDE_V and\n                new_operational_state == states.PROVIDE_V_RETRY):\n            if agent['num_retries'] >= maxr:\n                logger.warning(\"Agent %s was not reachable to provide v in %d tries, setting state to FAILED\", agent['agent_id'], maxr)\n                failure.add_event(\"not_reachable_v\", \"agent was not reachable to provide V\", False)\n                cloud_verifier_common.notify_error(\n                    agent, msgtype='comm_error', event=failure.highest_severity_event)\n                await process_agent(agent, states.FAILED, failure)\n            else:\n                agent['operational_state'] = states.PROVIDE_V\n                cb = functools.partial(invoke_provide_v, agent)\n                agent['num_retries'] += 1\n                logger.info(\"Connection to %s refused after %d/%d tries, trying again in %f seconds\", agent['ip'], agent['num_retries'], maxr, retry)\n                tornado.ioloop.IOLoop.current().call_later(retry, cb)\n            return\n        raise Exception(\"nothing should ever fall out of this!\")\n\n    except Exception as e:\n        logger.error(\"Polling thread error: %s\", e)\n        logger.exception(e)\n\n\nasync def activate_agents(verifier_id, verifier_ip, verifier_port, mtls_options):\n    session = get_session()\n    aas = get_AgentAttestStates()\n    try:\n        agents = session.query(VerfierMain).filter_by(\n            verifier_id=verifier_id).all()\n        for agent in agents:\n            agent.verifier_ip = verifier_ip\n            agent.verifier_host = verifier_port\n            agent_run = _from_db_obj(agent)\n            if agent_run[\"mtls_cert\"]:\n                agent_run[\"ssl_context\"] = web_util.generate_agent_mtls_context(agent_run[\"mtls_cert\"], mtls_options)\n            if agent.operational_state == states.START:\n                asyncio.ensure_future(process_agent(agent_run, states.GET_QUOTE))\n            if agent.boottime:\n                ima_pcrs_dict = {}\n                for pcr_num in agent.ima_pcrs:\n                    ima_pcrs_dict[pcr_num] = getattr(agent, 'pcr%d' % pcr_num)\n                aas.add(agent.agent_id, agent.boottime, ima_pcrs_dict, agent.next_ima_ml_entry, agent.learned_ima_keyrings)\n        session.commit()\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\ndef start_tornado(tornado_server, port):\n    tornado_server.listen(port)\n    print(\"Starting Torando on port \" + str(port))\n    tornado.ioloop.IOLoop.instance().start()\n    print(\"Tornado finished\")\n\n\ndef main():\n    \"\"\"Main method of the Cloud Verifier Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    cloudverifier_port = config.get('cloud_verifier', 'cloudverifier_port')\n    cloudverifier_host = config.get('cloud_verifier', 'cloudverifier_ip')\n    cloudverifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n\n    # allow tornado's max upload size to be configurable\n    max_upload_size = None\n    if config.has_option('cloud_verifier', 'max_upload_size'):\n        max_upload_size = int(config.get('cloud_verifier', 'max_upload_size'))\n\n    VerfierMain.metadata.create_all(engine, checkfirst=True)\n    session = get_session()\n    try:\n        query_all = session.query(VerfierMain).all()\n        for row in query_all:\n            if row.operational_state in states.APPROVED_REACTIVATE_STATES:\n                row.operational_state = states.START\n        session.commit()\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\n    num = session.query(VerfierMain.agent_id).count()\n    if num > 0:\n        agent_ids = session.query(VerfierMain.agent_id).all()\n        logger.info(\"Agent ids in db loaded from file: %s\", agent_ids)\n\n    logger.info('Starting Cloud Verifier (tornado) on port %s, use <Ctrl-C> to stop', cloudverifier_port)\n\n    # print out API versions we support\n    keylime_api_version.log_api_versions(logger)\n\n    context, mtls_options = web_util.init_mtls(logger=logger)\n\n    # Check for user defined CA to connect to agent\n    agent_mtls_cert = config.get(\"cloud_verifier\", \"agent_mtls_cert\", fallback=None)\n    agent_mtls_private_key = config.get(\"cloud_verifier\", \"agent_mtls_private_key\", fallback=None)\n    agent_mtls_private_key_pw = config.get(\"cloud_verifier\", \"agent_mtls_private_key_pw\", fallback=None)\n\n    # Only set custom options if the cert should not be the same as used by the verifier\n    if agent_mtls_cert != \"CV\":\n        mtls_options = (agent_mtls_cert, agent_mtls_private_key, agent_mtls_private_key_pw)\n\n    app = tornado.web.Application([\n        (r\"/v?[0-9]+(?:\\.[0-9]+)?/agents/.*\", AgentsHandler, {\"mtls_options\": mtls_options}),\n        (r\"/v?[0-9]+(?:\\.[0-9]+)?/allowlists/.*\", AllowlistHandler),\n        (r\"/versions?\", VersionHandler),\n        (r\".*\", MainHandler),\n    ])\n\n    sockets = tornado.netutil.bind_sockets(\n        int(cloudverifier_port), address=cloudverifier_host)\n\n    server = tornado.httpserver.HTTPServer(app, ssl_options=context, max_buffer_size=max_upload_size)\n    server.add_sockets(sockets)\n\n    signal.signal(signal.SIGTERM, lambda *_: sys.exit(0))\n\n    try:\n        server.start(config.getint('cloud_verifier', 'multiprocessing_pool_num_workers'))\n        if tornado.process.task_id() == 0:\n            # Start the revocation notifier only on one process\n            if config.getboolean('cloud_verifier', 'revocation_notifier'):\n                logger.info(\"Starting service for revocation notifications on port %s\",\n                            config.getint('cloud_verifier', 'revocation_notifier_port'))\n                revocation_notifier.start_broker()\n            # Auto activate agents\n            asyncio.ensure_future(activate_agents(cloudverifier_id, cloudverifier_host, cloudverifier_port, mtls_options))\n\n        tornado.ioloop.IOLoop.current().start()\n    except (KeyboardInterrupt, SystemExit):\n        tornado.ioloop.IOLoop.current().stop()\n        if tornado.process.task_id() == 0 and config.getboolean('cloud_verifier', 'revocation_notifier'):\n            revocation_notifier.stop_broker()\n", "#!/usr/bin/python3\n\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport asyncio\nimport http.server\nimport multiprocessing\nimport platform\nimport datetime\nimport signal\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom socketserver import ThreadingMixIn\nimport threading\nimport base64\nimport configparser\nimport uuid\nimport os\nimport socket\nimport sys\nimport time\nimport hashlib\nimport zipfile\nimport io\nimport importlib\nimport shutil\nimport subprocess\nimport psutil\n\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import serialization\n\nfrom keylime import config\nfrom keylime import keylime_logging\nfrom keylime import cmd_exec\nfrom keylime import crypto\nfrom keylime import ima\nfrom keylime import json\nfrom keylime import revocation_notifier\nfrom keylime import registrar_client\nfrom keylime import secure_mount\nfrom keylime import web_util\nfrom keylime import api_version as keylime_api_version\nfrom keylime.common import algorithms, validators\nfrom keylime.tpm.tpm_main import tpm\nfrom keylime.tpm.tpm_abstract import TPM_Utilities\nfrom keylime.tpm.tpm2_objects import pubkey_from_tpm2b_public\n\n# Configure logger\nlogger = keylime_logging.init_logging('cloudagent')\n\n# lock required for multithreaded operation\nuvLock = threading.Lock()\n\n# Instaniate tpm\ntpm_instance = tpm(need_hw_tpm=True)\n\n\nclass Handler(BaseHTTPRequestHandler):\n    parsed_path = ''\n\n    def do_HEAD(self):\n        \"\"\"Not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_GET(self):\n        \"\"\"This method services the GET request typically from either the Tenant or the Cloud Verifier.\n\n        Only tenant and cloudverifier uri's are supported. Both requests require a nonce parameter.\n        The Cloud verifier requires an additional mask paramter.  If the uri or parameters are incorrect, a 400 response is returned.\n        \"\"\"\n\n        logger.info('GET invoked from %s with uri: %s', self.client_address, self.path)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /version, /keys/ or /quotes/ interfaces\")\n            return\n\n        if \"version\" in rest_params:\n            version_info = {\n                \"supported_version\": keylime_api_version.current_version()\n            }\n            web_util.echo_json_response(self, 200, version_info)\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"keys\" in rest_params and rest_params['keys'] == 'verify':\n            if self.server.K is None:\n                logger.info('GET key challenge returning 400 response. bootstrap key not available')\n                web_util.echo_json_response(\n                    self, 400, \"Bootstrap key not yet available.\")\n                return\n            if \"challenge\" not in rest_params:\n                logger.info('GET key challenge returning 400 response. No challenge provided')\n                web_util.echo_json_response(\n                    self, 400, \"No challenge provided.\")\n                return\n\n            challenge = rest_params['challenge']\n            response = {}\n            response['hmac'] = crypto.do_hmac(self.server.K, challenge)\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info('GET key challenge returning 200 response.')\n\n        # If agent pubkey requested\n        elif \"keys\" in rest_params and rest_params[\"keys\"] == \"pubkey\":\n            response = {}\n            response['pubkey'] = self.server.rsapublickey_exportable\n\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info('GET pubkey returning 200 response.')\n            return\n\n        elif \"quotes\" in rest_params:\n            nonce = rest_params.get('nonce', None)\n            pcrmask = rest_params.get('mask', None)\n            ima_ml_entry = rest_params.get('ima_ml_entry', '0')\n\n            # if the query is not messed up\n            if nonce is None:\n                logger.warning('GET quote returning 400 response. nonce not provided as an HTTP parameter in request')\n                web_util.echo_json_response(\n                    self, 400, \"nonce not provided as an HTTP parameter in request\")\n                return\n\n            # Sanitization assurance (for tpm.run() tasks below)\n            if not (nonce.isalnum() and\n                    (pcrmask is None or validators.valid_hex(pcrmask)) and\n                    ima_ml_entry.isalnum()):\n                logger.warning('GET quote returning 400 response. parameters should be strictly alphanumeric')\n                web_util.echo_json_response(\n                    self, 400, \"parameters should be strictly alphanumeric\")\n                return\n\n            if len(nonce) > tpm_instance.MAX_NONCE_SIZE:\n                logger.warning('GET quote returning 400 response. Nonce is too long (max size %i): %i',\n                               tpm_instance.MAX_NONCE_SIZE, len(nonce))\n                web_util.echo_json_response(\n                    self, 400, f'Nonce is too long (max size {tpm_instance.MAX_NONCE_SIZE}): {len(nonce)}')\n                return\n\n            # identity quotes are always shallow\n            hash_alg = tpm_instance.defaults['hash']\n            if not tpm_instance.is_vtpm() or rest_params[\"quotes\"] == 'identity':\n                quote = tpm_instance.create_quote(\n                    nonce, self.server.rsapublickey_exportable, pcrmask, hash_alg)\n                imaMask = pcrmask\n\n            # Allow for a partial quote response (without pubkey)\n            enc_alg = tpm_instance.defaults['encrypt']\n            sign_alg = tpm_instance.defaults['sign']\n\n            if \"partial\" in rest_params and (rest_params[\"partial\"] is None or rest_params[\"partial\"] == \"1\"):\n                response = {\n                    'quote': quote,\n                    'hash_alg': hash_alg,\n                    'enc_alg': enc_alg,\n                    'sign_alg': sign_alg,\n                }\n            else:\n                response = {\n                    'quote': quote,\n                    'hash_alg': hash_alg,\n                    'enc_alg': enc_alg,\n                    'sign_alg': sign_alg,\n                    'pubkey': self.server.rsapublickey_exportable,\n                }\n\n            response['boottime'] = self.server.boottime\n\n            # return a measurement list if available\n            if TPM_Utilities.check_mask(imaMask, config.IMA_PCR):\n                ima_ml_entry = int(ima_ml_entry)\n                if ima_ml_entry > self.server.next_ima_ml_entry:\n                    ima_ml_entry = 0\n                ml, nth_entry, num_entries = ima.read_measurement_list(config.IMA_ML, ima_ml_entry)\n                if num_entries > 0:\n                    response['ima_measurement_list'] = ml\n                    response['ima_measurement_list_entry'] = nth_entry\n                    self.server.next_ima_ml_entry = num_entries\n\n            # similar to how IMA log retrievals are triggered by IMA_PCR, we trigger boot logs with MEASUREDBOOT_PCRs\n            # other possibilities would include adding additional data to rest_params to trigger boot log retrievals\n            # generally speaking, retrieving the 15Kbytes of a boot log does not seem significant compared to the\n            # potential Mbytes of an IMA measurement list.\n            if TPM_Utilities.check_mask(imaMask, config.MEASUREDBOOT_PCRS[0]):\n                if not os.path.exists(config.MEASUREDBOOT_ML):\n                    logger.warning(\"TPM2 event log not available: %s\", config.MEASUREDBOOT_ML)\n                else:\n                    with open(config.MEASUREDBOOT_ML, 'rb') as f:\n                        el = base64.b64encode(f.read())\n                    response['mb_measurement_list'] = el\n\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info('GET %s quote returning 200 response.', rest_params[\"quotes\"])\n            return\n\n        else:\n            logger.warning('GET returning 400 response. uri not supported: %s', self.path)\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            return\n\n    def do_POST(self):\n        \"\"\"This method services the POST request typically from either the Tenant or the Cloud Verifier.\n\n        Only tenant and cloudverifier uri's are supported. Both requests require a nonce parameter.\n        The Cloud verifier requires an additional mask parameter.  If the uri or parameters are incorrect, a 400 response is returned.\n        \"\"\"\n        rest_params = web_util.get_restful_params(self.path)\n\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /keys/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if rest_params.get(\"keys\", None) not in [\"ukey\", \"vkey\"]:\n            web_util.echo_json_response(self, 400, \"Only /keys/ukey or /keys/vkey are supported\")\n            return\n\n        content_length = int(self.headers.get('Content-Length', 0))\n        if content_length <= 0:\n            logger.warning('POST returning 400 response, expected content in message. url: %s', self.path)\n            web_util.echo_json_response(self, 400, \"expected content in message\")\n            return\n\n        post_body = self.rfile.read(content_length)\n        try:\n            json_body = json.loads(post_body)\n            b64_encrypted_key = json_body['encrypted_key']\n            decrypted_key = crypto.rsa_decrypt(\n                self.server.rsaprivatekey, base64.b64decode(b64_encrypted_key))\n        except (ValueError, KeyError, TypeError) as e:\n            logger.warning('POST returning 400 response, could not parse body data: %s', e)\n            web_util.echo_json_response(self, 400, \"content is invalid\")\n            return\n\n        have_derived_key = False\n\n        if rest_params[\"keys\"] == \"ukey\":\n            if 'auth_tag' not in json_body:\n                logger.warning('POST returning 400 response, U key provided without an auth_tag')\n                web_util.echo_json_response(self, 400, \"auth_tag is missing\")\n                return\n            self.server.add_U(decrypted_key)\n            self.server.auth_tag = json_body['auth_tag']\n            self.server.payload = json_body.get('payload', None)\n            have_derived_key = self.server.attempt_decryption()\n        elif rest_params[\"keys\"] == \"vkey\":\n            self.server.add_V(decrypted_key)\n            have_derived_key = self.server.attempt_decryption()\n        else:\n            logger.warning('POST returning  response. uri not supported: %s', self.path)\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            return\n        logger.info('POST of %s key returning 200', ('V', 'U')[rest_params[\"keys\"] == \"ukey\"])\n        web_util.echo_json_response(self, 200, \"Success\")\n\n        # no key yet, then we're done\n        if not have_derived_key:\n            return\n\n        # woo hoo we have a key\n        # ok lets write out the key now\n        secdir = secure_mount.mount()  # confirm that storage is still securely mounted\n\n        # clean out the secure dir of any previous info before we extract files\n        if os.path.isdir(\"%s/unzipped\" % secdir):\n            shutil.rmtree(\"%s/unzipped\" % secdir)\n\n        # write out key file\n        f = open(secdir + \"/\" + self.server.enc_keyname, 'w', encoding=\"utf-8\")\n        f.write(base64.b64encode(self.server.K).decode())\n        f.close()\n\n        # stow the U value for later\n        tpm_instance.write_key_nvram(self.server.final_U)\n\n        # optionally extend a hash of they key and payload into specified PCR\n        tomeasure = self.server.K\n\n        # if we have a good key, now attempt to write out the encrypted payload\n        dec_path = os.path.join(secdir,\n                                config.get('cloud_agent', \"dec_payload_file\"))\n        enc_path = os.path.join(config.WORK_DIR, \"encrypted_payload\")\n\n        dec_payload = None\n        enc_payload = None\n        if self.server.payload is not None:\n            dec_payload = crypto.decrypt(\n                self.server.payload, bytes(self.server.K))\n\n            enc_payload = self.server.payload\n        elif os.path.exists(enc_path):\n            # if no payload provided, try to decrypt one from a previous run stored in encrypted_payload\n            with open(enc_path, 'rb') as f:\n                enc_payload = f.read()\n            try:\n                dec_payload = crypto.decrypt(enc_payload, self.server.K)\n                logger.info(\"Decrypted previous payload in %s to %s\", enc_path, dec_path)\n            except Exception as e:\n                logger.warning(\"Unable to decrypt previous payload %s with derived key: %s\", enc_path, e)\n                os.remove(enc_path)\n                enc_payload = None\n\n        # also write out encrypted payload to be decrytped next time\n        if enc_payload is not None:\n            with open(enc_path, 'wb') as f:\n                f.write(self.server.payload.encode('utf-8'))\n\n        # deal with payload\n        payload_thread = None\n        if dec_payload is not None:\n            tomeasure = tomeasure + dec_payload\n            # see if payload is a zip\n            zfio = io.BytesIO(dec_payload)\n            if config.getboolean('cloud_agent', 'extract_payload_zip') and zipfile.is_zipfile(zfio):\n                logger.info(\"Decrypting and unzipping payload to %s/unzipped\", secdir)\n                with zipfile.ZipFile(zfio, 'r')as f:\n                    f.extractall('%s/unzipped' % secdir)\n\n                # run an included script if one has been provided\n                initscript = config.get('cloud_agent', 'payload_script')\n                if initscript != \"\":\n                    def initthread():\n                        env = os.environ.copy()\n                        env['AGENT_UUID'] = self.server.agent_uuid\n                        proc = subprocess.Popen([\"/bin/bash\", initscript], env=env, shell=False, cwd='%s/unzipped' % secdir,\n                                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n                        for line in iter(proc.stdout.readline, b''):\n                            logger.debug(\"init-output: %s\", line.strip())\n                        # should be a no-op as poll already told us it's done\n                        proc.wait()\n\n                    if not os.path.exists(\n                            os.path.join(secdir, \"unzipped\", initscript)):\n                        logger.info(\"No payload script %s found in %s/unzipped\", initscript, secdir)\n                    else:\n                        logger.info(\"Executing payload script: %s/unzipped/%s\", secdir, initscript)\n                        payload_thread = threading.Thread(target=initthread, daemon=True)\n            else:\n                logger.info(\"Decrypting payload to %s\", dec_path)\n                with open(dec_path, 'wb') as f:\n                    f.write(dec_payload)\n            zfio.close()\n\n        # now extend a measurement of the payload and key if there was one\n        pcr = config.getint('cloud_agent', 'measure_payload_pcr')\n        if 0 < pcr < 24:\n            logger.info(\"extending measurement of payload into PCR %s\", pcr)\n            measured = tpm_instance.hashdigest(tomeasure)\n            tpm_instance.extendPCR(pcr, measured)\n\n        if payload_thread is not None:\n            payload_thread.start()\n\n        return\n\n    # pylint: disable=W0622\n    def log_message(self, format, *args):\n        return\n\n# consider using PooledProcessMixIn\n# https://github.com/muayyad-alsadi/python-PooledProcessMixIn\n\n\nclass CloudAgentHTTPServer(ThreadingMixIn, HTTPServer):\n    \"\"\"Http Server which will handle each request in a separate thread.\"\"\"\n\n    # Do not modify directly unless you acquire uvLock. Set chosen for uniqueness of contained values\n    u_set = set()\n    v_set = set()\n\n    rsaprivatekey = None\n    rsapublickey = None\n    rsapublickey_exportable = None\n    mtls_cert_path = None\n    rsakey_path = None\n    mtls_cert = None\n    done = threading.Event()\n    auth_tag = None\n    payload = None\n    enc_keyname = None\n    K = None\n    final_U = None\n    agent_uuid = None\n    next_ima_ml_entry = 0 # The next IMA log offset the verifier may ask for.\n    boottime = int(psutil.boot_time())\n\n    def __init__(self, server_address, RequestHandlerClass, agent_uuid):\n        \"\"\"Constructor overridden to provide ability to pass configuration arguments to the server\"\"\"\n        secdir = secure_mount.mount()\n        keyname = os.path.join(secdir,\n                               config.get('cloud_agent', 'rsa_keyname'))\n        certname = os.path.join(secdir, config.get('cloud_agent', 'mtls_cert'))\n        # read or generate the key depending on configuration\n        if os.path.isfile(keyname):\n            # read in private key\n            logger.debug(\"Using existing key in %s\", keyname)\n            f = open(keyname, \"rb\")\n            rsa_key = crypto.rsa_import_privkey(f.read())\n        else:\n            logger.debug(\"key not found, generating a new one\")\n            rsa_key = crypto.rsa_generate(2048)\n            with open(keyname, \"wb\") as f:\n                f.write(crypto.rsa_export_privkey(rsa_key))\n\n        self.rsakey_path = keyname\n        self.rsaprivatekey = rsa_key\n        self.rsapublickey_exportable = crypto.rsa_export_pubkey(\n            self.rsaprivatekey)\n\n        if os.path.isfile(certname):\n            logger.debug(\"Using existing mTLS cert in %s\", certname)\n            with open(certname, \"rb\") as f:\n                mtls_cert = x509.load_pem_x509_certificate(f.read())\n        else:\n            logger.debug(\"No mTLS certificate found generating a new one\")\n            with open(certname, \"wb\") as f:\n                # By default generate a TLS certificate valid for 5 years\n                valid_util = datetime.datetime.utcnow() + datetime.timedelta(days=(360 * 5))\n                mtls_cert = crypto.generate_selfsigned_cert(agent_uuid, rsa_key, valid_util)\n                f.write(mtls_cert.public_bytes(serialization.Encoding.PEM))\n\n        self.mtls_cert_path = certname\n        self.mtls_cert = mtls_cert\n\n        # attempt to get a U value from the TPM NVRAM\n        nvram_u = tpm_instance.read_key_nvram()\n        if nvram_u is not None:\n            logger.info(\"Existing U loaded from TPM NVRAM\")\n            self.add_U(nvram_u)\n        http.server.HTTPServer.__init__(\n            self, server_address, RequestHandlerClass)\n        self.enc_keyname = config.get('cloud_agent', 'enc_keyname')\n        self.agent_uuid = agent_uuid\n\n    def add_U(self, u):\n        \"\"\"Threadsafe method for adding a U value received from the Tenant\n\n        Do not modify u_set of v_set directly.\n        \"\"\"\n        with uvLock:\n            # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n            if config.INSECURE_DEBUG:\n                logger.debug(\"Adding U len %d data:%s\", len(u), base64.b64encode(u))\n            self.u_set.add(u)\n\n    def add_V(self, v):\n        \"\"\"Threadsafe method for adding a V value received from the Cloud Verifier\n        Do not modify u_set of v_set directly.\n        \"\"\"\n        with uvLock:\n            # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n            if config.INSECURE_DEBUG:\n                logger.debug(\"Adding V: %s\", base64.b64encode(v))\n            self.v_set.add(v)\n\n    def attempt_decryption(self):\n        \"\"\"On reception of a U or V value, this method is called to attempt the decryption of the Cloud Init script\n\n        At least one U and V value must be received in order to attempt encryption. Multiple U and V values are stored\n        to prevent an attacker from sending U/V values to deny service.\n        \"\"\"\n        with uvLock:\n            both_u_and_v_present = False\n            return_value = False\n            for u in self.u_set:\n                for v in self.v_set:\n                    both_u_and_v_present = True\n                    return_value = self.decrypt_check(u, v)\n                    if return_value:\n                        # reset u and v sets\n                        self.u_set = set()\n                        self.v_set = set()\n                        return return_value\n            # TODO check on whether this happens or not.  NVRAM causes trouble\n            if both_u_and_v_present:\n                pass\n                # logger.critical(\"Possible attack from: \" + str(handler.client_address) + \".  Both U (potentially stale from TPM NVRAM) and V present but unsuccessful in attempt to decrypt check value.\")\n            return return_value\n\n    def decrypt_check(self, decrypted_U, decrypted_V):\n        \"\"\"Decrypt the Cloud init script with the passed U and V values.\n\n        This method will access the received auth tag, and may fail if decoy U and V values were received.\n        Do not call directly unless you acquire uvLock. Returns None if decryption unsuccessful, else returns the\n        decrypted agent UUID.\n        \"\"\"\n\n        if self.auth_tag is None:\n            return None\n\n        if len(decrypted_U) != len(decrypted_V):\n            logger.warning(\"Invalid U len %d or V len %d. skipping...\", len(decrypted_U), len(decrypted_V))\n            return None\n\n        candidate_key = crypto.strbitxor(decrypted_U, decrypted_V)\n\n        # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n        if config.INSECURE_DEBUG:\n            logger.debug(\"U: %s\", base64.b64encode(decrypted_U))\n            logger.debug(\"V: %s\", base64.b64encode(decrypted_V))\n            logger.debug(\"K: %s\", base64.b64encode(candidate_key))\n\n        logger.debug(\"auth_tag: %s\", self.auth_tag)\n        ex_mac = crypto.do_hmac(candidate_key, self.agent_uuid)\n\n        if ex_mac == self.auth_tag:\n            logger.info(\"Successfully derived K for UUID %s\", self.agent_uuid)\n            self.final_U = decrypted_U\n            self.K = candidate_key\n            return True\n\n        logger.error(\"Failed to derive K for UUID %s\", self.agent_uuid)\n\n        return False\n\n\ndef revocation_listener():\n    \"\"\"\n    This configures and starts the revocation listener. It is designed to be started in a separate process.\n    \"\"\"\n\n    if not config.getboolean('cloud_agent', 'listen_notfications'):\n        return\n\n    secdir = secure_mount.mount()\n\n    cert_path = config.get('cloud_agent', 'revocation_cert')\n    if cert_path == \"default\":\n        cert_path = os.path.join(secdir,\n                                 \"unzipped/RevocationNotifier-cert.crt\")\n    elif cert_path[0] != '/':\n        # if it is a relative, convert to absolute in work_dir\n        cert_path = os.path.abspath(\n            os.path.join(config.WORK_DIR, cert_path))\n\n    # Callback function handling the revocations\n    def perform_actions(revocation):\n        actionlist = []\n\n        # load the actions from inside the keylime module\n        actionlisttxt = config.get('cloud_agent', 'revocation_actions')\n        if actionlisttxt.strip() != \"\":\n            actionlist = actionlisttxt.split(',')\n            actionlist = [\"revocation_actions.%s\" % i for i in actionlist]\n\n        # load actions from unzipped\n        action_list_path = os.path.join(secdir, \"unzipped/action_list\")\n        if os.path.exists(action_list_path):\n            with open(action_list_path, encoding=\"utf-8\") as f:\n                actionlisttxt = f.read()\n            if actionlisttxt.strip() != \"\":\n                localactions = actionlisttxt.strip().split(',')\n                for action in localactions:\n                    if not action.startswith('local_action_'):\n                        logger.warning(\"Invalid local action: %s. Must start with local_action_\", action)\n                    else:\n                        actionlist.append(action)\n\n                uzpath = \"%s/unzipped\" % secdir\n                if uzpath not in sys.path:\n                    sys.path.append(uzpath)\n\n        for action in actionlist:\n            logger.info(\"Executing revocation action %s\", action)\n            try:\n                module = importlib.import_module(action)\n                execute = getattr(module, 'execute')\n                asyncio.get_event_loop().run_until_complete(execute(revocation))\n            except Exception as e:\n                logger.warning(\"Exception during execution of revocation action %s: %s\", action, e)\n\n    try:\n        while True:\n            try:\n                revocation_notifier.await_notifications(\n                    perform_actions, revocation_cert_path=cert_path)\n            except Exception as e:\n                logger.exception(e)\n                logger.warning(\"No connection to revocation server, retrying in 10s...\")\n                time.sleep(10)\n    except (KeyboardInterrupt, SystemExit):\n        logger.info(\"Stopping revocation listener...\")\n\n\ndef main():\n    for ML in [config.MEASUREDBOOT_ML, config.IMA_ML]:\n        if not os.access(ML, os.F_OK):\n            logger.warning(\"Measurement list path %s not accessible by agent. Any attempt to instruct it to access this path - via \\\"keylime_tenant\\\" CLI - will result in agent process dying\", ML)\n\n    if config.get('cloud_agent', 'agent_uuid') == 'dmidecode':\n        if os.getuid() != 0:\n            raise RuntimeError('agent_uuid is configured to use dmidecode, '\n                               'but current process is not running as root.')\n        cmd = ['which', 'dmidecode']\n        ret = cmd_exec.run(cmd, raiseOnError=False)\n        if ret['code'] != 0:\n            raise RuntimeError('agent_uuid is configured to use dmidecode, '\n                               'but it\\'s is not found on the system.')\n\n    # Instanitate TPM class\n\n    instance_tpm = tpm()\n    # get params for initialization\n    registrar_ip = config.get('cloud_agent', 'registrar_ip')\n    registrar_port = config.get('cloud_agent', 'registrar_port')\n\n    # get params for the verifier to contact the agent\n    contact_ip = os.getenv(\"KEYLIME_AGENT_CONTACT_IP\", None)\n    if contact_ip is None and config.has_option('cloud_agent', 'agent_contact_ip'):\n        contact_ip = config.get('cloud_agent', 'agent_contact_ip')\n    contact_port = os.getenv(\"KEYLIME_AGENT_CONTACT_PORT\", None)\n    if contact_port is None and config.has_option('cloud_agent', 'agent_contact_port'):\n        contact_port = config.get('cloud_agent', 'agent_contact_port', fallback=\"invalid\")\n\n    # initialize the tmpfs partition to store keys if it isn't already available\n    secure_mount.mount()\n\n    # change dir to working dir\n    config.ch_dir(config.WORK_DIR, logger)\n\n    # initialize tpm\n    (ekcert, ek_tpm, aik_tpm) = instance_tpm.tpm_init(self_activate=False, config_pw=config.get(\n        'cloud_agent', 'tpm_ownerpassword'))  # this tells initialize not to self activate the AIK\n    virtual_agent = instance_tpm.is_vtpm()\n\n    # Warn if kernel version is <5.10 and another algorithm than SHA1 is used,\n    # because otherwise IMA will not work\n    kernel_version = tuple(platform.release().split(\"-\")[0].split(\".\"))\n    if tuple(map(int,kernel_version)) < (5, 10, 0) and instance_tpm.defaults[\"hash\"] != algorithms.Hash.SHA1:\n        logger.warning(\"IMA attestation only works on kernel versions <5.10 with SHA1 as hash algorithm. \"\n                       \"Even if ascii_runtime_measurements shows \\\"%s\\\" as the \"\n                       \"algorithm, it might be just padding zeros\", (instance_tpm.defaults[\"hash\"]))\n\n    if ekcert is None:\n        if virtual_agent:\n            ekcert = 'virtual'\n        elif instance_tpm.is_emulator():\n            ekcert = 'emulator'\n\n    # now we need the UUID\n    try:\n        agent_uuid = config.get('cloud_agent', 'agent_uuid')\n    except configparser.NoOptionError:\n        agent_uuid = None\n    if agent_uuid == 'hash_ek':\n        ek_pubkey = pubkey_from_tpm2b_public(base64.b64decode(ek_tpm))\n        ek_pubkey_pem = ek_pubkey.public_bytes(encoding=serialization.Encoding.PEM,\n                                               format=serialization.PublicFormat.SubjectPublicKeyInfo)\n        agent_uuid = hashlib.sha256(ek_pubkey_pem).hexdigest()\n    elif agent_uuid == 'generate' or agent_uuid is None:\n        agent_uuid = str(uuid.uuid4())\n    elif agent_uuid == 'dmidecode':\n        cmd = ['dmidecode', '-s', 'system-uuid']\n        ret = cmd_exec.run(cmd)\n        sys_uuid = ret['retout'][0].decode('utf-8')\n        agent_uuid = sys_uuid.strip()\n        try:\n            uuid.UUID(agent_uuid)\n        except ValueError as e:\n            raise RuntimeError(\"The UUID returned from dmidecode is invalid: %s\" % e)  # pylint: disable=raise-missing-from\n    elif agent_uuid == 'hostname':\n        agent_uuid = socket.getfqdn()\n    elif agent_uuid == 'environment':\n        agent_uuid = os.getenv(\"KEYLIME_AGENT_UUID\", None)\n        if agent_uuid is None:\n            raise RuntimeError(\"Env variable KEYLIME_AGENT_UUID is empty, but agent_uuid is set to 'environment'\")\n\n    if config.STUB_VTPM and config.TPM_CANNED_VALUES is not None:\n        # Use canned values for stubbing\n        jsonIn = config.TPM_CANNED_VALUES\n        if \"add_vtpm_to_group\" in jsonIn:\n            # The value we're looking for has been canned!\n            agent_uuid = jsonIn['add_vtpm_to_group']['retout']\n        else:\n            # Our command hasn't been canned!\n            raise Exception(\"Command %s not found in canned json!\" %\n                            (\"add_vtpm_to_group\"))\n\n    logger.info(\"Agent UUID: %s\", agent_uuid)\n\n    serveraddr = (config.get('cloud_agent', 'cloudagent_ip'),\n                  config.getint('cloud_agent', 'cloudagent_port'))\n\n    keylime_ca = config.get('cloud_agent', 'keylime_ca')\n    if keylime_ca == \"default\":\n        keylime_ca = os.path.join(config.WORK_DIR, 'cv_ca', 'cacert.crt')\n\n    server = CloudAgentHTTPServer(serveraddr, Handler, agent_uuid)\n    context = web_util.generate_mtls_context(server.mtls_cert_path, server.rsakey_path, keylime_ca, logger=logger)\n    server.socket = context.wrap_socket(server.socket, server_side=True)\n    serverthread = threading.Thread(target=server.serve_forever, daemon=True)\n\n    # register it and get back a blob\n    mtls_cert = server.mtls_cert.public_bytes(serialization.Encoding.PEM)\n    keyblob = registrar_client.doRegisterAgent(\n        registrar_ip, registrar_port, agent_uuid, ek_tpm, ekcert, aik_tpm, mtls_cert, contact_ip, contact_port)\n\n    if keyblob is None:\n        instance_tpm.flush_keys()\n        raise Exception(\"Registration failed\")\n\n    # get the ephemeral registrar key\n    key = instance_tpm.activate_identity(keyblob)\n\n    if key is None:\n        instance_tpm.flush_keys()\n        raise Exception(\"Activation failed\")\n\n    # tell the registrar server we know the key\n    retval = registrar_client.doActivateAgent(\n        registrar_ip, registrar_port, agent_uuid, key)\n\n    if not retval:\n        instance_tpm.flush_keys()\n        raise Exception(\"Registration failed on activate\")\n\n    # Start revocation listener in a new process to not interfere with tornado\n    revocation_process = multiprocessing.Process(target=revocation_listener, daemon=True)\n    revocation_process.start()\n\n    logger.info(\"Starting Cloud Agent on %s:%s with API version %s. Use <Ctrl-C> to stop\", serveraddr[0], serveraddr[1], keylime_api_version.current_version())\n    serverthread.start()\n\n    def shutdown_handler(*_):\n        logger.info(\"TERM Signal received, shutting down...\")\n        logger.debug(\"Stopping revocation notifier...\")\n        revocation_process.terminate()\n        logger.debug(\"Shutting down HTTP server...\")\n        server.shutdown()\n        server.server_close()\n        serverthread.join()\n        logger.debug(\"...HTTP server stopped\")\n        revocation_process.join()\n        logger.debug(\"... revocation notifier stopped\")\n        instance_tpm.flush_keys()\n        logger.debug(\"Flushed keys successfully\")\n        sys.exit(0)\n\n    signal.signal(signal.SIGTERM, shutdown_handler)\n    signal.signal(signal.SIGQUIT, shutdown_handler)\n    signal.signal(signal.SIGINT, shutdown_handler)\n\n    # Keep the main thread alive by waiting for the server thread\n    serverthread.join()\n", "'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport base64\nimport ipaddress\nimport threading\nimport sys\nimport signal\nimport http.server\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom socketserver import ThreadingMixIn\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm.exc import NoResultFound\n\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.x509 import load_der_x509_certificate\n\nfrom keylime.db.registrar_db import RegistrarMain\nfrom keylime.db.keylime_db import DBEngineManager, SessionManager\nfrom keylime import config\nfrom keylime import crypto\nfrom keylime import json\nfrom keylime.tpm import tpm2_objects\nfrom keylime import keylime_logging\nfrom keylime.tpm.tpm_main import tpm\nfrom keylime import api_version as keylime_api_version\nfrom keylime import web_util\n\nlogger = keylime_logging.init_logging('registrar')\n\n\ntry:\n    engine = DBEngineManager().make_engine('registrar')\nexcept SQLAlchemyError as err:\n    logger.error('Error creating SQL engine: %s', err)\n    sys.exit(1)\n\n\nclass ProtectedHandler(BaseHTTPRequestHandler, SessionManager):\n\n    def do_HEAD(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_PATCH(self):\n        \"\"\"PATCH not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PATCH not supported\")\n\n    def do_GET(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents from the Registrar Server.\n\n        Currently, only agents resources are available for GETing, i.e. /agents. All other GET uri's\n        will return errors. agents requests require a single agent_id parameter which identifies the\n        agent to be returned. If the agent_id is not found, a 404 response is returned.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('GET returning 400 response. uri not supported: %s', self.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is not None:\n            try:\n                agent = session.query(RegistrarMain).filter_by(\n                    agent_id=agent_id).first()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n            if agent is None:\n                web_util.echo_json_response(self, 404, \"agent_id not found\")\n                logger.warning('GET returning 404 response. agent_id %s not found.', agent_id)\n                return\n\n            if not agent.active:\n                web_util.echo_json_response(self, 404, \"agent_id not yet active\")\n                logger.warning('GET returning 404 response. agent_id %s not yet active.', agent_id)\n                return\n\n            response = {\n                'aik_tpm': agent.aik_tpm,\n                'ek_tpm': agent.ek_tpm,\n                'ekcert': agent.ekcert,\n                'mtls_cert': agent.mtls_cert,\n                'ip': agent.ip,\n                'port': agent.port,\n                'regcount': agent.regcount,\n            }\n\n            if agent.virtual:\n                response['provider_keys'] = agent.provider_keys\n\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info('GET returning 200 response for agent_id: %s', agent_id)\n        else:\n            # return the available registered uuids from the DB\n            json_response = session.query(RegistrarMain.agent_id).all()\n            return_response = [item[0] for item in json_response]\n            web_util.echo_json_response(self, 200, \"Success\", {\n                                      'uuids': return_response})\n            logger.info('GET returning 200 response for agent_id list')\n\n        return\n\n    def do_POST(self):\n        \"\"\"POST not supported\"\"\"\n        web_util.echo_json_response(\n            self, 405, \"POST not supported via TLS interface\")\n\n    def do_PUT(self):\n        \"\"\"PUT not supported\"\"\"\n        web_util.echo_json_response(\n            self, 405, \"PUT not supported via TLS interface\")\n\n    def do_DELETE(self):\n        \"\"\"This method handles the DELETE requests to remove agents from the Registrar Server.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning('DELETE agent returning 400 response. uri not supported: %s', self.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is not None:\n            if session.query(RegistrarMain).filter_by(agent_id=agent_id).delete():\n                # send response\n                try:\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                web_util.echo_json_response(self, 200, \"Success\")\n                return\n\n            # send response\n            web_util.echo_json_response(self, 404)\n            return\n\n        web_util.echo_json_response(self, 404)\n\n    # pylint: disable=W0622\n    def log_message(self, format, *args):\n        return\n\n\nclass UnprotectedHandler(BaseHTTPRequestHandler, SessionManager):\n\n    def do_HEAD(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_PATCH(self):\n        \"\"\"PATCH not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PATCH not supported\")\n\n    def do_GET(self):\n        \"\"\"This method handles the GET requests to the unprotected side of the Registrar Server\n\n        Currently the only supported path is /versions which shows the supported API versions\n        \"\"\"\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /version/ interface\")\n            return\n\n        if \"version\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning('GET agent returning 400 response. URI not supported: %s', self.path)\n            return\n\n        version_info = {\n            \"current_version\": keylime_api_version.current_version(),\n            \"supported_versions\": keylime_api_version.all_versions(),\n        }\n\n        web_util.echo_json_response(self, 200, \"Success\", version_info)\n\n    def do_POST(self):\n        \"\"\"This method handles the POST requests to add agents to the Registrar Server.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's\n        will return errors. POST requests require an an agent_id identifying the agent to add, and json\n        block sent in the body with 2 entries: ek and aik.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('POST agent returning 400 response. uri not supported: %s', self.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            web_util.echo_json_response(self, 400, \"agent id not found in uri\")\n            logger.warning('POST agent returning 400 response. agent id not found in uri %s', self.path)\n            return\n\n        try:\n            content_length = int(self.headers.get('Content-Length', 0))\n            if content_length == 0:\n                web_util.echo_json_response(\n                    self, 400, \"Expected non zero content length\")\n                logger.warning('POST for %s returning 400 response. Expected non zero content length.', agent_id)\n                return\n\n            post_body = self.rfile.read(content_length)\n            json_body = json.loads(post_body)\n\n            ekcert = json_body['ekcert']\n            aik_tpm = json_body['aik_tpm']\n\n            initialize_tpm = tpm()\n\n            if ekcert is None or ekcert == 'emulator':\n                logger.warning('Agent %s did not submit an ekcert' % agent_id)\n                ek_tpm = json_body['ek_tpm']\n            else:\n                if 'ek_tpm' in json_body:\n                    # This would mean the agent submitted both a non-None ekcert, *and*\n                    #  an ek_tpm... We can deal with it by just ignoring the ek_tpm they sent\n                    logger.warning('Overriding ek_tpm for agent %s from ekcert' % agent_id)\n                # If there's an EKCert, we just overwrite their ek_tpm\n                # Note, we don't validate the EKCert here, other than the implicit\n                #  \"is it a valid x509 cert\" check. So it's still untrusted.\n                # This will be validated by the tenant.\n                ek509 = load_der_x509_certificate(\n                    base64.b64decode(ekcert),\n                    backend=default_backend(),\n                )\n                ek_tpm = base64.b64encode(\n                    tpm2_objects.ek_low_tpm2b_public_from_pubkey(\n                        ek509.public_key(),\n                    )\n                )\n\n            aik_attrs = tpm2_objects.get_tpm2b_public_object_attributes(\n                base64.b64decode(aik_tpm),\n            )\n            if aik_attrs != tpm2_objects.AK_EXPECTED_ATTRS:\n                web_util.echo_json_response(\n                    self, 400, \"Invalid AK attributes\")\n                logger.warning(\n                    \"Agent %s submitted AIK with invalid attributes! %s (provided) != %s (expected)\",\n                    agent_id,\n                    tpm2_objects.object_attributes_description(aik_attrs),\n                    tpm2_objects.object_attributes_description(tpm2_objects.AK_EXPECTED_ATTRS),\n                )\n                return\n\n            # try to encrypt the AIK\n            (blob, key) = initialize_tpm.encryptAIK(\n                agent_id,\n                base64.b64decode(ek_tpm),\n                base64.b64decode(aik_tpm),\n            )\n\n            # special behavior if we've registered this uuid before\n            regcount = 1\n            try:\n                agent = session.query(RegistrarMain).filter_by(\n                    agent_id=agent_id).first()\n            except NoResultFound:\n                agent = None\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise\n\n            if agent is not None:\n\n                # keep track of how many ek-ekcerts have registered on this uuid\n                regcount = agent.regcount\n                if agent.ek_tpm != ek_tpm or agent.ekcert != ekcert:\n                    logger.warning('WARNING: Overwriting previous registration for this UUID with new ek-ekcert pair!')\n                    regcount += 1\n\n                # force overwrite\n                logger.info('Overwriting previous registration for this UUID.')\n                try:\n                    session.query(RegistrarMain).filter_by(\n                        agent_id=agent_id).delete()\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                    raise\n            # Check for ip and port\n            contact_ip = json_body.get('ip', None)\n            contact_port = json_body.get('port', None)\n\n            # Validate ip and port\n            if contact_ip is not None:\n                try:\n                    # Use parser from the standard library instead of implementing our own\n                    ipaddress.ip_address(contact_ip)\n                except ValueError:\n                    logger.warning(f\"Contact ip for agent {agent_id} is not a valid ip got: {contact_ip}.\")\n                    contact_ip = None\n            if contact_port is not None:\n                try:\n                    contact_port = int(contact_port)\n                    if contact_port < 1 or contact_port > 65535:\n                        logger.warning(f\"Contact port for agent {agent_id} is not a number between 1 and got: {contact_port}.\")\n                        contact_port = None\n                except ValueError:\n                    logger.warning(f\"Contact port for agent {agent_id} is not a valid number got: {contact_port}.\")\n                    contact_port = None\n\n            # Check for mTLS cert\n            mtls_cert = json_body.get('mtls_cert', None)\n            if mtls_cert is None:\n                logger.warning(f\"Agent {agent_id} did not sent a mTLS certificate. Most operations will not work!\")\n\n            # Add values to database\n            d = {}\n            d['agent_id'] = agent_id\n            d['ek_tpm'] = ek_tpm\n            d['aik_tpm'] = aik_tpm\n            d['ekcert'] = ekcert\n            d['ip'] = contact_ip\n            d['mtls_cert'] = mtls_cert\n            d['port'] = contact_port\n            d['virtual'] = int(ekcert == 'virtual')\n            d['active'] = int(False)\n            d['key'] = key\n            d['provider_keys'] = {}\n            d['regcount'] = regcount\n\n\n            try:\n                session.add(RegistrarMain(**d))\n                session.commit()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise\n\n            response = {\n                'blob': blob,\n            }\n            web_util.echo_json_response(self, 200, \"Success\", response)\n\n            logger.info('POST returning key blob for agent_id: %s', agent_id)\n        except Exception as e:\n            web_util.echo_json_response(self, 400, \"Error: %s\" % e)\n            logger.warning(\"POST for %s returning 400 response. Error: %s\", agent_id, e)\n            logger.exception(e)\n\n    def do_PUT(self):\n        \"\"\"This method handles the PUT requests to add agents to the Registrar Server.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's\n        will return errors.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('PUT agent returning 400 response. uri not supported: %s', self.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            web_util.echo_json_response(self, 400, \"agent id not found in uri\")\n            logger.warning('PUT agent returning 400 response. agent id not found in uri %s', self.path)\n            return\n\n        try:\n            content_length = int(self.headers.get('Content-Length', 0))\n            if content_length == 0:\n                web_util.echo_json_response(\n                    self, 400, \"Expected non zero content length\")\n                logger.warning('PUT for %s returning 400 response. Expected non zero content length.', agent_id)\n                return\n\n            post_body = self.rfile.read(content_length)\n            json_body = json.loads(post_body)\n\n            auth_tag = json_body['auth_tag']\n            try:\n                agent = session.query(RegistrarMain).filter_by(\n                    agent_id=agent_id).first()\n            except NoResultFound as e:\n                raise Exception(\n                    \"attempting to activate agent before requesting \"\n                    \"registrar for %s\" % agent_id) from e\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise\n\n            if config.STUB_TPM:\n                try:\n                    session.query(RegistrarMain).filter(RegistrarMain.agent_id == agent_id).update(\n                        {'active': True})\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                    raise\n            else:\n                # TODO(kaifeng) Special handling should be removed\n                if engine.dialect.name == \"mysql\":\n                    agent.key = agent.key.encode('utf-8')\n\n                ex_mac = crypto.do_hmac(agent.key, agent_id)\n                if ex_mac == auth_tag:\n                    try:\n                        session.query(RegistrarMain).filter(RegistrarMain.agent_id == agent_id).update(\n                            {'active': True})\n                        session.commit()\n                    except SQLAlchemyError as e:\n                        logger.error('SQLAlchemy Error: %s', e)\n                        raise\n                else:\n                    raise Exception(\n                        f\"Auth tag {auth_tag} does not match expected value {ex_mac}\")\n\n            web_util.echo_json_response(self, 200, \"Success\")\n            logger.info('PUT activated: %s', agent_id)\n        except Exception as e:\n            web_util.echo_json_response(self, 400, \"Error: %s\" % e)\n            logger.warning(\"PUT for %s returning 400 response. Error: %s\", agent_id, e)\n            logger.exception(e)\n            return\n\n    def do_DELETE(self):\n        \"\"\"DELETE not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"DELETE not supported\")\n\n    # pylint: disable=W0622\n    def log_message(self, format, *args):\n        return\n\n# consider using PooledProcessMixIn\n# https://github.com/muayyad-alsadi/python-PooledProcessMixIn\n\n\nclass RegistrarServer(ThreadingMixIn, HTTPServer):\n    \"\"\"Handle requests in a separate thread.\"\"\"\n\n    def __init__(self, server_address, RequestHandlerClass):\n        \"\"\"Constructor overridden to provide ability to read file\"\"\"\n        http.server.HTTPServer.__init__(\n            self, server_address, RequestHandlerClass)\n\n    def shutdown(self):\n        http.server.HTTPServer.shutdown(self)\n\n\ndef start(host, tlsport, port):\n    \"\"\"Main method of the Registrar Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    RegistrarMain.metadata.create_all(engine, checkfirst=True)\n    session = SessionManager().make_session(engine)\n    try:\n        count = session.query(RegistrarMain.agent_id).count()\n        if count > 0:\n            logger.info(\"Loaded %d public keys from database\", count)\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\n    # Set up the protected registrar server\n    protected_server = RegistrarServer((host, tlsport), ProtectedHandler)\n    context, _ = web_util.init_mtls(section='registrar', generatedir='reg_ca', logger=logger)\n    if context is not None:\n        protected_server.socket = context.wrap_socket(protected_server.socket, server_side=True)\n    thread_protected_server = threading.Thread(target=protected_server.serve_forever)\n\n    # Set up the unprotected registrar server\n    unprotected_server = RegistrarServer((host, port), UnprotectedHandler)\n    thread_unprotected_server = threading.Thread(target=unprotected_server.serve_forever)\n\n    logger.info('Starting Cloud Registrar Server on ports %s and %s (TLS) use <Ctrl-C> to stop', port, tlsport)\n    keylime_api_version.log_api_versions(logger)\n    thread_protected_server.start()\n    thread_unprotected_server.start()\n\n    def signal_handler(signum, frame):\n        del signum, frame\n        logger.info(\"Shutting down Registrar Server...\")\n        protected_server.shutdown()\n        unprotected_server.shutdown()\n        sys.exit(0)\n\n    # Catch these signals.  Note that a SIGKILL cannot be caught, so\n    # killing this process with \"kill -9\" may result in improper shutdown\n    signal.signal(signal.SIGTERM, signal_handler)\n    signal.signal(signal.SIGQUIT, signal_handler)\n    signal.signal(signal.SIGINT, signal_handler)\n\n    thread_protected_server.join()\n    thread_unprotected_server.join()\n", "#!/usr/bin/python3\n\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport argparse\nimport base64\nimport hashlib\nimport io\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nimport zipfile\nimport json\nimport tempfile\nimport requests\n\nfrom cryptography.hazmat.primitives import serialization as crypto_serialization\n\nfrom keylime.agentstates import AgentAttestState\nfrom keylime.requests_client import RequestsClient\nfrom keylime.common import states\nfrom keylime import config\nfrom keylime import keylime_logging\nfrom keylime import registrar_client\nfrom keylime.tpm import tpm2_objects\nfrom keylime.tpm.tpm_main import tpm\nfrom keylime.tpm.tpm_abstract import TPM_Utilities\nfrom keylime import ima\nfrom keylime import crypto\nfrom keylime.cmd import user_data_encrypt\nfrom keylime import ca_util\nfrom keylime.common import algorithms\nfrom keylime import ima_file_signatures\nfrom keylime import measured_boot\nfrom keylime import gpg\nfrom keylime import api_version as keylime_api_version\n\n# setup logging\nlogger = keylime_logging.init_logging('tenant')\n\n# special exception that suppresses stack traces when it happens\nclass UserError(Exception):\n    pass\n\n\nclass Tenant():\n    \"\"\"Simple command processor example.\"\"\"\n\n    config = None\n\n    cloudverifier_ip = None\n    cloudverifier_port = None\n\n    cloudagent_ip = None\n    cv_cloudagent_ip = None\n    cloudagent_port = None\n\n    registrar_ip = None\n    registrar_port = None\n    registrar_data = None\n\n    webapp_ip = None\n    webapp_port = None\n\n    api_version = None\n\n    uuid_service_generate_locally = None\n    agent_uuid = None\n\n    K = None\n    V = None\n    U = None\n    auth_tag = None\n\n    tpm_policy = None\n    vtpm_policy = {}\n    metadata = {}\n    allowlist = {}\n    ima_sign_verification_keys = []\n    revocation_key = \"\"\n    accept_tpm_hash_algs = []\n    accept_tpm_encryption_algs = []\n    accept_tpm_signing_algs = []\n    mb_refstate = None\n    supported_version = None\n\n    payload = None\n\n    tpm_instance = tpm()\n\n    def __init__(self):\n        \"\"\" Set up required values and TLS\n        \"\"\"\n        self.nonce = None\n        self.agent_ip = None\n        self.verifier_id = None\n        self.agent_port = None\n        self.verifier_ip = config.get('tenant', 'cloudverifier_ip')\n        self.verifier_port = config.get('tenant', 'cloudverifier_port')\n        self.registrar_ip = config.get('tenant', 'registrar_ip')\n        self.registrar_port = config.get('tenant', 'registrar_port')\n        self.webapp_port = config.getint('webapp', 'webapp_port')\n        if not config.REQUIRE_ROOT and self.webapp_port < 1024:\n            self.webapp_port += 2000\n        self.webapp_ip = config.get('webapp', 'webapp_ip')\n\n        self.api_version = keylime_api_version.current_version()\n\n        (self.my_cert, self.my_priv_key), (self.my_agent_cert, self.my_agent_priv_key) = self.get_tls_context()\n        self.cert = (self.my_cert, self.my_priv_key)\n        self.agent_cert = (self.my_agent_cert, self.my_agent_priv_key)\n        if config.getboolean('general', \"enable_tls\"):\n            self.tls_enabled = True\n        else:\n            self.tls_enabled = False\n            self.cert = \"\"\n            logger.warning(\n                \"Warning: TLS is currently disabled, keys will be sent in the clear! This should only be used for testing.\")\n\n    @property\n    def verifier_base_url(self):\n        return f'{self.verifier_ip}:{self.verifier_port}'\n\n    def get_tls_context(self):\n        \"\"\"Generate certifcate naming and path\n\n        Returns:\n            string -- my_cert (client_cert), my_priv_key (client private key)\n        \"\"\"\n        my_cert = config.get('tenant', 'my_cert')\n        my_priv_key = config.get('tenant', 'private_key')\n        tls_dir = config.get('tenant', 'tls_dir')\n\n        if tls_dir == 'default':\n            my_cert = 'client-cert.crt'\n            my_priv_key = 'client-private.pem'\n            tls_dir = 'cv_ca'\n\n        if tls_dir[0] != '/':\n            tls_dir = os.path.abspath(os.path.join(config.WORK_DIR, tls_dir))\n\n        logger.info(\"Setting up client TLS in %s\", tls_dir)\n        my_cert = os.path.join(tls_dir, my_cert)\n        my_priv_key = os.path.join(tls_dir, my_priv_key)\n\n        tls_context = (my_cert, my_priv_key)\n\n        # Check for user defined CA to connect to agent\n        agent_mtls_cert = config.get(\"cloud_verifier\", \"agent_mtls_cert\", fallback=None)\n        agent_mtls_private_key = config.get(\"cloud_verifier\", \"agent_mtls_private_key\", fallback=None)\n\n        agent_mtls_context = tls_context\n        if agent_mtls_cert != \"CV\":\n            agent_mtls_context = (agent_mtls_cert, agent_mtls_private_key)\n\n        return tls_context, agent_mtls_context\n\n    def process_allowlist(self, args):\n        # Set up PCR values\n        tpm_policy = config.get('tenant', 'tpm_policy')\n        if \"tpm_policy\" in args and args[\"tpm_policy\"] is not None:\n            tpm_policy = args[\"tpm_policy\"]\n        self.tpm_policy = TPM_Utilities.readPolicy(tpm_policy)\n        logger.info(\"TPM PCR Mask from policy is %s\", self.tpm_policy['mask'])\n\n        vtpm_policy = config.get('tenant', 'vtpm_policy')\n        if \"vtpm_policy\" in args and args[\"vtpm_policy\"] is not None:\n            vtpm_policy = args[\"vtpm_policy\"]\n        self.vtpm_policy = TPM_Utilities.readPolicy(vtpm_policy)\n        logger.info(\"TPM PCR Mask from policy is %s\", self.vtpm_policy['mask'])\n\n        if len(args.get(\"ima_sign_verification_keys\")) > 0:\n            # Auto-enable IMA (or-bit mask)\n            self.tpm_policy['mask'] = \"0x%X\" % (\n                    int(self.tpm_policy['mask'], 0) | (1 << config.IMA_PCR))\n\n            # Add all IMA file signing verification keys to a keyring\n            tenant_keyring = ima_file_signatures.ImaKeyring()\n            for filename in args[\"ima_sign_verification_keys\"]:\n                pubkey, keyidv2 = ima_file_signatures.get_pubkey_from_file(filename)\n                if not pubkey:\n                    raise UserError(\n                        \"File '%s' is not a file with a key\" % filename)\n                tenant_keyring.add_pubkey(pubkey, keyidv2)\n            self.ima_sign_verification_keys = tenant_keyring.to_string()\n\n        # Read command-line path string allowlist\n        al_data = None\n\n        if \"allowlist\" in args and args[\"allowlist\"] is not None:\n\n            self.enforce_pcrs(list(self.tpm_policy.keys()), [ config.IMA_PCR ], \"IMA\")\n\n            # Auto-enable IMA (or-bit mask)\n            self.tpm_policy['mask'] = \"0x%X\" % (\n                    int(self.tpm_policy['mask'], 0) | (1 << config.IMA_PCR))\n\n            if isinstance(args[\"allowlist\"], str):\n                if args[\"allowlist\"] == \"default\":\n                    args[\"allowlist\"] = config.get('tenant', 'allowlist')\n                al_data = ima.read_allowlist(args[\"allowlist\"], args[\"allowlist_checksum\"], args[\"allowlist_sig\"], args[\"allowlist_sig_key\"])\n            elif isinstance(args[\"allowlist\"], list):\n                al_data = args[\"allowlist\"]\n            else:\n                raise UserError(\"Invalid allowlist provided\")\n\n        # Read command-line path string IMA exclude list\n        excl_data = None\n        if \"ima_exclude\" in args and args[\"ima_exclude\"] is not None:\n            if isinstance(args[\"ima_exclude\"], str):\n                if args[\"ima_exclude\"] == \"default\":\n                    args[\"ima_exclude\"] = config.get(\n                        'tenant', 'ima_excludelist')\n                excl_data = ima.read_excllist(args[\"ima_exclude\"])\n            elif isinstance(args[\"ima_exclude\"], list):\n                excl_data = args[\"ima_exclude\"]\n            else:\n                raise UserError(\"Invalid exclude list provided\")\n\n        # Set up IMA\n        if TPM_Utilities.check_mask(self.tpm_policy['mask'], config.IMA_PCR) or \\\n                TPM_Utilities.check_mask(self.vtpm_policy['mask'],\n                                         config.IMA_PCR):\n            # Process allowlists\n            self.allowlist = ima.process_allowlists(al_data, excl_data)\n\n        # Read command-line path string TPM event log (measured boot) reference state\n        mb_refstate_data = None\n        if \"mb_refstate\" in args and args[\"mb_refstate\"] is not None:\n\n            self.enforce_pcrs(list(self.tpm_policy.keys()), config.MEASUREDBOOT_PCRS, \"measured boot\")\n\n            # Auto-enable TPM event log mesured boot (or-bit mask)\n            for _pcr in config.MEASUREDBOOT_PCRS :\n                self.tpm_policy['mask'] = \"0x%X\" % (\n                    int(self.tpm_policy['mask'], 0) | (1 << _pcr))\n\n            logger.info(\"TPM PCR Mask automatically modified is %s to include IMA/Event log PCRs\", self.tpm_policy['mask'])\n\n            if isinstance(args[\"mb_refstate\"], str):\n                if args[\"mb_refstate\"] == \"default\":\n                    args[\"mb_refstate\"] = config.get('tenant', 'mb_refstate')\n                mb_refstate_data = measured_boot.read_mb_refstate(args[\"mb_refstate\"])\n            else:\n                raise UserError(\"Invalid measured boot reference state (intended state) provided\")\n\n        # Set up measured boot (TPM event log) reference state\n        if TPM_Utilities.check_mask(self.tpm_policy['mask'], config.MEASUREDBOOT_PCRS[2]) :\n            # Process measured boot reference state\n            self.mb_refstate = mb_refstate_data\n\n    def init_add(self, args):\n        \"\"\" Set up required values. Command line options can overwrite these config values\n\n        Arguments:\n            args {[string]} -- agent_ip|agent_port|cv_agent_ip\n        \"\"\"\n        if \"agent_ip\" in args:\n            self.agent_ip = args[\"agent_ip\"]\n\n        if 'agent_port' in args and args['agent_port'] is not None:\n            self.agent_port = args['agent_port']\n\n        registrar_client.init_client_tls(\"tenant\")\n        self.registrar_data = registrar_client.getData(self.registrar_ip, self.registrar_port, self.agent_uuid)\n\n        # try to get the port or ip from the registrar if it is missing\n        if (self.agent_ip is None or self.agent_port is None) and self.registrar_data is not None:\n            if self.agent_ip is None:\n                if self.registrar_data['ip'] is not None:\n                    self.agent_ip = self.registrar_data['ip']\n                else:\n                    raise UserError(\"No Ip was specified or found in the Registrar\")\n\n            if self.agent_port is None and self.registrar_data['port'] is not None:\n                self.agent_port = self.registrar_data[\"port\"]\n\n        # If no agent port was found try to use the default from the config file\n        if self.agent_port is None:\n            self.agent_port = config.get('cloud_agent', 'cloudagent_port')\n\n        # Check if a contact ip and port for the agent was found\n        if self.agent_ip is None:\n            raise UserError(\"The contact ip address for the agent was not specified.\")\n\n        if self.agent_port is None:\n            raise UserError(\"The contact port for the agent was not specified.\")\n\n        # Auto-detection for API version\n        self.supported_version = args[\"supported_version\"]\n        if self.supported_version is None:\n            # Default to 1.0 if the agent did not send a mTLS certificate\n            if self.registrar_data.get(\"mtls_cert\", None) is None:\n                self.supported_version = \"1.0\"\n            else:\n                # Try to connect to the agent to get supported version\n                with RequestsClient(f\"{self.agent_ip}:{self.agent_port}\", tls_enabled=True, cert=self.agent_cert,\n                                    ignore_hostname=True, verify_custom=self.registrar_data['mtls_cert']) as get_version:\n                    res = get_version.get(\"/version\")\n                    if res and res.status_code == 200:\n                        try:\n                            data = res.json()\n                            api_version = data[\"results\"][\"supported_version\"]\n                            if keylime_api_version.validate_version(api_version):\n                                self.supported_version = api_version\n                            else:\n                                logger.warning(\"API version provided by the agent is not valid\")\n                        except (TypeError, KeyError):\n                            pass\n\n        if self.supported_version is None:\n            api_version = keylime_api_version.current_version()\n            logger.warning(\"Could not detect supported API version. Defaulting to %s\", api_version)\n            self.supported_version = api_version\n\n        # Now set the cv_agent_ip\n        if 'cv_agent_ip' in args and args['cv_agent_ip'] is not None:\n            self.cv_cloudagent_ip = args['cv_agent_ip']\n        else:\n            self.cv_cloudagent_ip = self.agent_ip\n\n        # Make sure all keys exist in dictionary\n        if \"file\" not in args:\n            args[\"file\"] = None\n        if \"keyfile\" not in args:\n            args[\"keyfile\"] = None\n        if \"payload\" not in args:\n            args[\"payload\"] = None\n        if \"ca_dir\" not in args:\n            args[\"ca_dir\"] = None\n        if \"incl_dir\" not in args:\n            args[\"incl_dir\"] = None\n        if \"ca_dir_pw\" not in args:\n            args[\"ca_dir_pw\"] = None\n\n        # Set up accepted algorithms\n        self.accept_tpm_hash_algs = config.get(\n            'tenant', 'accept_tpm_hash_algs').split(',')\n        self.accept_tpm_encryption_algs = config.get(\n            'tenant', 'accept_tpm_encryption_algs').split(',')\n        self.accept_tpm_signing_algs = config.get(\n            'tenant', 'accept_tpm_signing_algs').split(',')\n\n        self.process_allowlist(args)\n\n        # if none\n        if (args[\"file\"] is None and args[\"keyfile\"] is None and args[\"ca_dir\"] is None):\n            raise UserError(\n                \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n        if args[\"keyfile\"] is not None:\n            if args[\"file\"] is not None or args[\"ca_dir\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n            # read the keys in\n            if isinstance(args[\"keyfile\"], dict) and \"data\" in args[\"keyfile\"]:\n                if isinstance(args[\"keyfile\"][\"data\"], list) and len(args[\"keyfile\"][\"data\"]) == 1:\n                    keyfile = args[\"keyfile\"][\"data\"][0]\n                    if keyfile is None:\n                        raise UserError(\"Invalid key file contents\")\n                    f = io.StringIO(keyfile)\n                else:\n                    raise UserError(\"Invalid key file provided\")\n            else:\n                f = open(args[\"keyfile\"], encoding=\"utf-8\")\n            self.K = base64.b64decode(f.readline())\n            self.U = base64.b64decode(f.readline())\n            self.V = base64.b64decode(f.readline())\n            f.close()\n\n            # read the payload in (opt.)\n            if isinstance(args[\"payload\"], dict) and \"data\" in args[\"payload\"]:\n                if isinstance(args[\"payload\"][\"data\"], list) and len(args[\"payload\"][\"data\"]) > 0:\n                    self.payload = args[\"payload\"][\"data\"][0]\n            else:\n                if args[\"payload\"] is not None:\n                    f = open(args[\"payload\"], 'rb')\n                    self.payload = f.read()\n                    f.close()\n\n        if args[\"file\"] is not None:\n            if args[\"keyfile\"] is not None or args[\"ca_dir\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n            if isinstance(args[\"file\"], dict) and \"data\" in args[\"file\"]:\n                if isinstance(args[\"file\"][\"data\"], list) and len(args[\"file\"][\"data\"]) > 0:\n                    contents = args[\"file\"][\"data\"][0]\n                    if contents is None:\n                        raise UserError(\"Invalid file payload contents\")\n                else:\n                    raise UserError(\"Invalid file payload provided\")\n            else:\n                with open(args[\"file\"], encoding=\"utf-8\") as f:\n                    contents = f.read()\n            ret = user_data_encrypt.encrypt(contents)\n            self.K = ret['k']\n            self.U = ret['u']\n            self.V = ret['v']\n            self.payload = ret['ciphertext']\n\n        if args[\"ca_dir\"] is None and args[\"incl_dir\"] is not None:\n            raise UserError(\n                \"--include option is only valid when used with --cert\")\n        if args[\"ca_dir\"] is not None:\n            if args[\"file\"] is not None or args[\"keyfile\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n            if args[\"ca_dir\"] == 'default':\n                args[\"ca_dir\"] = config.CA_WORK_DIR\n\n            if \"ca_dir_pw\" in args and args[\"ca_dir_pw\"] is not None:\n                ca_util.setpassword(args[\"ca_dir_pw\"])\n\n            if not os.path.exists(args[\"ca_dir\"]) or not os.path.exists(\"%s/cacert.crt\" % args[\"ca_dir\"]):\n                logger.warning(\"CA directory does not exist. Creating...\")\n                ca_util.cmd_init(args[\"ca_dir\"])\n            if not os.path.exists(\n                    os.path.join(args[\"ca_dir\"],\n                                 f\"{self.agent_uuid}-private.pem\")):\n                ca_util.cmd_mkcert(args[\"ca_dir\"], self.agent_uuid)\n\n            cert_pkg, serial, subject = ca_util.cmd_certpkg(\n                args[\"ca_dir\"], self.agent_uuid)\n\n            # support revocation\n            if not os.path.exists(\"%s/RevocationNotifier-private.pem\" % args[\"ca_dir\"]):\n                ca_util.cmd_mkcert(args[\"ca_dir\"], \"RevocationNotifier\")\n            rev_package, _, _ = ca_util.cmd_certpkg(\n                args[\"ca_dir\"], \"RevocationNotifier\")\n\n            # extract public and private keys from package\n            sf = io.BytesIO(rev_package)\n            with zipfile.ZipFile(sf) as zf:\n                privkey = zf.read(\"RevocationNotifier-private.pem\")\n                cert = zf.read(\"RevocationNotifier-cert.crt\")\n\n            # put the cert of the revoker into the cert package\n            sf = io.BytesIO(cert_pkg)\n            with zipfile.ZipFile(sf, 'a', compression=zipfile.ZIP_STORED) as zf:\n                zf.writestr('RevocationNotifier-cert.crt', cert)\n\n                # add additional files to zip\n                if args[\"incl_dir\"] is not None:\n                    if isinstance(args[\"incl_dir\"], dict) and \"data\" in args[\"incl_dir\"] and \"name\" in args[\"incl_dir\"]:\n                        if isinstance(args[\"incl_dir\"][\"data\"], list) and isinstance(args[\"incl_dir\"][\"name\"], list):\n                            if len(args[\"incl_dir\"][\"data\"]) != len(args[\"incl_dir\"][\"name\"]):\n                                raise UserError(\"Invalid incl_dir provided\")\n                            for i in range(len(args[\"incl_dir\"][\"data\"])):\n                                zf.writestr(os.path.basename(\n                                    args[\"incl_dir\"][\"name\"][i]), args[\"incl_dir\"][\"data\"][i])\n                    else:\n                        if os.path.exists(args[\"incl_dir\"]):\n                            files = next(os.walk(args[\"incl_dir\"]))[2]\n                            for filename in files:\n                                with open(os.path.join(args[\"incl_dir\"],\n                                                       filename), 'rb') as f:\n                                    zf.writestr(\n                                        os.path.basename(f.name), f.read())\n                        else:\n                            logger.warning('Specified include directory %s does not exist. Skipping...', args[\"incl_dir\"])\n\n            cert_pkg = sf.getvalue()\n\n            # put the private key into the data to be send to the CV\n            self.revocation_key = privkey.decode('utf-8')\n\n            # encrypt up the cert package\n            ret = user_data_encrypt.encrypt(cert_pkg)\n            self.K = ret['k']\n            self.U = ret['u']\n            self.V = ret['v']\n            self.metadata = {'cert_serial': serial, 'subject': subject}\n            self.payload = ret['ciphertext']\n\n        if self.payload is not None and len(self.payload) > config.getint('tenant', 'max_payload_size'):\n            raise UserError(\"Payload size %s exceeds max size %d\" % (\n                len(self.payload), config.getint('tenant', 'max_payload_size')))\n\n    def enforce_pcrs(self, policy_pcrs, protected_pcrs, pcr_use) :\n        policy_pcrs = list(self.tpm_policy.keys())\n        policy_pcrs.remove('mask')\n\n        for _pcr in policy_pcrs :\n            if int(_pcr) in protected_pcrs :\n                logger.error('WARNING: PCR %s is specified in \"tpm_policy\", but will in fact be used by %s. Please remove it from policy', _pcr, pcr_use)\n                sys.exit(1)\n\n    def preloop(self):\n        \"\"\" encrypt the agent UUID as a check for delivering the correct key\n        \"\"\"\n        self.auth_tag = crypto.do_hmac(self.K, self.agent_uuid)\n        # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n        if config.INSECURE_DEBUG:\n            logger.debug(\"K: %s\", base64.b64encode(self.K))\n            logger.debug(\"V: %s\", base64.b64encode(self.V))\n            logger.debug(\"U: %s\", base64.b64encode(self.U))\n            logger.debug(\"Auth Tag: %s\", self.auth_tag)\n\n    def check_ek(self, ekcert):\n        \"\"\" Check the Entity Key\n\n        Arguments:\n            ekcert {str} -- The endorsement key, either None, \"emulator\", or base64 encoded der cert\n\n        Returns:\n            [type] -- [description]\n        \"\"\"\n        if config.getboolean('tenant', 'require_ek_cert'):\n            if config.STUB_TPM:\n                logger.debug(\"Not checking ekcert due to STUB_TPM mode\")\n            elif ekcert == 'emulator' and config.DISABLE_EK_CERT_CHECK_EMULATOR:\n                logger.info(\"Not checking ekcert of TPM emulator\")\n            elif ekcert is None:\n                logger.warning(\"No EK cert provided, require_ek_cert option in config set to True\")\n                return False\n            elif not self.tpm_instance.verify_ek(base64.b64decode(ekcert)):\n                logger.warning(\"Invalid EK certificate\")\n                return False\n\n        return True\n\n    def validate_tpm_quote(self, public_key, quote, hash_alg):\n        \"\"\" Validate TPM Quote received from the Agent\n\n        Arguments:\n            public_key {[type]} -- [description]\n            quote {[type]} -- [description]\n            hash_alg {bool} -- [description]\n\n        Raises:\n            UserError: [description]\n\n        Returns:\n            [type] -- [description]\n        \"\"\"\n        registrar_client.init_client_tls('tenant')\n        if self.registrar_data is None:\n            logger.warning(\"AIK not found in registrar, quote not validated\")\n            return False\n\n        failure = self.tpm_instance.check_quote(AgentAttestState(self.agent_uuid), self.nonce, public_key, quote,\n                                                self.registrar_data['aik_tpm'], hash_alg=hash_alg,\n                                                compressed=(self.supported_version == \"1.0\"))\n        if failure:\n            if self.registrar_data['regcount'] > 1:\n                logger.error(\"WARNING: This UUID had more than one ek-ekcert registered to it! This might indicate that your system is misconfigured or a malicious host is present. Run 'regdelete' for this agent and restart\")\n                sys.exit()\n            return False\n\n        if self.registrar_data['regcount'] > 1:\n            logger.warning(\"WARNING: This UUID had more than one ek-ekcert registered to it! This might indicate that your system is misconfigured. Run 'regdelete' for this agent and restart\")\n\n        if not config.STUB_TPM and (not config.getboolean('tenant', 'require_ek_cert') and config.get('tenant', 'ek_check_script') == \"\"):\n            logger.warning(\n                \"DANGER: EK cert checking is disabled and no additional checks on EKs have been specified with ek_check_script option. Keylime is not secure!!\")\n\n        # check EK cert and make sure it matches EK\n        if not self.check_ek(self.registrar_data['ekcert']):\n            return False\n        # if agent is virtual, check phyisical EK cert and make sure it matches phyiscal EK\n        if 'provider_keys' in self.registrar_data:\n            if not self.check_ek(self.registrar_data['provider_keys']['ekcert']):\n                return False\n\n        # check all EKs with optional script:\n        script = config.get('tenant', 'ek_check_script')\n        if not script:\n            return True\n\n        if script[0] != '/':\n            script = os.path.join(config.WORK_DIR, script)\n\n        logger.info(\"Checking EK with script %s\", script)\n        # now we need to exec the script with the ek and ek cert in vars\n        env = os.environ.copy()\n        env['AGENT_UUID'] = self.agent_uuid\n        env['EK'] = tpm2_objects.pubkey_from_tpm2b_public(\n            base64.b64decode(self.registrar_data['ek_tpm']),\n            ).public_bytes(\n                crypto_serialization.Encoding.PEM,\n                crypto_serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n        env['EK_TPM'] = self.registrar_data['ek_tpm']\n        if self.registrar_data['ekcert'] is not None:\n            env['EK_CERT'] = self.registrar_data['ekcert']\n        else:\n            env['EK_CERT'] = \"\"\n\n        env['PROVKEYS'] = json.dumps(self.registrar_data.get('provider_keys', {}))\n        proc = subprocess.Popen(script, env=env, shell=True,\n                                cwd=config.WORK_DIR, stdout=subprocess.PIPE,\n                                stderr=subprocess.STDOUT)\n        retval = proc.wait()\n        if retval != 0:\n            raise UserError(\"External check script failed to validate EK\")\n        logger.debug(\"External check script successfully to validated EK\")\n        while True:\n            line = proc.stdout.readline().decode()\n            if line == \"\":\n                break\n            logger.debug(\"ek_check output: %s\", line.strip())\n        return True\n\n    def do_cv(self):\n        \"\"\" Initiaite v, agent_id and ip and initiate the cloudinit sequence\n        \"\"\"\n        b64_v = base64.b64encode(self.V).decode('utf-8')\n        logger.debug(\"b64_v: %s\", b64_v)\n        data = {\n            'v': b64_v,\n            'cloudagent_ip': self.cv_cloudagent_ip,\n            'cloudagent_port': self.agent_port,\n            'tpm_policy': json.dumps(self.tpm_policy),\n            'vtpm_policy': json.dumps(self.vtpm_policy),\n            'allowlist': json.dumps(self.allowlist),\n            'mb_refstate': json.dumps(self.mb_refstate),\n            'ima_sign_verification_keys': json.dumps(self.ima_sign_verification_keys),\n            'metadata': json.dumps(self.metadata),\n            'revocation_key': self.revocation_key,\n            'accept_tpm_hash_algs': self.accept_tpm_hash_algs,\n            'accept_tpm_encryption_algs': self.accept_tpm_encryption_algs,\n            'accept_tpm_signing_algs': self.accept_tpm_signing_algs,\n            'supported_version': self.supported_version,\n        }\n        json_message = json.dumps(data)\n        do_cv = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = do_cv.post(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            data=json_message,\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        if response.status_code == 409:\n            # this is a conflict, need to update or delete it\n            logger.error(\"Agent %s already existed at CV. Please use delete or update.\", self.agent_uuid)\n            sys.exit()\n        elif response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response.json())\n            logger.error(\"POST command response: %s Unexpected response from Cloud Verifier: %s\", response.status_code, response.text)\n            sys.exit()\n\n    def do_cvstatus(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_enabled)\n\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            res = response.pop('results')\n            response['results'] = {self.agent_uuid: res}\n\n            operational_state = states.state_to_str(\n                response['results'][self.agent_uuid]['operational_state'])\n            response['results'][self.agent_uuid]['operational_state'] = operational_state\n\n            logger.info(\"Agent Info:\\n%s\" % json.dumps(response[\"results\"]))\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvlist(self):\n        \"\"\"List all agent statues in cloudverifier\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        verifier_id = \"\"\n        if self.verifier_id is not None:\n            verifier_id = self.verifier_id\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/?verifier={verifier_id}'),\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            logger.info('From verifier %s port %s retrieved: \"%s\"',\n                        self.verifier_ip, self.verifier_port, response)\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvbulkinfo(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_enabled)\n\n        verifier_id = \"\"\n        if self.verifier_id is not None:\n            verifier_id = self.verifier_id\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/?bulk={True}&verifier={verifier_id}'),\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            for agent in response[\"results\"].keys():\n                response[\"results\"][agent][\"operational_state\"] = \\\n                    states.state_to_str(response[\"results\"][agent][\n                                            \"operational_state\"])\n            logger.info(\"Bulk Agent Info:\\n%s\" % json.dumps(response[\"results\"]))\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvdelete(self, verifier_check=True):\n        \"\"\"Delete agent from Verifier.\"\"\"\n        if verifier_check:\n            cvresponse = self.do_cvstatus()\n\n            if not isinstance(cvresponse, dict):\n                return cvresponse\n\n            if cvresponse['code'] != 200:\n                logger.error(\"Could not get status of agent %s from \"\n                             \"verifier %s.\", self.agent_uuid, self.verifier_ip)\n                return cvresponse\n\n            self.verifier_ip = cvresponse['results'][self.agent_uuid][\"verifier_ip\"]\n            self.verifier_port = cvresponse['results'][self.agent_uuid][\"verifier_port\"]\n\n        do_cvdelete = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = do_cvdelete.delete(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            cert=self.cert,\n            verify=False\n        )\n\n        response = response.json()\n\n        if response['code'] == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response\n        if response['code'] == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response\n        if response['code'] == 202:\n            deleted = False\n            for _ in range(12):\n                get_cvdelete = RequestsClient(\n                    self.verifier_base_url, self.tls_enabled)\n                response = get_cvdelete.get(\n                    (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n                    cert=self.cert,\n                    verify=False\n                )\n\n                if response.status_code == 404:\n                    deleted = True\n                    break\n                time.sleep(.4)\n            if deleted:\n                logger.info(\"CV completed deletion of agent %s\", self.agent_uuid)\n                return response.json()\n            logger.error(\"Timed out waiting for delete of agent %s to complete at CV\", self.agent_uuid)\n            return response.json()\n        if response['code'] == 200:\n            logger.info(\"Agent %s deleted from the CV\", self.agent_uuid)\n            return response\n\n        keylime_logging.log_http_response(\n            logger, logging.ERROR, response)\n        return response\n\n    def do_regstatus(self):\n        registrar_client.init_client_tls('tenant')\n        agent_info = registrar_client.getData(self.registrar_ip,\n                                              self.registrar_port,\n                                              self.agent_uuid)\n\n        if not agent_info:\n            logger.info(\n                \"Agent %s does not exist on the registrar. Please register the agent with the registrar.\",\n                self.agent_uuid)\n            response = {}\n            response['code'] = 404\n            response['status'] = \"Agent {0} does not exist on \" \\\n                                 \"registrar {1} port {2}.\".format(\n                self.agent_uuid, self.registrar_ip, self.registrar_port)\n            response['results'] = {}\n            logger.info(json.dumps((response)))\n            return response\n\n        response = {}\n        response['code'] = 200\n        response['status'] = \"Agent {0} exists on registrar {1} port {2}.\".format(\n                self.agent_uuid, self.registrar_ip, self.registrar_port)\n        response['results'] = {}\n        response['results'][self.agent_uuid] = agent_info\n        response['results'][self.agent_uuid]['operational_state'] = \\\n            states.state_to_str(states.REGISTERED)\n\n        logger.info(json.dumps(response))\n\n        return response\n\n    def do_reglist(self):\n        \"\"\"List agents from Registrar\"\"\"\n        registrar_client.init_client_tls('tenant')\n        response = registrar_client.doRegistrarList(\n            self.registrar_ip, self.registrar_port)\n\n        logger.info(\"From registrar %s port %s retrieved %s\",\n                    self.registrar_ip, self.registrar_port,\n                    json.dumps(response))\n        return response\n\n    def do_regdelete(self):\n        \"\"\"Delete agent from Registrar\"\"\"\n        registrar_client.init_client_tls('tenant')\n        response = registrar_client.doRegistrarDelete(self.registrar_ip,\n                                           self.registrar_port,\n                                           self.agent_uuid)\n\n        return response\n\n    def do_status(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        regresponse = self.do_regstatus()\n\n        if regresponse['code'] == 404:\n            return regresponse\n\n        cvresponse = self.do_cvstatus()\n\n        if not isinstance(cvresponse, dict):\n            logger.error(\"Unexpected response from Cloud Verifier %s on \"\n                         \"port %s. response %s\", self.verifier_ip,\n                         self.verifier_port, str(cvresponse))\n            return cvresponse\n\n        if regresponse['code'] == 200 and cvresponse['code'] == 200:\n            return cvresponse\n        if regresponse['code'] == 200 and cvresponse['code'] != 200:\n            return regresponse\n\n        logger.error(\"Unknown inconsistent state between registrar %s on \"\n                     \"port %s and verifier %s on port %s occured. Got \"\n                     \"registrar response %s verifier response %s\",\n                     self.verifier_ip, self.verifier_port, self.registrar_ip,\n                     self.registrar_port, str(regresponse), str(cvresponse))\n\n        return {'registrar': regresponse, 'verifier': cvresponse}\n\n    def do_cvreactivate(self, verifier_check=True):\n        \"\"\"Reactive Agent.\"\"\"\n        if verifier_check:\n            agent_json = self.do_cvstatus()\n            self.verifier_ip = agent_json['results'][self.agent_uuid]['verifier_ip']\n            self.verifier_port = agent_json['results'][self.agent_uuid]['verifier_port']\n\n        do_cvreactivate = RequestsClient(\n            self.verifier_base_url, self.tls_enabled)\n        response = do_cvreactivate.put(\n            f'/v{self.api_version}/agents/{self.agent_uuid}/reactivate',\n            data=b'',\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 200:\n            logger.info(\"Agent %s re-activated\", self.agent_uuid)\n            return response.json()\n\n        response_body = response.json()\n        keylime_logging.log_http_response(\n            logger, logging.ERROR, response_body)\n        logger.error(\"Update command response: %s Unexpected response from Cloud Verifier.\", response.status_code)\n        return response.json()\n\n    def do_cvstop(self):\n        \"\"\" Stop declared active agent\n        \"\"\"\n        params = f'/v{self.api_version}/agents/{self.agent_uuid}/stop'\n        do_cvstop = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = do_cvstop.put(\n            params,\n            cert=self.cert,\n            data=b'',\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        response_body = response.json()\n        if response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response_body)\n        else:\n            logger.info(\"Agent %s stopped\", self.agent_uuid)\n\n    def do_quote(self):\n        \"\"\" Perform TPM quote by GET towards Agent\n\n        Raises:\n            UserError: Connection handler\n        \"\"\"\n        self.nonce = TPM_Utilities.random_password(20)\n\n        numtries = 0\n        response = None\n        # Note: We need a specific retry handler (perhaps in common), no point having localised unless we have too.\n        while True:\n            try:\n                params = f'/v{self.supported_version}/quotes/identity?nonce=%s' % (self.nonce)\n                cloudagent_base_url = f'{self.agent_ip}:{self.agent_port}'\n\n                if self.registrar_data['mtls_cert']:\n                    with RequestsClient(cloudagent_base_url, tls_enabled=True, ignore_hostname=True, cert=self.agent_cert,\n                                        verify_custom=self.registrar_data['mtls_cert']) as do_quote:\n                        response = do_quote.get(params)\n                else:\n                    logger.warning(\"Connecting to agent without using mTLS!\")\n                    do_quote = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                    response = do_quote.get(params)\n\n                print(response)\n                response_body = response.json()\n\n            except Exception as e:\n                if response.status_code in (503, 504):\n                    numtries += 1\n                    maxr = config.getint('tenant', 'max_retries')\n                    if numtries >= maxr:\n                        logger.error(\"Tenant cannot establish connection to agent on %s with port %s\", self.agent_ip, self.agent_port)\n                        sys.exit()\n                    retry = config.getfloat('tenant', 'retry_interval')\n                    logger.info(\"Tenant connection to agent at %s refused %s/%s times, trying again in %s seconds...\",\n                        self.agent_ip, numtries, maxr, retry)\n                    time.sleep(retry)\n                    continue\n\n                raise e\n            break\n\n        try:\n            if response is not None and response.status_code != 200:\n                raise UserError(\n                    \"Status command response: %d Unexpected response from Cloud Agent.\" % response.status)\n\n            if \"results\" not in response_body:\n                raise UserError(\n                    \"Error: unexpected http response body from Cloud Agent: %s\" % str(response.status))\n\n            quote = response_body[\"results\"][\"quote\"]\n            logger.debug(\"Agent_quote received quote: %s\", quote)\n\n            public_key = response_body[\"results\"][\"pubkey\"]\n            logger.debug(\"Agent_quote received public key: %s\", public_key)\n\n            # Ensure hash_alg is in accept_tpm_hash_algs list\n            hash_alg = response_body[\"results\"][\"hash_alg\"]\n            logger.debug(\"Agent_quote received hash algorithm: %s\", hash_alg)\n            if not algorithms.is_accepted(hash_alg, config.get('tenant', 'accept_tpm_hash_algs').split(','))\\\n                    or not algorithms.Hash.is_recognized(hash_alg):\n                raise UserError(\n                    \"TPM Quote is using an unaccepted hash algorithm: %s\" % hash_alg)\n\n            # Ensure enc_alg is in accept_tpm_encryption_algs list\n            enc_alg = response_body[\"results\"][\"enc_alg\"]\n            logger.debug(\"Agent_quote received encryption algorithm: %s\", enc_alg)\n            if not algorithms.is_accepted(enc_alg, config.get('tenant', 'accept_tpm_encryption_algs').split(',')):\n                raise UserError(\n                    \"TPM Quote is using an unaccepted encryption algorithm: %s\" % enc_alg)\n\n            # Ensure sign_alg is in accept_tpm_encryption_algs list\n            sign_alg = response_body[\"results\"][\"sign_alg\"]\n            logger.debug(\"Agent_quote received signing algorithm: %s\", sign_alg)\n            if not algorithms.is_accepted(sign_alg, config.get('tenant', 'accept_tpm_signing_algs').split(',')):\n                raise UserError(\n                    \"TPM Quote is using an unaccepted signing algorithm: %s\" % sign_alg)\n\n            if not self.validate_tpm_quote(public_key, quote, algorithms.Hash(hash_alg)):\n                raise UserError(\n                    \"TPM Quote from cloud agent is invalid for nonce: %s\" % self.nonce)\n\n            logger.info(\"Quote from %s validated\", self.agent_ip)\n\n            # encrypt U with the public key\n            encrypted_U = crypto.rsa_encrypt(\n                crypto.rsa_import_pubkey(public_key), self.U)\n\n            b64_encrypted_u = base64.b64encode(encrypted_U)\n            logger.debug(\"b64_encrypted_u: %s\", b64_encrypted_u.decode('utf-8'))\n            data = {\n                'encrypted_key': b64_encrypted_u.decode('utf-8'),\n                'auth_tag': self.auth_tag\n            }\n\n            if self.payload is not None:\n                data['payload'] = self.payload.decode('utf-8')\n\n\n            # post encrypted U back to CloudAgent\n            params = f'/v{self.supported_version}/keys/ukey'\n            cloudagent_base_url = (\n                f'{self.agent_ip}:{self.agent_port}'\n            )\n\n            if self.registrar_data['mtls_cert']:\n                with RequestsClient(cloudagent_base_url, tls_enabled=True, ignore_hostname=True, cert=self.agent_cert,\n                                    verify_custom=self.registrar_data['mtls_cert']) as post_ukey:\n                    response = post_ukey.post(params, json=data)\n            else:\n                logger.warning(\"Connecting to agent without using mTLS!\")\n                post_ukey = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                response = post_ukey.post(params, json=data)\n\n            if response.status_code == 503:\n                logger.error(\"Cannot connect to Agent at %s with Port %s. Connection refused.\", self.agent_ip, self.agent_port)\n                sys.exit()\n            elif response.status_code == 504:\n                logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n                sys.exit()\n\n            if response.status_code != 200:\n                keylime_logging.log_http_response(\n                    logger, logging.ERROR, response_body)\n                raise UserError(\n                    \"Posting of Encrypted U to the Cloud Agent failed with response code %d (%s)\" % (response.status_code, response.text))\n        except Exception as e:\n            self.do_cvstop()\n            raise e\n\n    def do_verify(self):\n        \"\"\" Perform verify using a random generated challenge\n        \"\"\"\n        challenge = TPM_Utilities.random_password(20)\n        numtries = 0\n        while True:\n            try:\n                cloudagent_base_url = (\n                    f'{self.agent_ip}:{self.agent_port}'\n                )\n\n\n                if self.registrar_data['mtls_cert']:\n                    with RequestsClient(cloudagent_base_url, tls_enabled=True, ignore_hostname=True,\n                                        cert=self.agent_cert, verify_custom=self.registrar_data['mtls_cert']) as do_verify:\n                        response = do_verify.get(f'/v{self.supported_version}/keys/verify?challenge={challenge}')\n                else:\n                    logger.warning(\"Connecting to agent without using mTLS!\")\n                    do_verify = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                    response = do_verify.get(f'/v{self.supported_version}/keys/verify?challenge={challenge}')\n\n            except Exception as e:\n                if response.status_code in (503, 504):\n                    numtries += 1\n                    maxr = config.getint('tenant', 'max_retries')\n                    if numtries >= maxr:\n                        logger.error(\"Cannot establish connection to agent on %s with port %s\", self.agent_ip, self.agent_port)\n                        sys.exit()\n                    retry = config.getfloat('tenant', 'retry_interval')\n                    logger.info(\"Verifier connection to agent at %s refused %s/%s times, trying again in %s seconds...\",\n                        self.agent_ip, numtries, maxr, retry)\n                    time.sleep(retry)\n                    continue\n\n                raise e\n            response_body = response.json()\n            if response.status_code == 200:\n                if \"results\" not in response_body or 'hmac' not in response_body['results']:\n                    logger.critical(\"Error: unexpected http response body from Cloud Agent: %s\", response.status_code)\n                    break\n                mac = response_body['results']['hmac']\n\n                ex_mac = crypto.do_hmac(self.K, challenge)\n\n                if mac == ex_mac:\n                    logger.info(\"Key derivation successful\")\n                else:\n                    logger.error(\"Key derivation failed\")\n            else:\n                keylime_logging.log_http_response(\n                    logger, logging.ERROR, response_body)\n                retry = config.getfloat('tenant', 'retry_interval')\n                logger.warning(\"Key derivation not yet complete...trying again in %s seconds...Ctrl-C to stop\", retry)\n                time.sleep(retry)\n                continue\n            break\n\n    def do_add_allowlist(self, args):\n        if 'allowlist_name' not in args or not args['allowlist_name']:\n            raise UserError('allowlist_name is required to add an allowlist')\n\n        allowlist_name = args['allowlist_name']\n        self.process_allowlist(args)\n        data = {\n            'tpm_policy': json.dumps(self.tpm_policy),\n            'vtpm_policy': json.dumps(self.vtpm_policy),\n            'allowlist': json.dumps(self.allowlist)\n        }\n        body = json.dumps(data)\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = cv_client.post(f'/v{self.api_version}/allowlists/{allowlist_name}', data=body,\n                                  cert=self.cert, verify=False)\n        print(response.json())\n\n    def do_delete_allowlist(self, name):\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = cv_client.delete(f'/v{self.api_version}/allowlists/{name}',\n                                    cert=self.cert, verify=False)\n        print(response.json())\n\n    def do_show_allowlist(self, name):\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = cv_client.get(f'/v{self.api_version}/allowlists/{name}',\n                                 cert=self.cert, verify=False)\n        print(f\"Show allowlist command response: {response.status_code}.\")\n        print(response.json())\n\n\ndef write_to_namedtempfile(data, delete_tmp_files):\n    temp = tempfile.NamedTemporaryFile(prefix=\"keylime-\", delete=delete_tmp_files)\n    temp.write(data)\n    temp.flush()\n    return temp.name\n\ndef main(argv=sys.argv):\n    \"\"\"[summary]\n\n    Keyword Arguments:\n        argv {[type]} -- [description] (default: {sys.argv})\n\n    Raises:\n        UserError: [description]\n        UserError: [description]\n        UserError: [description]\n    \"\"\"\n    parser = argparse.ArgumentParser(argv[0])\n    parser.add_argument('-c', '--command', action='store', dest='command', default='add',\n                        help=\"valid commands are add,delete,update,\"\n                             \"regstatus,cvstatus,status,reglist,cvlist,reactivate,\"\n                             \"regdelete,\"\n                             \"bulkinfo. defaults to add\")\n    parser.add_argument('-t', '--targethost', action='store',\n                        dest='agent_ip', help=\"the IP address of the host to provision\")\n    parser.add_argument('-tp', '--targetport', action='store',\n                        dest='agent_port', help=\"the Port of the host to provision\")\n    parser.add_argument('-r', '--registrarhost', action='store',\n                        dest='registrar_ip', help=\"the IP address of the registrar where to retrieve the agents data from.\")\n    parser.add_argument('-rp', '--registrarport', action=\"store\",\n                        dest='registrar_port', help=\"the port of the registrar.\")\n    parser.add_argument('--cv_targethost', action='store', default=None, dest='cv_agent_ip',\n                        help='the IP address of the host to provision that the verifier will use (optional).  Use only if different than argument to option -t/--targethost')\n    parser.add_argument('-v', '--cv', action='store', dest='verifier_ip',\n                        help=\"the IP address of the cloud verifier\")\n    parser.add_argument('-vp', '--cvport', action='store', dest='verifier_port',\n                        help=\"the port of the cloud verifier\")\n    parser.add_argument('-vi', '--cvid', action='store', dest='verifier_id',\n                        help=\"the unique identifier of a cloud verifier\")\n    parser.add_argument('-nvc', '--no-verifier-check', action='store_false', dest='verifier_check', default=True,\n                        help='Disable the check to confirm if the agent is being processed by the specified verifier. Use only with -c/--command delete or reactivate')\n    parser.add_argument('-u', '--uuid', action='store',\n                        dest='agent_uuid', help=\"UUID for the agent to provision\")\n    parser.add_argument('-f', '--file', action='store', default=None,\n                        help='Deliver the specified plaintext to the provisioned agent')\n    parser.add_argument('--cert', action='store', dest='ca_dir', default=None,\n                        help='Create and deliver a certificate using a CA created by ca-util. Pass in the CA directory or use \"default\" to use the standard dir')\n    parser.add_argument('-k', '--key', action='store', dest='keyfile',\n                        help='an intermedia key file produced by user_data_encrypt')\n    parser.add_argument('-p', '--payload', action='store', default=None,\n                        help='Specify the encrypted payload to deliver with encrypted keys specified by -k')\n    parser.add_argument('--include', action='store', dest='incl_dir', default=None,\n                        help=\"Include additional files in provided directory in certificate zip file.  Must be specified with --cert\")\n    parser.add_argument('--allowlist', action='store', dest='allowlist',\n                        default=None, help=\"Specify the file path of an allowlist\")\n    parser.add_argument('--signature-verification-key', '--sign_verification_key', action='append', dest='ima_sign_verification_keys',\n                        default=[], help=\"Specify an IMA file signature verification key\")\n    parser.add_argument('--signature-verification-key-sig', action='append', dest='ima_sign_verification_key_sigs',\n                        default=[], help=\"Specify the GPG signature file for an IMA file signature verification key; pair this option with --signature-verification-key\")\n    parser.add_argument('--signature-verification-key-sig-key', action='append', dest='ima_sign_verification_key_sig_keys',\n                        default=[], help=\"Specify the GPG public key file use to validate the --signature-verification-key-sig; pair this option with --signature-verification-key\")\n    parser.add_argument('--signature-verification-key-url', action='append', dest='ima_sign_verification_key_urls',\n                        default=[], help=\"Specify the URL for a remote IMA file signature verification key\")\n    parser.add_argument('--signature-verification-key-sig-url', action='append',\n                        dest='ima_sign_verification_key_sig_urls',\n                        default=[], help=\"Specify the URL for the remote GPG signature of a remote IMA file signature verification key; pair this option with --signature-verification-key-url\")\n    parser.add_argument('--signature-verification-key-sig-url-key', action='append',\n                        dest='ima_sign_verification_key_sig_url_keys',\n                        default=[], help=\"Specify the GPG public key file used to validate the --signature-verification-key-sig-url; pair this option with --signature-verification-key-url\")\n    parser.add_argument('--mb_refstate', action='store', dest='mb_refstate',\n                        default=None, help=\"Specify the location of a measure boot reference state (intended state)\")\n    parser.add_argument('--allowlist-checksum', action='store', dest='allowlist_checksum',\n                        default=None, help=\"Specify the SHA2 checksum of an allowlist\")\n    parser.add_argument('--allowlist-sig', action='store', dest='allowlist_sig',\n                        default=None, help=\"Specify the GPG signature file of an allowlist\")\n    parser.add_argument('--allowlist-sig-key', action='store', dest='allowlist_sig_key',\n                        default=None, help=\"Specify the GPG public key file used to validate the --allowlist-sig or --allowlist-sig-url\")\n    parser.add_argument('--allowlist-url', action='store', dest='allowlist_url',\n                        default=None, help=\"Specify the URL of a remote allowlist\")\n    parser.add_argument('--allowlist-sig-url', action='store', dest='allowlist_sig_url',\n                        default=None, help=\"Specify the URL of the remote GPG signature file of an allowlist\")\n    parser.add_argument('--exclude', action='store', dest='ima_exclude',\n                        default=None, help=\"Specify the location of an IMA exclude list\")\n    parser.add_argument('--tpm_policy', action='store', dest='tpm_policy', default=None,\n                        help=\"Specify a TPM policy in JSON format. e.g., {\\\"15\\\":\\\"0000000000000000000000000000000000000000\\\"}\")\n    parser.add_argument('--vtpm_policy', action='store', dest='vtpm_policy',\n                        default=None, help=\"Specify a vTPM policy in JSON format\")\n    parser.add_argument('--verify', action='store_true', default=False,\n                        help='Block on cryptographically checked key derivation confirmation from the agent once it has been provisioned')\n    parser.add_argument('--allowlist-name', help='The name of allowlist to operate with')\n    parser.add_argument('--supported-version', default=None, action=\"store\", dest='supported_version', help='API version that is supported by the agent. Detected automatically by default')\n\n    args = parser.parse_args(argv[1:])\n\n    # Make sure argument dependencies are enforced\n    if( args.allowlist and args.allowlist_url):\n        parser.error(\"--allowlist and --allowlist-url cannot be specified at the same time\")\n    if( args.allowlist_url and not (args.allowlist_sig or args.allowlist_sig_url or args.allowlist_checksum)):\n        parser.error(\"--allowlist-url must have either --allowlist-sig, --allowlist-sig-url or --allowlist-checksum to verifier integrity\")\n    if( args.allowlist_sig and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-sig must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_sig_url and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-sig-url must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_checksum and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-checksum must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_sig and not args.allowlist_sig_key):\n        parser.error(\"--allowlist-sig must also have --allowlist-sig-key\")\n    if( args.allowlist_sig_url and not args.allowlist_sig_key):\n        parser.error(\"--allowlist-sig-url must also have --allowlist-sig-key\")\n    if( args.allowlist_sig_key and not (args.allowlist_sig or args.allowlist_sig_url)):\n        parser.error(\"--allowlist-sig-key must have either --allowlist-sig or --allowlist-sig-url\")\n\n    mytenant = Tenant()\n\n    if args.agent_uuid is not None:\n        mytenant.agent_uuid = args.agent_uuid\n        # if the uuid is actually a public key, then hash it\n        if mytenant.agent_uuid.startswith('-----BEGIN PUBLIC KEY-----'):\n            mytenant.agent_uuid = hashlib.sha256(\n                mytenant.agent_uuid).hexdigest()\n    else:\n        logger.warning(\"Using default UUID d432fbb3-d2f1-4a97-9ef7-75bd81c00000\")\n        mytenant.agent_uuid = \"d432fbb3-d2f1-4a97-9ef7-75bd81c00000\"\n\n    if config.STUB_VTPM and config.TPM_CANNED_VALUES is not None:\n        # Use canned values for agent UUID\n        jsonIn = config.TPM_CANNED_VALUES\n        if \"add_vtpm_to_group\" in jsonIn:\n            mytenant.agent_uuid = jsonIn['add_vtpm_to_group']['retout']\n        else:\n            # Our command hasn't been canned!\n            raise UserError(\"Command %s not found in canned JSON!\" %\n                            (\"add_vtpm_to_group\"))\n\n    if args.verifier_id is not None:\n        mytenant.verifier_id = args.verifier_id\n    if args.verifier_ip is not None:\n        mytenant.verifier_ip = args.verifier_ip\n    if args.verifier_port is not None:\n        mytenant.verifier_port = args.verifier_port\n\n    if args.registrar_ip is not None:\n        mytenant.registrar_ip = args.registrar_ip\n    if args.registrar_port is not None:\n        mytenant.registrar_port = args.registrar_port\n\n    # we only need to fetch remote files if we are adding or updating\n    if args.command in ['add', 'update']:\n        delete_tmp_files = logger.level > logging.DEBUG # delete tmp files unless in DEBUG mode\n\n        if args.allowlist_url:\n            logger.info(\"Downloading Allowlist from %s\", args.allowlist_url)\n            response = requests.get(args.allowlist_url, allow_redirects=False)\n            if response.status_code == 200:\n                args.allowlist = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Allowlist temporarily saved in %s\" % args.allowlist)\n            else:\n                raise Exception(f\"Downloading allowlist ({args.allowlist_url}) failed with status code {response.status_code}!\")\n\n        if args.allowlist_sig_url:\n            logger.info(\"Downloading Allowlist signature from %s\", args.allowlist_sig_url)\n            response = requests.get(args.allowlist_sig_url, allow_redirects=False)\n            if response.status_code == 200:\n                args.allowlist_sig = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Allowlist signature temporarily saved in %s\", args.allowlist_sig)\n            else:\n                raise Exception(f\"Downloading allowlist signature ({args.allowlist_sig_url}) failed with status code {response.status_code}!\")\n\n        # verify all the local keys for which we have a signature file and a key to verify\n        for i, key_file in enumerate(args.ima_sign_verification_keys):\n            if len(args.ima_sign_verification_key_sigs) <= i:\n                break\n            keysig_file = args.ima_sign_verification_key_sigs[i]\n            if len(args.ima_sign_verification_key_sig_keys) == 0:\n                raise UserError(\"A gpg key is missing for key signature file '%s'\" % keysig_file)\n\n            gpg_key_file = args.ima_sign_verification_key_sig_keys[i]\n            gpg.gpg_verify_filesignature(gpg_key_file, key_file, keysig_file, \"IMA file signing key\")\n\n            logger.info(\"Signature verification on %s was successful\" % key_file)\n\n        # verify all the remote keys for which we have a signature URL and key to to verify\n        # Append the downloaded key files to args.ima_sign_verification_keys\n        for i, key_url in enumerate(args.ima_sign_verification_key_urls):\n\n            logger.info(\"Downloading key from %s\", key_url)\n            response = requests.get(key_url, allow_redirects=False)\n            if response.status_code == 200:\n                key_file = write_to_namedtempfile(response.content, delete_tmp_files)\n                args.ima_sign_verification_keys.append(key_file)\n                logger.debug(\"Key temporarily saved in %s\" % key_file)\n            else:\n                raise Exception(f\"Downloading key ({key_url}) failed with status code {response.status_code}!\")\n\n            if len(args.ima_sign_verification_key_sig_urls) <= i:\n                continue\n\n            keysig_url = args.ima_sign_verification_key_sig_urls[i]\n\n            if len(args.ima_sign_verification_key_sig_url_keys) == 0:\n                raise UserError(\"A gpg key is missing for key signature URL '%s'\" % keysig_url)\n\n            logger.info(\"Downloading key signature from %s\" % keysig_url)\n            response = requests.get(keysig_url, allow_redirects=False)\n            if response.status_code == 200:\n                keysig_file = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Key signature temporarily saved in %s\" % keysig_file)\n            else:\n                raise Exception(f\"Downloading key signature ({key_url}) failed with status code {response.status_code}!\")\n\n            gpg_key_file = args.ima_sign_verification_key_sig_url_keys[i]\n            gpg.gpg_verify_filesignature(gpg_key_file, key_file, keysig_file, \"IMA file signing key\")\n            logger.info(\"Signature verification on %s was successful\" % key_url)\n\n    if args.command == 'add':\n        mytenant.init_add(vars(args))\n        mytenant.preloop()\n        mytenant.do_cv()\n        mytenant.do_quote()\n        if args.verify:\n            mytenant.do_verify()\n    elif args.command == 'update':\n        mytenant.init_add(vars(args))\n        mytenant.do_cvdelete(args.verifier_check)\n        mytenant.preloop()\n        mytenant.do_cv()\n        mytenant.do_quote()\n        if args.verify:\n            mytenant.do_verify()\n    elif args.command == 'delete':\n        mytenant.do_cvdelete(args.verifier_check)\n    elif args.command == 'status':\n        mytenant.do_status()\n    elif args.command == 'cvstatus':\n        mytenant.do_cvstatus()\n    elif args.command == 'bulkinfo':\n        mytenant.do_cvbulkinfo()\n    elif args.command == 'cvlist':\n        mytenant.do_cvlist()\n    elif args.command == 'reactivate':\n        mytenant.do_cvreactivate(args.verifier_check)\n    elif args.command == 'regstatus':\n        mytenant.do_regstatus()\n    elif args.command == 'reglist':\n        mytenant.do_reglist()\n    elif args.command == 'regdelete':\n        mytenant.do_regdelete()\n    elif args.command == 'addallowlist':\n        mytenant.do_add_allowlist(vars(args))\n    elif args.command == 'showallowlist':\n        mytenant.do_show_allowlist(args.allowlist_name)\n    elif args.command == 'deleteallowlist':\n        mytenant.do_delete_allowlist(args.allowlist_name)\n    else:\n        raise UserError(\"Invalid command specified: %s\" % (args.command))\n", "#!/usr/bin/python3\n\n'''\nSPDX-License-Identifier: BSD-2-Clause\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport base64\nimport logging\nimport os\nimport ssl\nimport traceback\nimport sys\n\nimport tornado.ioloop\nimport tornado.web\n\nfrom keylime.requests_client import RequestsClient\nfrom keylime.common import states\nfrom keylime import config\nfrom keylime import json\nfrom keylime import keylime_logging\nfrom keylime import tenant\nfrom keylime import web_util\nfrom keylime import api_version as keylime_api_version\n\n\nlogger = keylime_logging.init_logging('tenant_webapp')\ntenant_templ = tenant.Tenant()\n(my_cert, my_priv_key), agent_cert = tenant_templ.get_tls_context()\ncert = (my_cert, my_priv_key)\nif config.getboolean('general', \"enable_tls\"):\n    tls_enabled = True\nelse:\n    tls_enabled = False\n    cert = \"\"\n    logger.warning(\n        \"Warning: TLS is currently disabled, keys will be sent in the clear! This should only be used for testing.\")\n\nverifier_ip = config.get('cloud_verifier', 'cloudverifier_ip')\nverifier_port = config.get('cloud_verifier', 'cloudverifier_port')\nverifier_base_url = f'{verifier_ip}:{verifier_port}'\n\nregistrar_ip = config.get('registrar', 'registrar_ip')\nregistrar_tls_port = config.get('registrar', 'registrar_tls_port')\nregistrar_base_tls_url = f'{registrar_ip}:{registrar_tls_port}'\n\napi_version = keylime_api_version.current_version()\n\n\nclass Agent_Init_Types:\n    FILE = '0'\n    KEYFILE = '1'\n    CA_DIR = '2'\n\n\nclass BaseHandler(tornado.web.RequestHandler):\n\n    def write_error(self, status_code, **kwargs):\n\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            lines = []\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                lines.append(line)\n            web_util.echo_json_response(self, status_code, self._reason, lines)\n        else:\n            web_util.echo_json_response(self, status_code, self._reason)\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/ interface instead\")\n\n    def get(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/  interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/  interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/  interface instead\")\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/  interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass WebAppHandler(BaseHandler):\n    def head(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def get(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents for all agents in a Web-based GUI.\n\n        Currently, only the web app is available for GETing, i.e. /webapp. All other GET uri's\n        will return errors.\n        \"\"\"\n\n        # Get default policies for TPM/vTPM from config as suggestions to user\n        tpm_policy = json.dumps(json.loads(\n            config.get('tenant', 'tpm_policy')), indent=2)\n        vtpm_policy = json.dumps(json.loads(\n            config.get('tenant', 'vtpm_policy')), indent=2)\n\n        # Get default intervals for populating angents, updating agents and updating terminal\n        populate_agents_interval = json.dumps(json.loads(\n            config.get('webapp', 'populate_agents_interval')), indent=2)\n        update_agents_interval = json.dumps(json.loads(\n            config.get('webapp', 'update_agents_interval')), indent=2)\n        update_terminal_interval = json.dumps(json.loads(\n            config.get('webapp', 'update_terminal_interval')), indent=2)\n\n        self.set_status(200)\n        self.set_header('Content-Type', 'text/html')\n        self.write(\n            \"\"\"\n            <!DOCTYPE html>\n            <html>\n                <head>\n                    <meta charset='UTF-8'>\n                    <title>Advanced Tenant Management System</title>\n                    <script type='text/javascript' src='/static/js/webapp.js'></script>\n                    <script type='text/javascript'>\n                        window.onload = function(e) {{\n                            let droppable = document.getElementsByClassName(\"file_drop\");\n                            for (let i = 0; i < droppable.length; i++) {{\n                                droppable[i].addEventListener('dragover', dragoverCallback, false);\n                                droppable[i].addEventListener('drop', fileUploadCallback, false);\n                            }}\n                            populateAgents();\n                            setInterval(populateAgents, {0});\n                            setInterval(updateAgentsInfo, {1});\n                            setInterval(updateTerminal, {2});\n                        }}\n                    </script>\n                    <link href='/static/css/webapp.css' rel='stylesheet' type='text/css'/>\n                </head>\n                <body>\n                    <div id='modal_box' onclick=\"if (event.target == this) {{toggleVisibility(this.id);resetAddAgentForm();return false;}}\">\n\n            \"\"\".format(populate_agents_interval, update_agents_interval, update_terminal_interval)\n        )\n\n        self.write(\n            \"\"\"\n                        <div id='modal_body'>\n                            <center>\n                                <h3>Add Agent</h3>\n                                <h4 id='uuid_str'></h4>\n                            </center>\n                            <form id='add_agent' name='add_agent' onsubmit='submitAddAgentForm(this); return false;'>\n                                <div class=\"form_block\">\n                                    <label for='agent_ip'>Agent IP: </label>\n                                    <input type='text' id='agent_ip' name='agent_ip' value='127.0.0.1' required onfocus='this.select()'>\n                                    <br>\n                                </div>\n\n                                <div id='imalist_toggle' onclick=\"toggleVisibility('imalist_block');\" title='IMA Configuration'>\n                                    IMA Configuration\n                                </div>\n                                <div id=\"imalist_block\">\n                                    <div class=\"form_block\">\n                                        <label for='a_list'>Allow-List: </label>\n                                        <div id='a_list' name='a_list' class='file_drop'>\n                                            <i>Drag payload here &hellip;</i>\n                                        </div>\n                                        <input type='hidden' name='a_list_data' id='a_list_data' value=''>\n                                        <input type='hidden' name='a_list_name' id='a_list_name' value=''>\n                                        <br>\n                                    </div>\n\n                                    <div class=\"form_block\">\n                                        <label for='e_list'>Exclude: </label>\n                                        <div id='e_list' name='e_list' class='file_drop'>\n                                            <i>Drag payload here &hellip;</i>\n                                        </div>\n                                        <input type='hidden' name='e_list_data' id='e_list_data' value=''>\n                                        <input type='hidden' name='e_list_name' id='e_list_name' value=''>\n                                        <br>\n                                    </div>\n                                </div>\n                                <br>\n\n                                <div id='policy_toggle' onclick=\"toggleVisibility('policy_block');\" title='TPM &amp; vTPM Policy Configuration'>\n                                    TPM &amp; vTPM Policy Configuration\n                                </div>\n                                <div id=\"policy_block\">\n                                    <div class=\"form_block\">\n                                        <label for='tpm_policy'>TPM Policy: </label><br>\n                                        <textarea class='json_input' id='tpm_policy' name='tpm_policy'>{}</textarea>\n                                        <br>\n                                    </div>\n\n                                    <div class=\"form_block\">\n                                        <label for='vtpm_policy'>vTPM Policy: </label><br>\n                                        <textarea class='json_input' id='vtpm_policy' name='vtpm_policy'>{}</textarea>\n                                        <br>\n                                    </div>\n                                </div>\n                                <br>\n            \"\"\".format(tpm_policy, vtpm_policy)\n        )\n\n        self.write(\n            \"\"\"\n                                <div id=\"payload_block\">\n                                    <div class=\"form_block\">\n                                        <label for='ptype'>Payload type: </label>\n                                        <label><input type='radio' name='ptype' value='{}' checked=\"checked\" onclick='toggleTabs(this.value)'> File </label>&nbsp;\n                                        <label><input type='radio' name='ptype' value='{}' onclick='toggleTabs(this.value)'> Keyfile </label>&nbsp;\n                                        <label><input type='radio' name='ptype' value='{}' onclick='toggleTabs(this.value)'> CA Dir </label>&nbsp;\n                                        <br>\n                                    </div>\n            \"\"\".format(Agent_Init_Types.FILE, Agent_Init_Types.KEYFILE, Agent_Init_Types.CA_DIR)\n        )\n\n        self.write(\n            \"\"\"\n                                    <div id='keyfile_container' class=\"form_block\" style=\"display:none;\">\n                                        <label for='file'>Keyfile: </label>\n                                        <div id='keyfile' name='keyfile' class='file_drop'>\n                                            <i>Drag key file here &hellip;</i>\n                                        </div>\n                                        <input type='hidden' name='keyfile_data' id='keyfile_data' value=''>\n                                        <input type='hidden' name='keyfile_name' id='keyfile_name' value=''>\n                                        <br>\n                                    </div>\n\n                                    <div id='file_container' class=\"form_block\">\n                                        <label for='file'>Payload: </label>\n                                        <div id='file' name='file' class='file_drop'>\n                                            <i>Drag payload here &hellip;</i>\n                                        </div>\n                                        <input type='hidden' name='file_data' id='file_data' value=''>\n                                        <input type='hidden' name='file_name' id='file_name' value=''>\n                                        <br>\n                                    </div>\n\n                                    <div id='ca_dir_container' style=\"display:none;\">\n                                        <div class=\"form_block\">\n                                            <label for='ca_dir'>CA Dir: </label>\n                                            <input type='text' id='ca_dir' name='ca_dir' placeholder='e.g., default'>\n                                            <br>\n                                        </div>\n\n                                        <div class=\"form_block\">\n                                            <label for='ca_dir_pw'>CA Password: </label>\n                                            <input type='password' id='ca_dir_pw' name='ca_dir_pw' placeholder='e.g., default'>\n                                            <br>\n                                        </div>\n\n                                        <div class=\"form_block\">\n                                            <label for='include_dir'>Include dir: </label>\n                                            <div id='include_dir' name='include_dir' class='file_drop multi_file'>\n                                                <i>Drag files here &hellip;</i>\n                                            </div>\n                                            <input type='hidden' name='include_dir_data' id='include_dir_data' value=''>\n                                            <input type='hidden' name='include_dir_name' id='include_dir_name' value=''>\n                                            <br>\n                                        </div>\n                                    </div>\n                                </div>\n                                <br>\n\n                                <input type='hidden' name='uuid' id='uuid' value=''>\n                                <center><button type=\"submit\" value=\"Add Agent\">Add Agent</button></center>\n                                <br>\n                            </form>\n                        </div>\n                    </div>\n\n                    <div id=\"header\">\n                        <div class=\"logo\" title=\"Keylime\">&nbsp;</div>\n                        <div id=\"header_banner\">\n                            <h1>Keylime Advanced Tenant Management System</h1>\n                        </div>\n                        <div class=\"logo\" style=\"float:right;\" title=\"Keylime\">&nbsp;</div>\n                       <br style=\"clear:both;\">\n                    </div>\n\n                    <div id=\"agent_body\">\n                        <h2>Agents</h2>\n                        <div class='table_header'>\n                            <div class='table_control'>&nbsp;</div>\n                            <div class='table_col'>UUID</div>\n                            <div class='table_col'>address</div>\n                            <div class='table_col'>status</div>\n                            <br style='clear:both;' />\n                        </div>\n                        <div id='agent_template' style='display:none;'>\n                            <li class='agent'>\n                                <div style='display:block;cursor:help;width:800px;'></div>\n                                <div style='display:none;'></div>\n                            </li>\n                        </div>\n                        <ol id='agent_container'></ol>\n                        <div style=\"color:#888;margin-left:15px;padding:10px;\">\n                            <i>End of results</i>\n                        </div>\n                        <div id=\"terminal-frame\">\n                            <div id=\"terminal-header\" onmousedown=\"toggleVisibility('terminal')\">Tenant Logs</div>\n                            <div id=\"terminal\"></div>\n                        </div>\n                    </div>\n                </body>\n            </html>\n            \"\"\"\n        )\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AgentsHandler(BaseHandler):\n    def head(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    async def get_agent_state(self, agent_id):\n        try:\n            get_agent_state = RequestsClient(verifier_base_url, tls_enabled)\n            response = get_agent_state.get(\n                (f'/v{api_version}/agents/{agent_id}'),\n                cert=cert,\n                verify=False\n            )\n\n        except Exception as e:\n            logger.error(\"Status command response: %s:%s Unexpected response from Cloud Verifier.\",\n                tenant_templ.cloudverifier_ip, tenant_templ.cloudverifier_port)\n            logger.exception(e)\n            web_util.echo_json_response(\n                self, 500, \"Unexpected response from Cloud Verifier\", str(e))\n            logger.error(\"Unexpected response from Cloud Verifier: %s\", e)\n            return\n\n        inst_response_body = response.json()\n\n        if response.status_code not in [200, 404]:\n            logger.error(\"Status command response: %d Unexpected response from Cloud Verifier.\", response.status_code)\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, inst_response_body)\n            return None\n\n        if \"results\" not in inst_response_body:\n            logger.critical(\"Error: unexpected http response body from Cloud Verifier: %s\", response.status_code)\n            return None\n\n        # Agent not added to CV (but still registered)\n        if response.status_code == 404:\n            return {\"operational_state\": states.REGISTERED}\n\n        return inst_response_body[\"results\"]\n\n    async def get(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents from the WebApp.\n\n        Currently, only the web app is available for GETing, i.e. /agents. All other GET uri's\n        will return errors.\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ or /logs/ interface\")\n            return\n\n        if \"logs\" in rest_params and rest_params[\"logs\"] == \"tenant\":\n            offset = 0\n            if \"pos\" in rest_params and rest_params[\"pos\"] is not None and rest_params[\"pos\"].isdigit():\n                offset = int(rest_params[\"pos\"])\n            # intercept requests for logs\n            with open(keylime_logging.LOGSTREAM, encoding=\"utf-8\") as f:\n                logValue = f.readlines()\n                web_util.echo_json_response(self, 200, \"Success\", {\n                                          'log': logValue[offset:]})\n            return\n        if \"agents\" not in rest_params:\n            # otherwise they must be looking for agent info\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('GET returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n        if agent_id is not None:\n            # Handle request for specific agent data separately\n            agents = await self.get_agent_state(agent_id)\n            agents[\"id\"] = agent_id\n\n            web_util.echo_json_response(self, 200, \"Success\", agents)\n            return\n\n        # If no agent ID, get list of all agents from Registrar\n        try:\n            get_agents = RequestsClient(registrar_base_tls_url, tls_enabled)\n            response = get_agents.get(\n                (f'/v{api_version}/agents/'),\n                cert=cert,\n                verify=False\n            )\n\n        except Exception as e:\n            logger.error(\"Status command response: %s:%s Unexpected response from Registrar.\",\n                tenant_templ.registrar_ip, tenant_templ.registrar_port)\n            logger.exception(e)\n            web_util.echo_json_response(\n                self, 500, \"Unexpected response from Registrar\", str(e))\n            return\n\n        response_body = response.json()\n\n        if response.status_code != 200:\n            logger.error(\"Status command response: %d Unexpected response from Registrar.\", response.status_code)\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response_body)\n            return None\n\n        if (\"results\" not in response_body) or (\"uuids\" not in response_body[\"results\"]):\n            logger.critical(\"Error: unexpected http response body from Registrar: %s\", response.status_code)\n            return None\n\n        agent_list = response_body[\"results\"][\"uuids\"]\n\n        web_util.echo_json_response(self, 200, \"Success\", {\n                                  'uuids': agent_list})\n\n    def delete(self):\n        \"\"\"This method handles the DELETE requests to remove agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('DELETE returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        # let Tenant do dirty work of deleting agent\n        mytenant = tenant.Tenant()\n        mytenant.agent_uuid = agent_id\n        mytenant.do_cvdelete()\n\n        web_util.echo_json_response(self, 200, \"Success\")\n\n    def post(self):\n        \"\"\"This method handles the POST requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's will return errors.\n        agents requests require a yaml block sent in the body\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('POST returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        # Parse payload files (base64 data-uri)\n        if self.get_argument(\"ptype\", Agent_Init_Types.FILE, True) == Agent_Init_Types.FILE:\n            keyfile = None\n            payload = None\n            data = {'data': parse_data_uri(\n                self.get_argument(\"file_data\", None, True))}\n            ca_dir = None\n            incl_dir = None\n            ca_dir_pw = None\n        elif self.get_argument(\"ptype\", Agent_Init_Types.FILE, True) == Agent_Init_Types.KEYFILE:\n            keyfile = {'data': parse_data_uri(\n                self.get_argument(\"keyfile_data\", None, True)), }\n            payload = {'data': parse_data_uri(\n                self.get_argument(\"file_data\", None, True))}\n            data = None\n            ca_dir = None\n            incl_dir = None\n            ca_dir_pw = None\n        elif self.get_argument(\"ptype\", Agent_Init_Types.FILE, True) == Agent_Init_Types.CA_DIR:\n            keyfile = None\n            payload = None\n            data = None\n            incl_dir = {\n                'data': parse_data_uri(self.get_argument(\"include_dir_data\", None, True)),\n                'name': self.get_argument(\"include_dir_name\", \"\", True).splitlines()\n            }\n            ca_dir = self.get_argument(\"ca_dir\", 'default', True)\n            if ca_dir == \"\":\n                ca_dir = 'default'\n            ca_dir_pw = self.get_argument(\"ca_dir_pw\", 'default', True)\n            if ca_dir_pw == \"\":\n                ca_dir_pw = 'default'\n        else:\n            web_util.echo_json_response(self, 400, \"invalid payload type chosen\")\n            logger.warning('POST returning 400 response. malformed query')\n            return\n\n        # Pull in user-defined v/TPM policies\n        tpm_policy = self.get_argument(\"tpm_policy\", \"\", True)\n        if tpm_policy == \"\":\n            tpm_policy = None\n        vtpm_policy = self.get_argument(\"vtpm_policy\", \"\", True)\n        if vtpm_policy == \"\":\n            vtpm_policy = None\n\n        # Pull in allowlist\n        allowlist = None\n        a_list_data = self.get_argument(\"a_list_data\", None, True)\n        if a_list_data != \"\":\n            allowlist_str = parse_data_uri(a_list_data)\n            if allowlist_str is not None:\n                allowlist = allowlist_str[0].splitlines()\n\n        # Pull in IMA exclude list\n        ima_exclude = None\n        e_list_data = self.get_argument(\"e_list_data\", None, True)\n        if e_list_data != \"\":\n            ima_exclude_str = parse_data_uri(e_list_data)\n            if ima_exclude_str is not None:\n                ima_exclude = ima_exclude_str[0].splitlines()\n\n        # Build args to give to Tenant's init_add method\n        args = {\n            'agent_ip': self.get_argument(\"agent_ip\", None, True),\n            'file': data,\n            'keyfile': keyfile,\n            'payload': payload,\n            'ca_dir': ca_dir,\n            'incl_dir': incl_dir,\n            'ca_dir_pw': ca_dir_pw,\n            'tpm_policy': tpm_policy,\n            'vtpm_policy': vtpm_policy,\n            'allowlist': allowlist,\n            'ima_exclude': ima_exclude,\n        }\n\n        # let Tenant do dirty work of adding agent\n        try:\n            mytenant = tenant.Tenant()\n            mytenant.agent_uuid = agent_id\n            mytenant.init_add(args)\n            mytenant.preloop()\n            mytenant.do_cv()\n            mytenant.do_quote()\n        except Exception as e:\n            logger.exception(e)\n            logger.warning('POST returning 500 response. Tenant error: %s', e)\n            web_util.echo_json_response(self, 500, \"Request failure\", str(e))\n            return\n\n        web_util.echo_json_response(self, 200, \"Success\")\n\n    def put(self):\n        \"\"\"This method handles the PUT requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's will return errors.\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('PUT returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        # let Tenant do dirty work of reactivating agent\n        mytenant = tenant.Tenant()\n        mytenant.agent_uuid = agent_id\n        mytenant.do_cvreactivate()\n\n        web_util.echo_json_response(self, 200, \"Success\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\ndef parse_data_uri(data_uri):\n    if data_uri is None:\n        return None\n\n    data = []\n\n    dataset_uris = data_uri.split(\"\\n\")\n    for uri in dataset_uris:\n        fpos = uri.find(\",\")\n        if fpos == -1:\n            return None\n\n        try:\n            data.append(base64.b64decode(uri[fpos:]).decode('utf-8'))\n        except Exception:\n            # skip bad data\n            continue\n\n    return data\n\n\ndef start_tornado(tornado_server, port):\n    tornado_server.listen(port)\n    logger.info(\"Starting Tornado on port %s\", port)\n    tornado.ioloop.IOLoop.instance().start()\n    logger.info(\"Tornado finished\")\n\n\ndef get_tls_context():\n    ca_cert = config.get('tenant', 'ca_cert')\n\n    tls_dir = config.get('tenant', 'tls_dir')\n\n    if tls_dir == 'default':\n        ca_cert = 'cacert.crt'\n        tls_dir = 'cv_ca'\n\n    # this is relative path, convert to absolute in WORK_DIR\n    if tls_dir[0] != '/':\n        tls_dir = os.path.abspath(os.path.join(config.WORK_DIR, tls_dir))\n\n    logger.info(\"Setting up client TLS in %s\", tls_dir)\n\n    ca_path = os.path.join(tls_dir, ca_cert)\n    my_tls_cert = os.path.join(tls_dir, my_cert)\n    my_tls_priv_key = os.path.join(tls_dir, my_priv_key)\n\n    context = ssl.create_default_context()\n    context.load_verify_locations(cafile=ca_path)\n    context.load_cert_chain(\n        certfile=my_tls_cert, keyfile=my_tls_priv_key)\n    context.verify_mode = ssl.CERT_REQUIRED\n    context.check_hostname = config.getboolean(\n        'general', 'tls_check_hostnames')\n    return context\n\n\ndef main():\n    \"\"\"Main method of the Tenant Webapp Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    webapp_port = config.getint('webapp', 'webapp_port')\n\n    if not config.REQUIRE_ROOT and webapp_port < 1024:\n        webapp_port += 2000\n        logger.warning(\"Running without root, changing port to %d\", webapp_port)\n\n    logger.info('Starting Tenant WebApp (tornado) on port %d use <Ctrl-C> to stop', webapp_port)\n\n    # Figure out where our static files are located\n    if getattr(sys, 'frozen', False):\n        # static directory must be bundled with the script\n        root_dir = os.path.dirname(os.path.abspath(sys.executable))\n    else:\n        # instead try to locate static directory relative to script\n        root_dir = os.path.dirname(os.path.abspath(__file__))\n    if not os.path.exists(root_dir + \"/static/\"):\n        raise Exception(\n            'Static resource directory could not be found in %s!' % (root_dir))\n\n    app = tornado.web.Application([\n        (r\"/webapp/.*\", WebAppHandler),\n        (r\"/(?:v[0-9]/)?agents/.*\", AgentsHandler),\n        (r\"/(?:v[0-9]/)?logs/.*\", AgentsHandler),\n        (r'/static/(.*)', tornado.web.StaticFileHandler,\n         {'path': root_dir + \"/static/\"}),\n        (r\".*\", MainHandler),\n    ])\n\n    # WebApp Server TLS\n    server_context = get_tls_context()\n    server_context.check_hostname = False  # config.getboolean('general', 'tls_check_hostnames')\n    server_context.verify_mode = ssl.CERT_NONE  # ssl.CERT_REQUIRED\n\n    # Set up server\n    server = tornado.httpserver.HTTPServer(app, ssl_options=server_context)\n    server.bind(webapp_port, address='0.0.0.0')\n    server.start(config.getint('cloud_verifier',\n                               'multiprocessing_pool_num_workers'))\n\n    try:\n        tornado.ioloop.IOLoop.instance().start()\n    except KeyboardInterrupt:\n        tornado.ioloop.IOLoop.instance().stop()\n"], "fixing_code": ["#!/usr/bin/python3\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\nimport signal\nimport traceback\nimport sys\nimport functools\nimport asyncio\n\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm.exc import NoResultFound\nimport tornado.ioloop\nimport tornado.web\n\nfrom keylime import config\nfrom keylime import json\nfrom keylime import registrar_client\nfrom keylime.agentstates import AgentAttestStates\nfrom keylime.common import states, validators\nfrom keylime.db.verifier_db import VerfierMain\nfrom keylime.db.verifier_db import VerifierAllowlist\nfrom keylime.db.keylime_db import DBEngineManager, SessionManager\nfrom keylime import keylime_logging\nfrom keylime import cloud_verifier_common\nfrom keylime import revocation_notifier\nfrom keylime import web_util\nfrom keylime import tornado_requests\nfrom keylime import api_version as keylime_api_version\nfrom keylime.failure import MAX_SEVERITY_LABEL, Failure, Component\n\nlogger = keylime_logging.init_logging('cloudverifier')\n\n\ntry:\n    engine = DBEngineManager().make_engine('cloud_verifier')\nexcept SQLAlchemyError as err:\n    logger.error('Error creating SQL engine or session: %s', err)\n    sys.exit(1)\n\n\ndef get_session():\n    return SessionManager().make_session(engine)\n\n\ndef get_AgentAttestStates():\n    return AgentAttestStates.get_instance()\n\n\n# The \"exclude_db\" dict values are removed from the response before adding the dict to the DB\n# This is because we want these values to remain ephemeral and not stored in the database.\nexclude_db = {\n    'registrar_data': '',\n    'nonce': '',\n    'b64_encrypted_V': '',\n    'provide_V': True,\n    'num_retries': 0,\n    'pending_event': None,\n    'first_verified': False,\n    # the following 3 items are updated to VerifierDB only when the AgentState is stored\n    'boottime': '',\n    'ima_pcrs': [],\n    'pcr10': '',\n    'next_ima_ml_entry': 0,\n    'learned_ima_keyrings': {},\n    'ssl_context': None,\n}\n\n\ndef _from_db_obj(agent_db_obj):\n    fields = [ 'agent_id', \\\n                'v', \\\n                'ip', \\\n                'port', \\\n                'operational_state', \\\n                'public_key', \\\n                'tpm_policy', \\\n                'vtpm_policy', \\\n                'meta_data', \\\n                'mb_refstate', \\\n                'allowlist', \\\n                'ima_sign_verification_keys', \\\n                'revocation_key', \\\n                'accept_tpm_hash_algs', \\\n                'accept_tpm_encryption_algs', \\\n                'accept_tpm_signing_algs', \\\n                'hash_alg', \\\n                'enc_alg', \\\n                'sign_alg', \\\n                'boottime', \\\n                'ima_pcrs', \\\n                'pcr10', \\\n                'next_ima_ml_entry', \\\n                'learned_ima_keyrings',\n                'supported_version',\n                'mtls_cert',\n                'ak_tpm',\n               ]\n    agent_dict = {}\n    for field in fields:\n        agent_dict[field] = getattr(agent_db_obj, field, None)\n    return agent_dict\n\n\ndef verifier_db_delete_agent(session, agent_id):\n    get_AgentAttestStates().delete_by_agent_id(agent_id)\n    session.query(VerfierMain).filter_by(\n                  agent_id=agent_id).delete()\n    session.commit()\n\n\ndef store_attestation_state(agentAttestState):\n    # Only store if IMA log was evaluated\n    if agentAttestState.get_ima_pcrs():\n        session = get_session()\n        try:\n            update_agent = session.query(VerfierMain).get(agentAttestState.get_agent_id())\n            update_agent.boottime = agentAttestState.get_boottime()\n            update_agent.next_ima_ml_entry = agentAttestState.get_next_ima_ml_entry()\n            ima_pcrs_dict = agentAttestState.get_ima_pcrs()\n            update_agent.ima_pcrs = list(ima_pcrs_dict.keys())\n            for pcr_num, value in ima_pcrs_dict.items():\n                setattr(update_agent, 'pcr%d' % pcr_num, value)\n            update_agent.learned_ima_keyrings = agentAttestState.get_ima_keyrings().to_json()\n            try:\n                session.add(update_agent)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error on storing attestation state: %s', e)\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error on storing attestation state: %s', e)\n\n\nclass BaseHandler(tornado.web.RequestHandler):\n    def prepare(self):  # pylint: disable=W0235\n        super().prepare()\n\n    def write_error(self, status_code, **kwargs):\n\n        self.set_header('Content-Type', 'text/json')\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            lines = []\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                lines.append(line)\n            self.finish(json.dumps({\n                'code': status_code,\n                'status': self._reason,\n                'traceback': lines,\n                'results': {},\n            }))\n        else:\n            self.finish(json.dumps({\n                'code': status_code,\n                'status': self._reason,\n                'results': {},\n            }))\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass MainHandler(tornado.web.RequestHandler):\n\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def get(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /agents/ interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\nclass VersionHandler(BaseHandler):\n\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def get(self):\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(self, 405, \"Not Implemented\")\n            return\n\n        if \"version\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning('GET returning 400 response. URI not supported: %s', self.request.path)\n            return\n\n        version_info = {\n            \"current_version\": keylime_api_version.current_version(),\n            \"supported_versions\": keylime_api_version.all_versions(),\n        }\n\n        web_util.echo_json_response(self, 200, \"Success\", version_info)\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use GET interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AgentsHandler(BaseHandler):\n    mtls_options = None  # Stores the cert, key and password used by the verifier for mTLS connections\n\n    def initialize(self, mtls_options):\n        self.mtls_options = mtls_options\n\n    def head(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def get(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for GETing, i.e. /agents. All other GET uri's\n        will return errors. Agents requests require a single agent_id parameter which identifies the\n        agent to be returned. If the agent_id is not found, a 404 response is returned.  If the agent_id\n        was not found, it either completed successfully, or failed.  If found, the agent_id is still polling\n        to contact the Cloud Agent.\n        \"\"\"\n        session = get_session()\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('GET returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if (agent_id is not None) and (agent_id != ''):\n            # If the agent ID is not valid (wrong set of characters),\n            # just do nothing.\n            if not validators.valid_agent_id(agent_id):\n                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                logger.error(\"GET received an invalid agent ID: %s\", agent_id)\n                return\n\n            try:\n                agent = session.query(VerfierMain).filter_by(\n                    agent_id=agent_id).one_or_none()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n            if agent is not None:\n                response = cloud_verifier_common.process_get_status(agent)\n                web_util.echo_json_response(self, 200, \"Success\", response)\n            else:\n                web_util.echo_json_response(self, 404, \"agent id not found\")\n        else:\n            json_response = None\n            if \"bulk\" in rest_params.keys():\n                agent_list = None\n\n                if (\"verifier\" in rest_params.keys()) and (rest_params[\"verifier\"] != ''):\n                    agent_list = session.query(VerfierMain).filter_by(verifier_id=rest_params[\"verifier\"]).all()\n                else:\n                    agent_list = session.query(VerfierMain).all()\n\n                json_response = {}\n                for agent in agent_list:\n                    json_response[agent.agent_id] = cloud_verifier_common.process_get_status(agent)\n\n                web_util.echo_json_response(self, 200, \"Success\", json_response)\n            else:\n                if (\"verifier\" in rest_params.keys()) and (rest_params[\"verifier\"] != ''):\n                    json_response = session.query(VerfierMain.agent_id).filter_by(\n                        verifier_id=rest_params[\"verifier\"]).all()\n                else:\n                    json_response = session.query(VerfierMain.agent_id).all()\n\n                web_util.echo_json_response(self, 200, \"Success\", {\n                    'uuids': json_response})\n\n            logger.info('GET returning 200 response for agent_id list')\n\n    def delete(self):\n        \"\"\"This method handles the DELETE requests to remove agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n        session = get_session()\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('DELETE returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        # If the agent ID is not valid (wrong set of characters), just\n        # do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n            logger.error(\"DELETE received an invalid agent ID: %s\", agent_id)\n            return\n\n        try:\n            agent = session.query(VerfierMain).filter_by(\n                agent_id=agent_id).first()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        if agent is None:\n            web_util.echo_json_response(self, 404, \"agent id not found\")\n            logger.info('DELETE returning 404 response. agent id: %s not found.', agent_id)\n            return\n\n        verifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n        if verifier_id != agent.verifier_id:\n            web_util.echo_json_response(self, 404, \"agent id associated to this verifier\")\n            logger.info('DELETE returning 404 response. agent id: %s not associated to this verifer.', agent_id)\n            return\n\n        op_state = agent.operational_state\n        if op_state in (states.SAVED, states.FAILED, states.TERMINATED,\n                        states.TENANT_FAILED, states.INVALID_QUOTE):\n            try:\n                verifier_db_delete_agent(session, agent_id)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n            web_util.echo_json_response(self, 200, \"Success\")\n            logger.info('DELETE returning 200 response for agent id: %s', agent_id)\n        else:\n            try:\n                update_agent = session.query(VerfierMain).get(agent_id)\n                update_agent.operational_state = states.TERMINATED\n                try:\n                    session.add(update_agent)\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                session.commit()\n                web_util.echo_json_response(self, 202, \"Accepted\")\n                logger.info('DELETE returning 202 response for agent id: %s', agent_id)\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n    def post(self):\n        \"\"\"This method handles the POST requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's will return errors.\n        agents requests require a json block sent in the body\n        \"\"\"\n        session = get_session()\n        try:\n            rest_params = web_util.get_restful_params(self.request.uri)\n            if rest_params is None:\n                web_util.echo_json_response(\n                    self, 405, \"Not Implemented: Use /agents/ interface\")\n                return\n\n            if not rest_params[\"api_version\"]:\n                web_util.echo_json_response(self, 400, \"API Version not supported\")\n                return\n\n            if \"agents\" not in rest_params:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning('POST returning 400 response. uri not supported: %s', self.request.path)\n                return\n\n            agent_id = rest_params[\"agents\"]\n\n            if agent_id is not None:\n                # If the agent ID is not valid (wrong set of\n                # characters), just do nothing.\n                if not validators.valid_agent_id(agent_id):\n                    web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                    logger.error(\"POST received an invalid agent ID: %s\", agent_id)\n                    return\n\n                content_length = len(self.request.body)\n                if content_length == 0:\n                    web_util.echo_json_response(\n                        self, 400, \"Expected non zero content length\")\n                    logger.warning('POST returning 400 response. Expected non zero content length.')\n                else:\n                    json_body = json.loads(self.request.body)\n                    agent_data = {}\n                    agent_data['v'] = json_body['v']\n                    agent_data['ip'] = json_body['cloudagent_ip']\n                    agent_data['port'] = int(json_body['cloudagent_port'])\n                    agent_data['operational_state'] = states.START\n                    agent_data['public_key'] = \"\"\n                    agent_data['tpm_policy'] = json_body['tpm_policy']\n                    agent_data['vtpm_policy'] = json_body['vtpm_policy']\n                    agent_data['meta_data'] = json_body['metadata']\n                    agent_data['allowlist'] = json_body['allowlist']\n                    agent_data['mb_refstate'] = json_body['mb_refstate']\n                    agent_data['ima_sign_verification_keys'] = json_body['ima_sign_verification_keys']\n                    agent_data['revocation_key'] = json_body['revocation_key']\n                    agent_data['accept_tpm_hash_algs'] = json_body['accept_tpm_hash_algs']\n                    agent_data['accept_tpm_encryption_algs'] = json_body['accept_tpm_encryption_algs']\n                    agent_data['accept_tpm_signing_algs'] = json_body['accept_tpm_signing_algs']\n                    agent_data['supported_version'] = json_body['supported_version']\n                    agent_data['hash_alg'] = \"\"\n                    agent_data['enc_alg'] = \"\"\n                    agent_data['sign_alg'] = \"\"\n                    agent_data['agent_id'] = agent_id\n                    agent_data['boottime'] = 0\n                    agent_data['ima_pcrs'] = []\n                    agent_data['pcr10'] = None\n                    agent_data['next_ima_ml_entry'] = 0\n                    agent_data['learned_ima_keyrings'] = {}\n                    agent_data['verifier_id'] = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n                    agent_data['verifier_ip'] = config.get('cloud_verifier', 'cloudverifier_ip')\n                    agent_data['verifier_port'] = config.get('cloud_verifier', 'cloudverifier_port')\n\n                    # We fetch the registrar data directly here because we require it for connecting to the agent\n                    # using mTLS\n                    registrar_client.init_client_tls('cloud_verifier')\n                    registrar_data = registrar_client.getData(config.get(\"cloud_verifier\", \"registrar_ip\"),\n                                                              config.get(\"cloud_verifier\", \"registrar_port\"), agent_id)\n                    if registrar_data is None:\n                        web_util.echo_json_response(self, 400,\n                                                    f\"Data for agent {agent_id} could not be found in registrar!\")\n                        logger.warning(f\"Data for agent {agent_id} could not be found in registrar!\")\n                        return\n\n                    agent_data['mtls_cert'] = registrar_data.get('mtls_cert', None)\n                    agent_data['ak_tpm'] = registrar_data['aik_tpm']\n\n                    # TODO: Always error for v1.0 version after initial upgrade\n                    if registrar_data.get('mtls_cert', None) is None and agent_data['supported_version'] != \"1.0\":\n                        web_util.echo_json_response(self, 400, \"mTLS certificate for agent is required!\")\n                        return\n\n                    is_valid, err_msg = cloud_verifier_common.validate_agent_data(agent_data)\n                    if not is_valid:\n                        web_util.echo_json_response(self, 400, err_msg)\n                        logger.warning(err_msg)\n                        return\n\n                    try:\n                        new_agent_count = session.query(\n                            VerfierMain).filter_by(agent_id=agent_id).count()\n                    except SQLAlchemyError as e:\n                        logger.error('SQLAlchemy Error: %s', e)\n                        raise e\n\n                    # don't allow overwriting\n\n                    if new_agent_count > 0:\n                        web_util.echo_json_response(\n                            self, 409, \"Agent of uuid %s already exists\" % (agent_id))\n                        logger.warning(\"Agent of uuid %s already exists\", agent_id)\n                    else:\n                        try:\n                            # Add the agent and data\n                            session.add(VerfierMain(**agent_data))\n                            session.commit()\n                        except SQLAlchemyError as e:\n                            logger.error('SQLAlchemy Error: %s', e)\n                            raise e\n\n                        for key in list(exclude_db.keys()):\n                            agent_data[key] = exclude_db[key]\n\n                        # Prepare SSLContext for mTLS connections\n                        # TODO: drop special handling after initial upgrade\n                        mtls_cert = registrar_data.get('mtls_cert', None)\n                        agent_data['ssl_context'] = None\n                        if mtls_cert:\n                            agent_data['ssl_context'] = web_util.generate_agent_mtls_context(mtls_cert,\n                                                                                             self.mtls_options)\n\n                        if agent_data['ssl_context'] is None:\n                            logger.warning('Connecting to agent without mTLS: %s', agent_id)\n\n                        asyncio.ensure_future(\n                            process_agent(agent_data, states.GET_QUOTE))\n                        web_util.echo_json_response(self, 200, \"Success\")\n                        logger.info('POST returning 200 response for adding agent id: %s', agent_id)\n            else:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"POST returning 400 response. uri not supported\")\n        except Exception as e:\n            web_util.echo_json_response(self, 400, \"Exception error: %s\" % e)\n            logger.warning(\"POST returning 400 response. Exception error: %s\", e)\n            logger.exception(e)\n\n    def put(self):\n        \"\"\"This method handles the PUT requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's will return errors.\n        agents requests require a json block sent in the body\n        \"\"\"\n        session = get_session()\n        try:\n            rest_params = web_util.get_restful_params(self.request.uri)\n            if rest_params is None:\n                web_util.echo_json_response(\n                    self, 405, \"Not Implemented: Use /agents/ interface\")\n                return\n\n            if not rest_params[\"api_version\"]:\n                web_util.echo_json_response(self, 400, \"API Version not supported\")\n                return\n\n            if \"agents\" not in rest_params:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning('PUT returning 400 response. uri not supported: %s', self.request.path)\n                return\n\n            agent_id = rest_params[\"agents\"]\n\n            if agent_id is None:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"PUT returning 400 response. uri not supported\")\n\n            # If the agent ID is not valid (wrong set of characters),\n            # just do nothing.\n            if not validators.valid_agent_id(agent_id):\n                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                logger.error(\"PUT received an invalid agent ID: %s\", agent_id)\n                return\n\n            try:\n                verifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n                agent = session.query(VerfierMain).filter_by(\n                    agent_id=agent_id, verifier_id=verifier_id).one()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise e\n\n            if agent is None:\n                web_util.echo_json_response(self, 404, \"agent id not found\")\n                logger.info('PUT returning 404 response. agent id: %s not found.', agent_id)\n                return\n\n            if \"reactivate\" in rest_params:\n                if not isinstance(agent, dict):\n                    agent = _from_db_obj(agent)\n                if agent[\"mtls_cert\"]:\n                    agent['ssl_context'] = web_util.generate_agent_mtls_context(agent[\"mtls_cert\"], self.mtls_options)\n                agent[\"operational_state\"] = states.START\n                asyncio.ensure_future(\n                    process_agent(agent, states.GET_QUOTE))\n                web_util.echo_json_response(self, 200, \"Success\")\n                logger.info('PUT returning 200 response for agent id: %s', agent_id)\n            elif \"stop\" in rest_params:\n                # do stuff for terminate\n                logger.debug(\"Stopping polling on %s\", agent_id)\n                try:\n                    session.query(VerfierMain).filter(VerfierMain.agent_id == agent_id).update(\n                        {'operational_state': states.TENANT_FAILED})\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n\n                web_util.echo_json_response(self, 200, \"Success\")\n                logger.info('PUT returning 200 response for agent id: %s', agent_id)\n            else:\n                web_util.echo_json_response(self, 400, \"uri not supported\")\n                logger.warning(\"PUT returning 400 response. uri not supported\")\n\n        except Exception as e:\n            web_util.echo_json_response(self, 400, \"Exception error: %s\" % e)\n            logger.warning(\"PUT returning 400 response. Exception error: %s\", e)\n            logger.exception(e)\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AllowlistHandler(BaseHandler):\n    def head(self):\n        web_util.echo_json_response(\n            self, 400, \"Allowlist handler: HEAD Not Implemented\")\n\n    def get(self):\n        \"\"\"Get an allowlist\n\n        GET /allowlists/{name}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            logger.warning(\n                'GET returning 400 response: ' + self.request.path)\n            return\n\n        session = get_session()\n        try:\n            allowlist = session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).one()\n        except NoResultFound:\n            web_util.echo_json_response(self, 404, \"Allowlist %s not found\" % allowlist_name)\n            return\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        response = {}\n        for field in ('name', 'tpm_policy', 'vtpm_policy', 'ima_policy'):\n            response[field] = getattr(allowlist, field, None)\n        web_util.echo_json_response(self, 200, 'Success', response)\n\n    def delete(self):\n        \"\"\"Delete an allowlist\n\n        DELETE /allowlists/{name}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            logger.warning(\n                'DELETE returning 400 response: ' + self.request.path)\n            return\n\n        session = get_session()\n        try:\n            session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).one()\n        except NoResultFound:\n            web_util.echo_json_response(self, 404, \"Allowlist %s not found\" % allowlist_name)\n            return\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        try:\n            session.query(VerifierAllowlist).filter_by(\n                name=allowlist_name).delete()\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            web_util.echo_json_response(self, 500, \"Failed to get allowlist\")\n            raise\n\n        # NOTE(kaifeng) 204 Can not have response body, but current helper\n        # doesn't support this case.\n        self.set_status(204)\n        self.set_header('Content-Type', 'application/json')\n        self.finish()\n        logger.info(\n            'DELETE returning 204 response for allowlist: ' + allowlist_name)\n\n    def post(self):\n        \"\"\"Create an allowlist\n\n        POST /allowlists/{name}\n        body: {\"tpm_policy\": {..}, \"vtpm_policy\": {..}\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None or 'allowlists' not in rest_params:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        allowlist_name = rest_params['allowlists']\n        if allowlist_name is None:\n            web_util.echo_json_response(self, 400, \"Invalid URL\")\n            return\n\n        content_length = len(self.request.body)\n        if content_length == 0:\n            web_util.echo_json_response(\n                self, 400, \"Expected non zero content length\")\n            logger.warning(\n                'POST returning 400 response. Expected non zero content length.')\n            return\n\n        allowlist = {}\n        json_body = json.loads(self.request.body)\n        allowlist['name'] = allowlist_name\n        tpm_policy = json_body.get('tpm_policy')\n        if tpm_policy:\n            allowlist['tpm_policy'] = tpm_policy\n        vtpm_policy = json_body.get('vtpm_policy')\n        if vtpm_policy:\n            allowlist['vtpm_policy'] = vtpm_policy\n        ima_policy = json_body.get('ima_policy')\n        if ima_policy:\n            allowlist['ima_policy'] = ima_policy\n\n        session = get_session()\n        # don't allow overwritting\n        try:\n            al_count = session.query(\n                VerifierAllowlist).filter_by(name=allowlist_name).count()\n            if al_count > 0:\n                web_util.echo_json_response(\n                    self, 409, \"Allowlist with name %s already exists\" % allowlist_name)\n                logger.warning(\n                    \"Allowlist with name %s already exists\" % allowlist_name)\n                return\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            raise\n\n        try:\n            # Add the agent and data\n            session.add(VerifierAllowlist(**allowlist))\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error(f'SQLAlchemy Error: {e}')\n            raise\n\n        web_util.echo_json_response(self, 201)\n        logger.info('POST returning 201')\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 400, \"Allowlist handler: PUT Not Implemented\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nasync def invoke_get_quote(agent, need_pubkey):\n    failure = Failure(Component.INTERNAL, [\"verifier\"])\n    if agent is None:\n        raise Exception(\"agent deleted while being processed\")\n    params = cloud_verifier_common.prepare_get_quote(agent)\n\n    partial_req = \"1\"\n    if need_pubkey:\n        partial_req = \"0\"\n\n    # TODO: remove special handling after initial upgrade\n    if agent['ssl_context']:\n        res = tornado_requests.request(\"GET\",\n                                       \"https://%s:%d/v%s/quotes/integrity?nonce=%s&mask=%s&vmask=%s&partial=%s&ima_ml_entry=%d\" %\n                                       (agent['ip'], agent['port'], agent['supported_version'], params[\"nonce\"], params[\"mask\"], params['vmask'], partial_req, params['ima_ml_entry']),\n                                       context=agent['ssl_context'])\n    else:\n        res = tornado_requests.request(\"GET\",\n                                       \"http://%s:%d/v%s/quotes/integrity?nonce=%s&mask=%s&vmask=%s&partial=%s&ima_ml_entry=%d\" %\n                                       (agent['ip'], agent['port'], agent['supported_version'], params[\"nonce\"], params[\"mask\"],\n                                        params['vmask'], partial_req, params['ima_ml_entry']))\n    response = await res\n\n    if response.status_code != 200:\n        # this is a connection error, retry get quote\n        if response.status_code in [500, 599]:\n            asyncio.ensure_future(process_agent(\n                agent, states.GET_QUOTE_RETRY))\n        else:\n            # catastrophic error, do not continue\n            logger.critical(\"Unexpected Get Quote response error for cloud agent %s, Error: %s\", agent['agent_id'], response.status_code)\n            failure.add_event(\"no_quote\", \"Unexpected Get Quote reponse from agent\", False)\n            asyncio.ensure_future(process_agent(agent, states.FAILED, failure))\n    else:\n        try:\n            json_response = json.loads(response.body)\n\n            # validate the cloud agent response\n            if 'provide_V' not in agent :\n                agent['provide_V'] = True\n            agentAttestState = get_AgentAttestStates().get_by_agent_id(agent['agent_id'])\n            failure = cloud_verifier_common.process_quote_response(agent, json_response['results'], agentAttestState)\n            if not failure:\n                if agent['provide_V']:\n                    asyncio.ensure_future(process_agent(agent, states.PROVIDE_V))\n                else:\n                    asyncio.ensure_future(process_agent(agent, states.GET_QUOTE))\n            else:\n                asyncio.ensure_future(process_agent(agent, states.INVALID_QUOTE, failure))\n\n            # store the attestation state\n            store_attestation_state(agentAttestState)\n\n        except Exception as e:\n            logger.exception(e)\n\n\nasync def invoke_provide_v(agent):\n    failure = Failure(Component.INTERNAL, [\"verifier\"])\n    if agent is None:\n        raise Exception(\"Agent deleted while being processed\")\n    try:\n        if agent['pending_event'] is not None:\n            agent['pending_event'] = None\n    except KeyError:\n        pass\n    v_json_message = cloud_verifier_common.prepare_v(agent)\n\n    # TODO: remove special handling after initial upgrade\n    if agent['ssl_context']:\n        res = tornado_requests.request(\n            \"POST\", \"https://%s:%d/v%s/keys/vkey\" % (agent['ip'], agent['port'], agent['supported_version']),\n            data=v_json_message, context=agent['ssl_context'])\n    else:\n        res = tornado_requests.request(\n            \"POST\", \"http://%s:%d/v%s/keys/vkey\" % (agent['ip'], agent['port'], agent['supported_version']),\n            data=v_json_message)\n\n    response = await res\n\n    if response.status_code != 200:\n        if response.status_code in [500, 599]:\n            asyncio.ensure_future(\n                process_agent(agent, states.PROVIDE_V_RETRY))\n        else:\n            # catastrophic error, do not continue\n            logger.critical(\"Unexpected Provide V response error for cloud agent %s, Error: %s\", agent['agent_id'], response.status_code)\n            failure.add_event(\"no_v\", {\"message\": \"Unexpected provide V response\", \"data\": response.status_code}, False)\n            asyncio.ensure_future(process_agent(agent, states.FAILED, failure))\n    else:\n        asyncio.ensure_future(process_agent(agent, states.GET_QUOTE))\n\n\nasync def process_agent(agent, new_operational_state, failure=Failure(Component.INTERNAL, [\"verifier\"])):\n    # Convert to dict if the agent arg is a db object\n    if not isinstance(agent, dict):\n        agent = _from_db_obj(agent)\n\n    session = get_session()\n    try:  # pylint: disable=R1702\n        main_agent_operational_state = agent['operational_state']\n        try:\n            stored_agent = session.query(VerfierMain).filter_by(\n                agent_id=str(agent['agent_id'])).first()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        # if the user did terminated this agent\n        if stored_agent.operational_state == states.TERMINATED:\n            logger.warning(\"Agent %s terminated by user.\", agent['agent_id'])\n            if agent['pending_event'] is not None:\n                tornado.ioloop.IOLoop.current().remove_timeout(\n                    agent['pending_event'])\n            verifier_db_delete_agent(session, agent['agent_id'])\n            return\n\n        # if the user tells us to stop polling because the tenant quote check failed\n        if stored_agent.operational_state == states.TENANT_FAILED:\n            logger.warning(\"Agent %s has failed tenant quote. Stopping polling\",  agent['agent_id'])\n            if agent['pending_event'] is not None:\n                tornado.ioloop.IOLoop.current().remove_timeout(\n                    agent['pending_event'])\n            return\n\n        # If failed during processing, log regardless and drop it on the floor\n        # The administration application (tenant) can GET the status and act accordingly (delete/retry/etc).\n        if new_operational_state in (states.FAILED, states.INVALID_QUOTE):\n            assert failure, \"States FAILED and INVALID QUOTE should only be reached with a failure message\"\n\n            if agent.get('severity_level') is None or agent['severity_level'] < failure.highest_severity.severity:\n                agent['severity_level'] = failure.highest_severity.severity\n                agent['last_event_id'] = failure.highest_severity_event.event_id\n                agent['operational_state'] = new_operational_state\n\n                # issue notification for invalid quotes\n                if new_operational_state == states.INVALID_QUOTE:\n                    cloud_verifier_common.notify_error(agent, event=failure.highest_severity_event)\n\n                # When the failure is irrecoverable we stop polling the agent\n                if not failure.recoverable or failure.highest_severity == MAX_SEVERITY_LABEL:\n                    if agent['pending_event'] is not None:\n                        tornado.ioloop.IOLoop.current().remove_timeout(\n                            agent['pending_event'])\n                    for key in exclude_db:\n                        if key in agent:\n                            del agent[key]\n                    session.query(VerfierMain).filter_by(\n                        agent_id=agent['agent_id']).update(agent)\n                    session.commit()\n\n        # propagate all state, but remove none DB keys first (using exclude_db)\n        try:\n            agent_db = dict(agent)\n            for key in exclude_db:\n                if key in agent_db:\n                    del agent_db[key]\n\n            session.query(VerfierMain).filter_by(\n                agent_id=agent_db['agent_id']).update(agent_db)\n            session.commit()\n        except SQLAlchemyError as e:\n            logger.error('SQLAlchemy Error: %s', e)\n\n        # If agent was in a failed state we check if we either stop polling\n        # or just add it again to the event loop\n        if new_operational_state in [states.FAILED, states.INVALID_QUOTE]:\n            if not failure.recoverable or failure.highest_severity == MAX_SEVERITY_LABEL:\n                logger.warning(\"Agent %s failed, stopping polling\", agent['agent_id'])\n                return\n\n            await invoke_get_quote(agent, False)\n            return\n\n        # if new, get a quote\n        if (main_agent_operational_state == states.START and\n                new_operational_state == states.GET_QUOTE):\n            agent['num_retries'] = 0\n            agent['operational_state'] = states.GET_QUOTE\n            await invoke_get_quote(agent, True)\n            return\n\n        if (main_agent_operational_state == states.GET_QUOTE and\n                new_operational_state == states.PROVIDE_V):\n            agent['num_retries'] = 0\n            agent['operational_state'] = states.PROVIDE_V\n            await invoke_provide_v(agent)\n            return\n\n        if (main_agent_operational_state in (states.PROVIDE_V, states.GET_QUOTE) and\n                new_operational_state == states.GET_QUOTE):\n            agent['num_retries'] = 0\n            interval = config.getfloat('cloud_verifier', 'quote_interval')\n            agent['operational_state'] = states.GET_QUOTE\n            if interval == 0:\n                await invoke_get_quote(agent, False)\n            else:\n                logger.debug(\"Setting up callback to check again in %f seconds\", interval)\n                # set up a call back to check again\n                cb = functools.partial(invoke_get_quote, agent, False)\n                pending = tornado.ioloop.IOLoop.current().call_later(interval, cb)\n                agent['pending_event'] = pending\n            return\n\n        maxr = config.getint('cloud_verifier', 'max_retries')\n        retry = config.getfloat('cloud_verifier', 'retry_interval')\n        if (main_agent_operational_state == states.GET_QUOTE and\n                new_operational_state == states.GET_QUOTE_RETRY):\n            if agent['num_retries'] >= maxr:\n                logger.warning(\"Agent %s was not reachable for quote in %d tries, setting state to FAILED\", agent['agent_id'], maxr)\n                failure.add_event(\"not_reachable\", \"agent was not reachable from verifier\", False)\n                if agent['first_verified']:  # only notify on previously good agents\n                    cloud_verifier_common.notify_error(\n                        agent, msgtype='comm_error', event=failure.highest_severity_event)\n                else:\n                    logger.debug(\"Communication error for new agent. No notification will be sent\")\n                await process_agent(agent, states.FAILED, failure)\n            else:\n                agent['operational_state'] = states.GET_QUOTE\n                cb = functools.partial(invoke_get_quote, agent, True)\n                agent['num_retries'] += 1\n                logger.info(\"Connection to %s refused after %d/%d tries, trying again in %f seconds\", agent['ip'], agent['num_retries'], maxr, retry)\n                tornado.ioloop.IOLoop.current().call_later(retry, cb)\n            return\n\n        if (main_agent_operational_state == states.PROVIDE_V and\n                new_operational_state == states.PROVIDE_V_RETRY):\n            if agent['num_retries'] >= maxr:\n                logger.warning(\"Agent %s was not reachable to provide v in %d tries, setting state to FAILED\", agent['agent_id'], maxr)\n                failure.add_event(\"not_reachable_v\", \"agent was not reachable to provide V\", False)\n                cloud_verifier_common.notify_error(\n                    agent, msgtype='comm_error', event=failure.highest_severity_event)\n                await process_agent(agent, states.FAILED, failure)\n            else:\n                agent['operational_state'] = states.PROVIDE_V\n                cb = functools.partial(invoke_provide_v, agent)\n                agent['num_retries'] += 1\n                logger.info(\"Connection to %s refused after %d/%d tries, trying again in %f seconds\", agent['ip'], agent['num_retries'], maxr, retry)\n                tornado.ioloop.IOLoop.current().call_later(retry, cb)\n            return\n        raise Exception(\"nothing should ever fall out of this!\")\n\n    except Exception as e:\n        logger.error(\"Polling thread error: %s\", e)\n        logger.exception(e)\n\n\nasync def activate_agents(verifier_id, verifier_ip, verifier_port, mtls_options):\n    session = get_session()\n    aas = get_AgentAttestStates()\n    try:\n        agents = session.query(VerfierMain).filter_by(\n            verifier_id=verifier_id).all()\n        for agent in agents:\n            agent.verifier_ip = verifier_ip\n            agent.verifier_host = verifier_port\n            agent_run = _from_db_obj(agent)\n            if agent_run[\"mtls_cert\"]:\n                agent_run[\"ssl_context\"] = web_util.generate_agent_mtls_context(agent_run[\"mtls_cert\"], mtls_options)\n            if agent.operational_state == states.START:\n                asyncio.ensure_future(process_agent(agent_run, states.GET_QUOTE))\n            if agent.boottime:\n                ima_pcrs_dict = {}\n                for pcr_num in agent.ima_pcrs:\n                    ima_pcrs_dict[pcr_num] = getattr(agent, 'pcr%d' % pcr_num)\n                aas.add(agent.agent_id, agent.boottime, ima_pcrs_dict, agent.next_ima_ml_entry, agent.learned_ima_keyrings)\n        session.commit()\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\ndef start_tornado(tornado_server, port):\n    tornado_server.listen(port)\n    print(\"Starting Torando on port \" + str(port))\n    tornado.ioloop.IOLoop.instance().start()\n    print(\"Tornado finished\")\n\n\ndef main():\n    \"\"\"Main method of the Cloud Verifier Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    cloudverifier_port = config.get('cloud_verifier', 'cloudverifier_port')\n    cloudverifier_host = config.get('cloud_verifier', 'cloudverifier_ip')\n    cloudverifier_id = config.get('cloud_verifier', 'cloudverifier_id', fallback=cloud_verifier_common.DEFAULT_VERIFIER_ID)\n\n    # allow tornado's max upload size to be configurable\n    max_upload_size = None\n    if config.has_option('cloud_verifier', 'max_upload_size'):\n        max_upload_size = int(config.get('cloud_verifier', 'max_upload_size'))\n\n    VerfierMain.metadata.create_all(engine, checkfirst=True)\n    session = get_session()\n    try:\n        query_all = session.query(VerfierMain).all()\n        for row in query_all:\n            if row.operational_state in states.APPROVED_REACTIVATE_STATES:\n                row.operational_state = states.START\n        session.commit()\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\n    num = session.query(VerfierMain.agent_id).count()\n    if num > 0:\n        agent_ids = session.query(VerfierMain.agent_id).all()\n        logger.info(\"Agent ids in db loaded from file: %s\", agent_ids)\n\n    logger.info('Starting Cloud Verifier (tornado) on port %s, use <Ctrl-C> to stop', cloudverifier_port)\n\n    # print out API versions we support\n    keylime_api_version.log_api_versions(logger)\n\n    context, mtls_options = web_util.init_mtls(logger=logger)\n\n    # Check for user defined CA to connect to agent\n    agent_mtls_cert = config.get(\"cloud_verifier\", \"agent_mtls_cert\", fallback=None)\n    agent_mtls_private_key = config.get(\"cloud_verifier\", \"agent_mtls_private_key\", fallback=None)\n    agent_mtls_private_key_pw = config.get(\"cloud_verifier\", \"agent_mtls_private_key_pw\", fallback=None)\n\n    # Only set custom options if the cert should not be the same as used by the verifier\n    if agent_mtls_cert != \"CV\":\n        mtls_options = (agent_mtls_cert, agent_mtls_private_key, agent_mtls_private_key_pw)\n\n    app = tornado.web.Application([\n        (r\"/v?[0-9]+(?:\\.[0-9]+)?/agents/.*\", AgentsHandler, {\"mtls_options\": mtls_options}),\n        (r\"/v?[0-9]+(?:\\.[0-9]+)?/allowlists/.*\", AllowlistHandler),\n        (r\"/versions?\", VersionHandler),\n        (r\".*\", MainHandler),\n    ])\n\n    sockets = tornado.netutil.bind_sockets(\n        int(cloudverifier_port), address=cloudverifier_host)\n\n    server = tornado.httpserver.HTTPServer(app, ssl_options=context, max_buffer_size=max_upload_size)\n    server.add_sockets(sockets)\n\n    signal.signal(signal.SIGTERM, lambda *_: sys.exit(0))\n\n    try:\n        server.start(config.getint('cloud_verifier', 'multiprocessing_pool_num_workers'))\n        if tornado.process.task_id() == 0:\n            # Start the revocation notifier only on one process\n            if config.getboolean('cloud_verifier', 'revocation_notifier'):\n                logger.info(\"Starting service for revocation notifications on port %s\",\n                            config.getint('cloud_verifier', 'revocation_notifier_port'))\n                revocation_notifier.start_broker()\n            # Auto activate agents\n            asyncio.ensure_future(activate_agents(cloudverifier_id, cloudverifier_host, cloudverifier_port, mtls_options))\n\n        tornado.ioloop.IOLoop.current().start()\n    except (KeyboardInterrupt, SystemExit):\n        tornado.ioloop.IOLoop.current().stop()\n        if tornado.process.task_id() == 0 and config.getboolean('cloud_verifier', 'revocation_notifier'):\n            revocation_notifier.stop_broker()\n", "#!/usr/bin/python3\n\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport asyncio\nimport http.server\nimport multiprocessing\nimport platform\nimport datetime\nimport signal\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom socketserver import ThreadingMixIn\nimport threading\nimport base64\nimport configparser\nimport uuid\nimport os\nimport socket\nimport sys\nimport time\nimport hashlib\nimport zipfile\nimport io\nimport importlib\nimport shutil\nimport subprocess\nimport psutil\n\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import serialization\n\nfrom keylime import config\nfrom keylime import keylime_logging\nfrom keylime import cmd_exec\nfrom keylime import crypto\nfrom keylime import ima\nfrom keylime import json\nfrom keylime import revocation_notifier\nfrom keylime import registrar_client\nfrom keylime import secure_mount\nfrom keylime import web_util\nfrom keylime import api_version as keylime_api_version\nfrom keylime.common import algorithms, validators\nfrom keylime.tpm.tpm_main import tpm\nfrom keylime.tpm.tpm_abstract import TPM_Utilities\nfrom keylime.tpm.tpm2_objects import pubkey_from_tpm2b_public\n\n# Configure logger\nlogger = keylime_logging.init_logging('cloudagent')\n\n# lock required for multithreaded operation\nuvLock = threading.Lock()\n\n# Instaniate tpm\ntpm_instance = tpm(need_hw_tpm=True)\n\n\nclass Handler(BaseHTTPRequestHandler):\n    parsed_path = ''\n\n    def do_HEAD(self):\n        \"\"\"Not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_GET(self):\n        \"\"\"This method services the GET request typically from either the Tenant or the Cloud Verifier.\n\n        Only tenant and cloudverifier uri's are supported. Both requests require a nonce parameter.\n        The Cloud verifier requires an additional mask paramter.  If the uri or parameters are incorrect, a 400 response is returned.\n        \"\"\"\n\n        logger.info('GET invoked from %s with uri: %s', self.client_address, self.path)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /version, /keys/ or /quotes/ interfaces\")\n            return\n\n        if \"version\" in rest_params:\n            version_info = {\n                \"supported_version\": keylime_api_version.current_version()\n            }\n            web_util.echo_json_response(self, 200, version_info)\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"keys\" in rest_params and rest_params['keys'] == 'verify':\n            if self.server.K is None:\n                logger.info('GET key challenge returning 400 response. bootstrap key not available')\n                web_util.echo_json_response(\n                    self, 400, \"Bootstrap key not yet available.\")\n                return\n            if \"challenge\" not in rest_params:\n                logger.info('GET key challenge returning 400 response. No challenge provided')\n                web_util.echo_json_response(\n                    self, 400, \"No challenge provided.\")\n                return\n\n            challenge = rest_params['challenge']\n            response = {}\n            response['hmac'] = crypto.do_hmac(self.server.K, challenge)\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info('GET key challenge returning 200 response.')\n\n        # If agent pubkey requested\n        elif \"keys\" in rest_params and rest_params[\"keys\"] == \"pubkey\":\n            response = {}\n            response['pubkey'] = self.server.rsapublickey_exportable\n\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info('GET pubkey returning 200 response.')\n            return\n\n        elif \"quotes\" in rest_params:\n            nonce = rest_params.get('nonce', None)\n            pcrmask = rest_params.get('mask', None)\n            ima_ml_entry = rest_params.get('ima_ml_entry', '0')\n\n            # if the query is not messed up\n            if nonce is None:\n                logger.warning('GET quote returning 400 response. nonce not provided as an HTTP parameter in request')\n                web_util.echo_json_response(\n                    self, 400, \"nonce not provided as an HTTP parameter in request\")\n                return\n\n            # Sanitization assurance (for tpm.run() tasks below)\n            if not (nonce.isalnum() and\n                    (pcrmask is None or validators.valid_hex(pcrmask)) and\n                    ima_ml_entry.isalnum()):\n                logger.warning('GET quote returning 400 response. parameters should be strictly alphanumeric')\n                web_util.echo_json_response(\n                    self, 400, \"parameters should be strictly alphanumeric\")\n                return\n\n            if len(nonce) > tpm_instance.MAX_NONCE_SIZE:\n                logger.warning('GET quote returning 400 response. Nonce is too long (max size %i): %i',\n                               tpm_instance.MAX_NONCE_SIZE, len(nonce))\n                web_util.echo_json_response(\n                    self, 400, f'Nonce is too long (max size {tpm_instance.MAX_NONCE_SIZE}): {len(nonce)}')\n                return\n\n            # identity quotes are always shallow\n            hash_alg = tpm_instance.defaults['hash']\n            if not tpm_instance.is_vtpm() or rest_params[\"quotes\"] == 'identity':\n                quote = tpm_instance.create_quote(\n                    nonce, self.server.rsapublickey_exportable, pcrmask, hash_alg)\n                imaMask = pcrmask\n\n            # Allow for a partial quote response (without pubkey)\n            enc_alg = tpm_instance.defaults['encrypt']\n            sign_alg = tpm_instance.defaults['sign']\n\n            if \"partial\" in rest_params and (rest_params[\"partial\"] is None or rest_params[\"partial\"] == \"1\"):\n                response = {\n                    'quote': quote,\n                    'hash_alg': hash_alg,\n                    'enc_alg': enc_alg,\n                    'sign_alg': sign_alg,\n                }\n            else:\n                response = {\n                    'quote': quote,\n                    'hash_alg': hash_alg,\n                    'enc_alg': enc_alg,\n                    'sign_alg': sign_alg,\n                    'pubkey': self.server.rsapublickey_exportable,\n                }\n\n            response['boottime'] = self.server.boottime\n\n            # return a measurement list if available\n            if TPM_Utilities.check_mask(imaMask, config.IMA_PCR):\n                ima_ml_entry = int(ima_ml_entry)\n                if ima_ml_entry > self.server.next_ima_ml_entry:\n                    ima_ml_entry = 0\n                ml, nth_entry, num_entries = ima.read_measurement_list(config.IMA_ML, ima_ml_entry)\n                if num_entries > 0:\n                    response['ima_measurement_list'] = ml\n                    response['ima_measurement_list_entry'] = nth_entry\n                    self.server.next_ima_ml_entry = num_entries\n\n            # similar to how IMA log retrievals are triggered by IMA_PCR, we trigger boot logs with MEASUREDBOOT_PCRs\n            # other possibilities would include adding additional data to rest_params to trigger boot log retrievals\n            # generally speaking, retrieving the 15Kbytes of a boot log does not seem significant compared to the\n            # potential Mbytes of an IMA measurement list.\n            if TPM_Utilities.check_mask(imaMask, config.MEASUREDBOOT_PCRS[0]):\n                if not os.path.exists(config.MEASUREDBOOT_ML):\n                    logger.warning(\"TPM2 event log not available: %s\", config.MEASUREDBOOT_ML)\n                else:\n                    with open(config.MEASUREDBOOT_ML, 'rb') as f:\n                        el = base64.b64encode(f.read())\n                    response['mb_measurement_list'] = el\n\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info('GET %s quote returning 200 response.', rest_params[\"quotes\"])\n            return\n\n        else:\n            logger.warning('GET returning 400 response. uri not supported: %s', self.path)\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            return\n\n    def do_POST(self):\n        \"\"\"This method services the POST request typically from either the Tenant or the Cloud Verifier.\n\n        Only tenant and cloudverifier uri's are supported. Both requests require a nonce parameter.\n        The Cloud verifier requires an additional mask parameter.  If the uri or parameters are incorrect, a 400 response is returned.\n        \"\"\"\n        rest_params = web_util.get_restful_params(self.path)\n\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /keys/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if rest_params.get(\"keys\", None) not in [\"ukey\", \"vkey\"]:\n            web_util.echo_json_response(self, 400, \"Only /keys/ukey or /keys/vkey are supported\")\n            return\n\n        content_length = int(self.headers.get('Content-Length', 0))\n        if content_length <= 0:\n            logger.warning('POST returning 400 response, expected content in message. url: %s', self.path)\n            web_util.echo_json_response(self, 400, \"expected content in message\")\n            return\n\n        post_body = self.rfile.read(content_length)\n        try:\n            json_body = json.loads(post_body)\n            b64_encrypted_key = json_body['encrypted_key']\n            decrypted_key = crypto.rsa_decrypt(\n                self.server.rsaprivatekey, base64.b64decode(b64_encrypted_key))\n        except (ValueError, KeyError, TypeError) as e:\n            logger.warning('POST returning 400 response, could not parse body data: %s', e)\n            web_util.echo_json_response(self, 400, \"content is invalid\")\n            return\n\n        have_derived_key = False\n\n        if rest_params[\"keys\"] == \"ukey\":\n            if 'auth_tag' not in json_body:\n                logger.warning('POST returning 400 response, U key provided without an auth_tag')\n                web_util.echo_json_response(self, 400, \"auth_tag is missing\")\n                return\n            self.server.add_U(decrypted_key)\n            self.server.auth_tag = json_body['auth_tag']\n            self.server.payload = json_body.get('payload', None)\n            have_derived_key = self.server.attempt_decryption()\n        elif rest_params[\"keys\"] == \"vkey\":\n            self.server.add_V(decrypted_key)\n            have_derived_key = self.server.attempt_decryption()\n        else:\n            logger.warning('POST returning  response. uri not supported: %s', self.path)\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            return\n        logger.info('POST of %s key returning 200', ('V', 'U')[rest_params[\"keys\"] == \"ukey\"])\n        web_util.echo_json_response(self, 200, \"Success\")\n\n        # no key yet, then we're done\n        if not have_derived_key:\n            return\n\n        # woo hoo we have a key\n        # ok lets write out the key now\n        secdir = secure_mount.mount()  # confirm that storage is still securely mounted\n\n        # clean out the secure dir of any previous info before we extract files\n        if os.path.isdir(\"%s/unzipped\" % secdir):\n            shutil.rmtree(\"%s/unzipped\" % secdir)\n\n        # write out key file\n        f = open(secdir + \"/\" + self.server.enc_keyname, 'w', encoding=\"utf-8\")\n        f.write(base64.b64encode(self.server.K).decode())\n        f.close()\n\n        # stow the U value for later\n        tpm_instance.write_key_nvram(self.server.final_U)\n\n        # optionally extend a hash of they key and payload into specified PCR\n        tomeasure = self.server.K\n\n        # if we have a good key, now attempt to write out the encrypted payload\n        dec_path = os.path.join(secdir,\n                                config.get('cloud_agent', \"dec_payload_file\"))\n        enc_path = os.path.join(config.WORK_DIR, \"encrypted_payload\")\n\n        dec_payload = None\n        enc_payload = None\n        if self.server.payload is not None:\n            dec_payload = crypto.decrypt(\n                self.server.payload, bytes(self.server.K))\n\n            enc_payload = self.server.payload\n        elif os.path.exists(enc_path):\n            # if no payload provided, try to decrypt one from a previous run stored in encrypted_payload\n            with open(enc_path, 'rb') as f:\n                enc_payload = f.read()\n            try:\n                dec_payload = crypto.decrypt(enc_payload, self.server.K)\n                logger.info(\"Decrypted previous payload in %s to %s\", enc_path, dec_path)\n            except Exception as e:\n                logger.warning(\"Unable to decrypt previous payload %s with derived key: %s\", enc_path, e)\n                os.remove(enc_path)\n                enc_payload = None\n\n        # also write out encrypted payload to be decrytped next time\n        if enc_payload is not None:\n            with open(enc_path, 'wb') as f:\n                f.write(self.server.payload.encode('utf-8'))\n\n        # deal with payload\n        payload_thread = None\n        if dec_payload is not None:\n            tomeasure = tomeasure + dec_payload\n            # see if payload is a zip\n            zfio = io.BytesIO(dec_payload)\n            if config.getboolean('cloud_agent', 'extract_payload_zip') and zipfile.is_zipfile(zfio):\n                logger.info(\"Decrypting and unzipping payload to %s/unzipped\", secdir)\n                with zipfile.ZipFile(zfio, 'r')as f:\n                    f.extractall('%s/unzipped' % secdir)\n\n                # run an included script if one has been provided\n                initscript = config.get('cloud_agent', 'payload_script')\n                if initscript != \"\":\n                    def initthread():\n                        env = os.environ.copy()\n                        env['AGENT_UUID'] = self.server.agent_uuid\n                        proc = subprocess.Popen([\"/bin/bash\", initscript], env=env, shell=False, cwd='%s/unzipped' % secdir,\n                                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n                        for line in iter(proc.stdout.readline, b''):\n                            logger.debug(\"init-output: %s\", line.strip())\n                        # should be a no-op as poll already told us it's done\n                        proc.wait()\n\n                    if not os.path.exists(\n                            os.path.join(secdir, \"unzipped\", initscript)):\n                        logger.info(\"No payload script %s found in %s/unzipped\", initscript, secdir)\n                    else:\n                        logger.info(\"Executing payload script: %s/unzipped/%s\", secdir, initscript)\n                        payload_thread = threading.Thread(target=initthread, daemon=True)\n            else:\n                logger.info(\"Decrypting payload to %s\", dec_path)\n                with open(dec_path, 'wb') as f:\n                    f.write(dec_payload)\n            zfio.close()\n\n        # now extend a measurement of the payload and key if there was one\n        pcr = config.getint('cloud_agent', 'measure_payload_pcr')\n        if 0 < pcr < 24:\n            logger.info(\"extending measurement of payload into PCR %s\", pcr)\n            measured = tpm_instance.hashdigest(tomeasure)\n            tpm_instance.extendPCR(pcr, measured)\n\n        if payload_thread is not None:\n            payload_thread.start()\n\n        return\n\n    # pylint: disable=W0622\n    def log_message(self, format, *args):\n        return\n\n# consider using PooledProcessMixIn\n# https://github.com/muayyad-alsadi/python-PooledProcessMixIn\n\n\nclass CloudAgentHTTPServer(ThreadingMixIn, HTTPServer):\n    \"\"\"Http Server which will handle each request in a separate thread.\"\"\"\n\n    # Do not modify directly unless you acquire uvLock. Set chosen for uniqueness of contained values\n    u_set = set()\n    v_set = set()\n\n    rsaprivatekey = None\n    rsapublickey = None\n    rsapublickey_exportable = None\n    mtls_cert_path = None\n    rsakey_path = None\n    mtls_cert = None\n    done = threading.Event()\n    auth_tag = None\n    payload = None\n    enc_keyname = None\n    K = None\n    final_U = None\n    agent_uuid = None\n    next_ima_ml_entry = 0 # The next IMA log offset the verifier may ask for.\n    boottime = int(psutil.boot_time())\n\n    def __init__(self, server_address, RequestHandlerClass, agent_uuid):\n        \"\"\"Constructor overridden to provide ability to pass configuration arguments to the server\"\"\"\n        secdir = secure_mount.mount()\n        keyname = os.path.join(secdir,\n                               config.get('cloud_agent', 'rsa_keyname'))\n        certname = os.path.join(secdir, config.get('cloud_agent', 'mtls_cert'))\n        # read or generate the key depending on configuration\n        if os.path.isfile(keyname):\n            # read in private key\n            logger.debug(\"Using existing key in %s\", keyname)\n            f = open(keyname, \"rb\")\n            rsa_key = crypto.rsa_import_privkey(f.read())\n        else:\n            logger.debug(\"key not found, generating a new one\")\n            rsa_key = crypto.rsa_generate(2048)\n            with open(keyname, \"wb\") as f:\n                f.write(crypto.rsa_export_privkey(rsa_key))\n\n        self.rsakey_path = keyname\n        self.rsaprivatekey = rsa_key\n        self.rsapublickey_exportable = crypto.rsa_export_pubkey(\n            self.rsaprivatekey)\n\n        if os.path.isfile(certname):\n            logger.debug(\"Using existing mTLS cert in %s\", certname)\n            with open(certname, \"rb\") as f:\n                mtls_cert = x509.load_pem_x509_certificate(f.read())\n        else:\n            logger.debug(\"No mTLS certificate found generating a new one\")\n            with open(certname, \"wb\") as f:\n                # By default generate a TLS certificate valid for 5 years\n                valid_util = datetime.datetime.utcnow() + datetime.timedelta(days=(360 * 5))\n                mtls_cert = crypto.generate_selfsigned_cert(agent_uuid, rsa_key, valid_util)\n                f.write(mtls_cert.public_bytes(serialization.Encoding.PEM))\n\n        self.mtls_cert_path = certname\n        self.mtls_cert = mtls_cert\n\n        # attempt to get a U value from the TPM NVRAM\n        nvram_u = tpm_instance.read_key_nvram()\n        if nvram_u is not None:\n            logger.info(\"Existing U loaded from TPM NVRAM\")\n            self.add_U(nvram_u)\n        http.server.HTTPServer.__init__(\n            self, server_address, RequestHandlerClass)\n        self.enc_keyname = config.get('cloud_agent', 'enc_keyname')\n        self.agent_uuid = agent_uuid\n\n    def add_U(self, u):\n        \"\"\"Threadsafe method for adding a U value received from the Tenant\n\n        Do not modify u_set of v_set directly.\n        \"\"\"\n        with uvLock:\n            # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n            if config.INSECURE_DEBUG:\n                logger.debug(\"Adding U len %d data:%s\", len(u), base64.b64encode(u))\n            self.u_set.add(u)\n\n    def add_V(self, v):\n        \"\"\"Threadsafe method for adding a V value received from the Cloud Verifier\n        Do not modify u_set of v_set directly.\n        \"\"\"\n        with uvLock:\n            # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n            if config.INSECURE_DEBUG:\n                logger.debug(\"Adding V: %s\", base64.b64encode(v))\n            self.v_set.add(v)\n\n    def attempt_decryption(self):\n        \"\"\"On reception of a U or V value, this method is called to attempt the decryption of the Cloud Init script\n\n        At least one U and V value must be received in order to attempt encryption. Multiple U and V values are stored\n        to prevent an attacker from sending U/V values to deny service.\n        \"\"\"\n        with uvLock:\n            both_u_and_v_present = False\n            return_value = False\n            for u in self.u_set:\n                for v in self.v_set:\n                    both_u_and_v_present = True\n                    return_value = self.decrypt_check(u, v)\n                    if return_value:\n                        # reset u and v sets\n                        self.u_set = set()\n                        self.v_set = set()\n                        return return_value\n            # TODO check on whether this happens or not.  NVRAM causes trouble\n            if both_u_and_v_present:\n                pass\n                # logger.critical(\"Possible attack from: \" + str(handler.client_address) + \".  Both U (potentially stale from TPM NVRAM) and V present but unsuccessful in attempt to decrypt check value.\")\n            return return_value\n\n    def decrypt_check(self, decrypted_U, decrypted_V):\n        \"\"\"Decrypt the Cloud init script with the passed U and V values.\n\n        This method will access the received auth tag, and may fail if decoy U and V values were received.\n        Do not call directly unless you acquire uvLock. Returns None if decryption unsuccessful, else returns the\n        decrypted agent UUID.\n        \"\"\"\n\n        if self.auth_tag is None:\n            return None\n\n        if len(decrypted_U) != len(decrypted_V):\n            logger.warning(\"Invalid U len %d or V len %d. skipping...\", len(decrypted_U), len(decrypted_V))\n            return None\n\n        candidate_key = crypto.strbitxor(decrypted_U, decrypted_V)\n\n        # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n        if config.INSECURE_DEBUG:\n            logger.debug(\"U: %s\", base64.b64encode(decrypted_U))\n            logger.debug(\"V: %s\", base64.b64encode(decrypted_V))\n            logger.debug(\"K: %s\", base64.b64encode(candidate_key))\n\n        logger.debug(\"auth_tag: %s\", self.auth_tag)\n        ex_mac = crypto.do_hmac(candidate_key, self.agent_uuid)\n\n        if ex_mac == self.auth_tag:\n            logger.info(\"Successfully derived K for UUID %s\", self.agent_uuid)\n            self.final_U = decrypted_U\n            self.K = candidate_key\n            return True\n\n        logger.error(\"Failed to derive K for UUID %s\", self.agent_uuid)\n\n        return False\n\n\ndef revocation_listener():\n    \"\"\"\n    This configures and starts the revocation listener. It is designed to be started in a separate process.\n    \"\"\"\n\n    if not config.getboolean('cloud_agent', 'listen_notfications'):\n        return\n\n    secdir = secure_mount.mount()\n\n    cert_path = config.get('cloud_agent', 'revocation_cert')\n    if cert_path == \"default\":\n        cert_path = os.path.join(secdir,\n                                 \"unzipped/RevocationNotifier-cert.crt\")\n    elif cert_path[0] != '/':\n        # if it is a relative, convert to absolute in work_dir\n        cert_path = os.path.abspath(\n            os.path.join(config.WORK_DIR, cert_path))\n\n    # Callback function handling the revocations\n    def perform_actions(revocation):\n        actionlist = []\n\n        # load the actions from inside the keylime module\n        actionlisttxt = config.get('cloud_agent', 'revocation_actions')\n        if actionlisttxt.strip() != \"\":\n            actionlist = actionlisttxt.split(',')\n            actionlist = [\"revocation_actions.%s\" % i for i in actionlist]\n\n        # load actions from unzipped\n        action_list_path = os.path.join(secdir, \"unzipped/action_list\")\n        if os.path.exists(action_list_path):\n            with open(action_list_path, encoding=\"utf-8\") as f:\n                actionlisttxt = f.read()\n            if actionlisttxt.strip() != \"\":\n                localactions = actionlisttxt.strip().split(',')\n                for action in localactions:\n                    if not action.startswith('local_action_'):\n                        logger.warning(\"Invalid local action: %s. Must start with local_action_\", action)\n                    else:\n                        actionlist.append(action)\n\n                uzpath = \"%s/unzipped\" % secdir\n                if uzpath not in sys.path:\n                    sys.path.append(uzpath)\n\n        for action in actionlist:\n            logger.info(\"Executing revocation action %s\", action)\n            try:\n                module = importlib.import_module(action)\n                execute = getattr(module, 'execute')\n                asyncio.get_event_loop().run_until_complete(execute(revocation))\n            except Exception as e:\n                logger.warning(\"Exception during execution of revocation action %s: %s\", action, e)\n\n    try:\n        while True:\n            try:\n                revocation_notifier.await_notifications(\n                    perform_actions, revocation_cert_path=cert_path)\n            except Exception as e:\n                logger.exception(e)\n                logger.warning(\"No connection to revocation server, retrying in 10s...\")\n                time.sleep(10)\n    except (KeyboardInterrupt, SystemExit):\n        logger.info(\"Stopping revocation listener...\")\n\n\ndef main():\n    for ML in [config.MEASUREDBOOT_ML, config.IMA_ML]:\n        if not os.access(ML, os.F_OK):\n            logger.warning(\"Measurement list path %s not accessible by agent. Any attempt to instruct it to access this path - via \\\"keylime_tenant\\\" CLI - will result in agent process dying\", ML)\n\n    if config.get('cloud_agent', 'agent_uuid') == 'dmidecode':\n        if os.getuid() != 0:\n            raise RuntimeError('agent_uuid is configured to use dmidecode, '\n                               'but current process is not running as root.')\n        cmd = ['which', 'dmidecode']\n        ret = cmd_exec.run(cmd, raiseOnError=False)\n        if ret['code'] != 0:\n            raise RuntimeError('agent_uuid is configured to use dmidecode, '\n                               'but it\\'s is not found on the system.')\n\n    # Instanitate TPM class\n\n    instance_tpm = tpm()\n    # get params for initialization\n    registrar_ip = config.get('cloud_agent', 'registrar_ip')\n    registrar_port = config.get('cloud_agent', 'registrar_port')\n\n    # get params for the verifier to contact the agent\n    contact_ip = os.getenv(\"KEYLIME_AGENT_CONTACT_IP\", None)\n    if contact_ip is None and config.has_option('cloud_agent', 'agent_contact_ip'):\n        contact_ip = config.get('cloud_agent', 'agent_contact_ip')\n    contact_port = os.getenv(\"KEYLIME_AGENT_CONTACT_PORT\", None)\n    if contact_port is None and config.has_option('cloud_agent', 'agent_contact_port'):\n        contact_port = config.get('cloud_agent', 'agent_contact_port', fallback=\"invalid\")\n\n    # initialize the tmpfs partition to store keys if it isn't already available\n    secure_mount.mount()\n\n    # change dir to working dir\n    config.ch_dir(config.WORK_DIR, logger)\n\n    # initialize tpm\n    (ekcert, ek_tpm, aik_tpm) = instance_tpm.tpm_init(self_activate=False, config_pw=config.get(\n        'cloud_agent', 'tpm_ownerpassword'))  # this tells initialize not to self activate the AIK\n    virtual_agent = instance_tpm.is_vtpm()\n\n    # Warn if kernel version is <5.10 and another algorithm than SHA1 is used,\n    # because otherwise IMA will not work\n    kernel_version = tuple(platform.release().split(\"-\")[0].split(\".\"))\n    if tuple(map(int,kernel_version)) < (5, 10, 0) and instance_tpm.defaults[\"hash\"] != algorithms.Hash.SHA1:\n        logger.warning(\"IMA attestation only works on kernel versions <5.10 with SHA1 as hash algorithm. \"\n                       \"Even if ascii_runtime_measurements shows \\\"%s\\\" as the \"\n                       \"algorithm, it might be just padding zeros\", (instance_tpm.defaults[\"hash\"]))\n\n    if ekcert is None:\n        if virtual_agent:\n            ekcert = 'virtual'\n        elif instance_tpm.is_emulator():\n            ekcert = 'emulator'\n\n    # now we need the UUID\n    try:\n        agent_uuid = config.get('cloud_agent', 'agent_uuid')\n    except configparser.NoOptionError:\n        agent_uuid = None\n    if agent_uuid == 'hash_ek':\n        ek_pubkey = pubkey_from_tpm2b_public(base64.b64decode(ek_tpm))\n        ek_pubkey_pem = ek_pubkey.public_bytes(encoding=serialization.Encoding.PEM,\n                                               format=serialization.PublicFormat.SubjectPublicKeyInfo)\n        agent_uuid = hashlib.sha256(ek_pubkey_pem).hexdigest()\n    elif agent_uuid == 'generate' or agent_uuid is None:\n        agent_uuid = str(uuid.uuid4())\n    elif agent_uuid == 'dmidecode':\n        cmd = ['dmidecode', '-s', 'system-uuid']\n        ret = cmd_exec.run(cmd)\n        sys_uuid = ret['retout'][0].decode('utf-8')\n        agent_uuid = sys_uuid.strip()\n        try:\n            uuid.UUID(agent_uuid)\n        except ValueError as e:\n            raise RuntimeError(\"The UUID returned from dmidecode is invalid: %s\" % e)  # pylint: disable=raise-missing-from\n    elif agent_uuid == 'hostname':\n        agent_uuid = socket.getfqdn()\n    elif agent_uuid == 'environment':\n        agent_uuid = os.getenv(\"KEYLIME_AGENT_UUID\", None)\n        if agent_uuid is None:\n            raise RuntimeError(\"Env variable KEYLIME_AGENT_UUID is empty, but agent_uuid is set to 'environment'\")\n    elif not validators.valid_uuid(agent_uuid):\n        raise RuntimeError(\"The UUID is not valid\")\n\n    if not validators.valid_agent_id(agent_uuid):\n        raise RuntimeError(\"The agent ID set via agent uuid parameter use invalid characters\")\n\n    if config.STUB_VTPM and config.TPM_CANNED_VALUES is not None:\n        # Use canned values for stubbing\n        jsonIn = config.TPM_CANNED_VALUES\n        if \"add_vtpm_to_group\" in jsonIn:\n            # The value we're looking for has been canned!\n            agent_uuid = jsonIn['add_vtpm_to_group']['retout']\n        else:\n            # Our command hasn't been canned!\n            raise Exception(\"Command %s not found in canned json!\" %\n                            (\"add_vtpm_to_group\"))\n\n    logger.info(\"Agent UUID: %s\", agent_uuid)\n\n    serveraddr = (config.get('cloud_agent', 'cloudagent_ip'),\n                  config.getint('cloud_agent', 'cloudagent_port'))\n\n    keylime_ca = config.get('cloud_agent', 'keylime_ca')\n    if keylime_ca == \"default\":\n        keylime_ca = os.path.join(config.WORK_DIR, 'cv_ca', 'cacert.crt')\n\n    server = CloudAgentHTTPServer(serveraddr, Handler, agent_uuid)\n    context = web_util.generate_mtls_context(server.mtls_cert_path, server.rsakey_path, keylime_ca, logger=logger)\n    server.socket = context.wrap_socket(server.socket, server_side=True)\n    serverthread = threading.Thread(target=server.serve_forever, daemon=True)\n\n    # register it and get back a blob\n    mtls_cert = server.mtls_cert.public_bytes(serialization.Encoding.PEM)\n    keyblob = registrar_client.doRegisterAgent(\n        registrar_ip, registrar_port, agent_uuid, ek_tpm, ekcert, aik_tpm, mtls_cert, contact_ip, contact_port)\n\n    if keyblob is None:\n        instance_tpm.flush_keys()\n        raise Exception(\"Registration failed\")\n\n    # get the ephemeral registrar key\n    key = instance_tpm.activate_identity(keyblob)\n\n    if key is None:\n        instance_tpm.flush_keys()\n        raise Exception(\"Activation failed\")\n\n    # tell the registrar server we know the key\n    retval = registrar_client.doActivateAgent(\n        registrar_ip, registrar_port, agent_uuid, key)\n\n    if not retval:\n        instance_tpm.flush_keys()\n        raise Exception(\"Registration failed on activate\")\n\n    # Start revocation listener in a new process to not interfere with tornado\n    revocation_process = multiprocessing.Process(target=revocation_listener, daemon=True)\n    revocation_process.start()\n\n    logger.info(\"Starting Cloud Agent on %s:%s with API version %s. Use <Ctrl-C> to stop\", serveraddr[0], serveraddr[1], keylime_api_version.current_version())\n    serverthread.start()\n\n    def shutdown_handler(*_):\n        logger.info(\"TERM Signal received, shutting down...\")\n        logger.debug(\"Stopping revocation notifier...\")\n        revocation_process.terminate()\n        logger.debug(\"Shutting down HTTP server...\")\n        server.shutdown()\n        server.server_close()\n        serverthread.join()\n        logger.debug(\"...HTTP server stopped\")\n        revocation_process.join()\n        logger.debug(\"... revocation notifier stopped\")\n        instance_tpm.flush_keys()\n        logger.debug(\"Flushed keys successfully\")\n        sys.exit(0)\n\n    signal.signal(signal.SIGTERM, shutdown_handler)\n    signal.signal(signal.SIGQUIT, shutdown_handler)\n    signal.signal(signal.SIGINT, shutdown_handler)\n\n    # Keep the main thread alive by waiting for the server thread\n    serverthread.join()\n", "'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport base64\nimport ipaddress\nimport threading\nimport sys\nimport signal\nimport http.server\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom socketserver import ThreadingMixIn\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.orm.exc import NoResultFound\n\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.x509 import load_der_x509_certificate\n\nfrom keylime.common import validators\nfrom keylime.db.registrar_db import RegistrarMain\nfrom keylime.db.keylime_db import DBEngineManager, SessionManager\nfrom keylime import config\nfrom keylime import crypto\nfrom keylime import json\nfrom keylime.tpm import tpm2_objects\nfrom keylime import keylime_logging\nfrom keylime.tpm.tpm_main import tpm\nfrom keylime import api_version as keylime_api_version\nfrom keylime import web_util\n\nlogger = keylime_logging.init_logging('registrar')\n\n\ntry:\n    engine = DBEngineManager().make_engine('registrar')\nexcept SQLAlchemyError as err:\n    logger.error('Error creating SQL engine: %s', err)\n    sys.exit(1)\n\n\nclass ProtectedHandler(BaseHTTPRequestHandler, SessionManager):\n\n    def do_HEAD(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_PATCH(self):\n        \"\"\"PATCH not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PATCH not supported\")\n\n    def do_GET(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents from the Registrar Server.\n\n        Currently, only agents resources are available for GETing, i.e. /agents. All other GET uri's\n        will return errors. agents requests require a single agent_id parameter which identifies the\n        agent to be returned. If the agent_id is not found, a 404 response is returned.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('GET returning 400 response. uri not supported: %s', self.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is not None:\n            # If the agent ID is not valid (wrong set of characters),\n            # just do nothing.\n            if not validators.valid_agent_id(agent_id):\n                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                logger.error(\"GET received an invalid agent ID: %s\", agent_id)\n                return\n\n            try:\n                agent = session.query(RegistrarMain).filter_by(\n                    agent_id=agent_id).first()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n\n            if agent is None:\n                web_util.echo_json_response(self, 404, \"agent_id not found\")\n                logger.warning('GET returning 404 response. agent_id %s not found.', agent_id)\n                return\n\n            if not agent.active:\n                web_util.echo_json_response(self, 404, \"agent_id not yet active\")\n                logger.warning('GET returning 404 response. agent_id %s not yet active.', agent_id)\n                return\n\n            response = {\n                'aik_tpm': agent.aik_tpm,\n                'ek_tpm': agent.ek_tpm,\n                'ekcert': agent.ekcert,\n                'mtls_cert': agent.mtls_cert,\n                'ip': agent.ip,\n                'port': agent.port,\n                'regcount': agent.regcount,\n            }\n\n            if agent.virtual:\n                response['provider_keys'] = agent.provider_keys\n\n            web_util.echo_json_response(self, 200, \"Success\", response)\n            logger.info('GET returning 200 response for agent_id: %s', agent_id)\n        else:\n            # return the available registered uuids from the DB\n            json_response = session.query(RegistrarMain.agent_id).all()\n            return_response = [item[0] for item in json_response]\n            web_util.echo_json_response(self, 200, \"Success\", {\n                                      'uuids': return_response})\n            logger.info('GET returning 200 response for agent_id list')\n\n        return\n\n    def do_POST(self):\n        \"\"\"POST not supported\"\"\"\n        web_util.echo_json_response(\n            self, 405, \"POST not supported via TLS interface\")\n\n    def do_PUT(self):\n        \"\"\"PUT not supported\"\"\"\n        web_util.echo_json_response(\n            self, 405, \"PUT not supported via TLS interface\")\n\n    def do_DELETE(self):\n        \"\"\"This method handles the DELETE requests to remove agents from the Registrar Server.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning('DELETE agent returning 400 response. uri not supported: %s', self.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is not None:\n            # If the agent ID is not valid (wrong set of characters),\n            # just do nothing.\n            if not validators.valid_agent_id(agent_id):\n                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                logger.error(\"DELETE received an invalid agent ID: %s\", agent_id)\n                return\n\n            if session.query(RegistrarMain).filter_by(agent_id=agent_id).delete():\n                # send response\n                try:\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                web_util.echo_json_response(self, 200, \"Success\")\n                return\n\n            # send response\n            web_util.echo_json_response(self, 404)\n            return\n\n        web_util.echo_json_response(self, 404)\n\n    # pylint: disable=W0622\n    def log_message(self, format, *args):\n        return\n\n\nclass UnprotectedHandler(BaseHTTPRequestHandler, SessionManager):\n\n    def do_HEAD(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def do_PATCH(self):\n        \"\"\"PATCH not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"PATCH not supported\")\n\n    def do_GET(self):\n        \"\"\"This method handles the GET requests to the unprotected side of the Registrar Server\n\n        Currently the only supported path is /versions which shows the supported API versions\n        \"\"\"\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /version/ interface\")\n            return\n\n        if \"version\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"URI not supported\")\n            logger.warning('GET agent returning 400 response. URI not supported: %s', self.path)\n            return\n\n        version_info = {\n            \"current_version\": keylime_api_version.current_version(),\n            \"supported_versions\": keylime_api_version.all_versions(),\n        }\n\n        web_util.echo_json_response(self, 200, \"Success\", version_info)\n\n    def do_POST(self):\n        \"\"\"This method handles the POST requests to add agents to the Registrar Server.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's\n        will return errors. POST requests require an an agent_id identifying the agent to add, and json\n        block sent in the body with 2 entries: ek and aik.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('POST agent returning 400 response. uri not supported: %s', self.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            web_util.echo_json_response(self, 400, \"agent id not found in uri\")\n            logger.warning('POST agent returning 400 response. agent id not found in uri %s', self.path)\n            return\n\n        # If the agent ID is not valid (wrong set of characters), just\n        # do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent id not valid\")\n            logger.error(\"POST received an invalid agent ID: %s\", agent_id)\n            return\n\n        try:\n            content_length = int(self.headers.get('Content-Length', 0))\n            if content_length == 0:\n                web_util.echo_json_response(\n                    self, 400, \"Expected non zero content length\")\n                logger.warning('POST for %s returning 400 response. Expected non zero content length.', agent_id)\n                return\n\n            post_body = self.rfile.read(content_length)\n            json_body = json.loads(post_body)\n\n            ekcert = json_body['ekcert']\n            aik_tpm = json_body['aik_tpm']\n\n            initialize_tpm = tpm()\n\n            if ekcert is None or ekcert == 'emulator':\n                logger.warning('Agent %s did not submit an ekcert' % agent_id)\n                ek_tpm = json_body['ek_tpm']\n            else:\n                if 'ek_tpm' in json_body:\n                    # This would mean the agent submitted both a non-None ekcert, *and*\n                    #  an ek_tpm... We can deal with it by just ignoring the ek_tpm they sent\n                    logger.warning('Overriding ek_tpm for agent %s from ekcert' % agent_id)\n                # If there's an EKCert, we just overwrite their ek_tpm\n                # Note, we don't validate the EKCert here, other than the implicit\n                #  \"is it a valid x509 cert\" check. So it's still untrusted.\n                # This will be validated by the tenant.\n                ek509 = load_der_x509_certificate(\n                    base64.b64decode(ekcert),\n                    backend=default_backend(),\n                )\n                ek_tpm = base64.b64encode(\n                    tpm2_objects.ek_low_tpm2b_public_from_pubkey(\n                        ek509.public_key(),\n                    )\n                )\n\n            aik_attrs = tpm2_objects.get_tpm2b_public_object_attributes(\n                base64.b64decode(aik_tpm),\n            )\n            if aik_attrs != tpm2_objects.AK_EXPECTED_ATTRS:\n                web_util.echo_json_response(\n                    self, 400, \"Invalid AK attributes\")\n                logger.warning(\n                    \"Agent %s submitted AIK with invalid attributes! %s (provided) != %s (expected)\",\n                    agent_id,\n                    tpm2_objects.object_attributes_description(aik_attrs),\n                    tpm2_objects.object_attributes_description(tpm2_objects.AK_EXPECTED_ATTRS),\n                )\n                return\n\n            # try to encrypt the AIK\n            (blob, key) = initialize_tpm.encryptAIK(\n                agent_id,\n                base64.b64decode(ek_tpm),\n                base64.b64decode(aik_tpm),\n            )\n\n            # special behavior if we've registered this uuid before\n            regcount = 1\n            try:\n                agent = session.query(RegistrarMain).filter_by(\n                    agent_id=agent_id).first()\n            except NoResultFound:\n                agent = None\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise\n\n            if agent is not None:\n\n                # keep track of how many ek-ekcerts have registered on this uuid\n                regcount = agent.regcount\n                if agent.ek_tpm != ek_tpm or agent.ekcert != ekcert:\n                    logger.warning('WARNING: Overwriting previous registration for this UUID with new ek-ekcert pair!')\n                    regcount += 1\n\n                # force overwrite\n                logger.info('Overwriting previous registration for this UUID.')\n                try:\n                    session.query(RegistrarMain).filter_by(\n                        agent_id=agent_id).delete()\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                    raise\n            # Check for ip and port\n            contact_ip = json_body.get('ip', None)\n            contact_port = json_body.get('port', None)\n\n            # Validate ip and port\n            if contact_ip is not None:\n                try:\n                    # Use parser from the standard library instead of implementing our own\n                    ipaddress.ip_address(contact_ip)\n                except ValueError:\n                    logger.warning(f\"Contact ip for agent {agent_id} is not a valid ip got: {contact_ip}.\")\n                    contact_ip = None\n            if contact_port is not None:\n                try:\n                    contact_port = int(contact_port)\n                    if contact_port < 1 or contact_port > 65535:\n                        logger.warning(f\"Contact port for agent {agent_id} is not a number between 1 and got: {contact_port}.\")\n                        contact_port = None\n                except ValueError:\n                    logger.warning(f\"Contact port for agent {agent_id} is not a valid number got: {contact_port}.\")\n                    contact_port = None\n\n            # Check for mTLS cert\n            mtls_cert = json_body.get('mtls_cert', None)\n            if mtls_cert is None:\n                logger.warning(f\"Agent {agent_id} did not sent a mTLS certificate. Most operations will not work!\")\n\n            # Add values to database\n            d = {}\n            d['agent_id'] = agent_id\n            d['ek_tpm'] = ek_tpm\n            d['aik_tpm'] = aik_tpm\n            d['ekcert'] = ekcert\n            d['ip'] = contact_ip\n            d['mtls_cert'] = mtls_cert\n            d['port'] = contact_port\n            d['virtual'] = int(ekcert == 'virtual')\n            d['active'] = int(False)\n            d['key'] = key\n            d['provider_keys'] = {}\n            d['regcount'] = regcount\n\n\n            try:\n                session.add(RegistrarMain(**d))\n                session.commit()\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise\n\n            response = {\n                'blob': blob,\n            }\n            web_util.echo_json_response(self, 200, \"Success\", response)\n\n            logger.info('POST returning key blob for agent_id: %s', agent_id)\n        except Exception as e:\n            web_util.echo_json_response(self, 400, \"Error: %s\" % e)\n            logger.warning(\"POST for %s returning 400 response. Error: %s\", agent_id, e)\n            logger.exception(e)\n\n    def do_PUT(self):\n        \"\"\"This method handles the PUT requests to add agents to the Registrar Server.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's\n        will return errors.\n        \"\"\"\n        session = SessionManager().make_session(engine)\n        rest_params = web_util.get_restful_params(self.path)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if not rest_params[\"api_version\"]:\n            web_util.echo_json_response(self, 400, \"API Version not supported\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('PUT agent returning 400 response. uri not supported: %s', self.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n\n        if agent_id is None:\n            web_util.echo_json_response(self, 400, \"agent id not found in uri\")\n            logger.warning('PUT agent returning 400 response. agent id not found in uri %s', self.path)\n            return\n\n        # If the agent ID is not valid (wrong set of characters), just\n        # do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n            logger.error(\"PUT received an invalid agent ID: %s\", agent_id)\n            return\n\n        try:\n            content_length = int(self.headers.get('Content-Length', 0))\n            if content_length == 0:\n                web_util.echo_json_response(\n                    self, 400, \"Expected non zero content length\")\n                logger.warning('PUT for %s returning 400 response. Expected non zero content length.', agent_id)\n                return\n\n            post_body = self.rfile.read(content_length)\n            json_body = json.loads(post_body)\n\n            auth_tag = json_body['auth_tag']\n            try:\n                agent = session.query(RegistrarMain).filter_by(\n                    agent_id=agent_id).first()\n            except NoResultFound as e:\n                raise Exception(\n                    \"attempting to activate agent before requesting \"\n                    \"registrar for %s\" % agent_id) from e\n            except SQLAlchemyError as e:\n                logger.error('SQLAlchemy Error: %s', e)\n                raise\n\n            if config.STUB_TPM:\n                try:\n                    session.query(RegistrarMain).filter(RegistrarMain.agent_id == agent_id).update(\n                        {'active': True})\n                    session.commit()\n                except SQLAlchemyError as e:\n                    logger.error('SQLAlchemy Error: %s', e)\n                    raise\n            else:\n                # TODO(kaifeng) Special handling should be removed\n                if engine.dialect.name == \"mysql\":\n                    agent.key = agent.key.encode('utf-8')\n\n                ex_mac = crypto.do_hmac(agent.key, agent_id)\n                if ex_mac == auth_tag:\n                    try:\n                        session.query(RegistrarMain).filter(RegistrarMain.agent_id == agent_id).update(\n                            {'active': True})\n                        session.commit()\n                    except SQLAlchemyError as e:\n                        logger.error('SQLAlchemy Error: %s', e)\n                        raise\n                else:\n                    raise Exception(\n                        f\"Auth tag {auth_tag} does not match expected value {ex_mac}\")\n\n            web_util.echo_json_response(self, 200, \"Success\")\n            logger.info('PUT activated: %s', agent_id)\n        except Exception as e:\n            web_util.echo_json_response(self, 400, \"Error: %s\" % e)\n            logger.warning(\"PUT for %s returning 400 response. Error: %s\", agent_id, e)\n            logger.exception(e)\n            return\n\n    def do_DELETE(self):\n        \"\"\"DELETE not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"DELETE not supported\")\n\n    # pylint: disable=W0622\n    def log_message(self, format, *args):\n        return\n\n# consider using PooledProcessMixIn\n# https://github.com/muayyad-alsadi/python-PooledProcessMixIn\n\n\nclass RegistrarServer(ThreadingMixIn, HTTPServer):\n    \"\"\"Handle requests in a separate thread.\"\"\"\n\n    def __init__(self, server_address, RequestHandlerClass):\n        \"\"\"Constructor overridden to provide ability to read file\"\"\"\n        http.server.HTTPServer.__init__(\n            self, server_address, RequestHandlerClass)\n\n    def shutdown(self):\n        http.server.HTTPServer.shutdown(self)\n\n\ndef start(host, tlsport, port):\n    \"\"\"Main method of the Registrar Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    RegistrarMain.metadata.create_all(engine, checkfirst=True)\n    session = SessionManager().make_session(engine)\n    try:\n        count = session.query(RegistrarMain.agent_id).count()\n        if count > 0:\n            logger.info(\"Loaded %d public keys from database\", count)\n    except SQLAlchemyError as e:\n        logger.error('SQLAlchemy Error: %s', e)\n\n    # Set up the protected registrar server\n    protected_server = RegistrarServer((host, tlsport), ProtectedHandler)\n    context, _ = web_util.init_mtls(section='registrar', generatedir='reg_ca', logger=logger)\n    if context is not None:\n        protected_server.socket = context.wrap_socket(protected_server.socket, server_side=True)\n    thread_protected_server = threading.Thread(target=protected_server.serve_forever)\n\n    # Set up the unprotected registrar server\n    unprotected_server = RegistrarServer((host, port), UnprotectedHandler)\n    thread_unprotected_server = threading.Thread(target=unprotected_server.serve_forever)\n\n    logger.info('Starting Cloud Registrar Server on ports %s and %s (TLS) use <Ctrl-C> to stop', port, tlsport)\n    keylime_api_version.log_api_versions(logger)\n    thread_protected_server.start()\n    thread_unprotected_server.start()\n\n    def signal_handler(signum, frame):\n        del signum, frame\n        logger.info(\"Shutting down Registrar Server...\")\n        protected_server.shutdown()\n        unprotected_server.shutdown()\n        sys.exit(0)\n\n    # Catch these signals.  Note that a SIGKILL cannot be caught, so\n    # killing this process with \"kill -9\" may result in improper shutdown\n    signal.signal(signal.SIGTERM, signal_handler)\n    signal.signal(signal.SIGQUIT, signal_handler)\n    signal.signal(signal.SIGINT, signal_handler)\n\n    thread_protected_server.join()\n    thread_unprotected_server.join()\n", "#!/usr/bin/python3\n\n'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport argparse\nimport base64\nimport hashlib\nimport io\nimport logging\nimport os\nimport subprocess\nimport sys\nimport time\nimport zipfile\nimport json\nimport tempfile\nimport requests\n\nfrom cryptography.hazmat.primitives import serialization as crypto_serialization\n\nfrom keylime.agentstates import AgentAttestState\nfrom keylime.requests_client import RequestsClient\nfrom keylime.common import states\nfrom keylime import config\nfrom keylime import keylime_logging\nfrom keylime import registrar_client\nfrom keylime.tpm import tpm2_objects\nfrom keylime.tpm.tpm_main import tpm\nfrom keylime.tpm.tpm_abstract import TPM_Utilities\nfrom keylime import ima\nfrom keylime import crypto\nfrom keylime.cmd import user_data_encrypt\nfrom keylime import ca_util\nfrom keylime.common import algorithms, validators\nfrom keylime import ima_file_signatures\nfrom keylime import measured_boot\nfrom keylime import gpg\nfrom keylime import api_version as keylime_api_version\n\n# setup logging\nlogger = keylime_logging.init_logging('tenant')\n\n# special exception that suppresses stack traces when it happens\nclass UserError(Exception):\n    pass\n\n\nclass Tenant():\n    \"\"\"Simple command processor example.\"\"\"\n\n    config = None\n\n    cloudverifier_ip = None\n    cloudverifier_port = None\n\n    cloudagent_ip = None\n    cv_cloudagent_ip = None\n    cloudagent_port = None\n\n    registrar_ip = None\n    registrar_port = None\n    registrar_data = None\n\n    webapp_ip = None\n    webapp_port = None\n\n    api_version = None\n\n    uuid_service_generate_locally = None\n    agent_uuid = None\n\n    K = None\n    V = None\n    U = None\n    auth_tag = None\n\n    tpm_policy = None\n    vtpm_policy = {}\n    metadata = {}\n    allowlist = {}\n    ima_sign_verification_keys = []\n    revocation_key = \"\"\n    accept_tpm_hash_algs = []\n    accept_tpm_encryption_algs = []\n    accept_tpm_signing_algs = []\n    mb_refstate = None\n    supported_version = None\n\n    payload = None\n\n    tpm_instance = tpm()\n\n    def __init__(self):\n        \"\"\" Set up required values and TLS\n        \"\"\"\n        self.nonce = None\n        self.agent_ip = None\n        self.verifier_id = None\n        self.agent_port = None\n        self.verifier_ip = config.get('tenant', 'cloudverifier_ip')\n        self.verifier_port = config.get('tenant', 'cloudverifier_port')\n        self.registrar_ip = config.get('tenant', 'registrar_ip')\n        self.registrar_port = config.get('tenant', 'registrar_port')\n        self.webapp_port = config.getint('webapp', 'webapp_port')\n        if not config.REQUIRE_ROOT and self.webapp_port < 1024:\n            self.webapp_port += 2000\n        self.webapp_ip = config.get('webapp', 'webapp_ip')\n\n        self.api_version = keylime_api_version.current_version()\n\n        (self.my_cert, self.my_priv_key), (self.my_agent_cert, self.my_agent_priv_key) = self.get_tls_context()\n        self.cert = (self.my_cert, self.my_priv_key)\n        self.agent_cert = (self.my_agent_cert, self.my_agent_priv_key)\n        if config.getboolean('general', \"enable_tls\"):\n            self.tls_enabled = True\n        else:\n            self.tls_enabled = False\n            self.cert = \"\"\n            logger.warning(\n                \"Warning: TLS is currently disabled, keys will be sent in the clear! This should only be used for testing.\")\n\n    @property\n    def verifier_base_url(self):\n        return f'{self.verifier_ip}:{self.verifier_port}'\n\n    def get_tls_context(self):\n        \"\"\"Generate certifcate naming and path\n\n        Returns:\n            string -- my_cert (client_cert), my_priv_key (client private key)\n        \"\"\"\n        my_cert = config.get('tenant', 'my_cert')\n        my_priv_key = config.get('tenant', 'private_key')\n        tls_dir = config.get('tenant', 'tls_dir')\n\n        if tls_dir == 'default':\n            my_cert = 'client-cert.crt'\n            my_priv_key = 'client-private.pem'\n            tls_dir = 'cv_ca'\n\n        if tls_dir[0] != '/':\n            tls_dir = os.path.abspath(os.path.join(config.WORK_DIR, tls_dir))\n\n        logger.info(\"Setting up client TLS in %s\", tls_dir)\n        my_cert = os.path.join(tls_dir, my_cert)\n        my_priv_key = os.path.join(tls_dir, my_priv_key)\n\n        tls_context = (my_cert, my_priv_key)\n\n        # Check for user defined CA to connect to agent\n        agent_mtls_cert = config.get(\"cloud_verifier\", \"agent_mtls_cert\", fallback=None)\n        agent_mtls_private_key = config.get(\"cloud_verifier\", \"agent_mtls_private_key\", fallback=None)\n\n        agent_mtls_context = tls_context\n        if agent_mtls_cert != \"CV\":\n            agent_mtls_context = (agent_mtls_cert, agent_mtls_private_key)\n\n        return tls_context, agent_mtls_context\n\n    def process_allowlist(self, args):\n        # Set up PCR values\n        tpm_policy = config.get('tenant', 'tpm_policy')\n        if \"tpm_policy\" in args and args[\"tpm_policy\"] is not None:\n            tpm_policy = args[\"tpm_policy\"]\n        self.tpm_policy = TPM_Utilities.readPolicy(tpm_policy)\n        logger.info(\"TPM PCR Mask from policy is %s\", self.tpm_policy['mask'])\n\n        vtpm_policy = config.get('tenant', 'vtpm_policy')\n        if \"vtpm_policy\" in args and args[\"vtpm_policy\"] is not None:\n            vtpm_policy = args[\"vtpm_policy\"]\n        self.vtpm_policy = TPM_Utilities.readPolicy(vtpm_policy)\n        logger.info(\"TPM PCR Mask from policy is %s\", self.vtpm_policy['mask'])\n\n        if len(args.get(\"ima_sign_verification_keys\")) > 0:\n            # Auto-enable IMA (or-bit mask)\n            self.tpm_policy['mask'] = \"0x%X\" % (\n                    int(self.tpm_policy['mask'], 0) | (1 << config.IMA_PCR))\n\n            # Add all IMA file signing verification keys to a keyring\n            tenant_keyring = ima_file_signatures.ImaKeyring()\n            for filename in args[\"ima_sign_verification_keys\"]:\n                pubkey, keyidv2 = ima_file_signatures.get_pubkey_from_file(filename)\n                if not pubkey:\n                    raise UserError(\n                        \"File '%s' is not a file with a key\" % filename)\n                tenant_keyring.add_pubkey(pubkey, keyidv2)\n            self.ima_sign_verification_keys = tenant_keyring.to_string()\n\n        # Read command-line path string allowlist\n        al_data = None\n\n        if \"allowlist\" in args and args[\"allowlist\"] is not None:\n\n            self.enforce_pcrs(list(self.tpm_policy.keys()), [ config.IMA_PCR ], \"IMA\")\n\n            # Auto-enable IMA (or-bit mask)\n            self.tpm_policy['mask'] = \"0x%X\" % (\n                    int(self.tpm_policy['mask'], 0) | (1 << config.IMA_PCR))\n\n            if isinstance(args[\"allowlist\"], str):\n                if args[\"allowlist\"] == \"default\":\n                    args[\"allowlist\"] = config.get('tenant', 'allowlist')\n                al_data = ima.read_allowlist(args[\"allowlist\"], args[\"allowlist_checksum\"], args[\"allowlist_sig\"], args[\"allowlist_sig_key\"])\n            elif isinstance(args[\"allowlist\"], list):\n                al_data = args[\"allowlist\"]\n            else:\n                raise UserError(\"Invalid allowlist provided\")\n\n        # Read command-line path string IMA exclude list\n        excl_data = None\n        if \"ima_exclude\" in args and args[\"ima_exclude\"] is not None:\n            if isinstance(args[\"ima_exclude\"], str):\n                if args[\"ima_exclude\"] == \"default\":\n                    args[\"ima_exclude\"] = config.get(\n                        'tenant', 'ima_excludelist')\n                excl_data = ima.read_excllist(args[\"ima_exclude\"])\n            elif isinstance(args[\"ima_exclude\"], list):\n                excl_data = args[\"ima_exclude\"]\n            else:\n                raise UserError(\"Invalid exclude list provided\")\n\n        # Set up IMA\n        if TPM_Utilities.check_mask(self.tpm_policy['mask'], config.IMA_PCR) or \\\n                TPM_Utilities.check_mask(self.vtpm_policy['mask'],\n                                         config.IMA_PCR):\n            # Process allowlists\n            self.allowlist = ima.process_allowlists(al_data, excl_data)\n\n        # Read command-line path string TPM event log (measured boot) reference state\n        mb_refstate_data = None\n        if \"mb_refstate\" in args and args[\"mb_refstate\"] is not None:\n\n            self.enforce_pcrs(list(self.tpm_policy.keys()), config.MEASUREDBOOT_PCRS, \"measured boot\")\n\n            # Auto-enable TPM event log mesured boot (or-bit mask)\n            for _pcr in config.MEASUREDBOOT_PCRS :\n                self.tpm_policy['mask'] = \"0x%X\" % (\n                    int(self.tpm_policy['mask'], 0) | (1 << _pcr))\n\n            logger.info(\"TPM PCR Mask automatically modified is %s to include IMA/Event log PCRs\", self.tpm_policy['mask'])\n\n            if isinstance(args[\"mb_refstate\"], str):\n                if args[\"mb_refstate\"] == \"default\":\n                    args[\"mb_refstate\"] = config.get('tenant', 'mb_refstate')\n                mb_refstate_data = measured_boot.read_mb_refstate(args[\"mb_refstate\"])\n            else:\n                raise UserError(\"Invalid measured boot reference state (intended state) provided\")\n\n        # Set up measured boot (TPM event log) reference state\n        if TPM_Utilities.check_mask(self.tpm_policy['mask'], config.MEASUREDBOOT_PCRS[2]) :\n            # Process measured boot reference state\n            self.mb_refstate = mb_refstate_data\n\n    def init_add(self, args):\n        \"\"\" Set up required values. Command line options can overwrite these config values\n\n        Arguments:\n            args {[string]} -- agent_ip|agent_port|cv_agent_ip\n        \"\"\"\n        if \"agent_ip\" in args:\n            self.agent_ip = args[\"agent_ip\"]\n\n        if 'agent_port' in args and args['agent_port'] is not None:\n            self.agent_port = args['agent_port']\n\n        registrar_client.init_client_tls(\"tenant\")\n        self.registrar_data = registrar_client.getData(self.registrar_ip, self.registrar_port, self.agent_uuid)\n\n        # try to get the port or ip from the registrar if it is missing\n        if (self.agent_ip is None or self.agent_port is None) and self.registrar_data is not None:\n            if self.agent_ip is None:\n                if self.registrar_data['ip'] is not None:\n                    self.agent_ip = self.registrar_data['ip']\n                else:\n                    raise UserError(\"No Ip was specified or found in the Registrar\")\n\n            if self.agent_port is None and self.registrar_data['port'] is not None:\n                self.agent_port = self.registrar_data[\"port\"]\n\n        # If no agent port was found try to use the default from the config file\n        if self.agent_port is None:\n            self.agent_port = config.get('cloud_agent', 'cloudagent_port')\n\n        # Check if a contact ip and port for the agent was found\n        if self.agent_ip is None:\n            raise UserError(\"The contact ip address for the agent was not specified.\")\n\n        if self.agent_port is None:\n            raise UserError(\"The contact port for the agent was not specified.\")\n\n        # Auto-detection for API version\n        self.supported_version = args[\"supported_version\"]\n        if self.supported_version is None:\n            # Default to 1.0 if the agent did not send a mTLS certificate\n            if self.registrar_data.get(\"mtls_cert\", None) is None:\n                self.supported_version = \"1.0\"\n            else:\n                # Try to connect to the agent to get supported version\n                with RequestsClient(f\"{self.agent_ip}:{self.agent_port}\", tls_enabled=True, cert=self.agent_cert,\n                                    ignore_hostname=True, verify_custom=self.registrar_data['mtls_cert']) as get_version:\n                    res = get_version.get(\"/version\")\n                    if res and res.status_code == 200:\n                        try:\n                            data = res.json()\n                            api_version = data[\"results\"][\"supported_version\"]\n                            if keylime_api_version.validate_version(api_version):\n                                self.supported_version = api_version\n                            else:\n                                logger.warning(\"API version provided by the agent is not valid\")\n                        except (TypeError, KeyError):\n                            pass\n\n        if self.supported_version is None:\n            api_version = keylime_api_version.current_version()\n            logger.warning(\"Could not detect supported API version. Defaulting to %s\", api_version)\n            self.supported_version = api_version\n\n        # Now set the cv_agent_ip\n        if 'cv_agent_ip' in args and args['cv_agent_ip'] is not None:\n            self.cv_cloudagent_ip = args['cv_agent_ip']\n        else:\n            self.cv_cloudagent_ip = self.agent_ip\n\n        # Make sure all keys exist in dictionary\n        if \"file\" not in args:\n            args[\"file\"] = None\n        if \"keyfile\" not in args:\n            args[\"keyfile\"] = None\n        if \"payload\" not in args:\n            args[\"payload\"] = None\n        if \"ca_dir\" not in args:\n            args[\"ca_dir\"] = None\n        if \"incl_dir\" not in args:\n            args[\"incl_dir\"] = None\n        if \"ca_dir_pw\" not in args:\n            args[\"ca_dir_pw\"] = None\n\n        # Set up accepted algorithms\n        self.accept_tpm_hash_algs = config.get(\n            'tenant', 'accept_tpm_hash_algs').split(',')\n        self.accept_tpm_encryption_algs = config.get(\n            'tenant', 'accept_tpm_encryption_algs').split(',')\n        self.accept_tpm_signing_algs = config.get(\n            'tenant', 'accept_tpm_signing_algs').split(',')\n\n        self.process_allowlist(args)\n\n        # if none\n        if (args[\"file\"] is None and args[\"keyfile\"] is None and args[\"ca_dir\"] is None):\n            raise UserError(\n                \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n        if args[\"keyfile\"] is not None:\n            if args[\"file\"] is not None or args[\"ca_dir\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n            # read the keys in\n            if isinstance(args[\"keyfile\"], dict) and \"data\" in args[\"keyfile\"]:\n                if isinstance(args[\"keyfile\"][\"data\"], list) and len(args[\"keyfile\"][\"data\"]) == 1:\n                    keyfile = args[\"keyfile\"][\"data\"][0]\n                    if keyfile is None:\n                        raise UserError(\"Invalid key file contents\")\n                    f = io.StringIO(keyfile)\n                else:\n                    raise UserError(\"Invalid key file provided\")\n            else:\n                f = open(args[\"keyfile\"], encoding=\"utf-8\")\n            self.K = base64.b64decode(f.readline())\n            self.U = base64.b64decode(f.readline())\n            self.V = base64.b64decode(f.readline())\n            f.close()\n\n            # read the payload in (opt.)\n            if isinstance(args[\"payload\"], dict) and \"data\" in args[\"payload\"]:\n                if isinstance(args[\"payload\"][\"data\"], list) and len(args[\"payload\"][\"data\"]) > 0:\n                    self.payload = args[\"payload\"][\"data\"][0]\n            else:\n                if args[\"payload\"] is not None:\n                    f = open(args[\"payload\"], 'rb')\n                    self.payload = f.read()\n                    f.close()\n\n        if args[\"file\"] is not None:\n            if args[\"keyfile\"] is not None or args[\"ca_dir\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n\n            if isinstance(args[\"file\"], dict) and \"data\" in args[\"file\"]:\n                if isinstance(args[\"file\"][\"data\"], list) and len(args[\"file\"][\"data\"]) > 0:\n                    contents = args[\"file\"][\"data\"][0]\n                    if contents is None:\n                        raise UserError(\"Invalid file payload contents\")\n                else:\n                    raise UserError(\"Invalid file payload provided\")\n            else:\n                with open(args[\"file\"], encoding=\"utf-8\") as f:\n                    contents = f.read()\n            ret = user_data_encrypt.encrypt(contents)\n            self.K = ret['k']\n            self.U = ret['u']\n            self.V = ret['v']\n            self.payload = ret['ciphertext']\n\n        if args[\"ca_dir\"] is None and args[\"incl_dir\"] is not None:\n            raise UserError(\n                \"--include option is only valid when used with --cert\")\n        if args[\"ca_dir\"] is not None:\n            if args[\"file\"] is not None or args[\"keyfile\"] is not None:\n                raise UserError(\n                    \"You must specify one of -k, -f, or --cert to specify the key/contents to be securely delivered to the agent\")\n            if args[\"ca_dir\"] == 'default':\n                args[\"ca_dir\"] = config.CA_WORK_DIR\n\n            if \"ca_dir_pw\" in args and args[\"ca_dir_pw\"] is not None:\n                ca_util.setpassword(args[\"ca_dir_pw\"])\n\n            if not os.path.exists(args[\"ca_dir\"]) or not os.path.exists(\"%s/cacert.crt\" % args[\"ca_dir\"]):\n                logger.warning(\"CA directory does not exist. Creating...\")\n                ca_util.cmd_init(args[\"ca_dir\"])\n            if not os.path.exists(\n                    os.path.join(args[\"ca_dir\"],\n                                 f\"{self.agent_uuid}-private.pem\")):\n                ca_util.cmd_mkcert(args[\"ca_dir\"], self.agent_uuid)\n\n            cert_pkg, serial, subject = ca_util.cmd_certpkg(\n                args[\"ca_dir\"], self.agent_uuid)\n\n            # support revocation\n            if not os.path.exists(\"%s/RevocationNotifier-private.pem\" % args[\"ca_dir\"]):\n                ca_util.cmd_mkcert(args[\"ca_dir\"], \"RevocationNotifier\")\n            rev_package, _, _ = ca_util.cmd_certpkg(\n                args[\"ca_dir\"], \"RevocationNotifier\")\n\n            # extract public and private keys from package\n            sf = io.BytesIO(rev_package)\n            with zipfile.ZipFile(sf) as zf:\n                privkey = zf.read(\"RevocationNotifier-private.pem\")\n                cert = zf.read(\"RevocationNotifier-cert.crt\")\n\n            # put the cert of the revoker into the cert package\n            sf = io.BytesIO(cert_pkg)\n            with zipfile.ZipFile(sf, 'a', compression=zipfile.ZIP_STORED) as zf:\n                zf.writestr('RevocationNotifier-cert.crt', cert)\n\n                # add additional files to zip\n                if args[\"incl_dir\"] is not None:\n                    if isinstance(args[\"incl_dir\"], dict) and \"data\" in args[\"incl_dir\"] and \"name\" in args[\"incl_dir\"]:\n                        if isinstance(args[\"incl_dir\"][\"data\"], list) and isinstance(args[\"incl_dir\"][\"name\"], list):\n                            if len(args[\"incl_dir\"][\"data\"]) != len(args[\"incl_dir\"][\"name\"]):\n                                raise UserError(\"Invalid incl_dir provided\")\n                            for i in range(len(args[\"incl_dir\"][\"data\"])):\n                                zf.writestr(os.path.basename(\n                                    args[\"incl_dir\"][\"name\"][i]), args[\"incl_dir\"][\"data\"][i])\n                    else:\n                        if os.path.exists(args[\"incl_dir\"]):\n                            files = next(os.walk(args[\"incl_dir\"]))[2]\n                            for filename in files:\n                                with open(os.path.join(args[\"incl_dir\"],\n                                                       filename), 'rb') as f:\n                                    zf.writestr(\n                                        os.path.basename(f.name), f.read())\n                        else:\n                            logger.warning('Specified include directory %s does not exist. Skipping...', args[\"incl_dir\"])\n\n            cert_pkg = sf.getvalue()\n\n            # put the private key into the data to be send to the CV\n            self.revocation_key = privkey.decode('utf-8')\n\n            # encrypt up the cert package\n            ret = user_data_encrypt.encrypt(cert_pkg)\n            self.K = ret['k']\n            self.U = ret['u']\n            self.V = ret['v']\n            self.metadata = {'cert_serial': serial, 'subject': subject}\n            self.payload = ret['ciphertext']\n\n        if self.payload is not None and len(self.payload) > config.getint('tenant', 'max_payload_size'):\n            raise UserError(\"Payload size %s exceeds max size %d\" % (\n                len(self.payload), config.getint('tenant', 'max_payload_size')))\n\n    def enforce_pcrs(self, policy_pcrs, protected_pcrs, pcr_use) :\n        policy_pcrs = list(self.tpm_policy.keys())\n        policy_pcrs.remove('mask')\n\n        for _pcr in policy_pcrs :\n            if int(_pcr) in protected_pcrs :\n                logger.error('WARNING: PCR %s is specified in \"tpm_policy\", but will in fact be used by %s. Please remove it from policy', _pcr, pcr_use)\n                sys.exit(1)\n\n    def preloop(self):\n        \"\"\" encrypt the agent UUID as a check for delivering the correct key\n        \"\"\"\n        self.auth_tag = crypto.do_hmac(self.K, self.agent_uuid)\n        # be very careful printing K, U, or V as they leak in logs stored on unprotected disks\n        if config.INSECURE_DEBUG:\n            logger.debug(\"K: %s\", base64.b64encode(self.K))\n            logger.debug(\"V: %s\", base64.b64encode(self.V))\n            logger.debug(\"U: %s\", base64.b64encode(self.U))\n            logger.debug(\"Auth Tag: %s\", self.auth_tag)\n\n    def check_ek(self, ekcert):\n        \"\"\" Check the Entity Key\n\n        Arguments:\n            ekcert {str} -- The endorsement key, either None, \"emulator\", or base64 encoded der cert\n\n        Returns:\n            [type] -- [description]\n        \"\"\"\n        if config.getboolean('tenant', 'require_ek_cert'):\n            if config.STUB_TPM:\n                logger.debug(\"Not checking ekcert due to STUB_TPM mode\")\n            elif ekcert == 'emulator' and config.DISABLE_EK_CERT_CHECK_EMULATOR:\n                logger.info(\"Not checking ekcert of TPM emulator\")\n            elif ekcert is None:\n                logger.warning(\"No EK cert provided, require_ek_cert option in config set to True\")\n                return False\n            elif not self.tpm_instance.verify_ek(base64.b64decode(ekcert)):\n                logger.warning(\"Invalid EK certificate\")\n                return False\n\n        return True\n\n    def validate_tpm_quote(self, public_key, quote, hash_alg):\n        \"\"\" Validate TPM Quote received from the Agent\n\n        Arguments:\n            public_key {[type]} -- [description]\n            quote {[type]} -- [description]\n            hash_alg {bool} -- [description]\n\n        Raises:\n            UserError: [description]\n\n        Returns:\n            [type] -- [description]\n        \"\"\"\n        registrar_client.init_client_tls('tenant')\n        if self.registrar_data is None:\n            logger.warning(\"AIK not found in registrar, quote not validated\")\n            return False\n\n        failure = self.tpm_instance.check_quote(AgentAttestState(self.agent_uuid), self.nonce, public_key, quote,\n                                                self.registrar_data['aik_tpm'], hash_alg=hash_alg,\n                                                compressed=(self.supported_version == \"1.0\"))\n        if failure:\n            if self.registrar_data['regcount'] > 1:\n                logger.error(\"WARNING: This UUID had more than one ek-ekcert registered to it! This might indicate that your system is misconfigured or a malicious host is present. Run 'regdelete' for this agent and restart\")\n                sys.exit()\n            return False\n\n        if self.registrar_data['regcount'] > 1:\n            logger.warning(\"WARNING: This UUID had more than one ek-ekcert registered to it! This might indicate that your system is misconfigured. Run 'regdelete' for this agent and restart\")\n\n        if not config.STUB_TPM and (not config.getboolean('tenant', 'require_ek_cert') and config.get('tenant', 'ek_check_script') == \"\"):\n            logger.warning(\n                \"DANGER: EK cert checking is disabled and no additional checks on EKs have been specified with ek_check_script option. Keylime is not secure!!\")\n\n        # check EK cert and make sure it matches EK\n        if not self.check_ek(self.registrar_data['ekcert']):\n            return False\n        # if agent is virtual, check phyisical EK cert and make sure it matches phyiscal EK\n        if 'provider_keys' in self.registrar_data:\n            if not self.check_ek(self.registrar_data['provider_keys']['ekcert']):\n                return False\n\n        # check all EKs with optional script:\n        script = config.get('tenant', 'ek_check_script')\n        if not script:\n            return True\n\n        if script[0] != '/':\n            script = os.path.join(config.WORK_DIR, script)\n\n        logger.info(\"Checking EK with script %s\", script)\n        # now we need to exec the script with the ek and ek cert in vars\n        env = os.environ.copy()\n        env['AGENT_UUID'] = self.agent_uuid\n        env['EK'] = tpm2_objects.pubkey_from_tpm2b_public(\n            base64.b64decode(self.registrar_data['ek_tpm']),\n            ).public_bytes(\n                crypto_serialization.Encoding.PEM,\n                crypto_serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n        env['EK_TPM'] = self.registrar_data['ek_tpm']\n        if self.registrar_data['ekcert'] is not None:\n            env['EK_CERT'] = self.registrar_data['ekcert']\n        else:\n            env['EK_CERT'] = \"\"\n\n        env['PROVKEYS'] = json.dumps(self.registrar_data.get('provider_keys', {}))\n        proc = subprocess.Popen(script, env=env, shell=True,\n                                cwd=config.WORK_DIR, stdout=subprocess.PIPE,\n                                stderr=subprocess.STDOUT)\n        retval = proc.wait()\n        if retval != 0:\n            raise UserError(\"External check script failed to validate EK\")\n        logger.debug(\"External check script successfully to validated EK\")\n        while True:\n            line = proc.stdout.readline().decode()\n            if line == \"\":\n                break\n            logger.debug(\"ek_check output: %s\", line.strip())\n        return True\n\n    def do_cv(self):\n        \"\"\" Initiaite v, agent_id and ip and initiate the cloudinit sequence\n        \"\"\"\n        b64_v = base64.b64encode(self.V).decode('utf-8')\n        logger.debug(\"b64_v: %s\", b64_v)\n        data = {\n            'v': b64_v,\n            'cloudagent_ip': self.cv_cloudagent_ip,\n            'cloudagent_port': self.agent_port,\n            'tpm_policy': json.dumps(self.tpm_policy),\n            'vtpm_policy': json.dumps(self.vtpm_policy),\n            'allowlist': json.dumps(self.allowlist),\n            'mb_refstate': json.dumps(self.mb_refstate),\n            'ima_sign_verification_keys': json.dumps(self.ima_sign_verification_keys),\n            'metadata': json.dumps(self.metadata),\n            'revocation_key': self.revocation_key,\n            'accept_tpm_hash_algs': self.accept_tpm_hash_algs,\n            'accept_tpm_encryption_algs': self.accept_tpm_encryption_algs,\n            'accept_tpm_signing_algs': self.accept_tpm_signing_algs,\n            'supported_version': self.supported_version,\n        }\n        json_message = json.dumps(data)\n        do_cv = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = do_cv.post(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            data=json_message,\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        if response.status_code == 409:\n            # this is a conflict, need to update or delete it\n            logger.error(\"Agent %s already existed at CV. Please use delete or update.\", self.agent_uuid)\n            sys.exit()\n        elif response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response.json())\n            logger.error(\"POST command response: %s Unexpected response from Cloud Verifier: %s\", response.status_code, response.text)\n            sys.exit()\n\n    def do_cvstatus(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_enabled)\n\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            res = response.pop('results')\n            response['results'] = {self.agent_uuid: res}\n\n            operational_state = states.state_to_str(\n                response['results'][self.agent_uuid]['operational_state'])\n            response['results'][self.agent_uuid]['operational_state'] = operational_state\n\n            logger.info(\"Agent Info:\\n%s\" % json.dumps(response[\"results\"]))\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvlist(self):\n        \"\"\"List all agent statues in cloudverifier\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        verifier_id = \"\"\n        if self.verifier_id is not None:\n            verifier_id = self.verifier_id\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/?verifier={verifier_id}'),\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            logger.info('From verifier %s port %s retrieved: \"%s\"',\n                        self.verifier_ip, self.verifier_port, response)\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvbulkinfo(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        do_cvstatus = RequestsClient(self.verifier_base_url, self.tls_enabled)\n\n        verifier_id = \"\"\n        if self.verifier_id is not None:\n            verifier_id = self.verifier_id\n        response = do_cvstatus.get(\n            (f'/v{self.api_version}/agents/?bulk={True}&verifier={verifier_id}'),\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 404:\n            logger.info(\"Verifier at %s with Port %s does not have agent %s.\",\n                        self.verifier_ip, self.verifier_port, self.agent_uuid)\n            return response.json()\n        if response.status_code == 200:\n            response = response.json()\n\n            for agent in response[\"results\"].keys():\n                response[\"results\"][agent][\"operational_state\"] = \\\n                    states.state_to_str(response[\"results\"][agent][\n                                            \"operational_state\"])\n            logger.info(\"Bulk Agent Info:\\n%s\" % json.dumps(response[\"results\"]))\n\n            return response\n\n        logger.info(\"Status command response: %s. Unexpected response \"\n                    \"from Cloud Verifier %s on port %s. %s\",\n                    response.status_code,\n                    self.verifier_ip, self.verifier_port, str(response))\n        return response\n\n    def do_cvdelete(self, verifier_check=True):\n        \"\"\"Delete agent from Verifier.\"\"\"\n        if verifier_check:\n            cvresponse = self.do_cvstatus()\n\n            if not isinstance(cvresponse, dict):\n                return cvresponse\n\n            if cvresponse['code'] != 200:\n                logger.error(\"Could not get status of agent %s from \"\n                             \"verifier %s.\", self.agent_uuid, self.verifier_ip)\n                return cvresponse\n\n            self.verifier_ip = cvresponse['results'][self.agent_uuid][\"verifier_ip\"]\n            self.verifier_port = cvresponse['results'][self.agent_uuid][\"verifier_port\"]\n\n        do_cvdelete = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = do_cvdelete.delete(\n            (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n            cert=self.cert,\n            verify=False\n        )\n\n        response = response.json()\n\n        if response['code'] == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response\n        if response['code'] == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response\n        if response['code'] == 202:\n            deleted = False\n            for _ in range(12):\n                get_cvdelete = RequestsClient(\n                    self.verifier_base_url, self.tls_enabled)\n                response = get_cvdelete.get(\n                    (f'/v{self.api_version}/agents/{self.agent_uuid}'),\n                    cert=self.cert,\n                    verify=False\n                )\n\n                if response.status_code == 404:\n                    deleted = True\n                    break\n                time.sleep(.4)\n            if deleted:\n                logger.info(\"CV completed deletion of agent %s\", self.agent_uuid)\n                return response.json()\n            logger.error(\"Timed out waiting for delete of agent %s to complete at CV\", self.agent_uuid)\n            return response.json()\n        if response['code'] == 200:\n            logger.info(\"Agent %s deleted from the CV\", self.agent_uuid)\n            return response\n\n        keylime_logging.log_http_response(\n            logger, logging.ERROR, response)\n        return response\n\n    def do_regstatus(self):\n        registrar_client.init_client_tls('tenant')\n        agent_info = registrar_client.getData(self.registrar_ip,\n                                              self.registrar_port,\n                                              self.agent_uuid)\n\n        if not agent_info:\n            logger.info(\n                \"Agent %s does not exist on the registrar. Please register the agent with the registrar.\",\n                self.agent_uuid)\n            response = {}\n            response['code'] = 404\n            response['status'] = \"Agent {0} does not exist on \" \\\n                                 \"registrar {1} port {2}.\".format(\n                self.agent_uuid, self.registrar_ip, self.registrar_port)\n            response['results'] = {}\n            logger.info(json.dumps((response)))\n            return response\n\n        response = {}\n        response['code'] = 200\n        response['status'] = \"Agent {0} exists on registrar {1} port {2}.\".format(\n                self.agent_uuid, self.registrar_ip, self.registrar_port)\n        response['results'] = {}\n        response['results'][self.agent_uuid] = agent_info\n        response['results'][self.agent_uuid]['operational_state'] = \\\n            states.state_to_str(states.REGISTERED)\n\n        logger.info(json.dumps(response))\n\n        return response\n\n    def do_reglist(self):\n        \"\"\"List agents from Registrar\"\"\"\n        registrar_client.init_client_tls('tenant')\n        response = registrar_client.doRegistrarList(\n            self.registrar_ip, self.registrar_port)\n\n        logger.info(\"From registrar %s port %s retrieved %s\",\n                    self.registrar_ip, self.registrar_port,\n                    json.dumps(response))\n        return response\n\n    def do_regdelete(self):\n        \"\"\"Delete agent from Registrar\"\"\"\n        registrar_client.init_client_tls('tenant')\n        response = registrar_client.doRegistrarDelete(self.registrar_ip,\n                                           self.registrar_port,\n                                           self.agent_uuid)\n\n        return response\n\n    def do_status(self):\n        \"\"\"Perform operational state look up for agent\"\"\"\n\n        regresponse = self.do_regstatus()\n\n        if regresponse['code'] == 404:\n            return regresponse\n\n        cvresponse = self.do_cvstatus()\n\n        if not isinstance(cvresponse, dict):\n            logger.error(\"Unexpected response from Cloud Verifier %s on \"\n                         \"port %s. response %s\", self.verifier_ip,\n                         self.verifier_port, str(cvresponse))\n            return cvresponse\n\n        if regresponse['code'] == 200 and cvresponse['code'] == 200:\n            return cvresponse\n        if regresponse['code'] == 200 and cvresponse['code'] != 200:\n            return regresponse\n\n        logger.error(\"Unknown inconsistent state between registrar %s on \"\n                     \"port %s and verifier %s on port %s occured. Got \"\n                     \"registrar response %s verifier response %s\",\n                     self.verifier_ip, self.verifier_port, self.registrar_ip,\n                     self.registrar_port, str(regresponse), str(cvresponse))\n\n        return {'registrar': regresponse, 'verifier': cvresponse}\n\n    def do_cvreactivate(self, verifier_check=True):\n        \"\"\"Reactive Agent.\"\"\"\n        if verifier_check:\n            agent_json = self.do_cvstatus()\n            self.verifier_ip = agent_json['results'][self.agent_uuid]['verifier_ip']\n            self.verifier_port = agent_json['results'][self.agent_uuid]['verifier_port']\n\n        do_cvreactivate = RequestsClient(\n            self.verifier_base_url, self.tls_enabled)\n        response = do_cvreactivate.put(\n            f'/v{self.api_version}/agents/{self.agent_uuid}/reactivate',\n            data=b'',\n            cert=self.cert,\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            return response.json()\n        if response.status_code == 200:\n            logger.info(\"Agent %s re-activated\", self.agent_uuid)\n            return response.json()\n\n        response_body = response.json()\n        keylime_logging.log_http_response(\n            logger, logging.ERROR, response_body)\n        logger.error(\"Update command response: %s Unexpected response from Cloud Verifier.\", response.status_code)\n        return response.json()\n\n    def do_cvstop(self):\n        \"\"\" Stop declared active agent\n        \"\"\"\n        params = f'/v{self.api_version}/agents/{self.agent_uuid}/stop'\n        do_cvstop = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = do_cvstop.put(\n            params,\n            cert=self.cert,\n            data=b'',\n            verify=False\n        )\n\n        if response.status_code == 503:\n            logger.error(\"Cannot connect to Verifier at %s with Port %s. Connection refused.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n        elif response.status_code == 504:\n            logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n            sys.exit()\n\n        response_body = response.json()\n        if response.status_code != 200:\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response_body)\n        else:\n            logger.info(\"Agent %s stopped\", self.agent_uuid)\n\n    def do_quote(self):\n        \"\"\" Perform TPM quote by GET towards Agent\n\n        Raises:\n            UserError: Connection handler\n        \"\"\"\n        self.nonce = TPM_Utilities.random_password(20)\n\n        numtries = 0\n        response = None\n        # Note: We need a specific retry handler (perhaps in common), no point having localised unless we have too.\n        while True:\n            try:\n                params = f'/v{self.supported_version}/quotes/identity?nonce=%s' % (self.nonce)\n                cloudagent_base_url = f'{self.agent_ip}:{self.agent_port}'\n\n                if self.registrar_data['mtls_cert']:\n                    with RequestsClient(cloudagent_base_url, tls_enabled=True, ignore_hostname=True, cert=self.agent_cert,\n                                        verify_custom=self.registrar_data['mtls_cert']) as do_quote:\n                        response = do_quote.get(params)\n                else:\n                    logger.warning(\"Connecting to agent without using mTLS!\")\n                    do_quote = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                    response = do_quote.get(params)\n\n                print(response)\n                response_body = response.json()\n\n            except Exception as e:\n                if response.status_code in (503, 504):\n                    numtries += 1\n                    maxr = config.getint('tenant', 'max_retries')\n                    if numtries >= maxr:\n                        logger.error(\"Tenant cannot establish connection to agent on %s with port %s\", self.agent_ip, self.agent_port)\n                        sys.exit()\n                    retry = config.getfloat('tenant', 'retry_interval')\n                    logger.info(\"Tenant connection to agent at %s refused %s/%s times, trying again in %s seconds...\",\n                        self.agent_ip, numtries, maxr, retry)\n                    time.sleep(retry)\n                    continue\n\n                raise e\n            break\n\n        try:\n            if response is not None and response.status_code != 200:\n                raise UserError(\n                    \"Status command response: %d Unexpected response from Cloud Agent.\" % response.status)\n\n            if \"results\" not in response_body:\n                raise UserError(\n                    \"Error: unexpected http response body from Cloud Agent: %s\" % str(response.status))\n\n            quote = response_body[\"results\"][\"quote\"]\n            logger.debug(\"Agent_quote received quote: %s\", quote)\n\n            public_key = response_body[\"results\"][\"pubkey\"]\n            logger.debug(\"Agent_quote received public key: %s\", public_key)\n\n            # Ensure hash_alg is in accept_tpm_hash_algs list\n            hash_alg = response_body[\"results\"][\"hash_alg\"]\n            logger.debug(\"Agent_quote received hash algorithm: %s\", hash_alg)\n            if not algorithms.is_accepted(hash_alg, config.get('tenant', 'accept_tpm_hash_algs').split(','))\\\n                    or not algorithms.Hash.is_recognized(hash_alg):\n                raise UserError(\n                    \"TPM Quote is using an unaccepted hash algorithm: %s\" % hash_alg)\n\n            # Ensure enc_alg is in accept_tpm_encryption_algs list\n            enc_alg = response_body[\"results\"][\"enc_alg\"]\n            logger.debug(\"Agent_quote received encryption algorithm: %s\", enc_alg)\n            if not algorithms.is_accepted(enc_alg, config.get('tenant', 'accept_tpm_encryption_algs').split(',')):\n                raise UserError(\n                    \"TPM Quote is using an unaccepted encryption algorithm: %s\" % enc_alg)\n\n            # Ensure sign_alg is in accept_tpm_encryption_algs list\n            sign_alg = response_body[\"results\"][\"sign_alg\"]\n            logger.debug(\"Agent_quote received signing algorithm: %s\", sign_alg)\n            if not algorithms.is_accepted(sign_alg, config.get('tenant', 'accept_tpm_signing_algs').split(',')):\n                raise UserError(\n                    \"TPM Quote is using an unaccepted signing algorithm: %s\" % sign_alg)\n\n            if not self.validate_tpm_quote(public_key, quote, algorithms.Hash(hash_alg)):\n                raise UserError(\n                    \"TPM Quote from cloud agent is invalid for nonce: %s\" % self.nonce)\n\n            logger.info(\"Quote from %s validated\", self.agent_ip)\n\n            # encrypt U with the public key\n            encrypted_U = crypto.rsa_encrypt(\n                crypto.rsa_import_pubkey(public_key), self.U)\n\n            b64_encrypted_u = base64.b64encode(encrypted_U)\n            logger.debug(\"b64_encrypted_u: %s\", b64_encrypted_u.decode('utf-8'))\n            data = {\n                'encrypted_key': b64_encrypted_u.decode('utf-8'),\n                'auth_tag': self.auth_tag\n            }\n\n            if self.payload is not None:\n                data['payload'] = self.payload.decode('utf-8')\n\n\n            # post encrypted U back to CloudAgent\n            params = f'/v{self.supported_version}/keys/ukey'\n            cloudagent_base_url = (\n                f'{self.agent_ip}:{self.agent_port}'\n            )\n\n            if self.registrar_data['mtls_cert']:\n                with RequestsClient(cloudagent_base_url, tls_enabled=True, ignore_hostname=True, cert=self.agent_cert,\n                                    verify_custom=self.registrar_data['mtls_cert']) as post_ukey:\n                    response = post_ukey.post(params, json=data)\n            else:\n                logger.warning(\"Connecting to agent without using mTLS!\")\n                post_ukey = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                response = post_ukey.post(params, json=data)\n\n            if response.status_code == 503:\n                logger.error(\"Cannot connect to Agent at %s with Port %s. Connection refused.\", self.agent_ip, self.agent_port)\n                sys.exit()\n            elif response.status_code == 504:\n                logger.error(\"Verifier at %s with Port %s timed out.\", self.verifier_ip, self.verifier_port)\n                sys.exit()\n\n            if response.status_code != 200:\n                keylime_logging.log_http_response(\n                    logger, logging.ERROR, response_body)\n                raise UserError(\n                    \"Posting of Encrypted U to the Cloud Agent failed with response code %d (%s)\" % (response.status_code, response.text))\n        except Exception as e:\n            self.do_cvstop()\n            raise e\n\n    def do_verify(self):\n        \"\"\" Perform verify using a random generated challenge\n        \"\"\"\n        challenge = TPM_Utilities.random_password(20)\n        numtries = 0\n        while True:\n            try:\n                cloudagent_base_url = (\n                    f'{self.agent_ip}:{self.agent_port}'\n                )\n\n\n                if self.registrar_data['mtls_cert']:\n                    with RequestsClient(cloudagent_base_url, tls_enabled=True, ignore_hostname=True,\n                                        cert=self.agent_cert, verify_custom=self.registrar_data['mtls_cert']) as do_verify:\n                        response = do_verify.get(f'/v{self.supported_version}/keys/verify?challenge={challenge}')\n                else:\n                    logger.warning(\"Connecting to agent without using mTLS!\")\n                    do_verify = RequestsClient(cloudagent_base_url, tls_enabled=False)\n                    response = do_verify.get(f'/v{self.supported_version}/keys/verify?challenge={challenge}')\n\n            except Exception as e:\n                if response.status_code in (503, 504):\n                    numtries += 1\n                    maxr = config.getint('tenant', 'max_retries')\n                    if numtries >= maxr:\n                        logger.error(\"Cannot establish connection to agent on %s with port %s\", self.agent_ip, self.agent_port)\n                        sys.exit()\n                    retry = config.getfloat('tenant', 'retry_interval')\n                    logger.info(\"Verifier connection to agent at %s refused %s/%s times, trying again in %s seconds...\",\n                        self.agent_ip, numtries, maxr, retry)\n                    time.sleep(retry)\n                    continue\n\n                raise e\n            response_body = response.json()\n            if response.status_code == 200:\n                if \"results\" not in response_body or 'hmac' not in response_body['results']:\n                    logger.critical(\"Error: unexpected http response body from Cloud Agent: %s\", response.status_code)\n                    break\n                mac = response_body['results']['hmac']\n\n                ex_mac = crypto.do_hmac(self.K, challenge)\n\n                if mac == ex_mac:\n                    logger.info(\"Key derivation successful\")\n                else:\n                    logger.error(\"Key derivation failed\")\n            else:\n                keylime_logging.log_http_response(\n                    logger, logging.ERROR, response_body)\n                retry = config.getfloat('tenant', 'retry_interval')\n                logger.warning(\"Key derivation not yet complete...trying again in %s seconds...Ctrl-C to stop\", retry)\n                time.sleep(retry)\n                continue\n            break\n\n    def do_add_allowlist(self, args):\n        if 'allowlist_name' not in args or not args['allowlist_name']:\n            raise UserError('allowlist_name is required to add an allowlist')\n\n        allowlist_name = args['allowlist_name']\n        self.process_allowlist(args)\n        data = {\n            'tpm_policy': json.dumps(self.tpm_policy),\n            'vtpm_policy': json.dumps(self.vtpm_policy),\n            'allowlist': json.dumps(self.allowlist)\n        }\n        body = json.dumps(data)\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = cv_client.post(f'/v{self.api_version}/allowlists/{allowlist_name}', data=body,\n                                  cert=self.cert, verify=False)\n        print(response.json())\n\n    def do_delete_allowlist(self, name):\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = cv_client.delete(f'/v{self.api_version}/allowlists/{name}',\n                                    cert=self.cert, verify=False)\n        print(response.json())\n\n    def do_show_allowlist(self, name):\n        cv_client = RequestsClient(self.verifier_base_url, self.tls_enabled)\n        response = cv_client.get(f'/v{self.api_version}/allowlists/{name}',\n                                 cert=self.cert, verify=False)\n        print(f\"Show allowlist command response: {response.status_code}.\")\n        print(response.json())\n\n\ndef write_to_namedtempfile(data, delete_tmp_files):\n    temp = tempfile.NamedTemporaryFile(prefix=\"keylime-\", delete=delete_tmp_files)\n    temp.write(data)\n    temp.flush()\n    return temp.name\n\ndef main(argv=sys.argv):\n    \"\"\"[summary]\n\n    Keyword Arguments:\n        argv {[type]} -- [description] (default: {sys.argv})\n\n    Raises:\n        UserError: [description]\n        UserError: [description]\n        UserError: [description]\n    \"\"\"\n    parser = argparse.ArgumentParser(argv[0])\n    parser.add_argument('-c', '--command', action='store', dest='command', default='add',\n                        help=\"valid commands are add,delete,update,\"\n                             \"regstatus,cvstatus,status,reglist,cvlist,reactivate,\"\n                             \"regdelete,\"\n                             \"bulkinfo. defaults to add\")\n    parser.add_argument('-t', '--targethost', action='store',\n                        dest='agent_ip', help=\"the IP address of the host to provision\")\n    parser.add_argument('-tp', '--targetport', action='store',\n                        dest='agent_port', help=\"the Port of the host to provision\")\n    parser.add_argument('-r', '--registrarhost', action='store',\n                        dest='registrar_ip', help=\"the IP address of the registrar where to retrieve the agents data from.\")\n    parser.add_argument('-rp', '--registrarport', action=\"store\",\n                        dest='registrar_port', help=\"the port of the registrar.\")\n    parser.add_argument('--cv_targethost', action='store', default=None, dest='cv_agent_ip',\n                        help='the IP address of the host to provision that the verifier will use (optional).  Use only if different than argument to option -t/--targethost')\n    parser.add_argument('-v', '--cv', action='store', dest='verifier_ip',\n                        help=\"the IP address of the cloud verifier\")\n    parser.add_argument('-vp', '--cvport', action='store', dest='verifier_port',\n                        help=\"the port of the cloud verifier\")\n    parser.add_argument('-vi', '--cvid', action='store', dest='verifier_id',\n                        help=\"the unique identifier of a cloud verifier\")\n    parser.add_argument('-nvc', '--no-verifier-check', action='store_false', dest='verifier_check', default=True,\n                        help='Disable the check to confirm if the agent is being processed by the specified verifier. Use only with -c/--command delete or reactivate')\n    parser.add_argument('-u', '--uuid', action='store',\n                        dest='agent_uuid', help=\"UUID for the agent to provision\")\n    parser.add_argument('-f', '--file', action='store', default=None,\n                        help='Deliver the specified plaintext to the provisioned agent')\n    parser.add_argument('--cert', action='store', dest='ca_dir', default=None,\n                        help='Create and deliver a certificate using a CA created by ca-util. Pass in the CA directory or use \"default\" to use the standard dir')\n    parser.add_argument('-k', '--key', action='store', dest='keyfile',\n                        help='an intermedia key file produced by user_data_encrypt')\n    parser.add_argument('-p', '--payload', action='store', default=None,\n                        help='Specify the encrypted payload to deliver with encrypted keys specified by -k')\n    parser.add_argument('--include', action='store', dest='incl_dir', default=None,\n                        help=\"Include additional files in provided directory in certificate zip file.  Must be specified with --cert\")\n    parser.add_argument('--allowlist', action='store', dest='allowlist',\n                        default=None, help=\"Specify the file path of an allowlist\")\n    parser.add_argument('--signature-verification-key', '--sign_verification_key', action='append', dest='ima_sign_verification_keys',\n                        default=[], help=\"Specify an IMA file signature verification key\")\n    parser.add_argument('--signature-verification-key-sig', action='append', dest='ima_sign_verification_key_sigs',\n                        default=[], help=\"Specify the GPG signature file for an IMA file signature verification key; pair this option with --signature-verification-key\")\n    parser.add_argument('--signature-verification-key-sig-key', action='append', dest='ima_sign_verification_key_sig_keys',\n                        default=[], help=\"Specify the GPG public key file use to validate the --signature-verification-key-sig; pair this option with --signature-verification-key\")\n    parser.add_argument('--signature-verification-key-url', action='append', dest='ima_sign_verification_key_urls',\n                        default=[], help=\"Specify the URL for a remote IMA file signature verification key\")\n    parser.add_argument('--signature-verification-key-sig-url', action='append',\n                        dest='ima_sign_verification_key_sig_urls',\n                        default=[], help=\"Specify the URL for the remote GPG signature of a remote IMA file signature verification key; pair this option with --signature-verification-key-url\")\n    parser.add_argument('--signature-verification-key-sig-url-key', action='append',\n                        dest='ima_sign_verification_key_sig_url_keys',\n                        default=[], help=\"Specify the GPG public key file used to validate the --signature-verification-key-sig-url; pair this option with --signature-verification-key-url\")\n    parser.add_argument('--mb_refstate', action='store', dest='mb_refstate',\n                        default=None, help=\"Specify the location of a measure boot reference state (intended state)\")\n    parser.add_argument('--allowlist-checksum', action='store', dest='allowlist_checksum',\n                        default=None, help=\"Specify the SHA2 checksum of an allowlist\")\n    parser.add_argument('--allowlist-sig', action='store', dest='allowlist_sig',\n                        default=None, help=\"Specify the GPG signature file of an allowlist\")\n    parser.add_argument('--allowlist-sig-key', action='store', dest='allowlist_sig_key',\n                        default=None, help=\"Specify the GPG public key file used to validate the --allowlist-sig or --allowlist-sig-url\")\n    parser.add_argument('--allowlist-url', action='store', dest='allowlist_url',\n                        default=None, help=\"Specify the URL of a remote allowlist\")\n    parser.add_argument('--allowlist-sig-url', action='store', dest='allowlist_sig_url',\n                        default=None, help=\"Specify the URL of the remote GPG signature file of an allowlist\")\n    parser.add_argument('--exclude', action='store', dest='ima_exclude',\n                        default=None, help=\"Specify the location of an IMA exclude list\")\n    parser.add_argument('--tpm_policy', action='store', dest='tpm_policy', default=None,\n                        help=\"Specify a TPM policy in JSON format. e.g., {\\\"15\\\":\\\"0000000000000000000000000000000000000000\\\"}\")\n    parser.add_argument('--vtpm_policy', action='store', dest='vtpm_policy',\n                        default=None, help=\"Specify a vTPM policy in JSON format\")\n    parser.add_argument('--verify', action='store_true', default=False,\n                        help='Block on cryptographically checked key derivation confirmation from the agent once it has been provisioned')\n    parser.add_argument('--allowlist-name', help='The name of allowlist to operate with')\n    parser.add_argument('--supported-version', default=None, action=\"store\", dest='supported_version', help='API version that is supported by the agent. Detected automatically by default')\n\n    args = parser.parse_args(argv[1:])\n\n    # Make sure argument dependencies are enforced\n    if( args.allowlist and args.allowlist_url):\n        parser.error(\"--allowlist and --allowlist-url cannot be specified at the same time\")\n    if( args.allowlist_url and not (args.allowlist_sig or args.allowlist_sig_url or args.allowlist_checksum)):\n        parser.error(\"--allowlist-url must have either --allowlist-sig, --allowlist-sig-url or --allowlist-checksum to verifier integrity\")\n    if( args.allowlist_sig and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-sig must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_sig_url and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-sig-url must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_checksum and not (args.allowlist_url or args.allowlist)):\n        parser.error(\"--allowlist-checksum must have either --allowlist or --allowlist-url\")\n    if( args.allowlist_sig and not args.allowlist_sig_key):\n        parser.error(\"--allowlist-sig must also have --allowlist-sig-key\")\n    if( args.allowlist_sig_url and not args.allowlist_sig_key):\n        parser.error(\"--allowlist-sig-url must also have --allowlist-sig-key\")\n    if( args.allowlist_sig_key and not (args.allowlist_sig or args.allowlist_sig_url)):\n        parser.error(\"--allowlist-sig-key must have either --allowlist-sig or --allowlist-sig-url\")\n\n    mytenant = Tenant()\n\n    if args.agent_uuid is not None:\n        mytenant.agent_uuid = args.agent_uuid\n        # if the uuid is actually a public key, then hash it\n        if mytenant.agent_uuid.startswith('-----BEGIN PUBLIC KEY-----'):\n            mytenant.agent_uuid = hashlib.sha256(\n                mytenant.agent_uuid).hexdigest()\n        if not validators.valid_agent_id(mytenant.agent_uuid):\n            raise UserError(\"The agent ID set via agent uuid parameter use invalid characters\")\n    else:\n        logger.warning(\"Using default UUID d432fbb3-d2f1-4a97-9ef7-75bd81c00000\")\n        mytenant.agent_uuid = \"d432fbb3-d2f1-4a97-9ef7-75bd81c00000\"\n\n    if config.STUB_VTPM and config.TPM_CANNED_VALUES is not None:\n        # Use canned values for agent UUID\n        jsonIn = config.TPM_CANNED_VALUES\n        if \"add_vtpm_to_group\" in jsonIn:\n            mytenant.agent_uuid = jsonIn['add_vtpm_to_group']['retout']\n        else:\n            # Our command hasn't been canned!\n            raise UserError(\"Command %s not found in canned JSON!\" %\n                            (\"add_vtpm_to_group\"))\n\n    if args.verifier_id is not None:\n        mytenant.verifier_id = args.verifier_id\n    if args.verifier_ip is not None:\n        mytenant.verifier_ip = args.verifier_ip\n    if args.verifier_port is not None:\n        mytenant.verifier_port = args.verifier_port\n\n    if args.registrar_ip is not None:\n        mytenant.registrar_ip = args.registrar_ip\n    if args.registrar_port is not None:\n        mytenant.registrar_port = args.registrar_port\n\n    # we only need to fetch remote files if we are adding or updating\n    if args.command in ['add', 'update']:\n        delete_tmp_files = logger.level > logging.DEBUG # delete tmp files unless in DEBUG mode\n\n        if args.allowlist_url:\n            logger.info(\"Downloading Allowlist from %s\", args.allowlist_url)\n            response = requests.get(args.allowlist_url, allow_redirects=False)\n            if response.status_code == 200:\n                args.allowlist = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Allowlist temporarily saved in %s\" % args.allowlist)\n            else:\n                raise Exception(f\"Downloading allowlist ({args.allowlist_url}) failed with status code {response.status_code}!\")\n\n        if args.allowlist_sig_url:\n            logger.info(\"Downloading Allowlist signature from %s\", args.allowlist_sig_url)\n            response = requests.get(args.allowlist_sig_url, allow_redirects=False)\n            if response.status_code == 200:\n                args.allowlist_sig = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Allowlist signature temporarily saved in %s\", args.allowlist_sig)\n            else:\n                raise Exception(f\"Downloading allowlist signature ({args.allowlist_sig_url}) failed with status code {response.status_code}!\")\n\n        # verify all the local keys for which we have a signature file and a key to verify\n        for i, key_file in enumerate(args.ima_sign_verification_keys):\n            if len(args.ima_sign_verification_key_sigs) <= i:\n                break\n            keysig_file = args.ima_sign_verification_key_sigs[i]\n            if len(args.ima_sign_verification_key_sig_keys) == 0:\n                raise UserError(\"A gpg key is missing for key signature file '%s'\" % keysig_file)\n\n            gpg_key_file = args.ima_sign_verification_key_sig_keys[i]\n            gpg.gpg_verify_filesignature(gpg_key_file, key_file, keysig_file, \"IMA file signing key\")\n\n            logger.info(\"Signature verification on %s was successful\" % key_file)\n\n        # verify all the remote keys for which we have a signature URL and key to to verify\n        # Append the downloaded key files to args.ima_sign_verification_keys\n        for i, key_url in enumerate(args.ima_sign_verification_key_urls):\n\n            logger.info(\"Downloading key from %s\", key_url)\n            response = requests.get(key_url, allow_redirects=False)\n            if response.status_code == 200:\n                key_file = write_to_namedtempfile(response.content, delete_tmp_files)\n                args.ima_sign_verification_keys.append(key_file)\n                logger.debug(\"Key temporarily saved in %s\" % key_file)\n            else:\n                raise Exception(f\"Downloading key ({key_url}) failed with status code {response.status_code}!\")\n\n            if len(args.ima_sign_verification_key_sig_urls) <= i:\n                continue\n\n            keysig_url = args.ima_sign_verification_key_sig_urls[i]\n\n            if len(args.ima_sign_verification_key_sig_url_keys) == 0:\n                raise UserError(\"A gpg key is missing for key signature URL '%s'\" % keysig_url)\n\n            logger.info(\"Downloading key signature from %s\" % keysig_url)\n            response = requests.get(keysig_url, allow_redirects=False)\n            if response.status_code == 200:\n                keysig_file = write_to_namedtempfile(response.content, delete_tmp_files)\n                logger.debug(\"Key signature temporarily saved in %s\" % keysig_file)\n            else:\n                raise Exception(f\"Downloading key signature ({key_url}) failed with status code {response.status_code}!\")\n\n            gpg_key_file = args.ima_sign_verification_key_sig_url_keys[i]\n            gpg.gpg_verify_filesignature(gpg_key_file, key_file, keysig_file, \"IMA file signing key\")\n            logger.info(\"Signature verification on %s was successful\" % key_url)\n\n    if args.command == 'add':\n        mytenant.init_add(vars(args))\n        mytenant.preloop()\n        mytenant.do_cv()\n        mytenant.do_quote()\n        if args.verify:\n            mytenant.do_verify()\n    elif args.command == 'update':\n        mytenant.init_add(vars(args))\n        mytenant.do_cvdelete(args.verifier_check)\n        mytenant.preloop()\n        mytenant.do_cv()\n        mytenant.do_quote()\n        if args.verify:\n            mytenant.do_verify()\n    elif args.command == 'delete':\n        mytenant.do_cvdelete(args.verifier_check)\n    elif args.command == 'status':\n        mytenant.do_status()\n    elif args.command == 'cvstatus':\n        mytenant.do_cvstatus()\n    elif args.command == 'bulkinfo':\n        mytenant.do_cvbulkinfo()\n    elif args.command == 'cvlist':\n        mytenant.do_cvlist()\n    elif args.command == 'reactivate':\n        mytenant.do_cvreactivate(args.verifier_check)\n    elif args.command == 'regstatus':\n        mytenant.do_regstatus()\n    elif args.command == 'reglist':\n        mytenant.do_reglist()\n    elif args.command == 'regdelete':\n        mytenant.do_regdelete()\n    elif args.command == 'addallowlist':\n        mytenant.do_add_allowlist(vars(args))\n    elif args.command == 'showallowlist':\n        mytenant.do_show_allowlist(args.allowlist_name)\n    elif args.command == 'deleteallowlist':\n        mytenant.do_delete_allowlist(args.allowlist_name)\n    else:\n        raise UserError(\"Invalid command specified: %s\" % (args.command))\n", "#!/usr/bin/python3\n\n'''\nSPDX-License-Identifier: BSD-2-Clause\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nimport base64\nimport logging\nimport os\nimport ssl\nimport traceback\nimport sys\n\nimport tornado.ioloop\nimport tornado.web\n\nfrom keylime.requests_client import RequestsClient\nfrom keylime.common import validators, states\nfrom keylime import config\nfrom keylime import json\nfrom keylime import keylime_logging\nfrom keylime import tenant\nfrom keylime import web_util\nfrom keylime import api_version as keylime_api_version\n\n\nlogger = keylime_logging.init_logging('tenant_webapp')\ntenant_templ = tenant.Tenant()\n(my_cert, my_priv_key), agent_cert = tenant_templ.get_tls_context()\ncert = (my_cert, my_priv_key)\nif config.getboolean('general', \"enable_tls\"):\n    tls_enabled = True\nelse:\n    tls_enabled = False\n    cert = \"\"\n    logger.warning(\n        \"Warning: TLS is currently disabled, keys will be sent in the clear! This should only be used for testing.\")\n\nverifier_ip = config.get('cloud_verifier', 'cloudverifier_ip')\nverifier_port = config.get('cloud_verifier', 'cloudverifier_port')\nverifier_base_url = f'{verifier_ip}:{verifier_port}'\n\nregistrar_ip = config.get('registrar', 'registrar_ip')\nregistrar_tls_port = config.get('registrar', 'registrar_tls_port')\nregistrar_base_tls_url = f'{registrar_ip}:{registrar_tls_port}'\n\napi_version = keylime_api_version.current_version()\n\n\nclass Agent_Init_Types:\n    FILE = '0'\n    KEYFILE = '1'\n    CA_DIR = '2'\n\n\nclass BaseHandler(tornado.web.RequestHandler):\n\n    def write_error(self, status_code, **kwargs):\n\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            lines = []\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                lines.append(line)\n            web_util.echo_json_response(self, status_code, self._reason, lines)\n        else:\n            web_util.echo_json_response(self, status_code, self._reason)\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def head(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/ interface instead\")\n\n    def get(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/  interface instead\")\n\n    def put(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/  interface instead\")\n\n    def post(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/  interface instead\")\n\n    def delete(self):\n        web_util.echo_json_response(\n            self, 405, \"Not Implemented: Use /webapp/, /agents/ or /logs/  interface instead\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass WebAppHandler(BaseHandler):\n    def head(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    def get(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents for all agents in a Web-based GUI.\n\n        Currently, only the web app is available for GETing, i.e. /webapp. All other GET uri's\n        will return errors.\n        \"\"\"\n\n        # Get default policies for TPM/vTPM from config as suggestions to user\n        tpm_policy = json.dumps(json.loads(\n            config.get('tenant', 'tpm_policy')), indent=2)\n        vtpm_policy = json.dumps(json.loads(\n            config.get('tenant', 'vtpm_policy')), indent=2)\n\n        # Get default intervals for populating angents, updating agents and updating terminal\n        populate_agents_interval = json.dumps(json.loads(\n            config.get('webapp', 'populate_agents_interval')), indent=2)\n        update_agents_interval = json.dumps(json.loads(\n            config.get('webapp', 'update_agents_interval')), indent=2)\n        update_terminal_interval = json.dumps(json.loads(\n            config.get('webapp', 'update_terminal_interval')), indent=2)\n\n        self.set_status(200)\n        self.set_header('Content-Type', 'text/html')\n        self.write(\n            \"\"\"\n            <!DOCTYPE html>\n            <html>\n                <head>\n                    <meta charset='UTF-8'>\n                    <title>Advanced Tenant Management System</title>\n                    <script type='text/javascript' src='/static/js/webapp.js'></script>\n                    <script type='text/javascript'>\n                        window.onload = function(e) {{\n                            let droppable = document.getElementsByClassName(\"file_drop\");\n                            for (let i = 0; i < droppable.length; i++) {{\n                                droppable[i].addEventListener('dragover', dragoverCallback, false);\n                                droppable[i].addEventListener('drop', fileUploadCallback, false);\n                            }}\n                            populateAgents();\n                            setInterval(populateAgents, {0});\n                            setInterval(updateAgentsInfo, {1});\n                            setInterval(updateTerminal, {2});\n                        }}\n                    </script>\n                    <link href='/static/css/webapp.css' rel='stylesheet' type='text/css'/>\n                </head>\n                <body>\n                    <div id='modal_box' onclick=\"if (event.target == this) {{toggleVisibility(this.id);resetAddAgentForm();return false;}}\">\n\n            \"\"\".format(populate_agents_interval, update_agents_interval, update_terminal_interval)\n        )\n\n        self.write(\n            \"\"\"\n                        <div id='modal_body'>\n                            <center>\n                                <h3>Add Agent</h3>\n                                <h4 id='uuid_str'></h4>\n                            </center>\n                            <form id='add_agent' name='add_agent' onsubmit='submitAddAgentForm(this); return false;'>\n                                <div class=\"form_block\">\n                                    <label for='agent_ip'>Agent IP: </label>\n                                    <input type='text' id='agent_ip' name='agent_ip' value='127.0.0.1' required onfocus='this.select()'>\n                                    <br>\n                                </div>\n\n                                <div id='imalist_toggle' onclick=\"toggleVisibility('imalist_block');\" title='IMA Configuration'>\n                                    IMA Configuration\n                                </div>\n                                <div id=\"imalist_block\">\n                                    <div class=\"form_block\">\n                                        <label for='a_list'>Allow-List: </label>\n                                        <div id='a_list' name='a_list' class='file_drop'>\n                                            <i>Drag payload here &hellip;</i>\n                                        </div>\n                                        <input type='hidden' name='a_list_data' id='a_list_data' value=''>\n                                        <input type='hidden' name='a_list_name' id='a_list_name' value=''>\n                                        <br>\n                                    </div>\n\n                                    <div class=\"form_block\">\n                                        <label for='e_list'>Exclude: </label>\n                                        <div id='e_list' name='e_list' class='file_drop'>\n                                            <i>Drag payload here &hellip;</i>\n                                        </div>\n                                        <input type='hidden' name='e_list_data' id='e_list_data' value=''>\n                                        <input type='hidden' name='e_list_name' id='e_list_name' value=''>\n                                        <br>\n                                    </div>\n                                </div>\n                                <br>\n\n                                <div id='policy_toggle' onclick=\"toggleVisibility('policy_block');\" title='TPM &amp; vTPM Policy Configuration'>\n                                    TPM &amp; vTPM Policy Configuration\n                                </div>\n                                <div id=\"policy_block\">\n                                    <div class=\"form_block\">\n                                        <label for='tpm_policy'>TPM Policy: </label><br>\n                                        <textarea class='json_input' id='tpm_policy' name='tpm_policy'>{}</textarea>\n                                        <br>\n                                    </div>\n\n                                    <div class=\"form_block\">\n                                        <label for='vtpm_policy'>vTPM Policy: </label><br>\n                                        <textarea class='json_input' id='vtpm_policy' name='vtpm_policy'>{}</textarea>\n                                        <br>\n                                    </div>\n                                </div>\n                                <br>\n            \"\"\".format(tpm_policy, vtpm_policy)\n        )\n\n        self.write(\n            \"\"\"\n                                <div id=\"payload_block\">\n                                    <div class=\"form_block\">\n                                        <label for='ptype'>Payload type: </label>\n                                        <label><input type='radio' name='ptype' value='{}' checked=\"checked\" onclick='toggleTabs(this.value)'> File </label>&nbsp;\n                                        <label><input type='radio' name='ptype' value='{}' onclick='toggleTabs(this.value)'> Keyfile </label>&nbsp;\n                                        <label><input type='radio' name='ptype' value='{}' onclick='toggleTabs(this.value)'> CA Dir </label>&nbsp;\n                                        <br>\n                                    </div>\n            \"\"\".format(Agent_Init_Types.FILE, Agent_Init_Types.KEYFILE, Agent_Init_Types.CA_DIR)\n        )\n\n        self.write(\n            \"\"\"\n                                    <div id='keyfile_container' class=\"form_block\" style=\"display:none;\">\n                                        <label for='file'>Keyfile: </label>\n                                        <div id='keyfile' name='keyfile' class='file_drop'>\n                                            <i>Drag key file here &hellip;</i>\n                                        </div>\n                                        <input type='hidden' name='keyfile_data' id='keyfile_data' value=''>\n                                        <input type='hidden' name='keyfile_name' id='keyfile_name' value=''>\n                                        <br>\n                                    </div>\n\n                                    <div id='file_container' class=\"form_block\">\n                                        <label for='file'>Payload: </label>\n                                        <div id='file' name='file' class='file_drop'>\n                                            <i>Drag payload here &hellip;</i>\n                                        </div>\n                                        <input type='hidden' name='file_data' id='file_data' value=''>\n                                        <input type='hidden' name='file_name' id='file_name' value=''>\n                                        <br>\n                                    </div>\n\n                                    <div id='ca_dir_container' style=\"display:none;\">\n                                        <div class=\"form_block\">\n                                            <label for='ca_dir'>CA Dir: </label>\n                                            <input type='text' id='ca_dir' name='ca_dir' placeholder='e.g., default'>\n                                            <br>\n                                        </div>\n\n                                        <div class=\"form_block\">\n                                            <label for='ca_dir_pw'>CA Password: </label>\n                                            <input type='password' id='ca_dir_pw' name='ca_dir_pw' placeholder='e.g., default'>\n                                            <br>\n                                        </div>\n\n                                        <div class=\"form_block\">\n                                            <label for='include_dir'>Include dir: </label>\n                                            <div id='include_dir' name='include_dir' class='file_drop multi_file'>\n                                                <i>Drag files here &hellip;</i>\n                                            </div>\n                                            <input type='hidden' name='include_dir_data' id='include_dir_data' value=''>\n                                            <input type='hidden' name='include_dir_name' id='include_dir_name' value=''>\n                                            <br>\n                                        </div>\n                                    </div>\n                                </div>\n                                <br>\n\n                                <input type='hidden' name='uuid' id='uuid' value=''>\n                                <center><button type=\"submit\" value=\"Add Agent\">Add Agent</button></center>\n                                <br>\n                            </form>\n                        </div>\n                    </div>\n\n                    <div id=\"header\">\n                        <div class=\"logo\" title=\"Keylime\">&nbsp;</div>\n                        <div id=\"header_banner\">\n                            <h1>Keylime Advanced Tenant Management System</h1>\n                        </div>\n                        <div class=\"logo\" style=\"float:right;\" title=\"Keylime\">&nbsp;</div>\n                       <br style=\"clear:both;\">\n                    </div>\n\n                    <div id=\"agent_body\">\n                        <h2>Agents</h2>\n                        <div class='table_header'>\n                            <div class='table_control'>&nbsp;</div>\n                            <div class='table_col'>UUID</div>\n                            <div class='table_col'>address</div>\n                            <div class='table_col'>status</div>\n                            <br style='clear:both;' />\n                        </div>\n                        <div id='agent_template' style='display:none;'>\n                            <li class='agent'>\n                                <div style='display:block;cursor:help;width:800px;'></div>\n                                <div style='display:none;'></div>\n                            </li>\n                        </div>\n                        <ol id='agent_container'></ol>\n                        <div style=\"color:#888;margin-left:15px;padding:10px;\">\n                            <i>End of results</i>\n                        </div>\n                        <div id=\"terminal-frame\">\n                            <div id=\"terminal-header\" onmousedown=\"toggleVisibility('terminal')\">Tenant Logs</div>\n                            <div id=\"terminal\"></div>\n                        </div>\n                    </div>\n                </body>\n            </html>\n            \"\"\"\n        )\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\nclass AgentsHandler(BaseHandler):\n    def head(self):\n        \"\"\"HEAD not supported\"\"\"\n        web_util.echo_json_response(self, 405, \"HEAD not supported\")\n\n    async def get_agent_state(self, agent_id):\n        try:\n            get_agent_state = RequestsClient(verifier_base_url, tls_enabled)\n            response = get_agent_state.get(\n                (f'/v{api_version}/agents/{agent_id}'),\n                cert=cert,\n                verify=False\n            )\n\n        except Exception as e:\n            logger.error(\"Status command response: %s:%s Unexpected response from Cloud Verifier.\",\n                tenant_templ.cloudverifier_ip, tenant_templ.cloudverifier_port)\n            logger.exception(e)\n            web_util.echo_json_response(\n                self, 500, \"Unexpected response from Cloud Verifier\", str(e))\n            logger.error(\"Unexpected response from Cloud Verifier: %s\", e)\n            return\n\n        inst_response_body = response.json()\n\n        if response.status_code not in [200, 404]:\n            logger.error(\"Status command response: %d Unexpected response from Cloud Verifier.\", response.status_code)\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, inst_response_body)\n            return None\n\n        if \"results\" not in inst_response_body:\n            logger.critical(\"Error: unexpected http response body from Cloud Verifier: %s\", response.status_code)\n            return None\n\n        # Agent not added to CV (but still registered)\n        if response.status_code == 404:\n            return {\"operational_state\": states.REGISTERED}\n\n        return inst_response_body[\"results\"]\n\n    async def get(self):\n        \"\"\"This method handles the GET requests to retrieve status on agents from the WebApp.\n\n        Currently, only the web app is available for GETing, i.e. /agents. All other GET uri's\n        will return errors.\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ or /logs/ interface\")\n            return\n\n        if \"logs\" in rest_params and rest_params[\"logs\"] == \"tenant\":\n            offset = 0\n            if \"pos\" in rest_params and rest_params[\"pos\"] is not None and rest_params[\"pos\"].isdigit():\n                offset = int(rest_params[\"pos\"])\n            # intercept requests for logs\n            with open(keylime_logging.LOGSTREAM, encoding=\"utf-8\") as f:\n                logValue = f.readlines()\n                web_util.echo_json_response(self, 200, \"Success\", {\n                                          'log': logValue[offset:]})\n            return\n        if \"agents\" not in rest_params:\n            # otherwise they must be looking for agent info\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('GET returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n        if agent_id is not None:\n            # If the agent ID is not valid (wrong set of characters),\n            # just do nothing.\n            if not validators.valid_agent_id(agent_id):\n                web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n                logger.error(\"GET received an invalid agent ID: %s\", agent_id)\n                return\n\n            # Handle request for specific agent data separately\n            agents = await self.get_agent_state(agent_id)\n            agents[\"id\"] = agent_id\n\n            web_util.echo_json_response(self, 200, \"Success\", agents)\n            return\n\n        # If no agent ID, get list of all agents from Registrar\n        try:\n            get_agents = RequestsClient(registrar_base_tls_url, tls_enabled)\n            response = get_agents.get(\n                (f'/v{api_version}/agents/'),\n                cert=cert,\n                verify=False\n            )\n\n        except Exception as e:\n            logger.error(\"Status command response: %s:%s Unexpected response from Registrar.\",\n                tenant_templ.registrar_ip, tenant_templ.registrar_port)\n            logger.exception(e)\n            web_util.echo_json_response(\n                self, 500, \"Unexpected response from Registrar\", str(e))\n            return\n\n        response_body = response.json()\n\n        if response.status_code != 200:\n            logger.error(\"Status command response: %d Unexpected response from Registrar.\", response.status_code)\n            keylime_logging.log_http_response(\n                logger, logging.ERROR, response_body)\n            return None\n\n        if (\"results\" not in response_body) or (\"uuids\" not in response_body[\"results\"]):\n            logger.critical(\"Error: unexpected http response body from Registrar: %s\", response.status_code)\n            return None\n\n        agent_list = response_body[\"results\"][\"uuids\"]\n\n        web_util.echo_json_response(self, 200, \"Success\", {\n                                  'uuids': agent_list})\n\n    def delete(self):\n        \"\"\"This method handles the DELETE requests to remove agents from the Cloud Verifier.\n\n        Currently, only agents resources are available for DELETEing, i.e. /agents. All other DELETE uri's will return errors.\n        agents requests require a single agent_id parameter which identifies the agent to be deleted.\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('DELETE returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n        # If the agent ID is not valid (wrong set of characters), just\n        # do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n            logger.error(\"DELETE received an invalid agent ID: %s\", agent_id)\n            return\n\n        # let Tenant do dirty work of deleting agent\n        mytenant = tenant.Tenant()\n        mytenant.agent_uuid = agent_id\n        mytenant.do_cvdelete()\n\n        web_util.echo_json_response(self, 200, \"Success\")\n\n    def post(self):\n        \"\"\"This method handles the POST requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for POSTing, i.e. /agents. All other POST uri's will return errors.\n        agents requests require a yaml block sent in the body\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('POST returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n        # If the agent ID is not valid (wrong set of characters), just\n        # do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n            logger.error(\"POST received an invalid agent ID: %s\", agent_id)\n            return\n\n        # Parse payload files (base64 data-uri)\n        if self.get_argument(\"ptype\", Agent_Init_Types.FILE, True) == Agent_Init_Types.FILE:\n            keyfile = None\n            payload = None\n            data = {'data': parse_data_uri(\n                self.get_argument(\"file_data\", None, True))}\n            ca_dir = None\n            incl_dir = None\n            ca_dir_pw = None\n        elif self.get_argument(\"ptype\", Agent_Init_Types.FILE, True) == Agent_Init_Types.KEYFILE:\n            keyfile = {'data': parse_data_uri(\n                self.get_argument(\"keyfile_data\", None, True)), }\n            payload = {'data': parse_data_uri(\n                self.get_argument(\"file_data\", None, True))}\n            data = None\n            ca_dir = None\n            incl_dir = None\n            ca_dir_pw = None\n        elif self.get_argument(\"ptype\", Agent_Init_Types.FILE, True) == Agent_Init_Types.CA_DIR:\n            keyfile = None\n            payload = None\n            data = None\n            incl_dir = {\n                'data': parse_data_uri(self.get_argument(\"include_dir_data\", None, True)),\n                'name': self.get_argument(\"include_dir_name\", \"\", True).splitlines()\n            }\n            ca_dir = self.get_argument(\"ca_dir\", 'default', True)\n            if ca_dir == \"\":\n                ca_dir = 'default'\n            ca_dir_pw = self.get_argument(\"ca_dir_pw\", 'default', True)\n            if ca_dir_pw == \"\":\n                ca_dir_pw = 'default'\n        else:\n            web_util.echo_json_response(self, 400, \"invalid payload type chosen\")\n            logger.warning('POST returning 400 response. malformed query')\n            return\n\n        # Pull in user-defined v/TPM policies\n        tpm_policy = self.get_argument(\"tpm_policy\", \"\", True)\n        if tpm_policy == \"\":\n            tpm_policy = None\n        vtpm_policy = self.get_argument(\"vtpm_policy\", \"\", True)\n        if vtpm_policy == \"\":\n            vtpm_policy = None\n\n        # Pull in allowlist\n        allowlist = None\n        a_list_data = self.get_argument(\"a_list_data\", None, True)\n        if a_list_data != \"\":\n            allowlist_str = parse_data_uri(a_list_data)\n            if allowlist_str is not None:\n                allowlist = allowlist_str[0].splitlines()\n\n        # Pull in IMA exclude list\n        ima_exclude = None\n        e_list_data = self.get_argument(\"e_list_data\", None, True)\n        if e_list_data != \"\":\n            ima_exclude_str = parse_data_uri(e_list_data)\n            if ima_exclude_str is not None:\n                ima_exclude = ima_exclude_str[0].splitlines()\n\n        # Build args to give to Tenant's init_add method\n        args = {\n            'agent_ip': self.get_argument(\"agent_ip\", None, True),\n            'file': data,\n            'keyfile': keyfile,\n            'payload': payload,\n            'ca_dir': ca_dir,\n            'incl_dir': incl_dir,\n            'ca_dir_pw': ca_dir_pw,\n            'tpm_policy': tpm_policy,\n            'vtpm_policy': vtpm_policy,\n            'allowlist': allowlist,\n            'ima_exclude': ima_exclude,\n        }\n\n        # let Tenant do dirty work of adding agent\n        try:\n            mytenant = tenant.Tenant()\n            mytenant.agent_uuid = agent_id\n            mytenant.init_add(args)\n            mytenant.preloop()\n            mytenant.do_cv()\n            mytenant.do_quote()\n        except Exception as e:\n            logger.exception(e)\n            logger.warning('POST returning 500 response. Tenant error: %s', e)\n            web_util.echo_json_response(self, 500, \"Request failure\", str(e))\n            return\n\n        web_util.echo_json_response(self, 200, \"Success\")\n\n    def put(self):\n        \"\"\"This method handles the PUT requests to add agents to the Cloud Verifier.\n\n        Currently, only agents resources are available for PUTing, i.e. /agents. All other PUT uri's will return errors.\n        \"\"\"\n\n        rest_params = web_util.get_restful_params(self.request.uri)\n        if rest_params is None:\n            web_util.echo_json_response(\n                self, 405, \"Not Implemented: Use /agents/ interface\")\n            return\n\n        if \"agents\" not in rest_params:\n            web_util.echo_json_response(self, 400, \"uri not supported\")\n            logger.warning('PUT returning 400 response. uri not supported: %s', self.request.path)\n            return\n\n        agent_id = rest_params[\"agents\"]\n        # If the agent ID is not valid (wrong set of characters), just\n        # do nothing.\n        if not validators.valid_agent_id(agent_id):\n            web_util.echo_json_response(self, 400, \"agent_id not not valid\")\n            logger.error(\"PUT received an invalid agent ID: %s\", agent_id)\n            return\n\n        # let Tenant do dirty work of reactivating agent\n        mytenant = tenant.Tenant()\n        mytenant.agent_uuid = agent_id\n        mytenant.do_cvreactivate()\n\n        web_util.echo_json_response(self, 200, \"Success\")\n\n    def data_received(self, chunk):\n        raise NotImplementedError()\n\n\ndef parse_data_uri(data_uri):\n    if data_uri is None:\n        return None\n\n    data = []\n\n    dataset_uris = data_uri.split(\"\\n\")\n    for uri in dataset_uris:\n        fpos = uri.find(\",\")\n        if fpos == -1:\n            return None\n\n        try:\n            data.append(base64.b64decode(uri[fpos:]).decode('utf-8'))\n        except Exception:\n            # skip bad data\n            continue\n\n    return data\n\n\ndef start_tornado(tornado_server, port):\n    tornado_server.listen(port)\n    logger.info(\"Starting Tornado on port %s\", port)\n    tornado.ioloop.IOLoop.instance().start()\n    logger.info(\"Tornado finished\")\n\n\ndef get_tls_context():\n    ca_cert = config.get('tenant', 'ca_cert')\n\n    tls_dir = config.get('tenant', 'tls_dir')\n\n    if tls_dir == 'default':\n        ca_cert = 'cacert.crt'\n        tls_dir = 'cv_ca'\n\n    # this is relative path, convert to absolute in WORK_DIR\n    if tls_dir[0] != '/':\n        tls_dir = os.path.abspath(os.path.join(config.WORK_DIR, tls_dir))\n\n    logger.info(\"Setting up client TLS in %s\", tls_dir)\n\n    ca_path = os.path.join(tls_dir, ca_cert)\n    my_tls_cert = os.path.join(tls_dir, my_cert)\n    my_tls_priv_key = os.path.join(tls_dir, my_priv_key)\n\n    context = ssl.create_default_context()\n    context.load_verify_locations(cafile=ca_path)\n    context.load_cert_chain(\n        certfile=my_tls_cert, keyfile=my_tls_priv_key)\n    context.verify_mode = ssl.CERT_REQUIRED\n    context.check_hostname = config.getboolean(\n        'general', 'tls_check_hostnames')\n    return context\n\n\ndef main():\n    \"\"\"Main method of the Tenant Webapp Server.  This method is encapsulated in a function for packaging to allow it to be\n    called as a function by an external program.\"\"\"\n\n    webapp_port = config.getint('webapp', 'webapp_port')\n\n    if not config.REQUIRE_ROOT and webapp_port < 1024:\n        webapp_port += 2000\n        logger.warning(\"Running without root, changing port to %d\", webapp_port)\n\n    logger.info('Starting Tenant WebApp (tornado) on port %d use <Ctrl-C> to stop', webapp_port)\n\n    # Figure out where our static files are located\n    if getattr(sys, 'frozen', False):\n        # static directory must be bundled with the script\n        root_dir = os.path.dirname(os.path.abspath(sys.executable))\n    else:\n        # instead try to locate static directory relative to script\n        root_dir = os.path.dirname(os.path.abspath(__file__))\n    if not os.path.exists(root_dir + \"/static/\"):\n        raise Exception(\n            'Static resource directory could not be found in %s!' % (root_dir))\n\n    app = tornado.web.Application([\n        (r\"/webapp/.*\", WebAppHandler),\n        (r\"/(?:v[0-9]/)?agents/.*\", AgentsHandler),\n        (r\"/(?:v[0-9]/)?logs/.*\", AgentsHandler),\n        (r'/static/(.*)', tornado.web.StaticFileHandler,\n         {'path': root_dir + \"/static/\"}),\n        (r\".*\", MainHandler),\n    ])\n\n    # WebApp Server TLS\n    server_context = get_tls_context()\n    server_context.check_hostname = False  # config.getboolean('general', 'tls_check_hostnames')\n    server_context.verify_mode = ssl.CERT_NONE  # ssl.CERT_REQUIRED\n\n    # Set up server\n    server = tornado.httpserver.HTTPServer(app, ssl_options=server_context)\n    server.bind(webapp_port, address='0.0.0.0')\n    server.start(config.getint('cloud_verifier',\n                               'multiprocessing_pool_num_workers'))\n\n    try:\n        tornado.ioloop.IOLoop.instance().start()\n    except KeyboardInterrupt:\n        tornado.ioloop.IOLoop.instance().stop()\n"], "filenames": ["keylime/cloud_verifier_tornado.py", "keylime/keylime_agent.py", "keylime/registrar_common.py", "keylime/tenant.py", "keylime/tenant_webapp.py"], "buggy_code_start_loc": [21, 678, 19, 37, 19], "buggy_code_end_loc": [536, 678, 412, 1315, 595], "fixing_code_start_loc": [21, 679, 20, 37, 19], "fixing_code_end_loc": [566, 684, 442, 1318, 621], "type": "CWE-290", "message": "In Keylime before 6.3.0, unsanitized UUIDs can be passed by a rogue agent and can lead to log spoofing on the verifier and registrar.", "other": {"cve": {"id": "CVE-2022-23949", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2022-09-21T19:15:10.027", "lastModified": "2022-12-21T15:01:19.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Keylime before 6.3.0, unsanitized UUIDs can be passed by a rogue agent and can lead to log spoofing on the verifier and registrar."}, {"lang": "es", "value": "En Keylime versiones anteriores a 6.3.0, los UUIDs no saneados pueden ser pasados por un agente deshonesto y pueden conllevar a una suplantaci\u00f3n de registros en el verificador y el registrador"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-290"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-290"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keylime:keylime:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.3.0", "matchCriteriaId": "8BF970A4-62CA-4D1A-BDCC-4E5C717AD6C5"}]}]}], "references": [{"url": "https://github.com/keylime/keylime/commit/387e320dc22c89f4f47c68cb37eb9eec2137f34b", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/keylime/keylime/commit/65c2b737129b5837f4a03660aeb1191ced275a57", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/keylime/keylime/commit/e429e95329fc60608713ddfb82f4a92ee3b3d2d9", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/keylime/keylime/security/advisories/GHSA-87gh-qc28-j9mm", "source": "patrick@puiterwijk.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/oss-sec/2022/q1/101", "source": "patrick@puiterwijk.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/keylime/keylime/commit/387e320dc22c89f4f47c68cb37eb9eec2137f34b"}}