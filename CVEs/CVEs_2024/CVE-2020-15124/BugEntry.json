{"buggy_code": ["/**\n * This file is part of the Goobi viewer - a content presentation and management application for digitized objects.\n *\n * Visit these websites for more information.\n *          - http://www.intranda.com\n *          - http://digiverso.com\n *\n * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage io.goobi.viewer.controller;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentLibException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentNotFoundException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ServiceNotAllowedException;\nimport io.goobi.viewer.api.rest.AbstractApiUrlManager;\nimport io.goobi.viewer.api.rest.resourcebuilders.TextResourceBuilder;\nimport io.goobi.viewer.exceptions.AccessDeniedException;\nimport io.goobi.viewer.exceptions.DAOException;\nimport io.goobi.viewer.exceptions.HTTPException;\nimport io.goobi.viewer.exceptions.IndexUnreachableException;\nimport io.goobi.viewer.exceptions.PresentationException;\nimport io.goobi.viewer.exceptions.ViewerConfigurationException;\nimport io.goobi.viewer.managedbeans.utils.BeanUtils;\n\n/**\n * Utility class for retrieving data folders, data files and source files.\n *\n */\npublic class DataFileTools {\n\n    private static final Logger logger = LoggerFactory.getLogger(DataFileTools.class);\n\n\n    /**\n     * Retrieves the path to viewer home or repositories root, depending on the record. Used to generate a specific task client query parameter.\n     *\n     * @param pi Record identifier\n     * @return The root folder path of the data repositories; viewer home if none are used\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getDataRepositoryPathForRecord(String pi) throws PresentationException, IndexUnreachableException {\n        String dataRepositoryPath = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataRepositoryPath(dataRepositoryPath);\n    }\n\n    /**\n     * Returns the absolute path to the data repository with the given name (including a slash at the end). Package private to discourage direct usage\n     * by clients.\n     *\n     * @param dataRepositoryPath Data repository name or absolute path\n     * @return\n     * @should return correct path for empty data repository\n     * @should return correct path for data repository name\n     * @should return correct path for absolute data repository path\n     */\n    static String getDataRepositoryPath(String dataRepositoryPath) {\n        if (StringUtils.isBlank(dataRepositoryPath)) {\n            return DataManager.getInstance().getConfiguration().getViewerHome();\n        }\n\n        if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryPath)).isAbsolute()) {\n            return dataRepositoryPath + '/';\n        }\n\n        return DataManager.getInstance().getConfiguration().getDataRepositoriesHome() + dataRepositoryPath + '/';\n    }\n\n    /**\n     * Constructs the media folder path for the given pi, either directly in viewer-home or within a data repository\n     *\n     * @param pi The work PI. This is both the actual name of the folder and the identifier used to look up data repository in solr\n     * @return A Path to the media folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getMediaFolder(String pi) throws PresentationException, IndexUnreachableException {\n        return getDataFolder(pi, DataManager.getInstance().getConfiguration().getMediaFolder());\n    }\n\n    /**\n     * Returns a map of Paths for each data folder name passed as an argument.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @return HashMap<dataFolderName,Path>\n     * @should return all requested data folders\n     * @param dataFolderNames a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Map<String, Path> getDataFolders(String pi, String... dataFolderNames) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n        if (dataFolderNames == null) {\n            throw new IllegalArgumentException(\"dataFolderNames may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n\n        Map<String, Path> ret = new HashMap<>(dataFolderNames.length);\n        for (String dataFolderName : dataFolderNames) {\n            ret.put(dataFolderName, getDataFolder(pi, dataFolderName, dataRepositoryName));\n        }\n\n        return ret;\n    }\n\n    /**\n     * Constructs the folder path for data of the given pi, either directly in viewer-home or within a data repository.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @param dataFolderName the data folder within the repository; e.g 'media' or 'alto'\n     * @return A Path to the data folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataFolder(pi, dataFolderName, dataRepository);\n    }\n\n    /**\n     * Returns the data folder path for the given record identifier. To be used in clients that already possess the data repository name.\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param dataFolderName a {@link java.lang.String} object.\n     * @param dataRepositoryFolder Absolute path to the data repository folder or just the folder name\n     * @should return correct folder if no data repository used\n     * @should return correct folder if data repository used\n     * @return a {@link java.nio.file.Path} object.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName, String dataRepositoryFolder) {\n        Path repository;\n        // TODO Find a way to use absolute repo paths in unit tests\n        if (StringUtils.isBlank(dataRepositoryFolder)) {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getViewerHome());\n        } else if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryFolder)).isAbsolute()) {\n            repository = Paths.get(dataRepositoryFolder);\n        } else {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getDataRepositoriesHome(), dataRepositoryFolder);\n        }\n\n        Path folder = repository.resolve(dataFolderName).resolve(pi);\n\n        return folder;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param dataFolderName Name of the data folder (e.g. 'alto') - first choice\n     * @param altDataFolderName Name of the data folder - second choice\n     * @param fileName Name of the content file\n     * @return Path to the requested file\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)\n            throws PresentationException, IndexUnreachableException {\n        java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);\n        if (StringUtils.isNotBlank(fileName)) {\n            dataFolderPath = dataFolderPath.resolve(fileName);\n        }\n        if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {\n            return getDataFilePath(pi, altDataFolderName, null, fileName);\n        }\n\n        return dataFolderPath;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param relativeFilePath File path relative to data repositories root\n     * @return File represented by the relative file path\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        String dataRepositoryPath = getDataRepositoryPath(dataRepositoryName);\n\n        return Paths.get(dataRepositoryPath, relativeFilePath);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getSourceFilePath(String fileName, String format) throws PresentationException, IndexUnreachableException {\n        String pi = FilenameUtils.getBaseName(fileName);\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getSourceFilePath(fileName, dataRepository, format);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO/DENKXWEB/DUBLINCORE) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param dataRepository a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should construct METS file path correctly\n     * @should construct LIDO file path correctly\n     * @should construct DenkXweb file path correctly\n     * @should throw IllegalArgumentException if fileName is null\n     * @should throw IllegalArgumentException if format is unknown\n     * @return a {@link java.lang.String} object.\n     */\n    public static String getSourceFilePath(String fileName, String dataRepository, String format) {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n        switch (format) {\n            case SolrConstants._METS:\n            case SolrConstants._LIDO:\n            case SolrConstants._DENKXWEB:\n            case SolrConstants._WORLDVIEWS:\n            case SolrConstants._DUBLINCORE:\n                break;\n            default:\n                throw new IllegalArgumentException(\"format must be: METS | LIDO | DENKXWEB | DUBLINCORE | WORLDVIEWS\");\n        }\n\n        StringBuilder sb = new StringBuilder(getDataRepositoryPath(dataRepository));\n        switch (format) {\n            case SolrConstants._METS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n            case SolrConstants._LIDO:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedLidoFolder());\n                break;\n            case SolrConstants._DENKXWEB:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDenkxwebFolder());\n                break;\n            case SolrConstants._DUBLINCORE:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDublinCoreFolder());\n                break;\n            case SolrConstants._WORLDVIEWS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n        }\n        sb.append('/').append(fileName);\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should return correct path\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getTextFilePath(String pi, String fileName, String format) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n\n        String dataFolderName = null;\n        switch (format) {\n            case SolrConstants.FILENAME_ALTO:\n                dataFolderName = DataManager.getInstance().getConfiguration().getAltoFolder();\n                break;\n            case SolrConstants.FILENAME_FULLTEXT:\n                dataFolderName = DataManager.getInstance().getConfiguration().getFulltextFolder();\n                break;\n            case SolrConstants.FILENAME_TEI:\n                dataFolderName = DataManager.getInstance().getConfiguration().getTeiFolder();\n                break;\n        }\n\n        return getDataFilePath(pi, dataFolderName, null, fileName).toAbsolutePath().toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param relativeFilePath ALTO/text file path relative to the data folder\n     * @return a {@link java.nio.file.Path} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getTextFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isBlank(relativeFilePath)) {\n            return null;\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        Path filePath = Paths.get(getDataRepositoryPath(dataRepository), relativeFilePath);\n\n        return filePath;\n    }\n\n    /**\n     * Loads plain full-text via the REST service. ALTO is preferred (and converted to plain text, with a plain text fallback.\n     *\n     * @param altoFilePath ALTO file path relative to the repository root (e.g. \"alto/PPN123/00000001.xml\")\n     * @param fulltextFilePath plain full-text file path relative to the repository root (e.g. \"fulltext/PPN123/00000001.xml\")\n     * @param mergeLineBreakWords a boolean.\n     * @param request a {@link javax.servlet.http.HttpServletRequest} object.\n     * @should load fulltext from alto correctly\n     * @should load fulltext from plain text correctly\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadFulltext(String altoFilePath, String fulltextFilePath, boolean mergeLineBreakWords,\n            HttpServletRequest request)\n            throws AccessDeniedException, FileNotFoundException, IOException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                if (alto != null) {\n                    return ALTOTools.getFullText(alto, mergeLineBreakWords, request);\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n        if (fulltextFilePath != null) {\n            // Plain full-text file\n            try {\n                String fulltext = builder.getFulltext(FileTools.getBottomFolderFromPathString(fulltextFilePath),\n                        FileTools.getFilenameFromPathString(fulltextFilePath));\n                if (fulltext != null) {\n                    return fulltext;\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n\n        return null;\n    }\n    \n    public static String loadAlto(String altoFilePath)\n            throws  ContentNotFoundException, AccessDeniedException, IndexUnreachableException, DAOException, PresentationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                return alto;\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            }\n        } else throw new ContentNotFoundException(\"Alto file \" + altoFilePath + \" not found\");\n        \n\n    }\n\n    /**\n     * <p>\n     * loadTei.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param language a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadTei(String pi, String language)\n            throws AccessDeniedException, FileNotFoundException, IOException, ViewerConfigurationException {\n        logger.trace(\"loadTei: {}/{}\", pi, language);\n        if (pi == null) {\n            return null;\n        }\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        try {\n            return builder.getTeiDocument(pi, language);\n        } catch (PresentationException | IndexUnreachableException | DAOException | ContentLibException e) {\n            logger.error(e.toString());\n            return null;\n        }\n    }\n}\n"], "fixing_code": ["/**\n * This file is part of the Goobi viewer - a content presentation and management application for digitized objects.\n *\n * Visit these websites for more information.\n *          - http://www.intranda.com\n *          - http://digiverso.com\n *\n * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\npackage io.goobi.viewer.controller;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentLibException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ContentNotFoundException;\nimport de.unigoettingen.sub.commons.contentlib.exceptions.ServiceNotAllowedException;\nimport io.goobi.viewer.api.rest.AbstractApiUrlManager;\nimport io.goobi.viewer.api.rest.resourcebuilders.TextResourceBuilder;\nimport io.goobi.viewer.exceptions.AccessDeniedException;\nimport io.goobi.viewer.exceptions.DAOException;\nimport io.goobi.viewer.exceptions.HTTPException;\nimport io.goobi.viewer.exceptions.IndexUnreachableException;\nimport io.goobi.viewer.exceptions.PresentationException;\nimport io.goobi.viewer.exceptions.ViewerConfigurationException;\nimport io.goobi.viewer.managedbeans.utils.BeanUtils;\n\n/**\n * Utility class for retrieving data folders, data files and source files.\n *\n */\npublic class DataFileTools {\n\n    private static final Logger logger = LoggerFactory.getLogger(DataFileTools.class);\n\n\n    /**\n     * Retrieves the path to viewer home or repositories root, depending on the record. Used to generate a specific task client query parameter.\n     *\n     * @param pi Record identifier\n     * @return The root folder path of the data repositories; viewer home if none are used\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getDataRepositoryPathForRecord(String pi) throws PresentationException, IndexUnreachableException {\n        String dataRepositoryPath = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataRepositoryPath(dataRepositoryPath);\n    }\n\n    /**\n     * Returns the absolute path to the data repository with the given name (including a slash at the end). Package private to discourage direct usage\n     * by clients.\n     *\n     * @param dataRepositoryPath Data repository name or absolute path\n     * @return\n     * @should return correct path for empty data repository\n     * @should return correct path for data repository name\n     * @should return correct path for absolute data repository path\n     */\n    static String getDataRepositoryPath(String dataRepositoryPath) {\n        if (StringUtils.isBlank(dataRepositoryPath)) {\n            return DataManager.getInstance().getConfiguration().getViewerHome();\n        }\n\n        if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryPath)).isAbsolute()) {\n            return dataRepositoryPath + '/';\n        }\n\n        return DataManager.getInstance().getConfiguration().getDataRepositoriesHome() + dataRepositoryPath + '/';\n    }\n\n    /**\n     * Constructs the media folder path for the given pi, either directly in viewer-home or within a data repository\n     *\n     * @param pi The work PI. This is both the actual name of the folder and the identifier used to look up data repository in solr\n     * @return A Path to the media folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getMediaFolder(String pi) throws PresentationException, IndexUnreachableException {\n        return getDataFolder(pi, DataManager.getInstance().getConfiguration().getMediaFolder());\n    }\n\n    /**\n     * Returns a map of Paths for each data folder name passed as an argument.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @return HashMap<dataFolderName,Path>\n     * @should return all requested data folders\n     * @param dataFolderNames a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Map<String, Path> getDataFolders(String pi, String... dataFolderNames) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n        if (dataFolderNames == null) {\n            throw new IllegalArgumentException(\"dataFolderNames may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n\n        Map<String, Path> ret = new HashMap<>(dataFolderNames.length);\n        for (String dataFolderName : dataFolderNames) {\n            ret.put(dataFolderName, getDataFolder(pi, dataFolderName, dataRepositoryName));\n        }\n\n        return ret;\n    }\n\n    /**\n     * Constructs the folder path for data of the given pi, either directly in viewer-home or within a data repository.\n     *\n     * @param pi The record identifier. This is both the actual name of the folder and the identifier used to look up data repository in Solr\n     * @param dataFolderName the data folder within the repository; e.g 'media' or 'alto'\n     * @return A Path to the data folder for the given PI\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getDataFolder(pi, dataFolderName, dataRepository);\n    }\n\n    /**\n     * Returns the data folder path for the given record identifier. To be used in clients that already possess the data repository name.\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param dataFolderName a {@link java.lang.String} object.\n     * @param dataRepositoryFolder Absolute path to the data repository folder or just the folder name\n     * @should return correct folder if no data repository used\n     * @should return correct folder if data repository used\n     * @return a {@link java.nio.file.Path} object.\n     */\n    public static Path getDataFolder(String pi, String dataFolderName, String dataRepositoryFolder) {\n        Path repository;\n        // TODO Find a way to use absolute repo paths in unit tests\n        if (StringUtils.isBlank(dataRepositoryFolder)) {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getViewerHome());\n        } else if (Paths.get(FileTools.adaptPathForWindows(dataRepositoryFolder)).isAbsolute()) {\n            repository = Paths.get(dataRepositoryFolder);\n        } else {\n            repository = Paths.get(DataManager.getInstance().getConfiguration().getDataRepositoriesHome(), dataRepositoryFolder);\n        }\n\n        Path folder = repository.resolve(dataFolderName).resolve(pi);\n\n        return folder;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param dataFolderName Name of the data folder (e.g. 'alto') - first choice\n     * @param altDataFolderName Name of the data folder - second choice\n     * @param fileName Name of the content file\n     * @return Path to the requested file\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)\n            throws PresentationException, IndexUnreachableException {\n        //make sure fileName is a pure filename and not a path\n        fileName = Paths.get(fileName).getFileName().toString();\n        java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);\n        if (StringUtils.isNotBlank(fileName)) {\n            dataFolderPath = dataFolderPath.resolve(fileName);\n        }\n        if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {\n            return getDataFilePath(pi, altDataFolderName, null, fileName);\n        }\n\n        return dataFolderPath;\n    }\n\n    /**\n     * <p>\n     * getDataFilePath.\n     * </p>\n     *\n     * @param pi Record identifier\n     * @param relativeFilePath File path relative to data repositories root\n     * @return File represented by the relative file path\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getDataFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (pi == null) {\n            throw new IllegalArgumentException(\"pi may not be null\");\n        }\n\n        String dataRepositoryName = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        String dataRepositoryPath = getDataRepositoryPath(dataRepositoryName);\n\n        return Paths.get(dataRepositoryPath, relativeFilePath);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getSourceFilePath(String fileName, String format) throws PresentationException, IndexUnreachableException {\n        String pi = FilenameUtils.getBaseName(fileName);\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        return getSourceFilePath(fileName, dataRepository, format);\n    }\n\n    /**\n     * Returns the absolute path to the source (METS/LIDO/DENKXWEB/DUBLINCORE) file with the given file name.\n     *\n     * @param fileName a {@link java.lang.String} object.\n     * @param dataRepository a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should construct METS file path correctly\n     * @should construct LIDO file path correctly\n     * @should construct DenkXweb file path correctly\n     * @should throw IllegalArgumentException if fileName is null\n     * @should throw IllegalArgumentException if format is unknown\n     * @return a {@link java.lang.String} object.\n     */\n    public static String getSourceFilePath(String fileName, String dataRepository, String format) {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n        switch (format) {\n            case SolrConstants._METS:\n            case SolrConstants._LIDO:\n            case SolrConstants._DENKXWEB:\n            case SolrConstants._WORLDVIEWS:\n            case SolrConstants._DUBLINCORE:\n                break;\n            default:\n                throw new IllegalArgumentException(\"format must be: METS | LIDO | DENKXWEB | DUBLINCORE | WORLDVIEWS\");\n        }\n\n        StringBuilder sb = new StringBuilder(getDataRepositoryPath(dataRepository));\n        switch (format) {\n            case SolrConstants._METS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n            case SolrConstants._LIDO:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedLidoFolder());\n                break;\n            case SolrConstants._DENKXWEB:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDenkxwebFolder());\n                break;\n            case SolrConstants._DUBLINCORE:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedDublinCoreFolder());\n                break;\n            case SolrConstants._WORLDVIEWS:\n                sb.append(DataManager.getInstance().getConfiguration().getIndexedMetsFolder());\n                break;\n        }\n        sb.append('/').append(fileName);\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param fileName a {@link java.lang.String} object.\n     * @param format a {@link java.lang.String} object.\n     * @should return correct path\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static String getTextFilePath(String pi, String fileName, String format) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isEmpty(fileName)) {\n            throw new IllegalArgumentException(\"fileName may not be null or empty\");\n        }\n        if (StringUtils.isEmpty(format)) {\n            throw new IllegalArgumentException(\"format may not be null or empty\");\n        }\n\n        String dataFolderName = null;\n        switch (format) {\n            case SolrConstants.FILENAME_ALTO:\n                dataFolderName = DataManager.getInstance().getConfiguration().getAltoFolder();\n                break;\n            case SolrConstants.FILENAME_FULLTEXT:\n                dataFolderName = DataManager.getInstance().getConfiguration().getFulltextFolder();\n                break;\n            case SolrConstants.FILENAME_TEI:\n                dataFolderName = DataManager.getInstance().getConfiguration().getTeiFolder();\n                break;\n        }\n\n        return getDataFilePath(pi, dataFolderName, null, fileName).toAbsolutePath().toString();\n    }\n\n    /**\n     * <p>\n     * getTextFilePath.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param relativeFilePath ALTO/text file path relative to the data folder\n     * @return a {@link java.nio.file.Path} object.\n     * @throws io.goobi.viewer.exceptions.PresentationException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     */\n    public static Path getTextFilePath(String pi, String relativeFilePath) throws PresentationException, IndexUnreachableException {\n        if (StringUtils.isBlank(relativeFilePath)) {\n            return null;\n        }\n\n        String dataRepository = DataManager.getInstance().getSearchIndex().findDataRepositoryName(pi);\n        Path filePath = Paths.get(getDataRepositoryPath(dataRepository), relativeFilePath);\n\n        return filePath;\n    }\n\n    /**\n     * Loads plain full-text via the REST service. ALTO is preferred (and converted to plain text, with a plain text fallback.\n     *\n     * @param altoFilePath ALTO file path relative to the repository root (e.g. \"alto/PPN123/00000001.xml\")\n     * @param fulltextFilePath plain full-text file path relative to the repository root (e.g. \"fulltext/PPN123/00000001.xml\")\n     * @param mergeLineBreakWords a boolean.\n     * @param request a {@link javax.servlet.http.HttpServletRequest} object.\n     * @should load fulltext from alto correctly\n     * @should load fulltext from plain text correctly\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.IndexUnreachableException if any.\n     * @throws io.goobi.viewer.exceptions.DAOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadFulltext(String altoFilePath, String fulltextFilePath, boolean mergeLineBreakWords,\n            HttpServletRequest request)\n            throws AccessDeniedException, FileNotFoundException, IOException, IndexUnreachableException, DAOException, ViewerConfigurationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                if (alto != null) {\n                    return ALTOTools.getFullText(alto, mergeLineBreakWords, request);\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n        if (fulltextFilePath != null) {\n            // Plain full-text file\n            try {\n                String fulltext = builder.getFulltext(FileTools.getBottomFolderFromPathString(fulltextFilePath),\n                        FileTools.getFilenameFromPathString(fulltextFilePath));\n                if (fulltext != null) {\n                    return fulltext;\n                }\n            } catch (ContentNotFoundException e) {\n                throw new FileNotFoundException(e.getMessage());\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            } catch (PresentationException e) {\n                logger.error(e.getMessage());\n            }\n        }\n\n        return null;\n    }\n    \n    public static String loadAlto(String altoFilePath)\n            throws  ContentNotFoundException, AccessDeniedException, IndexUnreachableException, DAOException, PresentationException {\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        if (altoFilePath != null) {\n            // ALTO file\n            try {\n                String alto = builder.getAltoDocument(FileTools.getBottomFolderFromPathString(altoFilePath),\n                        FileTools.getFilenameFromPathString(altoFilePath));\n                return alto;\n            } catch (ServiceNotAllowedException e) {\n                throw new AccessDeniedException(\"fulltextAccessDenied\");\n            }\n        } else throw new ContentNotFoundException(\"Alto file \" + altoFilePath + \" not found\");\n        \n\n    }\n\n    /**\n     * <p>\n     * loadTei.\n     * </p>\n     *\n     * @param pi a {@link java.lang.String} object.\n     * @param language a {@link java.lang.String} object.\n     * @return a {@link java.lang.String} object.\n     * @throws io.goobi.viewer.exceptions.AccessDeniedException if any.\n     * @throws java.io.FileNotFoundException if any.\n     * @throws java.io.IOException if any.\n     * @throws io.goobi.viewer.exceptions.ViewerConfigurationException if any.\n     */\n    public static String loadTei(String pi, String language)\n            throws AccessDeniedException, FileNotFoundException, IOException, ViewerConfigurationException {\n        logger.trace(\"loadTei: {}/{}\", pi, language);\n        if (pi == null) {\n            return null;\n        }\n        TextResourceBuilder builder = new TextResourceBuilder(BeanUtils.getRequest(), null);\n        try {\n            return builder.getTeiDocument(pi, language);\n        } catch (PresentationException | IndexUnreachableException | DAOException | ContentLibException e) {\n            logger.error(e.toString());\n            return null;\n        }\n    }\n}\n"], "filenames": ["goobi-viewer-core/src/main/java/io/goobi/viewer/controller/DataFileTools.java"], "buggy_code_start_loc": [188], "buggy_code_end_loc": [188], "fixing_code_start_loc": [189], "fixing_code_end_loc": [191], "type": "CWE-22", "message": "In Goobi Viewer Core before version 4.8.3, a path traversal vulnerability allows for remote attackers to access files on the server via the application. This is limited to files accessible to the application server user, eg. tomcat, but can potentially lead to the disclosure of sensitive information. The vulnerability has been fixed in version 4.8.3", "other": {"cve": {"id": "CVE-2020-15124", "sourceIdentifier": "security-advisories@github.com", "published": "2020-07-22T18:15:11.863", "lastModified": "2020-07-24T20:21:11.453", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Goobi Viewer Core before version 4.8.3, a path traversal vulnerability allows for remote attackers to access files on the server via the application. This is limited to files accessible to the application server user, eg. tomcat, but can potentially lead to the disclosure of sensitive information. The vulnerability has been fixed in version 4.8.3"}, {"lang": "es", "value": "Una vulnerabilidad de salto de ruta en Goobi Viewer Core versiones anteriores a 4.8.3, permite a atacantes remotos acceder a los archivos en el servidor por medio de la aplicaci\u00f3n. Esto est\u00e1 limitado a archivos accesibles para el usuario del servidor de aplicaciones, por ejemplo. Tomcat, pero puede potencialmente conllevar a una divulgaci\u00f3n de informaci\u00f3n confidencial. Esta vulnerabilidad ha sido corregida en la versi\u00f3n 4.8.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:intranda:goobi_viewer_core:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.8.3", "matchCriteriaId": "AD82B722-2D9E-4525-9203-B1791555EEE0"}]}]}], "references": [{"url": "https://github.com/intranda/goobi-viewer-core/commit/44ceb8e2e7e888391e8a941127171d6366770df3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/intranda/goobi-viewer-core/security/advisories/GHSA-7gwq-xqw3-cr63", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/intranda/goobi-viewer-core/commit/44ceb8e2e7e888391e8a941127171d6366770df3"}}