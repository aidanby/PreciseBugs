{"buggy_code": ["/*********************************************************************\n *\n * Filename:      irqueue.c\n * Version:       0.3\n * Description:   General queue implementation\n * Status:        Experimental.\n * Author:        Dag Brattli <dagb@cs.uit.no>\n * Created at:    Tue Jun  9 13:29:31 1998\n * Modified at:   Sun Dec 12 13:48:22 1999\n * Modified by:   Dag Brattli <dagb@cs.uit.no>\n * Modified at:   Thu Jan  4 14:29:10 CET 2001\n * Modified by:   Marc Zyngier <mzyngier@freesurf.fr>\n *\n *     Copyright (C) 1998-1999, Aage Kvalnes <aage@cs.uit.no>\n *     Copyright (C) 1998, Dag Brattli,\n *     All Rights Reserved.\n *\n *     This code is taken from the Vortex Operating System written by Aage\n *     Kvalnes. Aage has agreed that this code can use the GPL licence,\n *     although he does not use that licence in his own code.\n *\n *     This copyright does however _not_ include the ELF hash() function\n *     which I currently don't know which licence or copyright it\n *     has. Please inform me if you know.\n *\n *     This program is free software; you can redistribute it and/or\n *     modify it under the terms of the GNU General Public License as\n *     published by the Free Software Foundation; either version 2 of\n *     the License, or (at your option) any later version.\n *\n *     Neither Dag Brattli nor University of Troms\u00f8 admit liability nor\n *     provide warranty for any of this software. This material is\n *     provided \"AS-IS\" and at no charge.\n *\n ********************************************************************/\n\n/*\n * NOTE :\n * There are various problems with this package :\n *\to the hash function for ints is pathetic (but could be changed)\n *\to locking is sometime suspicious (especially during enumeration)\n *\to most users have only a few elements (== overhead)\n *\to most users never use search, so don't benefit from hashing\n * Problem already fixed :\n *\to not 64 bit compliant (most users do hashv = (int) self)\n *\to hashbin_remove() is broken => use hashbin_remove_this()\n * I think most users would be better served by a simple linked list\n * (like include/linux/list.h) with a global spinlock per list.\n * Jean II\n */\n\n/*\n * Notes on the concurrent access to hashbin and other SMP issues\n * -------------------------------------------------------------\n *\tHashbins are very often in the IrDA stack a global repository of\n * information, and therefore used in a very asynchronous manner following\n * various events (driver calls, timers, user calls...).\n *\tTherefore, very often it is highly important to consider the\n * management of concurrent access to the hashbin and how to guarantee the\n * consistency of the operations on it.\n *\n *\tFirst, we need to define the objective of locking :\n *\t\t1) Protect user data (content pointed by the hashbin)\n *\t\t2) Protect hashbin structure itself (linked list in each bin)\n *\n *\t\t\t     OLD LOCKING\n *\t\t\t     -----------\n *\n *\tThe previous locking strategy, either HB_LOCAL or HB_GLOBAL were\n * both inadequate in *both* aspect.\n *\t\to HB_GLOBAL was using a spinlock for each bin (local locking).\n *\t\to HB_LOCAL was disabling irq on *all* CPUs, so use a single\n *\t\t  global semaphore.\n *\tThe problems were :\n *\t\tA) Global irq disabling is no longer supported by the kernel\n *\t\tB) No protection for the hashbin struct global data\n *\t\t\to hashbin_delete()\n *\t\t\to hb_current\n *\t\tC) No protection for user data in some cases\n *\n *\tA) HB_LOCAL use global irq disabling, so doesn't work on kernel\n * 2.5.X. Even when it is supported (kernel 2.4.X and earlier), its\n * performance is not satisfactory on SMP setups. Most hashbins were\n * HB_LOCAL, so (A) definitely need fixing.\n *\tB) HB_LOCAL could be modified to fix (B). However, because HB_GLOBAL\n * lock only the individual bins, it will never be able to lock the\n * global data, so can't do (B).\n *\tC) Some functions return pointer to data that is still in the\n * hashbin :\n *\t\to hashbin_find()\n *\t\to hashbin_get_first()\n *\t\to hashbin_get_next()\n *\tAs the data is still in the hashbin, it may be changed or free'd\n * while the caller is examinimg the data. In those case, locking can't\n * be done within the hashbin, but must include use of the data within\n * the caller.\n *\tThe caller can easily do this with HB_LOCAL (just disable irqs).\n * However, this is impossible with HB_GLOBAL because the caller has no\n * way to know the proper bin, so don't know which spinlock to use.\n *\n *\tQuick summary : can no longer use HB_LOCAL, and HB_GLOBAL is\n * fundamentally broken and will never work.\n *\n *\t\t\t     NEW LOCKING\n *\t\t\t     -----------\n *\n *\tTo fix those problems, I've introduce a few changes in the\n * hashbin locking :\n *\t\t1) New HB_LOCK scheme\n *\t\t2) hashbin->hb_spinlock\n *\t\t3) New hashbin usage policy\n *\n * HB_LOCK :\n * -------\n *\tHB_LOCK is a locking scheme intermediate between the old HB_LOCAL\n * and HB_GLOBAL. It uses a single spinlock to protect the whole content\n * of the hashbin. As it is a single spinlock, it can protect the global\n * data of the hashbin and not only the bins themselves.\n *\tHB_LOCK can only protect some of the hashbin calls, so it only lock\n * call that can be made 100% safe and leave other call unprotected.\n *\tHB_LOCK in theory is slower than HB_GLOBAL, but as the hashbin\n * content is always small contention is not high, so it doesn't matter\n * much. HB_LOCK is probably faster than HB_LOCAL.\n *\n * hashbin->hb_spinlock :\n * --------------------\n *\tThe spinlock that HB_LOCK uses is available for caller, so that\n * the caller can protect unprotected calls (see below).\n *\tIf the caller want to do entirely its own locking (HB_NOLOCK), he\n * can do so and may use safely this spinlock.\n *\tLocking is done like this :\n *\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n *\tReleasing the lock :\n *\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n *\n * Safe & Protected calls :\n * ----------------------\n *\tThe following calls are safe or protected via HB_LOCK :\n *\t\to hashbin_new()\t\t-> safe\n *\t\to hashbin_delete()\n *\t\to hashbin_insert()\n *\t\to hashbin_remove_first()\n *\t\to hashbin_remove()\n *\t\to hashbin_remove_this()\n *\t\to HASHBIN_GET_SIZE()\t-> atomic\n *\n *\tThe following calls only protect the hashbin itself :\n *\t\to hashbin_lock_find()\n *\t\to hashbin_find_next()\n *\n * Unprotected calls :\n * -----------------\n *\tThe following calls need to be protected by the caller :\n *\t\to hashbin_find()\n *\t\to hashbin_get_first()\n *\t\to hashbin_get_next()\n *\n * Locking Policy :\n * --------------\n *\tIf the hashbin is used only in a single thread of execution\n * (explicitly or implicitely), you can use HB_NOLOCK\n *\tIf the calling module already provide concurrent access protection,\n * you may use HB_NOLOCK.\n *\n *\tIn all other cases, you need to use HB_LOCK and lock the hashbin\n * every time before calling one of the unprotected calls. You also must\n * use the pointer returned by the unprotected call within the locked\n * region.\n *\n * Extra care for enumeration :\n * --------------------------\n *\thashbin_get_first() and hashbin_get_next() use the hashbin to\n * store the current position, in hb_current.\n *\tAs long as the hashbin remains locked, this is safe. If you unlock\n * the hashbin, the current position may change if anybody else modify\n * or enumerate the hashbin.\n *\tSummary : do the full enumeration while locked.\n *\n *\tAlternatively, you may use hashbin_find_next(). But, this will\n * be slower, is more complex to use and doesn't protect the hashbin\n * content. So, care is needed here as well.\n *\n * Other issues :\n * ------------\n *\tI believe that we are overdoing it by using spin_lock_irqsave()\n * and we should use only spin_lock_bh() or similar. But, I don't have\n * the balls to try it out.\n *\tDon't believe that because hashbin are now (somewhat) SMP safe\n * that the rest of the code is. Higher layers tend to be safest,\n * but LAP and LMP would need some serious dedicated love.\n *\n * Jean II\n */\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <net/irda/irda.h>\n#include <net/irda/irqueue.h>\n\n/************************ QUEUE SUBROUTINES ************************/\n\n/*\n * Hashbin\n */\n#define GET_HASHBIN(x) ( x & HASHBIN_MASK )\n\n/*\n * Function hash (name)\n *\n *    This function hash the input string 'name' using the ELF hash\n *    function for strings.\n */\nstatic __u32 hash( const char* name)\n{\n\t__u32 h = 0;\n\t__u32 g;\n\n\twhile(*name) {\n\t\th = (h<<4) + *name++;\n\t\tif ((g = (h & 0xf0000000)))\n\t\t\th ^=g>>24;\n\t\th &=~g;\n\t}\n\treturn h;\n}\n\n/*\n * Function enqueue_first (queue, proc)\n *\n *    Insert item first in queue.\n *\n */\nstatic void enqueue_first(irda_queue_t **queue, irda_queue_t* element)\n{\n\n\t/*\n\t * Check if queue is empty.\n\t */\n\tif ( *queue == NULL ) {\n\t\t/*\n\t\t * Queue is empty.  Insert one element into the queue.\n\t\t */\n\t\telement->q_next = element->q_prev = *queue = element;\n\n\t} else {\n\t\t/*\n\t\t * Queue is not empty.  Insert element into front of queue.\n\t\t */\n\t\telement->q_next          = (*queue);\n\t\t(*queue)->q_prev->q_next = element;\n\t\telement->q_prev          = (*queue)->q_prev;\n\t\t(*queue)->q_prev         = element;\n\t\t(*queue)                 = element;\n\t}\n}\n\n\n/*\n * Function dequeue (queue)\n *\n *    Remove first entry in queue\n *\n */\nstatic irda_queue_t *dequeue_first(irda_queue_t **queue)\n{\n\tirda_queue_t *ret;\n\n\tpr_debug(\"dequeue_first()\\n\");\n\n\t/*\n\t * Set return value\n\t */\n\tret =  *queue;\n\n\tif ( *queue == NULL ) {\n\t\t/*\n\t\t * Queue was empty.\n\t\t */\n\t} else if ( (*queue)->q_next == *queue ) {\n\t\t/*\n\t\t *  Queue only contained a single element. It will now be\n\t\t *  empty.\n\t\t */\n\t\t*queue = NULL;\n\t} else {\n\t\t/*\n\t\t * Queue contained several element.  Remove the first one.\n\t\t */\n\t\t(*queue)->q_prev->q_next = (*queue)->q_next;\n\t\t(*queue)->q_next->q_prev = (*queue)->q_prev;\n\t\t*queue = (*queue)->q_next;\n\t}\n\n\t/*\n\t * Return the removed entry (or NULL of queue was empty).\n\t */\n\treturn ret;\n}\n\n/*\n * Function dequeue_general (queue, element)\n *\n *\n */\nstatic irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)\n{\n\tirda_queue_t *ret;\n\n\tpr_debug(\"dequeue_general()\\n\");\n\n\t/*\n\t * Set return value\n\t */\n\tret =  *queue;\n\n\tif ( *queue == NULL ) {\n\t\t/*\n\t\t * Queue was empty.\n\t\t */\n\t} else if ( (*queue)->q_next == *queue ) {\n\t\t/*\n\t\t *  Queue only contained a single element. It will now be\n\t\t *  empty.\n\t\t */\n\t\t*queue = NULL;\n\n\t} else {\n\t\t/*\n\t\t *  Remove specific element.\n\t\t */\n\t\telement->q_prev->q_next = element->q_next;\n\t\telement->q_next->q_prev = element->q_prev;\n\t\tif ( (*queue) == element)\n\t\t\t(*queue) = element->q_next;\n\t}\n\n\t/*\n\t * Return the removed entry (or NULL of queue was empty).\n\t */\n\treturn ret;\n}\n\n/************************ HASHBIN MANAGEMENT ************************/\n\n/*\n * Function hashbin_create ( type, name )\n *\n *    Create hashbin!\n *\n */\nhashbin_t *hashbin_new(int type)\n{\n\thashbin_t* hashbin;\n\n\t/*\n\t * Allocate new hashbin\n\t */\n\thashbin = kzalloc(sizeof(*hashbin), GFP_ATOMIC);\n\tif (!hashbin)\n\t\treturn NULL;\n\n\t/*\n\t * Initialize structure\n\t */\n\thashbin->hb_type = type;\n\thashbin->magic = HB_MAGIC;\n\t//hashbin->hb_current = NULL;\n\n\t/* Make sure all spinlock's are unlocked */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_init(&hashbin->hb_spinlock);\n\t}\n\n\treturn hashbin;\n}\nEXPORT_SYMBOL(hashbin_new);\n\n\n/*\n * Function hashbin_delete (hashbin, free_func)\n *\n *    Destroy hashbin, the free_func can be a user supplied special routine\n *    for deallocating this structure if it's complex. If not the user can\n *    just supply kfree, which should take care of the job.\n */\n#ifdef CONFIG_LOCKDEP\nstatic int hashbin_lock_depth = 0;\n#endif\nint hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n{\n\tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n\tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\n\t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n\n\t/*\n\t *  Free the entries in the hashbin, TODO: use hashbin_clear when\n\t *  it has been shown to work\n\t */\n\tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n\t\t}\n\t}\n\n\t/* Cleanup local data */\n\thashbin->hb_current = NULL;\n\thashbin->magic = ~HB_MAGIC;\n\n\t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n\n\t/*\n\t *  Free the hashbin structure\n\t */\n\tkfree(hashbin);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hashbin_delete);\n\n/********************* HASHBIN LIST OPERATIONS *********************/\n\n/*\n * Function hashbin_insert (hashbin, entry, name)\n *\n *    Insert an entry into the hashbin\n *\n */\nvoid hashbin_insert(hashbin_t* hashbin, irda_queue_t* entry, long hashv,\n\t\t    const char* name)\n{\n\tunsigned long flags = 0;\n\tint bin;\n\n\tIRDA_ASSERT( hashbin != NULL, return;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return;);\n\n\t/*\n\t * Locate hashbin\n\t */\n\tif ( name )\n\t\thashv = hash( name );\n\tbin = GET_HASHBIN( hashv );\n\n\t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\t/*\n\t * Store name and key\n\t */\n\tentry->q_hash = hashv;\n\tif ( name )\n\t\tstrlcpy( entry->q_name, name, sizeof(entry->q_name));\n\n\t/*\n\t * Insert new entry first\n\t */\n\tenqueue_first( (irda_queue_t**) &hashbin->hb_queue[ bin ],\n\t\t       entry);\n\thashbin->hb_size++;\n\n\t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n}\nEXPORT_SYMBOL(hashbin_insert);\n\n/*\n *  Function hashbin_remove_first (hashbin)\n *\n *    Remove first entry of the hashbin\n *\n * Note : this function no longer use hashbin_remove(), but does things\n * similar to hashbin_remove_this(), so can be considered safe.\n * Jean II\n */\nvoid *hashbin_remove_first( hashbin_t *hashbin)\n{\n\tunsigned long flags = 0;\n\tirda_queue_t *entry = NULL;\n\n\t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\tentry = hashbin_get_first( hashbin);\n\tif ( entry != NULL) {\n\t\tint\tbin;\n\t\tlong\thashv;\n\t\t/*\n\t\t * Locate hashbin\n\t\t */\n\t\thashv = entry->q_hash;\n\t\tbin = GET_HASHBIN( hashv );\n\n\t\t/*\n\t\t * Dequeue the entry...\n\t\t */\n\t\tdequeue_general( (irda_queue_t**) &hashbin->hb_queue[ bin ],\n\t\t\t\t entry);\n\t\thashbin->hb_size--;\n\t\tentry->q_next = NULL;\n\t\tentry->q_prev = NULL;\n\n\t\t/*\n\t\t *  Check if this item is the currently selected item, and in\n\t\t *  that case we must reset hb_current\n\t\t */\n\t\tif ( entry == hashbin->hb_current)\n\t\t\thashbin->hb_current = NULL;\n\t}\n\n\t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\treturn entry;\n}\n\n\n/*\n *  Function hashbin_remove (hashbin, hashv, name)\n *\n *    Remove entry with the given name\n *\n *  The use of this function is highly discouraged, because the whole\n *  concept behind hashbin_remove() is broken. In many cases, it's not\n *  possible to guarantee the unicity of the index (either hashv or name),\n *  leading to removing the WRONG entry.\n *  The only simple safe use is :\n *\t\thashbin_remove(hasbin, (int) self, NULL);\n *  In other case, you must think hard to guarantee unicity of the index.\n *  Jean II\n */\nvoid* hashbin_remove( hashbin_t* hashbin, long hashv, const char* name)\n{\n\tint bin, found = FALSE;\n\tunsigned long flags = 0;\n\tirda_queue_t* entry;\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\n\t/*\n\t * Locate hashbin\n\t */\n\tif ( name )\n\t\thashv = hash( name );\n\tbin = GET_HASHBIN( hashv );\n\n\t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\t/*\n\t * Search for entry\n\t */\n\tentry = hashbin->hb_queue[ bin ];\n\tif ( entry ) {\n\t\tdo {\n\t\t\t/*\n\t\t\t * Check for key\n\t\t\t */\n\t\t\tif ( entry->q_hash == hashv ) {\n\t\t\t\t/*\n\t\t\t\t * Name compare too?\n\t\t\t\t */\n\t\t\t\tif ( name ) {\n\t\t\t\t\tif ( strcmp( entry->q_name, name) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry = entry->q_next;\n\t\t} while ( entry != hashbin->hb_queue[ bin ] );\n\t}\n\n\t/*\n\t * If entry was found, dequeue it\n\t */\n\tif ( found ) {\n\t\tdequeue_general( (irda_queue_t**) &hashbin->hb_queue[ bin ],\n\t\t\t\t entry);\n\t\thashbin->hb_size--;\n\n\t\t/*\n\t\t *  Check if this item is the currently selected item, and in\n\t\t *  that case we must reset hb_current\n\t\t */\n\t\tif ( entry == hashbin->hb_current)\n\t\t\thashbin->hb_current = NULL;\n\t}\n\n\t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\n\t/* Return */\n\tif ( found )\n\t\treturn entry;\n\telse\n\t\treturn NULL;\n\n}\nEXPORT_SYMBOL(hashbin_remove);\n\n/*\n *  Function hashbin_remove_this (hashbin, entry)\n *\n *    Remove entry with the given name\n *\n * In some cases, the user of hashbin can't guarantee the unicity\n * of either the hashv or name.\n * In those cases, using the above function is guaranteed to cause troubles,\n * so we use this one instead...\n * And by the way, it's also faster, because we skip the search phase ;-)\n */\nvoid* hashbin_remove_this( hashbin_t* hashbin, irda_queue_t* entry)\n{\n\tunsigned long flags = 0;\n\tint\tbin;\n\tlong\thashv;\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\tIRDA_ASSERT( entry != NULL, return NULL;);\n\n\t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\t/* Check if valid and not already removed... */\n\tif((entry->q_next == NULL) || (entry->q_prev == NULL)) {\n\t\tentry = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Locate hashbin\n\t */\n\thashv = entry->q_hash;\n\tbin = GET_HASHBIN( hashv );\n\n\t/*\n\t * Dequeue the entry...\n\t */\n\tdequeue_general( (irda_queue_t**) &hashbin->hb_queue[ bin ],\n\t\t\t entry);\n\thashbin->hb_size--;\n\tentry->q_next = NULL;\n\tentry->q_prev = NULL;\n\n\t/*\n\t *  Check if this item is the currently selected item, and in\n\t *  that case we must reset hb_current\n\t */\n\tif ( entry == hashbin->hb_current)\n\t\thashbin->hb_current = NULL;\nout:\n\t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\treturn entry;\n}\nEXPORT_SYMBOL(hashbin_remove_this);\n\n/*********************** HASHBIN ENUMERATION ***********************/\n\n/*\n * Function hashbin_common_find (hashbin, hashv, name)\n *\n *    Find item with the given hashv or name\n *\n */\nvoid* hashbin_find( hashbin_t* hashbin, long hashv, const char* name )\n{\n\tint bin;\n\tirda_queue_t* entry;\n\n\tpr_debug(\"hashbin_find()\\n\");\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\n\t/*\n\t * Locate hashbin\n\t */\n\tif ( name )\n\t\thashv = hash( name );\n\tbin = GET_HASHBIN( hashv );\n\n\t/*\n\t * Search for entry\n\t */\n\tentry = hashbin->hb_queue[ bin];\n\tif ( entry ) {\n\t\tdo {\n\t\t\t/*\n\t\t\t * Check for key\n\t\t\t */\n\t\t\tif ( entry->q_hash == hashv ) {\n\t\t\t\t/*\n\t\t\t\t * Name compare too?\n\t\t\t\t */\n\t\t\t\tif ( name ) {\n\t\t\t\t\tif ( strcmp( entry->q_name, name ) == 0 ) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry = entry->q_next;\n\t\t} while ( entry != hashbin->hb_queue[ bin ] );\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(hashbin_find);\n\n/*\n * Function hashbin_lock_find (hashbin, hashv, name)\n *\n *    Find item with the given hashv or name\n *\n * Same, but with spinlock protection...\n * I call it safe, but it's only safe with respect to the hashbin, not its\n * content. - Jean II\n */\nvoid* hashbin_lock_find( hashbin_t* hashbin, long hashv, const char* name )\n{\n\tunsigned long flags = 0;\n\tirda_queue_t* entry;\n\n\t/* Synchronize */\n\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\n\t/*\n\t * Search for entry\n\t */\n\tentry = hashbin_find(hashbin, hashv, name);\n\n\t/* Release lock */\n\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\n\treturn entry;\n}\nEXPORT_SYMBOL(hashbin_lock_find);\n\n/*\n * Function hashbin_find (hashbin, hashv, name, pnext)\n *\n *    Find an item with the given hashv or name, and its successor\n *\n * This function allow to do concurrent enumerations without the\n * need to lock over the whole session, because the caller keep the\n * context of the search. On the other hand, it might fail and return\n * NULL if the entry is removed. - Jean II\n */\nvoid* hashbin_find_next( hashbin_t* hashbin, long hashv, const char* name,\n\t\t\t void ** pnext)\n{\n\tunsigned long flags = 0;\n\tirda_queue_t* entry;\n\n\t/* Synchronize */\n\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\n\t/*\n\t * Search for current entry\n\t * This allow to check if the current item is still in the\n\t * hashbin or has been removed.\n\t */\n\tentry = hashbin_find(hashbin, hashv, name);\n\n\t/*\n\t * Trick hashbin_get_next() to return what we want\n\t */\n\tif(entry) {\n\t\thashbin->hb_current = entry;\n\t\t*pnext = hashbin_get_next( hashbin );\n\t} else\n\t\t*pnext = NULL;\n\n\t/* Release lock */\n\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\n\treturn entry;\n}\n\n/*\n * Function hashbin_get_first (hashbin)\n *\n *    Get a pointer to first element in hashbin, this function must be\n *    called before any calls to hashbin_get_next()!\n *\n */\nirda_queue_t *hashbin_get_first( hashbin_t* hashbin)\n{\n\tirda_queue_t *entry;\n\tint i;\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\n\tif ( hashbin == NULL)\n\t\treturn NULL;\n\n\tfor ( i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tentry = hashbin->hb_queue[ i];\n\t\tif ( entry) {\n\t\t\thashbin->hb_current = entry;\n\t\t\treturn entry;\n\t\t}\n\t}\n\t/*\n\t *  Did not find any item in hashbin\n\t */\n\treturn NULL;\n}\nEXPORT_SYMBOL(hashbin_get_first);\n\n/*\n * Function hashbin_get_next (hashbin)\n *\n *    Get next item in hashbin. A series of hashbin_get_next() calls must\n *    be started by a call to hashbin_get_first(). The function returns\n *    NULL when all items have been traversed\n *\n * The context of the search is stored within the hashbin, so you must\n * protect yourself from concurrent enumerations. - Jean II\n */\nirda_queue_t *hashbin_get_next( hashbin_t *hashbin)\n{\n\tirda_queue_t* entry;\n\tint bin;\n\tint i;\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\n\tif ( hashbin->hb_current == NULL) {\n\t\tIRDA_ASSERT( hashbin->hb_current != NULL, return NULL;);\n\t\treturn NULL;\n\t}\n\tentry = hashbin->hb_current->q_next;\n\tbin = GET_HASHBIN( entry->q_hash);\n\n\t/*\n\t *  Make sure that we are not back at the beginning of the queue\n\t *  again\n\t */\n\tif ( entry != hashbin->hb_queue[ bin ]) {\n\t\thashbin->hb_current = entry;\n\n\t\treturn entry;\n\t}\n\n\t/*\n\t *  Check that this is not the last queue in hashbin\n\t */\n\tif ( bin >= HASHBIN_SIZE)\n\t\treturn NULL;\n\n\t/*\n\t *  Move to next queue in hashbin\n\t */\n\tbin++;\n\tfor ( i = bin; i < HASHBIN_SIZE; i++ ) {\n\t\tentry = hashbin->hb_queue[ i];\n\t\tif ( entry) {\n\t\t\thashbin->hb_current = entry;\n\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(hashbin_get_next);\n"], "fixing_code": ["/*********************************************************************\n *\n * Filename:      irqueue.c\n * Version:       0.3\n * Description:   General queue implementation\n * Status:        Experimental.\n * Author:        Dag Brattli <dagb@cs.uit.no>\n * Created at:    Tue Jun  9 13:29:31 1998\n * Modified at:   Sun Dec 12 13:48:22 1999\n * Modified by:   Dag Brattli <dagb@cs.uit.no>\n * Modified at:   Thu Jan  4 14:29:10 CET 2001\n * Modified by:   Marc Zyngier <mzyngier@freesurf.fr>\n *\n *     Copyright (C) 1998-1999, Aage Kvalnes <aage@cs.uit.no>\n *     Copyright (C) 1998, Dag Brattli,\n *     All Rights Reserved.\n *\n *     This code is taken from the Vortex Operating System written by Aage\n *     Kvalnes. Aage has agreed that this code can use the GPL licence,\n *     although he does not use that licence in his own code.\n *\n *     This copyright does however _not_ include the ELF hash() function\n *     which I currently don't know which licence or copyright it\n *     has. Please inform me if you know.\n *\n *     This program is free software; you can redistribute it and/or\n *     modify it under the terms of the GNU General Public License as\n *     published by the Free Software Foundation; either version 2 of\n *     the License, or (at your option) any later version.\n *\n *     Neither Dag Brattli nor University of Troms\u00f8 admit liability nor\n *     provide warranty for any of this software. This material is\n *     provided \"AS-IS\" and at no charge.\n *\n ********************************************************************/\n\n/*\n * NOTE :\n * There are various problems with this package :\n *\to the hash function for ints is pathetic (but could be changed)\n *\to locking is sometime suspicious (especially during enumeration)\n *\to most users have only a few elements (== overhead)\n *\to most users never use search, so don't benefit from hashing\n * Problem already fixed :\n *\to not 64 bit compliant (most users do hashv = (int) self)\n *\to hashbin_remove() is broken => use hashbin_remove_this()\n * I think most users would be better served by a simple linked list\n * (like include/linux/list.h) with a global spinlock per list.\n * Jean II\n */\n\n/*\n * Notes on the concurrent access to hashbin and other SMP issues\n * -------------------------------------------------------------\n *\tHashbins are very often in the IrDA stack a global repository of\n * information, and therefore used in a very asynchronous manner following\n * various events (driver calls, timers, user calls...).\n *\tTherefore, very often it is highly important to consider the\n * management of concurrent access to the hashbin and how to guarantee the\n * consistency of the operations on it.\n *\n *\tFirst, we need to define the objective of locking :\n *\t\t1) Protect user data (content pointed by the hashbin)\n *\t\t2) Protect hashbin structure itself (linked list in each bin)\n *\n *\t\t\t     OLD LOCKING\n *\t\t\t     -----------\n *\n *\tThe previous locking strategy, either HB_LOCAL or HB_GLOBAL were\n * both inadequate in *both* aspect.\n *\t\to HB_GLOBAL was using a spinlock for each bin (local locking).\n *\t\to HB_LOCAL was disabling irq on *all* CPUs, so use a single\n *\t\t  global semaphore.\n *\tThe problems were :\n *\t\tA) Global irq disabling is no longer supported by the kernel\n *\t\tB) No protection for the hashbin struct global data\n *\t\t\to hashbin_delete()\n *\t\t\to hb_current\n *\t\tC) No protection for user data in some cases\n *\n *\tA) HB_LOCAL use global irq disabling, so doesn't work on kernel\n * 2.5.X. Even when it is supported (kernel 2.4.X and earlier), its\n * performance is not satisfactory on SMP setups. Most hashbins were\n * HB_LOCAL, so (A) definitely need fixing.\n *\tB) HB_LOCAL could be modified to fix (B). However, because HB_GLOBAL\n * lock only the individual bins, it will never be able to lock the\n * global data, so can't do (B).\n *\tC) Some functions return pointer to data that is still in the\n * hashbin :\n *\t\to hashbin_find()\n *\t\to hashbin_get_first()\n *\t\to hashbin_get_next()\n *\tAs the data is still in the hashbin, it may be changed or free'd\n * while the caller is examinimg the data. In those case, locking can't\n * be done within the hashbin, but must include use of the data within\n * the caller.\n *\tThe caller can easily do this with HB_LOCAL (just disable irqs).\n * However, this is impossible with HB_GLOBAL because the caller has no\n * way to know the proper bin, so don't know which spinlock to use.\n *\n *\tQuick summary : can no longer use HB_LOCAL, and HB_GLOBAL is\n * fundamentally broken and will never work.\n *\n *\t\t\t     NEW LOCKING\n *\t\t\t     -----------\n *\n *\tTo fix those problems, I've introduce a few changes in the\n * hashbin locking :\n *\t\t1) New HB_LOCK scheme\n *\t\t2) hashbin->hb_spinlock\n *\t\t3) New hashbin usage policy\n *\n * HB_LOCK :\n * -------\n *\tHB_LOCK is a locking scheme intermediate between the old HB_LOCAL\n * and HB_GLOBAL. It uses a single spinlock to protect the whole content\n * of the hashbin. As it is a single spinlock, it can protect the global\n * data of the hashbin and not only the bins themselves.\n *\tHB_LOCK can only protect some of the hashbin calls, so it only lock\n * call that can be made 100% safe and leave other call unprotected.\n *\tHB_LOCK in theory is slower than HB_GLOBAL, but as the hashbin\n * content is always small contention is not high, so it doesn't matter\n * much. HB_LOCK is probably faster than HB_LOCAL.\n *\n * hashbin->hb_spinlock :\n * --------------------\n *\tThe spinlock that HB_LOCK uses is available for caller, so that\n * the caller can protect unprotected calls (see below).\n *\tIf the caller want to do entirely its own locking (HB_NOLOCK), he\n * can do so and may use safely this spinlock.\n *\tLocking is done like this :\n *\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n *\tReleasing the lock :\n *\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n *\n * Safe & Protected calls :\n * ----------------------\n *\tThe following calls are safe or protected via HB_LOCK :\n *\t\to hashbin_new()\t\t-> safe\n *\t\to hashbin_delete()\n *\t\to hashbin_insert()\n *\t\to hashbin_remove_first()\n *\t\to hashbin_remove()\n *\t\to hashbin_remove_this()\n *\t\to HASHBIN_GET_SIZE()\t-> atomic\n *\n *\tThe following calls only protect the hashbin itself :\n *\t\to hashbin_lock_find()\n *\t\to hashbin_find_next()\n *\n * Unprotected calls :\n * -----------------\n *\tThe following calls need to be protected by the caller :\n *\t\to hashbin_find()\n *\t\to hashbin_get_first()\n *\t\to hashbin_get_next()\n *\n * Locking Policy :\n * --------------\n *\tIf the hashbin is used only in a single thread of execution\n * (explicitly or implicitely), you can use HB_NOLOCK\n *\tIf the calling module already provide concurrent access protection,\n * you may use HB_NOLOCK.\n *\n *\tIn all other cases, you need to use HB_LOCK and lock the hashbin\n * every time before calling one of the unprotected calls. You also must\n * use the pointer returned by the unprotected call within the locked\n * region.\n *\n * Extra care for enumeration :\n * --------------------------\n *\thashbin_get_first() and hashbin_get_next() use the hashbin to\n * store the current position, in hb_current.\n *\tAs long as the hashbin remains locked, this is safe. If you unlock\n * the hashbin, the current position may change if anybody else modify\n * or enumerate the hashbin.\n *\tSummary : do the full enumeration while locked.\n *\n *\tAlternatively, you may use hashbin_find_next(). But, this will\n * be slower, is more complex to use and doesn't protect the hashbin\n * content. So, care is needed here as well.\n *\n * Other issues :\n * ------------\n *\tI believe that we are overdoing it by using spin_lock_irqsave()\n * and we should use only spin_lock_bh() or similar. But, I don't have\n * the balls to try it out.\n *\tDon't believe that because hashbin are now (somewhat) SMP safe\n * that the rest of the code is. Higher layers tend to be safest,\n * but LAP and LMP would need some serious dedicated love.\n *\n * Jean II\n */\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <net/irda/irda.h>\n#include <net/irda/irqueue.h>\n\n/************************ QUEUE SUBROUTINES ************************/\n\n/*\n * Hashbin\n */\n#define GET_HASHBIN(x) ( x & HASHBIN_MASK )\n\n/*\n * Function hash (name)\n *\n *    This function hash the input string 'name' using the ELF hash\n *    function for strings.\n */\nstatic __u32 hash( const char* name)\n{\n\t__u32 h = 0;\n\t__u32 g;\n\n\twhile(*name) {\n\t\th = (h<<4) + *name++;\n\t\tif ((g = (h & 0xf0000000)))\n\t\t\th ^=g>>24;\n\t\th &=~g;\n\t}\n\treturn h;\n}\n\n/*\n * Function enqueue_first (queue, proc)\n *\n *    Insert item first in queue.\n *\n */\nstatic void enqueue_first(irda_queue_t **queue, irda_queue_t* element)\n{\n\n\t/*\n\t * Check if queue is empty.\n\t */\n\tif ( *queue == NULL ) {\n\t\t/*\n\t\t * Queue is empty.  Insert one element into the queue.\n\t\t */\n\t\telement->q_next = element->q_prev = *queue = element;\n\n\t} else {\n\t\t/*\n\t\t * Queue is not empty.  Insert element into front of queue.\n\t\t */\n\t\telement->q_next          = (*queue);\n\t\t(*queue)->q_prev->q_next = element;\n\t\telement->q_prev          = (*queue)->q_prev;\n\t\t(*queue)->q_prev         = element;\n\t\t(*queue)                 = element;\n\t}\n}\n\n\n/*\n * Function dequeue (queue)\n *\n *    Remove first entry in queue\n *\n */\nstatic irda_queue_t *dequeue_first(irda_queue_t **queue)\n{\n\tirda_queue_t *ret;\n\n\tpr_debug(\"dequeue_first()\\n\");\n\n\t/*\n\t * Set return value\n\t */\n\tret =  *queue;\n\n\tif ( *queue == NULL ) {\n\t\t/*\n\t\t * Queue was empty.\n\t\t */\n\t} else if ( (*queue)->q_next == *queue ) {\n\t\t/*\n\t\t *  Queue only contained a single element. It will now be\n\t\t *  empty.\n\t\t */\n\t\t*queue = NULL;\n\t} else {\n\t\t/*\n\t\t * Queue contained several element.  Remove the first one.\n\t\t */\n\t\t(*queue)->q_prev->q_next = (*queue)->q_next;\n\t\t(*queue)->q_next->q_prev = (*queue)->q_prev;\n\t\t*queue = (*queue)->q_next;\n\t}\n\n\t/*\n\t * Return the removed entry (or NULL of queue was empty).\n\t */\n\treturn ret;\n}\n\n/*\n * Function dequeue_general (queue, element)\n *\n *\n */\nstatic irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)\n{\n\tirda_queue_t *ret;\n\n\tpr_debug(\"dequeue_general()\\n\");\n\n\t/*\n\t * Set return value\n\t */\n\tret =  *queue;\n\n\tif ( *queue == NULL ) {\n\t\t/*\n\t\t * Queue was empty.\n\t\t */\n\t} else if ( (*queue)->q_next == *queue ) {\n\t\t/*\n\t\t *  Queue only contained a single element. It will now be\n\t\t *  empty.\n\t\t */\n\t\t*queue = NULL;\n\n\t} else {\n\t\t/*\n\t\t *  Remove specific element.\n\t\t */\n\t\telement->q_prev->q_next = element->q_next;\n\t\telement->q_next->q_prev = element->q_prev;\n\t\tif ( (*queue) == element)\n\t\t\t(*queue) = element->q_next;\n\t}\n\n\t/*\n\t * Return the removed entry (or NULL of queue was empty).\n\t */\n\treturn ret;\n}\n\n/************************ HASHBIN MANAGEMENT ************************/\n\n/*\n * Function hashbin_create ( type, name )\n *\n *    Create hashbin!\n *\n */\nhashbin_t *hashbin_new(int type)\n{\n\thashbin_t* hashbin;\n\n\t/*\n\t * Allocate new hashbin\n\t */\n\thashbin = kzalloc(sizeof(*hashbin), GFP_ATOMIC);\n\tif (!hashbin)\n\t\treturn NULL;\n\n\t/*\n\t * Initialize structure\n\t */\n\thashbin->hb_type = type;\n\thashbin->magic = HB_MAGIC;\n\t//hashbin->hb_current = NULL;\n\n\t/* Make sure all spinlock's are unlocked */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_init(&hashbin->hb_spinlock);\n\t}\n\n\treturn hashbin;\n}\nEXPORT_SYMBOL(hashbin_new);\n\n\n/*\n * Function hashbin_delete (hashbin, free_func)\n *\n *    Destroy hashbin, the free_func can be a user supplied special routine\n *    for deallocating this structure if it's complex. If not the user can\n *    just supply kfree, which should take care of the job.\n */\nint hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n{\n\tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n\tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\n\t/* Synchronize */\n\tif (hashbin->hb_type & HB_LOCK)\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\n\t/*\n\t *  Free the entries in the hashbin, TODO: use hashbin_clear when\n\t *  it has been shown to work\n\t */\n\tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\twhile (1) {\n\t\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\n\t\t\tif (!queue)\n\t\t\t\tbreak;\n\n\t\t\tif (free_func) {\n\t\t\t\tif (hashbin->hb_type & HB_LOCK)\n\t\t\t\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t\t\t\tfree_func(queue);\n\t\t\t\tif (hashbin->hb_type & HB_LOCK)\n\t\t\t\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Cleanup local data */\n\thashbin->hb_current = NULL;\n\thashbin->magic = ~HB_MAGIC;\n\n\t/* Release lock */\n\tif (hashbin->hb_type & HB_LOCK)\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\n\t/*\n\t *  Free the hashbin structure\n\t */\n\tkfree(hashbin);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hashbin_delete);\n\n/********************* HASHBIN LIST OPERATIONS *********************/\n\n/*\n * Function hashbin_insert (hashbin, entry, name)\n *\n *    Insert an entry into the hashbin\n *\n */\nvoid hashbin_insert(hashbin_t* hashbin, irda_queue_t* entry, long hashv,\n\t\t    const char* name)\n{\n\tunsigned long flags = 0;\n\tint bin;\n\n\tIRDA_ASSERT( hashbin != NULL, return;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return;);\n\n\t/*\n\t * Locate hashbin\n\t */\n\tif ( name )\n\t\thashv = hash( name );\n\tbin = GET_HASHBIN( hashv );\n\n\t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\t/*\n\t * Store name and key\n\t */\n\tentry->q_hash = hashv;\n\tif ( name )\n\t\tstrlcpy( entry->q_name, name, sizeof(entry->q_name));\n\n\t/*\n\t * Insert new entry first\n\t */\n\tenqueue_first( (irda_queue_t**) &hashbin->hb_queue[ bin ],\n\t\t       entry);\n\thashbin->hb_size++;\n\n\t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n}\nEXPORT_SYMBOL(hashbin_insert);\n\n/*\n *  Function hashbin_remove_first (hashbin)\n *\n *    Remove first entry of the hashbin\n *\n * Note : this function no longer use hashbin_remove(), but does things\n * similar to hashbin_remove_this(), so can be considered safe.\n * Jean II\n */\nvoid *hashbin_remove_first( hashbin_t *hashbin)\n{\n\tunsigned long flags = 0;\n\tirda_queue_t *entry = NULL;\n\n\t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\tentry = hashbin_get_first( hashbin);\n\tif ( entry != NULL) {\n\t\tint\tbin;\n\t\tlong\thashv;\n\t\t/*\n\t\t * Locate hashbin\n\t\t */\n\t\thashv = entry->q_hash;\n\t\tbin = GET_HASHBIN( hashv );\n\n\t\t/*\n\t\t * Dequeue the entry...\n\t\t */\n\t\tdequeue_general( (irda_queue_t**) &hashbin->hb_queue[ bin ],\n\t\t\t\t entry);\n\t\thashbin->hb_size--;\n\t\tentry->q_next = NULL;\n\t\tentry->q_prev = NULL;\n\n\t\t/*\n\t\t *  Check if this item is the currently selected item, and in\n\t\t *  that case we must reset hb_current\n\t\t */\n\t\tif ( entry == hashbin->hb_current)\n\t\t\thashbin->hb_current = NULL;\n\t}\n\n\t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\treturn entry;\n}\n\n\n/*\n *  Function hashbin_remove (hashbin, hashv, name)\n *\n *    Remove entry with the given name\n *\n *  The use of this function is highly discouraged, because the whole\n *  concept behind hashbin_remove() is broken. In many cases, it's not\n *  possible to guarantee the unicity of the index (either hashv or name),\n *  leading to removing the WRONG entry.\n *  The only simple safe use is :\n *\t\thashbin_remove(hasbin, (int) self, NULL);\n *  In other case, you must think hard to guarantee unicity of the index.\n *  Jean II\n */\nvoid* hashbin_remove( hashbin_t* hashbin, long hashv, const char* name)\n{\n\tint bin, found = FALSE;\n\tunsigned long flags = 0;\n\tirda_queue_t* entry;\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\n\t/*\n\t * Locate hashbin\n\t */\n\tif ( name )\n\t\thashv = hash( name );\n\tbin = GET_HASHBIN( hashv );\n\n\t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\t/*\n\t * Search for entry\n\t */\n\tentry = hashbin->hb_queue[ bin ];\n\tif ( entry ) {\n\t\tdo {\n\t\t\t/*\n\t\t\t * Check for key\n\t\t\t */\n\t\t\tif ( entry->q_hash == hashv ) {\n\t\t\t\t/*\n\t\t\t\t * Name compare too?\n\t\t\t\t */\n\t\t\t\tif ( name ) {\n\t\t\t\t\tif ( strcmp( entry->q_name, name) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfound = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry = entry->q_next;\n\t\t} while ( entry != hashbin->hb_queue[ bin ] );\n\t}\n\n\t/*\n\t * If entry was found, dequeue it\n\t */\n\tif ( found ) {\n\t\tdequeue_general( (irda_queue_t**) &hashbin->hb_queue[ bin ],\n\t\t\t\t entry);\n\t\thashbin->hb_size--;\n\n\t\t/*\n\t\t *  Check if this item is the currently selected item, and in\n\t\t *  that case we must reset hb_current\n\t\t */\n\t\tif ( entry == hashbin->hb_current)\n\t\t\thashbin->hb_current = NULL;\n\t}\n\n\t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\n\t/* Return */\n\tif ( found )\n\t\treturn entry;\n\telse\n\t\treturn NULL;\n\n}\nEXPORT_SYMBOL(hashbin_remove);\n\n/*\n *  Function hashbin_remove_this (hashbin, entry)\n *\n *    Remove entry with the given name\n *\n * In some cases, the user of hashbin can't guarantee the unicity\n * of either the hashv or name.\n * In those cases, using the above function is guaranteed to cause troubles,\n * so we use this one instead...\n * And by the way, it's also faster, because we skip the search phase ;-)\n */\nvoid* hashbin_remove_this( hashbin_t* hashbin, irda_queue_t* entry)\n{\n\tunsigned long flags = 0;\n\tint\tbin;\n\tlong\thashv;\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\tIRDA_ASSERT( entry != NULL, return NULL;);\n\n\t/* Synchronize */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\t/* Check if valid and not already removed... */\n\tif((entry->q_next == NULL) || (entry->q_prev == NULL)) {\n\t\tentry = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Locate hashbin\n\t */\n\thashv = entry->q_hash;\n\tbin = GET_HASHBIN( hashv );\n\n\t/*\n\t * Dequeue the entry...\n\t */\n\tdequeue_general( (irda_queue_t**) &hashbin->hb_queue[ bin ],\n\t\t\t entry);\n\thashbin->hb_size--;\n\tentry->q_next = NULL;\n\tentry->q_prev = NULL;\n\n\t/*\n\t *  Check if this item is the currently selected item, and in\n\t *  that case we must reset hb_current\n\t */\n\tif ( entry == hashbin->hb_current)\n\t\thashbin->hb_current = NULL;\nout:\n\t/* Release lock */\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t} /* Default is no-lock  */\n\n\treturn entry;\n}\nEXPORT_SYMBOL(hashbin_remove_this);\n\n/*********************** HASHBIN ENUMERATION ***********************/\n\n/*\n * Function hashbin_common_find (hashbin, hashv, name)\n *\n *    Find item with the given hashv or name\n *\n */\nvoid* hashbin_find( hashbin_t* hashbin, long hashv, const char* name )\n{\n\tint bin;\n\tirda_queue_t* entry;\n\n\tpr_debug(\"hashbin_find()\\n\");\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\n\t/*\n\t * Locate hashbin\n\t */\n\tif ( name )\n\t\thashv = hash( name );\n\tbin = GET_HASHBIN( hashv );\n\n\t/*\n\t * Search for entry\n\t */\n\tentry = hashbin->hb_queue[ bin];\n\tif ( entry ) {\n\t\tdo {\n\t\t\t/*\n\t\t\t * Check for key\n\t\t\t */\n\t\t\tif ( entry->q_hash == hashv ) {\n\t\t\t\t/*\n\t\t\t\t * Name compare too?\n\t\t\t\t */\n\t\t\t\tif ( name ) {\n\t\t\t\t\tif ( strcmp( entry->q_name, name ) == 0 ) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry = entry->q_next;\n\t\t} while ( entry != hashbin->hb_queue[ bin ] );\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(hashbin_find);\n\n/*\n * Function hashbin_lock_find (hashbin, hashv, name)\n *\n *    Find item with the given hashv or name\n *\n * Same, but with spinlock protection...\n * I call it safe, but it's only safe with respect to the hashbin, not its\n * content. - Jean II\n */\nvoid* hashbin_lock_find( hashbin_t* hashbin, long hashv, const char* name )\n{\n\tunsigned long flags = 0;\n\tirda_queue_t* entry;\n\n\t/* Synchronize */\n\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\n\t/*\n\t * Search for entry\n\t */\n\tentry = hashbin_find(hashbin, hashv, name);\n\n\t/* Release lock */\n\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\n\treturn entry;\n}\nEXPORT_SYMBOL(hashbin_lock_find);\n\n/*\n * Function hashbin_find (hashbin, hashv, name, pnext)\n *\n *    Find an item with the given hashv or name, and its successor\n *\n * This function allow to do concurrent enumerations without the\n * need to lock over the whole session, because the caller keep the\n * context of the search. On the other hand, it might fail and return\n * NULL if the entry is removed. - Jean II\n */\nvoid* hashbin_find_next( hashbin_t* hashbin, long hashv, const char* name,\n\t\t\t void ** pnext)\n{\n\tunsigned long flags = 0;\n\tirda_queue_t* entry;\n\n\t/* Synchronize */\n\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\n\t/*\n\t * Search for current entry\n\t * This allow to check if the current item is still in the\n\t * hashbin or has been removed.\n\t */\n\tentry = hashbin_find(hashbin, hashv, name);\n\n\t/*\n\t * Trick hashbin_get_next() to return what we want\n\t */\n\tif(entry) {\n\t\thashbin->hb_current = entry;\n\t\t*pnext = hashbin_get_next( hashbin );\n\t} else\n\t\t*pnext = NULL;\n\n\t/* Release lock */\n\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\n\treturn entry;\n}\n\n/*\n * Function hashbin_get_first (hashbin)\n *\n *    Get a pointer to first element in hashbin, this function must be\n *    called before any calls to hashbin_get_next()!\n *\n */\nirda_queue_t *hashbin_get_first( hashbin_t* hashbin)\n{\n\tirda_queue_t *entry;\n\tint i;\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\n\tif ( hashbin == NULL)\n\t\treturn NULL;\n\n\tfor ( i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tentry = hashbin->hb_queue[ i];\n\t\tif ( entry) {\n\t\t\thashbin->hb_current = entry;\n\t\t\treturn entry;\n\t\t}\n\t}\n\t/*\n\t *  Did not find any item in hashbin\n\t */\n\treturn NULL;\n}\nEXPORT_SYMBOL(hashbin_get_first);\n\n/*\n * Function hashbin_get_next (hashbin)\n *\n *    Get next item in hashbin. A series of hashbin_get_next() calls must\n *    be started by a call to hashbin_get_first(). The function returns\n *    NULL when all items have been traversed\n *\n * The context of the search is stored within the hashbin, so you must\n * protect yourself from concurrent enumerations. - Jean II\n */\nirda_queue_t *hashbin_get_next( hashbin_t *hashbin)\n{\n\tirda_queue_t* entry;\n\tint bin;\n\tint i;\n\n\tIRDA_ASSERT( hashbin != NULL, return NULL;);\n\tIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\n\n\tif ( hashbin->hb_current == NULL) {\n\t\tIRDA_ASSERT( hashbin->hb_current != NULL, return NULL;);\n\t\treturn NULL;\n\t}\n\tentry = hashbin->hb_current->q_next;\n\tbin = GET_HASHBIN( entry->q_hash);\n\n\t/*\n\t *  Make sure that we are not back at the beginning of the queue\n\t *  again\n\t */\n\tif ( entry != hashbin->hb_queue[ bin ]) {\n\t\thashbin->hb_current = entry;\n\n\t\treturn entry;\n\t}\n\n\t/*\n\t *  Check that this is not the last queue in hashbin\n\t */\n\tif ( bin >= HASHBIN_SIZE)\n\t\treturn NULL;\n\n\t/*\n\t *  Move to next queue in hashbin\n\t */\n\tbin++;\n\tfor ( i = bin; i < HASHBIN_SIZE; i++ ) {\n\t\tentry = hashbin->hb_queue[ i];\n\t\tif ( entry) {\n\t\t\thashbin->hb_current = entry;\n\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(hashbin_get_next);\n"], "filenames": ["net/irda/irqueue.c"], "buggy_code_start_loc": [386], "buggy_code_end_loc": [429], "fixing_code_start_loc": [385], "fixing_code_end_loc": [426], "type": "NVD-CWE-noinfo", "message": "The hashbin_delete function in net/irda/irqueue.c in the Linux kernel before 4.9.13 improperly manages lock dropping, which allows local users to cause a denial of service (deadlock) via crafted operations on IrDA devices.", "other": {"cve": {"id": "CVE-2017-6348", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-01T20:59:00.613", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The hashbin_delete function in net/irda/irqueue.c in the Linux kernel before 4.9.13 improperly manages lock dropping, which allows local users to cause a denial of service (deadlock) via crafted operations on IrDA devices."}, {"lang": "es", "value": "La funci\u00f3n hashben_delete en net/irda/irqueue.c en el kernel de Linux en versiones anteriores a 4.9.13 administra incorrectamente el soltado del bloqueo, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (punto muerto) a trav\u00e9s de operaciones manipuladas en los dispositivos IrDA."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.9.12", "matchCriteriaId": "BDE2E7F2-434A-4283-B0EA-25ACBCF7C4BF"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=4c03b862b12f980456f9de92db6d508a4999b788", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.debian.org/security/2017/dsa-3804", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.13", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/28/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96483", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/4c03b862b12f980456f9de92db6d508a4999b788", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4c03b862b12f980456f9de92db6d508a4999b788"}}