{"buggy_code": ["/*\n * Copyright (C) 2019 Freie Universit\u00e4t Berlin\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @{\n *\n * @file\n * @author  Martine Lenders <m.lenders@fu-berlin.de>\n */\n\n#include <stddef.h>\n\n#include \"irq.h\"\n#include \"kernel_defines.h\"\n#ifdef MODULE_GNRC_IPV6_NIB\n#include \"net/ipv6/addr.h\"\n#endif\n#ifdef MODULE_GNRC_IPV6\n#include \"net/ipv6/hdr.h\"\n#endif\n#include \"net/gnrc/neterr.h\"\n#include \"net/gnrc/netif/internal.h\"\n#include \"net/gnrc/netif/pktq.h\"\n#include \"net/gnrc/pkt.h\"\n#include \"net/gnrc/sixlowpan.h\"\n#include \"net/gnrc/sixlowpan/config.h\"\n#include \"net/gnrc/sixlowpan/frag/fb.h\"\n#include \"net/gnrc/sixlowpan/frag/rb.h\"\n#include \"net/gnrc/sixlowpan/frag/vrb.h\"\n#include \"net/gnrc/tx_sync.h\"\n#include \"net/sixlowpan/sfr.h\"\n#include \"thread.h\"\n#include \"unaligned.h\"\n#include \"xtimer.h\"\n\n#include \"net/gnrc/sixlowpan/frag/sfr.h\"\n#include \"net/gnrc/sixlowpan/frag/sfr/congure.h\"\n\n#define ENABLE_DEBUG    0\n#include \"debug.h\"\n\n#define FRAG_DESCS_POOL_SIZE    (CONFIG_GNRC_SIXLOWPAN_FRAG_FB_SIZE * \\\n                                 CONFIG_GNRC_SIXLOWPAN_SFR_MAX_WIN_SIZE)\n#define FRAME_QUEUE_POOL_SIZE   (FRAG_DESCS_POOL_SIZE + \\\n                                 CONFIG_GNRC_SIXLOWPAN_FRAG_VRB_SIZE)\n\ntypedef struct {\n    congure_snd_msg_t super;    /**< CongURE message parent */\n    /**\n     * @brief   Acknowledgment request flag, sequence number, and fragment size\n     */\n    uint16_t ar_seq_fs;\n    uint16_t offset;            /**< offset of the fragment */\n} _frag_desc_t;\n\ntypedef struct {\n    clist_node_t super;     /**< list parent instance */\n    gnrc_pktsnip_t *frame;  /**< frame in the queue */\n    uint8_t datagram_tag;   /**< tag for identification */\n    uint8_t page;           /**< parsing page context for the frame */\n} _frame_queue_t;\n\ntypedef struct {\n    enum {\n        _UNDEF = 0,\n        _RB,\n        _VRB,\n    } type;\n    union {\n        gnrc_sixlowpan_frag_rb_base_t *base;\n        gnrc_sixlowpan_frag_rb_t *rb;\n        gnrc_sixlowpan_frag_vrb_t *vrb;\n    } entry;\n} _generic_rb_entry_t;\n\n#ifdef MODULE_GNRC_IPV6_NIB\nstatic char addr_str[IPV6_ADDR_MAX_STR_LEN];\n#else   /* MODULE_GNRC_IPV6_NIB */\nstatic char addr_str[GNRC_NETIF_HDR_L2ADDR_PRINT_LEN];\n#endif  /* MODULE_GNRC_IPV6_NIB */\n\nstatic evtimer_msg_t _arq_timer;\nstatic xtimer_t _if_gap_timer = { 0 };\nstatic msg_t _if_gap_msg = { .type = GNRC_SIXLOWPAN_FRAG_SFR_INTER_FRAG_GAP_MSG };\nstatic uint32_t _last_frame_sent = 0U;\n\nstatic _frag_desc_t _frag_descs_pool[FRAG_DESCS_POOL_SIZE];\nstatic _frame_queue_t _frame_queue_pool[FRAME_QUEUE_POOL_SIZE];\n\nstatic clist_node_t _frag_descs_free;\nstatic clist_node_t _frame_queue_free;\nstatic clist_node_t _frame_queue;\n\nstatic const gnrc_sixlowpan_frag_sfr_bitmap_t _full_bitmap = { .u32 = UINT32_MAX };\nstatic const gnrc_sixlowpan_frag_sfr_bitmap_t _null_bitmap = { .u32 = 0U };\n\nstatic gnrc_sixlowpan_frag_sfr_stats_t _stats;\n\n/**\n * @brief   Converts a @ref sys_bitmap based bitmap to a\n *          gnrc_sixlowpan_frag_sfr_bitmap_t\n *\n * @param[in] bitmap A @ref sys_bitmap\n *\n * @return  A gnrc_sixlowpan_frag_sfr_bitmap_t.\n */\nstatic inline gnrc_sixlowpan_frag_sfr_bitmap_t *_get_bitmap(gnrc_sixlowpan_frag_rb_t *frag_rb);\n\n/**\n * @brief   Checks if fragment represented by a fragment descriptor requested an\n *          ACK\n */\nstatic inline bool _frag_ack_req(_frag_desc_t *frag);\n/**\n * @brief   Returns sequence number for fragment represented by fragment\n *          descriptor\n */\nstatic inline uint8_t _frag_seq(_frag_desc_t *frag);\n\n/**\n * @brief   Returns fragment size for fragment represented by fragment\n *          descriptor\n */\nstatic inline uint16_t _frag_size(_frag_desc_t *frag);\n\n/**\n * @brief   Cleans up a fragmentation buffer entry and all state related to its\n *          datagram.\n *\n * @param[in] fbuf  A fragmentation buffer entry\n * @param[in] error An errno to provide to an upper layer as the reason for why\n *                  gnrc_sixlowpan_frag_fb_t::pkt of @p fbuf was released.\n */\nstatic void _clean_up_fbuf(gnrc_sixlowpan_frag_fb_t *fbuf, int error);\n\n/**\n * @brief   Send first fragment.\n *\n * @param[in] netif         Network interface to send fragment over\n * @param[in] fbuf          Fragmentation buffer for the datagram to fragment\n * @param[in] page          Current 6Lo dispatch parsing page.\n * @param[in,out] tx_sync   Packet snip used to synchronize with transmission, if gnrc_tx_sync is\n *                          used\n *\n * @return  Size of the fragment\n */\nstatic uint16_t _send_1st_fragment(gnrc_netif_t *netif,\n                                   gnrc_sixlowpan_frag_fb_t *fbuf,\n                                   unsigned page,\n                                   gnrc_pktsnip_t **tx_sync);\n\n/**\n * @brief   Send subsequent fragment.\n *\n * @param[in] netif         Network interface to send fragment over\n * @param[in] fbuf          Fragmentation buffer for the datagram to fragment\n * @param[in] page          Current 6Lo dispatch parsing page.\n * @param[in,out] tx_sync   Packet snip used to synchronize with transmission, if gnrc_tx_sync is\n *                          used\n *\n * @return  Size of the fragment\n */\nstatic uint16_t _send_nth_fragment(gnrc_netif_t *netif,\n                                   gnrc_sixlowpan_frag_fb_t *fbuf,\n                                   unsigned page,\n                                   gnrc_pktsnip_t **tx_sync);\n\n/**\n * @brief   Send a abort pseudo fragment for datagram identified by @p tag\n *\n * @param[in] pkt       Datagram that is to be aborted.\n * @param[in] fbuf      Fragmentation buffer for @p pkt.\n * @param[in] req_ack   Request ACK for pseudo fragment from receive\n * @param[in] page      Current 6Lo dispatch parsing page.\n *\n * @return  true, if abort pseudo fragment was sent.\n * @return  false, if abort pseudo fragment was unable to be sent.\n */\nstatic bool _send_abort_frag(gnrc_pktsnip_t *pkt,\n                             gnrc_sixlowpan_frag_fb_t *fbuf,\n                             bool req_ack, unsigned page);\n\n/**\n * @brief   Adapts currently sent number of fragments to current window size\n *\n * Balances `fbuf->sfr.window` with `fbuf->sfr.congure->cwnd`\n *\n * @param[in] fbuf          Fragmentation buffer to adapt window for\n */\nstatic void _shrink_window(gnrc_sixlowpan_frag_fb_t *fbuf);\n\n/**\n * @brief   Re-send a fragment\n *\n * @param[in] node          The fragment descriptor for the fragment to be\n *                          resend\n * @param[in] fbuf_ptr      Fragmentation buffer for the datagram to fragment\n *\n * Used as a `clist_foreach()` iterator function\n *\n * return true  when fragment was resent\n * return false on error\n */\nstatic int _resend_frag(clist_node_t *node, void *fbuf_ptr);\n\n/**\n * @brief   Retry to send the complete datagram\n *\n * @param[in] fbuf  Fragmentation buffer for the datagram\n */\nstatic void _retry_datagram(gnrc_sixlowpan_frag_fb_t *fbuf);\n\n/**\n * @brief   Cleans up state for the causing RFRAG and optionally also sends an\n *          abort ACK (NULL-bitmap ACK).\n *\n * @param[in] pkt       The packet causing the abort. Will be released\n *                      by this function. gnrc_pktsnip_t::data of @p pkt is\n *                      expected to point to an RFRAG packet.\n * @param[in] entry     (Virtual) reassembly buffer entry to abort.\n * @param[in] netif_hdr NETIF header of @p pkt.\n * @param[in] send_ack  Send an abort ACK.\n */\nstatic void _abort_rb(gnrc_pktsnip_t *pkt, _generic_rb_entry_t *entry,\n                      gnrc_netif_hdr_t *netif_hdr, bool send_ack);\n\n/**\n * @brief   Sends an RFRAG-ACK\n *\n * @param[in] netif     Network interface to send ACK over\n * @param[in] dst       Destination address of ACK.\n * @param[in] dst_len   Length of @p dst.\n * @param[in] rfrag     The RFRAG to ACK\n * @param[in] bitmap    The bitmap for the ACK.\n */\nstatic void _send_ack(gnrc_netif_t *netif, const uint8_t *dst, uint8_t dst_len,\n                      const sixlowpan_sfr_t *rfrag, const uint8_t *bitmap);\n\n/**\n * @brief   Schedule next frame (RFRAG or RFRAG-ACK) with\n *          @ref GNRC_SIXLOWPAN_FRAG_SFR_INTER_FRAG_GAP_MSG\n *\n * @param[in] fbuf      A fragmentation buffer holding the state of the datagram\n *                      and recoverable fragments.\n */\nstatic void _sched_next_frame(gnrc_sixlowpan_frag_fb_t *fbuf);\n\n/**\n * @brief   Schedule ARQ timeout\n *\n * @param[in] fbuf      A fragmentation buffer holding the state of the datagram\n *                      and recoverable fragments.\n * @param[in] offset    Offset for the ARQ timeout in milliseconds.\n */\nstatic void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset);\n\n/**\n * @brief   Schedule ARQ timeout for an abort fragment pseudo fragment\n *\n * @param[in,out] fbuf  A fragmentation buffer. All state information will be\n *                      cleared when called, except for identifying the ACK.\n */\nstatic void _sched_abort_timeout(gnrc_sixlowpan_frag_fb_t *fbuf);\n\n/**\n * @brief   Handle a received RFRAG packet\n *\n * @param[in] netif_hdr NETIF header of @p pkt\n * @param[in] pkt       An RFRAG packet\n * @param[in] page      Current 6Lo dispatch parsing page.\n */\nstatic void _handle_rfrag(gnrc_netif_hdr_t *netif_hdr,\n                          gnrc_pktsnip_t *pkt, unsigned page);\n\n/**\n * @brief   Handle a received RFRAG-ACK\n *\n * @param[in] netif_hdr NETIF header of @p pkt\n * @param[in] pkt       An RFRAG-ACK\n * @param[in] page      Current 6Lo dispatch parsing page.\n */\nstatic void _handle_ack(gnrc_netif_hdr_t *netif_hdr,\n                        gnrc_pktsnip_t *pkt, unsigned page);\n\n/**\n * @brief   Forward a RFRAG\n *\n * @pre `entry->type == _VRB`\n *\n * @param[in] pkt       The RFRAG to forward (without NETIF header)\n * @param[in] entry     The VRB entry to determine the route\n * @param[in] offset    Offset (from the incoming RFRAG's field) of the RFRAG.\n *                      for offset > 0 this will be adapted for the offset\n *                      difference from the first fragment due to recompression\n * @param[in] page      Current 6Lo dispatch parsing page.\n *\n * @return  0 on success,\n * @return  -ENOMEM, when packet buffer is too full to prepare packet for\n *          forwarding. @p pkt is released in that case.\n */\nstatic int _forward_rfrag(gnrc_pktsnip_t *pkt, _generic_rb_entry_t *entry,\n                          uint16_t offset, unsigned page);\n\n/* ====== PUBLIC FUNCTION DEFINITIONS ====== */\nvoid gnrc_sixlowpan_frag_sfr_init(void)\n{\n    /* initialize _arq_timer if not yet done */\n    if (_arq_timer.callback == NULL) {\n        evtimer_init_msg(&_arq_timer);\n    }\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (unsigned i = 0; i < FRAME_QUEUE_POOL_SIZE; i++) {\n            clist_rpush(&_frame_queue_free, &_frame_queue_pool[i].super);\n        }\n    }\n    for (unsigned i = 0; i < FRAG_DESCS_POOL_SIZE; i++) {\n        clist_rpush(&_frag_descs_free, &_frag_descs_pool[i].super.super);\n    }\n}\n\nvoid gnrc_sixlowpan_frag_sfr_send(gnrc_pktsnip_t *pkt, void *ctx,\n                                  unsigned page)\n{\n    gnrc_sixlowpan_frag_fb_t *fbuf = ctx;\n    gnrc_netif_t *netif;\n    int error_no = GNRC_NETERR_SUCCESS;\n    gnrc_pktsnip_t *tx_sync = NULL;\n    uint16_t res;\n\n    assert((fbuf != NULL) && ((fbuf->pkt == pkt) || (pkt == NULL)));\n    DEBUG(\"6lo sfr: (re-)sending fragmented datagram %u\\n\", fbuf->tag);\n    pkt = fbuf->pkt;\n    assert(pkt->type == GNRC_NETTYPE_NETIF);\n    netif = gnrc_netif_hdr_get_netif(pkt->data);\n    assert(netif != NULL);\n\n    if (IS_USED(MODULE_GNRC_TX_SYNC)) {\n        tx_sync = gnrc_tx_sync_split(pkt);\n    }\n\n    if (fbuf->offset == 0) {\n        DEBUG(\"6lo sfr: sending first fragment\\n\");\n        gnrc_sixlowpan_frag_sfr_congure_snd_setup(fbuf);\n        res = _send_1st_fragment(netif, fbuf, page, &tx_sync);\n        if (res == 0) {\n            DEBUG(\"6lo sfr: error sending first fragment\\n\");\n            /* _send_1st_fragment only returns 0 if there is a memory problem */\n            error_no = ENOMEM;\n            goto error;\n        }\n    }\n    else if (!gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf)) {\n        DEBUG(\"6lo sfr: frags_sent not within congestion window: \"\n              \"don't send more\\n\");\n        return;\n    }\n    else if (fbuf->offset < fbuf->datagram_size) {\n        DEBUG(\"6lo sfr: sending subsequent fragment\\n\");\n#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)\n        assert(fbuf->sfr.congure);\n        assert(fbuf->sfr.congure->driver);\n#endif\n        res = _send_nth_fragment(netif, fbuf, page, &tx_sync);\n        if (res == 0) {\n            DEBUG(\"6lo sfr: error sending subsequent fragment (offset = %u)\\n\",\n                  fbuf->offset);\n            /* _send_nth_fragment only returns 0 if there is a memory problem */\n            error_no = ENOMEM;\n            goto error;\n        }\n    }\n    else {\n        /* offset is greater or equal to datagram size\n         * => we are done sending fragments (not an error, but we can release\n         * the fragmentation buffer now) */\n        goto error;\n    }\n    gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf);\n    fbuf->offset += res;\n\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf) &&\n        (fbuf->offset < fbuf->datagram_size) &&\n        !gnrc_sixlowpan_frag_fb_send(fbuf)) {\n        /* the queue of the 6LoWPAN thread is full */\n        error_no = ENOMEM;\n        /* go back offset to not send abort on first fragment */\n        fbuf->offset -= res;\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_discard(fbuf);\n        goto error;\n    }\n    /* check if last fragment sent requested an ACK */\n    _frag_desc_t *frag_desc = (_frag_desc_t *)clist_rpeek(&fbuf->sfr.window);\n    DEBUG(\"6lo sfr: last sent fragment (tag: %u, X: %i, seq: %u, \"\n          \"frag_size: %u, offset: %u)\\n\",\n          (uint8_t)fbuf->tag, _frag_ack_req(frag_desc),\n          _frag_seq(frag_desc), _frag_size(frag_desc),\n          frag_desc->offset);\n    if (_frag_ack_req(frag_desc)) {\n        _sched_arq_timeout(fbuf, fbuf->sfr.arq_timeout);\n    }\n\n    if (IS_USED(MODULE_GNRC_TX_SYNC) && tx_sync) {\n        /* re-attach tx_sync to allow releasing it at end\n         * of transmission, or transmission failure */\n        gnrc_pkt_append(pkt, tx_sync);\n    }\n    thread_yield();\n    return;\nerror:\n    /* don't send abort for first fragment, the network does not know about\n     * the datagram */\n    if ((fbuf->offset > 0) &&\n        _send_abort_frag(fbuf->pkt, fbuf, true, 0)) {\n        /* wait for ACK before fbuf is deleted */\n        _sched_abort_timeout(fbuf);\n    }\n    else {\n        _clean_up_fbuf(fbuf, error_no);\n    }\n    if (IS_USED(MODULE_GNRC_TX_SYNC) && tx_sync) {\n        gnrc_pktbuf_release(tx_sync);\n    }\n}\n\nvoid gnrc_sixlowpan_frag_sfr_recv(gnrc_pktsnip_t *pkt, void *ctx,\n                                  unsigned page)\n{\n    sixlowpan_sfr_t *hdr;\n    gnrc_netif_hdr_t *netif_hdr;\n\n    (void)ctx;\n    DEBUG(\"6lo sfr: received selective fragment forwarding message\\n\");\n    assert(pkt != NULL);\n    hdr = pkt->data;\n    assert(pkt->next != NULL);\n    netif_hdr = pkt->next->data;\n    assert(netif_hdr != NULL);\n    if (page != 0) {\n        DEBUG(\"6lo sfr: Invalid page %u\\n\", page);\n        gnrc_pktbuf_release(pkt);\n    }\n    else if (sixlowpan_sfr_rfrag_is(hdr)) {\n        _handle_rfrag(netif_hdr, pkt, page);\n    }\n    else if (sixlowpan_sfr_ack_is(hdr)) {\n        _handle_ack(netif_hdr, pkt, page);\n    }\n    else {\n        DEBUG(\"6lo sfr: Unknown dispatch: %02x\\n\",\n              hdr->disp_ecn & SIXLOWPAN_SFR_DISP_MASK);\n        gnrc_pktbuf_release(pkt);\n    }\n}\n\nint gnrc_sixlowpan_frag_sfr_forward(gnrc_pktsnip_t *pkt,\n                                    sixlowpan_sfr_rfrag_t *rfrag,\n                                    gnrc_sixlowpan_frag_vrb_t *vrbe,\n                                    unsigned page)\n{\n    _generic_rb_entry_t entry = { .type = _VRB, .entry = { .vrb = vrbe } };\n    gnrc_pktsnip_t *hdrsnip = gnrc_pktbuf_add(pkt, rfrag, sizeof(*rfrag),\n                                              GNRC_NETTYPE_SIXLOWPAN);\n\n    /* free all intervals associated to the VRB entry, as we don't need them\n     * with SFR, so throw them out, to save this resource */\n    while (vrbe->super.ints) {\n        vrbe->super.ints->end = 0U;\n        vrbe->super.ints = vrbe->super.ints->next;\n    }\n    if (hdrsnip == NULL) {\n        DEBUG(\"6lo sfr: Unable to allocate new rfrag header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ENOMEM;\n    }\n    DEBUG(\"6lo sfr: adapting old fragment size (%u) for forwarding to %u\\n\",\n          sixlowpan_sfr_rfrag_get_frag_size(hdrsnip->data),\n          (unsigned)gnrc_pkt_len(pkt));\n    /* due to compression, packet length of the original fragment might have\n     * changed */\n    sixlowpan_sfr_rfrag_set_frag_size(hdrsnip->data, gnrc_pkt_len(pkt));\n    /* offset is adapted in `_forward_rfrag()` */\n    return _forward_rfrag(hdrsnip, &entry, sixlowpan_sfr_rfrag_get_offset(rfrag),\n                          page);\n}\n\nstatic int _report_non_ack_req_window_sent(clist_node_t *node, void *fbuf_ptr)\n{\n    _frag_desc_t *frag_desc = (_frag_desc_t *)node;\n    if (!_frag_ack_req(frag_desc)) {\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf_ptr);\n    }\n    return 0;\n}\n\nvoid gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    uint32_t now = xtimer_now_usec() / US_PER_MS;\n    _frag_desc_t *frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;\n    uint32_t next_arq_offset = fbuf->sfr.arq_timeout;\n    bool reschedule_arq_timeout = false;\n    int error_no = ETIMEDOUT;   /* assume time out for fbuf->pkt */\n\n    DEBUG(\"6lo sfr: ARQ timeout for datagram %u\\n\", fbuf->tag);\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        /* mock-up to emulate time having passed beyond (1us) the ARQ timeout */\n        now -= (fbuf->sfr.arq_timeout * US_PER_MS) + 1;\n    }\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) && frag_desc) {\n        /* report timeout to CongURE state */\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(fbuf);\n        _shrink_window(fbuf);   /* potentially shrink window */\n        /* reassign frag_desc, in case window head changed */\n        frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;\n    }\n    /* copying clist_foreach because we can't work just in function context */\n    _frag_desc_t * const head = frag_desc;\n    if (frag_desc) {\n        do {\n            uint32_t diff;\n\n            frag_desc = (_frag_desc_t *)frag_desc->super.super.next;\n            diff = now - frag_desc->super.send_time;\n            if (diff < fbuf->sfr.arq_timeout) {\n                /* this fragment's last was last sent < fbuf->sfr.arq_timeout\n                 * ago */\n                uint32_t offset = fbuf->sfr.arq_timeout - diff;\n\n                DEBUG(\"6lo sfr: wait for fragment %u in next reschedule\\n\",\n                      _frag_seq(frag_desc));\n                if (offset < next_arq_offset) {\n                    /* wait for this fragments ACK next */\n                    next_arq_offset = offset;\n                    DEBUG(\"         (next ARQ timeout in %lu)\\n\",\n                          (long unsigned)next_arq_offset);\n                }\n                /* this fragment is still waiting for its ACK,\n                 * reschedule the next ACK timeout to the difference\n                 * of the ACK timeout and the time of its last send */\n                reschedule_arq_timeout = true;\n            }\n            else if (_frag_ack_req(frag_desc)) {\n                /* for this fragment we requested an ACK which was not received\n                 * yet. Try to resend it */\n                if ((frag_desc->super.resends++) < CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES) {\n                    /* we have retries left for this fragment */\n                    DEBUG(\"6lo sfr: %u retries left for fragment (tag: %u, \"\n                          \"X: %i, seq: %u, frag_size: %u, offset: %u)\\n\",\n                          CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES -\n                          (frag_desc->super.resends - 1), (uint8_t)fbuf->tag,\n                          _frag_ack_req(frag_desc), _frag_seq(frag_desc),\n                          _frag_size(frag_desc), frag_desc->offset);\n                    if (_resend_frag(&frag_desc->super.super, fbuf) != 0) {\n                        /* _resend_frag failed due to a memory resource\n                         * problem */\n                        error_no = ENOMEM;\n                        goto error;\n                    }\n                    else {\n                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {\n                            /* fragment was resent successfully, report this to CongURE state\n                             * object */\n                            gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf);\n                        }\n                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                            /* fragment was resent successfully, note this done\n                             * in the statistics */\n                            _stats.fragment_resends.by_timeout++;\n                        }\n                    }\n                    /* fragment was resent successfully, schedule next ACK\n                     * timeout */\n                    reschedule_arq_timeout = true;\n                }\n                else {\n                    /* out of retries */\n                    DEBUG(\"6lo sfr: no retries left for fragment \"\n                          \"(tag: %u, X: %i, seq: %u, frag_size: %u, \"\n                          \"offset: %u)\\n\",\n                          (uint8_t)fbuf->tag, _frag_ack_req(frag_desc),\n                          _frag_seq(frag_desc), _frag_size(frag_desc),\n                          frag_desc->offset);\n                    /* we are out of retries on the fragment level, but we\n                     * might be able to retry the datagram if retries for the\n                     * datagram are configured. */\n                    _retry_datagram(fbuf);\n                    return;\n                }\n            }\n            else {\n                /* Do not resend fragments that were not explicitly asking for\n                 * an ACK from the reassembling endpoint on ACK timeout.\n                 * If this is true for all fragments remaining in the fragment\n                 * buffer, the datagram is to be considered timed out, so\n                 * error_no should remain ETIMEDOUT */\n                DEBUG(\"6lo sfr: nothing to do for fragment %u\\n\",\n                      _frag_seq(frag_desc));\n            }\n        } while (frag_desc != head);\n        /* report all non-ack_req fragments in window also as sent, since even\n         * the lost fragments are still in flight (even though they were\n         * previously marked as timed out) */\n        clist_foreach(&fbuf->sfr.window, _report_non_ack_req_window_sent, fbuf);\n    }\n    else {\n        /* No fragments to resend, we can assume the packet was delivered\n         * successfully */\n        error_no = GNRC_NETERR_SUCCESS;\n    }\n    assert(fbuf->sfr.frags_sent == clist_count(&fbuf->sfr.window));\n    if (reschedule_arq_timeout) {\n        _sched_arq_timeout(fbuf, next_arq_offset);\n        return;\n    }\nerror:\n    /* don't check return value, as we don't want to wait for an ACK again ;-) */\n    _send_abort_frag(fbuf->pkt, fbuf, false, 0);\n    _clean_up_fbuf(fbuf, error_no);\n}\n\nvoid gnrc_sixlowpan_frag_sfr_inter_frame_gap(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        _frame_queue_t *node = (_frame_queue_t *)clist_lpop(&_frame_queue);\n\n        if (node != NULL) {\n            _last_frame_sent = xtimer_now_usec();\n            gnrc_sixlowpan_dispatch_send(node->frame, NULL, node->page);\n            /* unset packet just to be safe */\n            node->frame = NULL;\n            clist_rpush(&_frame_queue_free, &node->super);\n        }\n        if (clist_lpeek(&_frame_queue) != NULL) {\n            _sched_next_frame(fbuf);\n        }\n    }\n}\n\nvoid gnrc_sixlowpan_frag_sfr_stats_get(gnrc_sixlowpan_frag_sfr_stats_t *stats)\n{\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n        *stats = _stats;\n    }\n}\n\n/* ====== INTERNAL FUNCTION DEFINITIONS ====== */\nstatic inline uint16_t _min(uint16_t a, size_t b)\n{\n    return (a < b) ? a : (uint16_t)b;\n}\n\nstatic inline kernel_pid_t _getpid(void)\n{\n    /* in production, only the 6LoWPAN thread is supposed to call the API\n     * functions, so just get the current thread's PID for sending messages.\n     * When testing, those functions might however be called by the testing\n     * thread (usually the main thread), so indirect over the 6LoWPAN thread in\n     * that case */\n    return IS_ACTIVE(TEST_SUITES) ? gnrc_sixlowpan_get_pid() : thread_getpid();\n}\n\n/*\n * @brief   Returns the datagram in @p fbuf to its original state\n *\n * This function can be both used to clean up the fragmentation buffer on\n * failure without releasing @p fbuf's gnrc_sixlowpan_frag_fb_t::pkt and to\n * reset a datagram for a datagram retry.\n *\n * @param[in]   fbuf    The fragmentation buffer entry to clean up\n */\nstatic void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    clist_node_t new_queue = { .next = NULL };\n\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    /* remove potentially scheduled timers for this datagram */\n    evtimer_del((evtimer_t *)(&_arq_timer),\n                &fbuf->sfr.arq_timeout_event.event);\n    fbuf->sfr.arq_timeout_event.event.next = NULL;\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (clist_node_t *node = clist_lpop(&_frame_queue);\n             node != NULL; node = clist_lpop(&_frame_queue)) {\n            _frame_queue_t *entry = (_frame_queue_t *)node;\n            /* remove frames of this datagram from frame queue */\n            if (entry->datagram_tag == fbuf->tag) {\n                gnrc_pktbuf_release(entry->frame);\n                /* unset packet just to be safe */\n                entry->frame = NULL;\n                clist_rpush(&_frag_descs_free, node);\n            }\n            else {\n                clist_rpush(&new_queue, node);\n            }\n        }\n        /* reset frame queue with remaining frames */\n        _frame_queue = new_queue;\n    }\n    fbuf->offset = 0U;\n    fbuf->sfr.cur_seq = 0U;\n    fbuf->sfr.frags_sent = 0U;\n    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n        clist_rpush(&_frag_descs_free, node);\n    }\n}\n\nstatic gnrc_pktsnip_t *_build_rfrag(uint8_t tag, bool ack_req, uint16_t size,\n                                    uint8_t seq)\n{\n    sixlowpan_sfr_rfrag_t *hdr;\n    gnrc_pktsnip_t *frag = gnrc_pktbuf_add(NULL, NULL,\n                                           sizeof(sixlowpan_sfr_rfrag_t) +\n                                           size, GNRC_NETTYPE_SIXLOWPAN);\n\n    if (frag == NULL) {\n        return NULL;\n    }\n    sixlowpan_sfr_rfrag_set_disp(frag->data);\n\n    hdr = frag->data;\n    hdr->base.tag = tag;\n    if (ack_req) {\n        sixlowpan_sfr_rfrag_set_ack_req(hdr);\n    }\n    else {\n        sixlowpan_sfr_rfrag_clear_ack_req(hdr);\n    }\n    sixlowpan_sfr_rfrag_set_frag_size(hdr, size);\n    sixlowpan_sfr_rfrag_set_seq(hdr, seq);\n    /* set offset / datagram_size in callers */\n    return frag;\n}\n\nstatic gnrc_pktsnip_t *_build_frag_pkt(gnrc_netif_hdr_t *old_netif_hdr,\n                                       uint8_t tag, bool ack_req, uint16_t size,\n                                       uint8_t seq)\n{\n    gnrc_netif_hdr_t *new_netif_hdr;\n    gnrc_pktsnip_t *netif, *res;\n\n    DEBUG(\"6lo sfr: building fragment (tag: %u, X: %i, seq: %u, frag_size: %u)\\n\",\n           tag, ack_req, seq, size);\n    netif = gnrc_netif_hdr_build(gnrc_netif_hdr_get_src_addr(old_netif_hdr),\n                                 old_netif_hdr->src_l2addr_len,\n                                 gnrc_netif_hdr_get_dst_addr(old_netif_hdr),\n                                 old_netif_hdr->dst_l2addr_len);\n    if (netif == NULL) {\n        return NULL;\n    }\n\n    new_netif_hdr = netif->data;\n    *new_netif_hdr = *old_netif_hdr;\n    res = _build_rfrag(tag, ack_req, size, seq);\n    if (res == NULL) {\n        gnrc_pktbuf_release(netif);\n        return NULL;\n    }\n    return gnrc_pkt_prepend(res, netif);\n}\n\nstatic gnrc_pktsnip_t *_build_frag_from_fbuf(gnrc_pktsnip_t *pkt,\n                                             gnrc_sixlowpan_frag_fb_t *fbuf,\n                                             uint16_t frag_size)\n{\n    return _build_frag_pkt(pkt->data, (uint8_t)fbuf->tag,\n                           ((frag_size + fbuf->offset) >= fbuf->datagram_size) ||\n                           /* we only can send the next fragment we build here,\n                            * so request ACK for it */\n                           !gnrc_sixlowpan_frag_sfr_congure_snd_next_in_cwnd(fbuf),\n                           frag_size, fbuf->sfr.cur_seq);\n}\n\nstatic uint16_t _copy_pkt_to_frag(uint8_t *data, const gnrc_pktsnip_t *pkt,\n                                  uint16_t frag_size, uint16_t init_offset)\n{\n    uint16_t offset = init_offset;\n\n    while ((pkt != NULL) && (offset < frag_size)) {\n        uint16_t len = _min(frag_size - offset, pkt->size);\n\n        memcpy(data + offset, pkt->data, len);\n\n        offset += len;\n        pkt = pkt->next;\n    }\n    return offset;\n}\n\nstatic uint16_t _find_offset_and_copy_rest(uint8_t *data, gnrc_pktsnip_t **pkt,\n                                           uint16_t frag_size,\n                                           uint16_t offset)\n{\n    uint16_t offset_count = 0, cur_frag_size = 0;\n    while ((*pkt != NULL) && (offset_count != offset)) {     /* go to offset */\n        uint16_t pkt_size = (uint16_t)(*pkt)->size;\n        offset_count += pkt_size;\n\n        if (offset_count > offset) {                        /* we overshot */\n            /* => copy rest of partly send packet snip */\n            uint16_t pkt_offset = offset - (offset_count - pkt_size);\n            size_t clen = _min(frag_size, pkt_size - pkt_offset);\n\n            memcpy(data, ((uint8_t *)(*pkt)->data) + pkt_offset, clen);\n            cur_frag_size = clen;\n            *pkt = (*pkt)->next;\n            break;\n        }\n        *pkt = (*pkt)->next;\n    }\n    return cur_frag_size;\n}\n\nstatic void _check_for_ecn(gnrc_pktsnip_t *frame)\n{\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN) &&\n        (sixlowpan_sfr_rfrag_is(frame->next->data))) {\n        int queue_state = 0;\n        int queue_size = 0;\n\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN_IF_IN)) {\n            gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(frame->data);\n\n            assert(frame->type == GNRC_NETTYPE_NETIF);\n            assert(frame->next->type == GNRC_NETTYPE_SIXLOWPAN);\n            queue_state = msg_avail_thread(netif->pid);\n            queue_size = msg_queue_capacity(netif->pid);\n            assert(queue_size > 0);\n\n            if ((queue_state * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_IN_DEN) >\n                (queue_size * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_IN_NUM)) {\n                sixlowpan_sfr_set_ecn(frame->next->data);\n            }\n        }\n\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN_IF_OUT)) {\n            queue_state = gnrc_netif_pktq_usage();\n            queue_size = CONFIG_GNRC_NETIF_PKTQ_POOL_SIZE;\n\n            if ((queue_state * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_OUT_DEN) >\n                (queue_size * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_OUT_NUM)) {\n                sixlowpan_sfr_set_ecn(frame->next->data);\n            }\n        }\n\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN_FQUEUE)) {\n            queue_state = clist_count(&_frame_queue);\n            queue_size = FRAME_QUEUE_POOL_SIZE;\n\n            if ((queue_state * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_FQUEUE_DEN) >\n                (queue_size * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_FQUEUE_NUM)) {\n                sixlowpan_sfr_set_ecn(frame->next->data);\n            }\n        }\n    }\n}\n\nstatic bool _send_frame(gnrc_pktsnip_t *frame, gnrc_sixlowpan_frag_fb_t *fbuf,\n                        void *ctx, unsigned page)\n{\n    uint32_t now;\n    uint32_t if_gap = gnrc_sixlowpan_frag_sfr_congure_snd_inter_frame_gap(fbuf);\n\n    _check_for_ecn(frame);\n    now = xtimer_now_usec();\n    if ((if_gap == 0) || ((now - _last_frame_sent) > if_gap)) {\n        DEBUG(\"6lo sfr: dispatch frame to network interface\\n\");\n        _last_frame_sent = now;\n        gnrc_sixlowpan_dispatch_send(frame, ctx, page);\n        return true;\n    }\n    else {\n        _frame_queue_t *node = (_frame_queue_t *)clist_lpop(&_frame_queue_free);\n\n        if (node != NULL) {\n            sixlowpan_sfr_t *hdr = frame->next->data;\n\n            assert(sixlowpan_sfr_is(hdr));\n            node->frame = frame;\n            node->datagram_tag = hdr->tag;\n            node->page = page;\n            clist_rpush(&_frame_queue, &node->super);\n            _sched_next_frame(fbuf);\n        }\n        return (node != NULL);\n    }\n}\n\nstatic bool _send_fragment(gnrc_pktsnip_t *frag, gnrc_sixlowpan_frag_fb_t *fbuf,\n                           unsigned page, uint16_t offset)\n{\n    sixlowpan_sfr_rfrag_t *hdr = frag->next->data;\n    _frag_desc_t *frag_desc = (_frag_desc_t *)clist_lpop(&_frag_descs_free);\n    bool res;\n\n    if (frag_desc == NULL) {\n        DEBUG(\"6lo sfr: could not remember fragment to send\\n\");\n        gnrc_pktbuf_release(frag);\n        return false;\n    }\n    frag_desc->ar_seq_fs = byteorder_ntohs(hdr->ar_seq_fs);\n    frag_desc->offset = offset;\n    frag_desc->super.size = 1;\n    frag_desc->super.resends = 0;\n    clist_rpush(&fbuf->sfr.window, &frag_desc->super.super);\n    if ((res = _send_frame(frag, fbuf, NULL, page))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.fragments_sent.usual++;\n        }\n        frag_desc->super.send_time = _last_frame_sent / US_PER_MS;\n        fbuf->sfr.cur_seq++;\n        fbuf->sfr.frags_sent++;\n    }\n    return res;\n}\n\nstatic gnrc_pktsnip_t *_build_ack(gnrc_netif_t *netif,\n                                  const uint8_t *dst, uint8_t dst_len,\n                                  const sixlowpan_sfr_t *hdr,\n                                  const uint8_t *bitmap)\n{\n    gnrc_pktsnip_t *ack_snip, *ack_netif;\n    sixlowpan_sfr_ack_t *ack;\n\n    ack_netif = gnrc_netif_hdr_build(NULL, 0, dst, dst_len);\n    if (ack_netif == NULL) {\n        DEBUG(\"6lo sfr: can't allocate netif header for ACK for (%s, %02x).\\n\",\n              gnrc_netif_addr_to_str(dst, dst_len, addr_str), hdr->tag);\n        return NULL;\n    }\n    gnrc_netif_hdr_set_netif(ack_netif->data, netif);\n\n    ack_snip = gnrc_pktbuf_add(NULL, NULL, sizeof(sixlowpan_sfr_ack_t),\n                               GNRC_NETTYPE_SIXLOWPAN);\n\n    if (ack_snip == NULL) {\n        DEBUG(\"6lo sfr: can't allocate ACK for (%s, %02x).\\n\",\n              gnrc_netif_addr_to_str(dst, dst_len, addr_str), hdr->tag);\n        gnrc_pktbuf_release(ack_netif);\n        return NULL;\n    }\n    ack = ack_snip->data;\n    /* https://tools.ietf.org/html/rfc8931#section-6:\n     * The Datagram_Tag in the RFRAG_ACK is unique to the reassembling endpoint\n     * and is enough information for an intermediate hop to locate the VRB that\n     * contains the Datagram_Tag used by the previous hop and the Layer-2\n     * information associated with it (interface and Link-Layer address)..\n     * [...] The reassembling endpoint of a fragment with the 'E' (ECN) flag set\n     * MUST echo that information at most once by setting the 'E' (ECN) flag in\n     * the next RFRAG_ACK.\n     *\n     * => base except dispatch are the same as ack'd RFRAG.\n     */\n    ack->base = *hdr;\n    sixlowpan_sfr_ack_set_disp(&ack->base);\n    memcpy(ack->bitmap, bitmap, sizeof(ack->bitmap));\n    ack_netif->next = ack_snip;\n    return ack_netif;\n}\n\nstatic void _clean_up_rb_entry(_generic_rb_entry_t *entry)\n{\n    if (entry != NULL) {\n        switch (entry->type) {\n            case _RB:\n                gnrc_pktbuf_release(entry->entry.rb->pkt);\n                gnrc_sixlowpan_frag_rb_remove(entry->entry.rb);\n                break;\n            case _VRB:\n                gnrc_sixlowpan_frag_vrb_rm(entry->entry.vrb);\n                break;\n            default:\n                break;\n        }\n    }\n}\n\nstatic void _try_reassembly(gnrc_netif_hdr_t *netif_hdr,\n                            gnrc_pktsnip_t *rfrag, unsigned offset,\n                            _generic_rb_entry_t *entry,\n                            unsigned page)\n{\n    gnrc_sixlowpan_frag_vrb_t *vrbe;\n    const gnrc_sixlowpan_frag_sfr_bitmap_t *bitmap;\n    sixlowpan_sfr_rfrag_t *hdr = rfrag->data;\n    gnrc_pktsnip_t *netif_snip = rfrag->next;\n    /* copy base for ACK */\n    sixlowpan_sfr_t base = hdr->base;\n    int8_t ack_req = sixlowpan_sfr_rfrag_ack_req(hdr);\n    uint8_t seq = sixlowpan_sfr_rfrag_get_seq(hdr);\n\n    assert(netif_snip->data == netif_hdr);\n    gnrc_pktbuf_hold(netif_snip, 1);    /* hold netif header to use it with\n                                         * dispatch_when_complete()\n                                         * (rb_add() releases `pkt`) */\n    entry->entry.rb = gnrc_sixlowpan_frag_rb_add(netif_hdr, rfrag,\n                                                 offset, page);\n    /* check if VRB entry was created */\n    vrbe = gnrc_sixlowpan_frag_vrb_get(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                       netif_hdr->src_l2addr_len, base.tag);\n    if ((entry->entry.rb == NULL) && (vrbe == NULL)) {\n        DEBUG(\"6lo sfr: can't allocate reassembly buffer or forward compressed \"\n              \"fragment\\n\");\n        /* send abort */\n        bitmap = &_null_bitmap;\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.acks.aborts++;\n        }\n    }\n    else if (vrbe != NULL) {\n        DEBUG(\"6lo sfr: packet was forwarded\\n\");\n        goto end;\n    }\n    else {\n        int res;\n\n        DEBUG(\"6lo sfr: reassembling datagram (%s, %u)\\n\",\n              gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                     netif_hdr->src_l2addr_len, addr_str),\n              base.tag);\n        entry->type = _RB;\n        bf_set(entry->entry.rb->received, seq);\n        if ((res = gnrc_sixlowpan_frag_rb_dispatch_when_complete(entry->entry.rb,\n                                                                 netif_hdr)) < 0) {\n            DEBUG(\"6lo sfr: can not dispatch datagram to upper layer\\n\");\n            _clean_up_rb_entry(entry);\n            /* send abort */\n            bitmap = &_null_bitmap;\n            if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                _stats.acks.aborts++;\n            }\n        }\n        else {\n            if (res) {\n                DEBUG(\"6lo sfr: dispatched datagram to upper layer\\n\");\n                bitmap = &_full_bitmap;\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                    _stats.acks.full++;\n                }\n            }\n            else if (ack_req) {\n                DEBUG(\"6lo sfr: ACKing received fragments %02X%02X%02X%02X \"\n                      \"(%u of %u bytes received)\\n\",\n                      entry->entry.rb->received[0],\n                      entry->entry.rb->received[1],\n                      entry->entry.rb->received[2],\n                      entry->entry.rb->received[3],\n                      entry->entry.base->current_size,\n                      entry->entry.base->datagram_size);\n                bitmap = _get_bitmap(entry->entry.rb);\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                    _stats.acks.partly++;\n                }\n            }\n            else {\n                /* no ACK was requested and no error was causing an abort ACK*/\n                DEBUG(\"6lo sfr: no ACK requested by received fragment %u \"\n                      \"(bitmap so far: %02X%02X%02X%02X)\\n\", seq,\n                      entry->entry.rb->received[0],\n                      entry->entry.rb->received[1],\n                      entry->entry.rb->received[2],\n                      entry->entry.rb->received[3]);\n                goto end;\n            }\n        }\n    }\n    _send_ack(gnrc_netif_hdr_get_netif(netif_hdr),\n              gnrc_netif_hdr_get_src_addr(netif_hdr),\n              netif_hdr->src_l2addr_len, &base, bitmap->bf);\nend:\n    gnrc_pktbuf_release(netif_snip);    /* release hold */\n}\n\nstatic void _forward_uncomp(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                            unsigned page, _generic_rb_entry_t *entry,\n                            void *payload)\n{\n    sixlowpan_sfr_rfrag_t *hdr = pkt->data;\n    gnrc_sixlowpan_frag_rb_base_t vrb_base = {\n        .src_len = netif_hdr->src_l2addr_len,\n        .tag = hdr->base.tag,\n        .datagram_size = sixlowpan_sfr_rfrag_get_offset(hdr),\n    };\n    gnrc_pktsnip_t tmp = {\n        .data = payload,\n        .size = pkt->size - sizeof(sixlowpan_sfr_rfrag_t) - 1,\n        .users = 1,\n    };\n\n    switch (page) {\n#if defined(MODULE_GNRC_IPV6)\n        case 0: {\n            ipv6_hdr_t *ipv6_hdr = tmp.data;\n\n            if (ipv6_hdr->hl <= 1) {\n                DEBUG(\"6lo sfr: minimal hop-limit reached\\n\");\n                /* try to reassemble to hand to IPv6 module for error\n                 * handling */\n                _try_reassembly(netif_hdr, pkt, 0, entry, page);\n                return;\n            }\n            tmp.type = GNRC_NETTYPE_IPV6;\n            break;\n        }\n#endif\n        default:\n            tmp.type = GNRC_NETTYPE_UNDEF;\n            break;\n    }\n    vrb_base.arrival = xtimer_now_usec();\n    memcpy(vrb_base.src, gnrc_netif_hdr_get_src_addr(netif_hdr),\n           vrb_base.src_len);\n    entry->entry.vrb = gnrc_sixlowpan_frag_vrb_from_route(&vrb_base,\n                                                          NULL, &tmp);\n    if (entry->entry.vrb == NULL) {\n        DEBUG(\"6lo sfr: no route found or no VRB space left, \"\n              \"trying reassembly\\n\");\n        _try_reassembly(netif_hdr, pkt, 0, entry, page);\n        return;\n    }\n    /* only decrement hop-limit after check in case we reassemble */\n    switch (page) {\n#if defined(MODULE_GNRC_IPV6)\n        case 0: {\n            ipv6_hdr_t *ipv6_hdr = tmp.data;\n\n            ipv6_hdr->hl--;\n            break;\n        }\n#endif\n        default:\n            break;\n    }\n    entry->type = _VRB;\n    entry->entry.vrb->in_netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    entry->entry.vrb->offset_diff = 0; /* packet is uncompressed so offset\n                                        * does not change */\n    _forward_rfrag(pkt, entry, sixlowpan_sfr_rfrag_get_offset(hdr), page);\n}\n\nstatic void _handle_1st_rfrag(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                              unsigned page, _generic_rb_entry_t *entry)\n{\n    sixlowpan_sfr_rfrag_t *hdr = pkt->data;\n    /* https://tools.ietf.org/html/rfc8931#section-5.1:\n     *   +  For a first fragment (i.e. with a Sequence of 0), this field\n     *      indicates the datagram_size of the compressed datagram, [...] */\n    uint16_t datagram_size = sixlowpan_sfr_rfrag_get_offset(hdr);\n    uint8_t fragment_size = sixlowpan_sfr_rfrag_get_frag_size(hdr);\n    uint8_t *payload;\n\n    if ((datagram_size == 0) && (fragment_size == 0)) {\n        /* the received fragment is a pseudo-fragment that signals an abort\n         * condition by the fragmenting end-point, release state on the\n         * datagram */\n        bool release_pkt = true;\n\n        DEBUG(\"6lo sfr: Abort for datagram (%s, %u) received\\n\",\n              gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                     netif_hdr->src_l2addr_len, addr_str),\n              hdr->base.tag);\n        if ((entry->entry.vrb = gnrc_sixlowpan_frag_vrb_get(\n                gnrc_netif_hdr_get_src_addr(netif_hdr),\n                netif_hdr->src_l2addr_len, hdr->base.tag)) != NULL) {\n            /* we have a VRB on the aborted datagram. Release it */\n            entry->type = _VRB;\n            _forward_rfrag(pkt, entry, 0, page);\n            gnrc_sixlowpan_frag_vrb_rm(entry->entry.vrb);\n            release_pkt = false;\n        }\n        if ((entry->entry.rb = gnrc_sixlowpan_frag_rb_get_by_datagram(\n                netif_hdr, hdr->base.tag)) != NULL) {\n            /* we have a reassembly buffer entry on the aborted datagram.\n             * Release it */\n            entry->type = _RB;\n            _abort_rb(pkt, entry, netif_hdr, sixlowpan_sfr_rfrag_ack_req(hdr));\n            release_pkt = false;\n        }\n        if (release_pkt) {\n            DEBUG(\"6lo sfr: received abort for unknown datagram\\n\");\n            /* neither VRB or RB exists so we don't have any state on the\n             * aborted datagram left. Just release the abort pseudo fragment */\n            gnrc_pktbuf_release(pkt);\n        }\n        return;\n    }\n    DEBUG(\"6lo sfr: First fragment (%s, %u) received\\n\",\n          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                 netif_hdr->src_l2addr_len, addr_str),\n          hdr->base.tag);\n\n    payload = (uint8_t *)(hdr + 1);\n    if (payload[0] == SIXLOWPAN_UNCOMP) {\n        _forward_uncomp(netif_hdr, pkt, page, entry, payload + 1);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&\n            sixlowpan_iphc_is(payload)) {\n            _try_reassembly(netif_hdr, pkt, 0, entry, page);\n            return;\n        }\n        DEBUG(\"6lo sfr: unable to parse next dispatch for forwarding \"\n              \"information. Abort\\n\");\n        _abort_rb(pkt, entry, netif_hdr, false);\n        return;\n    }\n}\n\nstatic void _handle_nth_rfrag(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                              unsigned page, _generic_rb_entry_t *entry)\n{\n    sixlowpan_sfr_rfrag_t *hdr = pkt->data;\n    uint16_t offset = sixlowpan_sfr_rfrag_get_offset(hdr);\n\n    DEBUG(\"6lo sfr: Subsequent fragment (%s, %u) received\\n\",\n          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                 netif_hdr->src_l2addr_len, addr_str),\n          hdr->base.tag);\n    if (gnrc_sixlowpan_frag_rb_exists(netif_hdr, hdr->base.tag)) {\n        DEBUG(\"6lo sfr: I am destination endpoint => adding to reassembly \"\n              \"buffer\\n\");\n        _try_reassembly(netif_hdr, pkt, offset, entry, page);\n    }\n    else if ((entry->entry.vrb = gnrc_sixlowpan_frag_vrb_get(\n            gnrc_netif_hdr_get_src_addr(netif_hdr),\n            netif_hdr->src_l2addr_len, hdr->base.tag)) != NULL) {\n        entry->type = _VRB;\n        entry->entry.base->arrival = xtimer_now_usec();\n        _forward_rfrag(pkt, entry, offset, page);\n    }\n    else {\n        DEBUG(\"6lo sfr: neither VRB nor RB found\\n\");\n        /* always send abort ACK:\n         * https://tools.ietf.org/html/rfc8931#section-6.1.2 */\n        _abort_rb(pkt, entry, netif_hdr, true);\n    }\n}\n\nstatic int _resend_failed_frag(clist_node_t *node, void *fbuf_ptr)\n{\n    int res = _resend_frag(node, fbuf_ptr);\n\n    if (res == 0) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.fragment_resends.by_nack++;\n        }\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf_ptr);\n    }\n    return res;\n}\n\nstatic void _check_failed_frags(sixlowpan_sfr_ack_t *ack,\n                                gnrc_sixlowpan_frag_fb_t *fbuf,\n                                uint32_t ack_recv_time)\n{\n    _frag_desc_t *frag_desc;\n    clist_node_t not_received = { .next = NULL };\n    ztimer_now_t earliest_send = UINT32_MAX;\n\n    DEBUG(\"6lo sfr: checking which fragments to resend for datagram %u\\n\",\n          fbuf->tag);\n    for (frag_desc = (_frag_desc_t *)clist_lpop(&fbuf->sfr.window);\n         frag_desc != NULL;\n         frag_desc = (_frag_desc_t *)clist_lpop(&fbuf->sfr.window)) {\n        uint8_t seq;\n\n        seq = _frag_seq(frag_desc);\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) &&\n            (earliest_send > frag_desc->super.send_time)) {\n            earliest_send = frag_desc->super.send_time;\n        }\n        if (bf_isset(ack->bitmap, seq)) {\n            DEBUG(\"6lo sfr: fragment %u (offset: %u, frag_size: %u) \"\n                  \"for datagram %u was received\\n\", seq,\n                  frag_desc->offset, _frag_size(frag_desc), fbuf->tag);\n            fbuf->sfr.frags_sent--;\n            clist_rpush(&_frag_descs_free, &frag_desc->super.super);\n            if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {\n                congure_snd_ack_t ack = {\n                    .recv_time = ack_recv_time,\n                    .id = seq,\n                    .clean = 1U,\n                };\n                gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_acked(\n                    fbuf, &frag_desc->super, &ack\n                );\n            }\n        }\n        else {\n            DEBUG(\"6lo sfr: fragment %u (offset: %u, frag_size: %u) \"\n                  \"for datagram %u was not received\\n\", seq,\n                  frag_desc->offset, _frag_size(frag_desc), fbuf->tag);\n            if ((frag_desc->super.resends++) < CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES) {\n                DEBUG(\"6lo sfr: %u retries left\\n\",\n                      CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES -\n                      (frag_desc->super.resends - 1));\n                /* put fragment in \"not received\" list */\n                clist_rpush(&not_received, &frag_desc->super.super);\n                frag_desc->ar_seq_fs &= ~(SIXLOWPAN_SFR_ACK_REQ << 8U);\n            }\n            else {\n                DEBUG(\"6lo sfr: no more retries for fragment %u\\n\", seq);\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) &&\n                    IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_USE_ECN) &&\n                    sixlowpan_sfr_ecn(&ack->base)) {\n                    gnrc_sixlowpan_frag_sfr_congure_snd_report_ecn(\n                        fbuf, earliest_send\n                    );\n                }\n                clist_rpush(&_frag_descs_free, &frag_desc->super.super);\n                /* retry to resend whole datagram */\n                _retry_datagram(fbuf);\n                return;\n            }\n        }\n    }\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) &&\n        sixlowpan_sfr_ecn(&ack->base)) {\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_ecn(fbuf, earliest_send);\n    }\n    /* all fragments were received of the current window were received and\n     * the datagram was transmitted completely */\n    if ((clist_lpeek(&not_received) == NULL) &&\n        (fbuf->offset == fbuf->datagram_size)) {\n        /* release fragmentation buffer */\n        _clean_up_fbuf(fbuf, GNRC_NETERR_SUCCESS);\n    }\n    /* at least one fragment was not received */\n    else {\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_lost(\n            fbuf,\n            (congure_snd_msg_t *)&not_received\n        );\n        fbuf->sfr.window = not_received;\n        _shrink_window(fbuf);\n        assert(fbuf->sfr.frags_sent == clist_count(&fbuf->sfr.window));\n        /* use _resend_failed_frag here instead of loop above, so\n         * _resend_frag can know if the fragment is the last in the window by\n         * using clist_rpeek() on fbuf->sfr.window */\n        if (clist_foreach(&fbuf->sfr.window, _resend_failed_frag, fbuf) != NULL) {\n            /* XXX: it is unlikely that allocating an abort RFRAG will be\n             * successful since the resources missing to cause the abort are\n             * still in use, but we should at least try */\n            if (_send_abort_frag(fbuf->pkt, fbuf, true, 0)) {\n                /* wait for ACK before fbuf is deleted */\n                _sched_abort_timeout(fbuf);\n            }\n            else {\n                /* we have no memory resources left to send neither the\n                 * resent fragment nor the abort ACK to signalize that fact to\n                 * the reassembling endpoint */\n                _clean_up_fbuf(fbuf, ENOMEM);\n            }\n        }\n        if (gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf) &&\n            (fbuf->offset < fbuf->datagram_size)) {\n            DEBUG(\"6lo sfr: trigger send of further fragments of datagram %u\\n\",\n                  fbuf->tag);\n            gnrc_sixlowpan_frag_fb_send(fbuf);\n        }\n    }\n}\n\n/* ====== INTERNAL FUNCTIONS USED BY PUBLIC FUNCTIONS ======\n * ====== AND TO MANIPULATE INTERNAL DATA STRUCTURES  ====== */\nstatic inline gnrc_sixlowpan_frag_sfr_bitmap_t *_get_bitmap(gnrc_sixlowpan_frag_rb_t *frag_rb)\n{\n    DECLARE_CONSTANT(is_aligned,\n        HAS_ALIGNMENT_OF(offsetof(gnrc_sixlowpan_frag_rb_t, received),\n                         alignof(gnrc_sixlowpan_frag_sfr_bitmap_t)))\n    static_assert(is_aligned,\n                  \"gnrc_sixlowpan_frag_rb_t::received must be suitably aligned\");\n    return (gnrc_sixlowpan_frag_sfr_bitmap_t *)(uintptr_t)frag_rb->received;\n}\n\nstatic inline bool _frag_ack_req(_frag_desc_t *frag)\n{\n\n    return (frag->ar_seq_fs & (SIXLOWPAN_SFR_ACK_REQ << 8U));\n}\n\nstatic inline uint8_t _frag_seq(_frag_desc_t *frag)\n{\n    return (frag->ar_seq_fs & (SIXLOWPAN_SFR_SEQ_MASK << 8U)) >>\n           (SIXLOWPAN_SFR_SEQ_POS + 8U);\n}\n\nstatic inline uint16_t _frag_size(_frag_desc_t *frag)\n{\n    return (frag->ar_seq_fs & SIXLOWPAN_SFR_FRAG_SIZE_MASK);\n}\n\nstatic void _clean_up_fbuf(gnrc_sixlowpan_frag_fb_t *fbuf, int error)\n{\n    DEBUG(\"6lo sfr: removing fragmentation buffer entry for datagram %u\\n\",\n          fbuf->tag);\n    _clean_slate_datagram(fbuf);\n    gnrc_sixlowpan_frag_sfr_congure_snd_destroy(fbuf);\n    gnrc_pktbuf_release_error(fbuf->pkt, error);\n    fbuf->pkt = NULL;\n}\n\nstatic uint16_t _send_1st_fragment(gnrc_netif_t *netif,\n                                   gnrc_sixlowpan_frag_fb_t *fbuf,\n                                   unsigned page, gnrc_pktsnip_t **tx_sync)\n{\n    gnrc_pktsnip_t *frag, *pkt = fbuf->pkt;\n    sixlowpan_sfr_rfrag_t *hdr;\n    uint8_t *data;\n    size_t comp_form_size = gnrc_pkt_len(pkt->next);\n    uint16_t frag_size = (uint16_t)netif->sixlo.max_frag_size -\n                         sizeof(sixlowpan_sfr_rfrag_t);\n\n    assert((fbuf->sfr.cur_seq == 0) && (fbuf->sfr.frags_sent == 0));\n    assert(fbuf->sfr.window.next == NULL);\n    assert(comp_form_size <= UINT16_MAX);\n    /* restrict tag to value space of SFR, so that later RFRAG ACK can find\n     * it in reverse look-up */\n    fbuf->tag &= UINT8_MAX;\n    DEBUG(\"6lo sfr: determined frag_size = %u\\n\", frag_size);\n\n    /* packet was compressed */\n    if (fbuf->datagram_size > comp_form_size) {\n        /* add slack to first fragment */\n        frag_size -= (fbuf->datagram_size - comp_form_size);\n        /* use compressed form */\n        fbuf->datagram_size = (uint16_t)gnrc_pkt_len(pkt->next);\n    }\n    else {\n        /* Add uncompressed datagram dispatch to \"compressed form\"\n         * datagram_size */\n        fbuf->datagram_size++;\n    }\n    fbuf->sfr.arq_timeout = CONFIG_GNRC_SIXLOWPAN_SFR_OPT_ARQ_TIMEOUT_MS;\n\n    frag = _build_frag_from_fbuf(pkt, fbuf, frag_size);\n    if (frag == NULL) {\n        DEBUG(\"6lo sfr: error allocating first fragment\\n\");\n        return 0;\n    }\n    hdr = frag->next->data;\n    data = (uint8_t *)(hdr + 1);\n    sixlowpan_sfr_rfrag_set_offset(hdr, fbuf->datagram_size);\n    /* don't copy netif header of pkt => pkt->next */\n    frag_size = _copy_pkt_to_frag(data, pkt->next, frag_size, 0);\n    if (IS_USED(MODULE_GNRC_TX_SYNC) && *tx_sync && (frag_size >= fbuf->datagram_size)) {\n        gnrc_pkt_append(frag, *tx_sync);\n        *tx_sync = NULL;\n    }\n\n    DEBUG(\"6lo sfr: send first fragment (tag: %u, X: %i, seq: %u, \"\n          \"frag_size: %u, datagram_size: %u)\\n\",\n          hdr->base.tag, sixlowpan_sfr_rfrag_ack_req(hdr),\n          sixlowpan_sfr_rfrag_get_seq(hdr),\n          sixlowpan_sfr_rfrag_get_frag_size(hdr),\n          sixlowpan_sfr_rfrag_get_offset(hdr));\n    if (!_send_fragment(frag, fbuf, page, 0)) {\n        frag_size = 0;\n    }\n    return frag_size;\n}\n\nstatic uint16_t _send_nth_fragment(gnrc_netif_t *netif,\n                                   gnrc_sixlowpan_frag_fb_t *fbuf,\n                                   unsigned page,\n                                   gnrc_pktsnip_t **tx_sync)\n{\n    gnrc_pktsnip_t *frag, *pkt = fbuf->pkt;\n    sixlowpan_sfr_rfrag_t *hdr;\n    uint8_t *data;\n    uint16_t frag_size = (uint16_t)netif->sixlo.max_frag_size -\n                         sizeof(sixlowpan_sfr_rfrag_t);\n    uint16_t local_offset;\n\n    assert((fbuf->sfr.cur_seq > 0) &&\n           (fbuf->sfr.cur_seq <= SIXLOWPAN_SFR_SEQ_MAX));\n    assert((fbuf->sfr.frags_sent == 0) || (fbuf->sfr.window.next != NULL));\n    assert(fbuf->tag <= UINT8_MAX);\n\n    DEBUG(\"6lo sfr: determined frag_size = %u\\n\", frag_size);\n    frag = _build_frag_from_fbuf(pkt, fbuf,\n                                 _min(frag_size,\n                                      fbuf->datagram_size - fbuf->offset));\n    if (frag == NULL) {\n        DEBUG(\"6lo sfr: error allocating subsequent fragment\\n\");\n        return 0;\n    }\n    hdr = frag->next->data;\n    data = (uint8_t *)(hdr + 1);\n    sixlowpan_sfr_rfrag_set_offset(hdr, fbuf->offset);\n    pkt = pkt->next;    /* don't copy netif header */\n    local_offset = _find_offset_and_copy_rest(data, &pkt, frag_size,\n                                              fbuf->offset);\n    /* copy remaining packet snips */\n    local_offset = _copy_pkt_to_frag(data, pkt, frag_size, local_offset);\n    if (IS_USED(MODULE_GNRC_TX_SYNC) && *tx_sync && (local_offset >= fbuf->datagram_size)) {\n        gnrc_pkt_append(frag, *tx_sync);\n        *tx_sync = NULL;\n    }\n    DEBUG(\"6lo sfr: send subsequent fragment (tag: %u, X: %i, seq: %u, \"\n          \"frag_size: %u, offset: %u)\\n\",\n          hdr->base.tag, sixlowpan_sfr_rfrag_ack_req(hdr),\n          sixlowpan_sfr_rfrag_get_seq(hdr),\n          sixlowpan_sfr_rfrag_get_frag_size(hdr),\n          sixlowpan_sfr_rfrag_get_offset(hdr));\n    if (!_send_fragment(frag, fbuf, page, fbuf->offset)) {\n        local_offset = 0;\n    }\n    return local_offset;\n}\n\nstatic bool _send_abort_frag(gnrc_pktsnip_t *pkt,\n                             gnrc_sixlowpan_frag_fb_t *fbuf,\n                             bool req_ack, unsigned page)\n{\n    gnrc_pktsnip_t *frag;\n\n    frag = _build_frag_pkt(pkt->data, fbuf->tag, req_ack, 0, 0);\n    if (frag != NULL) {\n        sixlowpan_sfr_rfrag_set_offset(frag->next->data, 0);\n        _send_frame(frag, fbuf, NULL, page);\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.fragments_sent.aborts++;\n        }\n        return true;\n    }\n    return false;\n}\n\nstatic void _shrink_window(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    if (!IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {\n        /* window does not shrink without congure */\n        return;\n    }\n    if (!gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf)) {\n        /* we are beyond the congestion window, so shrink it to the new size */\n        clist_node_t new_window = { .next = NULL };\n        _frag_desc_t *last;\n\n        fbuf->sfr.frags_sent = 0;   /* temporarily reset fragments sent to count them again*/\n        /* move all fragments within congestion window into new, temporary list */\n        while (gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf)) {\n            clist_rpush(&new_window, clist_lpop(&fbuf->sfr.window));\n            fbuf->sfr.frags_sent++;\n        }\n        /* free all remaining fragments from old congestion window that did not fit into\n         * the shrunk window */\n        for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n             node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n            clist_rpush(&_frag_descs_free, node);\n        }\n        /* the temporary list is now the new, shrunk window */\n        fbuf->sfr.window.next = new_window.next;\n        /* recalculate offset for fragmentation header field */\n        last = (_frag_desc_t *)clist_rpeek(&fbuf->sfr.window);\n        fbuf->offset = last->offset + _frag_size(last);\n    }\n}\n\nstatic int _resend_frag(clist_node_t *node, void *fbuf_ptr)\n{\n    _frag_desc_t *frag_desc = (_frag_desc_t *)node;\n    gnrc_sixlowpan_frag_fb_t *fbuf = fbuf_ptr;\n    gnrc_pktsnip_t *frag, *pkt = fbuf->pkt;\n    sixlowpan_sfr_rfrag_t *hdr;\n    uint8_t *data;\n    uint16_t frag_size = _frag_size(frag_desc), cur_frag_size;\n\n    frag = _build_frag_pkt(pkt->data, (uint8_t)fbuf->tag, false,\n                           frag_size, 0);\n    if (frag == NULL) {\n        DEBUG(\"6lo sfr: error allocating fragment to resend\\n\");\n        return 1;\n    }\n    hdr = frag->next->data;\n    /* is last fragment in window */\n    if ((!gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf) ||\n         (fbuf->offset >= fbuf->datagram_size)) &&\n        (clist_node_t *)frag_desc == clist_rpeek(&fbuf->sfr.window)) {\n        frag_desc->ar_seq_fs |= (SIXLOWPAN_SFR_ACK_REQ << 8U);\n        _sched_arq_timeout(fbuf, fbuf->sfr.arq_timeout);\n    }\n    hdr->ar_seq_fs = byteorder_htons(frag_desc->ar_seq_fs);\n    if (frag_desc->offset > 0) {\n        sixlowpan_sfr_rfrag_set_offset(hdr, frag_desc->offset);\n    }\n    else {\n        sixlowpan_sfr_rfrag_set_offset(hdr, fbuf->datagram_size);\n    }\n\n    data = (uint8_t *)(hdr + 1);\n    pkt = pkt->next;    /* don't copy netif header */\n    cur_frag_size = _find_offset_and_copy_rest(data, &pkt, frag_size,\n                                               frag_desc->offset);\n    /* copy remaining packet snips */\n    _copy_pkt_to_frag(data, pkt, frag_size, cur_frag_size);\n    DEBUG(\"6lo sfr: resending fragment (retry: %u, tag: %u, X: %i, seq: %u, \"\n          \"frag_size: %u, %s: %u)\\n\", frag_desc->super.resends,\n          hdr->base.tag, sixlowpan_sfr_rfrag_ack_req(hdr),\n          sixlowpan_sfr_rfrag_get_seq(hdr),\n          sixlowpan_sfr_rfrag_get_frag_size(hdr),\n          (sixlowpan_sfr_rfrag_get_seq(hdr)) ? \"offset\" : \"datagram_size\",\n          sixlowpan_sfr_rfrag_get_offset(hdr));\n    if (_send_frame(frag, fbuf, NULL, 0)) {\n        frag_desc->super.send_time = _last_frame_sent / US_PER_MS;\n        return 0;\n    }\n    else {\n        return 1;\n    }\n}\n\nstatic void _retry_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    if ((CONFIG_GNRC_SIXLOWPAN_SFR_DG_RETRIES == 0) ||\n        (fbuf->sfr.retrans == 0)) {\n        DEBUG(\"6lo sfr: giving up to send datagram %u\\n\",\n              fbuf->tag);\n        _clean_up_fbuf(fbuf, ETIMEDOUT);\n    }\n    else {\n        DEBUG(\"6lo sfr: Retrying to send datagram %u completely\\n\", fbuf->tag);\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.datagram_resends++;\n        }\n        fbuf->sfr.retrans--;\n        /* return fragmentation buffer to its original state to resend the whole\n         * datagram again */\n        _clean_slate_datagram(fbuf);\n        gnrc_sixlowpan_frag_sfr_send(fbuf->pkt, fbuf, 0);\n    }\n}\n\nstatic void _abort_rb(gnrc_pktsnip_t *pkt, _generic_rb_entry_t *entry,\n                      gnrc_netif_hdr_t *netif_hdr, bool send_ack)\n{\n    sixlowpan_sfr_rfrag_t *hdr = pkt->data;\n\n    DEBUG(\"6lo sfr: Aborting datagram (%s, %02x)\\n\",\n          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                 netif_hdr->src_l2addr_len, addr_str),\n          hdr->base.tag);\n    if (send_ack) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.acks.aborts++;\n        }\n        _send_ack(gnrc_netif_hdr_get_netif(netif_hdr),\n                  gnrc_netif_hdr_get_src_addr(netif_hdr),\n                  netif_hdr->src_l2addr_len,\n                  &hdr->base, _null_bitmap.bf);\n    }\n    _clean_up_rb_entry(entry);\n    gnrc_pktbuf_release(pkt);\n}\n\nstatic void _send_ack(gnrc_netif_t *netif, const uint8_t *dst, uint8_t dst_len,\n                      const sixlowpan_sfr_t *hdr, const uint8_t *bitmap)\n{\n    gnrc_pktsnip_t *ack = _build_ack(netif, dst, dst_len, hdr, bitmap);\n\n    DEBUG(\"6lo sfr: Sending ACK for (%s, %02x): %02X%02X%02X%02X\\n\",\n          gnrc_netif_addr_to_str(dst, dst_len, addr_str),\n          hdr->tag, bitmap[0], bitmap[1], bitmap[2], bitmap[3]);\n    if (ack != NULL) {\n        _send_frame(ack, NULL, NULL, 0);\n    }\n    else {\n        DEBUG(\"6lo sfr: unable to build ACK for sending\\n\");\n    }\n}\n\nstatic void _sched_next_frame(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    if (!gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        return;\n    }\n    int state = irq_disable();  /* make timer check atomic */\n    bool already_set = xtimer_is_set(&_if_gap_timer);\n\n    irq_restore(state);\n    if (already_set) {\n        DEBUG(\"6lo sfr: inter-frame timer was already set\\n\");\n        return;\n    }\n    uint32_t last_sent_since = (_last_frame_sent - xtimer_now_usec());\n    uint32_t if_gap = gnrc_sixlowpan_frag_sfr_congure_snd_inter_frame_gap(fbuf);\n\n    if (last_sent_since <= if_gap) {\n        uint32_t offset = if_gap - last_sent_since;\n        DEBUG(\"6lo sfr: arming inter-frame timer in %\" PRIu32 \" us\\n\",\n              last_sent_since);\n        _if_gap_msg.content.ptr = fbuf;\n        xtimer_set_msg(&_if_gap_timer, offset, &_if_gap_msg, _getpid());\n    }\n    else {\n        DEBUG(\"6lo sfr: send frame immediately\\n\");\n        /* there is no risk of infinite recursion due to the call of `_sched_next_frame` since\n         * we only get here when (_last_frame_sent - now) > if_gap.\n         * Since gnrc_sixlowpan_frag_sfr_inter_frame_gap updates _last_frame_sent when the list is\n         * empty and only calls _sched_next_frame() when the list is still not empty after that this\n         * can not be the case if we came from there (except for misconfigured if_gap). */\n        gnrc_sixlowpan_frag_sfr_inter_frame_gap(fbuf);\n    }\n}\n\nstatic void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)\n{\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        /* mock does not need to be scheduled */\n        return;\n    }\n    if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {\n        DEBUG(\"6lo sfr: ARQ timeout for datagram %u already scheduled\\n\",\n              (uint8_t)fbuf->tag);\n        return;\n    }\n    DEBUG(\"6lo sfr: arming ACK timeout in %lums for datagram %u\\n\",\n          (long unsigned)offset, fbuf->tag);\n    fbuf->sfr.arq_timeout_event.event.offset = offset;\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = fbuf;\n    fbuf->sfr.arq_timeout_event.msg.type = GNRC_SIXLOWPAN_FRAG_SFR_ARQ_TIMEOUT_MSG;\n    evtimer_add_msg(&_arq_timer, &fbuf->sfr.arq_timeout_event,\n                    _getpid());\n}\n\nstatic void _sched_abort_timeout(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    /* no fragments to wait for anymore as we aborted fragmentation and just\n     * wait for an ACK by the reassembling end point that they know. As such,\n     * clean-out the fragmentation buffer. */\n    _clean_slate_datagram(fbuf);\n    fbuf->sfr.retrans = 0;\n    _sched_arq_timeout(fbuf, fbuf->sfr.arq_timeout);\n}\n\nstatic void _handle_rfrag(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                          unsigned page)\n{\n    _generic_rb_entry_t entry = { .type = _UNDEF };\n\n    if (sixlowpan_sfr_rfrag_get_seq(pkt->data) == 0U) {\n        _handle_1st_rfrag(netif_hdr, pkt, page, &entry);\n    }\n    else {\n        _handle_nth_rfrag(netif_hdr, pkt, page, &entry);\n    }\n}\n\nstatic void _handle_ack(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                        unsigned page)\n{\n    gnrc_sixlowpan_frag_vrb_t *vrbe;\n    sixlowpan_sfr_ack_t *hdr = pkt->data;\n    uint32_t recv_time = xtimer_now_usec();\n\n    (void)page;\n    DEBUG(\"6lo sfr: received ACK for datagram (%s, %02x): %02X%02X%02X%02X\\n\",\n          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                 netif_hdr->src_l2addr_len,\n                                 addr_str), hdr->base.tag,\n          hdr->bitmap[0], hdr->bitmap[1], hdr->bitmap[2], hdr->bitmap[3]);\n    if ((vrbe = gnrc_sixlowpan_frag_vrb_reverse(\n            gnrc_netif_hdr_get_netif(netif_hdr),\n            gnrc_netif_hdr_get_src_addr(netif_hdr),\n            netif_hdr->src_l2addr_len, hdr->base.tag)) != NULL) {\n        /* we found a VRB entry by reverse lookup, forward ACK further down. */\n        sixlowpan_sfr_t mock_base = { .disp_ecn = hdr->base.disp_ecn,\n                                      .tag = vrbe->super.tag };\n        DEBUG(\"6lo sfr: forward ACK to (%s, %02x)\\n\",\n              gnrc_netif_addr_to_str(vrbe->super.src, vrbe->super.src_len,\n                                     addr_str), vrbe->super.tag);\n        _send_ack(vrbe->in_netif, vrbe->super.src, vrbe->super.src_len,\n                  &mock_base, hdr->bitmap);\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.acks.forwarded++;\n        }\n        if ((unaligned_get_u32(hdr->bitmap) == _full_bitmap.u32) ||\n            (unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {\n            if (CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER > 0) {\n                /* garbage-collect entry after CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER\n                 * microseconds */\n                vrbe->super.arrival = recv_time -\n                                      (CONFIG_GNRC_SIXLOWPAN_FRAG_VRB_TIMEOUT_US -\n                                       CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER);\n            }\n            else {\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n            }\n        }\n        else {\n            vrbe->super.arrival = recv_time;\n        }\n    }\n    else {\n        gnrc_sixlowpan_frag_fb_t *fbuf;\n\n        if ((fbuf = gnrc_sixlowpan_frag_fb_get_by_tag(hdr->base.tag)) != NULL) {\n            /* ACK for pending ACK timeout received. removing ACK timeout */\n            DEBUG(\"6lo sfr: cancelling ARQ timeout\\n\");\n            evtimer_del((evtimer_t *)(&_arq_timer),\n                        &fbuf->sfr.arq_timeout_event.event);\n            fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n            if ((unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {\n                /* ACK indicates the reassembling endpoint canceled reassembly\n                 */\n                DEBUG(\"6lo sfr: fragmentation canceled\\n\");\n                /* Retry to send whole datagram if configured, otherwise\n                 * cancel fragmentation */\n                _retry_datagram(fbuf);\n            }\n            else {\n                /* Check and resent failed fragments within the current window\n                 */\n               _check_failed_frags(hdr, fbuf, recv_time / US_PER_MS);\n            }\n        }\n        else {\n            DEBUG(\"6lo sfr: no VRB or fragmentation buffer found\\n\");\n        }\n    }\n    gnrc_pktbuf_release(pkt);\n}\n\nstatic int _forward_rfrag(gnrc_pktsnip_t *pkt, _generic_rb_entry_t *entry,\n                          uint16_t offset, unsigned page)\n{\n    gnrc_pktsnip_t *old, *new = gnrc_netif_hdr_build(\n            NULL, 0,\n            entry->entry.base->dst, entry->entry.base->dst_len\n        );\n    sixlowpan_sfr_rfrag_t *hdr;\n\n    assert(entry->type == _VRB);\n    /* restrict out_tag to value space of SFR, so that later RFRAG ACK can find\n     * it in reverse look-up */\n    entry->entry.vrb->out_tag &= UINT8_MAX;\n    DEBUG(\"6lo sfr: Forwarding to (%s, %u)\\n\",\n          gnrc_netif_addr_to_str(entry->entry.base->dst,\n                                 entry->entry.base->dst_len, addr_str),\n          entry->entry.vrb->out_tag);\n    if (new == NULL) {\n        DEBUG(\"6lo sfr: Unable to forward fragment, \"\n              \"packet buffer full\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ENOMEM;\n    }\n\n    hdr = pkt->data;\n    old = gnrc_pktsnip_search_type(pkt, GNRC_NETTYPE_NETIF);\n    if (old != NULL) {\n        /* remove original netif header */\n        gnrc_pktbuf_remove_snip(pkt, old);\n    }\n    if (offset > 0) {\n        offset += entry->entry.vrb->offset_diff;\n    }\n    sixlowpan_sfr_rfrag_set_offset(hdr, offset);\n    hdr->base.tag = entry->entry.vrb->out_tag;\n    gnrc_netif_hdr_set_netif(new->data, entry->entry.vrb->out_netif);\n    new->next = pkt;\n    _send_frame(new, NULL, NULL, page);\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n        _stats.fragments_sent.forwarded++;\n    }\n    return 0;\n}\n\n/** @} */\n"], "fixing_code": ["/*\n * Copyright (C) 2019 Freie Universit\u00e4t Berlin\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @{\n *\n * @file\n * @author  Martine Lenders <m.lenders@fu-berlin.de>\n */\n\n#include <stddef.h>\n\n#include \"irq.h\"\n#include \"kernel_defines.h\"\n#ifdef MODULE_GNRC_IPV6_NIB\n#include \"net/ipv6/addr.h\"\n#endif\n#ifdef MODULE_GNRC_IPV6\n#include \"net/ipv6/hdr.h\"\n#endif\n#include \"net/gnrc/neterr.h\"\n#include \"net/gnrc/netif/internal.h\"\n#include \"net/gnrc/netif/pktq.h\"\n#include \"net/gnrc/pkt.h\"\n#include \"net/gnrc/sixlowpan.h\"\n#include \"net/gnrc/sixlowpan/config.h\"\n#include \"net/gnrc/sixlowpan/frag/fb.h\"\n#include \"net/gnrc/sixlowpan/frag/rb.h\"\n#include \"net/gnrc/sixlowpan/frag/vrb.h\"\n#include \"net/gnrc/tx_sync.h\"\n#include \"net/sixlowpan/sfr.h\"\n#include \"thread.h\"\n#include \"unaligned.h\"\n#include \"xtimer.h\"\n\n#include \"net/gnrc/sixlowpan/frag/sfr.h\"\n#include \"net/gnrc/sixlowpan/frag/sfr/congure.h\"\n\n#define ENABLE_DEBUG    0\n#include \"debug.h\"\n\n#define FRAG_DESCS_POOL_SIZE    (CONFIG_GNRC_SIXLOWPAN_FRAG_FB_SIZE * \\\n                                 CONFIG_GNRC_SIXLOWPAN_SFR_MAX_WIN_SIZE)\n#define FRAME_QUEUE_POOL_SIZE   (FRAG_DESCS_POOL_SIZE + \\\n                                 CONFIG_GNRC_SIXLOWPAN_FRAG_VRB_SIZE)\n\ntypedef struct {\n    congure_snd_msg_t super;    /**< CongURE message parent */\n    /**\n     * @brief   Acknowledgment request flag, sequence number, and fragment size\n     */\n    uint16_t ar_seq_fs;\n    uint16_t offset;            /**< offset of the fragment */\n} _frag_desc_t;\n\ntypedef struct {\n    clist_node_t super;     /**< list parent instance */\n    gnrc_pktsnip_t *frame;  /**< frame in the queue */\n    uint8_t datagram_tag;   /**< tag for identification */\n    uint8_t page;           /**< parsing page context for the frame */\n} _frame_queue_t;\n\ntypedef struct {\n    enum {\n        _UNDEF = 0,\n        _RB,\n        _VRB,\n    } type;\n    union {\n        gnrc_sixlowpan_frag_rb_base_t *base;\n        gnrc_sixlowpan_frag_rb_t *rb;\n        gnrc_sixlowpan_frag_vrb_t *vrb;\n    } entry;\n} _generic_rb_entry_t;\n\n#ifdef MODULE_GNRC_IPV6_NIB\nstatic char addr_str[IPV6_ADDR_MAX_STR_LEN];\n#else   /* MODULE_GNRC_IPV6_NIB */\nstatic char addr_str[GNRC_NETIF_HDR_L2ADDR_PRINT_LEN];\n#endif  /* MODULE_GNRC_IPV6_NIB */\n\nstatic evtimer_msg_t _arq_timer;\nstatic xtimer_t _if_gap_timer = { 0 };\nstatic msg_t _if_gap_msg = { .type = GNRC_SIXLOWPAN_FRAG_SFR_INTER_FRAG_GAP_MSG };\nstatic uint32_t _last_frame_sent = 0U;\n\nstatic _frag_desc_t _frag_descs_pool[FRAG_DESCS_POOL_SIZE];\nstatic _frame_queue_t _frame_queue_pool[FRAME_QUEUE_POOL_SIZE];\n\nstatic clist_node_t _frag_descs_free;\nstatic clist_node_t _frame_queue_free;\nstatic clist_node_t _frame_queue;\n\nstatic const gnrc_sixlowpan_frag_sfr_bitmap_t _full_bitmap = { .u32 = UINT32_MAX };\nstatic const gnrc_sixlowpan_frag_sfr_bitmap_t _null_bitmap = { .u32 = 0U };\n\nstatic gnrc_sixlowpan_frag_sfr_stats_t _stats;\n\n/**\n * @brief   Converts a @ref sys_bitmap based bitmap to a\n *          gnrc_sixlowpan_frag_sfr_bitmap_t\n *\n * @param[in] bitmap A @ref sys_bitmap\n *\n * @return  A gnrc_sixlowpan_frag_sfr_bitmap_t.\n */\nstatic inline gnrc_sixlowpan_frag_sfr_bitmap_t *_get_bitmap(gnrc_sixlowpan_frag_rb_t *frag_rb);\n\n/**\n * @brief   Checks if fragment represented by a fragment descriptor requested an\n *          ACK\n */\nstatic inline bool _frag_ack_req(_frag_desc_t *frag);\n/**\n * @brief   Returns sequence number for fragment represented by fragment\n *          descriptor\n */\nstatic inline uint8_t _frag_seq(_frag_desc_t *frag);\n\n/**\n * @brief   Returns fragment size for fragment represented by fragment\n *          descriptor\n */\nstatic inline uint16_t _frag_size(_frag_desc_t *frag);\n\n/**\n * @brief   Cleans up a fragmentation buffer entry and all state related to its\n *          datagram.\n *\n * @param[in] fbuf  A fragmentation buffer entry\n * @param[in] error An errno to provide to an upper layer as the reason for why\n *                  gnrc_sixlowpan_frag_fb_t::pkt of @p fbuf was released.\n */\nstatic void _clean_up_fbuf(gnrc_sixlowpan_frag_fb_t *fbuf, int error);\n\n/**\n * @brief   Send first fragment.\n *\n * @param[in] netif         Network interface to send fragment over\n * @param[in] fbuf          Fragmentation buffer for the datagram to fragment\n * @param[in] page          Current 6Lo dispatch parsing page.\n * @param[in,out] tx_sync   Packet snip used to synchronize with transmission, if gnrc_tx_sync is\n *                          used\n *\n * @return  Size of the fragment\n */\nstatic uint16_t _send_1st_fragment(gnrc_netif_t *netif,\n                                   gnrc_sixlowpan_frag_fb_t *fbuf,\n                                   unsigned page,\n                                   gnrc_pktsnip_t **tx_sync);\n\n/**\n * @brief   Send subsequent fragment.\n *\n * @param[in] netif         Network interface to send fragment over\n * @param[in] fbuf          Fragmentation buffer for the datagram to fragment\n * @param[in] page          Current 6Lo dispatch parsing page.\n * @param[in,out] tx_sync   Packet snip used to synchronize with transmission, if gnrc_tx_sync is\n *                          used\n *\n * @return  Size of the fragment\n */\nstatic uint16_t _send_nth_fragment(gnrc_netif_t *netif,\n                                   gnrc_sixlowpan_frag_fb_t *fbuf,\n                                   unsigned page,\n                                   gnrc_pktsnip_t **tx_sync);\n\n/**\n * @brief   Send a abort pseudo fragment for datagram identified by @p tag\n *\n * @param[in] pkt       Datagram that is to be aborted.\n * @param[in] fbuf      Fragmentation buffer for @p pkt.\n * @param[in] req_ack   Request ACK for pseudo fragment from receive\n * @param[in] page      Current 6Lo dispatch parsing page.\n *\n * @return  true, if abort pseudo fragment was sent.\n * @return  false, if abort pseudo fragment was unable to be sent.\n */\nstatic bool _send_abort_frag(gnrc_pktsnip_t *pkt,\n                             gnrc_sixlowpan_frag_fb_t *fbuf,\n                             bool req_ack, unsigned page);\n\n/**\n * @brief   Adapts currently sent number of fragments to current window size\n *\n * Balances `fbuf->sfr.window` with `fbuf->sfr.congure->cwnd`\n *\n * @param[in] fbuf          Fragmentation buffer to adapt window for\n */\nstatic void _shrink_window(gnrc_sixlowpan_frag_fb_t *fbuf);\n\n/**\n * @brief   Re-send a fragment\n *\n * @param[in] node          The fragment descriptor for the fragment to be\n *                          resend\n * @param[in] fbuf_ptr      Fragmentation buffer for the datagram to fragment\n *\n * Used as a `clist_foreach()` iterator function\n *\n * return true  when fragment was resent\n * return false on error\n */\nstatic int _resend_frag(clist_node_t *node, void *fbuf_ptr);\n\n/**\n * @brief   Retry to send the complete datagram\n *\n * @param[in] fbuf  Fragmentation buffer for the datagram\n */\nstatic void _retry_datagram(gnrc_sixlowpan_frag_fb_t *fbuf);\n\n/**\n * @brief   Cleans up state for the causing RFRAG and optionally also sends an\n *          abort ACK (NULL-bitmap ACK).\n *\n * @param[in] pkt       The packet causing the abort. Will be released\n *                      by this function. gnrc_pktsnip_t::data of @p pkt is\n *                      expected to point to an RFRAG packet.\n * @param[in] entry     (Virtual) reassembly buffer entry to abort.\n * @param[in] netif_hdr NETIF header of @p pkt.\n * @param[in] send_ack  Send an abort ACK.\n */\nstatic void _abort_rb(gnrc_pktsnip_t *pkt, _generic_rb_entry_t *entry,\n                      gnrc_netif_hdr_t *netif_hdr, bool send_ack);\n\n/**\n * @brief   Sends an RFRAG-ACK\n *\n * @param[in] netif     Network interface to send ACK over\n * @param[in] dst       Destination address of ACK.\n * @param[in] dst_len   Length of @p dst.\n * @param[in] rfrag     The RFRAG to ACK\n * @param[in] bitmap    The bitmap for the ACK.\n */\nstatic void _send_ack(gnrc_netif_t *netif, const uint8_t *dst, uint8_t dst_len,\n                      const sixlowpan_sfr_t *rfrag, const uint8_t *bitmap);\n\n/**\n * @brief   Schedule next frame (RFRAG or RFRAG-ACK) with\n *          @ref GNRC_SIXLOWPAN_FRAG_SFR_INTER_FRAG_GAP_MSG\n *\n * @param[in] fbuf      A fragmentation buffer holding the state of the datagram\n *                      and recoverable fragments.\n */\nstatic void _sched_next_frame(gnrc_sixlowpan_frag_fb_t *fbuf);\n\n/**\n * @brief   Schedule ARQ timeout\n *\n * @param[in] fbuf      A fragmentation buffer holding the state of the datagram\n *                      and recoverable fragments.\n * @param[in] offset    Offset for the ARQ timeout in milliseconds.\n */\nstatic void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset);\n\n/**\n * @brief   Schedule ARQ timeout for an abort fragment pseudo fragment\n *\n * @param[in,out] fbuf  A fragmentation buffer. All state information will be\n *                      cleared when called, except for identifying the ACK.\n */\nstatic void _sched_abort_timeout(gnrc_sixlowpan_frag_fb_t *fbuf);\n\n/**\n * @brief   Handle a received RFRAG packet\n *\n * @param[in] netif_hdr NETIF header of @p pkt\n * @param[in] pkt       An RFRAG packet\n * @param[in] page      Current 6Lo dispatch parsing page.\n */\nstatic void _handle_rfrag(gnrc_netif_hdr_t *netif_hdr,\n                          gnrc_pktsnip_t *pkt, unsigned page);\n\n/**\n * @brief   Handle a received RFRAG-ACK\n *\n * @param[in] netif_hdr NETIF header of @p pkt\n * @param[in] pkt       An RFRAG-ACK\n * @param[in] page      Current 6Lo dispatch parsing page.\n */\nstatic void _handle_ack(gnrc_netif_hdr_t *netif_hdr,\n                        gnrc_pktsnip_t *pkt, unsigned page);\n\n/**\n * @brief   Forward a RFRAG\n *\n * @pre `entry->type == _VRB`\n *\n * @param[in] pkt       The RFRAG to forward (without NETIF header)\n * @param[in] entry     The VRB entry to determine the route\n * @param[in] offset    Offset (from the incoming RFRAG's field) of the RFRAG.\n *                      for offset > 0 this will be adapted for the offset\n *                      difference from the first fragment due to recompression\n * @param[in] page      Current 6Lo dispatch parsing page.\n *\n * @return  0 on success,\n * @return  -ENOMEM, when packet buffer is too full to prepare packet for\n *          forwarding. @p pkt is released in that case.\n */\nstatic int _forward_rfrag(gnrc_pktsnip_t *pkt, _generic_rb_entry_t *entry,\n                          uint16_t offset, unsigned page);\n\n/* ====== PUBLIC FUNCTION DEFINITIONS ====== */\nvoid gnrc_sixlowpan_frag_sfr_init(void)\n{\n    /* initialize _arq_timer if not yet done */\n    if (_arq_timer.callback == NULL) {\n        evtimer_init_msg(&_arq_timer);\n    }\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (unsigned i = 0; i < FRAME_QUEUE_POOL_SIZE; i++) {\n            clist_rpush(&_frame_queue_free, &_frame_queue_pool[i].super);\n        }\n    }\n    for (unsigned i = 0; i < FRAG_DESCS_POOL_SIZE; i++) {\n        clist_rpush(&_frag_descs_free, &_frag_descs_pool[i].super.super);\n    }\n}\n\nvoid gnrc_sixlowpan_frag_sfr_send(gnrc_pktsnip_t *pkt, void *ctx,\n                                  unsigned page)\n{\n    gnrc_sixlowpan_frag_fb_t *fbuf = ctx;\n    gnrc_netif_t *netif;\n    int error_no = GNRC_NETERR_SUCCESS;\n    gnrc_pktsnip_t *tx_sync = NULL;\n    uint16_t res;\n\n    assert((fbuf != NULL) && ((fbuf->pkt == pkt) || (pkt == NULL)));\n    DEBUG(\"6lo sfr: (re-)sending fragmented datagram %u\\n\", fbuf->tag);\n    pkt = fbuf->pkt;\n    assert(pkt->type == GNRC_NETTYPE_NETIF);\n    netif = gnrc_netif_hdr_get_netif(pkt->data);\n    assert(netif != NULL);\n\n    if (IS_USED(MODULE_GNRC_TX_SYNC)) {\n        tx_sync = gnrc_tx_sync_split(pkt);\n    }\n\n    if (fbuf->offset == 0) {\n        DEBUG(\"6lo sfr: sending first fragment\\n\");\n        gnrc_sixlowpan_frag_sfr_congure_snd_setup(fbuf);\n        res = _send_1st_fragment(netif, fbuf, page, &tx_sync);\n        if (res == 0) {\n            DEBUG(\"6lo sfr: error sending first fragment\\n\");\n            /* _send_1st_fragment only returns 0 if there is a memory problem */\n            error_no = ENOMEM;\n            goto error;\n        }\n    }\n    else if (!gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf)) {\n        DEBUG(\"6lo sfr: frags_sent not within congestion window: \"\n              \"don't send more\\n\");\n        return;\n    }\n    else if (fbuf->offset < fbuf->datagram_size) {\n        DEBUG(\"6lo sfr: sending subsequent fragment\\n\");\n#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)\n        assert(fbuf->sfr.congure);\n        assert(fbuf->sfr.congure->driver);\n#endif\n        res = _send_nth_fragment(netif, fbuf, page, &tx_sync);\n        if (res == 0) {\n            DEBUG(\"6lo sfr: error sending subsequent fragment (offset = %u)\\n\",\n                  fbuf->offset);\n            /* _send_nth_fragment only returns 0 if there is a memory problem */\n            error_no = ENOMEM;\n            goto error;\n        }\n    }\n    else {\n        /* offset is greater or equal to datagram size\n         * => we are done sending fragments (not an error, but we can release\n         * the fragmentation buffer now) */\n        goto error;\n    }\n    gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf);\n    fbuf->offset += res;\n\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf) &&\n        (fbuf->offset < fbuf->datagram_size) &&\n        !gnrc_sixlowpan_frag_fb_send(fbuf)) {\n        /* the queue of the 6LoWPAN thread is full */\n        error_no = ENOMEM;\n        /* go back offset to not send abort on first fragment */\n        fbuf->offset -= res;\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_discard(fbuf);\n        goto error;\n    }\n    /* check if last fragment sent requested an ACK */\n    _frag_desc_t *frag_desc = (_frag_desc_t *)clist_rpeek(&fbuf->sfr.window);\n    DEBUG(\"6lo sfr: last sent fragment (tag: %u, X: %i, seq: %u, \"\n          \"frag_size: %u, offset: %u)\\n\",\n          (uint8_t)fbuf->tag, _frag_ack_req(frag_desc),\n          _frag_seq(frag_desc), _frag_size(frag_desc),\n          frag_desc->offset);\n    if (_frag_ack_req(frag_desc)) {\n        _sched_arq_timeout(fbuf, fbuf->sfr.arq_timeout);\n    }\n\n    if (IS_USED(MODULE_GNRC_TX_SYNC) && tx_sync) {\n        /* re-attach tx_sync to allow releasing it at end\n         * of transmission, or transmission failure */\n        gnrc_pkt_append(pkt, tx_sync);\n    }\n    thread_yield();\n    return;\nerror:\n    /* don't send abort for first fragment, the network does not know about\n     * the datagram */\n    if ((fbuf->offset > 0) &&\n        _send_abort_frag(fbuf->pkt, fbuf, true, 0)) {\n        /* wait for ACK before fbuf is deleted */\n        _sched_abort_timeout(fbuf);\n    }\n    else {\n        _clean_up_fbuf(fbuf, error_no);\n    }\n    if (IS_USED(MODULE_GNRC_TX_SYNC) && tx_sync) {\n        gnrc_pktbuf_release(tx_sync);\n    }\n}\n\nvoid gnrc_sixlowpan_frag_sfr_recv(gnrc_pktsnip_t *pkt, void *ctx,\n                                  unsigned page)\n{\n    sixlowpan_sfr_t *hdr;\n    gnrc_netif_hdr_t *netif_hdr;\n\n    (void)ctx;\n    DEBUG(\"6lo sfr: received selective fragment forwarding message\\n\");\n    assert(pkt != NULL);\n    hdr = pkt->data;\n    assert(pkt->next != NULL);\n    netif_hdr = pkt->next->data;\n    assert(netif_hdr != NULL);\n    if (page != 0) {\n        DEBUG(\"6lo sfr: Invalid page %u\\n\", page);\n        gnrc_pktbuf_release(pkt);\n    }\n    else if (sixlowpan_sfr_rfrag_is(hdr)) {\n        _handle_rfrag(netif_hdr, pkt, page);\n    }\n    else if (sixlowpan_sfr_ack_is(hdr)) {\n        _handle_ack(netif_hdr, pkt, page);\n    }\n    else {\n        DEBUG(\"6lo sfr: Unknown dispatch: %02x\\n\",\n              hdr->disp_ecn & SIXLOWPAN_SFR_DISP_MASK);\n        gnrc_pktbuf_release(pkt);\n    }\n}\n\nint gnrc_sixlowpan_frag_sfr_forward(gnrc_pktsnip_t *pkt,\n                                    sixlowpan_sfr_rfrag_t *rfrag,\n                                    gnrc_sixlowpan_frag_vrb_t *vrbe,\n                                    unsigned page)\n{\n    _generic_rb_entry_t entry = { .type = _VRB, .entry = { .vrb = vrbe } };\n    gnrc_pktsnip_t *hdrsnip = gnrc_pktbuf_add(pkt, rfrag, sizeof(*rfrag),\n                                              GNRC_NETTYPE_SIXLOWPAN);\n\n    /* free all intervals associated to the VRB entry, as we don't need them\n     * with SFR, so throw them out, to save this resource */\n    while (vrbe->super.ints) {\n        vrbe->super.ints->end = 0U;\n        vrbe->super.ints = vrbe->super.ints->next;\n    }\n    if (hdrsnip == NULL) {\n        DEBUG(\"6lo sfr: Unable to allocate new rfrag header\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ENOMEM;\n    }\n    DEBUG(\"6lo sfr: adapting old fragment size (%u) for forwarding to %u\\n\",\n          sixlowpan_sfr_rfrag_get_frag_size(hdrsnip->data),\n          (unsigned)gnrc_pkt_len(pkt));\n    /* due to compression, packet length of the original fragment might have\n     * changed */\n    sixlowpan_sfr_rfrag_set_frag_size(hdrsnip->data, gnrc_pkt_len(pkt));\n    /* offset is adapted in `_forward_rfrag()` */\n    return _forward_rfrag(hdrsnip, &entry, sixlowpan_sfr_rfrag_get_offset(rfrag),\n                          page);\n}\n\nstatic int _report_non_ack_req_window_sent(clist_node_t *node, void *fbuf_ptr)\n{\n    _frag_desc_t *frag_desc = (_frag_desc_t *)node;\n    if (!_frag_ack_req(frag_desc)) {\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf_ptr);\n    }\n    return 0;\n}\n\nvoid gnrc_sixlowpan_frag_sfr_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    uint32_t now = xtimer_now_usec() / US_PER_MS;\n    _frag_desc_t *frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;\n    uint32_t next_arq_offset = fbuf->sfr.arq_timeout;\n    bool reschedule_arq_timeout = false;\n    int error_no = ETIMEDOUT;   /* assume time out for fbuf->pkt */\n\n    DEBUG(\"6lo sfr: ARQ timeout for datagram %u\\n\", fbuf->tag);\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        /* mock-up to emulate time having passed beyond (1us) the ARQ timeout */\n        now -= (fbuf->sfr.arq_timeout * US_PER_MS) + 1;\n    }\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) && frag_desc) {\n        /* report timeout to CongURE state */\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_timeout(fbuf);\n        _shrink_window(fbuf);   /* potentially shrink window */\n        /* reassign frag_desc, in case window head changed */\n        frag_desc = (_frag_desc_t *)fbuf->sfr.window.next;\n    }\n    /* copying clist_foreach because we can't work just in function context */\n    _frag_desc_t * const head = frag_desc;\n    if (frag_desc) {\n        do {\n            uint32_t diff;\n\n            frag_desc = (_frag_desc_t *)frag_desc->super.super.next;\n            diff = now - frag_desc->super.send_time;\n            if (diff < fbuf->sfr.arq_timeout) {\n                /* this fragment's last was last sent < fbuf->sfr.arq_timeout\n                 * ago */\n                uint32_t offset = fbuf->sfr.arq_timeout - diff;\n\n                DEBUG(\"6lo sfr: wait for fragment %u in next reschedule\\n\",\n                      _frag_seq(frag_desc));\n                if (offset < next_arq_offset) {\n                    /* wait for this fragments ACK next */\n                    next_arq_offset = offset;\n                    DEBUG(\"         (next ARQ timeout in %lu)\\n\",\n                          (long unsigned)next_arq_offset);\n                }\n                /* this fragment is still waiting for its ACK,\n                 * reschedule the next ACK timeout to the difference\n                 * of the ACK timeout and the time of its last send */\n                reschedule_arq_timeout = true;\n            }\n            else if (_frag_ack_req(frag_desc)) {\n                /* for this fragment we requested an ACK which was not received\n                 * yet. Try to resend it */\n                if ((frag_desc->super.resends++) < CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES) {\n                    /* we have retries left for this fragment */\n                    DEBUG(\"6lo sfr: %u retries left for fragment (tag: %u, \"\n                          \"X: %i, seq: %u, frag_size: %u, offset: %u)\\n\",\n                          CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES -\n                          (frag_desc->super.resends - 1), (uint8_t)fbuf->tag,\n                          _frag_ack_req(frag_desc), _frag_seq(frag_desc),\n                          _frag_size(frag_desc), frag_desc->offset);\n                    if (_resend_frag(&frag_desc->super.super, fbuf) != 0) {\n                        /* _resend_frag failed due to a memory resource\n                         * problem */\n                        error_no = ENOMEM;\n                        goto error;\n                    }\n                    else {\n                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {\n                            /* fragment was resent successfully, report this to CongURE state\n                             * object */\n                            gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf);\n                        }\n                        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                            /* fragment was resent successfully, note this done\n                             * in the statistics */\n                            _stats.fragment_resends.by_timeout++;\n                        }\n                    }\n                    /* fragment was resent successfully, schedule next ACK\n                     * timeout */\n                    reschedule_arq_timeout = true;\n                }\n                else {\n                    /* out of retries */\n                    DEBUG(\"6lo sfr: no retries left for fragment \"\n                          \"(tag: %u, X: %i, seq: %u, frag_size: %u, \"\n                          \"offset: %u)\\n\",\n                          (uint8_t)fbuf->tag, _frag_ack_req(frag_desc),\n                          _frag_seq(frag_desc), _frag_size(frag_desc),\n                          frag_desc->offset);\n                    /* we are out of retries on the fragment level, but we\n                     * might be able to retry the datagram if retries for the\n                     * datagram are configured. */\n                    _retry_datagram(fbuf);\n                    return;\n                }\n            }\n            else {\n                /* Do not resend fragments that were not explicitly asking for\n                 * an ACK from the reassembling endpoint on ACK timeout.\n                 * If this is true for all fragments remaining in the fragment\n                 * buffer, the datagram is to be considered timed out, so\n                 * error_no should remain ETIMEDOUT */\n                DEBUG(\"6lo sfr: nothing to do for fragment %u\\n\",\n                      _frag_seq(frag_desc));\n            }\n        } while (frag_desc != head);\n        /* report all non-ack_req fragments in window also as sent, since even\n         * the lost fragments are still in flight (even though they were\n         * previously marked as timed out) */\n        clist_foreach(&fbuf->sfr.window, _report_non_ack_req_window_sent, fbuf);\n    }\n    else {\n        /* No fragments to resend, we can assume the packet was delivered\n         * successfully */\n        error_no = GNRC_NETERR_SUCCESS;\n    }\n    assert(fbuf->sfr.frags_sent == clist_count(&fbuf->sfr.window));\n    if (reschedule_arq_timeout) {\n        _sched_arq_timeout(fbuf, next_arq_offset);\n        return;\n    }\nerror:\n    /* don't check return value, as we don't want to wait for an ACK again ;-) */\n    _send_abort_frag(fbuf->pkt, fbuf, false, 0);\n    _clean_up_fbuf(fbuf, error_no);\n}\n\nvoid gnrc_sixlowpan_frag_sfr_inter_frame_gap(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        _frame_queue_t *node = (_frame_queue_t *)clist_lpop(&_frame_queue);\n\n        if (node != NULL) {\n            _last_frame_sent = xtimer_now_usec();\n            gnrc_sixlowpan_dispatch_send(node->frame, NULL, node->page);\n            /* unset packet just to be safe */\n            node->frame = NULL;\n            clist_rpush(&_frame_queue_free, &node->super);\n        }\n        if (clist_lpeek(&_frame_queue) != NULL) {\n            _sched_next_frame(fbuf);\n        }\n    }\n}\n\nvoid gnrc_sixlowpan_frag_sfr_stats_get(gnrc_sixlowpan_frag_sfr_stats_t *stats)\n{\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n        *stats = _stats;\n    }\n}\n\n/* ====== INTERNAL FUNCTION DEFINITIONS ====== */\nstatic inline uint16_t _min(uint16_t a, size_t b)\n{\n    return (a < b) ? a : (uint16_t)b;\n}\n\nstatic inline kernel_pid_t _getpid(void)\n{\n    /* in production, only the 6LoWPAN thread is supposed to call the API\n     * functions, so just get the current thread's PID for sending messages.\n     * When testing, those functions might however be called by the testing\n     * thread (usually the main thread), so indirect over the 6LoWPAN thread in\n     * that case */\n    return IS_ACTIVE(TEST_SUITES) ? gnrc_sixlowpan_get_pid() : thread_getpid();\n}\n\n/*\n * @brief   Returns the datagram in @p fbuf to its original state\n *\n * This function can be both used to clean up the fragmentation buffer on\n * failure without releasing @p fbuf's gnrc_sixlowpan_frag_fb_t::pkt and to\n * reset a datagram for a datagram retry.\n *\n * @param[in]   fbuf    The fragmentation buffer entry to clean up\n */\nstatic void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    clist_node_t new_queue = { .next = NULL };\n\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    /* remove potentially scheduled timers for this datagram */\n    evtimer_del((evtimer_t *)(&_arq_timer),\n                &fbuf->sfr.arq_timeout_event.event);\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (clist_node_t *node = clist_lpop(&_frame_queue);\n             node != NULL; node = clist_lpop(&_frame_queue)) {\n            _frame_queue_t *entry = (_frame_queue_t *)node;\n            /* remove frames of this datagram from frame queue */\n            if (entry->datagram_tag == fbuf->tag) {\n                gnrc_pktbuf_release(entry->frame);\n                /* unset packet just to be safe */\n                entry->frame = NULL;\n                clist_rpush(&_frag_descs_free, node);\n            }\n            else {\n                clist_rpush(&new_queue, node);\n            }\n        }\n        /* reset frame queue with remaining frames */\n        _frame_queue = new_queue;\n    }\n    fbuf->offset = 0U;\n    fbuf->sfr.cur_seq = 0U;\n    fbuf->sfr.frags_sent = 0U;\n    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n        clist_rpush(&_frag_descs_free, node);\n    }\n}\n\nstatic gnrc_pktsnip_t *_build_rfrag(uint8_t tag, bool ack_req, uint16_t size,\n                                    uint8_t seq)\n{\n    sixlowpan_sfr_rfrag_t *hdr;\n    gnrc_pktsnip_t *frag = gnrc_pktbuf_add(NULL, NULL,\n                                           sizeof(sixlowpan_sfr_rfrag_t) +\n                                           size, GNRC_NETTYPE_SIXLOWPAN);\n\n    if (frag == NULL) {\n        return NULL;\n    }\n    sixlowpan_sfr_rfrag_set_disp(frag->data);\n\n    hdr = frag->data;\n    hdr->base.tag = tag;\n    if (ack_req) {\n        sixlowpan_sfr_rfrag_set_ack_req(hdr);\n    }\n    else {\n        sixlowpan_sfr_rfrag_clear_ack_req(hdr);\n    }\n    sixlowpan_sfr_rfrag_set_frag_size(hdr, size);\n    sixlowpan_sfr_rfrag_set_seq(hdr, seq);\n    /* set offset / datagram_size in callers */\n    return frag;\n}\n\nstatic gnrc_pktsnip_t *_build_frag_pkt(gnrc_netif_hdr_t *old_netif_hdr,\n                                       uint8_t tag, bool ack_req, uint16_t size,\n                                       uint8_t seq)\n{\n    gnrc_netif_hdr_t *new_netif_hdr;\n    gnrc_pktsnip_t *netif, *res;\n\n    DEBUG(\"6lo sfr: building fragment (tag: %u, X: %i, seq: %u, frag_size: %u)\\n\",\n           tag, ack_req, seq, size);\n    netif = gnrc_netif_hdr_build(gnrc_netif_hdr_get_src_addr(old_netif_hdr),\n                                 old_netif_hdr->src_l2addr_len,\n                                 gnrc_netif_hdr_get_dst_addr(old_netif_hdr),\n                                 old_netif_hdr->dst_l2addr_len);\n    if (netif == NULL) {\n        return NULL;\n    }\n\n    new_netif_hdr = netif->data;\n    *new_netif_hdr = *old_netif_hdr;\n    res = _build_rfrag(tag, ack_req, size, seq);\n    if (res == NULL) {\n        gnrc_pktbuf_release(netif);\n        return NULL;\n    }\n    return gnrc_pkt_prepend(res, netif);\n}\n\nstatic gnrc_pktsnip_t *_build_frag_from_fbuf(gnrc_pktsnip_t *pkt,\n                                             gnrc_sixlowpan_frag_fb_t *fbuf,\n                                             uint16_t frag_size)\n{\n    return _build_frag_pkt(pkt->data, (uint8_t)fbuf->tag,\n                           ((frag_size + fbuf->offset) >= fbuf->datagram_size) ||\n                           /* we only can send the next fragment we build here,\n                            * so request ACK for it */\n                           !gnrc_sixlowpan_frag_sfr_congure_snd_next_in_cwnd(fbuf),\n                           frag_size, fbuf->sfr.cur_seq);\n}\n\nstatic uint16_t _copy_pkt_to_frag(uint8_t *data, const gnrc_pktsnip_t *pkt,\n                                  uint16_t frag_size, uint16_t init_offset)\n{\n    uint16_t offset = init_offset;\n\n    while ((pkt != NULL) && (offset < frag_size)) {\n        uint16_t len = _min(frag_size - offset, pkt->size);\n\n        memcpy(data + offset, pkt->data, len);\n\n        offset += len;\n        pkt = pkt->next;\n    }\n    return offset;\n}\n\nstatic uint16_t _find_offset_and_copy_rest(uint8_t *data, gnrc_pktsnip_t **pkt,\n                                           uint16_t frag_size,\n                                           uint16_t offset)\n{\n    uint16_t offset_count = 0, cur_frag_size = 0;\n    while ((*pkt != NULL) && (offset_count != offset)) {     /* go to offset */\n        uint16_t pkt_size = (uint16_t)(*pkt)->size;\n        offset_count += pkt_size;\n\n        if (offset_count > offset) {                        /* we overshot */\n            /* => copy rest of partly send packet snip */\n            uint16_t pkt_offset = offset - (offset_count - pkt_size);\n            size_t clen = _min(frag_size, pkt_size - pkt_offset);\n\n            memcpy(data, ((uint8_t *)(*pkt)->data) + pkt_offset, clen);\n            cur_frag_size = clen;\n            *pkt = (*pkt)->next;\n            break;\n        }\n        *pkt = (*pkt)->next;\n    }\n    return cur_frag_size;\n}\n\nstatic void _check_for_ecn(gnrc_pktsnip_t *frame)\n{\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN) &&\n        (sixlowpan_sfr_rfrag_is(frame->next->data))) {\n        int queue_state = 0;\n        int queue_size = 0;\n\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN_IF_IN)) {\n            gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(frame->data);\n\n            assert(frame->type == GNRC_NETTYPE_NETIF);\n            assert(frame->next->type == GNRC_NETTYPE_SIXLOWPAN);\n            queue_state = msg_avail_thread(netif->pid);\n            queue_size = msg_queue_capacity(netif->pid);\n            assert(queue_size > 0);\n\n            if ((queue_state * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_IN_DEN) >\n                (queue_size * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_IN_NUM)) {\n                sixlowpan_sfr_set_ecn(frame->next->data);\n            }\n        }\n\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN_IF_OUT)) {\n            queue_state = gnrc_netif_pktq_usage();\n            queue_size = CONFIG_GNRC_NETIF_PKTQ_POOL_SIZE;\n\n            if ((queue_state * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_OUT_DEN) >\n                (queue_size * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_OUT_NUM)) {\n                sixlowpan_sfr_set_ecn(frame->next->data);\n            }\n        }\n\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN_FQUEUE)) {\n            queue_state = clist_count(&_frame_queue);\n            queue_size = FRAME_QUEUE_POOL_SIZE;\n\n            if ((queue_state * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_FQUEUE_DEN) >\n                (queue_size * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_FQUEUE_NUM)) {\n                sixlowpan_sfr_set_ecn(frame->next->data);\n            }\n        }\n    }\n}\n\nstatic bool _send_frame(gnrc_pktsnip_t *frame, gnrc_sixlowpan_frag_fb_t *fbuf,\n                        void *ctx, unsigned page)\n{\n    uint32_t now;\n    uint32_t if_gap = gnrc_sixlowpan_frag_sfr_congure_snd_inter_frame_gap(fbuf);\n\n    _check_for_ecn(frame);\n    now = xtimer_now_usec();\n    if ((if_gap == 0) || ((now - _last_frame_sent) > if_gap)) {\n        DEBUG(\"6lo sfr: dispatch frame to network interface\\n\");\n        _last_frame_sent = now;\n        gnrc_sixlowpan_dispatch_send(frame, ctx, page);\n        return true;\n    }\n    else {\n        _frame_queue_t *node = (_frame_queue_t *)clist_lpop(&_frame_queue_free);\n\n        if (node != NULL) {\n            sixlowpan_sfr_t *hdr = frame->next->data;\n\n            assert(sixlowpan_sfr_is(hdr));\n            node->frame = frame;\n            node->datagram_tag = hdr->tag;\n            node->page = page;\n            clist_rpush(&_frame_queue, &node->super);\n            _sched_next_frame(fbuf);\n        }\n        return (node != NULL);\n    }\n}\n\nstatic bool _send_fragment(gnrc_pktsnip_t *frag, gnrc_sixlowpan_frag_fb_t *fbuf,\n                           unsigned page, uint16_t offset)\n{\n    sixlowpan_sfr_rfrag_t *hdr = frag->next->data;\n    _frag_desc_t *frag_desc = (_frag_desc_t *)clist_lpop(&_frag_descs_free);\n    bool res;\n\n    if (frag_desc == NULL) {\n        DEBUG(\"6lo sfr: could not remember fragment to send\\n\");\n        gnrc_pktbuf_release(frag);\n        return false;\n    }\n    frag_desc->ar_seq_fs = byteorder_ntohs(hdr->ar_seq_fs);\n    frag_desc->offset = offset;\n    frag_desc->super.size = 1;\n    frag_desc->super.resends = 0;\n    clist_rpush(&fbuf->sfr.window, &frag_desc->super.super);\n    if ((res = _send_frame(frag, fbuf, NULL, page))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.fragments_sent.usual++;\n        }\n        frag_desc->super.send_time = _last_frame_sent / US_PER_MS;\n        fbuf->sfr.cur_seq++;\n        fbuf->sfr.frags_sent++;\n    }\n    return res;\n}\n\nstatic gnrc_pktsnip_t *_build_ack(gnrc_netif_t *netif,\n                                  const uint8_t *dst, uint8_t dst_len,\n                                  const sixlowpan_sfr_t *hdr,\n                                  const uint8_t *bitmap)\n{\n    gnrc_pktsnip_t *ack_snip, *ack_netif;\n    sixlowpan_sfr_ack_t *ack;\n\n    ack_netif = gnrc_netif_hdr_build(NULL, 0, dst, dst_len);\n    if (ack_netif == NULL) {\n        DEBUG(\"6lo sfr: can't allocate netif header for ACK for (%s, %02x).\\n\",\n              gnrc_netif_addr_to_str(dst, dst_len, addr_str), hdr->tag);\n        return NULL;\n    }\n    gnrc_netif_hdr_set_netif(ack_netif->data, netif);\n\n    ack_snip = gnrc_pktbuf_add(NULL, NULL, sizeof(sixlowpan_sfr_ack_t),\n                               GNRC_NETTYPE_SIXLOWPAN);\n\n    if (ack_snip == NULL) {\n        DEBUG(\"6lo sfr: can't allocate ACK for (%s, %02x).\\n\",\n              gnrc_netif_addr_to_str(dst, dst_len, addr_str), hdr->tag);\n        gnrc_pktbuf_release(ack_netif);\n        return NULL;\n    }\n    ack = ack_snip->data;\n    /* https://tools.ietf.org/html/rfc8931#section-6:\n     * The Datagram_Tag in the RFRAG_ACK is unique to the reassembling endpoint\n     * and is enough information for an intermediate hop to locate the VRB that\n     * contains the Datagram_Tag used by the previous hop and the Layer-2\n     * information associated with it (interface and Link-Layer address)..\n     * [...] The reassembling endpoint of a fragment with the 'E' (ECN) flag set\n     * MUST echo that information at most once by setting the 'E' (ECN) flag in\n     * the next RFRAG_ACK.\n     *\n     * => base except dispatch are the same as ack'd RFRAG.\n     */\n    ack->base = *hdr;\n    sixlowpan_sfr_ack_set_disp(&ack->base);\n    memcpy(ack->bitmap, bitmap, sizeof(ack->bitmap));\n    ack_netif->next = ack_snip;\n    return ack_netif;\n}\n\nstatic void _clean_up_rb_entry(_generic_rb_entry_t *entry)\n{\n    if (entry != NULL) {\n        switch (entry->type) {\n            case _RB:\n                gnrc_pktbuf_release(entry->entry.rb->pkt);\n                gnrc_sixlowpan_frag_rb_remove(entry->entry.rb);\n                break;\n            case _VRB:\n                gnrc_sixlowpan_frag_vrb_rm(entry->entry.vrb);\n                break;\n            default:\n                break;\n        }\n    }\n}\n\nstatic void _try_reassembly(gnrc_netif_hdr_t *netif_hdr,\n                            gnrc_pktsnip_t *rfrag, unsigned offset,\n                            _generic_rb_entry_t *entry,\n                            unsigned page)\n{\n    gnrc_sixlowpan_frag_vrb_t *vrbe;\n    const gnrc_sixlowpan_frag_sfr_bitmap_t *bitmap;\n    sixlowpan_sfr_rfrag_t *hdr = rfrag->data;\n    gnrc_pktsnip_t *netif_snip = rfrag->next;\n    /* copy base for ACK */\n    sixlowpan_sfr_t base = hdr->base;\n    int8_t ack_req = sixlowpan_sfr_rfrag_ack_req(hdr);\n    uint8_t seq = sixlowpan_sfr_rfrag_get_seq(hdr);\n\n    assert(netif_snip->data == netif_hdr);\n    gnrc_pktbuf_hold(netif_snip, 1);    /* hold netif header to use it with\n                                         * dispatch_when_complete()\n                                         * (rb_add() releases `pkt`) */\n    entry->entry.rb = gnrc_sixlowpan_frag_rb_add(netif_hdr, rfrag,\n                                                 offset, page);\n    /* check if VRB entry was created */\n    vrbe = gnrc_sixlowpan_frag_vrb_get(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                       netif_hdr->src_l2addr_len, base.tag);\n    if ((entry->entry.rb == NULL) && (vrbe == NULL)) {\n        DEBUG(\"6lo sfr: can't allocate reassembly buffer or forward compressed \"\n              \"fragment\\n\");\n        /* send abort */\n        bitmap = &_null_bitmap;\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.acks.aborts++;\n        }\n    }\n    else if (vrbe != NULL) {\n        DEBUG(\"6lo sfr: packet was forwarded\\n\");\n        goto end;\n    }\n    else {\n        int res;\n\n        DEBUG(\"6lo sfr: reassembling datagram (%s, %u)\\n\",\n              gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                     netif_hdr->src_l2addr_len, addr_str),\n              base.tag);\n        entry->type = _RB;\n        bf_set(entry->entry.rb->received, seq);\n        if ((res = gnrc_sixlowpan_frag_rb_dispatch_when_complete(entry->entry.rb,\n                                                                 netif_hdr)) < 0) {\n            DEBUG(\"6lo sfr: can not dispatch datagram to upper layer\\n\");\n            _clean_up_rb_entry(entry);\n            /* send abort */\n            bitmap = &_null_bitmap;\n            if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                _stats.acks.aborts++;\n            }\n        }\n        else {\n            if (res) {\n                DEBUG(\"6lo sfr: dispatched datagram to upper layer\\n\");\n                bitmap = &_full_bitmap;\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                    _stats.acks.full++;\n                }\n            }\n            else if (ack_req) {\n                DEBUG(\"6lo sfr: ACKing received fragments %02X%02X%02X%02X \"\n                      \"(%u of %u bytes received)\\n\",\n                      entry->entry.rb->received[0],\n                      entry->entry.rb->received[1],\n                      entry->entry.rb->received[2],\n                      entry->entry.rb->received[3],\n                      entry->entry.base->current_size,\n                      entry->entry.base->datagram_size);\n                bitmap = _get_bitmap(entry->entry.rb);\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n                    _stats.acks.partly++;\n                }\n            }\n            else {\n                /* no ACK was requested and no error was causing an abort ACK*/\n                DEBUG(\"6lo sfr: no ACK requested by received fragment %u \"\n                      \"(bitmap so far: %02X%02X%02X%02X)\\n\", seq,\n                      entry->entry.rb->received[0],\n                      entry->entry.rb->received[1],\n                      entry->entry.rb->received[2],\n                      entry->entry.rb->received[3]);\n                goto end;\n            }\n        }\n    }\n    _send_ack(gnrc_netif_hdr_get_netif(netif_hdr),\n              gnrc_netif_hdr_get_src_addr(netif_hdr),\n              netif_hdr->src_l2addr_len, &base, bitmap->bf);\nend:\n    gnrc_pktbuf_release(netif_snip);    /* release hold */\n}\n\nstatic void _forward_uncomp(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                            unsigned page, _generic_rb_entry_t *entry,\n                            void *payload)\n{\n    sixlowpan_sfr_rfrag_t *hdr = pkt->data;\n    gnrc_sixlowpan_frag_rb_base_t vrb_base = {\n        .src_len = netif_hdr->src_l2addr_len,\n        .tag = hdr->base.tag,\n        .datagram_size = sixlowpan_sfr_rfrag_get_offset(hdr),\n    };\n    gnrc_pktsnip_t tmp = {\n        .data = payload,\n        .size = pkt->size - sizeof(sixlowpan_sfr_rfrag_t) - 1,\n        .users = 1,\n    };\n\n    switch (page) {\n#if defined(MODULE_GNRC_IPV6)\n        case 0: {\n            ipv6_hdr_t *ipv6_hdr = tmp.data;\n\n            if (ipv6_hdr->hl <= 1) {\n                DEBUG(\"6lo sfr: minimal hop-limit reached\\n\");\n                /* try to reassemble to hand to IPv6 module for error\n                 * handling */\n                _try_reassembly(netif_hdr, pkt, 0, entry, page);\n                return;\n            }\n            tmp.type = GNRC_NETTYPE_IPV6;\n            break;\n        }\n#endif\n        default:\n            tmp.type = GNRC_NETTYPE_UNDEF;\n            break;\n    }\n    vrb_base.arrival = xtimer_now_usec();\n    memcpy(vrb_base.src, gnrc_netif_hdr_get_src_addr(netif_hdr),\n           vrb_base.src_len);\n    entry->entry.vrb = gnrc_sixlowpan_frag_vrb_from_route(&vrb_base,\n                                                          NULL, &tmp);\n    if (entry->entry.vrb == NULL) {\n        DEBUG(\"6lo sfr: no route found or no VRB space left, \"\n              \"trying reassembly\\n\");\n        _try_reassembly(netif_hdr, pkt, 0, entry, page);\n        return;\n    }\n    /* only decrement hop-limit after check in case we reassemble */\n    switch (page) {\n#if defined(MODULE_GNRC_IPV6)\n        case 0: {\n            ipv6_hdr_t *ipv6_hdr = tmp.data;\n\n            ipv6_hdr->hl--;\n            break;\n        }\n#endif\n        default:\n            break;\n    }\n    entry->type = _VRB;\n    entry->entry.vrb->in_netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    entry->entry.vrb->offset_diff = 0; /* packet is uncompressed so offset\n                                        * does not change */\n    _forward_rfrag(pkt, entry, sixlowpan_sfr_rfrag_get_offset(hdr), page);\n}\n\nstatic void _handle_1st_rfrag(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                              unsigned page, _generic_rb_entry_t *entry)\n{\n    sixlowpan_sfr_rfrag_t *hdr = pkt->data;\n    /* https://tools.ietf.org/html/rfc8931#section-5.1:\n     *   +  For a first fragment (i.e. with a Sequence of 0), this field\n     *      indicates the datagram_size of the compressed datagram, [...] */\n    uint16_t datagram_size = sixlowpan_sfr_rfrag_get_offset(hdr);\n    uint8_t fragment_size = sixlowpan_sfr_rfrag_get_frag_size(hdr);\n    uint8_t *payload;\n\n    if ((datagram_size == 0) && (fragment_size == 0)) {\n        /* the received fragment is a pseudo-fragment that signals an abort\n         * condition by the fragmenting end-point, release state on the\n         * datagram */\n        bool release_pkt = true;\n\n        DEBUG(\"6lo sfr: Abort for datagram (%s, %u) received\\n\",\n              gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                     netif_hdr->src_l2addr_len, addr_str),\n              hdr->base.tag);\n        if ((entry->entry.vrb = gnrc_sixlowpan_frag_vrb_get(\n                gnrc_netif_hdr_get_src_addr(netif_hdr),\n                netif_hdr->src_l2addr_len, hdr->base.tag)) != NULL) {\n            /* we have a VRB on the aborted datagram. Release it */\n            entry->type = _VRB;\n            _forward_rfrag(pkt, entry, 0, page);\n            gnrc_sixlowpan_frag_vrb_rm(entry->entry.vrb);\n            release_pkt = false;\n        }\n        if ((entry->entry.rb = gnrc_sixlowpan_frag_rb_get_by_datagram(\n                netif_hdr, hdr->base.tag)) != NULL) {\n            /* we have a reassembly buffer entry on the aborted datagram.\n             * Release it */\n            entry->type = _RB;\n            _abort_rb(pkt, entry, netif_hdr, sixlowpan_sfr_rfrag_ack_req(hdr));\n            release_pkt = false;\n        }\n        if (release_pkt) {\n            DEBUG(\"6lo sfr: received abort for unknown datagram\\n\");\n            /* neither VRB or RB exists so we don't have any state on the\n             * aborted datagram left. Just release the abort pseudo fragment */\n            gnrc_pktbuf_release(pkt);\n        }\n        return;\n    }\n    DEBUG(\"6lo sfr: First fragment (%s, %u) received\\n\",\n          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                 netif_hdr->src_l2addr_len, addr_str),\n          hdr->base.tag);\n\n    payload = (uint8_t *)(hdr + 1);\n    if (payload[0] == SIXLOWPAN_UNCOMP) {\n        _forward_uncomp(netif_hdr, pkt, page, entry, payload + 1);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&\n            sixlowpan_iphc_is(payload)) {\n            _try_reassembly(netif_hdr, pkt, 0, entry, page);\n            return;\n        }\n        DEBUG(\"6lo sfr: unable to parse next dispatch for forwarding \"\n              \"information. Abort\\n\");\n        _abort_rb(pkt, entry, netif_hdr, false);\n        return;\n    }\n}\n\nstatic void _handle_nth_rfrag(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                              unsigned page, _generic_rb_entry_t *entry)\n{\n    sixlowpan_sfr_rfrag_t *hdr = pkt->data;\n    uint16_t offset = sixlowpan_sfr_rfrag_get_offset(hdr);\n\n    DEBUG(\"6lo sfr: Subsequent fragment (%s, %u) received\\n\",\n          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                 netif_hdr->src_l2addr_len, addr_str),\n          hdr->base.tag);\n    if (gnrc_sixlowpan_frag_rb_exists(netif_hdr, hdr->base.tag)) {\n        DEBUG(\"6lo sfr: I am destination endpoint => adding to reassembly \"\n              \"buffer\\n\");\n        _try_reassembly(netif_hdr, pkt, offset, entry, page);\n    }\n    else if ((entry->entry.vrb = gnrc_sixlowpan_frag_vrb_get(\n            gnrc_netif_hdr_get_src_addr(netif_hdr),\n            netif_hdr->src_l2addr_len, hdr->base.tag)) != NULL) {\n        entry->type = _VRB;\n        entry->entry.base->arrival = xtimer_now_usec();\n        _forward_rfrag(pkt, entry, offset, page);\n    }\n    else {\n        DEBUG(\"6lo sfr: neither VRB nor RB found\\n\");\n        /* always send abort ACK:\n         * https://tools.ietf.org/html/rfc8931#section-6.1.2 */\n        _abort_rb(pkt, entry, netif_hdr, true);\n    }\n}\n\nstatic int _resend_failed_frag(clist_node_t *node, void *fbuf_ptr)\n{\n    int res = _resend_frag(node, fbuf_ptr);\n\n    if (res == 0) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.fragment_resends.by_nack++;\n        }\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_sent(fbuf_ptr);\n    }\n    return res;\n}\n\nstatic void _check_failed_frags(sixlowpan_sfr_ack_t *ack,\n                                gnrc_sixlowpan_frag_fb_t *fbuf,\n                                uint32_t ack_recv_time)\n{\n    _frag_desc_t *frag_desc;\n    clist_node_t not_received = { .next = NULL };\n    ztimer_now_t earliest_send = UINT32_MAX;\n\n    DEBUG(\"6lo sfr: checking which fragments to resend for datagram %u\\n\",\n          fbuf->tag);\n    for (frag_desc = (_frag_desc_t *)clist_lpop(&fbuf->sfr.window);\n         frag_desc != NULL;\n         frag_desc = (_frag_desc_t *)clist_lpop(&fbuf->sfr.window)) {\n        uint8_t seq;\n\n        seq = _frag_seq(frag_desc);\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) &&\n            (earliest_send > frag_desc->super.send_time)) {\n            earliest_send = frag_desc->super.send_time;\n        }\n        if (bf_isset(ack->bitmap, seq)) {\n            DEBUG(\"6lo sfr: fragment %u (offset: %u, frag_size: %u) \"\n                  \"for datagram %u was received\\n\", seq,\n                  frag_desc->offset, _frag_size(frag_desc), fbuf->tag);\n            fbuf->sfr.frags_sent--;\n            clist_rpush(&_frag_descs_free, &frag_desc->super.super);\n            if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {\n                congure_snd_ack_t ack = {\n                    .recv_time = ack_recv_time,\n                    .id = seq,\n                    .clean = 1U,\n                };\n                gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_acked(\n                    fbuf, &frag_desc->super, &ack\n                );\n            }\n        }\n        else {\n            DEBUG(\"6lo sfr: fragment %u (offset: %u, frag_size: %u) \"\n                  \"for datagram %u was not received\\n\", seq,\n                  frag_desc->offset, _frag_size(frag_desc), fbuf->tag);\n            if ((frag_desc->super.resends++) < CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES) {\n                DEBUG(\"6lo sfr: %u retries left\\n\",\n                      CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES -\n                      (frag_desc->super.resends - 1));\n                /* put fragment in \"not received\" list */\n                clist_rpush(&not_received, &frag_desc->super.super);\n                frag_desc->ar_seq_fs &= ~(SIXLOWPAN_SFR_ACK_REQ << 8U);\n            }\n            else {\n                DEBUG(\"6lo sfr: no more retries for fragment %u\\n\", seq);\n                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) &&\n                    IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_USE_ECN) &&\n                    sixlowpan_sfr_ecn(&ack->base)) {\n                    gnrc_sixlowpan_frag_sfr_congure_snd_report_ecn(\n                        fbuf, earliest_send\n                    );\n                }\n                clist_rpush(&_frag_descs_free, &frag_desc->super.super);\n                /* retry to resend whole datagram */\n                _retry_datagram(fbuf);\n                return;\n            }\n        }\n    }\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) &&\n        sixlowpan_sfr_ecn(&ack->base)) {\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_ecn(fbuf, earliest_send);\n    }\n    /* all fragments were received of the current window were received and\n     * the datagram was transmitted completely */\n    if ((clist_lpeek(&not_received) == NULL) &&\n        (fbuf->offset == fbuf->datagram_size)) {\n        /* release fragmentation buffer */\n        _clean_up_fbuf(fbuf, GNRC_NETERR_SUCCESS);\n    }\n    /* at least one fragment was not received */\n    else {\n        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_lost(\n            fbuf,\n            (congure_snd_msg_t *)&not_received\n        );\n        fbuf->sfr.window = not_received;\n        _shrink_window(fbuf);\n        assert(fbuf->sfr.frags_sent == clist_count(&fbuf->sfr.window));\n        /* use _resend_failed_frag here instead of loop above, so\n         * _resend_frag can know if the fragment is the last in the window by\n         * using clist_rpeek() on fbuf->sfr.window */\n        if (clist_foreach(&fbuf->sfr.window, _resend_failed_frag, fbuf) != NULL) {\n            /* XXX: it is unlikely that allocating an abort RFRAG will be\n             * successful since the resources missing to cause the abort are\n             * still in use, but we should at least try */\n            if (_send_abort_frag(fbuf->pkt, fbuf, true, 0)) {\n                /* wait for ACK before fbuf is deleted */\n                _sched_abort_timeout(fbuf);\n            }\n            else {\n                /* we have no memory resources left to send neither the\n                 * resent fragment nor the abort ACK to signalize that fact to\n                 * the reassembling endpoint */\n                _clean_up_fbuf(fbuf, ENOMEM);\n            }\n        }\n        if (gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf) &&\n            (fbuf->offset < fbuf->datagram_size)) {\n            DEBUG(\"6lo sfr: trigger send of further fragments of datagram %u\\n\",\n                  fbuf->tag);\n            gnrc_sixlowpan_frag_fb_send(fbuf);\n        }\n    }\n}\n\n/* ====== INTERNAL FUNCTIONS USED BY PUBLIC FUNCTIONS ======\n * ====== AND TO MANIPULATE INTERNAL DATA STRUCTURES  ====== */\nstatic inline gnrc_sixlowpan_frag_sfr_bitmap_t *_get_bitmap(gnrc_sixlowpan_frag_rb_t *frag_rb)\n{\n    DECLARE_CONSTANT(is_aligned,\n        HAS_ALIGNMENT_OF(offsetof(gnrc_sixlowpan_frag_rb_t, received),\n                         alignof(gnrc_sixlowpan_frag_sfr_bitmap_t)))\n    static_assert(is_aligned,\n                  \"gnrc_sixlowpan_frag_rb_t::received must be suitably aligned\");\n    return (gnrc_sixlowpan_frag_sfr_bitmap_t *)(uintptr_t)frag_rb->received;\n}\n\nstatic inline bool _frag_ack_req(_frag_desc_t *frag)\n{\n\n    return (frag->ar_seq_fs & (SIXLOWPAN_SFR_ACK_REQ << 8U));\n}\n\nstatic inline uint8_t _frag_seq(_frag_desc_t *frag)\n{\n    return (frag->ar_seq_fs & (SIXLOWPAN_SFR_SEQ_MASK << 8U)) >>\n           (SIXLOWPAN_SFR_SEQ_POS + 8U);\n}\n\nstatic inline uint16_t _frag_size(_frag_desc_t *frag)\n{\n    return (frag->ar_seq_fs & SIXLOWPAN_SFR_FRAG_SIZE_MASK);\n}\n\nstatic void _clean_up_fbuf(gnrc_sixlowpan_frag_fb_t *fbuf, int error)\n{\n    DEBUG(\"6lo sfr: removing fragmentation buffer entry for datagram %u\\n\",\n          fbuf->tag);\n    _clean_slate_datagram(fbuf);\n    gnrc_sixlowpan_frag_sfr_congure_snd_destroy(fbuf);\n    gnrc_pktbuf_release_error(fbuf->pkt, error);\n    fbuf->pkt = NULL;\n}\n\nstatic uint16_t _send_1st_fragment(gnrc_netif_t *netif,\n                                   gnrc_sixlowpan_frag_fb_t *fbuf,\n                                   unsigned page, gnrc_pktsnip_t **tx_sync)\n{\n    gnrc_pktsnip_t *frag, *pkt = fbuf->pkt;\n    sixlowpan_sfr_rfrag_t *hdr;\n    uint8_t *data;\n    size_t comp_form_size = gnrc_pkt_len(pkt->next);\n    uint16_t frag_size = (uint16_t)netif->sixlo.max_frag_size -\n                         sizeof(sixlowpan_sfr_rfrag_t);\n\n    assert((fbuf->sfr.cur_seq == 0) && (fbuf->sfr.frags_sent == 0));\n    assert(fbuf->sfr.window.next == NULL);\n    assert(comp_form_size <= UINT16_MAX);\n    /* restrict tag to value space of SFR, so that later RFRAG ACK can find\n     * it in reverse look-up */\n    fbuf->tag &= UINT8_MAX;\n    DEBUG(\"6lo sfr: determined frag_size = %u\\n\", frag_size);\n\n    /* packet was compressed */\n    if (fbuf->datagram_size > comp_form_size) {\n        /* add slack to first fragment */\n        frag_size -= (fbuf->datagram_size - comp_form_size);\n        /* use compressed form */\n        fbuf->datagram_size = (uint16_t)gnrc_pkt_len(pkt->next);\n    }\n    else {\n        /* Add uncompressed datagram dispatch to \"compressed form\"\n         * datagram_size */\n        fbuf->datagram_size++;\n    }\n    fbuf->sfr.arq_timeout = CONFIG_GNRC_SIXLOWPAN_SFR_OPT_ARQ_TIMEOUT_MS;\n\n    frag = _build_frag_from_fbuf(pkt, fbuf, frag_size);\n    if (frag == NULL) {\n        DEBUG(\"6lo sfr: error allocating first fragment\\n\");\n        return 0;\n    }\n    hdr = frag->next->data;\n    data = (uint8_t *)(hdr + 1);\n    sixlowpan_sfr_rfrag_set_offset(hdr, fbuf->datagram_size);\n    /* don't copy netif header of pkt => pkt->next */\n    frag_size = _copy_pkt_to_frag(data, pkt->next, frag_size, 0);\n    if (IS_USED(MODULE_GNRC_TX_SYNC) && *tx_sync && (frag_size >= fbuf->datagram_size)) {\n        gnrc_pkt_append(frag, *tx_sync);\n        *tx_sync = NULL;\n    }\n\n    DEBUG(\"6lo sfr: send first fragment (tag: %u, X: %i, seq: %u, \"\n          \"frag_size: %u, datagram_size: %u)\\n\",\n          hdr->base.tag, sixlowpan_sfr_rfrag_ack_req(hdr),\n          sixlowpan_sfr_rfrag_get_seq(hdr),\n          sixlowpan_sfr_rfrag_get_frag_size(hdr),\n          sixlowpan_sfr_rfrag_get_offset(hdr));\n    if (!_send_fragment(frag, fbuf, page, 0)) {\n        frag_size = 0;\n    }\n    return frag_size;\n}\n\nstatic uint16_t _send_nth_fragment(gnrc_netif_t *netif,\n                                   gnrc_sixlowpan_frag_fb_t *fbuf,\n                                   unsigned page,\n                                   gnrc_pktsnip_t **tx_sync)\n{\n    gnrc_pktsnip_t *frag, *pkt = fbuf->pkt;\n    sixlowpan_sfr_rfrag_t *hdr;\n    uint8_t *data;\n    uint16_t frag_size = (uint16_t)netif->sixlo.max_frag_size -\n                         sizeof(sixlowpan_sfr_rfrag_t);\n    uint16_t local_offset;\n\n    assert((fbuf->sfr.cur_seq > 0) &&\n           (fbuf->sfr.cur_seq <= SIXLOWPAN_SFR_SEQ_MAX));\n    assert((fbuf->sfr.frags_sent == 0) || (fbuf->sfr.window.next != NULL));\n    assert(fbuf->tag <= UINT8_MAX);\n\n    DEBUG(\"6lo sfr: determined frag_size = %u\\n\", frag_size);\n    frag = _build_frag_from_fbuf(pkt, fbuf,\n                                 _min(frag_size,\n                                      fbuf->datagram_size - fbuf->offset));\n    if (frag == NULL) {\n        DEBUG(\"6lo sfr: error allocating subsequent fragment\\n\");\n        return 0;\n    }\n    hdr = frag->next->data;\n    data = (uint8_t *)(hdr + 1);\n    sixlowpan_sfr_rfrag_set_offset(hdr, fbuf->offset);\n    pkt = pkt->next;    /* don't copy netif header */\n    local_offset = _find_offset_and_copy_rest(data, &pkt, frag_size,\n                                              fbuf->offset);\n    /* copy remaining packet snips */\n    local_offset = _copy_pkt_to_frag(data, pkt, frag_size, local_offset);\n    if (IS_USED(MODULE_GNRC_TX_SYNC) && *tx_sync && (local_offset >= fbuf->datagram_size)) {\n        gnrc_pkt_append(frag, *tx_sync);\n        *tx_sync = NULL;\n    }\n    DEBUG(\"6lo sfr: send subsequent fragment (tag: %u, X: %i, seq: %u, \"\n          \"frag_size: %u, offset: %u)\\n\",\n          hdr->base.tag, sixlowpan_sfr_rfrag_ack_req(hdr),\n          sixlowpan_sfr_rfrag_get_seq(hdr),\n          sixlowpan_sfr_rfrag_get_frag_size(hdr),\n          sixlowpan_sfr_rfrag_get_offset(hdr));\n    if (!_send_fragment(frag, fbuf, page, fbuf->offset)) {\n        local_offset = 0;\n    }\n    return local_offset;\n}\n\nstatic bool _send_abort_frag(gnrc_pktsnip_t *pkt,\n                             gnrc_sixlowpan_frag_fb_t *fbuf,\n                             bool req_ack, unsigned page)\n{\n    gnrc_pktsnip_t *frag;\n\n    frag = _build_frag_pkt(pkt->data, fbuf->tag, req_ack, 0, 0);\n    if (frag != NULL) {\n        sixlowpan_sfr_rfrag_set_offset(frag->next->data, 0);\n        _send_frame(frag, fbuf, NULL, page);\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.fragments_sent.aborts++;\n        }\n        return true;\n    }\n    return false;\n}\n\nstatic void _shrink_window(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    if (!IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {\n        /* window does not shrink without congure */\n        return;\n    }\n    if (!gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf)) {\n        /* we are beyond the congestion window, so shrink it to the new size */\n        clist_node_t new_window = { .next = NULL };\n        _frag_desc_t *last;\n\n        fbuf->sfr.frags_sent = 0;   /* temporarily reset fragments sent to count them again*/\n        /* move all fragments within congestion window into new, temporary list */\n        while (gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf)) {\n            clist_rpush(&new_window, clist_lpop(&fbuf->sfr.window));\n            fbuf->sfr.frags_sent++;\n        }\n        /* free all remaining fragments from old congestion window that did not fit into\n         * the shrunk window */\n        for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n             node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n            clist_rpush(&_frag_descs_free, node);\n        }\n        /* the temporary list is now the new, shrunk window */\n        fbuf->sfr.window.next = new_window.next;\n        /* recalculate offset for fragmentation header field */\n        last = (_frag_desc_t *)clist_rpeek(&fbuf->sfr.window);\n        fbuf->offset = last->offset + _frag_size(last);\n    }\n}\n\nstatic int _resend_frag(clist_node_t *node, void *fbuf_ptr)\n{\n    _frag_desc_t *frag_desc = (_frag_desc_t *)node;\n    gnrc_sixlowpan_frag_fb_t *fbuf = fbuf_ptr;\n    gnrc_pktsnip_t *frag, *pkt = fbuf->pkt;\n    sixlowpan_sfr_rfrag_t *hdr;\n    uint8_t *data;\n    uint16_t frag_size = _frag_size(frag_desc), cur_frag_size;\n\n    frag = _build_frag_pkt(pkt->data, (uint8_t)fbuf->tag, false,\n                           frag_size, 0);\n    if (frag == NULL) {\n        DEBUG(\"6lo sfr: error allocating fragment to resend\\n\");\n        return 1;\n    }\n    hdr = frag->next->data;\n    /* is last fragment in window */\n    if ((!gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf) ||\n         (fbuf->offset >= fbuf->datagram_size)) &&\n        (clist_node_t *)frag_desc == clist_rpeek(&fbuf->sfr.window)) {\n        frag_desc->ar_seq_fs |= (SIXLOWPAN_SFR_ACK_REQ << 8U);\n        _sched_arq_timeout(fbuf, fbuf->sfr.arq_timeout);\n    }\n    hdr->ar_seq_fs = byteorder_htons(frag_desc->ar_seq_fs);\n    if (frag_desc->offset > 0) {\n        sixlowpan_sfr_rfrag_set_offset(hdr, frag_desc->offset);\n    }\n    else {\n        sixlowpan_sfr_rfrag_set_offset(hdr, fbuf->datagram_size);\n    }\n\n    data = (uint8_t *)(hdr + 1);\n    pkt = pkt->next;    /* don't copy netif header */\n    cur_frag_size = _find_offset_and_copy_rest(data, &pkt, frag_size,\n                                               frag_desc->offset);\n    /* copy remaining packet snips */\n    _copy_pkt_to_frag(data, pkt, frag_size, cur_frag_size);\n    DEBUG(\"6lo sfr: resending fragment (retry: %u, tag: %u, X: %i, seq: %u, \"\n          \"frag_size: %u, %s: %u)\\n\", frag_desc->super.resends,\n          hdr->base.tag, sixlowpan_sfr_rfrag_ack_req(hdr),\n          sixlowpan_sfr_rfrag_get_seq(hdr),\n          sixlowpan_sfr_rfrag_get_frag_size(hdr),\n          (sixlowpan_sfr_rfrag_get_seq(hdr)) ? \"offset\" : \"datagram_size\",\n          sixlowpan_sfr_rfrag_get_offset(hdr));\n    if (_send_frame(frag, fbuf, NULL, 0)) {\n        frag_desc->super.send_time = _last_frame_sent / US_PER_MS;\n        return 0;\n    }\n    else {\n        return 1;\n    }\n}\n\nstatic void _retry_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    if ((CONFIG_GNRC_SIXLOWPAN_SFR_DG_RETRIES == 0) ||\n        (fbuf->sfr.retrans == 0)) {\n        DEBUG(\"6lo sfr: giving up to send datagram %u\\n\",\n              fbuf->tag);\n        _clean_up_fbuf(fbuf, ETIMEDOUT);\n    }\n    else {\n        DEBUG(\"6lo sfr: Retrying to send datagram %u completely\\n\", fbuf->tag);\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.datagram_resends++;\n        }\n        fbuf->sfr.retrans--;\n        /* return fragmentation buffer to its original state to resend the whole\n         * datagram again */\n        _clean_slate_datagram(fbuf);\n        gnrc_sixlowpan_frag_sfr_send(fbuf->pkt, fbuf, 0);\n    }\n}\n\nstatic void _abort_rb(gnrc_pktsnip_t *pkt, _generic_rb_entry_t *entry,\n                      gnrc_netif_hdr_t *netif_hdr, bool send_ack)\n{\n    sixlowpan_sfr_rfrag_t *hdr = pkt->data;\n\n    DEBUG(\"6lo sfr: Aborting datagram (%s, %02x)\\n\",\n          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                 netif_hdr->src_l2addr_len, addr_str),\n          hdr->base.tag);\n    if (send_ack) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.acks.aborts++;\n        }\n        _send_ack(gnrc_netif_hdr_get_netif(netif_hdr),\n                  gnrc_netif_hdr_get_src_addr(netif_hdr),\n                  netif_hdr->src_l2addr_len,\n                  &hdr->base, _null_bitmap.bf);\n    }\n    _clean_up_rb_entry(entry);\n    gnrc_pktbuf_release(pkt);\n}\n\nstatic void _send_ack(gnrc_netif_t *netif, const uint8_t *dst, uint8_t dst_len,\n                      const sixlowpan_sfr_t *hdr, const uint8_t *bitmap)\n{\n    gnrc_pktsnip_t *ack = _build_ack(netif, dst, dst_len, hdr, bitmap);\n\n    DEBUG(\"6lo sfr: Sending ACK for (%s, %02x): %02X%02X%02X%02X\\n\",\n          gnrc_netif_addr_to_str(dst, dst_len, addr_str),\n          hdr->tag, bitmap[0], bitmap[1], bitmap[2], bitmap[3]);\n    if (ack != NULL) {\n        _send_frame(ack, NULL, NULL, 0);\n    }\n    else {\n        DEBUG(\"6lo sfr: unable to build ACK for sending\\n\");\n    }\n}\n\nstatic void _sched_next_frame(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    if (!gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        return;\n    }\n    int state = irq_disable();  /* make timer check atomic */\n    bool already_set = xtimer_is_set(&_if_gap_timer);\n\n    irq_restore(state);\n    if (already_set) {\n        DEBUG(\"6lo sfr: inter-frame timer was already set\\n\");\n        return;\n    }\n    uint32_t last_sent_since = (_last_frame_sent - xtimer_now_usec());\n    uint32_t if_gap = gnrc_sixlowpan_frag_sfr_congure_snd_inter_frame_gap(fbuf);\n\n    if (last_sent_since <= if_gap) {\n        uint32_t offset = if_gap - last_sent_since;\n        DEBUG(\"6lo sfr: arming inter-frame timer in %\" PRIu32 \" us\\n\",\n              last_sent_since);\n        _if_gap_msg.content.ptr = fbuf;\n        xtimer_set_msg(&_if_gap_timer, offset, &_if_gap_msg, _getpid());\n    }\n    else {\n        DEBUG(\"6lo sfr: send frame immediately\\n\");\n        /* there is no risk of infinite recursion due to the call of `_sched_next_frame` since\n         * we only get here when (_last_frame_sent - now) > if_gap.\n         * Since gnrc_sixlowpan_frag_sfr_inter_frame_gap updates _last_frame_sent when the list is\n         * empty and only calls _sched_next_frame() when the list is still not empty after that this\n         * can not be the case if we came from there (except for misconfigured if_gap). */\n        gnrc_sixlowpan_frag_sfr_inter_frame_gap(fbuf);\n    }\n}\n\nstatic inline bool _arq_scheduled(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    evtimer_event_t *ptr = _arq_timer.events;\n    evtimer_event_t *event = &fbuf->sfr.arq_timeout_event.event;\n    while (ptr) {\n        if (ptr == event) {\n            return true;\n        }\n        ptr = ptr->next;\n    }\n    return false;\n}\n\nstatic void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)\n{\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        /* mock does not need to be scheduled */\n        return;\n    }\n    if (_arq_scheduled(fbuf)) {\n        DEBUG(\"6lo sfr: ARQ timeout for datagram %u already scheduled\\n\",\n              (uint8_t)fbuf->tag);\n        return;\n    }\n    DEBUG(\"6lo sfr: arming ACK timeout in %lums for datagram %u\\n\",\n          (long unsigned)offset, fbuf->tag);\n    fbuf->sfr.arq_timeout_event.event.offset = offset;\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = fbuf;\n    fbuf->sfr.arq_timeout_event.msg.type = GNRC_SIXLOWPAN_FRAG_SFR_ARQ_TIMEOUT_MSG;\n    evtimer_add_msg(&_arq_timer, &fbuf->sfr.arq_timeout_event,\n                    _getpid());\n}\n\nstatic void _sched_abort_timeout(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    /* no fragments to wait for anymore as we aborted fragmentation and just\n     * wait for an ACK by the reassembling end point that they know. As such,\n     * clean-out the fragmentation buffer. */\n    _clean_slate_datagram(fbuf);\n    fbuf->sfr.retrans = 0;\n    _sched_arq_timeout(fbuf, fbuf->sfr.arq_timeout);\n}\n\nstatic void _handle_rfrag(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                          unsigned page)\n{\n    _generic_rb_entry_t entry = { .type = _UNDEF };\n\n    if (sixlowpan_sfr_rfrag_get_seq(pkt->data) == 0U) {\n        _handle_1st_rfrag(netif_hdr, pkt, page, &entry);\n    }\n    else {\n        _handle_nth_rfrag(netif_hdr, pkt, page, &entry);\n    }\n}\n\nstatic void _handle_ack(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,\n                        unsigned page)\n{\n    gnrc_sixlowpan_frag_vrb_t *vrbe;\n    sixlowpan_sfr_ack_t *hdr = pkt->data;\n    uint32_t recv_time = xtimer_now_usec();\n\n    (void)page;\n    DEBUG(\"6lo sfr: received ACK for datagram (%s, %02x): %02X%02X%02X%02X\\n\",\n          gnrc_netif_addr_to_str(gnrc_netif_hdr_get_src_addr(netif_hdr),\n                                 netif_hdr->src_l2addr_len,\n                                 addr_str), hdr->base.tag,\n          hdr->bitmap[0], hdr->bitmap[1], hdr->bitmap[2], hdr->bitmap[3]);\n    if ((vrbe = gnrc_sixlowpan_frag_vrb_reverse(\n            gnrc_netif_hdr_get_netif(netif_hdr),\n            gnrc_netif_hdr_get_src_addr(netif_hdr),\n            netif_hdr->src_l2addr_len, hdr->base.tag)) != NULL) {\n        /* we found a VRB entry by reverse lookup, forward ACK further down. */\n        sixlowpan_sfr_t mock_base = { .disp_ecn = hdr->base.disp_ecn,\n                                      .tag = vrbe->super.tag };\n        DEBUG(\"6lo sfr: forward ACK to (%s, %02x)\\n\",\n              gnrc_netif_addr_to_str(vrbe->super.src, vrbe->super.src_len,\n                                     addr_str), vrbe->super.tag);\n        _send_ack(vrbe->in_netif, vrbe->super.src, vrbe->super.src_len,\n                  &mock_base, hdr->bitmap);\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n            _stats.acks.forwarded++;\n        }\n        if ((unaligned_get_u32(hdr->bitmap) == _full_bitmap.u32) ||\n            (unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {\n            if (CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER > 0) {\n                /* garbage-collect entry after CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER\n                 * microseconds */\n                vrbe->super.arrival = recv_time -\n                                      (CONFIG_GNRC_SIXLOWPAN_FRAG_VRB_TIMEOUT_US -\n                                       CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER);\n            }\n            else {\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n            }\n        }\n        else {\n            vrbe->super.arrival = recv_time;\n        }\n    }\n    else {\n        gnrc_sixlowpan_frag_fb_t *fbuf;\n\n        if ((fbuf = gnrc_sixlowpan_frag_fb_get_by_tag(hdr->base.tag)) != NULL) {\n            /* ACK for pending ACK timeout received. removing ACK timeout */\n            DEBUG(\"6lo sfr: cancelling ARQ timeout\\n\");\n            evtimer_del((evtimer_t *)(&_arq_timer),\n                        &fbuf->sfr.arq_timeout_event.event);\n            if ((unaligned_get_u32(hdr->bitmap) == _null_bitmap.u32)) {\n                /* ACK indicates the reassembling endpoint canceled reassembly\n                 */\n                DEBUG(\"6lo sfr: fragmentation canceled\\n\");\n                /* Retry to send whole datagram if configured, otherwise\n                 * cancel fragmentation */\n                _retry_datagram(fbuf);\n            }\n            else {\n                /* Check and resent failed fragments within the current window\n                 */\n               _check_failed_frags(hdr, fbuf, recv_time / US_PER_MS);\n            }\n        }\n        else {\n            DEBUG(\"6lo sfr: no VRB or fragmentation buffer found\\n\");\n        }\n    }\n    gnrc_pktbuf_release(pkt);\n}\n\nstatic int _forward_rfrag(gnrc_pktsnip_t *pkt, _generic_rb_entry_t *entry,\n                          uint16_t offset, unsigned page)\n{\n    gnrc_pktsnip_t *old, *new = gnrc_netif_hdr_build(\n            NULL, 0,\n            entry->entry.base->dst, entry->entry.base->dst_len\n        );\n    sixlowpan_sfr_rfrag_t *hdr;\n\n    assert(entry->type == _VRB);\n    /* restrict out_tag to value space of SFR, so that later RFRAG ACK can find\n     * it in reverse look-up */\n    entry->entry.vrb->out_tag &= UINT8_MAX;\n    DEBUG(\"6lo sfr: Forwarding to (%s, %u)\\n\",\n          gnrc_netif_addr_to_str(entry->entry.base->dst,\n                                 entry->entry.base->dst_len, addr_str),\n          entry->entry.vrb->out_tag);\n    if (new == NULL) {\n        DEBUG(\"6lo sfr: Unable to forward fragment, \"\n              \"packet buffer full\\n\");\n        gnrc_pktbuf_release(pkt);\n        return -ENOMEM;\n    }\n\n    hdr = pkt->data;\n    old = gnrc_pktsnip_search_type(pkt, GNRC_NETTYPE_NETIF);\n    if (old != NULL) {\n        /* remove original netif header */\n        gnrc_pktbuf_remove_snip(pkt, old);\n    }\n    if (offset > 0) {\n        offset += entry->entry.vrb->offset_diff;\n    }\n    sixlowpan_sfr_rfrag_set_offset(hdr, offset);\n    hdr->base.tag = entry->entry.vrb->out_tag;\n    gnrc_netif_hdr_set_netif(new->data, entry->entry.vrb->out_netif);\n    new->next = pkt;\n    _send_frame(new, NULL, NULL, page);\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_STATS)) {\n        _stats.fragments_sent.forwarded++;\n    }\n    return 0;\n}\n\n/** @} */\n"], "filenames": ["sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c"], "buggy_code_start_loc": [509], "buggy_code_end_loc": [1808], "fixing_code_start_loc": [508], "fixing_code_end_loc": [1817], "type": "CWE-362", "message": "RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. In versions 2023.01 and prior, an attacker can send multiple crafted frames to the device to trigger a race condition. The race condition invalidates assumptions about the program state and leads to an invalid memory access resulting in denial of service. This issue is patched in pull request 19679. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-33974", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-30T17:15:10.200", "lastModified": "2023-06-06T14:57:41.787", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. In versions 2023.01 and prior, an attacker can send multiple crafted frames to the device to trigger a race condition. The race condition invalidates assumptions about the program state and leads to an invalid memory access resulting in denial of service. This issue is patched in pull request 19679. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:riot-os:riot:*:*:*:*:*:*:*:*", "versionEndIncluding": "2023.01", "matchCriteriaId": "E3ECD3F7-1DD5-430A-B5E7-50FDFE044CF7"}]}]}], "references": [{"url": "https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L1717", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L509", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/blob/f41b4b67b6affca0a8b32edced7f51088696869a/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L617", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/blob/master/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L1586", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/blob/master/sys/net/gnrc/network_layer/sixlowpan/frag/sfr/gnrc_sixlowpan_frag_sfr.c#L404", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/RIOT-OS/RIOT/pull/19679", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-8m3w-mphf-wxm8", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/RIOT-OS/RIOT/commit/31c6191f6196f1a05c9765cffeadba868e3b0723"}}