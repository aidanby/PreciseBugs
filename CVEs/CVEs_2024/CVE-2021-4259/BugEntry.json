{"buggy_code": ["<?php\n\n// This fill will perform HTTP digest authentication. This is not the most secure form of authentication so be carefull when using this.\nfunction authHttpDigest()\n{\n    global $config;\n\n    $realm = 'phpRedisAdmin';\n\n    // Using the md5 of the user agent and IP should make it a bit harder to intercept and reuse the responses.\n    $opaque = md5('phpRedisAdmin'.$_SERVER['HTTP_USER_AGENT'].$_SERVER['REMOTE_ADDR']);\n\n\n    if (!isset($_SERVER['PHP_AUTH_DIGEST']) || empty($_SERVER['PHP_AUTH_DIGEST'])) {\n      header('HTTP/1.1 401 Unauthorized');\n      header('WWW-Authenticate: Digest realm=\"'.$realm.'\",qop=\"auth\",nonce=\"'.uniqid().'\",opaque=\"'.$opaque.'\"');\n      die;\n    }\n\n    $needed_parts = array(\n      'nonce'    => 1,\n      'nc'       => 1,\n      'cnonce'   => 1,\n      'qop'      => 1,\n      'username' => 1,\n      'uri'      => 1,\n      'response' => 1\n     );\n\n    $data = array();\n    $keys = implode('|', array_keys($needed_parts));\n\n    preg_match_all('/('.$keys.')=(?:([\\'\"])([^\\2]+?)\\2|([^\\s,]+))/', $_SERVER['PHP_AUTH_DIGEST'], $matches, PREG_SET_ORDER);\n\n    foreach ($matches as $m) {\n      $data[$m[1]] = $m[3] ? $m[3] : $m[4];\n      unset($needed_parts[$m[1]]);\n    }\n\n    if (!empty($needed_parts)) {\n      header('HTTP/1.1 401 Unauthorized');\n      header('WWW-Authenticate: Digest realm=\"'.$realm.'\",qop=\"auth\",nonce=\"'.uniqid().'\",opaque=\"'.$opaque.'\"');\n      die;\n    }\n\n    if (!isset($config['login'][$data['username']])) {\n      header('HTTP/1.1 401 Unauthorized');\n      header('WWW-Authenticate: Digest realm=\"'.$realm.'\",qop=\"auth\",nonce=\"'.uniqid().'\",opaque=\"'.$opaque.'\"');\n      die('Invalid username and/or password combination.');\n    }\n\n    $login         = $config['login'][$data['username']];\n    $login['name'] = $data['username'];\n\n    $password = md5($login['name'].':'.$realm.':'.$login['password']);\n\n    $response = md5($password.':'.$data['nonce'].':'.$data['nc'].':'.$data['cnonce'].':'.$data['qop'].':'.md5($_SERVER['REQUEST_METHOD'].':'.$data['uri']));\n\n    if ($data['response'] != $response) {\n      header('HTTP/1.1 401 Unauthorized');\n      header('WWW-Authenticate: Digest realm=\"'.$realm.'\",qop=\"auth\",nonce=\"'.uniqid().'\",opaque=\"'.$opaque.'\"');\n      die('Invalid username and/or password combination.');\n    }\n\n    return $login;\n}\n\n// Perform auth using a standard HTML <form> submission and cookies to save login state\nfunction authCookie()\n{\n    global $config;\n\n    $generateCookieHash = function($username) use ($config) {\n        if (!isset($config['login'][$username])) {\n            throw new \\RuntimeException(\"Invalid username\");\n        }\n\n        // Storing this value client-side so we need to be careful that it\n        //  doesn't reveal anything nor can be guessed.\n        // Using SHA512 because MD5, SHA1 are both now considered broken\n        return hash(\n            'sha512',\n            implode(':', array(\n                $username,\n                $_SERVER['HTTP_USER_AGENT'],\n                $_SERVER['REMOTE_ADDR'],\n                $config['login'][$username]['password'],\n            ))\n        );\n    };\n\n    if (!empty($_COOKIE['phpRedisAdminLogin'])) {\n        // We have a cookie; is it correct?\n        // Cookie value looks like \"username:password-hash\"\n        $cookieVal = explode(':', $_COOKIE['phpRedisAdminLogin']);\n        if (count($cookieVal) === 2) {\n            list($username, $cookieHash) = $cookieVal;\n            if (isset($config['login'][$username])) {\n                $userData = $config['login'][$username];\n                $expectedHash = $generateCookieHash($username);\n\n                if ($cookieHash === $expectedHash) {\n                    // Correct username & password\n                    return $userData;\n                }\n            }\n        }\n    }\n\n    if (isset($_POST['username'], $_POST['password'])) {\n        // Login form submitted; correctly?\n        if (isset($config['login'][$_POST['username']])) {\n            $userData = $config['login'][$_POST['username']];\n            if ($_POST['password'] === $userData['password']) {\n                // Correct username & password. Set cookie and redirect to home page\n                $cookieValue = $_POST['username'] . ':' . $generateCookieHash($_POST['username']);\n                setcookie('phpRedisAdminLogin', $cookieValue);\n\n                // This should be an absolute URL, but that's a bit of a pain to generate; this will work\n                header(\"Location: index.php\");\n                die();\n            }\n        }\n    }\n\n    // If we're here, we don't have a valid login cookie and we don't have a\n    //  valid form submission, so redirect to the login page if we aren't\n    //  already on that page\n    if (!defined('LOGIN_PAGE')) {\n        header(\"Location: login.php\");\n        die();\n    }\n\n    // We must be on the login page without a valid cookie or submission\n    return null;\n}\n\nif (!empty($config['cookie_auth'])) {\n    $login = authCookie();\n} else {\n    $login = authHttpDigest();\n}\n\n?>\n"], "fixing_code": ["<?php\n\n// This fill will perform HTTP digest authentication. This is not the most secure form of authentication so be carefull when using this.\nfunction authHttpDigest()\n{\n    global $config;\n\n    $realm = 'phpRedisAdmin';\n\n    // Using the md5 of the user agent and IP should make it a bit harder to intercept and reuse the responses.\n    $opaque = md5('phpRedisAdmin'.$_SERVER['HTTP_USER_AGENT'].$_SERVER['REMOTE_ADDR']);\n\n\n    if (!isset($_SERVER['PHP_AUTH_DIGEST']) || empty($_SERVER['PHP_AUTH_DIGEST'])) {\n      header('HTTP/1.1 401 Unauthorized');\n      header('WWW-Authenticate: Digest realm=\"'.$realm.'\",qop=\"auth\",nonce=\"'.uniqid().'\",opaque=\"'.$opaque.'\"');\n      die;\n    }\n\n    $needed_parts = array(\n      'nonce'    => 1,\n      'nc'       => 1,\n      'cnonce'   => 1,\n      'qop'      => 1,\n      'username' => 1,\n      'uri'      => 1,\n      'response' => 1\n     );\n\n    $data = array();\n    $keys = implode('|', array_keys($needed_parts));\n\n    preg_match_all('/('.$keys.')=(?:([\\'\"])([^\\2]+?)\\2|([^\\s,]+))/', $_SERVER['PHP_AUTH_DIGEST'], $matches, PREG_SET_ORDER);\n\n    foreach ($matches as $m) {\n      $data[$m[1]] = $m[3] ? $m[3] : $m[4];\n      unset($needed_parts[$m[1]]);\n    }\n\n    if (!empty($needed_parts)) {\n      header('HTTP/1.1 401 Unauthorized');\n      header('WWW-Authenticate: Digest realm=\"'.$realm.'\",qop=\"auth\",nonce=\"'.uniqid().'\",opaque=\"'.$opaque.'\"');\n      die;\n    }\n\n    if (!isset($config['login'][$data['username']])) {\n      header('HTTP/1.1 401 Unauthorized');\n      header('WWW-Authenticate: Digest realm=\"'.$realm.'\",qop=\"auth\",nonce=\"'.uniqid().'\",opaque=\"'.$opaque.'\"');\n      die('Invalid username and/or password combination.');\n    }\n\n    $login         = $config['login'][$data['username']];\n    $login['name'] = $data['username'];\n\n    $password = md5($login['name'].':'.$realm.':'.$login['password']);\n\n    $response = md5($password.':'.$data['nonce'].':'.$data['nc'].':'.$data['cnonce'].':'.$data['qop'].':'.md5($_SERVER['REQUEST_METHOD'].':'.$data['uri']));\n\n    if ($data['response'] !== $response) {\n      header('HTTP/1.1 401 Unauthorized');\n      header('WWW-Authenticate: Digest realm=\"'.$realm.'\",qop=\"auth\",nonce=\"'.uniqid().'\",opaque=\"'.$opaque.'\"');\n      die('Invalid username and/or password combination.');\n    }\n\n    return $login;\n}\n\n// Perform auth using a standard HTML <form> submission and cookies to save login state\nfunction authCookie()\n{\n    global $config;\n\n    $generateCookieHash = function($username) use ($config) {\n        if (!isset($config['login'][$username])) {\n            throw new \\RuntimeException(\"Invalid username\");\n        }\n\n        // Storing this value client-side so we need to be careful that it\n        //  doesn't reveal anything nor can be guessed.\n        // Using SHA512 because MD5, SHA1 are both now considered broken\n        return hash(\n            'sha512',\n            implode(':', array(\n                $username,\n                $_SERVER['HTTP_USER_AGENT'],\n                $_SERVER['REMOTE_ADDR'],\n                $config['login'][$username]['password'],\n            ))\n        );\n    };\n\n    if (!empty($_COOKIE['phpRedisAdminLogin'])) {\n        // We have a cookie; is it correct?\n        // Cookie value looks like \"username:password-hash\"\n        $cookieVal = explode(':', $_COOKIE['phpRedisAdminLogin']);\n        if (count($cookieVal) === 2) {\n            list($username, $cookieHash) = $cookieVal;\n            if (isset($config['login'][$username])) {\n                $userData = $config['login'][$username];\n                $expectedHash = $generateCookieHash($username);\n\n                if ($cookieHash === $expectedHash) {\n                    // Correct username & password\n                    return $userData;\n                }\n            }\n        }\n    }\n\n    if (isset($_POST['username'], $_POST['password'])) {\n        // Login form submitted; correctly?\n        if (isset($config['login'][$_POST['username']])) {\n            $userData = $config['login'][$_POST['username']];\n            if ($_POST['password'] === $userData['password']) {\n                // Correct username & password. Set cookie and redirect to home page\n                $cookieValue = $_POST['username'] . ':' . $generateCookieHash($_POST['username']);\n                setcookie('phpRedisAdminLogin', $cookieValue);\n\n                // This should be an absolute URL, but that's a bit of a pain to generate; this will work\n                header(\"Location: index.php\");\n                die();\n            }\n        }\n    }\n\n    // If we're here, we don't have a valid login cookie and we don't have a\n    //  valid form submission, so redirect to the login page if we aren't\n    //  already on that page\n    if (!defined('LOGIN_PAGE')) {\n        header(\"Location: login.php\");\n        die();\n    }\n\n    // We must be on the login page without a valid cookie or submission\n    return null;\n}\n\nif (!empty($config['cookie_auth'])) {\n    $login = authCookie();\n} else {\n    $login = authHttpDigest();\n}\n\n?>\n"], "filenames": ["includes/login.inc.php"], "buggy_code_start_loc": [59], "buggy_code_end_loc": [60], "fixing_code_start_loc": [59], "fixing_code_end_loc": [60], "type": "CWE-597", "message": "A vulnerability was found in phpRedisAdmin up to 1.16.1. It has been classified as problematic. This affects the function authHttpDigest of the file includes/login.inc.php. The manipulation of the argument response leads to use of wrong operator in string comparison. Upgrading to version 1.16.2 is able to address this issue. The name of the patch is 31aa7661e6db6f4dffbf9a635817832a0a11c7d9. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216267.", "other": {"cve": {"id": "CVE-2021-4259", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-19T14:15:10.497", "lastModified": "2022-12-27T17:39:42.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in phpRedisAdmin up to 1.16.1. It has been classified as problematic. This affects the function authHttpDigest of the file includes/login.inc.php. The manipulation of the argument response leads to use of wrong operator in string comparison. Upgrading to version 1.16.2 is able to address this issue. The name of the patch is 31aa7661e6db6f4dffbf9a635817832a0a11c7d9. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216267."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-597"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpredisadmin_project:phpredisadmin:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.2", "matchCriteriaId": "F16F80BC-5EB4-4E80-AE7E-2CFF9538912A"}]}]}], "references": [{"url": "https://github.com/erikdubbelboer/phpRedisAdmin/commit/31aa7661e6db6f4dffbf9a635817832a0a11c7d9", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/erikdubbelboer/phpRedisAdmin/releases/tag/v1.16.2", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216267", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/erikdubbelboer/phpRedisAdmin/commit/31aa7661e6db6f4dffbf9a635817832a0a11c7d9"}}