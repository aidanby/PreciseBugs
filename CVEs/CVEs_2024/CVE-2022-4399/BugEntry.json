{"buggy_code": ["CHANGES:\n0.1\n\t- initial release\n0.2\n\t- added 'show' option, to display a note without editing\n\t- changed 'open' option to 'edit' to differentiate it from\n\t 'show', 'open' has been left for backward compatibility\n0.2.1\n\t- added man page thanks to Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n0.2.2\n\t- patch to build/Makefile to fix bug when building on ubuntu\n\t provided by Angel Abad\n\t http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=627306\n\t https://bugs.launchpad.net/ubuntu/+source/nodau/+bug/785135\n0.2.3\n\t- patches to Makefiles to improve build portability provided by\n\t Mats Andersson <bsd <at> gisladisker.se>\n0.3rc1\n\t- use an external editor for editing using the EDITOR\n\t environment variable\n\t- move database location to comply with XDG standard\n\t- rewritten Makefiles\n\t- add support for encrypted notes\n\t- add a config file\n0.3rc2\n\t- add GPL exception for linking with OpenSSL\n\t- updates to Makefile to allow passing of flags by environment\n\t variable\n\t- updates to man page about configuration file by Salvatore\n\t Bonaccorso <carnil <at> debian.org>\n\t- updates to man page and README file to document configuration\n\t settings by Ryan MacNish <ryan <at> nisshh.com>\n0.3rc3\n\t- only give user write permission when creating config/data\n\t directories\n\t- prevent segfault when list'ing with no matches\n0.3rc4\n\t- remove dependency on PATH_MAX to hopefully improve GNU Hurd\n\t compatability\n0.3rc5\n\t- remove dependency on PATH_MAX to hopefully improve GNU Hurd\n\t compatability - do it properly!\n0.3rc6\n\t- fix a segv in the database code\n\t- make encryption work again (when did this get broken?)\n0.3rc7\n\t- allow passing CPPFLAGS by Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n0.3.0\n\t- no changes, it seems stable\n0.3.1\n\t- fix various compiler warnings\n0.3.2\n\t- add 'create' as a synonym for 'new'\n\t- make 'edit' auto-create a note if it does not exist and\n\t edit_autocreate is true in config\n0.3.3\n\t- some documentation improvements by Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n0.3.4\n\t- fixes to Makefile by Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n0.3.5\n\t- make note editing scriptable, by allowing note content to be\n\t piped to stdin\n\t- stop stack corruption on db_update with long notes\n\t- changes to temporary file handling to fix security\n\t vulnerability - https://github.com/darkrose/nodau/issues/17\n0.3.6\n\t- add append option to help text by Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n\t- fix compiler warning in usage()\n0.3.7\n\t- prevent segv when env is empty\n\t- prevent segv in config file creation\n0.3.8\n\t- add support for openssl 1.1 (by Salvatore Bonaccorso\n\t <carnil <at> debian.org>)\n\t- fix typo in an error message\n\t- a bunch of small fixes to remove some compiler warnings\n0.3.9\n\t- fix segfault when running 'nodau list' with search keyword,\n\t and there are no matches (by Omer Dagan\n\t <mr.omer.dagan <at> gmail.com>)\n\t- remove variable definitions in header file that caused issues\n\t with gcc 10\n", "/************************************************************************\n* db.c\n* nodau console note taker\n* Copyright (C) Lisa Milne 2010-2013 <lisa@ltmnet.com>\n*\n* db.c is free software: you can redistribute it and/or modify it\n* under the terms of the GNU General Public License as published by the\n* Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* db.c is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n* See the GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program.  If not, see <http://www.gnu.org/licenses/>\n*\n* In addition, as a special exception, the copyright holder (Lisa Milne)\n* gives permission to link the code of this release of nodau with the\n* OpenSSL project's \"OpenSSL\" library (or with modified versions of it\n* that use the same license as the \"OpenSSL\" library), and distribute\n* the linked executables. You must obey the GNU General Public License\n* in all respects for all of the code used other than \"OpenSSL\". If you\n* modify this file, you may extend this exception to your version of the\n* file, but you are not obligated to do so. If you do not wish to do so,\n* delete this exception statement from your version.\n************************************************************************/\n\n#include <stdarg.h>\n/* so that getdate() works */\n#define _XOPEN_SOURCE 500\n/* so that asprintf works */\n#define _GNU_SOURCE\n#include <time.h>\n\n#include \"nodau.h\"\n\nstatic struct {\n\tsqlite3 *db;\n\tchar *error_msg;\n} db_data = {\n\tNULL,\n\tNULL\n};\n\n/* convert a db string to a date string */\nstatic char* db_gettime(char* d)\n{\n\ttime_t date = (time_t)atoi(d);\n\tstruct tm *timeinfo = localtime(&date);\n\tchar* tmp = asctime(timeinfo);\n\ttmp[strlen(tmp)-1] = '\\0';\n\treturn tmp;\n}\n\n/* convert a date string to a stamp */\nstatic unsigned int db_getstamp(char* d)\n{\n\tstruct tm *timeinfo;\n\t/* if string is now, get current time */\n\tif (strcmp(d,\"now\") == 0) {\n\t\treturn (unsigned int)time(NULL);\n\t}\n\n\t/* check datmask is set, if not create a temporary mask file */\n\tif (getenv(\"DATEMSK\") == 0) {\n\t\tcreate_datemask();\n\t}\n\n\t/* get the stamp from the string */\n\ttimeinfo = getdate(d);\n\n\t/* null means something went wrong, so print an error and return 'now' */\n\tif (timeinfo == NULL) {\n\t\tfprintf(stderr,\"invalid date format\\n\");\n\t\treturn db_getstamp(\"now\");\n\t}\n\n\t/* convert the tm struct to a time_t */\n\treturn mktime(timeinfo);\n}\n\n/* create the nodau table if it doesn't exist */\nstatic int db_check()\n{\n\tdb_data.error_msg = NULL;\n\tsqlite3_exec(db_data.db, \"CREATE TABLE IF NOT EXISTS nodau(name VARCHAR(255), date INTEGER UNSIGNED, text TEXT, encrypted BOOLEAN DEFAULT 'false')\", NULL, 0, &db_data.error_msg);\n\n\tif (db_data.error_msg) {\n\t\tfprintf(stderr,\"%s\\n\",db_data.error_msg);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/* get results from the database */\nstatic sql_result *db_get(char* sql,...)\n{\n\t/* temp storage area */\n\tsql_result *result;\n\tchar dtmp[512];\n\n\t/* insert variable args to the sql statement */\n\tva_list ap;\n\tva_start(ap, sql);\n\tvsnprintf(dtmp, 512, sql, ap);\n\tva_end(ap);\n\n\t/* get a result struct */\n\tresult = db_result_alloc();\n\n\t/* null result, return null */\n\tif (result == NULL)\n\t\treturn NULL;\n\n\tdb_data.error_msg = NULL;\n\n\t/* run the query, store the results in the result struct */\n\tsqlite3_get_table(db_data.db, dtmp, &result->data, &result->num_rows, &result->num_cols, &db_data.error_msg);\n\n\t/* return if there's an error message, but don't print it as\n\t * that's handled elsewhere and we don't want to print it twice */\n\tif (db_data.error_msg)\n\t\treturn NULL;\n\n\t/* return the struct */\n\treturn result;\n}\n\n/* insert a new note */\nstatic int db_insert(char* name, char* value)\n{\n\t/* somewhere to put the sql */\n\tchar sql[1024];\n\n\t/* get the current time */\n\tunsigned int date = (unsigned int)time(NULL);\n\n\t/* create the sql statement using the name/date/text for this note */\n\tsprintf(sql, \"INSERT INTO nodau values('%s','%u','%s','false')\", name, date, value);\n\n\t/* do it */\n\treturn sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n}\n\n/* connect to the database */\nint db_connect()\n{\n\tint c;\n\tchar* f;\n\tchar* xdh;\n\tchar* fl;\n\tdb_data.error_msg = NULL;\n\n\tf = getenv(\"HOME\");\n\txdh = getenv(\"XDG_DATA_HOME\");\n\n\t/* use XDG data directory for storing the database */\n\tif (!xdh || !xdh[0]) {\n\t\tif (asprintf(&fl,\"%s/.local/share/nodau\",f) < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&fl,\"%s/nodau\",xdh) < 0)\n\t\t\treturn 1;\n\t}\n\n\tdir_create(fl);\n\n\tif (asprintf(&xdh,\"%s/nodau.db\",fl) < 0)\n\t\treturn 1;\n\n\tfree(fl);\n\tfl = xdh;\n\n\t/* connect */\n\tc = sqlite3_open_v2(fl, &db_data.db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);\n\tfree(fl);\n\n\t/* check for an error */\n\tif (c)\n\t\treturn 1;\n\n\tc = db_check();\n\n\t/* check for an error */\n\tif (c)\n\t\treturn 1;\n\n\t/* import from old database file */\n\tif (!config_read(\"import_old_db\",\"false\")) {\n\t\tsqlite3 *odb;\n\t\tint i;\n\t\tsql_result *res = db_result_alloc();\n\n\t\tif (asprintf(&fl,\"%s/.nodau\",f) < 0)\n\t\t\treturn 1;\n\n\t\ti = sqlite3_open_v2(fl, &odb, SQLITE_OPEN_READWRITE, NULL);\n\t\tif (!i) {\n\t\t\tsqlite3_get_table(odb, \"SELECT * FROM nodau\", &res->data, &res->num_rows, &res->num_cols, &db_data.error_msg);\n\t\t\tif (!db_data.error_msg) {\n\t\t\t\tif (res->num_rows) {\n\t\t\t\t\tputs(\"Importing from old database\\n\");\n\t\t\t\t\tfor (i=0; i<res->num_rows; i++) {\n\t\t\t\t\t\tdb_insert(res->data[OCOLUMN(i,COL_NAME)],res->data[OCOLUMN(i,COL_TEXT)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdb_result_free(res);\n\t\t\t}\n\t\t}\n\t\tconfig_write(\"import_old_db\",\"false\");\n\t\tfree(fl);\n\t}\n\n\t/* check the table exists and return */\n\treturn c;\n}\n\n/* closes the database */\nvoid db_close()\n{\n\tsqlite3_close(db_data.db);\n}\n\nconst char* db_err()\n{\n\tconst char* m;\n\n\tm = sqlite3_errmsg(db_data.db);\n\n\tif (m)\n\t\treturn m;\n\n\treturn \"Unknown Error\";\n}\n\n/* create a result struct */\nsql_result *db_result_alloc()\n{\n\t/* malloc space */\n\tsql_result *res = malloc(sizeof(sql_result));\n\n\t/* null means error and return */\n\tif (res == NULL) {\n\t\tfprintf(stderr,\"allocation failure\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* set some default values */\n\tres->num_cols = 0;\n\tres->num_rows = 0;\n\tres->data = NULL;\n\n\t/* return the struct */\n\treturn res;\n}\n\n/* free a result struct */\nint db_result_free(sql_result *result)\n{\n\t/* if null do nothing */\n\tif (result == NULL)\n\t\treturn 1;\n\n\t/* if there's data free it */\n\tif (result->num_cols && result->num_rows && result->data) {\n\t\tsqlite3_free_table(result->data);\n\t}\n\n\t/* free the struct */\n\tfree(result);\n\n\t/* done */\n\treturn 0;\n}\n\n/* update an existing note */\nint db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\t/* create the sql statement using the name/text for this note\n\t * if it's meant to be encrypted, then crypt_key will be set */\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);\n\t\tfree(value);\n\t\tif (r < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)\n\t\t\treturn 1;\n\t}\n\n\t/* do it */\n\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n\tfree(sql);\n\treturn r;\n}\n\n/* list notes according to search criteria */\nint db_list(char* search)\n{\n\tsql_result *res = NULL;\n\tint i;\n\tchar* pref = \"match\";\n\n\t/* if search is null, list all */\n\tif (search == NULL) {\n\t\tpref = \"note\";\n\t\tres = db_get(\"SELECT * FROM nodau\");\n\n\t\t/* nothing there */\n\t\tif (res->num_rows == 0) {\n\t\t\tprintf(\"No notes to list\\n\");\n\t\t\tdb_result_free(res);\n\t\t\treturn 0;\n\t\t}\n\t}else{\n\t\t/* first try a name search */\n\t\tres = db_get(\"SELECT * FROM nodau WHERE name LIKE '%%%s%%'\",search);\n\n\t\t/* if there's nothing then try a time search */\n\t\tif (res->num_rows == 0) {\n\t\t\tunsigned int idate;\n\t\t\tdb_result_free(res);\n\t\t\tres = NULL;\n\t\t\t/* at time */\n\t\t\tif (strncmp(search,\"t@\",2) == 0) {\n\t\t\t\tidate = db_getstamp(search+2);\n\t\t\t\tres = db_get(\"SELECT * FROM nodau WHERE date = %u\", idate);\n\t\t\t/* after time */\n\t\t\t}else if (strncmp(search,\"t+\",2) == 0) {\n\t\t\t\tidate = db_getstamp(search+2);\n\t\t\t\tres = db_get(\"SELECT * FROM nodau WHERE date > %u\", idate);\n\t\t\t/* before time */\n\t\t\t}else if (strncmp(search,\"t-\",2) == 0) {\n\t\t\t\tidate = db_getstamp(search+2);\n\t\t\t\tres = db_get(\"SELECT * FROM nodau WHERE date < %u\", idate);\n\t\t\t}\n\t\t}\n\t\t/* nothing there */\n\t\tif (!res || !res->num_rows || !res->num_cols) {\n\t\t\tprintf(\"No notes match '%s'\\n\",search);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* print the list */\n\tfor (i=0; i<res->num_rows; i++) {\n\t\tprintf(\"%s %d: %s\\n\",pref,i+1,res->data[COLUMN(i,COL_NAME)]);\n\t}\n\n\t/* free the result */\n\tif (res)\n\t\tdb_result_free(res);\n\n\treturn 0;\n}\n\n/* open an existing note */\nint db_edit(char* search)\n{\n\tchar* date;\n\tchar* name;\n\tchar* text;\n\tchar* crypt;\n\tint r;\n\t/* get the note by name */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* nothing there */\n\tif (result->num_rows == 0) {\n\t\tdb_result_free(result);\n\t\tif (config_read(\"edit_autocreate\",\"false\")) {\n\t\t\tprintf(\"No notes match '%s'\\n\",search);\n\t\t}else{\n\t\t\t return db_new(search);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* get the data */\n\tdate = db_gettime(result->data[COLUMN(0,COL_DATE)]);\n\tname = result->data[COLUMN(0,COL_NAME)];\n\ttext = result->data[COLUMN(0,COL_TEXT)];\n\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t/* get the passphrase if it's encrypted */\n\tif (!strcmp(crypt,\"true\")) {\n\t\tcrypt = crypt_get_key();\n\t\ttext = note_decrypt(text,crypt);\n\t\tif (!text)\n\t\t\treturn 1;\n\t}\n\n\t/* edit the note */\n\tr = edit(name, date, text);\n\n\t/* free the result */\n\tdb_result_free(result);\n\n\treturn r;\n}\n\n/* append data from stdin to a note */\nint db_append(char* search)\n{\n\tchar* date;\n\tchar* name;\n\tchar* text;\n\tchar* crypt;\n\tint r;\n\t/* get the note by name */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* nothing there */\n\tif (result->num_rows == 0) {\n\t\tdb_result_free(result);\n\t\treturn db_new(search);\n\t}\n\n\t/* get the data */\n\tdate = db_gettime(result->data[COLUMN(0,COL_DATE)]);\n\tname = result->data[COLUMN(0,COL_NAME)];\n\ttext = result->data[COLUMN(0,COL_TEXT)];\n\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t/* get the passphrase if it's encrypted */\n\tif (!strcmp(crypt,\"true\")) {\n\t\tcrypt = crypt_get_key();\n\t\ttext = note_decrypt(text,crypt);\n\t\tif (!text)\n\t\t\treturn 1;\n\t}\n\n\t/* edit the note */\n\tr = edit_stdin(name, date, text,1);\n\n\t/* free the result */\n\tdb_result_free(result);\n\n\treturn r;\n}\n\n/* show an existing note */\nint db_show(char* search)\n{\n\tchar* date;\n\tchar* name;\n\tchar* text;\n\tchar* crypt;\n\t/* get the note by name */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* nothing there */\n\tif (result->num_rows == 0) {\n\t\tprintf(\"No notes match '%s'\\n\",search);\n\t\tdb_result_free(result);\n\t\treturn 0;\n\t}\n\n\t/* get the data */\n\tdate = db_gettime(result->data[COLUMN(0,COL_DATE)]);\n\tname = result->data[COLUMN(0,COL_NAME)];\n\ttext = result->data[COLUMN(0,COL_TEXT)];\n\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t/* get the passphrase if it's encrypted */\n\tif (!strcmp(crypt,\"true\")) {\n\t\tcrypt = crypt_get_key();\n\t\ttext = note_decrypt(text,crypt);\n\t\tif (!text)\n\t\t\treturn 1;\n\t}\n\n\t/* display the note */\n\tprintf(\"%s (%s):\\n%s\\n\",name,date,text);\n\n\t/* free the result */\n\tdb_result_free(result);\n\n\treturn 0;\n}\n\n/* delete notes */\nint db_del(char* search)\n{\n\tchar sql[512];\n\tunsigned int date = 0;\n\t/* try a name search */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* TODO: request passphrase before deleting encrypted notes?\n\t * File can be deleted without the passphrase anyway,\n\t * or the db can be edited with sqlite3 shell, so is there a\n\t * point to protecting from deletion? */\n\n\t/* if we got something, delete it */\n\tif (result->num_rows) {\n\t\tsprintf(sql, \"DELETE FROM nodau WHERE name = '%s'\", search);\n\t/* or try a delete by time at */\n\t}else if (strncmp(search,\"t@\",2) == 0) {\n\t\tdate = db_getstamp(search+2);\n\t\tsprintf(sql, \"DELETE FROM nodau WHERE date = %u\", date);\n\t/* or try a delete by later than */\n\t}else if (strncmp(search,\"t+\",2) == 0) {\n\t\tdate = db_getstamp(search+2);\n\t\tsprintf(sql, \"DELETE FROM nodau WHERE date > %u\", date);\n\t/* or try a delete by earlier than */\n\t}else if (strncmp(search,\"t-\",2) == 0) {\n\t\tdate = db_getstamp(search+2);\n\t\tsprintf(sql, \"DELETE FROM nodau WHERE date < %u\", date);\n\t/* or print an error */\n\t}else{\n\t\tprintf(\"No notes matches '%s'\\n\",search);\n\t\treturn 0;\n\t}\n\n\t/* run the statement */\n\tsqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n\n\t/* free the earlier result */\n\tdb_result_free(result);\n\n\treturn 0;\n}\n\n/* create a new note */\nint db_new(char* search)\n{\n\t/* search by name */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\tif (result) {\n\t\t/* there's already a note with that name, so error and return */\n\t\tif (result->num_rows) {\n\t\t\tprintf(\"There is already a note called '%s'\\n\",search);\n\t\t\tdb_result_free(result);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* free the search result */\n\t\tdb_result_free(result);\n\t}\n\n\t/* create the new entry */\n\tdb_insert(search,\"new entry\");\n\n\tif (db_data.error_msg)\n\t\tprintf(\"%s\\n\",db_data.error_msg);\n\n\t/* open for editing */\n\treturn db_edit(search);\n}\n\n/* encrypt an existing note, or create a new encrypted note */\nint db_encrypt(char* search)\n{\n\t/* search by name */\n\tsql_result *result;\n\tchar* crypt;\n\tint r = 0;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* there's already a note with that name */\n\tif (result->num_rows) {\n\t\tchar* name;\n\t\tchar* text;\n\n\t\t/* get the data */\n\t\tname = result->data[COLUMN(0,COL_NAME)];\n\t\ttext = result->data[COLUMN(0,COL_TEXT)];\n\t\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t\t/* encrypt it if it's not already */\n\t\tif (!strcmp(crypt,\"false\")) {\n\t\t\tcrypt = crypt_get_key();\n\t\t\tr = db_update(name,text);\n\t\t}else{\n\t\t\tprintf(\"Note '%s' is already encrypted\\n\",search);\n\t\t}\n\t\tdb_result_free(result);\n\t\treturn r;\n\t}\n\n\t/* free the search result */\n\tdb_result_free(result);\n\n\t/* create the new entry */\n\tdb_insert(search,\"new entry\");\n\n\tif (db_data.error_msg)\n\t\tfprintf(stderr,\"%s\\n\",db_data.error_msg);\n\n\tcrypt = crypt_get_key();\n\t/* open for editing */\n\treturn db_edit(search);\n}\n\n\n/* decrypt an existing note or create a new encrypted note */\nint db_decrypt(char* search)\n{\n\t/* search by name */\n\tsql_result *result;\n\tint r;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* found the note */\n\tif (result->num_rows) {\n\t\tchar* text;\n\t\tchar* crypt;\n\n\t\t/* get the data */\n\t\ttext = result->data[COLUMN(0,COL_TEXT)];\n\t\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t\t/* decrypt it if it is encrypted */\n\t\tif (!strcmp(crypt,\"true\")) {\n\t\t\tchar* t;\n\t\t\tcrypt = crypt_get_key();\n\t\t\tt = note_decrypt(text,crypt);\n\t\t\tif (!t)\n\t\t\t\treturn 1;\n\t\t\tfree(crypt_key);\n\t\t\tcrypt_key = NULL;\n\t\t\tr = db_update(search,t);\n\t\t\tdb_result_free(result);\n\t\t\treturn r;\n\t\t}else{\n\t\t\tprintf(\"Note '%s' is not encrypted\\n\",search);\n\t\t\tdb_result_free(result);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tprintf(\"No notes matches '%s'\\n\",search);\n\tdb_result_free(result);\n\n\treturn 0;\n}\n", "/************************************************************************\n* edit.c\n* nodau console note taker\n* Copyright (C) Lisa Milne 2010-2013 <lisa@ltmnet.com>\n*\n* edit.c is free software: you can redistribute it and/or modify it\n* under the terms of the GNU General Public License as published by the\n* Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* edit.c is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n* See the GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program.  If not, see <http://www.gnu.org/licenses/>\n*\n* In addition, as a special exception, the copyright holder (Lisa Milne)\n* gives permission to link the code of this release of nodau with the\n* OpenSSL project's \"OpenSSL\" library (or with modified versions of it\n* that use the same license as the \"OpenSSL\" library), and distribute\n* the linked executables. You must obey the GNU General Public License\n* in all respects for all of the code used other than \"OpenSSL\". If you\n* modify this file, you may extend this exception to your version of the\n* file, but you are not obligated to do so. If you do not wish to do so,\n* delete this exception statement from your version.\n************************************************************************/\n\n/* so that asprintf works */\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <ncurses.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n\n#include \"nodau.h\"\n\n/* local storage for note name and date */\nstatic char* bname;\nstatic char* bdate;\n\n/* draw to the screen */\nstatic void draw(char* data)\n{\n\t/* clear the screen */\n\tclear();\n\t/* print the name and date in bold */\n\tattron(A_BOLD);\n\tprintw(\"%s (%s):\\n\",bname,bdate);\n\tattroff(A_BOLD);\n\t/* print the note body */\n\tprintw(\"%s\",data);\n\t/* refresh the screen */\n\trefresh();\n}\n\n/* edit a note with the builtin editor */\nstatic int edit_builtin(char* name, char* date, char* data)\n{\n\tchar buffer[256];\n\tint bl;\n\t/* still editing? */\n\tint quit = 0;\n\t/* character storage */\n\tint plch = 0;\n\tint lch = 0;\n\tint ch = 0;\n\n\t/* set the local data */\n\tbname = name;\n\tbdate = date;\n\t/* find the buffer length */\n\tbl = strlen(data);\n\t/* create the buffer */\n\t/* fill the buffer with 0's */\n\tmemset(&buffer,0,256);\n\n\t/* if the note is too long, shorten it */\n\tif (bl > 255) {\n\t\tdata[255] = 0;\n\t\tbl = 255;\n\t}\n\n\t/* put the note into the buffer */\n\tsprintf(buffer, \"%s\", data);\n\n\t/* init ncurses */\n\tinitscr();\n\t/* no line buffering */\n\tcbreak();\n\t/* get all the keys */\n\tkeypad(stdscr, TRUE);\n\t/* don't echo keypresses */\n\tnoecho();\n\n\t/* while we are editing */\n\twhile (!quit) {\n\t\t/* draw the screen */\n\t\tdraw(buffer);\n\t\t/* set previous last char to last char */\n\t\tplch = lch;\n\t\t/* set last char to char */\n\t\tlch = ch;\n\t\t/* get char */\n\t\tch = getch();\n\t\t/* if it's printable or newline */\n\t\tif (isprint(ch) || ch == '\\n') {\n\t\t\tbl++;\n\t\t\t/* if the note is under 255 chars, add the char */\n\t\t\tif (bl < 255) {\n\t\t\t\tbuffer[bl-1] = ch;\n\t\t\t\tbuffer[bl] = 0;\n\t\t\t}\n\t\t/* backspace means delete a char */\n\t\t}else if (ch == 127 || ch == KEY_BACKSPACE) {\n\t\t\t/* if we've got one to delete */\n\t\t\tif (bl > 0) {\n\t\t\t\tbl--;\n\t\t\t\tbuffer[bl] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* check for newline dot exit */\n\t\tif (plch == '\\n' && lch == '.' && ch == '\\n') {\n\t\t\t/* don't include the dot in the note */\n\t\t\tbl -= 3;\n\t\t\tbuffer[bl] = 0;\n\t\t\tquit = 1;\n\t\t/* check for escape exit */\n\t\t}else if (ch == 27) {\n\t\t\tquit = 1;\n\t\t}\n\t}\n\n\t/* exit curses */\n\tendwin();\n\n\t/* save the note */\n\tif (!db_update(name,buffer))\n\t\treturn 1;\n\n\t/* let the user know */\n\tprintf(\"%s saved\\n\",name);\n\n\treturn 0;\n}\n\n/* edit with an external editor */\nstatic int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\n\tstrcpy(buff,\"/tmp/nodau.XXXXXX\");\n\tfd = mkstemp(buff);\n\n\tif (fd < 0)\n\t\treturn 1;\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\t/* find the file length */\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\t/* load the note into memory */\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\t/* delete the file */\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\t/* find the note data */\n\t\t\t\tl = strstr(b,\"-----\");\n\t\t\t\tif (l) {\n\t\t\t\t\t/* save the note */\n\t\t\t\t\tl += 6;\n\t\t\t\t\tif (db_update(name,l))\n\t\t\t\t\t\treturn 1;\n\n\t\t\t\t\t/* let the user know */\n\t\t\t\t\tprintf(\"%s saved\\n\",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\n\t/* insert data into file */\n\tsz = sprintf(\n\t\tb,\n\t\t\"%s (%s)\\nText above this line is ignored\\n-----\\n%s\",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\n\tst = execl(editor,editor,buff,(char*)NULL);\n\n\t/* we should only ever get here if something goes wrong with exec */\n\texit(st);\n\n\t/* and we shouldn't ever get here, but it stops the compiler complaining */\n\treturn 1;\n}\n\n/* edit a note using data piped from stdin */\nint edit_stdin(char* name, char* date, char* data, int append)\n{\n\tchar buff[1024];\n\tint l;\n\tint s;\n\tint r;\n\tchar* d;\n\tchar* b;\n\n\t/* get the initial buffer size */\n\tl = strlen(data);\n\tif (l < 512) {\n\t\ts = 512;\n\t}else{\n\t\ts = l*2;\n\t}\n\n\td = malloc(s);\n\tif (!d)\n\t\treturn 1;\n\n\t/* for append mode copy the old data to the start of the buffer */\n\tif (append && strcmp(data,\"new entry\")) {\n\t\tstrcpy(d,data);\n\t}else{\n\t\tl = 0;\n\t}\n\n\t/* read it in */\n\twhile ((r = read(STDIN_FILENO,buff,1024)) > 0) {\n\t\t/* extend the buffer as necessary */\n\t\tif (l+r+1 > s) {\n\t\t\ts = l+r+512;\n\t\t\tb = realloc(d,s);\n\t\t\tif (!b)\n\t\t\t\treturn 1;\n\t\t\td = b;\n\t\t}\n\t\tmemcpy(d+l,buff,r);\n\t\tl += r;\n\t}\n\n\t/* make sure there's room for the nul byte */\n\tif (l+1 > s) {\n\t\ts = l+1;\n\t\tb = realloc(d,s);\n\t\tif (!b)\n\t\t\treturn 1;\n\t\td = b;\n\t}\n\n\td[l] = 0;\n\n\t/* done */\n\treturn db_update(name,d);\n}\n\n/* edit a note */\nint edit(char* name, char* date, char* data)\n{\n\tchar* ed;\n\tchar* pt;\n\tchar* editor;\n\tchar* p = NULL;\n\tstruct stat st;\n\n\tif (!isatty(STDIN_FILENO))\n\t\treturn edit_stdin(name,date,data,0);\n\n\tpt = getenv(\"PATH\");\n\n\ted = config_read(\"external_editor\",NULL);\n\tif (!ed)\n\t\ted = getenv(\"EDITOR\");\n\n\t/* no editor or no path, use builtin */\n\tif (config_read(\"force_builtin_editor\",\"true\") || !ed || (ed[0] != '/' && !pt))\n\t\treturn edit_builtin(name,date,data);\n\n\t/* find the executable */\n\tif (ed[0] == '/') {\n\t\tstat(ed,&st);\n\t\t/* check it exists */\n\t\tif (S_ISREG(st.st_mode)) {\n\t\t\tp = ed;\n\t\t\teditor = strdup(ed);\n\t\t}\n\t}else{\n\t\tp = strtok(pt,\":\");\n\t\twhile (p) {\n\t\t\tp = strtok(NULL,\":\");\n\n\t\t\tif (asprintf(&editor,\"%s/%s\",p,ed) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tstat(editor,&st);\n\t\t\t/* check it exists */\n\t\t\tif (S_ISREG(st.st_mode))\n\t\t\t\tbreak;\n\n\t\t\tfree(editor);\n\t\t}\n\t}\n\n\t/* no executable, or fails to run, use builtin */\n\tif (!p || edit_ext(editor,name,date,data))\n\t\treturn edit_builtin(name,date,data);\n\n\treturn 0;\n}\n"], "fixing_code": ["CHANGES:\n0.1\n\t- initial release\n0.2\n\t- added 'show' option, to display a note without editing\n\t- changed 'open' option to 'edit' to differentiate it from\n\t 'show', 'open' has been left for backward compatibility\n0.2.1\n\t- added man page thanks to Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n0.2.2\n\t- patch to build/Makefile to fix bug when building on ubuntu\n\t provided by Angel Abad\n\t http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=627306\n\t https://bugs.launchpad.net/ubuntu/+source/nodau/+bug/785135\n0.2.3\n\t- patches to Makefiles to improve build portability provided by\n\t Mats Andersson <bsd <at> gisladisker.se>\n0.3rc1\n\t- use an external editor for editing using the EDITOR\n\t environment variable\n\t- move database location to comply with XDG standard\n\t- rewritten Makefiles\n\t- add support for encrypted notes\n\t- add a config file\n0.3rc2\n\t- add GPL exception for linking with OpenSSL\n\t- updates to Makefile to allow passing of flags by environment\n\t variable\n\t- updates to man page about configuration file by Salvatore\n\t Bonaccorso <carnil <at> debian.org>\n\t- updates to man page and README file to document configuration\n\t settings by Ryan MacNish <ryan <at> nisshh.com>\n0.3rc3\n\t- only give user write permission when creating config/data\n\t directories\n\t- prevent segfault when list'ing with no matches\n0.3rc4\n\t- remove dependency on PATH_MAX to hopefully improve GNU Hurd\n\t compatability\n0.3rc5\n\t- remove dependency on PATH_MAX to hopefully improve GNU Hurd\n\t compatability - do it properly!\n0.3rc6\n\t- fix a segv in the database code\n\t- make encryption work again (when did this get broken?)\n0.3rc7\n\t- allow passing CPPFLAGS by Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n0.3.0\n\t- no changes, it seems stable\n0.3.1\n\t- fix various compiler warnings\n0.3.2\n\t- add 'create' as a synonym for 'new'\n\t- make 'edit' auto-create a note if it does not exist and\n\t edit_autocreate is true in config\n0.3.3\n\t- some documentation improvements by Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n0.3.4\n\t- fixes to Makefile by Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n0.3.5\n\t- make note editing scriptable, by allowing note content to be\n\t piped to stdin\n\t- stop stack corruption on db_update with long notes\n\t- changes to temporary file handling to fix security\n\t vulnerability - https://github.com/darkrose/nodau/issues/17\n0.3.6\n\t- add append option to help text by Salvatore Bonaccorso\n\t <carnil <at> debian.org>\n\t- fix compiler warning in usage()\n0.3.7\n\t- prevent segv when env is empty\n\t- prevent segv in config file creation\n0.3.8\n\t- add support for openssl 1.1 (by Salvatore Bonaccorso\n\t <carnil <at> debian.org>)\n\t- fix typo in an error message\n\t- a bunch of small fixes to remove some compiler warnings\n0.3.9\n\t- fix segfault when running 'nodau list' with search keyword,\n\t and there are no matches (by Omer Dagan\n\t <mr.omer.dagan <at> gmail.com>)\n\t- remove variable definitions in header file that caused issues\n\t with gcc 10\n0.3.10\n    - Move to parametetrized SQL statement allows using chars like \"'\"\n     in notes, and also avoid sql injection\n", "/************************************************************************\n* db.c\n* nodau console note taker\n* Copyright (C) Lisa Milne 2010-2013 <lisa@ltmnet.com>\n*\n* db.c is free software: you can redistribute it and/or modify it\n* under the terms of the GNU General Public License as published by the\n* Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* db.c is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n* See the GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program.  If not, see <http://www.gnu.org/licenses/>\n*\n* In addition, as a special exception, the copyright holder (Lisa Milne)\n* gives permission to link the code of this release of nodau with the\n* OpenSSL project's \"OpenSSL\" library (or with modified versions of it\n* that use the same license as the \"OpenSSL\" library), and distribute\n* the linked executables. You must obey the GNU General Public License\n* in all respects for all of the code used other than \"OpenSSL\". If you\n* modify this file, you may extend this exception to your version of the\n* file, but you are not obligated to do so. If you do not wish to do so,\n* delete this exception statement from your version.\n************************************************************************/\n\n#include <stdarg.h>\n/* so that getdate() works */\n#define _XOPEN_SOURCE 500\n/* so that asprintf works */\n#define _GNU_SOURCE\n#include <time.h>\n\n#include \"nodau.h\"\n\nstatic struct {\n\tsqlite3 *db;\n\tchar *error_msg;\n} db_data = {\n\tNULL,\n\tNULL\n};\n\n/* convert a db string to a date string */\nstatic char* db_gettime(char* d)\n{\n\ttime_t date = (time_t)atoi(d);\n\tstruct tm *timeinfo = localtime(&date);\n\tchar* tmp = asctime(timeinfo);\n\ttmp[strlen(tmp)-1] = '\\0';\n\treturn tmp;\n}\n\n/* convert a date string to a stamp */\nstatic unsigned int db_getstamp(char* d)\n{\n\tstruct tm *timeinfo;\n\t/* if string is now, get current time */\n\tif (strcmp(d,\"now\") == 0) {\n\t\treturn (unsigned int)time(NULL);\n\t}\n\n\t/* check datmask is set, if not create a temporary mask file */\n\tif (getenv(\"DATEMSK\") == 0) {\n\t\tcreate_datemask();\n\t}\n\n\t/* get the stamp from the string */\n\ttimeinfo = getdate(d);\n\n\t/* null means something went wrong, so print an error and return 'now' */\n\tif (timeinfo == NULL) {\n\t\tfprintf(stderr,\"invalid date format\\n\");\n\t\treturn db_getstamp(\"now\");\n\t}\n\n\t/* convert the tm struct to a time_t */\n\treturn mktime(timeinfo);\n}\n\n/* create the nodau table if it doesn't exist */\nstatic int db_check()\n{\n\tdb_data.error_msg = NULL;\n\tsqlite3_exec(db_data.db, \"CREATE TABLE IF NOT EXISTS nodau(name VARCHAR(255), date INTEGER UNSIGNED, text TEXT, encrypted BOOLEAN DEFAULT 'false')\", NULL, 0, &db_data.error_msg);\n\n\tif (db_data.error_msg) {\n\t\tfprintf(stderr,\"%s\\n\",db_data.error_msg);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/* get results from the database */\nstatic sql_result *db_get(char* sql,...)\n{\n\t/* temp storage area */\n\tsql_result *result;\n\tchar dtmp[512];\n\n\t/* insert variable args to the sql statement */\n\tva_list ap;\n\tva_start(ap, sql);\n\tvsnprintf(dtmp, 512, sql, ap);\n\tva_end(ap);\n\n\t/* get a result struct */\n\tresult = db_result_alloc();\n\n\t/* null result, return null */\n\tif (result == NULL)\n\t\treturn NULL;\n\n\tdb_data.error_msg = NULL;\n\n\t/* run the query, store the results in the result struct */\n\tsqlite3_get_table(db_data.db, dtmp, &result->data, &result->num_rows, &result->num_cols, &db_data.error_msg);\n\n\t/* return if there's an error message, but don't print it as\n\t * that's handled elsewhere and we don't want to print it twice */\n\tif (db_data.error_msg)\n\t\treturn NULL;\n\n\t/* return the struct */\n\treturn result;\n}\n\n/* insert a new note */\nstatic int db_insert(char* name, char* value)\n{\n\t/* somewhere to put the sql */\n\tchar sql[1024];\n\n\t/* get the current time */\n\tunsigned int date = (unsigned int)time(NULL);\n\n\t/* create the sql statement using the name/date/text for this note */\n\tsprintf(sql, \"INSERT INTO nodau values('%s','%u','%s','false')\", name, date, value);\n\n\t/* do it */\n\treturn sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n}\n\n/* connect to the database */\nint db_connect()\n{\n\tint c;\n\tchar* f;\n\tchar* xdh;\n\tchar* fl;\n\tdb_data.error_msg = NULL;\n\n\tf = getenv(\"HOME\");\n\txdh = getenv(\"XDG_DATA_HOME\");\n\n\t/* use XDG data directory for storing the database */\n\tif (!xdh || !xdh[0]) {\n\t\tif (asprintf(&fl,\"%s/.local/share/nodau\",f) < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&fl,\"%s/nodau\",xdh) < 0)\n\t\t\treturn 1;\n\t}\n\n\tdir_create(fl);\n\n\tif (asprintf(&xdh,\"%s/nodau.db\",fl) < 0)\n\t\treturn 1;\n\n\tfree(fl);\n\tfl = xdh;\n\n\t/* connect */\n\tc = sqlite3_open_v2(fl, &db_data.db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);\n\tfree(fl);\n\n\t/* check for an error */\n\tif (c)\n\t\treturn 1;\n\n\tc = db_check();\n\n\t/* check for an error */\n\tif (c)\n\t\treturn 1;\n\n\t/* import from old database file */\n\tif (!config_read(\"import_old_db\",\"false\")) {\n\t\tsqlite3 *odb;\n\t\tint i;\n\t\tsql_result *res = db_result_alloc();\n\n\t\tif (asprintf(&fl,\"%s/.nodau\",f) < 0)\n\t\t\treturn 1;\n\n\t\ti = sqlite3_open_v2(fl, &odb, SQLITE_OPEN_READWRITE, NULL);\n\t\tif (!i) {\n\t\t\tsqlite3_get_table(odb, \"SELECT * FROM nodau\", &res->data, &res->num_rows, &res->num_cols, &db_data.error_msg);\n\t\t\tif (!db_data.error_msg) {\n\t\t\t\tif (res->num_rows) {\n\t\t\t\t\tputs(\"Importing from old database\\n\");\n\t\t\t\t\tfor (i=0; i<res->num_rows; i++) {\n\t\t\t\t\t\tdb_insert(res->data[OCOLUMN(i,COL_NAME)],res->data[OCOLUMN(i,COL_TEXT)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdb_result_free(res);\n\t\t\t}\n\t\t}\n\t\tconfig_write(\"import_old_db\",\"false\");\n\t\tfree(fl);\n\t}\n\n\t/* check the table exists and return */\n\treturn c;\n}\n\n/* closes the database */\nvoid db_close()\n{\n\tsqlite3_close(db_data.db);\n}\n\nconst char* db_err()\n{\n\tconst char* m;\n\n\tm = sqlite3_errmsg(db_data.db);\n\n\tif (m)\n\t\treturn m;\n\n\treturn \"Unknown Error\";\n}\n\n/* create a result struct */\nsql_result *db_result_alloc()\n{\n\t/* malloc space */\n\tsql_result *res = malloc(sizeof(sql_result));\n\n\t/* null means error and return */\n\tif (res == NULL) {\n\t\tfprintf(stderr,\"allocation failure\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* set some default values */\n\tres->num_cols = 0;\n\tres->num_rows = 0;\n\tres->data = NULL;\n\n\t/* return the struct */\n\treturn res;\n}\n\n/* free a result struct */\nint db_result_free(sql_result *result)\n{\n\t/* if null do nothing */\n\tif (result == NULL)\n\t\treturn 1;\n\n\t/* if there's data free it */\n\tif (result->num_cols && result->num_rows && result->data) {\n\t\tsqlite3_free_table(result->data);\n\t}\n\n\t/* free the struct */\n\tfree(result);\n\n\t/* done */\n\treturn 0;\n}\n\n/* update an existing note */\nint db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\t/* create the sql statement using the name/text for this note\n\t * if it's meant to be encrypted, then crypt_key will be set */\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='false' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}\n\n\tsqlite3_stmt *compiled_statement;\n\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);\n\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\t/* do it */\n\tr = sqlite3_step(compiled_statement);\n\tif (r != SQLITE_DONE) {\n\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n\t\treturn 1;\n\t}\n\tr = sqlite3_finalize(compiled_statement);\n\tif (r != SQLITE_OK)\n\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n\n\tfree(sql);\n\tif (crypt_key)\n\t\tfree(value);\n\treturn r;\n}\n\n/* list notes according to search criteria */\nint db_list(char* search)\n{\n\tsql_result *res = NULL;\n\tint i;\n\tchar* pref = \"match\";\n\n\t/* if search is null, list all */\n\tif (search == NULL) {\n\t\tpref = \"note\";\n\t\tres = db_get(\"SELECT * FROM nodau\");\n\n\t\t/* nothing there */\n\t\tif (res->num_rows == 0) {\n\t\t\tprintf(\"No notes to list\\n\");\n\t\t\tdb_result_free(res);\n\t\t\treturn 0;\n\t\t}\n\t}else{\n\t\t/* first try a name search */\n\t\tres = db_get(\"SELECT * FROM nodau WHERE name LIKE '%%%s%%'\",search);\n\n\t\t/* if there's nothing then try a time search */\n\t\tif (res->num_rows == 0) {\n\t\t\tunsigned int idate;\n\t\t\tdb_result_free(res);\n\t\t\tres = NULL;\n\t\t\t/* at time */\n\t\t\tif (strncmp(search,\"t@\",2) == 0) {\n\t\t\t\tidate = db_getstamp(search+2);\n\t\t\t\tres = db_get(\"SELECT * FROM nodau WHERE date = %u\", idate);\n\t\t\t/* after time */\n\t\t\t}else if (strncmp(search,\"t+\",2) == 0) {\n\t\t\t\tidate = db_getstamp(search+2);\n\t\t\t\tres = db_get(\"SELECT * FROM nodau WHERE date > %u\", idate);\n\t\t\t/* before time */\n\t\t\t}else if (strncmp(search,\"t-\",2) == 0) {\n\t\t\t\tidate = db_getstamp(search+2);\n\t\t\t\tres = db_get(\"SELECT * FROM nodau WHERE date < %u\", idate);\n\t\t\t}\n\t\t}\n\t\t/* nothing there */\n\t\tif (!res || !res->num_rows || !res->num_cols) {\n\t\t\tprintf(\"No notes match '%s'\\n\",search);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* print the list */\n\tfor (i=0; i<res->num_rows; i++) {\n\t\tprintf(\"%s %d: %s\\n\",pref,i+1,res->data[COLUMN(i,COL_NAME)]);\n\t}\n\n\t/* free the result */\n\tif (res)\n\t\tdb_result_free(res);\n\n\treturn 0;\n}\n\n/* open an existing note */\nint db_edit(char* search)\n{\n\tchar* date;\n\tchar* name;\n\tchar* text;\n\tchar* crypt;\n\tint r;\n\t/* get the note by name */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* nothing there */\n\tif (result->num_rows == 0) {\n\t\tdb_result_free(result);\n\t\tif (config_read(\"edit_autocreate\",\"false\")) {\n\t\t\tprintf(\"No notes match '%s'\\n\",search);\n\t\t}else{\n\t\t\t return db_new(search);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* get the data */\n\tdate = db_gettime(result->data[COLUMN(0,COL_DATE)]);\n\tname = result->data[COLUMN(0,COL_NAME)];\n\ttext = result->data[COLUMN(0,COL_TEXT)];\n\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t/* get the passphrase if it's encrypted */\n\tif (!strcmp(crypt,\"true\")) {\n\t\tcrypt = crypt_get_key();\n\t\ttext = note_decrypt(text,crypt);\n\t\tif (!text)\n\t\t\treturn 1;\n\t}\n\n\t/* edit the note */\n\tr = edit(name, date, text);\n\n\t/* free the result */\n\tdb_result_free(result);\n\n\treturn r;\n}\n\n/* append data from stdin to a note */\nint db_append(char* search)\n{\n\tchar* date;\n\tchar* name;\n\tchar* text;\n\tchar* crypt;\n\tint r;\n\t/* get the note by name */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* nothing there */\n\tif (result->num_rows == 0) {\n\t\tdb_result_free(result);\n\t\treturn db_new(search);\n\t}\n\n\t/* get the data */\n\tdate = db_gettime(result->data[COLUMN(0,COL_DATE)]);\n\tname = result->data[COLUMN(0,COL_NAME)];\n\ttext = result->data[COLUMN(0,COL_TEXT)];\n\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t/* get the passphrase if it's encrypted */\n\tif (!strcmp(crypt,\"true\")) {\n\t\tcrypt = crypt_get_key();\n\t\ttext = note_decrypt(text,crypt);\n\t\tif (!text)\n\t\t\treturn 1;\n\t}\n\n\t/* edit the note */\n\tr = edit_stdin(name, date, text,1);\n\n\t/* free the result */\n\tdb_result_free(result);\n\n\treturn r;\n}\n\n/* show an existing note */\nint db_show(char* search)\n{\n\tchar* date;\n\tchar* name;\n\tchar* text;\n\tchar* crypt;\n\t/* get the note by name */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* nothing there */\n\tif (result->num_rows == 0) {\n\t\tprintf(\"No notes match '%s'\\n\",search);\n\t\tdb_result_free(result);\n\t\treturn 0;\n\t}\n\n\t/* get the data */\n\tdate = db_gettime(result->data[COLUMN(0,COL_DATE)]);\n\tname = result->data[COLUMN(0,COL_NAME)];\n\ttext = result->data[COLUMN(0,COL_TEXT)];\n\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t/* get the passphrase if it's encrypted */\n\tif (!strcmp(crypt,\"true\")) {\n\t\tcrypt = crypt_get_key();\n\t\ttext = note_decrypt(text,crypt);\n\t\tif (!text)\n\t\t\treturn 1;\n\t}\n\n\t/* display the note */\n\tprintf(\"%s (%s):\\n%s\\n\",name,date,text);\n\n\t/* free the result */\n\tdb_result_free(result);\n\n\treturn 0;\n}\n\n/* delete notes */\nint db_del(char* search)\n{\n\tchar sql[512];\n\tunsigned int date = 0;\n\t/* try a name search */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* TODO: request passphrase before deleting encrypted notes?\n\t * File can be deleted without the passphrase anyway,\n\t * or the db can be edited with sqlite3 shell, so is there a\n\t * point to protecting from deletion? */\n\n\t/* if we got something, delete it */\n\tif (result->num_rows) {\n\t\tsprintf(sql, \"DELETE FROM nodau WHERE name = '%s'\", search);\n\t/* or try a delete by time at */\n\t}else if (strncmp(search,\"t@\",2) == 0) {\n\t\tdate = db_getstamp(search+2);\n\t\tsprintf(sql, \"DELETE FROM nodau WHERE date = %u\", date);\n\t/* or try a delete by later than */\n\t}else if (strncmp(search,\"t+\",2) == 0) {\n\t\tdate = db_getstamp(search+2);\n\t\tsprintf(sql, \"DELETE FROM nodau WHERE date > %u\", date);\n\t/* or try a delete by earlier than */\n\t}else if (strncmp(search,\"t-\",2) == 0) {\n\t\tdate = db_getstamp(search+2);\n\t\tsprintf(sql, \"DELETE FROM nodau WHERE date < %u\", date);\n\t/* or print an error */\n\t}else{\n\t\tprintf(\"No notes matches '%s'\\n\",search);\n\t\treturn 0;\n\t}\n\n\t/* run the statement */\n\tsqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n\n\t/* free the earlier result */\n\tdb_result_free(result);\n\n\treturn 0;\n}\n\n/* create a new note */\nint db_new(char* search)\n{\n\t/* search by name */\n\tsql_result *result;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\tif (result) {\n\t\t/* there's already a note with that name, so error and return */\n\t\tif (result->num_rows) {\n\t\t\tprintf(\"There is already a note called '%s'\\n\",search);\n\t\t\tdb_result_free(result);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* free the search result */\n\t\tdb_result_free(result);\n\t}\n\n\t/* create the new entry */\n\tdb_insert(search,\"new entry\");\n\n\tif (db_data.error_msg)\n\t\tprintf(\"%s\\n\",db_data.error_msg);\n\n\t/* open for editing */\n\treturn db_edit(search);\n}\n\n/* encrypt an existing note, or create a new encrypted note */\nint db_encrypt(char* search)\n{\n\t/* search by name */\n\tsql_result *result;\n\tchar* crypt;\n\tint r = 0;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* there's already a note with that name */\n\tif (result->num_rows) {\n\t\tchar* name;\n\t\tchar* text;\n\n\t\t/* get the data */\n\t\tname = result->data[COLUMN(0,COL_NAME)];\n\t\ttext = result->data[COLUMN(0,COL_TEXT)];\n\t\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t\t/* encrypt it if it's not already */\n\t\tif (!strcmp(crypt,\"false\")) {\n\t\t\tcrypt = crypt_get_key();\n\t\t\tr = db_update(name,text);\n\t\t}else{\n\t\t\tprintf(\"Note '%s' is already encrypted\\n\",search);\n\t\t}\n\t\tdb_result_free(result);\n\t\treturn r;\n\t}\n\n\t/* free the search result */\n\tdb_result_free(result);\n\n\t/* create the new entry */\n\tdb_insert(search,\"new entry\");\n\n\tif (db_data.error_msg)\n\t\tfprintf(stderr,\"%s\\n\",db_data.error_msg);\n\n\tcrypt = crypt_get_key();\n\t/* open for editing */\n\treturn db_edit(search);\n}\n\n\n/* decrypt an existing note or create a new encrypted note */\nint db_decrypt(char* search)\n{\n\t/* search by name */\n\tsql_result *result;\n\tint r;\n\tresult = db_get(\"SELECT * FROM nodau WHERE name = '%s'\",search);\n\n\t/* found the note */\n\tif (result->num_rows) {\n\t\tchar* text;\n\t\tchar* crypt;\n\n\t\t/* get the data */\n\t\ttext = result->data[COLUMN(0,COL_TEXT)];\n\t\tcrypt = result->data[COLUMN(0,COL_CRYPT)];\n\n\t\t/* decrypt it if it is encrypted */\n\t\tif (!strcmp(crypt,\"true\")) {\n\t\t\tchar* t;\n\t\t\tcrypt = crypt_get_key();\n\t\t\tt = note_decrypt(text,crypt);\n\t\t\tif (!t)\n\t\t\t\treturn 1;\n\t\t\tfree(crypt_key);\n\t\t\tcrypt_key = NULL;\n\t\t\tr = db_update(search,t);\n\t\t\tdb_result_free(result);\n\t\t\treturn r;\n\t\t}else{\n\t\t\tprintf(\"Note '%s' is not encrypted\\n\",search);\n\t\t\tdb_result_free(result);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tprintf(\"No notes matches '%s'\\n\",search);\n\tdb_result_free(result);\n\n\treturn 0;\n}\n", "/************************************************************************\n* edit.c\n* nodau console note taker\n* Copyright (C) Lisa Milne 2010-2013 <lisa@ltmnet.com>\n*\n* edit.c is free software: you can redistribute it and/or modify it\n* under the terms of the GNU General Public License as published by the\n* Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* edit.c is distributed in the hope that it will be useful, but\n* WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n* See the GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program.  If not, see <http://www.gnu.org/licenses/>\n*\n* In addition, as a special exception, the copyright holder (Lisa Milne)\n* gives permission to link the code of this release of nodau with the\n* OpenSSL project's \"OpenSSL\" library (or with modified versions of it\n* that use the same license as the \"OpenSSL\" library), and distribute\n* the linked executables. You must obey the GNU General Public License\n* in all respects for all of the code used other than \"OpenSSL\". If you\n* modify this file, you may extend this exception to your version of the\n* file, but you are not obligated to do so. If you do not wish to do so,\n* delete this exception statement from your version.\n************************************************************************/\n\n/* so that asprintf works */\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <ncurses.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <time.h>\n\n#include \"nodau.h\"\n\n/* local storage for note name and date */\nstatic char* bname;\nstatic char* bdate;\n\n/* draw to the screen */\nstatic void draw(char* data)\n{\n\t/* clear the screen */\n\tclear();\n\t/* print the name and date in bold */\n\tattron(A_BOLD);\n\tprintw(\"%s (%s):\\n\",bname,bdate);\n\tattroff(A_BOLD);\n\t/* print the note body */\n\tprintw(\"%s\",data);\n\t/* refresh the screen */\n\trefresh();\n}\n\n/* edit a note with the builtin editor */\nstatic int edit_builtin(char* name, char* date, char* data)\n{\n\tchar buffer[256];\n\tint bl;\n\t/* still editing? */\n\tint quit = 0;\n\t/* character storage */\n\tint plch = 0;\n\tint lch = 0;\n\tint ch = 0;\n\n\t/* set the local data */\n\tbname = name;\n\tbdate = date;\n\t/* find the buffer length */\n\tbl = strlen(data);\n\t/* create the buffer */\n\t/* fill the buffer with 0's */\n\tmemset(&buffer,0,256);\n\n\t/* if the note is too long, shorten it */\n\tif (bl > 255) {\n\t\tdata[255] = 0;\n\t\tbl = 255;\n\t}\n\n\t/* put the note into the buffer */\n\tsprintf(buffer, \"%s\", data);\n\n\t/* init ncurses */\n\tinitscr();\n\t/* no line buffering */\n\tcbreak();\n\t/* get all the keys */\n\tkeypad(stdscr, TRUE);\n\t/* don't echo keypresses */\n\tnoecho();\n\n\t/* while we are editing */\n\twhile (!quit) {\n\t\t/* draw the screen */\n\t\tdraw(buffer);\n\t\t/* set previous last char to last char */\n\t\tplch = lch;\n\t\t/* set last char to char */\n\t\tlch = ch;\n\t\t/* get char */\n\t\tch = getch();\n\t\t/* if it's printable or newline */\n\t\tif (isprint(ch) || ch == '\\n') {\n\t\t\tbl++;\n\t\t\t/* if the note is under 255 chars, add the char */\n\t\t\tif (bl < 255) {\n\t\t\t\tbuffer[bl-1] = ch;\n\t\t\t\tbuffer[bl] = 0;\n\t\t\t}\n\t\t/* backspace means delete a char */\n\t\t}else if (ch == 127 || ch == KEY_BACKSPACE) {\n\t\t\t/* if we've got one to delete */\n\t\t\tif (bl > 0) {\n\t\t\t\tbl--;\n\t\t\t\tbuffer[bl] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* check for newline dot exit */\n\t\tif (plch == '\\n' && lch == '.' && ch == '\\n') {\n\t\t\t/* don't include the dot in the note */\n\t\t\tbl -= 3;\n\t\t\tbuffer[bl] = 0;\n\t\t\tquit = 1;\n\t\t/* check for escape exit */\n\t\t}else if (ch == 27) {\n\t\t\tquit = 1;\n\t\t}\n\t}\n\n\t/* exit curses */\n\tendwin();\n\n\t/* save the note */\n\tif (!db_update(name,buffer))\n\t\treturn 1;\n\n\t/* let the user know */\n\tprintf(\"%s saved\\n\",name);\n\n\treturn 0;\n}\n\n/* edit with an external editor */\nstatic int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\n\tstrcpy(buff,\"/tmp/nodau.XXXXXX\");\n\tfd = mkstemp(buff);\n\n\tif (fd < 0)\n\t\treturn 1;\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\t/* find the file length */\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\t/* load the note into memory */\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\t/* delete the file */\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\t/* find the note data */\n\t\t\t\tl = strstr(b,\"-----\");\n\t\t\t\tif (l) {\n\t\t\t\t\t/* save the note */\n\t\t\t\t\tl += 6;\n\t\t\t\t\tint r = db_update(name,l);\n\t\t\t\t\tif (r != SQLITE_DONE && r != SQLITE_OK)\n\t\t\t\t\t\treturn 1;\n\n\t\t\t\t\t/* let the user know */\n\t\t\t\t\tprintf(\"%s saved\\n\",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\n\t/* insert data into file */\n\tsz = sprintf(\n\t\tb,\n\t\t\"%s (%s)\\nText above this line is ignored\\n-----\\n%s\",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\n\tst = execl(editor,editor,buff,(char*)NULL);\n\n\t/* we should only ever get here if something goes wrong with exec */\n\texit(st);\n\n\t/* and we shouldn't ever get here, but it stops the compiler complaining */\n\treturn 1;\n}\n\n/* edit a note using data piped from stdin */\nint edit_stdin(char* name, char* date, char* data, int append)\n{\n\tchar buff[1024];\n\tint l;\n\tint s;\n\tint r;\n\tchar* d;\n\tchar* b;\n\n\t/* get the initial buffer size */\n\tl = strlen(data);\n\tif (l < 512) {\n\t\ts = 512;\n\t}else{\n\t\ts = l*2;\n\t}\n\n\td = malloc(s);\n\tif (!d)\n\t\treturn 1;\n\n\t/* for append mode copy the old data to the start of the buffer */\n\tif (append && strcmp(data,\"new entry\")) {\n\t\tstrcpy(d,data);\n\t}else{\n\t\tl = 0;\n\t}\n\n\t/* read it in */\n\twhile ((r = read(STDIN_FILENO,buff,1024)) > 0) {\n\t\t/* extend the buffer as necessary */\n\t\tif (l+r+1 > s) {\n\t\t\ts = l+r+512;\n\t\t\tb = realloc(d,s);\n\t\t\tif (!b)\n\t\t\t\treturn 1;\n\t\t\td = b;\n\t\t}\n\t\tmemcpy(d+l,buff,r);\n\t\tl += r;\n\t}\n\n\t/* make sure there's room for the nul byte */\n\tif (l+1 > s) {\n\t\ts = l+1;\n\t\tb = realloc(d,s);\n\t\tif (!b)\n\t\t\treturn 1;\n\t\td = b;\n\t}\n\n\td[l] = 0;\n\n\t/* done */\n\treturn db_update(name,d);\n}\n\n/* edit a note */\nint edit(char* name, char* date, char* data)\n{\n\tchar* ed;\n\tchar* pt;\n\tchar* editor;\n\tchar* p = NULL;\n\tstruct stat st;\n\n\tif (!isatty(STDIN_FILENO))\n\t\treturn edit_stdin(name,date,data,0);\n\n\tpt = getenv(\"PATH\");\n\n\ted = config_read(\"external_editor\",NULL);\n\tif (!ed)\n\t\ted = getenv(\"EDITOR\");\n\n\t/* no editor or no path, use builtin */\n\tif (config_read(\"force_builtin_editor\",\"true\") || !ed || (ed[0] != '/' && !pt))\n\t\treturn edit_builtin(name,date,data);\n\n\t/* find the executable */\n\tif (ed[0] == '/') {\n\t\tstat(ed,&st);\n\t\t/* check it exists */\n\t\tif (S_ISREG(st.st_mode)) {\n\t\t\tp = ed;\n\t\t\teditor = strdup(ed);\n\t\t}\n\t}else{\n\t\tp = strtok(pt,\":\");\n\t\twhile (p) {\n\t\t\tp = strtok(NULL,\":\");\n\n\t\t\tif (asprintf(&editor,\"%s/%s\",p,ed) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tstat(editor,&st);\n\t\t\t/* check it exists */\n\t\t\tif (S_ISREG(st.st_mode))\n\t\t\t\tbreak;\n\n\t\t\tfree(editor);\n\t\t}\n\t}\n\n\t/* no executable, or fails to run, use builtin */\n\tif (!p || edit_ext(editor,name,date,data))\n\t\treturn edit_builtin(name,date,data);\n\n\treturn 0;\n}\n"], "filenames": ["CHANGELOG", "src/db.c", "src/edit.c"], "buggy_code_start_loc": [87, 288, 196], "buggy_code_end_loc": [87, 300, 197], "fixing_code_start_loc": [88, 288, 196], "fixing_code_end_loc": [91, 317, 198], "type": "CWE-89", "message": "A vulnerability was found in TicklishHoneyBee nodau. It has been rated as critical. Affected by this issue is some unknown functionality of the file src/db.c. The manipulation of the argument value/name leads to sql injection. The name of the patch is 7a7d737a3929f335b9717ddbd31db91151b69ad2. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215252.", "other": {"cve": {"id": "CVE-2022-4399", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-10T22:15:17.697", "lastModified": "2022-12-13T14:39:30.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in TicklishHoneyBee nodau. It has been rated as critical. Affected by this issue is some unknown functionality of the file src/db.c. The manipulation of the argument value/name leads to sql injection. The name of the patch is 7a7d737a3929f335b9717ddbd31db91151b69ad2. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215252."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-707"}, {"lang": "en", "value": "CWE-74"}, {"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodau_project:nodau:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.9", "matchCriteriaId": "76FDDEE6-0367-456E-82A2-FC04E20546B4"}]}]}], "references": [{"url": "https://github.com/TicklishHoneyBee/nodau/commit/7a7d737a3929f335b9717ddbd31db91151b69ad2", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TicklishHoneyBee/nodau/pull/26", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.215252", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/TicklishHoneyBee/nodau/commit/7a7d737a3929f335b9717ddbd31db91151b69ad2"}}