{"buggy_code": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/***************************************************************************\n * Copyright (C) 2017-2019 ZmartZone IAM\n * Copyright (C) 2013-2017 Ping Identity Corporation\n * All rights reserved.\n *\n * For further information please contact:\n *\n *      Ping Identity Corporation\n *      1099 18th St Suite 2950\n *      Denver, CO 80202\n *      303.468.2900\n *      http://www.pingidentity.com\n *\n * DISCLAIMER OF WARRANTIES:\n *\n * THE SOFTWARE PROVIDED HEREUNDER IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT\n * ANY WARRANTIES OR REPRESENTATIONS EXPRESS, IMPLIED OR STATUTORY; INCLUDING,\n * WITHOUT LIMITATION, WARRANTIES OF QUALITY, PERFORMANCE, NONINFRINGEMENT,\n * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  NOR ARE THERE ANY\n * WARRANTIES CREATED BY A COURSE OR DEALING, COURSE OF PERFORMANCE OR TRADE\n * USAGE.  FURTHERMORE, THERE ARE NO WARRANTIES THAT THE SOFTWARE WILL MEET\n * YOUR NEEDS OR BE FREE FROM ERRORS, OR THAT THE OPERATION OF THE SOFTWARE\n * WILL BE UNINTERRUPTED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Initially based on mod_auth_cas.c:\n * https://github.com/Jasig/mod_auth_cas\n *\n * Other code copied/borrowed/adapted:\n * shared memory caching: mod_auth_mellon\n *\n * @Author: Hans Zandbelt - hans.zandbelt@zmartzone.eu\n *\n **************************************************************************/\n\n#include \"apr_hash.h\"\n#include \"apr_strings.h\"\n#include \"ap_config.h\"\n#include \"ap_provider.h\"\n#include \"apr_lib.h\"\n#include \"apr_file_io.h\"\n#include \"apr_sha1.h\"\n#include \"apr_base64.h\"\n\n#include \"httpd.h\"\n#include \"http_core.h\"\n#include \"http_config.h\"\n#include \"http_log.h\"\n#include \"http_protocol.h\"\n#include \"http_request.h\"\n\n#include \"mod_auth_openidc.h\"\n\n#define ERROR 2\n\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url);\n\n// TODO:\n// - sort out oidc_cfg vs. oidc_dir_cfg stuff\n// - rigid input checking on discovery responses\n// - check self-issued support\n// - README.quickstart\n// - refresh metadata once-per too? (for non-signing key changes)\n\nextern module AP_MODULE_DECLARE_DATA auth_openidc_module;\n\n/*\n * clean any suspicious headers in the HTTP request sent by the user agent\n */\nstatic void oidc_scrub_request_headers(request_rec *r, const char *claim_prefix,\n\t\tapr_hash_t *scrub) {\n\n\tconst int prefix_len = claim_prefix ? strlen(claim_prefix) : 0;\n\n\t/* get an array representation of the incoming HTTP headers */\n\tconst apr_array_header_t * const h = apr_table_elts(r->headers_in);\n\n\t/* table to keep the non-suspicious headers */\n\tapr_table_t *clean_headers = apr_table_make(r->pool, h->nelts);\n\n\t/* loop over the incoming HTTP headers */\n\tconst apr_table_entry_t * const e = (const apr_table_entry_t *) h->elts;\n\tint i;\n\tfor (i = 0; i < h->nelts; i++) {\n\t\tconst char * const k = e[i].key;\n\n\t\t/* is this header's name equivalent to a header that needs scrubbing? */\n\t\tconst char *hdr =\n\t\t\t\t(k != NULL) && (scrub != NULL) ?\n\t\t\t\t\t\tapr_hash_get(scrub, k, APR_HASH_KEY_STRING) : NULL;\n\t\tconst int header_matches = (hdr != NULL)\n\t\t\t\t\t\t&& (oidc_strnenvcmp(k, hdr, -1) == 0);\n\n\t\t/*\n\t\t * would this header be interpreted as a mod_auth_openidc attribute? Note\n\t\t * that prefix_len will be zero if no attr_prefix is defined,\n\t\t * so this will always be false. Also note that we do not\n\t\t * scrub headers if the prefix is empty because every header\n\t\t * would match.\n\t\t */\n\t\tconst int prefix_matches = (k != NULL) && prefix_len\n\t\t\t\t&& (oidc_strnenvcmp(k, claim_prefix, prefix_len) == 0);\n\n\t\t/* add to the clean_headers if non-suspicious, skip and report otherwise */\n\t\tif (!prefix_matches && !header_matches) {\n\t\t\tapr_table_addn(clean_headers, k, e[i].val);\n\t\t} else {\n\t\t\toidc_warn(r, \"scrubbed suspicious request header (%s: %.32s)\", k,\n\t\t\t\t\te[i].val);\n\t\t}\n\t}\n\n\t/* overwrite the incoming headers with the cleaned result */\n\tr->headers_in = clean_headers;\n}\n\n/*\n * scrub all mod_auth_openidc related headers\n */\nvoid oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *prefix = oidc_cfg_claim_prefix(r);\n\tapr_hash_t *hdrs = apr_hash_make(r->pool);\n\n\tif (apr_strnatcmp(prefix, \"\") == 0) {\n\t\tif ((cfg->white_listed_claims != NULL)\n\t\t\t\t&& (apr_hash_count(cfg->white_listed_claims) > 0))\n\t\t\thdrs = apr_hash_overlay(r->pool, cfg->white_listed_claims, hdrs);\n\t\telse\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"both \" OIDCClaimPrefix \" and \" OIDCWhiteListedClaims \" are empty: this renders an insecure setup!\");\n\t}\n\n\tchar *authn_hdr = oidc_cfg_dir_authn_header(r);\n\tif (authn_hdr != NULL)\n\t\tapr_hash_set(hdrs, authn_hdr, APR_HASH_KEY_STRING, authn_hdr);\n\n\t/*\n\t * scrub all headers starting with OIDC_ first\n\t */\n\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX, hdrs);\n\n\t/*\n\t * then see if the claim headers need to be removed on top of that\n\t * (i.e. the prefix does not start with the default OIDC_)\n\t */\n\tif ((strstr(prefix, OIDC_DEFAULT_HEADER_PREFIX) != prefix)) {\n\t\toidc_scrub_request_headers(r, prefix, NULL);\n\t}\n}\n\n/*\n * strip the session cookie from the headers sent to the application/backend\n */\nvoid oidc_strip_cookies(request_rec *r) {\n\n\tchar *cookie, *ctx, *result = NULL;\n\tconst char *name = NULL;\n\tint i;\n\n\tapr_array_header_t *strip = oidc_dir_cfg_strip_cookies(r);\n\n\tchar *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));\n\n\tif ((cookies != NULL) && (strip != NULL)) {\n\n\t\toidc_debug(r,\n\t\t\t\t\"looking for the following cookies to strip from cookie header: %s\",\n\t\t\t\tapr_array_pstrcat(r->pool, strip, OIDC_CHAR_COMMA));\n\n\t\tcookie = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &ctx);\n\n\t\tdo {\n\t\t\twhile (cookie != NULL && *cookie == OIDC_CHAR_SPACE)\n\t\t\t\tcookie++;\n\n\t\t\tfor (i = 0; i < strip->nelts; i++) {\n\t\t\t\tname = ((const char**) strip->elts)[i];\n\t\t\t\tif ((strncmp(cookie, name, strlen(name)) == 0)\n\t\t\t\t\t\t&& (cookie[strlen(name)] == OIDC_CHAR_EQUAL)) {\n\t\t\t\t\toidc_debug(r, \"stripping: %s\", name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == strip->nelts) {\n\t\t\t\tresult = result ? apr_psprintf(r->pool, \"%s%s%s\", result,\n\t\t\t\t\t\tOIDC_STR_SEMI_COLON, cookie) :\n\t\t\t\t\t\tcookie;\n\t\t\t}\n\n\t\t\tcookie = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &ctx);\n\t\t} while (cookie != NULL);\n\n\t\toidc_util_hdr_in_cookie_set(r, result);\n\t}\n}\n\n#define OIDC_SHA1_LEN 20\n\n/*\n * calculates a hash value based on request fingerprint plus a provided nonce string.\n */\nstatic char *oidc_get_browser_state_hash(request_rec *r, const char *nonce) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* helper to hold to header values */\n\tconst char *value = NULL;\n\t/* the hash context */\n\tapr_sha1_ctx_t sha1;\n\n\t/* Initialize the hash context */\n\tapr_sha1_init(&sha1);\n\n\t/* get the X-FORWARDED-FOR header value  */\n\tvalue = oidc_util_hdr_in_x_forwarded_for_get(r);\n\t/* if we have a value for this header, concat it to the hash input */\n\tif (value != NULL)\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\n\t/* get the USER-AGENT header value  */\n\tvalue = oidc_util_hdr_in_user_agent_get(r);\n\t/* if we have a value for this header, concat it to the hash input */\n\tif (value != NULL)\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\n\t/* get the remote client IP address or host name */\n\t/*\n\tint remotehost_is_ip;\n\tvalue = ap_get_remote_host(r->connection, r->per_dir_config,\n\t\t\tREMOTE_NOLOOKUP, &remotehost_is_ip);\n\tapr_sha1_update(&sha1, value, strlen(value));\n\t*/\n\n\t/* concat the nonce parameter to the hash input */\n\tapr_sha1_update(&sha1, nonce, strlen(nonce));\n\n\t/* concat the token binding ID if present */\n\tvalue = oidc_util_get_provided_token_binding_id(r);\n\tif (value != NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"Provided Token Binding ID environment variable found; adding its value to the state\");\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\t}\n\n\t/* finalize the hash input and calculate the resulting hash output */\n\tunsigned char hash[OIDC_SHA1_LEN];\n\tapr_sha1_final(hash, &sha1);\n\n\t/* base64url-encode the resulting hash and return it */\n\tchar *result = NULL;\n\toidc_base64url_encode(r, &result, (const char *) hash, OIDC_SHA1_LEN, TRUE);\n\treturn result;\n}\n\n/*\n * return the name for the state cookie\n */\nstatic char *oidc_get_state_cookie_name(request_rec *r, const char *state) {\n\treturn apr_psprintf(r->pool, \"%s%s\", OIDC_STATE_COOKIE_PREFIX, state);\n}\n\n/*\n * return the static provider configuration, i.e. from a metadata URL or configuration primitives\n */\nstatic apr_byte_t oidc_provider_static_config(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t **provider) {\n\n\tjson_t *j_provider = NULL;\n\tchar *s_json = NULL;\n\n\t/* see if we should configure a static provider based on external (cached) metadata */\n\tif ((c->metadata_dir != NULL) || (c->provider.metadata_url == NULL)) {\n\t\t*provider = &c->provider;\n\t\treturn TRUE;\n\t}\n\n\toidc_cache_get_provider(r, c->provider.metadata_url, &s_json);\n\n\tif (s_json == NULL) {\n\n\t\tif (oidc_metadata_provider_retrieve(r, c, NULL,\n\t\t\t\tc->provider.metadata_url, &j_provider, &s_json) == FALSE) {\n\t\t\toidc_error(r, \"could not retrieve metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\toidc_cache_set_provider(r, c->provider.metadata_url, s_json,\n\t\t\t\tapr_time_now() + (c->provider_metadata_refresh_interval <= 0 ? apr_time_from_sec( OIDC_CACHE_PROVIDER_METADATA_EXPIRY_DEFAULT) : c->provider_metadata_refresh_interval));\n\n\t} else {\n\n\t\toidc_util_decode_json_object(r, s_json, &j_provider);\n\n\t\t/* check to see if it is valid metadata */\n\t\tif (oidc_metadata_provider_is_valid(r, c, j_provider, NULL) == FALSE) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"cache corruption detected: invalid metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t*provider = apr_pcalloc(r->pool, sizeof(oidc_provider_t));\n\tmemcpy(*provider, &c->provider, sizeof(oidc_provider_t));\n\n\tif (oidc_metadata_provider_parse(r, c, j_provider, *provider) == FALSE) {\n\t\toidc_error(r, \"could not parse metadata from url: %s\",\n\t\t\t\tc->provider.metadata_url);\n\t\tif (j_provider)\n\t\t\tjson_decref(j_provider);\n\t\treturn FALSE;\n\t}\n\n\tjson_decref(j_provider);\n\n\treturn TRUE;\n}\n\n/*\n * return the oidc_provider_t struct for the specified issuer\n */\nstatic oidc_provider_t *oidc_get_provider_for_issuer(request_rec *r,\n\t\toidc_cfg *c, const char *issuer, apr_byte_t allow_discovery) {\n\n\t/* by default we'll assume that we're dealing with a single statically configured OP */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\treturn NULL;\n\n\t/* unless a metadata directory was configured, so we'll try and get the provider settings from there */\n\tif (c->metadata_dir != NULL) {\n\n\t\t/* try and get metadata from the metadata directory for the OP that sent this response */\n\t\tif ((oidc_metadata_get(r, c, issuer, &provider, allow_discovery)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\n\t\t\t/* don't know nothing about this OP/issuer */\n\t\t\toidc_error(r, \"no provider metadata found for issuer \\\"%s\\\"\",\n\t\t\t\t\tissuer);\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn provider;\n}\n\n/*\n * find out whether the request is a response from an IDP discovery page\n */\nstatic apr_byte_t oidc_is_discovery_response(request_rec *r, oidc_cfg *cfg) {\n\t/*\n\t * prereq: this is a call to the configured redirect_uri, now see if:\n\t * the OIDC_DISC_OP_PARAM is present\n\t */\n\treturn oidc_util_request_has_parameter(r, OIDC_DISC_OP_PARAM)\n\t\t\t|| oidc_util_request_has_parameter(r, OIDC_DISC_USER_PARAM);\n}\n\n/*\n * return the HTTP method being called: only for POST data persistence purposes\n */\nstatic const char *oidc_original_request_method(request_rec *r, oidc_cfg *cfg,\n\t\tapr_byte_t handle_discovery_response) {\n\tconst char *method = OIDC_METHOD_GET;\n\n\tchar *m = NULL;\n\tif ((handle_discovery_response == TRUE)\n\t\t\t&& (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, cfg)))\n\t\t\t&& (oidc_is_discovery_response(r, cfg))) {\n\t\toidc_util_get_request_parameter(r, OIDC_DISC_RM_PARAM, &m);\n\t\tif (m != NULL)\n\t\t\tmethod = apr_pstrdup(r->pool, m);\n\t} else {\n\n\t\t/*\n\t\t * if POST preserve is not enabled for this location, there's no point in preserving\n\t\t * the method either which would result in POSTing empty data on return;\n\t\t * so we revert to legacy behavior\n\t\t */\n\t\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\t\treturn OIDC_METHOD_GET;\n\n\t\tconst char *content_type = oidc_util_hdr_in_content_type_get(r);\n\t\tif ((r->method_number == M_POST) && (apr_strnatcmp(content_type,\n\t\t\t\tOIDC_CONTENT_TYPE_FORM_ENCODED) == 0))\n\t\t\tmethod = OIDC_METHOD_FORM_POST;\n\t}\n\n\toidc_debug(r, \"return: %s\", method);\n\n\treturn method;\n}\n\n/*\n * send an OpenID Connect authorization request to the specified provider preserving POST parameters using HTML5 storage\n */\napr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * restore POST parameters on original_url from HTML5 local storage\n */\nstatic int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}\n\n/*\n * parse state that was sent to us by the issuer\n */\nstatic apr_byte_t oidc_unsolicited_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t **proto_state) {\n\n\tchar *alg = NULL;\n\toidc_debug(r, \"enter: state header=%s\",\n\t\t\toidc_proto_peek_jwt_header(r, state, &alg));\n\n\toidc_jose_error_t err;\n\toidc_jwk_t *jwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, c->provider.client_secret,\n\t\t\toidc_alg2keysize(alg), OIDC_JOSE_ALG_SHA256,\n\t\t\tTRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwt_t *jwt = NULL;\n\tif (oidc_jwt_parse(r->pool, state, &jwt,\n\t\t\toidc_util_merge_symmetric_key(r->pool, c->private_keys, jwk),\n\t\t\t&err) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse JWT from state: invalid unsolicited response: %s\",\n\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\treturn FALSE;\n\t}\n\n\toidc_jwk_destroy(jwk);\n\toidc_debug(r, \"successfully parsed JWT from state\");\n\n\tif (jwt->payload.iss == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" could be retrieved from JWT state, aborting\",\n\t\t\t\tOIDC_CLAIM_ISS);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\toidc_provider_t *provider = oidc_get_provider_for_issuer(r, c,\n\t\t\tjwt->payload.iss, FALSE);\n\tif (provider == NULL) {\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the state JWT, validating optional exp + iat */\n\tif (oidc_proto_validate_jwt(r, jwt, provider->issuer, FALSE, FALSE,\n\t\t\tprovider->idtoken_iat_slack,\n\t\t\tOIDC_TOKEN_BINDING_POLICY_DISABLED) == FALSE) {\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tchar *rfp = NULL;\n\tif (oidc_jose_get_string(r->pool, jwt->payload.value.json, OIDC_CLAIM_RFP,\n\t\t\tTRUE, &rfp, &err) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"no \\\"%s\\\" claim could be retrieved from JWT state, aborting: %s\",\n\t\t\t\tOIDC_CLAIM_RFP, oidc_jose_e2s(r->pool, err));\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tif (apr_strnatcmp(rfp, OIDC_PROTO_ISS) != 0) {\n\t\toidc_error(r, \"\\\"%s\\\" (%s) does not match \\\"%s\\\", aborting\",\n\t\t\t\tOIDC_CLAIM_RFP, rfp, OIDC_PROTO_ISS);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tchar *target_link_uri = NULL;\n\toidc_jose_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_TARGET_LINK_URI,\n\t\t\tFALSE, &target_link_uri, NULL);\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"no \\\"%s\\\" claim could be retrieved from JWT state and no \" OIDCDefaultURL \" is set, aborting\",\n\t\t\t\t\tOIDC_CLAIM_TARGET_LINK_URI);\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn FALSE;\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\tif (c->metadata_dir != NULL) {\n\t\tif ((oidc_metadata_get(r, c, jwt->payload.iss, &provider, FALSE)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\t\t\toidc_error(r, \"no provider metadata found for provider \\\"%s\\\"\",\n\t\t\t\t\tjwt->payload.iss);\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tchar *jti = NULL;\n\toidc_jose_get_string(r->pool, jwt->payload.value.json, OIDC_CLAIM_JTI,\n\t\t\tFALSE, &jti,\n\t\t\tNULL);\n\tif (jti == NULL) {\n\t\tchar *cser = oidc_jwt_serialize(r->pool, jwt, &err);\n\t\tif (cser == NULL)\n\t\t\treturn FALSE;\n\t\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\t\tcser, &jti) == FALSE) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tchar *replay = NULL;\n\toidc_cache_get_jti(r, jti, &replay);\n\tif (replay != NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"the \\\"%s\\\" value (%s) passed in the browser state was found in the cache already; possible replay attack!?\",\n\t\t\t\tOIDC_CLAIM_JTI, jti);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\t/* jti cache duration is the configured replay prevention window for token issuance plus 10 seconds for safety */\n\tapr_time_t jti_cache_duration = apr_time_from_sec(\n\t\t\tprovider->idtoken_iat_slack * 2 + 10);\n\n\t/* store it in the cache for the calculated duration */\n\toidc_cache_set_jti(r, jti, jti, apr_time_now() + jti_cache_duration);\n\n\toidc_debug(r,\n\t\t\t\"jti \\\"%s\\\" validated successfully and is now cached for %\" APR_TIME_T_FMT \" seconds\",\n\t\t\tjti, apr_time_sec(jti_cache_duration));\n\n\tjwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, c->provider.client_secret, 0,\n\t\t\tNULL, TRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwks_uri_t jwks_uri = { provider->jwks_uri,\n\t\t\tprovider->jwks_refresh_interval, provider->ssl_validate_server };\n\tif (oidc_proto_jwt_verify(r, c, jwt, &jwks_uri,\n\t\t\toidc_util_merge_symmetric_key(r->pool, NULL, jwk)) == FALSE) {\n\t\toidc_error(r, \"state JWT could not be validated, aborting\");\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\toidc_jwk_destroy(jwk);\n\toidc_debug(r, \"successfully verified state JWT\");\n\n\t*proto_state = oidc_proto_state_new();\n\toidc_proto_state_set_issuer(*proto_state, jwt->payload.iss);\n\toidc_proto_state_set_original_url(*proto_state, target_link_uri);\n\toidc_proto_state_set_original_method(*proto_state, OIDC_METHOD_GET);\n\toidc_proto_state_set_response_mode(*proto_state, provider->response_mode);\n\toidc_proto_state_set_response_type(*proto_state, provider->response_type);\n\toidc_proto_state_set_timestamp_now(*proto_state);\n\n\toidc_jwt_destroy(jwt);\n\n\treturn TRUE;\n}\n\ntypedef struct oidc_state_cookies_t {\n\tchar *name;\n\tapr_time_t timestamp;\n\tstruct oidc_state_cookies_t *next;\n} oidc_state_cookies_t;\n\nstatic int oidc_delete_oldest_state_cookies(request_rec *r,\n\t\tint number_of_valid_state_cookies, int max_number_of_state_cookies,\n\t\toidc_state_cookies_t *first) {\n\toidc_state_cookies_t *cur = NULL, *prev = NULL, *prev_oldest = NULL,\n\t\t\t*oldest = NULL;\n\twhile (number_of_valid_state_cookies >= max_number_of_state_cookies) {\n\t\toldest = first;\n\t\tprev_oldest = NULL;\n\t\tprev = first;\n\t\tcur = first->next;\n\t\twhile (cur) {\n\t\t\tif ((cur->timestamp < oldest->timestamp)) {\n\t\t\t\toldest = cur;\n\t\t\t\tprev_oldest = prev;\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t\toidc_warn(r,\n\t\t\t\t\"deleting oldest state cookie: %s (time until expiry %\" APR_TIME_T_FMT \" seconds)\",\n\t\t\t\toldest->name, apr_time_sec(oldest->timestamp - apr_time_now()));\n\t\toidc_util_set_cookie(r, oldest->name, \"\", 0, NULL);\n\t\tif (prev_oldest)\n\t\t\tprev_oldest->next = oldest->next;\n\t\telse\n\t\t\tfirst = first->next;\n\t\tnumber_of_valid_state_cookies--;\n\t}\n\treturn number_of_valid_state_cookies;\n}\n\n/*\n * clean state cookies that have expired i.e. for outstanding requests that will never return\n * successfully and return the number of remaining valid cookies/outstanding-requests while\n * doing so\n */\nstatic int oidc_clean_expired_state_cookies(request_rec *r, oidc_cfg *c,\n\t\tconst char *currentCookieName, int delete_oldest) {\n\tint number_of_valid_state_cookies = 0;\n\toidc_state_cookies_t *first = NULL, *last = NULL;\n\tchar *cookie, *tokenizerCtx = NULL;\n\tchar *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));\n\tif (cookies != NULL) {\n\t\tcookie = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &tokenizerCtx);\n\t\twhile (cookie != NULL) {\n\t\t\twhile (*cookie == OIDC_CHAR_SPACE)\n\t\t\t\tcookie++;\n\t\t\tif (strstr(cookie, OIDC_STATE_COOKIE_PREFIX) == cookie) {\n\t\t\t\tchar *cookieName = cookie;\n\t\t\t\twhile (cookie != NULL && *cookie != OIDC_CHAR_EQUAL)\n\t\t\t\t\tcookie++;\n\t\t\t\tif (*cookie == OIDC_CHAR_EQUAL) {\n\t\t\t\t\t*cookie = '\\0';\n\t\t\t\t\tcookie++;\n\t\t\t\t\tif ((currentCookieName == NULL)\n\t\t\t\t\t\t\t|| (apr_strnatcmp(cookieName, currentCookieName)\n\t\t\t\t\t\t\t\t\t!= 0)) {\n\t\t\t\t\t\toidc_proto_state_t *proto_state =\n\t\t\t\t\t\t\t\toidc_proto_state_from_cookie(r, c, cookie);\n\t\t\t\t\t\tif (proto_state != NULL) {\n\t\t\t\t\t\t\tjson_int_t ts = oidc_proto_state_get_timestamp(\n\t\t\t\t\t\t\t\t\tproto_state);\n\t\t\t\t\t\t\tif (apr_time_now() > ts + apr_time_from_sec(c->state_timeout)) {\n\t\t\t\t\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\t\t\t\t\"state (%s) has expired (original_url=%s)\",\n\t\t\t\t\t\t\t\t\t\tcookieName,\n\t\t\t\t\t\t\t\t\t\toidc_proto_state_get_original_url(\n\t\t\t\t\t\t\t\t\t\t\t\tproto_state));\n\t\t\t\t\t\t\t\toidc_util_set_cookie(r, cookieName, \"\", 0,\n\t\t\t\t\t\t\t\t\t\tNULL);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (first == NULL) {\n\t\t\t\t\t\t\t\t\tfirst = apr_pcalloc(r->pool,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(oidc_state_cookies_t));\n\t\t\t\t\t\t\t\t\tlast = first;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlast->next = apr_pcalloc(r->pool,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(oidc_state_cookies_t));\n\t\t\t\t\t\t\t\t\tlast = last->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlast->name = cookieName;\n\t\t\t\t\t\t\t\tlast->timestamp = ts;\n\t\t\t\t\t\t\t\tlast->next = NULL;\n\t\t\t\t\t\t\t\tnumber_of_valid_state_cookies++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcookie = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &tokenizerCtx);\n\t\t}\n\t}\n\n\tif (delete_oldest > 0)\n\t\tnumber_of_valid_state_cookies = oidc_delete_oldest_state_cookies(r,\n\t\t\t\tnumber_of_valid_state_cookies, c->max_number_of_state_cookies,\n\t\t\t\tfirst);\n\n\treturn number_of_valid_state_cookies;\n}\n\n/*\n * restore the state that was maintained between authorization request and response in an encrypted cookie\n */\nstatic apr_byte_t oidc_restore_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t **proto_state) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* clean expired state cookies to avoid pollution */\n\toidc_clean_expired_state_cookies(r, c, cookieName, FALSE);\n\n\t/* get the state cookie value first */\n\tchar *cookieValue = oidc_util_get_cookie(r, cookieName);\n\tif (cookieValue == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" state cookie found\", cookieName);\n\t\treturn oidc_unsolicited_proto_state(r, c, state, proto_state);\n\t}\n\n\t/* clear state cookie because we don't need it anymore */\n\toidc_util_set_cookie(r, cookieName, \"\", 0, NULL);\n\n\t*proto_state = oidc_proto_state_from_cookie(r, c, cookieValue);\n\tif (*proto_state == NULL)\n\t\treturn FALSE;\n\n\tconst char *nonce = oidc_proto_state_get_nonce(*proto_state);\n\n\t/* calculate the hash of the browser fingerprint concatenated with the nonce */\n\tchar *calc = oidc_get_browser_state_hash(r, nonce);\n\t/* compare the calculated hash with the value provided in the authorization response */\n\tif (apr_strnatcmp(calc, state) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"calculated state from cookie does not match state parameter passed back in URL: \\\"%s\\\" != \\\"%s\\\"\",\n\t\t\t\tstate, calc);\n\t\toidc_proto_state_destroy(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\tapr_time_t ts = oidc_proto_state_get_timestamp(*proto_state);\n\n\t/* check that the timestamp is not beyond the valid interval */\n\tif (apr_time_now() > ts + apr_time_from_sec(c->state_timeout)) {\n\t\toidc_error(r, \"state has expired\");\n\t\t/*\n\t\t * note that this overrides redirection to the OIDCDefaultURL as done later...\n\t\t * see: https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/mod_auth_openidc/L4JFBw-XCNU/BWi2Fmk2AwAJ\n\t\t */\n\t\toidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Authentication Response\",\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"This is due to a timeout; please restart your authentication session by re-entering the URL/bookmark you originally wanted to access: %s\",\n\t\t\t\t\t\toidc_proto_state_get_original_url(*proto_state)),\n\t\t\t\t\t\tOK);\n\t\toidc_proto_state_destroy(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\t/* add the state */\n\toidc_proto_state_set_state(*proto_state, state);\n\n\t/* log the restored state object */\n\toidc_debug(r, \"restored state: %s\",\n\t\t\toidc_proto_state_to_string(r, *proto_state));\n\n\t/* we've made it */\n\treturn TRUE;\n}\n\n/*\n * set the state that is maintained between an authorization request and an authorization response\n * in a cookie in the browser that is cryptographically bound to that state\n */\nstatic int oidc_authorization_request_set_cookie(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t *proto_state) {\n\t/*\n\t * create a cookie consisting of 8 elements:\n\t * random value, original URL, original method, issuer, response_type, response_mod, prompt and timestamp\n\t * encoded as JSON, encrypting the resulting JSON value\n\t */\n\tchar *cookieValue = oidc_proto_state_to_cookie(r, c, proto_state);\n\tif (cookieValue == NULL)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/*\n\t * clean expired state cookies to avoid pollution and optionally\n\t * try to avoid the number of state cookies exceeding a max\n\t */\n\tint number_of_cookies = oidc_clean_expired_state_cookies(r, c, NULL,\n\t\t\toidc_cfg_delete_oldest_state_cookies(c));\n\tint max_number_of_cookies = oidc_cfg_max_number_of_state_cookies(c);\n\tif ((max_number_of_cookies > 0)\n\t\t\t&& (number_of_cookies >= max_number_of_cookies)) {\n\n\t\toidc_warn(r,\n\t\t\t\t\"the number of existing, valid state cookies (%d) has exceeded the limit (%d), no additional authorization request + state cookie can be generated, aborting the request\",\n\t\t\t\tnumber_of_cookies, max_number_of_cookies);\n\t\t/*\n\t\t * TODO: the html_send code below caters for the case that there's a user behind a\n\t\t * browser generating this request, rather than a piece of XHR code; how would an\n\t\t * XHR client handle this?\n\t\t */\n\n\t\t/*\n\t\t * it appears that sending content with a 503 turns the HTTP status code\n\t\t * into a 200 so we'll avoid that for now: the user will see Apache specific\n\t\t * readable text anyway\n\t\t *\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Too Many Outstanding Requests\",\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No authentication request could be generated since there are too many outstanding authentication requests already; you may have to wait up to %d seconds to be able to create a new request\",\n\t\t\t\t\t\tc->state_timeout),\n\t\t\t\t\t\tHTTP_SERVICE_UNAVAILABLE);\n\t\t*/\n\n\t\treturn HTTP_SERVICE_UNAVAILABLE;\n\t}\n\n\t/* assemble the cookie name for the state cookie */\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* set it as a cookie */\n\toidc_util_set_cookie(r, cookieName, cookieValue, -1,\n\t\t\tc->cookie_same_site ? OIDC_COOKIE_EXT_SAME_SITE_LAX : NULL);\n\n\treturn HTTP_OK;\n}\n\n/*\n * get the mod_auth_openidc related context from the (userdata in the) request\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nstatic apr_table_t *oidc_request_state(request_rec *rr) {\n\n\t/* our state is always stored in the main request */\n\trequest_rec *r = (rr->main != NULL) ? rr->main : rr;\n\n\t/* our state is a table, get it */\n\tapr_table_t *state = NULL;\n\tapr_pool_userdata_get((void **) &state, OIDC_USERDATA_KEY, r->pool);\n\n\t/* if it does not exist, we'll create a new table */\n\tif (state == NULL) {\n\t\tstate = apr_table_make(r->pool, 5);\n\t\tapr_pool_userdata_set(state, OIDC_USERDATA_KEY, NULL, r->pool);\n\t}\n\n\t/* return the resulting table, always non-null now */\n\treturn state;\n}\n\n/*\n * set a name/value pair in the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nvoid oidc_request_state_set(request_rec *r, const char *key, const char *value) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* put the name/value pair in that table */\n\tapr_table_set(state, key, value);\n}\n\n/*\n * get a name/value pair from the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nconst char*oidc_request_state_get(request_rec *r, const char *key) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* return the value from the table */\n\treturn apr_table_get(state, key);\n}\n\n/*\n * set the claims from a JSON object (c.q. id_token or user_info response) stored\n * in the session in to HTTP headers passed on to the application\n */\nstatic apr_byte_t oidc_set_app_claims(request_rec *r,\n\t\tconst oidc_cfg * const cfg, oidc_session_t *session,\n\t\tconst char *s_claims) {\n\n\tjson_t *j_claims = NULL;\n\n\t/* decode the string-encoded attributes in to a JSON structure */\n\tif (s_claims != NULL) {\n\t\tif (oidc_util_decode_json_object(r, s_claims, &j_claims) == FALSE)\n\t\t\treturn FALSE;\n\t}\n\n\t/* set the resolved claims a HTTP headers for the application */\n\tif (j_claims != NULL) {\n\t\toidc_util_set_app_infos(r, j_claims, oidc_cfg_claim_prefix(r),\n\t\t\t\tcfg->claim_delimiter, oidc_cfg_dir_pass_info_in_headers(r),\n\t\t\t\toidc_cfg_dir_pass_info_in_envvars(r));\n\n\t\t/* release resources */\n\t\tjson_decref(j_claims);\n\t}\n\n\treturn TRUE;\n}\n\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params, const char *path_scope);\n\n/*\n * log message about max session duration\n */\nstatic void oidc_log_session_expires(request_rec *r, const char *msg,\n\t\tapr_time_t session_expires) {\n\tchar buf[APR_RFC822_DATE_LEN + 1];\n\tapr_rfc822_date(buf, session_expires);\n\toidc_debug(r, \"%s: %s (in %\" APR_TIME_T_FMT \" secs from now)\", msg, buf,\n\t\t\tapr_time_sec(session_expires - apr_time_now()));\n}\n\n/*\n * see if this is a non-browser request\n */\nstatic apr_byte_t oidc_is_xml_http_request(request_rec *r) {\n\n\tif ((oidc_util_hdr_in_x_requested_with_get(r) != NULL)\n\t\t\t&& (apr_strnatcasecmp(oidc_util_hdr_in_x_requested_with_get(r),\n\t\t\t\t\tOIDC_HTTP_HDR_VAL_XML_HTTP_REQUEST) == 0))\n\t\treturn TRUE;\n\n\tif ((oidc_util_hdr_in_accept_contains(r, OIDC_CONTENT_TYPE_TEXT_HTML)\n\t\t\t== FALSE) && (oidc_util_hdr_in_accept_contains(r,\n\t\t\t\t\tOIDC_CONTENT_TYPE_APP_XHTML_XML) == FALSE)\n\t\t\t\t\t&& (oidc_util_hdr_in_accept_contains(r,\n\t\t\t\t\t\t\tOIDC_CONTENT_TYPE_ANY) == FALSE))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\n/*\n * find out which action we need to take when encountering an unauthenticated request\n */\nstatic int oidc_handle_unauthenticated_user(request_rec *r, oidc_cfg *c) {\n\n\t/* see if we've configured OIDCUnAuthAction for this path */\n\tswitch (oidc_dir_cfg_unauth_action(r)) {\n\tcase OIDC_UNAUTH_RETURN410:\n\t\treturn HTTP_GONE;\n\tcase OIDC_UNAUTH_RETURN401:\n\t\treturn HTTP_UNAUTHORIZED;\n\tcase OIDC_UNAUTH_PASS:\n\t\tr->user = \"\";\n\n\t\t/*\n\t\t * we're not going to pass information about an authenticated user to the application,\n\t\t * but we do need to scrub the headers that mod_auth_openidc would set for security reasons\n\t\t */\n\t\toidc_scrub_headers(r);\n\n\t\treturn OK;\n\n\tcase OIDC_UNAUTH_AUTHENTICATE:\n\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/*\n\t * else: no session (regardless of whether it is main or sub-request),\n\t * and we need to authenticate the user\n\t */\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r),\n\t\t\toidc_dir_cfg_path_scope(r));\n}\n\n/*\n * check if maximum session duration was exceeded\n */\nstatic int oidc_check_max_session_duration(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\t/* get the session expiry from the session data */\n\tapr_time_t session_expires = oidc_session_get_session_expires(r, session);\n\n\t/* check the expire timestamp against the current time */\n\tif (apr_time_now() > session_expires) {\n\t\toidc_warn(r, \"maximum session duration exceeded for user: %s\",\n\t\t\t\tsession->remote_user);\n\t\toidc_session_kill(r, session);\n\t\treturn oidc_handle_unauthenticated_user(r, cfg);\n\t}\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\n\treturn OK;\n}\n\n/*\n * validate received session cookie against the domain it was issued for:\n *\n * this handles the case where the cache configured is a the same single memcache, Redis, or file\n * backend for different (virtual) hosts, or a client-side cookie protected with the same secret\n *\n * it also handles the case that a cookie is unexpectedly shared across multiple hosts in\n * name-based virtual hosting even though the OP(s) would be the same\n */\nstatic apr_byte_t oidc_check_cookie_domain(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tconst char *c_cookie_domain =\n\t\t\tcfg->cookie_domain ?\n\t\t\t\t\tcfg->cookie_domain : oidc_get_current_url_host(r);\n\tconst char *s_cookie_domain = oidc_session_get_cookie_domain(r, session);\n\tif ((s_cookie_domain == NULL)\n\t\t\t|| (apr_strnatcmp(c_cookie_domain, s_cookie_domain) != 0)) {\n\t\toidc_warn(r,\n\t\t\t\t\"aborting: detected attempt to play cookie against a different domain/host than issued for! (issued=%s, current=%s)\",\n\t\t\t\ts_cookie_domain, c_cookie_domain);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * get a handle to the provider configuration via the \"issuer\" stored in the session\n */\napr_byte_t oidc_get_provider_from_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t **provider) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the issuer value from the session state */\n\tconst char *issuer = oidc_session_get_issuer(r, session);\n\tif (issuer == NULL) {\n\t\toidc_error(r, \"session corrupted: no issuer found in session\");\n\t\treturn FALSE;\n\t}\n\n\t/* get the provider info associated with the issuer value */\n\toidc_provider_t *p = oidc_get_provider_for_issuer(r, c, issuer, FALSE);\n\tif (p == NULL) {\n\t\toidc_error(r, \"session corrupted: no provider found for issuer: %s\",\n\t\t\t\tissuer);\n\t\treturn FALSE;\n\t}\n\n\t*provider = p;\n\n\treturn TRUE;\n}\n\n/*\n * store claims resolved from the userinfo endpoint in the session\n */\nstatic void oidc_store_userinfo_claims(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider, const char *claims,\n\t\tconst char *userinfo_jwt) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* see if we've resolved any claims */\n\tif (claims != NULL) {\n\t\t/*\n\t\t * Successfully decoded a set claims from the response so we can store them\n\t\t * (well actually the stringified representation in the response)\n\t\t * in the session context safely now\n\t\t */\n\t\toidc_session_set_userinfo_claims(r, session, claims);\n\n\t\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* this will also clear the entry if a JWT was not returned at this point */\n\t\t\toidc_session_set_userinfo_jwt(r, session, userinfo_jwt);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * clear the existing claims because we could not refresh them\n\t\t */\n\t\toidc_session_set_userinfo_claims(r, session, NULL);\n\n\t\toidc_session_set_userinfo_jwt(r, session, NULL);\n\t}\n\n\t/* store the last refresh time if we've configured a userinfo refresh interval */\n\tif (provider->userinfo_refresh_interval > 0)\n\t\toidc_session_reset_userinfo_last_refresh(r, session);\n}\n\n/*\n * execute refresh token grant to refresh the existing access token\n */\nstatic apr_byte_t oidc_refresh_access_token(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tchar **new_access_token) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the refresh token that was stored in the session */\n\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\tif (refresh_token == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"refresh token routine called but no refresh_token found in the session\");\n\t\treturn FALSE;\n\t}\n\n\t/* elements returned in the refresh response */\n\tchar *s_id_token = NULL;\n\tint expires_in = -1;\n\tchar *s_token_type = NULL;\n\tchar *s_access_token = NULL;\n\tchar *s_refresh_token = NULL;\n\n\t/* refresh the tokens by calling the token endpoint */\n\tif (oidc_proto_refresh_request(r, c, provider, refresh_token, &s_id_token,\n\t\t\t&s_access_token, &s_token_type, &expires_in,\n\t\t\t&s_refresh_token) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\treturn FALSE;\n\t}\n\n\t/* store the new access_token in the session and discard the old one */\n\toidc_session_set_access_token(r, session, s_access_token);\n\toidc_session_set_access_token_expires(r, session, expires_in);\n\n\t/* reset the access token refresh timestamp */\n\toidc_session_reset_access_token_last_refresh(r, session);\n\n\t/* see if we need to return it as a parameter */\n\tif (new_access_token != NULL)\n\t\t*new_access_token = s_access_token;\n\n\t/* if we have a new refresh token (rolling refresh), store it in the session and overwrite the old one */\n\tif (s_refresh_token != NULL)\n\t\toidc_session_set_refresh_token(r, session, s_refresh_token);\n\n\treturn TRUE;\n}\n\n/*\n * retrieve claims from the userinfo endpoint and return the stringified response\n */\nstatic const char *oidc_retrieve_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *c, oidc_provider_t *provider, const char *access_token,\n\t\toidc_session_t *session, char *id_token_sub, char **userinfo_jwt) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *result = NULL;\n\tchar *refreshed_access_token = NULL;\n\n\t/* see if a userinfo endpoint is set, otherwise there's nothing to do for us */\n\tif (provider->userinfo_endpoint_url == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because userinfo_endpoint is not set\");\n\t\treturn NULL;\n\t}\n\n\t/* see if there's an access token, otherwise we can't call the userinfo endpoint at all */\n\tif (access_token == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because access_token is not provided\");\n\t\treturn NULL;\n\t}\n\n\tif ((id_token_sub == NULL) && (session != NULL)) {\n\n\t\t// when refreshing claims from the userinfo endpoint\n\t\tjson_t *id_token_claims = oidc_session_get_idtoken_claims_json(r,\n\t\t\t\tsession);\n\t\tif (id_token_claims == NULL) {\n\t\t\toidc_error(r, \"no id_token_claims found in session\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\toidc_jose_get_string(r->pool, id_token_claims, OIDC_CLAIM_SUB, FALSE,\n\t\t\t\t&id_token_sub, NULL);\n\t}\n\n\t// TODO: return code should indicate whether the token expired or some other error occurred\n\t// TODO: long-term: session storage should be JSON (with explicit types and less conversion, using standard routines)\n\n\t/* try to get claims from the userinfo endpoint using the provided access token */\n\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub, access_token,\n\t\t\t&result, userinfo_jwt) == FALSE) {\n\n\t\t/* see if we have an existing session and we are refreshing the user info claims */\n\t\tif (session != NULL) {\n\n\t\t\t/* first call to user info endpoint failed, but the access token may have just expired, so refresh it */\n\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t&refreshed_access_token) == TRUE) {\n\n\t\t\t\t/* try again with the new access token */\n\t\t\t\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub,\n\t\t\t\t\t\trefreshed_access_token, &result, userinfo_jwt) == FALSE) {\n\n\t\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\t\"resolving user info claims with the refreshed access token failed, nothing will be stored in the session\");\n\t\t\t\t\tresult = NULL;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"refreshing access token failed, claims will not be retrieved/refreshed from the userinfo endpoint\");\n\t\t\t\tresult = NULL;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toidc_error(r,\n\t\t\t\t\t\"resolving user info claims with the existing/provided access token failed, nothing will be stored in the session\");\n\t\t\tresult = NULL;\n\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*\n * get (new) claims from the userinfo endpoint\n */\nstatic apr_byte_t oidc_refresh_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\tconst char *claims = NULL;\n\tconst char *access_token = NULL;\n\tchar *userinfo_jwt = NULL;\n\n\t/* get the current provider info */\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\t/* see if we can do anything here, i.e. we have a userinfo endpoint and a refresh interval is configured */\n\tapr_time_t interval = apr_time_from_sec(\n\t\t\tprovider->userinfo_refresh_interval);\n\n\toidc_debug(r, \"userinfo_endpoint=%s, interval=%d\",\n\t\t\tprovider->userinfo_endpoint_url,\n\t\t\tprovider->userinfo_refresh_interval);\n\n\tif ((provider->userinfo_endpoint_url != NULL) && (interval > 0)) {\n\n\t\t/* get the last refresh timestamp from the session info */\n\t\tapr_time_t last_refresh = oidc_session_get_userinfo_last_refresh(r,\n\t\t\t\tsession);\n\n\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\tapr_time_sec(last_refresh + interval - apr_time_now()));\n\n\t\t/* see if we need to refresh again */\n\t\tif (last_refresh + interval < apr_time_now()) {\n\n\t\t\t/* get the current access token */\n\t\t\taccess_token = oidc_session_get_access_token(r, session);\n\n\t\t\t/* retrieve the current claims */\n\t\t\tclaims = oidc_retrieve_claims_from_userinfo_endpoint(r, cfg,\n\t\t\t\t\tprovider, access_token, session, NULL, &userinfo_jwt);\n\n\t\t\t/* store claims resolved from userinfo endpoint */\n\t\t\toidc_store_userinfo_claims(r, cfg, session, provider, claims,\n\t\t\t\t\tuserinfo_jwt);\n\n\t\t\t/* indicated something changed */\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*\n * copy the claims and id_token from the session to the request state and optionally return them\n */\nstatic void oidc_copy_tokens_to_request_state(request_rec *r,\n\t\toidc_session_t *session, const char **s_id_token, const char **s_claims) {\n\n\tconst char *id_token = oidc_session_get_idtoken_claims(r, session);\n\tconst char *claims = oidc_session_get_userinfo_claims(r, session);\n\n\toidc_debug(r, \"id_token=%s claims=%s\", id_token, claims);\n\n\tif (id_token != NULL) {\n\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_IDTOKEN, id_token);\n\t\tif (s_id_token != NULL)\n\t\t\t*s_id_token = id_token;\n\t}\n\n\tif (claims != NULL) {\n\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_CLAIMS, claims);\n\t\tif (s_claims != NULL)\n\t\t\t*s_claims = claims;\n\t}\n}\n\n/*\n * pass refresh_token, access_token and access_token_expires as headers/environment variables to the application\n */\nstatic apr_byte_t oidc_session_pass_tokens_and_save(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session, apr_byte_t needs_save) {\n\n\tapr_byte_t pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tapr_byte_t pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\t/* set the refresh_token in the app headers/variables, if enabled for this location/directory */\n\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\tif ((oidc_cfg_dir_pass_refresh_token(r) != 0) && (refresh_token != NULL)) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_REFRESH_TOKEN, refresh_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the access_token in the app headers/variables */\n\tconst char *access_token = oidc_session_get_access_token(r, session);\n\tif (access_token != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN, access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the expiry timestamp in the app headers/variables */\n\tconst char *access_token_expires = oidc_session_get_access_token_expires(r,\n\t\t\tsession);\n\tif (access_token_expires != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN_EXP,\n\t\t\t\taccess_token_expires,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/*\n\t * reset the session inactivity timer\n\t * but only do this once per 10% of the inactivity timeout interval (with a max to 60 seconds)\n\t * for performance reasons\n\t *\n\t * now there's a small chance that the session ends 10% (or a minute) earlier than configured/expected\n\t * cq. when there's a request after a recent save (so no update) and then no activity happens until\n\t * a request comes in just before the session should expire\n\t * (\"recent\" and \"just before\" refer to 10%-with-a-max-of-60-seconds of the inactivity interval after\n\t * the start/last-update and before the expiry of the session respectively)\n\t *\n\t * this is be deemed acceptable here because of performance gain\n\t */\n\tapr_time_t interval = apr_time_from_sec(cfg->session_inactivity_timeout);\n\tapr_time_t now = apr_time_now();\n\tapr_time_t slack = interval / 10;\n\tif (slack > apr_time_from_sec(60))\n\t\tslack = apr_time_from_sec(60);\n\tif (session->expiry - now < interval - slack) {\n\t\tsession->expiry = now + interval;\n\t\tneeds_save = TRUE;\n\t}\n\n\t/* log message about session expiry */\n\toidc_log_session_expires(r, \"session inactivity timeout\", session->expiry);\n\n\t/* check if something was updated in the session and we need to save it again */\n\tif (needs_save)\n\t\tif (oidc_session_save(r, session, FALSE) == FALSE)\n\t\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic apr_byte_t oidc_refresh_access_token_before_expiry(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session, int ttl_minimum, int logout_on_error) {\n\n\tconst char *s_access_token_expires = NULL;\n\tapr_time_t t_expires = -1;\n\toidc_provider_t *provider = NULL;\n\n\toidc_debug(r, \"ttl_minimum=%d\", ttl_minimum);\n\n\tif (ttl_minimum < 0)\n\t\treturn FALSE;\n\n\ts_access_token_expires = oidc_session_get_access_token_expires(r, session);\n\tif (s_access_token_expires == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"no access token expires_in stored in the session (i.e. returned from in the authorization response), so cannot refresh the access token based on TTL requirement\");\n\t\treturn FALSE;\n\t}\n\n\tif (oidc_session_get_refresh_token(r, session) == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"no refresh token stored in the session, so cannot refresh the access token based on TTL requirement\");\n\t\treturn FALSE;\n\t}\n\n\tif (sscanf(s_access_token_expires, \"%\" APR_TIME_T_FMT, &t_expires) != 1) {\n\t\toidc_error(r, \"could not parse s_access_token_expires %s\",\n\t\t\t\ts_access_token_expires);\n\t\treturn FALSE;\n\t}\n\n\tt_expires = apr_time_from_sec(t_expires - ttl_minimum);\n\n\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\tapr_time_sec(t_expires - apr_time_now()));\n\n\tif (t_expires > apr_time_now())\n\t\treturn FALSE;\n\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\tif (oidc_refresh_access_token(r, cfg, session, provider,\n\t\t\tNULL) == FALSE) {\n\t\toidc_warn(r, \"access_token could not be refreshed, logout=%d\", logout_on_error & OIDC_LOGOUT_ON_ERROR_REFRESH);\n\t\tif (logout_on_error & OIDC_LOGOUT_ON_ERROR_REFRESH)\n\t\t\treturn ERROR;\n\t\telse\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * handle the case where we have identified an existing authentication session for a user\n */\nstatic int oidc_handle_existing_session(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* track if the session needs to be updated/saved into the cache */\n\tapr_byte_t needs_save = FALSE;\n\n\t/* set the user in the main request for further (incl. sub-request) processing */\n\tr->user = apr_pstrdup(r->pool, session->remote_user);\n\toidc_debug(r, \"set remote_user to \\\"%s\\\"\", r->user);\n\n\t/* get the header name in which the remote user name needs to be passed */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tapr_byte_t pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tapr_byte_t pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\t/* verify current cookie domain against issued cookie domain */\n\tif (oidc_check_cookie_domain(r, cfg, session) == FALSE)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* check if the maximum session duration was exceeded */\n\tint rc = oidc_check_max_session_duration(r, cfg, session);\n\tif (rc != OK)\n\t\treturn rc;\n\n\t/* if needed, refresh the access token */\n\tneeds_save = oidc_refresh_access_token_before_expiry(r, cfg, session,\n\t\t\toidc_cfg_dir_refresh_access_token_before_expiry(r),\n\t\t\toidc_cfg_dir_logout_on_error_refresh(r));\n\tif (needs_save == ERROR)\n\t\treturn oidc_handle_logout_request(r, cfg, session, cfg->default_slo_url);\n\n\t/* if needed, refresh claims from the user info endpoint */\n\tif (oidc_refresh_claims_from_userinfo_endpoint(r, cfg, session) == TRUE)\n\t\tneeds_save = TRUE;\n\n\t/*\n\t * we're going to pass the information that we have to the application,\n\t * but first we need to scrub the headers that we're going to use for security reasons\n\t */\n\toidc_scrub_headers(r);\n\n\t/* set the user authentication HTTP header if set and required */\n\tif ((r->user != NULL) && (authn_header != NULL))\n\t\toidc_util_hdr_in_set(r, authn_header, r->user);\n\n\tconst char *s_claims = NULL;\n\tconst char *s_id_token = NULL;\n\n\t/* copy id_token and claims from session to request state and obtain their values */\n\toidc_copy_tokens_to_request_state(r, session, &s_id_token, &s_claims);\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_CLAIMS)) {\n\t\t/* set the userinfo claims in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_claims) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JSON_OBJECT)) {\n\t\t/* pass the userinfo JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JSON, s_claims,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JWT)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\tconst char *s_userinfo_jwt = oidc_session_get_userinfo_jwt(r,\n\t\t\t\t\tsession);\n\t\t\tif (s_userinfo_jwt != NULL) {\n\t\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\t\toidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JWT,\n\t\t\t\t\t\ts_userinfo_jwt,\n\t\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t\t\t} else {\n\t\t\t\toidc_debug(r,\n\t\t\t\t\t\t\"configured to pass userinfo in a JWT, but no such JWT was found in the session (probably no such JWT was returned from the userinfo endpoint)\");\n\t\t\t}\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing a userinfo JWT; use \\\"\" OIDCSessionType \" server-cache\\\" for that\");\n\t\t}\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_CLAIMS)) {\n\t\t/* set the id_token in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_id_token) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_PAYLOAD)) {\n\t\t/* pass the id_token JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN_PAYLOAD, s_id_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_SERIALIZED)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\tconst char *s_id_token = oidc_session_get_idtoken(r, session);\n\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN, s_id_token,\n\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing the id_token; use \\\"\" OIDCSessionType \" server-cache\\\" for that\");\n\t\t}\n\t}\n\n\t/* pass the at, rt and at expiry to the application, possibly update the session expiry and save the session */\n\tif (oidc_session_pass_tokens_and_save(r, cfg, session, needs_save) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/* return \"user authenticated\" status */\n\treturn OK;\n}\n\n/*\n * helper function for basic/implicit client flows upon receiving an authorization response:\n * check that it matches the state stored in the browser and return the variables associated\n * with the state, such as original_url and OP oidc_provider_t pointer.\n */\nstatic apr_byte_t oidc_authorization_response_match_state(request_rec *r,\n\t\toidc_cfg *c, const char *state, struct oidc_provider_t **provider,\n\t\toidc_proto_state_t **proto_state) {\n\n\toidc_debug(r, \"enter (state=%s)\", state);\n\n\tif ((state == NULL) || (apr_strnatcmp(state, \"\") == 0)) {\n\t\toidc_error(r, \"state parameter is not set\");\n\t\treturn FALSE;\n\t}\n\n\t/* check the state parameter against what we stored in a cookie */\n\tif (oidc_restore_proto_state(r, c, state, proto_state) == FALSE) {\n\t\toidc_error(r, \"unable to restore state\");\n\t\treturn FALSE;\n\t}\n\n\t*provider = oidc_get_provider_for_issuer(r, c,\n\t\t\toidc_proto_state_get_issuer(*proto_state), FALSE);\n\n\treturn (*provider != NULL);\n}\n\n/*\n * redirect the browser to the session logout endpoint\n */\nstatic int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}\n\n/*\n * handle an error returned by the OP\n */\nstatic int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,\n\t\toidc_proto_state_t *proto_state, const char *error,\n\t\tconst char *error_description) {\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\tif (prompt != NULL)\n\t\tprompt = apr_pstrdup(r->pool, prompt);\n\toidc_proto_state_destroy(proto_state);\n\tif ((prompt != NULL)\n\t\t\t&& (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\tapr_psprintf(r->pool, \"OpenID Connect Provider error: %s\", error),\n\t\t\terror_description, OK);\n}\n\n/*\n * get the r->user for this request based on the configuration for OIDC/OAuth\n */\napr_byte_t oidc_get_remote_user(request_rec *r, const char *claim_name,\n\t\tconst char *reg_exp, const char *replace, json_t *json,\n\t\tchar **request_user) {\n\n\t/* get the claim value from the JSON object */\n\tjson_t *username = json_object_get(json, claim_name);\n\tif ((username == NULL) || (!json_is_string(username))) {\n\t\toidc_warn(r, \"JSON object did not contain a \\\"%s\\\" string\", claim_name);\n\t\treturn FALSE;\n\t}\n\n\t*request_user = apr_pstrdup(r->pool, json_string_value(username));\n\n\tif (reg_exp != NULL) {\n\n\t\tchar *error_str = NULL;\n\n\t\tif (replace == NULL) {\n\n\t\t\tif (oidc_util_regexp_first_match(r->pool, *request_user, reg_exp,\n\t\t\t\t\trequest_user, &error_str) == FALSE) {\n\t\t\t\toidc_error(r, \"oidc_util_regexp_first_match failed: %s\",\n\t\t\t\t\t\terror_str);\n\t\t\t\t*request_user = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t} else if (oidc_util_regexp_substitute(r->pool, *request_user, reg_exp,\n\t\t\t\treplace, request_user, &error_str) == FALSE) {\n\n\t\t\toidc_error(r, \"oidc_util_regexp_substitute failed: %s\", error_str);\n\t\t\t*request_user = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * set the unique user identifier that will be propagated in the Apache r->user and REMOTE_USER variables\n */\nstatic apr_byte_t oidc_set_request_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, oidc_jwt_t *jwt, const char *s_claims) {\n\n\tchar *issuer = provider->issuer;\n\tchar *claim_name = apr_pstrdup(r->pool, c->remote_user_claim.claim_name);\n\tint n = strlen(claim_name);\n\tapr_byte_t post_fix_with_issuer = (claim_name[n - 1] == OIDC_CHAR_AT);\n\tif (post_fix_with_issuer == TRUE) {\n\t\tclaim_name[n - 1] = '\\0';\n\t\tissuer =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\t}\n\n\t/* extract the username claim (default: \"sub\") from the id_token payload or user claims */\n\tapr_byte_t rc = FALSE;\n\tchar *remote_user = NULL;\n\tjson_t *claims = NULL;\n\toidc_util_decode_json_object(r, s_claims, &claims);\n\tif (claims == NULL) {\n\t\trc = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,\n\t\t\t\tc->remote_user_claim.replace, jwt->payload.value.json,\n\t\t\t\t&remote_user);\n\t} else {\n\t\toidc_util_json_merge(r, jwt->payload.value.json, claims);\n\t\trc = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,\n\t\t\t\tc->remote_user_claim.replace, claims, &remote_user);\n\t\tjson_decref(claims);\n\t}\n\n\tif ((rc == FALSE) || (remote_user == NULL)) {\n\t\toidc_error(r,\n\t\t\t\t\"\" OIDCRemoteUserClaim \"is set to \\\"%s\\\", but could not set the remote user based on the requested claim \\\"%s\\\" and the available claims for the user\",\n\t\t\t\tc->remote_user_claim.claim_name, claim_name);\n\t\treturn FALSE;\n\t}\n\n\tif (post_fix_with_issuer == TRUE)\n\t\tremote_user = apr_psprintf(r->pool, \"%s%s%s\", remote_user, OIDC_STR_AT,\n\t\t\t\tissuer);\n\n\tr->user = apr_pstrdup(r->pool, remote_user);\n\n\toidc_debug(r, \"set remote_user to \\\"%s\\\" based on claim: \\\"%s\\\"%s\", r->user,\n\t\t\tc->remote_user_claim.claim_name,\n\t\t\tc->remote_user_claim.reg_exp ?\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\" and expression: \\\"%s\\\" and replace string: \\\"%s\\\"\",\n\t\t\t\t\t\t\tc->remote_user_claim.reg_exp,\n\t\t\t\t\t\t\tc->remote_user_claim.replace) :\n\t\t\t\t\t\t\t\"\");\n\n\treturn TRUE;\n}\n\nstatic char *oidc_make_sid_iss_unique(request_rec *r, const char *sid,\n\t\tconst char *issuer) {\n\treturn apr_psprintf(r->pool, \"%s@%s\", sid, issuer);\n}\n\n/*\n * store resolved information in the session\n */\nstatic apr_byte_t oidc_save_in_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tconst char *remoteUser, const char *id_token, oidc_jwt_t *id_token_jwt,\n\t\tconst char *claims, const char *access_token, const int expires_in,\n\t\tconst char *refresh_token, const char *session_state, const char *state,\n\t\tconst char *original_url, const char *userinfo_jwt) {\n\n\t/* store the user in the session */\n\tsession->remote_user = remoteUser;\n\n\t/* set the session expiry to the inactivity timeout */\n\tsession->expiry =\n\t\t\tapr_time_now() + apr_time_from_sec(c->session_inactivity_timeout);\n\n\t/* store the claims payload in the id_token for later reference */\n\toidc_session_set_idtoken_claims(r, session,\n\t\t\tid_token_jwt->payload.value.str);\n\n\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t/* store the compact serialized representation of the id_token for later reference  */\n\t\toidc_session_set_idtoken(r, session, id_token);\n\t}\n\n\t/* store the issuer in the session (at least needed for session mgmt and token refresh */\n\toidc_session_set_issuer(r, session, provider->issuer);\n\n\t/* store the state and original URL in the session for handling browser-back more elegantly */\n\toidc_session_set_request_state(r, session, state);\n\toidc_session_set_original_url(r, session, original_url);\n\n\tif ((session_state != NULL) && (provider->check_session_iframe != NULL)) {\n\t\t/* store the session state and required parameters session management  */\n\t\toidc_session_set_session_state(r, session, session_state);\n\t\toidc_debug(r,\n\t\t\t\t\"session management enabled: stored session_state (%s), check_session_iframe (%s) and client_id (%s) in the session\",\n\t\t\t\tsession_state, provider->check_session_iframe,\n\t\t\t\tprovider->client_id);\n\t} else if (provider->check_session_iframe == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: \\\"check_session_iframe\\\" is not set in provider configuration\");\n\t} else {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: no \\\"session_state\\\" value is provided in the authentication response even though \\\"check_session_iframe\\\" (%s) is set in the provider configuration\",\n\t\t\t\tprovider->check_session_iframe);\n\t}\n\n\t/* store claims resolved from userinfo endpoint */\n\toidc_store_userinfo_claims(r, c, session, provider, claims, userinfo_jwt);\n\n\t/* see if we have an access_token */\n\tif (access_token != NULL) {\n\t\t/* store the access_token in the session context */\n\t\toidc_session_set_access_token(r, session, access_token);\n\t\t/* store the associated expires_in value */\n\t\toidc_session_set_access_token_expires(r, session, expires_in);\n\t\t/* reset the access token refresh timestamp */\n\t\toidc_session_reset_access_token_last_refresh(r, session);\n\t}\n\n\t/* see if we have a refresh_token */\n\tif (refresh_token != NULL) {\n\t\t/* store the refresh_token in the session context */\n\t\toidc_session_set_refresh_token(r, session, refresh_token);\n\t}\n\n\t/* store max session duration in the session as a hard cut-off expiry timestamp */\n\tapr_time_t session_expires =\n\t\t\t(provider->session_max_duration == 0) ?\n\t\t\t\t\tapr_time_from_sec(id_token_jwt->payload.exp) :\n\t\t\t\t\t(apr_time_now()\n\t\t\t\t\t\t\t+ apr_time_from_sec(provider->session_max_duration));\n\toidc_session_set_session_expires(r, session, session_expires);\n\n\toidc_debug(r,\n\t\t\t\"provider->session_max_duration = %d, session_expires=%\" APR_TIME_T_FMT,\n\t\t\tprovider->session_max_duration, session_expires);\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\n\t/* store the domain for which this session is valid */\n\toidc_session_set_cookie_domain(r, session,\n\t\t\tc->cookie_domain ? c->cookie_domain : oidc_get_current_url_host(r));\n\n\tchar *sid = NULL;\n\toidc_debug(r, \"provider->backchannel_logout_supported=%d\",\n\t\t\tprovider->backchannel_logout_supported);\n\tif (provider->backchannel_logout_supported > 0) {\n\t\toidc_jose_get_string(r->pool, id_token_jwt->payload.value.json,\n\t\t\t\tOIDC_CLAIM_SID, FALSE, &sid, NULL);\n\t\tif (sid == NULL)\n\t\t\tsid = id_token_jwt->payload.sub;\n\t\tsession->sid = oidc_make_sid_iss_unique(r, sid, provider->issuer);\n\t}\n\n\t/* store the session */\n\treturn oidc_session_save(r, session, TRUE);\n}\n\n/*\n * parse the expiry for the access token\n */\nstatic int oidc_parse_expires_in(request_rec *r, const char *expires_in) {\n\tif (expires_in != NULL) {\n\t\tchar *ptr = NULL;\n\t\tlong number = strtol(expires_in, &ptr, 10);\n\t\tif (number <= 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"could not convert \\\"expires_in\\\" value (%s) to a number\",\n\t\t\t\t\texpires_in);\n\t\t\treturn -1;\n\t\t}\n\t\treturn number;\n\t}\n\treturn -1;\n}\n\n/*\n * handle the different flows (hybrid, implicit, Authorization Code)\n */\nstatic apr_byte_t oidc_handle_flows(request_rec *r, oidc_cfg *c,\n\t\toidc_proto_state_t *proto_state, oidc_provider_t *provider,\n\t\tapr_table_t *params, const char *response_mode, oidc_jwt_t **jwt) {\n\n\tapr_byte_t rc = FALSE;\n\n\tconst char *requested_response_type = oidc_proto_state_get_response_type(\n\t\t\tproto_state);\n\n\t/* handle the requested response type/mode */\n\tif (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN_TOKEN)) {\n\t\trc = oidc_proto_authorization_response_code_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN)) {\n\t\trc = oidc_proto_authorization_response_code_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_TOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_code_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE)) {\n\t\trc = oidc_proto_handle_authorization_response_code(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_IDTOKEN_TOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_IDTOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else {\n\t\toidc_error(r, \"unsupported response type: \\\"%s\\\"\",\n\t\t\t\trequested_response_type);\n\t}\n\n\tif ((rc == FALSE) && (*jwt != NULL)) {\n\t\toidc_jwt_destroy(*jwt);\n\t\t*jwt = NULL;\n\t}\n\n\treturn rc;\n}\n\n/* handle the browser back on an authorization response */\nstatic apr_byte_t oidc_handle_browser_back(request_rec *r, const char *r_state,\n\t\toidc_session_t *session) {\n\n\t/*  see if we have an existing session and browser-back was used */\n\tconst char *s_state = NULL, *o_url = NULL;\n\n\tif (session->remote_user != NULL) {\n\n\t\ts_state = oidc_session_get_request_state(r, session);\n\t\to_url = oidc_session_get_original_url(r, session);\n\n\t\tif ((r_state != NULL) && (s_state != NULL)\n\t\t\t\t&& (apr_strnatcmp(r_state, s_state) == 0)) {\n\n\t\t\t/* log the browser back event detection */\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"browser back detected, redirecting to original URL: %s\",\n\t\t\t\t\to_url);\n\n\t\t\t/* go back to the URL that he originally tried to access */\n\t\t\toidc_util_hdr_out_location_set(r, o_url);\n\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\n/*\n * complete the handling of an authorization response by obtaining, parsing and verifying the\n * id_token and storing the authenticated user state in the session\n */\nstatic int oidc_handle_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, apr_table_t *params, const char *response_mode) {\n\n\toidc_debug(r, \"enter, response_mode=%s\", response_mode);\n\n\toidc_provider_t *provider = NULL;\n\toidc_proto_state_t *proto_state = NULL;\n\toidc_jwt_t *jwt = NULL;\n\n\t/* see if this response came from a browser-back event */\n\tif (oidc_handle_browser_back(r, apr_table_get(params, OIDC_PROTO_STATE),\n\t\t\tsession) == TRUE)\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\n\t/* match the returned state parameter against the state stored in the browser */\n\tif (oidc_authorization_response_match_state(r, c,\n\t\t\tapr_table_get(params, OIDC_PROTO_STATE), &provider,\n\t\t\t&proto_state) == FALSE) {\n\t\tif (c->default_sso_url != NULL) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"invalid authorization response state; a default SSO URL is set, sending the user there: %s\",\n\t\t\t\t\tc->default_sso_url);\n\t\t\toidc_util_hdr_out_location_set(r, c->default_sso_url);\n\t\t\treturn HTTP_MOVED_TEMPORARILY;\n\t\t}\n\t\toidc_error(r,\n\t\t\t\t\"invalid authorization response state and no default SSO URL is set, sending an error...\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if the response is an error response */\n\tif (apr_table_get(params, OIDC_PROTO_ERROR) != NULL)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ERROR),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ERROR_DESCRIPTION));\n\n\t/* handle the code, implicit or hybrid flow */\n\tif (oidc_handle_flows(r, c, proto_state, provider, params, response_mode,\n\t\t\t&jwt) == FALSE)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Error in handling response type.\", NULL);\n\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no id_token was provided\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"No id_token was provided.\", NULL);\n\t}\n\n\tint expires_in = oidc_parse_expires_in(r,\n\t\t\tapr_table_get(params, OIDC_PROTO_EXPIRES_IN));\n\tchar *userinfo_jwt = NULL;\n\n\t/*\n\t * optionally resolve additional claims against the userinfo endpoint\n\t * parsed claims are not actually used here but need to be parsed anyway for error checking purposes\n\t */\n\tconst char *claims = oidc_retrieve_claims_from_userinfo_endpoint(r, c,\n\t\t\tprovider, apr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), NULL,\n\t\t\tjwt->payload.sub, &userinfo_jwt);\n\n\t/* restore the original protected URL that the user was trying to access */\n\tconst char *original_url = oidc_proto_state_get_original_url(proto_state);\n\tif (original_url != NULL)\n\t\toriginal_url = apr_pstrdup(r->pool, original_url);\n\tconst char *original_method = oidc_proto_state_get_original_method(\n\t\t\tproto_state);\n\tif (original_method != NULL)\n\t\toriginal_method = apr_pstrdup(r->pool, original_method);\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\n\t/* set the user */\n\tif (oidc_set_request_user(r, c, provider, jwt, claims) == TRUE) {\n\n\t\t/* session management: if the user in the new response is not equal to the old one, error out */\n\t\tif ((prompt != NULL)\n\t\t\t\t&& (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {\n\t\t\t// TOOD: actually need to compare sub? (need to store it in the session separately then\n\t\t\t//const char *sub = NULL;\n\t\t\t//oidc_session_get(r, session, \"sub\", &sub);\n\t\t\t//if (apr_strnatcmp(sub, jwt->payload.sub) != 0) {\n\t\t\tif (apr_strnatcmp(session->remote_user, r->user) != 0) {\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"user set from new id_token is different from current one\");\n\t\t\t\toidc_jwt_destroy(jwt);\n\t\t\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\t\t\"User changed!\", NULL);\n\t\t\t}\n\t\t}\n\n\t\t/* store resolved information in the session */\n\t\tif (oidc_save_in_session(r, c, session, provider, r->user,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ID_TOKEN), jwt, claims,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), expires_in,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_REFRESH_TOKEN),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_SESSION_STATE),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_STATE), original_url,\n\t\t\t\tuserinfo_jwt) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t} else {\n\t\toidc_error(r, \"remote user could not be set\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Remote user could not be set: contact the website administrator\",\n\t\t\t\tNULL);\n\t}\n\n\t/* cleanup */\n\toidc_proto_state_destroy(proto_state);\n\toidc_jwt_destroy(jwt);\n\n\t/* check that we've actually authenticated a user; functions as error handling for oidc_get_remote_user */\n\tif (r->user == NULL)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* log the successful response */\n\toidc_debug(r,\n\t\t\t\"session created and stored, returning to original URL: %s, original method: %s\",\n\t\t\toriginal_url, original_method);\n\n\t/* check whether form post data was preserved; if so restore it */\n\tif (apr_strnatcmp(original_method, OIDC_METHOD_FORM_POST) == 0) {\n\t\treturn oidc_request_post_preserved_restore(r, original_url);\n\t}\n\n\t/* now we've authenticated the user so go back to the URL that he originally tried to access */\n\toidc_util_hdr_out_location_set(r, original_url);\n\n\t/* do the actual redirect to the original URL */\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the POST (+fragment->POST) response_mode\n */\nstatic int oidc_handle_post_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* initialize local variables */\n\tchar *response_mode = NULL;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if we've got any POST-ed data at all */\n\tif ((apr_table_elts(params)->nelts < 1)\n\t\t\t|| ((apr_table_elts(params)->nelts == 1)\n\t\t\t\t\t&& apr_table_get(params, OIDC_PROTO_RESPONSE_MODE)\n\t\t\t\t\t&& (apr_strnatcmp(\n\t\t\t\t\t\t\tapr_table_get(params, OIDC_PROTO_RESPONSE_MODE),\n\t\t\t\t\t\t\tOIDC_PROTO_RESPONSE_MODE_FRAGMENT) == 0))) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"You've hit an OpenID Connect Redirect URI with no parameters, this is an invalid request; you should not open this URL in your browser directly, or have the server administrator use a different \" OIDCRedirectURI \" setting.\",\n\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t}\n\n\t/* get the parameters */\n\tresponse_mode = (char *) apr_table_get(params, OIDC_PROTO_RESPONSE_MODE);\n\n\t/* do the actual implicit work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tresponse_mode ? response_mode : OIDC_PROTO_RESPONSE_MODE_FORM_POST);\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the redirect response_mode\n */\nstatic int oidc_handle_redirect_authorization_response(request_rec *r,\n\t\toidc_cfg *c, oidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* read the parameters from the query string */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\toidc_util_read_form_encoded_params(r, params, r->args);\n\n\t/* do the actual work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tOIDC_PROTO_RESPONSE_MODE_QUERY);\n}\n\n/*\n * present the user with an OP selection screen\n */\nstatic int oidc_discovery(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* obtain the URL we're currently accessing, to be stored in the state/session */\n\tchar *current_url = oidc_get_current_url(r);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\t/* generate CSRF token */\n\tchar *csrf = NULL;\n\tif (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *path_scopes = oidc_dir_cfg_path_scope(r);\n\tchar *path_auth_request_params = oidc_dir_cfg_path_auth_request_params(r);\n\n\tchar *discover_url = oidc_cfg_dir_discover_url(r);\n\t/* see if there's an external discovery page configured */\n\tif (discover_url != NULL) {\n\n\t\t/* yes, assemble the parameters for external discovery */\n\t\tchar *url = apr_psprintf(r->pool, \"%s%s%s=%s&%s=%s&%s=%s&%s=%s\",\n\t\t\t\tdiscover_url,\n\t\t\t\tstrchr(discover_url, OIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_DISC_CB_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, oidc_get_redirect_uri(r, cfg)),\n\t\t\t\t\t\tOIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));\n\n\t\tif (path_scopes != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_SC_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\t/* log what we're about to do */\n\t\toidc_debug(r, \"redirecting to external discovery page: %s\", url);\n\n\t\t/* set CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\t\tcfg->cookie_same_site ?\n\t\t\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_STRICT :\n\t\t\t\t\t\tNULL);\n\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)\n\t\t\treturn OK;\n\n\t\t/* do the actual redirect to an external discovery page */\n\t\toidc_util_hdr_out_location_set(r, url);\n\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\t}\n\n\t/* get a list of all providers configured in the metadata directory */\n\tapr_array_header_t *arr = NULL;\n\tif (oidc_metadata_list(r, cfg, &arr) == FALSE)\n\t\treturn oidc_util_html_send_error(r, cfg->error_template,\n\t\t\t\t\"Configuration Error\",\n\t\t\t\t\"No configured providers found, contact your administrator\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\n\t/* assemble a where-are-you-from IDP discovery HTML page */\n\tconst char *s = \"\t\t\t<h3>Select your OpenID Connect Identity Provider</h3>\\n\";\n\n\t/* list all configured providers in there */\n\tint i;\n\tfor (i = 0; i < arr->nelts; i++) {\n\n\t\tconst char *issuer = ((const char**) arr->elts)[i];\n\t\t// TODO: html escape (especially & character)\n\n\t\tchar *href = apr_psprintf(r->pool,\n\t\t\t\t\"%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s\",\n\t\t\t\toidc_get_redirect_uri(r, cfg), OIDC_DISC_OP_PARAM,\n\t\t\t\toidc_util_escape_string(r, issuer),\n\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\tOIDC_CSRF_NAME, csrf);\n\n\t\tif (path_scopes != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_SC_PARAM, oidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\tchar *display =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\n\t\t/* strip port number */\n\t\t//char *p = strstr(display, \":\");\n\t\t//if (p != NULL) *p = '\\0';\n\t\t/* point back to the redirect_uri, where the selection is handled, with an IDP selection and return_to URL */\n\t\ts = apr_psprintf(r->pool, \"%s<p><a href=\\\"%s\\\">%s</a></p>\\n\", s, href,\n\t\t\t\tdisplay);\n\t}\n\n\t/* add an option to enter an account or issuer name for dynamic OP discovery */\n\ts = apr_psprintf(r->pool, \"%s<form method=\\\"get\\\" action=\\\"%s\\\">\\n\", s,\n\t\t\toidc_get_redirect_uri(r, cfg));\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RT_PARAM, current_url);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RM_PARAM, method);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_CSRF_NAME, csrf);\n\n\tif (path_scopes != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_SC_PARAM, path_scopes);\n\tif (path_auth_request_params != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_AR_PARAM, path_auth_request_params);\n\n\ts =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\\n\",\n\t\t\t\t\ts);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"text\\\" name=\\\"%s\\\" value=\\\"%s\\\"></p>\\n\", s,\n\t\t\tOIDC_DISC_OP_PARAM, \"\");\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"submit\\\" value=\\\"Submit\\\"></p>\\n\", s);\n\ts = apr_psprintf(r->pool, \"%s</form>\\n\", s);\n\n\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\tcfg->cookie_same_site ? OIDC_COOKIE_EXT_SAME_SITE_STRICT : NULL);\n\n\tchar *javascript = NULL, *javascript_method = NULL;\n\tchar *html_head =\n\t\t\t\"<style type=\\\"text/css\\\">body {text-align: center}</style>\";\n\tif (oidc_post_preserve_javascript(r, NULL, &javascript,\n\t\t\t&javascript_method) == TRUE)\n\t\thtml_head = apr_psprintf(r->pool, \"%s%s\", html_head, javascript);\n\n\t/* now send the HTML contents to the user agent */\n\treturn oidc_util_html_send(r, \"OpenID Connect Provider Discovery\",\n\t\t\thtml_head, javascript_method, s, OK);\n}\n\n/*\n * authenticate the user to the selected OP, if the OP is not selected yet perform discovery first\n */\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params, const char *path_scope) {\n\n\toidc_debug(r, \"enter\");\n\n\tif (provider == NULL) {\n\n\t\t// TODO: should we use an explicit redirect to the discovery endpoint (maybe a \"discovery\" param to the redirect_uri)?\n\t\tif (c->metadata_dir != NULL)\n\t\t\treturn oidc_discovery(r, c);\n\n\t\t/* we're not using multiple OP's configured in a metadata directory, pick the statically configured OP */\n\t\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* generate the random nonce value that correlates requests and responses */\n\tchar *nonce = NULL;\n\tif (oidc_proto_generate_nonce(r, &nonce, OIDC_PROTO_NONCE_LENGTH) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *pkce_state = NULL;\n\tchar *code_challenge = NULL;\n\n\tif ((oidc_util_spaced_string_contains(r->pool, provider->response_type,\n\t\t\tOIDC_PROTO_CODE) == TRUE) && (provider->pkce != NULL)) {\n\n\t\t/* generate the code verifier value that correlates authorization requests and code exchange requests */\n\t\tif (provider->pkce->state(r, &pkce_state) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t/* generate the PKCE code challenge */\n\t\tif (provider->pkce->challenge(r, pkce_state, &code_challenge) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* create the state between request/response */\n\toidc_proto_state_t *proto_state = oidc_proto_state_new();\n\toidc_proto_state_set_original_url(proto_state, original_url);\n\toidc_proto_state_set_original_method(proto_state,\n\t\t\toidc_original_request_method(r, c, TRUE));\n\toidc_proto_state_set_issuer(proto_state, provider->issuer);\n\toidc_proto_state_set_response_type(proto_state, provider->response_type);\n\toidc_proto_state_set_nonce(proto_state, nonce);\n\toidc_proto_state_set_timestamp_now(proto_state);\n\tif (provider->response_mode)\n\t\toidc_proto_state_set_response_mode(proto_state,\n\t\t\t\tprovider->response_mode);\n\tif (prompt)\n\t\toidc_proto_state_set_prompt(proto_state, prompt);\n\tif (pkce_state)\n\t\toidc_proto_state_set_pkce_state(proto_state, pkce_state);\n\n\t/* get a hash value that fingerprints the browser concatenated with the random input */\n\tchar *state = oidc_get_browser_state_hash(r, nonce);\n\n\t/*\n\t * create state that restores the context when the authorization response comes in\n\t * and cryptographically bind it to the browser\n\t */\n\tint rc = oidc_authorization_request_set_cookie(r, c, state, proto_state);\n\tif (rc != HTTP_OK) {\n\t\toidc_proto_state_destroy(proto_state);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * printout errors if Cookie settings are not going to work\n\t * TODO: separate this code out into its own function\n\t */\n\tapr_uri_t o_uri;\n\tmemset(&o_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_t r_uri;\n\tmemset(&r_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_parse(r->pool, original_url, &o_uri);\n\tapr_uri_parse(r->pool, oidc_get_redirect_uri(r, c), &r_uri);\n\tif ((apr_strnatcmp(o_uri.scheme, r_uri.scheme) != 0)\n\t\t\t&& (apr_strnatcmp(r_uri.scheme, \"https\") == 0)) {\n\t\toidc_error(r,\n\t\t\t\t\"the URL scheme (%s) of the configured \" OIDCRedirectURI \" does not match the URL scheme of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\tr_uri.scheme, o_uri.scheme);\n\t\toidc_proto_state_destroy(proto_state);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (c->cookie_domain == NULL) {\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured \" OIDCRedirectURI \" does not match the URL hostname of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!oidc_util_cookie_domain_valid(r_uri.hostname, c->cookie_domain)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in \" OIDCCookieDomain \" does not match the URL hostname (%s) of the URL being accessed (%s): setting \\\"state\\\" and \\\"session\\\" cookies will not work!!\",\n\t\t\t\t\tc->cookie_domain, o_uri.hostname, original_url);\n\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n\n\t/* send off to the OpenID Connect Provider */\n\t// TODO: maybe show intermediate/progress screen \"redirecting to\"\n\treturn oidc_proto_authorization_request(r, provider, login_hint,\n\t\t\toidc_get_redirect_uri_iss(r, c, provider), state, proto_state,\n\t\t\tid_token_hint, code_challenge, auth_request_params, path_scope);\n}\n\n/*\n * check if the target_link_uri matches to configuration settings to prevent an open redirect\n */\nstatic int oidc_target_link_uri_matches_configuration(request_rec *r,\n\t\toidc_cfg *cfg, const char *target_link_uri) {\n\n\tapr_uri_t o_uri;\n\tapr_uri_parse(r->pool, target_link_uri, &o_uri);\n\tif (o_uri.hostname == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse the \\\"target_link_uri\\\" (%s) in to a valid URL: aborting.\",\n\t\t\t\ttarget_link_uri);\n\t\treturn FALSE;\n\t}\n\n\tapr_uri_t r_uri;\n\tapr_uri_parse(r->pool, oidc_get_redirect_uri(r, cfg), &r_uri);\n\n\tif (cfg->cookie_domain == NULL) {\n\t\t/* cookie_domain set: see if the target_link_uri matches the redirect_uri host (because the session cookie will be set host-wide) */\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured \" OIDCRedirectURI \" does not match the URL hostname of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* cookie_domain set: see if the target_link_uri is within the cookie_domain */\n\t\tchar *p = strstr(o_uri.hostname, cfg->cookie_domain);\n\t\tif ((p == NULL) || (apr_strnatcmp(cfg->cookie_domain, p) != 0)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in \" OIDCCookieDomain \" does not match the URL hostname (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.hostname, target_link_uri);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* see if the cookie_path setting matches the target_link_uri path */\n\tchar *cookie_path = oidc_cfg_dir_cookie_path(r);\n\tif (cookie_path != NULL) {\n\t\tchar *p = (o_uri.path != NULL) ? strstr(o_uri.path, cookie_path) : NULL;\n\t\tif ((p == NULL) || (p != o_uri.path)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the path (%s) configured in \" OIDCCookiePath \" does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\treturn FALSE;\n\t\t} else if (strlen(o_uri.path) > strlen(cookie_path)) {\n\t\t\tint n = strlen(cookie_path);\n\t\t\tif (cookie_path[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\t\t\tn--;\n\t\t\tif (o_uri.path[n] != OIDC_CHAR_FORWARD_SLASH) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the path (%s) configured in \" OIDCCookiePath \" does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/*\n * handle a response from an IDP discovery page and/or handle 3rd-party initiated SSO\n */\nstatic int oidc_handle_discovery_response(request_rec *r, oidc_cfg *c) {\n\n\t/* variables to hold the values returned in the response */\n\tchar *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,\n\t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n\t\t\t*user = NULL, *path_scopes;\n\toidc_provider_t *provider = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n\toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n\toidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);\n\toidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);\n\toidc_util_get_request_parameter(r, OIDC_DISC_SC_PARAM, &path_scopes);\n\toidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,\n\t\t\t&auth_request_params);\n\toidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);\n\tcsrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);\n\n\t/* do CSRF protection if not 3rd party initiated SSO */\n\tif (csrf_cookie) {\n\n\t\t/* clean CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, \"\", 0, NULL);\n\n\t\t/* compare CSRF cookie value with query parameter value */\n\t\tif ((csrf_query == NULL)\n\t\t\t\t|| apr_strnatcmp(csrf_query, csrf_cookie) != 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"CSRF protection failed, no Discovery and dynamic client registration will be allowed\");\n\t\t\tcsrf_cookie = NULL;\n\t\t}\n\t}\n\n\t// TODO: trim issuer/accountname/domain input and do more input validation\n\n\toidc_debug(r,\n\t\t\t\"issuer=\\\"%s\\\", target_link_uri=\\\"%s\\\", login_hint=\\\"%s\\\", user=\\\"%s\\\"\",\n\t\t\tissuer, target_link_uri, login_hint, user);\n\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"SSO to this module without specifying a \\\"target_link_uri\\\" parameter is not possible because \" OIDCDefaultURL \" is not set.\",\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\t/* do open redirect prevention */\n\tif (oidc_target_link_uri_matches_configuration(r, c,\n\t\t\ttarget_link_uri) == FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* see if this is a static setup */\n\tif (c->metadata_dir == NULL) {\n\t\tif ((oidc_provider_static_config(r, c, &provider) == TRUE)\n\t\t\t\t&& (issuer != NULL)) {\n\t\t\tif (apr_strnatcmp(provider->issuer, issuer) != 0) {\n\t\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\t\"The \\\"iss\\\" value must match the configured providers' one (%s != %s).\",\n\t\t\t\t\t\t\t\tissuer, c->provider.issuer),\n\t\t\t\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t\treturn oidc_authenticate_user(r, c, NULL, target_link_uri, login_hint,\n\t\t\t\tNULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* find out if the user entered an account name or selected an OP manually */\n\tif (user != NULL) {\n\n\t\tif (login_hint == NULL)\n\t\t\tlogin_hint = apr_pstrdup(r->pool, user);\n\n\t\t/* normalize the user identifier */\n\t\tif (strstr(user, \"https://\") != user)\n\t\t\tuser = apr_psprintf(r->pool, \"https://%s\", user);\n\n\t\t/* got an user identifier as input, perform OP discovery with that */\n\t\tif (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t} else if (strstr(issuer, OIDC_STR_AT) != NULL) {\n\n\t\tif (login_hint == NULL) {\n\t\t\tlogin_hint = apr_pstrdup(r->pool, issuer);\n\t\t\t//char *p = strstr(issuer, OIDC_STR_AT);\n\t\t\t//*p = '\\0';\n\t\t}\n\n\t\t/* got an account name as input, perform OP discovery with that */\n\t\tif (oidc_proto_account_based_discovery(r, c, issuer, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided account name to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t}\n\n\t/* strip trailing '/' */\n\tint n = strlen(issuer);\n\tif (issuer[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\tissuer[n - 1] = '\\0';\n\n\t/* try and get metadata from the metadata directories for the selected OP */\n\tif ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)\n\t\t\t&& (provider != NULL)) {\n\n\t\t/* now we've got a selected OP, send the user there to authenticate */\n\t\treturn oidc_authenticate_user(r, c, provider, target_link_uri,\n\t\t\t\tlogin_hint, NULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\t\"Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator\",\n\t\t\tHTTP_NOT_FOUND);\n}\n\nstatic apr_uint32_t oidc_transparent_pixel[17] = { 0x474e5089, 0x0a1a0a0d,\n\t\t0x0d000000, 0x52444849, 0x01000000, 0x01000000, 0x00000408, 0x0c1cb500,\n\t\t0x00000002, 0x4144490b, 0x639c7854, 0x0000cffa, 0x02010702, 0x71311c9a,\n\t\t0x00000000, 0x444e4549, 0x826042ae };\n\nstatic apr_byte_t oidc_is_front_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL)\n\t\t\t&& ((apr_strnatcmp(logout_param_value,\n\t\t\t\t\tOIDC_GET_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t\t|| (apr_strnatcmp(logout_param_value,\n\t\t\t\t\t\t\tOIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)));\n}\n\nstatic apr_byte_t oidc_is_back_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL) && (apr_strnatcmp(logout_param_value,\n\t\t\tOIDC_BACKCHANNEL_STYLE_LOGOUT_PARAM_VALUE) == 0));\n}\n\n/*\n * revoke refresh token and access token stored in the session if the\n * OP has an RFC 7009 compliant token revocation endpoint\n */\nstatic void oidc_revoke_tokens(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *response = NULL;\n\tchar *basic_auth = NULL;\n\tchar *bearer_auth = NULL;\n\tapr_table_t *params = NULL;\n\tconst char *token = NULL;\n\toidc_provider_t *provider = NULL;\n\n\toidc_debug(r, \"enter\");\n\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE)\n\t\tgoto out;\n\n\toidc_debug(r, \"revocation_endpoint=%s\",\n\t\t\tprovider->revocation_endpoint_url ?\n\t\t\t\t\tprovider->revocation_endpoint_url : \"(null)\");\n\n\tif (provider->revocation_endpoint_url == NULL)\n\t\tgoto out;\n\n\tparams = apr_table_make(r->pool, 4);\n\n\t// add the token endpoint authentication credentials to the revocation endpoint call...\n\tif (oidc_proto_token_endpoint_auth(r, c, provider->token_endpoint_auth,\n\t\t\tprovider->client_id, provider->client_secret,\n\t\t\tprovider->client_signing_keys, provider->token_endpoint_url, params,\n\t\t\tNULL, &basic_auth, &bearer_auth) == FALSE)\n\t\tgoto out;\n\n\t// TODO: use oauth.ssl_validate_server ...\n\ttoken = oidc_session_get_refresh_token(r, session);\n\tif (token != NULL) {\n\t\tapr_table_addn(params, \"token_type_hint\", \"refresh_token\");\n\t\tapr_table_addn(params, \"token\", token);\n\n\t\tif (oidc_util_http_post_form(r, provider->revocation_endpoint_url,\n\t\t\t\tparams, basic_auth, bearer_auth, c->oauth.ssl_validate_server,\n\t\t\t\t&response, c->http_timeout_long, c->outgoing_proxy,\n\t\t\t\toidc_dir_cfg_pass_cookies(r), NULL,\n\t\t\t\tNULL) == FALSE) {\n\t\t\toidc_warn(r, \"revoking refresh token failed\");\n\t\t}\n\t\tapr_table_clear(params);\n\t}\n\n\ttoken = oidc_session_get_access_token(r, session);\n\tif (token != NULL) {\n\t\tapr_table_addn(params, \"token_type_hint\", \"access_token\");\n\t\tapr_table_addn(params, \"token\", token);\n\n\t\tif (oidc_util_http_post_form(r, provider->revocation_endpoint_url,\n\t\t\t\tparams, basic_auth, bearer_auth, c->oauth.ssl_validate_server,\n\t\t\t\t&response, c->http_timeout_long, c->outgoing_proxy,\n\t\t\t\toidc_dir_cfg_pass_cookies(r), NULL,\n\t\t\t\tNULL) == FALSE) {\n\t\t\toidc_warn(r, \"revoking access token failed\");\n\t\t}\n\t}\n\nout:\n\n\toidc_debug(r, \"leave\");\n}\n\n/*\n * handle a local logout\n */\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url) {\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\t/* if there's no remote_user then there's no (stored) session to kill */\n\tif (session->remote_user != NULL) {\n\n\t\toidc_revoke_tokens(r, c, session);\n\n\t\t/* remove session state (cq. cache entry and cookie) */\n\t\toidc_session_kill(r, session);\n\t}\n\n\t/* see if this is the OP calling us */\n\tif (oidc_is_front_channel_logout(url)) {\n\n\t\t/* set recommended cache control headers */\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_CACHE_CONTROL,\n\t\t\t\t\"no-cache, no-store\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_PRAGMA, \"no-cache\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_P3P, \"CAO PSA OUR\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_EXPIRES, \"0\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_X_FRAME_OPTIONS, \"DENY\");\n\n\t\t/* see if this is PF-PA style logout in which case we return a transparent pixel */\n\t\tconst char *accept = oidc_util_hdr_in_accept_get(r);\n\t\tif ((apr_strnatcmp(url, OIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t|| ((accept) && strstr(accept, OIDC_CONTENT_TYPE_IMAGE_PNG))) {\n\t\t\treturn oidc_util_http_send(r,\n\t\t\t\t\t(const char *) &oidc_transparent_pixel,\n\t\t\t\t\tsizeof(oidc_transparent_pixel), OIDC_CONTENT_TYPE_IMAGE_PNG,\n\t\t\t\t\tOK);\n\t\t}\n\n\t\t/* standard HTTP based logout: should be called in an iframe from the OP */\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", OK);\n\t}\n\n\t/* see if we don't need to go somewhere special after killing the session locally */\n\tif (url == NULL)\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", OK);\n\n\t/* send the user to the specified where-to-go-after-logout URL */\n\toidc_util_hdr_out_location_set(r, url);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle a backchannel logout\n */\n#define OIDC_EVENTS_BLOGOUT_KEY \"http://schemas.openid.net/event/backchannel-logout\"\n\nstatic int oidc_handle_logout_backchannel(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *logout_token = NULL;\n\toidc_jwt_t *jwt = NULL;\n\toidc_jose_error_t err;\n\toidc_jwk_t *jwk = NULL;\n\toidc_provider_t *provider = NULL;\n\tchar *sid = NULL, *uuid = NULL;\n\toidc_session_t session;\n\tint rc = HTTP_BAD_REQUEST;\n\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"could not read POST-ed parameters to the logout endpoint\");\n\t\tgoto out;\n\t}\n\n\tlogout_token = apr_table_get(params, OIDC_PROTO_LOGOUT_TOKEN);\n\tif (logout_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"backchannel lggout endpoint was called but could not find a parameter named \\\"%s\\\"\",\n\t\t\t\tOIDC_PROTO_LOGOUT_TOKEN);\n\t\tgoto out;\n\t}\n\n\t// TODO: jwk symmetric key based on provider\n\t// TODO: share more code with regular id_token validation and unsolicited state\n\n\tif (oidc_jwt_parse(r->pool, logout_token, &jwt,\n\t\t\toidc_util_merge_symmetric_key(r->pool, cfg->private_keys, NULL),\n\t\t\t&err) == FALSE) {\n\t\toidc_error(r, \"oidc_jwt_parse failed: %s\", oidc_jose_e2s(r->pool, err));\n\t\tgoto out;\n\t}\n\n\tprovider = oidc_get_provider_for_issuer(r, cfg, jwt->payload.iss, FALSE);\n\tif (provider == NULL) {\n\t\toidc_error(r, \"no provider found for issuer: %s\", jwt->payload.iss);\n\t\tgoto out;\n\t}\n\n\t// TODO: destroy the JWK used for decryption\n\n\tjwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, provider->client_secret, 0,\n\t\t\tNULL, TRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwks_uri_t jwks_uri = { provider->jwks_uri,\n\t\t\tprovider->jwks_refresh_interval, provider->ssl_validate_server };\n\tif (oidc_proto_jwt_verify(r, cfg, jwt, &jwks_uri,\n\t\t\toidc_util_merge_symmetric_key(r->pool, NULL, jwk)) == FALSE) {\n\n\t\toidc_error(r, \"id_token signature could not be validated, aborting\");\n\t\tgoto out;\n\t}\n\n\t// oidc_proto_validate_idtoken would try and require a token binding cnf\n\t// if the policy is set to \"required\", so don't use that here\n\n\tif (oidc_proto_validate_jwt(r, jwt, provider->issuer, FALSE, FALSE,\n\t\t\tprovider->idtoken_iat_slack,\n\t\t\tOIDC_TOKEN_BINDING_POLICY_DISABLED) == FALSE)\n\t\tgoto out;\n\n\t/* verify the \"aud\" and \"azp\" values */\n\tif (oidc_proto_validate_aud_and_azp(r, cfg, provider,\n\t\t\t&jwt->payload) == FALSE)\n\t\tgoto out;\n\n\tjson_t *events = json_object_get(jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_EVENTS);\n\tif (events == NULL) {\n\t\toidc_error(r, \"\\\"%s\\\" claim could not be found in logout token\",\n\t\t\t\tOIDC_CLAIM_EVENTS);\n\t\tgoto out;\n\t}\n\n\tjson_t *blogout = json_object_get(events, OIDC_EVENTS_BLOGOUT_KEY);\n\tif (!json_is_object(blogout)) {\n\t\toidc_error(r, \"\\\"%s\\\" object could not be found in \\\"%s\\\" claim\",\n\t\t\t\tOIDC_EVENTS_BLOGOUT_KEY, OIDC_CLAIM_EVENTS);\n\t\tgoto out;\n\t}\n\n\tchar *nonce = NULL;\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_NONCE, &nonce, NULL);\n\tif (nonce != NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"rejecting logout request/token since it contains a \\\"%s\\\" claim\",\n\t\t\t\tOIDC_CLAIM_NONCE);\n\t\tgoto out;\n\t}\n\n\tchar *jti = NULL;\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_JTI, &jti, NULL);\n\tif (jti != NULL) {\n\t\tchar *replay = NULL;\n\t\toidc_cache_get_jti(r, jti, &replay);\n\t\tif (replay != NULL) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the \\\"%s\\\" value (%s) passed in logout token was found in the cache already; possible replay attack!?\",\n\t\t\t\t\tOIDC_CLAIM_JTI, jti);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* jti cache duration is the configured replay prevention window for token issuance plus 10 seconds for safety */\n\tapr_time_t jti_cache_duration = apr_time_from_sec(\n\t\t\tprovider->idtoken_iat_slack * 2 + 10);\n\n\t/* store it in the cache for the calculated duration */\n\toidc_cache_set_jti(r, jti, jti, apr_time_now() + jti_cache_duration);\n\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_EVENTS, &sid, NULL);\n\n\t// TODO: by-spec we should cater for the fact that \"sid\" has been provided\n\t//       in the id_token returned in the authentication request, but \"sub\"\n\t//       is used in the logout token but that requires a 2nd entry in the\n\t//       cache and a separate session \"sub\" member, ugh; we'll just assume\n\t//       that is \"sid\" is specified in the id_token, the OP will actually use\n\t//       this for logout\n\t//       (and probably call us multiple times or the same sub if needed)\n\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_SID, &sid, NULL);\n\tif (sid == NULL)\n\t\tsid = jwt->payload.sub;\n\n\tif (sid == NULL) {\n\t\toidc_error(r, \"no \\\"sub\\\" and no \\\"sid\\\" claim found in logout token\");\n\t\tgoto out;\n\t}\n\n\t// TODO: when dealing with sub instead of a true sid, we'll be killing all sessions for\n\t//       a specific user, across hosts that share the *same* cache backend\n\t//       if those hosts haven't been configured with a different OIDCCryptoPassphrase\n\t//       - perhaps that's even acceptable since non-memory caching is encrypted by default\n\t//         and memory-based caching doesn't suffer from this (different shm segments)?\n\t//       - it will result in 400 errors returned from backchannel logout calls to the other hosts...\n\n\tsid = oidc_make_sid_iss_unique(r, sid, provider->issuer);\n\toidc_cache_get_sid(r, sid, &uuid);\n\tif (uuid == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"could not find session based on sid/sub provided in logout token: %s\",\n\t\t\t\tsid);\n\t\tgoto out;\n\t}\n\n\t// revoke tokens if we can get a handle on those\n\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\tif (oidc_session_load_cache_by_uuid(r, cfg, uuid, &session) != FALSE)\n\t\t\tif (oidc_session_extract(r, &session) != FALSE)\n\t\t\t\toidc_revoke_tokens(r, cfg, &session);\n\t}\n\n\t// clear the session cache\n\toidc_cache_set_sid(r, sid, NULL, 0);\n\toidc_cache_set_session(r, uuid, NULL, 0);\n\n\trc = OK;\n\nout:\n\n\tif (jwk != NULL) {\n\t\toidc_jwk_destroy(jwk);\n\t\tjwk = NULL;\n\n\t}\n\tif (jwt != NULL) {\n\t\toidc_jwt_destroy(jwt);\n\t\tjwt = NULL;\n\t}\n\n\treturn rc;\n}\n\nstatic apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n        } else if ((uri.hostname == NULL) && (strstr(url, \"//\") == url)) {\n                *err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n                *err_desc =\n                                apr_psprintf(r->pool,\n                                                \"No hostname was parsed and starting with '//': %s\",\n                                                url);\n                oidc_error(r, \"%s: %s\", *err_str, *err_desc);\n                return FALSE;\n\t}\n\n\t/* validate the URL to prevent HTTP header splitting */\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * perform (single) logout\n */\nstatic int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\t\tif (oidc_validate_post_logout_url(r, url, &error_str,\n\t\t\t\t&error_description) == FALSE) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\t\terror_description,\n\t\t\t\t\tHTTP_BAD_REQUEST);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}\n\n/*\n * handle request for JWKs\n */\nint oidc_handle_jwks(request_rec *r, oidc_cfg *c) {\n\n\t/* pickup requested JWKs type */\n\t//\tchar *jwks_type = NULL;\n\t//\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_JWKS, &jwks_type);\n\tchar *jwks = apr_pstrdup(r->pool, \"{ \\\"keys\\\" : [\");\n\tapr_hash_index_t *hi = NULL;\n\tapr_byte_t first = TRUE;\n\toidc_jose_error_t err;\n\n\tif (c->public_keys != NULL) {\n\n\t\t/* loop over the RSA public keys */\n\t\tfor (hi = apr_hash_first(r->pool, c->public_keys); hi; hi =\n\t\t\t\tapr_hash_next(hi)) {\n\n\t\t\tconst char *s_kid = NULL;\n\t\t\toidc_jwk_t *jwk = NULL;\n\t\t\tchar *s_json = NULL;\n\n\t\t\tapr_hash_this(hi, (const void**) &s_kid, NULL, (void**) &jwk);\n\n\t\t\tif (oidc_jwk_to_json(r->pool, jwk, &s_json, &err) == TRUE) {\n\t\t\t\tjwks = apr_psprintf(r->pool, \"%s%s %s \", jwks, first ? \"\" : \",\",\n\t\t\t\t\t\ts_json);\n\t\t\t\tfirst = FALSE;\n\t\t\t} else {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"could not convert RSA JWK to JSON using oidc_jwk_to_json: %s\",\n\t\t\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: send stuff if first == FALSE?\n\tjwks = apr_psprintf(r->pool, \"%s ] }\", jwks);\n\n\treturn oidc_util_http_send(r, jwks, strlen(jwks), OIDC_CONTENT_TYPE_JSON,\n\t\t\tOK);\n}\n\nstatic int oidc_handle_session_management_iframe_op(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *check_session_iframe) {\n\toidc_debug(r, \"enter\");\n\toidc_util_hdr_out_location_set(r, check_session_iframe);\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\nstatic int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var message = '%s' + ' ' + '%s';\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %d);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.debug('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed') {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=check';\\n\"\n\t\t\t\"          } else {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=logout';\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\treturn OK;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tint poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;\n\tif ((poll_interval <= 0) || (poll_interval > 3600 * 24))\n\t\tpoll_interval = 3000;\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, poll_interval, redirect_uri,\n\t\t\tredirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, OK);\n}\n\n/*\n * handle session management request\n */\nstatic int oidc_handle_session_management(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tchar *cmd = NULL;\n\tconst char *id_token_hint = NULL;\n\toidc_provider_t *provider = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_SESSION, &cmd);\n\tif (cmd == NULL) {\n\t\toidc_error(r, \"session management handler called with no command\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if this is a local logout during session management */\n\tif (apr_strnatcmp(\"logout\", cmd) == 0) {\n\t\toidc_debug(r,\n\t\t\t\t\"[session=logout] calling oidc_handle_logout_request because of session mgmt local logout call.\");\n\t\treturn oidc_handle_logout_request(r, c, session, c->default_slo_url);\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\t/* see if this is a request for the OP iframe */\n\tif (apr_strnatcmp(\"iframe_op\", cmd) == 0) {\n\t\tif (provider->check_session_iframe != NULL) {\n\t\t\treturn oidc_handle_session_management_iframe_op(r, c, session,\n\t\t\t\t\tprovider->check_session_iframe);\n\t\t}\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request for the RP iframe */\n\tif (apr_strnatcmp(\"iframe_rp\", cmd) == 0) {\n\t\tif ((provider->client_id != NULL)\n\t\t\t\t&& (provider->check_session_iframe != NULL)) {\n\t\t\treturn oidc_handle_session_management_iframe_rp(r, c, session,\n\t\t\t\t\tprovider->client_id, provider->check_session_iframe);\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"iframe_rp command issued but no client (%s) and/or no check_session_iframe (%s) set\",\n\t\t\t\tprovider->client_id, provider->check_session_iframe);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request check the login state with the OP */\n\tif (apr_strnatcmp(\"check\", cmd) == 0) {\n\t\tid_token_hint = oidc_session_get_idtoken(r, session);\n\t\tif ((session->remote_user != NULL) && (provider != NULL)) {\n\t\t\t/*\n\t\t\t * TODO: this doesn't work with per-path provided auth_request_params and scopes\n\t\t\t *       as oidc_dir_cfg_path_auth_request_params and oidc_dir_cfg_path_scope will pick\n\t\t\t *       those for the redirect_uri itself; do we need to store those as part of the\n\t\t\t *       session now?\n\t\t\t */\n\t\t\treturn oidc_authenticate_user(r, c, provider,\n\t\t\t\t\tapr_psprintf(r->pool, \"%s?session=iframe_rp\",\n\t\t\t\t\t\t\toidc_get_redirect_uri_iss(r, c, provider)), NULL,\n\t\t\t\t\t\t\tid_token_hint, \"none\",\n\t\t\t\t\t\t\toidc_dir_cfg_path_auth_request_params(r),\n\t\t\t\t\t\t\toidc_dir_cfg_path_scope(r));\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"[session=check] calling oidc_handle_logout_request because no session found.\");\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\n\t/* handle failure in fallthrough */\n\toidc_error(r, \"unknown command: %s\", cmd);\n\n\treturn HTTP_INTERNAL_SERVER_ERROR;\n}\n\n/*\n * handle refresh token request\n */\nstatic int oidc_handle_refresh_token_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *return_to = NULL;\n\tchar *r_access_token = NULL;\n\tchar *error_code = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REFRESH,\n\t\t\t&return_to);\n\toidc_util_get_request_parameter(r, OIDC_PROTO_ACCESS_TOKEN,\n\t\t\t&r_access_token);\n\n\t/* check the input parameters */\n\tif (return_to == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no URL to return to\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (r_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no access_token parameter\");\n\t\terror_code = \"no_access_token\";\n\t\tgoto end;\n\t}\n\n\tconst char *s_access_token = oidc_session_get_access_token(r, session);\n\tif (s_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"no existing access_token found in the session, nothing to refresh\");\n\t\terror_code = \"no_access_token_exists\";\n\t\tgoto end;\n\t}\n\n\t/* compare the access_token parameter used for XSRF protection */\n\tif (apr_strnatcmp(s_access_token, r_access_token) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"access_token passed in refresh request does not match the one stored in the session\");\n\t\terror_code = \"no_access_token_match\";\n\t\tgoto end;\n\t}\n\n\t/* get a handle to the provider configuration */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\n\t/* execute the actual refresh grant */\n\tif (oidc_refresh_access_token(r, c, session, provider, NULL) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\terror_code = \"refresh_failed\";\n\t\tgoto end;\n\t}\n\n\t/* pass the tokens to the application and save the session, possibly updating the expiry */\n\tif (oidc_session_pass_tokens_and_save(r, c, session, TRUE) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\nend:\n\n\t/* pass optional error message to the return URL */\n\tif (error_code != NULL)\n\t\treturn_to = apr_psprintf(r->pool, \"%s%serror_code=%s\", return_to,\n\t\t\t\tstrchr(return_to ? return_to : \"\", OIDC_CHAR_QUERY) ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY, oidc_util_escape_string(r, error_code));\n\n\t/* add the redirect location header */\n\toidc_util_hdr_out_location_set(r, return_to);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle request object by reference request\n */\nstatic int oidc_handle_request_uri(request_rec *r, oidc_cfg *c) {\n\n\tchar *request_ref = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REQUEST_URI,\n\t\t\t&request_ref);\n\tif (request_ref == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" parameter found\",\n\t\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI);\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\n\tchar *jwt = NULL;\n\toidc_cache_get_request_uri(r, request_ref, &jwt);\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no cached JWT found for %s reference: %s\",\n\t\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI, request_ref);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\toidc_cache_set_request_uri(r, request_ref, NULL, 0);\n\n\treturn oidc_util_http_send(r, jwt, strlen(jwt), OIDC_CONTENT_TYPE_JWT, OK);\n}\n\n/*\n * handle a request to invalidate a cached access token introspection result\n */\nint oidc_handle_remove_at_cache(request_rec *r, oidc_cfg *c) {\n\tchar *access_token = NULL;\n\toidc_util_get_request_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE, &access_token);\n\n\tchar *cache_entry = NULL;\n\toidc_cache_get_access_token(r, access_token, &cache_entry);\n\tif (cache_entry == NULL) {\n\t\toidc_error(r, \"no cached access token found for value: %s\",\n\t\t\t\taccess_token);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\toidc_cache_set_access_token(r, access_token, NULL, 0);\n\n\treturn OK;\n}\n\n#define OIDC_INFO_PARAM_ACCESS_TOKEN_REFRESH_INTERVAL \"access_token_refresh_interval\"\n\n/*\n * handle request for session info\n */\nstatic int oidc_handle_info_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tint rc = HTTP_UNAUTHORIZED;\n\tapr_byte_t needs_save = FALSE;\n\tchar *s_format = NULL, *s_interval = NULL, *r_value = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_INFO,\n\t\t\t&s_format);\n\toidc_util_get_request_parameter(r,\n\t\t\tOIDC_INFO_PARAM_ACCESS_TOKEN_REFRESH_INTERVAL, &s_interval);\n\n\t/* see if this is a request for a format that is supported */\n\tif ((apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_JSON, s_format) != 0)\n\t\t\t&& (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_HTML, s_format) != 0)) {\n\t\toidc_warn(r, \"request for unknown format: %s\", s_format);\n\t\treturn HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t}\n\n\t/* check that we actually have a user session and this is someone calling with a proper session cookie */\n\tif (session->remote_user == NULL) {\n\t\toidc_warn(r, \"no user session found\");\n\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/* set the user in the main request for further (incl. sub-request and authz) processing */\n\tr->user = apr_pstrdup(r->pool, session->remote_user);\n\n\tif (c->info_hook_data == NULL) {\n\t\toidc_warn(r, \"no data configured to return in \" OIDCInfoHook);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if we can and need to refresh the access token */\n\tif ((s_interval != NULL)\n\t\t\t&& (oidc_session_get_refresh_token(r, session) != NULL)) {\n\n\t\tapr_time_t t_interval;\n\t\tif (sscanf(s_interval, \"%\" APR_TIME_T_FMT, &t_interval) == 1) {\n\t\t\tt_interval = apr_time_from_sec(t_interval);\n\n\t\t\t/* get the last refresh timestamp from the session info */\n\t\t\tapr_time_t last_refresh =\n\t\t\t\t\toidc_session_get_access_token_last_refresh(r, session);\n\n\t\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\t\tapr_time_sec(last_refresh + t_interval - apr_time_now()));\n\n\t\t\t/* see if we need to refresh again */\n\t\t\tif (last_refresh + t_interval < apr_time_now()) {\n\n\t\t\t\t/* get the current provider info */\n\t\t\t\toidc_provider_t *provider = NULL;\n\t\t\t\tif (oidc_get_provider_from_session(r, c, session,\n\t\t\t\t\t\t&provider) == FALSE)\n\t\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t\t\t/* execute the actual refresh grant */\n\t\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t\tNULL) == FALSE)\n\t\t\t\t\toidc_warn(r, \"access_token could not be refreshed\");\n\t\t\t\telse\n\t\t\t\t\tneeds_save = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* create the JSON object */\n\tjson_t *json = json_object();\n\n\t/* add a timestamp of creation in there for the caller */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_TIMESTAMP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_TIMESTAMP,\n\t\t\t\tjson_integer(apr_time_sec(apr_time_now())));\n\t}\n\n\t/*\n\t * refresh the claims from the userinfo endpoint\n\t * side-effect is that this may refresh the access token if not already done\n\t * note that OIDCUserInfoRefreshInterval should be set to control the refresh policy\n\t */\n\tneeds_save |= oidc_refresh_claims_from_userinfo_endpoint(r, c, session);\n\n\t/* include the access token in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tconst char *access_token = oidc_session_get_access_token(r, session);\n\t\tif (access_token != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN,\n\t\t\t\t\tjson_string(access_token));\n\t}\n\n\t/* include the access token expiry timestamp in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tconst char *access_token_expires =\n\t\t\t\toidc_session_get_access_token_expires(r, session);\n\t\tif (access_token_expires != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,\n\t\t\t\t\tjson_string(access_token_expires));\n\t}\n\n\t/* include the id_token claims in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ID_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_t *id_token = oidc_session_get_idtoken_claims_json(r, session);\n\t\tif (id_token)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ID_TOKEN, id_token);\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_USER_INFO,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\t/* include the claims from the userinfo endpoint the session info */\n\t\tjson_t *claims = oidc_session_get_userinfo_claims_json(r, session);\n\t\tif (claims)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_USER_INFO, claims);\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_t *j_session = json_object();\n\t\tjson_object_set(j_session, OIDC_HOOK_INFO_SESSION_STATE,\n\t\t\t\tsession->state);\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_UUID,\n\t\t\t\tjson_string(session->uuid));\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_TIMEOUT,\n\t\t\t\tjson_integer(apr_time_sec(session->expiry)));\n\t\tapr_time_t session_expires = oidc_session_get_session_expires(r,\n\t\t\t\tsession);\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_EXP,\n\t\t\t\tjson_integer(apr_time_sec(session_expires)));\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_REMOTE_USER,\n\t\t\t\tjson_string(session->remote_user));\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION, j_session);\n\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_REFRESH_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\t/* include the refresh token in the session info */\n\t\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\t\tif (refresh_token != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_REFRESH_TOKEN,\n\t\t\t\t\tjson_string(refresh_token));\n\t}\n\n\tif (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_JSON, s_format) == 0) {\n\t\t/* JSON-encode the result */\n\t\tr_value = oidc_util_encode_json_object(r, json, 0);\n\t\t/* return the stringified JSON result */\n\t\trc = oidc_util_http_send(r, r_value, strlen(r_value),\n\t\t\t\tOIDC_CONTENT_TYPE_JSON, OK);\n\t} else if (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_HTML, s_format) == 0) {\n\t\t/* JSON-encode the result */\n\t\tr_value = oidc_util_encode_json_object(r, json, JSON_INDENT(2));\n\t\trc = oidc_util_html_send(r, \"Session Info\", NULL, NULL,\n\t\t\t\tapr_psprintf(r->pool, \"<pre>%s</pre>\", r_value), OK);\n\t}\n\n\t/* free the allocated resources */\n\tjson_decref(json);\n\n\t/* pass the tokens to the application and save the session, possibly updating the expiry */\n\tif (oidc_session_pass_tokens_and_save(r, c, session, needs_save) == FALSE) {\n\t\toidc_warn(r, \"error saving session\");\n\t\trc = HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\treturn rc;\n}\n\n/*\n * handle all requests to the redirect_uri\n */\nint oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response from the OP using the Basic Client profile or a Hybrid flow*/\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t/*\n\t *\n\t * Note that we are checking for logout *before* checking for a POST authorization response\n\t * to handle backchannel POST-based logout\n\t *\n\t * so any POST to the Redirect URI that does not have a logout query parameter will be handled\n\t * as an authorization response; alternatively we could assume that a POST response has no\n\t * parameters\n\t */\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_LOGOUT)) {\n\t\t/* handle logout */\n\t\treturn oidc_handle_logout(r, c, session);\n\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response using the fragment(+POST) response_mode with the Implicit Client profile */\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\n\t} else if (oidc_is_discovery_response(r, c)) {\n\n\t\t/* this is response from the OP discovery page */\n\t\treturn oidc_handle_discovery_response(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_JWKS)) {\n\n\t\t/* handle JWKs request */\n\t\treturn oidc_handle_jwks(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_SESSION)) {\n\n\t\t/* handle session management request */\n\t\treturn oidc_handle_session_management(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REFRESH)) {\n\n\t\t/* handle refresh token request */\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI)) {\n\n\t\t/* handle request object by reference request */\n\t\treturn oidc_handle_request_uri(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE)) {\n\n\t\t/* handle request to invalidate access token cache */\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_INFO)) {\n\n\t\tif (session->remote_user == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\n\t\t/* set r->user, set headers/env-vars, update expiry, update userinfo + AT */\n\t\tint rc = oidc_handle_existing_session(r, c, session);\n\t\tif (rc != OK)\n\t\t\treturn rc;\n\n\t\treturn oidc_handle_info_request(r, c, session);\n\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\n\t\t/* this is a \"bare\" request to the redirect URI, indicating implicit flow using the fragment response_mode */\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\n\t/* this is not an authorization response or logout request */\n\n\t/* check for \"error\" response */\n\tif (oidc_util_request_has_parameter(r, OIDC_PROTO_ERROR)) {\n\n\t\t//\t\tchar *error = NULL, *descr = NULL;\n\t\t//\t\toidc_util_get_request_parameter(r, \"error\", &error);\n\t\t//\t\toidc_util_get_request_parameter(r, \"error_description\", &descr);\n\t\t//\n\t\t//\t\t/* send user facing error to browser */\n\t\t//\t\treturn oidc_util_html_send_error(r, error, descr, DONE);\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\n\toidc_error(r,\n\t\t\t\"The OpenID Connect callback URL received an invalid request: %s; returning HTTP_INTERNAL_SERVER_ERROR\",\n\t\t\tr->args);\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request\"),\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n}\n\n#define OIDC_AUTH_TYPE_OPENID_CONNECT \"openid-connect\"\n#define OIDC_AUTH_TYPE_OPENID_OAUTH20 \"oauth20\"\n#define OIDC_AUTH_TYPE_OPENID_BOTH    \"auth-openidc\"\n\n/*\n * main routine: handle OpenID Connect authentication\n */\nstatic int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) {\n\n\tif (oidc_get_redirect_uri(r, c) == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"configuration error: the authentication type is set to \\\"\" OIDC_AUTH_TYPE_OPENID_CONNECT \"\\\" but \" OIDCRedirectURI \" has not been set\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* check if this is a sub-request or an initial request */\n\tif (ap_is_initial_req(r)) {\n\n\t\tint rc = OK;\n\n\t\t/* load the session from the request state; this will be a new \"empty\" session if no state exists */\n\t\toidc_session_t *session = NULL;\n\t\toidc_session_load(r, &session);\n\n\t\t/* see if the initial request is to the redirect URI; this handles potential logout too */\n\t\tif (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c))) {\n\n\t\t\t/* handle request to the redirect_uri */\n\t\t\trc = oidc_handle_redirect_uri_request(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\treturn rc;\n\n\t\t\t/* initial request to non-redirect URI, check if we have an existing session */\n\t\t} else if (session->remote_user != NULL) {\n\n\t\t\t/* this is initial request and we already have a session */\n\t\t\trc = oidc_handle_existing_session(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\t/*\n\t\t * else: initial request, we have no session and it is not an authorization or\n\t\t *       discovery response: just hit the default flow for unauthenticated users\n\t\t */\n\t} else {\n\n\t\t/* not an initial request, try to recycle what we've already established in the main request */\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session (headers will have been scrubbed and set already) */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\t/*\n\t\t\t * apparently request state can get lost in sub-requests, so let's see\n\t\t\t * if we need to restore id_token and/or claims from the session cache\n\t\t\t */\n\t\t\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\t\t\tif (s_id_token == NULL) {\n\n\t\t\t\toidc_session_t *session = NULL;\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\toidc_copy_tokens_to_request_state(r, session, NULL, NULL);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\t\t\t}\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn OK;\n\t\t}\n\t\t/*\n\t\t * else: not initial request, but we could not find a session, so:\n\t\t * just hit the default flow for unauthenticated users\n\t\t */\n\t}\n\n\treturn oidc_handle_unauthenticated_user(r, c);\n}\n\n/*\n * main routine: handle \"mixed\" OIDC/OAuth authentication\n */\nstatic int oidc_check_mixed_userid_oauth(request_rec *r, oidc_cfg *c) {\n\n\t/* get the bearer access token from the Authorization header */\n\tconst char *access_token = NULL;\n\tif (oidc_oauth_get_bearer_token(r, &access_token) == TRUE)\n\t\treturn oidc_oauth_check_userid(r, c, access_token);\n\n\t/* no bearer token found: then treat this as a regular OIDC browser request */\n\treturn oidc_check_userid_openidc(r, c);\n}\n\n/*\n * generic Apache authentication hook for this module: dispatches to OpenID Connect or OAuth 2.0 specific routines\n */\nint oidc_check_user_id(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\t/* log some stuff about the incoming HTTP request */\n\toidc_debug(r, \"incoming request: \\\"%s?%s\\\", ap_is_initial_req(r)=%d\",\n\t\t\tr->parsed_uri.path, r->args, ap_is_initial_req(r));\n\n\t/* see if any authentication has been defined at all */\n\tif (ap_auth_type(r) == NULL)\n\t\treturn DECLINED;\n\n\t/* see if we've configured OpenID Connect user authentication for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_CONNECT) == 0)\n\t\treturn oidc_check_userid_openidc(r, c);\n\n\t/* see if we've configured OAuth 2.0 access control for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)\n\t\treturn oidc_oauth_check_userid(r, c, NULL);\n\n\t/* see if we've configured \"mixed mode\" for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn oidc_check_mixed_userid_oauth(r, c);\n\n\t/* this is not for us but for some other handler */\n\treturn DECLINED;\n}\n\n/*\n * get the claims and id_token from request state\n */\nstatic void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\n\tconst char *s_claims = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_CLAIMS);\n\tif (s_claims != NULL)\n\t\toidc_util_decode_json_object(r, s_claims, claims);\n\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\tif (s_id_token != NULL)\n\t\toidc_util_decode_json_object(r, s_id_token, id_token);\n}\n\n#if MODULE_MAGIC_NUMBER_MAJOR >= 20100714\n\n/*\n * find out which action we need to take when encountering an unauthorized request\n */\nstatic authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\",\n\t\t\t\t\"Different scope(s) or other claims required\");\n\t\treturn AUTHZ_DENIED;\n\t}\n\n\t/* see if we've configured OIDCUnAutzAction for this path */\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t// TODO: document that AuthzSendForbiddenOnFailure is required to return 403 FORBIDDEN\n\tcase OIDC_UNAUTZ_RETURN403:\n\tcase OIDC_UNAUTZ_RETURN401:\n\t\treturn AUTHZ_DENIED;\n\t\tbreak;\n\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\treturn AUTHZ_DENIED;\n\t\tbreak;\n\t}\n\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r),\n\t\t\toidc_dir_cfg_path_scope(r));\n\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\",\n\t\t\t\tlocation);\n\n\t\tchar *html_head = apr_psprintf(r->pool,\n\t\t\t\t\"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\",\n\t\t\t\tlocation);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\treturn AUTHZ_DENIED;\n}\n\n/*\n * generic Apache >=2.4 authorization hook for this module\n * handles both OpenID Connect or OAuth 2.0 in the same way, based on the claims stored in the session\n */\nauthz_status oidc_authz_checker(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args,\n\t\toidc_authz_match_claim_fn_type match_claim_fn) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn AUTHZ_GRANTED;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(r, id_token, claims);\n\n\t/* dispatch to the >=2.4 specific authz routine */\n\tauthz_status rc = oidc_authz_worker24(r, claims ? claims : id_token,\n\t\t\trequire_args, match_claim_fn);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == AUTHZ_DENIED) && ap_auth_type(r))\n\t\trc = oidc_handle_unauthorized_user24(r);\n\n\treturn rc;\n}\n\nauthz_status oidc_authz_checker_claim(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args,\n\t\t\toidc_authz_match_claim);\n}\n\n#ifdef USE_LIBJQ\nauthz_status oidc_authz_checker_claims_expr(request_rec *r, const char *require_args, const void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args, oidc_authz_match_claims_expr);\n}\n#endif\n\n#else\n\n/*\n * find out which action we need to take when encountering an unauthorized request\n */\nstatic int oidc_handle_unauthorized_user22(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r), OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\", \"Different scope(s) or other claims required\");\n\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/* see if we've configured OIDCUnAutzAction for this path */\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\tcase OIDC_UNAUTZ_RETURN403:\n\t\treturn HTTP_FORBIDDEN;\n\tcase OIDC_UNAUTZ_RETURN401:\n\t\treturn HTTP_UNAUTHORIZED;\n\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n}\n\n/*\n * generic Apache <2.4 authorization hook for this module\n * handles both OpenID Connect and OAuth 2.0 in the same way, based on the claims stored in the request context\n */\nint oidc_auth_checker(request_rec *r) {\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn OK;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* get the Require statements */\n\tconst apr_array_header_t * const reqs_arr = ap_requires(r);\n\n\t/* see if we have any */\n\tconst require_line * const reqs =\n\t\t\treqs_arr ? (require_line *) reqs_arr->elts : NULL;\n\tif (!reqs_arr) {\n\t\toidc_debug(r,\n\t\t\t\t\"no require statements found, so declining to perform authorization.\");\n\t\treturn DECLINED;\n\t}\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(r, id_token, claims);\n\n\t/* dispatch to the <2.4 specific authz routine */\n\tint rc = oidc_authz_worker22(r, claims ? claims : id_token, reqs,\n\t\t\treqs_arr->nelts);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == HTTP_UNAUTHORIZED) && ap_auth_type(r))\n\t\trc = oidc_handle_unauthorized_user22(r);\n\n\treturn rc;\n}\n\n#endif\n\napr_byte_t oidc_enabled(request_rec *r) {\n\tif (ap_auth_type(r) == NULL)\n\t\treturn FALSE;\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_CONNECT) == 0)\n\t\treturn TRUE;\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)\n\t\treturn TRUE;\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n/*\n * handle content generating requests\n */\nint oidc_content_handler(request_rec *r) {\n\tif (oidc_enabled(r) == FALSE)\n\t\treturn DECLINED;\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\treturn oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c)) ?\n\t\t\tOK : DECLINED;\n}\n\nextern const command_rec oidc_config_cmds[];\n\nmodule AP_MODULE_DECLARE_DATA auth_openidc_module = {\n\t\tSTANDARD20_MODULE_STUFF,\n\t\toidc_create_dir_config,\n\t\toidc_merge_dir_config,\n\t\toidc_create_server_config,\n\t\toidc_merge_server_config,\n\t\toidc_config_cmds,\n\t\toidc_register_hooks\n};\n"], "fixing_code": ["/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/***************************************************************************\n * Copyright (C) 2017-2019 ZmartZone IAM\n * Copyright (C) 2013-2017 Ping Identity Corporation\n * All rights reserved.\n *\n * For further information please contact:\n *\n *      Ping Identity Corporation\n *      1099 18th St Suite 2950\n *      Denver, CO 80202\n *      303.468.2900\n *      http://www.pingidentity.com\n *\n * DISCLAIMER OF WARRANTIES:\n *\n * THE SOFTWARE PROVIDED HEREUNDER IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT\n * ANY WARRANTIES OR REPRESENTATIONS EXPRESS, IMPLIED OR STATUTORY; INCLUDING,\n * WITHOUT LIMITATION, WARRANTIES OF QUALITY, PERFORMANCE, NONINFRINGEMENT,\n * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  NOR ARE THERE ANY\n * WARRANTIES CREATED BY A COURSE OR DEALING, COURSE OF PERFORMANCE OR TRADE\n * USAGE.  FURTHERMORE, THERE ARE NO WARRANTIES THAT THE SOFTWARE WILL MEET\n * YOUR NEEDS OR BE FREE FROM ERRORS, OR THAT THE OPERATION OF THE SOFTWARE\n * WILL BE UNINTERRUPTED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Initially based on mod_auth_cas.c:\n * https://github.com/Jasig/mod_auth_cas\n *\n * Other code copied/borrowed/adapted:\n * shared memory caching: mod_auth_mellon\n *\n * @Author: Hans Zandbelt - hans.zandbelt@zmartzone.eu\n *\n **************************************************************************/\n\n#include \"apr_hash.h\"\n#include \"apr_strings.h\"\n#include \"ap_config.h\"\n#include \"ap_provider.h\"\n#include \"apr_lib.h\"\n#include \"apr_file_io.h\"\n#include \"apr_sha1.h\"\n#include \"apr_base64.h\"\n\n#include \"httpd.h\"\n#include \"http_core.h\"\n#include \"http_config.h\"\n#include \"http_log.h\"\n#include \"http_protocol.h\"\n#include \"http_request.h\"\n\n#include \"mod_auth_openidc.h\"\n\n#define ERROR 2\n\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url);\n\n// TODO:\n// - sort out oidc_cfg vs. oidc_dir_cfg stuff\n// - rigid input checking on discovery responses\n// - check self-issued support\n// - README.quickstart\n// - refresh metadata once-per too? (for non-signing key changes)\n\nextern module AP_MODULE_DECLARE_DATA auth_openidc_module;\n\n/*\n * clean any suspicious headers in the HTTP request sent by the user agent\n */\nstatic void oidc_scrub_request_headers(request_rec *r, const char *claim_prefix,\n\t\tapr_hash_t *scrub) {\n\n\tconst int prefix_len = claim_prefix ? strlen(claim_prefix) : 0;\n\n\t/* get an array representation of the incoming HTTP headers */\n\tconst apr_array_header_t * const h = apr_table_elts(r->headers_in);\n\n\t/* table to keep the non-suspicious headers */\n\tapr_table_t *clean_headers = apr_table_make(r->pool, h->nelts);\n\n\t/* loop over the incoming HTTP headers */\n\tconst apr_table_entry_t * const e = (const apr_table_entry_t *) h->elts;\n\tint i;\n\tfor (i = 0; i < h->nelts; i++) {\n\t\tconst char * const k = e[i].key;\n\n\t\t/* is this header's name equivalent to a header that needs scrubbing? */\n\t\tconst char *hdr =\n\t\t\t\t(k != NULL) && (scrub != NULL) ?\n\t\t\t\t\t\tapr_hash_get(scrub, k, APR_HASH_KEY_STRING) : NULL;\n\t\tconst int header_matches = (hdr != NULL)\n\t\t\t\t\t\t&& (oidc_strnenvcmp(k, hdr, -1) == 0);\n\n\t\t/*\n\t\t * would this header be interpreted as a mod_auth_openidc attribute? Note\n\t\t * that prefix_len will be zero if no attr_prefix is defined,\n\t\t * so this will always be false. Also note that we do not\n\t\t * scrub headers if the prefix is empty because every header\n\t\t * would match.\n\t\t */\n\t\tconst int prefix_matches = (k != NULL) && prefix_len\n\t\t\t\t&& (oidc_strnenvcmp(k, claim_prefix, prefix_len) == 0);\n\n\t\t/* add to the clean_headers if non-suspicious, skip and report otherwise */\n\t\tif (!prefix_matches && !header_matches) {\n\t\t\tapr_table_addn(clean_headers, k, e[i].val);\n\t\t} else {\n\t\t\toidc_warn(r, \"scrubbed suspicious request header (%s: %.32s)\", k,\n\t\t\t\t\te[i].val);\n\t\t}\n\t}\n\n\t/* overwrite the incoming headers with the cleaned result */\n\tr->headers_in = clean_headers;\n}\n\n/*\n * scrub all mod_auth_openidc related headers\n */\nvoid oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *prefix = oidc_cfg_claim_prefix(r);\n\tapr_hash_t *hdrs = apr_hash_make(r->pool);\n\n\tif (apr_strnatcmp(prefix, \"\") == 0) {\n\t\tif ((cfg->white_listed_claims != NULL)\n\t\t\t\t&& (apr_hash_count(cfg->white_listed_claims) > 0))\n\t\t\thdrs = apr_hash_overlay(r->pool, cfg->white_listed_claims, hdrs);\n\t\telse\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"both \" OIDCClaimPrefix \" and \" OIDCWhiteListedClaims \" are empty: this renders an insecure setup!\");\n\t}\n\n\tchar *authn_hdr = oidc_cfg_dir_authn_header(r);\n\tif (authn_hdr != NULL)\n\t\tapr_hash_set(hdrs, authn_hdr, APR_HASH_KEY_STRING, authn_hdr);\n\n\t/*\n\t * scrub all headers starting with OIDC_ first\n\t */\n\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX, hdrs);\n\n\t/*\n\t * then see if the claim headers need to be removed on top of that\n\t * (i.e. the prefix does not start with the default OIDC_)\n\t */\n\tif ((strstr(prefix, OIDC_DEFAULT_HEADER_PREFIX) != prefix)) {\n\t\toidc_scrub_request_headers(r, prefix, NULL);\n\t}\n}\n\n/*\n * strip the session cookie from the headers sent to the application/backend\n */\nvoid oidc_strip_cookies(request_rec *r) {\n\n\tchar *cookie, *ctx, *result = NULL;\n\tconst char *name = NULL;\n\tint i;\n\n\tapr_array_header_t *strip = oidc_dir_cfg_strip_cookies(r);\n\n\tchar *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));\n\n\tif ((cookies != NULL) && (strip != NULL)) {\n\n\t\toidc_debug(r,\n\t\t\t\t\"looking for the following cookies to strip from cookie header: %s\",\n\t\t\t\tapr_array_pstrcat(r->pool, strip, OIDC_CHAR_COMMA));\n\n\t\tcookie = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &ctx);\n\n\t\tdo {\n\t\t\twhile (cookie != NULL && *cookie == OIDC_CHAR_SPACE)\n\t\t\t\tcookie++;\n\n\t\t\tfor (i = 0; i < strip->nelts; i++) {\n\t\t\t\tname = ((const char**) strip->elts)[i];\n\t\t\t\tif ((strncmp(cookie, name, strlen(name)) == 0)\n\t\t\t\t\t\t&& (cookie[strlen(name)] == OIDC_CHAR_EQUAL)) {\n\t\t\t\t\toidc_debug(r, \"stripping: %s\", name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == strip->nelts) {\n\t\t\t\tresult = result ? apr_psprintf(r->pool, \"%s%s%s\", result,\n\t\t\t\t\t\tOIDC_STR_SEMI_COLON, cookie) :\n\t\t\t\t\t\tcookie;\n\t\t\t}\n\n\t\t\tcookie = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &ctx);\n\t\t} while (cookie != NULL);\n\n\t\toidc_util_hdr_in_cookie_set(r, result);\n\t}\n}\n\n#define OIDC_SHA1_LEN 20\n\n/*\n * calculates a hash value based on request fingerprint plus a provided nonce string.\n */\nstatic char *oidc_get_browser_state_hash(request_rec *r, const char *nonce) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* helper to hold to header values */\n\tconst char *value = NULL;\n\t/* the hash context */\n\tapr_sha1_ctx_t sha1;\n\n\t/* Initialize the hash context */\n\tapr_sha1_init(&sha1);\n\n\t/* get the X-FORWARDED-FOR header value  */\n\tvalue = oidc_util_hdr_in_x_forwarded_for_get(r);\n\t/* if we have a value for this header, concat it to the hash input */\n\tif (value != NULL)\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\n\t/* get the USER-AGENT header value  */\n\tvalue = oidc_util_hdr_in_user_agent_get(r);\n\t/* if we have a value for this header, concat it to the hash input */\n\tif (value != NULL)\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\n\t/* get the remote client IP address or host name */\n\t/*\n\tint remotehost_is_ip;\n\tvalue = ap_get_remote_host(r->connection, r->per_dir_config,\n\t\t\tREMOTE_NOLOOKUP, &remotehost_is_ip);\n\tapr_sha1_update(&sha1, value, strlen(value));\n\t*/\n\n\t/* concat the nonce parameter to the hash input */\n\tapr_sha1_update(&sha1, nonce, strlen(nonce));\n\n\t/* concat the token binding ID if present */\n\tvalue = oidc_util_get_provided_token_binding_id(r);\n\tif (value != NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"Provided Token Binding ID environment variable found; adding its value to the state\");\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\t}\n\n\t/* finalize the hash input and calculate the resulting hash output */\n\tunsigned char hash[OIDC_SHA1_LEN];\n\tapr_sha1_final(hash, &sha1);\n\n\t/* base64url-encode the resulting hash and return it */\n\tchar *result = NULL;\n\toidc_base64url_encode(r, &result, (const char *) hash, OIDC_SHA1_LEN, TRUE);\n\treturn result;\n}\n\n/*\n * return the name for the state cookie\n */\nstatic char *oidc_get_state_cookie_name(request_rec *r, const char *state) {\n\treturn apr_psprintf(r->pool, \"%s%s\", OIDC_STATE_COOKIE_PREFIX, state);\n}\n\n/*\n * return the static provider configuration, i.e. from a metadata URL or configuration primitives\n */\nstatic apr_byte_t oidc_provider_static_config(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t **provider) {\n\n\tjson_t *j_provider = NULL;\n\tchar *s_json = NULL;\n\n\t/* see if we should configure a static provider based on external (cached) metadata */\n\tif ((c->metadata_dir != NULL) || (c->provider.metadata_url == NULL)) {\n\t\t*provider = &c->provider;\n\t\treturn TRUE;\n\t}\n\n\toidc_cache_get_provider(r, c->provider.metadata_url, &s_json);\n\n\tif (s_json == NULL) {\n\n\t\tif (oidc_metadata_provider_retrieve(r, c, NULL,\n\t\t\t\tc->provider.metadata_url, &j_provider, &s_json) == FALSE) {\n\t\t\toidc_error(r, \"could not retrieve metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\toidc_cache_set_provider(r, c->provider.metadata_url, s_json,\n\t\t\t\tapr_time_now() + (c->provider_metadata_refresh_interval <= 0 ? apr_time_from_sec( OIDC_CACHE_PROVIDER_METADATA_EXPIRY_DEFAULT) : c->provider_metadata_refresh_interval));\n\n\t} else {\n\n\t\toidc_util_decode_json_object(r, s_json, &j_provider);\n\n\t\t/* check to see if it is valid metadata */\n\t\tif (oidc_metadata_provider_is_valid(r, c, j_provider, NULL) == FALSE) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"cache corruption detected: invalid metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t*provider = apr_pcalloc(r->pool, sizeof(oidc_provider_t));\n\tmemcpy(*provider, &c->provider, sizeof(oidc_provider_t));\n\n\tif (oidc_metadata_provider_parse(r, c, j_provider, *provider) == FALSE) {\n\t\toidc_error(r, \"could not parse metadata from url: %s\",\n\t\t\t\tc->provider.metadata_url);\n\t\tif (j_provider)\n\t\t\tjson_decref(j_provider);\n\t\treturn FALSE;\n\t}\n\n\tjson_decref(j_provider);\n\n\treturn TRUE;\n}\n\n/*\n * return the oidc_provider_t struct for the specified issuer\n */\nstatic oidc_provider_t *oidc_get_provider_for_issuer(request_rec *r,\n\t\toidc_cfg *c, const char *issuer, apr_byte_t allow_discovery) {\n\n\t/* by default we'll assume that we're dealing with a single statically configured OP */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\treturn NULL;\n\n\t/* unless a metadata directory was configured, so we'll try and get the provider settings from there */\n\tif (c->metadata_dir != NULL) {\n\n\t\t/* try and get metadata from the metadata directory for the OP that sent this response */\n\t\tif ((oidc_metadata_get(r, c, issuer, &provider, allow_discovery)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\n\t\t\t/* don't know nothing about this OP/issuer */\n\t\t\toidc_error(r, \"no provider metadata found for issuer \\\"%s\\\"\",\n\t\t\t\t\tissuer);\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn provider;\n}\n\n/*\n * find out whether the request is a response from an IDP discovery page\n */\nstatic apr_byte_t oidc_is_discovery_response(request_rec *r, oidc_cfg *cfg) {\n\t/*\n\t * prereq: this is a call to the configured redirect_uri, now see if:\n\t * the OIDC_DISC_OP_PARAM is present\n\t */\n\treturn oidc_util_request_has_parameter(r, OIDC_DISC_OP_PARAM)\n\t\t\t|| oidc_util_request_has_parameter(r, OIDC_DISC_USER_PARAM);\n}\n\n/*\n * return the HTTP method being called: only for POST data persistence purposes\n */\nstatic const char *oidc_original_request_method(request_rec *r, oidc_cfg *cfg,\n\t\tapr_byte_t handle_discovery_response) {\n\tconst char *method = OIDC_METHOD_GET;\n\n\tchar *m = NULL;\n\tif ((handle_discovery_response == TRUE)\n\t\t\t&& (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, cfg)))\n\t\t\t&& (oidc_is_discovery_response(r, cfg))) {\n\t\toidc_util_get_request_parameter(r, OIDC_DISC_RM_PARAM, &m);\n\t\tif (m != NULL)\n\t\t\tmethod = apr_pstrdup(r->pool, m);\n\t} else {\n\n\t\t/*\n\t\t * if POST preserve is not enabled for this location, there's no point in preserving\n\t\t * the method either which would result in POSTing empty data on return;\n\t\t * so we revert to legacy behavior\n\t\t */\n\t\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\t\treturn OIDC_METHOD_GET;\n\n\t\tconst char *content_type = oidc_util_hdr_in_content_type_get(r);\n\t\tif ((r->method_number == M_POST) && (apr_strnatcmp(content_type,\n\t\t\t\tOIDC_CONTENT_TYPE_FORM_ENCODED) == 0))\n\t\t\tmethod = OIDC_METHOD_FORM_POST;\n\t}\n\n\toidc_debug(r, \"return: %s\", method);\n\n\treturn method;\n}\n\n/*\n * send an OpenID Connect authorization request to the specified provider preserving POST parameters using HTML5 storage\n */\napr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * restore POST parameters on original_url from HTML5 local storage\n */\nstatic int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}\n\n/*\n * parse state that was sent to us by the issuer\n */\nstatic apr_byte_t oidc_unsolicited_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t **proto_state) {\n\n\tchar *alg = NULL;\n\toidc_debug(r, \"enter: state header=%s\",\n\t\t\toidc_proto_peek_jwt_header(r, state, &alg));\n\n\toidc_jose_error_t err;\n\toidc_jwk_t *jwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, c->provider.client_secret,\n\t\t\toidc_alg2keysize(alg), OIDC_JOSE_ALG_SHA256,\n\t\t\tTRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwt_t *jwt = NULL;\n\tif (oidc_jwt_parse(r->pool, state, &jwt,\n\t\t\toidc_util_merge_symmetric_key(r->pool, c->private_keys, jwk),\n\t\t\t&err) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse JWT from state: invalid unsolicited response: %s\",\n\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\treturn FALSE;\n\t}\n\n\toidc_jwk_destroy(jwk);\n\toidc_debug(r, \"successfully parsed JWT from state\");\n\n\tif (jwt->payload.iss == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" could be retrieved from JWT state, aborting\",\n\t\t\t\tOIDC_CLAIM_ISS);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\toidc_provider_t *provider = oidc_get_provider_for_issuer(r, c,\n\t\t\tjwt->payload.iss, FALSE);\n\tif (provider == NULL) {\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the state JWT, validating optional exp + iat */\n\tif (oidc_proto_validate_jwt(r, jwt, provider->issuer, FALSE, FALSE,\n\t\t\tprovider->idtoken_iat_slack,\n\t\t\tOIDC_TOKEN_BINDING_POLICY_DISABLED) == FALSE) {\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tchar *rfp = NULL;\n\tif (oidc_jose_get_string(r->pool, jwt->payload.value.json, OIDC_CLAIM_RFP,\n\t\t\tTRUE, &rfp, &err) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"no \\\"%s\\\" claim could be retrieved from JWT state, aborting: %s\",\n\t\t\t\tOIDC_CLAIM_RFP, oidc_jose_e2s(r->pool, err));\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tif (apr_strnatcmp(rfp, OIDC_PROTO_ISS) != 0) {\n\t\toidc_error(r, \"\\\"%s\\\" (%s) does not match \\\"%s\\\", aborting\",\n\t\t\t\tOIDC_CLAIM_RFP, rfp, OIDC_PROTO_ISS);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tchar *target_link_uri = NULL;\n\toidc_jose_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_TARGET_LINK_URI,\n\t\t\tFALSE, &target_link_uri, NULL);\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"no \\\"%s\\\" claim could be retrieved from JWT state and no \" OIDCDefaultURL \" is set, aborting\",\n\t\t\t\t\tOIDC_CLAIM_TARGET_LINK_URI);\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn FALSE;\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\tif (c->metadata_dir != NULL) {\n\t\tif ((oidc_metadata_get(r, c, jwt->payload.iss, &provider, FALSE)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\t\t\toidc_error(r, \"no provider metadata found for provider \\\"%s\\\"\",\n\t\t\t\t\tjwt->payload.iss);\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tchar *jti = NULL;\n\toidc_jose_get_string(r->pool, jwt->payload.value.json, OIDC_CLAIM_JTI,\n\t\t\tFALSE, &jti,\n\t\t\tNULL);\n\tif (jti == NULL) {\n\t\tchar *cser = oidc_jwt_serialize(r->pool, jwt, &err);\n\t\tif (cser == NULL)\n\t\t\treturn FALSE;\n\t\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\t\tcser, &jti) == FALSE) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tchar *replay = NULL;\n\toidc_cache_get_jti(r, jti, &replay);\n\tif (replay != NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"the \\\"%s\\\" value (%s) passed in the browser state was found in the cache already; possible replay attack!?\",\n\t\t\t\tOIDC_CLAIM_JTI, jti);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\t/* jti cache duration is the configured replay prevention window for token issuance plus 10 seconds for safety */\n\tapr_time_t jti_cache_duration = apr_time_from_sec(\n\t\t\tprovider->idtoken_iat_slack * 2 + 10);\n\n\t/* store it in the cache for the calculated duration */\n\toidc_cache_set_jti(r, jti, jti, apr_time_now() + jti_cache_duration);\n\n\toidc_debug(r,\n\t\t\t\"jti \\\"%s\\\" validated successfully and is now cached for %\" APR_TIME_T_FMT \" seconds\",\n\t\t\tjti, apr_time_sec(jti_cache_duration));\n\n\tjwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, c->provider.client_secret, 0,\n\t\t\tNULL, TRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwks_uri_t jwks_uri = { provider->jwks_uri,\n\t\t\tprovider->jwks_refresh_interval, provider->ssl_validate_server };\n\tif (oidc_proto_jwt_verify(r, c, jwt, &jwks_uri,\n\t\t\toidc_util_merge_symmetric_key(r->pool, NULL, jwk)) == FALSE) {\n\t\toidc_error(r, \"state JWT could not be validated, aborting\");\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\toidc_jwk_destroy(jwk);\n\toidc_debug(r, \"successfully verified state JWT\");\n\n\t*proto_state = oidc_proto_state_new();\n\toidc_proto_state_set_issuer(*proto_state, jwt->payload.iss);\n\toidc_proto_state_set_original_url(*proto_state, target_link_uri);\n\toidc_proto_state_set_original_method(*proto_state, OIDC_METHOD_GET);\n\toidc_proto_state_set_response_mode(*proto_state, provider->response_mode);\n\toidc_proto_state_set_response_type(*proto_state, provider->response_type);\n\toidc_proto_state_set_timestamp_now(*proto_state);\n\n\toidc_jwt_destroy(jwt);\n\n\treturn TRUE;\n}\n\ntypedef struct oidc_state_cookies_t {\n\tchar *name;\n\tapr_time_t timestamp;\n\tstruct oidc_state_cookies_t *next;\n} oidc_state_cookies_t;\n\nstatic int oidc_delete_oldest_state_cookies(request_rec *r,\n\t\tint number_of_valid_state_cookies, int max_number_of_state_cookies,\n\t\toidc_state_cookies_t *first) {\n\toidc_state_cookies_t *cur = NULL, *prev = NULL, *prev_oldest = NULL,\n\t\t\t*oldest = NULL;\n\twhile (number_of_valid_state_cookies >= max_number_of_state_cookies) {\n\t\toldest = first;\n\t\tprev_oldest = NULL;\n\t\tprev = first;\n\t\tcur = first->next;\n\t\twhile (cur) {\n\t\t\tif ((cur->timestamp < oldest->timestamp)) {\n\t\t\t\toldest = cur;\n\t\t\t\tprev_oldest = prev;\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t\toidc_warn(r,\n\t\t\t\t\"deleting oldest state cookie: %s (time until expiry %\" APR_TIME_T_FMT \" seconds)\",\n\t\t\t\toldest->name, apr_time_sec(oldest->timestamp - apr_time_now()));\n\t\toidc_util_set_cookie(r, oldest->name, \"\", 0, NULL);\n\t\tif (prev_oldest)\n\t\t\tprev_oldest->next = oldest->next;\n\t\telse\n\t\t\tfirst = first->next;\n\t\tnumber_of_valid_state_cookies--;\n\t}\n\treturn number_of_valid_state_cookies;\n}\n\n/*\n * clean state cookies that have expired i.e. for outstanding requests that will never return\n * successfully and return the number of remaining valid cookies/outstanding-requests while\n * doing so\n */\nstatic int oidc_clean_expired_state_cookies(request_rec *r, oidc_cfg *c,\n\t\tconst char *currentCookieName, int delete_oldest) {\n\tint number_of_valid_state_cookies = 0;\n\toidc_state_cookies_t *first = NULL, *last = NULL;\n\tchar *cookie, *tokenizerCtx = NULL;\n\tchar *cookies = apr_pstrdup(r->pool, oidc_util_hdr_in_cookie_get(r));\n\tif (cookies != NULL) {\n\t\tcookie = apr_strtok(cookies, OIDC_STR_SEMI_COLON, &tokenizerCtx);\n\t\twhile (cookie != NULL) {\n\t\t\twhile (*cookie == OIDC_CHAR_SPACE)\n\t\t\t\tcookie++;\n\t\t\tif (strstr(cookie, OIDC_STATE_COOKIE_PREFIX) == cookie) {\n\t\t\t\tchar *cookieName = cookie;\n\t\t\t\twhile (cookie != NULL && *cookie != OIDC_CHAR_EQUAL)\n\t\t\t\t\tcookie++;\n\t\t\t\tif (*cookie == OIDC_CHAR_EQUAL) {\n\t\t\t\t\t*cookie = '\\0';\n\t\t\t\t\tcookie++;\n\t\t\t\t\tif ((currentCookieName == NULL)\n\t\t\t\t\t\t\t|| (apr_strnatcmp(cookieName, currentCookieName)\n\t\t\t\t\t\t\t\t\t!= 0)) {\n\t\t\t\t\t\toidc_proto_state_t *proto_state =\n\t\t\t\t\t\t\t\toidc_proto_state_from_cookie(r, c, cookie);\n\t\t\t\t\t\tif (proto_state != NULL) {\n\t\t\t\t\t\t\tjson_int_t ts = oidc_proto_state_get_timestamp(\n\t\t\t\t\t\t\t\t\tproto_state);\n\t\t\t\t\t\t\tif (apr_time_now() > ts + apr_time_from_sec(c->state_timeout)) {\n\t\t\t\t\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\t\t\t\t\"state (%s) has expired (original_url=%s)\",\n\t\t\t\t\t\t\t\t\t\tcookieName,\n\t\t\t\t\t\t\t\t\t\toidc_proto_state_get_original_url(\n\t\t\t\t\t\t\t\t\t\t\t\tproto_state));\n\t\t\t\t\t\t\t\toidc_util_set_cookie(r, cookieName, \"\", 0,\n\t\t\t\t\t\t\t\t\t\tNULL);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (first == NULL) {\n\t\t\t\t\t\t\t\t\tfirst = apr_pcalloc(r->pool,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(oidc_state_cookies_t));\n\t\t\t\t\t\t\t\t\tlast = first;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlast->next = apr_pcalloc(r->pool,\n\t\t\t\t\t\t\t\t\t\t\tsizeof(oidc_state_cookies_t));\n\t\t\t\t\t\t\t\t\tlast = last->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlast->name = cookieName;\n\t\t\t\t\t\t\t\tlast->timestamp = ts;\n\t\t\t\t\t\t\t\tlast->next = NULL;\n\t\t\t\t\t\t\t\tnumber_of_valid_state_cookies++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcookie = apr_strtok(NULL, OIDC_STR_SEMI_COLON, &tokenizerCtx);\n\t\t}\n\t}\n\n\tif (delete_oldest > 0)\n\t\tnumber_of_valid_state_cookies = oidc_delete_oldest_state_cookies(r,\n\t\t\t\tnumber_of_valid_state_cookies, c->max_number_of_state_cookies,\n\t\t\t\tfirst);\n\n\treturn number_of_valid_state_cookies;\n}\n\n/*\n * restore the state that was maintained between authorization request and response in an encrypted cookie\n */\nstatic apr_byte_t oidc_restore_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t **proto_state) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* clean expired state cookies to avoid pollution */\n\toidc_clean_expired_state_cookies(r, c, cookieName, FALSE);\n\n\t/* get the state cookie value first */\n\tchar *cookieValue = oidc_util_get_cookie(r, cookieName);\n\tif (cookieValue == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" state cookie found\", cookieName);\n\t\treturn oidc_unsolicited_proto_state(r, c, state, proto_state);\n\t}\n\n\t/* clear state cookie because we don't need it anymore */\n\toidc_util_set_cookie(r, cookieName, \"\", 0, NULL);\n\n\t*proto_state = oidc_proto_state_from_cookie(r, c, cookieValue);\n\tif (*proto_state == NULL)\n\t\treturn FALSE;\n\n\tconst char *nonce = oidc_proto_state_get_nonce(*proto_state);\n\n\t/* calculate the hash of the browser fingerprint concatenated with the nonce */\n\tchar *calc = oidc_get_browser_state_hash(r, nonce);\n\t/* compare the calculated hash with the value provided in the authorization response */\n\tif (apr_strnatcmp(calc, state) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"calculated state from cookie does not match state parameter passed back in URL: \\\"%s\\\" != \\\"%s\\\"\",\n\t\t\t\tstate, calc);\n\t\toidc_proto_state_destroy(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\tapr_time_t ts = oidc_proto_state_get_timestamp(*proto_state);\n\n\t/* check that the timestamp is not beyond the valid interval */\n\tif (apr_time_now() > ts + apr_time_from_sec(c->state_timeout)) {\n\t\toidc_error(r, \"state has expired\");\n\t\t/*\n\t\t * note that this overrides redirection to the OIDCDefaultURL as done later...\n\t\t * see: https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/mod_auth_openidc/L4JFBw-XCNU/BWi2Fmk2AwAJ\n\t\t */\n\t\toidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Authentication Response\",\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"This is due to a timeout; please restart your authentication session by re-entering the URL/bookmark you originally wanted to access: %s\",\n\t\t\t\t\t\toidc_proto_state_get_original_url(*proto_state)),\n\t\t\t\t\t\tOK);\n\t\toidc_proto_state_destroy(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\t/* add the state */\n\toidc_proto_state_set_state(*proto_state, state);\n\n\t/* log the restored state object */\n\toidc_debug(r, \"restored state: %s\",\n\t\t\toidc_proto_state_to_string(r, *proto_state));\n\n\t/* we've made it */\n\treturn TRUE;\n}\n\n/*\n * set the state that is maintained between an authorization request and an authorization response\n * in a cookie in the browser that is cryptographically bound to that state\n */\nstatic int oidc_authorization_request_set_cookie(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, oidc_proto_state_t *proto_state) {\n\t/*\n\t * create a cookie consisting of 8 elements:\n\t * random value, original URL, original method, issuer, response_type, response_mod, prompt and timestamp\n\t * encoded as JSON, encrypting the resulting JSON value\n\t */\n\tchar *cookieValue = oidc_proto_state_to_cookie(r, c, proto_state);\n\tif (cookieValue == NULL)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/*\n\t * clean expired state cookies to avoid pollution and optionally\n\t * try to avoid the number of state cookies exceeding a max\n\t */\n\tint number_of_cookies = oidc_clean_expired_state_cookies(r, c, NULL,\n\t\t\toidc_cfg_delete_oldest_state_cookies(c));\n\tint max_number_of_cookies = oidc_cfg_max_number_of_state_cookies(c);\n\tif ((max_number_of_cookies > 0)\n\t\t\t&& (number_of_cookies >= max_number_of_cookies)) {\n\n\t\toidc_warn(r,\n\t\t\t\t\"the number of existing, valid state cookies (%d) has exceeded the limit (%d), no additional authorization request + state cookie can be generated, aborting the request\",\n\t\t\t\tnumber_of_cookies, max_number_of_cookies);\n\t\t/*\n\t\t * TODO: the html_send code below caters for the case that there's a user behind a\n\t\t * browser generating this request, rather than a piece of XHR code; how would an\n\t\t * XHR client handle this?\n\t\t */\n\n\t\t/*\n\t\t * it appears that sending content with a 503 turns the HTTP status code\n\t\t * into a 200 so we'll avoid that for now: the user will see Apache specific\n\t\t * readable text anyway\n\t\t *\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Too Many Outstanding Requests\",\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No authentication request could be generated since there are too many outstanding authentication requests already; you may have to wait up to %d seconds to be able to create a new request\",\n\t\t\t\t\t\tc->state_timeout),\n\t\t\t\t\t\tHTTP_SERVICE_UNAVAILABLE);\n\t\t*/\n\n\t\treturn HTTP_SERVICE_UNAVAILABLE;\n\t}\n\n\t/* assemble the cookie name for the state cookie */\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* set it as a cookie */\n\toidc_util_set_cookie(r, cookieName, cookieValue, -1,\n\t\t\tc->cookie_same_site ? OIDC_COOKIE_EXT_SAME_SITE_LAX : NULL);\n\n\treturn HTTP_OK;\n}\n\n/*\n * get the mod_auth_openidc related context from the (userdata in the) request\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nstatic apr_table_t *oidc_request_state(request_rec *rr) {\n\n\t/* our state is always stored in the main request */\n\trequest_rec *r = (rr->main != NULL) ? rr->main : rr;\n\n\t/* our state is a table, get it */\n\tapr_table_t *state = NULL;\n\tapr_pool_userdata_get((void **) &state, OIDC_USERDATA_KEY, r->pool);\n\n\t/* if it does not exist, we'll create a new table */\n\tif (state == NULL) {\n\t\tstate = apr_table_make(r->pool, 5);\n\t\tapr_pool_userdata_set(state, OIDC_USERDATA_KEY, NULL, r->pool);\n\t}\n\n\t/* return the resulting table, always non-null now */\n\treturn state;\n}\n\n/*\n * set a name/value pair in the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nvoid oidc_request_state_set(request_rec *r, const char *key, const char *value) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* put the name/value pair in that table */\n\tapr_table_set(state, key, value);\n}\n\n/*\n * get a name/value pair from the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nconst char*oidc_request_state_get(request_rec *r, const char *key) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* return the value from the table */\n\treturn apr_table_get(state, key);\n}\n\n/*\n * set the claims from a JSON object (c.q. id_token or user_info response) stored\n * in the session in to HTTP headers passed on to the application\n */\nstatic apr_byte_t oidc_set_app_claims(request_rec *r,\n\t\tconst oidc_cfg * const cfg, oidc_session_t *session,\n\t\tconst char *s_claims) {\n\n\tjson_t *j_claims = NULL;\n\n\t/* decode the string-encoded attributes in to a JSON structure */\n\tif (s_claims != NULL) {\n\t\tif (oidc_util_decode_json_object(r, s_claims, &j_claims) == FALSE)\n\t\t\treturn FALSE;\n\t}\n\n\t/* set the resolved claims a HTTP headers for the application */\n\tif (j_claims != NULL) {\n\t\toidc_util_set_app_infos(r, j_claims, oidc_cfg_claim_prefix(r),\n\t\t\t\tcfg->claim_delimiter, oidc_cfg_dir_pass_info_in_headers(r),\n\t\t\t\toidc_cfg_dir_pass_info_in_envvars(r));\n\n\t\t/* release resources */\n\t\tjson_decref(j_claims);\n\t}\n\n\treturn TRUE;\n}\n\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params, const char *path_scope);\n\n/*\n * log message about max session duration\n */\nstatic void oidc_log_session_expires(request_rec *r, const char *msg,\n\t\tapr_time_t session_expires) {\n\tchar buf[APR_RFC822_DATE_LEN + 1];\n\tapr_rfc822_date(buf, session_expires);\n\toidc_debug(r, \"%s: %s (in %\" APR_TIME_T_FMT \" secs from now)\", msg, buf,\n\t\t\tapr_time_sec(session_expires - apr_time_now()));\n}\n\n/*\n * see if this is a non-browser request\n */\nstatic apr_byte_t oidc_is_xml_http_request(request_rec *r) {\n\n\tif ((oidc_util_hdr_in_x_requested_with_get(r) != NULL)\n\t\t\t&& (apr_strnatcasecmp(oidc_util_hdr_in_x_requested_with_get(r),\n\t\t\t\t\tOIDC_HTTP_HDR_VAL_XML_HTTP_REQUEST) == 0))\n\t\treturn TRUE;\n\n\tif ((oidc_util_hdr_in_accept_contains(r, OIDC_CONTENT_TYPE_TEXT_HTML)\n\t\t\t== FALSE) && (oidc_util_hdr_in_accept_contains(r,\n\t\t\t\t\tOIDC_CONTENT_TYPE_APP_XHTML_XML) == FALSE)\n\t\t\t\t\t&& (oidc_util_hdr_in_accept_contains(r,\n\t\t\t\t\t\t\tOIDC_CONTENT_TYPE_ANY) == FALSE))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\n/*\n * find out which action we need to take when encountering an unauthenticated request\n */\nstatic int oidc_handle_unauthenticated_user(request_rec *r, oidc_cfg *c) {\n\n\t/* see if we've configured OIDCUnAuthAction for this path */\n\tswitch (oidc_dir_cfg_unauth_action(r)) {\n\tcase OIDC_UNAUTH_RETURN410:\n\t\treturn HTTP_GONE;\n\tcase OIDC_UNAUTH_RETURN401:\n\t\treturn HTTP_UNAUTHORIZED;\n\tcase OIDC_UNAUTH_PASS:\n\t\tr->user = \"\";\n\n\t\t/*\n\t\t * we're not going to pass information about an authenticated user to the application,\n\t\t * but we do need to scrub the headers that mod_auth_openidc would set for security reasons\n\t\t */\n\t\toidc_scrub_headers(r);\n\n\t\treturn OK;\n\n\tcase OIDC_UNAUTH_AUTHENTICATE:\n\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/*\n\t * else: no session (regardless of whether it is main or sub-request),\n\t * and we need to authenticate the user\n\t */\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r),\n\t\t\toidc_dir_cfg_path_scope(r));\n}\n\n/*\n * check if maximum session duration was exceeded\n */\nstatic int oidc_check_max_session_duration(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\t/* get the session expiry from the session data */\n\tapr_time_t session_expires = oidc_session_get_session_expires(r, session);\n\n\t/* check the expire timestamp against the current time */\n\tif (apr_time_now() > session_expires) {\n\t\toidc_warn(r, \"maximum session duration exceeded for user: %s\",\n\t\t\t\tsession->remote_user);\n\t\toidc_session_kill(r, session);\n\t\treturn oidc_handle_unauthenticated_user(r, cfg);\n\t}\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\n\treturn OK;\n}\n\n/*\n * validate received session cookie against the domain it was issued for:\n *\n * this handles the case where the cache configured is a the same single memcache, Redis, or file\n * backend for different (virtual) hosts, or a client-side cookie protected with the same secret\n *\n * it also handles the case that a cookie is unexpectedly shared across multiple hosts in\n * name-based virtual hosting even though the OP(s) would be the same\n */\nstatic apr_byte_t oidc_check_cookie_domain(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tconst char *c_cookie_domain =\n\t\t\tcfg->cookie_domain ?\n\t\t\t\t\tcfg->cookie_domain : oidc_get_current_url_host(r);\n\tconst char *s_cookie_domain = oidc_session_get_cookie_domain(r, session);\n\tif ((s_cookie_domain == NULL)\n\t\t\t|| (apr_strnatcmp(c_cookie_domain, s_cookie_domain) != 0)) {\n\t\toidc_warn(r,\n\t\t\t\t\"aborting: detected attempt to play cookie against a different domain/host than issued for! (issued=%s, current=%s)\",\n\t\t\t\ts_cookie_domain, c_cookie_domain);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * get a handle to the provider configuration via the \"issuer\" stored in the session\n */\napr_byte_t oidc_get_provider_from_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t **provider) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the issuer value from the session state */\n\tconst char *issuer = oidc_session_get_issuer(r, session);\n\tif (issuer == NULL) {\n\t\toidc_error(r, \"session corrupted: no issuer found in session\");\n\t\treturn FALSE;\n\t}\n\n\t/* get the provider info associated with the issuer value */\n\toidc_provider_t *p = oidc_get_provider_for_issuer(r, c, issuer, FALSE);\n\tif (p == NULL) {\n\t\toidc_error(r, \"session corrupted: no provider found for issuer: %s\",\n\t\t\t\tissuer);\n\t\treturn FALSE;\n\t}\n\n\t*provider = p;\n\n\treturn TRUE;\n}\n\n/*\n * store claims resolved from the userinfo endpoint in the session\n */\nstatic void oidc_store_userinfo_claims(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider, const char *claims,\n\t\tconst char *userinfo_jwt) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* see if we've resolved any claims */\n\tif (claims != NULL) {\n\t\t/*\n\t\t * Successfully decoded a set claims from the response so we can store them\n\t\t * (well actually the stringified representation in the response)\n\t\t * in the session context safely now\n\t\t */\n\t\toidc_session_set_userinfo_claims(r, session, claims);\n\n\t\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* this will also clear the entry if a JWT was not returned at this point */\n\t\t\toidc_session_set_userinfo_jwt(r, session, userinfo_jwt);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * clear the existing claims because we could not refresh them\n\t\t */\n\t\toidc_session_set_userinfo_claims(r, session, NULL);\n\n\t\toidc_session_set_userinfo_jwt(r, session, NULL);\n\t}\n\n\t/* store the last refresh time if we've configured a userinfo refresh interval */\n\tif (provider->userinfo_refresh_interval > 0)\n\t\toidc_session_reset_userinfo_last_refresh(r, session);\n}\n\n/*\n * execute refresh token grant to refresh the existing access token\n */\nstatic apr_byte_t oidc_refresh_access_token(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tchar **new_access_token) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the refresh token that was stored in the session */\n\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\tif (refresh_token == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"refresh token routine called but no refresh_token found in the session\");\n\t\treturn FALSE;\n\t}\n\n\t/* elements returned in the refresh response */\n\tchar *s_id_token = NULL;\n\tint expires_in = -1;\n\tchar *s_token_type = NULL;\n\tchar *s_access_token = NULL;\n\tchar *s_refresh_token = NULL;\n\n\t/* refresh the tokens by calling the token endpoint */\n\tif (oidc_proto_refresh_request(r, c, provider, refresh_token, &s_id_token,\n\t\t\t&s_access_token, &s_token_type, &expires_in,\n\t\t\t&s_refresh_token) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\treturn FALSE;\n\t}\n\n\t/* store the new access_token in the session and discard the old one */\n\toidc_session_set_access_token(r, session, s_access_token);\n\toidc_session_set_access_token_expires(r, session, expires_in);\n\n\t/* reset the access token refresh timestamp */\n\toidc_session_reset_access_token_last_refresh(r, session);\n\n\t/* see if we need to return it as a parameter */\n\tif (new_access_token != NULL)\n\t\t*new_access_token = s_access_token;\n\n\t/* if we have a new refresh token (rolling refresh), store it in the session and overwrite the old one */\n\tif (s_refresh_token != NULL)\n\t\toidc_session_set_refresh_token(r, session, s_refresh_token);\n\n\treturn TRUE;\n}\n\n/*\n * retrieve claims from the userinfo endpoint and return the stringified response\n */\nstatic const char *oidc_retrieve_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *c, oidc_provider_t *provider, const char *access_token,\n\t\toidc_session_t *session, char *id_token_sub, char **userinfo_jwt) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *result = NULL;\n\tchar *refreshed_access_token = NULL;\n\n\t/* see if a userinfo endpoint is set, otherwise there's nothing to do for us */\n\tif (provider->userinfo_endpoint_url == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because userinfo_endpoint is not set\");\n\t\treturn NULL;\n\t}\n\n\t/* see if there's an access token, otherwise we can't call the userinfo endpoint at all */\n\tif (access_token == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because access_token is not provided\");\n\t\treturn NULL;\n\t}\n\n\tif ((id_token_sub == NULL) && (session != NULL)) {\n\n\t\t// when refreshing claims from the userinfo endpoint\n\t\tjson_t *id_token_claims = oidc_session_get_idtoken_claims_json(r,\n\t\t\t\tsession);\n\t\tif (id_token_claims == NULL) {\n\t\t\toidc_error(r, \"no id_token_claims found in session\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\toidc_jose_get_string(r->pool, id_token_claims, OIDC_CLAIM_SUB, FALSE,\n\t\t\t\t&id_token_sub, NULL);\n\t}\n\n\t// TODO: return code should indicate whether the token expired or some other error occurred\n\t// TODO: long-term: session storage should be JSON (with explicit types and less conversion, using standard routines)\n\n\t/* try to get claims from the userinfo endpoint using the provided access token */\n\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub, access_token,\n\t\t\t&result, userinfo_jwt) == FALSE) {\n\n\t\t/* see if we have an existing session and we are refreshing the user info claims */\n\t\tif (session != NULL) {\n\n\t\t\t/* first call to user info endpoint failed, but the access token may have just expired, so refresh it */\n\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t&refreshed_access_token) == TRUE) {\n\n\t\t\t\t/* try again with the new access token */\n\t\t\t\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub,\n\t\t\t\t\t\trefreshed_access_token, &result, userinfo_jwt) == FALSE) {\n\n\t\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\t\"resolving user info claims with the refreshed access token failed, nothing will be stored in the session\");\n\t\t\t\t\tresult = NULL;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"refreshing access token failed, claims will not be retrieved/refreshed from the userinfo endpoint\");\n\t\t\t\tresult = NULL;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toidc_error(r,\n\t\t\t\t\t\"resolving user info claims with the existing/provided access token failed, nothing will be stored in the session\");\n\t\t\tresult = NULL;\n\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*\n * get (new) claims from the userinfo endpoint\n */\nstatic apr_byte_t oidc_refresh_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\tconst char *claims = NULL;\n\tconst char *access_token = NULL;\n\tchar *userinfo_jwt = NULL;\n\n\t/* get the current provider info */\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\t/* see if we can do anything here, i.e. we have a userinfo endpoint and a refresh interval is configured */\n\tapr_time_t interval = apr_time_from_sec(\n\t\t\tprovider->userinfo_refresh_interval);\n\n\toidc_debug(r, \"userinfo_endpoint=%s, interval=%d\",\n\t\t\tprovider->userinfo_endpoint_url,\n\t\t\tprovider->userinfo_refresh_interval);\n\n\tif ((provider->userinfo_endpoint_url != NULL) && (interval > 0)) {\n\n\t\t/* get the last refresh timestamp from the session info */\n\t\tapr_time_t last_refresh = oidc_session_get_userinfo_last_refresh(r,\n\t\t\t\tsession);\n\n\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\tapr_time_sec(last_refresh + interval - apr_time_now()));\n\n\t\t/* see if we need to refresh again */\n\t\tif (last_refresh + interval < apr_time_now()) {\n\n\t\t\t/* get the current access token */\n\t\t\taccess_token = oidc_session_get_access_token(r, session);\n\n\t\t\t/* retrieve the current claims */\n\t\t\tclaims = oidc_retrieve_claims_from_userinfo_endpoint(r, cfg,\n\t\t\t\t\tprovider, access_token, session, NULL, &userinfo_jwt);\n\n\t\t\t/* store claims resolved from userinfo endpoint */\n\t\t\toidc_store_userinfo_claims(r, cfg, session, provider, claims,\n\t\t\t\t\tuserinfo_jwt);\n\n\t\t\t/* indicated something changed */\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*\n * copy the claims and id_token from the session to the request state and optionally return them\n */\nstatic void oidc_copy_tokens_to_request_state(request_rec *r,\n\t\toidc_session_t *session, const char **s_id_token, const char **s_claims) {\n\n\tconst char *id_token = oidc_session_get_idtoken_claims(r, session);\n\tconst char *claims = oidc_session_get_userinfo_claims(r, session);\n\n\toidc_debug(r, \"id_token=%s claims=%s\", id_token, claims);\n\n\tif (id_token != NULL) {\n\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_IDTOKEN, id_token);\n\t\tif (s_id_token != NULL)\n\t\t\t*s_id_token = id_token;\n\t}\n\n\tif (claims != NULL) {\n\t\toidc_request_state_set(r, OIDC_REQUEST_STATE_KEY_CLAIMS, claims);\n\t\tif (s_claims != NULL)\n\t\t\t*s_claims = claims;\n\t}\n}\n\n/*\n * pass refresh_token, access_token and access_token_expires as headers/environment variables to the application\n */\nstatic apr_byte_t oidc_session_pass_tokens_and_save(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session, apr_byte_t needs_save) {\n\n\tapr_byte_t pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tapr_byte_t pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\t/* set the refresh_token in the app headers/variables, if enabled for this location/directory */\n\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\tif ((oidc_cfg_dir_pass_refresh_token(r) != 0) && (refresh_token != NULL)) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_REFRESH_TOKEN, refresh_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the access_token in the app headers/variables */\n\tconst char *access_token = oidc_session_get_access_token(r, session);\n\tif (access_token != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN, access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the expiry timestamp in the app headers/variables */\n\tconst char *access_token_expires = oidc_session_get_access_token_expires(r,\n\t\t\tsession);\n\tif (access_token_expires != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ACCESS_TOKEN_EXP,\n\t\t\t\taccess_token_expires,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/*\n\t * reset the session inactivity timer\n\t * but only do this once per 10% of the inactivity timeout interval (with a max to 60 seconds)\n\t * for performance reasons\n\t *\n\t * now there's a small chance that the session ends 10% (or a minute) earlier than configured/expected\n\t * cq. when there's a request after a recent save (so no update) and then no activity happens until\n\t * a request comes in just before the session should expire\n\t * (\"recent\" and \"just before\" refer to 10%-with-a-max-of-60-seconds of the inactivity interval after\n\t * the start/last-update and before the expiry of the session respectively)\n\t *\n\t * this is be deemed acceptable here because of performance gain\n\t */\n\tapr_time_t interval = apr_time_from_sec(cfg->session_inactivity_timeout);\n\tapr_time_t now = apr_time_now();\n\tapr_time_t slack = interval / 10;\n\tif (slack > apr_time_from_sec(60))\n\t\tslack = apr_time_from_sec(60);\n\tif (session->expiry - now < interval - slack) {\n\t\tsession->expiry = now + interval;\n\t\tneeds_save = TRUE;\n\t}\n\n\t/* log message about session expiry */\n\toidc_log_session_expires(r, \"session inactivity timeout\", session->expiry);\n\n\t/* check if something was updated in the session and we need to save it again */\n\tif (needs_save)\n\t\tif (oidc_session_save(r, session, FALSE) == FALSE)\n\t\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic apr_byte_t oidc_refresh_access_token_before_expiry(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session, int ttl_minimum, int logout_on_error) {\n\n\tconst char *s_access_token_expires = NULL;\n\tapr_time_t t_expires = -1;\n\toidc_provider_t *provider = NULL;\n\n\toidc_debug(r, \"ttl_minimum=%d\", ttl_minimum);\n\n\tif (ttl_minimum < 0)\n\t\treturn FALSE;\n\n\ts_access_token_expires = oidc_session_get_access_token_expires(r, session);\n\tif (s_access_token_expires == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"no access token expires_in stored in the session (i.e. returned from in the authorization response), so cannot refresh the access token based on TTL requirement\");\n\t\treturn FALSE;\n\t}\n\n\tif (oidc_session_get_refresh_token(r, session) == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"no refresh token stored in the session, so cannot refresh the access token based on TTL requirement\");\n\t\treturn FALSE;\n\t}\n\n\tif (sscanf(s_access_token_expires, \"%\" APR_TIME_T_FMT, &t_expires) != 1) {\n\t\toidc_error(r, \"could not parse s_access_token_expires %s\",\n\t\t\t\ts_access_token_expires);\n\t\treturn FALSE;\n\t}\n\n\tt_expires = apr_time_from_sec(t_expires - ttl_minimum);\n\n\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\tapr_time_sec(t_expires - apr_time_now()));\n\n\tif (t_expires > apr_time_now())\n\t\treturn FALSE;\n\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\tif (oidc_refresh_access_token(r, cfg, session, provider,\n\t\t\tNULL) == FALSE) {\n\t\toidc_warn(r, \"access_token could not be refreshed, logout=%d\", logout_on_error & OIDC_LOGOUT_ON_ERROR_REFRESH);\n\t\tif (logout_on_error & OIDC_LOGOUT_ON_ERROR_REFRESH)\n\t\t\treturn ERROR;\n\t\telse\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * handle the case where we have identified an existing authentication session for a user\n */\nstatic int oidc_handle_existing_session(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* track if the session needs to be updated/saved into the cache */\n\tapr_byte_t needs_save = FALSE;\n\n\t/* set the user in the main request for further (incl. sub-request) processing */\n\tr->user = apr_pstrdup(r->pool, session->remote_user);\n\toidc_debug(r, \"set remote_user to \\\"%s\\\"\", r->user);\n\n\t/* get the header name in which the remote user name needs to be passed */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tapr_byte_t pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tapr_byte_t pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\t/* verify current cookie domain against issued cookie domain */\n\tif (oidc_check_cookie_domain(r, cfg, session) == FALSE)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* check if the maximum session duration was exceeded */\n\tint rc = oidc_check_max_session_duration(r, cfg, session);\n\tif (rc != OK)\n\t\treturn rc;\n\n\t/* if needed, refresh the access token */\n\tneeds_save = oidc_refresh_access_token_before_expiry(r, cfg, session,\n\t\t\toidc_cfg_dir_refresh_access_token_before_expiry(r),\n\t\t\toidc_cfg_dir_logout_on_error_refresh(r));\n\tif (needs_save == ERROR)\n\t\treturn oidc_handle_logout_request(r, cfg, session, cfg->default_slo_url);\n\n\t/* if needed, refresh claims from the user info endpoint */\n\tif (oidc_refresh_claims_from_userinfo_endpoint(r, cfg, session) == TRUE)\n\t\tneeds_save = TRUE;\n\n\t/*\n\t * we're going to pass the information that we have to the application,\n\t * but first we need to scrub the headers that we're going to use for security reasons\n\t */\n\toidc_scrub_headers(r);\n\n\t/* set the user authentication HTTP header if set and required */\n\tif ((r->user != NULL) && (authn_header != NULL))\n\t\toidc_util_hdr_in_set(r, authn_header, r->user);\n\n\tconst char *s_claims = NULL;\n\tconst char *s_id_token = NULL;\n\n\t/* copy id_token and claims from session to request state and obtain their values */\n\toidc_copy_tokens_to_request_state(r, session, &s_id_token, &s_claims);\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_CLAIMS)) {\n\t\t/* set the userinfo claims in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_claims) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JSON_OBJECT)) {\n\t\t/* pass the userinfo JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JSON, s_claims,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\tif ((cfg->pass_userinfo_as & OIDC_PASS_USERINFO_AS_JWT)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\tconst char *s_userinfo_jwt = oidc_session_get_userinfo_jwt(r,\n\t\t\t\t\tsession);\n\t\t\tif (s_userinfo_jwt != NULL) {\n\t\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\t\toidc_util_set_app_info(r, OIDC_APP_INFO_USERINFO_JWT,\n\t\t\t\t\t\ts_userinfo_jwt,\n\t\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t\t\t} else {\n\t\t\t\toidc_debug(r,\n\t\t\t\t\t\t\"configured to pass userinfo in a JWT, but no such JWT was found in the session (probably no such JWT was returned from the userinfo endpoint)\");\n\t\t\t}\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing a userinfo JWT; use \\\"\" OIDCSessionType \" server-cache\\\" for that\");\n\t\t}\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_CLAIMS)) {\n\t\t/* set the id_token in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_id_token) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_PAYLOAD)) {\n\t\t/* pass the id_token JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN_PAYLOAD, s_id_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_SERIALIZED)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\tconst char *s_id_token = oidc_session_get_idtoken(r, session);\n\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\toidc_util_set_app_info(r, OIDC_APP_INFO_ID_TOKEN, s_id_token,\n\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing the id_token; use \\\"\" OIDCSessionType \" server-cache\\\" for that\");\n\t\t}\n\t}\n\n\t/* pass the at, rt and at expiry to the application, possibly update the session expiry and save the session */\n\tif (oidc_session_pass_tokens_and_save(r, cfg, session, needs_save) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/* return \"user authenticated\" status */\n\treturn OK;\n}\n\n/*\n * helper function for basic/implicit client flows upon receiving an authorization response:\n * check that it matches the state stored in the browser and return the variables associated\n * with the state, such as original_url and OP oidc_provider_t pointer.\n */\nstatic apr_byte_t oidc_authorization_response_match_state(request_rec *r,\n\t\toidc_cfg *c, const char *state, struct oidc_provider_t **provider,\n\t\toidc_proto_state_t **proto_state) {\n\n\toidc_debug(r, \"enter (state=%s)\", state);\n\n\tif ((state == NULL) || (apr_strnatcmp(state, \"\") == 0)) {\n\t\toidc_error(r, \"state parameter is not set\");\n\t\treturn FALSE;\n\t}\n\n\t/* check the state parameter against what we stored in a cookie */\n\tif (oidc_restore_proto_state(r, c, state, proto_state) == FALSE) {\n\t\toidc_error(r, \"unable to restore state\");\n\t\treturn FALSE;\n\t}\n\n\t*provider = oidc_get_provider_for_issuer(r, c,\n\t\t\toidc_proto_state_get_issuer(*proto_state), FALSE);\n\n\treturn (*provider != NULL);\n}\n\n/*\n * redirect the browser to the session logout endpoint\n */\nstatic int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}\n\n/*\n * handle an error returned by the OP\n */\nstatic int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,\n\t\toidc_proto_state_t *proto_state, const char *error,\n\t\tconst char *error_description) {\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\tif (prompt != NULL)\n\t\tprompt = apr_pstrdup(r->pool, prompt);\n\toidc_proto_state_destroy(proto_state);\n\tif ((prompt != NULL)\n\t\t\t&& (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\tapr_psprintf(r->pool, \"OpenID Connect Provider error: %s\", error),\n\t\t\terror_description, OK);\n}\n\n/*\n * get the r->user for this request based on the configuration for OIDC/OAuth\n */\napr_byte_t oidc_get_remote_user(request_rec *r, const char *claim_name,\n\t\tconst char *reg_exp, const char *replace, json_t *json,\n\t\tchar **request_user) {\n\n\t/* get the claim value from the JSON object */\n\tjson_t *username = json_object_get(json, claim_name);\n\tif ((username == NULL) || (!json_is_string(username))) {\n\t\toidc_warn(r, \"JSON object did not contain a \\\"%s\\\" string\", claim_name);\n\t\treturn FALSE;\n\t}\n\n\t*request_user = apr_pstrdup(r->pool, json_string_value(username));\n\n\tif (reg_exp != NULL) {\n\n\t\tchar *error_str = NULL;\n\n\t\tif (replace == NULL) {\n\n\t\t\tif (oidc_util_regexp_first_match(r->pool, *request_user, reg_exp,\n\t\t\t\t\trequest_user, &error_str) == FALSE) {\n\t\t\t\toidc_error(r, \"oidc_util_regexp_first_match failed: %s\",\n\t\t\t\t\t\terror_str);\n\t\t\t\t*request_user = NULL;\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t} else if (oidc_util_regexp_substitute(r->pool, *request_user, reg_exp,\n\t\t\t\treplace, request_user, &error_str) == FALSE) {\n\n\t\t\toidc_error(r, \"oidc_util_regexp_substitute failed: %s\", error_str);\n\t\t\t*request_user = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * set the unique user identifier that will be propagated in the Apache r->user and REMOTE_USER variables\n */\nstatic apr_byte_t oidc_set_request_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, oidc_jwt_t *jwt, const char *s_claims) {\n\n\tchar *issuer = provider->issuer;\n\tchar *claim_name = apr_pstrdup(r->pool, c->remote_user_claim.claim_name);\n\tint n = strlen(claim_name);\n\tapr_byte_t post_fix_with_issuer = (claim_name[n - 1] == OIDC_CHAR_AT);\n\tif (post_fix_with_issuer == TRUE) {\n\t\tclaim_name[n - 1] = '\\0';\n\t\tissuer =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\t}\n\n\t/* extract the username claim (default: \"sub\") from the id_token payload or user claims */\n\tapr_byte_t rc = FALSE;\n\tchar *remote_user = NULL;\n\tjson_t *claims = NULL;\n\toidc_util_decode_json_object(r, s_claims, &claims);\n\tif (claims == NULL) {\n\t\trc = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,\n\t\t\t\tc->remote_user_claim.replace, jwt->payload.value.json,\n\t\t\t\t&remote_user);\n\t} else {\n\t\toidc_util_json_merge(r, jwt->payload.value.json, claims);\n\t\trc = oidc_get_remote_user(r, claim_name, c->remote_user_claim.reg_exp,\n\t\t\t\tc->remote_user_claim.replace, claims, &remote_user);\n\t\tjson_decref(claims);\n\t}\n\n\tif ((rc == FALSE) || (remote_user == NULL)) {\n\t\toidc_error(r,\n\t\t\t\t\"\" OIDCRemoteUserClaim \"is set to \\\"%s\\\", but could not set the remote user based on the requested claim \\\"%s\\\" and the available claims for the user\",\n\t\t\t\tc->remote_user_claim.claim_name, claim_name);\n\t\treturn FALSE;\n\t}\n\n\tif (post_fix_with_issuer == TRUE)\n\t\tremote_user = apr_psprintf(r->pool, \"%s%s%s\", remote_user, OIDC_STR_AT,\n\t\t\t\tissuer);\n\n\tr->user = apr_pstrdup(r->pool, remote_user);\n\n\toidc_debug(r, \"set remote_user to \\\"%s\\\" based on claim: \\\"%s\\\"%s\", r->user,\n\t\t\tc->remote_user_claim.claim_name,\n\t\t\tc->remote_user_claim.reg_exp ?\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\" and expression: \\\"%s\\\" and replace string: \\\"%s\\\"\",\n\t\t\t\t\t\t\tc->remote_user_claim.reg_exp,\n\t\t\t\t\t\t\tc->remote_user_claim.replace) :\n\t\t\t\t\t\t\t\"\");\n\n\treturn TRUE;\n}\n\nstatic char *oidc_make_sid_iss_unique(request_rec *r, const char *sid,\n\t\tconst char *issuer) {\n\treturn apr_psprintf(r->pool, \"%s@%s\", sid, issuer);\n}\n\n/*\n * store resolved information in the session\n */\nstatic apr_byte_t oidc_save_in_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tconst char *remoteUser, const char *id_token, oidc_jwt_t *id_token_jwt,\n\t\tconst char *claims, const char *access_token, const int expires_in,\n\t\tconst char *refresh_token, const char *session_state, const char *state,\n\t\tconst char *original_url, const char *userinfo_jwt) {\n\n\t/* store the user in the session */\n\tsession->remote_user = remoteUser;\n\n\t/* set the session expiry to the inactivity timeout */\n\tsession->expiry =\n\t\t\tapr_time_now() + apr_time_from_sec(c->session_inactivity_timeout);\n\n\t/* store the claims payload in the id_token for later reference */\n\toidc_session_set_idtoken_claims(r, session,\n\t\t\tid_token_jwt->payload.value.str);\n\n\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t/* store the compact serialized representation of the id_token for later reference  */\n\t\toidc_session_set_idtoken(r, session, id_token);\n\t}\n\n\t/* store the issuer in the session (at least needed for session mgmt and token refresh */\n\toidc_session_set_issuer(r, session, provider->issuer);\n\n\t/* store the state and original URL in the session for handling browser-back more elegantly */\n\toidc_session_set_request_state(r, session, state);\n\toidc_session_set_original_url(r, session, original_url);\n\n\tif ((session_state != NULL) && (provider->check_session_iframe != NULL)) {\n\t\t/* store the session state and required parameters session management  */\n\t\toidc_session_set_session_state(r, session, session_state);\n\t\toidc_debug(r,\n\t\t\t\t\"session management enabled: stored session_state (%s), check_session_iframe (%s) and client_id (%s) in the session\",\n\t\t\t\tsession_state, provider->check_session_iframe,\n\t\t\t\tprovider->client_id);\n\t} else if (provider->check_session_iframe == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: \\\"check_session_iframe\\\" is not set in provider configuration\");\n\t} else {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: no \\\"session_state\\\" value is provided in the authentication response even though \\\"check_session_iframe\\\" (%s) is set in the provider configuration\",\n\t\t\t\tprovider->check_session_iframe);\n\t}\n\n\t/* store claims resolved from userinfo endpoint */\n\toidc_store_userinfo_claims(r, c, session, provider, claims, userinfo_jwt);\n\n\t/* see if we have an access_token */\n\tif (access_token != NULL) {\n\t\t/* store the access_token in the session context */\n\t\toidc_session_set_access_token(r, session, access_token);\n\t\t/* store the associated expires_in value */\n\t\toidc_session_set_access_token_expires(r, session, expires_in);\n\t\t/* reset the access token refresh timestamp */\n\t\toidc_session_reset_access_token_last_refresh(r, session);\n\t}\n\n\t/* see if we have a refresh_token */\n\tif (refresh_token != NULL) {\n\t\t/* store the refresh_token in the session context */\n\t\toidc_session_set_refresh_token(r, session, refresh_token);\n\t}\n\n\t/* store max session duration in the session as a hard cut-off expiry timestamp */\n\tapr_time_t session_expires =\n\t\t\t(provider->session_max_duration == 0) ?\n\t\t\t\t\tapr_time_from_sec(id_token_jwt->payload.exp) :\n\t\t\t\t\t(apr_time_now()\n\t\t\t\t\t\t\t+ apr_time_from_sec(provider->session_max_duration));\n\toidc_session_set_session_expires(r, session, session_expires);\n\n\toidc_debug(r,\n\t\t\t\"provider->session_max_duration = %d, session_expires=%\" APR_TIME_T_FMT,\n\t\t\tprovider->session_max_duration, session_expires);\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\n\t/* store the domain for which this session is valid */\n\toidc_session_set_cookie_domain(r, session,\n\t\t\tc->cookie_domain ? c->cookie_domain : oidc_get_current_url_host(r));\n\n\tchar *sid = NULL;\n\toidc_debug(r, \"provider->backchannel_logout_supported=%d\",\n\t\t\tprovider->backchannel_logout_supported);\n\tif (provider->backchannel_logout_supported > 0) {\n\t\toidc_jose_get_string(r->pool, id_token_jwt->payload.value.json,\n\t\t\t\tOIDC_CLAIM_SID, FALSE, &sid, NULL);\n\t\tif (sid == NULL)\n\t\t\tsid = id_token_jwt->payload.sub;\n\t\tsession->sid = oidc_make_sid_iss_unique(r, sid, provider->issuer);\n\t}\n\n\t/* store the session */\n\treturn oidc_session_save(r, session, TRUE);\n}\n\n/*\n * parse the expiry for the access token\n */\nstatic int oidc_parse_expires_in(request_rec *r, const char *expires_in) {\n\tif (expires_in != NULL) {\n\t\tchar *ptr = NULL;\n\t\tlong number = strtol(expires_in, &ptr, 10);\n\t\tif (number <= 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"could not convert \\\"expires_in\\\" value (%s) to a number\",\n\t\t\t\t\texpires_in);\n\t\t\treturn -1;\n\t\t}\n\t\treturn number;\n\t}\n\treturn -1;\n}\n\n/*\n * handle the different flows (hybrid, implicit, Authorization Code)\n */\nstatic apr_byte_t oidc_handle_flows(request_rec *r, oidc_cfg *c,\n\t\toidc_proto_state_t *proto_state, oidc_provider_t *provider,\n\t\tapr_table_t *params, const char *response_mode, oidc_jwt_t **jwt) {\n\n\tapr_byte_t rc = FALSE;\n\n\tconst char *requested_response_type = oidc_proto_state_get_response_type(\n\t\t\tproto_state);\n\n\t/* handle the requested response type/mode */\n\tif (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN_TOKEN)) {\n\t\trc = oidc_proto_authorization_response_code_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_IDTOKEN)) {\n\t\trc = oidc_proto_authorization_response_code_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE_TOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_code_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_CODE)) {\n\t\trc = oidc_proto_handle_authorization_response_code(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_IDTOKEN_TOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\tOIDC_PROTO_RESPONSE_TYPE_IDTOKEN)) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else {\n\t\toidc_error(r, \"unsupported response type: \\\"%s\\\"\",\n\t\t\t\trequested_response_type);\n\t}\n\n\tif ((rc == FALSE) && (*jwt != NULL)) {\n\t\toidc_jwt_destroy(*jwt);\n\t\t*jwt = NULL;\n\t}\n\n\treturn rc;\n}\n\n/* handle the browser back on an authorization response */\nstatic apr_byte_t oidc_handle_browser_back(request_rec *r, const char *r_state,\n\t\toidc_session_t *session) {\n\n\t/*  see if we have an existing session and browser-back was used */\n\tconst char *s_state = NULL, *o_url = NULL;\n\n\tif (session->remote_user != NULL) {\n\n\t\ts_state = oidc_session_get_request_state(r, session);\n\t\to_url = oidc_session_get_original_url(r, session);\n\n\t\tif ((r_state != NULL) && (s_state != NULL)\n\t\t\t\t&& (apr_strnatcmp(r_state, s_state) == 0)) {\n\n\t\t\t/* log the browser back event detection */\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"browser back detected, redirecting to original URL: %s\",\n\t\t\t\t\to_url);\n\n\t\t\t/* go back to the URL that he originally tried to access */\n\t\t\toidc_util_hdr_out_location_set(r, o_url);\n\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\n/*\n * complete the handling of an authorization response by obtaining, parsing and verifying the\n * id_token and storing the authenticated user state in the session\n */\nstatic int oidc_handle_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, apr_table_t *params, const char *response_mode) {\n\n\toidc_debug(r, \"enter, response_mode=%s\", response_mode);\n\n\toidc_provider_t *provider = NULL;\n\toidc_proto_state_t *proto_state = NULL;\n\toidc_jwt_t *jwt = NULL;\n\n\t/* see if this response came from a browser-back event */\n\tif (oidc_handle_browser_back(r, apr_table_get(params, OIDC_PROTO_STATE),\n\t\t\tsession) == TRUE)\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\n\t/* match the returned state parameter against the state stored in the browser */\n\tif (oidc_authorization_response_match_state(r, c,\n\t\t\tapr_table_get(params, OIDC_PROTO_STATE), &provider,\n\t\t\t&proto_state) == FALSE) {\n\t\tif (c->default_sso_url != NULL) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"invalid authorization response state; a default SSO URL is set, sending the user there: %s\",\n\t\t\t\t\tc->default_sso_url);\n\t\t\toidc_util_hdr_out_location_set(r, c->default_sso_url);\n\t\t\treturn HTTP_MOVED_TEMPORARILY;\n\t\t}\n\t\toidc_error(r,\n\t\t\t\t\"invalid authorization response state and no default SSO URL is set, sending an error...\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if the response is an error response */\n\tif (apr_table_get(params, OIDC_PROTO_ERROR) != NULL)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ERROR),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ERROR_DESCRIPTION));\n\n\t/* handle the code, implicit or hybrid flow */\n\tif (oidc_handle_flows(r, c, proto_state, provider, params, response_mode,\n\t\t\t&jwt) == FALSE)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Error in handling response type.\", NULL);\n\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no id_token was provided\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"No id_token was provided.\", NULL);\n\t}\n\n\tint expires_in = oidc_parse_expires_in(r,\n\t\t\tapr_table_get(params, OIDC_PROTO_EXPIRES_IN));\n\tchar *userinfo_jwt = NULL;\n\n\t/*\n\t * optionally resolve additional claims against the userinfo endpoint\n\t * parsed claims are not actually used here but need to be parsed anyway for error checking purposes\n\t */\n\tconst char *claims = oidc_retrieve_claims_from_userinfo_endpoint(r, c,\n\t\t\tprovider, apr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), NULL,\n\t\t\tjwt->payload.sub, &userinfo_jwt);\n\n\t/* restore the original protected URL that the user was trying to access */\n\tconst char *original_url = oidc_proto_state_get_original_url(proto_state);\n\tif (original_url != NULL)\n\t\toriginal_url = apr_pstrdup(r->pool, original_url);\n\tconst char *original_method = oidc_proto_state_get_original_method(\n\t\t\tproto_state);\n\tif (original_method != NULL)\n\t\toriginal_method = apr_pstrdup(r->pool, original_method);\n\tconst char *prompt = oidc_proto_state_get_prompt(proto_state);\n\n\t/* set the user */\n\tif (oidc_set_request_user(r, c, provider, jwt, claims) == TRUE) {\n\n\t\t/* session management: if the user in the new response is not equal to the old one, error out */\n\t\tif ((prompt != NULL)\n\t\t\t\t&& (apr_strnatcmp(prompt, OIDC_PROTO_PROMPT_NONE) == 0)) {\n\t\t\t// TOOD: actually need to compare sub? (need to store it in the session separately then\n\t\t\t//const char *sub = NULL;\n\t\t\t//oidc_session_get(r, session, \"sub\", &sub);\n\t\t\t//if (apr_strnatcmp(sub, jwt->payload.sub) != 0) {\n\t\t\tif (apr_strnatcmp(session->remote_user, r->user) != 0) {\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"user set from new id_token is different from current one\");\n\t\t\t\toidc_jwt_destroy(jwt);\n\t\t\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\t\t\"User changed!\", NULL);\n\t\t\t}\n\t\t}\n\n\t\t/* store resolved information in the session */\n\t\tif (oidc_save_in_session(r, c, session, provider, r->user,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ID_TOKEN), jwt, claims,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_ACCESS_TOKEN), expires_in,\n\t\t\t\tapr_table_get(params, OIDC_PROTO_REFRESH_TOKEN),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_SESSION_STATE),\n\t\t\t\tapr_table_get(params, OIDC_PROTO_STATE), original_url,\n\t\t\t\tuserinfo_jwt) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t} else {\n\t\toidc_error(r, \"remote user could not be set\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Remote user could not be set: contact the website administrator\",\n\t\t\t\tNULL);\n\t}\n\n\t/* cleanup */\n\toidc_proto_state_destroy(proto_state);\n\toidc_jwt_destroy(jwt);\n\n\t/* check that we've actually authenticated a user; functions as error handling for oidc_get_remote_user */\n\tif (r->user == NULL)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* log the successful response */\n\toidc_debug(r,\n\t\t\t\"session created and stored, returning to original URL: %s, original method: %s\",\n\t\t\toriginal_url, original_method);\n\n\t/* check whether form post data was preserved; if so restore it */\n\tif (apr_strnatcmp(original_method, OIDC_METHOD_FORM_POST) == 0) {\n\t\treturn oidc_request_post_preserved_restore(r, original_url);\n\t}\n\n\t/* now we've authenticated the user so go back to the URL that he originally tried to access */\n\toidc_util_hdr_out_location_set(r, original_url);\n\n\t/* do the actual redirect to the original URL */\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the POST (+fragment->POST) response_mode\n */\nstatic int oidc_handle_post_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* initialize local variables */\n\tchar *response_mode = NULL;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if we've got any POST-ed data at all */\n\tif ((apr_table_elts(params)->nelts < 1)\n\t\t\t|| ((apr_table_elts(params)->nelts == 1)\n\t\t\t\t\t&& apr_table_get(params, OIDC_PROTO_RESPONSE_MODE)\n\t\t\t\t\t&& (apr_strnatcmp(\n\t\t\t\t\t\t\tapr_table_get(params, OIDC_PROTO_RESPONSE_MODE),\n\t\t\t\t\t\t\tOIDC_PROTO_RESPONSE_MODE_FRAGMENT) == 0))) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"You've hit an OpenID Connect Redirect URI with no parameters, this is an invalid request; you should not open this URL in your browser directly, or have the server administrator use a different \" OIDCRedirectURI \" setting.\",\n\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t}\n\n\t/* get the parameters */\n\tresponse_mode = (char *) apr_table_get(params, OIDC_PROTO_RESPONSE_MODE);\n\n\t/* do the actual implicit work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tresponse_mode ? response_mode : OIDC_PROTO_RESPONSE_MODE_FORM_POST);\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the redirect response_mode\n */\nstatic int oidc_handle_redirect_authorization_response(request_rec *r,\n\t\toidc_cfg *c, oidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* read the parameters from the query string */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\toidc_util_read_form_encoded_params(r, params, r->args);\n\n\t/* do the actual work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tOIDC_PROTO_RESPONSE_MODE_QUERY);\n}\n\n/*\n * present the user with an OP selection screen\n */\nstatic int oidc_discovery(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* obtain the URL we're currently accessing, to be stored in the state/session */\n\tchar *current_url = oidc_get_current_url(r);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\t/* generate CSRF token */\n\tchar *csrf = NULL;\n\tif (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *path_scopes = oidc_dir_cfg_path_scope(r);\n\tchar *path_auth_request_params = oidc_dir_cfg_path_auth_request_params(r);\n\n\tchar *discover_url = oidc_cfg_dir_discover_url(r);\n\t/* see if there's an external discovery page configured */\n\tif (discover_url != NULL) {\n\n\t\t/* yes, assemble the parameters for external discovery */\n\t\tchar *url = apr_psprintf(r->pool, \"%s%s%s=%s&%s=%s&%s=%s&%s=%s\",\n\t\t\t\tdiscover_url,\n\t\t\t\tstrchr(discover_url, OIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_DISC_CB_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, oidc_get_redirect_uri(r, cfg)),\n\t\t\t\t\t\tOIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));\n\n\t\tif (path_scopes != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_SC_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\turl = apr_psprintf(r->pool, \"%s&%s=%s\", url, OIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\t/* log what we're about to do */\n\t\toidc_debug(r, \"redirecting to external discovery page: %s\", url);\n\n\t\t/* set CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\t\tcfg->cookie_same_site ?\n\t\t\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_STRICT :\n\t\t\t\t\t\tNULL);\n\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)\n\t\t\treturn OK;\n\n\t\t/* do the actual redirect to an external discovery page */\n\t\toidc_util_hdr_out_location_set(r, url);\n\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\t}\n\n\t/* get a list of all providers configured in the metadata directory */\n\tapr_array_header_t *arr = NULL;\n\tif (oidc_metadata_list(r, cfg, &arr) == FALSE)\n\t\treturn oidc_util_html_send_error(r, cfg->error_template,\n\t\t\t\t\"Configuration Error\",\n\t\t\t\t\"No configured providers found, contact your administrator\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\n\t/* assemble a where-are-you-from IDP discovery HTML page */\n\tconst char *s = \"\t\t\t<h3>Select your OpenID Connect Identity Provider</h3>\\n\";\n\n\t/* list all configured providers in there */\n\tint i;\n\tfor (i = 0; i < arr->nelts; i++) {\n\n\t\tconst char *issuer = ((const char**) arr->elts)[i];\n\t\t// TODO: html escape (especially & character)\n\n\t\tchar *href = apr_psprintf(r->pool,\n\t\t\t\t\"%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s\",\n\t\t\t\toidc_get_redirect_uri(r, cfg), OIDC_DISC_OP_PARAM,\n\t\t\t\toidc_util_escape_string(r, issuer),\n\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\tOIDC_CSRF_NAME, csrf);\n\n\t\tif (path_scopes != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_SC_PARAM, oidc_util_escape_string(r, path_scopes));\n\t\tif (path_auth_request_params != NULL)\n\t\t\thref = apr_psprintf(r->pool, \"%s&amp;%s=%s\", href,\n\t\t\t\t\tOIDC_DISC_AR_PARAM,\n\t\t\t\t\toidc_util_escape_string(r, path_auth_request_params));\n\n\t\tchar *display =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\n\t\t/* strip port number */\n\t\t//char *p = strstr(display, \":\");\n\t\t//if (p != NULL) *p = '\\0';\n\t\t/* point back to the redirect_uri, where the selection is handled, with an IDP selection and return_to URL */\n\t\ts = apr_psprintf(r->pool, \"%s<p><a href=\\\"%s\\\">%s</a></p>\\n\", s, href,\n\t\t\t\tdisplay);\n\t}\n\n\t/* add an option to enter an account or issuer name for dynamic OP discovery */\n\ts = apr_psprintf(r->pool, \"%s<form method=\\\"get\\\" action=\\\"%s\\\">\\n\", s,\n\t\t\toidc_get_redirect_uri(r, cfg));\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RT_PARAM, current_url);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RM_PARAM, method);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_CSRF_NAME, csrf);\n\n\tif (path_scopes != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_SC_PARAM, path_scopes);\n\tif (path_auth_request_params != NULL)\n\t\ts = apr_psprintf(r->pool,\n\t\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\t\tOIDC_DISC_AR_PARAM, path_auth_request_params);\n\n\ts =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\\n\",\n\t\t\t\t\ts);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"text\\\" name=\\\"%s\\\" value=\\\"%s\\\"></p>\\n\", s,\n\t\t\tOIDC_DISC_OP_PARAM, \"\");\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"submit\\\" value=\\\"Submit\\\"></p>\\n\", s);\n\ts = apr_psprintf(r->pool, \"%s</form>\\n\", s);\n\n\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1,\n\t\t\tcfg->cookie_same_site ? OIDC_COOKIE_EXT_SAME_SITE_STRICT : NULL);\n\n\tchar *javascript = NULL, *javascript_method = NULL;\n\tchar *html_head =\n\t\t\t\"<style type=\\\"text/css\\\">body {text-align: center}</style>\";\n\tif (oidc_post_preserve_javascript(r, NULL, &javascript,\n\t\t\t&javascript_method) == TRUE)\n\t\thtml_head = apr_psprintf(r->pool, \"%s%s\", html_head, javascript);\n\n\t/* now send the HTML contents to the user agent */\n\treturn oidc_util_html_send(r, \"OpenID Connect Provider Discovery\",\n\t\t\thtml_head, javascript_method, s, OK);\n}\n\n/*\n * authenticate the user to the selected OP, if the OP is not selected yet perform discovery first\n */\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params, const char *path_scope) {\n\n\toidc_debug(r, \"enter\");\n\n\tif (provider == NULL) {\n\n\t\t// TODO: should we use an explicit redirect to the discovery endpoint (maybe a \"discovery\" param to the redirect_uri)?\n\t\tif (c->metadata_dir != NULL)\n\t\t\treturn oidc_discovery(r, c);\n\n\t\t/* we're not using multiple OP's configured in a metadata directory, pick the statically configured OP */\n\t\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* generate the random nonce value that correlates requests and responses */\n\tchar *nonce = NULL;\n\tif (oidc_proto_generate_nonce(r, &nonce, OIDC_PROTO_NONCE_LENGTH) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *pkce_state = NULL;\n\tchar *code_challenge = NULL;\n\n\tif ((oidc_util_spaced_string_contains(r->pool, provider->response_type,\n\t\t\tOIDC_PROTO_CODE) == TRUE) && (provider->pkce != NULL)) {\n\n\t\t/* generate the code verifier value that correlates authorization requests and code exchange requests */\n\t\tif (provider->pkce->state(r, &pkce_state) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t/* generate the PKCE code challenge */\n\t\tif (provider->pkce->challenge(r, pkce_state, &code_challenge) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* create the state between request/response */\n\toidc_proto_state_t *proto_state = oidc_proto_state_new();\n\toidc_proto_state_set_original_url(proto_state, original_url);\n\toidc_proto_state_set_original_method(proto_state,\n\t\t\toidc_original_request_method(r, c, TRUE));\n\toidc_proto_state_set_issuer(proto_state, provider->issuer);\n\toidc_proto_state_set_response_type(proto_state, provider->response_type);\n\toidc_proto_state_set_nonce(proto_state, nonce);\n\toidc_proto_state_set_timestamp_now(proto_state);\n\tif (provider->response_mode)\n\t\toidc_proto_state_set_response_mode(proto_state,\n\t\t\t\tprovider->response_mode);\n\tif (prompt)\n\t\toidc_proto_state_set_prompt(proto_state, prompt);\n\tif (pkce_state)\n\t\toidc_proto_state_set_pkce_state(proto_state, pkce_state);\n\n\t/* get a hash value that fingerprints the browser concatenated with the random input */\n\tchar *state = oidc_get_browser_state_hash(r, nonce);\n\n\t/*\n\t * create state that restores the context when the authorization response comes in\n\t * and cryptographically bind it to the browser\n\t */\n\tint rc = oidc_authorization_request_set_cookie(r, c, state, proto_state);\n\tif (rc != HTTP_OK) {\n\t\toidc_proto_state_destroy(proto_state);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * printout errors if Cookie settings are not going to work\n\t * TODO: separate this code out into its own function\n\t */\n\tapr_uri_t o_uri;\n\tmemset(&o_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_t r_uri;\n\tmemset(&r_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_parse(r->pool, original_url, &o_uri);\n\tapr_uri_parse(r->pool, oidc_get_redirect_uri(r, c), &r_uri);\n\tif ((apr_strnatcmp(o_uri.scheme, r_uri.scheme) != 0)\n\t\t\t&& (apr_strnatcmp(r_uri.scheme, \"https\") == 0)) {\n\t\toidc_error(r,\n\t\t\t\t\"the URL scheme (%s) of the configured \" OIDCRedirectURI \" does not match the URL scheme of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\tr_uri.scheme, o_uri.scheme);\n\t\toidc_proto_state_destroy(proto_state);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (c->cookie_domain == NULL) {\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured \" OIDCRedirectURI \" does not match the URL hostname of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!oidc_util_cookie_domain_valid(r_uri.hostname, c->cookie_domain)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in \" OIDCCookieDomain \" does not match the URL hostname (%s) of the URL being accessed (%s): setting \\\"state\\\" and \\\"session\\\" cookies will not work!!\",\n\t\t\t\t\tc->cookie_domain, o_uri.hostname, original_url);\n\t\t\toidc_proto_state_destroy(proto_state);\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n\n\t/* send off to the OpenID Connect Provider */\n\t// TODO: maybe show intermediate/progress screen \"redirecting to\"\n\treturn oidc_proto_authorization_request(r, provider, login_hint,\n\t\t\toidc_get_redirect_uri_iss(r, c, provider), state, proto_state,\n\t\t\tid_token_hint, code_challenge, auth_request_params, path_scope);\n}\n\n/*\n * check if the target_link_uri matches to configuration settings to prevent an open redirect\n */\nstatic int oidc_target_link_uri_matches_configuration(request_rec *r,\n\t\toidc_cfg *cfg, const char *target_link_uri) {\n\n\tapr_uri_t o_uri;\n\tapr_uri_parse(r->pool, target_link_uri, &o_uri);\n\tif (o_uri.hostname == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse the \\\"target_link_uri\\\" (%s) in to a valid URL: aborting.\",\n\t\t\t\ttarget_link_uri);\n\t\treturn FALSE;\n\t}\n\n\tapr_uri_t r_uri;\n\tapr_uri_parse(r->pool, oidc_get_redirect_uri(r, cfg), &r_uri);\n\n\tif (cfg->cookie_domain == NULL) {\n\t\t/* cookie_domain set: see if the target_link_uri matches the redirect_uri host (because the session cookie will be set host-wide) */\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured \" OIDCRedirectURI \" does not match the URL hostname of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* cookie_domain set: see if the target_link_uri is within the cookie_domain */\n\t\tchar *p = strstr(o_uri.hostname, cfg->cookie_domain);\n\t\tif ((p == NULL) || (apr_strnatcmp(cfg->cookie_domain, p) != 0)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in \" OIDCCookieDomain \" does not match the URL hostname (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.hostname, target_link_uri);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* see if the cookie_path setting matches the target_link_uri path */\n\tchar *cookie_path = oidc_cfg_dir_cookie_path(r);\n\tif (cookie_path != NULL) {\n\t\tchar *p = (o_uri.path != NULL) ? strstr(o_uri.path, cookie_path) : NULL;\n\t\tif ((p == NULL) || (p != o_uri.path)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the path (%s) configured in \" OIDCCookiePath \" does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\treturn FALSE;\n\t\t} else if (strlen(o_uri.path) > strlen(cookie_path)) {\n\t\t\tint n = strlen(cookie_path);\n\t\t\tif (cookie_path[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\t\t\tn--;\n\t\t\tif (o_uri.path[n] != OIDC_CHAR_FORWARD_SLASH) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the path (%s) configured in \" OIDCCookiePath \" does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/*\n * handle a response from an IDP discovery page and/or handle 3rd-party initiated SSO\n */\nstatic int oidc_handle_discovery_response(request_rec *r, oidc_cfg *c) {\n\n\t/* variables to hold the values returned in the response */\n\tchar *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,\n\t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n\t\t\t*user = NULL, *path_scopes;\n\toidc_provider_t *provider = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n\toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n\toidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);\n\toidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);\n\toidc_util_get_request_parameter(r, OIDC_DISC_SC_PARAM, &path_scopes);\n\toidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,\n\t\t\t&auth_request_params);\n\toidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);\n\tcsrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);\n\n\t/* do CSRF protection if not 3rd party initiated SSO */\n\tif (csrf_cookie) {\n\n\t\t/* clean CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, \"\", 0, NULL);\n\n\t\t/* compare CSRF cookie value with query parameter value */\n\t\tif ((csrf_query == NULL)\n\t\t\t\t|| apr_strnatcmp(csrf_query, csrf_cookie) != 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"CSRF protection failed, no Discovery and dynamic client registration will be allowed\");\n\t\t\tcsrf_cookie = NULL;\n\t\t}\n\t}\n\n\t// TODO: trim issuer/accountname/domain input and do more input validation\n\n\toidc_debug(r,\n\t\t\t\"issuer=\\\"%s\\\", target_link_uri=\\\"%s\\\", login_hint=\\\"%s\\\", user=\\\"%s\\\"\",\n\t\t\tissuer, target_link_uri, login_hint, user);\n\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"SSO to this module without specifying a \\\"target_link_uri\\\" parameter is not possible because \" OIDCDefaultURL \" is not set.\",\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\t/* do open redirect prevention */\n\tif (oidc_target_link_uri_matches_configuration(r, c,\n\t\t\ttarget_link_uri) == FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* see if this is a static setup */\n\tif (c->metadata_dir == NULL) {\n\t\tif ((oidc_provider_static_config(r, c, &provider) == TRUE)\n\t\t\t\t&& (issuer != NULL)) {\n\t\t\tif (apr_strnatcmp(provider->issuer, issuer) != 0) {\n\t\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\t\"The \\\"iss\\\" value must match the configured providers' one (%s != %s).\",\n\t\t\t\t\t\t\t\tissuer, c->provider.issuer),\n\t\t\t\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t\treturn oidc_authenticate_user(r, c, NULL, target_link_uri, login_hint,\n\t\t\t\tNULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* find out if the user entered an account name or selected an OP manually */\n\tif (user != NULL) {\n\n\t\tif (login_hint == NULL)\n\t\t\tlogin_hint = apr_pstrdup(r->pool, user);\n\n\t\t/* normalize the user identifier */\n\t\tif (strstr(user, \"https://\") != user)\n\t\t\tuser = apr_psprintf(r->pool, \"https://%s\", user);\n\n\t\t/* got an user identifier as input, perform OP discovery with that */\n\t\tif (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t} else if (strstr(issuer, OIDC_STR_AT) != NULL) {\n\n\t\tif (login_hint == NULL) {\n\t\t\tlogin_hint = apr_pstrdup(r->pool, issuer);\n\t\t\t//char *p = strstr(issuer, OIDC_STR_AT);\n\t\t\t//*p = '\\0';\n\t\t}\n\n\t\t/* got an account name as input, perform OP discovery with that */\n\t\tif (oidc_proto_account_based_discovery(r, c, issuer, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided account name to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t}\n\n\t/* strip trailing '/' */\n\tint n = strlen(issuer);\n\tif (issuer[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\tissuer[n - 1] = '\\0';\n\n\t/* try and get metadata from the metadata directories for the selected OP */\n\tif ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)\n\t\t\t&& (provider != NULL)) {\n\n\t\t/* now we've got a selected OP, send the user there to authenticate */\n\t\treturn oidc_authenticate_user(r, c, provider, target_link_uri,\n\t\t\t\tlogin_hint, NULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\t\"Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator\",\n\t\t\tHTTP_NOT_FOUND);\n}\n\nstatic apr_uint32_t oidc_transparent_pixel[17] = { 0x474e5089, 0x0a1a0a0d,\n\t\t0x0d000000, 0x52444849, 0x01000000, 0x01000000, 0x00000408, 0x0c1cb500,\n\t\t0x00000002, 0x4144490b, 0x639c7854, 0x0000cffa, 0x02010702, 0x71311c9a,\n\t\t0x00000000, 0x444e4549, 0x826042ae };\n\nstatic apr_byte_t oidc_is_front_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL)\n\t\t\t&& ((apr_strnatcmp(logout_param_value,\n\t\t\t\t\tOIDC_GET_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t\t|| (apr_strnatcmp(logout_param_value,\n\t\t\t\t\t\t\tOIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)));\n}\n\nstatic apr_byte_t oidc_is_back_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL) && (apr_strnatcmp(logout_param_value,\n\t\t\tOIDC_BACKCHANNEL_STYLE_LOGOUT_PARAM_VALUE) == 0));\n}\n\n/*\n * revoke refresh token and access token stored in the session if the\n * OP has an RFC 7009 compliant token revocation endpoint\n */\nstatic void oidc_revoke_tokens(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *response = NULL;\n\tchar *basic_auth = NULL;\n\tchar *bearer_auth = NULL;\n\tapr_table_t *params = NULL;\n\tconst char *token = NULL;\n\toidc_provider_t *provider = NULL;\n\n\toidc_debug(r, \"enter\");\n\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE)\n\t\tgoto out;\n\n\toidc_debug(r, \"revocation_endpoint=%s\",\n\t\t\tprovider->revocation_endpoint_url ?\n\t\t\t\t\tprovider->revocation_endpoint_url : \"(null)\");\n\n\tif (provider->revocation_endpoint_url == NULL)\n\t\tgoto out;\n\n\tparams = apr_table_make(r->pool, 4);\n\n\t// add the token endpoint authentication credentials to the revocation endpoint call...\n\tif (oidc_proto_token_endpoint_auth(r, c, provider->token_endpoint_auth,\n\t\t\tprovider->client_id, provider->client_secret,\n\t\t\tprovider->client_signing_keys, provider->token_endpoint_url, params,\n\t\t\tNULL, &basic_auth, &bearer_auth) == FALSE)\n\t\tgoto out;\n\n\t// TODO: use oauth.ssl_validate_server ...\n\ttoken = oidc_session_get_refresh_token(r, session);\n\tif (token != NULL) {\n\t\tapr_table_addn(params, \"token_type_hint\", \"refresh_token\");\n\t\tapr_table_addn(params, \"token\", token);\n\n\t\tif (oidc_util_http_post_form(r, provider->revocation_endpoint_url,\n\t\t\t\tparams, basic_auth, bearer_auth, c->oauth.ssl_validate_server,\n\t\t\t\t&response, c->http_timeout_long, c->outgoing_proxy,\n\t\t\t\toidc_dir_cfg_pass_cookies(r), NULL,\n\t\t\t\tNULL) == FALSE) {\n\t\t\toidc_warn(r, \"revoking refresh token failed\");\n\t\t}\n\t\tapr_table_clear(params);\n\t}\n\n\ttoken = oidc_session_get_access_token(r, session);\n\tif (token != NULL) {\n\t\tapr_table_addn(params, \"token_type_hint\", \"access_token\");\n\t\tapr_table_addn(params, \"token\", token);\n\n\t\tif (oidc_util_http_post_form(r, provider->revocation_endpoint_url,\n\t\t\t\tparams, basic_auth, bearer_auth, c->oauth.ssl_validate_server,\n\t\t\t\t&response, c->http_timeout_long, c->outgoing_proxy,\n\t\t\t\toidc_dir_cfg_pass_cookies(r), NULL,\n\t\t\t\tNULL) == FALSE) {\n\t\t\toidc_warn(r, \"revoking access token failed\");\n\t\t}\n\t}\n\nout:\n\n\toidc_debug(r, \"leave\");\n}\n\n/*\n * handle a local logout\n */\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url) {\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\t/* if there's no remote_user then there's no (stored) session to kill */\n\tif (session->remote_user != NULL) {\n\n\t\toidc_revoke_tokens(r, c, session);\n\n\t\t/* remove session state (cq. cache entry and cookie) */\n\t\toidc_session_kill(r, session);\n\t}\n\n\t/* see if this is the OP calling us */\n\tif (oidc_is_front_channel_logout(url)) {\n\n\t\t/* set recommended cache control headers */\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_CACHE_CONTROL,\n\t\t\t\t\"no-cache, no-store\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_PRAGMA, \"no-cache\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_P3P, \"CAO PSA OUR\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_EXPIRES, \"0\");\n\t\toidc_util_hdr_err_out_add(r, OIDC_HTTP_HDR_X_FRAME_OPTIONS, \"DENY\");\n\n\t\t/* see if this is PF-PA style logout in which case we return a transparent pixel */\n\t\tconst char *accept = oidc_util_hdr_in_accept_get(r);\n\t\tif ((apr_strnatcmp(url, OIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t|| ((accept) && strstr(accept, OIDC_CONTENT_TYPE_IMAGE_PNG))) {\n\t\t\treturn oidc_util_http_send(r,\n\t\t\t\t\t(const char *) &oidc_transparent_pixel,\n\t\t\t\t\tsizeof(oidc_transparent_pixel), OIDC_CONTENT_TYPE_IMAGE_PNG,\n\t\t\t\t\tOK);\n\t\t}\n\n\t\t/* standard HTTP based logout: should be called in an iframe from the OP */\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", OK);\n\t}\n\n\t/* see if we don't need to go somewhere special after killing the session locally */\n\tif (url == NULL)\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", OK);\n\n\t/* send the user to the specified where-to-go-after-logout URL */\n\toidc_util_hdr_out_location_set(r, url);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle a backchannel logout\n */\n#define OIDC_EVENTS_BLOGOUT_KEY \"http://schemas.openid.net/event/backchannel-logout\"\n\nstatic int oidc_handle_logout_backchannel(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *logout_token = NULL;\n\toidc_jwt_t *jwt = NULL;\n\toidc_jose_error_t err;\n\toidc_jwk_t *jwk = NULL;\n\toidc_provider_t *provider = NULL;\n\tchar *sid = NULL, *uuid = NULL;\n\toidc_session_t session;\n\tint rc = HTTP_BAD_REQUEST;\n\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"could not read POST-ed parameters to the logout endpoint\");\n\t\tgoto out;\n\t}\n\n\tlogout_token = apr_table_get(params, OIDC_PROTO_LOGOUT_TOKEN);\n\tif (logout_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"backchannel lggout endpoint was called but could not find a parameter named \\\"%s\\\"\",\n\t\t\t\tOIDC_PROTO_LOGOUT_TOKEN);\n\t\tgoto out;\n\t}\n\n\t// TODO: jwk symmetric key based on provider\n\t// TODO: share more code with regular id_token validation and unsolicited state\n\n\tif (oidc_jwt_parse(r->pool, logout_token, &jwt,\n\t\t\toidc_util_merge_symmetric_key(r->pool, cfg->private_keys, NULL),\n\t\t\t&err) == FALSE) {\n\t\toidc_error(r, \"oidc_jwt_parse failed: %s\", oidc_jose_e2s(r->pool, err));\n\t\tgoto out;\n\t}\n\n\tprovider = oidc_get_provider_for_issuer(r, cfg, jwt->payload.iss, FALSE);\n\tif (provider == NULL) {\n\t\toidc_error(r, \"no provider found for issuer: %s\", jwt->payload.iss);\n\t\tgoto out;\n\t}\n\n\t// TODO: destroy the JWK used for decryption\n\n\tjwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, provider->client_secret, 0,\n\t\t\tNULL, TRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwks_uri_t jwks_uri = { provider->jwks_uri,\n\t\t\tprovider->jwks_refresh_interval, provider->ssl_validate_server };\n\tif (oidc_proto_jwt_verify(r, cfg, jwt, &jwks_uri,\n\t\t\toidc_util_merge_symmetric_key(r->pool, NULL, jwk)) == FALSE) {\n\n\t\toidc_error(r, \"id_token signature could not be validated, aborting\");\n\t\tgoto out;\n\t}\n\n\t// oidc_proto_validate_idtoken would try and require a token binding cnf\n\t// if the policy is set to \"required\", so don't use that here\n\n\tif (oidc_proto_validate_jwt(r, jwt, provider->issuer, FALSE, FALSE,\n\t\t\tprovider->idtoken_iat_slack,\n\t\t\tOIDC_TOKEN_BINDING_POLICY_DISABLED) == FALSE)\n\t\tgoto out;\n\n\t/* verify the \"aud\" and \"azp\" values */\n\tif (oidc_proto_validate_aud_and_azp(r, cfg, provider,\n\t\t\t&jwt->payload) == FALSE)\n\t\tgoto out;\n\n\tjson_t *events = json_object_get(jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_EVENTS);\n\tif (events == NULL) {\n\t\toidc_error(r, \"\\\"%s\\\" claim could not be found in logout token\",\n\t\t\t\tOIDC_CLAIM_EVENTS);\n\t\tgoto out;\n\t}\n\n\tjson_t *blogout = json_object_get(events, OIDC_EVENTS_BLOGOUT_KEY);\n\tif (!json_is_object(blogout)) {\n\t\toidc_error(r, \"\\\"%s\\\" object could not be found in \\\"%s\\\" claim\",\n\t\t\t\tOIDC_EVENTS_BLOGOUT_KEY, OIDC_CLAIM_EVENTS);\n\t\tgoto out;\n\t}\n\n\tchar *nonce = NULL;\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_NONCE, &nonce, NULL);\n\tif (nonce != NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"rejecting logout request/token since it contains a \\\"%s\\\" claim\",\n\t\t\t\tOIDC_CLAIM_NONCE);\n\t\tgoto out;\n\t}\n\n\tchar *jti = NULL;\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_JTI, &jti, NULL);\n\tif (jti != NULL) {\n\t\tchar *replay = NULL;\n\t\toidc_cache_get_jti(r, jti, &replay);\n\t\tif (replay != NULL) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the \\\"%s\\\" value (%s) passed in logout token was found in the cache already; possible replay attack!?\",\n\t\t\t\t\tOIDC_CLAIM_JTI, jti);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* jti cache duration is the configured replay prevention window for token issuance plus 10 seconds for safety */\n\tapr_time_t jti_cache_duration = apr_time_from_sec(\n\t\t\tprovider->idtoken_iat_slack * 2 + 10);\n\n\t/* store it in the cache for the calculated duration */\n\toidc_cache_set_jti(r, jti, jti, apr_time_now() + jti_cache_duration);\n\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_EVENTS, &sid, NULL);\n\n\t// TODO: by-spec we should cater for the fact that \"sid\" has been provided\n\t//       in the id_token returned in the authentication request, but \"sub\"\n\t//       is used in the logout token but that requires a 2nd entry in the\n\t//       cache and a separate session \"sub\" member, ugh; we'll just assume\n\t//       that is \"sid\" is specified in the id_token, the OP will actually use\n\t//       this for logout\n\t//       (and probably call us multiple times or the same sub if needed)\n\n\toidc_json_object_get_string(r->pool, jwt->payload.value.json,\n\t\t\tOIDC_CLAIM_SID, &sid, NULL);\n\tif (sid == NULL)\n\t\tsid = jwt->payload.sub;\n\n\tif (sid == NULL) {\n\t\toidc_error(r, \"no \\\"sub\\\" and no \\\"sid\\\" claim found in logout token\");\n\t\tgoto out;\n\t}\n\n\t// TODO: when dealing with sub instead of a true sid, we'll be killing all sessions for\n\t//       a specific user, across hosts that share the *same* cache backend\n\t//       if those hosts haven't been configured with a different OIDCCryptoPassphrase\n\t//       - perhaps that's even acceptable since non-memory caching is encrypted by default\n\t//         and memory-based caching doesn't suffer from this (different shm segments)?\n\t//       - it will result in 400 errors returned from backchannel logout calls to the other hosts...\n\n\tsid = oidc_make_sid_iss_unique(r, sid, provider->issuer);\n\toidc_cache_get_sid(r, sid, &uuid);\n\tif (uuid == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"could not find session based on sid/sub provided in logout token: %s\",\n\t\t\t\tsid);\n\t\tgoto out;\n\t}\n\n\t// revoke tokens if we can get a handle on those\n\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\tif (oidc_session_load_cache_by_uuid(r, cfg, uuid, &session) != FALSE)\n\t\t\tif (oidc_session_extract(r, &session) != FALSE)\n\t\t\t\toidc_revoke_tokens(r, cfg, &session);\n\t}\n\n\t// clear the session cache\n\toidc_cache_set_sid(r, sid, NULL, 0);\n\toidc_cache_set_session(r, uuid, NULL, 0);\n\n\trc = OK;\n\nout:\n\n\tif (jwk != NULL) {\n\t\toidc_jwk_destroy(jwk);\n\t\tjwk = NULL;\n\n\t}\n\tif (jwt != NULL) {\n\t\toidc_jwt_destroy(jwt);\n\t\tjwt = NULL;\n\t}\n\n\treturn rc;\n}\n\nstatic apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n        } else if ((uri.hostname == NULL) && (strstr(url, \"//\") == url)) {\n                *err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n                *err_desc =\n                                apr_psprintf(r->pool,\n                                                \"No hostname was parsed and starting with '//': %s\",\n                                                url);\n                oidc_error(r, \"%s: %s\", *err_str, *err_desc);\n                return FALSE;\n        } else if ((uri.hostname == NULL) && (strstr(url, \"/\\\\\") == url)) {\n                *err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n                *err_desc =\n                                apr_psprintf(r->pool,\n                                                \"No hostname was parsed and starting with '/\\\\': %s\",\n                                                url);\n                oidc_error(r, \"%s: %s\", *err_str, *err_desc);\n                return FALSE;\n\t}\n\n\t/* validate the URL to prevent HTTP header splitting */\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * perform (single) logout\n */\nstatic int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\t\tif (oidc_validate_post_logout_url(r, url, &error_str,\n\t\t\t\t&error_description) == FALSE) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\t\terror_description,\n\t\t\t\t\tHTTP_BAD_REQUEST);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}\n\n/*\n * handle request for JWKs\n */\nint oidc_handle_jwks(request_rec *r, oidc_cfg *c) {\n\n\t/* pickup requested JWKs type */\n\t//\tchar *jwks_type = NULL;\n\t//\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_JWKS, &jwks_type);\n\tchar *jwks = apr_pstrdup(r->pool, \"{ \\\"keys\\\" : [\");\n\tapr_hash_index_t *hi = NULL;\n\tapr_byte_t first = TRUE;\n\toidc_jose_error_t err;\n\n\tif (c->public_keys != NULL) {\n\n\t\t/* loop over the RSA public keys */\n\t\tfor (hi = apr_hash_first(r->pool, c->public_keys); hi; hi =\n\t\t\t\tapr_hash_next(hi)) {\n\n\t\t\tconst char *s_kid = NULL;\n\t\t\toidc_jwk_t *jwk = NULL;\n\t\t\tchar *s_json = NULL;\n\n\t\t\tapr_hash_this(hi, (const void**) &s_kid, NULL, (void**) &jwk);\n\n\t\t\tif (oidc_jwk_to_json(r->pool, jwk, &s_json, &err) == TRUE) {\n\t\t\t\tjwks = apr_psprintf(r->pool, \"%s%s %s \", jwks, first ? \"\" : \",\",\n\t\t\t\t\t\ts_json);\n\t\t\t\tfirst = FALSE;\n\t\t\t} else {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"could not convert RSA JWK to JSON using oidc_jwk_to_json: %s\",\n\t\t\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: send stuff if first == FALSE?\n\tjwks = apr_psprintf(r->pool, \"%s ] }\", jwks);\n\n\treturn oidc_util_http_send(r, jwks, strlen(jwks), OIDC_CONTENT_TYPE_JSON,\n\t\t\tOK);\n}\n\nstatic int oidc_handle_session_management_iframe_op(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *check_session_iframe) {\n\toidc_debug(r, \"enter\");\n\toidc_util_hdr_out_location_set(r, check_session_iframe);\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\nstatic int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var message = '%s' + ' ' + '%s';\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %d);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.debug('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed') {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=check';\\n\"\n\t\t\t\"          } else {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=logout';\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = oidc_session_get_session_state(r, session);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\treturn OK;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tint poll_interval = s_poll_interval ? strtol(s_poll_interval, NULL, 10) : 0;\n\tif ((poll_interval <= 0) || (poll_interval > 3600 * 24))\n\t\tpoll_interval = 3000;\n\n\tconst char *redirect_uri = oidc_get_redirect_uri(r, c);\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, poll_interval, redirect_uri,\n\t\t\tredirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, OK);\n}\n\n/*\n * handle session management request\n */\nstatic int oidc_handle_session_management(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tchar *cmd = NULL;\n\tconst char *id_token_hint = NULL;\n\toidc_provider_t *provider = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_SESSION, &cmd);\n\tif (cmd == NULL) {\n\t\toidc_error(r, \"session management handler called with no command\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if this is a local logout during session management */\n\tif (apr_strnatcmp(\"logout\", cmd) == 0) {\n\t\toidc_debug(r,\n\t\t\t\t\"[session=logout] calling oidc_handle_logout_request because of session mgmt local logout call.\");\n\t\treturn oidc_handle_logout_request(r, c, session, c->default_slo_url);\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\t/* see if this is a request for the OP iframe */\n\tif (apr_strnatcmp(\"iframe_op\", cmd) == 0) {\n\t\tif (provider->check_session_iframe != NULL) {\n\t\t\treturn oidc_handle_session_management_iframe_op(r, c, session,\n\t\t\t\t\tprovider->check_session_iframe);\n\t\t}\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request for the RP iframe */\n\tif (apr_strnatcmp(\"iframe_rp\", cmd) == 0) {\n\t\tif ((provider->client_id != NULL)\n\t\t\t\t&& (provider->check_session_iframe != NULL)) {\n\t\t\treturn oidc_handle_session_management_iframe_rp(r, c, session,\n\t\t\t\t\tprovider->client_id, provider->check_session_iframe);\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"iframe_rp command issued but no client (%s) and/or no check_session_iframe (%s) set\",\n\t\t\t\tprovider->client_id, provider->check_session_iframe);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request check the login state with the OP */\n\tif (apr_strnatcmp(\"check\", cmd) == 0) {\n\t\tid_token_hint = oidc_session_get_idtoken(r, session);\n\t\tif ((session->remote_user != NULL) && (provider != NULL)) {\n\t\t\t/*\n\t\t\t * TODO: this doesn't work with per-path provided auth_request_params and scopes\n\t\t\t *       as oidc_dir_cfg_path_auth_request_params and oidc_dir_cfg_path_scope will pick\n\t\t\t *       those for the redirect_uri itself; do we need to store those as part of the\n\t\t\t *       session now?\n\t\t\t */\n\t\t\treturn oidc_authenticate_user(r, c, provider,\n\t\t\t\t\tapr_psprintf(r->pool, \"%s?session=iframe_rp\",\n\t\t\t\t\t\t\toidc_get_redirect_uri_iss(r, c, provider)), NULL,\n\t\t\t\t\t\t\tid_token_hint, \"none\",\n\t\t\t\t\t\t\toidc_dir_cfg_path_auth_request_params(r),\n\t\t\t\t\t\t\toidc_dir_cfg_path_scope(r));\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"[session=check] calling oidc_handle_logout_request because no session found.\");\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\n\t/* handle failure in fallthrough */\n\toidc_error(r, \"unknown command: %s\", cmd);\n\n\treturn HTTP_INTERNAL_SERVER_ERROR;\n}\n\n/*\n * handle refresh token request\n */\nstatic int oidc_handle_refresh_token_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *return_to = NULL;\n\tchar *r_access_token = NULL;\n\tchar *error_code = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REFRESH,\n\t\t\t&return_to);\n\toidc_util_get_request_parameter(r, OIDC_PROTO_ACCESS_TOKEN,\n\t\t\t&r_access_token);\n\n\t/* check the input parameters */\n\tif (return_to == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no URL to return to\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (r_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no access_token parameter\");\n\t\terror_code = \"no_access_token\";\n\t\tgoto end;\n\t}\n\n\tconst char *s_access_token = oidc_session_get_access_token(r, session);\n\tif (s_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"no existing access_token found in the session, nothing to refresh\");\n\t\terror_code = \"no_access_token_exists\";\n\t\tgoto end;\n\t}\n\n\t/* compare the access_token parameter used for XSRF protection */\n\tif (apr_strnatcmp(s_access_token, r_access_token) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"access_token passed in refresh request does not match the one stored in the session\");\n\t\terror_code = \"no_access_token_match\";\n\t\tgoto end;\n\t}\n\n\t/* get a handle to the provider configuration */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\n\t/* execute the actual refresh grant */\n\tif (oidc_refresh_access_token(r, c, session, provider, NULL) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\terror_code = \"refresh_failed\";\n\t\tgoto end;\n\t}\n\n\t/* pass the tokens to the application and save the session, possibly updating the expiry */\n\tif (oidc_session_pass_tokens_and_save(r, c, session, TRUE) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\nend:\n\n\t/* pass optional error message to the return URL */\n\tif (error_code != NULL)\n\t\treturn_to = apr_psprintf(r->pool, \"%s%serror_code=%s\", return_to,\n\t\t\t\tstrchr(return_to ? return_to : \"\", OIDC_CHAR_QUERY) ?\n\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\tOIDC_STR_QUERY, oidc_util_escape_string(r, error_code));\n\n\t/* add the redirect location header */\n\toidc_util_hdr_out_location_set(r, return_to);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle request object by reference request\n */\nstatic int oidc_handle_request_uri(request_rec *r, oidc_cfg *c) {\n\n\tchar *request_ref = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_REQUEST_URI,\n\t\t\t&request_ref);\n\tif (request_ref == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" parameter found\",\n\t\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI);\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\n\tchar *jwt = NULL;\n\toidc_cache_get_request_uri(r, request_ref, &jwt);\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no cached JWT found for %s reference: %s\",\n\t\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI, request_ref);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\toidc_cache_set_request_uri(r, request_ref, NULL, 0);\n\n\treturn oidc_util_http_send(r, jwt, strlen(jwt), OIDC_CONTENT_TYPE_JWT, OK);\n}\n\n/*\n * handle a request to invalidate a cached access token introspection result\n */\nint oidc_handle_remove_at_cache(request_rec *r, oidc_cfg *c) {\n\tchar *access_token = NULL;\n\toidc_util_get_request_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE, &access_token);\n\n\tchar *cache_entry = NULL;\n\toidc_cache_get_access_token(r, access_token, &cache_entry);\n\tif (cache_entry == NULL) {\n\t\toidc_error(r, \"no cached access token found for value: %s\",\n\t\t\t\taccess_token);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\toidc_cache_set_access_token(r, access_token, NULL, 0);\n\n\treturn OK;\n}\n\n#define OIDC_INFO_PARAM_ACCESS_TOKEN_REFRESH_INTERVAL \"access_token_refresh_interval\"\n\n/*\n * handle request for session info\n */\nstatic int oidc_handle_info_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tint rc = HTTP_UNAUTHORIZED;\n\tapr_byte_t needs_save = FALSE;\n\tchar *s_format = NULL, *s_interval = NULL, *r_value = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_INFO,\n\t\t\t&s_format);\n\toidc_util_get_request_parameter(r,\n\t\t\tOIDC_INFO_PARAM_ACCESS_TOKEN_REFRESH_INTERVAL, &s_interval);\n\n\t/* see if this is a request for a format that is supported */\n\tif ((apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_JSON, s_format) != 0)\n\t\t\t&& (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_HTML, s_format) != 0)) {\n\t\toidc_warn(r, \"request for unknown format: %s\", s_format);\n\t\treturn HTTP_UNSUPPORTED_MEDIA_TYPE;\n\t}\n\n\t/* check that we actually have a user session and this is someone calling with a proper session cookie */\n\tif (session->remote_user == NULL) {\n\t\toidc_warn(r, \"no user session found\");\n\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/* set the user in the main request for further (incl. sub-request and authz) processing */\n\tr->user = apr_pstrdup(r->pool, session->remote_user);\n\n\tif (c->info_hook_data == NULL) {\n\t\toidc_warn(r, \"no data configured to return in \" OIDCInfoHook);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if we can and need to refresh the access token */\n\tif ((s_interval != NULL)\n\t\t\t&& (oidc_session_get_refresh_token(r, session) != NULL)) {\n\n\t\tapr_time_t t_interval;\n\t\tif (sscanf(s_interval, \"%\" APR_TIME_T_FMT, &t_interval) == 1) {\n\t\t\tt_interval = apr_time_from_sec(t_interval);\n\n\t\t\t/* get the last refresh timestamp from the session info */\n\t\t\tapr_time_t last_refresh =\n\t\t\t\t\toidc_session_get_access_token_last_refresh(r, session);\n\n\t\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\t\tapr_time_sec(last_refresh + t_interval - apr_time_now()));\n\n\t\t\t/* see if we need to refresh again */\n\t\t\tif (last_refresh + t_interval < apr_time_now()) {\n\n\t\t\t\t/* get the current provider info */\n\t\t\t\toidc_provider_t *provider = NULL;\n\t\t\t\tif (oidc_get_provider_from_session(r, c, session,\n\t\t\t\t\t\t&provider) == FALSE)\n\t\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t\t\t/* execute the actual refresh grant */\n\t\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t\tNULL) == FALSE)\n\t\t\t\t\toidc_warn(r, \"access_token could not be refreshed\");\n\t\t\t\telse\n\t\t\t\t\tneeds_save = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* create the JSON object */\n\tjson_t *json = json_object();\n\n\t/* add a timestamp of creation in there for the caller */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_TIMESTAMP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_TIMESTAMP,\n\t\t\t\tjson_integer(apr_time_sec(apr_time_now())));\n\t}\n\n\t/*\n\t * refresh the claims from the userinfo endpoint\n\t * side-effect is that this may refresh the access token if not already done\n\t * note that OIDCUserInfoRefreshInterval should be set to control the refresh policy\n\t */\n\tneeds_save |= oidc_refresh_claims_from_userinfo_endpoint(r, c, session);\n\n\t/* include the access token in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tconst char *access_token = oidc_session_get_access_token(r, session);\n\t\tif (access_token != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN,\n\t\t\t\t\tjson_string(access_token));\n\t}\n\n\t/* include the access token expiry timestamp in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tconst char *access_token_expires =\n\t\t\t\toidc_session_get_access_token_expires(r, session);\n\t\tif (access_token_expires != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ACCES_TOKEN_EXP,\n\t\t\t\t\tjson_string(access_token_expires));\n\t}\n\n\t/* include the id_token claims in the session info */\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_ID_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_t *id_token = oidc_session_get_idtoken_claims_json(r, session);\n\t\tif (id_token)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_ID_TOKEN, id_token);\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_USER_INFO,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\t/* include the claims from the userinfo endpoint the session info */\n\t\tjson_t *claims = oidc_session_get_userinfo_claims_json(r, session);\n\t\tif (claims)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_USER_INFO, claims);\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_SESSION,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\tjson_t *j_session = json_object();\n\t\tjson_object_set(j_session, OIDC_HOOK_INFO_SESSION_STATE,\n\t\t\t\tsession->state);\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_UUID,\n\t\t\t\tjson_string(session->uuid));\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_TIMEOUT,\n\t\t\t\tjson_integer(apr_time_sec(session->expiry)));\n\t\tapr_time_t session_expires = oidc_session_get_session_expires(r,\n\t\t\t\tsession);\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_EXP,\n\t\t\t\tjson_integer(apr_time_sec(session_expires)));\n\t\tjson_object_set_new(j_session, OIDC_HOOK_INFO_SESSION_REMOTE_USER,\n\t\t\t\tjson_string(session->remote_user));\n\t\tjson_object_set_new(json, OIDC_HOOK_INFO_SESSION, j_session);\n\n\t}\n\n\tif (apr_hash_get(c->info_hook_data, OIDC_HOOK_INFO_REFRESH_TOKEN,\n\t\t\tAPR_HASH_KEY_STRING)) {\n\t\t/* include the refresh token in the session info */\n\t\tconst char *refresh_token = oidc_session_get_refresh_token(r, session);\n\t\tif (refresh_token != NULL)\n\t\t\tjson_object_set_new(json, OIDC_HOOK_INFO_REFRESH_TOKEN,\n\t\t\t\t\tjson_string(refresh_token));\n\t}\n\n\tif (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_JSON, s_format) == 0) {\n\t\t/* JSON-encode the result */\n\t\tr_value = oidc_util_encode_json_object(r, json, 0);\n\t\t/* return the stringified JSON result */\n\t\trc = oidc_util_http_send(r, r_value, strlen(r_value),\n\t\t\t\tOIDC_CONTENT_TYPE_JSON, OK);\n\t} else if (apr_strnatcmp(OIDC_HOOK_INFO_FORMAT_HTML, s_format) == 0) {\n\t\t/* JSON-encode the result */\n\t\tr_value = oidc_util_encode_json_object(r, json, JSON_INDENT(2));\n\t\trc = oidc_util_html_send(r, \"Session Info\", NULL, NULL,\n\t\t\t\tapr_psprintf(r->pool, \"<pre>%s</pre>\", r_value), OK);\n\t}\n\n\t/* free the allocated resources */\n\tjson_decref(json);\n\n\t/* pass the tokens to the application and save the session, possibly updating the expiry */\n\tif (oidc_session_pass_tokens_and_save(r, c, session, needs_save) == FALSE) {\n\t\toidc_warn(r, \"error saving session\");\n\t\trc = HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\treturn rc;\n}\n\n/*\n * handle all requests to the redirect_uri\n */\nint oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response from the OP using the Basic Client profile or a Hybrid flow*/\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t/*\n\t *\n\t * Note that we are checking for logout *before* checking for a POST authorization response\n\t * to handle backchannel POST-based logout\n\t *\n\t * so any POST to the Redirect URI that does not have a logout query parameter will be handled\n\t * as an authorization response; alternatively we could assume that a POST response has no\n\t * parameters\n\t */\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_LOGOUT)) {\n\t\t/* handle logout */\n\t\treturn oidc_handle_logout(r, c, session);\n\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response using the fragment(+POST) response_mode with the Implicit Client profile */\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\n\t} else if (oidc_is_discovery_response(r, c)) {\n\n\t\t/* this is response from the OP discovery page */\n\t\treturn oidc_handle_discovery_response(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_JWKS)) {\n\n\t\t/* handle JWKs request */\n\t\treturn oidc_handle_jwks(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_SESSION)) {\n\n\t\t/* handle session management request */\n\t\treturn oidc_handle_session_management(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REFRESH)) {\n\n\t\t/* handle refresh token request */\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REQUEST_URI)) {\n\n\t\t/* handle request object by reference request */\n\t\treturn oidc_handle_request_uri(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_REMOVE_AT_CACHE)) {\n\n\t\t/* handle request to invalidate access token cache */\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r,\n\t\t\tOIDC_REDIRECT_URI_REQUEST_INFO)) {\n\n\t\tif (session->remote_user == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\n\t\t/* set r->user, set headers/env-vars, update expiry, update userinfo + AT */\n\t\tint rc = oidc_handle_existing_session(r, c, session);\n\t\tif (rc != OK)\n\t\t\treturn rc;\n\n\t\treturn oidc_handle_info_request(r, c, session);\n\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\n\t\t/* this is a \"bare\" request to the redirect URI, indicating implicit flow using the fragment response_mode */\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\n\t/* this is not an authorization response or logout request */\n\n\t/* check for \"error\" response */\n\tif (oidc_util_request_has_parameter(r, OIDC_PROTO_ERROR)) {\n\n\t\t//\t\tchar *error = NULL, *descr = NULL;\n\t\t//\t\toidc_util_get_request_parameter(r, \"error\", &error);\n\t\t//\t\toidc_util_get_request_parameter(r, \"error_description\", &descr);\n\t\t//\n\t\t//\t\t/* send user facing error to browser */\n\t\t//\t\treturn oidc_util_html_send_error(r, error, descr, DONE);\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\n\toidc_error(r,\n\t\t\t\"The OpenID Connect callback URL received an invalid request: %s; returning HTTP_INTERNAL_SERVER_ERROR\",\n\t\t\tr->args);\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request\"),\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n}\n\n#define OIDC_AUTH_TYPE_OPENID_CONNECT \"openid-connect\"\n#define OIDC_AUTH_TYPE_OPENID_OAUTH20 \"oauth20\"\n#define OIDC_AUTH_TYPE_OPENID_BOTH    \"auth-openidc\"\n\n/*\n * main routine: handle OpenID Connect authentication\n */\nstatic int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) {\n\n\tif (oidc_get_redirect_uri(r, c) == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"configuration error: the authentication type is set to \\\"\" OIDC_AUTH_TYPE_OPENID_CONNECT \"\\\" but \" OIDCRedirectURI \" has not been set\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* check if this is a sub-request or an initial request */\n\tif (ap_is_initial_req(r)) {\n\n\t\tint rc = OK;\n\n\t\t/* load the session from the request state; this will be a new \"empty\" session if no state exists */\n\t\toidc_session_t *session = NULL;\n\t\toidc_session_load(r, &session);\n\n\t\t/* see if the initial request is to the redirect URI; this handles potential logout too */\n\t\tif (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c))) {\n\n\t\t\t/* handle request to the redirect_uri */\n\t\t\trc = oidc_handle_redirect_uri_request(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\treturn rc;\n\n\t\t\t/* initial request to non-redirect URI, check if we have an existing session */\n\t\t} else if (session->remote_user != NULL) {\n\n\t\t\t/* this is initial request and we already have a session */\n\t\t\trc = oidc_handle_existing_session(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\t/*\n\t\t * else: initial request, we have no session and it is not an authorization or\n\t\t *       discovery response: just hit the default flow for unauthenticated users\n\t\t */\n\t} else {\n\n\t\t/* not an initial request, try to recycle what we've already established in the main request */\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session (headers will have been scrubbed and set already) */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\t/*\n\t\t\t * apparently request state can get lost in sub-requests, so let's see\n\t\t\t * if we need to restore id_token and/or claims from the session cache\n\t\t\t */\n\t\t\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\t\t\tif (s_id_token == NULL) {\n\n\t\t\t\toidc_session_t *session = NULL;\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\toidc_copy_tokens_to_request_state(r, session, NULL, NULL);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\t\t\t}\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn OK;\n\t\t}\n\t\t/*\n\t\t * else: not initial request, but we could not find a session, so:\n\t\t * just hit the default flow for unauthenticated users\n\t\t */\n\t}\n\n\treturn oidc_handle_unauthenticated_user(r, c);\n}\n\n/*\n * main routine: handle \"mixed\" OIDC/OAuth authentication\n */\nstatic int oidc_check_mixed_userid_oauth(request_rec *r, oidc_cfg *c) {\n\n\t/* get the bearer access token from the Authorization header */\n\tconst char *access_token = NULL;\n\tif (oidc_oauth_get_bearer_token(r, &access_token) == TRUE)\n\t\treturn oidc_oauth_check_userid(r, c, access_token);\n\n\t/* no bearer token found: then treat this as a regular OIDC browser request */\n\treturn oidc_check_userid_openidc(r, c);\n}\n\n/*\n * generic Apache authentication hook for this module: dispatches to OpenID Connect or OAuth 2.0 specific routines\n */\nint oidc_check_user_id(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\t/* log some stuff about the incoming HTTP request */\n\toidc_debug(r, \"incoming request: \\\"%s?%s\\\", ap_is_initial_req(r)=%d\",\n\t\t\tr->parsed_uri.path, r->args, ap_is_initial_req(r));\n\n\t/* see if any authentication has been defined at all */\n\tif (ap_auth_type(r) == NULL)\n\t\treturn DECLINED;\n\n\t/* see if we've configured OpenID Connect user authentication for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_CONNECT) == 0)\n\t\treturn oidc_check_userid_openidc(r, c);\n\n\t/* see if we've configured OAuth 2.0 access control for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)\n\t\treturn oidc_oauth_check_userid(r, c, NULL);\n\n\t/* see if we've configured \"mixed mode\" for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn oidc_check_mixed_userid_oauth(r, c);\n\n\t/* this is not for us but for some other handler */\n\treturn DECLINED;\n}\n\n/*\n * get the claims and id_token from request state\n */\nstatic void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\n\tconst char *s_claims = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_CLAIMS);\n\tif (s_claims != NULL)\n\t\toidc_util_decode_json_object(r, s_claims, claims);\n\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\tif (s_id_token != NULL)\n\t\toidc_util_decode_json_object(r, s_id_token, id_token);\n}\n\n#if MODULE_MAGIC_NUMBER_MAJOR >= 20100714\n\n/*\n * find out which action we need to take when encountering an unauthorized request\n */\nstatic authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\",\n\t\t\t\t\"Different scope(s) or other claims required\");\n\t\treturn AUTHZ_DENIED;\n\t}\n\n\t/* see if we've configured OIDCUnAutzAction for this path */\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t// TODO: document that AuthzSendForbiddenOnFailure is required to return 403 FORBIDDEN\n\tcase OIDC_UNAUTZ_RETURN403:\n\tcase OIDC_UNAUTZ_RETURN401:\n\t\treturn AUTHZ_DENIED;\n\t\tbreak;\n\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\treturn AUTHZ_DENIED;\n\t\tbreak;\n\t}\n\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r),\n\t\t\toidc_dir_cfg_path_scope(r));\n\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\",\n\t\t\t\tlocation);\n\n\t\tchar *html_head = apr_psprintf(r->pool,\n\t\t\t\t\"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\",\n\t\t\t\tlocation);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\treturn AUTHZ_DENIED;\n}\n\n/*\n * generic Apache >=2.4 authorization hook for this module\n * handles both OpenID Connect or OAuth 2.0 in the same way, based on the claims stored in the session\n */\nauthz_status oidc_authz_checker(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args,\n\t\toidc_authz_match_claim_fn_type match_claim_fn) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn AUTHZ_GRANTED;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(r, id_token, claims);\n\n\t/* dispatch to the >=2.4 specific authz routine */\n\tauthz_status rc = oidc_authz_worker24(r, claims ? claims : id_token,\n\t\t\trequire_args, match_claim_fn);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == AUTHZ_DENIED) && ap_auth_type(r))\n\t\trc = oidc_handle_unauthorized_user24(r);\n\n\treturn rc;\n}\n\nauthz_status oidc_authz_checker_claim(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args,\n\t\t\toidc_authz_match_claim);\n}\n\n#ifdef USE_LIBJQ\nauthz_status oidc_authz_checker_claims_expr(request_rec *r, const char *require_args, const void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args, oidc_authz_match_claims_expr);\n}\n#endif\n\n#else\n\n/*\n * find out which action we need to take when encountering an unauthorized request\n */\nstatic int oidc_handle_unauthorized_user22(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r), OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\", \"Different scope(s) or other claims required\");\n\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\t/* see if we've configured OIDCUnAutzAction for this path */\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\tcase OIDC_UNAUTZ_RETURN403:\n\t\treturn HTTP_FORBIDDEN;\n\tcase OIDC_UNAUTZ_RETURN401:\n\t\treturn HTTP_UNAUTHORIZED;\n\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t/*\n\t\t * exception handling: if this looks like a XMLHttpRequest call we\n\t\t * won't redirect the user and thus avoid creating a state cookie\n\t\t * for a non-browser (= Javascript) call that will never return from the OP\n\t\t */\n\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n}\n\n/*\n * generic Apache <2.4 authorization hook for this module\n * handles both OpenID Connect and OAuth 2.0 in the same way, based on the claims stored in the request context\n */\nint oidc_auth_checker(request_rec *r) {\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn OK;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* get the Require statements */\n\tconst apr_array_header_t * const reqs_arr = ap_requires(r);\n\n\t/* see if we have any */\n\tconst require_line * const reqs =\n\t\t\treqs_arr ? (require_line *) reqs_arr->elts : NULL;\n\tif (!reqs_arr) {\n\t\toidc_debug(r,\n\t\t\t\t\"no require statements found, so declining to perform authorization.\");\n\t\treturn DECLINED;\n\t}\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(r, id_token, claims);\n\n\t/* dispatch to the <2.4 specific authz routine */\n\tint rc = oidc_authz_worker22(r, claims ? claims : id_token, reqs,\n\t\t\treqs_arr->nelts);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == HTTP_UNAUTHORIZED) && ap_auth_type(r))\n\t\trc = oidc_handle_unauthorized_user22(r);\n\n\treturn rc;\n}\n\n#endif\n\napr_byte_t oidc_enabled(request_rec *r) {\n\tif (ap_auth_type(r) == NULL)\n\t\treturn FALSE;\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_CONNECT) == 0)\n\t\treturn TRUE;\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)\n\t\treturn TRUE;\n\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n/*\n * handle content generating requests\n */\nint oidc_content_handler(request_rec *r) {\n\tif (oidc_enabled(r) == FALSE)\n\t\treturn DECLINED;\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\treturn oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c)) ?\n\t\t\tOK : DECLINED;\n}\n\nextern const command_rec oidc_config_cmds[];\n\nmodule AP_MODULE_DECLARE_DATA auth_openidc_module = {\n\t\tSTANDARD20_MODULE_STUFF,\n\t\toidc_create_dir_config,\n\t\toidc_merge_dir_config,\n\t\toidc_create_server_config,\n\t\toidc_merge_server_config,\n\t\toidc_config_cmds,\n\t\toidc_register_hooks\n};\n"], "filenames": ["src/mod_auth_openidc.c"], "buggy_code_start_loc": [3065], "buggy_code_end_loc": [3065], "fixing_code_start_loc": [3066], "fixing_code_end_loc": [3074], "type": "CWE-601", "message": "A flaw was found in mod_auth_openidc before version 2.4.1. An open redirect issue exists in URLs with a slash and backslash at the beginning.", "other": {"cve": {"id": "CVE-2019-20479", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-20T06:15:11.027", "lastModified": "2023-05-25T20:18:46.990", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in mod_auth_openidc before version 2.4.1. An open redirect issue exists in URLs with a slash and backslash at the beginning."}, {"lang": "es", "value": "Se detect\u00f3 un fallo en mod_auth_openidc versiones anteriores a 2.4.1. Se presenta un problema de redireccionamiento abierto en las URL con una barra diagonal y una barra diagonal inversa al principio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openidc:mod_auth_openidc:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.1", "matchCriteriaId": "F486B27B-8085-4A55-9FFC-4AB9A349D445"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-03/msg00036.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/zmartzone/mod_auth_openidc/commit/02431c0adfa30f478cf2eb20ed6ea51fdf446be7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/zmartzone/mod_auth_openidc/pull/453", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/02/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00028.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/04/msg00034.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/27XJYAEONKJDESNE7WVZF5D2Z2OBY5JK/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NGXONXPWTX7DV62TIUIUVOZF4KQ6SIJE/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zmartzone/mod_auth_openidc/commit/02431c0adfa30f478cf2eb20ed6ea51fdf446be7"}}