{"buggy_code": ["/*\n * ejabberd, Copyright (C) 2002-2011   ProcessOne\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n * 02111-1307 USA\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <erl_driver.h>\n#include <zlib.h>\n\n\n#define BUF_SIZE 1024\n\n/*\n * R15B changed several driver callbacks to use ErlDrvSizeT and\n * ErlDrvSSizeT typedefs instead of int.\n * This provides missing typedefs on older OTP versions.\n */\n#if ERL_DRV_EXTENDED_MAJOR_VERSION < 2\ntypedef int ErlDrvSizeT;\ntypedef int ErlDrvSSizeT;\n#endif\n\ntypedef struct {\n      ErlDrvPort port;\n      z_stream *d_stream;\n      z_stream *i_stream;\n} ejabberd_zlib_data;\n\nstatic void* zlib_alloc(void* data, unsigned int items, unsigned int size)\n{\n    return (void*) driver_alloc(items*size);\n}\n\nstatic void zlib_free(void* data, void* addr)\n{\n    driver_free(addr);\n}\n\nstatic ErlDrvData ejabberd_zlib_drv_start(ErlDrvPort port, char *buff)\n{\n   ejabberd_zlib_data *d =\n      (ejabberd_zlib_data *)driver_alloc(sizeof(ejabberd_zlib_data));\n   d->port = port;\n\n   d->d_stream = (z_stream *)driver_alloc(sizeof(z_stream));\n\n   d->d_stream->zalloc = zlib_alloc;\n   d->d_stream->zfree = zlib_free;\n   d->d_stream->opaque = (voidpf)0;\n\n   deflateInit(d->d_stream, Z_DEFAULT_COMPRESSION);\n\n   d->i_stream = (z_stream *)driver_alloc(sizeof(z_stream));\n\n   d->i_stream->zalloc = zlib_alloc;\n   d->i_stream->zfree = zlib_free;\n   d->i_stream->opaque = (voidpf)0;\n\n   inflateInit(d->i_stream);\n\n   set_port_control_flags(port, PORT_CONTROL_FLAG_BINARY);\n\n   return (ErlDrvData)d;\n}\n\nstatic void ejabberd_zlib_drv_stop(ErlDrvData handle)\n{\n   ejabberd_zlib_data *d = (ejabberd_zlib_data *)handle;\n\n   deflateEnd(d->d_stream);\n   driver_free(d->d_stream);\n\n   inflateEnd(d->i_stream);\n   driver_free(d->i_stream);\n\n   driver_free((char *)handle);\n}\n\n\n#define DEFLATE 1\n#define INFLATE 2\n\n#define die_unless(cond, errstr)\t\t\t\t\\\n\t if (!(cond))\t\t\t\t\t\t\\\n\t {\t\t\t\t\t\t\t\\\n\t    rlen = strlen(errstr) + 1;\t\t\t\t\\\n\t    b = driver_realloc_binary(b, rlen);\t\t\t\\\n\t    b->orig_bytes[0] = 1;\t\t\t\t\\\n\t    strncpy(b->orig_bytes + 1, errstr, rlen - 1);\t\\\n\t    *rbuf = (char *)b;\t\t\t\t\t\\\n\t    return rlen;\t\t\t\t\t\\\n\t }\n\n\nstatic ErlDrvSSizeT ejabberd_zlib_drv_control(ErlDrvData handle,\n\t\t\t\t     unsigned int command,\n\t\t\t\t     char *buf, ErlDrvSizeT len,\n\t\t\t\t     char **rbuf, ErlDrvSizeT rlen)\n{\n   ejabberd_zlib_data *d = (ejabberd_zlib_data *)handle;\n   int err;\n   int size;\n   ErlDrvBinary *b;\n\n   switch (command)\n   {\n      case DEFLATE:\n\t size = BUF_SIZE + 1;\n\t rlen = 1;\n\t b = driver_alloc_binary(size);\n\t b->orig_bytes[0] = 0;\n\n\t d->d_stream->next_in = (unsigned char *)buf;\n\t d->d_stream->avail_in = len;\n\t d->d_stream->avail_out = 0;\n\t err = Z_OK;\n\n\t while (err == Z_OK && d->d_stream->avail_out == 0)\n\t {\n\t    d->d_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n\t    d->d_stream->avail_out = BUF_SIZE;\n\n\t    err = deflate(d->d_stream, Z_SYNC_FLUSH);\n\t    die_unless((err == Z_OK) || (err == Z_STREAM_END),\n\t\t       \"Deflate error\");\n\n\t    rlen += (BUF_SIZE - d->d_stream->avail_out);\n\t    size += (BUF_SIZE - d->d_stream->avail_out);\n\t    b = driver_realloc_binary(b, size);\n\t }\n\t b = driver_realloc_binary(b, rlen);\n\t *rbuf = (char *)b;\n\t return rlen;\n      case INFLATE:\n\t size = BUF_SIZE + 1;\n\t rlen = 1;\n\t b = driver_alloc_binary(size);\n\t b->orig_bytes[0] = 0;\n\n\t if (len > 0) {\n\t    d->i_stream->next_in = (unsigned char *)buf;\n\t    d->i_stream->avail_in = len;\n\t    d->i_stream->avail_out = 0;\n\t    err = Z_OK;\n\n\t    while (err == Z_OK && d->i_stream->avail_out == 0)\n\t    {\n\t       d->i_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n\t       d->i_stream->avail_out = BUF_SIZE;\n\n\t       err = inflate(d->i_stream, Z_SYNC_FLUSH);\n\t       die_unless((err == Z_OK) || (err == Z_STREAM_END),\n\t\t\t  \"Inflate error\");\n\n\t       rlen += (BUF_SIZE - d->i_stream->avail_out);\n\t       size += (BUF_SIZE - d->i_stream->avail_out);\n\t       b = driver_realloc_binary(b, size);\n\t    }\n\t }\n\t b = driver_realloc_binary(b, rlen);\n\t *rbuf = (char *)b;\n\t return rlen;\n   }\n\n   b = driver_alloc_binary(1);\n   b->orig_bytes[0] = 0;\n   *rbuf = (char *)b;\n   return 1;\n}\n\n\nErlDrvEntry ejabberd_zlib_driver_entry = {\n   NULL,\t\t\t/* F_PTR init, N/A */\n   ejabberd_zlib_drv_start,\t/* L_PTR start, called when port is opened */\n   ejabberd_zlib_drv_stop,\t/* F_PTR stop, called when port is closed */\n   NULL,\t\t\t/* F_PTR output, called when erlang has sent */\n   NULL,\t\t\t/* F_PTR ready_input, called when input descriptor ready */\n   NULL,\t\t\t/* F_PTR ready_output, called when output descriptor ready */\n   \"ejabberd_zlib_drv\",\t\t/* char *driver_name, the argument to open_port */\n   NULL,\t\t\t/* F_PTR finish, called when unloaded */\n   NULL,\t\t\t/* handle */\n   ejabberd_zlib_drv_control,   /* F_PTR control, port_command callback */\n   NULL,\t\t\t/* F_PTR timeout, reserved */\n   NULL,\t\t\t\t/* F_PTR outputv, reserved */\n   /* Added in Erlang/OTP R15B: */\n   NULL,                 /* ready_async */\n   NULL,                 /* flush */\n   NULL,                 /* call */\n   NULL,                 /* event */\n   ERL_DRV_EXTENDED_MARKER,        /* extended_marker */\n   ERL_DRV_EXTENDED_MAJOR_VERSION, /* major_version */\n   ERL_DRV_EXTENDED_MINOR_VERSION, /* minor_version */\n   0,                    /* driver_flags */\n   NULL,                 /* handle2 */\n   NULL,                 /* process_exit */\n   NULL\t\t\t\t\t /* stop select */\n};\n\nDRIVER_INIT(ejabberd_zlib_drv) /* must match name in driver_entry */\n{\n   return &ejabberd_zlib_driver_entry;\n}\n\n\n", "%%%----------------------------------------------------------------------\n%%% File    : ejabberd_c2s.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Serve C2S connection\n%%% Created : 16 Nov 2002 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(ejabberd_c2s).\n-author('alexey@process-one.net').\n-update_info({update, 0}).\n\n-define(GEN_FSM, p1_fsm).\n\n-behaviour(?GEN_FSM).\n\n%% External exports\n-export([start/2,\n\t stop/1,\n\t start_link/2,\n\t send_text/2,\n\t send_element/2,\n\t socket_type/0,\n\t get_presence/1,\n\t get_aux_field/2,\n\t set_aux_field/3,\n\t del_aux_field/2,\n\t get_subscription/2,\n\t broadcast/4,\n\t get_subscribed/1]).\n\n%% gen_fsm callbacks\n-export([init/1,\n\t wait_for_stream/2,\n\t wait_for_auth/2,\n\t wait_for_feature_request/2,\n\t wait_for_bind/2,\n\t wait_for_session/2,\n\t wait_for_sasl_response/2,\n\t session_established/2,\n\t handle_event/3,\n\t handle_sync_event/4,\n\t code_change/4,\n\t handle_info/3,\n\t terminate/3,\n\t print_state/1]).\n\n-include(\"ejabberd.hrl\").\n-include(\"jlib.hrl\").\n-include(\"mod_privacy.hrl\").\n\n-define(SETS, gb_sets).\n-define(DICT, dict).\n\n%% pres_a contains all the presence available send (either through roster mechanism or directed).\n%% Directed presence unavailable remove user from pres_a.\n-record(state, {socket,\n\t\tsockmod,\n\t\tsocket_monitor,\n\t\txml_socket,\n\t\tstreamid,\n\t\tsasl_state,\n\t\taccess,\n\t\tshaper,\n\t\tzlib = false,\n\t\ttls = false,\n\t\ttls_required = false,\n\t\ttls_enabled = false,\n\t\ttls_options = [],\n\t\tauthenticated = false,\n\t\tjid,\n\t\tuser = <<>>, server = ?MYNAME, resource = <<>>,\n\t\tsid,\n\t\tpres_t = ?SETS:new(),\n\t\tpres_f = ?SETS:new(),\n\t\tpres_a = ?SETS:new(),\n\t\tpres_i = ?SETS:new(),\n\t\tpending_invitations = [],\n\t\tpres_last, pres_pri,\n\t\tpres_timestamp,\n\t\tpres_invis = false,\n\t\tprivacy_list = #userlist{},\n\t\tconn = unknown,\n\t\tauth_module = unknown,\n\t\tip,\n\t\taux_fields = [],\n\t\tlang}).\n\n%-define(DBGFSM, true).\n\n-ifdef(DBGFSM).\n-define(FSMOPTS, [{debug, [trace]}]).\n-else.\n-define(FSMOPTS, []).\n-endif.\n\n%% Module start with or without supervisor:\n-ifdef(NO_TRANSIENT_SUPERVISORS).\n-define(SUPERVISOR_START, ?GEN_FSM:start(ejabberd_c2s, [SockData, Opts],\n\t\t\t\t\t fsm_limit_opts(Opts) ++ ?FSMOPTS)).\n-else.\n-define(SUPERVISOR_START, supervisor:start_child(ejabberd_c2s_sup,\n\t\t\t\t\t\t [SockData, Opts])).\n-endif.\n\n%% This is the timeout to apply between event when starting a new\n%% session:\n-define(C2S_OPEN_TIMEOUT, 60000).\n-define(C2S_HIBERNATE_TIMEOUT, 90000).\n\n-define(STREAM_HEADER,\n\t\"<?xml version='1.0'?>\"\n\t\"<stream:stream xmlns='jabber:client' \"\n\t\"xmlns:stream='http://etherx.jabber.org/streams' \"\n\t\"id='~s' from='~s'~s~s>\"\n       ).\n\n-define(STREAM_TRAILER, \"</stream:stream>\").\n\n-define(INVALID_NS_ERR, ?SERR_INVALID_NAMESPACE).\n-define(INVALID_XML_ERR, ?SERR_XML_NOT_WELL_FORMED).\n-define(HOST_UNKNOWN_ERR, ?SERR_HOST_UNKNOWN).\n-define(POLICY_VIOLATION_ERR(Lang, Text),\n\t?SERRT_POLICY_VIOLATION(Lang, Text)).\n-define(INVALID_FROM, ?SERR_INVALID_FROM).\n\n\n%%%----------------------------------------------------------------------\n%%% API\n%%%----------------------------------------------------------------------\nstart(SockData, Opts) ->\n    ?SUPERVISOR_START.\n\nstart_link(SockData, Opts) ->\n    ?GEN_FSM:start_link(ejabberd_c2s, [SockData, Opts],\n\t\t\tfsm_limit_opts(Opts) ++ ?FSMOPTS).\n\nsocket_type() ->\n    xml_stream.\n\n%% Return Username, Resource and presence information\nget_presence(FsmRef) ->\n    ?GEN_FSM:sync_send_all_state_event(FsmRef, get_presence, 1000).\n\nget_aux_field(Key, #state{aux_fields = Opts}) ->\n    case lists:keysearch(Key, 1, Opts) of\n\t{value, {_, Val}} ->\n\t    {ok, Val};\n\t_ ->\n\t    error\n    end.\n\nset_aux_field(Key, Val, #state{aux_fields = Opts} = State) ->\n    Opts1 = lists:keydelete(Key, 1, Opts),\n    State#state{aux_fields = [{Key, Val}|Opts1]}.\n\ndel_aux_field(Key, #state{aux_fields = Opts} = State) ->\n    Opts1 = lists:keydelete(Key, 1, Opts),\n    State#state{aux_fields = Opts1}.\n\nget_subscription(From = #jid{}, StateData) ->\n    get_subscription(jlib:jid_tolower(From), StateData);\nget_subscription(LFrom, StateData) ->\n    LBFrom = setelement(3, LFrom, <<>>),\n    F = ?SETS:is_element(LFrom, StateData#state.pres_f) orelse\n\t?SETS:is_element(LBFrom, StateData#state.pres_f),\n    T = ?SETS:is_element(LFrom, StateData#state.pres_t) orelse\n\t?SETS:is_element(LBFrom, StateData#state.pres_t),\n    if F and T -> both;\n       F -> from;\n       T -> to;\n       true -> none\n    end.\n\nbroadcast(FsmRef, Type, From, Packet) ->\n    FsmRef ! {broadcast, Type, From, Packet}.\n\nstop(FsmRef) ->\n    ?GEN_FSM:send_event(FsmRef, closed).\n\n%%%----------------------------------------------------------------------\n%%% Callback functions from gen_fsm\n%%%----------------------------------------------------------------------\n\n%%----------------------------------------------------------------------\n%% Func: init/1\n%% Returns: {ok, StateName, StateData}          |\n%%          {ok, StateName, StateData, Timeout} |\n%%          ignore                              |\n%%          {stop, StopReason}\n%%----------------------------------------------------------------------\ninit([{SockMod, Socket}, Opts]) ->\n    Access = case lists:keysearch(access, 1, Opts) of\n\t\t {value, {_, A}} -> A;\n\t\t _ -> all\n\t     end,\n    Shaper = case lists:keysearch(shaper, 1, Opts) of\n\t\t {value, {_, S}} -> S;\n\t\t _ -> none\n\t     end,\n    XMLSocket =\n\tcase lists:keysearch(xml_socket, 1, Opts) of\n\t    {value, {_, XS}} -> XS;\n\t    _ -> false\n\tend,\n    Zlib = lists:member(zlib, Opts),\n    StartTLS = lists:member(starttls, Opts),\n    StartTLSRequired = lists:member(starttls_required, Opts),\n    TLSEnabled = lists:member(tls, Opts),\n    TLS = StartTLS orelse StartTLSRequired orelse TLSEnabled,\n    TLSOpts1 =\n\tlists:filter(fun({certfile, _}) -> true;\n\t\t\t(_) -> false\n\t\t     end, Opts),\n    TLSOpts = [verify_none | TLSOpts1],\n    IP = peerip(SockMod, Socket),\n    %% Check if IP is blacklisted:\n    case is_ip_blacklisted(IP) of\n\ttrue ->\n\t    ?INFO_MSG(\"Connection attempt from blacklisted IP: ~s (~w)\",\n\t\t      [jlib:ip_to_list(IP), IP]),\n\t    {stop, normal};\n\tfalse ->\n\t    Socket1 =\n\t\tif\n\t\t    TLSEnabled ->\n\t\t\tSockMod:starttls(Socket, TLSOpts);\n\t\t    true ->\n\t\t\tSocket\n\t\tend,\n\t    SocketMonitor = SockMod:monitor(Socket1),\n\t    {ok, wait_for_stream, #state{socket         = Socket1,\n\t\t\t\t\t sockmod        = SockMod,\n\t\t\t\t\t socket_monitor = SocketMonitor,\n\t\t\t\t\t xml_socket     = XMLSocket,\n\t\t\t\t\t zlib           = Zlib,\n\t\t\t\t\t tls            = TLS,\n\t\t\t\t\t tls_required   = StartTLSRequired,\n\t\t\t\t\t tls_enabled    = TLSEnabled,\n\t\t\t\t\t tls_options    = TLSOpts,\n\t\t\t\t\t streamid       = new_id(),\n\t\t\t\t\t access         = Access,\n\t\t\t\t\t shaper         = Shaper,\n\t\t\t\t\t ip             = IP},\n\t     ?C2S_OPEN_TIMEOUT}\n    end.\n\n%% Return list of all available resources of contacts,\nget_subscribed(FsmRef) ->\n    ?GEN_FSM:sync_send_all_state_event(FsmRef, get_subscribed, 1000).\n\n%%----------------------------------------------------------------------\n%% Func: StateName/2\n%% Returns: {next_state, NextStateName, NextStateData}          |\n%%          {next_state, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}\n%%----------------------------------------------------------------------\n\nwait_for_stream({xmlstreamstart, _Name, Attrs}, StateData) ->\n    DefaultLang = case ?MYLANG of\n\t\t      undefined ->\n\t\t\t  \"en\";\n\t\t      DL ->\n\t\t\t  DL\n\t\t  end,\n    case xml:get_attr_s(<<\"xmlns:stream\">>, Attrs) of\n\t?NS_STREAM ->\n\t    Server = jlib:nameprep(xml:get_attr_s(<<\"to\">>, Attrs)),\n\t    case lists:member(Server, ?MYHOSTS) of\n\t\ttrue ->\n\t\t    Lang = case xml:get_attr_s(<<\"xml:lang\">>, Attrs) of\n\t\t\t       Lang1 when size(Lang1) =< 35 ->\n\t\t\t\t   %% As stated in BCP47, 4.4.1:\n\t\t\t\t   %% Protocols or specifications that\n\t\t\t\t   %% specify limited buffer sizes for\n\t\t\t\t   %% language tags MUST allow for\n\t\t\t\t   %% language tags of at least 35 characters.\n\t\t\t\t   binary_to_list(Lang1);\n\t\t\t       _ ->\n\t\t\t\t   %% Do not store long language tag to\n\t\t\t\t   %% avoid possible DoS/flood attacks\n\t\t\t\t   \"\"\n\t\t\t   end,\n\t\t    change_shaper(StateData, jlib:make_jid(<<>>, Server, <<>>)),\n\t\t    case xml:get_attr_s(<<\"version\">>, Attrs) of\n\t\t\t<<\"1.0\">> ->\n\t\t\t    send_header(StateData, Server, \"1.0\", DefaultLang),\n\t\t\t    case StateData#state.authenticated of\n\t\t\t\tfalse ->\n                    SASLState =\n\t\t\t\t\tcyrsasl:server_new(\n\t\t\t\t\t  <<\"jabber\">>, Server, <<>>, [],\n\t\t\t\t\t  fun(U) ->\n\t\t\t\t\t\t  ejabberd_auth:get_password_with_authmodule(\n\t\t\t\t\t\t    U, Server)\n\t\t\t\t\t  end,\n\t\t\t\t\t  fun(U, P) ->\n\t\t\t\t\t\t  ejabberd_auth:check_password_with_authmodule(\n\t\t\t\t\t\t    U, Server, P)\n\t\t\t\t\t  end,\n\t\t\t\t\t  fun(U, P, D, DG) ->\n\t\t\t\t\t\t  ejabberd_auth:check_password_with_authmodule(\n\t\t\t\t\t\t    U, Server, P, D, DG)\n\t\t\t\t\t  end),\n\t\t\t\t    Mechs = lists:map(\n\t\t\t\t\t      fun(S) ->\n\t\t\t\t      #xmlel{name = <<\"mechanism\">>,\n\t\t\t     children = [#xmlcdata{content = S}]}\n\t\t\t      end, cyrsasl:listmech(Server)),\n\t\t    SockMod =\n\t\t\t (StateData#state.sockmod):get_sockmod(\n\t\t\t   StateData#state.socket),\n\t\t    Zlib = StateData#state.zlib,\n\t\t    CompressFeature =\n\t\t\tcase Zlib andalso\n\t\t\t      ((SockMod == gen_tcp) orelse\n\t\t\t       (SockMod == tls)) of\n\t\t\t    true ->\n\t\t\t\t[#xmlel{name = <<\"compression\">>,\n\t\t\t\t\tattrs = [{<<\"xmlns\">>, ?NS_FEATURE_COMPRESS}],\n\t\t\t\t\tchildren = [#xmlel{name = <<\"method\">>,\n\t\t\t\t\t\t           children = [#xmlcdata{content = <<\"zlib\">>}]}]}];\n\t\t\t    _ ->\n\t\t\t\t[]\n\t\t\tend,\n\t\t    TLS = StateData#state.tls,\n\t\t    TLSEnabled = StateData#state.tls_enabled,\n\t\t    TLSRequired = StateData#state.tls_required,\n\t\t    TLSFeature =\n\t\t\tcase  (TLS == true) andalso\n\t\t\t     (TLSEnabled == false) andalso\n\t\t\t     (SockMod == gen_tcp) of\n\t\t\t    true ->\n\t\t\t\tcase TLSRequired of\n\t\t\t\t    true ->\n\t\t\t\t\t[#xmlel{name = <<\"starttls\">>,\n\t\t\t\t\t\tattrs = [{\"xmlns\", ?NS_TLS}],\n\t\t\t\t\t\tchildren = [#xmlel{name = <<\"required\">>}]}];\n\t\t\t\t    _ ->\n\t\t\t\t\t[#xmlel{name = <<\"starttls\">>,\n\t\t\t\t\t\tattrs = [{<<\"xmlns\">>, ?NS_TLS}]}]\n\t\t\t\tend;\n\t\t\t    false ->\n\t\t\t\t[]\n\t\t\tend,\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"stream:features\">>,\n\t\t\t\t\tchildren = TLSFeature ++ CompressFeature ++\n\t\t\t\t\t\t   [#xmlel{name = <<\"mechanisms\">>,\n\t\t\t\t\t\t           attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t\t\t           children = Mechs}] ++\n\t\t\t\t\t\t   ejabberd_hooks:run_fold(\n\t\t\t\t\t\t     c2s_stream_features,\n\t\t\t\t\t\t     Server,\n\t\t\t\t\t\t     [], [Server])}),\n\t\t    fsm_next_state(wait_for_feature_request,\n\t\t\t       StateData#state{\n\t\t\t\t server = Server,\n\t\t\t\t sasl_state = SASLState,\n\t\t\t\t lang = Lang});\n\t\t\t\t_ ->\n\t\t\t\t    case StateData#state.resource of\n\t\t\t\t\t<<>> ->\n\t\t\t\t\t    RosterVersioningFeature =\n\t\t\t\t\t\tejabberd_hooks:run_fold(\n\t\t\t\t\t\t  roster_get_versioning_feature,\n\t\t\t\t\t\t  Server, [], [Server]),\n\t\t\t\t            StreamFeatures =\n\t\t\t\t\t\t[#xmlel{name = <<\"bind\">>,\n\t\t\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_BIND}]},\n\t\t\t\t\t\t #xmlel{name = <<\"session\">>,\n\t\t\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SESSION}]}]\n\t\t\t\t\t       ++ RosterVersioningFeature\n\t\t\t\t\t      ++ ejabberd_hooks:run_fold(\n\t\t\t\t\t\t   c2s_stream_features,\n\t\t\t\t\t\t   Server,\n\t\t\t\t\t\t   [], [Server]),\n\t\t\t\t\t    send_element(\n\t\t\t\t\t      StateData,\n\t\t\t\t\t      #xmlel{name = <<\"stream:features\">>,\n\t\t\t\t\t             children = StreamFeatures}),\n\t\t\t\t\t    fsm_next_state(wait_for_bind,\n\t\t\t\t\t\t       StateData#state{\n\t\t\t\t\t\t\t server = Server,\n\t\t\t\t\t\t\t lang = Lang});\n\t\t\t\t\t_ ->\n\t\t\t\t\t    send_element(\n\t\t\t\t\t      StateData,\n\t\t\t\t\t      #xmlel{name = <<\"stream:features\">>}),\n\t\t\t\t\t    fsm_next_state(wait_for_session,\n\t\t\t\t\t\t       StateData#state{\n\t\t\t\t\t\t\t server = Server,\n\t\t\t\t\t\t\t lang = Lang})\n\t\t\t\t    end\n\t\t\t    end;\n\t\t\t_ ->\n\t\t\t    send_header(StateData, Server, \"\", DefaultLang),\n\t\t\t    if\n\t\t\t\t(not StateData#state.tls_enabled) and\n\t\t\t\tStateData#state.tls_required ->\n\t\t\t\t    send_element(\n\t\t\t\t      StateData,\n\t\t\t\t      ?POLICY_VIOLATION_ERR(\n\t\t\t\t\t Lang,\n\t\t\t\t\t \"Use of STARTTLS required\")),\n\t\t\t\t    send_trailer(StateData),\n\t\t\t\t    {stop, normal, StateData};\n\t\t\t\ttrue ->\n\t\t\t\t    fsm_next_state(wait_for_auth,\n\t\t\t\t\t\t   StateData#state{\n\t\t\t\t\t\t     server = Server,\n\t\t\t\t\t\t     lang = Lang})\n\t\t\t    end\n\t\t    end;\n\t\t_ ->\n\t\t    send_header(StateData, ?MYNAME, \"\", DefaultLang),\n\t\t    send_element(StateData, ?HOST_UNKNOWN_ERR),\n\t\t    send_trailer(StateData),\n\t\t    {stop, normal, StateData}\n\t    end;\n\t_ ->\n\t    send_header(StateData, ?MYNAME, \"\", DefaultLang),\n\t    send_element(StateData, ?INVALID_NS_ERR),\n\t    send_trailer(StateData),\n\t    {stop, normal, StateData}\n    end;\n\nwait_for_stream(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_stream({xmlstreamelement, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_stream({xmlstreamend, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_stream({xmlstreamerror, _}, StateData) ->\n    send_header(StateData, ?MYNAME, \"1.0\", \"\"),\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_stream(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\nwait_for_auth({xmlstreamelement, El}, StateData) ->\n    case is_auth_packet(El) of\n\t{auth, _ID, get, {U, _, _, _}} ->\n\t    XE = #xmlel{name = Name,\n                        attrs = Attrs} = jlib:make_result_iq_reply(El),\n\t    case U of\n\t\t<<>> ->\n\t\t    UCdata = [];\n\t\t_ ->\n\t\t    UCdata = [#xmlcdata{content = U}]\n\t    end,\n\t    Res = case ejabberd_auth:plain_password_required(\n\t\t\t StateData#state.server) of\n\t\t      false ->\n\t\t\t  XE#xmlel{children = [#xmlel{name = <<\"query\">>,\n\t\t\t                              attrs = [{<<\"xmlns\">>,\n\t\t\t                                        ?NS_AUTH}],\n\t\t\t                              children = [#xmlel{name = <<\"username\">>,\n\t\t\t                                                 children = UCdata},\n\t\t\t                                          #xmlel{name = <<\"password\">>},\n\t\t\t                                          #xmlel{name = <<\"digest\">>},\n                                                                  #xmlel{name = <<\"resource\">>}]}]};\n\t\t      true ->\n\t\t\t  XE#xmlel{children = [#xmlel{name = <<\"query\">>,\n\t\t\t                              attrs = [{<<\"xmlns\">>,\n\t\t\t                                        ?NS_AUTH}],\n\t\t\t                              children = [#xmlel{name = <<\"username\">>,\n\t\t\t                                                 children = UCdata},\n\t\t\t                                          #xmlel{name = <<\"password\">>},\n                                                                  #xmlel{name = <<\"resource\">>}]}]}\n\t\t  end,\n\t    send_element(StateData, Res),\n\t    fsm_next_state(wait_for_auth, StateData);\n\t{auth, _ID, set, {_U, _P, _D, <<>>}} ->\n\t    Err = jlib:make_error_reply(\n\t\t    El,\n\t\t    ?ERR_AUTH_NO_RESOURCE_PROVIDED(StateData#state.lang)),\n\t    send_element(StateData, Err),\n\t    fsm_next_state(wait_for_auth, StateData);\n\t{auth, _ID, set, {U, P, D, R}} ->\n\t    JID = jlib:make_jid(U, StateData#state.server, R),\n\t    case (JID /= error) andalso\n\t\t(acl:match_rule(StateData#state.server,\n\t\t\t\tStateData#state.access, JID) == allow) of\n\t\ttrue ->\n                    DGen = fun(PW) ->\n                             list_to_binary(sha:sha(\n                                              StateData#state.streamid\n                                              ++ binary_to_list(PW))) end,\n\t\t    case ejabberd_auth:check_password_with_authmodule(\n\t\t\t   U, StateData#state.server, P, D, DGen) of\n\t\t\t{true, AuthModule} ->\n\t\t\t    ?INFO_MSG(\n\t\t\t       \"(~w) Accepted legacy authentication for ~s by ~p\",\n\t\t\t       [StateData#state.socket,\n\t\t\t\tjlib:jid_to_binary(JID), AuthModule]),\n\t\t\t    SID = {now(), self()},\n\t\t\t    Conn = get_conn_type(StateData),\n\t\t\t    Info = [{ip, StateData#state.ip}, {conn, Conn},\n\t\t\t\t    {auth_module, AuthModule}],\n\t\t\t    Res1 = jlib:make_result_iq_reply(El),\n\t\t\t    Res = setelement(4, Res1, []),\n\t\t\t    send_element(StateData, Res),\n\t\t\t    ejabberd_sm:open_session(\n\t\t\t      SID, U, StateData#state.server, R, Info),\n\t\t\t    change_shaper(StateData, JID),\n\t\t\t    {Fs, Ts, Pending} = ejabberd_hooks:run_fold(\n                                      roster_get_subscription_lists,\n                                      StateData#state.server,\n                                      {[], [], []},\n                                      [U, StateData#state.server]),\n\t\t\t    LJID = jlib:jid_tolower(\n\t\t\t\t     jlib:jid_remove_resource(JID)),\n\t\t\t    Fs1 = [LJID | Fs],\n\t\t\t    Ts1 = [LJID | Ts],\n\t\t\t    PrivList =\n\t\t\t\tejabberd_hooks:run_fold(\n\t\t\t\t  privacy_get_user_list, StateData#state.server,\n\t\t\t\t  #userlist{},\n\t\t\t\t  [U, StateData#state.server]),\n                            NewStateData =\n                                StateData#state{\n\t\t\t\t\t     user = U,\n\t\t\t\t\t     resource = R,\n\t\t\t\t\t     jid = JID,\n\t\t\t\t\t     sid = SID,\n\t\t\t\t\t     conn = Conn,\n\t\t\t\t\t     auth_module = AuthModule,\n\t\t\t\t\t     pres_f = ?SETS:from_list(Fs1),\n\t\t\t\t\t     pres_t = ?SETS:from_list(Ts1),\n                         pending_invitations = Pending,\n\t\t\t\t\t     privacy_list = PrivList},\n\t\t\t    fsm_next_state_pack(session_established,\n                                                NewStateData);\n\t\t\t_ ->\n\t\t\t    ?INFO_MSG(\n\t\t\t       \"(~w) Failed legacy authentication for ~s\",\n\t\t\t       [StateData#state.socket,\n\t\t\t\tjlib:jid_to_binary(JID)]),\n\t\t\t    Err = jlib:make_error_reply(\n\t\t\t\t    El, ?ERR_NOT_AUTHORIZED),\n\t\t\t    send_element(StateData, Err),\n\t\t\t    fsm_next_state(wait_for_auth, StateData)\n\t\t    end;\n\t\t_ ->\n\t\t    if\n\t\t\tJID == error ->\n\t\t\t    ?INFO_MSG(\n\t\t\t       \"(~w) Forbidden legacy authentication for \"\n\t\t\t       \"username '~s' with resource '~s'\",\n\t\t\t       [StateData#state.socket, U, R]),\n\t\t\t    Err = jlib:make_error_reply(El, ?ERR_JID_MALFORMED),\n\t\t\t    send_element(StateData, Err),\n\t\t\t    fsm_next_state(wait_for_auth, StateData);\n\t\t\ttrue ->\n\t\t\t    ?INFO_MSG(\n\t\t\t       \"(~w) Forbidden legacy authentication for ~s\",\n\t\t\t       [StateData#state.socket,\n\t\t\t\tjlib:jid_to_binary(JID)]),\n\t\t\t    Err = jlib:make_error_reply(El, ?ERR_NOT_ALLOWED),\n\t\t\t    send_element(StateData, Err),\n\t\t\t    fsm_next_state(wait_for_auth, StateData)\n\t\t    end\n\t    end;\n\t_ ->\n\t    process_unauthenticated_stanza(StateData, El),\n\t    fsm_next_state(wait_for_auth, StateData)\n    end;\n\nwait_for_auth(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_auth({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_auth({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_auth(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\nwait_for_feature_request({xmlstreamelement, El}, StateData) ->\n    #xmlel{name = Name, attrs = Attrs, children = Els} = El,\n    Zlib = StateData#state.zlib,\n    TLS = StateData#state.tls,\n    TLSEnabled = StateData#state.tls_enabled,\n    TLSRequired = StateData#state.tls_required,\n    SockMod = (StateData#state.sockmod):get_sockmod(StateData#state.socket),\n    case {xml:get_attr_s(<<\"xmlns\">>, Attrs), Name} of\n\t{?NS_SASL, <<\"auth\">>} when not ((SockMod == gen_tcp) and TLSRequired) ->\n\t    Mech = xml:get_attr_s(<<\"mechanism\">>, Attrs),\n\t    ClientIn = jlib:decode_base64(xml:get_cdata(Els)),\n\t    case cyrsasl:server_start(StateData#state.sasl_state,\n\t\t\t\t      Mech,\n\t\t\t\t      ClientIn) of\n\t\t{ok, Props} ->\n\t\t    (StateData#state.sockmod):reset_stream(\n\t\t      StateData#state.socket),\n\t\t    send_element(StateData,\n\t\t\t\t  #xmlel{name = <<\"success\">>,\n\t\t\t\t         attrs = [{<<\"xmlns\">>, ?NS_SASL}]}),\n\t\t     U = xml:get_attr_s(username, Props),\n\t\t     AuthModule = xml:get_attr_s(auth_module, Props),\n\t\t     ?INFO_MSG(\"(~w) Accepted authentication for ~s by ~p\",\n\t\t\t       [StateData#state.socket, U, AuthModule]),\n\t\t     fsm_next_state(wait_for_stream,\n\t\t\t\t    StateData#state{\n\t\t\t\t      streamid = new_id(),\n\t\t\t\t      authenticated = true,\n\t\t\t\t      auth_module = AuthModule,\n\t\t\t\t      user = U});\n\t\t{continue, ServerOut, NewSASLState} ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"challenge\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlcdata{content = jlib:encode_base64(ServerOut)}]}),\n\t\t    fsm_next_state(wait_for_sasl_response,\n\t\t\t\t   StateData#state{\n\t\t\t\t     sasl_state = NewSASLState});\n\t\t{error, Error, Username} ->\n\t\t    ?INFO_MSG(\n\t\t       \"(~w) Failed authentication for ~s@~s\",\n\t\t       [StateData#state.socket,\n\t\t\tUsername, StateData#state.server]),\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlel{name = Error}]}),\n\t\t    {next_state, wait_for_feature_request, StateData,\n\t\t     ?C2S_OPEN_TIMEOUT};\n\t\t{error, Error} ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlel{name = Error}]}),\n\t\t    fsm_next_state(wait_for_feature_request, StateData)\n\t    end;\n\t{?NS_TLS_BIN, <<\"starttls\">>} when TLS == true,\n\t\t\t\t   TLSEnabled == false,\n\t\t\t\t   SockMod == gen_tcp ->\n\t    TLSOpts = case ejabberd_config:get_local_option(\n\t\t\t     {domain_certfile, StateData#state.server}) of\n\t\t\t  undefined ->\n\t\t\t      StateData#state.tls_options;\n\t\t\t  CertFile ->\n\t\t\t      [{certfile, CertFile} |\n\t\t\t       lists:keydelete(\n\t\t\t\t certfile, 1, StateData#state.tls_options)]\n\t\t      end,\n\t    Socket = StateData#state.socket,\n\t    TLSSocket = (StateData#state.sockmod):starttls(\n\t\t\t  Socket, TLSOpts,\n\t\t\t  xml:element_to_binary(\n\t\t\t     #xmlel{name = <<\"proceed\">>,\n                                    attrs = [{<<\"xmlns\">>, ?NS_TLS}]})),\n\t    fsm_next_state(wait_for_stream,\n\t\t\t   StateData#state{socket = TLSSocket,\n\t\t\t\t\t   streamid = new_id(),\n\t\t\t\t\t   tls_enabled = true\n\t\t\t\t\t  });\n\t{?NS_COMPRESS_BIN, <<\"compress\">>} when Zlib == true,\n\t\t\t\t\t((SockMod == gen_tcp) or\n\t\t\t\t\t (SockMod == tls)) ->\n\t    case xml:get_subtag(El, <<\"method\">>) of\n\t\tfalse ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_COMPRESS}],\n\t\t\t\t        children = [#xmlel{name = <<\"setup-failed\">>}]}),\n\t\t    fsm_next_state(wait_for_feature_request, StateData);\n\t\tMethod ->\n\t\t    case xml:get_tag_cdata(Method) of\n\t\t\t<<\"zlib\">> ->\n\t\t\t    Socket = StateData#state.socket,\n\t\t\t    ZlibSocket = (StateData#state.sockmod):compress(\n\t\t\t\t\t   Socket,\n\t\t\t\t\t   xml:element_to_binary(\n\t\t\t\t\t      #xmlel{name = <<\"compressed\">>,\n\t\t\t\t\t             attrs = [{<<\"xmlns\">>, ?NS_COMPRESS}]})),\n\t\t\t    fsm_next_state(wait_for_stream,\n\t\t\t     StateData#state{socket = ZlibSocket,\n\t\t\t\t\t     streamid = new_id()\n\t\t\t\t\t    });\n\t\t\t_ ->\n\t\t\t    send_element(StateData,\n\t\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_COMPRESS}],\n\t\t\t\t\t        children = [#xmlel{name = <<\"unsupported-method\">>}]}),\n\t\t\t    fsm_next_state(wait_for_feature_request,\n\t\t\t\t\t   StateData)\n\t\t    end\n\t    end;\n\t_ ->\n\t    if\n\t\t(SockMod == gen_tcp) and TLSRequired ->\n\t\t    Lang = StateData#state.lang,\n\t\t    send_element(StateData, ?POLICY_VIOLATION_ERR(\n\t\t\t\t\t       Lang,\n\t\t\t\t\t       \"Use of STARTTLS required\")),\n\t\t    send_trailer(StateData),\n\t\t    {stop, normal, StateData};\n\t\ttrue ->\n\t\t    process_unauthenticated_stanza(StateData, El),\n\t\t    fsm_next_state(wait_for_feature_request, StateData)\n\t    end\n    end;\n\nwait_for_feature_request(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_feature_request({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_feature_request({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_feature_request(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\nwait_for_sasl_response({xmlstreamelement, El}, StateData) ->\n    #xmlel{name = Name, attrs = Attrs, children = Els} = El,\n    case {xml:get_attr_s(<<\"xmlns\">>, Attrs), Name} of\n\t{?NS_SASL, <<\"response\">>} ->\n\t    ClientIn = jlib:decode_base64(xml:get_cdata(Els)),\n\t    case cyrsasl:server_step(StateData#state.sasl_state,\n\t\t\t\t     ClientIn) of\n\t\t{ok, Props} ->\n\t\t    (StateData#state.sockmod):reset_stream(\n\t\t      StateData#state.socket),\n\t\t    send_element(StateData,\n\t\t\t\t  #xmlel{name = <<\"success\">>,\n\t\t\t\t         attrs = [{<<\"xmlns\">>, ?NS_SASL}]}),\n\t\t     U = xml:get_attr_s(username, Props),\n\t\t     AuthModule = xml:get_attr_s(auth_module, Props),\n\t\t     ?INFO_MSG(\"(~w) Accepted authentication for ~s by ~p\",\n\t\t\t       [StateData#state.socket, U, AuthModule]),\n\t\t     fsm_next_state(wait_for_stream,\n\t\t\t\t    StateData#state{\n\t\t\t\t      streamid = new_id(),\n\t\t\t\t      authenticated = true,\n\t\t\t\t      auth_module = AuthModule,\n\t\t\t\t      user = U});\n\t\t{continue, ServerOut, NewSASLState} ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"challenge\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlcdata{content = jlib:encode_base64(ServerOut)}]}),\n\t\t    fsm_next_state(wait_for_sasl_response,\n\t\t     StateData#state{sasl_state = NewSASLState});\n\t\t{error, Error, Username} ->\n\t\t    ?INFO_MSG(\n\t\t       \"(~w) Failed authentication for ~s@~s\",\n\t\t       [StateData#state.socket,\n\t\t\tUsername, StateData#state.server]),\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlel{name = Error}]}),\n\t\t    fsm_next_state(wait_for_feature_request, StateData);\n\t\t{error, Error} ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlel{name = Error}]}),\n\t\t    fsm_next_state(wait_for_feature_request, StateData)\n\t    end;\n\t_ ->\n\t    process_unauthenticated_stanza(StateData, El),\n\t    fsm_next_state(wait_for_feature_request, StateData)\n    end;\n\nwait_for_sasl_response(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_sasl_response({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_sasl_response({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_sasl_response(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\n\nwait_for_bind({xmlstreamelement, El}, StateData) ->\n    case jlib:iq_query_info(El) of\n\t#iq{type = set, xmlns = ?NS_BIND, sub_el = SubEl} = IQ ->\n\t    U = StateData#state.user,\n\t    R1 = xml:get_path_s(SubEl, [{elem, <<\"resource\">>}, cdata]),\n\t    R = case jlib:resourceprep(R1) of\n\t\t    error -> error;\n\t\t    <<>> ->\n                    list_to_binary(lists:concat(\n                                     [randoms:get_string() | tuple_to_list(now())]));\n\t\t    Resource -> Resource\n\t\tend,\n\t    case R of\n\t\terror ->\n\t\t    Err = jlib:make_error_reply(El, ?ERR_BAD_REQUEST),\n\t\t    send_element(StateData, Err),\n\t\t    fsm_next_state(wait_for_bind, StateData);\n\t\t_ ->\n\t\t    JID = jlib:make_jid(U, StateData#state.server, R),\n\t\t    %%Server = StateData#state.server,\n\t\t    %%RosterVersioningFeature =\n\t\t    %%\tejabberd_hooks:run_fold(\n\t\t    %%  roster_get_versioning_feature, Server, [], [Server]),\n\t            %%StreamFeatures = [{xmlel, \"session\",\n\t\t    %%\t\t       [{\"xmlns\", ?NS_SESSION}], []} |\n\t\t    %%\t\t      RosterVersioningFeature],\n\t\t    %%send_element(StateData, {xmlel, \"stream:features\",\n\t\t    %%\t\t\t     [], StreamFeatures}),\n\t\t    Res = IQ#iq{type = result,\n\t\t\t\tsub_el = [#xmlel{name = <<\"bind\">>,\n\t\t\t\t\t         attrs = [{<<\"xmlns\">>, ?NS_BIND}],\n\t\t\t\t\t         children = [#xmlel{name = <<\"jid\">>,\n\t\t\t\t\t                            children = [#xmlcdata{content = jlib:jid_to_binary(JID)}]}]}]},\n\t\t    send_element(StateData, jlib:iq_to_xml(Res)),\n\t\t    fsm_next_state(wait_for_session,\n\t\t\t\t   StateData#state{resource = R, jid = JID})\n\t    end;\n\t_ ->\n\t    fsm_next_state(wait_for_bind, StateData)\n    end;\n\nwait_for_bind(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_bind({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_bind({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_bind(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\n\nwait_for_session({xmlstreamelement, El}, StateData) ->\n    case jlib:iq_query_info(El) of\n\t#iq{type = set, xmlns = ?NS_SESSION} ->\n\t    U = StateData#state.user,\n\t    R = StateData#state.resource,\n\t    JID = StateData#state.jid,\n\t    case acl:match_rule(StateData#state.server,\n\t\t\t\tStateData#state.access, JID) of\n\t\tallow ->\n\t\t    ?INFO_MSG(\"(~w) Opened session for ~s\",\n\t\t\t      [StateData#state.socket,\n\t\t\t       jlib:jid_to_binary(JID)]),\n\t\t    Res = jlib:make_result_iq_reply(El),\n\t\t    send_element(StateData, Res),\n\t\t    change_shaper(StateData, JID),\n\t\t    {Fs, Ts, Pending} = ejabberd_hooks:run_fold(\n                                  roster_get_subscription_lists,\n                                  StateData#state.server,\n                                  {[], [], []},\n                                  [U, StateData#state.server]),\n\t\t    LJID = jlib:jid_tolower(jlib:jid_remove_resource(JID)),\n\t\t    Fs1 = [LJID | Fs],\n\t\t    Ts1 = [LJID | Ts],\n\t\t    PrivList =\n\t\t\tejabberd_hooks:run_fold(\n\t\t\t  privacy_get_user_list, StateData#state.server,\n\t\t\t  #userlist{},\n\t\t\t  [U, StateData#state.server]),\n\t\t    SID = {now(), self()},\n\t\t    Conn = get_conn_type(StateData),\n\t\t    Info = [{ip, StateData#state.ip}, {conn, Conn},\n\t\t\t    {auth_module, StateData#state.auth_module}],\n\t\t    ejabberd_sm:open_session(\n\t\t      SID, U, StateData#state.server, R, Info),\n                    NewStateData =\n                        StateData#state{\n\t\t\t\t     sid = SID,\n\t\t\t\t     conn = Conn,\n\t\t\t\t     pres_f = ?SETS:from_list(Fs1),\n\t\t\t\t     pres_t = ?SETS:from_list(Ts1),\n                     pending_invitations = Pending,\n\t\t\t\t     privacy_list = PrivList},\n\t\t    fsm_next_state_pack(session_established,\n                                        NewStateData);\n\t\t_ ->\n\t\t    ejabberd_hooks:run(forbidden_session_hook,\n\t\t\t\t       StateData#state.server, [JID]),\n\t\t    ?INFO_MSG(\"(~w) Forbidden session for ~s\",\n\t\t\t      [StateData#state.socket,\n\t\t\t       jlib:jid_to_binary(JID)]),\n\t\t    Err = jlib:make_error_reply(El, ?ERR_NOT_ALLOWED),\n\t\t    send_element(StateData, Err),\n\t\t    fsm_next_state(wait_for_session, StateData)\n\t    end;\n\t_ ->\n\t    fsm_next_state(wait_for_session, StateData)\n    end;\n\nwait_for_session(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_session({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_session({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_session(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\nsession_established({xmlstreamelement, El}, StateData) ->\n    FromJID = StateData#state.jid,\n    % Check 'from' attribute in stanza RFC 3920 Section 9.1.2\n    case check_from(El, FromJID) of\n\t'invalid-from' ->\n\t    send_element(StateData, ?INVALID_FROM),\n\t    send_trailer(StateData),\n\t    {stop, normal, StateData};\n\t_NewEl ->\n\t    session_established2(El, StateData)\n    end;\n\n%% We hibernate the process to reduce memory consumption after a\n%% configurable activity timeout\nsession_established(timeout, StateData) ->\n    %% TODO: Options must be stored in state:\n    Options = [],\n    proc_lib:hibernate(?GEN_FSM, enter_loop,\n\t\t       [?MODULE, Options, session_established, StateData]),\n    fsm_next_state(session_established, StateData);\n\nsession_established({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nsession_established({xmlstreamerror, \"XML stanza is too big\" = E}, StateData) ->\n    send_element(StateData, ?POLICY_VIOLATION_ERR(StateData#state.lang, E)),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nsession_established({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nsession_established(closed, StateData) ->\n    {stop, normal, StateData}.\n\n%% Process packets sent by user (coming from user on c2s XMPP\n%% connection)\nsession_established2(El, StateData) ->\n    #xmlel{name = Name, attrs = Attrs} = El,\n    User = StateData#state.user,\n    Server = StateData#state.server,\n    FromJID = StateData#state.jid,\n    To = xml:get_attr_s(<<\"to\">>, Attrs),\n    ToJID = case To of\n\t\t<<>> ->\n\t\t    jlib:make_jid(User, Server, <<>>);\n\t\t_ ->\n\t\t    jlib:binary_to_jid(To)\n\t    end,\n    NewEl1 = jlib:remove_attr(<<\"xmlns\">>, El),\n    NewEl = case xml:get_attr_s(<<\"xml:lang\">>, Attrs) of\n\t\t<<>> ->\n\t\t    case StateData#state.lang of\n\t\t\t<<>> -> NewEl1;\n\t\t\tLang ->\n\t\t\t    xml:replace_tag_attr(<<\"xml:lang\">>, list_to_binary(Lang), NewEl1)\n\t\t    end;\n\t\t_ ->\n\t\t    NewEl1\n\t    end,\n    NewState =\n\tcase ToJID of\n\t    error ->\n\t\tcase xml:get_attr_s(<<\"type\">>, Attrs) of\n\t\t    <<\"error\">> -> StateData;\n\t\t    <<\"result\">> -> StateData;\n\t\t    _ ->\n\t\t\tErr = jlib:make_error_reply(NewEl, ?ERR_JID_MALFORMED),\n\t\t\tsend_element(StateData, Err),\n\t\t\tStateData\n\t\tend;\n\t    _ ->\n\t\tcase Name of\n\t\t    <<\"presence\">> ->\n\t\t\tPresenceEl = ejabberd_hooks:run_fold(\n\t\t\t\t       c2s_update_presence,\n\t\t\t\t       Server,\n\t\t\t\t       NewEl,\n\t\t\t\t       [User, Server]),\n\t\t\tejabberd_hooks:run(\n\t\t\t  user_send_packet,\n\t\t\t  Server,\n\t\t\t  [FromJID, ToJID, PresenceEl]),\n\t\t\tcase ToJID of\n\t\t\t    #jid{user = User,\n\t\t\t\t server = Server,\n\t\t\t\t resource = <<>>} ->\n\t\t\t\t?DEBUG(\"presence_update(~p,~n\\t~p,~n\\t~p)\",\n\t\t\t\t       [FromJID, PresenceEl, StateData]),\n\t\t\t\tpresence_update(FromJID, PresenceEl,\n\t\t\t\t\t\tStateData);\n\t\t\t    _ ->\n\t\t\t\tpresence_track(FromJID, ToJID, PresenceEl,\n\t\t\t\t\t       StateData)\n\t\t\tend;\n\t\t    <<\"iq\">> ->\n\t\t\tcase jlib:iq_query_info(NewEl) of\n\t\t\t    #iq{xmlns = Xmlns} = IQ\n\t\t\t    when Xmlns == ?NS_PRIVACY;\n\t\t\t\t Xmlns == ?NS_BLOCKING ->\n\t\t\t\tprocess_privacy_iq(\n\t\t\t\t  FromJID, ToJID, IQ, StateData);\n\t\t\t    _ ->\n\t\t\t\tejabberd_hooks:run(\n\t\t\t\t  user_send_packet,\n\t\t\t\t  Server,\n\t\t\t\t  [FromJID, ToJID, NewEl]),\n\t\t\t\tcheck_privacy_route(FromJID, StateData, FromJID, ToJID, NewEl),\n\t\t\t\tStateData\n\t\t\tend;\n\t\t    <<\"message\">> ->\n\t\t\tejabberd_hooks:run(user_send_packet,\n\t\t\t\t\t   Server,\n\t\t\t\t\t   [FromJID, ToJID, NewEl]),\n\t\t\tcheck_privacy_route(FromJID, StateData, FromJID,\n\t\t\t\t\t    ToJID, NewEl),\n\t\t\tStateData;\n\t\t    _ ->\n\t\t\tStateData\n\t\tend\n\tend,\n    ejabberd_hooks:run(c2s_loop_debug, [{xmlstreamelement, El}]),\n    fsm_next_state(session_established, NewState).\n\n\n\n%%----------------------------------------------------------------------\n%% Func: StateName/3\n%% Returns: {next_state, NextStateName, NextStateData}            |\n%%          {next_state, NextStateName, NextStateData, Timeout}   |\n%%          {reply, Reply, NextStateName, NextStateData}          |\n%%          {reply, Reply, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}                          |\n%%          {stop, Reason, Reply, NewStateData}\n%%----------------------------------------------------------------------\n%state_name(Event, From, StateData) ->\n%    Reply = ok,\n%    {reply, Reply, state_name, StateData}.\n\n%%----------------------------------------------------------------------\n%% Func: handle_event/3\n%% Returns: {next_state, NextStateName, NextStateData}          |\n%%          {next_state, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}\n%%----------------------------------------------------------------------\nhandle_event(_Event, StateName, StateData) ->\n    fsm_next_state(StateName, StateData).\n\n%%----------------------------------------------------------------------\n%% Func: handle_sync_event/4\n%% Returns: {next_state, NextStateName, NextStateData}            |\n%%          {next_state, NextStateName, NextStateData, Timeout}   |\n%%          {reply, Reply, NextStateName, NextStateData}          |\n%%          {reply, Reply, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}                          |\n%%          {stop, Reason, Reply, NewStateData}\n%%----------------------------------------------------------------------\nhandle_sync_event(get_presence, _From, StateName, StateData) ->\n    User = StateData#state.user,\n    PresLast = StateData#state.pres_last,\n\n    Show = get_showtag(PresLast),\n    Status = get_statustag(PresLast),\n    Resource = StateData#state.resource,\n\n    Reply = {User, Resource, Show, Status},\n    fsm_reply(Reply, StateName, StateData);\n\nhandle_sync_event(get_subscribed, _From, StateName, StateData) ->\n    Subscribed = ?SETS:to_list(StateData#state.pres_f),\n    {reply, Subscribed, StateName, StateData};\n\nhandle_sync_event(_Event, _From, StateName, StateData) ->\n    Reply = ok,\n    fsm_reply(Reply, StateName, StateData).\n\ncode_change(_OldVsn, StateName, StateData, _Extra) ->\n    {ok, StateName, StateData}.\n\n%%----------------------------------------------------------------------\n%% Func: handle_info/3\n%% Returns: {next_state, NextStateName, NextStateData}          |\n%%          {next_state, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}\n%%----------------------------------------------------------------------\nhandle_info({send_text, Text}, StateName, StateData) ->\n    send_text(StateData, Text),\n    ejabberd_hooks:run(c2s_loop_debug, [Text]),\n    fsm_next_state(StateName, StateData);\nhandle_info(replaced, _StateName, StateData) ->\n    Lang = StateData#state.lang,\n    send_element(StateData,\n\t\t ?SERRT_CONFLICT(Lang, \"Replaced by new connection\")),\n    send_trailer(StateData),\n    {stop, normal, StateData#state{authenticated = replaced}};\n%% Process Packets that are to be send to the user\nhandle_info({route, From, To, Packet}, StateName, StateData) ->\n    #xmlel{name = Name, attrs = Attrs, children = Els} = Packet,\n    {Pass, NewAttrs, NewState} =\n\tcase Name of\n\t    <<\"presence\">> ->\n\t\tState = ejabberd_hooks:run_fold(\n\t\t\t  c2s_presence_in, StateData#state.server,\n\t\t\t  StateData,\n\t\t\t  [{From, To, Packet}]),\n\t\tcase xml:get_attr_s(<<\"type\">>, Attrs) of\n\t\t    <<\"probe\">> ->\n\t\t\tLFrom = jlib:jid_tolower(From),\n\t\t\tLBFrom = jlib:jid_remove_resource(LFrom),\n\t\t\tNewStateData =\n\t\t\t    case ?SETS:is_element(\n\t\t\t\t    LFrom, State#state.pres_a) orelse\n\t\t\t\t?SETS:is_element(\n\t\t\t\t   LBFrom, State#state.pres_a) of\n\t\t\t\ttrue ->\n\t\t\t\t    State;\n\t\t\t\tfalse ->\n\t\t\t\t    case ?SETS:is_element(\n\t\t\t\t\t    LFrom, State#state.pres_f) of\n\t\t\t\t\ttrue ->\n\t\t\t\t\t    A = ?SETS:add_element(\n\t\t\t\t\t\t   LFrom,\n\t\t\t\t\t\t   State#state.pres_a),\n\t\t\t\t\t    State#state{pres_a = A};\n\t\t\t\t\tfalse ->\n\t\t\t\t\t    case ?SETS:is_element(\n\t\t\t\t\t\t    LBFrom, State#state.pres_f) of\n\t\t\t\t\t\ttrue ->\n\t\t\t\t\t\t    A = ?SETS:add_element(\n\t\t\t\t\t\t\t   LBFrom,\n\t\t\t\t\t\t\t   State#state.pres_a),\n\t\t\t\t\t\t    State#state{pres_a = A};\n\t\t\t\t\t\tfalse ->\n\t\t\t\t\t\t    State\n\t\t\t\t\t    end\n\t\t\t\t    end\n\t\t\t    end,\n\t\t\tprocess_presence_probe(From, To, NewStateData),\n\t\t\t{false, Attrs, NewStateData};\n\t\t    <<\"error\">> ->\n\t\t\tNewA = remove_element(jlib:jid_tolower(From),\n\t\t\t\t\t      State#state.pres_a),\n\t\t\t{true, Attrs, State#state{pres_a = NewA}};\n\t\t    <<\"invisible\">> ->\n\t\t\tAttrs1 = lists:keydelete(<<\"type\">>, 1, Attrs),\n\t\t\t{true, [{<<\"type\">>, <<\"unavailable\">>} | Attrs1], State};\n\t\t    <<\"subscribe\">> ->\n\t\t\tSRes = is_privacy_allow(State, From, To, Packet, in),\n\t\t\t{SRes, Attrs, State};\n\t\t    <<\"subscribed\">> ->\n\t\t\tSRes = is_privacy_allow(State, From, To, Packet, in),\n\t\t\t{SRes, Attrs, State};\n\t\t    <<\"unsubscribe\">> ->\n\t\t\tSRes = is_privacy_allow(State, From, To, Packet, in),\n\t\t\t{SRes, Attrs, State};\n\t\t    <<\"unsubscribed\">> ->\n\t\t\tSRes = is_privacy_allow(State, From, To, Packet, in),\n\t\t\t{SRes, Attrs, State};\n\t\t    _ ->\n\t\t\tcase privacy_check_packet(State, From, To, Packet, in) of\n\t\t\t    allow ->\n\t\t\t\tLFrom = jlib:jid_tolower(From),\n\t\t\t\tLBFrom = jlib:jid_remove_resource(LFrom),\n\t\t\t\tcase ?SETS:is_element(\n\t\t\t\t\tLFrom, State#state.pres_a) orelse\n\t\t\t\t    ?SETS:is_element(\n\t\t\t\t       LBFrom, State#state.pres_a) of\n\t\t\t\t    true ->\n\t\t\t\t\t{true, Attrs, State};\n\t\t\t\t    false ->\n\t\t\t\t\tcase ?SETS:is_element(\n\t\t\t\t\t\tLFrom, State#state.pres_f) of\n\t\t\t\t\t    true ->\n\t\t\t\t\t\tA = ?SETS:add_element(\n\t\t\t\t\t\t       LFrom,\n\t\t\t\t\t\t       State#state.pres_a),\n\t\t\t\t\t\t{true, Attrs,\n\t\t\t\t\t\t State#state{pres_a = A}};\n\t\t\t\t\t    false ->\n\t\t\t\t\t\tcase ?SETS:is_element(\n\t\t\t\t\t\t\tLBFrom, State#state.pres_f) of\n\t\t\t\t\t\t    true ->\n\t\t\t\t\t\t\tA = ?SETS:add_element(\n\t\t\t\t\t\t\t       LBFrom,\n\t\t\t\t\t\t\t       State#state.pres_a),\n\t\t\t\t\t\t\t{true, Attrs,\n\t\t\t\t\t\t\t State#state{pres_a = A}};\n\t\t\t\t\t\t    false ->\n\t\t\t\t\t\t\t{true, Attrs, State}\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend;\n\t\t\t    deny ->\n\t\t\t\t{false, Attrs, State}\n\t\t\tend\n\t\tend;\n\t    <<\"broadcast\">> ->\n\t\t?DEBUG(\"broadcast~n~p~n\", [Els]),\n\t\tcase Els of\n\t\t    [{item, IJID, ISubscription}] ->\n\t\t\t{false, Attrs,\n\t\t\t roster_change(IJID, ISubscription,\n\t\t\t\t       StateData)};\n\t\t    [{exit, Reason}] ->\n\t\t\t{exit, Attrs, Reason};\n\t\t    [{privacy_list, PrivList, PrivListName}] ->\n\t\t\tcase ejabberd_hooks:run_fold(\n\t\t\t       privacy_updated_list, StateData#state.server,\n\t\t\t       false,\n\t\t\t       [StateData#state.privacy_list,\n\t\t\t\tPrivList]) of\n\t\t\t    false ->\n\t\t\t\t{false, Attrs, StateData};\n\t\t\t    NewPL ->\n\t\t\t\tPrivPushIQ =\n\t\t\t\t    #iq{type = set, xmlns = ?NS_PRIVACY,\n\t\t\t\t\tid = list_to_binary(\"push\" ++ randoms:get_string()),\n\t\t\t\t\tsub_el = [#xmlel{name = <<\"query\">>,\n\t\t\t\t\t\t         attrs = [{<<\"xmlns\">>, ?NS_PRIVACY}],\n\t\t\t\t\t\t         children = [#xmlel{name = <<\"list\">>,\n\t\t\t\t\t\t                            attrs = [{<<\"name\">>, PrivListName}]}]}]},\n\t\t\t\tPrivPushEl =\n\t\t\t\t    jlib:replace_from_to(\n\t\t\t\t      jlib:jid_remove_resource(\n\t\t\t\t\tStateData#state.jid),\n\t\t\t\t      StateData#state.jid,\n\t\t\t\t      jlib:iq_to_xml(PrivPushIQ)),\n\t\t\t\tsend_element(StateData, PrivPushEl),\n\t\t\t\t{false, Attrs, StateData#state{privacy_list = NewPL}}\n\t\t\tend;\n\t\t    [{blocking, What}] ->\n\t\t\troute_blocking(What, StateData),\n\t\t\t{false, Attrs, StateData};\n\t\t    _ ->\n\t\t\t{false, Attrs, StateData}\n\t\tend;\n\t    <<\"iq\">> ->\n\t\tIQ = jlib:iq_query_info(Packet),\n\t\tcase IQ of\n\t\t    #iq{xmlns = ?NS_LAST} ->\n\t\t\tLFrom = jlib:jid_tolower(From),\n\t\t\tLBFrom = jlib:jid_remove_resource(LFrom),\n\t\t\tHasFromSub = (?SETS:is_element(LFrom, StateData#state.pres_f) orelse ?SETS:is_element(LBFrom, StateData#state.pres_f))\n\t\t\t   andalso is_privacy_allow(StateData, To, From, #xmlel{name = <<\"presence\">>}, out),\n\t\t\tcase HasFromSub of\n\t\t\t    true ->\n\t\t\t\tcase privacy_check_packet(StateData, From, To, Packet, in) of\n\t\t\t\t    allow ->\n\t\t\t\t\t{true, Attrs, StateData};\n\t\t\t\t    deny ->\n\t\t\t\t\t{false, Attrs, StateData}\n\t\t\t\tend;\n\t\t\t    _ ->\n\t\t\t\tErr = jlib:make_error_reply(Packet, ?ERR_FORBIDDEN),\n\t\t\t\tejabberd_router:route(To, From, Err),\n\t\t\t\t{false, Attrs, StateData}\n\t\t\tend;\n\t\t    IQ when (is_record(IQ, iq)) or (IQ == reply) ->\n\t\t\tcase privacy_check_packet(StateData, From, To, Packet, in) of\n\t\t\t    allow ->\n\t\t\t\t{true, Attrs, StateData};\n\t\t\t    deny when is_record(IQ, iq) ->\n\t\t\t\tErr = jlib:make_error_reply(\n\t\t\t\t\tPacket, ?ERR_SERVICE_UNAVAILABLE),\n\t\t\t\tejabberd_router:route(To, From, Err),\n\t\t\t\t{false, Attrs, StateData};\n\t\t\t    deny when IQ == reply ->\n\t\t\t\t{false, Attrs, StateData}\n\t\t\tend;\n\t\t    IQ when (IQ == invalid) or (IQ == not_iq) ->\n\t\t\t{false, Attrs, StateData}\n\t\tend;\n\t    <<\"message\">> ->\n\t\tcase privacy_check_packet(StateData, From, To, Packet, in) of\n\t\t    allow ->\n\t\t\t{true, Attrs, StateData};\n\t\t    deny ->\n\t\t\t{false, Attrs, StateData}\n\t\tend;\n\t    _ ->\n\t\t{true, Attrs, StateData}\n\tend,\n    if\n\tPass == exit ->\n\t    %% When Pass==exit, NewState contains a string instead of a #state{}\n\t    Lang = StateData#state.lang,\n\t    send_element(StateData, ?SERRT_CONFLICT(Lang, NewState)),\n\t    send_trailer(StateData),\n\t    {stop, normal, StateData};\n\tPass ->\n\t    Attrs2 = jlib:replace_from_to_attrs(jlib:jid_to_binary(From),\n\t\t\t\t\t\tjlib:jid_to_binary(To),\n\t\t\t\t\t\tNewAttrs),\n\t    FixedPacket = Packet#xmlel{attrs = Attrs2},\n\t    send_element(StateData, FixedPacket),\n\t    ejabberd_hooks:run(user_receive_packet,\n\t\t\t       StateData#state.server,\n\t\t\t       [StateData#state.jid, From, To, FixedPacket]),\n\t    ejabberd_hooks:run(c2s_loop_debug, [{route, From, To, Packet}]),\n\t    fsm_next_state(StateName, NewState);\n\ttrue ->\n\t    ejabberd_hooks:run(c2s_loop_debug, [{route, From, To, Packet}]),\n\t    fsm_next_state(StateName, NewState)\n    end;\nhandle_info({'DOWN', Monitor, _Type, _Object, _Info}, _StateName, StateData)\n  when Monitor == StateData#state.socket_monitor ->\n    {stop, normal, StateData};\nhandle_info(system_shutdown, StateName, StateData) ->\n    case StateName of\n       wait_for_stream ->\n           send_header(StateData, ?MYNAME, \"1.0\", \"en\"),\n           send_element(StateData, ?SERR_SYSTEM_SHUTDOWN),\n           send_trailer(StateData),\n           ok;\n       _ ->\n           send_element(StateData, ?SERR_SYSTEM_SHUTDOWN),\n           send_trailer(StateData),\n           ok\n    end,\n    {stop, normal, StateData};\nhandle_info({force_update_presence, LUser}, StateName,\n            #state{user = LUser, server = LServer} = StateData) ->\n    NewStateData =\n\tcase StateData#state.pres_last of\n\t    #xmlel{name = <<\"presence\">>} ->\n\t\tPresenceEl = ejabberd_hooks:run_fold(\n\t\t\t       c2s_update_presence,\n\t\t\t       LServer,\n\t\t\t       StateData#state.pres_last,\n\t\t\t       [LUser, LServer]),\n\t\tStateData2 = StateData#state{pres_last = PresenceEl},\n\t\tpresence_update(StateData2#state.jid,\n\t\t\t\tPresenceEl,\n\t\t\t\tStateData2),\n\t\tStateData2;\n\t    _ ->\n\t\tStateData\n\tend,\n    {next_state, StateName, NewStateData};\nhandle_info({broadcast, Type, From, Packet}, StateName, StateData) ->\n    Recipients = ejabberd_hooks:run_fold(\n\t\t   c2s_broadcast_recipients, StateData#state.server,\n\t\t   [],\n\t\t   [StateData, Type, From, Packet]),\n    lists:foreach(\n      fun(USR) ->\n\t      ejabberd_router:route(\n\t\tFrom, jlib:make_jid(USR), Packet)\n      end, lists:usort(Recipients)),\n    fsm_next_state(StateName, StateData);\nhandle_info(Info, StateName, StateData) ->\n    ?ERROR_MSG(\"Unexpected info: ~p\", [Info]),\n    fsm_next_state(StateName, StateData).\n\n\n%%----------------------------------------------------------------------\n%% Func: print_state/1\n%% Purpose: Prepare the state to be printed on error log\n%% Returns: State to print\n%%----------------------------------------------------------------------\nprint_state(State = #state{pres_t = T, pres_f = F, pres_a = A, pres_i = I}) ->\n   State#state{pres_t = {pres_t, ?SETS:size(T)},\n               pres_f = {pres_f, ?SETS:size(F)},\n               pres_a = {pres_a, ?SETS:size(A)},\n               pres_i = {pres_i, ?SETS:size(I)}\n               }.\n\n%%----------------------------------------------------------------------\n%% Func: terminate/3\n%% Purpose: Shutdown the fsm\n%% Returns: any\n%%----------------------------------------------------------------------\nterminate(_Reason, StateName, StateData) ->\n    case StateName of\n\tsession_established ->\n\t    case StateData#state.authenticated of\n\t\treplaced ->\n\t\t    ?INFO_MSG(\"(~w) Replaced session for ~s\",\n\t\t\t      [StateData#state.socket,\n\t\t\t       jlib:jid_to_binary(StateData#state.jid)]),\n\t\t    From = StateData#state.jid,\n\t\t    Packet = #xmlel{name = <<\"presence\">>,\n\t\t\t            attrs = [{<<\"type\">>, <<\"unavailable\">>}],\n\t\t\t            children = [#xmlel{name = <<\"status\">>,\n\t\t\t\t                       children = [#xmlcdata{content = \"Replaced by new connection\"}]}]},\n\t\t    ejabberd_sm:close_session_unset_presence(\n\t\t      StateData#state.sid,\n\t\t      StateData#state.user,\n\t\t      StateData#state.server,\n\t\t      StateData#state.resource,\n\t\t      \"Replaced by new connection\"),\n\t\t    presence_broadcast(\n\t\t      StateData, From, StateData#state.pres_a, Packet),\n\t\t    presence_broadcast(\n\t\t      StateData, From, StateData#state.pres_i, Packet);\n\t\t_ ->\n\t\t    ?INFO_MSG(\"(~w) Close session for ~s\",\n\t\t\t      [StateData#state.socket,\n\t\t\t       jlib:jid_to_binary(StateData#state.jid)]),\n\n\t\t    EmptySet = ?SETS:new(),\n\t\t    case StateData of\n\t\t\t#state{pres_last = undefined,\n\t\t\t       pres_a = EmptySet,\n\t\t\t       pres_i = EmptySet,\n\t\t\t       pres_invis = false} ->\n\t\t\t    ejabberd_sm:close_session(StateData#state.sid,\n\t\t\t\t\t\t      StateData#state.user,\n\t\t\t\t\t\t      StateData#state.server,\n\t\t\t\t\t\t      StateData#state.resource);\n\t\t\t_ ->\n\t\t\t    From = StateData#state.jid,\n\t\t\t    Packet = #xmlel{name = <<\"presence\">>,\n\t\t\t\t            attrs = [{<<\"type\">>, <<\"unavailable\">>}]},\n\t\t\t    ejabberd_sm:close_session_unset_presence(\n\t\t\t      StateData#state.sid,\n\t\t\t      StateData#state.user,\n\t\t\t      StateData#state.server,\n\t\t\t      StateData#state.resource,\n\t\t\t      \"\"),\n\t\t\t    presence_broadcast(\n\t\t\t      StateData, From, StateData#state.pres_a, Packet),\n\t\t\t    presence_broadcast(\n\t\t\t      StateData, From, StateData#state.pres_i, Packet)\n\t\t    end\n\t    end,\n\t    bounce_messages();\n\t_ ->\n\t    ok\n    end,\n    (StateData#state.sockmod):close(StateData#state.socket),\n    ok.\n\n%%%----------------------------------------------------------------------\n%%% Internal functions\n%%%----------------------------------------------------------------------\n\nchange_shaper(StateData, JID) ->\n    Shaper = acl:match_rule(StateData#state.server,\n\t\t\t    StateData#state.shaper, JID),\n    (StateData#state.sockmod):change_shaper(StateData#state.socket, Shaper).\n\nsend_text(StateData, Text) when StateData#state.xml_socket ->\n    ?DEBUG(\"Send Text on stream = ~p\", [lists:flatten(Text)]),\n    (StateData#state.sockmod):send_xml(StateData#state.socket,\n\t\t\t\t       {xmlstreamraw, Text});\nsend_text(StateData, Text) ->\n    ?DEBUG(\"Send XML on stream = ~p\", [Text]),\n    (StateData#state.sockmod):send(StateData#state.socket, Text).\n\nsend_element(#state{server = Server, sockmod = SockMod} = StateData, El)\n\t\twhen StateData#state.xml_socket ->\n    ejabberd_hooks:run(xmpp_send_element,\n                       Server, [Server, El]),\n    SockMod:send_xml(StateData#state.socket,\n\t\t\t\t       {xmlstreamelement, El});\nsend_element(#state{server = Server} = StateData, El) ->\n    ejabberd_hooks:run(xmpp_send_element,\n                       Server, [Server, El]),\n    send_text(StateData, xml:element_to_binary(El)).\n\nsend_header(StateData, Server, Version, Lang)\n  when StateData#state.xml_socket ->\n    VersionAttr =\n\tcase Version of\n\t    \"\" -> [];\n\t    _ -> [{<<\"version\">>, Version}]\n\tend,\n    LangAttr =\n\tcase Lang of\n\t    \"\" -> [];\n\t    _ -> [{<<\"xml:lang\">>, Lang}]\n\tend,\n    Header =\n\t{xmlstreamstart,\n\t <<\"stream:stream\">>,\n\t VersionAttr ++\n\t LangAttr ++\n\t [{<<\"xmlns\">>, <<\"jabber:client\">>},\n\t  {<<\"xmlns:stream\">>, <<\"http://etherx.jabber.org/streams\">>},\n\t  {<<\"id\">>, StateData#state.streamid},\n\t  {<<\"from\">>, Server}]},\n    (StateData#state.sockmod):send_xml(\n      StateData#state.socket, Header);\nsend_header(StateData, Server, Version, Lang) ->\n    VersionStr =\n\tcase Version of\n\t    \"\" -> \"\";\n\t    _ -> [\" version='\", Version, \"'\"]\n\tend,\n    LangStr =\n\tcase Lang of\n\t    \"\" -> \"\";\n\t    _ -> [\" xml:lang='\", Lang, \"'\"]\n\tend,\n    Header = io_lib:format(?STREAM_HEADER,\n\t\t\t   [StateData#state.streamid,\n\t\t\t    Server,\n\t\t\t    VersionStr,\n\t\t\t    LangStr]),\n    send_text(StateData, Header).\n\nsend_trailer(StateData) when StateData#state.xml_socket ->\n    (StateData#state.sockmod):send_xml(\n      StateData#state.socket,\n      {xmlstreamend, <<\"stream:stream\">>});\nsend_trailer(StateData) ->\n    send_text(StateData, ?STREAM_TRAILER).\n\n\nnew_id() ->\n    randoms:get_string().\n\n\nis_auth_packet(El) ->\n    case jlib:iq_query_info(El) of\n\t#iq{id = ID, type = Type, xmlns = ?NS_AUTH, sub_el = SubEl} ->\n\t    #xmlel{children = Els} = SubEl,\n\t    {auth, ID, Type,\n\t     get_auth_tags(Els, <<>>, <<>>, <<>>, <<>>)};\n\t_ ->\n\t    false\n    end.\n\n\nget_auth_tags([#xmlel{name = Name, children = Els}| L], U, P, D, R) ->\n    CData = xml:get_cdata(Els),\n    case Name of\n\t<<\"username\">> ->\n\t    get_auth_tags(L, CData, P, D, R);\n\t<<\"password\">> ->\n\t    get_auth_tags(L, U, CData, D, R);\n\t<<\"digest\">> ->\n\t    get_auth_tags(L, U, P, CData, R);\n\t<<\"resource\">> ->\n\t    get_auth_tags(L, U, P, D, CData);\n\t_ ->\n\t    get_auth_tags(L, U, P, D, R)\n    end;\nget_auth_tags([_ | L], U, P, D, R) ->\n    get_auth_tags(L, U, P, D, R);\nget_auth_tags([], U, P, D, R) ->\n    {U, P, D, R}.\n\n%% Copied from ejabberd_socket.erl\n-record(socket_state, {sockmod, socket, receiver}).\n\nget_conn_type(StateData) ->\n    case (StateData#state.sockmod):get_sockmod(StateData#state.socket) of\n    gen_tcp -> c2s;\n    ejabberd_tls -> c2s_tls;\n    ejabberd_zlib ->\n\tcase ejabberd_zlib:get_sockmod((StateData#state.socket)#socket_state.socket) of\n\t    gen_tcp -> c2s_compressed;\n\t    ejabberd_tls -> c2s_compressed_tls\n\tend;\n    ejabberd_http_poll -> http_poll;\n    ejabberd_http_bind -> http_bind;\n    _ -> unknown\n    end.\n\nprocess_presence_probe(From, To, StateData) ->\n    LFrom = jlib:jid_tolower(From),\n    LBFrom = setelement(3, LFrom, <<>>),\n    case StateData#state.pres_last of\n\tundefined ->\n\t    ok;\n\t_ ->\n\t    Cond1 = (not StateData#state.pres_invis)\n\t\tandalso (?SETS:is_element(LFrom, StateData#state.pres_f)\n\t\t\t orelse\n\t\t\t ((LFrom /= LBFrom) andalso\n\t\t\t  ?SETS:is_element(LBFrom, StateData#state.pres_f)))\n\t\tandalso (not\n\t\t\t (?SETS:is_element(LFrom, StateData#state.pres_i)\n\t\t\t  orelse\n\t\t\t  ((LFrom /= LBFrom) andalso\n\t\t\t   ?SETS:is_element(LBFrom, StateData#state.pres_i)))),\n\t    Cond2 = StateData#state.pres_invis\n\t\tandalso ?SETS:is_element(LFrom, StateData#state.pres_f)\n\t\tandalso ?SETS:is_element(LFrom, StateData#state.pres_a),\n\t    if\n\t\tCond1 ->\n\t\t    Timestamp = StateData#state.pres_timestamp,\n\t\t    Packet = xml:append_subtags(\n\t\t\t       StateData#state.pres_last,\n\t\t\t       %% To is the one sending the presence (the target of the probe)\n\t\t\t       [jlib:timestamp_to_xml(Timestamp, utc, To, <<>>),\n\t\t\t\t%% TODO: Delete the next line once XEP-0091 is Obsolete\n\t\t\t\tjlib:timestamp_to_xml(Timestamp)]),\n\t\t    case privacy_check_packet(StateData, To, From, Packet, out) of\n\t\t\tdeny ->\n\t\t\t    ok;\n\t\t\tallow ->\n\t\t\t    Pid=element(2, StateData#state.sid),\n\t\t\t    ejabberd_hooks:run(presence_probe_hook, StateData#state.server, [From, To, Pid]),\n\t\t\t    %% Don't route a presence probe to oneself\n\t\t\t    case From == To of\n\t\t\t\tfalse ->\n\t\t\t\t    ejabberd_router:route(To, From, Packet);\n\t\t\t    \ttrue ->\n\t\t\t\t    ok\n\t\t\t    end\n\t\t    end;\n\t\tCond2 ->\n\t\t    ejabberd_router:route(To, From,\n\t\t\t\t\t  #xmlel{name = <<\"presence\">>});\n\t\ttrue ->\n\t\t    ok\n\t    end\n    end.\n\n%% User updates his presence (non-directed presence packet)\npresence_update(From, Packet, StateData) ->\n    #xmlel{attrs = Attrs} = Packet,\n    case xml:get_attr_s(<<\"type\">>, Attrs) of\n\t<<\"unavailable\">> ->\n\t    Status = case xml:get_subtag(Packet, <<\"status\">>) of\n\t\t\t false ->\n\t\t\t    <<>>;\n\t\t\t StatusTag ->\n\t\t\t    xml:get_tag_cdata(StatusTag)\n\t\t     end,\n\t    Info = [{ip, StateData#state.ip}, {conn, StateData#state.conn},\n\t\t    {auth_module, StateData#state.auth_module}],\n\t    ejabberd_sm:unset_presence(StateData#state.sid,\n\t\t\t\t       StateData#state.user,\n\t\t\t\t       StateData#state.server,\n\t\t\t\t       StateData#state.resource,\n\t\t\t\t       Status,\n\t\t\t\t       Info),\n\t    presence_broadcast(StateData, From, StateData#state.pres_a, Packet),\n\t    presence_broadcast(StateData, From, StateData#state.pres_i, Packet),\n\t    StateData#state{pres_last = undefined,\n\t\t\t    pres_timestamp = undefined,\n\t\t\t    pres_a = ?SETS:new(),\n\t\t\t    pres_i = ?SETS:new(),\n\t\t\t    pres_invis = false};\n\t<<\"invisible\">> ->\n\t    NewPriority = get_priority_from_presence(Packet),\n\t    update_priority(NewPriority, Packet, StateData),\n\t    NewState =\n\t\tif\n\t\t    not StateData#state.pres_invis ->\n\t\t\tpresence_broadcast(StateData, From,\n\t\t\t\t\t   StateData#state.pres_a,\n\t\t\t\t\t   Packet),\n\t\t\tpresence_broadcast(StateData, From,\n\t\t\t\t\t   StateData#state.pres_i,\n\t\t\t\t\t   Packet),\n\t\t\tS1 = StateData#state{pres_last = undefined,\n\t\t\t\t\t     pres_timestamp = undefined,\n\t\t\t\t\t     pres_a = ?SETS:new(),\n\t\t\t\t\t     pres_i = ?SETS:new(),\n\t\t\t\t\t     pres_invis = true},\n\t\t\tpresence_broadcast_first(From, S1, Packet);\n\t\t    true ->\n\t\t\tStateData\n\t\tend,\n\t    NewState;\n\t<<\"error\">> ->\n\t    StateData;\n\t<<\"probe\">> ->\n\t    StateData;\n\t<<\"subscribe\">> ->\n\t    StateData;\n\t<<\"subscribed\">> ->\n\t    StateData;\n\t<<\"unsubscribe\">> ->\n\t    StateData;\n\t<<\"unsubscribed\">> ->\n\t    StateData;\n\t_ ->\n\t    OldPriority = case StateData#state.pres_last of\n\t\t\t      undefined ->\n\t\t\t\t  0;\n\t\t\t      OldPresence ->\n\t\t\t\t  get_priority_from_presence(OldPresence)\n\t\t\t  end,\n\t    NewPriority = get_priority_from_presence(Packet),\n\t    Timestamp = calendar:now_to_universal_time(os:timestamp()),\n\t    update_priority(NewPriority, Packet, StateData),\n\t    FromUnavail = (StateData#state.pres_last == undefined) or\n\t\tStateData#state.pres_invis,\n\t    ?DEBUG(\"from unavail = ~p~n\", [FromUnavail]),\n        NewStateData = StateData#state{pres_last = Packet,\n                                       pres_invis = false,\n                                       pres_timestamp = Timestamp},\n\t\tif\n\t\t    FromUnavail ->\n\t\t\tejabberd_hooks:run(user_available_hook,\n\t\t\t\t\t   NewStateData#state.server,\n\t\t\t\t\t   [NewStateData#state.jid]),\n\t\t\tNewStateData1 = if NewPriority >= 0 ->\n                                    resend_offline_messages(NewStateData),\n                                    resend_subscription_requests(NewStateData);\n                               true ->\n                                    NewStateData\n                            end,\n\t\t\tpresence_broadcast_first(From, NewStateData1, Packet);\n\t\t    true ->\n\t\t\tpresence_broadcast_to_trusted(NewStateData,\n\t\t\t\t\t\t      From,\n\t\t\t\t\t\t      NewStateData#state.pres_f,\n\t\t\t\t\t\t      NewStateData#state.pres_a,\n\t\t\t\t\t\t      Packet),\n\t\t\tif OldPriority < 0, NewPriority >= 0 ->\n\t\t\t\tresend_offline_messages(NewStateData);\n\t\t\t   true ->\n\t\t\t\tok\n\t\t\tend,\n            NewStateData\n\t\tend\n    end.\n\n%% User sends a directed presence packet\npresence_track(From, To, Packet, StateData) ->\n    #xmlel{attrs = Attrs} = Packet,\n    LTo = jlib:jid_tolower(To),\n    User = StateData#state.user,\n    Server = StateData#state.server,\n    case xml:get_attr_s(<<\"type\">>, Attrs) of\n\t<<\"unavailable\">> ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    I = remove_element(LTo, StateData#state.pres_i),\n\t    A = remove_element(LTo, StateData#state.pres_a),\n\t    StateData#state{pres_i = I,\n\t\t\t    pres_a = A};\n\t<<\"invisible\">> ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    I = ?SETS:add_element(LTo, StateData#state.pres_i),\n\t    A = remove_element(LTo, StateData#state.pres_a),\n\t    StateData#state{pres_i = I,\n\t\t\t    pres_a = A};\n\t<<\"subscribe\">> ->\n\t    ejabberd_hooks:run(roster_out_subscription,\n\t\t\t       Server,\n\t\t\t       [User, Server, To, subscribe]),\n\t    check_privacy_route(From, StateData, jlib:jid_remove_resource(From),\n\t\t\t\tTo, Packet),\n\t    StateData;\n\t<<\"subscribed\">> ->\n\t    ejabberd_hooks:run(roster_out_subscription,\n\t\t\t       Server,\n\t\t\t       [User, Server, To, subscribed]),\n\t    check_privacy_route(From, StateData, jlib:jid_remove_resource(From),\n\t\t\t\tTo, Packet),\n\t    StateData;\n\t<<\"unsubscribe\">> ->\n\t    ejabberd_hooks:run(roster_out_subscription,\n\t\t\t       Server,\n\t\t\t       [User, Server, To, unsubscribe]),\n\t    check_privacy_route(From, StateData, jlib:jid_remove_resource(From),\n\t\t\t\tTo, Packet),\n\t    StateData;\n\t<<\"unsubscribed\">> ->\n\t    ejabberd_hooks:run(roster_out_subscription,\n\t\t\t       Server,\n\t\t\t       [User, Server, To, unsubscribed]),\n\t    check_privacy_route(From, StateData, jlib:jid_remove_resource(From),\n\t\t\t\tTo, Packet),\n\t    StateData;\n\t<<\"error\">> ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    StateData;\n\t<<\"probe\">> ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    StateData;\n\t_ ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    I = remove_element(LTo, StateData#state.pres_i),\n\t    A = ?SETS:add_element(LTo, StateData#state.pres_a),\n\t    StateData#state{pres_i = I,\n\t\t\t    pres_a = A}\n    end.\n\ncheck_privacy_route(From, StateData, FromRoute, To, Packet) ->\n    case privacy_check_packet(StateData, From, To, Packet, out) of\n\tdeny ->\n\t    Lang = StateData#state.lang,\n\t    ErrText = \"Your active privacy list has denied the routing of this stanza.\",\n\t    Err = jlib:make_error_reply(Packet, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText)),\n\t    ejabberd_router:route(To, From, Err),\n\t    ok;\n\tallow ->\n\t    ejabberd_router:route(FromRoute, To, Packet)\n    end.\n\nprivacy_check_packet(StateData, From, To, Packet, Dir) ->\n    ejabberd_hooks:run_fold(\n      privacy_check_packet, StateData#state.server,\n      allow,\n      [StateData#state.user,\n       StateData#state.server,\n       StateData#state.privacy_list,\n       {From, To, Packet},\n       Dir]).\n\n%% Check if privacy rules allow this delivery\nis_privacy_allow(StateData, From, To, Packet, Dir) ->\n    allow == privacy_check_packet(StateData, From, To, Packet, Dir).\n\npresence_broadcast(StateData, From, JIDSet, Packet) ->\n    lists:foreach(fun(JID) ->\n\t\t\t  FJID = jlib:make_jid(JID),\n\t\t\t  case privacy_check_packet(StateData, From, FJID, Packet, out) of\n\t\t\t      deny ->\n\t\t\t\t  ok;\n\t\t\t      allow ->\n\t\t\t\t  ejabberd_router:route(From, FJID, Packet)\n\t\t\t  end\n\t\t  end, ?SETS:to_list(JIDSet)).\n\npresence_broadcast_to_trusted(StateData, From, T, A, Packet) ->\n    lists:foreach(\n      fun(JID) ->\n\t      case ?SETS:is_element(JID, T) of\n\t\t  true ->\n\t\t      FJID = jlib:make_jid(JID),\n\t\t      case privacy_check_packet(StateData, From, FJID, Packet, out) of\n\t\t\t  deny ->\n\t\t\t      ok;\n\t\t\t  allow ->\n\t\t\t      ejabberd_router:route(From, FJID, Packet)\n\t\t      end;\n\t\t  _ ->\n\t\t      ok\n\t      end\n      end, ?SETS:to_list(A)).\n\n\npresence_broadcast_first(From, StateData, Packet) ->\n    ?SETS:fold(fun(JID, X) ->\n\t\t       ejabberd_router:route(\n\t\t\t From,\n\t\t\t jlib:make_jid(JID),\n\t\t\t #xmlel{name = <<\"presence\">>,\n\t\t\t        attrs = [{<<\"type\">>, <<\"probe\">>}]}),\n\t\t       X\n\t       end,\n\t       [],\n\t       StateData#state.pres_t),\n    if\n\tStateData#state.pres_invis ->\n\t    StateData;\n\ttrue ->\n\t    As = ?SETS:fold(\n\t\t    fun(JID, A) ->\n\t\t\t    FJID = jlib:make_jid(JID),\n\t\t\t    case privacy_check_packet(StateData, From, FJID, Packet, out) of\n\t\t\t\tdeny ->\n\t\t\t\t    ok;\n\t\t\t\tallow ->\n\t\t\t\t    ejabberd_router:route(From, FJID, Packet)\n\t\t\t    end,\n\t\t\t    ?SETS:add_element(JID, A)\n\t\t    end,\n\t\t    StateData#state.pres_a,\n\t\t    StateData#state.pres_f),\n\t    StateData#state{pres_a = As}\n    end.\n\n\nremove_element(E, Set) ->\n    case ?SETS:is_element(E, Set) of\n\ttrue ->\n\t    ?SETS:del_element(E, Set);\n\t_ ->\n\t    Set\n    end.\n\n\nroster_change(IJID, ISubscription, StateData) ->\n    LIJID = jlib:jid_tolower(IJID),\n    IsFrom = (ISubscription == both) or (ISubscription == from),\n    IsTo   = (ISubscription == both) or (ISubscription == to),\n    OldIsFrom = ?SETS:is_element(LIJID, StateData#state.pres_f),\n    FSet = if\n\t       IsFrom ->\n\t\t   ?SETS:add_element(LIJID, StateData#state.pres_f);\n\t       true ->\n\t\t   remove_element(LIJID, StateData#state.pres_f)\n\t   end,\n    TSet = if\n\t       IsTo ->\n\t\t   ?SETS:add_element(LIJID, StateData#state.pres_t);\n\t       true ->\n\t\t   remove_element(LIJID, StateData#state.pres_t)\n\t   end,\n    case StateData#state.pres_last of\n\tundefined ->\n\t    StateData#state{pres_f = FSet, pres_t = TSet};\n\tP ->\n\t    ?DEBUG(\"roster changed for ~p~n\", [StateData#state.user]),\n\t    From = StateData#state.jid,\n\t    To = jlib:make_jid(IJID),\n\t    Cond1 = (not StateData#state.pres_invis) and IsFrom\n\t\tand (not OldIsFrom),\n\t    Cond2 = (not IsFrom) and OldIsFrom\n\t\tand (?SETS:is_element(LIJID, StateData#state.pres_a) or\n\t\t     ?SETS:is_element(LIJID, StateData#state.pres_i)),\n\t    if\n\t\tCond1 ->\n\t\t    ?DEBUG(\"C1: ~p~n\", [LIJID]),\n\t\t    case privacy_check_packet(StateData, From, To, P, out) of\n\t\t\tdeny ->\n\t\t\t    ok;\n\t\t\tallow ->\n\t\t\t    ejabberd_router:route(From, To, P)\n\t\t    end,\n\t\t    A = ?SETS:add_element(LIJID,\n\t\t\t\t\t  StateData#state.pres_a),\n\t\t    StateData#state{pres_a = A,\n\t\t\t\t    pres_f = FSet,\n\t\t\t\t    pres_t = TSet};\n\t\tCond2 ->\n\t\t    ?DEBUG(\"C2: ~p~n\", [LIJID]),\n\t\t    PU = #xmlel{name = <<\"presence\">>,\n\t\t\t        attrs = [{<<\"type\">>, <<\"unavailable\">>}]},\n\t\t    case privacy_check_packet(StateData, From, To, PU, out) of\n\t\t\tdeny ->\n\t\t\t    ok;\n\t\t\tallow ->\n\t\t\t    ejabberd_router:route(From, To, PU)\n\t\t    end,\n\t\t    I = remove_element(LIJID,\n\t\t\t\t       StateData#state.pres_i),\n\t\t    A = remove_element(LIJID,\n\t\t\t\t       StateData#state.pres_a),\n\t\t    StateData#state{pres_i = I,\n\t\t\t\t    pres_a = A,\n\t\t\t\t    pres_f = FSet,\n\t\t\t\t    pres_t = TSet};\n\t\ttrue ->\n\t\t    StateData#state{pres_f = FSet, pres_t = TSet}\n\t    end\n    end.\n\n\nupdate_priority(Priority, Packet, StateData) ->\n    Info = [{ip, StateData#state.ip}, {conn, StateData#state.conn},\n\t    {auth_module, StateData#state.auth_module}],\n    ejabberd_sm:set_presence(StateData#state.sid,\n\t\t\t     StateData#state.user,\n\t\t\t     StateData#state.server,\n\t\t\t     StateData#state.resource,\n\t\t\t     Priority,\n\t\t\t     Packet,\n\t\t\t     Info).\n\nget_priority_from_presence(PresencePacket) ->\n    case xml:get_subtag(PresencePacket, <<\"priority\">>) of\n\tfalse ->\n\t    0;\n\tSubEl ->\n        case catch list_to_integer(binary_to_list(xml:get_tag_cdata(SubEl))) of\n\t\tP when is_integer(P) ->\n\t\t    P;\n\t\t_ ->\n\t\t    0\n\t    end\n    end.\n\nprocess_privacy_iq(From, To,\n\t\t   #iq{type = Type, sub_el = SubEl} = IQ,\n\t\t   StateData) ->\n    {Res, NewStateData} =\n\tcase Type of\n\t    get ->\n\t\tR = ejabberd_hooks:run_fold(\n\t\t      privacy_iq_get, StateData#state.server,\n\t\t      {error, ?ERR_FEATURE_NOT_IMPLEMENTED},\n\t\t      [From, To, IQ, StateData#state.privacy_list]),\n\t\t{R, StateData};\n\t    set ->\n\t\tcase ejabberd_hooks:run_fold(\n\t\t       privacy_iq_set, StateData#state.server,\n\t\t       {error, ?ERR_FEATURE_NOT_IMPLEMENTED},\n\t\t       [From, To, IQ]) of\n\t\t    {result, R, NewPrivList} ->\n\t\t\t{{result, R},\n\t\t\t StateData#state{privacy_list = NewPrivList}};\n\t\t    R -> {R, StateData}\n\t\tend\n\tend,\n    IQRes =\n\tcase Res of\n\t    {result, Result} ->\n\t\tIQ#iq{type = result, sub_el = Result};\n\t    {error, Error} ->\n\t\tIQ#iq{type = error, sub_el = [SubEl, Error]}\n\tend,\n    ejabberd_router:route(\n      To, From, jlib:iq_to_xml(IQRes)),\n    NewStateData.\n\n\nresend_offline_messages(StateData) ->\n    case ejabberd_hooks:run_fold(\n\t   resend_offline_messages_hook, StateData#state.server,\n\t   [],\n\t   [StateData#state.user, StateData#state.server]) of\n\tRs when is_list(Rs) ->\n\t    lists:foreach(\n\t      fun({route,\n\t\t   From, To, #xmlel{} = Packet}) ->\n\t\t      Pass = case privacy_check_packet(StateData, From, To, Packet, in) of\n\t\t\t\t allow ->\n\t\t\t\t     true;\n\t\t\t\t deny ->\n\t\t\t\t     false\n\t\t\t     end,\n\t\t      if\n\t\t\t  Pass ->\n\t\t\t      %% Attrs2 = jlib:replace_from_to_attrs(\n\t\t\t      %%\t\t jlib:jid_to_binary(From),\n\t\t\t      %%\t\t jlib:jid_to_binary(To),\n\t\t\t      %%\t\t Attrs),\n\t\t\t      %% FixedPacket = {xmlel, Name, Attrs2, Els},\n                              %% Use route instead of send_element to go through standard workflow\n                              ejabberd_router:route(From, To, Packet);\n\t\t\t      %% send_element(StateData, FixedPacket),\n\t\t\t      %% ejabberd_hooks:run(user_receive_packet,\n\t\t\t      %%\t\t\t StateData#state.server,\n\t\t\t      %%\t\t\t [StateData#state.jid,\n\t\t\t      %%\t\t\t  From, To, FixedPacket]);\n\t\t\t  true ->\n\t\t\t      ok\n\t\t      end\n\t      end, Rs)\n    end.\n\nresend_subscription_requests(#state{pending_invitations = Pending} = StateData) ->\n    lists:foreach(fun(XMLPacket) ->\n\t\t\t  send_element(StateData,\n\t\t\t\t       XMLPacket)\n\t\t  end, Pending),\n    StateData#state{pending_invitations = []}.\n\nget_showtag(undefined) ->\n    <<\"unavailable\">>;\nget_showtag(Presence) ->\n    case xml:get_path_s(Presence, [{elem, <<\"show\">>}, cdata]) of\n\t<<>>      -> <<\"available\">>;\n\tShowTag -> ShowTag\n    end.\n\nget_statustag(undefined) ->\n    <<>>;\nget_statustag(Presence) ->\n    case xml:get_path_s(Presence, [{elem, <<\"status\">>}, cdata]) of\n\tShowTag -> ShowTag\n    end.\n\nprocess_unauthenticated_stanza(StateData, El) ->\n    NewEl = case xml:get_tag_attr_s(<<\"xml:lang\">>, El) of\n\t\t<<>> ->\n\t\t    case StateData#state.lang of\n\t\t\t<<>> -> El;\n\t\t\tLang ->\n\t\t\t    xml:replace_tag_attr(<<\"xml:lang\">>, list_to_binary(Lang), El)\n\t\t    end;\n\t\t_ ->\n\t\t    El\n\t    end,\n    case jlib:iq_query_info(NewEl) of\n\t#iq{} = IQ ->\n\t    Res = ejabberd_hooks:run_fold(c2s_unauthenticated_iq,\n\t\t\t\t\t  StateData#state.server,\n\t\t\t\t\t  empty,\n\t\t\t\t\t  [StateData#state.server, IQ,\n\t\t\t\t\t   StateData#state.ip]),\n\t    case Res of\n\t\tempty ->\n\t\t    % The only reasonable IQ's here are auth and register IQ's\n\t\t    % They contain secrets, so don't include subelements to responsec\n\t\t    ResIQ = IQ#iq{type = error,\n\t\t\t\t  sub_el = [?ERR_SERVICE_UNAVAILABLE]},\n\t\t    Res1 = jlib:replace_from_to(\n\t\t\t     jlib:make_jid(<<>>, StateData#state.server, <<>>),\n\t\t\t     jlib:make_jid(<<>>, <<>>, <<>>),\n\t\t\t     jlib:iq_to_xml(ResIQ)),\n\t\t    send_element(StateData, jlib:remove_attr(<<\"to\">>, Res1));\n\t\t_ ->\n\t\t    send_element(StateData, Res)\n\t    end;\n\t_ ->\n\t    % Drop any stanza, which isn't IQ stanza\n\t    ok\n    end.\n\npeerip(SockMod, Socket) ->\n    IP = case SockMod of\n\t     gen_tcp -> inet:peername(Socket);\n\t     _ -> SockMod:peername(Socket)\n\t end,\n    case IP of\n\t{ok, IPOK} -> IPOK;\n\t_ -> undefined\n    end.\n\n%% fsm_next_state_pack: Pack the StateData structure to improve\n%% sharing.\nfsm_next_state_pack(StateName, StateData) ->\n    fsm_next_state_gc(StateName, pack(StateData)).\n\n%% fsm_next_state_gc: Garbage collect the process heap to make use of\n%% the newly packed StateData structure.\nfsm_next_state_gc(StateName, PackedStateData) ->\n    erlang:garbage_collect(),\n    fsm_next_state(StateName, PackedStateData).\n\n%% fsm_next_state: Generate the next_state FSM tuple with different\n%% timeout, depending on the future state\nfsm_next_state(session_established, StateData) ->\n    {next_state, session_established, StateData, ?C2S_HIBERNATE_TIMEOUT};\nfsm_next_state(StateName, StateData) ->\n    {next_state, StateName, StateData, ?C2S_OPEN_TIMEOUT}.\n\n%% fsm_reply: Generate the reply FSM tuple with different timeout,\n%% depending on the future state\nfsm_reply(Reply, session_established, StateData) ->\n    {reply, Reply, session_established, StateData, ?C2S_HIBERNATE_TIMEOUT};\nfsm_reply(Reply, StateName, StateData) ->\n    {reply, Reply, StateName, StateData, ?C2S_OPEN_TIMEOUT}.\n\n%% Used by c2s blacklist plugins\nis_ip_blacklisted(undefined) ->\n    false;\nis_ip_blacklisted({IP,_Port}) ->\n    ejabberd_hooks:run_fold(check_bl_c2s, false, [IP]).\n\n%% Check from attributes\n%% returns invalid-from|NewElement\ncheck_from(El, FromJID) ->\n    case xml:get_tag_attr(<<\"from\">>, El) of\n\tfalse ->\n\t    El;\n\t{value, SJID} ->\n\t    JID = jlib:binary_to_jid(SJID),\n\t    case JID of\n\t\terror ->\n\t\t    'invalid-from';\n\t\t#jid{} ->\n\t\t    if\n\t\t\t(JID#jid.luser == FromJID#jid.luser) and\n\t\t\t(JID#jid.lserver == FromJID#jid.lserver) and\n\t\t\t(JID#jid.lresource == FromJID#jid.lresource) ->\n\t\t\t    El;\n\t\t\t(JID#jid.luser == FromJID#jid.luser) and\n\t\t\t(JID#jid.lserver == FromJID#jid.lserver) and\n\t\t\t(JID#jid.lresource == <<>>) ->\n\t\t\t    El;\n\t\t\ttrue ->\n\t\t\t    'invalid-from'\n\t\t    end\n\t    end\n    end.\n\nfsm_limit_opts(Opts) ->\n    case lists:keysearch(max_fsm_queue, 1, Opts) of\n\t{value, {_, N}} when is_integer(N) ->\n\t    [{max_queue, N}];\n\t_ ->\n\t    case ejabberd_config:get_local_option(max_fsm_queue) of\n\t\tN when is_integer(N) ->\n\t\t    [{max_queue, N}];\n\t\t_ ->\n\t\t    []\n\t    end\n    end.\n\nbounce_messages() ->\n    receive\n\t{route, From, To, El} ->\n\t    ejabberd_router:route(From, To, El),\n\t    bounce_messages()\n    after 0 ->\n\t    ok\n    end.\n\n%%%----------------------------------------------------------------------\n%%% XEP-0191\n%%%----------------------------------------------------------------------\n\nroute_blocking(What, StateData) ->\n    SubEl =\n\tcase What of\n\t    {block, JIDs} ->\n\t\t#xmlel{name = <<\"block\">>,\n\t\t       attrs = [{<<\"xmlns\">>, ?NS_BLOCKING}],\n\t\t       children = lists:map(\n\t\t                    fun(JID) ->\n\t\t\t                    #xmlel{name = <<\"item\">>,\n\t\t\t                           attrs = [{<<\"jid\">>, jlib:jid_to_binary(JID)}]}\n\t\t\t            end, JIDs)};\n\t    {unblock, JIDs} ->\n\t\t#xmlel{name = <<\"unblock\">>,\n\t\t       attrs = [{<<\"xmlns\">>, ?NS_BLOCKING}],\n\t\t       children = lists:map(\n\t\t                    fun(JID) ->\n\t\t\t                    #xmlel{name = <<\"item\">>,\n\t\t\t                           attrs = [{<<\"jid\">>, jlib:jid_to_binary(JID)}]}\n\t\t\t            end, JIDs)};\n\t    unblock_all ->\n\t\t#xmlel{name = <<\"unblock\">>,\n\t\t       attrs = [{<<\"xmlns\">>, ?NS_BLOCKING}]}\n\tend,\n    PrivPushIQ =\n\t#iq{type = set, xmlns = ?NS_BLOCKING,\n\t    id = <<\"push\">>,\n\t    sub_el = [SubEl]},\n    PrivPushEl =\n\tjlib:replace_from_to(\n\t  jlib:jid_remove_resource(\n\t    StateData#state.jid),\n\t  StateData#state.jid,\n\t  jlib:iq_to_xml(PrivPushIQ)),\n    send_element(StateData, PrivPushEl),\n    %% No need to replace active privacy list here,\n    %% blocking pushes are always accompanied by\n    %% Privacy List pushes\n    ok.\n\n%%%----------------------------------------------------------------------\n%%% JID Set memory footprint reduction code\n%%%----------------------------------------------------------------------\n\n%% Try to reduce the heap footprint of the four presence sets\n%% by ensuring that we re-use strings and Jids wherever possible.\npack(S = #state{pres_a=A,\n                pres_i=I,\n                pres_f=F,\n                pres_t=T}) ->\n    {NewA, Pack1} = pack_jid_set(A, gb_trees:empty()),\n    {NewI, Pack2} = pack_jid_set(I, Pack1),\n    {NewF, Pack3} = pack_jid_set(F, Pack2),\n    {NewT, _Pack4} = pack_jid_set(T, Pack3),\n    %% Throw away Pack4 so that if we delete references to\n    %% Strings or Jids in any of the sets there will be\n    %% no live references for the GC to find.\n    S#state{pres_a=NewA,\n            pres_i=NewI,\n            pres_f=NewF,\n            pres_t=NewT}.\n\npack_jid_set(Set, Pack) ->\n    Jids = ?SETS:to_list(Set),\n    {PackedJids, NewPack} = pack_jids(Jids, Pack, []),\n    {?SETS:from_list(PackedJids), NewPack}.\n\npack_jids([], Pack, Acc) -> {Acc, Pack};\npack_jids([{U,S,R}=Jid | Jids], Pack, Acc) ->\n    case gb_trees:lookup(Jid, Pack) of\n        {value, PackedJid} ->\n            pack_jids(Jids, Pack, [PackedJid | Acc]);\n        none ->\n            {NewU, Pack1} = pack_string(U, Pack),\n            {NewS, Pack2} = pack_string(S, Pack1),\n            {NewR, Pack3} = pack_string(R, Pack2),\n            NewJid = {NewU, NewS, NewR},\n            NewPack = gb_trees:insert(NewJid, NewJid, Pack3),\n            pack_jids(Jids, NewPack, [NewJid | Acc])\n    end.\n\npack_string(String, Pack) ->\n    case gb_trees:lookup(String, Pack) of\n        {value, PackedString} ->\n            {PackedString, Pack};\n        none ->\n            {String, gb_trees:insert(String, String, Pack)}\n    end.\n", "%%%----------------------------------------------------------------------\n%%% File    : ejabberd_receiver.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Socket receiver for C2S and S2S connections\n%%% Created : 10 Nov 2003 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(ejabberd_receiver).\n-author('alexey@process-one.net').\n\n-behaviour(gen_server).\n\n%% API\n-export([start_link/4,\n\t start/3,\n\t start/4,\n\t change_shaper/2,\n\t reset_stream/1,\n\t starttls/2,\n\t compress/2,\n\t become_controller/2,\n\t close/1]).\n\n%% gen_server callbacks\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2,\n\t terminate/2, code_change/3]).\n\n-include(\"ejabberd.hrl\").\n-include(\"jlib.hrl\").\n\n-record(state, {socket,\n\t\tsock_mod,\n\t\tshaper_state,\n\t\tc2s_pid,\n\t\tmax_stanza_size,\n\t\txml_stream_state,\n\t\ttimeout}).\n\n-define(HIBERNATE_TIMEOUT, 90000).\n\n%%====================================================================\n%% API\n%%====================================================================\n%%--------------------------------------------------------------------\n%% Function: start_link() -> {ok,Pid} | ignore | {error,Error}\n%% Description: Starts the server\n%%--------------------------------------------------------------------\nstart_link(Socket, SockMod, Shaper, MaxStanzaSize) ->\n    gen_server:start_link(\n      ?MODULE, [Socket, SockMod, Shaper, MaxStanzaSize], []).\n\n%%--------------------------------------------------------------------\n%% Function: start() -> {ok,Pid} | ignore | {error,Error}\n%% Description: Starts the server\n%%--------------------------------------------------------------------\nstart(Socket, SockMod, Shaper) ->\n    start(Socket, SockMod, Shaper, infinity).\n\nstart(Socket, SockMod, Shaper, MaxStanzaSize) ->\n    {ok, Pid} = supervisor:start_child(\n\t\t  ejabberd_receiver_sup,\n\t\t  [Socket, SockMod, Shaper, MaxStanzaSize]),\n    Pid.\n\nchange_shaper(Pid, Shaper) ->\n    gen_server:cast(Pid, {change_shaper, Shaper}).\n\nreset_stream(Pid) ->\n    gen_server:call(Pid, reset_stream).\n\nstarttls(Pid, TLSSocket) ->\n    gen_server:call(Pid, {starttls, TLSSocket}).\n\ncompress(Pid, ZlibSocket) ->\n    gen_server:call(Pid, {compress, ZlibSocket}).\n\nbecome_controller(Pid, C2SPid) ->\n    gen_server:call(Pid, {become_controller, C2SPid}).\n\nclose(Pid) ->\n    gen_server:cast(Pid, close).\n\n%%====================================================================\n%% gen_server callbacks\n%%====================================================================\n\n%%--------------------------------------------------------------------\n%% Function: init(Args) -> {ok, State} |\n%%                         {ok, State, Timeout} |\n%%                         ignore               |\n%%                         {stop, Reason}\n%% Description: Initiates the server\n%%--------------------------------------------------------------------\ninit([Socket, SockMod, Shaper, MaxStanzaSize]) ->\n    ShaperState = shaper:new(Shaper),\n    Timeout = case SockMod of\n\t\t  ssl ->\n\t\t      20;\n\t\t  _ ->\n\t\t      infinity\n\t      end,\n    {ok, #state{socket = Socket,\n\t\tsock_mod = SockMod,\n\t\tshaper_state = ShaperState,\n\t\tmax_stanza_size = MaxStanzaSize,\n\t\ttimeout = Timeout}}.\n\n%%--------------------------------------------------------------------\n%% Function: %% handle_call(Request, From, State) -> {reply, Reply, State} |\n%%                                      {reply, Reply, State, Timeout} |\n%%                                      {noreply, State} |\n%%                                      {noreply, State, Timeout} |\n%%                                      {stop, Reason, Reply, State} |\n%%                                      {stop, Reason, State}\n%% Description: Handling call messages\n%%--------------------------------------------------------------------\nhandle_call({starttls, TLSSocket}, _From,\n\t    #state{xml_stream_state = XMLStreamState,\n\t\t   c2s_pid = C2SPid,\n\t\t   max_stanza_size = MaxStanzaSize} = State) ->\n    close_stream(XMLStreamState),\n    NewXMLStreamState = xml_stream:new(C2SPid, MaxStanzaSize),\n    NewState = State#state{socket = TLSSocket,\n\t\t\t   sock_mod = ejabberd_tls,\n\t\t\t   xml_stream_state = NewXMLStreamState},\n    case ejabberd_tls:recv_data(TLSSocket, \"\") of\n\t{ok, TLSData} ->\n\t    {reply, ok, process_data(TLSData, NewState), ?HIBERNATE_TIMEOUT};\n\t{error, _Reason} ->\n\t    {stop, normal, ok, NewState}\n    end;\nhandle_call({compress, ZlibSocket}, _From,\n\t    #state{xml_stream_state = XMLStreamState,\n\t\t   c2s_pid = C2SPid,\n\t\t   max_stanza_size = MaxStanzaSize} = State) ->\n    close_stream(XMLStreamState),\n    NewXMLStreamState = xml_stream:new(C2SPid, MaxStanzaSize),\n    NewState = State#state{socket = ZlibSocket,\n\t\t\t   sock_mod = ejabberd_zlib,\n\t\t\t   xml_stream_state = NewXMLStreamState},\n    case ejabberd_zlib:recv_data(ZlibSocket, \"\") of\n\t{ok, ZlibData} ->\n\t    {reply, ok, process_data(ZlibData, NewState), ?HIBERNATE_TIMEOUT};\n\t{error, _Reason} ->\n\t    {stop, normal, ok, NewState}\n    end;\nhandle_call(reset_stream, _From,\n\t    #state{xml_stream_state = XMLStreamState,\n\t\t   c2s_pid = C2SPid,\n\t\t   max_stanza_size = MaxStanzaSize} = State) ->\n    close_stream(XMLStreamState),\n    NewXMLStreamState = xml_stream:new(C2SPid, MaxStanzaSize),\n    Reply = ok,\n    {reply, Reply, State#state{xml_stream_state = NewXMLStreamState},\n     ?HIBERNATE_TIMEOUT};\nhandle_call({become_controller, C2SPid}, _From, State) ->\n    XMLStreamState = xml_stream:new(C2SPid, State#state.max_stanza_size),\n    NewState = State#state{c2s_pid = C2SPid,\n\t\t\t   xml_stream_state = XMLStreamState},\n    activate_socket(NewState),\n    Reply = ok,\n    {reply, Reply, NewState, ?HIBERNATE_TIMEOUT};\nhandle_call(_Request, _From, State) ->\n    Reply = ok,\n    {reply, Reply, State, ?HIBERNATE_TIMEOUT}.\n\n%%--------------------------------------------------------------------\n%% Function: handle_cast(Msg, State) -> {noreply, State} |\n%%                                      {noreply, State, Timeout} |\n%%                                      {stop, Reason, State}\n%% Description: Handling cast messages\n%%--------------------------------------------------------------------\nhandle_cast({change_shaper, Shaper}, State) ->\n    NewShaperState = shaper:new(Shaper),\n    {noreply, State#state{shaper_state = NewShaperState}, ?HIBERNATE_TIMEOUT};\nhandle_cast(close, State) ->\n    {stop, normal, State};\nhandle_cast(_Msg, State) ->\n    {noreply, State, ?HIBERNATE_TIMEOUT}.\n\n%%--------------------------------------------------------------------\n%% Function: handle_info(Info, State) -> {noreply, State} |\n%%                                       {noreply, State, Timeout} |\n%%                                       {stop, Reason, State}\n%% Description: Handling all non call/cast messages\n%%--------------------------------------------------------------------\nhandle_info({Tag, _TCPSocket, Data},\n\t    #state{socket = Socket,\n\t\t   sock_mod = SockMod} = State)\n  when (Tag == tcp) or (Tag == ssl) or (Tag == ejabberd_xml) ->\n    case SockMod of\n\tejabberd_tls ->\n\t    case ejabberd_tls:recv_data(Socket, Data) of\n\t\t{ok, TLSData} ->\n\t\t    {noreply, process_data(TLSData, State),\n\t\t     ?HIBERNATE_TIMEOUT};\n\t\t{error, _Reason} ->\n\t\t    {stop, normal, State}\n\t    end;\n\tejabberd_zlib ->\n\t    case ejabberd_zlib:recv_data(Socket, Data) of\n\t\t{ok, ZlibData} ->\n\t\t    {noreply, process_data(ZlibData, State),\n\t\t     ?HIBERNATE_TIMEOUT};\n\t\t{error, _Reason} ->\n\t\t    {stop, normal, State}\n\t    end;\n\t_ ->\n\t    {noreply, process_data(Data, State), ?HIBERNATE_TIMEOUT}\n    end;\nhandle_info({Tag, _TCPSocket}, State)\n  when (Tag == tcp_closed) or (Tag == ssl_closed) ->\n    {stop, normal, State};\nhandle_info({Tag, _TCPSocket, Reason}, State)\n  when (Tag == tcp_error) or (Tag == ssl_error) ->\n    case Reason of\n\ttimeout ->\n\t    {noreply, State, ?HIBERNATE_TIMEOUT};\n\t_ ->\n\t    {stop, normal, State}\n    end;\nhandle_info({timeout, _Ref, activate}, State) ->\n    activate_socket(State),\n    {noreply, State, ?HIBERNATE_TIMEOUT};\nhandle_info(timeout, State) ->\n    proc_lib:hibernate(gen_server, enter_loop, [?MODULE, [], State]),\n    {noreply, State, ?HIBERNATE_TIMEOUT};\nhandle_info(_Info, State) ->\n    {noreply, State, ?HIBERNATE_TIMEOUT}.\n\n%%--------------------------------------------------------------------\n%% Function: terminate(Reason, State) -> void()\n%% Description: This function is called by a gen_server when it is about to\n%% terminate. It should be the opposite of Module:init/1 and do any necessary\n%% cleaning up. When it returns, the gen_server terminates with Reason.\n%% The return value is ignored.\n%%--------------------------------------------------------------------\nterminate(_Reason, #state{xml_stream_state = XMLStreamState,\n\t\t\t  c2s_pid = C2SPid} = State) ->\n    close_stream(XMLStreamState),\n    if\n\tC2SPid /= undefined ->\n\t    gen_fsm:send_event(C2SPid, closed);\n\ttrue ->\n\t    ok\n    end,\n    catch (State#state.sock_mod):close(State#state.socket),\n    ok.\n\n%%--------------------------------------------------------------------\n%% Func: code_change(OldVsn, State, Extra) -> {ok, NewState}\n%% Description: Convert process state when code is changed\n%%--------------------------------------------------------------------\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%--------------------------------------------------------------------\n%%% Internal functions\n%%--------------------------------------------------------------------\n\nactivate_socket(#state{socket = Socket,\n\t\t       sock_mod = SockMod}) ->\n    PeerName =\n\tcase SockMod of\n\t    gen_tcp ->\n\t\tinet:setopts(Socket, [{active, once}]),\n\t\tinet:peername(Socket);\n\t    _ ->\n\t\tSockMod:setopts(Socket, [{active, once}]),\n\t\tSockMod:peername(Socket)\n\tend,\n    case PeerName of\n\t{error, _Reason} ->\n\t    self() ! {tcp_closed, Socket};\n\t{ok, _} ->\n\t    ok\n    end.\n\n%% Data processing for connectors directly generating xmlel in\n%% Erlang data structure.\n%% WARNING: Shaper does not work with Erlang data structure.\nprocess_data([], State) ->\n    activate_socket(State),\n    State;\nprocess_data([Element|Els], #state{c2s_pid = C2SPid} = State)\n  when element(1, Element) == xmlel;\n       element(1, Element) == xmlstreamstart;\n      element(1, Element) == xmlstreamelement;\n       element(1, Element) == xmlstreamend ->\n    if\n\tC2SPid == undefined ->\n\t    State;\n\ttrue ->\n\t    catch gen_fsm:send_event(C2SPid, element_wrapper(Element)),\n\t    process_data(Els, State)\n    end;\n%% Data processing for connectors receivind data as string.\nprocess_data(Data,\n\t     #state{xml_stream_state = XMLStreamState,\n\t\t    shaper_state = ShaperState,\n\t\t    c2s_pid = C2SPid} = State) ->\n    ?DEBUG(\"Received XML on stream = \\\"~s\\\"\", [Data]),\n    XMLStreamState1 = xml_stream:parse(XMLStreamState, Data),\n    {NewShaperState, Pause} = shaper:update(ShaperState, size(Data)),\n    if\n\tC2SPid == undefined ->\n\t    ok;\n\tPause > 0 ->\n\t    erlang:start_timer(Pause, self(), activate);\n\ttrue ->\n\t    activate_socket(State)\n    end,\n    State#state{xml_stream_state = XMLStreamState1,\n\t\tshaper_state = NewShaperState}.\n\n%% Element coming from XML parser are wrapped inside xmlstreamelement\n%% When we receive directly xmlel tuple (from a socket module\n%% speaking directly Erlang XML), we wrap it inside the same\n%% xmlstreamelement coming from the XML parser.\nelement_wrapper(#xmlel{} = XMLElement) ->\n    {xmlstreamelement, XMLElement};\nelement_wrapper(Element) ->\n    Element.\n\nclose_stream(undefined) ->\n    ok;\nclose_stream(XMLStreamState) ->\n    xml_stream:close(XMLStreamState).\n", "%%%----------------------------------------------------------------------\n%%% File    : ejabberd_socket.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Socket with zlib and TLS support library\n%%% Created : 23 Aug 2006 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(ejabberd_socket).\n-author('alexey@process-one.net').\n\n%% API\n-export([start/4,\n\t connect/3,\n\t connect/4,\n\t starttls/2,\n\t starttls/3,\n\t compress/1,\n\t compress/2,\n\t reset_stream/1,\n\t send/2,\n\t send_xml/2,\n\t change_shaper/2,\n\t monitor/1,\n\t get_sockmod/1,\n\t get_peer_certificate/1,\n\t get_verify_result/1,\n\t close/1,\n\t sockname/1, peername/1]).\n\n-include(\"ejabberd.hrl\").\n\n-record(socket_state, {sockmod, socket, receiver}).\n\n%%====================================================================\n%% API\n%%====================================================================\n%%--------------------------------------------------------------------\n%% Function:\n%% Description:\n%%--------------------------------------------------------------------\nstart(Module, SockMod, Socket, Opts) ->\n    case Module:socket_type() of\n\txml_stream ->\n\t    MaxStanzaSize =\n\t\tcase lists:keysearch(max_stanza_size, 1, Opts) of\n\t\t    {value, {_, Size}} -> Size;\n\t\t    _ -> infinity\n\t\tend,\n\t    {ReceiverMod, Receiver, RecRef} =\n\t\tcase catch SockMod:custom_receiver(Socket) of\n\t\t    {receiver, RecMod, RecPid} ->\n\t\t\t{RecMod, RecPid, RecMod};\n\t\t    _ ->\n\t\t\tRecPid = ejabberd_receiver:start(\n\t\t\t\t   Socket, SockMod, none, MaxStanzaSize),\n\t\t\t{ejabberd_receiver, RecPid, RecPid}\n\t\tend,\n\t    SocketData = #socket_state{sockmod = SockMod,\n\t\t\t\t       socket = Socket,\n\t\t\t\t       receiver = RecRef},\n\t    case Module:start({?MODULE, SocketData}, Opts) of\n\t\t{ok, Pid} ->\n\t\t    case SockMod:controlling_process(Socket, Receiver) of\n\t\t\tok ->\n\t\t\t    ok;\n\t\t\t{error, _Reason} ->\n\t\t\t    SockMod:close(Socket)\n\t\t    end,\n\t\t    ReceiverMod:become_controller(Receiver, Pid);\n\t\t{error, _Reason} ->\n\t\t    SockMod:close(Socket),\n\t\t    case ReceiverMod of\n\t\t\tejabberd_receiver ->\n\t\t\t    ReceiverMod:close(Receiver);\n\t\t\t_ ->\n\t\t\t    ok\n\t\t    end\n\t    end;\n\tindependent ->\n\t    ok;\n\traw ->\n\t    case Module:start({SockMod, Socket}, Opts) of\n\t\t{ok, Pid} ->\n\t\t    case SockMod:controlling_process(Socket, Pid) of\n\t\t\tok ->\n\t\t\t    ok;\n\t\t\t{error, _Reason} ->\n\t\t\t    SockMod:close(Socket)\n\t\t    end;\n\t\t{error, _Reason} ->\n\t\t    SockMod:close(Socket)\n\t    end\n    end.\n\nconnect(Addr, Port, Opts) ->\n    connect(Addr, Port, Opts, infinity).\n\nconnect(Addr, Port, Opts, Timeout) ->\n    case gen_tcp:connect(Addr, Port, Opts, Timeout) of\n\t{ok, Socket} ->\n\t    Receiver = ejabberd_receiver:start(Socket, gen_tcp, none),\n\t    SocketData = #socket_state{sockmod = gen_tcp,\n\t\t\t\t       socket = Socket,\n\t\t\t\t       receiver = Receiver},\n\t    Pid = self(),\n\t    case gen_tcp:controlling_process(Socket, Receiver) of\n\t\tok ->\n\t\t    ejabberd_receiver:become_controller(Receiver, Pid),\n\t\t    {ok, SocketData};\n\t\t{error, _Reason} = Error ->\n\t\t    gen_tcp:close(Socket),\n\t\t    Error\n\t    end;\n\t{error, _Reason} = Error ->\n\t    Error\n    end.\n\nstarttls(SocketData, TLSOpts) ->\n    {ok, TLSSocket} = ejabberd_tls:tcp_to_tls(SocketData#socket_state.socket, TLSOpts),\n    ejabberd_receiver:starttls(SocketData#socket_state.receiver, TLSSocket),\n    SocketData#socket_state{socket = TLSSocket, sockmod = ejabberd_tls}.\n\nstarttls(SocketData, TLSOpts, Data) ->\n    {ok, TLSSocket} = ejabberd_tls:tcp_to_tls(SocketData#socket_state.socket, TLSOpts),\n    ejabberd_receiver:starttls(SocketData#socket_state.receiver, TLSSocket),\n    send(SocketData, Data),\n    SocketData#socket_state{socket = TLSSocket, sockmod = ejabberd_tls}.\n\ncompress(SocketData) ->\n    {ok, ZlibSocket} = ejabberd_zlib:enable_zlib(\n\t\t\t SocketData#socket_state.sockmod,\n\t\t\t SocketData#socket_state.socket),\n    ejabberd_receiver:compress(SocketData#socket_state.receiver, ZlibSocket),\n    SocketData#socket_state{socket = ZlibSocket, sockmod = ejabberd_zlib}.\n\ncompress(SocketData, Data) ->\n    {ok, ZlibSocket} = ejabberd_zlib:enable_zlib(\n\t\t\t SocketData#socket_state.sockmod,\n\t\t\t SocketData#socket_state.socket),\n    ejabberd_receiver:compress(SocketData#socket_state.receiver, ZlibSocket),\n    send(SocketData, Data),\n    SocketData#socket_state{socket = ZlibSocket, sockmod = ejabberd_zlib}.\n\nreset_stream(SocketData) when is_pid(SocketData#socket_state.receiver) ->\n    ejabberd_receiver:reset_stream(SocketData#socket_state.receiver);\nreset_stream(SocketData) when is_atom(SocketData#socket_state.receiver) ->\n    (SocketData#socket_state.receiver):reset_stream(\n      SocketData#socket_state.socket).\n\n%% sockmod=gen_tcp|ejabberd_tls|ejabberd_zlib\nsend(SocketData, Data) ->\n    case catch (SocketData#socket_state.sockmod):send(\n\t     SocketData#socket_state.socket, Data) of\n        ok -> ok;\n\t{error, timeout} ->\n\t    ?INFO_MSG(\"Timeout on ~p:send\",[SocketData#socket_state.sockmod]),\n\t    exit(normal);\n        Error ->\n\t    ?DEBUG(\"Error in ~p:send: ~p\",[SocketData#socket_state.sockmod, Error]),\n\t    exit(normal)\n    end.\n\n%% Can only be called when in c2s StateData#state.xml_socket is true\n%% This function is used for HTTP bind\n%% sockmod=ejabberd_http_poll|ejabberd_http_bind or any custom module\nsend_xml(SocketData, Data) ->\n    catch (SocketData#socket_state.sockmod):send_xml(\n\t    SocketData#socket_state.socket, Data).\n\nchange_shaper(SocketData, Shaper)\n  when is_pid(SocketData#socket_state.receiver) ->\n    ejabberd_receiver:change_shaper(SocketData#socket_state.receiver, Shaper);\nchange_shaper(SocketData, Shaper)\n  when is_atom(SocketData#socket_state.receiver) ->\n    (SocketData#socket_state.receiver):change_shaper(\n      SocketData#socket_state.socket, Shaper).\n\nmonitor(SocketData) when is_pid(SocketData#socket_state.receiver) ->\n    erlang:monitor(process, SocketData#socket_state.receiver);\nmonitor(SocketData) when is_atom(SocketData#socket_state.receiver) ->\n    (SocketData#socket_state.receiver):monitor(\n      SocketData#socket_state.socket).\n\nget_sockmod(SocketData) ->\n    SocketData#socket_state.sockmod.\n\nget_peer_certificate(SocketData) ->\n    ejabberd_tls:get_peer_certificate(SocketData#socket_state.socket).\n\nget_verify_result(SocketData) ->\n    ejabberd_tls:get_verify_result(SocketData#socket_state.socket).\n\nclose(SocketData) ->\n    ejabberd_receiver:close(SocketData#socket_state.receiver).\n\nsockname(#socket_state{sockmod = SockMod, socket = Socket}) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:sockname(Socket);\n\t_ ->\n\t    SockMod:sockname(Socket)\n    end.\n\npeername(#socket_state{sockmod = SockMod, socket = Socket}) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:peername(Socket);\n\t_ ->\n\t    SockMod:peername(Socket)\n    end.\n\n%%====================================================================\n%% Internal functions\n%%====================================================================\n", "%%%----------------------------------------------------------------------\n%%% File    : ejabberd_zlib.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Interface to zlib\n%%% Created : 19 Jan 2006 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(ejabberd_zlib).\n-author('alexey@process-one.net').\n\n-behaviour(gen_server).\n\n-export([start/0, start_link/0,\n\t enable_zlib/2, disable_zlib/1,\n\t send/2,\n\t recv/2, recv/3, recv_data/2,\n\t setopts/2,\n\t sockname/1, peername/1,\n\t get_sockmod/1,\n\t controlling_process/2,\n\t close/1]).\n\n%% Internal exports, call-back functions.\n-export([init/1,\n\t handle_call/3,\n\t handle_cast/2,\n\t handle_info/2,\n\t code_change/3,\n\t terminate/2]).\n\n-define(DEFLATE, 1).\n-define(INFLATE, 2).\n\n-record(zlibsock, {sockmod, socket, zlibport}).\n\nstart() ->\n    gen_server:start({local, ?MODULE}, ?MODULE, [], []).\n\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\ninit([]) ->\n    case erl_ddll:load_driver(ejabberd:get_so_path(), ejabberd_zlib_drv) of\n\tok -> ok;\n\t{error, already_loaded} -> ok\n    end,\n    Port = open_port({spawn, ejabberd_zlib_drv}, [binary]),\n    {ok, Port}.\n\n\n%%% --------------------------------------------------------\n%%% The call-back functions.\n%%% --------------------------------------------------------\n\nhandle_call(_, _, State) ->\n    {noreply, State}.\n\nhandle_cast(_, State) ->\n    {noreply, State}.\n\nhandle_info({'EXIT', Port, Reason}, Port) ->\n    {stop, {port_died, Reason}, Port};\n\nhandle_info({'EXIT', _Pid, _Reason}, Port) ->\n    {noreply, Port};\n\nhandle_info(_, State) ->\n    {noreply, State}.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\nterminate(_Reason, Port) ->\n    Port ! {self, close},\n    ok.\n\n\nenable_zlib(SockMod, Socket) ->\n    case erl_ddll:load_driver(ejabberd:get_so_path(), ejabberd_zlib_drv) of\n\tok -> ok;\n\t{error, already_loaded} -> ok\n    end,\n    Port = open_port({spawn, ejabberd_zlib_drv}, [binary]),\n    {ok, #zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port}}.\n\ndisable_zlib(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port}) ->\n    port_close(Port),\n    {SockMod, Socket}.\n\nrecv(Socket, Length) ->\n    recv(Socket, Length, infinity).\nrecv(#zlibsock{sockmod = SockMod, socket = Socket} = ZlibSock,\n     Length, Timeout) ->\n    case SockMod:recv(Socket, Length, Timeout) of\n\t{ok, Packet} ->\n\t    recv_data(ZlibSock, Packet);\n\t{error, _Reason} = Error ->\n\t    Error\n    end.\n\nrecv_data(#zlibsock{sockmod = SockMod, socket = Socket} = ZlibSock, Packet) ->\n    case SockMod of\n\tgen_tcp ->\n\t    recv_data2(ZlibSock, Packet);\n\t_ ->\n\t    case SockMod:recv_data(Socket, Packet) of\n\t\t{ok, Packet2} ->\n\t\t    recv_data2(ZlibSock, Packet2);\n\t\tError ->\n\t\t    Error\n\t    end\n    end.\n\nrecv_data2(ZlibSock, Packet) ->\n    case catch recv_data1(ZlibSock, Packet) of\n\t{'EXIT', Reason} ->\n\t    {error, Reason};\n\tRes ->\n\t    Res\n    end.\n\nrecv_data1(#zlibsock{zlibport = Port} = _ZlibSock, Packet) ->\n    case port_control(Port, ?INFLATE, Packet) of\n\t<<0, In/binary>> ->\n\t    {ok, In};\n\t<<1, Error/binary>> ->\n\t    {error, binary_to_list(Error)}\n    end.\n\nsend(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port},\n     Packet) ->\n    case port_control(Port, ?DEFLATE, Packet) of\n\t<<0, Out/binary>> ->\n\t    SockMod:send(Socket, Out);\n\t<<1, Error/binary>> ->\n\t    {error, binary_to_list(Error)}\n    end.\n\n\nsetopts(#zlibsock{sockmod = SockMod, socket = Socket}, Opts) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:setopts(Socket, Opts);\n\t_ ->\n\t    SockMod:setopts(Socket, Opts)\n    end.\n\nsockname(#zlibsock{sockmod = SockMod, socket = Socket}) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:sockname(Socket);\n\t_ ->\n\t    SockMod:sockname(Socket)\n    end.\n\nget_sockmod(#zlibsock{sockmod = SockMod}) ->\n    SockMod.\n\npeername(#zlibsock{sockmod = SockMod, socket = Socket}) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:peername(Socket);\n\t_ ->\n\t    SockMod:peername(Socket)\n    end.\n\ncontrolling_process(#zlibsock{sockmod = SockMod, socket = Socket}, Pid) ->\n    SockMod:controlling_process(Socket, Pid).\n\nclose(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port}) ->\n    SockMod:close(Socket),\n    port_close(Port).\n\n\n", "-module(mod_bosh_socket).\n\n-behaviour(gen_fsm).\n\n%% API\n-export([start/2,\n         start_link/2,\n         start_supervisor/0,\n         handle_request/2,\n         pause/2]).\n\n%% Private API\n-export([get_handlers/1,\n         get_pending/1,\n         get_client_acks/1,\n         set_client_acks/2,\n         get_cached_responses/1]).\n\n%% ejabberd_socket compatibility\n-export([starttls/2, starttls/3,\n         compress/1, compress/2,\n         reset_stream/1,\n         send/2,\n         send_xml/2,\n         change_shaper/2,\n         monitor/1,\n         get_sockmod/1,\n         close/1,\n         peername/1]).\n\n%% gen_fsm callbacks\n-export([init/1,\n         accumulate/2, accumulate/3,\n         normal/2, normal/3,\n         handle_event/3,\n         handle_sync_event/4,\n         handle_info/3,\n         terminate/3,\n         code_change/4]).\n\n-include(\"ejabberd.hrl\").\n-include(\"jlib.hrl\").\n-include_lib(\"exml/include/exml_stream.hrl\").\n-include(\"mod_bosh.hrl\").\n\n-define(ACCUMULATE_PERIOD, 10).\n-define(DEFAULT_HOLD, 1).\n-define(CONCURRENT_REQUESTS, 2).\n-define(DEFAULT_WAIT, 60).\n-define(DEFAULT_MAXPAUSE, 120).\n-define(DEFAULT_CLIENT_ACKS, false).\n\n-type cached_response() :: {rid(), erlang:timestamp(), #xmlel{}}.\n-type rid() :: pos_integer().\n\n-record(state, {c2s_pid :: pid(),\n                handlers = [] :: [{rid(), timer:tref(), pid()}],\n                %% Elements buffered for sending to the client.\n                pending = [] :: [xmlstreamelement()],\n                sid :: bosh_sid(),\n                wait = ?DEFAULT_WAIT,\n                hold = ?DEFAULT_HOLD,\n                rid :: rid(),\n                %% Requests deferred for later processing because\n                %% of having Rid greater than expected.\n                deferred = [] :: [{rid(), {event_type(), #xmlel{}}}],\n                client_acks = ?DEFAULT_CLIENT_ACKS :: boolean(),\n                sent = [] :: [cached_response()],\n                %% Allowed inactivity period in seconds.\n                inactivity :: pos_integer() | infinity,\n                inactivity_tref,\n                %% Max pause period in seconds.\n                maxpause :: pos_integer() | undefined,\n                %% Are acknowledgements used?\n                server_acks :: boolean(),\n                last_processed :: rid() | undefined,\n                %% Report scheduled for sending at the earliest\n                %% possible occasion.\n                report = false :: {rid(), timer:time()} | false}).\n\n%%--------------------------------------------------------------------\n%% API\n%%--------------------------------------------------------------------\n\nstart(Sid, Peer) ->\n    supervisor:start_child(?BOSH_SOCKET_SUP, [Sid, Peer]).\n\nstart_link(Sid, Peer) ->\n    gen_fsm:start_link(?MODULE, [Sid, Peer], []).\n\nstart_supervisor() ->\n    ChildId = ?BOSH_SOCKET_SUP,\n    ChildSpec =\n        {ChildId,\n         {ejabberd_tmp_sup, start_link,\n          [ChildId, ?MODULE]},\n         permanent,\n         infinity,\n         supervisor,\n         [ejabberd_tmp_sup]},\n    case supervisor:start_child(ejabberd_sup, ChildSpec) of\n        {ok, undefined} ->\n            {error, undefined};\n        {ok, Child} ->\n            {ok, Child};\n        {ok, Child, _Info} ->\n            {ok, Child};\n        {error, {already_started, Child}} ->\n            {ok, Child};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n-spec handle_request(Pid, {EventTag, Handler, Body}) -> ok\n    when Pid :: pid(),\n         EventTag :: event_type(),\n         Handler :: pid(),\n         Body :: #xmlel{}.\nhandle_request(Pid, Request) ->\n    gen_fsm:send_all_state_event(Pid, Request).\n\n%% TODO: no handler for this call is present!\n%% No check for violating maxpause is made when calling this!\n-spec pause(Pid, Seconds) -> ok\n    when Pid :: pid(),\n         Seconds :: pos_integer().\npause(Pid, Seconds) ->\n    gen_fsm:send_all_state_event(Pid, {pause, Seconds}).\n\n%%--------------------------------------------------------------------\n%% Private API\n%%--------------------------------------------------------------------\n\nget_handlers(Pid) ->\n    gen_fsm:sync_send_all_state_event(Pid, get_handlers).\n\nget_pending(Pid) ->\n    gen_fsm:sync_send_all_state_event(Pid, get_pending).\n\n-spec get_client_acks(pid()) -> boolean().\nget_client_acks(Pid) ->\n    gen_fsm:sync_send_all_state_event(Pid, get_client_acks).\n\n-spec set_client_acks(pid(), boolean()) -> any().\nset_client_acks(Pid, Enabled) ->\n    gen_fsm:sync_send_all_state_event(Pid, {set_client_acks, Enabled}).\n\n-spec get_cached_responses(pid()) -> [cached_response()].\nget_cached_responses(Pid) ->\n    gen_fsm:sync_send_all_state_event(Pid, get_cached_responses).\n\n%%--------------------------------------------------------------------\n%% gen_fsm callbacks\n%%--------------------------------------------------------------------\n\n%%--------------------------------------------------------------------\n%% @private\n%% @spec init(Args) -> {ok, StateName, State} |\n%%                     {ok, StateName, State, Timeout} |\n%%                     ignore |\n%%                     {stop, StopReason}\n%% @end\n%%--------------------------------------------------------------------\ninit([Sid, Peer]) ->\n    BoshSocket = #bosh_socket{sid = Sid, pid = self(), peer = Peer},\n    C2SOpts = [{xml_socket, true}],\n    {ok, C2SPid} = ejabberd_c2s:start({mod_bosh_socket, BoshSocket}, C2SOpts),\n    ?DEBUG(\"mod_bosh_socket started~n\", []),\n    {ok, accumulate, #state{sid = Sid,\n                            c2s_pid = C2SPid,\n                            inactivity = mod_bosh:get_inactivity(),\n                            maxpause = get_maxpause(),\n                            server_acks = mod_bosh:get_server_acks()}}.\n\n%% TODO: maybe make maxpause runtime configurable like inactivity?\nget_maxpause() ->\n    case gen_mod:get_module_opt(?MYNAME, mod_bosh, maxpause, undefined) of\n        undefined -> ?DEFAULT_MAXPAUSE;\n        MP -> MP\n    end.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% There should be one instance of this function for each possible\n%% state name. Whenever a gen_fsm receives an event sent using\n%% gen_fsm:send_event/2, the instance of this function with the same\n%% name as the current state name StateName is called to handle\n%% the event. It is also called if a timeout occurs.\n%%\n%% @spec state_name(Event, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState}\n%% @end\n%%--------------------------------------------------------------------\n\naccumulate(acc_off, #state{pending = Pending} = S) ->\n    NS = S#state{pending = []},\n    {next_state, normal, send_or_store(Pending, NS)};\naccumulate(Event, State) ->\n    ?DEBUG(\"Unhandled event in 'accumulate' state: ~w~n\", [Event]),\n    {next_state, accumulate, State}.\n\nnormal(acc_off, #state{} = S) ->\n    {next_state, normal, S};\nnormal(Event, State) ->\n    ?DEBUG(\"Unhandled event in 'normal' state: ~w~n\", [Event]),\n    {next_state, normal, State}.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% There should be one instance of this function for each possible\n%% state name. Whenever a gen_fsm receives an event sent using\n%% gen_fsm:sync_send_event/[2,3], the instance of this function with\n%% the same name as the current state name StateName is called to\n%% handle the event.\n%%\n%% @spec state_name(Event, From, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {reply, Reply, NextStateName, NextState} |\n%%                   {reply, Reply, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState} |\n%%                   {stop, Reason, Reply, NewState}\n%% @end\n%%--------------------------------------------------------------------\naccumulate(Event, _From, State) ->\n    ?DEBUG(\"Unhandled sync event in 'accumulate' state: ~w~n\", [Event]),\n    {reply, ok, state_name, State}.\n\nnormal(Event, _From, State) ->\n    ?DEBUG(\"Unhandled sync event in 'normal' state: ~w~n\", [Event]),\n    {reply, ok, state_name, State}.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever a gen_fsm receives an event sent using\n%% gen_fsm:send_all_state_event/2, this function is called to handle\n%% the event.\n%%\n%% @spec handle_event(Event, StateName, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState}\n%% @end\n%%--------------------------------------------------------------------\n\nhandle_event({EventTag, Handler, #xmlel{} = Body}, SName, S) ->\n    NS = cancel_inactivity_timer(S),\n    Rid = binary_to_integer(exml_query:attr(Body, <<\"rid\">>)),\n    try\n        NNS = handle_stream_event({EventTag, Body, Rid}, Handler, SName, NS),\n        %% TODO: it's the event which determines the next state,\n        %%       this ought to be returned from handle_stream_event\n        case EventTag of\n            _ when EventTag == streamstart; EventTag == restart ->\n                timer:apply_after(?ACCUMULATE_PERIOD,\n                                  gen_fsm, send_event, [self(), acc_off]),\n                {next_state, accumulate, NNS};\n            _ ->\n                {next_state, SName, NNS}\n        end\n    catch\n        throw:{invalid_rid, TState} ->\n            {stop, {shutdown, invalid_rid}, TState};\n        throw:{invalid_pause, TState} ->\n            {stop, {shutdown, policy_violation}, TState}\n    end;\n\nhandle_event(Event, StateName, State) ->\n    ?DEBUG(\"Unhandled all state event: ~w~n\", [Event]),\n    {next_state, StateName, State}.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever a gen_fsm receives an event sent using\n%% gen_fsm:sync_send_all_state_event/[2,3], this function is called\n%% to handle the event.\n%%\n%% @spec handle_sync_event(Event, From, StateName, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {reply, Reply, NextStateName, NextState} |\n%%                   {reply, Reply, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState} |\n%%                   {stop, Reason, Reply, NewState}\n%% @end\n%%--------------------------------------------------------------------\nhandle_sync_event(get_handlers, _From, StateName,\n                  #state{handlers = Handlers} = S) ->\n    {reply, Handlers, StateName, S};\nhandle_sync_event(get_pending, _From, StateName,\n                  #state{pending = Pending} = S) ->\n    {reply, Pending, StateName, S};\nhandle_sync_event(get_client_acks, _From, StateName,\n                  #state{client_acks = ClientAcks} = S) ->\n    {reply, ClientAcks, StateName, S};\nhandle_sync_event({set_client_acks, ClientAcks}, _From, StateName,\n                  #state{} = S) ->\n    NS = S#state{client_acks = ClientAcks},\n    {reply, ok, StateName, NS};\nhandle_sync_event(get_cached_responses, _From, StateName,\n                  #state{sent = CachedResponses} = S) ->\n    {reply, CachedResponses, StateName, S};\nhandle_sync_event(Event, _From, StateName, State) ->\n    ?DEBUG(\"Unhandled sync all state event: ~w~n\", [Event]),\n    Reply = ok,\n    {reply, Reply, StateName, State}.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% This function is called by a gen_fsm when it receives any\n%% message other than a synchronous or asynchronous event\n%% (or a system message).\n%%\n%% @spec handle_info(Info,StateName,State)->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState}\n%% @end\n%%--------------------------------------------------------------------\n\nhandle_info({send, #xmlstreamend{} = StreamEnd}, _SName,\n            #state{pending = Pending} = S) ->\n    NS = send_or_store(Pending ++ [StreamEnd], S#state{pending = []}),\n    {next_state, normal, NS};\nhandle_info({send, Data}, accumulate = SName, #state{} = S) ->\n    {next_state, SName, store([Data], S)};\nhandle_info({send, Data}, normal = SName, #state{} = S) ->\n    NS = send_or_store(Data, S),\n    {next_state, SName, NS};\nhandle_info(reset_stream, SName, #state{} = S) ->\n    %% TODO: actually reset the stream once it's stored per bosh session\n    ?DEBUG(\"Stream reset by c2s~n\", []),\n    {next_state, SName, S};\nhandle_info(close, _SName, State) ->\n    {stop, normal, State};\nhandle_info(inactivity_timeout, _SName, State) ->\n    ?DEBUG(\"terminating due to client inactivity~n\", []),\n    {stop, {shutdown, inactivity_timeout}, State};\nhandle_info({wait_timeout, {Rid, Pid}}, SName,\n            #state{handlers = Handlers} = S) ->\n    ?DEBUG(\"'wait' limit reached for ~p~n\", [Pid]),\n    %% In case some message was being handled when the timer fired\n    %% it may turn out that Pid is no longer available in Handlers.\n    case lists:keytake(Rid, 1, Handlers) of\n        false ->\n            {next_state, SName, S};\n        {value, {Rid, _, Pid}, NewHandlers} ->\n            NS = send_to_handler({Rid, Pid}, [], S),\n            {next_state, SName, NS#state{handlers = NewHandlers}}\n    end;\nhandle_info(Info, SName, State) ->\n    ?DEBUG(\"Unhandled info in '~s' state: ~w~n\", [SName, Info]),\n    {next_state, SName, State}.\n\nterminate(_Reason, StateName, #state{sid = Sid, handlers = Handlers} = S) ->\n    [Pid ! {close, Sid} || {_, _, Pid} <- lists:sort(Handlers)],\n    ?BOSH_BACKEND:delete_session(Sid),\n    catch ejabberd_c2s:stop(S#state.c2s_pid),\n    ?DEBUG(\"Closing session ~p in '~s' state. Handlers: ~p Pending: ~p~n\",\n           [Sid, StateName, Handlers, S#state.pending]).\n\ncode_change(_OldVsn, StateName, State, _Extra) ->\n    {ok, StateName, State}.\n\n%%--------------------------------------------------------------------\n%% callback implementations\n%%--------------------------------------------------------------------\n\nhandle_stream_event({EventTag, Body, Rid} = Event, Handler,\n                    SName, #state{rid = OldRid} = S) ->\n    NS = maybe_add_handler(Handler, Rid, S),\n    NNS = case {EventTag,\n                maybe_is_retransmission(Rid, OldRid, S#state.sent),\n                is_valid_rid(Rid, OldRid),\n                is_acceptable_rid(Rid, OldRid)}\n    of\n        {_, {true, CachedResponse}, _, _} ->\n            case CachedResponse of\n                none ->\n                    NS;\n                _ ->\n                    resend_cached(CachedResponse, NS)\n            end;\n        {streamstart, _, _, _} ->\n            process_acked_stream_event(Event, SName, NS);\n        {_, _, true, _} ->\n            process_acked_stream_event(Event, SName, NS);\n        {_, _, false, true} ->\n            ?DEBUG(\"storing stream event for deferred processing: ~p~n\",\n                   [{EventTag, Body}]),\n            NS#state{deferred = [Event | NS#state.deferred]};\n        {_, _, false, false} ->\n            ?ERROR_MSG(\"invalid rid ~p, expected ~p:~n~p~n\",\n                       [Rid, OldRid + 1, {EventTag, Body}]),\n            [Pid ! item_not_found\n             || {_, _, Pid} <- lists:sort(NS#state.handlers)],\n            throw({invalid_rid, NS#state{handlers = []}})\n    end,\n    return_surplus_handlers(SName, NNS).\n\n-spec maybe_is_retransmission(rid(), rid(), [cached_response()])\n    -> false | {true, none} | {true, cached_response()}.\nmaybe_is_retransmission(Rid, OldRid, Sent) ->\n    case {lists:keyfind(Rid, 1, Sent), Rid =:= OldRid} of\n        {false, false} ->\n            false;\n        {false, true} ->\n            ?INFO_MSG(\"request ~p repeated but no response found in cache ~p~n\",\n                      [Rid, Sent]),\n            {true, none};\n        {CachedResponse, _} ->\n            {true, CachedResponse}\n    end.\n\nresend_cached({_Rid, _, CachedBody}, S) ->\n    send_to_handler(CachedBody, S).\n\nprocess_acked_stream_event({EventTag, Body, Rid}, SName,\n                           #state{} = S) ->\n    MaybeBAck = exml_query:attr(Body, <<\"ack\">>),\n    {Action, Ack} = determine_report_action(MaybeBAck, S#state.client_acks,\n                                            Rid, S#state.last_processed),\n    NS = maybe_trim_cache(Ack, S),\n    case Action of\n        noreport ->\n            process_stream_event(EventTag, Body, SName, NS#state{rid = Rid});\n        report ->\n            NS2 = schedule_report(Ack, NS),\n            NS3 = process_stream_event(EventTag, Body, SName,\n                                       NS2#state{rid = Rid}),\n            maybe_send_report(NS3)\n    end.\n\ndetermine_report_action(undefined, false, _, _) ->\n    {noreport, undefined};\ndetermine_report_action(undefined, true, Rid, LastProcessed) ->\n    if\n        Rid+1 == LastProcessed ->\n            {noreport, undefined};\n        Rid+1 /= LastProcessed ->\n            ?WARNING_MSG(\"expected 'ack' attribute on ~p~n\", [Rid]),\n            {noreport, undefined}\n    end;\ndetermine_report_action(BAck, _, _, LastProcessed) ->\n    Ack = binary_to_integer(BAck),\n    case {LastProcessed, is_valid_ack(Ack, LastProcessed)} of\n        {undefined, _} ->\n            {noreport, Ack};\n        {_, true} ->\n            {noreport, Ack};\n        {_, false} ->\n            {report, Ack}\n    end.\n\nis_valid_ack(Ack, LastProcessed)\n        when Ack < LastProcessed ->\n    false;\nis_valid_ack(_, _) ->\n    true.\n\nmaybe_trim_cache(undefined, S) ->\n    S;\nmaybe_trim_cache(Ack, S) ->\n    UpToAck = fun({R,_,_}) when R =< Ack ->\n                    true;\n                 (_) ->\n                    false\n              end,\n    NewSent = lists:dropwhile(UpToAck, S#state.sent),\n    S#state{sent = NewSent}.\n\nschedule_report(Ack, #state{sent = Sent} = S) ->\n    ReportRid = Ack + 1,\n    try\n        {resp,\n         {ReportRid, TimeSent, _}} = {resp, lists:keyfind(ReportRid, 1, Sent)},\n        ElapsedTimeMillis = erlang:round(timer:now_diff(now(), TimeSent)\n                                         / 1000),\n        Report = {ReportRid, ElapsedTimeMillis},\n        case S#state.report of\n            false ->\n                S#state{report = Report};\n            OldReport when OldReport < Report ->\n                S#state{report = OldReport};\n            _ ->\n                S#state{report = Report}\n        end\n    catch\n        error:{badmatch, {resp, false}} ->\n            ?ERROR_MSG(\"no cached response for RID ~p, responses ~p~n\",\n                       [ReportRid, Sent]),\n            S\n    end.\n\nmaybe_send_report(#state{report = false} = S) ->\n    S;\nmaybe_send_report(#state{} = S) ->\n    send_or_store([], S).\n\nprocess_stream_event(pause, Body, SName, State) ->\n    Seconds = binary_to_integer(exml_query:attr(Body, <<\"pause\">>)),\n    NewState = process_pause_event(Seconds, State),\n    process_deferred_events(SName, NewState);\nprocess_stream_event(EventTag, Body, SName, #state{c2s_pid = C2SPid} = State) ->\n    {Els, NewState} = bosh_unwrap(EventTag, Body, State),\n    [forward_to_c2s(C2SPid, El) || El <- Els],\n    process_deferred_events(SName, NewState).\n\nprocess_pause_event(Seconds, #state{maxpause = MaxPause} = S)\n        when MaxPause == undefined;\n             Seconds > MaxPause ->\n    [Pid ! policy_violation || {_, _, Pid} <- S#state.handlers],\n    throw({invalid_pause, S#state{handlers = []}});\nprocess_pause_event(Seconds, State) ->\n    NS = State#state{inactivity = Seconds},\n    F = fun(_, S) ->\n            send_to_handler([], S)\n    end,\n    lists:foldl(F, NS, lists:seq(1, length(State#state.handlers))).\n\nprocess_deferred_events(SName, #state{deferred = Deferred} = S) ->\n    lists:foldl(fun(Event, State) ->\n                    ?DEBUG(\"processing deferred event: ~p~n\", [Event]),\n                    handle_stream_event(Event, none, SName, State)\n                end,\n                S#state{deferred = []},\n                lists:sort(Deferred)).\n\nis_valid_rid(Rid, OldRid) when Rid == OldRid + 1 ->\n    true;\nis_valid_rid(_, _) ->\n    false.\n\nis_acceptable_rid(Rid, OldRid)\n        when Rid > OldRid + 1,\n             Rid =< OldRid + ?CONCURRENT_REQUESTS ->\n    true;\nis_acceptable_rid(_, _) ->\n    false.\n\n%% Send data to the client if any request handler is available.\n%% Otherwise, store for sending later.\nsend_or_store(Data, State) when not is_list(Data) ->\n    send_or_store([Data], State);\nsend_or_store(Data, #state{handlers = []} = S) ->\n    store(Data, S);\nsend_or_store(Data, State) ->\n    send_to_handler(Data, State).\n\n%% send_to_handler() assumes that Handlers is not empty!\n%% Be sure that's the case if calling it.\nsend_to_handler(Data, State) ->\n    {Handler, NS} = pick_handler(State),\n    send_to_handler(Handler, Data, NS).\n\n%% Return handler and new state if a handler is available\n%% or `false` otherwise.\n-spec pick_handler(#state{}) -> {{rid(), pid()}, #state{}} | false.\npick_handler(#state{handlers = []}) ->\n    false;\npick_handler(#state{handlers = Handlers} = S) ->\n    [{Rid, TRef, Pid} | HRest] = lists:sort(Handlers),\n    %% The cancellation might fail if the timer already fired.\n    %% Don't worry, it's handled on receiving the timeout message.\n    timer:cancel(TRef),\n    {{Rid, Pid}, S#state{handlers = HRest}}.\n\nsend_to_handler({_, Pid}, #xmlel{name = <<\"body\">>} = Wrapped, State) ->\n    send_wrapped_to_handler(Pid, Wrapped, State);\nsend_to_handler({Rid, Pid}, Data, State) ->\n    {Wrapped, NS} = bosh_wrap(Data, Rid, State),\n    NS2 = cache_response({Rid, now(), Wrapped}, NS),\n    send_wrapped_to_handler(Pid, Wrapped, NS2).\n\n%% This is the most specific variant of send_to_handler()\n%% and the *only one* actually performing a send\n%% to the cowboy_loop_handler serving a HTTP request.\nsend_wrapped_to_handler(Pid, Wrapped, #state{handlers = []} = State) ->\n    Pid ! {bosh_reply, Wrapped},\n    setup_inactivity_timer(State);\nsend_wrapped_to_handler(Pid, Wrapped, State) ->\n    Pid ! {bosh_reply, Wrapped},\n    State.\n\nmaybe_ack(HandlerRid, #state{rid = Rid} = S) ->\n    if\n        Rid > HandlerRid ->\n            server_ack(S#state.server_acks, Rid);\n        Rid =< HandlerRid ->\n            []\n    end.\n\nmaybe_report(#state{report = false} = S) ->\n    {[], S};\nmaybe_report(#state{report = Report} = S) ->\n    {ReportRid, ElapsedTime} = Report,\n    NewAttrs = [{<<\"report\">>, integer_to_binary(ReportRid)},\n                {<<\"time\">>, integer_to_binary(ElapsedTime)}],\n    {NewAttrs, S#state{report = false}}.\n\ncache_response({Rid,_,_} = Response, #state{sent = Sent} = S) ->\n    NewSent = lists:keymerge(1, [Response], Sent),\n    CacheUpTo = case S#state.client_acks of\n        true ->\n            %% Acknowledgements are on - there's no limit on the number\n            %% of cached responses.\n            infinity;\n        false ->\n            %% Leave up to ?CONCURRENT_REQUESTS responses in cache.\n            ?CONCURRENT_REQUESTS\n    end,\n    S#state{sent = cache_up_to(CacheUpTo, NewSent),\n            last_processed = last_processed(Rid, S#state.last_processed)}.\n\ncache_up_to(infinity, Responses) ->\n    Responses;\ncache_up_to(N, Responses) ->\n    lists:nthtail(max(0, length(Responses) - N), Responses).\n\nlast_processed(Rid, undefined) ->\n    Rid;\nlast_processed(Rid1, Rid2) ->\n    max(Rid1, Rid2).\n\nsetup_inactivity_timer(#state{inactivity = infinity} = S) ->\n    S;\nsetup_inactivity_timer(S) ->\n    cancel_inactivity_timer(S),\n    {ok, TRef} = timer:send_after(timer:seconds(S#state.inactivity),\n                                  inactivity_timeout),\n    S#state{inactivity_tref = TRef}.\n\ncancel_inactivity_timer(#state{inactivity_tref = undefined} = S) ->\n    S;\ncancel_inactivity_timer(S) ->\n    timer:cancel(S#state.inactivity_tref),\n    S#state{inactivity_tref = undefined}.\n\n%% Store data for sending later.\nstore(Data, #state{pending = Pending} = S) ->\n    S#state{pending = Pending ++ Data}.\n\nforward_to_c2s(C2SPid, StreamElement) ->\n    gen_fsm:send_event(C2SPid, StreamElement).\n\nmaybe_add_handler(Handler, Rid, S) when is_pid(Handler) ->\n    add_handler({Rid, Handler}, S);\nmaybe_add_handler(_, _, S) ->\n    S.\n\nadd_handler({Rid, Pid}, #state{handlers = Handlers} = S) ->\n    {ok, TRef} = timer:send_after(timer:seconds(S#state.wait),\n                                  {wait_timeout, {Rid, Pid}}),\n    S#state{handlers = [{Rid, TRef, Pid} | Handlers]}.\n\n%% Keep in mind the hardcoding for hold == 1.\nreturn_surplus_handlers(accumulate, #state{handlers = []} = State) ->\n    State;\nreturn_surplus_handlers(accumulate, #state{handlers = [_]} = State) ->\n    State;\nreturn_surplus_handlers(accumulate, #state{handlers = _} = S) ->\n    NS = send_to_handler([], S),\n    return_surplus_handlers(accumulate, NS);\nreturn_surplus_handlers(normal, #state{handlers = []} = State) ->\n    State;\nreturn_surplus_handlers(normal, #state{handlers = [_], pending = []} = State) ->\n    State;\nreturn_surplus_handlers(normal, #state{pending = Pending} = S) ->\n    NS = send_or_store(Pending, S#state{pending = []}),\n    return_surplus_handlers(normal, NS).\n\n-spec bosh_unwrap(EventTag, #xmlel{}, #state{})\n    -> {[StreamEvent], #state{}}\n    when EventTag :: event_type(),\n         StreamEvent :: #xmlstreamstart{}\n                     | {xmlstreamelement, #xmlel{}}\n                     | #xmlstreamend{}.\nbosh_unwrap(StreamEvent, Body, #state{} = S)\n       when StreamEvent =:= streamstart;\n            StreamEvent =:= restart ->\n    Wait = min(get_attr(<<\"wait\">>, Body, S#state.wait), mod_bosh:get_max_wait()),\n    Hold = get_attr(<<\"hold\">>, Body, S#state.hold),\n    ClientAcks = get_client_acks(StreamEvent, Body, S#state.client_acks),\n    E = stream_start(exml_query:attr(Body, <<\"from\">>),\n                     exml_query:attr(Body, <<\"to\">>)),\n    {[E], record_set(S, [{#state.wait, Wait},\n                         {#state.hold, Hold},\n                         {#state.client_acks, ClientAcks}])};\nbosh_unwrap(streamend, Body, State) ->\n    {Els, NewState} = bosh_unwrap(normal, Body, State),\n    {Els ++ [#xmlstreamend{name = <<>>}], NewState};\nbosh_unwrap(normal, Body, #state{sid = Sid} = State) ->\n    Sid = exml_query:attr(Body, <<\"sid\">>),\n    ?NS_HTTPBIND = exml_query:attr(Body, <<\"xmlns\">>),\n    {[{xmlstreamelement, El}\n      || El <- Body#xmlel.children,\n         %% Ignore whitespace keepalives.\n         El /= #xmlcdata{content = <<\" \">>}],\n     State}.\n\nget_client_acks(restart, _, Default) ->\n    Default;\nget_client_acks(streamstart, Element, Default) ->\n    case exml_query:attr(Element, <<\"ack\">>) of\n        undefined ->\n            Default;\n        <<\"1\">> ->\n            true;\n        _ ->\n            ?INFO_MSG(\"ignoring invalid client ack on stream start~n\", []),\n            false\n    end.\n\nget_attr(Attr, Element, Default) ->\n    case exml_query:attr(Element, Attr) of\n        undefined ->\n            Default;\n        Value ->\n            binary_to_integer(Value)\n    end.\n\nstream_start(From, To) ->\n    #xmlstreamstart{name = <<\"stream:stream\">>,\n                    attrs = [{<<\"from\">>, From},\n                             {<<\"to\">>, To},\n                             {<<\"version\">>, <<\"1.0\">>},\n                             {<<\"xml:lang\">>, <<\"en\">>},\n                             {<<\"xmlns\">>, <<\"jabber:client\">>},\n                             {<<\"xmlns:stream\">>, ?NS_STREAM}]}.\n\nbosh_wrap(Elements, Rid, #state{} = S) ->\n    EventsStanzas = lists:partition(fun is_stream_event/1, Elements),\n    {{Body, Children}, NS} = case EventsStanzas of\n        {[], Stanzas} ->\n            {{bosh_body(S), Stanzas}, S};\n        {[#xmlstreamstart{} = StreamStart], Stanzas} ->\n            {{bosh_stream_start_body(StreamStart, S), Stanzas}, S};\n        {[#xmlstreamend{}], []} ->\n            %% No stanzas except stream end - OK.\n            {{bosh_stream_end_body(), []}, S};\n        {[#xmlstreamend{} = StreamEnd], Stanzas} ->\n            %% Can't wrap remaining stanzas in a stream end body.\n            %% Send Stanzas and forfeit sending stream end.\n            ?DEBUG(\"pending stanzas, can't send stream end\", []),\n            Pending = S#state.pending,\n            {{bosh_body(S), Stanzas},\n             S#state{pending = Pending ++ [StreamEnd]}}\n    end,\n    MaybeAck = maybe_ack(Rid, NS),\n    {MaybeReport, NNS} = maybe_report(NS),\n    ExtraAttrs = MaybeAck ++ MaybeReport,\n    {Body#xmlel{attrs = Body#xmlel.attrs ++ ExtraAttrs,\n                children = Children}, NNS}.\n\nis_stream_event(#xmlstreamstart{}) ->\n    true;\nis_stream_event(#xmlstreamend{}) ->\n    true;\nis_stream_event(_) ->\n    false.\n\n%% Bosh body for a session creation response.\nbosh_stream_start_body(#xmlstreamstart{attrs = Attrs}, #state{} = S) ->\n    #xmlel{name = <<\"body\">>,\n           attrs = [{<<\"wait\">>, integer_to_binary(S#state.wait)},\n                    {<<\"requests\">>,\n                     integer_to_binary(?CONCURRENT_REQUESTS)},\n                    {<<\"hold\">>, integer_to_binary(S#state.hold)},\n                    {<<\"from\">>, proplists:get_value(<<\"from\">>, Attrs)},\n                    %% TODO: how to support these with cowboy?\n                    {<<\"accept\">>, <<\"deflate,gzip\">>},\n                    {<<\"sid\">>, S#state.sid},\n                    {<<\"xmpp:restartlogic\">>, <<\"true\">>},\n                    {<<\"xmpp:version\">>, <<\"1.0\">>},\n                    {<<\"xmlns\">>, ?NS_HTTPBIND},\n                    {<<\"xmlns:xmpp\">>, <<\"urn:xmpp:xbosh\">>},\n                    {<<\"xmlns:stream\">>, ?NS_STREAM}] ++\n           inactivity(S#state.inactivity) ++\n           maxpause(S#state.maxpause) ++\n           %% TODO: shouldn't an ack be sent on restart?\n           server_ack(S#state.server_acks, S#state.rid),\n           children = []}.\n\ninactivity(I) ->\n    [{<<\"inactivity\">>, integer_to_binary(I)} || is_integer(I)].\n\nmaxpause(MP) ->\n    [{<<\"maxpause\">>, integer_to_binary(MP)} || is_integer(MP)].\n\nserver_ack(ServerAcks, Rid) ->\n    [{<<\"ack\">>, integer_to_binary(Rid)} || ServerAcks =:= true].\n\n%% Bosh body for an ordinary stream element(s).\nbosh_body(#state{} = S) ->\n    #xmlel{name = <<\"body\">>,\n           attrs = [{<<\"sid\">>, S#state.sid},\n                    {<<\"xmlns\">>, ?NS_HTTPBIND}],\n           children = []}.\n\nbosh_stream_end_body() ->\n    #xmlel{name = <<\"body\">>,\n           attrs = [{<<\"type\">>, <<\"terminate\">>},\n                    {<<\"xmlns\">>, ?NS_HTTPBIND}],\n           children = []}.\n\n%%--------------------------------------------------------------------\n%% ejabberd_socket compatibility\n%%--------------------------------------------------------------------\n\n%% Should be negotiated on HTTP level.\nstarttls(SocketData, TLSOpts) ->\n    starttls(SocketData, TLSOpts, <<>>).\n\nstarttls(_SocketData, _TLSOpts, _Data) ->\n    throw({error, negotiate_tls_on_http_level}).\n\n%% Should be negotiated on HTTP level.\ncompress(SocketData) ->\n    compress(SocketData, <<>>).\n\ncompress(_SocketData, _Data) ->\n    throw({error, negotiate_compression_on_http_level}).\n\n%% TODO: adjust for BOSH\nreset_stream(#bosh_socket{pid = Pid} = SocketData) ->\n    Pid ! reset_stream,\n    SocketData.\n\nsend_xml(Socket, {xmlstreamelement, XML}) ->\n    send(Socket, XML);\nsend_xml(Socket, #xmlstreamstart{} = XML) ->\n    send(Socket, XML);\nsend_xml(Socket, #xmlstreamend{} = XML) ->\n    send(Socket, XML).\n\nsend(#bosh_socket{pid = Pid}, Data) ->\n    Pid ! {send, Data},\n    ok.\n\nchange_shaper(SocketData, _Shaper) ->\n    %% TODO: we ignore shapers for now\n    SocketData.\n\nmonitor(#bosh_socket{pid = Pid}) ->\n    erlang:monitor(process, Pid).\n\nget_sockmod(_SocketData) ->\n    ?MODULE.\n\nclose(#bosh_socket{pid = Pid}) ->\n    Pid ! close.\n\n-spec peername(#bosh_socket{}) -> {ok, {Addr, Port}}\n    when Addr :: inet:ip_address(),\n         Port :: inet:port_number().\npeername(#bosh_socket{peer = Peer}) ->\n    {ok, Peer}.\n\n%%--------------------------------------------------------------------\n%% Helpers\n%%--------------------------------------------------------------------\n\n%% Set Fields of the Record to Values,\n%% when {Field, Value} <- FieldValues (in list comprehension syntax).\nrecord_set(Record, FieldValues) ->\n    F = fun({Field, Value}, Rec) ->\n            setelement(Field, Rec, Value)\n        end,\n    lists:foldl(F, Record, FieldValues).\n\n%%--------------------------------------------------------------------\n%% Tests\n%%--------------------------------------------------------------------\n\n-ifdef(TEST).\n\n-include_lib(\"eunit/include/eunit.hrl\").\n\ncache_up_to_test_() ->\n    [?_test(?assertEqual( [4,5], cache_up_to(2, [1,2,3,4,5]) ))].\n\n-endif.\n", "%%%===================================================================\n%%% @copyright (C) 2013, Erlang Solutions Ltd.\n%%% @doc Module providing support for websockets in ejabberd\n%%% @end\n%%%===================================================================\n-module(mod_websockets).\n-behaviour(gen_mod).\n-behaviour(cowboy_http_handler).\n-behaviour(cowboy_websocket_handler).\n\n%% gen_mod callbacks\n-export([start/2,\n         stop/1]).\n\n%% cowboy_http_handler callbacks\n-export([init/3,\n         handle/2,\n         terminate/3]).\n\n%% cowboy_http_websocket_handler callbacks\n-export([websocket_init/3,\n         websocket_handle/3,\n         websocket_info/3,\n         websocket_terminate/3]).\n\n%% ejabberd_socket compatibility\n-export([starttls/2, starttls/3,\n         compress/1, compress/2,\n         reset_stream/1,\n         send/2,\n         send_xml/2,\n         change_shaper/2,\n         monitor/1,\n         get_sockmod/1,\n         close/1,\n         peername/1]).\n\n%% ejabberd_listener compatibility\n-export([socket_type/0,\n         start_listener/2]).\n\n-export([stop/0]).\n\n\n-include(\"ejabberd.hrl\").\n-include_lib(\"exml/include/exml_stream.hrl\").\n\n-define(LISTENER, ?MODULE).\n\n-record(websocket, {pid :: pid(),\n                    peername :: string()}).\n-record(ws_state, {c2s_pid :: pid(),\n                   parser :: exml_stream:parser()}).\n\n%%--------------------------------------------------------------------\n%% ejabberd_listener compatibility\n%%--------------------------------------------------------------------\n-spec socket_type() -> independent.\nsocket_type() ->\n    independent.\n\n% -spec start_listener(list())\nstart_listener({Port, IP, ws}, Opts) ->\n    Dispatch = get_dispatch(Opts),\n    NumAcceptors = gen_mod:get_opt(num_acceptors, Opts, 100),\n    start_ws(NumAcceptors, Port, IP, Dispatch);\n\nstart_listener({Port, IP, wss}, Opts) ->\n    Dispatch = get_dispatch(Opts),\n    NumAcceptors = gen_mod:get_opt(num_acceptors, Opts, 100),\n    SSLPort = gen_mod:get_opt(ssl_port, Opts, Port),\n    SSLCert = gen_mod:get_opt(cert, Opts, undefined),\n    SSLKey = gen_mod:get_opt(key, Opts, undefined),\n    SSLKeyPass = gen_mod:get_opt(key_pass, Opts, undefined),\n    start_wss(NumAcceptors, SSLPort, IP, SSLCert, SSLKey, SSLKeyPass, Dispatch).\n\n%%--------------------------------------------------------------------\n%% gen_mod callbacks\n%%--------------------------------------------------------------------\n\nstart(_Host, Opts) ->\n    NumAcceptors = gen_mod:get_opt(num_acceptors, Opts, 100),\n    Port = gen_mod:get_opt(port, Opts, undefined),\n    IP = gen_mod:get_opt(ip, Opts, {0,0,0,0}),\n    SSLPort = gen_mod:get_opt(ssl_port, Opts, undefined),\n    SSLCert = gen_mod:get_opt(cert, Opts, undefined),\n    SSLKey = gen_mod:get_opt(key, Opts, undefined),\n    SSLKeyPass = gen_mod:get_opt(key_pass, Opts, undefined),\n    Dispatch = get_dispatch(Opts),\n    {ok, _} = start_ws(NumAcceptors, Port, IP, Dispatch),\n    {ok, _} = start_wss(NumAcceptors, SSLPort, IP, SSLCert, SSLKey,\n                        SSLKeyPass, Dispatch).\n\nstart_ws(_, undefined, _, _) ->\n    {ok, not_started};\nstart_ws(NumAcceptors, Port, IP, Dispatch) ->\n    case cowboy:start_http(?LISTENER, NumAcceptors,\n                                [{port, Port}, {ip, IP}],\n                                [{env, [{dispatch, Dispatch}]}]) of\n        {error, {already_started, Pid}} ->\n            {ok, Pid};\n        {ok, Pid} ->\n            {ok, Pid};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\nstart_wss(_, _, _, undefined, undefined, undefined, _) ->\n    {ok, not_started};\nstart_wss(NumAcceptors, Port, IP, Cert, Key, Pass, Dispatch) ->\n    case cowboy:start_https({?LISTENER, secure}, NumAcceptors,\n                                [\n                                    {certfile, Cert},\n                                    {keyfile, Key},\n                                    {password, Pass},\n                                    {ip, IP},\n                                    {port, Port}\n                                ],\n                                [{env, [{dispatch, Dispatch}]}]) of\n        {error, {already_started, Pid}} ->\n            {ok, Pid};\n        {ok, Pid} ->\n            {ok, Pid};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\nstop() ->\n    stop(any).\n\nstop(_Host) ->\n    cowboy:stop_listener({?LISTENER, secure}),\n    cowboy:stop_listener(?LISTENER),\n    ok.\n\n%%--------------------------------------------------------------------\n%% cowboy_http_handler callbacks\n%%--------------------------------------------------------------------\n\ninit(Transport, Req, Opts) ->\n    ?DEBUG(\"cowboy init: ~p~n\", [{Transport, Req, Opts}]),\n    {upgrade, protocol, cowboy_websocket}.\n\nhandle(Req, State) ->\n        {ok, Req, State}.\n\nterminate(_Reason, _Req, _State) ->\n        ok.\n\n%%--------------------------------------------------------------------\n%% cowboy_http_websocket_handler callbacks\n%%--------------------------------------------------------------------\n\n% Called for every new websocket connection.\nwebsocket_init(Transport, Req, Opts) ->\n    ?DEBUG(\"websocket_init: ~p~n\", [{Transport, Req, Opts}]),\n    {Peer, NewReq} = cowboy_req:peer(Req),\n    NewReq2 = cowboy_req:set_resp_header(\"Sec-WebSocket-Protocol\", \"xmpp\", NewReq),\n    SocketData = #websocket{pid=self(),\n                            peername = Peer},\n    case ejabberd_c2s:start({?MODULE, SocketData}, Opts) of\n        {ok, Pid} ->\n            ?DEBUG(\"started c2s via websockets: ~p\", [Pid]),\n            {ok, Parser} = exml_stream:new_parser(),\n            State = #ws_state{c2s_pid = Pid,\n                              parser = Parser},\n            {ok, NewReq2, State};\n        {error, Reason} ->\n            ?WARNING_MSG(\"c2s start failed: ~p\", [Reason]),\n            {shutdown, NewReq2}\n    end.\n\n\n% Called when a text message arrives.\nwebsocket_handle({text, Msg}, Req, State) ->\n    ?INFO_MSG(\"Received: ~p\", [Msg]),\n    {ok, NewState} = handle_text(Msg, State),\n    {ok, Req, NewState};\n\nwebsocket_handle({binary, Msg}, Req, State) ->\n    ?INFO_MSG(\"Received binary: ~p\", [Msg]),\n    {ok, NewState} = handle_text(Msg, State),\n    {ok, Req, NewState};\n\n% With this callback we can handle other kind of\n% messages, like binary.\nwebsocket_handle(Any, Req, State) ->\n    ?INFO_MSG(\"Received non-text: ~p\", [Any]),\n    {ok, Req, State}.\n\n% Other messages from the system are handled here.\nwebsocket_info({send, Text}, Req, State) ->\n    {reply, {text, Text}, Req, State};\nwebsocket_info(reset_stream, Req, #ws_state{parser = Parser} = State) ->\n    {ok, NewParser} = exml_stream:reset_parser(Parser),\n    {ok, Req, State#ws_state{parser = NewParser}};\nwebsocket_info(stop, Req, #ws_state{parser = Parser} = State) ->\n    exml_stream:free_parser(Parser),\n    {shutdown, Req, State};\nwebsocket_info(Info, Req, State) ->\n    ?INFO_MSG(\"unknown info: ~p\", [Info]),\n    {ok, Req, State}.\n\nwebsocket_terminate(_Reason, _Req, _State) ->\n    ok.\n\n%%--------------------------------------------------------------------\n%% Callbacks implementation\n%%--------------------------------------------------------------------\n\nhandle_text(Text, #ws_state{c2s_pid = C2S, parser = Parser} = State) ->\n    {ok, NewParser, Elements} = exml_stream:parse(Parser, Text),\n    [send_to_c2s(C2S, Elem) || Elem <- Elements],\n    {ok, State#ws_state{parser = NewParser}}.\n\nsend_to_c2s(C2S, #xmlel{} = Element) ->\n    send_to_c2s(C2S, {xmlstreamelement, Element});\nsend_to_c2s(C2S, StreamElement) ->\n    gen_fsm:send_event(C2S, StreamElement).\n\n%%--------------------------------------------------------------------\n%% ejabberd_socket compatibility\n%%--------------------------------------------------------------------\n\nstarttls(SocketData, TLSOpts) ->\n    starttls(SocketData, TLSOpts, <<>>).\n\nstarttls(_SocketData, _TLSOpts, _Data) ->\n    throw({error, tls_not_allowed_on_websockets}).\n\ncompress(SocketData) ->\n    compress(SocketData, <<>>).\n\ncompress(_SocketData, _Data) ->\n    throw({error, compression_not_allowed_on_websockets}).\n\nreset_stream(#websocket{pid = Pid} = SocketData) ->\n    Pid ! reset_stream,\n    SocketData.\n\nsend_xml(SocketData, {xmlstreamraw, Text}) ->\n    send(SocketData, Text);\nsend_xml(SocketData, {xmlstreamelement, XML}) ->\n    send_xml(SocketData, XML);\nsend_xml(SocketData, XML) ->\n    Text = exml:to_iolist(XML),\n    send(SocketData, Text).\n\nsend(#websocket{pid = Pid}, Data) ->\n    Pid ! {send, Data},\n    ok.\n\nchange_shaper(SocketData, _Shaper) ->\n    SocketData. %% TODO: we ignore shapers for now\n\nmonitor(#websocket{pid = Pid}) ->\n    erlang:monitor(process, Pid).\n\nget_sockmod(_SocketData) ->\n    ?MODULE.\n\nclose(#websocket{pid = Pid}) ->\n    Pid ! close.\n\npeername(#websocket{peername = PeerName}) ->\n    {ok, PeerName}.\n\n%%--------------------------------------------------------------------\n%% Helpers\n%%--------------------------------------------------------------------\n\nget_dispatch(Opts) ->\n    WSHost = gen_mod:get_opt(host, Opts, '_'), %% default to any\n    WSPrefix = gen_mod:get_opt(prefix, Opts, \"/ws-xmpp\"),\n    cowboy_router:compile([{WSHost, [{WSPrefix, ?MODULE, Opts}] }]).\n", "%%%----------------------------------------------------------------------\n%%% File    : xml_stream.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Parse XML streams\n%%% Created : 17 Nov 2002 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(xml_stream).\n-author('alexey@process-one.net').\n\n-export([new/2,\n\t parse/2,\n\t close/1,\n\t parse_element/1]).\n\n-define(XML_START, 0).\n-define(XML_END,   1).\n-define(XML_CDATA, 2).\n-define(XML_ERROR, 3).\n\n-define(PARSE_COMMAND, 0).\n-define(PARSE_FINAL_COMMAND, 1).\n\n-include(\"jlib.hrl\").\n-record(xml_stream_state, {callback_pid, port, stack, size, maxsize}).\n\nprocess_data(CallbackPid, Stack, Data) ->\n    case Data of\n\t{?XML_START, {Name, Attrs}} ->\n\t    if\n\t\tStack == [] ->\n\t\t    catch gen_fsm:send_event(CallbackPid,\n\t\t\t\t\t     {xmlstreamstart, Name, Attrs});\n\t\ttrue ->\n\t\t    ok\n\t    end,\n\t    [#xmlel{name = Name, attrs = Attrs} | Stack];\n\t{?XML_END, EndName} ->\n\t    case Stack of\n\t\t[XE = #xmlel{children = Els} | Tail] ->\n\t\t    NewEl = XE#xmlel{children = lists:reverse(Els)},\n\t\t    case Tail of\n\t\t\t[] ->\n\t\t\t    catch gen_fsm:send_event(CallbackPid,\n\t\t\t\t\t\t     {xmlstreamend, EndName}),\n\t\t\t    Tail;\n\t\t\t[_] ->\n\t\t\t    catch gen_fsm:send_event(CallbackPid,\n\t\t\t\t\t\t     {xmlstreamelement, NewEl}),\n\t\t\t    Tail;\n\t\t\t[XE1 = #xmlel{children = Els1} | Tail1] ->\n\t\t\t    [XE1#xmlel{children = [NewEl | Els1]} |\n\t\t\t   Tail1]\n\t\t    end\n\t    end;\n\t{?XML_CDATA, CData} ->\n\t    case Stack of\n\t\t[El] ->\n\t\t    [El];\n\t\t%% Merge CDATA nodes if they are contiguous\n\t\t%% This does not change the semantic: the split in\n\t\t%% several CDATA nodes depends on the TCP/IP packet\n\t\t%% fragmentation\n\t\t[XE2 = #xmlel{children = [#xmlcdata{content = PreviousCData}\n\t\t                          | Els]} | Tail] ->\n\t\t    [XE2#xmlel{children = [#xmlcdata{content = list_to_binary([PreviousCData,\n\t\t                                                               CData])}\n                                           | Els]} | Tail];\n\t\t%% No previous CDATA\n\t\t[XE3 = #xmlel{children = Els} | Tail] ->\n\t\t    [XE3#xmlel{children = [#xmlcdata{content = CData} | Els]} |\n\t\t              Tail];\n\t\t[] -> []\n\t    end;\n\t{?XML_ERROR, Err} ->\n\t    catch gen_fsm:send_event(CallbackPid, {xmlstreamerror, Err})\n    end.\n\nnew(CallbackPid, MaxSize) ->\n    Port = open_port({spawn, expat_erl}, [binary]),\n    #xml_stream_state{callback_pid = CallbackPid,\n\t\t      port = Port,\n\t\t      stack = [],\n\t\t      size = 0,\n\t\t      maxsize = MaxSize}.\n\n\nparse(#xml_stream_state{callback_pid = CallbackPid,\n\t\t\tport = Port,\n\t\t\tstack = Stack,\n\t\t\tsize = Size,\n\t\t\tmaxsize = MaxSize} = State, Str) ->\n    StrSize = if\n\t\t  is_list(Str) -> length(Str);\n\t\t  is_binary(Str) -> size(Str)\n\t      end,\n    Res = port_control(Port, ?PARSE_COMMAND, Str),\n    {NewStack, NewSize} =\n\tlists:foldl(\n\t  fun(Data, {St, Sz}) ->\n\t\t  NewSt = process_data(CallbackPid, St, Data),\n\t\t  case NewSt of\n\t\t      [_] -> {NewSt, 0};\n\t\t      _ -> {NewSt, Sz}\n\t\t  end\n\t  end, {Stack, Size + StrSize}, binary_to_term(Res)),\n    if\n\tNewSize > MaxSize ->\n\t    catch gen_fsm:send_event(CallbackPid,\n\t\t\t\t     {xmlstreamerror, \"XML stanza is too big\"});\n\ttrue ->\n\t    ok\n    end,\n    State#xml_stream_state{stack = NewStack, size = NewSize}.\n\nclose(#xml_stream_state{port = Port}) ->\n    port_close(Port).\n\n\nparse_element(Str) ->\n    Port = open_port({spawn, expat_erl}, [binary]),\n    Res = port_control(Port, ?PARSE_FINAL_COMMAND, Str),\n    port_close(Port),\n    process_element_events(binary_to_term(Res)).\n\nprocess_element_events(Events) ->\n    process_element_events(Events, []).\n\nprocess_element_events([], _Stack) ->\n    {error, parse_error};\nprocess_element_events([Event | Events], Stack) ->\n    case Event of\n\t{?XML_START, {Name, Attrs}} ->\n\t    process_element_events(\n\t      Events, [#xmlel{name = Name, attrs = Attrs} | Stack]);\n\t{?XML_END, _EndName} ->\n\t    case Stack of\n\t\t[XE = #xmlel{children = Els} | Tail] ->\n\t\t    NewEl = XE#xmlel{children = lists:reverse(Els)},\n\t\t    case Tail of\n\t\t\t[] ->\n\t\t\t    if\n\t\t\t\tEvents == [] ->\n\t\t\t\t    NewEl;\n\t\t\t\ttrue ->\n\t\t\t\t    {error, parse_error}\n\t\t\t    end;\n\t\t\t[XE1 = #xmlel{children = Els1} | Tail1] ->\n\t\t\t    process_element_events(\n\t\t\t      Events,\n\t\t\t      [XE1#xmlel{children = [NewEl | Els1]} |\n\t\t\t     Tail1])\n\t\t    end\n\t    end;\n\t{?XML_CDATA, CData} ->\n\t    case Stack of\n\t\t[XE2 = #xmlel{children = Els} | Tail] ->\n\t\t    process_element_events(\n\t\t      Events,\n\t\t      [XE2#xmlel{children = [#xmlcdata{content = CData}\n\t\t                             | Els]} |\n     Tail]);\n\t\t[] ->\n\t\t    process_element_events(Events, [])\n\t    end;\n\t{?XML_ERROR, Err} ->\n\t    {error, Err}\n    end.\n\n", "%%%\n%%%               ejabberd configuration file\n%%%\n%%%'\n\n%%% The parameters used in this configuration file are explained in more detail\n%%% in the ejabberd Installation and Operation Guide.\n%%% Please consult the Guide in case of doubts, it is included with\n%%% your copy of ejabberd, and is also available online at\n%%% http://www.process-one.net/en/ejabberd/docs/\n\n%%% This configuration file contains Erlang terms.\n%%% In case you want to understand the syntax, here are the concepts:\n%%%\n%%%  - The character to comment a line is %\n%%%\n%%%  - Each term ends in a dot, for example:\n%%%      override_global.\n%%%\n%%%  - A tuple has a fixed definition, its elements are\n%%%    enclosed in {}, and separated with commas:\n%%%      {loglevel, 4}.\n%%%\n%%%  - A list can have as many elements as you want,\n%%%    and is enclosed in [], for example:\n%%%      [http_poll, web_admin, tls]\n%%%\n%%%    Pay attention that list elements are delimited with commas,\n%%%    but no comma is allowed after the last list element. This will\n%%%    give a syntax error unlike in more lenient languages (e.g. Python).\n%%%\n%%%  - A keyword of ejabberd is a word in lowercase.\n%%%    Strings are enclosed in \"\" and can contain spaces, dots, ...\n%%%      {language, \"en\"}.\n%%%      {ldap_rootdn, \"dc=example,dc=com\"}.\n%%%\n%%%  - This term includes a tuple, a keyword, a list, and two strings:\n%%%      {hosts, [\"jabber.example.net\", \"im.example.com\"]}.\n%%%\n%%%  - This config is preprocessed during release generation by a tool which\n%%%    interprets double curly braces as substitution markers, so avoid this\n%%%    syntax in this file (though it's valid Erlang).\n%%%\n%%%    So this is OK (though arguably looks quite ugly):\n%%%      { {s2s_addr, \"example-host.net\"}, {127,0,0,1} }.\n%%%\n%%%    And I can't give an example of what's not OK exactly because\n%%%    of this rule.\n%%%\n\n\n%%%.   =======================\n%%%'   OVERRIDE STORED OPTIONS\n\n%%\n%% Override the old values stored in the database.\n%%\n\n%%\n%% Override global options (shared by all ejabberd nodes in a cluster).\n%%\n%%override_global.\n\n%%\n%% Override local options (specific for this particular ejabberd node).\n%%\n%%override_local.\n\n%%\n%% Remove the Access Control Lists before new ones are added.\n%%\n%%override_acls.\n\n\n%%%.   =========\n%%%'   DEBUGGING\n\n%%\n%% loglevel: Verbosity of log files generated by ejabberd.\n%% 0: No ejabberd log at all (not recommended)\n%% 1: Critical\n%% 2: Error\n%% 3: Warning\n%% 4: Info\n%% 5: Debug\n%%\n{loglevel, 3}.\n\n%%\n%% alarms: an optional alarm handler, subscribed to system events\n%% long_gc: minimum GC time in ms for long_gc alarm\n%% large_heap: minimum process heap size for large_heap alarm\n%% handlers: a list of alarm handlers\n%%   - alarms_basic_handler:  logs alarms and stores a brief alarm summary\n%%   - alarms_folsom_handler: stores alarm details in folsom metrics\n%%\n%% Example:\n%% {alarms,\n%%  [{long_gc, 10000},\n%%   {large_heap, 1000000},\n%%   {handlers, [alarms_basic_handler,\n%%               alarms_folsom_handler]}]\n%% }.\n\n%%\n%% watchdog_admins: Only useful for developers: if an ejabberd process\n%% consumes a lot of memory, send live notifications to these XMPP\n%% accounts. Requires alarms (see above).\n%%\n%%{watchdog_admins, [\"bob@example.com\"]}.\n\n\n%%%.   ================\n%%%'   SERVED HOSTNAMES\n\n%%\n%% hosts: Domains served by ejabberd.\n%% You can define one or several, for example:\n%% {hosts, [\"example.net\", \"example.com\", \"example.org\"]}.\n%%\n{hosts, {{hosts}} }.\n\n%%\n%% route_subdomains: Delegate subdomains to other XMPP servers.\n%% For example, if this ejabberd serves example.org and you want\n%% to allow communication with an XMPP server called im.example.org.\n%%\n%%{route_subdomains, s2s}.\n\n\n%%%.   ===============\n%%%'   LISTENING PORTS\n\n%%\n%% listen: The ports ejabberd will listen on, which service each is handled\n%% by and what options to start it with.\n%%\n{listen,\n [\n\n  { {{cowboy_port}}, ejabberd_cowboy, [\n      {num_acceptors, 10},\n      {max_connections, 1024},\n      %% Uncomment for HTTPS\n      %{cert, \"priv/server.crt\"},\n      %{key, \"priv/server.key\"},\n      %{key_pass, \"\"},\n      {modules, [\n          %% Modules used here should also be listed in the MODULES section.\n          {\"_\", \"/http-bind\", mod_bosh},\n          {\"_\", \"/ws-xmpp\", mod_websockets},\n          {\"localhost\", \"/metrics\", mod_metrics}\n      ]}\n  ]},\n\n  { {{ejabberd_c2s_port}}, ejabberd_c2s, [\n\n\t\t\t%%\n\t\t\t%% If TLS is compiled in and you installed a SSL\n\t\t\t%% certificate, specify the full path to the\n\t\t\t%% file and uncomment this line:\n\t\t\t%%\n                        {{tls_config}}\n                        {{zlib}}\n\t\t\t{access, c2s},\n\t\t\t{shaper, c2s_shaper},\n\t\t\t{max_stanza_size, 65536}\n\t\t       ]},\n\n  %%\n  %% To enable the old SSL connection method on port 5223:\n  %%\n  %%{5223, ejabberd_c2s, [\n  %%\t\t\t{access, c2s},\n  %%\t\t\t{shaper, c2s_shaper},\n  %%\t\t\t{certfile, \"/path/to/ssl.pem\"}, tls,\n  %%\t\t\t{max_stanza_size, 65536}\n  %%\t\t       ]},\n\n  { {{ejabberd_s2s_in_port}}, ejabberd_s2s_in, [\n\t\t\t   {shaper, s2s_shaper},\n\t\t\t   {max_stanza_size, 131072}\n\t\t\t  ]}\n\n  %%\n  %% ejabberd_service: Interact with external components (transports, ...)\n  %%\n  %%{8888, ejabberd_service, [\n  %%\t\t\t    {access, all},\n  %%\t\t\t    {shaper_rule, fast},\n  %%\t\t\t    {ip, {127, 0, 0, 1}},\n  %%\t\t\t    {hosts, [\"icq.example.org\", \"sms.example.org\"],\n  %%\t\t\t     [{password, \"secret\"}]\n  %%\t\t\t    }\n  %%\t\t\t   ]},\n\n  %%\n  %% ejabberd_stun: Handles STUN Binding requests\n  %%\n  %%{ {3478, udp}, ejabberd_stun, []}\n\n ]}.\n\n%%\n%% s2s_use_starttls: Enable STARTTLS + Dialback for S2S connections.\n%% Allowed values are: false optional required required_trusted\n%% You must specify a certificate file.\n%%\n%%{s2s_use_starttls, optional}.\n\n%%\n%% s2s_certfile: Specify a certificate file.\n%%\n%%{s2s_certfile, \"/path/to/ssl.pem\"}.\n\n%%\n%% domain_certfile: Specify a different certificate for each served hostname.\n%%\n%%{domain_certfile, \"example.org\", \"/path/to/example_org.pem\"}.\n%%{domain_certfile, \"example.com\", \"/path/to/example_com.pem\"}.\n\n%%\n%% S2S whitelist or blacklist\n%%\n%% Default s2s policy for undefined hosts.\n%%\n{s2s_default_policy, {{s2s_default_policy}} }.\n\n%%\n%% Allow or deny communication with specific servers.\n%%\n%%{ {s2s_host, \"goodhost.org\"}, allow}.\n%%{ {s2s_host, \"badhost.org\"}, deny}.\n\n{outgoing_s2s_port, {{outgoing_s2s_port}} }.\n\n%%\n%% IP addresses predefined for specific hosts to skip DNS lookups.\n%% Ports defined here take precedence over outgoing_s2s_port.\n%% Examples:\n%%\n%% { {s2s_addr, \"example-host.net\"}, {127,0,0,1} }.\n%% { {s2s_addr, \"example-host.net\"}, { {127,0,0,1}, 5269 } }.\n{{s2s_addr}}\n\n%%\n%% Outgoing S2S options\n%%\n%% Preferred address families (which to try first) and connect timeout\n%% in milliseconds.\n%%\n%%{outgoing_s2s_options, [ipv4, ipv6], 10000}.\n\n%%%.   ==============\n%%%'   SESSION BACKEND\n\n%%{sm_backend, {mnesia, []}}.\n\n%%{sm_backend, {redis, [{pool_size, 3}, {worker_config, [{host, \"localhost\"}, {port, 6379}]}]}}.\n{sm_backend, {{sm_backend}} }.\n\n\n%%%.   ==============\n%%%'   AUTHENTICATION\n\n%%\n%% auth_method: Method used to authenticate the users.\n%% The default method is the internal.\n%% If you want to use a different method,\n%% comment this line and enable the correct ones.\n%%\n{auth_method, {{auth_method}} }.\n\n%%\n%% Authentication using external script\n%% Make sure the script is executable by ejabberd.\n%%\n%%{auth_method, external}.\n{{ext_auth_script}}\n\n%%\n%% Authentication using ODBC\n%% Remember to setup a database in the next section.\n%%\n%%{auth_method, odbc}.\n\n%%\n%% Authentication using PAM\n%%\n%%{auth_method, pam}.\n%%{pam_service, \"pamservicename\"}.\n\n%%\n%% Authentication using LDAP\n%%\n%%{auth_method, ldap}.\n%%\n{{auth_ldap}}\n%% List of LDAP servers:\n%%{ldap_servers, [\"localhost\"]}.\n%%\n%% Encryption of connection to LDAP servers:\n%%{ldap_encrypt, none}.\n%%{ldap_encrypt, tls}.\n%%\n%% Port to connect to on LDAP servers:\n%%{ldap_port, 389}.\n%%{ldap_port, 636}.\n%%\n%% LDAP manager:\n%%{ldap_rootdn, \"dc=example,dc=com\"}.\n%%\n%% Password of LDAP manager:\n%%{ldap_password, \"******\"}.\n%%\n%% Search base of LDAP directory:\n%%{ldap_base, \"dc=example,dc=com\"}.\n%%\n%% LDAP attribute that holds user ID:\n%%{ldap_uids, [{\"mail\", \"%u@mail.example.org\"}]}.\n%%\n%% LDAP filter:\n%%{ldap_filter, \"(objectClass=shadowAccount)\"}.\n\n%%\n%% Anonymous login support:\n%%   auth_method: anonymous\n%%   anonymous_protocol: sasl_anon | login_anon | both\n%%   allow_multiple_connections: true | false\n%%\n%%{host_config, \"public.example.org\", [{auth_method, anonymous},\n%%                                     {allow_multiple_connections, false},\n%%                                     {anonymous_protocol, sasl_anon}]}.\n%%\n%% To use both anonymous and internal authentication:\n%%\n%%{host_config, \"public.example.org\", [{auth_method, [internal, anonymous]}]}.\n{{host_config}}\n\n%%%.   ==============\n%%%'   DATABASE SETUP\n\n%% ejabberd by default uses the internal Mnesia database,\n%% so you do not necessarily need this section.\n%% This section provides configuration examples in case\n%% you want to use other database backends.\n%% Please consult the ejabberd Guide for details on database creation.\n\n%%\n%% MySQL server:\n%%\n{{odbc_server}}\n%%\n%% If you want to specify the port:\n%%{odbc_server, {mysql, \"server\", 1234, \"database\", \"username\", \"password\"}}.\n\n%%\n%% PostgreSQL server:\n%%\n%%{odbc_server, {pgsql, \"server\", \"database\", \"username\", \"password\"}}.\n%%\n%% If you want to specify the port:\n%%{odbc_server, {pgsql, \"server\", 1234, \"database\", \"username\", \"password\"}}.\n%%\n%% If you use PostgreSQL, have a large database, and need a\n%% faster but inexact replacement for \"select count(*) from users\"\n%%\n%%{pgsql_users_number_estimate, true}.\n\n%%\n%% ODBC compatible or MSSQL server:\n%%\n%%{odbc_server, \"DSN=ejabberd;UID=ejabberd;PWD=ejabberd\"}.\n\n%%\n%% Number of connections to open to the database for each virtual host\n%%\n%%{odbc_pool_size, 10}.\n\n%%\n%% Interval to make a dummy SQL request to keep the connections to the\n%% database alive. Specify in seconds: for example 28800 means 8 hours\n%%\n%%{odbc_keepalive_interval, undefined}.\n\n\n%%%.   ===============\n%%%'   TRAFFIC SHAPERS\n\n%%\n%% The \"normal\" shaper limits traffic speed to 1000 B/s\n%%\n{shaper, normal, {maxrate, 1000}}.\n\n%%\n%% The \"fast\" shaper limits traffic speed to 50000 B/s\n%%\n{shaper, fast, {maxrate, 50000}}.\n\n%%\n%% This option specifies the maximum number of elements in the queue\n%% of the FSM. Refer to the documentation for details.\n%%\n{max_fsm_queue, 1000}.\n\n\n%%%.   ====================\n%%%'   ACCESS CONTROL LISTS\n\n%%\n%% The 'admin' ACL grants administrative privileges to XMPP accounts.\n%% You can put here as many accounts as you want.\n%%\n%{acl, admin, {user, \"alice\", \"localhost\"}}.\n%{acl, admin, {user, \"a\", \"localhost\"}}.\n\n%%\n%% Blocked users\n%%\n%%{acl, blocked, {user, \"baduser\", \"example.org\"}}.\n%%{acl, blocked, {user, \"test\"}}.\n\n%%\n%% Local users: don't modify this line.\n%%\n{acl, local, {user_regexp, \"\"}}.\n\n%%\n%% More examples of ACLs\n%%\n%%{acl, jabberorg, {server, \"jabber.org\"}}.\n%%{acl, aleksey, {user, \"aleksey\", \"jabber.ru\"}}.\n%%{acl, test, {user_regexp, \"^test\"}}.\n%%{acl, test, {user_glob, \"test*\"}}.\n\n%%\n%% Define specific ACLs in a virtual host.\n%%\n%%{host_config, \"localhost\",\n%% [\n%%  {acl, admin, {user, \"bob-local\", \"localhost\"}}\n%% ]\n%%}.\n\n\n%%%.   ============\n%%%'   ACCESS RULES\n\n%% Maximum number of simultaneous sessions allowed for a single user:\n{access, max_user_sessions, [{10, all}]}.\n\n%% Maximum number of offline messages that users can have:\n{access, max_user_offline_messages, [{5000, admin}, {100, all}]}.\n\n%% This rule allows access only for local users:\n{access, local, [{allow, local}]}.\n\n%% Only non-blocked users can use c2s connections:\n{access, c2s, [{deny, blocked},\n\t       {allow, all}]}.\n\n%% For C2S connections, all users except admins use the \"normal\" shaper\n{access, c2s_shaper, [{none, admin},\n\t\t      {normal, all}]}.\n\n%% All S2S connections use the \"fast\" shaper\n{access, s2s_shaper, [{fast, all}]}.\n\n%% Admins of this server are also admins of the MUC service:\n{access, muc_admin, [{allow, admin}]}.\n\n%% Only accounts of the local ejabberd server can create rooms:\n{access, muc_create, [{allow, local}]}.\n\n%% All users are allowed to use the MUC service:\n{access, muc, [{allow, all}]}.\n\n%% In-band registration allows registration of any possible username.\n%% To disable in-band registration, replace 'allow' with 'deny'.\n{access, register, [{allow, all}]}.\n\n%% By default the frequency of account registrations from the same IP\n%% is limited to 1 account every 10 minutes. To disable, specify: infinity\n{registration_timeout, infinity}.\n\n%% Default settings for MAM.\n%% To set non-standard value, replace 'default' with 'allow' or 'deny'.\n%% Only user can access his/her archive by default.\n%% An online user can read room's archive by default.\n%% Only an owner can change settings and purge messages by default.\n%% Empty list (i.e. `[]`) means `[{deny, all}]`.\n{access, mam_set_prefs, [{default, all}]}.\n{access, mam_get_prefs, [{default, all}]}.\n{access, mam_lookup_messages, [{default, all}]}.\n{access, mam_purge_single_message, [{default, all}]}.\n{access, mam_purge_multiple_messages, [{default, all}]}.\n\n%% 1 command of the specified type per second.\n{shaper, mam_shaper, {maxrate, 1}}.\n%% This shaper is primeraly for Mnesia overload protection during stress testing.\n%% The limit is 1000 operations of each type per second.\n{shaper, mam_global_shaper, {maxrate, 1000}}.\n\n{access, mam_set_prefs_shaper, [{mam_shaper, all}]}.\n{access, mam_get_prefs_shaper, [{mam_shaper, all}]}.\n{access, mam_lookup_messages_shaper, [{mam_shaper, all}]}.\n{access, mam_purge_single_message_shaper, [{mam_shaper, all}]}.\n{access, mam_purge_multiple_messages_shaper, [{mam_shaper, all}]}.\n\n{access, mam_set_prefs_global_shaper, [{mam_global_shaper, all}]}.\n{access, mam_get_prefs_global_shaper, [{mam_global_shaper, all}]}.\n{access, mam_lookup_messages_global_shaper, [{mam_global_shaper, all}]}.\n{access, mam_purge_single_message_global_shaper, [{mam_global_shaper, all}]}.\n{access, mam_purge_multiple_messages_global_shaper, [{mam_global_shaper, all}]}.\n\n\n%%\n%% Define specific Access Rules in a virtual host.\n%%\n%%{host_config, \"localhost\",\n%% [\n%%  {access, c2s, [{allow, admin}, {deny, all}]},\n%%  {access, register, [{deny, all}]}\n%% ]\n%%}.\n\n\n%%%.   ================\n%%%'   DEFAULT LANGUAGE\n\n%%\n%% language: Default language used for server messages.\n%%\n{language, \"en\"}.\n\n%%\n%% Set a different default language in a virtual host.\n%%\n%%{host_config, \"localhost\",\n%% [{language, \"ru\"}]\n%%}.\n\n\n%%%.   =======\n%%%'   MODULES\n\n%%\n%% Modules enabled in all ejabberd virtual hosts.\n%% For list of possible modules options, check documentation.\n%% If module comes in two versions, like mod_last and mod_last_odbc,\n%% use only one of them.\n%%\n{modules,\n [\n  %{mod_admin_extra, [{submods, [node, accounts, sessions, vcard,\n  %                              roster, last, private, stanza, stats]}]},\n  {mod_adhoc, []},\n  {mod_disco, []},\n  {{mod_last}}\n  {mod_muc, [\n             {host, \"muc.@HOST@\"},\n             {access, muc},\n             {access_create, muc_create}\n            ]},\n  {mod_muc_log,\n        [\n        {outdir, \"/tmp/muclogs\"},\n        {access_log, muc}\n        ]},\n  {{mod_offline}}\n  {{mod_privacy}}\n  {{mod_private}}\n% {mod_private, [{backend, mnesia}]},\n% {mod_private, [{backend, odbc}]},\n  {mod_register, [\n\t\t  %%\n\t\t  %% Set the minimum informational entropy for passwords.\n\t\t  %%\n\t\t  %%{password_strength, 32},\n\n\t\t  %%\n\t\t  %% After successful registration, the user receives\n\t\t  %% a message with this subject and body.\n\t\t  %%\n\t\t  {welcome_message, {\"\"}},\n\n\t\t  %%\n\t\t  %% When a user registers, send a notification to\n\t\t  %% these XMPP accounts.\n\t\t  %%\n\t\t  %%{registration_watchers, [\"admin1@example.org\"]},\n\n\t\t  %%\n\t\t  %% Only clients in the server machine can register accounts\n\t\t  %%\n\t\t  {ip_access, [{allow, \"127.0.0.0/8\"},\n\t\t\t       {deny, \"0.0.0.0/0\"}]},\n\n\t\t  %%\n\t\t  %% Local c2s or remote s2s users cannot register accounts\n\t\t  %%\n\t\t  %%{access_from, deny},\n\n\t\t  {access, register}\n\t\t ]},\n  {{mod_roster}}\n  {mod_sic, []},\n  {{mod_vcard}}\n  {mod_bosh, []},\n  {mod_websockets, []},\n  {mod_metrics, []}\n\n  %% \n  %% Message Archive Management (MAM) for registered users.\n  %%\n\n  %% A module for storing preferences in RDBMS (used by default).\n  %% Enable for private message archives.\n% {mod_mam_odbc_prefs, [pm]},\n  %% Enable for multiuser message archives.\n% {mod_mam_odbc_prefs, [muc]},\n  %% Enable for both private and multiuser message archives.\n% {mod_mam_odbc_prefs, [pm, muc]},\n\n  %% A module for storing preferences in Mnesia (recommended).\n  %% This module will be called each time, as a message is routed.\n  %% That is why, Mnesia is better for this job.\n% {mod_mam_mnesia_prefs, [pm, muc]},\n\n  %% Mnesia back-end with optimized writes and dirty synchronious writes.\n% {mod_mam_mnesia_dirty_prefs, [pm, muc]},\n\n  %% A back-end for storing messages.\n  %% Synchronious writer (used by default).\n  %% This writer is easy to debug, but writing performance is low.\n% {mod_mam_odbc_arch, [pm]},\n\n  %% Enable the module with a custom writer.\n% {mod_mam_odbc_arch, [no_writer, pm]},\n\n  %% Asynchronious writer for RDBMS (recommended).\n  %% Messages will be grouped and inserted all at once.\n% {mod_mam_odbc_async_writer, [pm]},\n\n  %% A pool of asynchronious writers (recommended).\n  %% Messages will be grouped together based on archive id.\n% {mod_mam_odbc_async_pool_writer, [pm]},\n\n  %% A module for converting an archive id to an integer.\n  %% Extract information using ODBC.\n% {mod_mam_odbc_user, [pm, muc]},\n\n  %% Cache information about users (recommended).\n  %% Requires mod_mam_odbc_user or alternative.\n% {mod_mam_cache_user, [pm, muc]},\n\n  %% Enable MAM.\n% {mod_mam, []},\n\n\n  %%\n  %% Message Archive Management (MAM) for multi-user chats (MUC).\n  %% Enable XEP-0313 for \"muc.@HOST@\".\n  %%\n\n  %% A back-end for storing messages (default for MUC).\n  %% Modules mod_mam_muc_* are optimized for MUC.\n  %%\n  %% Synchronious writer (used by default for MUC).\n  %% This module is easy to debug, but performance is low.\n% {mod_mam_muc_odbc_arch, []},\n% {mod_mam_muc_odbc_arch, [no_writer]},\n\n  %% Asynchronious writer for RDBMS (recommended for MUC).\n  %% Messages will be grouped and inserted all at once.\n% {mod_mam_muc_odbc_async_writer, []},\n% {mod_mam_muc_odbc_async_pool_writer, []},\n\n  %% Load mod_mam_odbc_user too.\n\n  %% Enable MAM for MUC\n% {mod_mam_muc, [{host, \"muc.@HOST@\"}]}\n\n\n  %%\n  %% MAM configuration examples\n  %%\n\n  %% Only MUC, no user-defined preferences, good performance.\n% {mod_mam_odbc_user, [muc]},\n% {mod_mam_cache_user, [muc]},\n% {mod_mam_muc_odbc_arch, [no_writer]},\n% {mod_mam_muc_odbc_async_pool_writer, []},\n% {mod_mam_muc, [{host, \"muc.@HOST@\"}]}\n\n  %% Only archives for c2c messages, good performance.\n% {mod_mam_odbc_user, [pm]},\n% {mod_mam_cache_user, [pm]},\n% {mod_mam_mnesia_dirty_prefs, [pm]},\n% {mod_mam_odbc_arch, [pm, no_writer]},\n% {mod_mam_odbc_async_pool_writer, [pm]},\n% {mod_mam, []}\n\n  %% Basic configuration for c2c messages, bad performance, easy to debug.\n% {mod_mam_odbc_user, [pm]},\n% {mod_mam_odbc_prefs, [pm]},\n% {mod_mam_odbc_arch, [pm]},\n% {mod_mam, []}\n\n ]}.\n\n{{module_host_config}}\n%%\n%% Enable modules with custom options in a specific virtual host\n%%\n%%{host_config, \"localhost\",\n%% [{ {add, modules},\n%%   [\n%%    {mod_some_module, []}\n%%   ]\n%%  }\n%% ]}.\n\n%%%.\n%%%'\n\n%%% $Id$\n\n%%% Local Variables:\n%%% mode: erlang\n%%% End:\n%%% vim: set filetype=erlang tabstop=8 foldmarker=%%%',%%%. foldmethod=marker:\n%%%.\n", "{hosts, \"[\\\"localhost\\\",\n          \\\"anonymous.localhost\\\",\n          \\\"localhost.bis\\\"\n         ]\"}.\n{host_config,\n\"{host_config, \\\"anonymous.localhost\\\", [{auth_method, anonymous},\n                                        {allow_multiple_connections, true},\n                                        {anonymous_protocol, both}]}.\" }.\n{outgoing_s2s_port, 5279}.\n{odbc_server, \"\"}.\n{auth_ldap,\"\"}.\n{s2s_addr, \"{ {s2s_addr, \\\"localhost2\\\"}, {127,0,0,1} }.\"}.\n{s2s_default_policy, allow}.\n{node_name, \"ejabberd@localhost\"}.\n{ejabberd_c2s_port, 5222}.\n{ejabberd_s2s_in_port, 5269}.\n{mod_last, \"{mod_last, []},\"}.\n{mod_offline, \"{mod_offline, [{access_max_user_messages, max_user_offline_messages}]},\"}.\n{mod_privacy, \"{mod_privacy, []},\"}.\n{mod_private, \"{mod_private, []},\"}.\n{mod_roster, \"{mod_roster, []},\"}.\n{mod_vcard, \"{mod_vcard, [ {allow_return_all, true},\\n\"\n                \"{search_all_hosts, true}\\n\"\n                \"%{matches, 1},\\n\"\n                \"%{search, true},\\n\"\n                \"%{host, directory.@HOST@}\\n\"\n                \"]},\"}.\n{cowboy_port, 5280}.\n{tls_config, \"{certfile, \\\"/tmp/server.pem\\\"}, starttls,\"}.\n{ {s2s_addr, \"localhost2\"}, {127,0,0,1} }.\n{ {s2s_addr, \"micha\u0142\"}, {127,0,0,1} }.\n{module_host_config, \"\"}.\n", "{hosts, \"[\\\"localhost\\\"]\"}.\n{host_config, \"\"}.\n{odbc_server, \"%% {odbc_server, {mysql, \\\"localhost\\\", 3306, \\\"database\\\", \\\"username\\\", \\\"password\\\"}}.\"}.\n{auth_ldap, \"\"}.\n{s2s_addr, \"%% { {s2s_addr, \\\"example-host.net\\\"}, { {127,0,0,1}, 5269 } }.\"}.\n{s2s_default_policy, deny}.\n{outgoing_s2s_port, 5269}.\n{node_name, \"mongooseim@localhost\"}.\n{ejabberd_c2s_port, 5222}.\n{ejabberd_s2s_in_port, 5269}.\n{cowboy_port, 5280}.\n{mod_last, \"{mod_last, []},\"}.\n{mod_offline, \"{mod_offline, [{access_max_user_messages, max_user_offline_messages}]},\"}.\n{mod_privacy, \"{mod_privacy, []},\"}.\n{mod_private, \"{mod_private, []},\"}.\n{mod_roster, \"{mod_roster, []},\"}.\n{mod_vcard, \"{mod_vcard, [ {allow_return_all, true},\\n\"\n                \"{search_all_hosts, true}\\n\"\n                \"%{matches, 1},\\n\"\n                \"%{search, true},\\n\"\n                \"%{host, directory.@HOST@}\\n\"\n                \"]},\"}.\n{mod_snmp,   \"%% CAUTION: serious performance problems have been found in the snmp_rt module\\n\"\n           \"  %% which is part of the ejabberd SNMP implementation. It's advised not to use\\n\"\n           \"  %% SNMP statistics until a fix is released or at least use it with option\\n\"\n           \"  %%     {rt_enabled, false}\\n\"\n           \"  %% as shown below. Some counters will always return 0 because of that.\\n\"\n           \"  %%, {mod_snmp, [{modules, []}, {rt_enabled, false}]}\"}.\n{sm_backend, \"{mnesia, []}\"}.\n{auth_method, \"internal\"}.\n{ext_auth_script, \"%%{extauth_program, \\\"/path/to/authentication/script\\\"}.\"}.\n{tls_config, \"%%{certfile, \\\"/path/to/ssl.pem\\\"}, starttls,\"}.\n{wss_config, \"%%,{cert, \\\"priv/server.crt\\\"}, {key, \\\"priv/server.key\\\"}, {key_pass, \\\"\\\"}\"}. %% PEM format\n{zlib, \"\"}.\n"], "fixing_code": ["/*\n * ejabberd, Copyright (C) 2002-2011   ProcessOne\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n * 02111-1307 USA\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <erl_driver.h>\n#include <zlib.h>\n\n\n#define BUF_SIZE 1024\n\n/*\n * R15B changed several driver callbacks to use ErlDrvSizeT and\n * ErlDrvSSizeT typedefs instead of int.\n * This provides missing typedefs on older OTP versions.\n */\n#if ERL_DRV_EXTENDED_MAJOR_VERSION < 2\ntypedef int ErlDrvSizeT;\ntypedef int ErlDrvSSizeT;\n#endif\n\ntypedef struct {\n      ErlDrvPort port;\n      z_stream *d_stream;\n      z_stream *i_stream;\n} ejabberd_zlib_data;\n\nstatic void* zlib_alloc(void* data, unsigned int items, unsigned int size)\n{\n    return (void*) driver_alloc(items*size);\n}\n\nstatic void zlib_free(void* data, void* addr)\n{\n    driver_free(addr);\n}\n\nstatic ErlDrvData ejabberd_zlib_drv_start(ErlDrvPort port, char *buff)\n{\n   ejabberd_zlib_data *d =\n      (ejabberd_zlib_data *)driver_alloc(sizeof(ejabberd_zlib_data));\n   d->port = port;\n\n   d->d_stream = (z_stream *)driver_alloc(sizeof(z_stream));\n\n   d->d_stream->zalloc = zlib_alloc;\n   d->d_stream->zfree = zlib_free;\n   d->d_stream->opaque = (voidpf)0;\n\n   deflateInit(d->d_stream, Z_DEFAULT_COMPRESSION);\n\n   d->i_stream = (z_stream *)driver_alloc(sizeof(z_stream));\n\n   d->i_stream->zalloc = zlib_alloc;\n   d->i_stream->zfree = zlib_free;\n   d->i_stream->opaque = (voidpf)0;\n\n   inflateInit(d->i_stream);\n\n   set_port_control_flags(port, PORT_CONTROL_FLAG_BINARY);\n\n   return (ErlDrvData)d;\n}\n\nstatic void ejabberd_zlib_drv_stop(ErlDrvData handle)\n{\n   ejabberd_zlib_data *d = (ejabberd_zlib_data *)handle;\n\n   deflateEnd(d->d_stream);\n   driver_free(d->d_stream);\n\n   inflateEnd(d->i_stream);\n   driver_free(d->i_stream);\n\n   driver_free((char *)handle);\n}\n\n\n#define DEFLATE 1\n#define INFLATE 2\n\n#define die_unless(cond, errstr)\t\t\t\t\\\n\t if (!(cond))\t\t\t\t\t\t\\\n\t {\t\t\t\t\t\t\t\\\n\t    rlen = strlen(errstr) + 1;\t\t\t\t\\\n\t    b = driver_realloc_binary(b, rlen);\t\t\t\\\n\t    b->orig_bytes[0] = 1;\t\t\t\t\\\n\t    strncpy(b->orig_bytes + 1, errstr, rlen - 1);\t\\\n\t    *rbuf = (char *)b;\t\t\t\t\t\\\n\t    return rlen;\t\t\t\t\t\\\n\t }\n\n\nstatic ErlDrvSSizeT ejabberd_zlib_drv_control(ErlDrvData handle,\n        unsigned int command,\n        char *buf, ErlDrvSizeT len,\n        char **rbuf, ErlDrvSizeT rlen)\n{\n    ejabberd_zlib_data *d = (ejabberd_zlib_data *)handle;\n    int err;\n    int size;\n    int size_limit;\n    ErlDrvBinary *b;\n\n    // operation is in command's 2 lower bits and size_limit is in bits higher than 1\n    size_limit = command >> 2; // applies only to inflation\n    command = command & 3;\n    switch (command)\n    {\n        case DEFLATE:\n            size = BUF_SIZE + 1;\n            rlen = 1;\n            b = driver_alloc_binary(size);\n            b->orig_bytes[0] = 0;\n\n            d->d_stream->next_in = (unsigned char *)buf;\n            d->d_stream->avail_in = len;\n            d->d_stream->avail_out = 0;\n            err = Z_OK;\n\n            while (err == Z_OK && d->d_stream->avail_out == 0)\n            {\n                d->d_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n                d->d_stream->avail_out = BUF_SIZE;\n\n                err = deflate(d->d_stream, Z_SYNC_FLUSH);\n                die_unless((err == Z_OK) || (err == Z_STREAM_END),\n                        \"deflate_error\");\n\n                rlen += (BUF_SIZE - d->d_stream->avail_out);\n                size += (BUF_SIZE - d->d_stream->avail_out);\n                b = driver_realloc_binary(b, size);\n            }\n            b = driver_realloc_binary(b, rlen);\n            *rbuf = (char *)b;\n            return rlen;\n        case INFLATE:\n            size = BUF_SIZE + 1;\n            rlen = 1;\n            b = driver_alloc_binary(size);\n            b->orig_bytes[0] = 0;\n\n            if (len > 0) {\n                d->i_stream->next_in = (unsigned char *)buf;\n                d->i_stream->avail_in = len;\n                d->i_stream->avail_out = 0;\n                err = Z_OK;\n\n                while (err == Z_OK && d->i_stream->avail_out == 0)\n                {\n                    d->i_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n                    d->i_stream->avail_out = BUF_SIZE;\n\n                    err = inflate(d->i_stream, Z_SYNC_FLUSH);\n                    die_unless((err == Z_OK) || (err == Z_STREAM_END),\n                            \"inflate_error\");\n\n                    rlen += (BUF_SIZE - d->i_stream->avail_out);\n                    die_unless((rlen < size_limit) || (size_limit == 0),\n                            \"inflate_size_exceeded\");\n\n                    size += (BUF_SIZE - d->i_stream->avail_out);\n                    b = driver_realloc_binary(b, size);\n                }\n            }\n            b = driver_realloc_binary(b, rlen);\n            *rbuf = (char *)b;\n            return rlen;\n    }\n\n    b = driver_alloc_binary(1);\n    b->orig_bytes[0] = 0;\n    *rbuf = (char *)b;\n    return 1;\n}\n\n\nErlDrvEntry ejabberd_zlib_driver_entry = {\n   NULL,\t\t\t/* F_PTR init, N/A */\n   ejabberd_zlib_drv_start,\t/* L_PTR start, called when port is opened */\n   ejabberd_zlib_drv_stop,\t/* F_PTR stop, called when port is closed */\n   NULL,\t\t\t/* F_PTR output, called when erlang has sent */\n   NULL,\t\t\t/* F_PTR ready_input, called when input descriptor ready */\n   NULL,\t\t\t/* F_PTR ready_output, called when output descriptor ready */\n   \"ejabberd_zlib_drv\",\t\t/* char *driver_name, the argument to open_port */\n   NULL,\t\t\t/* F_PTR finish, called when unloaded */\n   NULL,\t\t\t/* handle */\n   ejabberd_zlib_drv_control,   /* F_PTR control, port_command callback */\n   NULL,\t\t\t/* F_PTR timeout, reserved */\n   NULL,\t\t\t\t/* F_PTR outputv, reserved */\n   /* Added in Erlang/OTP R15B: */\n   NULL,                 /* ready_async */\n   NULL,                 /* flush */\n   NULL,                 /* call */\n   NULL,                 /* event */\n   ERL_DRV_EXTENDED_MARKER,        /* extended_marker */\n   ERL_DRV_EXTENDED_MAJOR_VERSION, /* major_version */\n   ERL_DRV_EXTENDED_MINOR_VERSION, /* minor_version */\n   0,                    /* driver_flags */\n   NULL,                 /* handle2 */\n   NULL,                 /* process_exit */\n   NULL\t\t\t\t\t /* stop select */\n};\n\nDRIVER_INIT(ejabberd_zlib_drv) /* must match name in driver_entry */\n{\n   return &ejabberd_zlib_driver_entry;\n}\n\n\n", "%%%----------------------------------------------------------------------\n%%% File    : ejabberd_c2s.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Serve C2S connection\n%%% Created : 16 Nov 2002 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(ejabberd_c2s).\n-author('alexey@process-one.net').\n-update_info({update, 0}).\n\n-define(GEN_FSM, p1_fsm).\n\n-behaviour(?GEN_FSM).\n\n%% External exports\n-export([start/2,\n\t stop/1,\n\t start_link/2,\n\t send_text/2,\n\t send_element/2,\n\t socket_type/0,\n\t get_presence/1,\n\t get_aux_field/2,\n\t set_aux_field/3,\n\t del_aux_field/2,\n\t get_subscription/2,\n\t broadcast/4,\n\t get_subscribed/1]).\n\n%% gen_fsm callbacks\n-export([init/1,\n\t wait_for_stream/2,\n\t wait_for_auth/2,\n\t wait_for_feature_request/2,\n\t wait_for_bind/2,\n\t wait_for_session/2,\n\t wait_for_sasl_response/2,\n\t session_established/2,\n\t handle_event/3,\n\t handle_sync_event/4,\n\t code_change/4,\n\t handle_info/3,\n\t terminate/3,\n\t print_state/1]).\n\n-include(\"ejabberd.hrl\").\n-include(\"jlib.hrl\").\n-include(\"mod_privacy.hrl\").\n\n-define(SETS, gb_sets).\n-define(DICT, dict).\n\n%% pres_a contains all the presence available send (either through roster mechanism or directed).\n%% Directed presence unavailable remove user from pres_a.\n-record(state, {socket,\n\t\tsockmod,\n\t\tsocket_monitor,\n\t\txml_socket,\n\t\tstreamid,\n\t\tsasl_state,\n\t\taccess,\n\t\tshaper,\n\t\tzlib = {false, 0},\n\t\ttls = false,\n\t\ttls_required = false,\n\t\ttls_enabled = false,\n\t\ttls_options = [],\n\t\tauthenticated = false,\n\t\tjid,\n\t\tuser = <<>>, server = ?MYNAME, resource = <<>>,\n\t\tsid,\n\t\tpres_t = ?SETS:new(),\n\t\tpres_f = ?SETS:new(),\n\t\tpres_a = ?SETS:new(),\n\t\tpres_i = ?SETS:new(),\n\t\tpending_invitations = [],\n\t\tpres_last, pres_pri,\n\t\tpres_timestamp,\n\t\tpres_invis = false,\n\t\tprivacy_list = #userlist{},\n\t\tconn = unknown,\n\t\tauth_module = unknown,\n\t\tip,\n\t\taux_fields = [],\n\t\tlang}).\n\n%-define(DBGFSM, true).\n\n-ifdef(DBGFSM).\n-define(FSMOPTS, [{debug, [trace]}]).\n-else.\n-define(FSMOPTS, []).\n-endif.\n\n%% Module start with or without supervisor:\n-ifdef(NO_TRANSIENT_SUPERVISORS).\n-define(SUPERVISOR_START, ?GEN_FSM:start(ejabberd_c2s, [SockData, Opts],\n\t\t\t\t\t fsm_limit_opts(Opts) ++ ?FSMOPTS)).\n-else.\n-define(SUPERVISOR_START, supervisor:start_child(ejabberd_c2s_sup,\n\t\t\t\t\t\t [SockData, Opts])).\n-endif.\n\n%% This is the timeout to apply between event when starting a new\n%% session:\n-define(C2S_OPEN_TIMEOUT, 60000).\n-define(C2S_HIBERNATE_TIMEOUT, 90000).\n\n-define(STREAM_HEADER,\n\t\"<?xml version='1.0'?>\"\n\t\"<stream:stream xmlns='jabber:client' \"\n\t\"xmlns:stream='http://etherx.jabber.org/streams' \"\n\t\"id='~s' from='~s'~s~s>\"\n       ).\n\n-define(STREAM_TRAILER, \"</stream:stream>\").\n\n-define(INVALID_NS_ERR, ?SERR_INVALID_NAMESPACE).\n-define(INVALID_XML_ERR, ?SERR_XML_NOT_WELL_FORMED).\n-define(HOST_UNKNOWN_ERR, ?SERR_HOST_UNKNOWN).\n-define(POLICY_VIOLATION_ERR(Lang, Text),\n\t?SERRT_POLICY_VIOLATION(Lang, Text)).\n-define(INVALID_FROM, ?SERR_INVALID_FROM).\n\n\n%%%----------------------------------------------------------------------\n%%% API\n%%%----------------------------------------------------------------------\nstart(SockData, Opts) ->\n    ?SUPERVISOR_START.\n\nstart_link(SockData, Opts) ->\n    ?GEN_FSM:start_link(ejabberd_c2s, [SockData, Opts],\n\t\t\tfsm_limit_opts(Opts) ++ ?FSMOPTS).\n\nsocket_type() ->\n    xml_stream.\n\n%% Return Username, Resource and presence information\nget_presence(FsmRef) ->\n    ?GEN_FSM:sync_send_all_state_event(FsmRef, get_presence, 1000).\n\nget_aux_field(Key, #state{aux_fields = Opts}) ->\n    case lists:keyfind(Key, 1, Opts) of\n\t{_, Val} ->\n\t    {ok, Val};\n\t_ ->\n\t    error\n    end.\n\nset_aux_field(Key, Val, #state{aux_fields = Opts} = State) ->\n    Opts1 = lists:keydelete(Key, 1, Opts),\n    State#state{aux_fields = [{Key, Val}|Opts1]}.\n\ndel_aux_field(Key, #state{aux_fields = Opts} = State) ->\n    Opts1 = lists:keydelete(Key, 1, Opts),\n    State#state{aux_fields = Opts1}.\n\nget_subscription(From = #jid{}, StateData) ->\n    get_subscription(jlib:jid_tolower(From), StateData);\nget_subscription(LFrom, StateData) ->\n    LBFrom = setelement(3, LFrom, <<>>),\n    F = ?SETS:is_element(LFrom, StateData#state.pres_f) orelse\n\t?SETS:is_element(LBFrom, StateData#state.pres_f),\n    T = ?SETS:is_element(LFrom, StateData#state.pres_t) orelse\n\t?SETS:is_element(LBFrom, StateData#state.pres_t),\n    if F and T -> both;\n       F -> from;\n       T -> to;\n       true -> none\n    end.\n\nbroadcast(FsmRef, Type, From, Packet) ->\n    FsmRef ! {broadcast, Type, From, Packet}.\n\nstop(FsmRef) ->\n    ?GEN_FSM:send_event(FsmRef, closed).\n\n%%%----------------------------------------------------------------------\n%%% Callback functions from gen_fsm\n%%%----------------------------------------------------------------------\n\n%%----------------------------------------------------------------------\n%% Func: init/1\n%% Returns: {ok, StateName, StateData}          |\n%%          {ok, StateName, StateData, Timeout} |\n%%          ignore                              |\n%%          {stop, StopReason}\n%%----------------------------------------------------------------------\ninit([{SockMod, Socket}, Opts]) ->\n    Access = case lists:keyfind(access, 1, Opts) of\n\t\t {_, A} -> A;\n\t\t _ -> all\n\t     end,\n    Shaper = case lists:keyfind(shaper, 1, Opts) of\n\t\t {_, S} -> S;\n\t\t _ -> none\n\t     end,\n    XMLSocket =\n\tcase lists:keyfind(xml_socket, 1, Opts) of\n\t    {_, XS} -> XS;\n\t    _ -> false\n\tend,\n    Zlib = case lists:keyfind(zlib, 1, Opts) of\n               {_, ZlibLimit} -> {true, ZlibLimit};\n               _ -> {false, 0}\n           end,\n    StartTLS = lists:member(starttls, Opts),\n    StartTLSRequired = lists:member(starttls_required, Opts),\n    TLSEnabled = lists:member(tls, Opts),\n    TLS = StartTLS orelse StartTLSRequired orelse TLSEnabled,\n    TLSOpts1 =\n\tlists:filter(fun({certfile, _}) -> true;\n\t\t\t(_) -> false\n\t\t     end, Opts),\n    TLSOpts = [verify_none | TLSOpts1],\n    IP = peerip(SockMod, Socket),\n    %% Check if IP is blacklisted:\n    case is_ip_blacklisted(IP) of\n\ttrue ->\n\t    ?INFO_MSG(\"Connection attempt from blacklisted IP: ~s (~w)\",\n\t\t      [jlib:ip_to_list(IP), IP]),\n\t    {stop, normal};\n\tfalse ->\n\t    Socket1 =\n\t\tif\n\t\t    TLSEnabled ->\n\t\t\tSockMod:starttls(Socket, TLSOpts);\n\t\t    true ->\n\t\t\tSocket\n\t\tend,\n\t    SocketMonitor = SockMod:monitor(Socket1),\n\t    {ok, wait_for_stream, #state{socket         = Socket1,\n\t\t\t\t\t sockmod        = SockMod,\n\t\t\t\t\t socket_monitor = SocketMonitor,\n\t\t\t\t\t xml_socket     = XMLSocket,\n\t\t\t\t\t zlib           = Zlib,\n\t\t\t\t\t tls            = TLS,\n\t\t\t\t\t tls_required   = StartTLSRequired,\n\t\t\t\t\t tls_enabled    = TLSEnabled,\n\t\t\t\t\t tls_options    = TLSOpts,\n\t\t\t\t\t streamid       = new_id(),\n\t\t\t\t\t access         = Access,\n\t\t\t\t\t shaper         = Shaper,\n\t\t\t\t\t ip             = IP},\n\t     ?C2S_OPEN_TIMEOUT}\n    end.\n\n%% Return list of all available resources of contacts,\nget_subscribed(FsmRef) ->\n    ?GEN_FSM:sync_send_all_state_event(FsmRef, get_subscribed, 1000).\n\n%%----------------------------------------------------------------------\n%% Func: StateName/2\n%% Returns: {next_state, NextStateName, NextStateData}          |\n%%          {next_state, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}\n%%----------------------------------------------------------------------\n\nwait_for_stream({xmlstreamstart, _Name, Attrs}, StateData) ->\n    DefaultLang = case ?MYLANG of\n\t\t      undefined ->\n\t\t\t  \"en\";\n\t\t      DL ->\n\t\t\t  DL\n\t\t  end,\n    case xml:get_attr_s(<<\"xmlns:stream\">>, Attrs) of\n\t?NS_STREAM ->\n\t    Server = jlib:nameprep(xml:get_attr_s(<<\"to\">>, Attrs)),\n\t    case lists:member(Server, ?MYHOSTS) of\n\t\ttrue ->\n\t\t    Lang = case xml:get_attr_s(<<\"xml:lang\">>, Attrs) of\n\t\t\t       Lang1 when size(Lang1) =< 35 ->\n\t\t\t\t   %% As stated in BCP47, 4.4.1:\n\t\t\t\t   %% Protocols or specifications that\n\t\t\t\t   %% specify limited buffer sizes for\n\t\t\t\t   %% language tags MUST allow for\n\t\t\t\t   %% language tags of at least 35 characters.\n\t\t\t\t   binary_to_list(Lang1);\n\t\t\t       _ ->\n\t\t\t\t   %% Do not store long language tag to\n\t\t\t\t   %% avoid possible DoS/flood attacks\n\t\t\t\t   \"\"\n\t\t\t   end,\n\t\t    change_shaper(StateData, jlib:make_jid(<<>>, Server, <<>>)),\n\t\t    case xml:get_attr_s(<<\"version\">>, Attrs) of\n\t\t\t<<\"1.0\">> ->\n\t\t\t    send_header(StateData, Server, \"1.0\", DefaultLang),\n\t\t\t    case StateData#state.authenticated of\n\t\t\t\tfalse ->\n                    SASLState =\n\t\t\t\t\tcyrsasl:server_new(\n\t\t\t\t\t  <<\"jabber\">>, Server, <<>>, [],\n\t\t\t\t\t  fun(U) ->\n\t\t\t\t\t\t  ejabberd_auth:get_password_with_authmodule(\n\t\t\t\t\t\t    U, Server)\n\t\t\t\t\t  end,\n\t\t\t\t\t  fun(U, P) ->\n\t\t\t\t\t\t  ejabberd_auth:check_password_with_authmodule(\n\t\t\t\t\t\t    U, Server, P)\n\t\t\t\t\t  end,\n\t\t\t\t\t  fun(U, P, D, DG) ->\n\t\t\t\t\t\t  ejabberd_auth:check_password_with_authmodule(\n\t\t\t\t\t\t    U, Server, P, D, DG)\n\t\t\t\t\t  end),\n\t\t\t\t    Mechs = lists:map(\n\t\t\t\t\t      fun(S) ->\n\t\t\t\t      #xmlel{name = <<\"mechanism\">>,\n\t\t\t     children = [#xmlcdata{content = S}]}\n\t\t\t      end, cyrsasl:listmech(Server)),\n\t\t    SockMod =\n\t\t\t (StateData#state.sockmod):get_sockmod(\n\t\t\t   StateData#state.socket),\n\t\t    {Zlib, _} = StateData#state.zlib,\n\t\t    CompressFeature =\n\t\t\tcase Zlib andalso\n\t\t\t      ((SockMod == gen_tcp) orelse\n\t\t\t       (SockMod == tls)) of\n\t\t\t    true ->\n\t\t\t\t[#xmlel{name = <<\"compression\">>,\n\t\t\t\t\tattrs = [{<<\"xmlns\">>, ?NS_FEATURE_COMPRESS}],\n\t\t\t\t\tchildren = [#xmlel{name = <<\"method\">>,\n\t\t\t\t\t\t           children = [#xmlcdata{content = <<\"zlib\">>}]}]}];\n\t\t\t    _ ->\n\t\t\t\t[]\n\t\t\tend,\n\t\t    TLS = StateData#state.tls,\n\t\t    TLSEnabled = StateData#state.tls_enabled,\n\t\t    TLSRequired = StateData#state.tls_required,\n\t\t    TLSFeature =\n\t\t\tcase  (TLS == true) andalso\n\t\t\t     (TLSEnabled == false) andalso\n\t\t\t     (SockMod == gen_tcp) of\n\t\t\t    true ->\n\t\t\t\tcase TLSRequired of\n\t\t\t\t    true ->\n\t\t\t\t\t[#xmlel{name = <<\"starttls\">>,\n\t\t\t\t\t\tattrs = [{\"xmlns\", ?NS_TLS}],\n\t\t\t\t\t\tchildren = [#xmlel{name = <<\"required\">>}]}];\n\t\t\t\t    _ ->\n\t\t\t\t\t[#xmlel{name = <<\"starttls\">>,\n\t\t\t\t\t\tattrs = [{<<\"xmlns\">>, ?NS_TLS}]}]\n\t\t\t\tend;\n\t\t\t    false ->\n\t\t\t\t[]\n\t\t\tend,\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"stream:features\">>,\n\t\t\t\t\tchildren = TLSFeature ++ CompressFeature ++\n\t\t\t\t\t\t   [#xmlel{name = <<\"mechanisms\">>,\n\t\t\t\t\t\t           attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t\t\t           children = Mechs}] ++\n\t\t\t\t\t\t   ejabberd_hooks:run_fold(\n\t\t\t\t\t\t     c2s_stream_features,\n\t\t\t\t\t\t     Server,\n\t\t\t\t\t\t     [], [Server])}),\n\t\t    fsm_next_state(wait_for_feature_request,\n\t\t\t       StateData#state{\n\t\t\t\t server = Server,\n\t\t\t\t sasl_state = SASLState,\n\t\t\t\t lang = Lang});\n\t\t\t\t_ ->\n\t\t\t\t    case StateData#state.resource of\n\t\t\t\t\t<<>> ->\n\t\t\t\t\t    RosterVersioningFeature =\n\t\t\t\t\t\tejabberd_hooks:run_fold(\n\t\t\t\t\t\t  roster_get_versioning_feature,\n\t\t\t\t\t\t  Server, [], [Server]),\n\t\t\t\t            StreamFeatures =\n\t\t\t\t\t\t[#xmlel{name = <<\"bind\">>,\n\t\t\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_BIND}]},\n\t\t\t\t\t\t #xmlel{name = <<\"session\">>,\n\t\t\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SESSION}]}]\n\t\t\t\t\t       ++ RosterVersioningFeature\n\t\t\t\t\t      ++ ejabberd_hooks:run_fold(\n\t\t\t\t\t\t   c2s_stream_features,\n\t\t\t\t\t\t   Server,\n\t\t\t\t\t\t   [], [Server]),\n\t\t\t\t\t    send_element(\n\t\t\t\t\t      StateData,\n\t\t\t\t\t      #xmlel{name = <<\"stream:features\">>,\n\t\t\t\t\t             children = StreamFeatures}),\n\t\t\t\t\t    fsm_next_state(wait_for_bind,\n\t\t\t\t\t\t       StateData#state{\n\t\t\t\t\t\t\t server = Server,\n\t\t\t\t\t\t\t lang = Lang});\n\t\t\t\t\t_ ->\n\t\t\t\t\t    send_element(\n\t\t\t\t\t      StateData,\n\t\t\t\t\t      #xmlel{name = <<\"stream:features\">>}),\n\t\t\t\t\t    fsm_next_state(wait_for_session,\n\t\t\t\t\t\t       StateData#state{\n\t\t\t\t\t\t\t server = Server,\n\t\t\t\t\t\t\t lang = Lang})\n\t\t\t\t    end\n\t\t\t    end;\n\t\t\t_ ->\n\t\t\t    send_header(StateData, Server, \"\", DefaultLang),\n\t\t\t    if\n\t\t\t\t(not StateData#state.tls_enabled) and\n\t\t\t\tStateData#state.tls_required ->\n\t\t\t\t    send_element(\n\t\t\t\t      StateData,\n\t\t\t\t      ?POLICY_VIOLATION_ERR(\n\t\t\t\t\t Lang,\n\t\t\t\t\t \"Use of STARTTLS required\")),\n\t\t\t\t    send_trailer(StateData),\n\t\t\t\t    {stop, normal, StateData};\n\t\t\t\ttrue ->\n\t\t\t\t    fsm_next_state(wait_for_auth,\n\t\t\t\t\t\t   StateData#state{\n\t\t\t\t\t\t     server = Server,\n\t\t\t\t\t\t     lang = Lang})\n\t\t\t    end\n\t\t    end;\n\t\t_ ->\n\t\t    send_header(StateData, ?MYNAME, \"\", DefaultLang),\n\t\t    send_element(StateData, ?HOST_UNKNOWN_ERR),\n\t\t    send_trailer(StateData),\n\t\t    {stop, normal, StateData}\n\t    end;\n\t_ ->\n\t    send_header(StateData, ?MYNAME, \"\", DefaultLang),\n\t    send_element(StateData, ?INVALID_NS_ERR),\n\t    send_trailer(StateData),\n\t    {stop, normal, StateData}\n    end;\n\nwait_for_stream(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_stream({xmlstreamelement, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_stream({xmlstreamend, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_stream({xmlstreamerror, _}, StateData) ->\n    send_header(StateData, ?MYNAME, \"1.0\", \"\"),\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_stream(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\nwait_for_auth({xmlstreamelement, El}, StateData) ->\n    case is_auth_packet(El) of\n\t{auth, _ID, get, {U, _, _, _}} ->\n\t    XE = jlib:make_result_iq_reply(El),\n\t    case U of\n\t\t<<>> ->\n\t\t    UCdata = [];\n\t\t_ ->\n\t\t    UCdata = [#xmlcdata{content = U}]\n\t    end,\n\t    Res = case ejabberd_auth:plain_password_required(\n\t\t\t StateData#state.server) of\n\t\t      false ->\n\t\t\t  XE#xmlel{children = [#xmlel{name = <<\"query\">>,\n\t\t\t                              attrs = [{<<\"xmlns\">>,\n\t\t\t                                        ?NS_AUTH}],\n\t\t\t                              children = [#xmlel{name = <<\"username\">>,\n\t\t\t                                                 children = UCdata},\n\t\t\t                                          #xmlel{name = <<\"password\">>},\n\t\t\t                                          #xmlel{name = <<\"digest\">>},\n                                                                  #xmlel{name = <<\"resource\">>}]}]};\n\t\t      true ->\n\t\t\t  XE#xmlel{children = [#xmlel{name = <<\"query\">>,\n\t\t\t                              attrs = [{<<\"xmlns\">>,\n\t\t\t                                        ?NS_AUTH}],\n\t\t\t                              children = [#xmlel{name = <<\"username\">>,\n\t\t\t                                                 children = UCdata},\n\t\t\t                                          #xmlel{name = <<\"password\">>},\n                                                                  #xmlel{name = <<\"resource\">>}]}]}\n\t\t  end,\n\t    send_element(StateData, Res),\n\t    fsm_next_state(wait_for_auth, StateData);\n\t{auth, _ID, set, {_U, _P, _D, <<>>}} ->\n\t    Err = jlib:make_error_reply(\n\t\t    El,\n\t\t    ?ERR_AUTH_NO_RESOURCE_PROVIDED(StateData#state.lang)),\n\t    send_element(StateData, Err),\n\t    fsm_next_state(wait_for_auth, StateData);\n\t{auth, _ID, set, {U, P, D, R}} ->\n\t    JID = jlib:make_jid(U, StateData#state.server, R),\n\t    case (JID /= error) andalso\n\t\t(acl:match_rule(StateData#state.server,\n\t\t\t\tStateData#state.access, JID) == allow) of\n\t\ttrue ->\n                    DGen = fun(PW) ->\n                             list_to_binary(sha:sha(\n                                              StateData#state.streamid\n                                              ++ binary_to_list(PW))) end,\n\t\t    case ejabberd_auth:check_password_with_authmodule(\n\t\t\t   U, StateData#state.server, P, D, DGen) of\n\t\t\t{true, AuthModule} ->\n\t\t\t    ?INFO_MSG(\n\t\t\t       \"(~w) Accepted legacy authentication for ~s by ~p\",\n\t\t\t       [StateData#state.socket,\n\t\t\t\tjlib:jid_to_binary(JID), AuthModule]),\n\t\t\t    SID = {now(), self()},\n\t\t\t    Conn = get_conn_type(StateData),\n\t\t\t    Info = [{ip, StateData#state.ip}, {conn, Conn},\n\t\t\t\t    {auth_module, AuthModule}],\n\t\t\t    Res1 = jlib:make_result_iq_reply(El),\n\t\t\t    Res = setelement(4, Res1, []),\n\t\t\t    send_element(StateData, Res),\n\t\t\t    ejabberd_sm:open_session(\n\t\t\t      SID, U, StateData#state.server, R, Info),\n\t\t\t    change_shaper(StateData, JID),\n\t\t\t    {Fs, Ts, Pending} = ejabberd_hooks:run_fold(\n                                      roster_get_subscription_lists,\n                                      StateData#state.server,\n                                      {[], [], []},\n                                      [U, StateData#state.server]),\n\t\t\t    LJID = jlib:jid_tolower(\n\t\t\t\t     jlib:jid_remove_resource(JID)),\n\t\t\t    Fs1 = [LJID | Fs],\n\t\t\t    Ts1 = [LJID | Ts],\n\t\t\t    PrivList =\n\t\t\t\tejabberd_hooks:run_fold(\n\t\t\t\t  privacy_get_user_list, StateData#state.server,\n\t\t\t\t  #userlist{},\n\t\t\t\t  [U, StateData#state.server]),\n                            NewStateData =\n                                StateData#state{\n\t\t\t\t\t     user = U,\n\t\t\t\t\t     resource = R,\n\t\t\t\t\t     jid = JID,\n\t\t\t\t\t     sid = SID,\n\t\t\t\t\t     conn = Conn,\n\t\t\t\t\t     auth_module = AuthModule,\n\t\t\t\t\t     pres_f = ?SETS:from_list(Fs1),\n\t\t\t\t\t     pres_t = ?SETS:from_list(Ts1),\n                         pending_invitations = Pending,\n\t\t\t\t\t     privacy_list = PrivList},\n\t\t\t    fsm_next_state_pack(session_established,\n                                                NewStateData);\n\t\t\t_ ->\n\t\t\t    ?INFO_MSG(\n\t\t\t       \"(~w) Failed legacy authentication for ~s\",\n\t\t\t       [StateData#state.socket,\n\t\t\t\tjlib:jid_to_binary(JID)]),\n\t\t\t    Err = jlib:make_error_reply(\n\t\t\t\t    El, ?ERR_NOT_AUTHORIZED),\n\t\t\t    send_element(StateData, Err),\n\t\t\t    fsm_next_state(wait_for_auth, StateData)\n\t\t    end;\n\t\t_ ->\n\t\t    if\n\t\t\tJID == error ->\n\t\t\t    ?INFO_MSG(\n\t\t\t       \"(~w) Forbidden legacy authentication for \"\n\t\t\t       \"username '~s' with resource '~s'\",\n\t\t\t       [StateData#state.socket, U, R]),\n\t\t\t    Err = jlib:make_error_reply(El, ?ERR_JID_MALFORMED),\n\t\t\t    send_element(StateData, Err),\n\t\t\t    fsm_next_state(wait_for_auth, StateData);\n\t\t\ttrue ->\n\t\t\t    ?INFO_MSG(\n\t\t\t       \"(~w) Forbidden legacy authentication for ~s\",\n\t\t\t       [StateData#state.socket,\n\t\t\t\tjlib:jid_to_binary(JID)]),\n\t\t\t    Err = jlib:make_error_reply(El, ?ERR_NOT_ALLOWED),\n\t\t\t    send_element(StateData, Err),\n\t\t\t    fsm_next_state(wait_for_auth, StateData)\n\t\t    end\n\t    end;\n\t_ ->\n\t    process_unauthenticated_stanza(StateData, El),\n\t    fsm_next_state(wait_for_auth, StateData)\n    end;\n\nwait_for_auth(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_auth({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_auth({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_auth(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\nwait_for_feature_request({xmlstreamelement, El}, StateData) ->\n    #xmlel{name = Name, attrs = Attrs, children = Els} = El,\n    {Zlib, ZlibLimit} = StateData#state.zlib,\n    TLS = StateData#state.tls,\n    TLSEnabled = StateData#state.tls_enabled,\n    TLSRequired = StateData#state.tls_required,\n    SockMod = (StateData#state.sockmod):get_sockmod(StateData#state.socket),\n    case {xml:get_attr_s(<<\"xmlns\">>, Attrs), Name} of\n\t{?NS_SASL, <<\"auth\">>} when not ((SockMod == gen_tcp) and TLSRequired) ->\n\t    Mech = xml:get_attr_s(<<\"mechanism\">>, Attrs),\n\t    ClientIn = jlib:decode_base64(xml:get_cdata(Els)),\n\t    case cyrsasl:server_start(StateData#state.sasl_state,\n\t\t\t\t      Mech,\n\t\t\t\t      ClientIn) of\n\t\t{ok, Props} ->\n\t\t    (StateData#state.sockmod):reset_stream(\n\t\t      StateData#state.socket),\n\t\t    send_element(StateData,\n\t\t\t\t  #xmlel{name = <<\"success\">>,\n\t\t\t\t         attrs = [{<<\"xmlns\">>, ?NS_SASL}]}),\n\t\t     U = xml:get_attr_s(username, Props),\n\t\t     AuthModule = xml:get_attr_s(auth_module, Props),\n\t\t     ?INFO_MSG(\"(~w) Accepted authentication for ~s by ~p\",\n\t\t\t       [StateData#state.socket, U, AuthModule]),\n\t\t     fsm_next_state(wait_for_stream,\n\t\t\t\t    StateData#state{\n\t\t\t\t      streamid = new_id(),\n\t\t\t\t      authenticated = true,\n\t\t\t\t      auth_module = AuthModule,\n\t\t\t\t      user = U});\n\t\t{continue, ServerOut, NewSASLState} ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"challenge\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlcdata{content = jlib:encode_base64(ServerOut)}]}),\n\t\t    fsm_next_state(wait_for_sasl_response,\n\t\t\t\t   StateData#state{\n\t\t\t\t     sasl_state = NewSASLState});\n\t\t{error, Error, Username} ->\n\t\t    ?INFO_MSG(\n\t\t       \"(~w) Failed authentication for ~s@~s\",\n\t\t       [StateData#state.socket,\n\t\t\tUsername, StateData#state.server]),\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlel{name = Error}]}),\n\t\t    {next_state, wait_for_feature_request, StateData,\n\t\t     ?C2S_OPEN_TIMEOUT};\n\t\t{error, Error} ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlel{name = Error}]}),\n\t\t    fsm_next_state(wait_for_feature_request, StateData)\n\t    end;\n\t{?NS_TLS_BIN, <<\"starttls\">>} when TLS == true,\n\t\t\t\t   TLSEnabled == false,\n\t\t\t\t   SockMod == gen_tcp ->\n\t    TLSOpts = case ejabberd_config:get_local_option(\n\t\t\t     {domain_certfile, StateData#state.server}) of\n\t\t\t  undefined ->\n\t\t\t      StateData#state.tls_options;\n\t\t\t  CertFile ->\n\t\t\t      [{certfile, CertFile} |\n\t\t\t       lists:keydelete(\n\t\t\t\t certfile, 1, StateData#state.tls_options)]\n\t\t      end,\n\t    Socket = StateData#state.socket,\n\t    TLSSocket = (StateData#state.sockmod):starttls(\n\t\t\t  Socket, TLSOpts,\n\t\t\t  xml:element_to_binary(\n\t\t\t     #xmlel{name = <<\"proceed\">>,\n                                    attrs = [{<<\"xmlns\">>, ?NS_TLS}]})),\n\t    fsm_next_state(wait_for_stream,\n\t\t\t   StateData#state{socket = TLSSocket,\n\t\t\t\t\t   streamid = new_id(),\n\t\t\t\t\t   tls_enabled = true\n\t\t\t\t\t  });\n\t{?NS_COMPRESS_BIN, <<\"compress\">>} when Zlib == true,\n\t\t\t\t\t((SockMod == gen_tcp) or\n\t\t\t\t\t (SockMod == tls)) ->\n\t    case xml:get_subtag(El, <<\"method\">>) of\n\t\tfalse ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_COMPRESS}],\n\t\t\t\t        children = [#xmlel{name = <<\"setup-failed\">>}]}),\n\t\t    fsm_next_state(wait_for_feature_request, StateData);\n\t\tMethod ->\n\t\t    case xml:get_tag_cdata(Method) of\n\t\t\t<<\"zlib\">> ->\n\t\t\t    Socket = StateData#state.socket,\n\t\t\t    ZlibSocket = (StateData#state.sockmod):compress(\n\t\t\t\t\t   Socket, ZlibLimit,\n\t\t\t\t\t   xml:element_to_binary(\n\t\t\t\t\t      #xmlel{name = <<\"compressed\">>,\n\t\t\t\t\t             attrs = [{<<\"xmlns\">>, ?NS_COMPRESS}]})),\n\t\t\t    fsm_next_state(wait_for_stream,\n\t\t\t     StateData#state{socket = ZlibSocket,\n\t\t\t\t\t     streamid = new_id()\n\t\t\t\t\t    });\n\t\t\t_ ->\n\t\t\t    send_element(StateData,\n\t\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_COMPRESS}],\n\t\t\t\t\t        children = [#xmlel{name = <<\"unsupported-method\">>}]}),\n\t\t\t    fsm_next_state(wait_for_feature_request,\n\t\t\t\t\t   StateData)\n\t\t    end\n\t    end;\n\t_ ->\n\t    if\n\t\t(SockMod == gen_tcp) and TLSRequired ->\n\t\t    Lang = StateData#state.lang,\n\t\t    send_element(StateData, ?POLICY_VIOLATION_ERR(\n\t\t\t\t\t       Lang,\n\t\t\t\t\t       \"Use of STARTTLS required\")),\n\t\t    send_trailer(StateData),\n\t\t    {stop, normal, StateData};\n\t\ttrue ->\n\t\t    process_unauthenticated_stanza(StateData, El),\n\t\t    fsm_next_state(wait_for_feature_request, StateData)\n\t    end\n    end;\n\nwait_for_feature_request(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_feature_request({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_feature_request({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_feature_request(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\nwait_for_sasl_response({xmlstreamelement, El}, StateData) ->\n    #xmlel{name = Name, attrs = Attrs, children = Els} = El,\n    case {xml:get_attr_s(<<\"xmlns\">>, Attrs), Name} of\n\t{?NS_SASL, <<\"response\">>} ->\n\t    ClientIn = jlib:decode_base64(xml:get_cdata(Els)),\n\t    case cyrsasl:server_step(StateData#state.sasl_state,\n\t\t\t\t     ClientIn) of\n\t\t{ok, Props} ->\n\t\t    (StateData#state.sockmod):reset_stream(\n\t\t      StateData#state.socket),\n\t\t    send_element(StateData,\n\t\t\t\t  #xmlel{name = <<\"success\">>,\n\t\t\t\t         attrs = [{<<\"xmlns\">>, ?NS_SASL}]}),\n\t\t     U = xml:get_attr_s(username, Props),\n\t\t     AuthModule = xml:get_attr_s(auth_module, Props),\n\t\t     ?INFO_MSG(\"(~w) Accepted authentication for ~s by ~p\",\n\t\t\t       [StateData#state.socket, U, AuthModule]),\n\t\t     fsm_next_state(wait_for_stream,\n\t\t\t\t    StateData#state{\n\t\t\t\t      streamid = new_id(),\n\t\t\t\t      authenticated = true,\n\t\t\t\t      auth_module = AuthModule,\n\t\t\t\t      user = U});\n\t\t{continue, ServerOut, NewSASLState} ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"challenge\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlcdata{content = jlib:encode_base64(ServerOut)}]}),\n\t\t    fsm_next_state(wait_for_sasl_response,\n\t\t     StateData#state{sasl_state = NewSASLState});\n\t\t{error, Error, Username} ->\n\t\t    ?INFO_MSG(\n\t\t       \"(~w) Failed authentication for ~s@~s\",\n\t\t       [StateData#state.socket,\n\t\t\tUsername, StateData#state.server]),\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlel{name = Error}]}),\n\t\t    fsm_next_state(wait_for_feature_request, StateData);\n\t\t{error, Error} ->\n\t\t    send_element(StateData,\n\t\t\t\t #xmlel{name = <<\"failure\">>,\n\t\t\t\t        attrs = [{<<\"xmlns\">>, ?NS_SASL}],\n\t\t\t\t        children = [#xmlel{name = Error}]}),\n\t\t    fsm_next_state(wait_for_feature_request, StateData)\n\t    end;\n\t_ ->\n\t    process_unauthenticated_stanza(StateData, El),\n\t    fsm_next_state(wait_for_feature_request, StateData)\n    end;\n\nwait_for_sasl_response(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_sasl_response({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_sasl_response({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_sasl_response(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\n\nwait_for_bind({xmlstreamelement, El}, StateData) ->\n    case jlib:iq_query_info(El) of\n\t#iq{type = set, xmlns = ?NS_BIND, sub_el = SubEl} = IQ ->\n\t    U = StateData#state.user,\n\t    R1 = xml:get_path_s(SubEl, [{elem, <<\"resource\">>}, cdata]),\n\t    R = case jlib:resourceprep(R1) of\n\t\t    error -> error;\n\t\t    <<>> ->\n                    list_to_binary(lists:concat(\n                                     [randoms:get_string() | tuple_to_list(now())]));\n\t\t    Resource -> Resource\n\t\tend,\n\t    case R of\n\t\terror ->\n\t\t    Err = jlib:make_error_reply(El, ?ERR_BAD_REQUEST),\n\t\t    send_element(StateData, Err),\n\t\t    fsm_next_state(wait_for_bind, StateData);\n\t\t_ ->\n\t\t    JID = jlib:make_jid(U, StateData#state.server, R),\n\t\t    %%Server = StateData#state.server,\n\t\t    %%RosterVersioningFeature =\n\t\t    %%\tejabberd_hooks:run_fold(\n\t\t    %%  roster_get_versioning_feature, Server, [], [Server]),\n\t            %%StreamFeatures = [{xmlel, \"session\",\n\t\t    %%\t\t       [{\"xmlns\", ?NS_SESSION}], []} |\n\t\t    %%\t\t      RosterVersioningFeature],\n\t\t    %%send_element(StateData, {xmlel, \"stream:features\",\n\t\t    %%\t\t\t     [], StreamFeatures}),\n\t\t    Res = IQ#iq{type = result,\n\t\t\t\tsub_el = [#xmlel{name = <<\"bind\">>,\n\t\t\t\t\t         attrs = [{<<\"xmlns\">>, ?NS_BIND}],\n\t\t\t\t\t         children = [#xmlel{name = <<\"jid\">>,\n\t\t\t\t\t                            children = [#xmlcdata{content = jlib:jid_to_binary(JID)}]}]}]},\n\t\t    send_element(StateData, jlib:iq_to_xml(Res)),\n\t\t    fsm_next_state(wait_for_session,\n\t\t\t\t   StateData#state{resource = R, jid = JID})\n\t    end;\n\t_ ->\n\t    fsm_next_state(wait_for_bind, StateData)\n    end;\n\nwait_for_bind(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_bind({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_bind({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_bind(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\n\nwait_for_session({xmlstreamelement, El}, StateData) ->\n    case jlib:iq_query_info(El) of\n\t#iq{type = set, xmlns = ?NS_SESSION} ->\n\t    U = StateData#state.user,\n\t    R = StateData#state.resource,\n\t    JID = StateData#state.jid,\n\t    case acl:match_rule(StateData#state.server,\n\t\t\t\tStateData#state.access, JID) of\n\t\tallow ->\n\t\t    ?INFO_MSG(\"(~w) Opened session for ~s\",\n\t\t\t      [StateData#state.socket,\n\t\t\t       jlib:jid_to_binary(JID)]),\n\t\t    Res = jlib:make_result_iq_reply(El),\n\t\t    send_element(StateData, Res),\n\t\t    change_shaper(StateData, JID),\n\t\t    {Fs, Ts, Pending} = ejabberd_hooks:run_fold(\n                                  roster_get_subscription_lists,\n                                  StateData#state.server,\n                                  {[], [], []},\n                                  [U, StateData#state.server]),\n\t\t    LJID = jlib:jid_tolower(jlib:jid_remove_resource(JID)),\n\t\t    Fs1 = [LJID | Fs],\n\t\t    Ts1 = [LJID | Ts],\n\t\t    PrivList =\n\t\t\tejabberd_hooks:run_fold(\n\t\t\t  privacy_get_user_list, StateData#state.server,\n\t\t\t  #userlist{},\n\t\t\t  [U, StateData#state.server]),\n\t\t    SID = {now(), self()},\n\t\t    Conn = get_conn_type(StateData),\n\t\t    Info = [{ip, StateData#state.ip}, {conn, Conn},\n\t\t\t    {auth_module, StateData#state.auth_module}],\n\t\t    ejabberd_sm:open_session(\n\t\t      SID, U, StateData#state.server, R, Info),\n                    NewStateData =\n                        StateData#state{\n\t\t\t\t     sid = SID,\n\t\t\t\t     conn = Conn,\n\t\t\t\t     pres_f = ?SETS:from_list(Fs1),\n\t\t\t\t     pres_t = ?SETS:from_list(Ts1),\n                     pending_invitations = Pending,\n\t\t\t\t     privacy_list = PrivList},\n\t\t    fsm_next_state_pack(session_established,\n                                        NewStateData);\n\t\t_ ->\n\t\t    ejabberd_hooks:run(forbidden_session_hook,\n\t\t\t\t       StateData#state.server, [JID]),\n\t\t    ?INFO_MSG(\"(~w) Forbidden session for ~s\",\n\t\t\t      [StateData#state.socket,\n\t\t\t       jlib:jid_to_binary(JID)]),\n\t\t    Err = jlib:make_error_reply(El, ?ERR_NOT_ALLOWED),\n\t\t    send_element(StateData, Err),\n\t\t    fsm_next_state(wait_for_session, StateData)\n\t    end;\n\t_ ->\n\t    fsm_next_state(wait_for_session, StateData)\n    end;\n\nwait_for_session(timeout, StateData) ->\n    {stop, normal, StateData};\n\nwait_for_session({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_session({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nwait_for_session(closed, StateData) ->\n    {stop, normal, StateData}.\n\n\nsession_established({xmlstreamelement, El}, StateData) ->\n    FromJID = StateData#state.jid,\n    % Check 'from' attribute in stanza RFC 3920 Section 9.1.2\n    case check_from(El, FromJID) of\n\t'invalid-from' ->\n\t    send_element(StateData, ?INVALID_FROM),\n\t    send_trailer(StateData),\n\t    {stop, normal, StateData};\n\t_NewEl ->\n\t    session_established2(El, StateData)\n    end;\n\n%% We hibernate the process to reduce memory consumption after a\n%% configurable activity timeout\nsession_established(timeout, StateData) ->\n    %% TODO: Options must be stored in state:\n    Options = [],\n    proc_lib:hibernate(?GEN_FSM, enter_loop,\n\t\t       [?MODULE, Options, session_established, StateData]),\n    fsm_next_state(session_established, StateData);\n\nsession_established({xmlstreamend, _Name}, StateData) ->\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nsession_established({xmlstreamerror, <<\"XML stanza is too big\">> = E}, StateData) ->\n    send_element(StateData, ?POLICY_VIOLATION_ERR(StateData#state.lang, E)),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nsession_established({xmlstreamerror, _}, StateData) ->\n    send_element(StateData, ?INVALID_XML_ERR),\n    send_trailer(StateData),\n    {stop, normal, StateData};\n\nsession_established(closed, StateData) ->\n    {stop, normal, StateData}.\n\n%% Process packets sent by user (coming from user on c2s XMPP\n%% connection)\nsession_established2(El, StateData) ->\n    #xmlel{name = Name, attrs = Attrs} = El,\n    User = StateData#state.user,\n    Server = StateData#state.server,\n    FromJID = StateData#state.jid,\n    To = xml:get_attr_s(<<\"to\">>, Attrs),\n    ToJID = case To of\n\t\t<<>> ->\n\t\t    jlib:make_jid(User, Server, <<>>);\n\t\t_ ->\n\t\t    jlib:binary_to_jid(To)\n\t    end,\n    NewEl1 = jlib:remove_attr(<<\"xmlns\">>, El),\n    NewEl = case xml:get_attr_s(<<\"xml:lang\">>, Attrs) of\n\t\t<<>> ->\n\t\t    case StateData#state.lang of\n\t\t\t<<>> -> NewEl1;\n\t\t\tLang ->\n\t\t\t    xml:replace_tag_attr(<<\"xml:lang\">>, list_to_binary(Lang), NewEl1)\n\t\t    end;\n\t\t_ ->\n\t\t    NewEl1\n\t    end,\n    NewState =\n\tcase ToJID of\n\t    error ->\n\t\tcase xml:get_attr_s(<<\"type\">>, Attrs) of\n\t\t    <<\"error\">> -> StateData;\n\t\t    <<\"result\">> -> StateData;\n\t\t    _ ->\n\t\t\tErr = jlib:make_error_reply(NewEl, ?ERR_JID_MALFORMED),\n\t\t\tsend_element(StateData, Err),\n\t\t\tStateData\n\t\tend;\n\t    _ ->\n\t\tcase Name of\n\t\t    <<\"presence\">> ->\n\t\t\tPresenceEl = ejabberd_hooks:run_fold(\n\t\t\t\t       c2s_update_presence,\n\t\t\t\t       Server,\n\t\t\t\t       NewEl,\n\t\t\t\t       [User, Server]),\n\t\t\tejabberd_hooks:run(\n\t\t\t  user_send_packet,\n\t\t\t  Server,\n\t\t\t  [FromJID, ToJID, PresenceEl]),\n\t\t\tcase ToJID of\n\t\t\t    #jid{user = User,\n\t\t\t\t server = Server,\n\t\t\t\t resource = <<>>} ->\n\t\t\t\t?DEBUG(\"presence_update(~p,~n\\t~p,~n\\t~p)\",\n\t\t\t\t       [FromJID, PresenceEl, StateData]),\n\t\t\t\tpresence_update(FromJID, PresenceEl,\n\t\t\t\t\t\tStateData);\n\t\t\t    _ ->\n\t\t\t\tpresence_track(FromJID, ToJID, PresenceEl,\n\t\t\t\t\t       StateData)\n\t\t\tend;\n\t\t    <<\"iq\">> ->\n\t\t\tcase jlib:iq_query_info(NewEl) of\n\t\t\t    #iq{xmlns = Xmlns} = IQ\n\t\t\t    when Xmlns == ?NS_PRIVACY;\n\t\t\t\t Xmlns == ?NS_BLOCKING ->\n\t\t\t\tprocess_privacy_iq(\n\t\t\t\t  FromJID, ToJID, IQ, StateData);\n\t\t\t    _ ->\n\t\t\t\tejabberd_hooks:run(\n\t\t\t\t  user_send_packet,\n\t\t\t\t  Server,\n\t\t\t\t  [FromJID, ToJID, NewEl]),\n\t\t\t\tcheck_privacy_route(FromJID, StateData, FromJID, ToJID, NewEl),\n\t\t\t\tStateData\n\t\t\tend;\n\t\t    <<\"message\">> ->\n\t\t\tejabberd_hooks:run(user_send_packet,\n\t\t\t\t\t   Server,\n\t\t\t\t\t   [FromJID, ToJID, NewEl]),\n\t\t\tcheck_privacy_route(FromJID, StateData, FromJID,\n\t\t\t\t\t    ToJID, NewEl),\n\t\t\tStateData;\n\t\t    _ ->\n\t\t\tStateData\n\t\tend\n\tend,\n    ejabberd_hooks:run(c2s_loop_debug, [{xmlstreamelement, El}]),\n    fsm_next_state(session_established, NewState).\n\n\n\n%%----------------------------------------------------------------------\n%% Func: StateName/3\n%% Returns: {next_state, NextStateName, NextStateData}            |\n%%          {next_state, NextStateName, NextStateData, Timeout}   |\n%%          {reply, Reply, NextStateName, NextStateData}          |\n%%          {reply, Reply, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}                          |\n%%          {stop, Reason, Reply, NewStateData}\n%%----------------------------------------------------------------------\n%state_name(Event, From, StateData) ->\n%    Reply = ok,\n%    {reply, Reply, state_name, StateData}.\n\n%%----------------------------------------------------------------------\n%% Func: handle_event/3\n%% Returns: {next_state, NextStateName, NextStateData}          |\n%%          {next_state, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}\n%%----------------------------------------------------------------------\nhandle_event(_Event, StateName, StateData) ->\n    fsm_next_state(StateName, StateData).\n\n%%----------------------------------------------------------------------\n%% Func: handle_sync_event/4\n%% Returns: {next_state, NextStateName, NextStateData}            |\n%%          {next_state, NextStateName, NextStateData, Timeout}   |\n%%          {reply, Reply, NextStateName, NextStateData}          |\n%%          {reply, Reply, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}                          |\n%%          {stop, Reason, Reply, NewStateData}\n%%----------------------------------------------------------------------\nhandle_sync_event(get_presence, _From, StateName, StateData) ->\n    User = StateData#state.user,\n    PresLast = StateData#state.pres_last,\n\n    Show = get_showtag(PresLast),\n    Status = get_statustag(PresLast),\n    Resource = StateData#state.resource,\n\n    Reply = {User, Resource, Show, Status},\n    fsm_reply(Reply, StateName, StateData);\n\nhandle_sync_event(get_subscribed, _From, StateName, StateData) ->\n    Subscribed = ?SETS:to_list(StateData#state.pres_f),\n    {reply, Subscribed, StateName, StateData};\n\nhandle_sync_event(_Event, _From, StateName, StateData) ->\n    Reply = ok,\n    fsm_reply(Reply, StateName, StateData).\n\ncode_change(_OldVsn, StateName, StateData, _Extra) ->\n    {ok, StateName, StateData}.\n\n%%----------------------------------------------------------------------\n%% Func: handle_info/3\n%% Returns: {next_state, NextStateName, NextStateData}          |\n%%          {next_state, NextStateName, NextStateData, Timeout} |\n%%          {stop, Reason, NewStateData}\n%%----------------------------------------------------------------------\nhandle_info({send_text, Text}, StateName, StateData) ->\n    send_text(StateData, Text),\n    ejabberd_hooks:run(c2s_loop_debug, [Text]),\n    fsm_next_state(StateName, StateData);\nhandle_info(replaced, _StateName, StateData) ->\n    Lang = StateData#state.lang,\n    send_element(StateData,\n\t\t ?SERRT_CONFLICT(Lang, \"Replaced by new connection\")),\n    send_trailer(StateData),\n    {stop, normal, StateData#state{authenticated = replaced}};\n%% Process Packets that are to be send to the user\nhandle_info({route, From, To, Packet}, StateName, StateData) ->\n    #xmlel{name = Name, attrs = Attrs, children = Els} = Packet,\n    {Pass, NewAttrs, NewState} =\n\tcase Name of\n\t    <<\"presence\">> ->\n\t\tState = ejabberd_hooks:run_fold(\n\t\t\t  c2s_presence_in, StateData#state.server,\n\t\t\t  StateData,\n\t\t\t  [{From, To, Packet}]),\n\t\tcase xml:get_attr_s(<<\"type\">>, Attrs) of\n\t\t    <<\"probe\">> ->\n\t\t\tLFrom = jlib:jid_tolower(From),\n\t\t\tLBFrom = jlib:jid_remove_resource(LFrom),\n\t\t\tNewStateData =\n\t\t\t    case ?SETS:is_element(\n\t\t\t\t    LFrom, State#state.pres_a) orelse\n\t\t\t\t?SETS:is_element(\n\t\t\t\t   LBFrom, State#state.pres_a) of\n\t\t\t\ttrue ->\n\t\t\t\t    State;\n\t\t\t\tfalse ->\n\t\t\t\t    case ?SETS:is_element(\n\t\t\t\t\t    LFrom, State#state.pres_f) of\n\t\t\t\t\ttrue ->\n\t\t\t\t\t    A = ?SETS:add_element(\n\t\t\t\t\t\t   LFrom,\n\t\t\t\t\t\t   State#state.pres_a),\n\t\t\t\t\t    State#state{pres_a = A};\n\t\t\t\t\tfalse ->\n\t\t\t\t\t    case ?SETS:is_element(\n\t\t\t\t\t\t    LBFrom, State#state.pres_f) of\n\t\t\t\t\t\ttrue ->\n\t\t\t\t\t\t    A = ?SETS:add_element(\n\t\t\t\t\t\t\t   LBFrom,\n\t\t\t\t\t\t\t   State#state.pres_a),\n\t\t\t\t\t\t    State#state{pres_a = A};\n\t\t\t\t\t\tfalse ->\n\t\t\t\t\t\t    State\n\t\t\t\t\t    end\n\t\t\t\t    end\n\t\t\t    end,\n\t\t\tprocess_presence_probe(From, To, NewStateData),\n\t\t\t{false, Attrs, NewStateData};\n\t\t    <<\"error\">> ->\n\t\t\tNewA = remove_element(jlib:jid_tolower(From),\n\t\t\t\t\t      State#state.pres_a),\n\t\t\t{true, Attrs, State#state{pres_a = NewA}};\n\t\t    <<\"invisible\">> ->\n\t\t\tAttrs1 = lists:keydelete(<<\"type\">>, 1, Attrs),\n\t\t\t{true, [{<<\"type\">>, <<\"unavailable\">>} | Attrs1], State};\n\t\t    <<\"subscribe\">> ->\n\t\t\tSRes = is_privacy_allow(State, From, To, Packet, in),\n\t\t\t{SRes, Attrs, State};\n\t\t    <<\"subscribed\">> ->\n\t\t\tSRes = is_privacy_allow(State, From, To, Packet, in),\n\t\t\t{SRes, Attrs, State};\n\t\t    <<\"unsubscribe\">> ->\n\t\t\tSRes = is_privacy_allow(State, From, To, Packet, in),\n\t\t\t{SRes, Attrs, State};\n\t\t    <<\"unsubscribed\">> ->\n\t\t\tSRes = is_privacy_allow(State, From, To, Packet, in),\n\t\t\t{SRes, Attrs, State};\n\t\t    _ ->\n\t\t\tcase privacy_check_packet(State, From, To, Packet, in) of\n\t\t\t    allow ->\n\t\t\t\tLFrom = jlib:jid_tolower(From),\n\t\t\t\tLBFrom = jlib:jid_remove_resource(LFrom),\n\t\t\t\tcase ?SETS:is_element(\n\t\t\t\t\tLFrom, State#state.pres_a) orelse\n\t\t\t\t    ?SETS:is_element(\n\t\t\t\t       LBFrom, State#state.pres_a) of\n\t\t\t\t    true ->\n\t\t\t\t\t{true, Attrs, State};\n\t\t\t\t    false ->\n\t\t\t\t\tcase ?SETS:is_element(\n\t\t\t\t\t\tLFrom, State#state.pres_f) of\n\t\t\t\t\t    true ->\n\t\t\t\t\t\tA = ?SETS:add_element(\n\t\t\t\t\t\t       LFrom,\n\t\t\t\t\t\t       State#state.pres_a),\n\t\t\t\t\t\t{true, Attrs,\n\t\t\t\t\t\t State#state{pres_a = A}};\n\t\t\t\t\t    false ->\n\t\t\t\t\t\tcase ?SETS:is_element(\n\t\t\t\t\t\t\tLBFrom, State#state.pres_f) of\n\t\t\t\t\t\t    true ->\n\t\t\t\t\t\t\tA = ?SETS:add_element(\n\t\t\t\t\t\t\t       LBFrom,\n\t\t\t\t\t\t\t       State#state.pres_a),\n\t\t\t\t\t\t\t{true, Attrs,\n\t\t\t\t\t\t\t State#state{pres_a = A}};\n\t\t\t\t\t\t    false ->\n\t\t\t\t\t\t\t{true, Attrs, State}\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend;\n\t\t\t    deny ->\n\t\t\t\t{false, Attrs, State}\n\t\t\tend\n\t\tend;\n\t    <<\"broadcast\">> ->\n\t\t?DEBUG(\"broadcast~n~p~n\", [Els]),\n\t\tcase Els of\n\t\t    [{item, IJID, ISubscription}] ->\n\t\t\t{false, Attrs,\n\t\t\t roster_change(IJID, ISubscription,\n\t\t\t\t       StateData)};\n\t\t    [{exit, Reason}] ->\n\t\t\t{exit, Attrs, Reason};\n\t\t    [{privacy_list, PrivList, PrivListName}] ->\n\t\t\tcase ejabberd_hooks:run_fold(\n\t\t\t       privacy_updated_list, StateData#state.server,\n\t\t\t       false,\n\t\t\t       [StateData#state.privacy_list,\n\t\t\t\tPrivList]) of\n\t\t\t    false ->\n\t\t\t\t{false, Attrs, StateData};\n\t\t\t    NewPL ->\n\t\t\t\tPrivPushIQ =\n\t\t\t\t    #iq{type = set, xmlns = ?NS_PRIVACY,\n\t\t\t\t\tid = list_to_binary(\"push\" ++ randoms:get_string()),\n\t\t\t\t\tsub_el = [#xmlel{name = <<\"query\">>,\n\t\t\t\t\t\t         attrs = [{<<\"xmlns\">>, ?NS_PRIVACY}],\n\t\t\t\t\t\t         children = [#xmlel{name = <<\"list\">>,\n\t\t\t\t\t\t                            attrs = [{<<\"name\">>, PrivListName}]}]}]},\n\t\t\t\tPrivPushEl =\n\t\t\t\t    jlib:replace_from_to(\n\t\t\t\t      jlib:jid_remove_resource(\n\t\t\t\t\tStateData#state.jid),\n\t\t\t\t      StateData#state.jid,\n\t\t\t\t      jlib:iq_to_xml(PrivPushIQ)),\n\t\t\t\tsend_element(StateData, PrivPushEl),\n\t\t\t\t{false, Attrs, StateData#state{privacy_list = NewPL}}\n\t\t\tend;\n\t\t    [{blocking, What}] ->\n\t\t\troute_blocking(What, StateData),\n\t\t\t{false, Attrs, StateData};\n\t\t    _ ->\n\t\t\t{false, Attrs, StateData}\n\t\tend;\n\t    <<\"iq\">> ->\n\t\tIQ = jlib:iq_query_info(Packet),\n\t\tcase IQ of\n\t\t    #iq{xmlns = ?NS_LAST} ->\n\t\t\tLFrom = jlib:jid_tolower(From),\n\t\t\tLBFrom = jlib:jid_remove_resource(LFrom),\n\t\t\tHasFromSub = (?SETS:is_element(LFrom, StateData#state.pres_f) orelse ?SETS:is_element(LBFrom, StateData#state.pres_f))\n\t\t\t   andalso is_privacy_allow(StateData, To, From, #xmlel{name = <<\"presence\">>}, out),\n\t\t\tcase HasFromSub of\n\t\t\t    true ->\n\t\t\t\tcase privacy_check_packet(StateData, From, To, Packet, in) of\n\t\t\t\t    allow ->\n\t\t\t\t\t{true, Attrs, StateData};\n\t\t\t\t    deny ->\n\t\t\t\t\t{false, Attrs, StateData}\n\t\t\t\tend;\n\t\t\t    _ ->\n\t\t\t\tErr = jlib:make_error_reply(Packet, ?ERR_FORBIDDEN),\n\t\t\t\tejabberd_router:route(To, From, Err),\n\t\t\t\t{false, Attrs, StateData}\n\t\t\tend;\n\t\t    IQ when (is_record(IQ, iq)) or (IQ == reply) ->\n\t\t\tcase privacy_check_packet(StateData, From, To, Packet, in) of\n\t\t\t    allow ->\n\t\t\t\t{true, Attrs, StateData};\n\t\t\t    deny when is_record(IQ, iq) ->\n\t\t\t\tErr = jlib:make_error_reply(\n\t\t\t\t\tPacket, ?ERR_SERVICE_UNAVAILABLE),\n\t\t\t\tejabberd_router:route(To, From, Err),\n\t\t\t\t{false, Attrs, StateData};\n\t\t\t    deny when IQ == reply ->\n\t\t\t\t{false, Attrs, StateData}\n\t\t\tend;\n\t\t    IQ when (IQ == invalid) or (IQ == not_iq) ->\n\t\t\t{false, Attrs, StateData}\n\t\tend;\n\t    <<\"message\">> ->\n\t\tcase privacy_check_packet(StateData, From, To, Packet, in) of\n\t\t    allow ->\n\t\t\t{true, Attrs, StateData};\n\t\t    deny ->\n\t\t\t{false, Attrs, StateData}\n\t\tend;\n\t    _ ->\n\t\t{true, Attrs, StateData}\n\tend,\n    if\n\tPass == exit ->\n\t    %% When Pass==exit, NewState contains a string instead of a #state{}\n\t    Lang = StateData#state.lang,\n\t    send_element(StateData, ?SERRT_CONFLICT(Lang, NewState)),\n\t    send_trailer(StateData),\n\t    {stop, normal, StateData};\n\tPass ->\n\t    Attrs2 = jlib:replace_from_to_attrs(jlib:jid_to_binary(From),\n\t\t\t\t\t\tjlib:jid_to_binary(To),\n\t\t\t\t\t\tNewAttrs),\n\t    FixedPacket = Packet#xmlel{attrs = Attrs2},\n\t    send_element(StateData, FixedPacket),\n\t    ejabberd_hooks:run(user_receive_packet,\n\t\t\t       StateData#state.server,\n\t\t\t       [StateData#state.jid, From, To, FixedPacket]),\n\t    ejabberd_hooks:run(c2s_loop_debug, [{route, From, To, Packet}]),\n\t    fsm_next_state(StateName, NewState);\n\ttrue ->\n\t    ejabberd_hooks:run(c2s_loop_debug, [{route, From, To, Packet}]),\n\t    fsm_next_state(StateName, NewState)\n    end;\nhandle_info({'DOWN', Monitor, _Type, _Object, _Info}, _StateName, StateData)\n  when Monitor == StateData#state.socket_monitor ->\n    {stop, normal, StateData};\nhandle_info(system_shutdown, StateName, StateData) ->\n    case StateName of\n       wait_for_stream ->\n           send_header(StateData, ?MYNAME, \"1.0\", \"en\"),\n           send_element(StateData, ?SERR_SYSTEM_SHUTDOWN),\n           send_trailer(StateData),\n           ok;\n       _ ->\n           send_element(StateData, ?SERR_SYSTEM_SHUTDOWN),\n           send_trailer(StateData),\n           ok\n    end,\n    {stop, normal, StateData};\nhandle_info({force_update_presence, LUser}, StateName,\n            #state{user = LUser, server = LServer} = StateData) ->\n    NewStateData =\n\tcase StateData#state.pres_last of\n\t    #xmlel{name = <<\"presence\">>} ->\n\t\tPresenceEl = ejabberd_hooks:run_fold(\n\t\t\t       c2s_update_presence,\n\t\t\t       LServer,\n\t\t\t       StateData#state.pres_last,\n\t\t\t       [LUser, LServer]),\n\t\tStateData2 = StateData#state{pres_last = PresenceEl},\n\t\tpresence_update(StateData2#state.jid,\n\t\t\t\tPresenceEl,\n\t\t\t\tStateData2),\n\t\tStateData2;\n\t    _ ->\n\t\tStateData\n\tend,\n    {next_state, StateName, NewStateData};\nhandle_info({broadcast, Type, From, Packet}, StateName, StateData) ->\n    Recipients = ejabberd_hooks:run_fold(\n\t\t   c2s_broadcast_recipients, StateData#state.server,\n\t\t   [],\n\t\t   [StateData, Type, From, Packet]),\n    lists:foreach(\n      fun(USR) ->\n\t      ejabberd_router:route(\n\t\tFrom, jlib:make_jid(USR), Packet)\n      end, lists:usort(Recipients)),\n    fsm_next_state(StateName, StateData);\nhandle_info(Info, StateName, StateData) ->\n    ?ERROR_MSG(\"Unexpected info: ~p\", [Info]),\n    fsm_next_state(StateName, StateData).\n\n\n%%----------------------------------------------------------------------\n%% Func: print_state/1\n%% Purpose: Prepare the state to be printed on error log\n%% Returns: State to print\n%%----------------------------------------------------------------------\nprint_state(State = #state{pres_t = T, pres_f = F, pres_a = A, pres_i = I}) ->\n   State#state{pres_t = {pres_t, ?SETS:size(T)},\n               pres_f = {pres_f, ?SETS:size(F)},\n               pres_a = {pres_a, ?SETS:size(A)},\n               pres_i = {pres_i, ?SETS:size(I)}\n               }.\n\n%%----------------------------------------------------------------------\n%% Func: terminate/3\n%% Purpose: Shutdown the fsm\n%% Returns: any\n%%----------------------------------------------------------------------\nterminate(_Reason, StateName, StateData) ->\n    case StateName of\n\tsession_established ->\n\t    case StateData#state.authenticated of\n\t\treplaced ->\n\t\t    ?INFO_MSG(\"(~w) Replaced session for ~s\",\n\t\t\t      [StateData#state.socket,\n\t\t\t       jlib:jid_to_binary(StateData#state.jid)]),\n\t\t    From = StateData#state.jid,\n\t\t    Packet = #xmlel{name = <<\"presence\">>,\n\t\t\t            attrs = [{<<\"type\">>, <<\"unavailable\">>}],\n\t\t\t            children = [#xmlel{name = <<\"status\">>,\n\t\t\t\t                       children = [#xmlcdata{content = \"Replaced by new connection\"}]}]},\n\t\t    ejabberd_sm:close_session_unset_presence(\n\t\t      StateData#state.sid,\n\t\t      StateData#state.user,\n\t\t      StateData#state.server,\n\t\t      StateData#state.resource,\n\t\t      \"Replaced by new connection\"),\n\t\t    presence_broadcast(\n\t\t      StateData, From, StateData#state.pres_a, Packet),\n\t\t    presence_broadcast(\n\t\t      StateData, From, StateData#state.pres_i, Packet);\n\t\t_ ->\n\t\t    ?INFO_MSG(\"(~w) Close session for ~s\",\n\t\t\t      [StateData#state.socket,\n\t\t\t       jlib:jid_to_binary(StateData#state.jid)]),\n\n\t\t    EmptySet = ?SETS:new(),\n\t\t    case StateData of\n\t\t\t#state{pres_last = undefined,\n\t\t\t       pres_a = EmptySet,\n\t\t\t       pres_i = EmptySet,\n\t\t\t       pres_invis = false} ->\n\t\t\t    ejabberd_sm:close_session(StateData#state.sid,\n\t\t\t\t\t\t      StateData#state.user,\n\t\t\t\t\t\t      StateData#state.server,\n\t\t\t\t\t\t      StateData#state.resource);\n\t\t\t_ ->\n\t\t\t    From = StateData#state.jid,\n\t\t\t    Packet = #xmlel{name = <<\"presence\">>,\n\t\t\t\t            attrs = [{<<\"type\">>, <<\"unavailable\">>}]},\n\t\t\t    ejabberd_sm:close_session_unset_presence(\n\t\t\t      StateData#state.sid,\n\t\t\t      StateData#state.user,\n\t\t\t      StateData#state.server,\n\t\t\t      StateData#state.resource,\n\t\t\t      \"\"),\n\t\t\t    presence_broadcast(\n\t\t\t      StateData, From, StateData#state.pres_a, Packet),\n\t\t\t    presence_broadcast(\n\t\t\t      StateData, From, StateData#state.pres_i, Packet)\n\t\t    end\n\t    end,\n\t    bounce_messages();\n\t_ ->\n\t    ok\n    end,\n    (StateData#state.sockmod):close(StateData#state.socket),\n    ok.\n\n%%%----------------------------------------------------------------------\n%%% Internal functions\n%%%----------------------------------------------------------------------\n\nchange_shaper(StateData, JID) ->\n    Shaper = acl:match_rule(StateData#state.server,\n\t\t\t    StateData#state.shaper, JID),\n    (StateData#state.sockmod):change_shaper(StateData#state.socket, Shaper).\n\nsend_text(StateData, Text) when StateData#state.xml_socket ->\n    ?DEBUG(\"Send Text on stream = ~p\", [lists:flatten(Text)]),\n    (StateData#state.sockmod):send_xml(StateData#state.socket,\n\t\t\t\t       {xmlstreamraw, Text});\nsend_text(StateData, Text) ->\n    ?DEBUG(\"Send XML on stream = ~p\", [Text]),\n    (StateData#state.sockmod):send(StateData#state.socket, Text).\n\nsend_element(#state{server = Server, sockmod = SockMod} = StateData, El)\n\t\twhen StateData#state.xml_socket ->\n    ejabberd_hooks:run(xmpp_send_element,\n                       Server, [Server, El]),\n    SockMod:send_xml(StateData#state.socket,\n\t\t\t\t       {xmlstreamelement, El});\nsend_element(#state{server = Server} = StateData, El) ->\n    ejabberd_hooks:run(xmpp_send_element,\n                       Server, [Server, El]),\n    send_text(StateData, xml:element_to_binary(El)).\n\nsend_header(StateData, Server, Version, Lang)\n  when StateData#state.xml_socket ->\n    VersionAttr =\n\tcase Version of\n\t    \"\" -> [];\n\t    _ -> [{<<\"version\">>, Version}]\n\tend,\n    LangAttr =\n\tcase Lang of\n\t    \"\" -> [];\n\t    _ -> [{<<\"xml:lang\">>, Lang}]\n\tend,\n    Header =\n\t{xmlstreamstart,\n\t <<\"stream:stream\">>,\n\t VersionAttr ++\n\t LangAttr ++\n\t [{<<\"xmlns\">>, <<\"jabber:client\">>},\n\t  {<<\"xmlns:stream\">>, <<\"http://etherx.jabber.org/streams\">>},\n\t  {<<\"id\">>, StateData#state.streamid},\n\t  {<<\"from\">>, Server}]},\n    (StateData#state.sockmod):send_xml(\n      StateData#state.socket, Header);\nsend_header(StateData, Server, Version, Lang) ->\n    VersionStr =\n\tcase Version of\n\t    \"\" -> \"\";\n\t    _ -> [\" version='\", Version, \"'\"]\n\tend,\n    LangStr =\n\tcase Lang of\n\t    \"\" -> \"\";\n\t    _ -> [\" xml:lang='\", Lang, \"'\"]\n\tend,\n    Header = io_lib:format(?STREAM_HEADER,\n\t\t\t   [StateData#state.streamid,\n\t\t\t    Server,\n\t\t\t    VersionStr,\n\t\t\t    LangStr]),\n    send_text(StateData, Header).\n\nsend_trailer(StateData) when StateData#state.xml_socket ->\n    (StateData#state.sockmod):send_xml(\n      StateData#state.socket,\n      {xmlstreamend, <<\"stream:stream\">>});\nsend_trailer(StateData) ->\n    send_text(StateData, ?STREAM_TRAILER).\n\n\nnew_id() ->\n    randoms:get_string().\n\n\nis_auth_packet(El) ->\n    case jlib:iq_query_info(El) of\n\t#iq{id = ID, type = Type, xmlns = ?NS_AUTH, sub_el = SubEl} ->\n\t    #xmlel{children = Els} = SubEl,\n\t    {auth, ID, Type,\n\t     get_auth_tags(Els, <<>>, <<>>, <<>>, <<>>)};\n\t_ ->\n\t    false\n    end.\n\n\nget_auth_tags([#xmlel{name = Name, children = Els}| L], U, P, D, R) ->\n    CData = xml:get_cdata(Els),\n    case Name of\n\t<<\"username\">> ->\n\t    get_auth_tags(L, CData, P, D, R);\n\t<<\"password\">> ->\n\t    get_auth_tags(L, U, CData, D, R);\n\t<<\"digest\">> ->\n\t    get_auth_tags(L, U, P, CData, R);\n\t<<\"resource\">> ->\n\t    get_auth_tags(L, U, P, D, CData);\n\t_ ->\n\t    get_auth_tags(L, U, P, D, R)\n    end;\nget_auth_tags([_ | L], U, P, D, R) ->\n    get_auth_tags(L, U, P, D, R);\nget_auth_tags([], U, P, D, R) ->\n    {U, P, D, R}.\n\n%% Copied from ejabberd_socket.erl\n-record(socket_state, {sockmod, socket, receiver}).\n\nget_conn_type(StateData) ->\n    case (StateData#state.sockmod):get_sockmod(StateData#state.socket) of\n    gen_tcp -> c2s;\n    ejabberd_tls -> c2s_tls;\n    ejabberd_zlib ->\n\tcase ejabberd_zlib:get_sockmod((StateData#state.socket)#socket_state.socket) of\n\t    gen_tcp -> c2s_compressed;\n\t    ejabberd_tls -> c2s_compressed_tls\n\tend;\n    ejabberd_http_poll -> http_poll;\n    ejabberd_http_bind -> http_bind;\n    _ -> unknown\n    end.\n\nprocess_presence_probe(From, To, StateData) ->\n    LFrom = jlib:jid_tolower(From),\n    LBFrom = setelement(3, LFrom, <<>>),\n    case StateData#state.pres_last of\n\tundefined ->\n\t    ok;\n\t_ ->\n\t    Cond1 = (not StateData#state.pres_invis)\n\t\tandalso (?SETS:is_element(LFrom, StateData#state.pres_f)\n\t\t\t orelse\n\t\t\t ((LFrom /= LBFrom) andalso\n\t\t\t  ?SETS:is_element(LBFrom, StateData#state.pres_f)))\n\t\tandalso (not\n\t\t\t (?SETS:is_element(LFrom, StateData#state.pres_i)\n\t\t\t  orelse\n\t\t\t  ((LFrom /= LBFrom) andalso\n\t\t\t   ?SETS:is_element(LBFrom, StateData#state.pres_i)))),\n\t    Cond2 = StateData#state.pres_invis\n\t\tandalso ?SETS:is_element(LFrom, StateData#state.pres_f)\n\t\tandalso ?SETS:is_element(LFrom, StateData#state.pres_a),\n\t    if\n\t\tCond1 ->\n\t\t    Timestamp = StateData#state.pres_timestamp,\n\t\t    Packet = xml:append_subtags(\n\t\t\t       StateData#state.pres_last,\n\t\t\t       %% To is the one sending the presence (the target of the probe)\n\t\t\t       [jlib:timestamp_to_xml(Timestamp, utc, To, <<>>),\n\t\t\t\t%% TODO: Delete the next line once XEP-0091 is Obsolete\n\t\t\t\tjlib:timestamp_to_xml(Timestamp)]),\n\t\t    case privacy_check_packet(StateData, To, From, Packet, out) of\n\t\t\tdeny ->\n\t\t\t    ok;\n\t\t\tallow ->\n\t\t\t    Pid=element(2, StateData#state.sid),\n\t\t\t    ejabberd_hooks:run(presence_probe_hook, StateData#state.server, [From, To, Pid]),\n\t\t\t    %% Don't route a presence probe to oneself\n\t\t\t    case From == To of\n\t\t\t\tfalse ->\n\t\t\t\t    ejabberd_router:route(To, From, Packet);\n\t\t\t    \ttrue ->\n\t\t\t\t    ok\n\t\t\t    end\n\t\t    end;\n\t\tCond2 ->\n\t\t    ejabberd_router:route(To, From,\n\t\t\t\t\t  #xmlel{name = <<\"presence\">>});\n\t\ttrue ->\n\t\t    ok\n\t    end\n    end.\n\n%% User updates his presence (non-directed presence packet)\npresence_update(From, Packet, StateData) ->\n    #xmlel{attrs = Attrs} = Packet,\n    case xml:get_attr_s(<<\"type\">>, Attrs) of\n\t<<\"unavailable\">> ->\n\t    Status = case xml:get_subtag(Packet, <<\"status\">>) of\n\t\t\t false ->\n\t\t\t    <<>>;\n\t\t\t StatusTag ->\n\t\t\t    xml:get_tag_cdata(StatusTag)\n\t\t     end,\n\t    Info = [{ip, StateData#state.ip}, {conn, StateData#state.conn},\n\t\t    {auth_module, StateData#state.auth_module}],\n\t    ejabberd_sm:unset_presence(StateData#state.sid,\n\t\t\t\t       StateData#state.user,\n\t\t\t\t       StateData#state.server,\n\t\t\t\t       StateData#state.resource,\n\t\t\t\t       Status,\n\t\t\t\t       Info),\n\t    presence_broadcast(StateData, From, StateData#state.pres_a, Packet),\n\t    presence_broadcast(StateData, From, StateData#state.pres_i, Packet),\n\t    StateData#state{pres_last = undefined,\n\t\t\t    pres_timestamp = undefined,\n\t\t\t    pres_a = ?SETS:new(),\n\t\t\t    pres_i = ?SETS:new(),\n\t\t\t    pres_invis = false};\n\t<<\"invisible\">> ->\n\t    NewPriority = get_priority_from_presence(Packet),\n\t    update_priority(NewPriority, Packet, StateData),\n\t    NewState =\n\t\tif\n\t\t    not StateData#state.pres_invis ->\n\t\t\tpresence_broadcast(StateData, From,\n\t\t\t\t\t   StateData#state.pres_a,\n\t\t\t\t\t   Packet),\n\t\t\tpresence_broadcast(StateData, From,\n\t\t\t\t\t   StateData#state.pres_i,\n\t\t\t\t\t   Packet),\n\t\t\tS1 = StateData#state{pres_last = undefined,\n\t\t\t\t\t     pres_timestamp = undefined,\n\t\t\t\t\t     pres_a = ?SETS:new(),\n\t\t\t\t\t     pres_i = ?SETS:new(),\n\t\t\t\t\t     pres_invis = true},\n\t\t\tpresence_broadcast_first(From, S1, Packet);\n\t\t    true ->\n\t\t\tStateData\n\t\tend,\n\t    NewState;\n\t<<\"error\">> ->\n\t    StateData;\n\t<<\"probe\">> ->\n\t    StateData;\n\t<<\"subscribe\">> ->\n\t    StateData;\n\t<<\"subscribed\">> ->\n\t    StateData;\n\t<<\"unsubscribe\">> ->\n\t    StateData;\n\t<<\"unsubscribed\">> ->\n\t    StateData;\n\t_ ->\n\t    OldPriority = case StateData#state.pres_last of\n\t\t\t      undefined ->\n\t\t\t\t  0;\n\t\t\t      OldPresence ->\n\t\t\t\t  get_priority_from_presence(OldPresence)\n\t\t\t  end,\n\t    NewPriority = get_priority_from_presence(Packet),\n\t    Timestamp = calendar:now_to_universal_time(os:timestamp()),\n\t    update_priority(NewPriority, Packet, StateData),\n\t    FromUnavail = (StateData#state.pres_last == undefined) or\n\t\tStateData#state.pres_invis,\n\t    ?DEBUG(\"from unavail = ~p~n\", [FromUnavail]),\n        NewStateData = StateData#state{pres_last = Packet,\n                                       pres_invis = false,\n                                       pres_timestamp = Timestamp},\n\t\tif\n\t\t    FromUnavail ->\n\t\t\tejabberd_hooks:run(user_available_hook,\n\t\t\t\t\t   NewStateData#state.server,\n\t\t\t\t\t   [NewStateData#state.jid]),\n\t\t\tNewStateData1 = if NewPriority >= 0 ->\n                                    resend_offline_messages(NewStateData),\n                                    resend_subscription_requests(NewStateData);\n                               true ->\n                                    NewStateData\n                            end,\n\t\t\tpresence_broadcast_first(From, NewStateData1, Packet);\n\t\t    true ->\n\t\t\tpresence_broadcast_to_trusted(NewStateData,\n\t\t\t\t\t\t      From,\n\t\t\t\t\t\t      NewStateData#state.pres_f,\n\t\t\t\t\t\t      NewStateData#state.pres_a,\n\t\t\t\t\t\t      Packet),\n\t\t\tif OldPriority < 0, NewPriority >= 0 ->\n\t\t\t\tresend_offline_messages(NewStateData);\n\t\t\t   true ->\n\t\t\t\tok\n\t\t\tend,\n            NewStateData\n\t\tend\n    end.\n\n%% User sends a directed presence packet\npresence_track(From, To, Packet, StateData) ->\n    #xmlel{attrs = Attrs} = Packet,\n    LTo = jlib:jid_tolower(To),\n    User = StateData#state.user,\n    Server = StateData#state.server,\n    case xml:get_attr_s(<<\"type\">>, Attrs) of\n\t<<\"unavailable\">> ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    I = remove_element(LTo, StateData#state.pres_i),\n\t    A = remove_element(LTo, StateData#state.pres_a),\n\t    StateData#state{pres_i = I,\n\t\t\t    pres_a = A};\n\t<<\"invisible\">> ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    I = ?SETS:add_element(LTo, StateData#state.pres_i),\n\t    A = remove_element(LTo, StateData#state.pres_a),\n\t    StateData#state{pres_i = I,\n\t\t\t    pres_a = A};\n\t<<\"subscribe\">> ->\n\t    ejabberd_hooks:run(roster_out_subscription,\n\t\t\t       Server,\n\t\t\t       [User, Server, To, subscribe]),\n\t    check_privacy_route(From, StateData, jlib:jid_remove_resource(From),\n\t\t\t\tTo, Packet),\n\t    StateData;\n\t<<\"subscribed\">> ->\n\t    ejabberd_hooks:run(roster_out_subscription,\n\t\t\t       Server,\n\t\t\t       [User, Server, To, subscribed]),\n\t    check_privacy_route(From, StateData, jlib:jid_remove_resource(From),\n\t\t\t\tTo, Packet),\n\t    StateData;\n\t<<\"unsubscribe\">> ->\n\t    ejabberd_hooks:run(roster_out_subscription,\n\t\t\t       Server,\n\t\t\t       [User, Server, To, unsubscribe]),\n\t    check_privacy_route(From, StateData, jlib:jid_remove_resource(From),\n\t\t\t\tTo, Packet),\n\t    StateData;\n\t<<\"unsubscribed\">> ->\n\t    ejabberd_hooks:run(roster_out_subscription,\n\t\t\t       Server,\n\t\t\t       [User, Server, To, unsubscribed]),\n\t    check_privacy_route(From, StateData, jlib:jid_remove_resource(From),\n\t\t\t\tTo, Packet),\n\t    StateData;\n\t<<\"error\">> ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    StateData;\n\t<<\"probe\">> ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    StateData;\n\t_ ->\n\t    check_privacy_route(From, StateData, From, To, Packet),\n\t    I = remove_element(LTo, StateData#state.pres_i),\n\t    A = ?SETS:add_element(LTo, StateData#state.pres_a),\n\t    StateData#state{pres_i = I,\n\t\t\t    pres_a = A}\n    end.\n\ncheck_privacy_route(From, StateData, FromRoute, To, Packet) ->\n    case privacy_check_packet(StateData, From, To, Packet, out) of\n\tdeny ->\n\t    Lang = StateData#state.lang,\n\t    ErrText = \"Your active privacy list has denied the routing of this stanza.\",\n\t    Err = jlib:make_error_reply(Packet, ?ERRT_NOT_ACCEPTABLE(Lang, ErrText)),\n\t    ejabberd_router:route(To, From, Err),\n\t    ok;\n\tallow ->\n\t    ejabberd_router:route(FromRoute, To, Packet)\n    end.\n\nprivacy_check_packet(StateData, From, To, Packet, Dir) ->\n    ejabberd_hooks:run_fold(\n      privacy_check_packet, StateData#state.server,\n      allow,\n      [StateData#state.user,\n       StateData#state.server,\n       StateData#state.privacy_list,\n       {From, To, Packet},\n       Dir]).\n\n%% Check if privacy rules allow this delivery\nis_privacy_allow(StateData, From, To, Packet, Dir) ->\n    allow == privacy_check_packet(StateData, From, To, Packet, Dir).\n\npresence_broadcast(StateData, From, JIDSet, Packet) ->\n    lists:foreach(fun(JID) ->\n\t\t\t  FJID = jlib:make_jid(JID),\n\t\t\t  case privacy_check_packet(StateData, From, FJID, Packet, out) of\n\t\t\t      deny ->\n\t\t\t\t  ok;\n\t\t\t      allow ->\n\t\t\t\t  ejabberd_router:route(From, FJID, Packet)\n\t\t\t  end\n\t\t  end, ?SETS:to_list(JIDSet)).\n\npresence_broadcast_to_trusted(StateData, From, T, A, Packet) ->\n    lists:foreach(\n      fun(JID) ->\n\t      case ?SETS:is_element(JID, T) of\n\t\t  true ->\n\t\t      FJID = jlib:make_jid(JID),\n\t\t      case privacy_check_packet(StateData, From, FJID, Packet, out) of\n\t\t\t  deny ->\n\t\t\t      ok;\n\t\t\t  allow ->\n\t\t\t      ejabberd_router:route(From, FJID, Packet)\n\t\t      end;\n\t\t  _ ->\n\t\t      ok\n\t      end\n      end, ?SETS:to_list(A)).\n\n\npresence_broadcast_first(From, StateData, Packet) ->\n    ?SETS:fold(fun(JID, X) ->\n\t\t       ejabberd_router:route(\n\t\t\t From,\n\t\t\t jlib:make_jid(JID),\n\t\t\t #xmlel{name = <<\"presence\">>,\n\t\t\t        attrs = [{<<\"type\">>, <<\"probe\">>}]}),\n\t\t       X\n\t       end,\n\t       [],\n\t       StateData#state.pres_t),\n    if\n\tStateData#state.pres_invis ->\n\t    StateData;\n\ttrue ->\n\t    As = ?SETS:fold(\n\t\t    fun(JID, A) ->\n\t\t\t    FJID = jlib:make_jid(JID),\n\t\t\t    case privacy_check_packet(StateData, From, FJID, Packet, out) of\n\t\t\t\tdeny ->\n\t\t\t\t    ok;\n\t\t\t\tallow ->\n\t\t\t\t    ejabberd_router:route(From, FJID, Packet)\n\t\t\t    end,\n\t\t\t    ?SETS:add_element(JID, A)\n\t\t    end,\n\t\t    StateData#state.pres_a,\n\t\t    StateData#state.pres_f),\n\t    StateData#state{pres_a = As}\n    end.\n\n\nremove_element(E, Set) ->\n    case ?SETS:is_element(E, Set) of\n\ttrue ->\n\t    ?SETS:del_element(E, Set);\n\t_ ->\n\t    Set\n    end.\n\n\nroster_change(IJID, ISubscription, StateData) ->\n    LIJID = jlib:jid_tolower(IJID),\n    IsFrom = (ISubscription == both) or (ISubscription == from),\n    IsTo   = (ISubscription == both) or (ISubscription == to),\n    OldIsFrom = ?SETS:is_element(LIJID, StateData#state.pres_f),\n    FSet = if\n\t       IsFrom ->\n\t\t   ?SETS:add_element(LIJID, StateData#state.pres_f);\n\t       true ->\n\t\t   remove_element(LIJID, StateData#state.pres_f)\n\t   end,\n    TSet = if\n\t       IsTo ->\n\t\t   ?SETS:add_element(LIJID, StateData#state.pres_t);\n\t       true ->\n\t\t   remove_element(LIJID, StateData#state.pres_t)\n\t   end,\n    case StateData#state.pres_last of\n\tundefined ->\n\t    StateData#state{pres_f = FSet, pres_t = TSet};\n\tP ->\n\t    ?DEBUG(\"roster changed for ~p~n\", [StateData#state.user]),\n\t    From = StateData#state.jid,\n\t    To = jlib:make_jid(IJID),\n\t    Cond1 = (not StateData#state.pres_invis) and IsFrom\n\t\tand (not OldIsFrom),\n\t    Cond2 = (not IsFrom) and OldIsFrom\n\t\tand (?SETS:is_element(LIJID, StateData#state.pres_a) or\n\t\t     ?SETS:is_element(LIJID, StateData#state.pres_i)),\n\t    if\n\t\tCond1 ->\n\t\t    ?DEBUG(\"C1: ~p~n\", [LIJID]),\n\t\t    case privacy_check_packet(StateData, From, To, P, out) of\n\t\t\tdeny ->\n\t\t\t    ok;\n\t\t\tallow ->\n\t\t\t    ejabberd_router:route(From, To, P)\n\t\t    end,\n\t\t    A = ?SETS:add_element(LIJID,\n\t\t\t\t\t  StateData#state.pres_a),\n\t\t    StateData#state{pres_a = A,\n\t\t\t\t    pres_f = FSet,\n\t\t\t\t    pres_t = TSet};\n\t\tCond2 ->\n\t\t    ?DEBUG(\"C2: ~p~n\", [LIJID]),\n\t\t    PU = #xmlel{name = <<\"presence\">>,\n\t\t\t        attrs = [{<<\"type\">>, <<\"unavailable\">>}]},\n\t\t    case privacy_check_packet(StateData, From, To, PU, out) of\n\t\t\tdeny ->\n\t\t\t    ok;\n\t\t\tallow ->\n\t\t\t    ejabberd_router:route(From, To, PU)\n\t\t    end,\n\t\t    I = remove_element(LIJID,\n\t\t\t\t       StateData#state.pres_i),\n\t\t    A = remove_element(LIJID,\n\t\t\t\t       StateData#state.pres_a),\n\t\t    StateData#state{pres_i = I,\n\t\t\t\t    pres_a = A,\n\t\t\t\t    pres_f = FSet,\n\t\t\t\t    pres_t = TSet};\n\t\ttrue ->\n\t\t    StateData#state{pres_f = FSet, pres_t = TSet}\n\t    end\n    end.\n\n\nupdate_priority(Priority, Packet, StateData) ->\n    Info = [{ip, StateData#state.ip}, {conn, StateData#state.conn},\n\t    {auth_module, StateData#state.auth_module}],\n    ejabberd_sm:set_presence(StateData#state.sid,\n\t\t\t     StateData#state.user,\n\t\t\t     StateData#state.server,\n\t\t\t     StateData#state.resource,\n\t\t\t     Priority,\n\t\t\t     Packet,\n\t\t\t     Info).\n\nget_priority_from_presence(PresencePacket) ->\n    case xml:get_subtag(PresencePacket, <<\"priority\">>) of\n\tfalse ->\n\t    0;\n\tSubEl ->\n        case catch list_to_integer(binary_to_list(xml:get_tag_cdata(SubEl))) of\n\t\tP when is_integer(P) ->\n\t\t    P;\n\t\t_ ->\n\t\t    0\n\t    end\n    end.\n\nprocess_privacy_iq(From, To,\n\t\t   #iq{type = Type, sub_el = SubEl} = IQ,\n\t\t   StateData) ->\n    {Res, NewStateData} =\n\tcase Type of\n\t    get ->\n\t\tR = ejabberd_hooks:run_fold(\n\t\t      privacy_iq_get, StateData#state.server,\n\t\t      {error, ?ERR_FEATURE_NOT_IMPLEMENTED},\n\t\t      [From, To, IQ, StateData#state.privacy_list]),\n\t\t{R, StateData};\n\t    set ->\n\t\tcase ejabberd_hooks:run_fold(\n\t\t       privacy_iq_set, StateData#state.server,\n\t\t       {error, ?ERR_FEATURE_NOT_IMPLEMENTED},\n\t\t       [From, To, IQ]) of\n\t\t    {result, R, NewPrivList} ->\n\t\t\t{{result, R},\n\t\t\t StateData#state{privacy_list = NewPrivList}};\n\t\t    R -> {R, StateData}\n\t\tend\n\tend,\n    IQRes =\n\tcase Res of\n\t    {result, Result} ->\n\t\tIQ#iq{type = result, sub_el = Result};\n\t    {error, Error} ->\n\t\tIQ#iq{type = error, sub_el = [SubEl, Error]}\n\tend,\n    ejabberd_router:route(\n      To, From, jlib:iq_to_xml(IQRes)),\n    NewStateData.\n\n\nresend_offline_messages(StateData) ->\n    case ejabberd_hooks:run_fold(\n\t   resend_offline_messages_hook, StateData#state.server,\n\t   [],\n\t   [StateData#state.user, StateData#state.server]) of\n\tRs when is_list(Rs) ->\n\t    lists:foreach(\n\t      fun({route,\n\t\t   From, To, #xmlel{} = Packet}) ->\n\t\t      Pass = case privacy_check_packet(StateData, From, To, Packet, in) of\n\t\t\t\t allow ->\n\t\t\t\t     true;\n\t\t\t\t deny ->\n\t\t\t\t     false\n\t\t\t     end,\n\t\t      if\n\t\t\t  Pass ->\n\t\t\t      %% Attrs2 = jlib:replace_from_to_attrs(\n\t\t\t      %%\t\t jlib:jid_to_binary(From),\n\t\t\t      %%\t\t jlib:jid_to_binary(To),\n\t\t\t      %%\t\t Attrs),\n\t\t\t      %% FixedPacket = {xmlel, Name, Attrs2, Els},\n                              %% Use route instead of send_element to go through standard workflow\n                              ejabberd_router:route(From, To, Packet);\n\t\t\t      %% send_element(StateData, FixedPacket),\n\t\t\t      %% ejabberd_hooks:run(user_receive_packet,\n\t\t\t      %%\t\t\t StateData#state.server,\n\t\t\t      %%\t\t\t [StateData#state.jid,\n\t\t\t      %%\t\t\t  From, To, FixedPacket]);\n\t\t\t  true ->\n\t\t\t      ok\n\t\t      end\n\t      end, Rs)\n    end.\n\nresend_subscription_requests(#state{pending_invitations = Pending} = StateData) ->\n    lists:foreach(fun(XMLPacket) ->\n\t\t\t  send_element(StateData,\n\t\t\t\t       XMLPacket)\n\t\t  end, Pending),\n    StateData#state{pending_invitations = []}.\n\nget_showtag(undefined) ->\n    <<\"unavailable\">>;\nget_showtag(Presence) ->\n    case xml:get_path_s(Presence, [{elem, <<\"show\">>}, cdata]) of\n\t<<>>      -> <<\"available\">>;\n\tShowTag -> ShowTag\n    end.\n\nget_statustag(undefined) ->\n    <<>>;\nget_statustag(Presence) ->\n    case xml:get_path_s(Presence, [{elem, <<\"status\">>}, cdata]) of\n\tShowTag -> ShowTag\n    end.\n\nprocess_unauthenticated_stanza(StateData, El) ->\n    NewEl = case xml:get_tag_attr_s(<<\"xml:lang\">>, El) of\n\t\t<<>> ->\n\t\t    case StateData#state.lang of\n\t\t\t<<>> -> El;\n\t\t\tLang ->\n\t\t\t    xml:replace_tag_attr(<<\"xml:lang\">>, list_to_binary(Lang), El)\n\t\t    end;\n\t\t_ ->\n\t\t    El\n\t    end,\n    case jlib:iq_query_info(NewEl) of\n\t#iq{} = IQ ->\n\t    Res = ejabberd_hooks:run_fold(c2s_unauthenticated_iq,\n\t\t\t\t\t  StateData#state.server,\n\t\t\t\t\t  empty,\n\t\t\t\t\t  [StateData#state.server, IQ,\n\t\t\t\t\t   StateData#state.ip]),\n\t    case Res of\n\t\tempty ->\n\t\t    % The only reasonable IQ's here are auth and register IQ's\n\t\t    % They contain secrets, so don't include subelements to responsec\n\t\t    ResIQ = IQ#iq{type = error,\n\t\t\t\t  sub_el = [?ERR_SERVICE_UNAVAILABLE]},\n\t\t    Res1 = jlib:replace_from_to(\n\t\t\t     jlib:make_jid(<<>>, StateData#state.server, <<>>),\n\t\t\t     jlib:make_jid(<<>>, <<>>, <<>>),\n\t\t\t     jlib:iq_to_xml(ResIQ)),\n\t\t    send_element(StateData, jlib:remove_attr(<<\"to\">>, Res1));\n\t\t_ ->\n\t\t    send_element(StateData, Res)\n\t    end;\n\t_ ->\n\t    % Drop any stanza, which isn't IQ stanza\n\t    ok\n    end.\n\npeerip(SockMod, Socket) ->\n    IP = case SockMod of\n\t     gen_tcp -> inet:peername(Socket);\n\t     _ -> SockMod:peername(Socket)\n\t end,\n    case IP of\n\t{ok, IPOK} -> IPOK;\n\t_ -> undefined\n    end.\n\n%% fsm_next_state_pack: Pack the StateData structure to improve\n%% sharing.\nfsm_next_state_pack(StateName, StateData) ->\n    fsm_next_state_gc(StateName, pack(StateData)).\n\n%% fsm_next_state_gc: Garbage collect the process heap to make use of\n%% the newly packed StateData structure.\nfsm_next_state_gc(StateName, PackedStateData) ->\n    erlang:garbage_collect(),\n    fsm_next_state(StateName, PackedStateData).\n\n%% fsm_next_state: Generate the next_state FSM tuple with different\n%% timeout, depending on the future state\nfsm_next_state(session_established, StateData) ->\n    {next_state, session_established, StateData, ?C2S_HIBERNATE_TIMEOUT};\nfsm_next_state(StateName, StateData) ->\n    {next_state, StateName, StateData, ?C2S_OPEN_TIMEOUT}.\n\n%% fsm_reply: Generate the reply FSM tuple with different timeout,\n%% depending on the future state\nfsm_reply(Reply, session_established, StateData) ->\n    {reply, Reply, session_established, StateData, ?C2S_HIBERNATE_TIMEOUT};\nfsm_reply(Reply, StateName, StateData) ->\n    {reply, Reply, StateName, StateData, ?C2S_OPEN_TIMEOUT}.\n\n%% Used by c2s blacklist plugins\nis_ip_blacklisted(undefined) ->\n    false;\nis_ip_blacklisted({IP,_Port}) ->\n    ejabberd_hooks:run_fold(check_bl_c2s, false, [IP]).\n\n%% Check from attributes\n%% returns invalid-from|NewElement\ncheck_from(El, FromJID) ->\n    case xml:get_tag_attr(<<\"from\">>, El) of\n\tfalse ->\n\t    El;\n\t{value, SJID} ->\n\t    JID = jlib:binary_to_jid(SJID),\n\t    case JID of\n\t\terror ->\n\t\t    'invalid-from';\n\t\t#jid{} ->\n\t\t    if\n\t\t\t(JID#jid.luser == FromJID#jid.luser) and\n\t\t\t(JID#jid.lserver == FromJID#jid.lserver) and\n\t\t\t(JID#jid.lresource == FromJID#jid.lresource) ->\n\t\t\t    El;\n\t\t\t(JID#jid.luser == FromJID#jid.luser) and\n\t\t\t(JID#jid.lserver == FromJID#jid.lserver) and\n\t\t\t(JID#jid.lresource == <<>>) ->\n\t\t\t    El;\n\t\t\ttrue ->\n\t\t\t    'invalid-from'\n\t\t    end\n\t    end\n    end.\n\nfsm_limit_opts(Opts) ->\n    case lists:keyfind(max_fsm_queue, 1, Opts) of\n\t{_, N} when is_integer(N) ->\n\t    [{max_queue, N}];\n\t_ ->\n\t    case ejabberd_config:get_local_option(max_fsm_queue) of\n\t\tN when is_integer(N) ->\n\t\t    [{max_queue, N}];\n\t\t_ ->\n\t\t    []\n\t    end\n    end.\n\nbounce_messages() ->\n    receive\n\t{route, From, To, El} ->\n\t    ejabberd_router:route(From, To, El),\n\t    bounce_messages()\n    after 0 ->\n\t    ok\n    end.\n\n%%%----------------------------------------------------------------------\n%%% XEP-0191\n%%%----------------------------------------------------------------------\n\nroute_blocking(What, StateData) ->\n    SubEl =\n\tcase What of\n\t    {block, JIDs} ->\n\t\t#xmlel{name = <<\"block\">>,\n\t\t       attrs = [{<<\"xmlns\">>, ?NS_BLOCKING}],\n\t\t       children = lists:map(\n\t\t                    fun(JID) ->\n\t\t\t                    #xmlel{name = <<\"item\">>,\n\t\t\t                           attrs = [{<<\"jid\">>, jlib:jid_to_binary(JID)}]}\n\t\t\t            end, JIDs)};\n\t    {unblock, JIDs} ->\n\t\t#xmlel{name = <<\"unblock\">>,\n\t\t       attrs = [{<<\"xmlns\">>, ?NS_BLOCKING}],\n\t\t       children = lists:map(\n\t\t                    fun(JID) ->\n\t\t\t                    #xmlel{name = <<\"item\">>,\n\t\t\t                           attrs = [{<<\"jid\">>, jlib:jid_to_binary(JID)}]}\n\t\t\t            end, JIDs)};\n\t    unblock_all ->\n\t\t#xmlel{name = <<\"unblock\">>,\n\t\t       attrs = [{<<\"xmlns\">>, ?NS_BLOCKING}]}\n\tend,\n    PrivPushIQ =\n\t#iq{type = set, xmlns = ?NS_BLOCKING,\n\t    id = <<\"push\">>,\n\t    sub_el = [SubEl]},\n    PrivPushEl =\n\tjlib:replace_from_to(\n\t  jlib:jid_remove_resource(\n\t    StateData#state.jid),\n\t  StateData#state.jid,\n\t  jlib:iq_to_xml(PrivPushIQ)),\n    send_element(StateData, PrivPushEl),\n    %% No need to replace active privacy list here,\n    %% blocking pushes are always accompanied by\n    %% Privacy List pushes\n    ok.\n\n%%%----------------------------------------------------------------------\n%%% JID Set memory footprint reduction code\n%%%----------------------------------------------------------------------\n\n%% Try to reduce the heap footprint of the four presence sets\n%% by ensuring that we re-use strings and Jids wherever possible.\npack(S = #state{pres_a=A,\n                pres_i=I,\n                pres_f=F,\n                pres_t=T}) ->\n    {NewA, Pack1} = pack_jid_set(A, gb_trees:empty()),\n    {NewI, Pack2} = pack_jid_set(I, Pack1),\n    {NewF, Pack3} = pack_jid_set(F, Pack2),\n    {NewT, _Pack4} = pack_jid_set(T, Pack3),\n    %% Throw away Pack4 so that if we delete references to\n    %% Strings or Jids in any of the sets there will be\n    %% no live references for the GC to find.\n    S#state{pres_a=NewA,\n            pres_i=NewI,\n            pres_f=NewF,\n            pres_t=NewT}.\n\npack_jid_set(Set, Pack) ->\n    Jids = ?SETS:to_list(Set),\n    {PackedJids, NewPack} = pack_jids(Jids, Pack, []),\n    {?SETS:from_list(PackedJids), NewPack}.\n\npack_jids([], Pack, Acc) -> {Acc, Pack};\npack_jids([{U,S,R}=Jid | Jids], Pack, Acc) ->\n    case gb_trees:lookup(Jid, Pack) of\n        {value, PackedJid} ->\n            pack_jids(Jids, Pack, [PackedJid | Acc]);\n        none ->\n            {NewU, Pack1} = pack_string(U, Pack),\n            {NewS, Pack2} = pack_string(S, Pack1),\n            {NewR, Pack3} = pack_string(R, Pack2),\n            NewJid = {NewU, NewS, NewR},\n            NewPack = gb_trees:insert(NewJid, NewJid, Pack3),\n            pack_jids(Jids, NewPack, [NewJid | Acc])\n    end.\n\npack_string(String, Pack) ->\n    case gb_trees:lookup(String, Pack) of\n        {value, PackedString} ->\n            {PackedString, Pack};\n        none ->\n            {String, gb_trees:insert(String, String, Pack)}\n    end.\n", "%%%----------------------------------------------------------------------\n%%% File    : ejabberd_receiver.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Socket receiver for C2S and S2S connections\n%%% Created : 10 Nov 2003 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(ejabberd_receiver).\n-author('alexey@process-one.net').\n\n-behaviour(gen_server).\n\n%% API\n-export([start_link/4,\n\t start/3,\n\t start/4,\n\t change_shaper/2,\n\t reset_stream/1,\n\t starttls/2,\n\t compress/2,\n\t become_controller/2,\n\t close/1]).\n\n%% gen_server callbacks\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2,\n\t terminate/2, code_change/3]).\n\n-include(\"ejabberd.hrl\").\n-include(\"jlib.hrl\").\n\n-record(state, {socket,\n\t\tsock_mod,\n\t\tshaper_state,\n\t\tc2s_pid,\n\t\tmax_stanza_size,\n\t\txml_stream_state,\n\t\ttimeout}).\n\n-define(HIBERNATE_TIMEOUT, 90000).\n-define(GEN_FSM, p1_fsm).\n\n%%====================================================================\n%% API\n%%====================================================================\n%%--------------------------------------------------------------------\n%% Function: start_link() -> {ok,Pid} | ignore | {error,Error}\n%% Description: Starts the server\n%%--------------------------------------------------------------------\nstart_link(Socket, SockMod, Shaper, MaxStanzaSize) ->\n    gen_server:start_link(\n      ?MODULE, [Socket, SockMod, Shaper, MaxStanzaSize], []).\n\n%%--------------------------------------------------------------------\n%% Function: start() -> {ok,Pid} | ignore | {error,Error}\n%% Description: Starts the server\n%%--------------------------------------------------------------------\nstart(Socket, SockMod, Shaper) ->\n    start(Socket, SockMod, Shaper, infinity).\n\nstart(Socket, SockMod, Shaper, MaxStanzaSize) ->\n    {ok, Pid} = supervisor:start_child(\n\t\t  ejabberd_receiver_sup,\n\t\t  [Socket, SockMod, Shaper, MaxStanzaSize]),\n    Pid.\n\nchange_shaper(Pid, Shaper) ->\n    gen_server:cast(Pid, {change_shaper, Shaper}).\n\nreset_stream(Pid) ->\n    gen_server:call(Pid, reset_stream).\n\nstarttls(Pid, TLSSocket) ->\n    gen_server:call(Pid, {starttls, TLSSocket}).\n\ncompress(Pid, ZlibSocket) ->\n    gen_server:call(Pid, {compress, ZlibSocket}).\n\nbecome_controller(Pid, C2SPid) ->\n    gen_server:call(Pid, {become_controller, C2SPid}).\n\nclose(Pid) ->\n    gen_server:cast(Pid, close).\n\n%%====================================================================\n%% gen_server callbacks\n%%====================================================================\n\n%%--------------------------------------------------------------------\n%% Function: init(Args) -> {ok, State} |\n%%                         {ok, State, Timeout} |\n%%                         ignore               |\n%%                         {stop, Reason}\n%% Description: Initiates the server\n%%--------------------------------------------------------------------\ninit([Socket, SockMod, Shaper, MaxStanzaSize]) ->\n    ShaperState = shaper:new(Shaper),\n    Timeout = case SockMod of\n\t\t  ssl ->\n\t\t      20;\n\t\t  _ ->\n\t\t      infinity\n\t      end,\n    {ok, #state{socket = Socket,\n\t\tsock_mod = SockMod,\n\t\tshaper_state = ShaperState,\n\t\tmax_stanza_size = MaxStanzaSize,\n\t\ttimeout = Timeout}}.\n\n%%--------------------------------------------------------------------\n%% Function: %% handle_call(Request, From, State) -> {reply, Reply, State} |\n%%                                      {reply, Reply, State, Timeout} |\n%%                                      {noreply, State} |\n%%                                      {noreply, State, Timeout} |\n%%                                      {stop, Reason, Reply, State} |\n%%                                      {stop, Reason, State}\n%% Description: Handling call messages\n%%--------------------------------------------------------------------\nhandle_call({starttls, TLSSocket}, _From,\n\t    #state{xml_stream_state = XMLStreamState,\n\t\t   c2s_pid = C2SPid,\n\t\t   max_stanza_size = MaxStanzaSize} = State) ->\n    close_stream(XMLStreamState),\n    NewXMLStreamState = xml_stream:new(C2SPid, MaxStanzaSize),\n    NewState = State#state{socket = TLSSocket,\n\t\t\t   sock_mod = ejabberd_tls,\n\t\t\t   xml_stream_state = NewXMLStreamState},\n    case ejabberd_tls:recv_data(TLSSocket, \"\") of\n\t{ok, TLSData} ->\n\t    {reply, ok, process_data(TLSData, NewState), ?HIBERNATE_TIMEOUT};\n\t{error, _Reason} ->\n\t    {stop, normal, ok, NewState}\n    end;\nhandle_call({compress, ZlibSocket}, _From,\n\t    #state{xml_stream_state = XMLStreamState,\n\t\t   c2s_pid = C2SPid,\n\t\t   max_stanza_size = MaxStanzaSize} = State) ->\n    close_stream(XMLStreamState),\n    NewXMLStreamState = xml_stream:new(C2SPid, MaxStanzaSize),\n    NewState = State#state{socket = ZlibSocket,\n\t\t\t   sock_mod = ejabberd_zlib,\n\t\t\t   xml_stream_state = NewXMLStreamState},\n    case ejabberd_zlib:recv_data(ZlibSocket, \"\") of\n\t{ok, ZlibData} ->\n\t    {reply, ok, process_data(ZlibData, NewState), ?HIBERNATE_TIMEOUT};\n\t{error, inflate_size_exceeded} ->\n\t    ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n\t    {reply, ok, NewState, ?HIBERNATE_TIMEOUT};\n\t{error, inflate_error} ->\n\t    {stop, normal, ok, NewState}\n    end;\nhandle_call(reset_stream, _From,\n\t    #state{xml_stream_state = XMLStreamState,\n\t\t   c2s_pid = C2SPid,\n\t\t   max_stanza_size = MaxStanzaSize} = State) ->\n    close_stream(XMLStreamState),\n    NewXMLStreamState = xml_stream:new(C2SPid, MaxStanzaSize),\n    Reply = ok,\n    {reply, Reply, State#state{xml_stream_state = NewXMLStreamState},\n     ?HIBERNATE_TIMEOUT};\nhandle_call({become_controller, C2SPid}, _From, State) ->\n    XMLStreamState = xml_stream:new(C2SPid, State#state.max_stanza_size),\n    NewState = State#state{c2s_pid = C2SPid,\n\t\t\t   xml_stream_state = XMLStreamState},\n    activate_socket(NewState),\n    Reply = ok,\n    {reply, Reply, NewState, ?HIBERNATE_TIMEOUT};\nhandle_call(_Request, _From, State) ->\n    Reply = ok,\n    {reply, Reply, State, ?HIBERNATE_TIMEOUT}.\n\n%%--------------------------------------------------------------------\n%% Function: handle_cast(Msg, State) -> {noreply, State} |\n%%                                      {noreply, State, Timeout} |\n%%                                      {stop, Reason, State}\n%% Description: Handling cast messages\n%%--------------------------------------------------------------------\nhandle_cast({change_shaper, Shaper}, State) ->\n    NewShaperState = shaper:new(Shaper),\n    {noreply, State#state{shaper_state = NewShaperState}, ?HIBERNATE_TIMEOUT};\nhandle_cast(close, State) ->\n    {stop, normal, State};\nhandle_cast(_Msg, State) ->\n    {noreply, State, ?HIBERNATE_TIMEOUT}.\n\n%%--------------------------------------------------------------------\n%% Function: handle_info(Info, State) -> {noreply, State} |\n%%                                       {noreply, State, Timeout} |\n%%                                       {stop, Reason, State}\n%% Description: Handling all non call/cast messages\n%%--------------------------------------------------------------------\nhandle_info({Tag, _TCPSocket, Data},\n\t    #state{socket = Socket,\n\t\t   c2s_pid = C2SPid,\n\t\t   sock_mod = SockMod} = State)\n  when (Tag == tcp) or (Tag == ssl) or (Tag == ejabberd_xml) ->\n    case SockMod of\n\tejabberd_tls ->\n\t    case ejabberd_tls:recv_data(Socket, Data) of\n\t\t{ok, TLSData} ->\n\t\t    {noreply, process_data(TLSData, State),\n\t\t     ?HIBERNATE_TIMEOUT};\n\t\t{error, _Reason} ->\n\t\t    {stop, normal, State}\n\t    end;\n\tejabberd_zlib ->\n\t    case ejabberd_zlib:recv_data(Socket, Data) of\n\t\t{ok, ZlibData} ->\n\t\t    {noreply, process_data(ZlibData, State),\n\t\t     ?HIBERNATE_TIMEOUT};\n\t\t{error, inflate_size_exceeded} ->\n\t\t    ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n\t\t    {noreply, State, ?HIBERNATE_TIMEOUT};\n\t\t{error, inflate_error} ->\n\t\t    {stop, normal, State}\n\t    end;\n\t_ ->\n\t    {noreply, process_data(Data, State), ?HIBERNATE_TIMEOUT}\n    end;\nhandle_info({Tag, _TCPSocket}, State)\n  when (Tag == tcp_closed) or (Tag == ssl_closed) ->\n    {stop, normal, State};\nhandle_info({Tag, _TCPSocket, Reason}, State)\n  when (Tag == tcp_error) or (Tag == ssl_error) ->\n    case Reason of\n\ttimeout ->\n\t    {noreply, State, ?HIBERNATE_TIMEOUT};\n\t_ ->\n\t    {stop, normal, State}\n    end;\nhandle_info({timeout, _Ref, activate}, State) ->\n    activate_socket(State),\n    {noreply, State, ?HIBERNATE_TIMEOUT};\nhandle_info(timeout, State) ->\n    proc_lib:hibernate(gen_server, enter_loop, [?MODULE, [], State]),\n    {noreply, State, ?HIBERNATE_TIMEOUT};\nhandle_info(_Info, State) ->\n    {noreply, State, ?HIBERNATE_TIMEOUT}.\n\n%%--------------------------------------------------------------------\n%% Function: terminate(Reason, State) -> void()\n%% Description: This function is called by a gen_server when it is about to\n%% terminate. It should be the opposite of Module:init/1 and do any necessary\n%% cleaning up. When it returns, the gen_server terminates with Reason.\n%% The return value is ignored.\n%%--------------------------------------------------------------------\nterminate(_Reason, #state{xml_stream_state = XMLStreamState,\n\t\t\t  c2s_pid = C2SPid} = State) ->\n    close_stream(XMLStreamState),\n    if\n\tC2SPid /= undefined ->\n\t    gen_fsm:send_event(C2SPid, closed);\n\ttrue ->\n\t    ok\n    end,\n    catch (State#state.sock_mod):close(State#state.socket),\n    ok.\n\n%%--------------------------------------------------------------------\n%% Func: code_change(OldVsn, State, Extra) -> {ok, NewState}\n%% Description: Convert process state when code is changed\n%%--------------------------------------------------------------------\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%--------------------------------------------------------------------\n%%% Internal functions\n%%--------------------------------------------------------------------\n\nactivate_socket(#state{socket = Socket,\n\t\t       sock_mod = SockMod}) ->\n    PeerName =\n\tcase SockMod of\n\t    gen_tcp ->\n\t\tinet:setopts(Socket, [{active, once}]),\n\t\tinet:peername(Socket);\n\t    _ ->\n\t\tSockMod:setopts(Socket, [{active, once}]),\n\t\tSockMod:peername(Socket)\n\tend,\n    case PeerName of\n\t{error, _Reason} ->\n\t    self() ! {tcp_closed, Socket};\n\t{ok, _} ->\n\t    ok\n    end.\n\n%% Data processing for connectors directly generating xmlel in\n%% Erlang data structure.\n%% WARNING: Shaper does not work with Erlang data structure.\nprocess_data([], State) ->\n    activate_socket(State),\n    State;\nprocess_data([Element|Els], #state{c2s_pid = C2SPid} = State)\n  when element(1, Element) == xmlel;\n       element(1, Element) == xmlstreamstart;\n      element(1, Element) == xmlstreamelement;\n       element(1, Element) == xmlstreamend ->\n    if\n\tC2SPid == undefined ->\n\t    State;\n\ttrue ->\n\t    catch gen_fsm:send_event(C2SPid, element_wrapper(Element)),\n\t    process_data(Els, State)\n    end;\n%% Data processing for connectors receivind data as string.\nprocess_data(Data,\n\t     #state{xml_stream_state = XMLStreamState,\n\t\t    shaper_state = ShaperState,\n\t\t    c2s_pid = C2SPid} = State) ->\n    ?DEBUG(\"Received XML on stream = \\\"~s\\\"\", [Data]),\n    XMLStreamState1 = xml_stream:parse(XMLStreamState, Data),\n    {NewShaperState, Pause} = shaper:update(ShaperState, size(Data)),\n    if\n\tC2SPid == undefined ->\n\t    ok;\n\tPause > 0 ->\n\t    erlang:start_timer(Pause, self(), activate);\n\ttrue ->\n\t    activate_socket(State)\n    end,\n    State#state{xml_stream_state = XMLStreamState1,\n\t\tshaper_state = NewShaperState}.\n\n%% Element coming from XML parser are wrapped inside xmlstreamelement\n%% When we receive directly xmlel tuple (from a socket module\n%% speaking directly Erlang XML), we wrap it inside the same\n%% xmlstreamelement coming from the XML parser.\nelement_wrapper(#xmlel{} = XMLElement) ->\n    {xmlstreamelement, XMLElement};\nelement_wrapper(Element) ->\n    Element.\n\nclose_stream(undefined) ->\n    ok;\nclose_stream(XMLStreamState) ->\n    xml_stream:close(XMLStreamState).\n", "%%%----------------------------------------------------------------------\n%%% File    : ejabberd_socket.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Socket with zlib and TLS support library\n%%% Created : 23 Aug 2006 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(ejabberd_socket).\n-author('alexey@process-one.net').\n\n%% API\n-export([start/4,\n\t connect/3,\n\t connect/4,\n\t starttls/2,\n\t starttls/3,\n\t compress/1,\n\t compress/3,\n\t reset_stream/1,\n\t send/2,\n\t send_xml/2,\n\t change_shaper/2,\n\t monitor/1,\n\t get_sockmod/1,\n\t get_peer_certificate/1,\n\t get_verify_result/1,\n\t close/1,\n\t sockname/1, peername/1]).\n\n-include(\"ejabberd.hrl\").\n\n-record(socket_state, {sockmod, socket, receiver}).\n\n%%====================================================================\n%% API\n%%====================================================================\n%%--------------------------------------------------------------------\n%% Function:\n%% Description:\n%%--------------------------------------------------------------------\nstart(Module, SockMod, Socket, Opts) ->\n    case Module:socket_type() of\n\txml_stream ->\n\t    MaxStanzaSize =\n\t\tcase lists:keysearch(max_stanza_size, 1, Opts) of\n\t\t    {value, {_, Size}} -> Size;\n\t\t    _ -> infinity\n\t\tend,\n\t    {ReceiverMod, Receiver, RecRef} =\n\t\tcase catch SockMod:custom_receiver(Socket) of\n\t\t    {receiver, RecMod, RecPid} ->\n\t\t\t{RecMod, RecPid, RecMod};\n\t\t    _ ->\n\t\t\tRecPid = ejabberd_receiver:start(\n\t\t\t\t   Socket, SockMod, none, MaxStanzaSize),\n\t\t\t{ejabberd_receiver, RecPid, RecPid}\n\t\tend,\n\t    SocketData = #socket_state{sockmod = SockMod,\n\t\t\t\t       socket = Socket,\n\t\t\t\t       receiver = RecRef},\n\t    case Module:start({?MODULE, SocketData}, Opts) of\n\t\t{ok, Pid} ->\n\t\t    case SockMod:controlling_process(Socket, Receiver) of\n\t\t\tok ->\n\t\t\t    ok;\n\t\t\t{error, _Reason} ->\n\t\t\t    SockMod:close(Socket)\n\t\t    end,\n\t\t    ReceiverMod:become_controller(Receiver, Pid);\n\t\t{error, _Reason} ->\n\t\t    SockMod:close(Socket),\n\t\t    case ReceiverMod of\n\t\t\tejabberd_receiver ->\n\t\t\t    ReceiverMod:close(Receiver);\n\t\t\t_ ->\n\t\t\t    ok\n\t\t    end\n\t    end;\n\tindependent ->\n\t    ok;\n\traw ->\n\t    case Module:start({SockMod, Socket}, Opts) of\n\t\t{ok, Pid} ->\n\t\t    case SockMod:controlling_process(Socket, Pid) of\n\t\t\tok ->\n\t\t\t    ok;\n\t\t\t{error, _Reason} ->\n\t\t\t    SockMod:close(Socket)\n\t\t    end;\n\t\t{error, _Reason} ->\n\t\t    SockMod:close(Socket)\n\t    end\n    end.\n\nconnect(Addr, Port, Opts) ->\n    connect(Addr, Port, Opts, infinity).\n\nconnect(Addr, Port, Opts, Timeout) ->\n    case gen_tcp:connect(Addr, Port, Opts, Timeout) of\n\t{ok, Socket} ->\n\t    Receiver = ejabberd_receiver:start(Socket, gen_tcp, none),\n\t    SocketData = #socket_state{sockmod = gen_tcp,\n\t\t\t\t       socket = Socket,\n\t\t\t\t       receiver = Receiver},\n\t    Pid = self(),\n\t    case gen_tcp:controlling_process(Socket, Receiver) of\n\t\tok ->\n\t\t    ejabberd_receiver:become_controller(Receiver, Pid),\n\t\t    {ok, SocketData};\n\t\t{error, _Reason} = Error ->\n\t\t    gen_tcp:close(Socket),\n\t\t    Error\n\t    end;\n\t{error, _Reason} = Error ->\n\t    Error\n    end.\n\nstarttls(SocketData, TLSOpts) ->\n    {ok, TLSSocket} = ejabberd_tls:tcp_to_tls(SocketData#socket_state.socket, TLSOpts),\n    ejabberd_receiver:starttls(SocketData#socket_state.receiver, TLSSocket),\n    SocketData#socket_state{socket = TLSSocket, sockmod = ejabberd_tls}.\n\nstarttls(SocketData, TLSOpts, Data) ->\n    {ok, TLSSocket} = ejabberd_tls:tcp_to_tls(SocketData#socket_state.socket, TLSOpts),\n    ejabberd_receiver:starttls(SocketData#socket_state.receiver, TLSSocket),\n    send(SocketData, Data),\n    SocketData#socket_state{socket = TLSSocket, sockmod = ejabberd_tls}.\n\ncompress(SocketData) ->\n    {ok, ZlibSocket} = ejabberd_zlib:enable_zlib(\n\t\t\t SocketData#socket_state.sockmod,\n\t\t\t SocketData#socket_state.socket),\n    ejabberd_receiver:compress(SocketData#socket_state.receiver, ZlibSocket),\n    SocketData#socket_state{socket = ZlibSocket, sockmod = ejabberd_zlib}.\n\ncompress(SocketData, InflateSizeLimit, Data) ->\n    {ok, ZlibSocket} = ejabberd_zlib:enable_zlib(\n\t\t\t SocketData#socket_state.sockmod,\n\t\t\t SocketData#socket_state.socket,\n\t\t\t InflateSizeLimit),\n    ejabberd_receiver:compress(SocketData#socket_state.receiver, ZlibSocket),\n    send(SocketData, Data),\n    SocketData#socket_state{socket = ZlibSocket, sockmod = ejabberd_zlib}.\n\nreset_stream(SocketData) when is_pid(SocketData#socket_state.receiver) ->\n    ejabberd_receiver:reset_stream(SocketData#socket_state.receiver);\nreset_stream(SocketData) when is_atom(SocketData#socket_state.receiver) ->\n    (SocketData#socket_state.receiver):reset_stream(\n      SocketData#socket_state.socket).\n\n%% sockmod=gen_tcp|ejabberd_tls|ejabberd_zlib\nsend(SocketData, Data) ->\n    case catch (SocketData#socket_state.sockmod):send(\n\t     SocketData#socket_state.socket, Data) of\n        ok -> ok;\n\t{error, timeout} ->\n\t    ?INFO_MSG(\"Timeout on ~p:send\",[SocketData#socket_state.sockmod]),\n\t    exit(normal);\n        Error ->\n\t    ?DEBUG(\"Error in ~p:send: ~p\",[SocketData#socket_state.sockmod, Error]),\n\t    exit(normal)\n    end.\n\n%% Can only be called when in c2s StateData#state.xml_socket is true\n%% This function is used for HTTP bind\n%% sockmod=ejabberd_http_poll|ejabberd_http_bind or any custom module\nsend_xml(SocketData, Data) ->\n    catch (SocketData#socket_state.sockmod):send_xml(\n\t    SocketData#socket_state.socket, Data).\n\nchange_shaper(SocketData, Shaper)\n  when is_pid(SocketData#socket_state.receiver) ->\n    ejabberd_receiver:change_shaper(SocketData#socket_state.receiver, Shaper);\nchange_shaper(SocketData, Shaper)\n  when is_atom(SocketData#socket_state.receiver) ->\n    (SocketData#socket_state.receiver):change_shaper(\n      SocketData#socket_state.socket, Shaper).\n\nmonitor(SocketData) when is_pid(SocketData#socket_state.receiver) ->\n    erlang:monitor(process, SocketData#socket_state.receiver);\nmonitor(SocketData) when is_atom(SocketData#socket_state.receiver) ->\n    (SocketData#socket_state.receiver):monitor(\n      SocketData#socket_state.socket).\n\nget_sockmod(SocketData) ->\n    SocketData#socket_state.sockmod.\n\nget_peer_certificate(SocketData) ->\n    ejabberd_tls:get_peer_certificate(SocketData#socket_state.socket).\n\nget_verify_result(SocketData) ->\n    ejabberd_tls:get_verify_result(SocketData#socket_state.socket).\n\nclose(SocketData) ->\n    ejabberd_receiver:close(SocketData#socket_state.receiver).\n\nsockname(#socket_state{sockmod = SockMod, socket = Socket}) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:sockname(Socket);\n\t_ ->\n\t    SockMod:sockname(Socket)\n    end.\n\npeername(#socket_state{sockmod = SockMod, socket = Socket}) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:peername(Socket);\n\t_ ->\n\t    SockMod:peername(Socket)\n    end.\n\n%%====================================================================\n%% Internal functions\n%%====================================================================\n", "%%%----------------------------------------------------------------------\n%%% File    : ejabberd_zlib.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Interface to zlib\n%%% Created : 19 Jan 2006 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(ejabberd_zlib).\n-author('alexey@process-one.net').\n\n-behaviour(gen_server).\n\n-export([start/0, start_link/0,\n\t enable_zlib/3, disable_zlib/1,\n\t send/2,\n\t recv/2, recv/3, recv_data/2,\n\t setopts/2,\n\t sockname/1, peername/1,\n\t get_sockmod/1,\n\t controlling_process/2,\n\t close/1]).\n\n%% Internal exports, call-back functions.\n-export([init/1,\n\t handle_call/3,\n\t handle_cast/2,\n\t handle_info/2,\n\t code_change/3,\n\t terminate/2]).\n\n-define(DEFLATE, 1).\n-define(INFLATE, 2).\n\n-record(zlibsock, {sockmod, socket, zlibport, inflate_size_limit = 0}).\n\nstart() ->\n    gen_server:start({local, ?MODULE}, ?MODULE, [], []).\n\nstart_link() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n\ninit([]) ->\n    case erl_ddll:load_driver(ejabberd:get_so_path(), ejabberd_zlib_drv) of\n\tok -> ok;\n\t{error, already_loaded} -> ok\n    end,\n    Port = open_port({spawn, ejabberd_zlib_drv}, [binary]),\n    {ok, Port}.\n\n\n%%% --------------------------------------------------------\n%%% The call-back functions.\n%%% --------------------------------------------------------\n\nhandle_call(_, _, State) ->\n    {noreply, State}.\n\nhandle_cast(_, State) ->\n    {noreply, State}.\n\nhandle_info({'EXIT', Port, Reason}, Port) ->\n    {stop, {port_died, Reason}, Port};\n\nhandle_info({'EXIT', _Pid, _Reason}, Port) ->\n    {noreply, Port};\n\nhandle_info(_, State) ->\n    {noreply, State}.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\nterminate(_Reason, Port) ->\n    Port ! {self, close},\n    ok.\n\n\nenable_zlib(SockMod, Socket, InflateSizeLimit) ->\n    case erl_ddll:load_driver(ejabberd:get_so_path(), ejabberd_zlib_drv) of\n\tok -> ok;\n\t{error, already_loaded} -> ok\n    end,\n    Port = open_port({spawn, ejabberd_zlib_drv}, [binary]),\n    {ok, #zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port,\n                   inflate_size_limit = InflateSizeLimit}}.\n\ndisable_zlib(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port}) ->\n    port_close(Port),\n    {SockMod, Socket}.\n\nrecv(Socket, Length) ->\n    recv(Socket, Length, infinity).\nrecv(#zlibsock{sockmod = SockMod, socket = Socket} = ZlibSock,\n     Length, Timeout) ->\n    case SockMod:recv(Socket, Length, Timeout) of\n\t{ok, Packet} ->\n\t    recv_data(ZlibSock, Packet);\n\t{error, _Reason} = Error ->\n\t    Error\n    end.\n\nrecv_data(#zlibsock{sockmod = SockMod, socket = Socket} = ZlibSock, Packet) ->\n    case SockMod of\n\tgen_tcp ->\n\t    recv_data2(ZlibSock, Packet);\n\t_ ->\n\t    case SockMod:recv_data(Socket, Packet) of\n\t\t{ok, Packet2} ->\n\t\t    recv_data2(ZlibSock, Packet2);\n\t\tError ->\n\t\t    Error\n\t    end\n    end.\n\nrecv_data2(ZlibSock, Packet) ->\n    case catch recv_data1(ZlibSock, Packet) of\n\t{'EXIT', Reason} ->\n\t    {error, Reason};\n\tRes ->\n\t    Res\n    end.\n\nrecv_data1(#zlibsock{zlibport = Port, inflate_size_limit = SizeLimit} = _ZlibSock, Packet) ->\n    case port_control(Port, SizeLimit bsl 2 + ?INFLATE, Packet) of\n\t<<0, In/binary>> ->\n\t    {ok, In};\n\t<<1, Error/binary>> ->\n\t    {error, erlang:binary_to_existing_atom(Error, utf8)}\n    end.\n\nsend(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port},\n     Packet) ->\n    case port_control(Port, ?DEFLATE, Packet) of\n\t<<0, Out/binary>> ->\n\t    SockMod:send(Socket, Out);\n\t<<1, Error/binary>> ->\n\t    {error, erlang:binary_to_existing_atom(Error, utf8)};\n\t_ ->\n\t    {error, deflate_error}\n    end.\n\n\nsetopts(#zlibsock{sockmod = SockMod, socket = Socket}, Opts) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:setopts(Socket, Opts);\n\t_ ->\n\t    SockMod:setopts(Socket, Opts)\n    end.\n\nsockname(#zlibsock{sockmod = SockMod, socket = Socket}) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:sockname(Socket);\n\t_ ->\n\t    SockMod:sockname(Socket)\n    end.\n\nget_sockmod(#zlibsock{sockmod = SockMod}) ->\n    SockMod.\n\npeername(#zlibsock{sockmod = SockMod, socket = Socket}) ->\n    case SockMod of\n\tgen_tcp ->\n\t    inet:peername(Socket);\n\t_ ->\n\t    SockMod:peername(Socket)\n    end.\n\ncontrolling_process(#zlibsock{sockmod = SockMod, socket = Socket}, Pid) ->\n    SockMod:controlling_process(Socket, Pid).\n\nclose(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port}) ->\n    SockMod:close(Socket),\n    port_close(Port).\n\n\n", "-module(mod_bosh_socket).\n\n-behaviour(gen_fsm).\n\n%% API\n-export([start/2,\n         start_link/2,\n         start_supervisor/0,\n         handle_request/2,\n         pause/2]).\n\n%% Private API\n-export([get_handlers/1,\n         get_pending/1,\n         get_client_acks/1,\n         set_client_acks/2,\n         get_cached_responses/1]).\n\n%% ejabberd_socket compatibility\n-export([starttls/2, starttls/3,\n         compress/1, compress/3,\n         reset_stream/1,\n         send/2,\n         send_xml/2,\n         change_shaper/2,\n         monitor/1,\n         get_sockmod/1,\n         close/1,\n         peername/1]).\n\n%% gen_fsm callbacks\n-export([init/1,\n         accumulate/2, accumulate/3,\n         normal/2, normal/3,\n         handle_event/3,\n         handle_sync_event/4,\n         handle_info/3,\n         terminate/3,\n         code_change/4]).\n\n-include(\"ejabberd.hrl\").\n-include(\"jlib.hrl\").\n-include_lib(\"exml/include/exml_stream.hrl\").\n-include(\"mod_bosh.hrl\").\n\n-define(ACCUMULATE_PERIOD, 10).\n-define(DEFAULT_HOLD, 1).\n-define(CONCURRENT_REQUESTS, 2).\n-define(DEFAULT_WAIT, 60).\n-define(DEFAULT_MAXPAUSE, 120).\n-define(DEFAULT_CLIENT_ACKS, false).\n\n-type cached_response() :: {rid(), erlang:timestamp(), #xmlel{}}.\n-type rid() :: pos_integer().\n\n-record(state, {c2s_pid :: pid(),\n                handlers = [] :: [{rid(), timer:tref(), pid()}],\n                %% Elements buffered for sending to the client.\n                pending = [] :: [xmlstreamelement()],\n                sid :: bosh_sid(),\n                wait = ?DEFAULT_WAIT,\n                hold = ?DEFAULT_HOLD,\n                rid :: rid(),\n                %% Requests deferred for later processing because\n                %% of having Rid greater than expected.\n                deferred = [] :: [{rid(), {event_type(), #xmlel{}}}],\n                client_acks = ?DEFAULT_CLIENT_ACKS :: boolean(),\n                sent = [] :: [cached_response()],\n                %% Allowed inactivity period in seconds.\n                inactivity :: pos_integer() | infinity,\n                inactivity_tref,\n                %% Max pause period in seconds.\n                maxpause :: pos_integer() | undefined,\n                %% Are acknowledgements used?\n                server_acks :: boolean(),\n                last_processed :: rid() | undefined,\n                %% Report scheduled for sending at the earliest\n                %% possible occasion.\n                report = false :: {rid(), timer:time()} | false}).\n\n%%--------------------------------------------------------------------\n%% API\n%%--------------------------------------------------------------------\n\nstart(Sid, Peer) ->\n    supervisor:start_child(?BOSH_SOCKET_SUP, [Sid, Peer]).\n\nstart_link(Sid, Peer) ->\n    gen_fsm:start_link(?MODULE, [Sid, Peer], []).\n\nstart_supervisor() ->\n    ChildId = ?BOSH_SOCKET_SUP,\n    ChildSpec =\n        {ChildId,\n         {ejabberd_tmp_sup, start_link,\n          [ChildId, ?MODULE]},\n         permanent,\n         infinity,\n         supervisor,\n         [ejabberd_tmp_sup]},\n    case supervisor:start_child(ejabberd_sup, ChildSpec) of\n        {ok, undefined} ->\n            {error, undefined};\n        {ok, Child} ->\n            {ok, Child};\n        {ok, Child, _Info} ->\n            {ok, Child};\n        {error, {already_started, Child}} ->\n            {ok, Child};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\n-spec handle_request(Pid, {EventTag, Handler, Body}) -> ok\n    when Pid :: pid(),\n         EventTag :: event_type(),\n         Handler :: pid(),\n         Body :: #xmlel{}.\nhandle_request(Pid, Request) ->\n    gen_fsm:send_all_state_event(Pid, Request).\n\n%% TODO: no handler for this call is present!\n%% No check for violating maxpause is made when calling this!\n-spec pause(Pid, Seconds) -> ok\n    when Pid :: pid(),\n         Seconds :: pos_integer().\npause(Pid, Seconds) ->\n    gen_fsm:send_all_state_event(Pid, {pause, Seconds}).\n\n%%--------------------------------------------------------------------\n%% Private API\n%%--------------------------------------------------------------------\n\nget_handlers(Pid) ->\n    gen_fsm:sync_send_all_state_event(Pid, get_handlers).\n\nget_pending(Pid) ->\n    gen_fsm:sync_send_all_state_event(Pid, get_pending).\n\n-spec get_client_acks(pid()) -> boolean().\nget_client_acks(Pid) ->\n    gen_fsm:sync_send_all_state_event(Pid, get_client_acks).\n\n-spec set_client_acks(pid(), boolean()) -> any().\nset_client_acks(Pid, Enabled) ->\n    gen_fsm:sync_send_all_state_event(Pid, {set_client_acks, Enabled}).\n\n-spec get_cached_responses(pid()) -> [cached_response()].\nget_cached_responses(Pid) ->\n    gen_fsm:sync_send_all_state_event(Pid, get_cached_responses).\n\n%%--------------------------------------------------------------------\n%% gen_fsm callbacks\n%%--------------------------------------------------------------------\n\n%%--------------------------------------------------------------------\n%% @private\n%% @spec init(Args) -> {ok, StateName, State} |\n%%                     {ok, StateName, State, Timeout} |\n%%                     ignore |\n%%                     {stop, StopReason}\n%% @end\n%%--------------------------------------------------------------------\ninit([Sid, Peer]) ->\n    BoshSocket = #bosh_socket{sid = Sid, pid = self(), peer = Peer},\n    C2SOpts = [{xml_socket, true}],\n    {ok, C2SPid} = ejabberd_c2s:start({mod_bosh_socket, BoshSocket}, C2SOpts),\n    ?DEBUG(\"mod_bosh_socket started~n\", []),\n    {ok, accumulate, #state{sid = Sid,\n                            c2s_pid = C2SPid,\n                            inactivity = mod_bosh:get_inactivity(),\n                            maxpause = get_maxpause(),\n                            server_acks = mod_bosh:get_server_acks()}}.\n\n%% TODO: maybe make maxpause runtime configurable like inactivity?\nget_maxpause() ->\n    case gen_mod:get_module_opt(?MYNAME, mod_bosh, maxpause, undefined) of\n        undefined -> ?DEFAULT_MAXPAUSE;\n        MP -> MP\n    end.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% There should be one instance of this function for each possible\n%% state name. Whenever a gen_fsm receives an event sent using\n%% gen_fsm:send_event/2, the instance of this function with the same\n%% name as the current state name StateName is called to handle\n%% the event. It is also called if a timeout occurs.\n%%\n%% @spec state_name(Event, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState}\n%% @end\n%%--------------------------------------------------------------------\n\naccumulate(acc_off, #state{pending = Pending} = S) ->\n    NS = S#state{pending = []},\n    {next_state, normal, send_or_store(Pending, NS)};\naccumulate(Event, State) ->\n    ?DEBUG(\"Unhandled event in 'accumulate' state: ~w~n\", [Event]),\n    {next_state, accumulate, State}.\n\nnormal(acc_off, #state{} = S) ->\n    {next_state, normal, S};\nnormal(Event, State) ->\n    ?DEBUG(\"Unhandled event in 'normal' state: ~w~n\", [Event]),\n    {next_state, normal, State}.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% There should be one instance of this function for each possible\n%% state name. Whenever a gen_fsm receives an event sent using\n%% gen_fsm:sync_send_event/[2,3], the instance of this function with\n%% the same name as the current state name StateName is called to\n%% handle the event.\n%%\n%% @spec state_name(Event, From, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {reply, Reply, NextStateName, NextState} |\n%%                   {reply, Reply, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState} |\n%%                   {stop, Reason, Reply, NewState}\n%% @end\n%%--------------------------------------------------------------------\naccumulate(Event, _From, State) ->\n    ?DEBUG(\"Unhandled sync event in 'accumulate' state: ~w~n\", [Event]),\n    {reply, ok, state_name, State}.\n\nnormal(Event, _From, State) ->\n    ?DEBUG(\"Unhandled sync event in 'normal' state: ~w~n\", [Event]),\n    {reply, ok, state_name, State}.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever a gen_fsm receives an event sent using\n%% gen_fsm:send_all_state_event/2, this function is called to handle\n%% the event.\n%%\n%% @spec handle_event(Event, StateName, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState}\n%% @end\n%%--------------------------------------------------------------------\n\nhandle_event({EventTag, Handler, #xmlel{} = Body}, SName, S) ->\n    NS = cancel_inactivity_timer(S),\n    Rid = binary_to_integer(exml_query:attr(Body, <<\"rid\">>)),\n    try\n        NNS = handle_stream_event({EventTag, Body, Rid}, Handler, SName, NS),\n        %% TODO: it's the event which determines the next state,\n        %%       this ought to be returned from handle_stream_event\n        case EventTag of\n            _ when EventTag == streamstart; EventTag == restart ->\n                timer:apply_after(?ACCUMULATE_PERIOD,\n                                  gen_fsm, send_event, [self(), acc_off]),\n                {next_state, accumulate, NNS};\n            _ ->\n                {next_state, SName, NNS}\n        end\n    catch\n        throw:{invalid_rid, TState} ->\n            {stop, {shutdown, invalid_rid}, TState};\n        throw:{invalid_pause, TState} ->\n            {stop, {shutdown, policy_violation}, TState}\n    end;\n\nhandle_event(Event, StateName, State) ->\n    ?DEBUG(\"Unhandled all state event: ~w~n\", [Event]),\n    {next_state, StateName, State}.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever a gen_fsm receives an event sent using\n%% gen_fsm:sync_send_all_state_event/[2,3], this function is called\n%% to handle the event.\n%%\n%% @spec handle_sync_event(Event, From, StateName, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {reply, Reply, NextStateName, NextState} |\n%%                   {reply, Reply, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState} |\n%%                   {stop, Reason, Reply, NewState}\n%% @end\n%%--------------------------------------------------------------------\nhandle_sync_event(get_handlers, _From, StateName,\n                  #state{handlers = Handlers} = S) ->\n    {reply, Handlers, StateName, S};\nhandle_sync_event(get_pending, _From, StateName,\n                  #state{pending = Pending} = S) ->\n    {reply, Pending, StateName, S};\nhandle_sync_event(get_client_acks, _From, StateName,\n                  #state{client_acks = ClientAcks} = S) ->\n    {reply, ClientAcks, StateName, S};\nhandle_sync_event({set_client_acks, ClientAcks}, _From, StateName,\n                  #state{} = S) ->\n    NS = S#state{client_acks = ClientAcks},\n    {reply, ok, StateName, NS};\nhandle_sync_event(get_cached_responses, _From, StateName,\n                  #state{sent = CachedResponses} = S) ->\n    {reply, CachedResponses, StateName, S};\nhandle_sync_event(Event, _From, StateName, State) ->\n    ?DEBUG(\"Unhandled sync all state event: ~w~n\", [Event]),\n    Reply = ok,\n    {reply, Reply, StateName, State}.\n\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% This function is called by a gen_fsm when it receives any\n%% message other than a synchronous or asynchronous event\n%% (or a system message).\n%%\n%% @spec handle_info(Info,StateName,State)->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState}\n%% @end\n%%--------------------------------------------------------------------\n\nhandle_info({send, #xmlstreamend{} = StreamEnd}, _SName,\n            #state{pending = Pending} = S) ->\n    NS = send_or_store(Pending ++ [StreamEnd], S#state{pending = []}),\n    {next_state, normal, NS};\nhandle_info({send, Data}, accumulate = SName, #state{} = S) ->\n    {next_state, SName, store([Data], S)};\nhandle_info({send, Data}, normal = SName, #state{} = S) ->\n    NS = send_or_store(Data, S),\n    {next_state, SName, NS};\nhandle_info(reset_stream, SName, #state{} = S) ->\n    %% TODO: actually reset the stream once it's stored per bosh session\n    ?DEBUG(\"Stream reset by c2s~n\", []),\n    {next_state, SName, S};\nhandle_info(close, _SName, State) ->\n    {stop, normal, State};\nhandle_info(inactivity_timeout, _SName, State) ->\n    ?DEBUG(\"terminating due to client inactivity~n\", []),\n    {stop, {shutdown, inactivity_timeout}, State};\nhandle_info({wait_timeout, {Rid, Pid}}, SName,\n            #state{handlers = Handlers} = S) ->\n    ?DEBUG(\"'wait' limit reached for ~p~n\", [Pid]),\n    %% In case some message was being handled when the timer fired\n    %% it may turn out that Pid is no longer available in Handlers.\n    case lists:keytake(Rid, 1, Handlers) of\n        false ->\n            {next_state, SName, S};\n        {value, {Rid, _, Pid}, NewHandlers} ->\n            NS = send_to_handler({Rid, Pid}, [], S),\n            {next_state, SName, NS#state{handlers = NewHandlers}}\n    end;\nhandle_info(Info, SName, State) ->\n    ?DEBUG(\"Unhandled info in '~s' state: ~w~n\", [SName, Info]),\n    {next_state, SName, State}.\n\nterminate(_Reason, StateName, #state{sid = Sid, handlers = Handlers} = S) ->\n    [Pid ! {close, Sid} || {_, _, Pid} <- lists:sort(Handlers)],\n    ?BOSH_BACKEND:delete_session(Sid),\n    catch ejabberd_c2s:stop(S#state.c2s_pid),\n    ?DEBUG(\"Closing session ~p in '~s' state. Handlers: ~p Pending: ~p~n\",\n           [Sid, StateName, Handlers, S#state.pending]).\n\ncode_change(_OldVsn, StateName, State, _Extra) ->\n    {ok, StateName, State}.\n\n%%--------------------------------------------------------------------\n%% callback implementations\n%%--------------------------------------------------------------------\n\nhandle_stream_event({EventTag, Body, Rid} = Event, Handler,\n                    SName, #state{rid = OldRid} = S) ->\n    NS = maybe_add_handler(Handler, Rid, S),\n    NNS = case {EventTag,\n                maybe_is_retransmission(Rid, OldRid, S#state.sent),\n                is_valid_rid(Rid, OldRid),\n                is_acceptable_rid(Rid, OldRid)}\n    of\n        {_, {true, CachedResponse}, _, _} ->\n            case CachedResponse of\n                none ->\n                    NS;\n                _ ->\n                    resend_cached(CachedResponse, NS)\n            end;\n        {streamstart, _, _, _} ->\n            process_acked_stream_event(Event, SName, NS);\n        {_, _, true, _} ->\n            process_acked_stream_event(Event, SName, NS);\n        {_, _, false, true} ->\n            ?DEBUG(\"storing stream event for deferred processing: ~p~n\",\n                   [{EventTag, Body}]),\n            NS#state{deferred = [Event | NS#state.deferred]};\n        {_, _, false, false} ->\n            ?ERROR_MSG(\"invalid rid ~p, expected ~p:~n~p~n\",\n                       [Rid, OldRid + 1, {EventTag, Body}]),\n            [Pid ! item_not_found\n             || {_, _, Pid} <- lists:sort(NS#state.handlers)],\n            throw({invalid_rid, NS#state{handlers = []}})\n    end,\n    return_surplus_handlers(SName, NNS).\n\n-spec maybe_is_retransmission(rid(), rid(), [cached_response()])\n    -> false | {true, none} | {true, cached_response()}.\nmaybe_is_retransmission(Rid, OldRid, Sent) ->\n    case {lists:keyfind(Rid, 1, Sent), Rid =:= OldRid} of\n        {false, false} ->\n            false;\n        {false, true} ->\n            ?INFO_MSG(\"request ~p repeated but no response found in cache ~p~n\",\n                      [Rid, Sent]),\n            {true, none};\n        {CachedResponse, _} ->\n            {true, CachedResponse}\n    end.\n\nresend_cached({_Rid, _, CachedBody}, S) ->\n    send_to_handler(CachedBody, S).\n\nprocess_acked_stream_event({EventTag, Body, Rid}, SName,\n                           #state{} = S) ->\n    MaybeBAck = exml_query:attr(Body, <<\"ack\">>),\n    {Action, Ack} = determine_report_action(MaybeBAck, S#state.client_acks,\n                                            Rid, S#state.last_processed),\n    NS = maybe_trim_cache(Ack, S),\n    case Action of\n        noreport ->\n            process_stream_event(EventTag, Body, SName, NS#state{rid = Rid});\n        report ->\n            NS2 = schedule_report(Ack, NS),\n            NS3 = process_stream_event(EventTag, Body, SName,\n                                       NS2#state{rid = Rid}),\n            maybe_send_report(NS3)\n    end.\n\ndetermine_report_action(undefined, false, _, _) ->\n    {noreport, undefined};\ndetermine_report_action(undefined, true, Rid, LastProcessed) ->\n    if\n        Rid+1 == LastProcessed ->\n            {noreport, undefined};\n        Rid+1 /= LastProcessed ->\n            ?WARNING_MSG(\"expected 'ack' attribute on ~p~n\", [Rid]),\n            {noreport, undefined}\n    end;\ndetermine_report_action(BAck, _, _, LastProcessed) ->\n    Ack = binary_to_integer(BAck),\n    case {LastProcessed, is_valid_ack(Ack, LastProcessed)} of\n        {undefined, _} ->\n            {noreport, Ack};\n        {_, true} ->\n            {noreport, Ack};\n        {_, false} ->\n            {report, Ack}\n    end.\n\nis_valid_ack(Ack, LastProcessed)\n        when Ack < LastProcessed ->\n    false;\nis_valid_ack(_, _) ->\n    true.\n\nmaybe_trim_cache(undefined, S) ->\n    S;\nmaybe_trim_cache(Ack, S) ->\n    UpToAck = fun({R,_,_}) when R =< Ack ->\n                    true;\n                 (_) ->\n                    false\n              end,\n    NewSent = lists:dropwhile(UpToAck, S#state.sent),\n    S#state{sent = NewSent}.\n\nschedule_report(Ack, #state{sent = Sent} = S) ->\n    ReportRid = Ack + 1,\n    try\n        {resp,\n         {ReportRid, TimeSent, _}} = {resp, lists:keyfind(ReportRid, 1, Sent)},\n        ElapsedTimeMillis = erlang:round(timer:now_diff(now(), TimeSent)\n                                         / 1000),\n        Report = {ReportRid, ElapsedTimeMillis},\n        case S#state.report of\n            false ->\n                S#state{report = Report};\n            OldReport when OldReport < Report ->\n                S#state{report = OldReport};\n            _ ->\n                S#state{report = Report}\n        end\n    catch\n        error:{badmatch, {resp, false}} ->\n            ?ERROR_MSG(\"no cached response for RID ~p, responses ~p~n\",\n                       [ReportRid, Sent]),\n            S\n    end.\n\nmaybe_send_report(#state{report = false} = S) ->\n    S;\nmaybe_send_report(#state{} = S) ->\n    send_or_store([], S).\n\nprocess_stream_event(pause, Body, SName, State) ->\n    Seconds = binary_to_integer(exml_query:attr(Body, <<\"pause\">>)),\n    NewState = process_pause_event(Seconds, State),\n    process_deferred_events(SName, NewState);\nprocess_stream_event(EventTag, Body, SName, #state{c2s_pid = C2SPid} = State) ->\n    {Els, NewState} = bosh_unwrap(EventTag, Body, State),\n    [forward_to_c2s(C2SPid, El) || El <- Els],\n    process_deferred_events(SName, NewState).\n\nprocess_pause_event(Seconds, #state{maxpause = MaxPause} = S)\n        when MaxPause == undefined;\n             Seconds > MaxPause ->\n    [Pid ! policy_violation || {_, _, Pid} <- S#state.handlers],\n    throw({invalid_pause, S#state{handlers = []}});\nprocess_pause_event(Seconds, State) ->\n    NS = State#state{inactivity = Seconds},\n    F = fun(_, S) ->\n            send_to_handler([], S)\n    end,\n    lists:foldl(F, NS, lists:seq(1, length(State#state.handlers))).\n\nprocess_deferred_events(SName, #state{deferred = Deferred} = S) ->\n    lists:foldl(fun(Event, State) ->\n                    ?DEBUG(\"processing deferred event: ~p~n\", [Event]),\n                    handle_stream_event(Event, none, SName, State)\n                end,\n                S#state{deferred = []},\n                lists:sort(Deferred)).\n\nis_valid_rid(Rid, OldRid) when Rid == OldRid + 1 ->\n    true;\nis_valid_rid(_, _) ->\n    false.\n\nis_acceptable_rid(Rid, OldRid)\n        when Rid > OldRid + 1,\n             Rid =< OldRid + ?CONCURRENT_REQUESTS ->\n    true;\nis_acceptable_rid(_, _) ->\n    false.\n\n%% Send data to the client if any request handler is available.\n%% Otherwise, store for sending later.\nsend_or_store(Data, State) when not is_list(Data) ->\n    send_or_store([Data], State);\nsend_or_store(Data, #state{handlers = []} = S) ->\n    store(Data, S);\nsend_or_store(Data, State) ->\n    send_to_handler(Data, State).\n\n%% send_to_handler() assumes that Handlers is not empty!\n%% Be sure that's the case if calling it.\nsend_to_handler(Data, State) ->\n    {Handler, NS} = pick_handler(State),\n    send_to_handler(Handler, Data, NS).\n\n%% Return handler and new state if a handler is available\n%% or `false` otherwise.\n-spec pick_handler(#state{}) -> {{rid(), pid()}, #state{}} | false.\npick_handler(#state{handlers = []}) ->\n    false;\npick_handler(#state{handlers = Handlers} = S) ->\n    [{Rid, TRef, Pid} | HRest] = lists:sort(Handlers),\n    %% The cancellation might fail if the timer already fired.\n    %% Don't worry, it's handled on receiving the timeout message.\n    timer:cancel(TRef),\n    {{Rid, Pid}, S#state{handlers = HRest}}.\n\nsend_to_handler({_, Pid}, #xmlel{name = <<\"body\">>} = Wrapped, State) ->\n    send_wrapped_to_handler(Pid, Wrapped, State);\nsend_to_handler({Rid, Pid}, Data, State) ->\n    {Wrapped, NS} = bosh_wrap(Data, Rid, State),\n    NS2 = cache_response({Rid, now(), Wrapped}, NS),\n    send_wrapped_to_handler(Pid, Wrapped, NS2).\n\n%% This is the most specific variant of send_to_handler()\n%% and the *only one* actually performing a send\n%% to the cowboy_loop_handler serving a HTTP request.\nsend_wrapped_to_handler(Pid, Wrapped, #state{handlers = []} = State) ->\n    Pid ! {bosh_reply, Wrapped},\n    setup_inactivity_timer(State);\nsend_wrapped_to_handler(Pid, Wrapped, State) ->\n    Pid ! {bosh_reply, Wrapped},\n    State.\n\nmaybe_ack(HandlerRid, #state{rid = Rid} = S) ->\n    if\n        Rid > HandlerRid ->\n            server_ack(S#state.server_acks, Rid);\n        Rid =< HandlerRid ->\n            []\n    end.\n\nmaybe_report(#state{report = false} = S) ->\n    {[], S};\nmaybe_report(#state{report = Report} = S) ->\n    {ReportRid, ElapsedTime} = Report,\n    NewAttrs = [{<<\"report\">>, integer_to_binary(ReportRid)},\n                {<<\"time\">>, integer_to_binary(ElapsedTime)}],\n    {NewAttrs, S#state{report = false}}.\n\ncache_response({Rid,_,_} = Response, #state{sent = Sent} = S) ->\n    NewSent = lists:keymerge(1, [Response], Sent),\n    CacheUpTo = case S#state.client_acks of\n        true ->\n            %% Acknowledgements are on - there's no limit on the number\n            %% of cached responses.\n            infinity;\n        false ->\n            %% Leave up to ?CONCURRENT_REQUESTS responses in cache.\n            ?CONCURRENT_REQUESTS\n    end,\n    S#state{sent = cache_up_to(CacheUpTo, NewSent),\n            last_processed = last_processed(Rid, S#state.last_processed)}.\n\ncache_up_to(infinity, Responses) ->\n    Responses;\ncache_up_to(N, Responses) ->\n    lists:nthtail(max(0, length(Responses) - N), Responses).\n\nlast_processed(Rid, undefined) ->\n    Rid;\nlast_processed(Rid1, Rid2) ->\n    max(Rid1, Rid2).\n\nsetup_inactivity_timer(#state{inactivity = infinity} = S) ->\n    S;\nsetup_inactivity_timer(S) ->\n    cancel_inactivity_timer(S),\n    {ok, TRef} = timer:send_after(timer:seconds(S#state.inactivity),\n                                  inactivity_timeout),\n    S#state{inactivity_tref = TRef}.\n\ncancel_inactivity_timer(#state{inactivity_tref = undefined} = S) ->\n    S;\ncancel_inactivity_timer(S) ->\n    timer:cancel(S#state.inactivity_tref),\n    S#state{inactivity_tref = undefined}.\n\n%% Store data for sending later.\nstore(Data, #state{pending = Pending} = S) ->\n    S#state{pending = Pending ++ Data}.\n\nforward_to_c2s(C2SPid, StreamElement) ->\n    gen_fsm:send_event(C2SPid, StreamElement).\n\nmaybe_add_handler(Handler, Rid, S) when is_pid(Handler) ->\n    add_handler({Rid, Handler}, S);\nmaybe_add_handler(_, _, S) ->\n    S.\n\nadd_handler({Rid, Pid}, #state{handlers = Handlers} = S) ->\n    {ok, TRef} = timer:send_after(timer:seconds(S#state.wait),\n                                  {wait_timeout, {Rid, Pid}}),\n    S#state{handlers = [{Rid, TRef, Pid} | Handlers]}.\n\n%% Keep in mind the hardcoding for hold == 1.\nreturn_surplus_handlers(accumulate, #state{handlers = []} = State) ->\n    State;\nreturn_surplus_handlers(accumulate, #state{handlers = [_]} = State) ->\n    State;\nreturn_surplus_handlers(accumulate, #state{handlers = _} = S) ->\n    NS = send_to_handler([], S),\n    return_surplus_handlers(accumulate, NS);\nreturn_surplus_handlers(normal, #state{handlers = []} = State) ->\n    State;\nreturn_surplus_handlers(normal, #state{handlers = [_], pending = []} = State) ->\n    State;\nreturn_surplus_handlers(normal, #state{pending = Pending} = S) ->\n    NS = send_or_store(Pending, S#state{pending = []}),\n    return_surplus_handlers(normal, NS).\n\n-spec bosh_unwrap(EventTag, #xmlel{}, #state{})\n    -> {[StreamEvent], #state{}}\n    when EventTag :: event_type(),\n         StreamEvent :: #xmlstreamstart{}\n                     | {xmlstreamelement, #xmlel{}}\n                     | #xmlstreamend{}.\nbosh_unwrap(StreamEvent, Body, #state{} = S)\n       when StreamEvent =:= streamstart;\n            StreamEvent =:= restart ->\n    Wait = min(get_attr(<<\"wait\">>, Body, S#state.wait), mod_bosh:get_max_wait()),\n    Hold = get_attr(<<\"hold\">>, Body, S#state.hold),\n    ClientAcks = get_client_acks(StreamEvent, Body, S#state.client_acks),\n    E = stream_start(exml_query:attr(Body, <<\"from\">>),\n                     exml_query:attr(Body, <<\"to\">>)),\n    {[E], record_set(S, [{#state.wait, Wait},\n                         {#state.hold, Hold},\n                         {#state.client_acks, ClientAcks}])};\nbosh_unwrap(streamend, Body, State) ->\n    {Els, NewState} = bosh_unwrap(normal, Body, State),\n    {Els ++ [#xmlstreamend{name = <<>>}], NewState};\nbosh_unwrap(normal, Body, #state{sid = Sid} = State) ->\n    Sid = exml_query:attr(Body, <<\"sid\">>),\n    ?NS_HTTPBIND = exml_query:attr(Body, <<\"xmlns\">>),\n    {[{xmlstreamelement, El}\n      || El <- Body#xmlel.children,\n         %% Ignore whitespace keepalives.\n         El /= #xmlcdata{content = <<\" \">>}],\n     State}.\n\nget_client_acks(restart, _, Default) ->\n    Default;\nget_client_acks(streamstart, Element, Default) ->\n    case exml_query:attr(Element, <<\"ack\">>) of\n        undefined ->\n            Default;\n        <<\"1\">> ->\n            true;\n        _ ->\n            ?INFO_MSG(\"ignoring invalid client ack on stream start~n\", []),\n            false\n    end.\n\nget_attr(Attr, Element, Default) ->\n    case exml_query:attr(Element, Attr) of\n        undefined ->\n            Default;\n        Value ->\n            binary_to_integer(Value)\n    end.\n\nstream_start(From, To) ->\n    #xmlstreamstart{name = <<\"stream:stream\">>,\n                    attrs = [{<<\"from\">>, From},\n                             {<<\"to\">>, To},\n                             {<<\"version\">>, <<\"1.0\">>},\n                             {<<\"xml:lang\">>, <<\"en\">>},\n                             {<<\"xmlns\">>, <<\"jabber:client\">>},\n                             {<<\"xmlns:stream\">>, ?NS_STREAM}]}.\n\nbosh_wrap(Elements, Rid, #state{} = S) ->\n    EventsStanzas = lists:partition(fun is_stream_event/1, Elements),\n    {{Body, Children}, NS} = case EventsStanzas of\n        {[], Stanzas} ->\n            {{bosh_body(S), Stanzas}, S};\n        {[#xmlstreamstart{} = StreamStart], Stanzas} ->\n            {{bosh_stream_start_body(StreamStart, S), Stanzas}, S};\n        {[#xmlstreamend{}], []} ->\n            %% No stanzas except stream end - OK.\n            {{bosh_stream_end_body(), []}, S};\n        {[#xmlstreamend{} = StreamEnd], Stanzas} ->\n            %% Can't wrap remaining stanzas in a stream end body.\n            %% Send Stanzas and forfeit sending stream end.\n            ?DEBUG(\"pending stanzas, can't send stream end\", []),\n            Pending = S#state.pending,\n            {{bosh_body(S), Stanzas},\n             S#state{pending = Pending ++ [StreamEnd]}}\n    end,\n    MaybeAck = maybe_ack(Rid, NS),\n    {MaybeReport, NNS} = maybe_report(NS),\n    ExtraAttrs = MaybeAck ++ MaybeReport,\n    {Body#xmlel{attrs = Body#xmlel.attrs ++ ExtraAttrs,\n                children = Children}, NNS}.\n\nis_stream_event(#xmlstreamstart{}) ->\n    true;\nis_stream_event(#xmlstreamend{}) ->\n    true;\nis_stream_event(_) ->\n    false.\n\n%% Bosh body for a session creation response.\nbosh_stream_start_body(#xmlstreamstart{attrs = Attrs}, #state{} = S) ->\n    #xmlel{name = <<\"body\">>,\n           attrs = [{<<\"wait\">>, integer_to_binary(S#state.wait)},\n                    {<<\"requests\">>,\n                     integer_to_binary(?CONCURRENT_REQUESTS)},\n                    {<<\"hold\">>, integer_to_binary(S#state.hold)},\n                    {<<\"from\">>, proplists:get_value(<<\"from\">>, Attrs)},\n                    %% TODO: how to support these with cowboy?\n                    {<<\"accept\">>, <<\"deflate,gzip\">>},\n                    {<<\"sid\">>, S#state.sid},\n                    {<<\"xmpp:restartlogic\">>, <<\"true\">>},\n                    {<<\"xmpp:version\">>, <<\"1.0\">>},\n                    {<<\"xmlns\">>, ?NS_HTTPBIND},\n                    {<<\"xmlns:xmpp\">>, <<\"urn:xmpp:xbosh\">>},\n                    {<<\"xmlns:stream\">>, ?NS_STREAM}] ++\n           inactivity(S#state.inactivity) ++\n           maxpause(S#state.maxpause) ++\n           %% TODO: shouldn't an ack be sent on restart?\n           server_ack(S#state.server_acks, S#state.rid),\n           children = []}.\n\ninactivity(I) ->\n    [{<<\"inactivity\">>, integer_to_binary(I)} || is_integer(I)].\n\nmaxpause(MP) ->\n    [{<<\"maxpause\">>, integer_to_binary(MP)} || is_integer(MP)].\n\nserver_ack(ServerAcks, Rid) ->\n    [{<<\"ack\">>, integer_to_binary(Rid)} || ServerAcks =:= true].\n\n%% Bosh body for an ordinary stream element(s).\nbosh_body(#state{} = S) ->\n    #xmlel{name = <<\"body\">>,\n           attrs = [{<<\"sid\">>, S#state.sid},\n                    {<<\"xmlns\">>, ?NS_HTTPBIND}],\n           children = []}.\n\nbosh_stream_end_body() ->\n    #xmlel{name = <<\"body\">>,\n           attrs = [{<<\"type\">>, <<\"terminate\">>},\n                    {<<\"xmlns\">>, ?NS_HTTPBIND}],\n           children = []}.\n\n%%--------------------------------------------------------------------\n%% ejabberd_socket compatibility\n%%--------------------------------------------------------------------\n\n%% Should be negotiated on HTTP level.\nstarttls(SocketData, TLSOpts) ->\n    starttls(SocketData, TLSOpts, <<>>).\n\nstarttls(_SocketData, _TLSOpts, _Data) ->\n    throw({error, negotiate_tls_on_http_level}).\n\n%% Should be negotiated on HTTP level.\ncompress(SocketData) ->\n    compress(SocketData, <<>>, 0).\n\ncompress(_SocketData, _Data, _InflateSizeLimit) ->\n    throw({error, negotiate_compression_on_http_level}).\n\n%% TODO: adjust for BOSH\nreset_stream(#bosh_socket{pid = Pid} = SocketData) ->\n    Pid ! reset_stream,\n    SocketData.\n\nsend_xml(Socket, {xmlstreamelement, XML}) ->\n    send(Socket, XML);\nsend_xml(Socket, #xmlstreamstart{} = XML) ->\n    send(Socket, XML);\nsend_xml(Socket, #xmlstreamend{} = XML) ->\n    send(Socket, XML).\n\nsend(#bosh_socket{pid = Pid}, Data) ->\n    Pid ! {send, Data},\n    ok.\n\nchange_shaper(SocketData, _Shaper) ->\n    %% TODO: we ignore shapers for now\n    SocketData.\n\nmonitor(#bosh_socket{pid = Pid}) ->\n    erlang:monitor(process, Pid).\n\nget_sockmod(_SocketData) ->\n    ?MODULE.\n\nclose(#bosh_socket{pid = Pid}) ->\n    Pid ! close.\n\n-spec peername(#bosh_socket{}) -> {ok, {Addr, Port}}\n    when Addr :: inet:ip_address(),\n         Port :: inet:port_number().\npeername(#bosh_socket{peer = Peer}) ->\n    {ok, Peer}.\n\n%%--------------------------------------------------------------------\n%% Helpers\n%%--------------------------------------------------------------------\n\n%% Set Fields of the Record to Values,\n%% when {Field, Value} <- FieldValues (in list comprehension syntax).\nrecord_set(Record, FieldValues) ->\n    F = fun({Field, Value}, Rec) ->\n            setelement(Field, Rec, Value)\n        end,\n    lists:foldl(F, Record, FieldValues).\n\n%%--------------------------------------------------------------------\n%% Tests\n%%--------------------------------------------------------------------\n\n-ifdef(TEST).\n\n-include_lib(\"eunit/include/eunit.hrl\").\n\ncache_up_to_test_() ->\n    [?_test(?assertEqual( [4,5], cache_up_to(2, [1,2,3,4,5]) ))].\n\n-endif.\n", "%%%===================================================================\n%%% @copyright (C) 2013, Erlang Solutions Ltd.\n%%% @doc Module providing support for websockets in ejabberd\n%%% @end\n%%%===================================================================\n-module(mod_websockets).\n-behaviour(gen_mod).\n-behaviour(cowboy_http_handler).\n-behaviour(cowboy_websocket_handler).\n\n%% gen_mod callbacks\n-export([start/2,\n         stop/1]).\n\n%% cowboy_http_handler callbacks\n-export([init/3,\n         handle/2,\n         terminate/3]).\n\n%% cowboy_http_websocket_handler callbacks\n-export([websocket_init/3,\n         websocket_handle/3,\n         websocket_info/3,\n         websocket_terminate/3]).\n\n%% ejabberd_socket compatibility\n-export([starttls/2, starttls/3,\n         compress/1, compress/3,\n         reset_stream/1,\n         send/2,\n         send_xml/2,\n         change_shaper/2,\n         monitor/1,\n         get_sockmod/1,\n         close/1,\n         peername/1]).\n\n%% ejabberd_listener compatibility\n-export([socket_type/0,\n         start_listener/2]).\n\n-export([stop/0]).\n\n\n-include(\"ejabberd.hrl\").\n-include_lib(\"exml/include/exml_stream.hrl\").\n\n-define(LISTENER, ?MODULE).\n\n-record(websocket, {pid :: pid(),\n                    peername :: string()}).\n-record(ws_state, {c2s_pid :: pid(),\n                   parser :: exml_stream:parser()}).\n\n%%--------------------------------------------------------------------\n%% ejabberd_listener compatibility\n%%--------------------------------------------------------------------\n-spec socket_type() -> independent.\nsocket_type() ->\n    independent.\n\n% -spec start_listener(list())\nstart_listener({Port, IP, ws}, Opts) ->\n    Dispatch = get_dispatch(Opts),\n    NumAcceptors = gen_mod:get_opt(num_acceptors, Opts, 100),\n    start_ws(NumAcceptors, Port, IP, Dispatch);\n\nstart_listener({Port, IP, wss}, Opts) ->\n    Dispatch = get_dispatch(Opts),\n    NumAcceptors = gen_mod:get_opt(num_acceptors, Opts, 100),\n    SSLPort = gen_mod:get_opt(ssl_port, Opts, Port),\n    SSLCert = gen_mod:get_opt(cert, Opts, undefined),\n    SSLKey = gen_mod:get_opt(key, Opts, undefined),\n    SSLKeyPass = gen_mod:get_opt(key_pass, Opts, undefined),\n    start_wss(NumAcceptors, SSLPort, IP, SSLCert, SSLKey, SSLKeyPass, Dispatch).\n\n%%--------------------------------------------------------------------\n%% gen_mod callbacks\n%%--------------------------------------------------------------------\n\nstart(_Host, Opts) ->\n    NumAcceptors = gen_mod:get_opt(num_acceptors, Opts, 100),\n    Port = gen_mod:get_opt(port, Opts, undefined),\n    IP = gen_mod:get_opt(ip, Opts, {0,0,0,0}),\n    SSLPort = gen_mod:get_opt(ssl_port, Opts, undefined),\n    SSLCert = gen_mod:get_opt(cert, Opts, undefined),\n    SSLKey = gen_mod:get_opt(key, Opts, undefined),\n    SSLKeyPass = gen_mod:get_opt(key_pass, Opts, undefined),\n    Dispatch = get_dispatch(Opts),\n    {ok, _} = start_ws(NumAcceptors, Port, IP, Dispatch),\n    {ok, _} = start_wss(NumAcceptors, SSLPort, IP, SSLCert, SSLKey,\n                        SSLKeyPass, Dispatch).\n\nstart_ws(_, undefined, _, _) ->\n    {ok, not_started};\nstart_ws(NumAcceptors, Port, IP, Dispatch) ->\n    case cowboy:start_http(?LISTENER, NumAcceptors,\n                                [{port, Port}, {ip, IP}],\n                                [{env, [{dispatch, Dispatch}]}]) of\n        {error, {already_started, Pid}} ->\n            {ok, Pid};\n        {ok, Pid} ->\n            {ok, Pid};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\nstart_wss(_, _, _, undefined, undefined, undefined, _) ->\n    {ok, not_started};\nstart_wss(NumAcceptors, Port, IP, Cert, Key, Pass, Dispatch) ->\n    case cowboy:start_https({?LISTENER, secure}, NumAcceptors,\n                                [\n                                    {certfile, Cert},\n                                    {keyfile, Key},\n                                    {password, Pass},\n                                    {ip, IP},\n                                    {port, Port}\n                                ],\n                                [{env, [{dispatch, Dispatch}]}]) of\n        {error, {already_started, Pid}} ->\n            {ok, Pid};\n        {ok, Pid} ->\n            {ok, Pid};\n        {error, Reason} ->\n            {error, Reason}\n    end.\n\nstop() ->\n    stop(any).\n\nstop(_Host) ->\n    cowboy:stop_listener({?LISTENER, secure}),\n    cowboy:stop_listener(?LISTENER),\n    ok.\n\n%%--------------------------------------------------------------------\n%% cowboy_http_handler callbacks\n%%--------------------------------------------------------------------\n\ninit(Transport, Req, Opts) ->\n    ?DEBUG(\"cowboy init: ~p~n\", [{Transport, Req, Opts}]),\n    {upgrade, protocol, cowboy_websocket}.\n\nhandle(Req, State) ->\n        {ok, Req, State}.\n\nterminate(_Reason, _Req, _State) ->\n        ok.\n\n%%--------------------------------------------------------------------\n%% cowboy_http_websocket_handler callbacks\n%%--------------------------------------------------------------------\n\n% Called for every new websocket connection.\nwebsocket_init(Transport, Req, Opts) ->\n    ?DEBUG(\"websocket_init: ~p~n\", [{Transport, Req, Opts}]),\n    {Peer, NewReq} = cowboy_req:peer(Req),\n    NewReq2 = cowboy_req:set_resp_header(\"Sec-WebSocket-Protocol\", \"xmpp\", NewReq),\n    SocketData = #websocket{pid=self(),\n                            peername = Peer},\n    case ejabberd_c2s:start({?MODULE, SocketData}, Opts) of\n        {ok, Pid} ->\n            ?DEBUG(\"started c2s via websockets: ~p\", [Pid]),\n            {ok, Parser} = exml_stream:new_parser(),\n            State = #ws_state{c2s_pid = Pid,\n                              parser = Parser},\n            {ok, NewReq2, State};\n        {error, Reason} ->\n            ?WARNING_MSG(\"c2s start failed: ~p\", [Reason]),\n            {shutdown, NewReq2}\n    end.\n\n\n% Called when a text message arrives.\nwebsocket_handle({text, Msg}, Req, State) ->\n    ?INFO_MSG(\"Received: ~p\", [Msg]),\n    {ok, NewState} = handle_text(Msg, State),\n    {ok, Req, NewState};\n\nwebsocket_handle({binary, Msg}, Req, State) ->\n    ?INFO_MSG(\"Received binary: ~p\", [Msg]),\n    {ok, NewState} = handle_text(Msg, State),\n    {ok, Req, NewState};\n\n% With this callback we can handle other kind of\n% messages, like binary.\nwebsocket_handle(Any, Req, State) ->\n    ?INFO_MSG(\"Received non-text: ~p\", [Any]),\n    {ok, Req, State}.\n\n% Other messages from the system are handled here.\nwebsocket_info({send, Text}, Req, State) ->\n    {reply, {text, Text}, Req, State};\nwebsocket_info(reset_stream, Req, #ws_state{parser = Parser} = State) ->\n    {ok, NewParser} = exml_stream:reset_parser(Parser),\n    {ok, Req, State#ws_state{parser = NewParser}};\nwebsocket_info(stop, Req, #ws_state{parser = Parser} = State) ->\n    exml_stream:free_parser(Parser),\n    {shutdown, Req, State};\nwebsocket_info(Info, Req, State) ->\n    ?INFO_MSG(\"unknown info: ~p\", [Info]),\n    {ok, Req, State}.\n\nwebsocket_terminate(_Reason, _Req, _State) ->\n    ok.\n\n%%--------------------------------------------------------------------\n%% Callbacks implementation\n%%--------------------------------------------------------------------\n\nhandle_text(Text, #ws_state{c2s_pid = C2S, parser = Parser} = State) ->\n    {ok, NewParser, Elements} = exml_stream:parse(Parser, Text),\n    [send_to_c2s(C2S, Elem) || Elem <- Elements],\n    {ok, State#ws_state{parser = NewParser}}.\n\nsend_to_c2s(C2S, #xmlel{} = Element) ->\n    send_to_c2s(C2S, {xmlstreamelement, Element});\nsend_to_c2s(C2S, StreamElement) ->\n    gen_fsm:send_event(C2S, StreamElement).\n\n%%--------------------------------------------------------------------\n%% ejabberd_socket compatibility\n%%--------------------------------------------------------------------\n\nstarttls(SocketData, TLSOpts) ->\n    starttls(SocketData, TLSOpts, <<>>).\n\nstarttls(_SocketData, _TLSOpts, _Data) ->\n    throw({error, tls_not_allowed_on_websockets}).\n\ncompress(SocketData) ->\n    compress(SocketData, <<>>, 0).\n\ncompress(_SocketData, _Data, _InflateSizeLimit) ->\n    throw({error, compression_not_allowed_on_websockets}).\n\nreset_stream(#websocket{pid = Pid} = SocketData) ->\n    Pid ! reset_stream,\n    SocketData.\n\nsend_xml(SocketData, {xmlstreamraw, Text}) ->\n    send(SocketData, Text);\nsend_xml(SocketData, {xmlstreamelement, XML}) ->\n    send_xml(SocketData, XML);\nsend_xml(SocketData, XML) ->\n    Text = exml:to_iolist(XML),\n    send(SocketData, Text).\n\nsend(#websocket{pid = Pid}, Data) ->\n    Pid ! {send, Data},\n    ok.\n\nchange_shaper(SocketData, _Shaper) ->\n    SocketData. %% TODO: we ignore shapers for now\n\nmonitor(#websocket{pid = Pid}) ->\n    erlang:monitor(process, Pid).\n\nget_sockmod(_SocketData) ->\n    ?MODULE.\n\nclose(#websocket{pid = Pid}) ->\n    Pid ! close.\n\npeername(#websocket{peername = PeerName}) ->\n    {ok, PeerName}.\n\n%%--------------------------------------------------------------------\n%% Helpers\n%%--------------------------------------------------------------------\n\nget_dispatch(Opts) ->\n    WSHost = gen_mod:get_opt(host, Opts, '_'), %% default to any\n    WSPrefix = gen_mod:get_opt(prefix, Opts, \"/ws-xmpp\"),\n    cowboy_router:compile([{WSHost, [{WSPrefix, ?MODULE, Opts}] }]).\n", "%%%----------------------------------------------------------------------\n%%% File    : xml_stream.erl\n%%% Author  : Alexey Shchepin <alexey@process-one.net>\n%%% Purpose : Parse XML streams\n%%% Created : 17 Nov 2002 by Alexey Shchepin <alexey@process-one.net>\n%%%\n%%%\n%%% ejabberd, Copyright (C) 2002-2011   ProcessOne\n%%%\n%%% This program is free software; you can redistribute it and/or\n%%% modify it under the terms of the GNU General Public License as\n%%% published by the Free Software Foundation; either version 2 of the\n%%% License, or (at your option) any later version.\n%%%\n%%% This program is distributed in the hope that it will be useful,\n%%% but WITHOUT ANY WARRANTY; without even the implied warranty of\n%%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n%%% General Public License for more details.\n%%%\n%%% You should have received a copy of the GNU General Public License\n%%% along with this program; if not, write to the Free Software\n%%% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n%%% 02111-1307 USA\n%%%\n%%%----------------------------------------------------------------------\n\n-module(xml_stream).\n-author('alexey@process-one.net').\n\n-export([new/2,\n\t parse/2,\n\t close/1,\n\t parse_element/1]).\n\n-define(XML_START, 0).\n-define(XML_END,   1).\n-define(XML_CDATA, 2).\n-define(XML_ERROR, 3).\n\n-define(PARSE_COMMAND, 0).\n-define(PARSE_FINAL_COMMAND, 1).\n\n-include(\"jlib.hrl\").\n-record(xml_stream_state, {callback_pid, port, stack, size, maxsize}).\n\nprocess_data(CallbackPid, Stack, Data) ->\n    case Data of\n\t{?XML_START, {Name, Attrs}} ->\n\t    if\n\t\tStack == [] ->\n\t\t    catch gen_fsm:send_event(CallbackPid,\n\t\t\t\t\t     {xmlstreamstart, Name, Attrs});\n\t\ttrue ->\n\t\t    ok\n\t    end,\n\t    [#xmlel{name = Name, attrs = Attrs} | Stack];\n\t{?XML_END, EndName} ->\n\t    case Stack of\n\t\t[XE = #xmlel{children = Els} | Tail] ->\n\t\t    NewEl = XE#xmlel{children = lists:reverse(Els)},\n\t\t    case Tail of\n\t\t\t[] ->\n\t\t\t    catch gen_fsm:send_event(CallbackPid,\n\t\t\t\t\t\t     {xmlstreamend, EndName}),\n\t\t\t    Tail;\n\t\t\t[_] ->\n\t\t\t    catch gen_fsm:send_event(CallbackPid,\n\t\t\t\t\t\t     {xmlstreamelement, NewEl}),\n\t\t\t    Tail;\n\t\t\t[XE1 = #xmlel{children = Els1} | Tail1] ->\n\t\t\t    [XE1#xmlel{children = [NewEl | Els1]} |\n\t\t\t   Tail1]\n\t\t    end\n\t    end;\n\t{?XML_CDATA, CData} ->\n\t    case Stack of\n\t\t[El] ->\n\t\t    [El];\n\t\t%% Merge CDATA nodes if they are contiguous\n\t\t%% This does not change the semantic: the split in\n\t\t%% several CDATA nodes depends on the TCP/IP packet\n\t\t%% fragmentation\n\t\t[XE2 = #xmlel{children = [#xmlcdata{content = PreviousCData}\n\t\t                          | Els]} | Tail] ->\n\t\t    [XE2#xmlel{children = [#xmlcdata{content = list_to_binary([PreviousCData,\n\t\t                                                               CData])}\n                                           | Els]} | Tail];\n\t\t%% No previous CDATA\n\t\t[XE3 = #xmlel{children = Els} | Tail] ->\n\t\t    [XE3#xmlel{children = [#xmlcdata{content = CData} | Els]} |\n\t\t              Tail];\n\t\t[] -> []\n\t    end;\n\t{?XML_ERROR, Err} ->\n\t    catch gen_fsm:send_event(CallbackPid, {xmlstreamerror, Err})\n    end.\n\nnew(CallbackPid, MaxSize) ->\n    Port = open_port({spawn, expat_erl}, [binary]),\n    #xml_stream_state{callback_pid = CallbackPid,\n\t\t      port = Port,\n\t\t      stack = [],\n\t\t      size = 0,\n\t\t      maxsize = MaxSize}.\n\n\nparse(#xml_stream_state{callback_pid = CallbackPid,\n\t\t\tport = Port,\n\t\t\tstack = Stack,\n\t\t\tsize = Size,\n\t\t\tmaxsize = MaxSize} = State, Str) ->\n    StrSize = if\n\t\t  is_list(Str) -> length(Str);\n\t\t  is_binary(Str) -> size(Str)\n\t      end,\n    Res = port_control(Port, ?PARSE_COMMAND, Str),\n    {NewStack, NewSize} =\n\tlists:foldl(\n\t  fun(Data, {St, Sz}) ->\n\t\t  NewSt = process_data(CallbackPid, St, Data),\n\t\t  case NewSt of\n\t\t      [_] -> {NewSt, 0};\n\t\t      _ -> {NewSt, Sz}\n\t\t  end\n\t  end, {Stack, Size + StrSize}, binary_to_term(Res)),\n    if\n\tNewSize > MaxSize ->\n\t    catch gen_fsm:send_event(CallbackPid,\n\t\t\t\t     {xmlstreamerror, <<\"XML stanza is too big\">>});\n\ttrue ->\n\t    ok\n    end,\n    State#xml_stream_state{stack = NewStack, size = NewSize}.\n\nclose(#xml_stream_state{port = Port}) ->\n    port_close(Port).\n\n\nparse_element(Str) ->\n    Port = open_port({spawn, expat_erl}, [binary]),\n    Res = port_control(Port, ?PARSE_FINAL_COMMAND, Str),\n    port_close(Port),\n    process_element_events(binary_to_term(Res)).\n\nprocess_element_events(Events) ->\n    process_element_events(Events, []).\n\nprocess_element_events([], _Stack) ->\n    {error, parse_error};\nprocess_element_events([Event | Events], Stack) ->\n    case Event of\n\t{?XML_START, {Name, Attrs}} ->\n\t    process_element_events(\n\t      Events, [#xmlel{name = Name, attrs = Attrs} | Stack]);\n\t{?XML_END, _EndName} ->\n\t    case Stack of\n\t\t[XE = #xmlel{children = Els} | Tail] ->\n\t\t    NewEl = XE#xmlel{children = lists:reverse(Els)},\n\t\t    case Tail of\n\t\t\t[] ->\n\t\t\t    if\n\t\t\t\tEvents == [] ->\n\t\t\t\t    NewEl;\n\t\t\t\ttrue ->\n\t\t\t\t    {error, parse_error}\n\t\t\t    end;\n\t\t\t[XE1 = #xmlel{children = Els1} | Tail1] ->\n\t\t\t    process_element_events(\n\t\t\t      Events,\n\t\t\t      [XE1#xmlel{children = [NewEl | Els1]} |\n\t\t\t     Tail1])\n\t\t    end\n\t    end;\n\t{?XML_CDATA, CData} ->\n\t    case Stack of\n\t\t[XE2 = #xmlel{children = Els} | Tail] ->\n\t\t    process_element_events(\n\t\t      Events,\n\t\t      [XE2#xmlel{children = [#xmlcdata{content = CData}\n\t\t                             | Els]} |\n     Tail]);\n\t\t[] ->\n\t\t    process_element_events(Events, [])\n\t    end;\n\t{?XML_ERROR, Err} ->\n\t    {error, Err}\n    end.\n\n", "%%%\n%%%               ejabberd configuration file\n%%%\n%%%'\n\n%%% The parameters used in this configuration file are explained in more detail\n%%% in the ejabberd Installation and Operation Guide.\n%%% Please consult the Guide in case of doubts, it is included with\n%%% your copy of ejabberd, and is also available online at\n%%% http://www.process-one.net/en/ejabberd/docs/\n\n%%% This configuration file contains Erlang terms.\n%%% In case you want to understand the syntax, here are the concepts:\n%%%\n%%%  - The character to comment a line is %\n%%%\n%%%  - Each term ends in a dot, for example:\n%%%      override_global.\n%%%\n%%%  - A tuple has a fixed definition, its elements are\n%%%    enclosed in {}, and separated with commas:\n%%%      {loglevel, 4}.\n%%%\n%%%  - A list can have as many elements as you want,\n%%%    and is enclosed in [], for example:\n%%%      [http_poll, web_admin, tls]\n%%%\n%%%    Pay attention that list elements are delimited with commas,\n%%%    but no comma is allowed after the last list element. This will\n%%%    give a syntax error unlike in more lenient languages (e.g. Python).\n%%%\n%%%  - A keyword of ejabberd is a word in lowercase.\n%%%    Strings are enclosed in \"\" and can contain spaces, dots, ...\n%%%      {language, \"en\"}.\n%%%      {ldap_rootdn, \"dc=example,dc=com\"}.\n%%%\n%%%  - This term includes a tuple, a keyword, a list, and two strings:\n%%%      {hosts, [\"jabber.example.net\", \"im.example.com\"]}.\n%%%\n%%%  - This config is preprocessed during release generation by a tool which\n%%%    interprets double curly braces as substitution markers, so avoid this\n%%%    syntax in this file (though it's valid Erlang).\n%%%\n%%%    So this is OK (though arguably looks quite ugly):\n%%%      { {s2s_addr, \"example-host.net\"}, {127,0,0,1} }.\n%%%\n%%%    And I can't give an example of what's not OK exactly because\n%%%    of this rule.\n%%%\n\n\n%%%.   =======================\n%%%'   OVERRIDE STORED OPTIONS\n\n%%\n%% Override the old values stored in the database.\n%%\n\n%%\n%% Override global options (shared by all ejabberd nodes in a cluster).\n%%\n%%override_global.\n\n%%\n%% Override local options (specific for this particular ejabberd node).\n%%\n%%override_local.\n\n%%\n%% Remove the Access Control Lists before new ones are added.\n%%\n%%override_acls.\n\n\n%%%.   =========\n%%%'   DEBUGGING\n\n%%\n%% loglevel: Verbosity of log files generated by ejabberd.\n%% 0: No ejabberd log at all (not recommended)\n%% 1: Critical\n%% 2: Error\n%% 3: Warning\n%% 4: Info\n%% 5: Debug\n%%\n{loglevel, 3}.\n\n%%\n%% alarms: an optional alarm handler, subscribed to system events\n%% long_gc: minimum GC time in ms for long_gc alarm\n%% large_heap: minimum process heap size for large_heap alarm\n%% handlers: a list of alarm handlers\n%%   - alarms_basic_handler:  logs alarms and stores a brief alarm summary\n%%   - alarms_folsom_handler: stores alarm details in folsom metrics\n%%\n%% Example:\n%% {alarms,\n%%  [{long_gc, 10000},\n%%   {large_heap, 1000000},\n%%   {handlers, [alarms_basic_handler,\n%%               alarms_folsom_handler]}]\n%% }.\n\n%%\n%% watchdog_admins: Only useful for developers: if an ejabberd process\n%% consumes a lot of memory, send live notifications to these XMPP\n%% accounts. Requires alarms (see above).\n%%\n%%{watchdog_admins, [\"bob@example.com\"]}.\n\n\n%%%.   ================\n%%%'   SERVED HOSTNAMES\n\n%%\n%% hosts: Domains served by ejabberd.\n%% You can define one or several, for example:\n%% {hosts, [\"example.net\", \"example.com\", \"example.org\"]}.\n%%\n{hosts, {{hosts}} }.\n\n%%\n%% route_subdomains: Delegate subdomains to other XMPP servers.\n%% For example, if this ejabberd serves example.org and you want\n%% to allow communication with an XMPP server called im.example.org.\n%%\n%%{route_subdomains, s2s}.\n\n\n%%%.   ===============\n%%%'   LISTENING PORTS\n\n%%\n%% listen: The ports ejabberd will listen on, which service each is handled\n%% by and what options to start it with.\n%%\n{listen,\n [\n\n  { {{cowboy_port}}, ejabberd_cowboy, [\n      {num_acceptors, 10},\n      {max_connections, 1024},\n      %% Uncomment for HTTPS\n      %{cert, \"priv/server.crt\"},\n      %{key, \"priv/server.key\"},\n      %{key_pass, \"\"},\n      {modules, [\n          %% Modules used here should also be listed in the MODULES section.\n          {\"_\", \"/http-bind\", mod_bosh},\n          {\"_\", \"/ws-xmpp\", mod_websockets},\n          {\"localhost\", \"/metrics\", mod_metrics}\n      ]}\n  ]},\n\n  { {{ejabberd_c2s_port}}, ejabberd_c2s, [\n\n\t\t\t%%\n\t\t\t%% If TLS is compiled in and you installed a SSL\n\t\t\t%% certificate, specify the full path to the\n\t\t\t%% file and uncomment this line:\n\t\t\t%%\n                        {{tls_config}}\n                        {{zlib}}\n\t\t\t{access, c2s},\n\t\t\t{shaper, c2s_shaper},\n\t\t\t{max_stanza_size, 65536}\n\t\t       ]},\n\n  {{secondary_c2s}}\n\n  %%\n  %% To enable the old SSL connection method on port 5223:\n  %%\n  %%{5223, ejabberd_c2s, [\n  %%\t\t\t{access, c2s},\n  %%\t\t\t{shaper, c2s_shaper},\n  %%\t\t\t{certfile, \"/path/to/ssl.pem\"}, tls,\n  %%\t\t\t{max_stanza_size, 65536}\n  %%\t\t       ]},\n\n  { {{ejabberd_s2s_in_port}}, ejabberd_s2s_in, [\n\t\t\t   {shaper, s2s_shaper},\n\t\t\t   {max_stanza_size, 131072}\n\t\t\t  ]}\n\n  %%\n  %% ejabberd_service: Interact with external components (transports, ...)\n  %%\n  %%{8888, ejabberd_service, [\n  %%\t\t\t    {access, all},\n  %%\t\t\t    {shaper_rule, fast},\n  %%\t\t\t    {ip, {127, 0, 0, 1}},\n  %%\t\t\t    {hosts, [\"icq.example.org\", \"sms.example.org\"],\n  %%\t\t\t     [{password, \"secret\"}]\n  %%\t\t\t    }\n  %%\t\t\t   ]},\n\n  %%\n  %% ejabberd_stun: Handles STUN Binding requests\n  %%\n  %%{ {3478, udp}, ejabberd_stun, []}\n\n ]}.\n\n%%\n%% s2s_use_starttls: Enable STARTTLS + Dialback for S2S connections.\n%% Allowed values are: false optional required required_trusted\n%% You must specify a certificate file.\n%%\n%%{s2s_use_starttls, optional}.\n\n%%\n%% s2s_certfile: Specify a certificate file.\n%%\n%%{s2s_certfile, \"/path/to/ssl.pem\"}.\n\n%%\n%% domain_certfile: Specify a different certificate for each served hostname.\n%%\n%%{domain_certfile, \"example.org\", \"/path/to/example_org.pem\"}.\n%%{domain_certfile, \"example.com\", \"/path/to/example_com.pem\"}.\n\n%%\n%% S2S whitelist or blacklist\n%%\n%% Default s2s policy for undefined hosts.\n%%\n{s2s_default_policy, {{s2s_default_policy}} }.\n\n%%\n%% Allow or deny communication with specific servers.\n%%\n%%{ {s2s_host, \"goodhost.org\"}, allow}.\n%%{ {s2s_host, \"badhost.org\"}, deny}.\n\n{outgoing_s2s_port, {{outgoing_s2s_port}} }.\n\n%%\n%% IP addresses predefined for specific hosts to skip DNS lookups.\n%% Ports defined here take precedence over outgoing_s2s_port.\n%% Examples:\n%%\n%% { {s2s_addr, \"example-host.net\"}, {127,0,0,1} }.\n%% { {s2s_addr, \"example-host.net\"}, { {127,0,0,1}, 5269 } }.\n{{s2s_addr}}\n\n%%\n%% Outgoing S2S options\n%%\n%% Preferred address families (which to try first) and connect timeout\n%% in milliseconds.\n%%\n%%{outgoing_s2s_options, [ipv4, ipv6], 10000}.\n\n%%%.   ==============\n%%%'   SESSION BACKEND\n\n%%{sm_backend, {mnesia, []}}.\n\n%%{sm_backend, {redis, [{pool_size, 3}, {worker_config, [{host, \"localhost\"}, {port, 6379}]}]}}.\n{sm_backend, {{sm_backend}} }.\n\n\n%%%.   ==============\n%%%'   AUTHENTICATION\n\n%%\n%% auth_method: Method used to authenticate the users.\n%% The default method is the internal.\n%% If you want to use a different method,\n%% comment this line and enable the correct ones.\n%%\n{auth_method, {{auth_method}} }.\n\n%%\n%% Authentication using external script\n%% Make sure the script is executable by ejabberd.\n%%\n%%{auth_method, external}.\n{{ext_auth_script}}\n\n%%\n%% Authentication using ODBC\n%% Remember to setup a database in the next section.\n%%\n%%{auth_method, odbc}.\n\n%%\n%% Authentication using PAM\n%%\n%%{auth_method, pam}.\n%%{pam_service, \"pamservicename\"}.\n\n%%\n%% Authentication using LDAP\n%%\n%%{auth_method, ldap}.\n%%\n{{auth_ldap}}\n%% List of LDAP servers:\n%%{ldap_servers, [\"localhost\"]}.\n%%\n%% Encryption of connection to LDAP servers:\n%%{ldap_encrypt, none}.\n%%{ldap_encrypt, tls}.\n%%\n%% Port to connect to on LDAP servers:\n%%{ldap_port, 389}.\n%%{ldap_port, 636}.\n%%\n%% LDAP manager:\n%%{ldap_rootdn, \"dc=example,dc=com\"}.\n%%\n%% Password of LDAP manager:\n%%{ldap_password, \"******\"}.\n%%\n%% Search base of LDAP directory:\n%%{ldap_base, \"dc=example,dc=com\"}.\n%%\n%% LDAP attribute that holds user ID:\n%%{ldap_uids, [{\"mail\", \"%u@mail.example.org\"}]}.\n%%\n%% LDAP filter:\n%%{ldap_filter, \"(objectClass=shadowAccount)\"}.\n\n%%\n%% Anonymous login support:\n%%   auth_method: anonymous\n%%   anonymous_protocol: sasl_anon | login_anon | both\n%%   allow_multiple_connections: true | false\n%%\n%%{host_config, \"public.example.org\", [{auth_method, anonymous},\n%%                                     {allow_multiple_connections, false},\n%%                                     {anonymous_protocol, sasl_anon}]}.\n%%\n%% To use both anonymous and internal authentication:\n%%\n%%{host_config, \"public.example.org\", [{auth_method, [internal, anonymous]}]}.\n{{host_config}}\n\n%%%.   ==============\n%%%'   DATABASE SETUP\n\n%% ejabberd by default uses the internal Mnesia database,\n%% so you do not necessarily need this section.\n%% This section provides configuration examples in case\n%% you want to use other database backends.\n%% Please consult the ejabberd Guide for details on database creation.\n\n%%\n%% MySQL server:\n%%\n{{odbc_server}}\n%%\n%% If you want to specify the port:\n%%{odbc_server, {mysql, \"server\", 1234, \"database\", \"username\", \"password\"}}.\n\n%%\n%% PostgreSQL server:\n%%\n%%{odbc_server, {pgsql, \"server\", \"database\", \"username\", \"password\"}}.\n%%\n%% If you want to specify the port:\n%%{odbc_server, {pgsql, \"server\", 1234, \"database\", \"username\", \"password\"}}.\n%%\n%% If you use PostgreSQL, have a large database, and need a\n%% faster but inexact replacement for \"select count(*) from users\"\n%%\n%%{pgsql_users_number_estimate, true}.\n\n%%\n%% ODBC compatible or MSSQL server:\n%%\n%%{odbc_server, \"DSN=ejabberd;UID=ejabberd;PWD=ejabberd\"}.\n\n%%\n%% Number of connections to open to the database for each virtual host\n%%\n%%{odbc_pool_size, 10}.\n\n%%\n%% Interval to make a dummy SQL request to keep the connections to the\n%% database alive. Specify in seconds: for example 28800 means 8 hours\n%%\n%%{odbc_keepalive_interval, undefined}.\n\n\n%%%.   ===============\n%%%'   TRAFFIC SHAPERS\n\n%%\n%% The \"normal\" shaper limits traffic speed to 1000 B/s\n%%\n{shaper, normal, {maxrate, 1000}}.\n\n%%\n%% The \"fast\" shaper limits traffic speed to 50000 B/s\n%%\n{shaper, fast, {maxrate, 50000}}.\n\n%%\n%% This option specifies the maximum number of elements in the queue\n%% of the FSM. Refer to the documentation for details.\n%%\n{max_fsm_queue, 1000}.\n\n\n%%%.   ====================\n%%%'   ACCESS CONTROL LISTS\n\n%%\n%% The 'admin' ACL grants administrative privileges to XMPP accounts.\n%% You can put here as many accounts as you want.\n%%\n%{acl, admin, {user, \"alice\", \"localhost\"}}.\n%{acl, admin, {user, \"a\", \"localhost\"}}.\n\n%%\n%% Blocked users\n%%\n%%{acl, blocked, {user, \"baduser\", \"example.org\"}}.\n%%{acl, blocked, {user, \"test\"}}.\n\n%%\n%% Local users: don't modify this line.\n%%\n{acl, local, {user_regexp, \"\"}}.\n\n%%\n%% More examples of ACLs\n%%\n%%{acl, jabberorg, {server, \"jabber.org\"}}.\n%%{acl, aleksey, {user, \"aleksey\", \"jabber.ru\"}}.\n%%{acl, test, {user_regexp, \"^test\"}}.\n%%{acl, test, {user_glob, \"test*\"}}.\n\n%%\n%% Define specific ACLs in a virtual host.\n%%\n%%{host_config, \"localhost\",\n%% [\n%%  {acl, admin, {user, \"bob-local\", \"localhost\"}}\n%% ]\n%%}.\n\n\n%%%.   ============\n%%%'   ACCESS RULES\n\n%% Maximum number of simultaneous sessions allowed for a single user:\n{access, max_user_sessions, [{10, all}]}.\n\n%% Maximum number of offline messages that users can have:\n{access, max_user_offline_messages, [{5000, admin}, {100, all}]}.\n\n%% This rule allows access only for local users:\n{access, local, [{allow, local}]}.\n\n%% Only non-blocked users can use c2s connections:\n{access, c2s, [{deny, blocked},\n\t       {allow, all}]}.\n\n%% For C2S connections, all users except admins use the \"normal\" shaper\n{access, c2s_shaper, [{none, admin},\n\t\t      {normal, all}]}.\n\n%% All S2S connections use the \"fast\" shaper\n{access, s2s_shaper, [{fast, all}]}.\n\n%% Admins of this server are also admins of the MUC service:\n{access, muc_admin, [{allow, admin}]}.\n\n%% Only accounts of the local ejabberd server can create rooms:\n{access, muc_create, [{allow, local}]}.\n\n%% All users are allowed to use the MUC service:\n{access, muc, [{allow, all}]}.\n\n%% In-band registration allows registration of any possible username.\n%% To disable in-band registration, replace 'allow' with 'deny'.\n{access, register, [{allow, all}]}.\n\n%% By default the frequency of account registrations from the same IP\n%% is limited to 1 account every 10 minutes. To disable, specify: infinity\n{registration_timeout, infinity}.\n\n%% Default settings for MAM.\n%% To set non-standard value, replace 'default' with 'allow' or 'deny'.\n%% Only user can access his/her archive by default.\n%% An online user can read room's archive by default.\n%% Only an owner can change settings and purge messages by default.\n%% Empty list (i.e. `[]`) means `[{deny, all}]`.\n{access, mam_set_prefs, [{default, all}]}.\n{access, mam_get_prefs, [{default, all}]}.\n{access, mam_lookup_messages, [{default, all}]}.\n{access, mam_purge_single_message, [{default, all}]}.\n{access, mam_purge_multiple_messages, [{default, all}]}.\n\n%% 1 command of the specified type per second.\n{shaper, mam_shaper, {maxrate, 1}}.\n%% This shaper is primeraly for Mnesia overload protection during stress testing.\n%% The limit is 1000 operations of each type per second.\n{shaper, mam_global_shaper, {maxrate, 1000}}.\n\n{access, mam_set_prefs_shaper, [{mam_shaper, all}]}.\n{access, mam_get_prefs_shaper, [{mam_shaper, all}]}.\n{access, mam_lookup_messages_shaper, [{mam_shaper, all}]}.\n{access, mam_purge_single_message_shaper, [{mam_shaper, all}]}.\n{access, mam_purge_multiple_messages_shaper, [{mam_shaper, all}]}.\n\n{access, mam_set_prefs_global_shaper, [{mam_global_shaper, all}]}.\n{access, mam_get_prefs_global_shaper, [{mam_global_shaper, all}]}.\n{access, mam_lookup_messages_global_shaper, [{mam_global_shaper, all}]}.\n{access, mam_purge_single_message_global_shaper, [{mam_global_shaper, all}]}.\n{access, mam_purge_multiple_messages_global_shaper, [{mam_global_shaper, all}]}.\n\n\n%%\n%% Define specific Access Rules in a virtual host.\n%%\n%%{host_config, \"localhost\",\n%% [\n%%  {access, c2s, [{allow, admin}, {deny, all}]},\n%%  {access, register, [{deny, all}]}\n%% ]\n%%}.\n\n\n%%%.   ================\n%%%'   DEFAULT LANGUAGE\n\n%%\n%% language: Default language used for server messages.\n%%\n{language, \"en\"}.\n\n%%\n%% Set a different default language in a virtual host.\n%%\n%%{host_config, \"localhost\",\n%% [{language, \"ru\"}]\n%%}.\n\n\n%%%.   =======\n%%%'   MODULES\n\n%%\n%% Modules enabled in all ejabberd virtual hosts.\n%% For list of possible modules options, check documentation.\n%% If module comes in two versions, like mod_last and mod_last_odbc,\n%% use only one of them.\n%%\n{modules,\n [\n  %{mod_admin_extra, [{submods, [node, accounts, sessions, vcard,\n  %                              roster, last, private, stanza, stats]}]},\n  {mod_adhoc, []},\n  {mod_disco, []},\n  {{mod_last}}\n  {mod_muc, [\n             {host, \"muc.@HOST@\"},\n             {access, muc},\n             {access_create, muc_create}\n            ]},\n  {mod_muc_log,\n        [\n        {outdir, \"/tmp/muclogs\"},\n        {access_log, muc}\n        ]},\n  {{mod_offline}}\n  {{mod_privacy}}\n  {{mod_private}}\n% {mod_private, [{backend, mnesia}]},\n% {mod_private, [{backend, odbc}]},\n  {mod_register, [\n\t\t  %%\n\t\t  %% Set the minimum informational entropy for passwords.\n\t\t  %%\n\t\t  %%{password_strength, 32},\n\n\t\t  %%\n\t\t  %% After successful registration, the user receives\n\t\t  %% a message with this subject and body.\n\t\t  %%\n\t\t  {welcome_message, {\"\"}},\n\n\t\t  %%\n\t\t  %% When a user registers, send a notification to\n\t\t  %% these XMPP accounts.\n\t\t  %%\n\t\t  %%{registration_watchers, [\"admin1@example.org\"]},\n\n\t\t  %%\n\t\t  %% Only clients in the server machine can register accounts\n\t\t  %%\n\t\t  {ip_access, [{allow, \"127.0.0.0/8\"},\n\t\t\t       {deny, \"0.0.0.0/0\"}]},\n\n\t\t  %%\n\t\t  %% Local c2s or remote s2s users cannot register accounts\n\t\t  %%\n\t\t  %%{access_from, deny},\n\n\t\t  {access, register}\n\t\t ]},\n  {{mod_roster}}\n  {mod_sic, []},\n  {{mod_vcard}}\n  {mod_bosh, []},\n  {mod_websockets, []},\n  {mod_metrics, []}\n\n  %% \n  %% Message Archive Management (MAM) for registered users.\n  %%\n\n  %% A module for storing preferences in RDBMS (used by default).\n  %% Enable for private message archives.\n% {mod_mam_odbc_prefs, [pm]},\n  %% Enable for multiuser message archives.\n% {mod_mam_odbc_prefs, [muc]},\n  %% Enable for both private and multiuser message archives.\n% {mod_mam_odbc_prefs, [pm, muc]},\n\n  %% A module for storing preferences in Mnesia (recommended).\n  %% This module will be called each time, as a message is routed.\n  %% That is why, Mnesia is better for this job.\n% {mod_mam_mnesia_prefs, [pm, muc]},\n\n  %% Mnesia back-end with optimized writes and dirty synchronious writes.\n% {mod_mam_mnesia_dirty_prefs, [pm, muc]},\n\n  %% A back-end for storing messages.\n  %% Synchronious writer (used by default).\n  %% This writer is easy to debug, but writing performance is low.\n% {mod_mam_odbc_arch, [pm]},\n\n  %% Enable the module with a custom writer.\n% {mod_mam_odbc_arch, [no_writer, pm]},\n\n  %% Asynchronious writer for RDBMS (recommended).\n  %% Messages will be grouped and inserted all at once.\n% {mod_mam_odbc_async_writer, [pm]},\n\n  %% A pool of asynchronious writers (recommended).\n  %% Messages will be grouped together based on archive id.\n% {mod_mam_odbc_async_pool_writer, [pm]},\n\n  %% A module for converting an archive id to an integer.\n  %% Extract information using ODBC.\n% {mod_mam_odbc_user, [pm, muc]},\n\n  %% Cache information about users (recommended).\n  %% Requires mod_mam_odbc_user or alternative.\n% {mod_mam_cache_user, [pm, muc]},\n\n  %% Enable MAM.\n% {mod_mam, []},\n\n\n  %%\n  %% Message Archive Management (MAM) for multi-user chats (MUC).\n  %% Enable XEP-0313 for \"muc.@HOST@\".\n  %%\n\n  %% A back-end for storing messages (default for MUC).\n  %% Modules mod_mam_muc_* are optimized for MUC.\n  %%\n  %% Synchronious writer (used by default for MUC).\n  %% This module is easy to debug, but performance is low.\n% {mod_mam_muc_odbc_arch, []},\n% {mod_mam_muc_odbc_arch, [no_writer]},\n\n  %% Asynchronious writer for RDBMS (recommended for MUC).\n  %% Messages will be grouped and inserted all at once.\n% {mod_mam_muc_odbc_async_writer, []},\n% {mod_mam_muc_odbc_async_pool_writer, []},\n\n  %% Load mod_mam_odbc_user too.\n\n  %% Enable MAM for MUC\n% {mod_mam_muc, [{host, \"muc.@HOST@\"}]}\n\n\n  %%\n  %% MAM configuration examples\n  %%\n\n  %% Only MUC, no user-defined preferences, good performance.\n% {mod_mam_odbc_user, [muc]},\n% {mod_mam_cache_user, [muc]},\n% {mod_mam_muc_odbc_arch, [no_writer]},\n% {mod_mam_muc_odbc_async_pool_writer, []},\n% {mod_mam_muc, [{host, \"muc.@HOST@\"}]}\n\n  %% Only archives for c2c messages, good performance.\n% {mod_mam_odbc_user, [pm]},\n% {mod_mam_cache_user, [pm]},\n% {mod_mam_mnesia_dirty_prefs, [pm]},\n% {mod_mam_odbc_arch, [pm, no_writer]},\n% {mod_mam_odbc_async_pool_writer, [pm]},\n% {mod_mam, []}\n\n  %% Basic configuration for c2c messages, bad performance, easy to debug.\n% {mod_mam_odbc_user, [pm]},\n% {mod_mam_odbc_prefs, [pm]},\n% {mod_mam_odbc_arch, [pm]},\n% {mod_mam, []}\n\n ]}.\n\n{{module_host_config}}\n%%\n%% Enable modules with custom options in a specific virtual host\n%%\n%%{host_config, \"localhost\",\n%% [{ {add, modules},\n%%   [\n%%    {mod_some_module, []}\n%%   ]\n%%  }\n%% ]}.\n\n%%%.\n%%%'\n\n%%% $Id$\n\n%%% Local Variables:\n%%% mode: erlang\n%%% End:\n%%% vim: set filetype=erlang tabstop=8 foldmarker=%%%',%%%. foldmethod=marker:\n%%%.\n", "{hosts, \"[\\\"localhost\\\",\n          \\\"anonymous.localhost\\\",\n          \\\"localhost.bis\\\"\n         ]\"}.\n{host_config,\n\"{host_config, \\\"anonymous.localhost\\\", [{auth_method, anonymous},\n                                        {allow_multiple_connections, true},\n                                        {anonymous_protocol, both}]}.\" }.\n{outgoing_s2s_port, 5279}.\n{odbc_server, \"\"}.\n{auth_ldap,\"\"}.\n{s2s_addr, \"{ {s2s_addr, \\\"localhost2\\\"}, {127,0,0,1} }.\"}.\n{s2s_default_policy, allow}.\n{node_name, \"ejabberd@localhost\"}.\n{ejabberd_c2s_port, 5222}.\n{secondary_c2s,\n    \"{ 5223, ejabberd_c2s, [\n    {zlib, 4096},\n    {access, c2s},\n        {shaper, c2s_shaper},\n        {max_stanza_size, 65536}\n    ]},\"}.\n{ejabberd_s2s_in_port, 5269}.\n{mod_last, \"{mod_last, []},\"}.\n{mod_offline, \"{mod_offline, [{access_max_user_messages, max_user_offline_messages}]},\"}.\n{mod_privacy, \"{mod_privacy, []},\"}.\n{mod_private, \"{mod_private, []},\"}.\n{mod_roster, \"{mod_roster, []},\"}.\n{mod_vcard, \"{mod_vcard, [ {allow_return_all, true},\\n\"\n                \"{search_all_hosts, true}\\n\"\n                \"%{matches, 1},\\n\"\n                \"%{search, true},\\n\"\n                \"%{host, directory.@HOST@}\\n\"\n                \"]},\"}.\n{cowboy_port, 5280}.\n{tls_config, \"{certfile, \\\"/tmp/server.pem\\\"}, starttls,\"}.\n{ {s2s_addr, \"localhost2\"}, {127,0,0,1} }.\n{ {s2s_addr, \"micha\u0142\"}, {127,0,0,1} }.\n{module_host_config, \"\"}.\n", "{hosts, \"[\\\"localhost\\\"]\"}.\n{host_config, \"\"}.\n{odbc_server, \"%% {odbc_server, {mysql, \\\"localhost\\\", 3306, \\\"database\\\", \\\"username\\\", \\\"password\\\"}}.\"}.\n{auth_ldap, \"\"}.\n{s2s_addr, \"%% { {s2s_addr, \\\"example-host.net\\\"}, { {127,0,0,1}, 5269 } }.\"}.\n{s2s_default_policy, deny}.\n{outgoing_s2s_port, 5269}.\n{node_name, \"mongooseim@localhost\"}.\n{ejabberd_c2s_port, 5222}.\n{ejabberd_s2s_in_port, 5269}.\n{cowboy_port, 5280}.\n{mod_last, \"{mod_last, []},\"}.\n{mod_offline, \"{mod_offline, [{access_max_user_messages, max_user_offline_messages}]},\"}.\n{mod_privacy, \"{mod_privacy, []},\"}.\n{mod_private, \"{mod_private, []},\"}.\n{mod_roster, \"{mod_roster, []},\"}.\n{mod_vcard, \"{mod_vcard, [ {allow_return_all, true},\\n\"\n                \"{search_all_hosts, true}\\n\"\n                \"%{matches, 1},\\n\"\n                \"%{search, true},\\n\"\n                \"%{host, directory.@HOST@}\\n\"\n                \"]},\"}.\n{mod_snmp,   \"%% CAUTION: serious performance problems have been found in the snmp_rt module\\n\"\n           \"  %% which is part of the ejabberd SNMP implementation. It's advised not to use\\n\"\n           \"  %% SNMP statistics until a fix is released or at least use it with option\\n\"\n           \"  %%     {rt_enabled, false}\\n\"\n           \"  %% as shown below. Some counters will always return 0 because of that.\\n\"\n           \"  %%, {mod_snmp, [{modules, []}, {rt_enabled, false}]}\"}.\n{sm_backend, \"{mnesia, []}\"}.\n{auth_method, \"internal\"}.\n{ext_auth_script, \"%%{extauth_program, \\\"/path/to/authentication/script\\\"}.\"}.\n{tls_config, \"%%{certfile, \\\"/path/to/ssl.pem\\\"}, starttls,\"}.\n{wss_config, \"%%,{cert, \\\"priv/server.crt\\\"}, {key, \\\"priv/server.key\\\"}, {key_pass, \\\"\\\"}\"}. %% PEM format\n{zlib, \"%%{zlib, 10000},\"}. %% Second element of a tuple is inflated data size limit; 0 for no limit\n"], "filenames": ["apps/ejabberd/c_src/ejabberd_zlib_drv.c", "apps/ejabberd/src/ejabberd_c2s.erl", "apps/ejabberd/src/ejabberd_receiver.erl", "apps/ejabberd/src/ejabberd_socket.erl", "apps/ejabberd/src/ejabberd_zlib.erl", "apps/ejabberd/src/mod_bosh_socket.erl", "apps/ejabberd/src/mod_websockets.erl", "apps/ejabberd/src/xml_stream.erl", "rel/files/ejabberd.cfg", "rel/reltool_vars/node1_vars.config", "rel/vars.config"], "buggy_code_start_loc": [112, 83, 58, 37, 33, 21, 28, 129, 168, 15, 34], "buggy_code_end_loc": [185, 2222, 225, 159, 156, 829, 235, 130, 168, 15, 35], "fixing_code_start_loc": [112, 83, 59, 37, 33, 21, 28, 129, 169, 16, 34], "fixing_code_end_loc": [192, 2224, 233, 160, 159, 829, 235, 130, 171, 23, 35], "type": "CWE-264", "message": "Erlang Solutions MongooseIM through 1.3.1 rev. 2 does not properly restrict the processing of compressed XML elements, which allows remote attackers to cause a denial of service (resource consumption) via a crafted XMPP stream, aka an \"xmppbomb\" attack.", "other": {"cve": {"id": "CVE-2014-2829", "sourceIdentifier": "cve@mitre.org", "published": "2014-04-11T01:55:07.083", "lastModified": "2014-04-11T19:45:00.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Erlang Solutions MongooseIM through 1.3.1 rev. 2 does not properly restrict the processing of compressed XML elements, which allows remote attackers to cause a denial of service (resource consumption) via a crafted XMPP stream, aka an \"xmppbomb\" attack."}, {"lang": "es", "value": "Erlang Solutions MongooseIM hasta 1.3.1 rev. 2 no restringe debidamente el procesamiento de elementos XML comprimidos, lo que permite a atacantes remotos causar una denegaci\u00f3n de servicio (consumo de recursos) a trav\u00e9s de una cadena XMPP manipulada, tambi\u00e9n conocido como un ataque \"xmppbomb\"."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:erlang-solutions:mongooseim:*:rev2:*:*:*:*:*:*", "versionEndIncluding": "1.3.1", "matchCriteriaId": "16330245-BAF7-4529-B2B8-7079400FB2E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:erlang-solutions:mongooseim:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "4175D09B-10A7-400D-B950-32770C74017F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:erlang-solutions:mongooseim:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "9D1161D9-4822-4764-9F71-1789A9D1E22D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:erlang-solutions:mongooseim:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "57B82892-14C7-4CBC-AA0D-F0200421F26D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:erlang-solutions:mongooseim:1.3.1:-:*:*:*:*:*:*", "matchCriteriaId": "74AF913A-9DB4-4850-A2AA-81D3EDBC8CA9"}]}]}], "references": [{"url": "http://xmpp.org/resources/security-notices/uncontrolled-resource-consumption-with-highly-compressed-xmpp-stanzas/", "source": "cve@mitre.org"}, {"url": "https://github.com/esl/MongooseIM/commit/586d96cc12ef218243a3466354b4d208b5472a6c", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/esl/MongooseIM/commit/586d96cc12ef218243a3466354b4d208b5472a6c"}}