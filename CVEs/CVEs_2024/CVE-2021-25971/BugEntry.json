{"buggy_code": ["class CamaleonCmsLocalUploader < CamaleonCmsUploader\n  def after_initialize\n    @root_folder = @args[:root_folder] || @current_site.upload_directory\n\n    FileUtils.mkdir_p(@root_folder)\n  end\n\n  def setup_private_folder\n    @root_folder = Rails.root.join(self.class::PRIVATE_DIRECTORY).to_s\n\n    FileUtils.mkdir_p(@root_folder) unless Dir.exist?(@root_folder)\n  end\n\n  def browser_files(prefix = '/', objects = {})\n    path = File.join(@root_folder, prefix)\n\n    Dir.entries(path).each do |f_name|\n      next if f_name == '..' || f_name == '.' || f_name == 'thumb'\n\n      obj = file_parse(File.join(path, f_name).sub(@root_folder, '').cama_fix_media_key)\n      cache_item(obj)\n\n      if obj['is_folder']\n        browser_files(File.join(prefix, obj['name']))\n      end\n    end\n  end\n\n  def fetch_file(file_name)\n    if file_exists?(file_name)\n      file_name\n    else\n      raise ActionController::RoutingError, 'File not found'\n    end\n  end\n\n  def file_parse(key)\n    file_path = File.join(@root_folder, key)\n    url_path, is_dir = file_path.sub(Rails.root.join('public').to_s, ''), File.directory?(file_path)\n    res = {\n        \"name\" => File.basename(key),\n        \"folder_path\" => File.dirname(key),\n        \"url\" => is_dir ? '' : (is_private_uploader? ? url_path.sub(\"#{@root_folder}/\", '') : File.join(@current_site.decorate.the_url(as_path: true, locale: false, skip_relative_url_root: true), url_path)),\n        \"is_folder\" => is_dir,\n        \"file_size\" => is_dir ? 0 : File.size(file_path).round(2),\n        \"thumb\" => '',\n        'file_type' => self.class.get_file_format(file_path),\n        'dimension' => ''\n    }.with_indifferent_access\n    res['key'] = File.join(res['folder_path'], res['name'])\n    res[\"thumb\"] = (is_private_uploader? ? '/admin/media/download_private_file?file=' + version_path(key).slice(1..-1) : version_path(res['url'])) if res['file_type'] == 'image' && File.extname(file_path).downcase != '.gif'\n    if res['file_type'] == 'image'\n      res[\"thumb\"].sub! '.svg', '.jpg'\n      im = MiniMagick::Image.open(file_path)\n      res['dimension'] = \"#{im[:width]}x#{im[:height]}\"\n    end\n    res\n  end\n\n  # save a file into local folder\n  def add_file(uploaded_io_or_file_path, key, args = {})\n    args, res = {same_name: false, is_thumb: false}.merge(args), nil\n    key = search_new_key(key) unless args[:same_name]\n\n    if @instance # private hook to upload files by different way, add file data into result_data\n      _args={result_data: nil, file: uploaded_io_or_file_path, key: key, args: args, klass: self}; @instance.hooks_run('uploader_local_before_upload', _args)\n      return _args[:result_data] if _args[:result_data].present?\n    end\n\n    add_folder(File.dirname(key)) if File.dirname(key).present?\n    upload_io = uploaded_io_or_file_path.is_a?(String) ? File.open(uploaded_io_or_file_path) : uploaded_io_or_file_path\n    File.open(File.join(@root_folder, key), 'wb'){|file|       file.write(upload_io.read) }\n    res = cache_item(file_parse(key)) unless args[:is_thumb]\n    res\n  end\n\n  # create a new folder into local directory\n  def add_folder(key)\n    d, is_new_folder = File.join(@root_folder, key).to_s, false\n    unless Dir.exist?(d)\n      FileUtils.mkdir_p(d)\n      is_new_folder = true if File.basename(d) != 'thumb'\n    end\n    f = file_parse(key)\n    cache_item(f) if is_new_folder\n    f\n  end\n\n  # remove an existent folder\n  def delete_folder(key)\n    folder = File.join(@root_folder, key)\n    FileUtils.rm_rf(folder) if Dir.exist? folder\n    get_media_collection.find_by_key(key).take.destroy\n  end\n\n  # remove an existent file\n  def delete_file(key)\n    file = File.join(@root_folder, key)\n    FileUtils.rm(file) if File.exist? file\n    @instance.hooks_run('after_delete', key)\n    get_media_collection.find_by_key(key).take.destroy\n  end\n\n  # convert a real file path into file key\n  def parse_key(file_path)\n    file_path.sub(@root_folder, '').cama_fix_media_key\n  end\nend\n"], "fixing_code": ["class CamaleonCmsLocalUploader < CamaleonCmsUploader\n  def after_initialize\n    @root_folder = @args[:root_folder] || @current_site.upload_directory\n\n    FileUtils.mkdir_p(@root_folder)\n  end\n\n  def setup_private_folder\n    @root_folder = Rails.root.join(self.class::PRIVATE_DIRECTORY).to_s\n\n    FileUtils.mkdir_p(@root_folder) unless Dir.exist?(@root_folder)\n  end\n\n  def browser_files(prefix = '/', objects = {})\n    path = File.join(@root_folder, prefix)\n\n    Dir.entries(path).each do |f_name|\n      next if f_name == '..' || f_name == '.' || f_name == 'thumb'\n\n      obj = file_parse(File.join(path, f_name).sub(@root_folder, '').cama_fix_media_key)\n      cache_item(obj)\n\n      if obj['is_folder']\n        browser_files(File.join(prefix, obj['name']))\n      end\n    end\n  end\n\n  def fetch_file(file_name)\n    if file_exists?(file_name)\n      file_name\n    else\n      raise ActionController::RoutingError, 'File not found'\n    end\n  end\n\n  def file_parse(key)\n    file_path = File.join(@root_folder, key)\n    url_path, is_dir = file_path.sub(Rails.root.join('public').to_s, ''), File.directory?(file_path)\n    res = {\n        \"name\" => File.basename(key),\n        \"folder_path\" => File.dirname(key),\n        \"url\" => is_dir ? '' : (is_private_uploader? ? url_path.sub(\"#{@root_folder}/\", '') : File.join(@current_site.decorate.the_url(as_path: true, locale: false, skip_relative_url_root: true), url_path)),\n        \"is_folder\" => is_dir,\n        \"file_size\" => is_dir ? 0 : File.size(file_path).round(2),\n        \"thumb\" => '',\n        'file_type' => self.class.get_file_format(file_path),\n        'dimension' => ''\n    }.with_indifferent_access\n    res['key'] = File.join(res['folder_path'], res['name'])\n    res[\"thumb\"] = (is_private_uploader? ? '/admin/media/download_private_file?file=' + version_path(key).slice(1..-1) : version_path(res['url'])) if res['file_type'] == 'image' && File.extname(file_path).downcase != '.gif'\n    if res['file_type'] == 'image'\n      res[\"thumb\"].sub! '.svg', '.jpg'\n      im = MiniMagick::Image.open(file_path)\n      res['dimension'] = \"#{im[:width]}x#{im[:height]}\" rescue \"0x0\" # Malformed SVGs raise an exception here.\n    end\n    res\n  end\n\n  # save a file into local folder\n  def add_file(uploaded_io_or_file_path, key, args = {})\n    args, res = {same_name: false, is_thumb: false}.merge(args), nil\n    key = search_new_key(key) unless args[:same_name]\n\n    if @instance # private hook to upload files by different way, add file data into result_data\n      _args={result_data: nil, file: uploaded_io_or_file_path, key: key, args: args, klass: self}; @instance.hooks_run('uploader_local_before_upload', _args)\n      return _args[:result_data] if _args[:result_data].present?\n    end\n\n    add_folder(File.dirname(key)) if File.dirname(key).present?\n    upload_io = uploaded_io_or_file_path.is_a?(String) ? File.open(uploaded_io_or_file_path) : uploaded_io_or_file_path\n    File.open(File.join(@root_folder, key), 'wb'){|file|       file.write(upload_io.read) }\n    res = cache_item(file_parse(key)) unless args[:is_thumb]\n    res\n  end\n\n  # create a new folder into local directory\n  def add_folder(key)\n    d, is_new_folder = File.join(@root_folder, key).to_s, false\n    unless Dir.exist?(d)\n      FileUtils.mkdir_p(d)\n      is_new_folder = true if File.basename(d) != 'thumb'\n    end\n    f = file_parse(key)\n    cache_item(f) if is_new_folder\n    f\n  end\n\n  # remove an existent folder\n  def delete_folder(key)\n    folder = File.join(@root_folder, key)\n    FileUtils.rm_rf(folder) if Dir.exist? folder\n    get_media_collection.find_by_key(key).take.destroy\n  end\n\n  # remove an existent file\n  def delete_file(key)\n    file = File.join(@root_folder, key)\n    FileUtils.rm(file) if File.exist? file\n    @instance.hooks_run('after_delete', key)\n    get_media_collection.find_by_key(key).take.destroy\n  end\n\n  # convert a real file path into file key\n  def parse_key(file_path)\n    file_path.sub(@root_folder, '').cama_fix_media_key\n  end\nend\n"], "filenames": ["app/uploaders/camaleon_cms_local_uploader.rb"], "buggy_code_start_loc": [55], "buggy_code_end_loc": [56], "fixing_code_start_loc": [55], "fixing_code_end_loc": [56], "type": "NVD-CWE-Other", "message": "In Camaleon CMS, versions 2.0.1 to 2.6.0 are vulnerable to an Uncaught Exception. The app's media upload feature crashes permanently when an attacker with a low privileged access uploads a specially crafted .svg file", "other": {"cve": {"id": "CVE-2021-25971", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-10-20T12:15:07.650", "lastModified": "2021-11-30T20:21:49.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Camaleon CMS, versions 2.0.1 to 2.6.0 are vulnerable to an Uncaught Exception. The app's media upload feature crashes permanently when an attacker with a low privileged access uploads a specially crafted .svg file"}, {"lang": "es", "value": "En Camaleon CMS, versiones 2.0.1 a 2.6.0 son vulnerables a un ataque de tipo Uncaught Exception. La funci\u00f3n media upload de la aplicaci\u00f3n es bloqueada permanentemente cuando un atacante con un acceso de bajo privilegio carga un archivo .svg especialmente dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-248"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tuzitio:camaleon_cms:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.1", "versionEndIncluding": "2.6.0", "matchCriteriaId": "EC9AA85B-8092-4C72-9402-C48CFE64F59F"}]}]}], "references": [{"url": "https://github.com/owen2345/camaleon-cms/commit/ab89584ab32b98a0af3d711e3f508a1d048147d2", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25971", "source": "vulnerabilitylab@mend.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/owen2345/camaleon-cms/commit/ab89584ab32b98a0af3d711e3f508a1d048147d2"}}