{"buggy_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/kernels/data/experimental/threadpool_dataset_op.h\"\n\n#include <memory>\n\n#include \"tensorflow/core/data/dataset_utils.h\"\n#include \"tensorflow/core/framework/dataset.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/lib/core/refcount.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/platform/cpu_info.h\"\n#include \"tensorflow/core/platform/stringprintf.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\nnamespace data {\nnamespace experimental {\n\n/* static */ constexpr const char* const\n    MaxIntraOpParallelismDatasetOp::kDatasetType;\n/* static */ constexpr const char* const\n    MaxIntraOpParallelismDatasetOp::kDatasetOp;\n/* static */ constexpr const char* const\n    PrivateThreadPoolDatasetOp::kDatasetType;\n/* static */ constexpr const char* const PrivateThreadPoolDatasetOp::kDatasetOp;\n\nclass ThreadPoolResource : public ResourceBase {\n public:\n  ThreadPoolResource(Env* env, const ThreadOptions& thread_options,\n                     const string& name, int num_threads, bool low_latency_hint,\n                     int max_intra_op_parallelism)\n      : thread_pool_(env, thread_options, name, num_threads, low_latency_hint),\n        max_intra_op_parallelism_(max_intra_op_parallelism) {}\n\n  // Schedules fn() for execution in the pool of threads.\n  void Schedule(std::function<void()> fn) {\n    if (max_intra_op_parallelism_ < 0) {\n      thread_pool_.Schedule(std::move(fn));\n    } else {\n      thread_pool_.Schedule(std::bind(\n          [this](std::function<void()> bound_fn) {\n            // TODO(mrry): Consider moving this thread-local configuration to\n            // the threads themselves.\n            ScopedPerThreadMaxParallelism scope(max_intra_op_parallelism_);\n            bound_fn();\n          },\n          std::move(fn)));\n    }\n  }\n\n  int32 NumThreads() { return thread_pool_.NumThreads(); }\n\n  string DebugString() const override { return \"ThreadPoolResource\"; }\n\n private:\n  thread::ThreadPool thread_pool_;\n  const int max_intra_op_parallelism_;\n};\n\n// Creates a handle to a ThreadPool resource. Note that we don't use\n// ResourceOpKernel here because the ThreadPoolResource constructor requires\n// access to `OpKernelContext::env()`, which isn't provided by\n// `ResourceOpKernel<T>::CreateResource()`.\nclass ThreadPoolHandleOp : public OpKernel {\n public:\n  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES(\n        ctx, num_threads_ > 0,\n        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n  }\n\n  // The resource is deleted from the resource manager only when it is private\n  // to kernel. Ideally the resource should be deleted when it is no longer held\n  // by anyone, but it would break backward compatibility.\n  ~ThreadPoolHandleOp() override {\n    if (cinfo_.resource_is_private_to_kernel()) {\n      if (!cinfo_.resource_manager()\n               ->Delete<ThreadPoolResource>(cinfo_.container(), cinfo_.name())\n               .ok()) {\n        // Do nothing; the resource can have been deleted by session resets.\n      }\n    }\n  }\n\n  void Compute(OpKernelContext* ctx) override TF_LOCKS_EXCLUDED(mu_) {\n    mutex_lock l(mu_);\n    if (!initialized_) {\n      ResourceMgr* mgr = ctx->resource_manager();\n      OP_REQUIRES_OK(ctx, cinfo_.Init(mgr, def()));\n      ThreadPoolResource* resource;\n      OP_REQUIRES_OK(ctx, mgr->LookupOrCreate<ThreadPoolResource>(\n                              cinfo_.container(), cinfo_.name(), &resource,\n                              [this, ctx](ThreadPoolResource** ret)\n                                  TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n                                    *ret = new ThreadPoolResource(\n                                        ctx->env(), {}, display_name_,\n                                        num_threads_,\n                                        /*low_latency_hint=*/false,\n                                        max_intra_op_parallelism_);\n                                    return Status::OK();\n                                  }));\n      initialized_ = true;\n    }\n    OP_REQUIRES_OK(ctx, MakeResourceHandleToOutput(\n                            ctx, 0, cinfo_.container(), cinfo_.name(),\n                            TypeIndex::Make<ThreadPoolResource>()));\n  }\n\n private:\n  mutex mu_;\n  ContainerInfo cinfo_ TF_GUARDED_BY(mu_);\n  bool initialized_ TF_GUARDED_BY(mu_) = false;\n  string display_name_;\n  int num_threads_;\n  int max_intra_op_parallelism_;\n};\n\nclass ThreadPoolDatasetOp : public UnaryDatasetOpKernel {\n public:\n  explicit ThreadPoolDatasetOp(OpKernelConstruction* ctx)\n      : UnaryDatasetOpKernel(ctx) {}\n\n  void MakeDataset(OpKernelContext* ctx, DatasetBase* input,\n                   DatasetBase** output) override {\n    core::RefCountPtr<ThreadPoolResource> threadpool_resource;\n    OP_REQUIRES_OK(ctx, LookupResource(ctx, HandleFromInput(ctx, 1),\n                                       &threadpool_resource));\n    *output = new Dataset(ctx, input, ctx->input(1), threadpool_resource.get());\n  }\n\n private:\n  class Dataset : public DatasetBase {\n   public:\n    Dataset(OpKernelContext* ctx, const DatasetBase* input,\n            const Tensor& resource_handle, ThreadPoolResource* threadpool)\n        : DatasetBase(DatasetContext(ctx)),\n          input_(input),\n          resource_handle_(resource_handle),\n          threadpool_(threadpool) {\n      input_->Ref();\n      threadpool_->Ref();\n    }\n\n    ~Dataset() override {\n      input_->Unref();\n      threadpool_->Unref();\n    }\n\n    std::unique_ptr<IteratorBase> MakeIteratorInternal(\n        const string& prefix) const override {\n      return absl::make_unique<Iterator>(\n          Iterator::Params{this, strings::StrCat(prefix, \"::ThreadPool\")});\n    }\n\n    const DataTypeVector& output_dtypes() const override {\n      return input_->output_dtypes();\n    }\n    const std::vector<PartialTensorShape>& output_shapes() const override {\n      return input_->output_shapes();\n    }\n\n    string DebugString() const override {\n      return \"ThreadPoolDatasetOp::Dataset\";\n    }\n\n    int64_t CardinalityInternal() const override {\n      return input_->Cardinality();\n    }\n\n    Status InputDatasets(\n        std::vector<const DatasetBase*>* inputs) const override {\n      inputs->push_back(input_);\n      return Status::OK();\n    }\n\n    Status CheckExternalState() const override {\n      return input_->CheckExternalState();\n    }\n\n   protected:\n    Status AsGraphDefInternal(SerializationContext* ctx,\n                              DatasetGraphDefBuilder* b,\n                              Node** output) const override {\n      Node* input_graph_node = nullptr;\n      TF_RETURN_IF_ERROR(b->AddInputDataset(ctx, input_, &input_graph_node));\n      Node* resource_handle_node = nullptr;\n      TF_RETURN_IF_ERROR(b->AddTensor(resource_handle_, &resource_handle_node));\n      TF_RETURN_IF_ERROR(b->AddDataset(\n          this, {input_graph_node, resource_handle_node}, output));\n      return Status::OK();\n    }\n\n   private:\n    class Iterator : public DatasetIterator<Dataset> {\n     public:\n      explicit Iterator(const Params& params)\n          : DatasetIterator<Dataset>(params) {}\n\n      Status Initialize(IteratorContext* ctx) override {\n        return dataset()->input_->MakeIterator(\n            IteratorContext(CreateParams(ctx)), this, prefix(), &input_impl_);\n      }\n\n      Status GetNextInternal(IteratorContext* ctx,\n                             std::vector<Tensor>* out_tensors,\n                             bool* end_of_sequence) override {\n        return input_impl_->GetNext(IteratorContext(CreateParams(ctx)),\n                                    out_tensors, end_of_sequence);\n      }\n\n     protected:\n      std::shared_ptr<model::Node> CreateNode(\n          IteratorContext* ctx, model::Node::Args args) const override {\n        return model::MakeKnownRatioNode(std::move(args),\n                                         /*ratio=*/1);\n      }\n\n      Status SaveInternal(SerializationContext* ctx,\n                          IteratorStateWriter* writer) override {\n        DCHECK(input_impl_ != nullptr);\n        TF_RETURN_IF_ERROR(SaveInput(ctx, writer, input_impl_));\n        return Status::OK();\n      }\n\n      Status RestoreInternal(IteratorContext* ctx,\n                             IteratorStateReader* reader) override {\n        TF_RETURN_IF_ERROR(RestoreInput(ctx, reader, input_impl_));\n        return Status::OK();\n      }\n\n     private:\n      IteratorContext::Params CreateParams(IteratorContext* ctx) {\n        ThreadPoolResource* pool = dataset()->threadpool_;\n        IteratorContext::Params params(ctx);\n        params.runner = [pool](std::function<void()> c) {\n          pool->Schedule(std::move(c));\n        };\n        params.runner_threadpool_size = pool->NumThreads();\n        return params;\n      }\n\n      std::unique_ptr<IteratorBase> input_impl_;\n    };\n\n    const DatasetBase* const input_;\n    const Tensor resource_handle_;\n    ThreadPoolResource* const threadpool_;\n  };\n};\n\nclass MaxIntraOpParallelismDatasetOp::Dataset : public DatasetBase {\n public:\n  Dataset(OpKernelContext* ctx, const DatasetBase* input,\n          int64_t max_intra_op_parallelism)\n      : Dataset(DatasetContext(ctx), input, max_intra_op_parallelism) {}\n\n  Dataset(DatasetContext&& ctx, const DatasetBase* input,\n          int64_t max_intra_op_parallelism)\n      : DatasetBase(std::move(ctx)),\n        input_(input),\n        max_intra_op_parallelism_(max_intra_op_parallelism),\n        traceme_metadata_(\n            {{\"parallelism\",\n              strings::Printf(\"%lld\", static_cast<long long>(\n                                          max_intra_op_parallelism_))}}) {\n    input_->Ref();\n  }\n\n  ~Dataset() override { input_->Unref(); }\n\n  std::unique_ptr<IteratorBase> MakeIteratorInternal(\n      const string& prefix) const override {\n    return absl::make_unique<Iterator>(Iterator::Params{\n        this, strings::StrCat(prefix, \"::MaxIntraOpParallelism\")});\n  }\n\n  const DataTypeVector& output_dtypes() const override {\n    return input_->output_dtypes();\n  }\n  const std::vector<PartialTensorShape>& output_shapes() const override {\n    return input_->output_shapes();\n  }\n\n  string DebugString() const override {\n    return \"MaxIntraOpParallelismDatasetOp::Dataset\";\n  }\n\n  int64_t CardinalityInternal() const override { return input_->Cardinality(); }\n\n  Status InputDatasets(std::vector<const DatasetBase*>* inputs) const override {\n    inputs->clear();\n    inputs->push_back(input_);\n    return Status::OK();\n  }\n\n  Status CheckExternalState() const override {\n    return input_->CheckExternalState();\n  }\n\n protected:\n  Status AsGraphDefInternal(SerializationContext* ctx,\n                            DatasetGraphDefBuilder* b,\n                            Node** output) const override {\n    Node* input_graph_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddInputDataset(ctx, input_, &input_graph_node));\n    Node* max_intra_op_parallelism_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddScalar(max_intra_op_parallelism_,\n                                    &max_intra_op_parallelism_node));\n    TF_RETURN_IF_ERROR(b->AddDataset(\n        this, {input_graph_node, max_intra_op_parallelism_node}, output));\n    return Status::OK();\n  }\n\n private:\n  class Iterator : public DatasetIterator<Dataset> {\n   public:\n    explicit Iterator(const Params& params)\n        : DatasetIterator<Dataset>(params) {}\n\n    Status Initialize(IteratorContext* ctx) override {\n      return dataset()->input_->MakeIterator(ctx, this, prefix(), &input_impl_);\n    }\n\n    Status GetNextInternal(IteratorContext* ctx,\n                           std::vector<Tensor>* out_tensors,\n                           bool* end_of_sequence) override {\n      IteratorContext::Params params(ctx);\n      auto max_parallelism = dataset()->max_intra_op_parallelism_;\n      params.runner = RunnerWithMaxParallelism(*ctx->runner(), max_parallelism);\n      return input_impl_->GetNext(IteratorContext{std::move(params)},\n                                  out_tensors, end_of_sequence);\n    }\n\n   protected:\n    std::shared_ptr<model::Node> CreateNode(\n        IteratorContext* ctx, model::Node::Args args) const override {\n      return model::MakeKnownRatioNode(std::move(args), /*ratio=*/1);\n    }\n\n    Status SaveInternal(SerializationContext* ctx,\n                        IteratorStateWriter* writer) override {\n      DCHECK(input_impl_ != nullptr);\n      TF_RETURN_IF_ERROR(SaveInput(ctx, writer, input_impl_));\n      return Status::OK();\n    }\n\n    Status RestoreInternal(IteratorContext* ctx,\n                           IteratorStateReader* reader) override {\n      TF_RETURN_IF_ERROR(RestoreInput(ctx, reader, input_impl_));\n      return Status::OK();\n    }\n\n    TraceMeMetadata GetTraceMeMetadata() const override {\n      return dataset()->traceme_metadata_;\n    }\n\n   private:\n    std::unique_ptr<IteratorBase> input_impl_;\n  };\n\n  const DatasetBase* const input_;\n  const int64_t max_intra_op_parallelism_;\n  const TraceMeMetadata traceme_metadata_;\n};\n\n/* static */\nvoid MaxIntraOpParallelismDatasetOp::MakeDatasetFromOptions(\n    OpKernelContext* ctx, DatasetBase* input, int32_t max_intra_op_parallelism,\n    DatasetBase** output) {\n  OP_REQUIRES(\n      ctx, max_intra_op_parallelism >= 0,\n      errors::InvalidArgument(\"`max_intra_op_parallelism` must be >= 0\"));\n  *output = new Dataset(DatasetContext(DatasetContext::Params(\n                            {MaxIntraOpParallelismDatasetOp::kDatasetType,\n                             MaxIntraOpParallelismDatasetOp::kDatasetOp})),\n                        input, max_intra_op_parallelism);\n}\n\nvoid MaxIntraOpParallelismDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                                 DatasetBase* input,\n                                                 DatasetBase** output) {\n  int64_t max_intra_op_parallelism;\n  OP_REQUIRES_OK(ctx,\n                 ParseScalarArgument<int64_t>(ctx, \"max_intra_op_parallelism\",\n                                              &max_intra_op_parallelism));\n  OP_REQUIRES(\n      ctx, max_intra_op_parallelism >= 0,\n      errors::InvalidArgument(\"`max_intra_op_parallelism` must be >= 0\"));\n  *output = new Dataset(ctx, input, max_intra_op_parallelism);\n}\n\nclass PrivateThreadPoolDatasetOp::Dataset : public DatasetBase {\n public:\n  Dataset(OpKernelContext* ctx, const DatasetBase* input, int num_threads)\n      : Dataset(ctx, DatasetContext(ctx), input, num_threads) {}\n\n  Dataset(OpKernelContext* ctx, DatasetContext&& dataset_ctx,\n          const DatasetBase* input, int num_threads)\n      : DatasetBase(std::move(dataset_ctx)),\n        input_(input),\n        num_threads_(num_threads == 0 ? port::MaxParallelism() : num_threads),\n        traceme_metadata_(\n            {{\"num_threads\",\n              strings::Printf(\"%lld\", static_cast<long long>(num_threads_))}}) {\n    thread_pool_ = absl::make_unique<thread::ThreadPool>(\n        ctx->env(), ThreadOptions{}, \"data_private_threadpool\", num_threads_);\n    input_->Ref();\n  }\n\n  ~Dataset() override { input_->Unref(); }\n\n  std::unique_ptr<IteratorBase> MakeIteratorInternal(\n      const string& prefix) const override {\n    return absl::make_unique<Iterator>(\n        Iterator::Params{this, strings::StrCat(prefix, \"::PrivateThreadPool\")});\n  }\n\n  const DataTypeVector& output_dtypes() const override {\n    return input_->output_dtypes();\n  }\n  const std::vector<PartialTensorShape>& output_shapes() const override {\n    return input_->output_shapes();\n  }\n\n  string DebugString() const override {\n    return \"PrivateThreadPoolDatasetOp::Dataset\";\n  }\n\n  int64_t CardinalityInternal() const override { return input_->Cardinality(); }\n\n  Status InputDatasets(std::vector<const DatasetBase*>* inputs) const override {\n    inputs->clear();\n    inputs->push_back(input_);\n    return Status::OK();\n  }\n\n  Status CheckExternalState() const override {\n    return input_->CheckExternalState();\n  }\n\n protected:\n  Status AsGraphDefInternal(SerializationContext* ctx,\n                            DatasetGraphDefBuilder* b,\n                            Node** output) const override {\n    Node* input_graph_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddInputDataset(ctx, input_, &input_graph_node));\n    Node* num_threads_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddScalar(num_threads_, &num_threads_node));\n    TF_RETURN_IF_ERROR(\n        b->AddDataset(this, {input_graph_node, num_threads_node}, output));\n    return Status::OK();\n  }\n\n private:\n  class Iterator : public DatasetIterator<Dataset> {\n   public:\n    explicit Iterator(const Params& params)\n        : DatasetIterator<Dataset>(params) {}\n\n    Status Initialize(IteratorContext* ctx) override {\n      return dataset()->input_->MakeIterator(ctx, this, prefix(), &input_impl_);\n    }\n\n    Status GetNextInternal(IteratorContext* ctx,\n                           std::vector<Tensor>* out_tensors,\n                           bool* end_of_sequence) override {\n      thread::ThreadPool* pool = dataset()->thread_pool_.get();\n      IteratorContext::Params params(ctx);\n      params.runner = [pool](std::function<void()> c) {\n        pool->Schedule(std::move(c));\n      };\n      params.runner_threadpool_size = dataset()->num_threads_;\n      return input_impl_->GetNext(IteratorContext{std::move(params)},\n                                  out_tensors, end_of_sequence);\n    }\n\n   protected:\n    std::shared_ptr<model::Node> CreateNode(\n        IteratorContext* ctx, model::Node::Args args) const override {\n      return model::MakeKnownRatioNode(std::move(args), /*ratio=*/1);\n    }\n\n    Status SaveInternal(SerializationContext* ctx,\n                        IteratorStateWriter* writer) override {\n      DCHECK(input_impl_ != nullptr);\n      TF_RETURN_IF_ERROR(SaveInput(ctx, writer, input_impl_));\n      return Status::OK();\n    }\n\n    Status RestoreInternal(IteratorContext* ctx,\n                           IteratorStateReader* reader) override {\n      TF_RETURN_IF_ERROR(RestoreInput(ctx, reader, input_impl_));\n      return Status::OK();\n    }\n\n    TraceMeMetadata GetTraceMeMetadata() const override {\n      return dataset()->traceme_metadata_;\n    }\n\n   private:\n    std::unique_ptr<IteratorBase> input_impl_;\n  };\n\n  const DatasetBase* const input_;\n  const int64_t num_threads_;\n  const TraceMeMetadata traceme_metadata_;\n  std::unique_ptr<thread::ThreadPool> thread_pool_;\n};\n\n/* static */\nvoid PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}\n\nvoid PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx, input, num_threads);\n}\n\nnamespace {\n\nREGISTER_KERNEL_BUILDER(Name(\"MaxIntraOpParallelismDataset\").Device(DEVICE_CPU),\n                        MaxIntraOpParallelismDatasetOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalMaxIntraOpParallelismDataset\").Device(DEVICE_CPU),\n    MaxIntraOpParallelismDatasetOp);\n\nREGISTER_KERNEL_BUILDER(Name(\"PrivateThreadPoolDataset\").Device(DEVICE_CPU),\n                        PrivateThreadPoolDatasetOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalPrivateThreadPoolDataset\").Device(DEVICE_CPU),\n    PrivateThreadPoolDatasetOp);\n\nREGISTER_KERNEL_BUILDER(Name(\"ThreadPoolHandle\").Device(DEVICE_CPU),\n                        ThreadPoolHandleOp);\nREGISTER_KERNEL_BUILDER(Name(\"ExperimentalThreadPoolHandle\").Device(DEVICE_CPU),\n                        ThreadPoolHandleOp);\n\nREGISTER_KERNEL_BUILDER(Name(\"ThreadPoolDataset\").Device(DEVICE_CPU),\n                        ThreadPoolDatasetOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalThreadPoolDataset\").Device(DEVICE_CPU),\n    ThreadPoolDatasetOp);\n\n}  // namespace\n}  // namespace experimental\n}  // namespace data\n}  // namespace tensorflow\n"], "fixing_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#include \"tensorflow/core/kernels/data/experimental/threadpool_dataset_op.h\"\n\n#include <memory>\n\n#include \"tensorflow/core/data/dataset_utils.h\"\n#include \"tensorflow/core/framework/dataset.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include \"tensorflow/core/lib/core/refcount.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/platform/cpu_info.h\"\n#include \"tensorflow/core/platform/stringprintf.h\"\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\nnamespace data {\nnamespace experimental {\n\n/* static */ constexpr const char* const\n    MaxIntraOpParallelismDatasetOp::kDatasetType;\n/* static */ constexpr const char* const\n    MaxIntraOpParallelismDatasetOp::kDatasetOp;\n/* static */ constexpr const char* const\n    PrivateThreadPoolDatasetOp::kDatasetType;\n/* static */ constexpr const char* const PrivateThreadPoolDatasetOp::kDatasetOp;\n\nnamespace {\n// To prevent integer overflow issues when allocating threadpool memory for an\n// unreasonable number of threads.\nconstexpr int kThreadLimit = 65536;\n\nStatus ValidateNumThreads(int32_t num_threads) {\n  if (num_threads < 0) {\n    return errors::InvalidArgument(\"`num_threads` must be >= 0\");\n  }\n  if (num_threads >= kThreadLimit) {\n    return errors::InvalidArgument(\"`num_threads` must be < \", kThreadLimit);\n  }\n  return Status::OK();\n}\n}  // namespace\n\nclass ThreadPoolResource : public ResourceBase {\n public:\n  ThreadPoolResource(Env* env, const ThreadOptions& thread_options,\n                     const string& name, int num_threads, bool low_latency_hint,\n                     int max_intra_op_parallelism)\n      : thread_pool_(env, thread_options, name, num_threads, low_latency_hint),\n        max_intra_op_parallelism_(max_intra_op_parallelism) {}\n\n  // Schedules fn() for execution in the pool of threads.\n  void Schedule(std::function<void()> fn) {\n    if (max_intra_op_parallelism_ < 0) {\n      thread_pool_.Schedule(std::move(fn));\n    } else {\n      thread_pool_.Schedule(std::bind(\n          [this](std::function<void()> bound_fn) {\n            // TODO(mrry): Consider moving this thread-local configuration to\n            // the threads themselves.\n            ScopedPerThreadMaxParallelism scope(max_intra_op_parallelism_);\n            bound_fn();\n          },\n          std::move(fn)));\n    }\n  }\n\n  int32 NumThreads() { return thread_pool_.NumThreads(); }\n\n  string DebugString() const override { return \"ThreadPoolResource\"; }\n\n private:\n  thread::ThreadPool thread_pool_;\n  const int max_intra_op_parallelism_;\n};\n\n// Creates a handle to a ThreadPool resource. Note that we don't use\n// ResourceOpKernel here because the ThreadPoolResource constructor requires\n// access to `OpKernelContext::env()`, which isn't provided by\n// `ResourceOpKernel<T>::CreateResource()`.\nclass ThreadPoolHandleOp : public OpKernel {\n public:\n  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads_));\n  }\n\n  // The resource is deleted from the resource manager only when it is private\n  // to kernel. Ideally the resource should be deleted when it is no longer held\n  // by anyone, but it would break backward compatibility.\n  ~ThreadPoolHandleOp() override {\n    if (cinfo_.resource_is_private_to_kernel()) {\n      if (!cinfo_.resource_manager()\n               ->Delete<ThreadPoolResource>(cinfo_.container(), cinfo_.name())\n               .ok()) {\n        // Do nothing; the resource can have been deleted by session resets.\n      }\n    }\n  }\n\n  void Compute(OpKernelContext* ctx) override TF_LOCKS_EXCLUDED(mu_) {\n    mutex_lock l(mu_);\n    if (!initialized_) {\n      ResourceMgr* mgr = ctx->resource_manager();\n      OP_REQUIRES_OK(ctx, cinfo_.Init(mgr, def()));\n      ThreadPoolResource* resource;\n      OP_REQUIRES_OK(ctx, mgr->LookupOrCreate<ThreadPoolResource>(\n                              cinfo_.container(), cinfo_.name(), &resource,\n                              [this, ctx](ThreadPoolResource** ret)\n                                  TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n                                    *ret = new ThreadPoolResource(\n                                        ctx->env(), {}, display_name_,\n                                        num_threads_,\n                                        /*low_latency_hint=*/false,\n                                        max_intra_op_parallelism_);\n                                    return Status::OK();\n                                  }));\n      initialized_ = true;\n    }\n    OP_REQUIRES_OK(ctx, MakeResourceHandleToOutput(\n                            ctx, 0, cinfo_.container(), cinfo_.name(),\n                            TypeIndex::Make<ThreadPoolResource>()));\n  }\n\n private:\n  mutex mu_;\n  ContainerInfo cinfo_ TF_GUARDED_BY(mu_);\n  bool initialized_ TF_GUARDED_BY(mu_) = false;\n  string display_name_;\n  int num_threads_;\n  int max_intra_op_parallelism_;\n};\n\nclass ThreadPoolDatasetOp : public UnaryDatasetOpKernel {\n public:\n  explicit ThreadPoolDatasetOp(OpKernelConstruction* ctx)\n      : UnaryDatasetOpKernel(ctx) {}\n\n  void MakeDataset(OpKernelContext* ctx, DatasetBase* input,\n                   DatasetBase** output) override {\n    core::RefCountPtr<ThreadPoolResource> threadpool_resource;\n    OP_REQUIRES_OK(ctx, LookupResource(ctx, HandleFromInput(ctx, 1),\n                                       &threadpool_resource));\n    *output = new Dataset(ctx, input, ctx->input(1), threadpool_resource.get());\n  }\n\n private:\n  class Dataset : public DatasetBase {\n   public:\n    Dataset(OpKernelContext* ctx, const DatasetBase* input,\n            const Tensor& resource_handle, ThreadPoolResource* threadpool)\n        : DatasetBase(DatasetContext(ctx)),\n          input_(input),\n          resource_handle_(resource_handle),\n          threadpool_(threadpool) {\n      input_->Ref();\n      threadpool_->Ref();\n    }\n\n    ~Dataset() override {\n      input_->Unref();\n      threadpool_->Unref();\n    }\n\n    std::unique_ptr<IteratorBase> MakeIteratorInternal(\n        const string& prefix) const override {\n      return absl::make_unique<Iterator>(\n          Iterator::Params{this, strings::StrCat(prefix, \"::ThreadPool\")});\n    }\n\n    const DataTypeVector& output_dtypes() const override {\n      return input_->output_dtypes();\n    }\n    const std::vector<PartialTensorShape>& output_shapes() const override {\n      return input_->output_shapes();\n    }\n\n    string DebugString() const override {\n      return \"ThreadPoolDatasetOp::Dataset\";\n    }\n\n    int64_t CardinalityInternal() const override {\n      return input_->Cardinality();\n    }\n\n    Status InputDatasets(\n        std::vector<const DatasetBase*>* inputs) const override {\n      inputs->push_back(input_);\n      return Status::OK();\n    }\n\n    Status CheckExternalState() const override {\n      return input_->CheckExternalState();\n    }\n\n   protected:\n    Status AsGraphDefInternal(SerializationContext* ctx,\n                              DatasetGraphDefBuilder* b,\n                              Node** output) const override {\n      Node* input_graph_node = nullptr;\n      TF_RETURN_IF_ERROR(b->AddInputDataset(ctx, input_, &input_graph_node));\n      Node* resource_handle_node = nullptr;\n      TF_RETURN_IF_ERROR(b->AddTensor(resource_handle_, &resource_handle_node));\n      TF_RETURN_IF_ERROR(b->AddDataset(\n          this, {input_graph_node, resource_handle_node}, output));\n      return Status::OK();\n    }\n\n   private:\n    class Iterator : public DatasetIterator<Dataset> {\n     public:\n      explicit Iterator(const Params& params)\n          : DatasetIterator<Dataset>(params) {}\n\n      Status Initialize(IteratorContext* ctx) override {\n        return dataset()->input_->MakeIterator(\n            IteratorContext(CreateParams(ctx)), this, prefix(), &input_impl_);\n      }\n\n      Status GetNextInternal(IteratorContext* ctx,\n                             std::vector<Tensor>* out_tensors,\n                             bool* end_of_sequence) override {\n        return input_impl_->GetNext(IteratorContext(CreateParams(ctx)),\n                                    out_tensors, end_of_sequence);\n      }\n\n     protected:\n      std::shared_ptr<model::Node> CreateNode(\n          IteratorContext* ctx, model::Node::Args args) const override {\n        return model::MakeKnownRatioNode(std::move(args),\n                                         /*ratio=*/1);\n      }\n\n      Status SaveInternal(SerializationContext* ctx,\n                          IteratorStateWriter* writer) override {\n        DCHECK(input_impl_ != nullptr);\n        TF_RETURN_IF_ERROR(SaveInput(ctx, writer, input_impl_));\n        return Status::OK();\n      }\n\n      Status RestoreInternal(IteratorContext* ctx,\n                             IteratorStateReader* reader) override {\n        TF_RETURN_IF_ERROR(RestoreInput(ctx, reader, input_impl_));\n        return Status::OK();\n      }\n\n     private:\n      IteratorContext::Params CreateParams(IteratorContext* ctx) {\n        ThreadPoolResource* pool = dataset()->threadpool_;\n        IteratorContext::Params params(ctx);\n        params.runner = [pool](std::function<void()> c) {\n          pool->Schedule(std::move(c));\n        };\n        params.runner_threadpool_size = pool->NumThreads();\n        return params;\n      }\n\n      std::unique_ptr<IteratorBase> input_impl_;\n    };\n\n    const DatasetBase* const input_;\n    const Tensor resource_handle_;\n    ThreadPoolResource* const threadpool_;\n  };\n};\n\nclass MaxIntraOpParallelismDatasetOp::Dataset : public DatasetBase {\n public:\n  Dataset(OpKernelContext* ctx, const DatasetBase* input,\n          int64_t max_intra_op_parallelism)\n      : Dataset(DatasetContext(ctx), input, max_intra_op_parallelism) {}\n\n  Dataset(DatasetContext&& ctx, const DatasetBase* input,\n          int64_t max_intra_op_parallelism)\n      : DatasetBase(std::move(ctx)),\n        input_(input),\n        max_intra_op_parallelism_(max_intra_op_parallelism),\n        traceme_metadata_(\n            {{\"parallelism\",\n              strings::Printf(\"%lld\", static_cast<long long>(\n                                          max_intra_op_parallelism_))}}) {\n    input_->Ref();\n  }\n\n  ~Dataset() override { input_->Unref(); }\n\n  std::unique_ptr<IteratorBase> MakeIteratorInternal(\n      const string& prefix) const override {\n    return absl::make_unique<Iterator>(Iterator::Params{\n        this, strings::StrCat(prefix, \"::MaxIntraOpParallelism\")});\n  }\n\n  const DataTypeVector& output_dtypes() const override {\n    return input_->output_dtypes();\n  }\n  const std::vector<PartialTensorShape>& output_shapes() const override {\n    return input_->output_shapes();\n  }\n\n  string DebugString() const override {\n    return \"MaxIntraOpParallelismDatasetOp::Dataset\";\n  }\n\n  int64_t CardinalityInternal() const override { return input_->Cardinality(); }\n\n  Status InputDatasets(std::vector<const DatasetBase*>* inputs) const override {\n    inputs->clear();\n    inputs->push_back(input_);\n    return Status::OK();\n  }\n\n  Status CheckExternalState() const override {\n    return input_->CheckExternalState();\n  }\n\n protected:\n  Status AsGraphDefInternal(SerializationContext* ctx,\n                            DatasetGraphDefBuilder* b,\n                            Node** output) const override {\n    Node* input_graph_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddInputDataset(ctx, input_, &input_graph_node));\n    Node* max_intra_op_parallelism_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddScalar(max_intra_op_parallelism_,\n                                    &max_intra_op_parallelism_node));\n    TF_RETURN_IF_ERROR(b->AddDataset(\n        this, {input_graph_node, max_intra_op_parallelism_node}, output));\n    return Status::OK();\n  }\n\n private:\n  class Iterator : public DatasetIterator<Dataset> {\n   public:\n    explicit Iterator(const Params& params)\n        : DatasetIterator<Dataset>(params) {}\n\n    Status Initialize(IteratorContext* ctx) override {\n      return dataset()->input_->MakeIterator(ctx, this, prefix(), &input_impl_);\n    }\n\n    Status GetNextInternal(IteratorContext* ctx,\n                           std::vector<Tensor>* out_tensors,\n                           bool* end_of_sequence) override {\n      IteratorContext::Params params(ctx);\n      auto max_parallelism = dataset()->max_intra_op_parallelism_;\n      params.runner = RunnerWithMaxParallelism(*ctx->runner(), max_parallelism);\n      return input_impl_->GetNext(IteratorContext{std::move(params)},\n                                  out_tensors, end_of_sequence);\n    }\n\n   protected:\n    std::shared_ptr<model::Node> CreateNode(\n        IteratorContext* ctx, model::Node::Args args) const override {\n      return model::MakeKnownRatioNode(std::move(args), /*ratio=*/1);\n    }\n\n    Status SaveInternal(SerializationContext* ctx,\n                        IteratorStateWriter* writer) override {\n      DCHECK(input_impl_ != nullptr);\n      TF_RETURN_IF_ERROR(SaveInput(ctx, writer, input_impl_));\n      return Status::OK();\n    }\n\n    Status RestoreInternal(IteratorContext* ctx,\n                           IteratorStateReader* reader) override {\n      TF_RETURN_IF_ERROR(RestoreInput(ctx, reader, input_impl_));\n      return Status::OK();\n    }\n\n    TraceMeMetadata GetTraceMeMetadata() const override {\n      return dataset()->traceme_metadata_;\n    }\n\n   private:\n    std::unique_ptr<IteratorBase> input_impl_;\n  };\n\n  const DatasetBase* const input_;\n  const int64_t max_intra_op_parallelism_;\n  const TraceMeMetadata traceme_metadata_;\n};\n\n/* static */\nvoid MaxIntraOpParallelismDatasetOp::MakeDatasetFromOptions(\n    OpKernelContext* ctx, DatasetBase* input, int32_t max_intra_op_parallelism,\n    DatasetBase** output) {\n  OP_REQUIRES(\n      ctx, max_intra_op_parallelism >= 0,\n      errors::InvalidArgument(\"`max_intra_op_parallelism` must be >= 0\"));\n  *output = new Dataset(DatasetContext(DatasetContext::Params(\n                            {MaxIntraOpParallelismDatasetOp::kDatasetType,\n                             MaxIntraOpParallelismDatasetOp::kDatasetOp})),\n                        input, max_intra_op_parallelism);\n}\n\nvoid MaxIntraOpParallelismDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                                 DatasetBase* input,\n                                                 DatasetBase** output) {\n  int64_t max_intra_op_parallelism;\n  OP_REQUIRES_OK(ctx,\n                 ParseScalarArgument<int64_t>(ctx, \"max_intra_op_parallelism\",\n                                              &max_intra_op_parallelism));\n  OP_REQUIRES(\n      ctx, max_intra_op_parallelism >= 0,\n      errors::InvalidArgument(\"`max_intra_op_parallelism` must be >= 0\"));\n  *output = new Dataset(ctx, input, max_intra_op_parallelism);\n}\n\nclass PrivateThreadPoolDatasetOp::Dataset : public DatasetBase {\n public:\n  Dataset(OpKernelContext* ctx, const DatasetBase* input, int num_threads)\n      : Dataset(ctx, DatasetContext(ctx), input, num_threads) {}\n\n  Dataset(OpKernelContext* ctx, DatasetContext&& dataset_ctx,\n          const DatasetBase* input, int num_threads)\n      : DatasetBase(std::move(dataset_ctx)),\n        input_(input),\n        num_threads_(num_threads == 0 ? port::MaxParallelism() : num_threads),\n        traceme_metadata_(\n            {{\"num_threads\",\n              strings::Printf(\"%lld\", static_cast<long long>(num_threads_))}}) {\n    thread_pool_ = absl::make_unique<thread::ThreadPool>(\n        ctx->env(), ThreadOptions{}, \"data_private_threadpool\", num_threads_);\n    input_->Ref();\n  }\n\n  ~Dataset() override { input_->Unref(); }\n\n  std::unique_ptr<IteratorBase> MakeIteratorInternal(\n      const string& prefix) const override {\n    return absl::make_unique<Iterator>(\n        Iterator::Params{this, strings::StrCat(prefix, \"::PrivateThreadPool\")});\n  }\n\n  const DataTypeVector& output_dtypes() const override {\n    return input_->output_dtypes();\n  }\n  const std::vector<PartialTensorShape>& output_shapes() const override {\n    return input_->output_shapes();\n  }\n\n  string DebugString() const override {\n    return \"PrivateThreadPoolDatasetOp::Dataset\";\n  }\n\n  int64_t CardinalityInternal() const override { return input_->Cardinality(); }\n\n  Status InputDatasets(std::vector<const DatasetBase*>* inputs) const override {\n    inputs->clear();\n    inputs->push_back(input_);\n    return Status::OK();\n  }\n\n  Status CheckExternalState() const override {\n    return input_->CheckExternalState();\n  }\n\n protected:\n  Status AsGraphDefInternal(SerializationContext* ctx,\n                            DatasetGraphDefBuilder* b,\n                            Node** output) const override {\n    Node* input_graph_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddInputDataset(ctx, input_, &input_graph_node));\n    Node* num_threads_node = nullptr;\n    TF_RETURN_IF_ERROR(b->AddScalar(num_threads_, &num_threads_node));\n    TF_RETURN_IF_ERROR(\n        b->AddDataset(this, {input_graph_node, num_threads_node}, output));\n    return Status::OK();\n  }\n\n private:\n  class Iterator : public DatasetIterator<Dataset> {\n   public:\n    explicit Iterator(const Params& params)\n        : DatasetIterator<Dataset>(params) {}\n\n    Status Initialize(IteratorContext* ctx) override {\n      return dataset()->input_->MakeIterator(ctx, this, prefix(), &input_impl_);\n    }\n\n    Status GetNextInternal(IteratorContext* ctx,\n                           std::vector<Tensor>* out_tensors,\n                           bool* end_of_sequence) override {\n      thread::ThreadPool* pool = dataset()->thread_pool_.get();\n      IteratorContext::Params params(ctx);\n      params.runner = [pool](std::function<void()> c) {\n        pool->Schedule(std::move(c));\n      };\n      params.runner_threadpool_size = dataset()->num_threads_;\n      return input_impl_->GetNext(IteratorContext{std::move(params)},\n                                  out_tensors, end_of_sequence);\n    }\n\n   protected:\n    std::shared_ptr<model::Node> CreateNode(\n        IteratorContext* ctx, model::Node::Args args) const override {\n      return model::MakeKnownRatioNode(std::move(args), /*ratio=*/1);\n    }\n\n    Status SaveInternal(SerializationContext* ctx,\n                        IteratorStateWriter* writer) override {\n      DCHECK(input_impl_ != nullptr);\n      TF_RETURN_IF_ERROR(SaveInput(ctx, writer, input_impl_));\n      return Status::OK();\n    }\n\n    Status RestoreInternal(IteratorContext* ctx,\n                           IteratorStateReader* reader) override {\n      TF_RETURN_IF_ERROR(RestoreInput(ctx, reader, input_impl_));\n      return Status::OK();\n    }\n\n    TraceMeMetadata GetTraceMeMetadata() const override {\n      return dataset()->traceme_metadata_;\n    }\n\n   private:\n    std::unique_ptr<IteratorBase> input_impl_;\n  };\n\n  const DatasetBase* const input_;\n  const int64_t num_threads_;\n  const TraceMeMetadata traceme_metadata_;\n  std::unique_ptr<thread::ThreadPool> thread_pool_;\n};\n\n/* static */\nvoid PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}\n\nvoid PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n  *output = new Dataset(ctx, input, num_threads);\n}\n\nnamespace {\n\nREGISTER_KERNEL_BUILDER(Name(\"MaxIntraOpParallelismDataset\").Device(DEVICE_CPU),\n                        MaxIntraOpParallelismDatasetOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalMaxIntraOpParallelismDataset\").Device(DEVICE_CPU),\n    MaxIntraOpParallelismDatasetOp);\n\nREGISTER_KERNEL_BUILDER(Name(\"PrivateThreadPoolDataset\").Device(DEVICE_CPU),\n                        PrivateThreadPoolDatasetOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalPrivateThreadPoolDataset\").Device(DEVICE_CPU),\n    PrivateThreadPoolDatasetOp);\n\nREGISTER_KERNEL_BUILDER(Name(\"ThreadPoolHandle\").Device(DEVICE_CPU),\n                        ThreadPoolHandleOp);\nREGISTER_KERNEL_BUILDER(Name(\"ExperimentalThreadPoolHandle\").Device(DEVICE_CPU),\n                        ThreadPoolHandleOp);\n\nREGISTER_KERNEL_BUILDER(Name(\"ThreadPoolDataset\").Device(DEVICE_CPU),\n                        ThreadPoolDatasetOp);\nREGISTER_KERNEL_BUILDER(\n    Name(\"ExperimentalThreadPoolDataset\").Device(DEVICE_CPU),\n    ThreadPoolDatasetOp);\n\n}  // namespace\n}  // namespace experimental\n}  // namespace data\n}  // namespace tensorflow\n"], "filenames": ["tensorflow/core/kernels/data/experimental/threadpool_dataset_op.cc"], "buggy_code_start_loc": [40], "buggy_code_end_loc": [551], "fixing_code_start_loc": [41], "fixing_code_end_loc": [563], "type": "CWE-770", "message": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `ThreadPoolHandle` can be used to trigger a denial of service attack by allocating too much memory. This is because the `num_threads` argument is only checked to not be negative, but there is no upper bound on its value. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2022-21732", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-03T12:15:07.933", "lastModified": "2022-02-09T03:08:52.380", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Tensorflow is an Open Source Machine Learning Framework. The implementation of `ThreadPoolHandle` can be used to trigger a denial of service attack by allocating too much memory. This is because the `num_threads` argument is only checked to not be negative, but there is no upper bound on its value. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."}, {"lang": "es", "value": "Tensorflow es un marco de aprendizaje autom\u00e1tico de c\u00f3digo abierto. La implementaci\u00f3n de \"ThreadPoolHandle\" puede ser usada para desencadenar un ataque de denegaci\u00f3n de servicio asignando demasiada memoria. Esto es debido a que el argumento \"num_threads\" s\u00f3lo es comprobado que no sea negativo, pero no se presenta un l\u00edmite superior en su valor. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.8.0. Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.7.1, TensorFlow versi\u00f3n 2.6.3, y TensorFlow versi\u00f3n 2.5.3, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.2", "matchCriteriaId": "688150BF-477C-48FC-9AEF-A79AC57A6DDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndIncluding": "2.6.2", "matchCriteriaId": "C9E69B60-8C97-47E2-9027-9598B8392E5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "2EDFAAB8-799C-4259-9102-944D4760DA2C"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/blob/5100e359aef5c8021f2e71c7b986420b85ce7b3d/tensorflow/core/kernels/data/experimental/threadpool_dataset_op.cc#L79-L135", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/e3749a6d5d1e8d11806d4a2e9cc3123d1a90b75e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-c582-c96p-r5cq", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/e3749a6d5d1e8d11806d4a2e9cc3123d1a90b75e"}}