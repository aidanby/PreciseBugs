{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2016 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Rasmus Lerdorf <rasmus@lerdorf.on.ca>                       |\n   |          Zeev Suraski <zeev@zend.com>                                |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n#include <stdio.h>\n#include \"php.h\"\n#include \"ext/standard/php_standard.h\"\n#include \"ext/standard/credits.h\"\n#include \"ext/standard/php_smart_str.h\"\n#include \"php_variables.h\"\n#include \"php_globals.h\"\n#include \"php_content_types.h\"\n#include \"SAPI.h\"\n#include \"zend_globals.h\"\n#ifdef PHP_WIN32\n# include \"win32/php_inttypes.h\"\n#endif\n\n/* for systems that need to override reading of environment variables */\nvoid _php_import_environment_variables(zval *array_ptr TSRMLS_DC);\nPHPAPI void (*php_import_environment_variables)(zval *array_ptr TSRMLS_DC) = _php_import_environment_variables;\n\nPHPAPI void php_register_variable(char *var, char *strval, zval *track_vars_array TSRMLS_DC)\n{\n\tphp_register_variable_safe(var, strval, strlen(strval), track_vars_array TSRMLS_CC);\n}\n\n/* binary-safe version */\nPHPAPI void php_register_variable_safe(char *var, char *strval, int str_len, zval *track_vars_array TSRMLS_DC)\n{\n\tzval new_entry;\n\tassert(strval != NULL);\n\n\t/* Prepare value */\n\tZ_STRLEN(new_entry) = str_len;\n\tZ_STRVAL(new_entry) = estrndup(strval, Z_STRLEN(new_entry));\n\tZ_TYPE(new_entry) = IS_STRING;\n\n\tphp_register_variable_ex(var, &new_entry, track_vars_array TSRMLS_CC);\n}\n\nPHPAPI void php_register_variable_ex(char *var_name, zval *val, zval *track_vars_array TSRMLS_DC)\n{\n\tchar *p = NULL;\n\tchar *ip = NULL;\t\t/* index pointer */\n\tchar *index;\n\tchar *var, *var_orig;\n\tint var_len, index_len;\n\tzval *gpc_element, **gpc_element_p;\n\tzend_bool is_array = 0;\n\tHashTable *symtable1 = NULL;\n\tALLOCA_FLAG(use_heap)\n\n\tassert(var_name != NULL);\n\n\tif (track_vars_array) {\n\t\tsymtable1 = Z_ARRVAL_P(track_vars_array);\n\t}\n\n\tif (!symtable1) {\n\t\t/* Nothing to do */\n\t\tzval_dtor(val);\n\t\treturn;\n\t}\n\n\n\t/* ignore leading spaces in the variable name */\n\twhile (*var_name && *var_name==' ') {\n\t\tvar_name++;\n\t}\n\n\t/*\n\t * Prepare variable name\n\t */\n\tvar_len = strlen(var_name);\n\tvar = var_orig = do_alloca(var_len + 1, use_heap);\n\tmemcpy(var_orig, var_name, var_len + 1);\n\n\t/* ensure that we don't have spaces or dots in the variable name (not binary safe) */\n\tfor (p = var; *p; p++) {\n\t\tif (*p == ' ' || *p == '.') {\n\t\t\t*p='_';\n\t\t} else if (*p == '[') {\n\t\t\tis_array = 1;\n\t\t\tip = p;\n\t\t\t*p = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvar_len = p - var;\n\n\tif (var_len==0) { /* empty variable name, or variable name with a space in it */\n\t\tzval_dtor(val);\n\t\tfree_alloca(var_orig, use_heap);\n\t\treturn;\n\t}\n\n\t/* GLOBALS hijack attempt, reject parameter */\n\tif (symtable1 == EG(active_symbol_table) &&\n\t\tvar_len == sizeof(\"GLOBALS\")-1 &&\n\t\t!memcmp(var, \"GLOBALS\", sizeof(\"GLOBALS\")-1)) {\n\t\tzval_dtor(val);\n\t\tfree_alloca(var_orig, use_heap);\n\t\treturn;\n\t}\n\n\tindex = var;\n\tindex_len = var_len;\n\n\tif (is_array) {\n\t\tint nest_level = 0;\n\t\twhile (1) {\n\t\t\tchar *index_s;\n\t\t\tint new_idx_len = 0;\n\n\t\t\tif(++nest_level > PG(max_input_nesting_level)) {\n\t\t\t\tHashTable *ht;\n\t\t\t\t/* too many levels of nesting */\n\n\t\t\t\tif (track_vars_array) {\n\t\t\t\t\tht = Z_ARRVAL_P(track_vars_array);\n\t\t\t\t\tzend_symtable_del(ht, var, var_len + 1);\n\t\t\t\t}\n\n\t\t\t\tzval_dtor(val);\n\n\t\t\t\t/* do not output the error message to the screen,\n\t\t\t\t this helps us to to avoid \"information disclosure\" */\n\t\t\t\tif (!PG(display_errors)) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Input variable nesting level exceeded %ld. To increase the limit change max_input_nesting_level in php.ini.\", PG(max_input_nesting_level));\n\t\t\t\t}\n\t\t\t\tfree_alloca(var_orig, use_heap);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tip++;\n\t\t\tindex_s = ip;\n\t\t\tif (isspace(*ip)) {\n\t\t\t\tip++;\n\t\t\t}\n\t\t\tif (*ip==']') {\n\t\t\t\tindex_s = NULL;\n\t\t\t} else {\n\t\t\t\tip = strchr(ip, ']');\n\t\t\t\tif (!ip) {\n\t\t\t\t\t/* PHP variables cannot contain '[' in their names, so we replace the character with a '_' */\n\t\t\t\t\t*(index_s - 1) = '_';\n\n\t\t\t\t\tindex_len = 0;\n\t\t\t\t\tif (index) {\n\t\t\t\t\t\tindex_len = strlen(index);\n\t\t\t\t\t}\n\t\t\t\t\tgoto plain_var;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t*ip = 0;\n\t\t\t\tnew_idx_len = strlen(index_s);\n\t\t\t}\n\n\t\t\tif (!index) {\n\t\t\t\tMAKE_STD_ZVAL(gpc_element);\n\t\t\t\tarray_init(gpc_element);\n\t\t\t\tif (zend_hash_next_index_insert(symtable1, &gpc_element, sizeof(zval *), (void **) &gpc_element_p) == FAILURE) {\n\t\t\t\t\tzval_ptr_dtor(&gpc_element);\n\t\t\t\t\tzval_dtor(val);\n\t\t\t\t\tfree_alloca(var_orig, use_heap);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (zend_symtable_find(symtable1, index, index_len + 1, (void **) &gpc_element_p) == FAILURE\n\t\t\t\t\t|| Z_TYPE_PP(gpc_element_p) != IS_ARRAY) {\n\t\t\t\t\tMAKE_STD_ZVAL(gpc_element);\n\t\t\t\t\tarray_init(gpc_element);\n\t\t\t\t\tzend_symtable_update(symtable1, index, index_len + 1, &gpc_element, sizeof(zval *), (void **) &gpc_element_p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymtable1 = Z_ARRVAL_PP(gpc_element_p);\n\t\t\t/* ip pointed to the '[' character, now obtain the key */\n\t\t\tindex = index_s;\n\t\t\tindex_len = new_idx_len;\n\n\t\t\tip++;\n\t\t\tif (*ip == '[') {\n\t\t\t\tis_array = 1;\n\t\t\t\t*ip = 0;\n\t\t\t} else {\n\t\t\t\tgoto plain_var;\n\t\t\t}\n\t\t}\n\t} else {\nplain_var:\n\t\tMAKE_STD_ZVAL(gpc_element);\n\t\tgpc_element->value = val->value;\n\t\tZ_TYPE_P(gpc_element) = Z_TYPE_P(val);\n\t\tif (!index) {\n\t\t\tif (zend_hash_next_index_insert(symtable1, &gpc_element, sizeof(zval *), (void **) &gpc_element_p) == FAILURE) {\n\t\t\t\tzval_ptr_dtor(&gpc_element);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * According to rfc2965, more specific paths are listed above the less specific ones.\n\t\t\t * If we encounter a duplicate cookie name, we should skip it, since it is not possible\n\t\t\t * to have the same (plain text) cookie name for the same path and we should not overwrite\n\t\t\t * more specific cookies with the less specific ones.\n\t\t\t */\n\t\t\tif (PG(http_globals)[TRACK_VARS_COOKIE] &&\n\t\t\t\tsymtable1 == Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_COOKIE]) &&\n\t\t\t\tzend_symtable_exists(symtable1, index, index_len + 1)) {\n\t\t\t\tzval_ptr_dtor(&gpc_element);\n\t\t\t} else {\n\t\t\t\tzend_symtable_update(symtable1, index, index_len + 1, &gpc_element, sizeof(zval *), (void **) &gpc_element_p);\n\t\t\t}\n\t\t}\n\t}\n\tfree_alloca(var_orig, use_heap);\n}\n\ntypedef struct post_var_data {\n\tsmart_str str;\n\tchar *ptr;\n\tchar *end;\n\tuint64_t cnt;\n} post_var_data_t;\n\nstatic zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\t/* FIXME: string-size_t */\n\tunsigned int new_vlen;\n\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\t/* \"foo=bar&\" or \"foo=&\" */\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\t/* \"foo&\" */\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\n\tphp_url_decode(var->ptr, klen);\n\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n\tefree(val);\n\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}\n\nstatic inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (!eof) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}\n\n#ifdef PHP_WIN32\n#define SAPI_POST_HANDLER_BUFSIZ 16384\n#else\n# define SAPI_POST_HANDLER_BUFSIZ BUFSIZ\n#endif\nSAPI_API SAPI_POST_HANDLER_FUNC(php_std_post_handler)\n{\n\tzval *arr = (zval *) arg;\n\tphp_stream *s = SG(request_info).request_body;\n\tpost_var_data_t post_data;\n\n\tif (s && SUCCESS == php_stream_rewind(s)) {\n\t\tmemset(&post_data, 0, sizeof(post_data));\n\n\t\twhile (!php_stream_eof(s)) {\n\t\t\tchar buf[SAPI_POST_HANDLER_BUFSIZ] = {0};\n\t\t\tsize_t len = php_stream_read(s, buf, SAPI_POST_HANDLER_BUFSIZ);\n\n\t\t\tif (len && len != (size_t) -1) {\n\t\t\t\tsmart_str_appendl(&post_data.str, buf, len);\n\n\t\t\t\tif (SUCCESS != add_post_vars(arr, &post_data, 0 TSRMLS_CC)) {\n\t\t\t\t\tif (post_data.str.c) {\n\t\t\t\t\t\tefree(post_data.str.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (len != SAPI_POST_HANDLER_BUFSIZ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tadd_post_vars(arr, &post_data, 1 TSRMLS_CC);\n\t\tif (post_data.str.c) {\n\t\t\tefree(post_data.str.c);\n\t\t}\n\t}\n}\n#undef SAPI_POST_HANDLER_BUFSIZ\n\nSAPI_API SAPI_INPUT_FILTER_FUNC(php_default_input_filter)\n{\n\t/* TODO: check .ini setting here and apply user-defined input filter */\n\tif(new_val_len) *new_val_len = val_len;\n\treturn 1;\n}\n\nSAPI_API SAPI_TREAT_DATA_FUNC(php_default_treat_data)\n{\n\tchar *res = NULL, *var, *val, *separator = NULL;\n\tconst char *c_var;\n\tzval *array_ptr;\n\tint free_buffer = 0;\n\tchar *strtok_buf = NULL;\n\tlong count = 0;\n\n\tswitch (arg) {\n\t\tcase PARSE_POST:\n\t\tcase PARSE_GET:\n\t\tcase PARSE_COOKIE:\n\t\t\tALLOC_ZVAL(array_ptr);\n\t\t\tarray_init(array_ptr);\n\t\t\tINIT_PZVAL(array_ptr);\n\t\t\tswitch (arg) {\n\t\t\t\tcase PARSE_POST:\n\t\t\t\t\tif (PG(http_globals)[TRACK_VARS_POST]) {\n\t\t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_POST]);\n\t\t\t\t\t}\n\t\t\t\t\tPG(http_globals)[TRACK_VARS_POST] = array_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARSE_GET:\n\t\t\t\t\tif (PG(http_globals)[TRACK_VARS_GET]) {\n\t\t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);\n\t\t\t\t\t}\n\t\t\t\t\tPG(http_globals)[TRACK_VARS_GET] = array_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARSE_COOKIE:\n\t\t\t\t\tif (PG(http_globals)[TRACK_VARS_COOKIE]) {\n\t\t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_COOKIE]);\n\t\t\t\t\t}\n\t\t\t\t\tPG(http_globals)[TRACK_VARS_COOKIE] = array_ptr;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarray_ptr = destArray;\n\t\t\tbreak;\n\t}\n\n\tif (arg == PARSE_POST) {\n\t\tsapi_handle_post(array_ptr TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tif (arg == PARSE_GET) {\t\t/* GET data */\n\t\tc_var = SG(request_info).query_string;\n\t\tif (c_var && *c_var) {\n\t\t\tres = (char *) estrdup(c_var);\n\t\t\tfree_buffer = 1;\n\t\t} else {\n\t\t\tfree_buffer = 0;\n\t\t}\n\t} else if (arg == PARSE_COOKIE) {\t\t/* Cookie data */\n\t\tc_var = SG(request_info).cookie_data;\n\t\tif (c_var && *c_var) {\n\t\t\tres = (char *) estrdup(c_var);\n\t\t\tfree_buffer = 1;\n\t\t} else {\n\t\t\tfree_buffer = 0;\n\t\t}\n\t} else if (arg == PARSE_STRING) {\t\t/* String data */\n\t\tres = str;\n\t\tfree_buffer = 1;\n\t}\n\n\tif (!res) {\n\t\treturn;\n\t}\n\n\tswitch (arg) {\n\t\tcase PARSE_GET:\n\t\tcase PARSE_STRING:\n\t\t\tseparator = (char *) estrdup(PG(arg_separator).input);\n\t\t\tbreak;\n\t\tcase PARSE_COOKIE:\n\t\t\tseparator = \";\\0\";\n\t\t\tbreak;\n\t}\n\n\tvar = php_strtok_r(res, separator, &strtok_buf);\n\n\twhile (var) {\n\t\tval = strchr(var, '=');\n\n\t\tif (arg == PARSE_COOKIE) {\n\t\t\t/* Remove leading spaces from cookie names, needed for multi-cookie header where ; can be followed by a space */\n\t\t\twhile (isspace(*var)) {\n\t\t\t\tvar++;\n\t\t\t}\n\t\t\tif (var == val || *var == '\\0') {\n\t\t\t\tgoto next_cookie;\n\t\t\t}\n\t\t}\n\n\t\tif (++count > PG(max_input_vars)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Input variables exceeded %ld. To increase the limit change max_input_vars in php.ini.\", PG(max_input_vars));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val) { /* have a value */\n\t\t\tint val_len;\n\t\t\tunsigned int new_val_len;\n\n\t\t\t*val++ = '\\0';\n\t\t\tphp_url_decode(var, strlen(var));\n\t\t\tval_len = php_url_decode(val, strlen(val));\n\t\t\tval = estrndup(val, val_len);\n\t\t\tif (sapi_module.input_filter(arg, var, &val, val_len, &new_val_len TSRMLS_CC)) {\n\t\t\t\tphp_register_variable_safe(var, val, new_val_len, array_ptr TSRMLS_CC);\n\t\t\t}\n\t\t\tefree(val);\n\t\t} else {\n\t\t\tint val_len;\n\t\t\tunsigned int new_val_len;\n\n\t\t\tphp_url_decode(var, strlen(var));\n\t\t\tval_len = 0;\n\t\t\tval = estrndup(\"\", val_len);\n\t\t\tif (sapi_module.input_filter(arg, var, &val, val_len, &new_val_len TSRMLS_CC)) {\n\t\t\t\tphp_register_variable_safe(var, val, new_val_len, array_ptr TSRMLS_CC);\n\t\t\t}\n\t\t\tefree(val);\n\t\t}\nnext_cookie:\n\t\tvar = php_strtok_r(NULL, separator, &strtok_buf);\n\t}\n\n\tif (arg != PARSE_COOKIE) {\n\t\tefree(separator);\n\t}\n\n\tif (free_buffer) {\n\t\tefree(res);\n\t}\n}\n\nvoid _php_import_environment_variables(zval *array_ptr TSRMLS_DC)\n{\n\tchar buf[128];\n\tchar **env, *p, *t = buf;\n\tsize_t alloc_size = sizeof(buf);\n\tunsigned long nlen; /* ptrdiff_t is not portable */\n\n\tfor (env = environ; env != NULL && *env != NULL; env++) {\n\t\tp = strchr(*env, '=');\n\t\tif (!p) {\t\t\t\t/* malformed entry? */\n\t\t\tcontinue;\n\t\t}\n\t\tnlen = p - *env;\n\t\tif (nlen >= alloc_size) {\n\t\t\talloc_size = nlen + 64;\n\t\t\tt = (t == buf ? emalloc(alloc_size): erealloc(t, alloc_size));\n\t\t}\n\t\tmemcpy(t, *env, nlen);\n\t\tt[nlen] = '\\0';\n\t\tphp_register_variable(t, p + 1, array_ptr TSRMLS_CC);\n\t}\n\tif (t != buf && t != NULL) {\n\t\tefree(t);\n\t}\n}\n\nzend_bool php_std_auto_global_callback(char *name, uint name_len TSRMLS_DC)\n{\n\tzend_printf(\"%s\\n\", name);\n\treturn 0; /* don't rearm */\n}\n\n/* {{{ php_build_argv\n */\nstatic void php_build_argv(char *s, zval *track_vars_array TSRMLS_DC)\n{\n\tzval *arr, *argc, *tmp;\n\tint count = 0;\n\tchar *ss, *space;\n\n\tif (!(SG(request_info).argc || track_vars_array)) {\n\t\treturn;\n\t}\n\n\tALLOC_INIT_ZVAL(arr);\n\tarray_init(arr);\n\n\t/* Prepare argv */\n\tif (SG(request_info).argc) { /* are we in cli sapi? */\n\t\tint i;\n\t\tfor (i = 0; i < SG(request_info).argc; i++) {\n\t\t\tALLOC_ZVAL(tmp);\n\t\t\tZ_TYPE_P(tmp) = IS_STRING;\n\t\t\tZ_STRLEN_P(tmp) = strlen(SG(request_info).argv[i]);\n\t\t\tZ_STRVAL_P(tmp) = estrndup(SG(request_info).argv[i], Z_STRLEN_P(tmp));\n\t\t\tINIT_PZVAL(tmp);\n\t\t\tif (zend_hash_next_index_insert(Z_ARRVAL_P(arr), &tmp, sizeof(zval *), NULL) == FAILURE) {\n\t\t\t\tif (Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\tefree(Z_STRVAL_P(tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else \tif (s && *s) {\n\t\tss = s;\n\t\twhile (ss) {\n\t\t\tspace = strchr(ss, '+');\n\t\t\tif (space) {\n\t\t\t\t*space = '\\0';\n\t\t\t}\n\t\t\t/* auto-type */\n\t\t\tALLOC_ZVAL(tmp);\n\t\t\tZ_TYPE_P(tmp) = IS_STRING;\n\t\t\tZ_STRLEN_P(tmp) = strlen(ss);\n\t\t\tZ_STRVAL_P(tmp) = estrndup(ss, Z_STRLEN_P(tmp));\n\t\t\tINIT_PZVAL(tmp);\n\t\t\tcount++;\n\t\t\tif (zend_hash_next_index_insert(Z_ARRVAL_P(arr), &tmp, sizeof(zval *), NULL) == FAILURE) {\n\t\t\t\tif (Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\tefree(Z_STRVAL_P(tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (space) {\n\t\t\t\t*space = '+';\n\t\t\t\tss = space + 1;\n\t\t\t} else {\n\t\t\t\tss = space;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* prepare argc */\n\tALLOC_INIT_ZVAL(argc);\n\tif (SG(request_info).argc) {\n\t\tZ_LVAL_P(argc) = SG(request_info).argc;\n\t} else {\n\t\tZ_LVAL_P(argc) = count;\n\t}\n\tZ_TYPE_P(argc) = IS_LONG;\n\n\tif (SG(request_info).argc) {\n\t\tZ_ADDREF_P(arr);\n\t\tZ_ADDREF_P(argc);\n\t\tzend_hash_update(&EG(symbol_table), \"argv\", sizeof(\"argv\"), &arr, sizeof(zval *), NULL);\n\t\tzend_hash_update(&EG(symbol_table), \"argc\", sizeof(\"argc\"), &argc, sizeof(zval *), NULL);\n\t}\n\tif (track_vars_array) {\n\t\tZ_ADDREF_P(arr);\n\t\tZ_ADDREF_P(argc);\n\t\tzend_hash_update(Z_ARRVAL_P(track_vars_array), \"argv\", sizeof(\"argv\"), &arr, sizeof(zval *), NULL);\n\t\tzend_hash_update(Z_ARRVAL_P(track_vars_array), \"argc\", sizeof(\"argc\"), &argc, sizeof(zval *), NULL);\n\t}\n\tzval_ptr_dtor(&arr);\n\tzval_ptr_dtor(&argc);\n}\n/* }}} */\n\n/* {{{ php_register_server_variables\n */\nstatic inline void php_register_server_variables(TSRMLS_D)\n{\n\tzval *array_ptr = NULL;\n\n\tALLOC_ZVAL(array_ptr);\n\tarray_init(array_ptr);\n\tINIT_PZVAL(array_ptr);\n\tif (PG(http_globals)[TRACK_VARS_SERVER]) {\n\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_SERVER]);\n\t}\n\tPG(http_globals)[TRACK_VARS_SERVER] = array_ptr;\n\n\t/* Server variables */\n\tif (sapi_module.register_server_variables) {\n\t\tsapi_module.register_server_variables(array_ptr TSRMLS_CC);\n\t}\n\n\t/* PHP Authentication support */\n\tif (SG(request_info).auth_user) {\n\t\tphp_register_variable(\"PHP_AUTH_USER\", SG(request_info).auth_user, array_ptr TSRMLS_CC);\n\t}\n\tif (SG(request_info).auth_password) {\n\t\tphp_register_variable(\"PHP_AUTH_PW\", SG(request_info).auth_password, array_ptr TSRMLS_CC);\n\t}\n\tif (SG(request_info).auth_digest) {\n\t\tphp_register_variable(\"PHP_AUTH_DIGEST\", SG(request_info).auth_digest, array_ptr TSRMLS_CC);\n\t}\n\t/* store request init time */\n\t{\n\t\tzval request_time_float, request_time_long;\n\t\tZ_TYPE(request_time_float) = IS_DOUBLE;\n\t\tZ_DVAL(request_time_float) = sapi_get_request_time(TSRMLS_C);\n\t\tphp_register_variable_ex(\"REQUEST_TIME_FLOAT\", &request_time_float, array_ptr TSRMLS_CC);\n\t\tZ_TYPE(request_time_long) = IS_LONG;\n\t\tZ_LVAL(request_time_long) = zend_dval_to_lval(Z_DVAL(request_time_float));\n\t\tphp_register_variable_ex(\"REQUEST_TIME\", &request_time_long, array_ptr TSRMLS_CC);\n\t}\n\n}\n/* }}} */\n\n/* {{{ php_autoglobal_merge\n */\nstatic void php_autoglobal_merge(HashTable *dest, HashTable *src TSRMLS_DC)\n{\n\tzval **src_entry, **dest_entry;\n\tchar *string_key;\n\tuint string_key_len;\n\tulong num_key;\n\tHashPosition pos;\n\tint key_type;\n\tint globals_check = (dest == (&EG(symbol_table)));\n\n\tzend_hash_internal_pointer_reset_ex(src, &pos);\n\twhile (zend_hash_get_current_data_ex(src, (void **)&src_entry, &pos) == SUCCESS) {\n\t\tkey_type = zend_hash_get_current_key_ex(src, &string_key, &string_key_len, &num_key, 0, &pos);\n\t\tif (Z_TYPE_PP(src_entry) != IS_ARRAY\n\t\t\t|| (key_type == HASH_KEY_IS_STRING && zend_hash_find(dest, string_key, string_key_len, (void **) &dest_entry) != SUCCESS)\n\t\t\t|| (key_type == HASH_KEY_IS_LONG && zend_hash_index_find(dest, num_key, (void **)&dest_entry) != SUCCESS)\n\t\t\t|| Z_TYPE_PP(dest_entry) != IS_ARRAY\n\t\t\t) {\n\t\t\tZ_ADDREF_PP(src_entry);\n\t\t\tif (key_type == HASH_KEY_IS_STRING) {\n\t\t\t\tif (!globals_check || string_key_len != sizeof(\"GLOBALS\") || memcmp(string_key, \"GLOBALS\", sizeof(\"GLOBALS\") - 1)) {\n\t\t\t\t\tzend_hash_update(dest, string_key, string_key_len, src_entry, sizeof(zval *), NULL);\n\t\t\t\t} else {\n\t\t\t\t\tZ_DELREF_PP(src_entry);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzend_hash_index_update(dest, num_key, src_entry, sizeof(zval *), NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tSEPARATE_ZVAL(dest_entry);\n\t\t\tphp_autoglobal_merge(Z_ARRVAL_PP(dest_entry), Z_ARRVAL_PP(src_entry) TSRMLS_CC);\n\t\t}\n\t\tzend_hash_move_forward_ex(src, &pos);\n\t}\n}\n/* }}} */\n\nstatic zend_bool php_auto_globals_create_server(const char *name, uint name_len TSRMLS_DC);\nstatic zend_bool php_auto_globals_create_env(const char *name, uint name_len TSRMLS_DC);\nstatic zend_bool php_auto_globals_create_request(const char *name, uint name_len TSRMLS_DC);\n\n/* {{{ php_hash_environment\n */\nPHPAPI int php_hash_environment(TSRMLS_D)\n{\n\tmemset(PG(http_globals), 0, sizeof(PG(http_globals)));\n\tzend_activate_auto_globals(TSRMLS_C);\n\tif (PG(register_argc_argv)) {\n\t\tphp_build_argv(SG(request_info).query_string, PG(http_globals)[TRACK_VARS_SERVER] TSRMLS_CC);\n\t}\n\treturn SUCCESS;\n}\n/* }}} */\n\nstatic zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {\n\t\tsapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_GET];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_GET]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_GET] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_post(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(variables_order) &&\n\t\t\t(strchr(PG(variables_order),'P') || strchr(PG(variables_order),'p')) &&\n\t\tSG(request_info).request_method &&\n\t\t!strcasecmp(SG(request_info).request_method, \"POST\")) {\n\t\tsapi_module.treat_data(PARSE_POST, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_POST];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_POST]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_POST]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_POST] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_cookie(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(variables_order) && (strchr(PG(variables_order),'C') || strchr(PG(variables_order),'c'))) {\n\t\tsapi_module.treat_data(PARSE_COOKIE, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_COOKIE];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_COOKIE]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_COOKIE]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_COOKIE] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_files(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(http_globals)[TRACK_VARS_FILES]) {\n\t\tvars = PG(http_globals)[TRACK_VARS_FILES];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tPG(http_globals)[TRACK_VARS_FILES] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\n\treturn 0; /* don't rearm */\n}\n\n/* Upgly hack to fix HTTP_PROXY issue, see bug #72573 */\nstatic void check_http_proxy(HashTable *var_table)\n{\n\tif (zend_hash_exists(var_table, \"HTTP_PROXY\", sizeof(\"HTTP_PROXY\"))) {\n\t\tchar *local_proxy = getenv(\"HTTP_PROXY\");\n\n\t\tif (!local_proxy) {\n\t\t\tzend_hash_del(var_table, \"HTTP_PROXY\", sizeof(\"HTTP_PROXY\"));\n\t\t} else {\n\t\t\tzval *local_zval;\n\t\t\tALLOC_INIT_ZVAL(local_zval);\n\t\t\tZVAL_STRING(local_zval, local_proxy, 1);\n\t\t\tzend_hash_update(var_table, \"HTTP_PROXY\", sizeof(\"HTTP_PROXY\"), &local_zval, sizeof(zval **), NULL);\n\t\t}\n\t}\n}\n\nstatic zend_bool php_auto_globals_create_server(const char *name, uint name_len TSRMLS_DC)\n{\n\tif (PG(variables_order) && (strchr(PG(variables_order),'S') || strchr(PG(variables_order),'s'))) {\n\t\tphp_register_server_variables(TSRMLS_C);\n\n\t\tif (PG(register_argc_argv)) {\n\t\t\tif (SG(request_info).argc) {\n\t\t\t\tzval **argc, **argv;\n\n\t\t\t\tif (zend_hash_find(&EG(symbol_table), \"argc\", sizeof(\"argc\"), (void**)&argc) == SUCCESS &&\n\t\t\t\t\tzend_hash_find(&EG(symbol_table), \"argv\", sizeof(\"argv\"), (void**)&argv) == SUCCESS) {\n\t\t\t\t\tZ_ADDREF_PP(argc);\n\t\t\t\t\tZ_ADDREF_PP(argv);\n\t\t\t\t\tzend_hash_update(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]), \"argv\", sizeof(\"argv\"), argv, sizeof(zval *), NULL);\n\t\t\t\t\tzend_hash_update(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]), \"argc\", sizeof(\"argc\"), argc, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_build_argv(SG(request_info).query_string, PG(http_globals)[TRACK_VARS_SERVER] TSRMLS_CC);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tzval *server_vars=NULL;\n\t\tALLOC_ZVAL(server_vars);\n\t\tarray_init(server_vars);\n\t\tINIT_PZVAL(server_vars);\n\t\tif (PG(http_globals)[TRACK_VARS_SERVER]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_SERVER]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_SERVER] = server_vars;\n\t}\n\n\tcheck_http_proxy(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]));\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &PG(http_globals)[TRACK_VARS_SERVER], sizeof(zval *), NULL);\n\tZ_ADDREF_P(PG(http_globals)[TRACK_VARS_SERVER]);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_env(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *env_vars = NULL;\n\tALLOC_ZVAL(env_vars);\n\tarray_init(env_vars);\n\tINIT_PZVAL(env_vars);\n\tif (PG(http_globals)[TRACK_VARS_ENV]) {\n\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_ENV]);\n\t}\n\tPG(http_globals)[TRACK_VARS_ENV] = env_vars;\n\n\tif (PG(variables_order) && (strchr(PG(variables_order),'E') || strchr(PG(variables_order),'e'))) {\n\t\tphp_import_environment_variables(PG(http_globals)[TRACK_VARS_ENV] TSRMLS_CC);\n\t}\n\n\tcheck_http_proxy(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_ENV]));\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &PG(http_globals)[TRACK_VARS_ENV], sizeof(zval *), NULL);\n\tZ_ADDREF_P(PG(http_globals)[TRACK_VARS_ENV]);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_request(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *form_variables;\n\tunsigned char _gpc_flags[3] = {0, 0, 0};\n\tchar *p;\n\n\tALLOC_ZVAL(form_variables);\n\tarray_init(form_variables);\n\tINIT_PZVAL(form_variables);\n\n\tif (PG(request_order) != NULL) {\n\t\tp = PG(request_order);\n\t} else {\n\t\tp = PG(variables_order);\n\t}\n\n\tfor (; p && *p; p++) {\n\t\tswitch (*p) {\n\t\t\tcase 'g':\n\t\t\tcase 'G':\n\t\t\t\tif (!_gpc_flags[0]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_GET]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[0] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\tcase 'P':\n\t\t\t\tif (!_gpc_flags[1]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_POST]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[1] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\tif (!_gpc_flags[2]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_COOKIE]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[2] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &form_variables, sizeof(zval *), NULL);\n\treturn 0;\n}\n\nvoid php_startup_auto_globals(TSRMLS_D)\n{\n\tzend_register_auto_global(ZEND_STRL(\"_GET\"), 0, php_auto_globals_create_get TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_POST\"), 0, php_auto_globals_create_post TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_COOKIE\"), 0, php_auto_globals_create_cookie TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_SERVER\"), PG(auto_globals_jit), php_auto_globals_create_server TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_ENV\"), PG(auto_globals_jit), php_auto_globals_create_env TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_REQUEST\"), PG(auto_globals_jit), php_auto_globals_create_request TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_FILES\"), 0, php_auto_globals_create_files TSRMLS_CC);\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2016 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Rasmus Lerdorf <rasmus@lerdorf.on.ca>                       |\n   |          Zeev Suraski <zeev@zend.com>                                |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n#include <stdio.h>\n#include \"php.h\"\n#include \"ext/standard/php_standard.h\"\n#include \"ext/standard/credits.h\"\n#include \"ext/standard/php_smart_str.h\"\n#include \"php_variables.h\"\n#include \"php_globals.h\"\n#include \"php_content_types.h\"\n#include \"SAPI.h\"\n#include \"zend_globals.h\"\n#ifdef PHP_WIN32\n# include \"win32/php_inttypes.h\"\n#endif\n\n/* for systems that need to override reading of environment variables */\nvoid _php_import_environment_variables(zval *array_ptr TSRMLS_DC);\nPHPAPI void (*php_import_environment_variables)(zval *array_ptr TSRMLS_DC) = _php_import_environment_variables;\n\nPHPAPI void php_register_variable(char *var, char *strval, zval *track_vars_array TSRMLS_DC)\n{\n\tphp_register_variable_safe(var, strval, strlen(strval), track_vars_array TSRMLS_CC);\n}\n\n/* binary-safe version */\nPHPAPI void php_register_variable_safe(char *var, char *strval, int str_len, zval *track_vars_array TSRMLS_DC)\n{\n\tzval new_entry;\n\tassert(strval != NULL);\n\n\t/* Prepare value */\n\tZ_STRLEN(new_entry) = str_len;\n\tZ_STRVAL(new_entry) = estrndup(strval, Z_STRLEN(new_entry));\n\tZ_TYPE(new_entry) = IS_STRING;\n\n\tphp_register_variable_ex(var, &new_entry, track_vars_array TSRMLS_CC);\n}\n\nPHPAPI void php_register_variable_ex(char *var_name, zval *val, zval *track_vars_array TSRMLS_DC)\n{\n\tchar *p = NULL;\n\tchar *ip = NULL;\t\t/* index pointer */\n\tchar *index;\n\tchar *var, *var_orig;\n\tint var_len, index_len;\n\tzval *gpc_element, **gpc_element_p;\n\tzend_bool is_array = 0;\n\tHashTable *symtable1 = NULL;\n\tALLOCA_FLAG(use_heap)\n\n\tassert(var_name != NULL);\n\n\tif (track_vars_array) {\n\t\tsymtable1 = Z_ARRVAL_P(track_vars_array);\n\t}\n\n\tif (!symtable1) {\n\t\t/* Nothing to do */\n\t\tzval_dtor(val);\n\t\treturn;\n\t}\n\n\n\t/* ignore leading spaces in the variable name */\n\twhile (*var_name && *var_name==' ') {\n\t\tvar_name++;\n\t}\n\n\t/*\n\t * Prepare variable name\n\t */\n\tvar_len = strlen(var_name);\n\tvar = var_orig = do_alloca(var_len + 1, use_heap);\n\tmemcpy(var_orig, var_name, var_len + 1);\n\n\t/* ensure that we don't have spaces or dots in the variable name (not binary safe) */\n\tfor (p = var; *p; p++) {\n\t\tif (*p == ' ' || *p == '.') {\n\t\t\t*p='_';\n\t\t} else if (*p == '[') {\n\t\t\tis_array = 1;\n\t\t\tip = p;\n\t\t\t*p = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvar_len = p - var;\n\n\tif (var_len==0) { /* empty variable name, or variable name with a space in it */\n\t\tzval_dtor(val);\n\t\tfree_alloca(var_orig, use_heap);\n\t\treturn;\n\t}\n\n\t/* GLOBALS hijack attempt, reject parameter */\n\tif (symtable1 == EG(active_symbol_table) &&\n\t\tvar_len == sizeof(\"GLOBALS\")-1 &&\n\t\t!memcmp(var, \"GLOBALS\", sizeof(\"GLOBALS\")-1)) {\n\t\tzval_dtor(val);\n\t\tfree_alloca(var_orig, use_heap);\n\t\treturn;\n\t}\n\n\tindex = var;\n\tindex_len = var_len;\n\n\tif (is_array) {\n\t\tint nest_level = 0;\n\t\twhile (1) {\n\t\t\tchar *index_s;\n\t\t\tint new_idx_len = 0;\n\n\t\t\tif(++nest_level > PG(max_input_nesting_level)) {\n\t\t\t\tHashTable *ht;\n\t\t\t\t/* too many levels of nesting */\n\n\t\t\t\tif (track_vars_array) {\n\t\t\t\t\tht = Z_ARRVAL_P(track_vars_array);\n\t\t\t\t\tzend_symtable_del(ht, var, var_len + 1);\n\t\t\t\t}\n\n\t\t\t\tzval_dtor(val);\n\n\t\t\t\t/* do not output the error message to the screen,\n\t\t\t\t this helps us to to avoid \"information disclosure\" */\n\t\t\t\tif (!PG(display_errors)) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Input variable nesting level exceeded %ld. To increase the limit change max_input_nesting_level in php.ini.\", PG(max_input_nesting_level));\n\t\t\t\t}\n\t\t\t\tfree_alloca(var_orig, use_heap);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tip++;\n\t\t\tindex_s = ip;\n\t\t\tif (isspace(*ip)) {\n\t\t\t\tip++;\n\t\t\t}\n\t\t\tif (*ip==']') {\n\t\t\t\tindex_s = NULL;\n\t\t\t} else {\n\t\t\t\tip = strchr(ip, ']');\n\t\t\t\tif (!ip) {\n\t\t\t\t\t/* PHP variables cannot contain '[' in their names, so we replace the character with a '_' */\n\t\t\t\t\t*(index_s - 1) = '_';\n\n\t\t\t\t\tindex_len = 0;\n\t\t\t\t\tif (index) {\n\t\t\t\t\t\tindex_len = strlen(index);\n\t\t\t\t\t}\n\t\t\t\t\tgoto plain_var;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t*ip = 0;\n\t\t\t\tnew_idx_len = strlen(index_s);\n\t\t\t}\n\n\t\t\tif (!index) {\n\t\t\t\tMAKE_STD_ZVAL(gpc_element);\n\t\t\t\tarray_init(gpc_element);\n\t\t\t\tif (zend_hash_next_index_insert(symtable1, &gpc_element, sizeof(zval *), (void **) &gpc_element_p) == FAILURE) {\n\t\t\t\t\tzval_ptr_dtor(&gpc_element);\n\t\t\t\t\tzval_dtor(val);\n\t\t\t\t\tfree_alloca(var_orig, use_heap);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (zend_symtable_find(symtable1, index, index_len + 1, (void **) &gpc_element_p) == FAILURE\n\t\t\t\t\t|| Z_TYPE_PP(gpc_element_p) != IS_ARRAY) {\n\t\t\t\t\tMAKE_STD_ZVAL(gpc_element);\n\t\t\t\t\tarray_init(gpc_element);\n\t\t\t\t\tzend_symtable_update(symtable1, index, index_len + 1, &gpc_element, sizeof(zval *), (void **) &gpc_element_p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymtable1 = Z_ARRVAL_PP(gpc_element_p);\n\t\t\t/* ip pointed to the '[' character, now obtain the key */\n\t\t\tindex = index_s;\n\t\t\tindex_len = new_idx_len;\n\n\t\t\tip++;\n\t\t\tif (*ip == '[') {\n\t\t\t\tis_array = 1;\n\t\t\t\t*ip = 0;\n\t\t\t} else {\n\t\t\t\tgoto plain_var;\n\t\t\t}\n\t\t}\n\t} else {\nplain_var:\n\t\tMAKE_STD_ZVAL(gpc_element);\n\t\tgpc_element->value = val->value;\n\t\tZ_TYPE_P(gpc_element) = Z_TYPE_P(val);\n\t\tif (!index) {\n\t\t\tif (zend_hash_next_index_insert(symtable1, &gpc_element, sizeof(zval *), (void **) &gpc_element_p) == FAILURE) {\n\t\t\t\tzval_ptr_dtor(&gpc_element);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * According to rfc2965, more specific paths are listed above the less specific ones.\n\t\t\t * If we encounter a duplicate cookie name, we should skip it, since it is not possible\n\t\t\t * to have the same (plain text) cookie name for the same path and we should not overwrite\n\t\t\t * more specific cookies with the less specific ones.\n\t\t\t */\n\t\t\tif (PG(http_globals)[TRACK_VARS_COOKIE] &&\n\t\t\t\tsymtable1 == Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_COOKIE]) &&\n\t\t\t\tzend_symtable_exists(symtable1, index, index_len + 1)) {\n\t\t\t\tzval_ptr_dtor(&gpc_element);\n\t\t\t} else {\n\t\t\t\tzend_symtable_update(symtable1, index, index_len + 1, &gpc_element, sizeof(zval *), (void **) &gpc_element_p);\n\t\t\t}\n\t\t}\n\t}\n\tfree_alloca(var_orig, use_heap);\n}\n\ntypedef struct post_var_data {\n\tsmart_str str;\n\tchar *ptr;\n\tchar *end;\n\tuint64_t cnt;\n\n\t/* Bytes in ptr that have already been scanned for '&' */\n\tsize_t already_scanned;\n} post_var_data_t;\n\nstatic zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *start, *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\t/* FIXME: string-size_t */\n\tunsigned int new_vlen;\n\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\n\tstart = var->ptr + var->already_scanned;\n\tvsep = memchr(start, '&', var->end - start);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\tvar->already_scanned = var->end - var->ptr;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\t/* \"foo=bar&\" or \"foo=&\" */\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\t/* \"foo&\" */\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\n\tphp_url_decode(var->ptr, klen);\n\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n\tefree(val);\n\n\tvar->ptr = vsep + (vsep != var->end);\n\tvar->already_scanned = 0;\n\treturn 1;\n}\n\nstatic inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (!eof && vars->str.c != vars->ptr) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}\n\n#ifdef PHP_WIN32\n#define SAPI_POST_HANDLER_BUFSIZ 16384\n#else\n# define SAPI_POST_HANDLER_BUFSIZ BUFSIZ\n#endif\nSAPI_API SAPI_POST_HANDLER_FUNC(php_std_post_handler)\n{\n\tzval *arr = (zval *) arg;\n\tphp_stream *s = SG(request_info).request_body;\n\tpost_var_data_t post_data;\n\n\tif (s && SUCCESS == php_stream_rewind(s)) {\n\t\tmemset(&post_data, 0, sizeof(post_data));\n\n\t\twhile (!php_stream_eof(s)) {\n\t\t\tchar buf[SAPI_POST_HANDLER_BUFSIZ] = {0};\n\t\t\tsize_t len = php_stream_read(s, buf, SAPI_POST_HANDLER_BUFSIZ);\n\n\t\t\tif (len && len != (size_t) -1) {\n\t\t\t\tsmart_str_appendl(&post_data.str, buf, len);\n\n\t\t\t\tif (SUCCESS != add_post_vars(arr, &post_data, 0 TSRMLS_CC)) {\n\t\t\t\t\tif (post_data.str.c) {\n\t\t\t\t\t\tefree(post_data.str.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (len != SAPI_POST_HANDLER_BUFSIZ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tadd_post_vars(arr, &post_data, 1 TSRMLS_CC);\n\t\tif (post_data.str.c) {\n\t\t\tefree(post_data.str.c);\n\t\t}\n\t}\n}\n#undef SAPI_POST_HANDLER_BUFSIZ\n\nSAPI_API SAPI_INPUT_FILTER_FUNC(php_default_input_filter)\n{\n\t/* TODO: check .ini setting here and apply user-defined input filter */\n\tif(new_val_len) *new_val_len = val_len;\n\treturn 1;\n}\n\nSAPI_API SAPI_TREAT_DATA_FUNC(php_default_treat_data)\n{\n\tchar *res = NULL, *var, *val, *separator = NULL;\n\tconst char *c_var;\n\tzval *array_ptr;\n\tint free_buffer = 0;\n\tchar *strtok_buf = NULL;\n\tlong count = 0;\n\n\tswitch (arg) {\n\t\tcase PARSE_POST:\n\t\tcase PARSE_GET:\n\t\tcase PARSE_COOKIE:\n\t\t\tALLOC_ZVAL(array_ptr);\n\t\t\tarray_init(array_ptr);\n\t\t\tINIT_PZVAL(array_ptr);\n\t\t\tswitch (arg) {\n\t\t\t\tcase PARSE_POST:\n\t\t\t\t\tif (PG(http_globals)[TRACK_VARS_POST]) {\n\t\t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_POST]);\n\t\t\t\t\t}\n\t\t\t\t\tPG(http_globals)[TRACK_VARS_POST] = array_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARSE_GET:\n\t\t\t\t\tif (PG(http_globals)[TRACK_VARS_GET]) {\n\t\t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);\n\t\t\t\t\t}\n\t\t\t\t\tPG(http_globals)[TRACK_VARS_GET] = array_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARSE_COOKIE:\n\t\t\t\t\tif (PG(http_globals)[TRACK_VARS_COOKIE]) {\n\t\t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_COOKIE]);\n\t\t\t\t\t}\n\t\t\t\t\tPG(http_globals)[TRACK_VARS_COOKIE] = array_ptr;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarray_ptr = destArray;\n\t\t\tbreak;\n\t}\n\n\tif (arg == PARSE_POST) {\n\t\tsapi_handle_post(array_ptr TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tif (arg == PARSE_GET) {\t\t/* GET data */\n\t\tc_var = SG(request_info).query_string;\n\t\tif (c_var && *c_var) {\n\t\t\tres = (char *) estrdup(c_var);\n\t\t\tfree_buffer = 1;\n\t\t} else {\n\t\t\tfree_buffer = 0;\n\t\t}\n\t} else if (arg == PARSE_COOKIE) {\t\t/* Cookie data */\n\t\tc_var = SG(request_info).cookie_data;\n\t\tif (c_var && *c_var) {\n\t\t\tres = (char *) estrdup(c_var);\n\t\t\tfree_buffer = 1;\n\t\t} else {\n\t\t\tfree_buffer = 0;\n\t\t}\n\t} else if (arg == PARSE_STRING) {\t\t/* String data */\n\t\tres = str;\n\t\tfree_buffer = 1;\n\t}\n\n\tif (!res) {\n\t\treturn;\n\t}\n\n\tswitch (arg) {\n\t\tcase PARSE_GET:\n\t\tcase PARSE_STRING:\n\t\t\tseparator = (char *) estrdup(PG(arg_separator).input);\n\t\t\tbreak;\n\t\tcase PARSE_COOKIE:\n\t\t\tseparator = \";\\0\";\n\t\t\tbreak;\n\t}\n\n\tvar = php_strtok_r(res, separator, &strtok_buf);\n\n\twhile (var) {\n\t\tval = strchr(var, '=');\n\n\t\tif (arg == PARSE_COOKIE) {\n\t\t\t/* Remove leading spaces from cookie names, needed for multi-cookie header where ; can be followed by a space */\n\t\t\twhile (isspace(*var)) {\n\t\t\t\tvar++;\n\t\t\t}\n\t\t\tif (var == val || *var == '\\0') {\n\t\t\t\tgoto next_cookie;\n\t\t\t}\n\t\t}\n\n\t\tif (++count > PG(max_input_vars)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Input variables exceeded %ld. To increase the limit change max_input_vars in php.ini.\", PG(max_input_vars));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (val) { /* have a value */\n\t\t\tint val_len;\n\t\t\tunsigned int new_val_len;\n\n\t\t\t*val++ = '\\0';\n\t\t\tphp_url_decode(var, strlen(var));\n\t\t\tval_len = php_url_decode(val, strlen(val));\n\t\t\tval = estrndup(val, val_len);\n\t\t\tif (sapi_module.input_filter(arg, var, &val, val_len, &new_val_len TSRMLS_CC)) {\n\t\t\t\tphp_register_variable_safe(var, val, new_val_len, array_ptr TSRMLS_CC);\n\t\t\t}\n\t\t\tefree(val);\n\t\t} else {\n\t\t\tint val_len;\n\t\t\tunsigned int new_val_len;\n\n\t\t\tphp_url_decode(var, strlen(var));\n\t\t\tval_len = 0;\n\t\t\tval = estrndup(\"\", val_len);\n\t\t\tif (sapi_module.input_filter(arg, var, &val, val_len, &new_val_len TSRMLS_CC)) {\n\t\t\t\tphp_register_variable_safe(var, val, new_val_len, array_ptr TSRMLS_CC);\n\t\t\t}\n\t\t\tefree(val);\n\t\t}\nnext_cookie:\n\t\tvar = php_strtok_r(NULL, separator, &strtok_buf);\n\t}\n\n\tif (arg != PARSE_COOKIE) {\n\t\tefree(separator);\n\t}\n\n\tif (free_buffer) {\n\t\tefree(res);\n\t}\n}\n\nvoid _php_import_environment_variables(zval *array_ptr TSRMLS_DC)\n{\n\tchar buf[128];\n\tchar **env, *p, *t = buf;\n\tsize_t alloc_size = sizeof(buf);\n\tunsigned long nlen; /* ptrdiff_t is not portable */\n\n\tfor (env = environ; env != NULL && *env != NULL; env++) {\n\t\tp = strchr(*env, '=');\n\t\tif (!p) {\t\t\t\t/* malformed entry? */\n\t\t\tcontinue;\n\t\t}\n\t\tnlen = p - *env;\n\t\tif (nlen >= alloc_size) {\n\t\t\talloc_size = nlen + 64;\n\t\t\tt = (t == buf ? emalloc(alloc_size): erealloc(t, alloc_size));\n\t\t}\n\t\tmemcpy(t, *env, nlen);\n\t\tt[nlen] = '\\0';\n\t\tphp_register_variable(t, p + 1, array_ptr TSRMLS_CC);\n\t}\n\tif (t != buf && t != NULL) {\n\t\tefree(t);\n\t}\n}\n\nzend_bool php_std_auto_global_callback(char *name, uint name_len TSRMLS_DC)\n{\n\tzend_printf(\"%s\\n\", name);\n\treturn 0; /* don't rearm */\n}\n\n/* {{{ php_build_argv\n */\nstatic void php_build_argv(char *s, zval *track_vars_array TSRMLS_DC)\n{\n\tzval *arr, *argc, *tmp;\n\tint count = 0;\n\tchar *ss, *space;\n\n\tif (!(SG(request_info).argc || track_vars_array)) {\n\t\treturn;\n\t}\n\n\tALLOC_INIT_ZVAL(arr);\n\tarray_init(arr);\n\n\t/* Prepare argv */\n\tif (SG(request_info).argc) { /* are we in cli sapi? */\n\t\tint i;\n\t\tfor (i = 0; i < SG(request_info).argc; i++) {\n\t\t\tALLOC_ZVAL(tmp);\n\t\t\tZ_TYPE_P(tmp) = IS_STRING;\n\t\t\tZ_STRLEN_P(tmp) = strlen(SG(request_info).argv[i]);\n\t\t\tZ_STRVAL_P(tmp) = estrndup(SG(request_info).argv[i], Z_STRLEN_P(tmp));\n\t\t\tINIT_PZVAL(tmp);\n\t\t\tif (zend_hash_next_index_insert(Z_ARRVAL_P(arr), &tmp, sizeof(zval *), NULL) == FAILURE) {\n\t\t\t\tif (Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\tefree(Z_STRVAL_P(tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else \tif (s && *s) {\n\t\tss = s;\n\t\twhile (ss) {\n\t\t\tspace = strchr(ss, '+');\n\t\t\tif (space) {\n\t\t\t\t*space = '\\0';\n\t\t\t}\n\t\t\t/* auto-type */\n\t\t\tALLOC_ZVAL(tmp);\n\t\t\tZ_TYPE_P(tmp) = IS_STRING;\n\t\t\tZ_STRLEN_P(tmp) = strlen(ss);\n\t\t\tZ_STRVAL_P(tmp) = estrndup(ss, Z_STRLEN_P(tmp));\n\t\t\tINIT_PZVAL(tmp);\n\t\t\tcount++;\n\t\t\tif (zend_hash_next_index_insert(Z_ARRVAL_P(arr), &tmp, sizeof(zval *), NULL) == FAILURE) {\n\t\t\t\tif (Z_TYPE_P(tmp) == IS_STRING) {\n\t\t\t\t\tefree(Z_STRVAL_P(tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (space) {\n\t\t\t\t*space = '+';\n\t\t\t\tss = space + 1;\n\t\t\t} else {\n\t\t\t\tss = space;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* prepare argc */\n\tALLOC_INIT_ZVAL(argc);\n\tif (SG(request_info).argc) {\n\t\tZ_LVAL_P(argc) = SG(request_info).argc;\n\t} else {\n\t\tZ_LVAL_P(argc) = count;\n\t}\n\tZ_TYPE_P(argc) = IS_LONG;\n\n\tif (SG(request_info).argc) {\n\t\tZ_ADDREF_P(arr);\n\t\tZ_ADDREF_P(argc);\n\t\tzend_hash_update(&EG(symbol_table), \"argv\", sizeof(\"argv\"), &arr, sizeof(zval *), NULL);\n\t\tzend_hash_update(&EG(symbol_table), \"argc\", sizeof(\"argc\"), &argc, sizeof(zval *), NULL);\n\t}\n\tif (track_vars_array) {\n\t\tZ_ADDREF_P(arr);\n\t\tZ_ADDREF_P(argc);\n\t\tzend_hash_update(Z_ARRVAL_P(track_vars_array), \"argv\", sizeof(\"argv\"), &arr, sizeof(zval *), NULL);\n\t\tzend_hash_update(Z_ARRVAL_P(track_vars_array), \"argc\", sizeof(\"argc\"), &argc, sizeof(zval *), NULL);\n\t}\n\tzval_ptr_dtor(&arr);\n\tzval_ptr_dtor(&argc);\n}\n/* }}} */\n\n/* {{{ php_register_server_variables\n */\nstatic inline void php_register_server_variables(TSRMLS_D)\n{\n\tzval *array_ptr = NULL;\n\n\tALLOC_ZVAL(array_ptr);\n\tarray_init(array_ptr);\n\tINIT_PZVAL(array_ptr);\n\tif (PG(http_globals)[TRACK_VARS_SERVER]) {\n\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_SERVER]);\n\t}\n\tPG(http_globals)[TRACK_VARS_SERVER] = array_ptr;\n\n\t/* Server variables */\n\tif (sapi_module.register_server_variables) {\n\t\tsapi_module.register_server_variables(array_ptr TSRMLS_CC);\n\t}\n\n\t/* PHP Authentication support */\n\tif (SG(request_info).auth_user) {\n\t\tphp_register_variable(\"PHP_AUTH_USER\", SG(request_info).auth_user, array_ptr TSRMLS_CC);\n\t}\n\tif (SG(request_info).auth_password) {\n\t\tphp_register_variable(\"PHP_AUTH_PW\", SG(request_info).auth_password, array_ptr TSRMLS_CC);\n\t}\n\tif (SG(request_info).auth_digest) {\n\t\tphp_register_variable(\"PHP_AUTH_DIGEST\", SG(request_info).auth_digest, array_ptr TSRMLS_CC);\n\t}\n\t/* store request init time */\n\t{\n\t\tzval request_time_float, request_time_long;\n\t\tZ_TYPE(request_time_float) = IS_DOUBLE;\n\t\tZ_DVAL(request_time_float) = sapi_get_request_time(TSRMLS_C);\n\t\tphp_register_variable_ex(\"REQUEST_TIME_FLOAT\", &request_time_float, array_ptr TSRMLS_CC);\n\t\tZ_TYPE(request_time_long) = IS_LONG;\n\t\tZ_LVAL(request_time_long) = zend_dval_to_lval(Z_DVAL(request_time_float));\n\t\tphp_register_variable_ex(\"REQUEST_TIME\", &request_time_long, array_ptr TSRMLS_CC);\n\t}\n\n}\n/* }}} */\n\n/* {{{ php_autoglobal_merge\n */\nstatic void php_autoglobal_merge(HashTable *dest, HashTable *src TSRMLS_DC)\n{\n\tzval **src_entry, **dest_entry;\n\tchar *string_key;\n\tuint string_key_len;\n\tulong num_key;\n\tHashPosition pos;\n\tint key_type;\n\tint globals_check = (dest == (&EG(symbol_table)));\n\n\tzend_hash_internal_pointer_reset_ex(src, &pos);\n\twhile (zend_hash_get_current_data_ex(src, (void **)&src_entry, &pos) == SUCCESS) {\n\t\tkey_type = zend_hash_get_current_key_ex(src, &string_key, &string_key_len, &num_key, 0, &pos);\n\t\tif (Z_TYPE_PP(src_entry) != IS_ARRAY\n\t\t\t|| (key_type == HASH_KEY_IS_STRING && zend_hash_find(dest, string_key, string_key_len, (void **) &dest_entry) != SUCCESS)\n\t\t\t|| (key_type == HASH_KEY_IS_LONG && zend_hash_index_find(dest, num_key, (void **)&dest_entry) != SUCCESS)\n\t\t\t|| Z_TYPE_PP(dest_entry) != IS_ARRAY\n\t\t\t) {\n\t\t\tZ_ADDREF_PP(src_entry);\n\t\t\tif (key_type == HASH_KEY_IS_STRING) {\n\t\t\t\tif (!globals_check || string_key_len != sizeof(\"GLOBALS\") || memcmp(string_key, \"GLOBALS\", sizeof(\"GLOBALS\") - 1)) {\n\t\t\t\t\tzend_hash_update(dest, string_key, string_key_len, src_entry, sizeof(zval *), NULL);\n\t\t\t\t} else {\n\t\t\t\t\tZ_DELREF_PP(src_entry);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tzend_hash_index_update(dest, num_key, src_entry, sizeof(zval *), NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tSEPARATE_ZVAL(dest_entry);\n\t\t\tphp_autoglobal_merge(Z_ARRVAL_PP(dest_entry), Z_ARRVAL_PP(src_entry) TSRMLS_CC);\n\t\t}\n\t\tzend_hash_move_forward_ex(src, &pos);\n\t}\n}\n/* }}} */\n\nstatic zend_bool php_auto_globals_create_server(const char *name, uint name_len TSRMLS_DC);\nstatic zend_bool php_auto_globals_create_env(const char *name, uint name_len TSRMLS_DC);\nstatic zend_bool php_auto_globals_create_request(const char *name, uint name_len TSRMLS_DC);\n\n/* {{{ php_hash_environment\n */\nPHPAPI int php_hash_environment(TSRMLS_D)\n{\n\tmemset(PG(http_globals), 0, sizeof(PG(http_globals)));\n\tzend_activate_auto_globals(TSRMLS_C);\n\tif (PG(register_argc_argv)) {\n\t\tphp_build_argv(SG(request_info).query_string, PG(http_globals)[TRACK_VARS_SERVER] TSRMLS_CC);\n\t}\n\treturn SUCCESS;\n}\n/* }}} */\n\nstatic zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {\n\t\tsapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_GET];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_GET]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_GET] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_post(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(variables_order) &&\n\t\t\t(strchr(PG(variables_order),'P') || strchr(PG(variables_order),'p')) &&\n\t\tSG(request_info).request_method &&\n\t\t!strcasecmp(SG(request_info).request_method, \"POST\")) {\n\t\tsapi_module.treat_data(PARSE_POST, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_POST];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_POST]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_POST]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_POST] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_cookie(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(variables_order) && (strchr(PG(variables_order),'C') || strchr(PG(variables_order),'c'))) {\n\t\tsapi_module.treat_data(PARSE_COOKIE, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_COOKIE];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_COOKIE]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_COOKIE]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_COOKIE] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_files(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(http_globals)[TRACK_VARS_FILES]) {\n\t\tvars = PG(http_globals)[TRACK_VARS_FILES];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tPG(http_globals)[TRACK_VARS_FILES] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\n\treturn 0; /* don't rearm */\n}\n\n/* Upgly hack to fix HTTP_PROXY issue, see bug #72573 */\nstatic void check_http_proxy(HashTable *var_table)\n{\n\tif (zend_hash_exists(var_table, \"HTTP_PROXY\", sizeof(\"HTTP_PROXY\"))) {\n\t\tchar *local_proxy = getenv(\"HTTP_PROXY\");\n\n\t\tif (!local_proxy) {\n\t\t\tzend_hash_del(var_table, \"HTTP_PROXY\", sizeof(\"HTTP_PROXY\"));\n\t\t} else {\n\t\t\tzval *local_zval;\n\t\t\tALLOC_INIT_ZVAL(local_zval);\n\t\t\tZVAL_STRING(local_zval, local_proxy, 1);\n\t\t\tzend_hash_update(var_table, \"HTTP_PROXY\", sizeof(\"HTTP_PROXY\"), &local_zval, sizeof(zval **), NULL);\n\t\t}\n\t}\n}\n\nstatic zend_bool php_auto_globals_create_server(const char *name, uint name_len TSRMLS_DC)\n{\n\tif (PG(variables_order) && (strchr(PG(variables_order),'S') || strchr(PG(variables_order),'s'))) {\n\t\tphp_register_server_variables(TSRMLS_C);\n\n\t\tif (PG(register_argc_argv)) {\n\t\t\tif (SG(request_info).argc) {\n\t\t\t\tzval **argc, **argv;\n\n\t\t\t\tif (zend_hash_find(&EG(symbol_table), \"argc\", sizeof(\"argc\"), (void**)&argc) == SUCCESS &&\n\t\t\t\t\tzend_hash_find(&EG(symbol_table), \"argv\", sizeof(\"argv\"), (void**)&argv) == SUCCESS) {\n\t\t\t\t\tZ_ADDREF_PP(argc);\n\t\t\t\t\tZ_ADDREF_PP(argv);\n\t\t\t\t\tzend_hash_update(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]), \"argv\", sizeof(\"argv\"), argv, sizeof(zval *), NULL);\n\t\t\t\t\tzend_hash_update(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]), \"argc\", sizeof(\"argc\"), argc, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_build_argv(SG(request_info).query_string, PG(http_globals)[TRACK_VARS_SERVER] TSRMLS_CC);\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tzval *server_vars=NULL;\n\t\tALLOC_ZVAL(server_vars);\n\t\tarray_init(server_vars);\n\t\tINIT_PZVAL(server_vars);\n\t\tif (PG(http_globals)[TRACK_VARS_SERVER]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_SERVER]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_SERVER] = server_vars;\n\t}\n\n\tcheck_http_proxy(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]));\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &PG(http_globals)[TRACK_VARS_SERVER], sizeof(zval *), NULL);\n\tZ_ADDREF_P(PG(http_globals)[TRACK_VARS_SERVER]);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_env(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *env_vars = NULL;\n\tALLOC_ZVAL(env_vars);\n\tarray_init(env_vars);\n\tINIT_PZVAL(env_vars);\n\tif (PG(http_globals)[TRACK_VARS_ENV]) {\n\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_ENV]);\n\t}\n\tPG(http_globals)[TRACK_VARS_ENV] = env_vars;\n\n\tif (PG(variables_order) && (strchr(PG(variables_order),'E') || strchr(PG(variables_order),'e'))) {\n\t\tphp_import_environment_variables(PG(http_globals)[TRACK_VARS_ENV] TSRMLS_CC);\n\t}\n\n\tcheck_http_proxy(Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_ENV]));\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &PG(http_globals)[TRACK_VARS_ENV], sizeof(zval *), NULL);\n\tZ_ADDREF_P(PG(http_globals)[TRACK_VARS_ENV]);\n\n\treturn 0; /* don't rearm */\n}\n\nstatic zend_bool php_auto_globals_create_request(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *form_variables;\n\tunsigned char _gpc_flags[3] = {0, 0, 0};\n\tchar *p;\n\n\tALLOC_ZVAL(form_variables);\n\tarray_init(form_variables);\n\tINIT_PZVAL(form_variables);\n\n\tif (PG(request_order) != NULL) {\n\t\tp = PG(request_order);\n\t} else {\n\t\tp = PG(variables_order);\n\t}\n\n\tfor (; p && *p; p++) {\n\t\tswitch (*p) {\n\t\t\tcase 'g':\n\t\t\tcase 'G':\n\t\t\t\tif (!_gpc_flags[0]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_GET]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[0] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\tcase 'P':\n\t\t\t\tif (!_gpc_flags[1]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_POST]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[1] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\tif (!_gpc_flags[2]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_COOKIE]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[2] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &form_variables, sizeof(zval *), NULL);\n\treturn 0;\n}\n\nvoid php_startup_auto_globals(TSRMLS_D)\n{\n\tzend_register_auto_global(ZEND_STRL(\"_GET\"), 0, php_auto_globals_create_get TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_POST\"), 0, php_auto_globals_create_post TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_COOKIE\"), 0, php_auto_globals_create_cookie TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_SERVER\"), PG(auto_globals_jit), php_auto_globals_create_server TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_ENV\"), PG(auto_globals_jit), php_auto_globals_create_env TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_REQUEST\"), PG(auto_globals_jit), php_auto_globals_create_request TSRMLS_CC);\n\tzend_register_auto_global(ZEND_STRL(\"_FILES\"), 0, php_auto_globals_create_files TSRMLS_CC);\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "filenames": ["main/php_variables.c"], "buggy_code_start_loc": [239], "buggy_code_end_loc": [308], "fixing_code_start_loc": [240], "fixing_code_end_loc": [314], "type": "CWE-400", "message": "In PHP before 5.6.31, 7.x before 7.0.17, and 7.1.x before 7.1.3, remote attackers could cause a CPU consumption denial of service attack by injecting long form variables, related to main/php_variables.c.", "other": {"cve": {"id": "CVE-2017-11142", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-10T14:29:00.557", "lastModified": "2018-01-14T02:29:01.150", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In PHP before 5.6.31, 7.x before 7.0.17, and 7.1.x before 7.1.3, remote attackers could cause a CPU consumption denial of service attack by injecting long form variables, related to main/php_variables.c."}, {"lang": "es", "value": "En PHP anterior a versi\u00f3n 5.6.31, versi\u00f3n 7.x anterior a 7.0.17 y versi\u00f3n 7.1.x anterior a 7.1.3, los atacantes remotos podr\u00edan causar un ataque de denegaci\u00f3n de servicio de consumo de CPU mediante la inyecci\u00f3n de variables de formulario largo, relacionadas con el archivo main/php_variables.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.6.30", "matchCriteriaId": "399EA21A-9B46-4F4F-9A33-4DC557B11743"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "DB6890AF-8A0A-46EE-AAD5-CF9AAE14A321"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "6B90B947-7B54-47F3-9637-2F4AC44079EE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "35848414-BD5D-4164-84DC-61ABBB1C4152"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "2B1F8402-8551-4F66-A9A7-81D472AB058E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "7A773E8E-48CD-4D35-A0FD-629BD9334486"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "FC492340-79AF-4676-A161-079A97EC6F0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "F1C2D8FE-C380-4B43-B634-A3DBA4700A71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "3EB58393-0C10-413C-8D95-6BAA8BC19A1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "751F51CA-9D88-4971-A6EC-8C0B72E8E22B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "37B74118-8FC2-44CB-9673-A83DF777B2E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "4D56A200-1477-40DA-9444-CFC946157C69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "FD0D1CCC-A857-4C15-899E-08F9255CEE34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "6745CC43-2836-4CD8-848F-EEA08AE9D5AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "7BEB6696-14F9-4D9B-9974-B682FFBB828E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "04146390-021D-4147-9830-9EAA90D120A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "5B124547-DC1D-4A92-B8AB-8A1900063786"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "F45B2127-CF3D-4D59-9042-AE6DF2908319"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "0C68AA43-ED90-4B98-A5F8-4E210C2CC7CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "2466D297-9442-40B0-A1A7-F9D166396CF8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:7.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "EADBF7EE-18DC-49F9-BF2F-A09BBAE76F45"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/07/10/6", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "http://php.net/ChangeLog-5.php", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://php.net/ChangeLog-7.php", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/99601", "source": "cve@mitre.org"}, {"url": "https://bugs.php.net/bug.php?id=73807", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/php/php-src/commit/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/php/php-src/commit/a15bffd105ac28fd0dd9b596632dbf035238fda3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20180112-0001/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4081", "source": "cve@mitre.org"}, {"url": "https://www.tenable.com/security/tns-2017-12", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/php/php-src/commit/0f8cf3b8497dc45c010c44ed9e96518e11e19fc3"}}