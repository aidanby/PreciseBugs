{"buggy_code": ["/* Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"jcontext.h\"\n#include \"js-parser-internal.h\"\n#include \"js-scanner-internal.h\"\n#include \"lit-char-helpers.h\"\n\n#if ENABLED (JERRY_PARSER)\n\n/** \\addtogroup parser Parser\n * @{\n *\n * \\addtogroup jsparser JavaScript\n * @{\n *\n * \\addtogroup jsparser_scanner Scanner\n * @{\n */\n\n/**\n * Scan return types.\n */\ntypedef enum\n{\n  SCAN_NEXT_TOKEN, /**< get next token after return */\n  SCAN_KEEP_TOKEN, /**< keep the current token after return */\n} scan_return_types_t;\n\n/**\n * Checks whether token type is \"of\".\n */\n#if ENABLED (JERRY_ES2015)\n#define SCANNER_IDENTIFIER_IS_OF() (lexer_token_is_identifier (context_p, \"of\", 2))\n#else\n#define SCANNER_IDENTIFIER_IS_OF() (false)\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015)\n\nJERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_GENERATOR)\n                     == SCAN_STACK_COMPUTED_GENERATOR,\n                     scanner_invalid_conversion_from_literal_pool_generator_to_computed_generator);\nJERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_ASYNC)\n                     == SCAN_STACK_COMPUTED_ASYNC,\n                     scanner_invalid_conversion_from_literal_pool_async_to_computed_async);\n\nJERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_GENERATOR)\n                     == SCANNER_LITERAL_POOL_GENERATOR,\n                     scanner_invalid_conversion_from_computed_generator_to_literal_pool_generator);\nJERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_ASYNC)\n                     == SCANNER_LITERAL_POOL_ASYNC,\n                     scanner_invalid_conversion_from_computed_async_to_literal_pool_async);\n\n#endif /* ENABLED (JERRY_ES2015) */\n\n/**\n * Scan primary expression.\n *\n * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing\n */\nstatic scan_return_types_t\nscanner_scan_primary_expression (parser_context_t *context_p, /**< context */\n                                 scanner_context_t *scanner_context_p, /* scanner context */\n                                 lexer_token_type_t type, /**< current token type */\n                                 scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_KEYW_NEW:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW;\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_try_scan_new_target (context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n    case LEXER_DIVIDE:\n    case LEXER_ASSIGN_DIVIDE:\n    {\n      lexer_construct_regexp_object (context_p, true);\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_context_p->async_source_p != NULL)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n      }\n\n      if (lexer_consume_generator (context_p))\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        lexer_next_token (context_p);\n      }\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      scanner_scan_bracket (context_p, scanner_context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_SQUARE:\n    {\n#if ENABLED (JERRY_ES2015)\n      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      break;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if ENABLED (JERRY_ES2015)\n      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n      scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n      return SCAN_KEEP_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_TEMPLATE_STRING);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        break;\n      }\n\n      /* The string is a normal string literal. */\n      /* FALLTHRU */\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_LITERAL:\n    {\n#if ENABLED (JERRY_ES2015)\n      const uint8_t *source_p = context_p->source_p;\n\n      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL\n          && lexer_check_arrow (context_p))\n      {\n        scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);\n        return SCAN_KEEP_TOKEN;\n      }\n      else if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n      {\n        scanner_context_p->async_source_p = source_p;\n        scanner_check_async_function (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        scanner_add_reference (context_p, scanner_context_p);\n      }\n      /* FALLTHRU */\n    }\n    case LEXER_KEYW_THIS:\n    case LEXER_KEYW_SUPER:\n    case LEXER_LIT_TRUE:\n    case LEXER_LIT_FALSE:\n    case LEXER_LIT_NULL:\n    {\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_CLASS:\n    {\n      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_EXPRESSION);\n\n      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        return SCAN_KEEP_TOKEN;\n      }\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_RIGHT_SQUARE:\n    {\n      if (stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_THREE_DOTS:\n    {\n      /* Elision or spread arguments */\n      if (stack_top != SCAN_STACK_PAREN_EXPRESSION && stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_COMMA:\n    {\n      if (stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n      {\n        scanner_context_p->mode = SCAN_MODE_BINDING;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_YIELD:\n    {\n      lexer_next_token (context_p);\n\n      if (lexer_check_yield_no_arg (context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      }\n\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_RIGHT_PAREN:\n    {\n      if (stack_top == SCAN_STACK_PAREN_EXPRESSION)\n      {\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        parser_stack_pop_uint8 (context_p);\n        break;\n      }\n      /* FALLTHRU */\n    }\n    default:\n    {\n      scanner_raise_error (context_p);\n    }\n  }\n  return SCAN_NEXT_TOKEN;\n} /* scanner_scan_primary_expression */\n\n/**\n * Scan the tokens after the primary expression.\n *\n * @return true for break, false for fall through\n */\nstatic bool\nscanner_scan_post_primary_expression (parser_context_t *context_p, /**< context */\n                                      scanner_context_t *scanner_context_p, /**< scanner context */\n                                      lexer_token_type_t type, /**< current token type */\n                                      scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_DOT:\n    {\n      lexer_scan_identifier (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      return true;\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (JERRY_UNLIKELY (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT))\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        parser_stack_push_uint8 (context_p, SCAN_STACK_TAGGED_TEMPLATE_LITERAL);\n      }\n      return true;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_LEFT_SQUARE:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_PROPERTY_ACCESSOR);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n    case LEXER_INCREASE:\n    case LEXER_DECREASE:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n\n      if (context_p->token.flags & LEXER_WAS_NEWLINE)\n      {\n        return false;\n      }\n\n      lexer_next_token (context_p);\n      type = (lexer_token_type_t) context_p->token.type;\n\n      if (type != LEXER_QUESTION_MARK)\n      {\n        break;\n      }\n      /* FALLTHRU */\n    }\n    case LEXER_QUESTION_MARK:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_COLON_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  if (LEXER_IS_BINARY_OP_TOKEN (type)\n      && (type != LEXER_KEYW_IN || !SCANNER_IS_FOR_START (stack_top)))\n  {\n    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n    return true;\n  }\n\n  return false;\n} /* scanner_scan_post_primary_expression */\n\n/**\n * Scan the tokens after the primary expression.\n *\n * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing\n */\nstatic scan_return_types_t\nscanner_scan_primary_expression_end (parser_context_t *context_p, /**< context */\n                                     scanner_context_t *scanner_context_p, /**< scanner context */\n                                     lexer_token_type_t type, /**< current token type */\n                                     scan_stack_modes_t stack_top) /**< current stack top */\n{\n  if (type == LEXER_COMMA)\n  {\n    switch (stack_top)\n    {\n      case SCAN_STACK_VAR:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_LET:\n      case SCAN_STACK_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCAN_STACK_FOR_VAR_START:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_FOR_LET_START:\n      case SCAN_STACK_FOR_CONST_START:\n#endif /* ENABLED (JERRY_ES2015) */\n      {\n        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_COLON_EXPRESSION:\n      {\n        scanner_raise_error (context_p);\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_BINDING_INIT:\n      case SCAN_STACK_BINDING_LIST_INIT:\n      {\n        break;\n      }\n      case SCAN_STACK_ARROW_ARGUMENTS:\n      {\n        lexer_next_token (context_p);\n        scanner_check_arrow_arg (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n      case SCAN_STACK_ARROW_EXPRESSION:\n      {\n        break;\n      }\n      case SCAN_STACK_FUNCTION_PARAMETERS:\n      {\n        scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;\n        parser_stack_pop_uint8 (context_p);\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_ARRAY_LITERAL:\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n        if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n        {\n          scanner_context_p->mode = SCAN_MODE_BINDING;\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCAN_STACK_OBJECT_LITERAL:\n      {\n        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n        return SCAN_KEEP_TOKEN;\n      }\n      default:\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n    }\n  }\n\n  switch (stack_top)\n  {\n    case SCAN_STACK_WITH_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n      uint16_t status_flags = scanner_context_p->active_literal_pool_p->status_flags;\n      parser_stack_push_uint8 (context_p, (status_flags & SCANNER_LITERAL_POOL_IN_WITH) ? 1 : 0);\n      parser_stack_push_uint8 (context_p, SCAN_STACK_WITH_STATEMENT);\n      status_flags |= SCANNER_LITERAL_POOL_IN_WITH;\n      scanner_context_p->active_literal_pool_p->status_flags = status_flags;\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_DO_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_WHILE_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_WHILE;\n\n      scanner_get_location (&location_info_p->location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_PAREN_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)\n      {\n        scanner_add_async_literal (context_p, scanner_context_p);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_STATEMENT_WITH_EXPR:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->stack_top_uint8 == SCAN_STACK_IF_STATEMENT)\n      {\n        scanner_check_function_after_if (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_BINDING_LIST_INIT:\n    {\n      parser_stack_pop_uint8 (context_p);\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_LET\n                    || context_p->stack_top_uint8 == SCAN_STACK_CONST\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS\n                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);\n\n      scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;\n\n      while (item_p != NULL)\n      {\n        if (item_p->literal_p->type & SCANNER_LITERAL_IS_USED)\n        {\n          item_p->literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n        }\n        item_p = item_p->next_p;\n      }\n\n      scanner_pop_binding_list (scanner_context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_BINDING_INIT:\n    {\n      scanner_binding_literal_t binding_literal;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_LET\n                    || context_p->stack_top_uint8 == SCAN_STACK_CONST\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS\n                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);\n\n      JERRY_ASSERT ((stack_top != SCAN_STACK_ARRAY_LITERAL && stack_top != SCAN_STACK_OBJECT_LITERAL)\n                    || SCANNER_NEEDS_BINDING_LIST (scanner_context_p->binding_type));\n\n      if (binding_literal.literal_p->type & SCANNER_LITERAL_IS_USED)\n      {\n        binding_literal.literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_VAR:\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_LET:\n    case SCAN_STACK_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n    {\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n      scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_FOR_VAR_START:\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_FOR_LET_START:\n    case SCAN_STACK_FOR_CONST_START:\n#endif /* ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_FOR_START:\n    {\n      if (type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())\n      {\n        scanner_for_statement_t for_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n        scanner_location_info_t *location_info;\n        location_info = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         for_statement.u.source_p,\n                                                                         sizeof (scanner_location_info_t));\n#if ENABLED (JERRY_ES2015)\n        location_info->info.type = (type == LEXER_KEYW_IN) ? SCANNER_TYPE_FOR_IN : SCANNER_TYPE_FOR_OF;\n\n        if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)\n        {\n          parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK_EARLY);\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        location_info->info.type = SCANNER_TYPE_FOR_IN;\n#endif /* ENABLED (JERRY_ES2015) */\n\n        scanner_get_location (&location_info->location, context_p);\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_STATEMENT_WITH_EXPR);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (type != LEXER_SEMICOLON)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, NULL, sizeof (scanner_for_statement_t));\n\n#if ENABLED (JERRY_ES2015)\n      if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      for_statement.u.source_p = context_p->source_p;\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_CONDITION);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_SEMICOLON)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      type = LEXER_SEMICOLON;\n      /* FALLTHRU */\n    }\n    case SCAN_STACK_FOR_CONDITION:\n    {\n      if (type != LEXER_SEMICOLON)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n      scanner_for_info_t *for_info_p;\n      for_info_p = (scanner_for_info_t *) scanner_insert_info (context_p,\n                                                               for_statement.u.source_p,\n                                                               sizeof (scanner_for_info_t));\n      for_info_p->info.type = SCANNER_TYPE_FOR;\n\n      scanner_get_location (&for_info_p->expression_location, context_p);\n      for_info_p->end_location.source_p = NULL;\n\n      for_statement.u.for_info_p = for_info_p;\n\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_EXPRESSION);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_RIGHT_PAREN)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      type = LEXER_RIGHT_PAREN;\n      /* FALLTHRU */\n    }\n    case SCAN_STACK_FOR_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n      scanner_get_location (&for_statement.u.for_info_p->end_location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_SWITCH_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_BRACE)\n      {\n        break;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);\n      literal_pool_p->source_p = context_p->source_p - 1;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_stack_pop_uint8 (context_p);\n\n      scanner_switch_statement_t switch_statement = scanner_context_p->active_switch_statement;\n      parser_stack_push (context_p, &switch_statement, sizeof (scanner_switch_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SWITCH_BLOCK);\n\n      scanner_switch_info_t *switch_info_p;\n      switch_info_p = (scanner_switch_info_t *) scanner_insert_info (context_p,\n                                                                     context_p->source_p,\n                                                                     sizeof (scanner_switch_info_t));\n      switch_info_p->info.type = SCANNER_TYPE_SWITCH;\n      switch_info_p->case_p = NULL;\n      scanner_context_p->active_switch_statement.last_case_p = &switch_info_p->case_p;\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_RIGHT_BRACE\n          && context_p->token.type != LEXER_KEYW_CASE\n          && context_p->token.type != LEXER_KEYW_DEFAULT)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_CASE_STATEMENT:\n    {\n      if (type != LEXER_COLON)\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_CASE;\n\n      scanner_get_location (&location_info_p->location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_COLON_EXPRESSION:\n    {\n      if (type != LEXER_COLON)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_ARRAY_LITERAL:\n    case SCAN_STACK_OBJECT_LITERAL:\n    {\n      if (((stack_top == SCAN_STACK_ARRAY_LITERAL) && (type != LEXER_RIGHT_SQUARE))\n          || ((stack_top == SCAN_STACK_OBJECT_LITERAL) && (type != LEXER_RIGHT_BRACE)))\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n      uint8_t binding_type = scanner_context_p->binding_type;\n\n      parser_stack_pop_uint8 (context_p);\n      scanner_context_p->binding_type = context_p->stack_top_uint8;\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      lexer_next_token (context_p);\n\n      if (binding_type == SCANNER_BINDING_CATCH && context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT)\n      {\n        scanner_pop_binding_list (scanner_context_p);\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (context_p->token.type != LEXER_ASSIGN)\n      {\n        if (SCANNER_NEEDS_BINDING_LIST (binding_type))\n        {\n          scanner_pop_binding_list (scanner_context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_INITIALIZER;\n      scanner_get_location (&location_info_p->location, context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      if (SCANNER_NEEDS_BINDING_LIST (binding_type))\n      {\n        scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;\n\n        while (item_p != NULL)\n        {\n          item_p->literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_USED;\n          item_p = item_p->next_p;\n        }\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_LIST_INIT);\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n#else /* !ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_ARRAY_LITERAL:\n#endif /* ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_PROPERTY_ACCESSOR:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#if !ENABLED (JERRY_ES2015)\n    case SCAN_STACK_OBJECT_LITERAL:\n    {\n      if (type != LEXER_RIGHT_BRACE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* !ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_COMPUTED_PROPERTY:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n\n      parser_stack_pop_uint8 (context_p);\n      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n\n      if (stack_top == SCAN_STACK_FUNCTION_PROPERTY)\n      {\n        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);\n\n      if (context_p->token.type == LEXER_LEFT_PAREN)\n      {\n        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      if (context_p->token.type != LEXER_COLON)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n      {\n        scanner_context_p->mode = SCAN_MODE_BINDING;\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_COMPUTED_GENERATOR:\n    case SCAN_STACK_COMPUTED_ASYNC:\n    case SCAN_STACK_COMPUTED_ASYNC_GENERATOR:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n      parser_stack_pop_uint8 (context_p);\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PROPERTY);\n\n      uint16_t status_flags = (uint16_t) (SCANNER_LITERAL_POOL_FUNCTION\n                                          | SCANNER_LITERAL_POOL_GENERATOR\n                                          | SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (stack_top));\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_TEMPLATE_STRING:\n    case SCAN_STACK_TAGGED_TEMPLATE_LITERAL:\n    {\n      if (type != LEXER_RIGHT_BRACE)\n      {\n        break;\n      }\n\n      context_p->source_p--;\n      context_p->column--;\n      lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      }\n      else\n      {\n        parser_stack_pop_uint8 (context_p);\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_ARROW_ARGUMENTS:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_check_arrow (context_p, scanner_context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_ARROW_EXPRESSION:\n    {\n      scanner_pop_literal_pool (context_p, scanner_context_p);\n      parser_stack_pop_uint8 (context_p);\n      lexer_update_await_yield (context_p, context_p->status_flags);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_CLASS_EXTENDS:\n    {\n      if (type != LEXER_LEFT_BRACE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_CLASS_METHOD;\n      parser_stack_pop_uint8 (context_p);\n\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_FUNCTION_PARAMETERS:\n    {\n      parser_stack_pop_uint8 (context_p);\n\n      if (type != LEXER_RIGHT_PAREN\n          && (type != LEXER_EOS || context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION))\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n  }\n\n  scanner_raise_error (context_p);\n  return SCAN_NEXT_TOKEN;\n} /* scanner_scan_primary_expression_end */\n\n/**\n * Scan statements.\n *\n * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing\n */\nstatic scan_return_types_t\nscanner_scan_statement (parser_context_t *context_p, /**< context */\n                        scanner_context_t *scanner_context_p, /**< scanner context */\n                        lexer_token_type_t type, /**< current token type */\n                        scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_SEMICOLON:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if ENABLED (JERRY_ES2015)\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p,\n                                                  scanner_context_p,\n                                                  SCANNER_LITERAL_POOL_BLOCK);\n      literal_pool_p->source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_DO:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_DO_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_TRY:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_BRACE)\n      {\n        scanner_raise_error (context_p);\n      }\n\n#if ENABLED (JERRY_ES2015)\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p,\n                                                  scanner_context_p,\n                                                  SCANNER_LITERAL_POOL_BLOCK);\n      literal_pool_p->source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_TRY_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_DEBUGGER:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_IF:\n    case LEXER_KEYW_WITH:\n    case LEXER_KEYW_SWITCH:\n    {\n      lexer_next_token (context_p);\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      uint8_t mode = SCAN_STACK_STATEMENT_WITH_EXPR;\n\n      if (type == LEXER_KEYW_IF)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_IF_STATEMENT);\n      }\n      else if (type == LEXER_KEYW_WITH)\n      {\n        mode = SCAN_STACK_WITH_EXPRESSION;\n      }\n      else if (type == LEXER_KEYW_SWITCH)\n      {\n        mode = SCAN_STACK_SWITCH_EXPRESSION;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      parser_stack_push_uint8 (context_p, mode);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_WHILE:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      scanner_source_start_t source_start;\n      source_start.source_p = context_p->source_p;\n\n      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_WHILE_EXPRESSION);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_FOR:\n    {\n      lexer_next_token (context_p);\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_for_statement_t for_statement;\n      for_statement.u.source_p = context_p->source_p;\n      uint8_t stack_mode = SCAN_STACK_FOR_START;\n      scan_return_types_t return_type = SCAN_KEEP_TOKEN;\n\n      lexer_next_token (context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if ENABLED (JERRY_ES2015)\n      const uint8_t *source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      switch (context_p->token.type)\n      {\n        case LEXER_SEMICOLON:\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n          break;\n        }\n        case LEXER_KEYW_VAR:\n        {\n          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n          stack_mode = SCAN_STACK_FOR_VAR_START;\n          return_type = SCAN_NEXT_TOKEN;\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case LEXER_LITERAL:\n        {\n          if (!lexer_token_is_let (context_p))\n          {\n            break;\n          }\n\n          parser_line_counter_t line = context_p->line;\n          parser_line_counter_t column = context_p->column;\n\n          if (lexer_check_arrow (context_p))\n          {\n            context_p->source_p = source_p;\n            context_p->line = line;\n            context_p->column = column;\n            context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n            break;\n          }\n\n          lexer_next_token (context_p);\n\n          type = (lexer_token_type_t) context_p->token.type;\n\n          if (type != LEXER_LEFT_SQUARE\n              && type != LEXER_LEFT_BRACE\n              && (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL))\n          {\n            scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));\n            info_p->type = SCANNER_TYPE_LET_EXPRESSION;\n\n            scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n            break;\n          }\n\n          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n          /* FALLTHRU */\n        }\n        case LEXER_KEYW_LET:\n        case LEXER_KEYW_CONST:\n        {\n          scanner_literal_pool_t *literal_pool_p;\n          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);\n          literal_pool_p->source_p = source_p;\n\n          if (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION)\n          {\n            scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n            return_type = SCAN_NEXT_TOKEN;\n          }\n\n          stack_mode = ((context_p->token.type == LEXER_KEYW_CONST) ? SCAN_STACK_FOR_CONST_START\n                                                                    : SCAN_STACK_FOR_LET_START);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, stack_mode);\n      return return_type;\n    }\n    case LEXER_KEYW_VAR:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_VAR);\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_LET:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_LET);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_CONST:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_CONST);\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_KEYW_THROW:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_RETURN:\n    {\n      lexer_next_token (context_p);\n\n      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n          && context_p->token.type != LEXER_SEMICOLON\n          && context_p->token.type != LEXER_EOS\n          && context_p->token.type != LEXER_RIGHT_BRACE)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_KEYW_BREAK:\n    case LEXER_KEYW_CONTINUE:\n    {\n      lexer_next_token (context_p);\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n\n      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n          && context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_KEYW_CASE:\n    case LEXER_KEYW_DEFAULT:\n    {\n      if (stack_top != SCAN_STACK_SWITCH_BLOCK)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_case_info_t *case_info_p;\n      case_info_p = (scanner_case_info_t *) scanner_malloc (context_p, sizeof (scanner_case_info_t));\n\n      *(scanner_context_p->active_switch_statement.last_case_p) = case_info_p;\n      scanner_context_p->active_switch_statement.last_case_p = &case_info_p->next_p;\n\n      case_info_p->next_p = NULL;\n      scanner_get_location (&case_info_p->location, context_p);\n\n      if (type == LEXER_KEYW_DEFAULT)\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_COLON)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      scanner_source_start_t source_start;\n      source_start.source_p = context_p->source_p;\n\n      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_CASE_STATEMENT);\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n#if ENABLED (JERRY_ES2015)\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_FUNCTION_STATEMENT;\n\n      if (scanner_context_p->async_source_p != NULL)\n      {\n        scanner_context_p->status_flags |= SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;\n        status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n        lexer_next_token (context_p);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LOCAL);\n\n      if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)\n          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION))\n      {\n        scanner_raise_redeclaration_error (context_p);\n      }\n\n      literal_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION;\n\n      scanner_context_p->status_flags &= (uint16_t) ~SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;\n#else\n      literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_CLASS:\n    {\n      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);\n\n      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n      scanner_detect_invalid_let (context_p, literal_p);\n      literal_p->type |= SCANNER_LITERAL_IS_LET;\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)\n      {\n        literal_p->type |= SCANNER_LITERAL_NO_REG;\n        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n      }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n    case LEXER_KEYW_IMPORT:\n    {\n      if (stack_top != SCAN_STACK_SCRIPT)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      context_p->global_status_flags |= ECMA_PARSE_MODULE;\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n\n      bool parse_imports = true;\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n        scanner_detect_invalid_let (context_p, literal_p);\n        literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n#else /* !ENABLED (JERRY_ES2015) */\n        literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;\n#endif /* ENABLED (JERRY_ES2015) */\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_COMMA)\n        {\n          lexer_next_token (context_p);\n        }\n        else\n        {\n          parse_imports = false;\n        }\n      }\n\n      if (parse_imports)\n      {\n        if (context_p->token.type == LEXER_MULTIPLY)\n        {\n          lexer_next_token (context_p);\n          if (!lexer_token_is_identifier (context_p, \"as\", 2))\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LITERAL\n              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n          scanner_detect_invalid_let (context_p, literal_p);\n          literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n#else /* !ENABLED (JERRY_ES2015) */\n          literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          lexer_next_token (context_p);\n        }\n        else if (context_p->token.type == LEXER_LEFT_BRACE)\n        {\n          lexer_next_token (context_p);\n\n          while (context_p->token.type != LEXER_RIGHT_BRACE)\n          {\n            if (context_p->token.type != LEXER_LITERAL\n                || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n#if ENABLED (JERRY_ES2015)\n            const uint8_t *source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (lexer_check_next_character (context_p, LIT_CHAR_LOWERCASE_A))\n            {\n              lexer_next_token (context_p);\n\n              if (!lexer_token_is_identifier (context_p, \"as\", 2))\n              {\n                scanner_raise_error (context_p);\n              }\n\n              lexer_next_token (context_p);\n\n              if (context_p->token.type != LEXER_LITERAL\n                  && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n              {\n                scanner_raise_error (context_p);\n              }\n\n#if ENABLED (JERRY_ES2015)\n              source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n            }\n\n            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (literal_p->type & (SCANNER_LITERAL_IS_ARG\n                                   | SCANNER_LITERAL_IS_VAR\n                                   | SCANNER_LITERAL_IS_LOCAL))\n            {\n              context_p->source_p = source_p;\n              scanner_raise_redeclaration_error (context_p);\n            }\n\n            if (literal_p->type & SCANNER_LITERAL_IS_FUNC)\n            {\n              literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;\n            }\n\n            literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n#else /* !ENABLED (JERRY_ES2015) */\n            literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            lexer_next_token (context_p);\n\n            if (context_p->token.type != LEXER_RIGHT_BRACE)\n            {\n              if (context_p->token.type != LEXER_COMMA)\n              {\n                scanner_raise_error (context_p);\n              }\n\n              lexer_next_token (context_p);\n            }\n          }\n\n          lexer_next_token (context_p);\n        }\n        else\n        {\n          scanner_raise_error (context_p);\n        }\n      }\n\n      if (!lexer_token_is_identifier (context_p, \"from\", 4))\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          && context_p->token.lit_location.type != LEXER_STRING_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_EXPORT:\n    {\n      if (stack_top != SCAN_STACK_SCRIPT)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      context_p->global_status_flags |= ECMA_PARSE_MODULE;\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_KEYW_DEFAULT)\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_KEYW_FUNCTION)\n        {\n          lexer_next_token (context_p);\n          if (context_p->token.type == LEXER_LITERAL\n              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (location_p->type & SCANNER_LITERAL_IS_LOCAL\n                && !(location_p->type & SCANNER_LITERAL_IS_FUNC))\n            {\n              scanner_raise_redeclaration_error (context_p);\n            }\n            location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;\n#else /* !ENABLED (JERRY_ES2015) */\n            location_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            lexer_next_token (context_p);\n          }\n          else\n          {\n            lexer_lit_location_t *location_p;\n            location_p = scanner_add_custom_literal (context_p,\n                                                     scanner_context_p->active_literal_pool_p,\n                                                     &lexer_default_literal);\n#if ENABLED (JERRY_ES2015)\n            location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;\n#else /* !ENABLED (JERRY_ES2015) */\n            location_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n#endif /* ENABLED (JERRY_ES2015) */\n          }\n\n          scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);\n          scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n          return SCAN_KEEP_TOKEN;\n        }\n#if ENABLED (JERRY_ES2015)\n        if (context_p->token.type == LEXER_KEYW_CLASS)\n        {\n          scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);\n\n          if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;\n            return SCAN_NEXT_TOKEN;\n          }\n\n          lexer_lit_location_t *literal_p;\n          literal_p = scanner_add_custom_literal (context_p,\n                                                  scanner_context_p->active_literal_pool_p,\n                                                  &lexer_default_literal);\n          literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        /* Assignment expression. */\n        lexer_lit_location_t *location_p;\n        location_p = scanner_add_custom_literal (context_p,\n                                                 scanner_context_p->active_literal_pool_p,\n                                                 &lexer_default_literal);\n        location_p->type |= SCANNER_LITERAL_IS_VAR;\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n        if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n        {\n          return SCAN_KEEP_TOKEN;\n        }\n\n        location_p = scanner_add_literal (context_p, scanner_context_p);\n        location_p->type |= SCANNER_LITERAL_IS_VAR;\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        lexer_next_token (context_p);\n        if (!lexer_token_is_identifier (context_p, \"from\", 4))\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LITERAL\n            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (context_p->token.type == LEXER_LEFT_BRACE)\n      {\n        lexer_next_token (context_p);\n\n        while (context_p->token.type != LEXER_RIGHT_BRACE)\n        {\n          if (context_p->token.type != LEXER_LITERAL\n              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (lexer_token_is_identifier (context_p, \"as\", 2))\n          {\n            lexer_next_token (context_p);\n\n            if (context_p->token.type != LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            lexer_next_token (context_p);\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_BRACE)\n          {\n            if (context_p->token.type != LEXER_COMMA)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            lexer_next_token (context_p);\n          }\n        }\n\n        lexer_next_token (context_p);\n\n        if (!lexer_token_is_identifier (context_p, \"from\", 4))\n        {\n          return SCAN_KEEP_TOKEN;\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LITERAL\n            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n\n      switch (context_p->token.type)\n      {\n#if ENABLED (JERRY_ES2015)\n        case LEXER_KEYW_CLASS:\n        case LEXER_KEYW_LET:\n        case LEXER_KEYW_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n        case LEXER_KEYW_VAR:\n        {\n          scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IN_EXPORT;\n          break;\n        }\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n    default:\n    {\n      break;\n    }\n  }\n\n  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n  if (type == LEXER_LITERAL\n      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n  {\n    if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))\n    {\n      lexer_consume_next_character (context_p);\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n\n    JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);\n\n#if ENABLED (JERRY_ES2015)\n    /* The colon needs to be checked first because the parser also checks\n     * it first, and this check skips the spaces which affects source_p. */\n    if (JERRY_UNLIKELY (lexer_check_arrow (context_p)))\n    {\n      scanner_scan_simple_arrow (context_p, scanner_context_p, context_p->source_p);\n      return SCAN_KEEP_TOKEN;\n    }\n\n    if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))\n    {\n      lexer_lit_location_t let_literal = context_p->token.lit_location;\n      const uint8_t *source_p = context_p->source_p;\n\n      lexer_next_token (context_p);\n\n      type = (lexer_token_type_t) context_p->token.type;\n\n      if (type == LEXER_LEFT_SQUARE\n          || type == LEXER_LEFT_BRACE\n          || (type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL))\n      {\n        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n        parser_stack_push_uint8 (context_p, SCAN_STACK_LET);\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));\n      info_p->type = SCANNER_TYPE_LET_EXPRESSION;\n\n      lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,\n                                                                         scanner_context_p->active_literal_pool_p,\n                                                                         &let_literal);\n      lit_location_p->type |= SCANNER_LITERAL_IS_USED;\n\n      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n      {\n        lit_location_p->type |= SCANNER_LITERAL_NO_REG;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      return SCAN_KEEP_TOKEN;\n    }\n\n    if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n    {\n      scanner_context_p->async_source_p = context_p->source_p;\n\n      if (scanner_check_async_function (context_p, scanner_context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    scanner_add_reference (context_p, scanner_context_p);\n\n    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n    return SCAN_NEXT_TOKEN;\n  }\n\n  return SCAN_KEEP_TOKEN;\n} /* scanner_scan_statement */\n\n/**\n * Scan statement terminator.\n *\n * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing\n */\nstatic scan_return_types_t\nscanner_scan_statement_end (parser_context_t *context_p, /**< context */\n                            scanner_context_t *scanner_context_p, /**< scanner context */\n                            lexer_token_type_t type) /**< current token type */\n{\n  bool terminator_found = false;\n\n  if (type == LEXER_SEMICOLON)\n  {\n    lexer_next_token (context_p);\n    terminator_found = true;\n  }\n\n  while (true)\n  {\n    type = (lexer_token_type_t) context_p->token.type;\n\n    switch (context_p->stack_top_uint8)\n    {\n      case SCAN_STACK_SCRIPT:\n      case SCAN_STACK_SCRIPT_FUNCTION:\n      {\n        if (type == LEXER_EOS)\n        {\n          return SCAN_NEXT_TOKEN;\n        }\n        break;\n      }\n      case SCAN_STACK_BLOCK_STATEMENT:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_CLASS_STATEMENT:\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCAN_STACK_FUNCTION_STATEMENT:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 != SCAN_STACK_CLASS_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        terminator_found = true;\n        parser_stack_pop_uint8 (context_p);\n        lexer_next_token (context_p);\n        continue;\n      }\n      case SCAN_STACK_FUNCTION_EXPRESSION:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_FUNCTION_ARROW:\n#endif /* ENABLED (JERRY_ES2015) */\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_ARROW)\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        parser_stack_pop_uint8 (context_p);\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_FUNCTION_PROPERTY:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        parser_stack_pop_uint8 (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR\n            || context_p->stack_top_uint8 == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n        {\n          scanner_context_p->mode = SCAN_MODE_CLASS_METHOD;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL);\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_RIGHT_BRACE)\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n          return SCAN_KEEP_TOKEN;\n        }\n\n        if (context_p->token.type != LEXER_COMMA)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n        return SCAN_KEEP_TOKEN;\n      }\n      case SCAN_STACK_SWITCH_BLOCK:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_switch_statement_t switch_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &switch_statement, sizeof (scanner_switch_statement_t));\n\n        scanner_context_p->active_switch_statement = switch_statement;\n\n#if ENABLED (JERRY_ES2015)\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n        terminator_found = true;\n        lexer_next_token (context_p);\n        continue;\n      }\n      case SCAN_STACK_IF_STATEMENT:\n      {\n        parser_stack_pop_uint8 (context_p);\n\n        if (type == LEXER_KEYW_ELSE\n            && (terminator_found || (context_p->token.flags & LEXER_WAS_NEWLINE)))\n        {\n#if ENABLED (JERRY_ES2015)\n          scanner_check_function_after_if (context_p, scanner_context_p);\n          return SCAN_KEEP_TOKEN;\n#else /* !ENABLED (JERRY_ES2015) */\n          scanner_context_p->mode = SCAN_MODE_STATEMENT;\n          return SCAN_NEXT_TOKEN;\n#endif /* ENABLED (JERRY_ES2015) */\n        }\n        continue;\n      }\n      case SCAN_STACK_WITH_STATEMENT:\n      {\n        scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n\n        JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH);\n\n        parser_stack_pop_uint8 (context_p);\n\n        if (context_p->stack_top_uint8 == 0)\n        {\n          literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_WITH;\n        }\n\n        parser_stack_pop_uint8 (context_p);\n        continue;\n      }\n      case SCAN_STACK_DO_STATEMENT:\n      {\n        parser_stack_pop_uint8 (context_p);\n\n        if (type != LEXER_KEYW_WHILE\n            || (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE)))\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n        if (context_p->token.type != LEXER_LEFT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_DO_EXPRESSION);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_DO_EXPRESSION:\n      {\n        parser_stack_pop_uint8 (context_p);\n        terminator_found = true;\n        continue;\n      }\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_PRIVATE_BLOCK_EARLY:\n      {\n        parser_list_iterator_t literal_iterator;\n        lexer_lit_location_t *literal_p;\n\n        parser_list_iterator_init (&scanner_context_p->active_literal_pool_p->literal_pool, &literal_iterator);\n\n        while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n        {\n          if ((literal_p->type & (SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_IS_CONST))\n              && literal_p->type & SCANNER_LITERAL_NO_REG)\n          {\n            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n          }\n        }\n        /* FALLTHRU */\n      }\n      case SCAN_STACK_PRIVATE_BLOCK:\n      {\n        parser_stack_pop_uint8 (context_p);\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        continue;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      default:\n      {\n        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_TRY_STATEMENT\n                      || context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT);\n\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        uint8_t stack_top = context_p->stack_top_uint8;\n        parser_stack_pop_uint8 (context_p);\n        lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n#else /* !ENABLED (JERRY_ES2015) */\n        if (stack_top == SCAN_STACK_CATCH_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        /* A finally statement is optional after a try or catch statement. */\n        if (context_p->token.type == LEXER_KEYW_FINALLY)\n        {\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n#if ENABLED (JERRY_ES2015)\n          scanner_literal_pool_t *literal_pool_p;\n          literal_pool_p = scanner_push_literal_pool (context_p,\n                                                      scanner_context_p,\n                                                      SCANNER_LITERAL_POOL_BLOCK);\n          literal_pool_p->source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);\n          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n          return SCAN_NEXT_TOKEN;\n        }\n\n        if (stack_top == SCAN_STACK_CATCH_STATEMENT)\n        {\n          terminator_found = true;\n          continue;\n        }\n\n        /* A catch statement must be present after a try statement unless a finally is provided. */\n        if (context_p->token.type != LEXER_KEYW_CATCH)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_literal_pool_t *literal_pool_p;\n        literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);\n        literal_pool_p->source_p = context_p->source_p;\n\n        lexer_next_token (context_p);\n        parser_stack_push_uint8 (context_p, SCAN_STACK_CATCH_STATEMENT);\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n        {\n          scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_CATCH, false);\n\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n            scanner_context_p->mode = SCAN_MODE_BINDING;\n            return SCAN_NEXT_TOKEN;\n          }\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n          scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (context_p->token.type != LEXER_LITERAL\n            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_lit_location_t *lit_location_p = scanner_add_literal (context_p, scanner_context_p);\n        lit_location_p->type |= SCANNER_LITERAL_IS_LOCAL;\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n    }\n\n    if (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE))\n    {\n      scanner_raise_error (context_p);\n    }\n\n    scanner_context_p->mode = SCAN_MODE_STATEMENT;\n    return SCAN_KEEP_TOKEN;\n  }\n} /* scanner_scan_statement_end */\n\n/**\n * Scan the whole source code.\n */\nvoid JERRY_ATTR_NOINLINE\nscanner_scan_all (parser_context_t *context_p, /**< context */\n                  const uint8_t *arg_list_p, /**< function argument list */\n                  const uint8_t *arg_list_end_p, /**< end of argument list */\n                  const uint8_t *source_p, /**< valid UTF-8 source code */\n                  const uint8_t *source_end_p) /**< end of source code */\n{\n  scanner_context_t scanner_context;\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"\\n--- Scanning start ---\\n\\n\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  scanner_context.context_status_flags = context_p->status_flags;\n  scanner_context.status_flags = SCANNER_CONTEXT_NO_FLAGS;\n#if ENABLED (JERRY_DEBUGGER)\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    scanner_context.status_flags |= SCANNER_CONTEXT_DEBUGGER_ENABLED;\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n#if ENABLED (JERRY_ES2015)\n  scanner_context.binding_type = SCANNER_BINDING_NONE;\n  scanner_context.active_binding_list_p = NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n  scanner_context.active_literal_pool_p = NULL;\n  scanner_context.active_switch_statement.last_case_p = NULL;\n  scanner_context.end_arguments_p = NULL;\n#if ENABLED (JERRY_ES2015)\n  scanner_context.async_source_p = NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* This assignment must be here because of Apple compilers. */\n  context_p->u.scanner_context_p = &scanner_context;\n\n  parser_stack_init (context_p);\n\n  PARSER_TRY (context_p->try_buffer)\n  {\n    context_p->line = 1;\n    context_p->column = 1;\n\n    if (arg_list_p == NULL)\n    {\n      context_p->source_p = source_p;\n      context_p->source_end_p = source_end_p;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION_WITHOUT_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL;\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n      }\n\n      scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n      literal_pool_p->source_p = source_p;\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT);\n\n      lexer_next_token (context_p);\n      scanner_check_directives (context_p, &scanner_context);\n    }\n    else\n    {\n      context_p->source_p = arg_list_p;\n      context_p->source_end_p = arg_list_end_p;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n      scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT_FUNCTION);\n\n      /* Faking the first token. */\n      context_p->token.type = LEXER_LEFT_PAREN;\n    }\n\n    while (true)\n    {\n      lexer_token_type_t type = (lexer_token_type_t) context_p->token.type;\n      scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n\n      switch (scanner_context.mode)\n      {\n        case SCAN_MODE_PRIMARY_EXPRESSION:\n        {\n          if (type == LEXER_ADD\n              || type == LEXER_SUBTRACT\n              || LEXER_IS_UNARY_OP_TOKEN (type))\n          {\n            break;\n          }\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW:\n        {\n          if (scanner_scan_primary_expression (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCAN_MODE_CLASS_DECLARATION:\n        {\n          if (context_p->token.type == LEXER_KEYW_EXTENDS)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_EXTENDS);\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n          else if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_context.mode = SCAN_MODE_CLASS_METHOD;\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_CLASS_METHOD:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR\n                        || stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n\n          lexer_skip_empty_statements (context_p);\n\n          lexer_scan_identifier (context_p);\n\n          if (context_p->token.type == LEXER_RIGHT_BRACE)\n          {\n            scanner_source_start_t source_start;\n\n            parser_stack_pop_uint8 (context_p);\n\n            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n            {\n              parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n            }\n\n            stack_top = context_p->stack_top_uint8;\n\n            JERRY_ASSERT (stack_top == SCAN_STACK_CLASS_STATEMENT || stack_top == SCAN_STACK_CLASS_EXPRESSION);\n\n            if (stack_top == SCAN_STACK_CLASS_STATEMENT)\n            {\n              /* The token is kept to disallow consuming a semicolon after it. */\n              scanner_context.mode = SCAN_MODE_STATEMENT_END;\n              continue;\n            }\n\n            scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n            parser_stack_pop_uint8 (context_p);\n            break;\n          }\n\n          if (context_p->token.type == LEXER_LITERAL\n              && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)\n              && lexer_compare_literal_to_string (context_p, \"constructor\", 11))\n          {\n            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n            {\n              scanner_source_start_t source_start;\n              parser_stack_pop_uint8 (context_p);\n              parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n              scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));\n              info_p->type = SCANNER_TYPE_CLASS_CONSTRUCTOR;\n              parser_stack_push_uint8 (context_p, SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n            }\n          }\n\n          if (lexer_token_is_identifier (context_p, \"static\", 6))\n          {\n            lexer_scan_identifier (context_p);\n          }\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n          scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n\n          uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n          if (lexer_token_is_identifier (context_p, \"get\", 3)\n              || lexer_token_is_identifier (context_p, \"set\", 3))\n          {\n            lexer_scan_identifier (context_p);\n\n            if (context_p->token.type == LEXER_LEFT_PAREN)\n            {\n              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n              continue;\n            }\n          }\n          else if (lexer_token_is_identifier (context_p, \"async\", 5))\n          {\n            lexer_scan_identifier (context_p);\n\n            if (context_p->token.type == LEXER_LEFT_PAREN)\n            {\n              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n              continue;\n            }\n\n            literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n\n            if (context_p->token.type == LEXER_MULTIPLY)\n            {\n              lexer_scan_identifier (context_p);\n              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n            }\n          }\n          else if (context_p->token.type == LEXER_MULTIPLY)\n          {\n            lexer_scan_identifier (context_p);\n            literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n          }\n\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n\n          if (context_p->token.type != LEXER_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          if (literal_pool_flags & SCANNER_LITERAL_POOL_GENERATOR)\n          {\n            context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n          }\n\n          scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n          lexer_next_token (context_p);\n          continue;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case SCAN_MODE_POST_PRIMARY_EXPRESSION:\n        {\n          if (scanner_scan_post_primary_expression (context_p, &scanner_context, type, stack_top))\n          {\n            break;\n          }\n          type = (lexer_token_type_t) context_p->token.type;\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_PRIMARY_EXPRESSION_END:\n        {\n          if (scanner_scan_primary_expression_end (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n        case SCAN_MODE_STATEMENT_OR_TERMINATOR:\n        {\n          if (type == LEXER_RIGHT_BRACE || type == LEXER_EOS)\n          {\n            scanner_context.mode = SCAN_MODE_STATEMENT_END;\n            continue;\n          }\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_STATEMENT:\n        {\n          if (scanner_scan_statement (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n        case SCAN_MODE_STATEMENT_END:\n        {\n          if (scanner_scan_statement_end (context_p, &scanner_context, type) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n\n          if (context_p->token.type == LEXER_EOS)\n          {\n            goto scan_completed;\n          }\n\n          break;\n        }\n        case SCAN_MODE_VAR_STATEMENT:\n        {\n#if ENABLED (JERRY_ES2015)\n          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n          {\n            uint8_t binding_type = SCANNER_BINDING_VAR;\n\n            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n            {\n              binding_type = SCANNER_BINDING_LET;\n            }\n            else if (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START)\n            {\n              binding_type = SCANNER_BINDING_CONST;\n            }\n\n            scanner_push_destructuring_pattern (context_p, &scanner_context, binding_type, false);\n\n            if (type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n              scanner_context.mode = SCAN_MODE_BINDING;\n              break;\n            }\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n            continue;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (type != LEXER_LITERAL\n              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n\n#if ENABLED (JERRY_ES2015)\n          if (stack_top != SCAN_STACK_VAR && stack_top != SCAN_STACK_FOR_VAR_START)\n          {\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n            {\n              literal_p->type |= SCANNER_LITERAL_IS_LET;\n            }\n            else\n            {\n              JERRY_ASSERT (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START);\n              literal_p->type |= SCANNER_LITERAL_IS_CONST;\n            }\n\n            lexer_next_token (context_p);\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n            }\n            else if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_binding_literal_t binding_literal;\n              binding_literal.literal_p = literal_p;\n\n              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n            }\n          }\n          else\n          {\n            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n            {\n              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n              literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n              {\n                literal_p->type |= SCANNER_LITERAL_NO_REG;\n              }\n            }\n\n            lexer_next_token (context_p);\n          }\n#else /* !ENABLED (JERRY_ES2015) */\n          literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n          {\n            literal_p->type |= SCANNER_LITERAL_NO_REG;\n          }\n\n          lexer_next_token (context_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)\n          {\n            literal_p->type |= SCANNER_LITERAL_NO_REG;\n          }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n          switch (context_p->token.type)\n          {\n            case LEXER_ASSIGN:\n            {\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              /* FALLTHRU */\n            }\n            case LEXER_COMMA:\n            {\n              lexer_next_token (context_p);\n              continue;\n            }\n          }\n\n          if (SCANNER_IS_FOR_START (stack_top))\n          {\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n            JERRY_ASSERT (!(scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT));\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n            if (context_p->token.type != LEXER_SEMICOLON\n                && context_p->token.type != LEXER_KEYW_IN\n                && !SCANNER_IDENTIFIER_IS_OF ())\n            {\n              scanner_raise_error (context_p);\n            }\n\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n\n#if ENABLED (JERRY_ES2015)\n          JERRY_ASSERT (stack_top == SCAN_STACK_VAR || stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_CONST);\n#else /* !ENABLED (JERRY_ES2015) */\n          JERRY_ASSERT (stack_top == SCAN_STACK_VAR);\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n          scanner_context.active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n          scanner_context.mode = SCAN_MODE_STATEMENT_END;\n          parser_stack_pop_uint8 (context_p);\n          continue;\n        }\n        case SCAN_MODE_FUNCTION_ARGUMENTS:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_SCRIPT_FUNCTION\n                        || stack_top == SCAN_STACK_FUNCTION_STATEMENT\n                        || stack_top == SCAN_STACK_FUNCTION_EXPRESSION\n                        || stack_top == SCAN_STACK_FUNCTION_PROPERTY);\n\n          scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n\n          JERRY_ASSERT (literal_pool_p != NULL && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION));\n\n          literal_pool_p->source_p = context_p->source_p;\n\n#if ENABLED (JERRY_ES2015)\n          if (JERRY_UNLIKELY (scanner_context.async_source_p != NULL))\n          {\n            literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n            literal_pool_p->source_p = scanner_context.async_source_p;\n            scanner_context.async_source_p = NULL;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (type != LEXER_LEFT_PAREN)\n          {\n            scanner_raise_error (context_p);\n          }\n          lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS:\n        {\n#endif /* ENABLED (JERRY_ES2015) */\n          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)\n          {\n#if ENABLED (JERRY_ES2015)\n            lexer_lit_location_t *argument_literal_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            while (true)\n            {\n#if ENABLED (JERRY_ES2015)\n              if (context_p->token.type == LEXER_THREE_DOTS)\n              {\n                scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n\n                lexer_next_token (context_p);\n              }\n\n              if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n              {\n                argument_literal_p = NULL;\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n\n              if (context_p->token.type != LEXER_LITERAL\n                  || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n              {\n                scanner_raise_error (context_p);\n              }\n\n#if ENABLED (JERRY_ES2015)\n              argument_literal_p = scanner_append_argument (context_p, &scanner_context);\n#else /* !ENABLED (JERRY_ES2015) */\n              scanner_append_argument (context_p, &scanner_context);\n#endif /* ENABLED (JERRY_ES2015) */\n\n              lexer_next_token (context_p);\n\n              if (context_p->token.type != LEXER_COMMA)\n              {\n                break;\n              }\n              lexer_next_token (context_p);\n            }\n\n#if ENABLED (JERRY_ES2015)\n            if (argument_literal_p == NULL)\n            {\n              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n              scanner_append_hole (context_p, &scanner_context);\n              scanner_push_destructuring_pattern (context_p, &scanner_context, SCANNER_BINDING_ARG, false);\n\n              if (context_p->token.type == LEXER_LEFT_SQUARE)\n              {\n                parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n                scanner_context.mode = SCAN_MODE_BINDING;\n                break;\n              }\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n              scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n              continue;\n            }\n\n            if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n              if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)\n              {\n                JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);\n                break;\n              }\n\n              scanner_binding_literal_t binding_literal;\n              binding_literal.literal_p = argument_literal_p;\n\n              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n              break;\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n          }\n\n          if (context_p->token.type == LEXER_EOS && stack_top == SCAN_STACK_SCRIPT_FUNCTION)\n          {\n            /* End of argument parsing. */\n            scanner_info_t *scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, sizeof (scanner_info_t));\n            scanner_info_p->next_p = context_p->next_scanner_info_p;\n            scanner_info_p->source_p = NULL;\n            scanner_info_p->type = SCANNER_TYPE_END_ARGUMENTS;\n            scanner_context.end_arguments_p = scanner_info_p;\n\n            context_p->next_scanner_info_p = scanner_info_p;\n            context_p->source_p = source_p;\n            context_p->source_end_p = source_end_p;\n            context_p->line = 1;\n            context_p->column = 1;\n\n            scanner_filter_arguments (context_p, &scanner_context);\n            lexer_next_token (context_p);\n            scanner_check_directives (context_p, &scanner_context);\n            continue;\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_PAREN)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_filter_arguments (context_p, &scanner_context);\n          lexer_next_token (context_p);\n          scanner_check_directives (context_p, &scanner_context);\n          continue;\n        }\n        case SCAN_MODE_PROPERTY_NAME:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);\n\n          if (lexer_scan_identifier (context_p))\n          {\n            lexer_check_property_modifier (context_p);\n          }\n\n#if ENABLED (JERRY_ES2015)\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_COMPUTED_PROPERTY);\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (context_p->token.type == LEXER_RIGHT_BRACE)\n          {\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n\n          if (context_p->token.type == LEXER_PROPERTY_GETTER\n#if ENABLED (JERRY_ES2015)\n              || context_p->token.type == LEXER_KEYW_ASYNC\n              || context_p->token.type == LEXER_MULTIPLY\n#endif /* ENABLED (JERRY_ES2015) */\n              || context_p->token.type == LEXER_PROPERTY_SETTER)\n          {\n            uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n#if ENABLED (JERRY_ES2015)\n            if (context_p->token.type == LEXER_MULTIPLY)\n            {\n              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n            }\n            else if (context_p->token.type == LEXER_KEYW_ASYNC)\n            {\n              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n\n              if (lexer_consume_generator (context_p))\n              {\n                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n              }\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            lexer_scan_identifier (context_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (context_p->token.type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              break;\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (context_p->token.type != LEXER_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n            break;\n          }\n\n          if (context_p->token.type != LEXER_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n#if ENABLED (JERRY_ES2015)\n          parser_line_counter_t start_line = context_p->token.line;\n          parser_line_counter_t start_column = context_p->token.column;\n          bool is_ident = (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n#endif /* ENABLED (JERRY_ES2015) */\n\n          lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n          if (context_p->token.type == LEXER_LEFT_PAREN)\n          {\n            scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n            continue;\n          }\n\n          if (is_ident\n              && (context_p->token.type == LEXER_COMMA\n                  || context_p->token.type == LEXER_RIGHT_BRACE\n                  || context_p->token.type == LEXER_ASSIGN))\n          {\n            context_p->source_p = context_p->token.lit_location.char_p;\n            context_p->line = start_line;\n            context_p->column = start_column;\n\n            lexer_next_token (context_p);\n\n            JERRY_ASSERT (context_p->token.type != LEXER_LITERAL\n                          || context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n            if (context_p->token.type != LEXER_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n            {\n              scanner_context.mode = SCAN_MODE_BINDING;\n              continue;\n            }\n\n            scanner_add_reference (context_p, &scanner_context);\n\n            lexer_next_token (context_p);\n\n            if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              break;\n            }\n\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (context_p->token.type != LEXER_COLON)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if ENABLED (JERRY_ES2015)\n          if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n          {\n            scanner_context.mode = SCAN_MODE_BINDING;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCAN_MODE_BINDING:\n        {\n          JERRY_ASSERT (scanner_context.binding_type == SCANNER_BINDING_VAR\n                        || scanner_context.binding_type == SCANNER_BINDING_LET\n                        || scanner_context.binding_type == SCANNER_BINDING_CATCH\n                        || scanner_context.binding_type == SCANNER_BINDING_CONST\n                        || scanner_context.binding_type == SCANNER_BINDING_ARG\n                        || scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG);\n\n          if (type == LEXER_THREE_DOTS)\n          {\n            lexer_next_token (context_p);\n            type = (lexer_token_type_t) context_p->token.type;\n          }\n\n          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n          {\n            scanner_push_destructuring_pattern (context_p, &scanner_context, scanner_context.binding_type, true);\n\n            if (type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n              break;\n            }\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n            continue;\n          }\n\n          if (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            continue;\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n\n          scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n\n          if (scanner_context.binding_type == SCANNER_BINDING_VAR)\n          {\n            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n            {\n              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n              literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n              {\n                literal_p->type |= SCANNER_LITERAL_NO_REG;\n              }\n            }\n            break;\n          }\n\n          if (scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG)\n          {\n            literal_p->type |= SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n              break;\n            }\n          }\n          else\n          {\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            if (scanner_context.binding_type <= SCANNER_BINDING_CATCH)\n            {\n              JERRY_ASSERT ((scanner_context.binding_type == SCANNER_BINDING_LET)\n                            || (scanner_context.binding_type == SCANNER_BINDING_CATCH));\n\n              literal_p->type |= SCANNER_LITERAL_IS_LET;\n            }\n            else\n            {\n              literal_p->type |= SCANNER_LITERAL_IS_CONST;\n\n              if (scanner_context.binding_type == SCANNER_BINDING_ARG)\n              {\n                literal_p->type |= SCANNER_LITERAL_IS_ARG;\n\n                if (literal_p->type & SCANNER_LITERAL_IS_USED)\n                {\n                  literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n                  break;\n                }\n              }\n            }\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n              break;\n            }\n          }\n\n          scanner_binding_item_t *binding_item_p;\n          binding_item_p = (scanner_binding_item_t *) scanner_malloc (context_p, sizeof (scanner_binding_item_t));\n\n          binding_item_p->next_p = scanner_context.active_binding_list_p->items_p;\n          binding_item_p->literal_p = literal_p;\n\n          scanner_context.active_binding_list_p->items_p = binding_item_p;\n\n          lexer_next_token (context_p);\n          if (context_p->token.type != LEXER_ASSIGN)\n          {\n            continue;\n          }\n\n          scanner_binding_literal_t binding_literal;\n          binding_literal.literal_p = literal_p;\n\n          parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n          parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n\n          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      lexer_next_token (context_p);\n    }\n\nscan_completed:\n    if (context_p->stack_top_uint8 != SCAN_STACK_SCRIPT\n        && context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION)\n    {\n      scanner_raise_error (context_p);\n    }\n\n    scanner_pop_literal_pool (context_p, &scanner_context);\n\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (scanner_context.active_binding_list_p == NULL);\n#endif /* ENABLED (JERRY_ES2015) */\n    JERRY_ASSERT (scanner_context.active_literal_pool_p == NULL);\n\n#ifndef JERRY_NDEBUG\n    scanner_context.context_status_flags |= PARSER_SCANNING_SUCCESSFUL;\n#endif /* !JERRY_NDEBUG */\n  }\n  PARSER_CATCH\n  {\n    /* Ignore the errors thrown by the lexer. */\n    if (context_p->error != PARSER_ERR_OUT_OF_MEMORY)\n    {\n      context_p->error = PARSER_ERR_NO_ERROR;\n    }\n\n#if ENABLED (JERRY_ES2015)\n    while (scanner_context.active_binding_list_p != NULL)\n    {\n      scanner_pop_binding_list (&scanner_context);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    /* The following code may allocate memory, so it is enclosed in a try/catch. */\n    PARSER_TRY (context_p->try_buffer)\n    {\n#if ENABLED (JERRY_ES2015)\n      if (scanner_context.status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION)\n      {\n        JERRY_ASSERT (scanner_context.async_source_p != NULL);\n\n        scanner_info_t *info_p;\n        info_p = scanner_insert_info (context_p, scanner_context.async_source_p, sizeof (scanner_info_t));\n        info_p->type = SCANNER_TYPE_ERR_ASYNC_FUNCTION;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      while (scanner_context.active_literal_pool_p != NULL)\n      {\n        scanner_pop_literal_pool (context_p, &scanner_context);\n      }\n    }\n    PARSER_CATCH\n    {\n      JERRY_ASSERT (context_p->error == PARSER_ERR_NO_ERROR);\n\n      while (scanner_context.active_literal_pool_p != NULL)\n      {\n        scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n\n        scanner_context.active_literal_pool_p = literal_pool_p->prev_p;\n\n        parser_list_free (&literal_pool_p->literal_pool);\n        scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n      }\n    }\n    PARSER_TRY_END\n\n#if ENABLED (JERRY_ES2015)\n    context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;\n#endif /* ENABLED (JERRY_ES2015) */\n  }\n  PARSER_TRY_END\n\n  context_p->status_flags = scanner_context.context_status_flags;\n  scanner_reverse_info_list (context_p);\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    scanner_info_t *info_p = context_p->next_scanner_info_p;\n    const uint8_t *source_start_p = (arg_list_p == NULL) ? source_p : arg_list_p;\n\n    while (info_p->type != SCANNER_TYPE_END)\n    {\n      const char *name_p = NULL;\n      bool print_location = false;\n\n      switch (info_p->type)\n      {\n        case SCANNER_TYPE_END_ARGUMENTS:\n        {\n          JERRY_DEBUG_MSG (\"  END_ARGUMENTS\\n\");\n          source_start_p = source_p;\n          break;\n        }\n        case SCANNER_TYPE_FUNCTION:\n        case SCANNER_TYPE_BLOCK:\n        {\n          const uint8_t *prev_source_p = info_p->source_p - 1;\n          const uint8_t *data_p;\n\n          if (info_p->type == SCANNER_TYPE_FUNCTION)\n          {\n            data_p = (const uint8_t *) (info_p + 1);\n\n            JERRY_DEBUG_MSG (\"  FUNCTION: flags: 0x%x declarations: %d\",\n                             (int) info_p->u8_arg,\n                             (int) info_p->u16_arg);\n          }\n          else\n          {\n            data_p = (const uint8_t *) (info_p + 1);\n\n            JERRY_DEBUG_MSG (\"  BLOCK:\");\n          }\n\n          JERRY_DEBUG_MSG (\" source:%d\\n\", (int) (info_p->source_p - source_start_p));\n\n          while (data_p[0] != SCANNER_STREAM_TYPE_END)\n          {\n            switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)\n            {\n              case SCANNER_STREAM_TYPE_VAR:\n              {\n                JERRY_DEBUG_MSG (\"    VAR \");\n                break;\n              }\n#if ENABLED (JERRY_ES2015)\n              case SCANNER_STREAM_TYPE_LET:\n              {\n                JERRY_DEBUG_MSG (\"    LET \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_CONST:\n              {\n                JERRY_DEBUG_MSG (\"    CONST \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_LOCAL:\n              {\n                JERRY_DEBUG_MSG (\"    LOCAL \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n              case SCANNER_STREAM_TYPE_IMPORT:\n              {\n                JERRY_DEBUG_MSG (\"    IMPORT \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n              case SCANNER_STREAM_TYPE_ARG:\n              {\n                JERRY_DEBUG_MSG (\"    ARG \");\n                break;\n              }\n#if ENABLED (JERRY_ES2015)\n              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n              {\n                JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n              case SCANNER_STREAM_TYPE_ARG_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    ARG_FUNC \");\n                break;\n              }\n#if ENABLED (JERRY_ES2015)\n              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG_FUNC \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n              case SCANNER_STREAM_TYPE_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    FUNC \");\n                break;\n              }\n              default:\n              {\n                JERRY_ASSERT ((data_p[0] & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_HOLE);\n                JERRY_DEBUG_MSG (\"    HOLE\\n\");\n                data_p++;\n                continue;\n              }\n            }\n\n            size_t length;\n\n            if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))\n            {\n              if (data_p[2] != 0)\n              {\n                prev_source_p += data_p[2];\n                length = 2 + 1;\n              }\n              else\n              {\n                memcpy (&prev_source_p, data_p + 2 + 1, sizeof (const uint8_t *));\n                length = 2 + 1 + sizeof (const uint8_t *);\n              }\n            }\n            else\n            {\n              int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;\n\n              if (diff <= UINT8_MAX)\n              {\n                diff = -diff;\n              }\n\n              prev_source_p += diff;\n              length = 2 + 2;\n            }\n\n#if ENABLED (JERRY_ES2015)\n            if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)\n            {\n              JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);\n              JERRY_DEBUG_MSG (\"*\");\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (data_p[0] & SCANNER_STREAM_NO_REG)\n            {\n              JERRY_DEBUG_MSG (\"* \");\n            }\n\n            JERRY_DEBUG_MSG (\"'%.*s'\\n\", data_p[1], (char *) prev_source_p);\n            prev_source_p += data_p[1];\n            data_p += length;\n          }\n          break;\n        }\n        case SCANNER_TYPE_WHILE:\n        {\n          name_p = \"WHILE\";\n          print_location = true;\n          break;\n        }\n        case SCANNER_TYPE_FOR:\n        {\n          scanner_for_info_t *for_info_p = (scanner_for_info_t *) info_p;\n          JERRY_DEBUG_MSG (\"  FOR: source:%d expression:%d[%d:%d] end:%d[%d:%d]\\n\",\n                           (int) (for_info_p->info.source_p - source_start_p),\n                           (int) (for_info_p->expression_location.source_p - source_start_p),\n                           (int) for_info_p->expression_location.line,\n                           (int) for_info_p->expression_location.column,\n                           (int) (for_info_p->end_location.source_p - source_start_p),\n                           (int) for_info_p->end_location.line,\n                           (int) for_info_p->end_location.column);\n          break;\n        }\n        case SCANNER_TYPE_FOR_IN:\n        {\n          name_p = \"FOR-IN\";\n          print_location = true;\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCANNER_TYPE_FOR_OF:\n        {\n          name_p = \"FOR-OF\";\n          print_location = true;\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case SCANNER_TYPE_SWITCH:\n        {\n          JERRY_DEBUG_MSG (\"  SWITCH: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n\n          scanner_case_info_t *current_case_p = ((scanner_switch_info_t *) info_p)->case_p;\n\n          while (current_case_p != NULL)\n          {\n            JERRY_DEBUG_MSG (\"    CASE: location:%d[%d:%d]\\n\",\n                             (int) (current_case_p->location.source_p - source_start_p),\n                             (int) current_case_p->location.line,\n                             (int) current_case_p->location.column);\n\n            current_case_p = current_case_p->next_p;\n          }\n          break;\n        }\n        case SCANNER_TYPE_CASE:\n        {\n          name_p = \"CASE\";\n          print_location = true;\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCANNER_TYPE_INITIALIZER:\n        {\n          name_p = \"INITIALIZER\";\n          print_location = true;\n          break;\n        }\n        case SCANNER_TYPE_CLASS_CONSTRUCTOR:\n        {\n          JERRY_DEBUG_MSG (\"  CLASS-CONSTRUCTOR: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          print_location = false;\n          break;\n        }\n        case SCANNER_TYPE_LET_EXPRESSION:\n        {\n          JERRY_DEBUG_MSG (\"  LET_EXPRESSION: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n        case SCANNER_TYPE_ERR_REDECLARED:\n        {\n          JERRY_DEBUG_MSG (\"  ERR_REDECLARED: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n        case SCANNER_TYPE_ERR_ASYNC_FUNCTION:\n        {\n          JERRY_DEBUG_MSG (\"  ERR_ASYNC_FUNCTION: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      if (print_location)\n      {\n        scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;\n        JERRY_DEBUG_MSG (\"  %s: source:%d location:%d[%d:%d]\\n\",\n                         name_p,\n                         (int) (location_info_p->info.source_p - source_start_p),\n                         (int) (location_info_p->location.source_p - source_start_p),\n                         (int) location_info_p->location.line,\n                         (int) location_info_p->location.column);\n      }\n\n      info_p = info_p->next_p;\n    }\n\n    JERRY_DEBUG_MSG (\"\\n--- Scanning end ---\\n\\n\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  parser_stack_free (context_p);\n} /* scanner_scan_all */\n\n/**\n * @}\n * @}\n * @}\n */\n\n#endif /* ENABLED (JERRY_PARSER) */\n"], "fixing_code": ["/* Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"jcontext.h\"\n#include \"js-parser-internal.h\"\n#include \"js-scanner-internal.h\"\n#include \"lit-char-helpers.h\"\n\n#if ENABLED (JERRY_PARSER)\n\n/** \\addtogroup parser Parser\n * @{\n *\n * \\addtogroup jsparser JavaScript\n * @{\n *\n * \\addtogroup jsparser_scanner Scanner\n * @{\n */\n\n/**\n * Scan return types.\n */\ntypedef enum\n{\n  SCAN_NEXT_TOKEN, /**< get next token after return */\n  SCAN_KEEP_TOKEN, /**< keep the current token after return */\n} scan_return_types_t;\n\n/**\n * Checks whether token type is \"of\".\n */\n#if ENABLED (JERRY_ES2015)\n#define SCANNER_IDENTIFIER_IS_OF() (lexer_token_is_identifier (context_p, \"of\", 2))\n#else\n#define SCANNER_IDENTIFIER_IS_OF() (false)\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015)\n\nJERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_GENERATOR)\n                     == SCAN_STACK_COMPUTED_GENERATOR,\n                     scanner_invalid_conversion_from_literal_pool_generator_to_computed_generator);\nJERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_ASYNC)\n                     == SCAN_STACK_COMPUTED_ASYNC,\n                     scanner_invalid_conversion_from_literal_pool_async_to_computed_async);\n\nJERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_GENERATOR)\n                     == SCANNER_LITERAL_POOL_GENERATOR,\n                     scanner_invalid_conversion_from_computed_generator_to_literal_pool_generator);\nJERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_ASYNC)\n                     == SCANNER_LITERAL_POOL_ASYNC,\n                     scanner_invalid_conversion_from_computed_async_to_literal_pool_async);\n\n#endif /* ENABLED (JERRY_ES2015) */\n\n/**\n * Scan primary expression.\n *\n * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing\n */\nstatic scan_return_types_t\nscanner_scan_primary_expression (parser_context_t *context_p, /**< context */\n                                 scanner_context_t *scanner_context_p, /* scanner context */\n                                 lexer_token_type_t type, /**< current token type */\n                                 scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_KEYW_NEW:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW;\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_try_scan_new_target (context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n    case LEXER_DIVIDE:\n    case LEXER_ASSIGN_DIVIDE:\n    {\n      lexer_construct_regexp_object (context_p, true);\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_context_p->async_source_p != NULL)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n      }\n\n      if (lexer_consume_generator (context_p))\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        lexer_next_token (context_p);\n      }\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      scanner_scan_bracket (context_p, scanner_context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_SQUARE:\n    {\n#if ENABLED (JERRY_ES2015)\n      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      break;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if ENABLED (JERRY_ES2015)\n      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n      scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n      return SCAN_KEEP_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_TEMPLATE_STRING);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        break;\n      }\n\n      /* The string is a normal string literal. */\n      /* FALLTHRU */\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_LITERAL:\n    {\n#if ENABLED (JERRY_ES2015)\n      const uint8_t *source_p = context_p->source_p;\n\n      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL\n          && lexer_check_arrow (context_p))\n      {\n        scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);\n        return SCAN_KEEP_TOKEN;\n      }\n      else if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n      {\n        scanner_context_p->async_source_p = source_p;\n        scanner_check_async_function (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        scanner_add_reference (context_p, scanner_context_p);\n      }\n      /* FALLTHRU */\n    }\n    case LEXER_KEYW_THIS:\n    case LEXER_KEYW_SUPER:\n    case LEXER_LIT_TRUE:\n    case LEXER_LIT_FALSE:\n    case LEXER_LIT_NULL:\n    {\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_CLASS:\n    {\n      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_EXPRESSION);\n\n      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        return SCAN_KEEP_TOKEN;\n      }\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_RIGHT_SQUARE:\n    {\n      if (stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_THREE_DOTS:\n    {\n      /* Elision or spread arguments */\n      if (stack_top != SCAN_STACK_PAREN_EXPRESSION && stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      break;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_COMMA:\n    {\n      if (stack_top != SCAN_STACK_ARRAY_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if ENABLED (JERRY_ES2015)\n      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n      {\n        scanner_context_p->mode = SCAN_MODE_BINDING;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      break;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_YIELD:\n    {\n      lexer_next_token (context_p);\n\n      if (lexer_check_yield_no_arg (context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      }\n\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_RIGHT_PAREN:\n    {\n      if (stack_top == SCAN_STACK_PAREN_EXPRESSION)\n      {\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        parser_stack_pop_uint8 (context_p);\n        break;\n      }\n      /* FALLTHRU */\n    }\n    default:\n    {\n      scanner_raise_error (context_p);\n    }\n  }\n  return SCAN_NEXT_TOKEN;\n} /* scanner_scan_primary_expression */\n\n/**\n * Scan the tokens after the primary expression.\n *\n * @return true for break, false for fall through\n */\nstatic bool\nscanner_scan_post_primary_expression (parser_context_t *context_p, /**< context */\n                                      scanner_context_t *scanner_context_p, /**< scanner context */\n                                      lexer_token_type_t type, /**< current token type */\n                                      scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_DOT:\n    {\n      lexer_scan_identifier (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      return true;\n    }\n    case LEXER_LEFT_PAREN:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_TEMPLATE_LITERAL:\n    {\n      if (JERRY_UNLIKELY (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT))\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        parser_stack_push_uint8 (context_p, SCAN_STACK_TAGGED_TEMPLATE_LITERAL);\n      }\n      return true;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_LEFT_SQUARE:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_PROPERTY_ACCESSOR);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n    case LEXER_INCREASE:\n    case LEXER_DECREASE:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n\n      if (context_p->token.flags & LEXER_WAS_NEWLINE)\n      {\n        return false;\n      }\n\n      lexer_next_token (context_p);\n      type = (lexer_token_type_t) context_p->token.type;\n\n      if (type != LEXER_QUESTION_MARK)\n      {\n        break;\n      }\n      /* FALLTHRU */\n    }\n    case LEXER_QUESTION_MARK:\n    {\n      parser_stack_push_uint8 (context_p, SCAN_STACK_COLON_EXPRESSION);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return true;\n    }\n    default:\n    {\n      break;\n    }\n  }\n\n  if (LEXER_IS_BINARY_OP_TOKEN (type)\n      && (type != LEXER_KEYW_IN || !SCANNER_IS_FOR_START (stack_top)))\n  {\n    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n    return true;\n  }\n\n  return false;\n} /* scanner_scan_post_primary_expression */\n\n/**\n * Scan the tokens after the primary expression.\n *\n * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing\n */\nstatic scan_return_types_t\nscanner_scan_primary_expression_end (parser_context_t *context_p, /**< context */\n                                     scanner_context_t *scanner_context_p, /**< scanner context */\n                                     lexer_token_type_t type, /**< current token type */\n                                     scan_stack_modes_t stack_top) /**< current stack top */\n{\n  if (type == LEXER_COMMA)\n  {\n    switch (stack_top)\n    {\n      case SCAN_STACK_VAR:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_LET:\n      case SCAN_STACK_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCAN_STACK_FOR_VAR_START:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_FOR_LET_START:\n      case SCAN_STACK_FOR_CONST_START:\n#endif /* ENABLED (JERRY_ES2015) */\n      {\n        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_COLON_EXPRESSION:\n      {\n        scanner_raise_error (context_p);\n        break;\n      }\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_BINDING_INIT:\n      case SCAN_STACK_BINDING_LIST_INIT:\n      {\n        break;\n      }\n      case SCAN_STACK_ARROW_ARGUMENTS:\n      {\n        lexer_next_token (context_p);\n        scanner_check_arrow_arg (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n      case SCAN_STACK_ARROW_EXPRESSION:\n      {\n        break;\n      }\n      case SCAN_STACK_FUNCTION_PARAMETERS:\n      {\n        scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;\n        parser_stack_pop_uint8 (context_p);\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_ARRAY_LITERAL:\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n        if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n        {\n          scanner_context_p->mode = SCAN_MODE_BINDING;\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCAN_STACK_OBJECT_LITERAL:\n      {\n        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n        return SCAN_KEEP_TOKEN;\n      }\n      default:\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n    }\n  }\n\n  switch (stack_top)\n  {\n    case SCAN_STACK_WITH_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n      uint16_t status_flags = scanner_context_p->active_literal_pool_p->status_flags;\n      parser_stack_push_uint8 (context_p, (status_flags & SCANNER_LITERAL_POOL_IN_WITH) ? 1 : 0);\n      parser_stack_push_uint8 (context_p, SCAN_STACK_WITH_STATEMENT);\n      status_flags |= SCANNER_LITERAL_POOL_IN_WITH;\n      scanner_context_p->active_literal_pool_p->status_flags = status_flags;\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_DO_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_WHILE_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_WHILE;\n\n      scanner_get_location (&location_info_p->location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_PAREN_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)\n      {\n        scanner_add_async_literal (context_p, scanner_context_p);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_STATEMENT_WITH_EXPR:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      parser_stack_pop_uint8 (context_p);\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->stack_top_uint8 == SCAN_STACK_IF_STATEMENT)\n      {\n        scanner_check_function_after_if (context_p, scanner_context_p);\n        return SCAN_KEEP_TOKEN;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_BINDING_LIST_INIT:\n    {\n      parser_stack_pop_uint8 (context_p);\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_LET\n                    || context_p->stack_top_uint8 == SCAN_STACK_CONST\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS\n                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);\n\n      scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;\n\n      while (item_p != NULL)\n      {\n        if (item_p->literal_p->type & SCANNER_LITERAL_IS_USED)\n        {\n          item_p->literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n        }\n        item_p = item_p->next_p;\n      }\n\n      scanner_pop_binding_list (scanner_context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_BINDING_INIT:\n    {\n      scanner_binding_literal_t binding_literal;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_LET\n                    || context_p->stack_top_uint8 == SCAN_STACK_CONST\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS\n                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);\n\n      JERRY_ASSERT ((stack_top != SCAN_STACK_ARRAY_LITERAL && stack_top != SCAN_STACK_OBJECT_LITERAL)\n                    || SCANNER_NEEDS_BINDING_LIST (scanner_context_p->binding_type));\n\n      if (binding_literal.literal_p->type & SCANNER_LITERAL_IS_USED)\n      {\n        binding_literal.literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_VAR:\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_LET:\n    case SCAN_STACK_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n    {\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n      scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_FOR_VAR_START:\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_FOR_LET_START:\n    case SCAN_STACK_FOR_CONST_START:\n#endif /* ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_FOR_START:\n    {\n      if (type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())\n      {\n        scanner_for_statement_t for_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n        scanner_location_info_t *location_info;\n        location_info = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         for_statement.u.source_p,\n                                                                         sizeof (scanner_location_info_t));\n#if ENABLED (JERRY_ES2015)\n        location_info->info.type = (type == LEXER_KEYW_IN) ? SCANNER_TYPE_FOR_IN : SCANNER_TYPE_FOR_OF;\n\n        if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)\n        {\n          parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK_EARLY);\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        location_info->info.type = SCANNER_TYPE_FOR_IN;\n#endif /* ENABLED (JERRY_ES2015) */\n\n        scanner_get_location (&location_info->location, context_p);\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_STATEMENT_WITH_EXPR);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (type != LEXER_SEMICOLON)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, NULL, sizeof (scanner_for_statement_t));\n\n#if ENABLED (JERRY_ES2015)\n      if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      for_statement.u.source_p = context_p->source_p;\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_CONDITION);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_SEMICOLON)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      type = LEXER_SEMICOLON;\n      /* FALLTHRU */\n    }\n    case SCAN_STACK_FOR_CONDITION:\n    {\n      if (type != LEXER_SEMICOLON)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n      scanner_for_info_t *for_info_p;\n      for_info_p = (scanner_for_info_t *) scanner_insert_info (context_p,\n                                                               for_statement.u.source_p,\n                                                               sizeof (scanner_for_info_t));\n      for_info_p->info.type = SCANNER_TYPE_FOR;\n\n      scanner_get_location (&for_info_p->expression_location, context_p);\n      for_info_p->end_location.source_p = NULL;\n\n      for_statement.u.for_info_p = for_info_p;\n\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_EXPRESSION);\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_RIGHT_PAREN)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      type = LEXER_RIGHT_PAREN;\n      /* FALLTHRU */\n    }\n    case SCAN_STACK_FOR_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_for_statement_t for_statement;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));\n\n      scanner_get_location (&for_statement.u.for_info_p->end_location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_SWITCH_EXPRESSION:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_BRACE)\n      {\n        break;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);\n      literal_pool_p->source_p = context_p->source_p - 1;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      parser_stack_pop_uint8 (context_p);\n\n      scanner_switch_statement_t switch_statement = scanner_context_p->active_switch_statement;\n      parser_stack_push (context_p, &switch_statement, sizeof (scanner_switch_statement_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SWITCH_BLOCK);\n\n      scanner_switch_info_t *switch_info_p;\n      switch_info_p = (scanner_switch_info_t *) scanner_insert_info (context_p,\n                                                                     context_p->source_p,\n                                                                     sizeof (scanner_switch_info_t));\n      switch_info_p->info.type = SCANNER_TYPE_SWITCH;\n      switch_info_p->case_p = NULL;\n      scanner_context_p->active_switch_statement.last_case_p = &switch_info_p->case_p;\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_RIGHT_BRACE\n          && context_p->token.type != LEXER_KEYW_CASE\n          && context_p->token.type != LEXER_KEYW_DEFAULT)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_CASE_STATEMENT:\n    {\n      if (type != LEXER_COLON)\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_CASE;\n\n      scanner_get_location (&location_info_p->location, context_p);\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_COLON_EXPRESSION:\n    {\n      if (type != LEXER_COLON)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_ARRAY_LITERAL:\n    case SCAN_STACK_OBJECT_LITERAL:\n    {\n      if (((stack_top == SCAN_STACK_ARRAY_LITERAL) && (type != LEXER_RIGHT_SQUARE))\n          || ((stack_top == SCAN_STACK_OBJECT_LITERAL) && (type != LEXER_RIGHT_BRACE)))\n      {\n        break;\n      }\n\n      scanner_source_start_t source_start;\n      uint8_t binding_type = scanner_context_p->binding_type;\n\n      parser_stack_pop_uint8 (context_p);\n      scanner_context_p->binding_type = context_p->stack_top_uint8;\n      parser_stack_pop_uint8 (context_p);\n      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n      lexer_next_token (context_p);\n\n      if (binding_type == SCANNER_BINDING_CATCH && context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT)\n      {\n        scanner_pop_binding_list (scanner_context_p);\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (context_p->token.type != LEXER_ASSIGN)\n      {\n        if (SCANNER_NEEDS_BINDING_LIST (binding_type))\n        {\n          scanner_pop_binding_list (scanner_context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_location_info_t *location_info_p;\n      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,\n                                                                         source_start.source_p,\n                                                                         sizeof (scanner_location_info_t));\n      location_info_p->info.type = SCANNER_TYPE_INITIALIZER;\n      scanner_get_location (&location_info_p->location, context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      if (SCANNER_NEEDS_BINDING_LIST (binding_type))\n      {\n        scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;\n\n        while (item_p != NULL)\n        {\n          item_p->literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_USED;\n          item_p = item_p->next_p;\n        }\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_LIST_INIT);\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n#else /* !ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_ARRAY_LITERAL:\n#endif /* ENABLED (JERRY_ES2015) */\n    case SCAN_STACK_PROPERTY_ACCESSOR:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#if !ENABLED (JERRY_ES2015)\n    case SCAN_STACK_OBJECT_LITERAL:\n    {\n      if (type != LEXER_RIGHT_BRACE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      parser_stack_pop_uint8 (context_p);\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* !ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015)\n    case SCAN_STACK_COMPUTED_PROPERTY:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n\n      parser_stack_pop_uint8 (context_p);\n      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n\n      if (stack_top == SCAN_STACK_FUNCTION_PROPERTY)\n      {\n        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);\n\n      if (context_p->token.type == LEXER_LEFT_PAREN)\n      {\n        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      if (context_p->token.type != LEXER_COLON)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)\n      {\n        scanner_context_p->mode = SCAN_MODE_BINDING;\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_COMPUTED_GENERATOR:\n    case SCAN_STACK_COMPUTED_ASYNC:\n    case SCAN_STACK_COMPUTED_ASYNC_GENERATOR:\n    {\n      if (type != LEXER_RIGHT_SQUARE)\n      {\n        break;\n      }\n\n      lexer_next_token (context_p);\n      parser_stack_pop_uint8 (context_p);\n\n      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL\n                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PROPERTY);\n\n      uint16_t status_flags = (uint16_t) (SCANNER_LITERAL_POOL_FUNCTION\n                                          | SCANNER_LITERAL_POOL_GENERATOR\n                                          | SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (stack_top));\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_TEMPLATE_STRING:\n    case SCAN_STACK_TAGGED_TEMPLATE_LITERAL:\n    {\n      if (type != LEXER_RIGHT_BRACE)\n      {\n        break;\n      }\n\n      context_p->source_p--;\n      context_p->column--;\n      lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);\n\n      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      }\n      else\n      {\n        parser_stack_pop_uint8 (context_p);\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      }\n      return SCAN_NEXT_TOKEN;\n    }\n    case SCAN_STACK_ARROW_ARGUMENTS:\n    {\n      if (type != LEXER_RIGHT_PAREN)\n      {\n        break;\n      }\n\n      scanner_check_arrow (context_p, scanner_context_p);\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_ARROW_EXPRESSION:\n    {\n      scanner_pop_literal_pool (context_p, scanner_context_p);\n      parser_stack_pop_uint8 (context_p);\n      lexer_update_await_yield (context_p, context_p->status_flags);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_CLASS_EXTENDS:\n    {\n      if (type != LEXER_LEFT_BRACE)\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_CLASS_METHOD;\n      parser_stack_pop_uint8 (context_p);\n\n      return SCAN_KEEP_TOKEN;\n    }\n    case SCAN_STACK_FUNCTION_PARAMETERS:\n    {\n      parser_stack_pop_uint8 (context_p);\n\n      if (type != LEXER_RIGHT_PAREN\n          && (type != LEXER_EOS || context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION))\n      {\n        break;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    default:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n  }\n\n  scanner_raise_error (context_p);\n  return SCAN_NEXT_TOKEN;\n} /* scanner_scan_primary_expression_end */\n\n/**\n * Scan statements.\n *\n * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing\n */\nstatic scan_return_types_t\nscanner_scan_statement (parser_context_t *context_p, /**< context */\n                        scanner_context_t *scanner_context_p, /**< scanner context */\n                        lexer_token_type_t type, /**< current token type */\n                        scan_stack_modes_t stack_top) /**< current stack top */\n{\n  switch (type)\n  {\n    case LEXER_SEMICOLON:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_LEFT_BRACE:\n    {\n#if ENABLED (JERRY_ES2015)\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p,\n                                                  scanner_context_p,\n                                                  SCANNER_LITERAL_POOL_BLOCK);\n      literal_pool_p->source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_DO:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_DO_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_TRY:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_BRACE)\n      {\n        scanner_raise_error (context_p);\n      }\n\n#if ENABLED (JERRY_ES2015)\n      scanner_literal_pool_t *literal_pool_p;\n      literal_pool_p = scanner_push_literal_pool (context_p,\n                                                  scanner_context_p,\n                                                  SCANNER_LITERAL_POOL_BLOCK);\n      literal_pool_p->source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_TRY_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_DEBUGGER:\n    {\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_IF:\n    case LEXER_KEYW_WITH:\n    case LEXER_KEYW_SWITCH:\n    {\n      lexer_next_token (context_p);\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      uint8_t mode = SCAN_STACK_STATEMENT_WITH_EXPR;\n\n      if (type == LEXER_KEYW_IF)\n      {\n        parser_stack_push_uint8 (context_p, SCAN_STACK_IF_STATEMENT);\n      }\n      else if (type == LEXER_KEYW_WITH)\n      {\n        mode = SCAN_STACK_WITH_EXPRESSION;\n      }\n      else if (type == LEXER_KEYW_SWITCH)\n      {\n        mode = SCAN_STACK_SWITCH_EXPRESSION;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      parser_stack_push_uint8 (context_p, mode);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_WHILE:\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n      scanner_source_start_t source_start;\n      source_start.source_p = context_p->source_p;\n\n      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_WHILE_EXPRESSION);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_FOR:\n    {\n      lexer_next_token (context_p);\n      if (context_p->token.type != LEXER_LEFT_PAREN)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_for_statement_t for_statement;\n      for_statement.u.source_p = context_p->source_p;\n      uint8_t stack_mode = SCAN_STACK_FOR_START;\n      scan_return_types_t return_type = SCAN_KEEP_TOKEN;\n\n      lexer_next_token (context_p);\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if ENABLED (JERRY_ES2015)\n      const uint8_t *source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      switch (context_p->token.type)\n      {\n        case LEXER_SEMICOLON:\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n          break;\n        }\n        case LEXER_KEYW_VAR:\n        {\n          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n          stack_mode = SCAN_STACK_FOR_VAR_START;\n          return_type = SCAN_NEXT_TOKEN;\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case LEXER_LITERAL:\n        {\n          if (!lexer_token_is_let (context_p))\n          {\n            break;\n          }\n\n          parser_line_counter_t line = context_p->line;\n          parser_line_counter_t column = context_p->column;\n\n          if (lexer_check_arrow (context_p))\n          {\n            context_p->source_p = source_p;\n            context_p->line = line;\n            context_p->column = column;\n            context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;\n            break;\n          }\n\n          lexer_next_token (context_p);\n\n          type = (lexer_token_type_t) context_p->token.type;\n\n          if (type != LEXER_LEFT_SQUARE\n              && type != LEXER_LEFT_BRACE\n              && (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL))\n          {\n            scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));\n            info_p->type = SCANNER_TYPE_LET_EXPRESSION;\n\n            scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n            break;\n          }\n\n          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n          /* FALLTHRU */\n        }\n        case LEXER_KEYW_LET:\n        case LEXER_KEYW_CONST:\n        {\n          scanner_literal_pool_t *literal_pool_p;\n          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);\n          literal_pool_p->source_p = source_p;\n\n          if (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION)\n          {\n            scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n            return_type = SCAN_NEXT_TOKEN;\n          }\n\n          stack_mode = ((context_p->token.type == LEXER_KEYW_CONST) ? SCAN_STACK_FOR_CONST_START\n                                                                    : SCAN_STACK_FOR_LET_START);\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));\n      parser_stack_push_uint8 (context_p, stack_mode);\n      return return_type;\n    }\n    case LEXER_KEYW_VAR:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_VAR);\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_LET:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_LET);\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_CONST:\n    {\n      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_CONST);\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n    case LEXER_KEYW_THROW:\n    {\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_RETURN:\n    {\n      lexer_next_token (context_p);\n\n      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n          && context_p->token.type != LEXER_SEMICOLON\n          && context_p->token.type != LEXER_EOS\n          && context_p->token.type != LEXER_RIGHT_BRACE)\n      {\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_KEYW_BREAK:\n    case LEXER_KEYW_CONTINUE:\n    {\n      lexer_next_token (context_p);\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n\n      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)\n          && context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n    case LEXER_KEYW_CASE:\n    case LEXER_KEYW_DEFAULT:\n    {\n      if (stack_top != SCAN_STACK_SWITCH_BLOCK)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      scanner_case_info_t *case_info_p;\n      case_info_p = (scanner_case_info_t *) scanner_malloc (context_p, sizeof (scanner_case_info_t));\n\n      *(scanner_context_p->active_switch_statement.last_case_p) = case_info_p;\n      scanner_context_p->active_switch_statement.last_case_p = &case_info_p->next_p;\n\n      case_info_p->next_p = NULL;\n      scanner_get_location (&case_info_p->location, context_p);\n\n      if (type == LEXER_KEYW_DEFAULT)\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_COLON)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      scanner_source_start_t source_start;\n      source_start.source_p = context_p->source_p;\n\n      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));\n      parser_stack_push_uint8 (context_p, SCAN_STACK_CASE_STATEMENT);\n\n      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_FUNCTION:\n    {\n#if ENABLED (JERRY_ES2015)\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_FUNCTION_STATEMENT;\n\n      if (scanner_context_p->async_source_p != NULL)\n      {\n        scanner_context_p->status_flags |= SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;\n        status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n        lexer_next_token (context_p);\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LOCAL);\n\n      if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)\n          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG)\n          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION))\n      {\n        scanner_raise_redeclaration_error (context_p);\n      }\n\n      literal_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION;\n\n      scanner_context_p->status_flags &= (uint16_t) ~SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;\n#else\n      literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);\n\n      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);\n      return SCAN_NEXT_TOKEN;\n    }\n#if ENABLED (JERRY_ES2015)\n    case LEXER_KEYW_CLASS:\n    {\n      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);\n\n      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n      scanner_detect_invalid_let (context_p, literal_p);\n      literal_p->type |= SCANNER_LITERAL_IS_LET;\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)\n      {\n        literal_p->type |= SCANNER_LITERAL_NO_REG;\n        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n      }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n      return SCAN_NEXT_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n    case LEXER_KEYW_IMPORT:\n    {\n      if (stack_top != SCAN_STACK_SCRIPT)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      context_p->global_status_flags |= ECMA_PARSE_MODULE;\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n      {\n        return SCAN_NEXT_TOKEN;\n      }\n\n      bool parse_imports = true;\n\n      if (context_p->token.type == LEXER_LITERAL\n          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n      {\n        lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n        scanner_detect_invalid_let (context_p, literal_p);\n        literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n#else /* !ENABLED (JERRY_ES2015) */\n        literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;\n#endif /* ENABLED (JERRY_ES2015) */\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_COMMA)\n        {\n          lexer_next_token (context_p);\n        }\n        else\n        {\n          parse_imports = false;\n        }\n      }\n\n      if (parse_imports)\n      {\n        if (context_p->token.type == LEXER_MULTIPLY)\n        {\n          lexer_next_token (context_p);\n          if (!lexer_token_is_identifier (context_p, \"as\", 2))\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LITERAL\n              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n          scanner_detect_invalid_let (context_p, literal_p);\n          literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n#else /* !ENABLED (JERRY_ES2015) */\n          literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          lexer_next_token (context_p);\n        }\n        else if (context_p->token.type == LEXER_LEFT_BRACE)\n        {\n          lexer_next_token (context_p);\n\n          while (context_p->token.type != LEXER_RIGHT_BRACE)\n          {\n            if (context_p->token.type != LEXER_LITERAL\n                || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n#if ENABLED (JERRY_ES2015)\n            const uint8_t *source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (lexer_check_next_character (context_p, LIT_CHAR_LOWERCASE_A))\n            {\n              lexer_next_token (context_p);\n\n              if (!lexer_token_is_identifier (context_p, \"as\", 2))\n              {\n                scanner_raise_error (context_p);\n              }\n\n              lexer_next_token (context_p);\n\n              if (context_p->token.type != LEXER_LITERAL\n                  && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n              {\n                scanner_raise_error (context_p);\n              }\n\n#if ENABLED (JERRY_ES2015)\n              source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n            }\n\n            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (literal_p->type & (SCANNER_LITERAL_IS_ARG\n                                   | SCANNER_LITERAL_IS_VAR\n                                   | SCANNER_LITERAL_IS_LOCAL))\n            {\n              context_p->source_p = source_p;\n              scanner_raise_redeclaration_error (context_p);\n            }\n\n            if (literal_p->type & SCANNER_LITERAL_IS_FUNC)\n            {\n              literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;\n            }\n\n            literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;\n#else /* !ENABLED (JERRY_ES2015) */\n            literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            lexer_next_token (context_p);\n\n            if (context_p->token.type != LEXER_RIGHT_BRACE)\n            {\n              if (context_p->token.type != LEXER_COMMA)\n              {\n                scanner_raise_error (context_p);\n              }\n\n              lexer_next_token (context_p);\n            }\n          }\n\n          lexer_next_token (context_p);\n        }\n        else\n        {\n          scanner_raise_error (context_p);\n        }\n      }\n\n      if (!lexer_token_is_identifier (context_p, \"from\", 4))\n      {\n        scanner_raise_error (context_p);\n      }\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          && context_p->token.lit_location.type != LEXER_STRING_LITERAL)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      return SCAN_NEXT_TOKEN;\n    }\n    case LEXER_KEYW_EXPORT:\n    {\n      if (stack_top != SCAN_STACK_SCRIPT)\n      {\n        scanner_raise_error (context_p);\n      }\n\n      context_p->global_status_flags |= ECMA_PARSE_MODULE;\n\n      lexer_next_token (context_p);\n\n      if (context_p->token.type == LEXER_KEYW_DEFAULT)\n      {\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_KEYW_FUNCTION)\n        {\n          lexer_next_token (context_p);\n          if (context_p->token.type == LEXER_LITERAL\n              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (location_p->type & SCANNER_LITERAL_IS_LOCAL\n                && !(location_p->type & SCANNER_LITERAL_IS_FUNC))\n            {\n              scanner_raise_redeclaration_error (context_p);\n            }\n            location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;\n#else /* !ENABLED (JERRY_ES2015) */\n            location_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            lexer_next_token (context_p);\n          }\n          else\n          {\n            lexer_lit_location_t *location_p;\n            location_p = scanner_add_custom_literal (context_p,\n                                                     scanner_context_p->active_literal_pool_p,\n                                                     &lexer_default_literal);\n#if ENABLED (JERRY_ES2015)\n            location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;\n#else /* !ENABLED (JERRY_ES2015) */\n            location_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;\n#endif /* ENABLED (JERRY_ES2015) */\n          }\n\n          scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);\n          scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n          return SCAN_KEEP_TOKEN;\n        }\n#if ENABLED (JERRY_ES2015)\n        if (context_p->token.type == LEXER_KEYW_CLASS)\n        {\n          scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);\n\n          if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n          {\n            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);\n\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;\n            return SCAN_NEXT_TOKEN;\n          }\n\n          lexer_lit_location_t *literal_p;\n          literal_p = scanner_add_custom_literal (context_p,\n                                                  scanner_context_p->active_literal_pool_p,\n                                                  &lexer_default_literal);\n          literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        /* Assignment expression. */\n        lexer_lit_location_t *location_p;\n        location_p = scanner_add_custom_literal (context_p,\n                                                 scanner_context_p->active_literal_pool_p,\n                                                 &lexer_default_literal);\n        location_p->type |= SCANNER_LITERAL_IS_VAR;\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n        if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n        {\n          return SCAN_KEEP_TOKEN;\n        }\n\n        location_p = scanner_add_literal (context_p, scanner_context_p);\n        location_p->type |= SCANNER_LITERAL_IS_VAR;\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;\n\n      if (context_p->token.type == LEXER_MULTIPLY)\n      {\n        lexer_next_token (context_p);\n        if (!lexer_token_is_identifier (context_p, \"from\", 4))\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LITERAL\n            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n\n      if (context_p->token.type == LEXER_LEFT_BRACE)\n      {\n        lexer_next_token (context_p);\n\n        while (context_p->token.type != LEXER_RIGHT_BRACE)\n        {\n          if (context_p->token.type != LEXER_LITERAL\n              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (lexer_token_is_identifier (context_p, \"as\", 2))\n          {\n            lexer_next_token (context_p);\n\n            if (context_p->token.type != LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            lexer_next_token (context_p);\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_BRACE)\n          {\n            if (context_p->token.type != LEXER_COMMA)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            lexer_next_token (context_p);\n          }\n        }\n\n        lexer_next_token (context_p);\n\n        if (!lexer_token_is_identifier (context_p, \"from\", 4))\n        {\n          return SCAN_KEEP_TOKEN;\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LITERAL\n            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        return SCAN_NEXT_TOKEN;\n      }\n\n      switch (context_p->token.type)\n      {\n#if ENABLED (JERRY_ES2015)\n        case LEXER_KEYW_CLASS:\n        case LEXER_KEYW_LET:\n        case LEXER_KEYW_CONST:\n#endif /* ENABLED (JERRY_ES2015) */\n        case LEXER_KEYW_VAR:\n        {\n          scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IN_EXPORT;\n          break;\n        }\n      }\n\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n    default:\n    {\n      break;\n    }\n  }\n\n  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n  if (type == LEXER_LITERAL\n      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)\n  {\n    if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))\n    {\n      lexer_consume_next_character (context_p);\n      scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      return SCAN_NEXT_TOKEN;\n    }\n\n    JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);\n\n#if ENABLED (JERRY_ES2015)\n    /* The colon needs to be checked first because the parser also checks\n     * it first, and this check skips the spaces which affects source_p. */\n    if (JERRY_UNLIKELY (lexer_check_arrow (context_p)))\n    {\n      scanner_scan_simple_arrow (context_p, scanner_context_p, context_p->source_p);\n      return SCAN_KEEP_TOKEN;\n    }\n\n    if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))\n    {\n      lexer_lit_location_t let_literal = context_p->token.lit_location;\n      const uint8_t *source_p = context_p->source_p;\n\n      lexer_next_token (context_p);\n\n      type = (lexer_token_type_t) context_p->token.type;\n\n      if (type == LEXER_LEFT_SQUARE\n          || type == LEXER_LEFT_BRACE\n          || (type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL))\n      {\n        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;\n        parser_stack_push_uint8 (context_p, SCAN_STACK_LET);\n        return SCAN_KEEP_TOKEN;\n      }\n\n      scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));\n      info_p->type = SCANNER_TYPE_LET_EXPRESSION;\n\n      lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,\n                                                                         scanner_context_p->active_literal_pool_p,\n                                                                         &let_literal);\n      lit_location_p->type |= SCANNER_LITERAL_IS_USED;\n\n      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n      {\n        lit_location_p->type |= SCANNER_LITERAL_NO_REG;\n      }\n\n      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n      return SCAN_KEEP_TOKEN;\n    }\n\n    if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))\n    {\n      scanner_context_p->async_source_p = context_p->source_p;\n\n      if (scanner_check_async_function (context_p, scanner_context_p))\n      {\n        scanner_context_p->mode = SCAN_MODE_STATEMENT;\n      }\n      return SCAN_KEEP_TOKEN;\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    scanner_add_reference (context_p, scanner_context_p);\n\n    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n    return SCAN_NEXT_TOKEN;\n  }\n\n  return SCAN_KEEP_TOKEN;\n} /* scanner_scan_statement */\n\n/**\n * Scan statement terminator.\n *\n * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing\n */\nstatic scan_return_types_t\nscanner_scan_statement_end (parser_context_t *context_p, /**< context */\n                            scanner_context_t *scanner_context_p, /**< scanner context */\n                            lexer_token_type_t type) /**< current token type */\n{\n  bool terminator_found = false;\n\n  if (type == LEXER_SEMICOLON)\n  {\n    lexer_next_token (context_p);\n    terminator_found = true;\n  }\n\n  while (true)\n  {\n    type = (lexer_token_type_t) context_p->token.type;\n\n    switch (context_p->stack_top_uint8)\n    {\n      case SCAN_STACK_SCRIPT:\n      case SCAN_STACK_SCRIPT_FUNCTION:\n      {\n        if (type == LEXER_EOS)\n        {\n          return SCAN_NEXT_TOKEN;\n        }\n        break;\n      }\n      case SCAN_STACK_BLOCK_STATEMENT:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_CLASS_STATEMENT:\n#endif /* ENABLED (JERRY_ES2015) */\n      case SCAN_STACK_FUNCTION_STATEMENT:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 != SCAN_STACK_CLASS_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#else /* !ENABLED (JERRY_ES2015) */\n        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        terminator_found = true;\n        parser_stack_pop_uint8 (context_p);\n        lexer_next_token (context_p);\n        continue;\n      }\n      case SCAN_STACK_FUNCTION_EXPRESSION:\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_FUNCTION_ARROW:\n#endif /* ENABLED (JERRY_ES2015) */\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_ARROW)\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        parser_stack_pop_uint8 (context_p);\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_FUNCTION_PROPERTY:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        parser_stack_pop_uint8 (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->stack_top_uint8 == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR\n            || context_p->stack_top_uint8 == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n        {\n          scanner_context_p->mode = SCAN_MODE_CLASS_METHOD;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL);\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type == LEXER_RIGHT_BRACE)\n        {\n          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n          return SCAN_KEEP_TOKEN;\n        }\n\n        if (context_p->token.type != LEXER_COMMA)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n        return SCAN_KEEP_TOKEN;\n      }\n      case SCAN_STACK_SWITCH_BLOCK:\n      {\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        scanner_switch_statement_t switch_statement;\n\n        parser_stack_pop_uint8 (context_p);\n        parser_stack_pop (context_p, &switch_statement, sizeof (scanner_switch_statement_t));\n\n        scanner_context_p->active_switch_statement = switch_statement;\n\n#if ENABLED (JERRY_ES2015)\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n        terminator_found = true;\n        lexer_next_token (context_p);\n        continue;\n      }\n      case SCAN_STACK_IF_STATEMENT:\n      {\n        parser_stack_pop_uint8 (context_p);\n\n        if (type == LEXER_KEYW_ELSE\n            && (terminator_found || (context_p->token.flags & LEXER_WAS_NEWLINE)))\n        {\n#if ENABLED (JERRY_ES2015)\n          scanner_check_function_after_if (context_p, scanner_context_p);\n          return SCAN_KEEP_TOKEN;\n#else /* !ENABLED (JERRY_ES2015) */\n          scanner_context_p->mode = SCAN_MODE_STATEMENT;\n          return SCAN_NEXT_TOKEN;\n#endif /* ENABLED (JERRY_ES2015) */\n        }\n        continue;\n      }\n      case SCAN_STACK_WITH_STATEMENT:\n      {\n        scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;\n\n        JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH);\n\n        parser_stack_pop_uint8 (context_p);\n\n        if (context_p->stack_top_uint8 == 0)\n        {\n          literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_WITH;\n        }\n\n        parser_stack_pop_uint8 (context_p);\n        continue;\n      }\n      case SCAN_STACK_DO_STATEMENT:\n      {\n        parser_stack_pop_uint8 (context_p);\n\n        if (type != LEXER_KEYW_WHILE\n            || (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE)))\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n        if (context_p->token.type != LEXER_LEFT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        parser_stack_push_uint8 (context_p, SCAN_STACK_DO_EXPRESSION);\n        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;\n        return SCAN_NEXT_TOKEN;\n      }\n      case SCAN_STACK_DO_EXPRESSION:\n      {\n        parser_stack_pop_uint8 (context_p);\n        terminator_found = true;\n        continue;\n      }\n#if ENABLED (JERRY_ES2015)\n      case SCAN_STACK_PRIVATE_BLOCK_EARLY:\n      {\n        parser_list_iterator_t literal_iterator;\n        lexer_lit_location_t *literal_p;\n\n        parser_list_iterator_init (&scanner_context_p->active_literal_pool_p->literal_pool, &literal_iterator);\n\n        while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n        {\n          if ((literal_p->type & (SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_IS_CONST))\n              && literal_p->type & SCANNER_LITERAL_NO_REG)\n          {\n            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n          }\n        }\n        /* FALLTHRU */\n      }\n      case SCAN_STACK_PRIVATE_BLOCK:\n      {\n        parser_stack_pop_uint8 (context_p);\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n        continue;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      default:\n      {\n        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_TRY_STATEMENT\n                      || context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT);\n\n        if (type != LEXER_RIGHT_BRACE)\n        {\n          break;\n        }\n\n        uint8_t stack_top = context_p->stack_top_uint8;\n        parser_stack_pop_uint8 (context_p);\n        lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n        scanner_pop_literal_pool (context_p, scanner_context_p);\n#else /* !ENABLED (JERRY_ES2015) */\n        if (stack_top == SCAN_STACK_CATCH_STATEMENT)\n        {\n          scanner_pop_literal_pool (context_p, scanner_context_p);\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        /* A finally statement is optional after a try or catch statement. */\n        if (context_p->token.type == LEXER_KEYW_FINALLY)\n        {\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n#if ENABLED (JERRY_ES2015)\n          scanner_literal_pool_t *literal_pool_p;\n          literal_pool_p = scanner_push_literal_pool (context_p,\n                                                      scanner_context_p,\n                                                      SCANNER_LITERAL_POOL_BLOCK);\n          literal_pool_p->source_p = context_p->source_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);\n          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n          return SCAN_NEXT_TOKEN;\n        }\n\n        if (stack_top == SCAN_STACK_CATCH_STATEMENT)\n        {\n          terminator_found = true;\n          continue;\n        }\n\n        /* A catch statement must be present after a try statement unless a finally is provided. */\n        if (context_p->token.type != LEXER_KEYW_CATCH)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_literal_pool_t *literal_pool_p;\n        literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);\n        literal_pool_p->source_p = context_p->source_p;\n\n        lexer_next_token (context_p);\n        parser_stack_push_uint8 (context_p, SCAN_STACK_CATCH_STATEMENT);\n\n#if ENABLED (JERRY_ES2015)\n        if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n        {\n          scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_CATCH, false);\n\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n            scanner_context_p->mode = SCAN_MODE_BINDING;\n            return SCAN_NEXT_TOKEN;\n          }\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n          scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;\n          return SCAN_KEEP_TOKEN;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n\n        if (context_p->token.type != LEXER_LITERAL\n            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_lit_location_t *lit_location_p = scanner_add_literal (context_p, scanner_context_p);\n        lit_location_p->type |= SCANNER_LITERAL_IS_LOCAL;\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_RIGHT_PAREN)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        lexer_next_token (context_p);\n\n        if (context_p->token.type != LEXER_LEFT_BRACE)\n        {\n          scanner_raise_error (context_p);\n        }\n\n        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;\n        return SCAN_NEXT_TOKEN;\n      }\n    }\n\n    if (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE))\n    {\n      scanner_raise_error (context_p);\n    }\n\n    scanner_context_p->mode = SCAN_MODE_STATEMENT;\n    return SCAN_KEEP_TOKEN;\n  }\n} /* scanner_scan_statement_end */\n\n/**\n * Scan the whole source code.\n */\nvoid JERRY_ATTR_NOINLINE\nscanner_scan_all (parser_context_t *context_p, /**< context */\n                  const uint8_t *arg_list_p, /**< function argument list */\n                  const uint8_t *arg_list_end_p, /**< end of argument list */\n                  const uint8_t *source_p, /**< valid UTF-8 source code */\n                  const uint8_t *source_end_p) /**< end of source code */\n{\n  scanner_context_t scanner_context;\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    JERRY_DEBUG_MSG (\"\\n--- Scanning start ---\\n\\n\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  scanner_context.context_status_flags = context_p->status_flags;\n  scanner_context.status_flags = SCANNER_CONTEXT_NO_FLAGS;\n#if ENABLED (JERRY_DEBUGGER)\n  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n  {\n    scanner_context.status_flags |= SCANNER_CONTEXT_DEBUGGER_ENABLED;\n  }\n#endif /* ENABLED (JERRY_DEBUGGER) */\n#if ENABLED (JERRY_ES2015)\n  scanner_context.binding_type = SCANNER_BINDING_NONE;\n  scanner_context.active_binding_list_p = NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n  scanner_context.active_literal_pool_p = NULL;\n  scanner_context.active_switch_statement.last_case_p = NULL;\n  scanner_context.end_arguments_p = NULL;\n#if ENABLED (JERRY_ES2015)\n  scanner_context.async_source_p = NULL;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  /* This assignment must be here because of Apple compilers. */\n  context_p->u.scanner_context_p = &scanner_context;\n\n  parser_stack_init (context_p);\n\n  PARSER_TRY (context_p->try_buffer)\n  {\n    context_p->line = 1;\n    context_p->column = 1;\n\n    if (arg_list_p == NULL)\n    {\n      context_p->source_p = source_p;\n      context_p->source_end_p = source_end_p;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION_WITHOUT_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL;\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n      }\n\n      scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n      literal_pool_p->source_p = source_p;\n\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT);\n\n      lexer_next_token (context_p);\n      scanner_check_directives (context_p, &scanner_context);\n    }\n    else\n    {\n      context_p->source_p = arg_list_p;\n      context_p->source_end_p = arg_list_end_p;\n\n      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n      if (context_p->status_flags & PARSER_IS_STRICT)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n      {\n        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n\n      scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n      scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT_FUNCTION);\n\n      /* Faking the first token. */\n      context_p->token.type = LEXER_LEFT_PAREN;\n    }\n\n    while (true)\n    {\n      lexer_token_type_t type = (lexer_token_type_t) context_p->token.type;\n      scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n\n      switch (scanner_context.mode)\n      {\n        case SCAN_MODE_PRIMARY_EXPRESSION:\n        {\n          if (type == LEXER_ADD\n              || type == LEXER_SUBTRACT\n              || LEXER_IS_UNARY_OP_TOKEN (type))\n          {\n            break;\n          }\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW:\n        {\n          if (scanner_scan_primary_expression (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCAN_MODE_CLASS_DECLARATION:\n        {\n          if (context_p->token.type == LEXER_KEYW_EXTENDS)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_EXTENDS);\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n          else if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_context.mode = SCAN_MODE_CLASS_METHOD;\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_CLASS_METHOD:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR\n                        || stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n\n          lexer_skip_empty_statements (context_p);\n\n          lexer_scan_identifier (context_p);\n\n          if (context_p->token.type == LEXER_RIGHT_BRACE)\n          {\n            scanner_source_start_t source_start;\n\n            parser_stack_pop_uint8 (context_p);\n\n            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n            {\n              parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n            }\n\n            stack_top = context_p->stack_top_uint8;\n\n            JERRY_ASSERT (stack_top == SCAN_STACK_CLASS_STATEMENT || stack_top == SCAN_STACK_CLASS_EXPRESSION);\n\n            if (stack_top == SCAN_STACK_CLASS_STATEMENT)\n            {\n              /* The token is kept to disallow consuming a semicolon after it. */\n              scanner_context.mode = SCAN_MODE_STATEMENT_END;\n              continue;\n            }\n\n            scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n            parser_stack_pop_uint8 (context_p);\n            break;\n          }\n\n          if (context_p->token.type == LEXER_LITERAL\n              && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)\n              && lexer_compare_literal_to_string (context_p, \"constructor\", 11))\n          {\n            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n            {\n              scanner_source_start_t source_start;\n              parser_stack_pop_uint8 (context_p);\n              parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n\n              scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));\n              info_p->type = SCANNER_TYPE_CLASS_CONSTRUCTOR;\n              parser_stack_push_uint8 (context_p, SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n            }\n          }\n\n          if (lexer_token_is_identifier (context_p, \"static\", 6))\n          {\n            lexer_scan_identifier (context_p);\n          }\n\n          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n          scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n\n          uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n          if (lexer_token_is_identifier (context_p, \"get\", 3)\n              || lexer_token_is_identifier (context_p, \"set\", 3))\n          {\n            lexer_scan_identifier (context_p);\n\n            if (context_p->token.type == LEXER_LEFT_PAREN)\n            {\n              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n              continue;\n            }\n          }\n          else if (lexer_token_is_identifier (context_p, \"async\", 5))\n          {\n            lexer_scan_identifier (context_p);\n\n            if (context_p->token.type == LEXER_LEFT_PAREN)\n            {\n              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n              continue;\n            }\n\n            literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n\n            if (context_p->token.type == LEXER_MULTIPLY)\n            {\n              lexer_scan_identifier (context_p);\n              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n            }\n          }\n          else if (context_p->token.type == LEXER_MULTIPLY)\n          {\n            lexer_scan_identifier (context_p);\n            literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n          }\n\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n\n          if (context_p->token.type != LEXER_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          if (literal_pool_flags & SCANNER_LITERAL_POOL_GENERATOR)\n          {\n            context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n          }\n\n          scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n          lexer_next_token (context_p);\n          continue;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case SCAN_MODE_POST_PRIMARY_EXPRESSION:\n        {\n          if (scanner_scan_post_primary_expression (context_p, &scanner_context, type, stack_top))\n          {\n            break;\n          }\n          type = (lexer_token_type_t) context_p->token.type;\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_PRIMARY_EXPRESSION_END:\n        {\n          if (scanner_scan_primary_expression_end (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n        case SCAN_MODE_STATEMENT_OR_TERMINATOR:\n        {\n          if (type == LEXER_RIGHT_BRACE || type == LEXER_EOS)\n          {\n            scanner_context.mode = SCAN_MODE_STATEMENT_END;\n            continue;\n          }\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_STATEMENT:\n        {\n          if (scanner_scan_statement (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n          break;\n        }\n        case SCAN_MODE_STATEMENT_END:\n        {\n          if (scanner_scan_statement_end (context_p, &scanner_context, type) != SCAN_NEXT_TOKEN)\n          {\n            continue;\n          }\n\n          if (context_p->token.type == LEXER_EOS)\n          {\n            goto scan_completed;\n          }\n\n          break;\n        }\n        case SCAN_MODE_VAR_STATEMENT:\n        {\n#if ENABLED (JERRY_ES2015)\n          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n          {\n            uint8_t binding_type = SCANNER_BINDING_VAR;\n\n            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n            {\n              binding_type = SCANNER_BINDING_LET;\n            }\n            else if (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START)\n            {\n              binding_type = SCANNER_BINDING_CONST;\n            }\n\n            scanner_push_destructuring_pattern (context_p, &scanner_context, binding_type, false);\n\n            if (type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n              scanner_context.mode = SCAN_MODE_BINDING;\n              break;\n            }\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n            continue;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (type != LEXER_LITERAL\n              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n\n#if ENABLED (JERRY_ES2015)\n          if (stack_top != SCAN_STACK_VAR && stack_top != SCAN_STACK_FOR_VAR_START)\n          {\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n            {\n              literal_p->type |= SCANNER_LITERAL_IS_LET;\n            }\n            else\n            {\n              JERRY_ASSERT (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START);\n              literal_p->type |= SCANNER_LITERAL_IS_CONST;\n            }\n\n            lexer_next_token (context_p);\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n            }\n            else if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_binding_literal_t binding_literal;\n              binding_literal.literal_p = literal_p;\n\n              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n            }\n          }\n          else\n          {\n            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n            {\n              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n              literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n              {\n                literal_p->type |= SCANNER_LITERAL_NO_REG;\n              }\n            }\n\n            lexer_next_token (context_p);\n          }\n#else /* !ENABLED (JERRY_ES2015) */\n          literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n          {\n            literal_p->type |= SCANNER_LITERAL_NO_REG;\n          }\n\n          lexer_next_token (context_p);\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)\n          {\n            literal_p->type |= SCANNER_LITERAL_NO_REG;\n          }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n          switch (context_p->token.type)\n          {\n            case LEXER_ASSIGN:\n            {\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              /* FALLTHRU */\n            }\n            case LEXER_COMMA:\n            {\n              lexer_next_token (context_p);\n              continue;\n            }\n          }\n\n          if (SCANNER_IS_FOR_START (stack_top))\n          {\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n            JERRY_ASSERT (!(scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT));\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n            if (context_p->token.type != LEXER_SEMICOLON\n                && context_p->token.type != LEXER_KEYW_IN\n                && !SCANNER_IDENTIFIER_IS_OF ())\n            {\n              scanner_raise_error (context_p);\n            }\n\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n\n#if ENABLED (JERRY_ES2015)\n          JERRY_ASSERT (stack_top == SCAN_STACK_VAR || stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_CONST);\n#else /* !ENABLED (JERRY_ES2015) */\n          JERRY_ASSERT (stack_top == SCAN_STACK_VAR);\n#endif /* ENABLED (JERRY_ES2015) */\n\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n          scanner_context.active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n\n          scanner_context.mode = SCAN_MODE_STATEMENT_END;\n          parser_stack_pop_uint8 (context_p);\n          continue;\n        }\n        case SCAN_MODE_FUNCTION_ARGUMENTS:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_SCRIPT_FUNCTION\n                        || stack_top == SCAN_STACK_FUNCTION_STATEMENT\n                        || stack_top == SCAN_STACK_FUNCTION_EXPRESSION\n                        || stack_top == SCAN_STACK_FUNCTION_PROPERTY);\n\n          scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n\n          JERRY_ASSERT (literal_pool_p != NULL && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION));\n\n          literal_pool_p->source_p = context_p->source_p;\n\n#if ENABLED (JERRY_ES2015)\n          if (JERRY_UNLIKELY (scanner_context.async_source_p != NULL))\n          {\n            literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n            literal_pool_p->source_p = scanner_context.async_source_p;\n            scanner_context.async_source_p = NULL;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (type != LEXER_LEFT_PAREN)\n          {\n            scanner_raise_error (context_p);\n          }\n          lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n          /* FALLTHRU */\n        }\n        case SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS:\n        {\n#endif /* ENABLED (JERRY_ES2015) */\n          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)\n          {\n#if ENABLED (JERRY_ES2015)\n            lexer_lit_location_t *argument_literal_p;\n#endif /* ENABLED (JERRY_ES2015) */\n\n            while (true)\n            {\n#if ENABLED (JERRY_ES2015)\n              if (context_p->token.type == LEXER_THREE_DOTS)\n              {\n                scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n\n                lexer_next_token (context_p);\n              }\n\n              if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n              {\n                argument_literal_p = NULL;\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n\n              if (context_p->token.type != LEXER_LITERAL\n                  || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n              {\n                scanner_raise_error (context_p);\n              }\n\n#if ENABLED (JERRY_ES2015)\n              argument_literal_p = scanner_append_argument (context_p, &scanner_context);\n#else /* !ENABLED (JERRY_ES2015) */\n              scanner_append_argument (context_p, &scanner_context);\n#endif /* ENABLED (JERRY_ES2015) */\n\n              lexer_next_token (context_p);\n\n              if (context_p->token.type != LEXER_COMMA)\n              {\n                break;\n              }\n              lexer_next_token (context_p);\n            }\n\n#if ENABLED (JERRY_ES2015)\n            if (argument_literal_p == NULL)\n            {\n              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n              scanner_append_hole (context_p, &scanner_context);\n              scanner_push_destructuring_pattern (context_p, &scanner_context, SCANNER_BINDING_ARG, false);\n\n              if (context_p->token.type == LEXER_LEFT_SQUARE)\n              {\n                parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n                scanner_context.mode = SCAN_MODE_BINDING;\n                break;\n              }\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n              scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n              continue;\n            }\n\n            if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n\n              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n              if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)\n              {\n                JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);\n                break;\n              }\n\n              scanner_binding_literal_t binding_literal;\n              binding_literal.literal_p = argument_literal_p;\n\n              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n              break;\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n          }\n\n          if (context_p->token.type == LEXER_EOS && stack_top == SCAN_STACK_SCRIPT_FUNCTION)\n          {\n            /* End of argument parsing. */\n            scanner_info_t *scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, sizeof (scanner_info_t));\n            scanner_info_p->next_p = context_p->next_scanner_info_p;\n            scanner_info_p->source_p = NULL;\n            scanner_info_p->type = SCANNER_TYPE_END_ARGUMENTS;\n            scanner_context.end_arguments_p = scanner_info_p;\n\n            context_p->next_scanner_info_p = scanner_info_p;\n            context_p->source_p = source_p;\n            context_p->source_end_p = source_end_p;\n            context_p->line = 1;\n            context_p->column = 1;\n\n            scanner_filter_arguments (context_p, &scanner_context);\n            lexer_next_token (context_p);\n            scanner_check_directives (context_p, &scanner_context);\n            continue;\n          }\n\n          if (context_p->token.type != LEXER_RIGHT_PAREN)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          lexer_next_token (context_p);\n\n          if (context_p->token.type != LEXER_LEFT_BRACE)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_filter_arguments (context_p, &scanner_context);\n          lexer_next_token (context_p);\n          scanner_check_directives (context_p, &scanner_context);\n          continue;\n        }\n        case SCAN_MODE_PROPERTY_NAME:\n        {\n          JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);\n\n          if (lexer_scan_identifier (context_p))\n          {\n            lexer_check_property_modifier (context_p);\n          }\n\n#if ENABLED (JERRY_ES2015)\n          if (context_p->token.type == LEXER_LEFT_SQUARE)\n          {\n            parser_stack_push_uint8 (context_p, SCAN_STACK_COMPUTED_PROPERTY);\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            break;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (context_p->token.type == LEXER_RIGHT_BRACE)\n          {\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n\n          if (context_p->token.type == LEXER_PROPERTY_GETTER\n#if ENABLED (JERRY_ES2015)\n              || context_p->token.type == LEXER_KEYW_ASYNC\n              || context_p->token.type == LEXER_MULTIPLY\n#endif /* ENABLED (JERRY_ES2015) */\n              || context_p->token.type == LEXER_PROPERTY_SETTER)\n          {\n            uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n\n#if ENABLED (JERRY_ES2015)\n            if (context_p->token.type == LEXER_MULTIPLY)\n            {\n              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n            }\n            else if (context_p->token.type == LEXER_KEYW_ASYNC)\n            {\n              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n\n              if (lexer_consume_generator (context_p))\n              {\n                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n              }\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            lexer_scan_identifier (context_p);\n\n#if ENABLED (JERRY_ES2015)\n            if (context_p->token.type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              break;\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (context_p->token.type != LEXER_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n            break;\n          }\n\n          if (context_p->token.type != LEXER_LITERAL)\n          {\n            scanner_raise_error (context_p);\n          }\n\n#if ENABLED (JERRY_ES2015)\n          parser_line_counter_t start_line = context_p->token.line;\n          parser_line_counter_t start_column = context_p->token.column;\n          bool is_ident = (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n#endif /* ENABLED (JERRY_ES2015) */\n\n          lexer_next_token (context_p);\n\n#if ENABLED (JERRY_ES2015)\n          if (context_p->token.type == LEXER_LEFT_PAREN)\n          {\n            scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n            continue;\n          }\n\n          if (is_ident\n              && (context_p->token.type == LEXER_COMMA\n                  || context_p->token.type == LEXER_RIGHT_BRACE\n                  || context_p->token.type == LEXER_ASSIGN))\n          {\n            context_p->source_p = context_p->token.lit_location.char_p;\n            context_p->line = start_line;\n            context_p->column = start_column;\n\n            lexer_next_token (context_p);\n\n            JERRY_ASSERT (context_p->token.type != LEXER_LITERAL\n                          || context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n            if (context_p->token.type != LEXER_LITERAL)\n            {\n              scanner_raise_error (context_p);\n            }\n\n            if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n            {\n              scanner_context.mode = SCAN_MODE_BINDING;\n              continue;\n            }\n\n            scanner_add_reference (context_p, &scanner_context);\n\n            lexer_next_token (context_p);\n\n            if (context_p->token.type == LEXER_ASSIGN)\n            {\n              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n              break;\n            }\n\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n            continue;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n\n          if (context_p->token.type != LEXER_COLON)\n          {\n            scanner_raise_error (context_p);\n          }\n\n          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n\n#if ENABLED (JERRY_ES2015)\n          if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n          {\n            scanner_context.mode = SCAN_MODE_BINDING;\n          }\n#endif /* ENABLED (JERRY_ES2015) */\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCAN_MODE_BINDING:\n        {\n          JERRY_ASSERT (scanner_context.binding_type == SCANNER_BINDING_VAR\n                        || scanner_context.binding_type == SCANNER_BINDING_LET\n                        || scanner_context.binding_type == SCANNER_BINDING_CATCH\n                        || scanner_context.binding_type == SCANNER_BINDING_CONST\n                        || scanner_context.binding_type == SCANNER_BINDING_ARG\n                        || scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG);\n\n          if (type == LEXER_THREE_DOTS)\n          {\n            lexer_next_token (context_p);\n            type = (lexer_token_type_t) context_p->token.type;\n          }\n\n          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n          {\n            scanner_push_destructuring_pattern (context_p, &scanner_context, scanner_context.binding_type, true);\n\n            if (type == LEXER_LEFT_SQUARE)\n            {\n              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n              break;\n            }\n\n            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n            continue;\n          }\n\n          if (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n          {\n            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n            continue;\n          }\n\n          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n\n          scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n\n          if (scanner_context.binding_type == SCANNER_BINDING_VAR)\n          {\n            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n            {\n              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n              literal_p->type |= SCANNER_LITERAL_IS_VAR;\n\n              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n              {\n                literal_p->type |= SCANNER_LITERAL_NO_REG;\n              }\n            }\n            break;\n          }\n\n          if (scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG)\n          {\n            literal_p->type |= SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n              break;\n            }\n          }\n          else\n          {\n            scanner_detect_invalid_let (context_p, literal_p);\n\n            if (scanner_context.binding_type <= SCANNER_BINDING_CATCH)\n            {\n              JERRY_ASSERT ((scanner_context.binding_type == SCANNER_BINDING_LET)\n                            || (scanner_context.binding_type == SCANNER_BINDING_CATCH));\n\n              literal_p->type |= SCANNER_LITERAL_IS_LET;\n            }\n            else\n            {\n              literal_p->type |= SCANNER_LITERAL_IS_CONST;\n\n              if (scanner_context.binding_type == SCANNER_BINDING_ARG)\n              {\n                literal_p->type |= SCANNER_LITERAL_IS_ARG;\n\n                if (literal_p->type & SCANNER_LITERAL_IS_USED)\n                {\n                  literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n                  break;\n                }\n              }\n            }\n\n            if (literal_p->type & SCANNER_LITERAL_IS_USED)\n            {\n              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n              break;\n            }\n          }\n\n          scanner_binding_item_t *binding_item_p;\n          binding_item_p = (scanner_binding_item_t *) scanner_malloc (context_p, sizeof (scanner_binding_item_t));\n\n          binding_item_p->next_p = scanner_context.active_binding_list_p->items_p;\n          binding_item_p->literal_p = literal_p;\n\n          scanner_context.active_binding_list_p->items_p = binding_item_p;\n\n          lexer_next_token (context_p);\n          if (context_p->token.type != LEXER_ASSIGN)\n          {\n            continue;\n          }\n\n          scanner_binding_literal_t binding_literal;\n          binding_literal.literal_p = literal_p;\n\n          parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n          parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n\n          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      lexer_next_token (context_p);\n    }\n\nscan_completed:\n    if (context_p->stack_top_uint8 != SCAN_STACK_SCRIPT\n        && context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION)\n    {\n      scanner_raise_error (context_p);\n    }\n\n    scanner_pop_literal_pool (context_p, &scanner_context);\n\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (scanner_context.active_binding_list_p == NULL);\n#endif /* ENABLED (JERRY_ES2015) */\n    JERRY_ASSERT (scanner_context.active_literal_pool_p == NULL);\n\n#ifndef JERRY_NDEBUG\n    scanner_context.context_status_flags |= PARSER_SCANNING_SUCCESSFUL;\n#endif /* !JERRY_NDEBUG */\n  }\n  PARSER_CATCH\n  {\n#if ENABLED (JERRY_ES2015)\n    while (scanner_context.active_binding_list_p != NULL)\n    {\n      scanner_pop_binding_list (&scanner_context);\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    if (JERRY_UNLIKELY (context_p->error != PARSER_ERR_OUT_OF_MEMORY))\n    {\n      /* Ignore the errors thrown by the lexer. */\n      context_p->error = PARSER_ERR_NO_ERROR;\n\n      /* The following code may allocate memory, so it is enclosed in a try/catch. */\n      PARSER_TRY (context_p->try_buffer)\n      {\n  #if ENABLED (JERRY_ES2015)\n        if (scanner_context.status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION)\n        {\n          JERRY_ASSERT (scanner_context.async_source_p != NULL);\n\n          scanner_info_t *info_p;\n          info_p = scanner_insert_info (context_p, scanner_context.async_source_p, sizeof (scanner_info_t));\n          info_p->type = SCANNER_TYPE_ERR_ASYNC_FUNCTION;\n        }\n  #endif /* ENABLED (JERRY_ES2015) */\n\n        while (scanner_context.active_literal_pool_p != NULL)\n        {\n          scanner_pop_literal_pool (context_p, &scanner_context);\n        }\n      }\n      PARSER_CATCH\n      {\n        JERRY_ASSERT (context_p->error == PARSER_ERR_OUT_OF_MEMORY);\n      }\n      PARSER_TRY_END\n    }\n\n    JERRY_ASSERT (context_p->error == PARSER_ERR_NO_ERROR || context_p->error == PARSER_ERR_OUT_OF_MEMORY);\n\n    if (context_p->error == PARSER_ERR_OUT_OF_MEMORY)\n    {\n      while (scanner_context.active_literal_pool_p != NULL)\n      {\n        scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n\n        scanner_context.active_literal_pool_p = literal_pool_p->prev_p;\n\n        parser_list_free (&literal_pool_p->literal_pool);\n        scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n      }\n\n      parser_stack_free (context_p);\n      return;\n    }\n  }\n  PARSER_TRY_END\n\n  context_p->status_flags = scanner_context.context_status_flags;\n  scanner_reverse_info_list (context_p);\n\n#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n  if (context_p->is_show_opcodes)\n  {\n    scanner_info_t *info_p = context_p->next_scanner_info_p;\n    const uint8_t *source_start_p = (arg_list_p == NULL) ? source_p : arg_list_p;\n\n    while (info_p->type != SCANNER_TYPE_END)\n    {\n      const char *name_p = NULL;\n      bool print_location = false;\n\n      switch (info_p->type)\n      {\n        case SCANNER_TYPE_END_ARGUMENTS:\n        {\n          JERRY_DEBUG_MSG (\"  END_ARGUMENTS\\n\");\n          source_start_p = source_p;\n          break;\n        }\n        case SCANNER_TYPE_FUNCTION:\n        case SCANNER_TYPE_BLOCK:\n        {\n          const uint8_t *prev_source_p = info_p->source_p - 1;\n          const uint8_t *data_p;\n\n          if (info_p->type == SCANNER_TYPE_FUNCTION)\n          {\n            data_p = (const uint8_t *) (info_p + 1);\n\n            JERRY_DEBUG_MSG (\"  FUNCTION: flags: 0x%x declarations: %d\",\n                             (int) info_p->u8_arg,\n                             (int) info_p->u16_arg);\n          }\n          else\n          {\n            data_p = (const uint8_t *) (info_p + 1);\n\n            JERRY_DEBUG_MSG (\"  BLOCK:\");\n          }\n\n          JERRY_DEBUG_MSG (\" source:%d\\n\", (int) (info_p->source_p - source_start_p));\n\n          while (data_p[0] != SCANNER_STREAM_TYPE_END)\n          {\n            switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)\n            {\n              case SCANNER_STREAM_TYPE_VAR:\n              {\n                JERRY_DEBUG_MSG (\"    VAR \");\n                break;\n              }\n#if ENABLED (JERRY_ES2015)\n              case SCANNER_STREAM_TYPE_LET:\n              {\n                JERRY_DEBUG_MSG (\"    LET \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_CONST:\n              {\n                JERRY_DEBUG_MSG (\"    CONST \");\n                break;\n              }\n              case SCANNER_STREAM_TYPE_LOCAL:\n              {\n                JERRY_DEBUG_MSG (\"    LOCAL \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n              case SCANNER_STREAM_TYPE_IMPORT:\n              {\n                JERRY_DEBUG_MSG (\"    IMPORT \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */\n              case SCANNER_STREAM_TYPE_ARG:\n              {\n                JERRY_DEBUG_MSG (\"    ARG \");\n                break;\n              }\n#if ENABLED (JERRY_ES2015)\n              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n              {\n                JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n              case SCANNER_STREAM_TYPE_ARG_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    ARG_FUNC \");\n                break;\n              }\n#if ENABLED (JERRY_ES2015)\n              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG_FUNC \");\n                break;\n              }\n#endif /* ENABLED (JERRY_ES2015) */\n              case SCANNER_STREAM_TYPE_FUNC:\n              {\n                JERRY_DEBUG_MSG (\"    FUNC \");\n                break;\n              }\n              default:\n              {\n                JERRY_ASSERT ((data_p[0] & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_HOLE);\n                JERRY_DEBUG_MSG (\"    HOLE\\n\");\n                data_p++;\n                continue;\n              }\n            }\n\n            size_t length;\n\n            if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))\n            {\n              if (data_p[2] != 0)\n              {\n                prev_source_p += data_p[2];\n                length = 2 + 1;\n              }\n              else\n              {\n                memcpy (&prev_source_p, data_p + 2 + 1, sizeof (const uint8_t *));\n                length = 2 + 1 + sizeof (const uint8_t *);\n              }\n            }\n            else\n            {\n              int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;\n\n              if (diff <= UINT8_MAX)\n              {\n                diff = -diff;\n              }\n\n              prev_source_p += diff;\n              length = 2 + 2;\n            }\n\n#if ENABLED (JERRY_ES2015)\n            if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)\n            {\n              JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);\n              JERRY_DEBUG_MSG (\"*\");\n            }\n#endif /* ENABLED (JERRY_ES2015) */\n\n            if (data_p[0] & SCANNER_STREAM_NO_REG)\n            {\n              JERRY_DEBUG_MSG (\"* \");\n            }\n\n            JERRY_DEBUG_MSG (\"'%.*s'\\n\", data_p[1], (char *) prev_source_p);\n            prev_source_p += data_p[1];\n            data_p += length;\n          }\n          break;\n        }\n        case SCANNER_TYPE_WHILE:\n        {\n          name_p = \"WHILE\";\n          print_location = true;\n          break;\n        }\n        case SCANNER_TYPE_FOR:\n        {\n          scanner_for_info_t *for_info_p = (scanner_for_info_t *) info_p;\n          JERRY_DEBUG_MSG (\"  FOR: source:%d expression:%d[%d:%d] end:%d[%d:%d]\\n\",\n                           (int) (for_info_p->info.source_p - source_start_p),\n                           (int) (for_info_p->expression_location.source_p - source_start_p),\n                           (int) for_info_p->expression_location.line,\n                           (int) for_info_p->expression_location.column,\n                           (int) (for_info_p->end_location.source_p - source_start_p),\n                           (int) for_info_p->end_location.line,\n                           (int) for_info_p->end_location.column);\n          break;\n        }\n        case SCANNER_TYPE_FOR_IN:\n        {\n          name_p = \"FOR-IN\";\n          print_location = true;\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCANNER_TYPE_FOR_OF:\n        {\n          name_p = \"FOR-OF\";\n          print_location = true;\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n        case SCANNER_TYPE_SWITCH:\n        {\n          JERRY_DEBUG_MSG (\"  SWITCH: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n\n          scanner_case_info_t *current_case_p = ((scanner_switch_info_t *) info_p)->case_p;\n\n          while (current_case_p != NULL)\n          {\n            JERRY_DEBUG_MSG (\"    CASE: location:%d[%d:%d]\\n\",\n                             (int) (current_case_p->location.source_p - source_start_p),\n                             (int) current_case_p->location.line,\n                             (int) current_case_p->location.column);\n\n            current_case_p = current_case_p->next_p;\n          }\n          break;\n        }\n        case SCANNER_TYPE_CASE:\n        {\n          name_p = \"CASE\";\n          print_location = true;\n          break;\n        }\n#if ENABLED (JERRY_ES2015)\n        case SCANNER_TYPE_INITIALIZER:\n        {\n          name_p = \"INITIALIZER\";\n          print_location = true;\n          break;\n        }\n        case SCANNER_TYPE_CLASS_CONSTRUCTOR:\n        {\n          JERRY_DEBUG_MSG (\"  CLASS-CONSTRUCTOR: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          print_location = false;\n          break;\n        }\n        case SCANNER_TYPE_LET_EXPRESSION:\n        {\n          JERRY_DEBUG_MSG (\"  LET_EXPRESSION: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n        case SCANNER_TYPE_ERR_REDECLARED:\n        {\n          JERRY_DEBUG_MSG (\"  ERR_REDECLARED: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n        case SCANNER_TYPE_ERR_ASYNC_FUNCTION:\n        {\n          JERRY_DEBUG_MSG (\"  ERR_ASYNC_FUNCTION: source:%d\\n\",\n                           (int) (info_p->source_p - source_start_p));\n          break;\n        }\n#endif /* ENABLED (JERRY_ES2015) */\n      }\n\n      if (print_location)\n      {\n        scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;\n        JERRY_DEBUG_MSG (\"  %s: source:%d location:%d[%d:%d]\\n\",\n                         name_p,\n                         (int) (location_info_p->info.source_p - source_start_p),\n                         (int) (location_info_p->location.source_p - source_start_p),\n                         (int) location_info_p->location.line,\n                         (int) location_info_p->location.column);\n      }\n\n      info_p = info_p->next_p;\n    }\n\n    JERRY_DEBUG_MSG (\"\\n--- Scanning end ---\\n\\n\");\n  }\n#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */\n\n  parser_stack_free (context_p);\n} /* scanner_scan_all */\n\n/**\n * @}\n * @}\n * @}\n */\n\n#endif /* ENABLED (JERRY_PARSER) */\n"], "filenames": ["jerry-core/parser/js/js-scanner.c"], "buggy_code_start_loc": [3162], "buggy_code_end_loc": [3213], "fixing_code_start_loc": [3162], "fixing_code_end_loc": [3217], "type": "CWE-476", "message": "parser/js/js-scanner.c in JerryScript 2.2.0 mishandles errors during certain out-of-memory conditions, as demonstrated by a scanner_reverse_info_list NULL pointer dereference and a scanner_scan_all assertion failure.", "other": {"cve": {"id": "CVE-2020-13649", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-28T15:15:11.980", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "parser/js/js-scanner.c in JerryScript 2.2.0 mishandles errors during certain out-of-memory conditions, as demonstrated by a scanner_reverse_info_list NULL pointer dereference and a scanner_scan_all assertion failure."}, {"lang": "es", "value": "El archivo parser/js/js-scanner.c en JerryScript versi\u00f3n 2.2.0, maneja inapropiadamente los errores durante determinadas condiciones de falta de memoria, como es demostrado por una desreferencia del puntero NULL de la funci\u00f3n scan_reverse_info_list y un fallo de aserci\u00f3n de la funci\u00f3n scanner_scan_all."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}, {"lang": "en", "value": "CWE-617"}, {"lang": "en", "value": "CWE-754"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jerryscript:jerryscript:2.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "88EBD351-0E34-480A-906A-603AC3920FBF"}]}]}], "references": [{"url": "https://github.com/jerryscript-project/jerryscript/commit/69f8e78c2f8d562bd6d8002b5488f1662ac30d24", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jerryscript-project/jerryscript/issues/3786", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/jerryscript-project/jerryscript/issues/3788", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jerryscript-project/jerryscript/commit/69f8e78c2f8d562bd6d8002b5488f1662ac30d24"}}