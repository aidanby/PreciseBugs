{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2019 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2020 Hyunchul Lee <hyc.lee@gmail.com>\n */\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <string.h>\n#include <errno.h>\n#include <locale.h>\n\n#include \"exfat_ondisk.h\"\n#include \"libexfat.h\"\n#include \"repair.h\"\n#include \"exfat_fs.h\"\n#include \"exfat_dir.h\"\n#include \"fsck.h\"\n\nstruct fsck_user_input {\n\tstruct exfat_user_input\t\tei;\n\tenum fsck_ui_options\t\toptions;\n};\n\n#define EXFAT_MAX_UPCASE_CHARS\t0x10000\n\n#define FSCK_EXIT_NO_ERRORS\t\t0x00\n#define FSCK_EXIT_CORRECTED\t\t0x01\n#define FSCK_EXIT_NEED_REBOOT\t\t0x02\n#define FSCK_EXIT_ERRORS_LEFT\t\t0x04\n#define FSCK_EXIT_OPERATION_ERROR\t0x08\n#define FSCK_EXIT_SYNTAX_ERROR\t\t0x10\n#define FSCK_EXIT_USER_CANCEL\t\t0x20\n#define FSCK_EXIT_LIBRARY_ERROR\t\t0x80\n\nstruct exfat_stat {\n\tlong\t\tdir_count;\n\tlong\t\tfile_count;\n\tlong\t\terror_count;\n\tlong\t\tfixed_count;\n};\n\nstruct exfat_fsck exfat_fsck;\nstruct exfat_stat exfat_stat;\nstruct path_resolve_ctx path_resolve_ctx;\n\nstatic struct option opts[] = {\n\t{\"repair\",\tno_argument,\tNULL,\t'r' },\n\t{\"repair-yes\",\tno_argument,\tNULL,\t'y' },\n\t{\"repair-no\",\tno_argument,\tNULL,\t'n' },\n\t{\"repair-auto\",\tno_argument,\tNULL,\t'p' },\n\t{\"rescue\",\tno_argument,\tNULL,\t's' },\n\t{\"version\",\tno_argument,\tNULL,\t'V' },\n\t{\"verbose\",\tno_argument,\tNULL,\t'v' },\n\t{\"help\",\tno_argument,\tNULL,\t'h' },\n\t{\"?\",\t\tno_argument,\tNULL,\t'?' },\n\t{\"ignore-bad-fs\",\tno_argument,\tNULL,\t'b' },\n\t{NULL,\t\t0,\t\tNULL,\t 0  }\n};\n\nstatic void usage(char *name)\n{\n\tfprintf(stderr, \"Usage: %s\\n\", name);\n\tfprintf(stderr, \"\\t-r | --repair        Repair interactively\\n\");\n\tfprintf(stderr, \"\\t-y | --repair-yes    Repair without ask\\n\");\n\tfprintf(stderr, \"\\t-n | --repair-no     No repair\\n\");\n\tfprintf(stderr, \"\\t-p | --repair-auto   Repair automatically\\n\");\n\tfprintf(stderr, \"\\t-a                   Repair automatically\\n\");\n\tfprintf(stderr, \"\\t-b | --ignore-bad-fs Try to recover even if exfat is not found\\n\");\n\tfprintf(stderr, \"\\t-s | --rescue        Assign orphaned clusters to files\\n\");\n\tfprintf(stderr, \"\\t-V | --version       Show version\\n\");\n\tfprintf(stderr, \"\\t-v | --verbose       Print debug\\n\");\n\tfprintf(stderr, \"\\t-h | --help          Show help\\n\");\n\n\texit(FSCK_EXIT_SYNTAX_ERROR);\n}\n\n#define fsck_err(parent, inode, fmt, ...)\t\t\\\n({\t\t\t\t\t\t\t\\\n\t\texfat_resolve_path_parent(&path_resolve_ctx,\t\\\n\t\t\tparent, inode);\t\t\t\\\n\t\texfat_err(\"ERROR: %s: \" fmt,\t\t\\\n\t\t\tpath_resolve_ctx.local_path,\t\\\n\t\t\t##__VA_ARGS__);\t\t\t\\\n})\n\n#define repair_file_ask(iter, inode, code, fmt, ...)\t\\\n({\t\t\t\t\t\t\t\\\n\t\tif (inode)\t\t\t\t\t\t\\\n\t\t\texfat_resolve_path_parent(&path_resolve_ctx,\t\\\n\t\t\t\t\t    (iter)->parent, inode);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\texfat_resolve_path(&path_resolve_ctx,\t\t\\\n\t\t\t\t     (iter)->parent);\t\t\t\\\n\t\texfat_repair_ask(&exfat_fsck, code,\t\t\t\\\n\t\t\t\t \"ERROR: %s: \" fmt \" at %#\" PRIx64,\t\\\n\t\t\t\t path_resolve_ctx.local_path,\t\t\\\n\t\t\t\t ##__VA_ARGS__,\t\t\t\t\\\n\t\t\t\t exfat_de_iter_device_offset(iter));\t\\\n})\n\nstatic int check_clus_chain(struct exfat_de_iter *de_iter,\n\t\t\t\tstruct exfat_inode *node)\n{\n\tstruct exfat *exfat = de_iter->exfat;\n\tstruct exfat_dentry *stream_de;\n\tclus_t clus, prev, next, new_clus;\n\tuint64_t count, max_count;\n\tint err;\n\n\tclus = node->first_clus;\n\tprev = EXFAT_EOF_CLUSTER;\n\tcount = 0;\n\tmax_count = DIV_ROUND_UP(node->size, exfat->clus_size);\n\n\tif (node->size == 0 && node->first_clus == EXFAT_FREE_CLUSTER) {\n\t\t/* locate a cluster for the empty dir if the dir starts with EXFAT_FREE_CLUSTER */\n\t\tif (node->attr & ATTR_SUBDIR) {\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\tER_DE_FIRST_CLUS,\n\t\t\t\t\t\"size %#\" PRIx64 \", but the first cluster %#x\",\n\t\t\t\t\tnode->size, node->first_clus))\n\t\t\t\tgoto allocate_cluster;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\t/* the first cluster is wrong */\n\tif ((node->size == 0 && node->first_clus != EXFAT_FREE_CLUSTER) ||\n\t    (node->size > 0 && !exfat_heap_clus(exfat, node->first_clus))) {\n\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t    ER_FILE_FIRST_CLUS,\n\t\t\t\t    \"size %#\" PRIx64 \", but the first cluster %#x\",\n\t\t\t\t    node->size, node->first_clus))\n\t\t\tgoto truncate_file;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (clus != EXFAT_EOF_CLUSTER) {\n\t\tif (count >= max_count) {\n\t\t\tif (node->is_contiguous)\n\t\t\t\tbreak;\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t    ER_FILE_SMALLER_SIZE,\n\t\t\t\t\t    \"more clusters are allocated. truncate to %\"\n\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t    count * exfat->clus_size))\n\t\t\t\tgoto truncate_file;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * This cluster is already allocated. it may be shared with\n\t\t * the other file, or there is a loop in cluster chain.\n\t\t */\n\t\tif (exfat_bitmap_get(exfat->alloc_bitmap, clus)) {\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t    ER_FILE_DUPLICATED_CLUS,\n\t\t\t\t\t    \"cluster is already allocated for the other file. truncated to %\"\n\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t    count * exfat->clus_size))\n\t\t\t\tgoto truncate_file;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!exfat_bitmap_get(exfat->disk_bitmap, clus)) {\n\t\t\tif (!repair_file_ask(de_iter, node,\n\t\t\t\t\t     ER_FILE_INVALID_CLUS,\n\t\t\t\t\t     \"cluster %#x is marked as free\",\n\t\t\t\t\t     clus))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* This cluster is allocated or not */\n\t\tif (exfat_get_inode_next_clus(exfat, node, clus, &next))\n\t\t\tgoto truncate_file;\n\t\tif (next == EXFAT_BAD_CLUSTER) {\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t    ER_FILE_INVALID_CLUS,\n\t\t\t\t\t    \"BAD cluster. truncate to %\"\n\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t    count * exfat->clus_size))\n\t\t\t\tgoto truncate_file;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!node->is_contiguous) {\n\t\t\tif (next != EXFAT_EOF_CLUSTER &&\n\t\t\t    !exfat_heap_clus(exfat, next)) {\n\t\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t\t    ER_FILE_INVALID_CLUS,\n\t\t\t\t\t\t    \"broken cluster chain. truncate to %\"\n\t\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t\t    (count + 1) * exfat->clus_size)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tprev = clus;\n\t\t\t\t\texfat_bitmap_set(exfat->alloc_bitmap,\n\t\t\t\t\t\t\t clus);\n\t\t\t\t\tgoto truncate_file;\n\t\t\t\t} else {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcount++;\n\t\texfat_bitmap_set(exfat->alloc_bitmap, clus);\n\t\tprev = clus;\n\t\tclus = next;\n\t}\n\n\tif (count < max_count) {\n\t\tif (repair_file_ask(de_iter, node, ER_FILE_LARGER_SIZE,\n\t\t\t\t    \"less clusters are allocated. truncates to %\"\n\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t    count * exfat->clus_size))\n\t\t\tgoto truncate_file;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\nallocate_cluster:\n\texfat_de_iter_get_dirty(de_iter, 1, &stream_de);\n\terr = exfat_find_free_cluster(exfat, exfat->start_clu, &new_clus);\n\tif (err) {\n\t\texfat->start_clu = EXFAT_FIRST_CLUSTER;\n\t\texfat_err(\"failed to find a free cluster\\n\");\n\t\treturn -ENOSPC;\n\t}\n\texfat->start_clu = new_clus;\n\n\tif (exfat_set_fat(exfat, new_clus, EXFAT_EOF_CLUSTER))\n\t\treturn -EIO;\n\n\t/* zero out the new cluster */\n\tif (exfat_write(exfat->blk_dev->dev_fd, exfat->zero_cluster,\n\t\t\texfat->clus_size, exfat_c2o(exfat, new_clus)) !=\n\t\t\t(ssize_t)exfat->clus_size) {\n\t\texfat_err(\"failed to fill new cluster with zeroes\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* modify the number of cluster form 0 to 1 */\n\tcount = 1;\n\tstream_de->stream_start_clu = cpu_to_le32(new_clus);\n\tstream_de->stream_size = cpu_to_le64(count * exfat->clus_size);\n\tstream_de->stream_valid_size = cpu_to_le64(count * exfat->clus_size);\n\tstream_de->dentry.stream.flags |= EXFAT_SF_CONTIGUOUS;\n\tnode->first_clus = new_clus;\n\tnode->size = count * exfat->clus_size;\n\tnode->is_contiguous = true;\n\texfat_bitmap_set(exfat->alloc_bitmap, new_clus);\n\treturn 1;\ntruncate_file:\n\tnode->size = count * exfat->clus_size;\n\tif (!exfat_heap_clus(exfat, prev))\n\t\tnode->first_clus = EXFAT_FREE_CLUSTER;\n\n\texfat_de_iter_get_dirty(de_iter, 1, &stream_de);\n\tif (count * exfat->clus_size <\n\t    le64_to_cpu(stream_de->stream_valid_size))\n\t\tstream_de->stream_valid_size = cpu_to_le64(\n\t\t\t\t\t\t\t   count * exfat->clus_size);\n\tif (!exfat_heap_clus(exfat, prev))\n\t\tstream_de->stream_start_clu = EXFAT_FREE_CLUSTER;\n\tstream_de->stream_size = cpu_to_le64(\n\t\t\t\t\t     count * exfat->clus_size);\n\n\t/* remaining clusters will be freed while FAT is compared with\n\t * alloc_bitmap.\n\t */\n\tif (!node->is_contiguous && exfat_heap_clus(exfat, prev)) {\n\t\tif (exfat_set_fat(exfat, prev, EXFAT_EOF_CLUSTER))\n\t\t\treturn -EIO;\n\t}\n\treturn 1;\n}\n\nstatic int root_check_clus_chain(struct exfat *exfat,\n\t\t\t\t struct exfat_inode *node,\n\t\t\t\t clus_t *clus_count)\n{\n\tclus_t clus, next, prev = EXFAT_EOF_CLUSTER;\n\n\tif (!exfat_heap_clus(exfat, node->first_clus))\n\t\tgoto out_trunc;\n\n\tclus = node->first_clus;\n\t*clus_count = 0;\n\n\tdo {\n\t\tif (exfat_bitmap_get(exfat->alloc_bitmap, clus)) {\n\t\t\tif (exfat_repair_ask(&exfat_fsck,\n\t\t\t\t\t     ER_FILE_DUPLICATED_CLUS,\n\t\t\t\t\t     \"ERROR: the cluster chain of root is cyclic\"))\n\t\t\t\tgoto out_trunc;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\texfat_bitmap_set(exfat->alloc_bitmap, clus);\n\n\t\tif (exfat_get_inode_next_clus(exfat, node, clus, &next)) {\n\t\t\texfat_err(\"ERROR: failed to read the fat entry of root\");\n\t\t\tgoto out_trunc;\n\t\t}\n\n\t\tif (next != EXFAT_EOF_CLUSTER && !exfat_heap_clus(exfat, next)) {\n\t\t\tif (exfat_repair_ask(&exfat_fsck,\n\t\t\t\t\t     ER_FILE_INVALID_CLUS,\n\t\t\t\t\t     \"ERROR: the cluster chain of root is broken\")) {\n\t\t\t\tif (next != EXFAT_BAD_CLUSTER) {\n\t\t\t\t\tprev = clus;\n\t\t\t\t\t(*clus_count)++;\n\t\t\t\t}\n\t\t\t\tgoto out_trunc;\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprev = clus;\n\t\tclus = next;\n\t\t(*clus_count)++;\n\t} while (clus != EXFAT_EOF_CLUSTER);\n\n\treturn 0;\nout_trunc:\n\tif (!exfat_heap_clus(exfat, prev)) {\n\t\texfat_err(\"ERROR: the start cluster of root is wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\tnode->size = *clus_count * exfat->clus_size;\n\treturn exfat_set_fat(exfat, prev, EXFAT_EOF_CLUSTER);\n}\n\nstatic int boot_region_checksum(int dev_fd,\n\t\t\t\tint bs_offset, unsigned int sect_size)\n{\n\tvoid *sect;\n\tunsigned int i;\n\tuint32_t checksum;\n\tint ret = 0;\n\n\tsect = malloc(sect_size);\n\tif (!sect)\n\t\treturn -ENOMEM;\n\n\tchecksum = 0;\n\tfor (i = 0; i < 11; i++) {\n\t\tif (exfat_read(dev_fd, sect, sect_size,\n\t\t\t\tbs_offset * sect_size + i * sect_size) !=\n\t\t\t\t(ssize_t)sect_size) {\n\t\t\texfat_err(\"failed to read boot region\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tboot_calc_checksum(sect, sect_size, i == 0, &checksum);\n\t}\n\n\tif (exfat_read(dev_fd, sect, sect_size,\n\t\t\tbs_offset * sect_size + 11 * sect_size) !=\n\t\t\t(ssize_t)sect_size) {\n\t\texfat_err(\"failed to read a boot checksum sector\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < sect_size/sizeof(checksum); i++) {\n\t\tif (le32_to_cpu(((__le32 *)sect)[i]) != checksum) {\n\t\t\texfat_err(\"checksum of boot region is not correct. %#x, but expected %#x\\n\",\n\t\t\t\tle32_to_cpu(((__le32 *)sect)[i]), checksum);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree(sect);\n\treturn ret;\n}\n\nstatic int exfat_mark_volume_dirty(struct exfat *exfat, bool dirty)\n{\n\tuint16_t flags;\n\n\tflags = le16_to_cpu(exfat->bs->bsx.vol_flags);\n\tif (dirty)\n\t\tflags |= 0x02;\n\telse\n\t\tflags &= ~0x02;\n\n\texfat->bs->bsx.vol_flags = cpu_to_le16(flags);\n\tif (exfat_write(exfat->blk_dev->dev_fd, exfat->bs,\n\t\t\tsizeof(struct pbr), 0) != (ssize_t)sizeof(struct pbr)) {\n\t\texfat_err(\"failed to set VolumeDirty\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (fsync(exfat->blk_dev->dev_fd) != 0) {\n\t\texfat_err(\"failed to set VolumeDirty\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int read_boot_region(struct exfat_blk_dev *bd, struct pbr **pbr,\n\t\t\t    int bs_offset, unsigned int sect_size,\n\t\t\t    bool verbose)\n{\n\tstruct pbr *bs;\n\tint ret = -EINVAL;\n\n\t*pbr = NULL;\n\tbs = (struct pbr *)malloc(sizeof(struct pbr));\n\tif (!bs) {\n\t\texfat_err(\"failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (exfat_read(bd->dev_fd, bs, sizeof(*bs),\n\t\t\tbs_offset * sect_size) != (ssize_t)sizeof(*bs)) {\n\t\texfat_err(\"failed to read a boot sector\\n\");\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (memcmp(bs->bpb.oem_name, \"EXFAT   \", 8) != 0) {\n\t\tif (verbose)\n\t\t\texfat_err(\"failed to find exfat file system\\n\");\n\t\tgoto err;\n\t}\n\n\tret = boot_region_checksum(bd->dev_fd, bs_offset, sect_size);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EINVAL;\n\tif (EXFAT_SECTOR_SIZE(bs) < 512 || EXFAT_SECTOR_SIZE(bs) > 4 * KB) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too small or big sector size: %d\\n\",\n\t\t\t\t  EXFAT_SECTOR_SIZE(bs));\n\t\tgoto err;\n\t}\n\n\tif (EXFAT_CLUSTER_SIZE(bs) > 32 * MB) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too big cluster size: %d\\n\",\n\t\t\t\t  EXFAT_CLUSTER_SIZE(bs));\n\t\tgoto err;\n\t}\n\n\tif (bs->bsx.fs_version[1] != 1 || bs->bsx.fs_version[0] != 0) {\n\t\tif (verbose)\n\t\t\texfat_err(\"unsupported exfat version: %d.%d\\n\",\n\t\t\t\t  bs->bsx.fs_version[1], bs->bsx.fs_version[0]);\n\t\tgoto err;\n\t}\n\n\tif (bs->bsx.num_fats != 1) {\n\t\tif (verbose)\n\t\t\texfat_err(\"unsupported FAT count: %d\\n\",\n\t\t\t\t  bs->bsx.num_fats);\n\t\tgoto err;\n\t}\n\n\tif (le64_to_cpu(bs->bsx.vol_length) * EXFAT_SECTOR_SIZE(bs) >\n\t\t\tbd->size) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too large sector count: %\" PRIu64 \", expected: %llu\\n\",\n\t\t\t\t  le64_to_cpu(bs->bsx.vol_length),\n\t\t\t\t  bd->num_sectors);\n\t\tgoto err;\n\t}\n\n\tif (le32_to_cpu(bs->bsx.clu_count) * EXFAT_CLUSTER_SIZE(bs) >\n\t\t\tbd->size) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too large cluster count: %u, expected: %u\\n\",\n\t\t\t\t  le32_to_cpu(bs->bsx.clu_count),\n\t\t\t\t  bd->num_clusters);\n\t\tgoto err;\n\t}\n\n\t*pbr = bs;\n\treturn 0;\nerr:\n\tfree(bs);\n\treturn ret;\n}\n\nstatic int restore_boot_region(struct exfat_blk_dev *bd, unsigned int sect_size)\n{\n\tint i;\n\tchar *sector;\n\tint ret;\n\n\tsector = malloc(sect_size);\n\tif (!sector)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < 12; i++) {\n\t\tif (exfat_read(bd->dev_fd, sector, sect_size,\n\t\t\t\tBACKUP_BOOT_SEC_IDX * sect_size +\n\t\t\t\ti * sect_size) !=\n\t\t\t\t(ssize_t)sect_size) {\n\t\t\tret = -EIO;\n\t\t\tgoto free_sector;\n\t\t}\n\t\tif (i == 0)\n\t\t\t((struct pbr *)sector)->bsx.perc_in_use = 0xff;\n\n\t\tif (exfat_write(bd->dev_fd, sector, sect_size,\n\t\t\t\tBOOT_SEC_IDX * sect_size +\n\t\t\t\ti * sect_size) !=\n\t\t\t\t(ssize_t)sect_size) {\n\t\t\tret = -EIO;\n\t\t\tgoto free_sector;\n\t\t}\n\t}\n\n\tif (fsync(bd->dev_fd)) {\n\t\tret = -EIO;\n\t\tgoto free_sector;\n\t}\n\tret = 0;\n\nfree_sector:\n\tfree(sector);\n\treturn ret;\n}\n\nstatic int exfat_boot_region_check(struct exfat_blk_dev *blkdev,\n\t\t\t\t   struct pbr **bs,\n\t\t\t\t   bool ignore_bad_fs_name)\n{\n\tstruct pbr *boot_sect;\n\tunsigned int sect_size;\n\tint ret;\n\n\t/* First, find out the exfat sector size */\n\tboot_sect = malloc(sizeof(*boot_sect));\n\tif (boot_sect == NULL)\n\t\treturn -ENOMEM;\n\n\tif (exfat_read(blkdev->dev_fd, boot_sect,\n\t\t       sizeof(*boot_sect), 0) != (ssize_t)sizeof(*boot_sect)) {\n\t\texfat_err(\"failed to read Main boot sector\\n\");\n\t\tfree(boot_sect);\n\t\treturn -EIO;\n\t}\n\n\tif (memcmp(boot_sect->bpb.oem_name, \"EXFAT   \", 8) != 0 &&\n\t    !ignore_bad_fs_name) {\n\t\texfat_err(\"Bad fs_name in boot sector, which does not describe a valid exfat filesystem\\n\");\n\t\tfree(boot_sect);\n\t\treturn -ENOTSUP;\n\t}\n\n\tsect_size = 1 << boot_sect->bsx.sect_size_bits;\n\tfree(boot_sect);\n\n\t/* check boot regions */\n\tret = read_boot_region(blkdev, bs,\n\t\t\t       BOOT_SEC_IDX, sect_size, true);\n\tif (ret == -EINVAL &&\n\t    exfat_repair_ask(&exfat_fsck, ER_BS_BOOT_REGION,\n\t\t\t     \"boot region is corrupted. try to restore the region from backup\"\n\t\t\t\t)) {\n\t\tconst unsigned int sector_sizes[] = {512, 4096, 1024, 2048};\n\t\tunsigned int i;\n\n\t\tif (sect_size >= 512 && sect_size <= EXFAT_MAX_SECTOR_SIZE) {\n\t\t\tret = read_boot_region(blkdev, bs,\n\t\t\t\t\t       BACKUP_BOOT_SEC_IDX, sect_size,\n\t\t\t\t\t       false);\n\t\t\tif (!ret)\n\t\t\t\tgoto restore;\n\t\t}\n\n\t\tfor (i = 0; i < sizeof(sector_sizes)/sizeof(sector_sizes[0]); i++) {\n\t\t\tif (sector_sizes[i] == sect_size)\n\t\t\t\tcontinue;\n\n\t\t\tret = read_boot_region(blkdev, bs,\n\t\t\t\t\t       BACKUP_BOOT_SEC_IDX,\n\t\t\t\t\t       sector_sizes[i], false);\n\t\t\tif (!ret) {\n\t\t\t\tsect_size = sector_sizes[i];\n\t\t\t\tgoto restore;\n\t\t\t}\n\t\t}\n\t\texfat_err(\"backup boot region is also corrupted\\n\");\n\t}\n\n\treturn ret;\nrestore:\n\tret = restore_boot_region(blkdev, sect_size);\n\tif (ret) {\n\t\texfat_err(\"failed to restore boot region from backup\\n\");\n\t\tfree(*bs);\n\t\t*bs = NULL;\n\t}\n\treturn ret;\n}\n\nstatic uint16_t file_calc_checksum(struct exfat_de_iter *iter)\n{\n\tuint16_t checksum;\n\tstruct exfat_dentry *file_de, *de;\n\tint i;\n\n\tchecksum = 0;\n\texfat_de_iter_get(iter, 0, &file_de);\n\n\texfat_calc_dentry_checksum(file_de, &checksum, true);\n\tfor (i = 1; i <= file_de->file_num_ext; i++) {\n\t\texfat_de_iter_get(iter, i, &de);\n\t\texfat_calc_dentry_checksum(de, &checksum, false);\n\t}\n\treturn checksum;\n}\n\n/*\n * return 0 if there are no errors, or 1 if errors are fixed, or\n * an error code\n */\nstatic int check_inode(struct exfat_de_iter *iter, struct exfat_inode *node)\n{\n\tstruct exfat *exfat = iter->exfat;\n\tstruct exfat_dentry *dentry;\n\tint ret = 0;\n\tuint16_t checksum;\n\tbool valid = true;\n\n\tret = check_clus_chain(iter, node);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (node->size > le32_to_cpu(exfat->bs->bsx.clu_count) *\n\t\t\t\t(uint64_t)exfat->clus_size) {\n\t\tfsck_err(iter->parent, node,\n\t\t\t\"size %\" PRIu64 \" is greater than cluster heap\\n\",\n\t\t\tnode->size);\n\t\tvalid = false;\n\t}\n\n\tif (node->size == 0 && node->is_contiguous) {\n\t\tif (repair_file_ask(iter, node, ER_FILE_ZERO_NOFAT,\n\t\t\t\t\"empty, but has no Fat chain\")) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &dentry);\n\t\t\tdentry->stream_flags &= ~EXFAT_SF_CONTIGUOUS;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tvalid = false;\n\t}\n\n\tif ((node->attr & ATTR_SUBDIR) &&\n\t\t\tnode->size % exfat->clus_size != 0) {\n\t\tfsck_err(iter->parent, node,\n\t\t\t\"directory size %\" PRIu64 \" is not divisible by %d\\n\",\n\t\t\tnode->size, exfat->clus_size);\n\t\tvalid = false;\n\t}\n\n\tchecksum = file_calc_checksum(iter);\n\texfat_de_iter_get(iter, 0, &dentry);\n\tif (checksum != le16_to_cpu(dentry->file_checksum)) {\n\t\texfat_de_iter_get_dirty(iter, 0, &dentry);\n\t\tdentry->file_checksum = cpu_to_le16(checksum);\n\t\tret = 1;\n\t}\n\n\treturn valid ? ret : -EINVAL;\n}\n\nstatic int check_name_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\t struct exfat_inode *inode)\n{\n\tstruct exfat_dentry *stream_de;\n\tsize_t name_len;\n\t__u16 hash;\n\n\texfat_de_iter_get(iter, 1, &stream_de);\n\n\tname_len = exfat_utf16_len(inode->name, NAME_BUFFER_SIZE);\n\tif (stream_de->stream_name_len != name_len) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_NAME_LEN,\n\t\t\t\t    \"the name length of a file is wrong\")) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\t\tstream_de->stream_name_len = (__u8)name_len;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\thash = exfat_calc_name_hash(iter->exfat, inode->name, (int)name_len);\n\tif (cpu_to_le16(hash) != stream_de->stream_name_hash) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_NAME_HASH,\n\t\t\t\t    \"the name hash of a file is wrong\")) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\t\tstream_de->stream_name_hash = cpu_to_le16(hash);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_bad_char(char w)\n{\n\treturn (w < 0x0020) || (w == '*') || (w == '?') || (w == '<') ||\n\t\t(w == '>') || (w == '|') || (w == '\"') || (w == ':') ||\n\t\t(w == '/') || (w == '\\\\');\n}\n\nstatic char *get_rename_from_user(struct exfat_de_iter *iter)\n{\n\tchar *rename = malloc(ENTRY_NAME_MAX + 2);\n\n\tif (!rename)\n\t\treturn NULL;\n\nretry:\n\t/* +2 means LF(Line Feed) and NULL terminator */\n\tmemset(rename, 0x1, ENTRY_NAME_MAX + 2);\n\tprintf(\"New name: \");\n\tif (fgets(rename, ENTRY_NAME_MAX + 2, stdin)) {\n\t\tint i, len, err;\n\t\tstruct exfat_lookup_filter filter;\n\n\t\tlen = strlen(rename);\n\t\t/* Remove LF in filename */\n\t\trename[len - 1] = '\\0';\n\t\tfor (i = 0; i < len - 1; i++) {\n\t\t\tif (check_bad_char(rename[i])) {\n\t\t\t\tprintf(\"filename contain invalid character(%c)\\n\", rename[i]);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\n\t\texfat_de_iter_flush(iter);\n\t\terr = exfat_lookup_file(iter->exfat, iter->parent, rename, &filter);\n\t\tif (!err) {\n\t\t\tprintf(\"file(%s) already exists, retry to insert name\\n\", rename);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\treturn rename;\n}\n\nstatic char *generate_rename(struct exfat_de_iter *iter)\n{\n\tchar *rename;\n\n\tif (iter->dot_name_num > DOT_NAME_NUM_MAX)\n\t\treturn NULL;\n\n\trename = malloc(ENTRY_NAME_MAX + 1);\n\tif (!rename)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tstruct exfat_lookup_filter filter;\n\t\tint err;\n\n\t\tsnprintf(rename, ENTRY_NAME_MAX + 1, \"FILE%07d.CHK\",\n\t\t\t iter->dot_name_num++);\n\t\terr = exfat_lookup_file(iter->exfat, iter->parent, rename,\n\t\t\t\t\t&filter);\n\t\tif (!err)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\treturn rename;\n}\n\nconst __le16 MSDOS_DOT[ENTRY_NAME_MAX] = {cpu_to_le16(46), 0, };\nconst __le16 MSDOS_DOTDOT[ENTRY_NAME_MAX] = {cpu_to_le16(46), cpu_to_le16(46), 0, };\n\nstatic int handle_dot_dotdot_filename(struct exfat_de_iter *iter,\n\t\t\t\t      struct exfat_dentry *dentry,\n\t\t\t\t      int strm_name_len)\n{\n\tchar *filename;\n\tchar error_msg[150];\n\tint num;\n\n\tif (!memcmp(dentry->name_unicode, MSDOS_DOT, strm_name_len * 2))\n\t\tfilename = \".\";\n\telse if (!memcmp(dentry->name_unicode, MSDOS_DOTDOT,\n\t\t\t strm_name_len * 2))\n\t\tfilename = \"..\";\n\telse\n\t\treturn 0;\n\n\tsprintf(error_msg, \"ERROR: '%s' filename is not allowed.\\n\"\n\t\t\t\" [1] Insert the name you want to rename.\\n\"\n\t\t\t\" [2] Automatically renames filename.\\n\"\n\t\t\t\" [3] Bypass this check(No repair)\\n\", filename);\nask_again:\n\tnum = exfat_repair_ask(&exfat_fsck, ER_DE_DOT_NAME,\n\t\t\t       error_msg);\n\tif (num) {\n\t\t__le16 utf16_name[ENTRY_NAME_MAX];\n\t\tchar *rename = NULL;\n\t\t__u16 hash;\n\t\tstruct exfat_dentry *stream_de;\n\t\tint name_len, ret;\n\n\t\tswitch (num) {\n\t\tcase 1:\n\t\t\trename = get_rename_from_user(iter);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trename = generate_rename(iter);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texfat_info(\"select 1 or 2 number instead of %d\\n\", num);\n\t\t\tgoto ask_again;\n\t\t}\n\n\t\tif (!rename)\n\t\t\treturn -EINVAL;\n\n\t\texfat_info(\"%s filename is renamed to %s\\n\", filename, rename);\n\n\t\texfat_de_iter_get_dirty(iter, 2, &dentry);\n\n\t\tmemset(utf16_name, 0, sizeof(utf16_name));\n\t\tret = exfat_utf16_enc(rename, utf16_name, sizeof(utf16_name));\n\t\tfree(rename);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmemcpy(dentry->name_unicode, utf16_name, ENTRY_NAME_MAX * 2);\n\t\tname_len = exfat_utf16_len(utf16_name, ENTRY_NAME_MAX * 2);\n\t\thash = exfat_calc_name_hash(iter->exfat, utf16_name, (int)name_len);\n\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\tstream_de->stream_name_len = (__u8)name_len;\n\t\tstream_de->stream_name_hash = cpu_to_le16(hash);\n\t}\n\n\treturn 0;\n}\n\nstatic int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tbool need_delete = false;\n\tuint16_t checksum;\n\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_err(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchecksum = file_calc_checksum(iter);\n\tif (checksum != le16_to_cpu(file_de->file_checksum)) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_CHECKSUM,\n\t\t\t\t    \"the checksum of a file is wrong\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (file_de->file_num_ext < 2) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_SECONDARY_COUNT,\n\t\t\t\t    \"a file has too few secondary count. %d\",\n\t\t\t\t    file_de->file_num_ext))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_STREAM,\n\t\t\t\t    \"failed to get stream dentry\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME) {\n\t\t\tif (i > 2 && repair_file_ask(iter, NULL, ER_DE_NAME,\n\t\t\t\t\t\t     \"failed to get name dentry\")) {\n\t\t\t\texfat_de_iter_get_dirty(iter, 0, &file_de);\n\t\t\t\tfile_de->file_num_ext = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*skip_dentries = i + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tret = check_name_dentry_set(iter, node);\n\tif (ret) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (file_de->file_num_ext == 2 && stream_de->stream_name_len <= 2) {\n\t\tret = handle_dot_dotdot_filename(iter, dentry,\n\t\t\t\tstream_de->stream_name_len);\n\t\tif (ret < 0) {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\n\tif (node->size < le64_to_cpu(stream_de->stream_valid_size)) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tif (repair_file_ask(iter, node, ER_FILE_VALID_SIZE,\n\t\t\t\t    \"valid size %\" PRIu64 \" greater than size %\" PRIu64,\n\t\t\t\t    le64_to_cpu(stream_de->stream_valid_size),\n\t\t\t\t    node->size)) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\t\tstream_de->stream_valid_size =\n\t\t\t\t\tstream_de->stream_size;\n\t\t} else {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\t*skip_dentries = (file_de->file_num_ext + 1);\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\tif (need_delete) {\n\t\texfat_de_iter_get_dirty(iter, 0, &dentry);\n\t\tdentry->type &= EXFAT_DELETE;\n\t}\n\tfor (i = 1; i < *skip_dentries; i++) {\n\t\texfat_de_iter_get(iter, i, &dentry);\n\t\tif (dentry->type == EXFAT_FILE)\n\t\t\tbreak;\n\t\tif (need_delete) {\n\t\t\texfat_de_iter_get_dirty(iter, i, &dentry);\n\t\t\tdentry->type &= EXFAT_DELETE;\n\t\t}\n\t}\n\t*skip_dentries = i;\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn need_delete ? 1 : -EINVAL;\n}\n\nstatic int read_file(struct exfat_de_iter *de_iter,\n\t\tstruct exfat_inode **new_node, int *dentry_count)\n{\n\tstruct exfat_inode *node;\n\tint ret;\n\n\t*new_node = NULL;\n\n\tret = read_file_dentry_set(de_iter, &node, dentry_count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_inode(de_iter, node);\n\tif (ret < 0) {\n\t\texfat_free_inode(node);\n\t\treturn -EINVAL;\n\t}\n\n\tif (node->attr & ATTR_SUBDIR)\n\t\texfat_stat.dir_count++;\n\telse\n\t\texfat_stat.file_count++;\n\t*new_node = node;\n\treturn ret;\n}\n\nstatic int read_bitmap(struct exfat *exfat)\n{\n\tstruct exfat_lookup_filter filter = {\n\t\t.in.type\t= EXFAT_BITMAP,\n\t\t.in.filter\t= NULL,\n\t\t.in.param\t= NULL,\n\t};\n\tstruct exfat_dentry *dentry;\n\tint retval;\n\n\tretval = exfat_lookup_dentry_set(exfat, exfat->root, &filter);\n\tif (retval)\n\t\treturn retval;\n\n\tdentry = filter.out.dentry_set;\n\texfat_debug(\"start cluster %#x, size %#\" PRIx64 \"\\n\",\n\t\t\tle32_to_cpu(dentry->bitmap_start_clu),\n\t\t\tle64_to_cpu(dentry->bitmap_size));\n\n\tif (le64_to_cpu(dentry->bitmap_size) <\n\t\t\tDIV_ROUND_UP(exfat->clus_count, 8)) {\n\t\texfat_err(\"invalid size of allocation bitmap. 0x%\" PRIx64 \"\\n\",\n\t\t\t\tle64_to_cpu(dentry->bitmap_size));\n\t\treturn -EINVAL;\n\t}\n\tif (!exfat_heap_clus(exfat, le32_to_cpu(dentry->bitmap_start_clu))) {\n\t\texfat_err(\"invalid start cluster of allocate bitmap. 0x%x\\n\",\n\t\t\t\tle32_to_cpu(dentry->bitmap_start_clu));\n\t\treturn -EINVAL;\n\t}\n\n\texfat->disk_bitmap_clus = le32_to_cpu(dentry->bitmap_start_clu);\n\texfat->disk_bitmap_size = DIV_ROUND_UP(exfat->clus_count, 8);\n\n\texfat_bitmap_set_range(exfat, exfat->alloc_bitmap,\n\t\t\t       le64_to_cpu(dentry->bitmap_start_clu),\n\t\t\t       DIV_ROUND_UP(exfat->disk_bitmap_size,\n\t\t\t\t\t    exfat->clus_size));\n\tfree(filter.out.dentry_set);\n\n\tif (exfat_read(exfat->blk_dev->dev_fd, exfat->disk_bitmap,\n\t\t\texfat->disk_bitmap_size,\n\t\t\texfat_c2o(exfat, exfat->disk_bitmap_clus)) !=\n\t\t\t(ssize_t)exfat->disk_bitmap_size)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decompress_upcase_table(const __le16 *in_table, size_t in_len,\n\t\t\t\t   __u16 *out_table, size_t out_len)\n{\n\tsize_t i, k;\n\tuint16_t ch;\n\n\tif (in_len > out_len)\n\t\treturn -E2BIG;\n\n\tfor (k = 0; k < out_len; k++)\n\t\tout_table[k] = k;\n\n\tfor (i = 0, k = 0; i < in_len && k < out_len; i++) {\n\t\tch = le16_to_cpu(in_table[i]);\n\n\t\tif (ch == 0xFFFF && i + 1 < in_len) {\n\t\t\tuint16_t len = le16_to_cpu(in_table[++i]);\n\n\t\t\tk += len;\n\t\t} else {\n\t\t\tout_table[k++] = ch;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int read_upcase_table(struct exfat *exfat)\n{\n\tstruct exfat_lookup_filter filter = {\n\t\t.in.type\t= EXFAT_UPCASE,\n\t\t.in.filter\t= NULL,\n\t\t.in.param\t= NULL,\n\t};\n\tstruct exfat_dentry *dentry = NULL;\n\t__le16 *upcase = NULL;\n\tint retval;\n\tssize_t size;\n\t__le32 checksum;\n\n\tretval = exfat_lookup_dentry_set(exfat, exfat->root, &filter);\n\tif (retval)\n\t\treturn retval;\n\n\tdentry = filter.out.dentry_set;\n\n\tif (!exfat_heap_clus(exfat, le32_to_cpu(dentry->upcase_start_clu))) {\n\t\texfat_err(\"invalid start cluster of upcase table. 0x%x\\n\",\n\t\t\tle32_to_cpu(dentry->upcase_start_clu));\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsize = (ssize_t)le64_to_cpu(dentry->upcase_size);\n\tif (size > (ssize_t)(EXFAT_MAX_UPCASE_CHARS * sizeof(__le16)) ||\n\t\t\tsize == 0 || size % sizeof(__le16)) {\n\t\texfat_err(\"invalid size of upcase table. 0x%\" PRIx64 \"\\n\",\n\t\t\tle64_to_cpu(dentry->upcase_size));\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tupcase = (__le16 *)malloc(size);\n\tif (!upcase) {\n\t\texfat_err(\"failed to allocate upcase table\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (exfat_read(exfat->blk_dev->dev_fd, upcase, size,\n\t\t\texfat_c2o(exfat,\n\t\t\tle32_to_cpu(dentry->upcase_start_clu))) != size) {\n\t\texfat_err(\"failed to read upcase table\\n\");\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\tchecksum = 0;\n\tboot_calc_checksum((unsigned char *)upcase, size, false, &checksum);\n\tif (le32_to_cpu(dentry->upcase_checksum) != checksum) {\n\t\texfat_err(\"corrupted upcase table %#x (expected: %#x)\\n\",\n\t\t\tchecksum, le32_to_cpu(dentry->upcase_checksum));\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\texfat_bitmap_set_range(exfat, exfat->alloc_bitmap,\n\t\t\t       le32_to_cpu(dentry->upcase_start_clu),\n\t\t\t       DIV_ROUND_UP(le64_to_cpu(dentry->upcase_size),\n\t\t\t\t\t    exfat->clus_size));\n\n\texfat->upcase_table = calloc(1,\n\t\t\t\t     sizeof(uint16_t) * EXFAT_UPCASE_TABLE_CHARS);\n\tif (!exfat->upcase_table) {\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\tdecompress_upcase_table(upcase, size / 2,\n\t\t\t\texfat->upcase_table, EXFAT_UPCASE_TABLE_CHARS);\nout:\n\tif (dentry)\n\t\tfree(dentry);\n\tif (upcase)\n\t\tfree(upcase);\n\treturn retval;\n}\n\nstatic int read_children(struct exfat_fsck *fsck, struct exfat_inode *dir)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tstruct exfat_inode *node = NULL;\n\tstruct exfat_dentry *dentry;\n\tstruct exfat_de_iter *de_iter;\n\tint dentry_count;\n\tint ret;\n\n\tde_iter = &fsck->de_iter;\n\tret = exfat_de_iter_init(de_iter, exfat, dir, fsck->buffer_desc);\n\tif (ret == EOF)\n\t\treturn 0;\n\telse if (ret)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tret = exfat_de_iter_get(de_iter, 0, &dentry);\n\t\tif (ret == EOF) {\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tfsck_err(dir->parent, dir,\n\t\t\t\t\"failed to get a dentry. %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tdentry_count = 1;\n\n\t\tswitch (dentry->type) {\n\t\tcase EXFAT_FILE:\n\t\t\tret = read_file(de_iter, &node, &dentry_count);\n\t\t\tif (ret < 0) {\n\t\t\t\texfat_stat.error_count++;\n\t\t\t\tbreak;\n\t\t\t} else if (ret) {\n\t\t\t\texfat_stat.error_count++;\n\t\t\t\texfat_stat.fixed_count++;\n\t\t\t}\n\n\t\t\tif (node) {\n\t\t\t\tif ((node->attr & ATTR_SUBDIR) && node->size) {\n\t\t\t\t\tnode->parent = dir;\n\t\t\t\t\tlist_add_tail(&node->sibling,\n\t\t\t\t\t\t      &dir->children);\n\t\t\t\t\tlist_add_tail(&node->list,\n\t\t\t\t\t\t      &exfat->dir_list);\n\t\t\t\t} else {\n\t\t\t\t\texfat_free_inode(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXFAT_LAST:\n\t\t\tgoto out;\n\t\tcase EXFAT_VOLUME:\n\t\tcase EXFAT_BITMAP:\n\t\tcase EXFAT_UPCASE:\n\t\t\tif (dir == exfat->root)\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tif (IS_EXFAT_DELETED(dentry->type))\n\t\t\t\tbreak;\n\t\t\tif (repair_file_ask(de_iter, NULL, ER_DE_UNKNOWN,\n\t\t\t\t\t    \"unknown entry type %#x at %07\" PRIx64,\n\t\t\t\t\t    dentry->type,\n\t\t\t\t\t    exfat_de_iter_file_offset(de_iter))) {\n\t\t\t\tstruct exfat_dentry *dentry;\n\n\t\t\t\texfat_de_iter_get_dirty(de_iter, 0, &dentry);\n\t\t\t\tdentry->type &= EXFAT_DELETE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\texfat_de_iter_advance(de_iter, dentry_count);\n\t}\nout:\n\texfat_de_iter_flush(de_iter);\n\treturn 0;\nerr:\n\texfat_free_children(dir, false);\n\tINIT_LIST_HEAD(&dir->children);\n\texfat_de_iter_flush(de_iter);\n\treturn ret;\n}\n\n/* write bitmap segments for clusters which are marked\n * as free, but allocated to files.\n */\nstatic int write_bitmap(struct exfat_fsck *fsck)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tbitmap_t *disk_b, *alloc_b, *ohead_b;\n\toff_t dev_offset;\n\tunsigned int i, bitmap_bytes, byte_offset, write_bytes;\n\n\tdev_offset = exfat_c2o(exfat, exfat->disk_bitmap_clus);\n\tbitmap_bytes = EXFAT_BITMAP_SIZE(le32_to_cpu(exfat->bs->bsx.clu_count));\n\n\tdisk_b = (bitmap_t *)exfat->disk_bitmap;\n\talloc_b = (bitmap_t *)exfat->alloc_bitmap;\n\tohead_b = (bitmap_t *)exfat->ohead_bitmap;\n\n\tfor (i = 0; i < bitmap_bytes / sizeof(bitmap_t); i++)\n\t\tohead_b[i] = alloc_b[i] | disk_b[i];\n\n\ti = 0;\n\twhile (i < bitmap_bytes / sizeof(bitmap_t)) {\n\t\tif (ohead_b[i] == disk_b[i]) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbyte_offset = ((i * sizeof(bitmap_t)) / 512) * 512;\n\t\twrite_bytes = MIN(512, bitmap_bytes - byte_offset);\n\n\t\tif (exfat_write(exfat->blk_dev->dev_fd,\n\t\t\t\t(char *)ohead_b + byte_offset, write_bytes,\n\t\t\t\tdev_offset + byte_offset) != (ssize_t)write_bytes)\n\t\t\treturn -EIO;\n\n\t\ti = (byte_offset + write_bytes) / sizeof(bitmap_t);\n\t}\n\treturn 0;\n\n}\n\n/*\n * for each directory in @dir_list.\n * 1. read all dentries and allocate exfat_nodes for files and directories.\n *    and append directory exfat_nodes to the head of @dir_list\n * 2. free all of file exfat_nodes.\n * 3. if the directory does not have children, free its exfat_node.\n */\nstatic int exfat_filesystem_check(struct exfat_fsck *fsck)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tstruct exfat_inode *dir;\n\tint ret = 0, dir_errors;\n\n\tif (!exfat->root) {\n\t\texfat_err(\"root is NULL\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tlist_add(&exfat->root->list, &exfat->dir_list);\n\n\twhile (!list_empty(&exfat->dir_list)) {\n\t\tdir = list_entry(exfat->dir_list.next,\n\t\t\t\t struct exfat_inode, list);\n\n\t\tif (!(dir->attr & ATTR_SUBDIR)) {\n\t\t\tfsck_err(dir->parent, dir,\n\t\t\t\t\"failed to travel directories. \"\n\t\t\t\t\"the node is not directory\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdir_errors = read_children(fsck, dir);\n\t\tif (dir_errors) {\n\t\t\texfat_resolve_path(&path_resolve_ctx, dir);\n\t\t\texfat_debug(\"failed to check dentries: %s\\n\",\n\t\t\t\t\tpath_resolve_ctx.local_path);\n\t\t\tret = dir_errors;\n\t\t}\n\n\t\tlist_del(&dir->list);\n\t\texfat_free_file_children(dir);\n\t\texfat_free_ancestors(dir);\n\t}\nout:\n\texfat_free_dir_list(exfat);\n\treturn ret;\n}\n\nstatic int exfat_root_dir_check(struct exfat *exfat)\n{\n\tstruct exfat_inode *root;\n\tclus_t clus_count = 0;\n\tint err;\n\n\troot = exfat_alloc_inode(ATTR_SUBDIR);\n\tif (!root)\n\t\treturn -ENOMEM;\n\n\texfat->root = root;\n\troot->first_clus = le32_to_cpu(exfat->bs->bsx.root_cluster);\n\tif (root_check_clus_chain(exfat, root, &clus_count)) {\n\t\texfat_err(\"failed to follow the cluster chain of root\\n\");\n\t\texfat_free_inode(root);\n\t\texfat->root = NULL;\n\t\treturn -EINVAL;\n\t}\n\troot->size = clus_count * exfat->clus_size;\n\n\texfat_stat.dir_count++;\n\texfat_debug(\"root directory: start cluster[0x%x] size[0x%\" PRIx64 \"]\\n\",\n\t\troot->first_clus, root->size);\n\n\terr = exfat_read_volume_label(exfat);\n\tif (err && err != EOF)\n\t\texfat_err(\"failed to read volume label\\n\");\n\terr = 0;\n\n\terr = read_bitmap(exfat);\n\tif (err) {\n\t\texfat_err(\"failed to read bitmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = read_upcase_table(exfat);\n\tif (err) {\n\t\texfat_err(\"failed to read upcase table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\troot->dev_offset = 0;\n\terr = exfat_build_file_dentry_set(exfat, \" \", ATTR_SUBDIR,\n\t\t\t\t\t  &root->dentry_set, &root->dentry_count);\n\tif (err) {\n\t\texfat_free_inode(root);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int read_lostfound(struct exfat *exfat, struct exfat_inode **lostfound)\n{\n\tstruct exfat_lookup_filter filter;\n\tstruct exfat_inode *inode;\n\tint err;\n\n\terr = exfat_lookup_file(exfat, exfat->root, \"LOST+FOUND\", &filter);\n\tif (err)\n\t\treturn err;\n\n\tinode = exfat_alloc_inode(ATTR_SUBDIR);\n\tif (!inode) {\n\t\tfree(filter.out.dentry_set);\n\t\treturn -ENOMEM;\n\t}\n\n\tinode->dentry_set = filter.out.dentry_set;\n\tinode->dentry_count = filter.out.dentry_count;\n\tinode->dev_offset = filter.out.dev_offset;\n\n\tinode->first_clus =\n\t\tle32_to_cpu(filter.out.dentry_set[1].dentry.stream.start_clu);\n\tinode->size =\n\t\tle64_to_cpu(filter.out.dentry_set[1].dentry.stream.size);\n\n\t*lostfound = inode;\n\treturn 0;\n}\n\n/* Create temporary files under LOST+FOUND and assign orphan\n * chains of clusters to these files.\n */\nstatic int rescue_orphan_clusters(struct exfat_fsck *fsck)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tstruct exfat_inode *lostfound;\n\tbitmap_t *disk_b, *alloc_b, *ohead_b;\n\tstruct exfat_dentry *dset;\n\tclus_t clu_count, clu, s_clu, e_clu;\n\tint err, dcount;\n\tunsigned int i;\n\tchar name[] = \"FILE0000000.CHK\";\n\tstruct exfat_dentry_loc loc;\n\tstruct exfat_lookup_filter lf = {\n\t\t.in.type = EXFAT_INVAL,\n\t\t.in.filter = NULL,\n\t};\n\n\terr = read_lostfound(exfat, &lostfound);\n\tif (err) {\n\t\texfat_err(\"failed to find LOST+FOUND\\n\");\n\t\treturn err;\n\t}\n\n\t/* get the last empty region of LOST+FOUND */\n\terr = exfat_lookup_dentry_set(exfat, lostfound, &lf);\n\tif (err && err != EOF) {\n\t\texfat_err(\"failed to find the last empty slot in LOST+FOUND\\n\");\n\t\tgoto out;\n\t}\n\n\tloc.parent = lostfound;\n\tloc.file_offset = lf.out.file_offset;\n\tloc.dev_offset = lf.out.dev_offset;\n\n\t/* build a template dentry set */\n\terr = exfat_build_file_dentry_set(exfat, name, 0, &dset, &dcount);\n\tif (err) {\n\t\texfat_err(\"failed to create a temporary file in LOST+FOUNDn\");\n\t\tgoto out;\n\t}\n\tdset[1].dentry.stream.flags |= EXFAT_SF_CONTIGUOUS;\n\n\tclu_count = le32_to_cpu(exfat->bs->bsx.clu_count);\n\n\t/* find clusters which are not marked as free, but not allocated to\n\t * any files.\n\t */\n\tdisk_b = (bitmap_t *)exfat->disk_bitmap;\n\talloc_b = (bitmap_t *)exfat->alloc_bitmap;\n\tohead_b = (bitmap_t *)exfat->ohead_bitmap;\n\tfor (i = 0; i < EXFAT_BITMAP_SIZE(clu_count) / sizeof(bitmap_t); i++)\n\t\tohead_b[i] = disk_b[i] & ~alloc_b[i];\n\n\t/* create temporary files and allocate contiguous orphan clusters\n\t * to each file.\n\t */\n\tfor (clu = EXFAT_FIRST_CLUSTER; clu < clu_count + EXFAT_FIRST_CLUSTER &&\n\t     exfat_bitmap_find_one(exfat, exfat->ohead_bitmap, clu, &s_clu) == 0;) {\n\t\tif (exfat_bitmap_find_zero(exfat, exfat->ohead_bitmap, s_clu, &e_clu))\n\t\t\te_clu = clu_count + EXFAT_FIRST_CLUSTER;\n\t\tclu = e_clu;\n\n\t\tsnprintf(name, sizeof(name), \"FILE%07d.CHK\",\n\t\t\t (unsigned int)(loc.file_offset >> 5));\n\t\terr = exfat_update_file_dentry_set(exfat, dset, dcount,\n\t\t\t\t\t\t   name, s_clu, e_clu - s_clu);\n\t\tif (err)\n\t\t\tcontinue;\n\t\terr = exfat_add_dentry_set(exfat, &loc, dset, dcount, true);\n\t\tif (err)\n\t\t\tcontinue;\n\t}\n\n\tfree(dset);\n\terr = 0;\nout:\n\texfat_free_inode(lostfound);\n\treturn err;\n}\n\nstatic char *bytes_to_human_readable(size_t bytes)\n{\n\tstatic const char * const units[] = {\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\"};\n\tstatic char buf[15*4];\n\tunsigned int i, shift, quoti, remain;\n\ti = sizeof(units) / sizeof(units[0]) - 1;\n\n\twhile (i && (bytes >> i * 10) == 0)\n\t\ti--;\n\n\tshift = i * 10;\n\tquoti = (unsigned int)(bytes / (1ULL << shift));\n\tremain = 0;\n\tif (shift > 0) {\n\t\tremain = (unsigned int)\n\t\t\t((bytes & ((1ULL << shift) - 1)) >> (shift - 10));\n\t\tremain = (remain * 100) / 1024;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%u.%02u %s\", quoti, remain, units[i]);\n\treturn buf;\n}\n\nstatic void exfat_show_info(struct exfat_fsck *fsck, const char *dev_name)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tbool clean;\n\n\texfat_info(\"sector size:  %s\\n\",\n\t\tbytes_to_human_readable(1 << exfat->bs->bsx.sect_size_bits));\n\texfat_info(\"cluster size: %s\\n\",\n\t\tbytes_to_human_readable(exfat->clus_size));\n\texfat_info(\"volume size:  %s\\n\",\n\t\tbytes_to_human_readable(exfat->blk_dev->size));\n\n\tclean = exfat_stat.error_count == 0 ||\n\t\texfat_stat.error_count == exfat_stat.fixed_count;\n\tprintf(\"%s: %s. directories %ld, files %ld\\n\", dev_name,\n\t\t\tclean ? \"clean\" : \"corrupted\",\n\t\t\texfat_stat.dir_count, exfat_stat.file_count);\n\tif (exfat_stat.error_count)\n\t\tprintf(\"%s: files corrupted %ld, files fixed %ld\\n\", dev_name,\n\t\t\texfat_stat.error_count - exfat_stat.fixed_count,\n\t\t\texfat_stat.fixed_count);\n}\n\nint main(int argc, char * const argv[])\n{\n\tstruct fsck_user_input ui;\n\tstruct exfat_blk_dev bd;\n\tstruct pbr *bs = NULL;\n\tint c, ret, exit_code;\n\tbool version_only = false;\n\n\tmemset(&ui, 0, sizeof(ui));\n\tmemset(&bd, 0, sizeof(bd));\n\n\tprint_level = EXFAT_ERROR;\n\n\tif (!setlocale(LC_CTYPE, \"\"))\n\t\texfat_err(\"failed to init locale/codeset\\n\");\n\n\topterr = 0;\n\twhile ((c = getopt_long(argc, argv, \"arynpbsVvh\", opts, NULL)) != EOF) {\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_NO;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_ASK;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_YES;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'p':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_AUTO;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tui.options |= FSCK_OPTS_IGNORE_BAD_FS_NAME;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tui.options |= FSCK_OPTS_RESCUE_CLUS;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tversion_only = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (print_level < EXFAT_DEBUG)\n\t\t\t\tprint_level++;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tshow_version();\n\tif (optind != argc - 1)\n\t\tusage(argv[0]);\n\n\tif (version_only)\n\t\texit(FSCK_EXIT_SYNTAX_ERROR);\n\tif (ui.options & FSCK_OPTS_REPAIR_WRITE)\n\t\tui.ei.writeable = true;\n\telse {\n\t\tif (ui.options & (FSCK_OPTS_IGNORE_BAD_FS_NAME |\n\t\t\t\t  FSCK_OPTS_RESCUE_CLUS))\n\t\t\tusage(argv[0]);\n\t\tui.options |= FSCK_OPTS_REPAIR_NO;\n\t\tui.ei.writeable = false;\n\t}\n\n\texfat_fsck.options = ui.options;\n\n\tsnprintf(ui.ei.dev_name, sizeof(ui.ei.dev_name), \"%s\", argv[optind]);\n\tret = exfat_get_blk_dev_info(&ui.ei, &bd);\n\tif (ret < 0) {\n\t\texfat_err(\"failed to open %s. %d\\n\", ui.ei.dev_name, ret);\n\t\treturn FSCK_EXIT_OPERATION_ERROR;\n\t}\n\n\tret = exfat_boot_region_check(&bd, &bs,\n\t\t\t\t      ui.options & FSCK_OPTS_IGNORE_BAD_FS_NAME ?\n\t\t\t\t      true : false);\n\tif (ret)\n\t\tgoto err;\n\n\texfat_fsck.exfat = exfat_alloc_exfat(&bd, bs);\n\tif (!exfat_fsck.exfat) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\texfat_fsck.buffer_desc = exfat_alloc_buffer(2,\n\t\t\t\t\t\t    exfat_fsck.exfat->clus_size,\n\t\t\t\t\t\t    exfat_fsck.exfat->sect_size);\n\tif (!exfat_fsck.buffer_desc) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tif ((exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE) &&\n\t    exfat_mark_volume_dirty(exfat_fsck.exfat, true)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\texfat_debug(\"verifying root directory...\\n\");\n\tret = exfat_root_dir_check(exfat_fsck.exfat);\n\tif (ret) {\n\t\texfat_err(\"failed to verify root directory.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (exfat_fsck.options & FSCK_OPTS_RESCUE_CLUS) {\n\t\tret = exfat_create_file(exfat_fsck.exfat,\n\t\t\t\t\texfat_fsck.exfat->root,\n\t\t\t\t\t\"LOST+FOUND\",\n\t\t\t\t\tATTR_SUBDIR);\n\t\tif (ret) {\n\t\t\texfat_err(\"failed to create lost+found directory\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fsync(exfat_fsck.exfat->blk_dev->dev_fd) != 0) {\n\t\t\tret = -EIO;\n\t\t\texfat_err(\"failed to sync()\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\texfat_debug(\"verifying directory entries...\\n\");\n\tret = exfat_filesystem_check(&exfat_fsck);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exfat_fsck.options & FSCK_OPTS_RESCUE_CLUS) {\n\t\trescue_orphan_clusters(&exfat_fsck);\n\t\texfat_fsck.dirty = true;\n\t\texfat_fsck.dirty_fat = true;\n\t}\n\n\tif (exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE) {\n\t\tret = write_bitmap(&exfat_fsck);\n\t\tif (ret) {\n\t\t\texfat_err(\"failed to write bitmap\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ui.ei.writeable && fsync(bd.dev_fd)) {\n\t\texfat_err(\"failed to sync\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE)\n\t\texfat_mark_volume_dirty(exfat_fsck.exfat, false);\n\nout:\n\texfat_show_info(&exfat_fsck, ui.ei.dev_name);\nerr:\n\tif (ret && ret != -EINVAL)\n\t\texit_code = FSCK_EXIT_OPERATION_ERROR;\n\telse if (ret == -EINVAL ||\n\t\t exfat_stat.error_count != exfat_stat.fixed_count)\n\t\texit_code = FSCK_EXIT_ERRORS_LEFT;\n\telse if (exfat_fsck.dirty)\n\t\texit_code = FSCK_EXIT_CORRECTED;\n\telse\n\t\texit_code = FSCK_EXIT_NO_ERRORS;\n\n\tif (exfat_fsck.buffer_desc)\n\t\texfat_free_buffer(exfat_fsck.buffer_desc, 2);\n\tif (exfat_fsck.exfat)\n\t\texfat_free_exfat(exfat_fsck.exfat);\n\tclose(bd.dev_fd);\n\treturn exit_code;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *   Copyright (C) 2019 Namjae Jeon <linkinjeon@kernel.org>\n *   Copyright (C) 2020 Hyunchul Lee <hyc.lee@gmail.com>\n */\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <inttypes.h>\n#include <string.h>\n#include <errno.h>\n#include <locale.h>\n\n#include \"exfat_ondisk.h\"\n#include \"libexfat.h\"\n#include \"repair.h\"\n#include \"exfat_fs.h\"\n#include \"exfat_dir.h\"\n#include \"fsck.h\"\n\nstruct fsck_user_input {\n\tstruct exfat_user_input\t\tei;\n\tenum fsck_ui_options\t\toptions;\n};\n\n#define EXFAT_MAX_UPCASE_CHARS\t0x10000\n\n#define FSCK_EXIT_NO_ERRORS\t\t0x00\n#define FSCK_EXIT_CORRECTED\t\t0x01\n#define FSCK_EXIT_NEED_REBOOT\t\t0x02\n#define FSCK_EXIT_ERRORS_LEFT\t\t0x04\n#define FSCK_EXIT_OPERATION_ERROR\t0x08\n#define FSCK_EXIT_SYNTAX_ERROR\t\t0x10\n#define FSCK_EXIT_USER_CANCEL\t\t0x20\n#define FSCK_EXIT_LIBRARY_ERROR\t\t0x80\n\nstruct exfat_stat {\n\tlong\t\tdir_count;\n\tlong\t\tfile_count;\n\tlong\t\terror_count;\n\tlong\t\tfixed_count;\n};\n\nstruct exfat_fsck exfat_fsck;\nstruct exfat_stat exfat_stat;\nstruct path_resolve_ctx path_resolve_ctx;\n\nstatic struct option opts[] = {\n\t{\"repair\",\tno_argument,\tNULL,\t'r' },\n\t{\"repair-yes\",\tno_argument,\tNULL,\t'y' },\n\t{\"repair-no\",\tno_argument,\tNULL,\t'n' },\n\t{\"repair-auto\",\tno_argument,\tNULL,\t'p' },\n\t{\"rescue\",\tno_argument,\tNULL,\t's' },\n\t{\"version\",\tno_argument,\tNULL,\t'V' },\n\t{\"verbose\",\tno_argument,\tNULL,\t'v' },\n\t{\"help\",\tno_argument,\tNULL,\t'h' },\n\t{\"?\",\t\tno_argument,\tNULL,\t'?' },\n\t{\"ignore-bad-fs\",\tno_argument,\tNULL,\t'b' },\n\t{NULL,\t\t0,\t\tNULL,\t 0  }\n};\n\nstatic void usage(char *name)\n{\n\tfprintf(stderr, \"Usage: %s\\n\", name);\n\tfprintf(stderr, \"\\t-r | --repair        Repair interactively\\n\");\n\tfprintf(stderr, \"\\t-y | --repair-yes    Repair without ask\\n\");\n\tfprintf(stderr, \"\\t-n | --repair-no     No repair\\n\");\n\tfprintf(stderr, \"\\t-p | --repair-auto   Repair automatically\\n\");\n\tfprintf(stderr, \"\\t-a                   Repair automatically\\n\");\n\tfprintf(stderr, \"\\t-b | --ignore-bad-fs Try to recover even if exfat is not found\\n\");\n\tfprintf(stderr, \"\\t-s | --rescue        Assign orphaned clusters to files\\n\");\n\tfprintf(stderr, \"\\t-V | --version       Show version\\n\");\n\tfprintf(stderr, \"\\t-v | --verbose       Print debug\\n\");\n\tfprintf(stderr, \"\\t-h | --help          Show help\\n\");\n\n\texit(FSCK_EXIT_SYNTAX_ERROR);\n}\n\n#define fsck_err(parent, inode, fmt, ...)\t\t\\\n({\t\t\t\t\t\t\t\\\n\t\texfat_resolve_path_parent(&path_resolve_ctx,\t\\\n\t\t\tparent, inode);\t\t\t\\\n\t\texfat_err(\"ERROR: %s: \" fmt,\t\t\\\n\t\t\tpath_resolve_ctx.local_path,\t\\\n\t\t\t##__VA_ARGS__);\t\t\t\\\n})\n\n#define repair_file_ask(iter, inode, code, fmt, ...)\t\\\n({\t\t\t\t\t\t\t\\\n\t\tif (inode)\t\t\t\t\t\t\\\n\t\t\texfat_resolve_path_parent(&path_resolve_ctx,\t\\\n\t\t\t\t\t    (iter)->parent, inode);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\texfat_resolve_path(&path_resolve_ctx,\t\t\\\n\t\t\t\t     (iter)->parent);\t\t\t\\\n\t\texfat_repair_ask(&exfat_fsck, code,\t\t\t\\\n\t\t\t\t \"ERROR: %s: \" fmt \" at %#\" PRIx64,\t\\\n\t\t\t\t path_resolve_ctx.local_path,\t\t\\\n\t\t\t\t ##__VA_ARGS__,\t\t\t\t\\\n\t\t\t\t exfat_de_iter_device_offset(iter));\t\\\n})\n\nstatic int check_clus_chain(struct exfat_de_iter *de_iter,\n\t\t\t\tstruct exfat_inode *node)\n{\n\tstruct exfat *exfat = de_iter->exfat;\n\tstruct exfat_dentry *stream_de;\n\tclus_t clus, prev, next, new_clus;\n\tuint64_t count, max_count;\n\tint err;\n\n\tclus = node->first_clus;\n\tprev = EXFAT_EOF_CLUSTER;\n\tcount = 0;\n\tmax_count = DIV_ROUND_UP(node->size, exfat->clus_size);\n\n\tif (node->size == 0 && node->first_clus == EXFAT_FREE_CLUSTER) {\n\t\t/* locate a cluster for the empty dir if the dir starts with EXFAT_FREE_CLUSTER */\n\t\tif (node->attr & ATTR_SUBDIR) {\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\tER_DE_FIRST_CLUS,\n\t\t\t\t\t\"size %#\" PRIx64 \", but the first cluster %#x\",\n\t\t\t\t\tnode->size, node->first_clus))\n\t\t\t\tgoto allocate_cluster;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\t/* the first cluster is wrong */\n\tif ((node->size == 0 && node->first_clus != EXFAT_FREE_CLUSTER) ||\n\t    (node->size > 0 && !exfat_heap_clus(exfat, node->first_clus))) {\n\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t    ER_FILE_FIRST_CLUS,\n\t\t\t\t    \"size %#\" PRIx64 \", but the first cluster %#x\",\n\t\t\t\t    node->size, node->first_clus))\n\t\t\tgoto truncate_file;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\twhile (clus != EXFAT_EOF_CLUSTER) {\n\t\tif (count >= max_count) {\n\t\t\tif (node->is_contiguous)\n\t\t\t\tbreak;\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t    ER_FILE_SMALLER_SIZE,\n\t\t\t\t\t    \"more clusters are allocated. truncate to %\"\n\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t    count * exfat->clus_size))\n\t\t\t\tgoto truncate_file;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * This cluster is already allocated. it may be shared with\n\t\t * the other file, or there is a loop in cluster chain.\n\t\t */\n\t\tif (exfat_bitmap_get(exfat->alloc_bitmap, clus)) {\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t    ER_FILE_DUPLICATED_CLUS,\n\t\t\t\t\t    \"cluster is already allocated for the other file. truncated to %\"\n\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t    count * exfat->clus_size))\n\t\t\t\tgoto truncate_file;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!exfat_bitmap_get(exfat->disk_bitmap, clus)) {\n\t\t\tif (!repair_file_ask(de_iter, node,\n\t\t\t\t\t     ER_FILE_INVALID_CLUS,\n\t\t\t\t\t     \"cluster %#x is marked as free\",\n\t\t\t\t\t     clus))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* This cluster is allocated or not */\n\t\tif (exfat_get_inode_next_clus(exfat, node, clus, &next))\n\t\t\tgoto truncate_file;\n\t\tif (next == EXFAT_BAD_CLUSTER) {\n\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t    ER_FILE_INVALID_CLUS,\n\t\t\t\t\t    \"BAD cluster. truncate to %\"\n\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t    count * exfat->clus_size))\n\t\t\t\tgoto truncate_file;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!node->is_contiguous) {\n\t\t\tif (next != EXFAT_EOF_CLUSTER &&\n\t\t\t    !exfat_heap_clus(exfat, next)) {\n\t\t\t\tif (repair_file_ask(de_iter, node,\n\t\t\t\t\t\t    ER_FILE_INVALID_CLUS,\n\t\t\t\t\t\t    \"broken cluster chain. truncate to %\"\n\t\t\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t\t\t    (count + 1) * exfat->clus_size)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tprev = clus;\n\t\t\t\t\texfat_bitmap_set(exfat->alloc_bitmap,\n\t\t\t\t\t\t\t clus);\n\t\t\t\t\tgoto truncate_file;\n\t\t\t\t} else {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcount++;\n\t\texfat_bitmap_set(exfat->alloc_bitmap, clus);\n\t\tprev = clus;\n\t\tclus = next;\n\t}\n\n\tif (count < max_count) {\n\t\tif (repair_file_ask(de_iter, node, ER_FILE_LARGER_SIZE,\n\t\t\t\t    \"less clusters are allocated. truncates to %\"\n\t\t\t\t    PRIu64 \" bytes\",\n\t\t\t\t    count * exfat->clus_size))\n\t\t\tgoto truncate_file;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\nallocate_cluster:\n\texfat_de_iter_get_dirty(de_iter, 1, &stream_de);\n\terr = exfat_find_free_cluster(exfat, exfat->start_clu, &new_clus);\n\tif (err) {\n\t\texfat->start_clu = EXFAT_FIRST_CLUSTER;\n\t\texfat_err(\"failed to find a free cluster\\n\");\n\t\treturn -ENOSPC;\n\t}\n\texfat->start_clu = new_clus;\n\n\tif (exfat_set_fat(exfat, new_clus, EXFAT_EOF_CLUSTER))\n\t\treturn -EIO;\n\n\t/* zero out the new cluster */\n\tif (exfat_write(exfat->blk_dev->dev_fd, exfat->zero_cluster,\n\t\t\texfat->clus_size, exfat_c2o(exfat, new_clus)) !=\n\t\t\t(ssize_t)exfat->clus_size) {\n\t\texfat_err(\"failed to fill new cluster with zeroes\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* modify the number of cluster form 0 to 1 */\n\tcount = 1;\n\tstream_de->stream_start_clu = cpu_to_le32(new_clus);\n\tstream_de->stream_size = cpu_to_le64(count * exfat->clus_size);\n\tstream_de->stream_valid_size = cpu_to_le64(count * exfat->clus_size);\n\tstream_de->dentry.stream.flags |= EXFAT_SF_CONTIGUOUS;\n\tnode->first_clus = new_clus;\n\tnode->size = count * exfat->clus_size;\n\tnode->is_contiguous = true;\n\texfat_bitmap_set(exfat->alloc_bitmap, new_clus);\n\treturn 1;\ntruncate_file:\n\tnode->size = count * exfat->clus_size;\n\tif (!exfat_heap_clus(exfat, prev))\n\t\tnode->first_clus = EXFAT_FREE_CLUSTER;\n\n\texfat_de_iter_get_dirty(de_iter, 1, &stream_de);\n\tif (count * exfat->clus_size <\n\t    le64_to_cpu(stream_de->stream_valid_size))\n\t\tstream_de->stream_valid_size = cpu_to_le64(\n\t\t\t\t\t\t\t   count * exfat->clus_size);\n\tif (!exfat_heap_clus(exfat, prev))\n\t\tstream_de->stream_start_clu = EXFAT_FREE_CLUSTER;\n\tstream_de->stream_size = cpu_to_le64(\n\t\t\t\t\t     count * exfat->clus_size);\n\n\t/* remaining clusters will be freed while FAT is compared with\n\t * alloc_bitmap.\n\t */\n\tif (!node->is_contiguous && exfat_heap_clus(exfat, prev)) {\n\t\tif (exfat_set_fat(exfat, prev, EXFAT_EOF_CLUSTER))\n\t\t\treturn -EIO;\n\t}\n\treturn 1;\n}\n\nstatic int root_check_clus_chain(struct exfat *exfat,\n\t\t\t\t struct exfat_inode *node,\n\t\t\t\t clus_t *clus_count)\n{\n\tclus_t clus, next, prev = EXFAT_EOF_CLUSTER;\n\n\tif (!exfat_heap_clus(exfat, node->first_clus))\n\t\tgoto out_trunc;\n\n\tclus = node->first_clus;\n\t*clus_count = 0;\n\n\tdo {\n\t\tif (exfat_bitmap_get(exfat->alloc_bitmap, clus)) {\n\t\t\tif (exfat_repair_ask(&exfat_fsck,\n\t\t\t\t\t     ER_FILE_DUPLICATED_CLUS,\n\t\t\t\t\t     \"ERROR: the cluster chain of root is cyclic\"))\n\t\t\t\tgoto out_trunc;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\texfat_bitmap_set(exfat->alloc_bitmap, clus);\n\n\t\tif (exfat_get_inode_next_clus(exfat, node, clus, &next)) {\n\t\t\texfat_err(\"ERROR: failed to read the fat entry of root\");\n\t\t\tgoto out_trunc;\n\t\t}\n\n\t\tif (next != EXFAT_EOF_CLUSTER && !exfat_heap_clus(exfat, next)) {\n\t\t\tif (exfat_repair_ask(&exfat_fsck,\n\t\t\t\t\t     ER_FILE_INVALID_CLUS,\n\t\t\t\t\t     \"ERROR: the cluster chain of root is broken\")) {\n\t\t\t\tif (next != EXFAT_BAD_CLUSTER) {\n\t\t\t\t\tprev = clus;\n\t\t\t\t\t(*clus_count)++;\n\t\t\t\t}\n\t\t\t\tgoto out_trunc;\n\t\t\t}\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprev = clus;\n\t\tclus = next;\n\t\t(*clus_count)++;\n\t} while (clus != EXFAT_EOF_CLUSTER);\n\n\treturn 0;\nout_trunc:\n\tif (!exfat_heap_clus(exfat, prev)) {\n\t\texfat_err(\"ERROR: the start cluster of root is wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\tnode->size = *clus_count * exfat->clus_size;\n\treturn exfat_set_fat(exfat, prev, EXFAT_EOF_CLUSTER);\n}\n\nstatic int boot_region_checksum(int dev_fd,\n\t\t\t\tint bs_offset, unsigned int sect_size)\n{\n\tvoid *sect;\n\tunsigned int i;\n\tuint32_t checksum;\n\tint ret = 0;\n\n\tsect = malloc(sect_size);\n\tif (!sect)\n\t\treturn -ENOMEM;\n\n\tchecksum = 0;\n\tfor (i = 0; i < 11; i++) {\n\t\tif (exfat_read(dev_fd, sect, sect_size,\n\t\t\t\tbs_offset * sect_size + i * sect_size) !=\n\t\t\t\t(ssize_t)sect_size) {\n\t\t\texfat_err(\"failed to read boot region\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tboot_calc_checksum(sect, sect_size, i == 0, &checksum);\n\t}\n\n\tif (exfat_read(dev_fd, sect, sect_size,\n\t\t\tbs_offset * sect_size + 11 * sect_size) !=\n\t\t\t(ssize_t)sect_size) {\n\t\texfat_err(\"failed to read a boot checksum sector\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < sect_size/sizeof(checksum); i++) {\n\t\tif (le32_to_cpu(((__le32 *)sect)[i]) != checksum) {\n\t\t\texfat_err(\"checksum of boot region is not correct. %#x, but expected %#x\\n\",\n\t\t\t\tle32_to_cpu(((__le32 *)sect)[i]), checksum);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree(sect);\n\treturn ret;\n}\n\nstatic int exfat_mark_volume_dirty(struct exfat *exfat, bool dirty)\n{\n\tuint16_t flags;\n\n\tflags = le16_to_cpu(exfat->bs->bsx.vol_flags);\n\tif (dirty)\n\t\tflags |= 0x02;\n\telse\n\t\tflags &= ~0x02;\n\n\texfat->bs->bsx.vol_flags = cpu_to_le16(flags);\n\tif (exfat_write(exfat->blk_dev->dev_fd, exfat->bs,\n\t\t\tsizeof(struct pbr), 0) != (ssize_t)sizeof(struct pbr)) {\n\t\texfat_err(\"failed to set VolumeDirty\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (fsync(exfat->blk_dev->dev_fd) != 0) {\n\t\texfat_err(\"failed to set VolumeDirty\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int read_boot_region(struct exfat_blk_dev *bd, struct pbr **pbr,\n\t\t\t    int bs_offset, unsigned int sect_size,\n\t\t\t    bool verbose)\n{\n\tstruct pbr *bs;\n\tint ret = -EINVAL;\n\n\t*pbr = NULL;\n\tbs = (struct pbr *)malloc(sizeof(struct pbr));\n\tif (!bs) {\n\t\texfat_err(\"failed to allocate memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (exfat_read(bd->dev_fd, bs, sizeof(*bs),\n\t\t\tbs_offset * sect_size) != (ssize_t)sizeof(*bs)) {\n\t\texfat_err(\"failed to read a boot sector\\n\");\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (memcmp(bs->bpb.oem_name, \"EXFAT   \", 8) != 0) {\n\t\tif (verbose)\n\t\t\texfat_err(\"failed to find exfat file system\\n\");\n\t\tgoto err;\n\t}\n\n\tret = boot_region_checksum(bd->dev_fd, bs_offset, sect_size);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EINVAL;\n\tif (EXFAT_SECTOR_SIZE(bs) < 512 || EXFAT_SECTOR_SIZE(bs) > 4 * KB) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too small or big sector size: %d\\n\",\n\t\t\t\t  EXFAT_SECTOR_SIZE(bs));\n\t\tgoto err;\n\t}\n\n\tif (EXFAT_CLUSTER_SIZE(bs) > 32 * MB) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too big cluster size: %d\\n\",\n\t\t\t\t  EXFAT_CLUSTER_SIZE(bs));\n\t\tgoto err;\n\t}\n\n\tif (bs->bsx.fs_version[1] != 1 || bs->bsx.fs_version[0] != 0) {\n\t\tif (verbose)\n\t\t\texfat_err(\"unsupported exfat version: %d.%d\\n\",\n\t\t\t\t  bs->bsx.fs_version[1], bs->bsx.fs_version[0]);\n\t\tgoto err;\n\t}\n\n\tif (bs->bsx.num_fats != 1) {\n\t\tif (verbose)\n\t\t\texfat_err(\"unsupported FAT count: %d\\n\",\n\t\t\t\t  bs->bsx.num_fats);\n\t\tgoto err;\n\t}\n\n\tif (le64_to_cpu(bs->bsx.vol_length) * EXFAT_SECTOR_SIZE(bs) >\n\t\t\tbd->size) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too large sector count: %\" PRIu64 \", expected: %llu\\n\",\n\t\t\t\t  le64_to_cpu(bs->bsx.vol_length),\n\t\t\t\t  bd->num_sectors);\n\t\tgoto err;\n\t}\n\n\tif (le32_to_cpu(bs->bsx.clu_count) * EXFAT_CLUSTER_SIZE(bs) >\n\t\t\tbd->size) {\n\t\tif (verbose)\n\t\t\texfat_err(\"too large cluster count: %u, expected: %u\\n\",\n\t\t\t\t  le32_to_cpu(bs->bsx.clu_count),\n\t\t\t\t  bd->num_clusters);\n\t\tgoto err;\n\t}\n\n\t*pbr = bs;\n\treturn 0;\nerr:\n\tfree(bs);\n\treturn ret;\n}\n\nstatic int restore_boot_region(struct exfat_blk_dev *bd, unsigned int sect_size)\n{\n\tint i;\n\tchar *sector;\n\tint ret;\n\n\tsector = malloc(sect_size);\n\tif (!sector)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < 12; i++) {\n\t\tif (exfat_read(bd->dev_fd, sector, sect_size,\n\t\t\t\tBACKUP_BOOT_SEC_IDX * sect_size +\n\t\t\t\ti * sect_size) !=\n\t\t\t\t(ssize_t)sect_size) {\n\t\t\tret = -EIO;\n\t\t\tgoto free_sector;\n\t\t}\n\t\tif (i == 0)\n\t\t\t((struct pbr *)sector)->bsx.perc_in_use = 0xff;\n\n\t\tif (exfat_write(bd->dev_fd, sector, sect_size,\n\t\t\t\tBOOT_SEC_IDX * sect_size +\n\t\t\t\ti * sect_size) !=\n\t\t\t\t(ssize_t)sect_size) {\n\t\t\tret = -EIO;\n\t\t\tgoto free_sector;\n\t\t}\n\t}\n\n\tif (fsync(bd->dev_fd)) {\n\t\tret = -EIO;\n\t\tgoto free_sector;\n\t}\n\tret = 0;\n\nfree_sector:\n\tfree(sector);\n\treturn ret;\n}\n\nstatic int exfat_boot_region_check(struct exfat_blk_dev *blkdev,\n\t\t\t\t   struct pbr **bs,\n\t\t\t\t   bool ignore_bad_fs_name)\n{\n\tstruct pbr *boot_sect;\n\tunsigned int sect_size;\n\tint ret;\n\n\t/* First, find out the exfat sector size */\n\tboot_sect = malloc(sizeof(*boot_sect));\n\tif (boot_sect == NULL)\n\t\treturn -ENOMEM;\n\n\tif (exfat_read(blkdev->dev_fd, boot_sect,\n\t\t       sizeof(*boot_sect), 0) != (ssize_t)sizeof(*boot_sect)) {\n\t\texfat_err(\"failed to read Main boot sector\\n\");\n\t\tfree(boot_sect);\n\t\treturn -EIO;\n\t}\n\n\tif (memcmp(boot_sect->bpb.oem_name, \"EXFAT   \", 8) != 0 &&\n\t    !ignore_bad_fs_name) {\n\t\texfat_err(\"Bad fs_name in boot sector, which does not describe a valid exfat filesystem\\n\");\n\t\tfree(boot_sect);\n\t\treturn -ENOTSUP;\n\t}\n\n\tsect_size = 1 << boot_sect->bsx.sect_size_bits;\n\tfree(boot_sect);\n\n\t/* check boot regions */\n\tret = read_boot_region(blkdev, bs,\n\t\t\t       BOOT_SEC_IDX, sect_size, true);\n\tif (ret == -EINVAL &&\n\t    exfat_repair_ask(&exfat_fsck, ER_BS_BOOT_REGION,\n\t\t\t     \"boot region is corrupted. try to restore the region from backup\"\n\t\t\t\t)) {\n\t\tconst unsigned int sector_sizes[] = {512, 4096, 1024, 2048};\n\t\tunsigned int i;\n\n\t\tif (sect_size >= 512 && sect_size <= EXFAT_MAX_SECTOR_SIZE) {\n\t\t\tret = read_boot_region(blkdev, bs,\n\t\t\t\t\t       BACKUP_BOOT_SEC_IDX, sect_size,\n\t\t\t\t\t       false);\n\t\t\tif (!ret)\n\t\t\t\tgoto restore;\n\t\t}\n\n\t\tfor (i = 0; i < sizeof(sector_sizes)/sizeof(sector_sizes[0]); i++) {\n\t\t\tif (sector_sizes[i] == sect_size)\n\t\t\t\tcontinue;\n\n\t\t\tret = read_boot_region(blkdev, bs,\n\t\t\t\t\t       BACKUP_BOOT_SEC_IDX,\n\t\t\t\t\t       sector_sizes[i], false);\n\t\t\tif (!ret) {\n\t\t\t\tsect_size = sector_sizes[i];\n\t\t\t\tgoto restore;\n\t\t\t}\n\t\t}\n\t\texfat_err(\"backup boot region is also corrupted\\n\");\n\t}\n\n\treturn ret;\nrestore:\n\tret = restore_boot_region(blkdev, sect_size);\n\tif (ret) {\n\t\texfat_err(\"failed to restore boot region from backup\\n\");\n\t\tfree(*bs);\n\t\t*bs = NULL;\n\t}\n\treturn ret;\n}\n\nstatic uint16_t file_calc_checksum(struct exfat_de_iter *iter)\n{\n\tuint16_t checksum;\n\tstruct exfat_dentry *file_de, *de;\n\tint i;\n\n\tchecksum = 0;\n\texfat_de_iter_get(iter, 0, &file_de);\n\n\texfat_calc_dentry_checksum(file_de, &checksum, true);\n\tfor (i = 1; i <= file_de->file_num_ext; i++) {\n\t\texfat_de_iter_get(iter, i, &de);\n\t\texfat_calc_dentry_checksum(de, &checksum, false);\n\t}\n\treturn checksum;\n}\n\n/*\n * return 0 if there are no errors, or 1 if errors are fixed, or\n * an error code\n */\nstatic int check_inode(struct exfat_de_iter *iter, struct exfat_inode *node)\n{\n\tstruct exfat *exfat = iter->exfat;\n\tstruct exfat_dentry *dentry;\n\tint ret = 0;\n\tuint16_t checksum;\n\tbool valid = true;\n\n\tret = check_clus_chain(iter, node);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (node->size > le32_to_cpu(exfat->bs->bsx.clu_count) *\n\t\t\t\t(uint64_t)exfat->clus_size) {\n\t\tfsck_err(iter->parent, node,\n\t\t\t\"size %\" PRIu64 \" is greater than cluster heap\\n\",\n\t\t\tnode->size);\n\t\tvalid = false;\n\t}\n\n\tif (node->size == 0 && node->is_contiguous) {\n\t\tif (repair_file_ask(iter, node, ER_FILE_ZERO_NOFAT,\n\t\t\t\t\"empty, but has no Fat chain\")) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &dentry);\n\t\t\tdentry->stream_flags &= ~EXFAT_SF_CONTIGUOUS;\n\t\t\tret = 1;\n\t\t} else\n\t\t\tvalid = false;\n\t}\n\n\tif ((node->attr & ATTR_SUBDIR) &&\n\t\t\tnode->size % exfat->clus_size != 0) {\n\t\tfsck_err(iter->parent, node,\n\t\t\t\"directory size %\" PRIu64 \" is not divisible by %d\\n\",\n\t\t\tnode->size, exfat->clus_size);\n\t\tvalid = false;\n\t}\n\n\tchecksum = file_calc_checksum(iter);\n\texfat_de_iter_get(iter, 0, &dentry);\n\tif (checksum != le16_to_cpu(dentry->file_checksum)) {\n\t\texfat_de_iter_get_dirty(iter, 0, &dentry);\n\t\tdentry->file_checksum = cpu_to_le16(checksum);\n\t\tret = 1;\n\t}\n\n\treturn valid ? ret : -EINVAL;\n}\n\nstatic int check_name_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\t struct exfat_inode *inode)\n{\n\tstruct exfat_dentry *stream_de;\n\tsize_t name_len;\n\t__u16 hash;\n\n\texfat_de_iter_get(iter, 1, &stream_de);\n\n\tname_len = exfat_utf16_len(inode->name, NAME_BUFFER_SIZE);\n\tif (stream_de->stream_name_len != name_len) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_NAME_LEN,\n\t\t\t\t    \"the name length of a file is wrong\")) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\t\tstream_de->stream_name_len = (__u8)name_len;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\thash = exfat_calc_name_hash(iter->exfat, inode->name, (int)name_len);\n\tif (cpu_to_le16(hash) != stream_de->stream_name_hash) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_NAME_HASH,\n\t\t\t\t    \"the name hash of a file is wrong\")) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\t\tstream_de->stream_name_hash = cpu_to_le16(hash);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_bad_char(char w)\n{\n\treturn (w < 0x0020) || (w == '*') || (w == '?') || (w == '<') ||\n\t\t(w == '>') || (w == '|') || (w == '\"') || (w == ':') ||\n\t\t(w == '/') || (w == '\\\\');\n}\n\nstatic char *get_rename_from_user(struct exfat_de_iter *iter)\n{\n\tchar *rename = malloc(ENTRY_NAME_MAX + 2);\n\n\tif (!rename)\n\t\treturn NULL;\n\nretry:\n\t/* +2 means LF(Line Feed) and NULL terminator */\n\tmemset(rename, 0x1, ENTRY_NAME_MAX + 2);\n\tprintf(\"New name: \");\n\tif (fgets(rename, ENTRY_NAME_MAX + 2, stdin)) {\n\t\tint i, len, err;\n\t\tstruct exfat_lookup_filter filter;\n\n\t\tlen = strlen(rename);\n\t\t/* Remove LF in filename */\n\t\trename[len - 1] = '\\0';\n\t\tfor (i = 0; i < len - 1; i++) {\n\t\t\tif (check_bad_char(rename[i])) {\n\t\t\t\tprintf(\"filename contain invalid character(%c)\\n\", rename[i]);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\n\t\texfat_de_iter_flush(iter);\n\t\terr = exfat_lookup_file(iter->exfat, iter->parent, rename, &filter);\n\t\tif (!err) {\n\t\t\tprintf(\"file(%s) already exists, retry to insert name\\n\", rename);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\treturn rename;\n}\n\nstatic char *generate_rename(struct exfat_de_iter *iter)\n{\n\tchar *rename;\n\n\tif (iter->dot_name_num > DOT_NAME_NUM_MAX)\n\t\treturn NULL;\n\n\trename = malloc(ENTRY_NAME_MAX + 1);\n\tif (!rename)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tstruct exfat_lookup_filter filter;\n\t\tint err;\n\n\t\tsnprintf(rename, ENTRY_NAME_MAX + 1, \"FILE%07d.CHK\",\n\t\t\t iter->dot_name_num++);\n\t\terr = exfat_lookup_file(iter->exfat, iter->parent, rename,\n\t\t\t\t\t&filter);\n\t\tif (!err)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\treturn rename;\n}\n\nconst __le16 MSDOS_DOT[ENTRY_NAME_MAX] = {cpu_to_le16(46), 0, };\nconst __le16 MSDOS_DOTDOT[ENTRY_NAME_MAX] = {cpu_to_le16(46), cpu_to_le16(46), 0, };\n\nstatic int handle_dot_dotdot_filename(struct exfat_de_iter *iter,\n\t\t\t\t      struct exfat_dentry *dentry,\n\t\t\t\t      int strm_name_len)\n{\n\tchar *filename;\n\tchar error_msg[150];\n\tint num;\n\n\tif (!memcmp(dentry->name_unicode, MSDOS_DOT, strm_name_len * 2))\n\t\tfilename = \".\";\n\telse if (!memcmp(dentry->name_unicode, MSDOS_DOTDOT,\n\t\t\t strm_name_len * 2))\n\t\tfilename = \"..\";\n\telse\n\t\treturn 0;\n\n\tsprintf(error_msg, \"ERROR: '%s' filename is not allowed.\\n\"\n\t\t\t\" [1] Insert the name you want to rename.\\n\"\n\t\t\t\" [2] Automatically renames filename.\\n\"\n\t\t\t\" [3] Bypass this check(No repair)\\n\", filename);\nask_again:\n\tnum = exfat_repair_ask(&exfat_fsck, ER_DE_DOT_NAME,\n\t\t\t       error_msg);\n\tif (num) {\n\t\t__le16 utf16_name[ENTRY_NAME_MAX];\n\t\tchar *rename = NULL;\n\t\t__u16 hash;\n\t\tstruct exfat_dentry *stream_de;\n\t\tint ret;\n\n\t\tswitch (num) {\n\t\tcase 1:\n\t\t\trename = get_rename_from_user(iter);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trename = generate_rename(iter);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texfat_info(\"select 1 or 2 number instead of %d\\n\", num);\n\t\t\tgoto ask_again;\n\t\t}\n\n\t\tif (!rename)\n\t\t\treturn -EINVAL;\n\n\t\texfat_info(\"%s filename is renamed to %s\\n\", filename, rename);\n\n\t\texfat_de_iter_get_dirty(iter, 2, &dentry);\n\n\t\tmemset(utf16_name, 0, sizeof(utf16_name));\n\t\tret = exfat_utf16_enc(rename, utf16_name, sizeof(utf16_name));\n\t\tfree(rename);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret >>= 1;\n\t\tmemcpy(dentry->name_unicode, utf16_name, ENTRY_NAME_MAX * 2);\n\t\thash = exfat_calc_name_hash(iter->exfat, utf16_name, ret);\n\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\tstream_de->stream_name_len = (__u8)ret;\n\t\tstream_de->stream_name_hash = cpu_to_le16(hash);\n\t}\n\n\treturn 0;\n}\n\nstatic int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tbool need_delete = false;\n\tuint16_t checksum;\n\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_err(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchecksum = file_calc_checksum(iter);\n\tif (checksum != le16_to_cpu(file_de->file_checksum)) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_CHECKSUM,\n\t\t\t\t    \"the checksum of a file is wrong\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (file_de->file_num_ext < 2) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_SECONDARY_COUNT,\n\t\t\t\t    \"a file has too few secondary count. %d\",\n\t\t\t\t    file_de->file_num_ext))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 1;\n\t\tgoto skip_dset;\n\t}\n\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\tif (repair_file_ask(iter, NULL, ER_DE_STREAM,\n\t\t\t\t    \"failed to get stream dentry\"))\n\t\t\tneed_delete = true;\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME) {\n\t\t\tif (i > 2 && repair_file_ask(iter, NULL, ER_DE_NAME,\n\t\t\t\t\t\t     \"failed to get name dentry\")) {\n\t\t\t\texfat_de_iter_get_dirty(iter, 0, &file_de);\n\t\t\t\tfile_de->file_num_ext = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*skip_dentries = i + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tret = check_name_dentry_set(iter, node);\n\tif (ret) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tgoto skip_dset;\n\t}\n\n\tif (file_de->file_num_ext == 2 && stream_de->stream_name_len <= 2) {\n\t\tret = handle_dot_dotdot_filename(iter, dentry,\n\t\t\t\tstream_de->stream_name_len);\n\t\tif (ret < 0) {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\n\tif (node->size < le64_to_cpu(stream_de->stream_valid_size)) {\n\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\tif (repair_file_ask(iter, node, ER_FILE_VALID_SIZE,\n\t\t\t\t    \"valid size %\" PRIu64 \" greater than size %\" PRIu64,\n\t\t\t\t    le64_to_cpu(stream_de->stream_valid_size),\n\t\t\t\t    node->size)) {\n\t\t\texfat_de_iter_get_dirty(iter, 1, &stream_de);\n\t\t\tstream_de->stream_valid_size =\n\t\t\t\t\tstream_de->stream_size;\n\t\t} else {\n\t\t\t*skip_dentries = file_de->file_num_ext + 1;\n\t\t\tgoto skip_dset;\n\t\t}\n\t}\n\n\t*skip_dentries = (file_de->file_num_ext + 1);\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\tif (need_delete) {\n\t\texfat_de_iter_get_dirty(iter, 0, &dentry);\n\t\tdentry->type &= EXFAT_DELETE;\n\t}\n\tfor (i = 1; i < *skip_dentries; i++) {\n\t\texfat_de_iter_get(iter, i, &dentry);\n\t\tif (dentry->type == EXFAT_FILE)\n\t\t\tbreak;\n\t\tif (need_delete) {\n\t\t\texfat_de_iter_get_dirty(iter, i, &dentry);\n\t\t\tdentry->type &= EXFAT_DELETE;\n\t\t}\n\t}\n\t*skip_dentries = i;\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn need_delete ? 1 : -EINVAL;\n}\n\nstatic int read_file(struct exfat_de_iter *de_iter,\n\t\tstruct exfat_inode **new_node, int *dentry_count)\n{\n\tstruct exfat_inode *node;\n\tint ret;\n\n\t*new_node = NULL;\n\n\tret = read_file_dentry_set(de_iter, &node, dentry_count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_inode(de_iter, node);\n\tif (ret < 0) {\n\t\texfat_free_inode(node);\n\t\treturn -EINVAL;\n\t}\n\n\tif (node->attr & ATTR_SUBDIR)\n\t\texfat_stat.dir_count++;\n\telse\n\t\texfat_stat.file_count++;\n\t*new_node = node;\n\treturn ret;\n}\n\nstatic int read_bitmap(struct exfat *exfat)\n{\n\tstruct exfat_lookup_filter filter = {\n\t\t.in.type\t= EXFAT_BITMAP,\n\t\t.in.filter\t= NULL,\n\t\t.in.param\t= NULL,\n\t};\n\tstruct exfat_dentry *dentry;\n\tint retval;\n\n\tretval = exfat_lookup_dentry_set(exfat, exfat->root, &filter);\n\tif (retval)\n\t\treturn retval;\n\n\tdentry = filter.out.dentry_set;\n\texfat_debug(\"start cluster %#x, size %#\" PRIx64 \"\\n\",\n\t\t\tle32_to_cpu(dentry->bitmap_start_clu),\n\t\t\tle64_to_cpu(dentry->bitmap_size));\n\n\tif (le64_to_cpu(dentry->bitmap_size) <\n\t\t\tDIV_ROUND_UP(exfat->clus_count, 8)) {\n\t\texfat_err(\"invalid size of allocation bitmap. 0x%\" PRIx64 \"\\n\",\n\t\t\t\tle64_to_cpu(dentry->bitmap_size));\n\t\treturn -EINVAL;\n\t}\n\tif (!exfat_heap_clus(exfat, le32_to_cpu(dentry->bitmap_start_clu))) {\n\t\texfat_err(\"invalid start cluster of allocate bitmap. 0x%x\\n\",\n\t\t\t\tle32_to_cpu(dentry->bitmap_start_clu));\n\t\treturn -EINVAL;\n\t}\n\n\texfat->disk_bitmap_clus = le32_to_cpu(dentry->bitmap_start_clu);\n\texfat->disk_bitmap_size = DIV_ROUND_UP(exfat->clus_count, 8);\n\n\texfat_bitmap_set_range(exfat, exfat->alloc_bitmap,\n\t\t\t       le64_to_cpu(dentry->bitmap_start_clu),\n\t\t\t       DIV_ROUND_UP(exfat->disk_bitmap_size,\n\t\t\t\t\t    exfat->clus_size));\n\tfree(filter.out.dentry_set);\n\n\tif (exfat_read(exfat->blk_dev->dev_fd, exfat->disk_bitmap,\n\t\t\texfat->disk_bitmap_size,\n\t\t\texfat_c2o(exfat, exfat->disk_bitmap_clus)) !=\n\t\t\t(ssize_t)exfat->disk_bitmap_size)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int decompress_upcase_table(const __le16 *in_table, size_t in_len,\n\t\t\t\t   __u16 *out_table, size_t out_len)\n{\n\tsize_t i, k;\n\tuint16_t ch;\n\n\tif (in_len > out_len)\n\t\treturn -E2BIG;\n\n\tfor (k = 0; k < out_len; k++)\n\t\tout_table[k] = k;\n\n\tfor (i = 0, k = 0; i < in_len && k < out_len; i++) {\n\t\tch = le16_to_cpu(in_table[i]);\n\n\t\tif (ch == 0xFFFF && i + 1 < in_len) {\n\t\t\tuint16_t len = le16_to_cpu(in_table[++i]);\n\n\t\t\tk += len;\n\t\t} else {\n\t\t\tout_table[k++] = ch;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int read_upcase_table(struct exfat *exfat)\n{\n\tstruct exfat_lookup_filter filter = {\n\t\t.in.type\t= EXFAT_UPCASE,\n\t\t.in.filter\t= NULL,\n\t\t.in.param\t= NULL,\n\t};\n\tstruct exfat_dentry *dentry = NULL;\n\t__le16 *upcase = NULL;\n\tint retval;\n\tssize_t size;\n\t__le32 checksum;\n\n\tretval = exfat_lookup_dentry_set(exfat, exfat->root, &filter);\n\tif (retval)\n\t\treturn retval;\n\n\tdentry = filter.out.dentry_set;\n\n\tif (!exfat_heap_clus(exfat, le32_to_cpu(dentry->upcase_start_clu))) {\n\t\texfat_err(\"invalid start cluster of upcase table. 0x%x\\n\",\n\t\t\tle32_to_cpu(dentry->upcase_start_clu));\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsize = (ssize_t)le64_to_cpu(dentry->upcase_size);\n\tif (size > (ssize_t)(EXFAT_MAX_UPCASE_CHARS * sizeof(__le16)) ||\n\t\t\tsize == 0 || size % sizeof(__le16)) {\n\t\texfat_err(\"invalid size of upcase table. 0x%\" PRIx64 \"\\n\",\n\t\t\tle64_to_cpu(dentry->upcase_size));\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tupcase = (__le16 *)malloc(size);\n\tif (!upcase) {\n\t\texfat_err(\"failed to allocate upcase table\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (exfat_read(exfat->blk_dev->dev_fd, upcase, size,\n\t\t\texfat_c2o(exfat,\n\t\t\tle32_to_cpu(dentry->upcase_start_clu))) != size) {\n\t\texfat_err(\"failed to read upcase table\\n\");\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\tchecksum = 0;\n\tboot_calc_checksum((unsigned char *)upcase, size, false, &checksum);\n\tif (le32_to_cpu(dentry->upcase_checksum) != checksum) {\n\t\texfat_err(\"corrupted upcase table %#x (expected: %#x)\\n\",\n\t\t\tchecksum, le32_to_cpu(dentry->upcase_checksum));\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\texfat_bitmap_set_range(exfat, exfat->alloc_bitmap,\n\t\t\t       le32_to_cpu(dentry->upcase_start_clu),\n\t\t\t       DIV_ROUND_UP(le64_to_cpu(dentry->upcase_size),\n\t\t\t\t\t    exfat->clus_size));\n\n\texfat->upcase_table = calloc(1,\n\t\t\t\t     sizeof(uint16_t) * EXFAT_UPCASE_TABLE_CHARS);\n\tif (!exfat->upcase_table) {\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\tdecompress_upcase_table(upcase, size / 2,\n\t\t\t\texfat->upcase_table, EXFAT_UPCASE_TABLE_CHARS);\nout:\n\tif (dentry)\n\t\tfree(dentry);\n\tif (upcase)\n\t\tfree(upcase);\n\treturn retval;\n}\n\nstatic int read_children(struct exfat_fsck *fsck, struct exfat_inode *dir)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tstruct exfat_inode *node = NULL;\n\tstruct exfat_dentry *dentry;\n\tstruct exfat_de_iter *de_iter;\n\tint dentry_count;\n\tint ret;\n\n\tde_iter = &fsck->de_iter;\n\tret = exfat_de_iter_init(de_iter, exfat, dir, fsck->buffer_desc);\n\tif (ret == EOF)\n\t\treturn 0;\n\telse if (ret)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tret = exfat_de_iter_get(de_iter, 0, &dentry);\n\t\tif (ret == EOF) {\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tfsck_err(dir->parent, dir,\n\t\t\t\t\"failed to get a dentry. %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tdentry_count = 1;\n\n\t\tswitch (dentry->type) {\n\t\tcase EXFAT_FILE:\n\t\t\tret = read_file(de_iter, &node, &dentry_count);\n\t\t\tif (ret < 0) {\n\t\t\t\texfat_stat.error_count++;\n\t\t\t\tbreak;\n\t\t\t} else if (ret) {\n\t\t\t\texfat_stat.error_count++;\n\t\t\t\texfat_stat.fixed_count++;\n\t\t\t}\n\n\t\t\tif (node) {\n\t\t\t\tif ((node->attr & ATTR_SUBDIR) && node->size) {\n\t\t\t\t\tnode->parent = dir;\n\t\t\t\t\tlist_add_tail(&node->sibling,\n\t\t\t\t\t\t      &dir->children);\n\t\t\t\t\tlist_add_tail(&node->list,\n\t\t\t\t\t\t      &exfat->dir_list);\n\t\t\t\t} else {\n\t\t\t\t\texfat_free_inode(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EXFAT_LAST:\n\t\t\tgoto out;\n\t\tcase EXFAT_VOLUME:\n\t\tcase EXFAT_BITMAP:\n\t\tcase EXFAT_UPCASE:\n\t\t\tif (dir == exfat->root)\n\t\t\t\tbreak;\n\t\t\t/* fallthrough */\n\t\tdefault:\n\t\t\tif (IS_EXFAT_DELETED(dentry->type))\n\t\t\t\tbreak;\n\t\t\tif (repair_file_ask(de_iter, NULL, ER_DE_UNKNOWN,\n\t\t\t\t\t    \"unknown entry type %#x at %07\" PRIx64,\n\t\t\t\t\t    dentry->type,\n\t\t\t\t\t    exfat_de_iter_file_offset(de_iter))) {\n\t\t\t\tstruct exfat_dentry *dentry;\n\n\t\t\t\texfat_de_iter_get_dirty(de_iter, 0, &dentry);\n\t\t\t\tdentry->type &= EXFAT_DELETE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\texfat_de_iter_advance(de_iter, dentry_count);\n\t}\nout:\n\texfat_de_iter_flush(de_iter);\n\treturn 0;\nerr:\n\texfat_free_children(dir, false);\n\tINIT_LIST_HEAD(&dir->children);\n\texfat_de_iter_flush(de_iter);\n\treturn ret;\n}\n\n/* write bitmap segments for clusters which are marked\n * as free, but allocated to files.\n */\nstatic int write_bitmap(struct exfat_fsck *fsck)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tbitmap_t *disk_b, *alloc_b, *ohead_b;\n\toff_t dev_offset;\n\tunsigned int i, bitmap_bytes, byte_offset, write_bytes;\n\n\tdev_offset = exfat_c2o(exfat, exfat->disk_bitmap_clus);\n\tbitmap_bytes = EXFAT_BITMAP_SIZE(le32_to_cpu(exfat->bs->bsx.clu_count));\n\n\tdisk_b = (bitmap_t *)exfat->disk_bitmap;\n\talloc_b = (bitmap_t *)exfat->alloc_bitmap;\n\tohead_b = (bitmap_t *)exfat->ohead_bitmap;\n\n\tfor (i = 0; i < bitmap_bytes / sizeof(bitmap_t); i++)\n\t\tohead_b[i] = alloc_b[i] | disk_b[i];\n\n\ti = 0;\n\twhile (i < bitmap_bytes / sizeof(bitmap_t)) {\n\t\tif (ohead_b[i] == disk_b[i]) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbyte_offset = ((i * sizeof(bitmap_t)) / 512) * 512;\n\t\twrite_bytes = MIN(512, bitmap_bytes - byte_offset);\n\n\t\tif (exfat_write(exfat->blk_dev->dev_fd,\n\t\t\t\t(char *)ohead_b + byte_offset, write_bytes,\n\t\t\t\tdev_offset + byte_offset) != (ssize_t)write_bytes)\n\t\t\treturn -EIO;\n\n\t\ti = (byte_offset + write_bytes) / sizeof(bitmap_t);\n\t}\n\treturn 0;\n\n}\n\n/*\n * for each directory in @dir_list.\n * 1. read all dentries and allocate exfat_nodes for files and directories.\n *    and append directory exfat_nodes to the head of @dir_list\n * 2. free all of file exfat_nodes.\n * 3. if the directory does not have children, free its exfat_node.\n */\nstatic int exfat_filesystem_check(struct exfat_fsck *fsck)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tstruct exfat_inode *dir;\n\tint ret = 0, dir_errors;\n\n\tif (!exfat->root) {\n\t\texfat_err(\"root is NULL\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tlist_add(&exfat->root->list, &exfat->dir_list);\n\n\twhile (!list_empty(&exfat->dir_list)) {\n\t\tdir = list_entry(exfat->dir_list.next,\n\t\t\t\t struct exfat_inode, list);\n\n\t\tif (!(dir->attr & ATTR_SUBDIR)) {\n\t\t\tfsck_err(dir->parent, dir,\n\t\t\t\t\"failed to travel directories. \"\n\t\t\t\t\"the node is not directory\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdir_errors = read_children(fsck, dir);\n\t\tif (dir_errors) {\n\t\t\texfat_resolve_path(&path_resolve_ctx, dir);\n\t\t\texfat_debug(\"failed to check dentries: %s\\n\",\n\t\t\t\t\tpath_resolve_ctx.local_path);\n\t\t\tret = dir_errors;\n\t\t}\n\n\t\tlist_del(&dir->list);\n\t\texfat_free_file_children(dir);\n\t\texfat_free_ancestors(dir);\n\t}\nout:\n\texfat_free_dir_list(exfat);\n\treturn ret;\n}\n\nstatic int exfat_root_dir_check(struct exfat *exfat)\n{\n\tstruct exfat_inode *root;\n\tclus_t clus_count = 0;\n\tint err;\n\n\troot = exfat_alloc_inode(ATTR_SUBDIR);\n\tif (!root)\n\t\treturn -ENOMEM;\n\n\texfat->root = root;\n\troot->first_clus = le32_to_cpu(exfat->bs->bsx.root_cluster);\n\tif (root_check_clus_chain(exfat, root, &clus_count)) {\n\t\texfat_err(\"failed to follow the cluster chain of root\\n\");\n\t\texfat_free_inode(root);\n\t\texfat->root = NULL;\n\t\treturn -EINVAL;\n\t}\n\troot->size = clus_count * exfat->clus_size;\n\n\texfat_stat.dir_count++;\n\texfat_debug(\"root directory: start cluster[0x%x] size[0x%\" PRIx64 \"]\\n\",\n\t\troot->first_clus, root->size);\n\n\terr = exfat_read_volume_label(exfat);\n\tif (err && err != EOF)\n\t\texfat_err(\"failed to read volume label\\n\");\n\terr = 0;\n\n\terr = read_bitmap(exfat);\n\tif (err) {\n\t\texfat_err(\"failed to read bitmap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = read_upcase_table(exfat);\n\tif (err) {\n\t\texfat_err(\"failed to read upcase table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\troot->dev_offset = 0;\n\terr = exfat_build_file_dentry_set(exfat, \" \", ATTR_SUBDIR,\n\t\t\t\t\t  &root->dentry_set, &root->dentry_count);\n\tif (err) {\n\t\texfat_free_inode(root);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int read_lostfound(struct exfat *exfat, struct exfat_inode **lostfound)\n{\n\tstruct exfat_lookup_filter filter;\n\tstruct exfat_inode *inode;\n\tint err;\n\n\terr = exfat_lookup_file(exfat, exfat->root, \"LOST+FOUND\", &filter);\n\tif (err)\n\t\treturn err;\n\n\tinode = exfat_alloc_inode(ATTR_SUBDIR);\n\tif (!inode) {\n\t\tfree(filter.out.dentry_set);\n\t\treturn -ENOMEM;\n\t}\n\n\tinode->dentry_set = filter.out.dentry_set;\n\tinode->dentry_count = filter.out.dentry_count;\n\tinode->dev_offset = filter.out.dev_offset;\n\n\tinode->first_clus =\n\t\tle32_to_cpu(filter.out.dentry_set[1].dentry.stream.start_clu);\n\tinode->size =\n\t\tle64_to_cpu(filter.out.dentry_set[1].dentry.stream.size);\n\n\t*lostfound = inode;\n\treturn 0;\n}\n\n/* Create temporary files under LOST+FOUND and assign orphan\n * chains of clusters to these files.\n */\nstatic int rescue_orphan_clusters(struct exfat_fsck *fsck)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tstruct exfat_inode *lostfound;\n\tbitmap_t *disk_b, *alloc_b, *ohead_b;\n\tstruct exfat_dentry *dset;\n\tclus_t clu_count, clu, s_clu, e_clu;\n\tint err, dcount;\n\tunsigned int i;\n\tchar name[] = \"FILE0000000.CHK\";\n\tstruct exfat_dentry_loc loc;\n\tstruct exfat_lookup_filter lf = {\n\t\t.in.type = EXFAT_INVAL,\n\t\t.in.filter = NULL,\n\t};\n\n\terr = read_lostfound(exfat, &lostfound);\n\tif (err) {\n\t\texfat_err(\"failed to find LOST+FOUND\\n\");\n\t\treturn err;\n\t}\n\n\t/* get the last empty region of LOST+FOUND */\n\terr = exfat_lookup_dentry_set(exfat, lostfound, &lf);\n\tif (err && err != EOF) {\n\t\texfat_err(\"failed to find the last empty slot in LOST+FOUND\\n\");\n\t\tgoto out;\n\t}\n\n\tloc.parent = lostfound;\n\tloc.file_offset = lf.out.file_offset;\n\tloc.dev_offset = lf.out.dev_offset;\n\n\t/* build a template dentry set */\n\terr = exfat_build_file_dentry_set(exfat, name, 0, &dset, &dcount);\n\tif (err) {\n\t\texfat_err(\"failed to create a temporary file in LOST+FOUNDn\");\n\t\tgoto out;\n\t}\n\tdset[1].dentry.stream.flags |= EXFAT_SF_CONTIGUOUS;\n\n\tclu_count = le32_to_cpu(exfat->bs->bsx.clu_count);\n\n\t/* find clusters which are not marked as free, but not allocated to\n\t * any files.\n\t */\n\tdisk_b = (bitmap_t *)exfat->disk_bitmap;\n\talloc_b = (bitmap_t *)exfat->alloc_bitmap;\n\tohead_b = (bitmap_t *)exfat->ohead_bitmap;\n\tfor (i = 0; i < EXFAT_BITMAP_SIZE(clu_count) / sizeof(bitmap_t); i++)\n\t\tohead_b[i] = disk_b[i] & ~alloc_b[i];\n\n\t/* create temporary files and allocate contiguous orphan clusters\n\t * to each file.\n\t */\n\tfor (clu = EXFAT_FIRST_CLUSTER; clu < clu_count + EXFAT_FIRST_CLUSTER &&\n\t     exfat_bitmap_find_one(exfat, exfat->ohead_bitmap, clu, &s_clu) == 0;) {\n\t\tif (exfat_bitmap_find_zero(exfat, exfat->ohead_bitmap, s_clu, &e_clu))\n\t\t\te_clu = clu_count + EXFAT_FIRST_CLUSTER;\n\t\tclu = e_clu;\n\n\t\tsnprintf(name, sizeof(name), \"FILE%07d.CHK\",\n\t\t\t (unsigned int)(loc.file_offset >> 5));\n\t\terr = exfat_update_file_dentry_set(exfat, dset, dcount,\n\t\t\t\t\t\t   name, s_clu, e_clu - s_clu);\n\t\tif (err)\n\t\t\tcontinue;\n\t\terr = exfat_add_dentry_set(exfat, &loc, dset, dcount, true);\n\t\tif (err)\n\t\t\tcontinue;\n\t}\n\n\tfree(dset);\n\terr = 0;\nout:\n\texfat_free_inode(lostfound);\n\treturn err;\n}\n\nstatic char *bytes_to_human_readable(size_t bytes)\n{\n\tstatic const char * const units[] = {\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\"};\n\tstatic char buf[15*4];\n\tunsigned int i, shift, quoti, remain;\n\ti = sizeof(units) / sizeof(units[0]) - 1;\n\n\twhile (i && (bytes >> i * 10) == 0)\n\t\ti--;\n\n\tshift = i * 10;\n\tquoti = (unsigned int)(bytes / (1ULL << shift));\n\tremain = 0;\n\tif (shift > 0) {\n\t\tremain = (unsigned int)\n\t\t\t((bytes & ((1ULL << shift) - 1)) >> (shift - 10));\n\t\tremain = (remain * 100) / 1024;\n\t}\n\n\tsnprintf(buf, sizeof(buf), \"%u.%02u %s\", quoti, remain, units[i]);\n\treturn buf;\n}\n\nstatic void exfat_show_info(struct exfat_fsck *fsck, const char *dev_name)\n{\n\tstruct exfat *exfat = fsck->exfat;\n\tbool clean;\n\n\texfat_info(\"sector size:  %s\\n\",\n\t\tbytes_to_human_readable(1 << exfat->bs->bsx.sect_size_bits));\n\texfat_info(\"cluster size: %s\\n\",\n\t\tbytes_to_human_readable(exfat->clus_size));\n\texfat_info(\"volume size:  %s\\n\",\n\t\tbytes_to_human_readable(exfat->blk_dev->size));\n\n\tclean = exfat_stat.error_count == 0 ||\n\t\texfat_stat.error_count == exfat_stat.fixed_count;\n\tprintf(\"%s: %s. directories %ld, files %ld\\n\", dev_name,\n\t\t\tclean ? \"clean\" : \"corrupted\",\n\t\t\texfat_stat.dir_count, exfat_stat.file_count);\n\tif (exfat_stat.error_count)\n\t\tprintf(\"%s: files corrupted %ld, files fixed %ld\\n\", dev_name,\n\t\t\texfat_stat.error_count - exfat_stat.fixed_count,\n\t\t\texfat_stat.fixed_count);\n}\n\nint main(int argc, char * const argv[])\n{\n\tstruct fsck_user_input ui;\n\tstruct exfat_blk_dev bd;\n\tstruct pbr *bs = NULL;\n\tint c, ret, exit_code;\n\tbool version_only = false;\n\n\tmemset(&ui, 0, sizeof(ui));\n\tmemset(&bd, 0, sizeof(bd));\n\n\tprint_level = EXFAT_ERROR;\n\n\tif (!setlocale(LC_CTYPE, \"\"))\n\t\texfat_err(\"failed to init locale/codeset\\n\");\n\n\topterr = 0;\n\twhile ((c = getopt_long(argc, argv, \"arynpbsVvh\", opts, NULL)) != EOF) {\n\t\tswitch (c) {\n\t\tcase 'n':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_NO;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_ASK;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_YES;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'p':\n\t\t\tif (ui.options & FSCK_OPTS_REPAIR_ALL)\n\t\t\t\tusage(argv[0]);\n\t\t\tui.options |= FSCK_OPTS_REPAIR_AUTO;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tui.options |= FSCK_OPTS_IGNORE_BAD_FS_NAME;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tui.options |= FSCK_OPTS_RESCUE_CLUS;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tversion_only = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tif (print_level < EXFAT_DEBUG)\n\t\t\t\tprint_level++;\n\t\t\tbreak;\n\t\tcase '?':\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t}\n\t}\n\n\tshow_version();\n\tif (optind != argc - 1)\n\t\tusage(argv[0]);\n\n\tif (version_only)\n\t\texit(FSCK_EXIT_SYNTAX_ERROR);\n\tif (ui.options & FSCK_OPTS_REPAIR_WRITE)\n\t\tui.ei.writeable = true;\n\telse {\n\t\tif (ui.options & (FSCK_OPTS_IGNORE_BAD_FS_NAME |\n\t\t\t\t  FSCK_OPTS_RESCUE_CLUS))\n\t\t\tusage(argv[0]);\n\t\tui.options |= FSCK_OPTS_REPAIR_NO;\n\t\tui.ei.writeable = false;\n\t}\n\n\texfat_fsck.options = ui.options;\n\n\tsnprintf(ui.ei.dev_name, sizeof(ui.ei.dev_name), \"%s\", argv[optind]);\n\tret = exfat_get_blk_dev_info(&ui.ei, &bd);\n\tif (ret < 0) {\n\t\texfat_err(\"failed to open %s. %d\\n\", ui.ei.dev_name, ret);\n\t\treturn FSCK_EXIT_OPERATION_ERROR;\n\t}\n\n\tret = exfat_boot_region_check(&bd, &bs,\n\t\t\t\t      ui.options & FSCK_OPTS_IGNORE_BAD_FS_NAME ?\n\t\t\t\t      true : false);\n\tif (ret)\n\t\tgoto err;\n\n\texfat_fsck.exfat = exfat_alloc_exfat(&bd, bs);\n\tif (!exfat_fsck.exfat) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\texfat_fsck.buffer_desc = exfat_alloc_buffer(2,\n\t\t\t\t\t\t    exfat_fsck.exfat->clus_size,\n\t\t\t\t\t\t    exfat_fsck.exfat->sect_size);\n\tif (!exfat_fsck.buffer_desc) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tif ((exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE) &&\n\t    exfat_mark_volume_dirty(exfat_fsck.exfat, true)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\texfat_debug(\"verifying root directory...\\n\");\n\tret = exfat_root_dir_check(exfat_fsck.exfat);\n\tif (ret) {\n\t\texfat_err(\"failed to verify root directory.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (exfat_fsck.options & FSCK_OPTS_RESCUE_CLUS) {\n\t\tret = exfat_create_file(exfat_fsck.exfat,\n\t\t\t\t\texfat_fsck.exfat->root,\n\t\t\t\t\t\"LOST+FOUND\",\n\t\t\t\t\tATTR_SUBDIR);\n\t\tif (ret) {\n\t\t\texfat_err(\"failed to create lost+found directory\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fsync(exfat_fsck.exfat->blk_dev->dev_fd) != 0) {\n\t\t\tret = -EIO;\n\t\t\texfat_err(\"failed to sync()\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\texfat_debug(\"verifying directory entries...\\n\");\n\tret = exfat_filesystem_check(&exfat_fsck);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exfat_fsck.options & FSCK_OPTS_RESCUE_CLUS) {\n\t\trescue_orphan_clusters(&exfat_fsck);\n\t\texfat_fsck.dirty = true;\n\t\texfat_fsck.dirty_fat = true;\n\t}\n\n\tif (exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE) {\n\t\tret = write_bitmap(&exfat_fsck);\n\t\tif (ret) {\n\t\t\texfat_err(\"failed to write bitmap\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ui.ei.writeable && fsync(bd.dev_fd)) {\n\t\texfat_err(\"failed to sync\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE)\n\t\texfat_mark_volume_dirty(exfat_fsck.exfat, false);\n\nout:\n\texfat_show_info(&exfat_fsck, ui.ei.dev_name);\nerr:\n\tif (ret && ret != -EINVAL)\n\t\texit_code = FSCK_EXIT_OPERATION_ERROR;\n\telse if (ret == -EINVAL ||\n\t\t exfat_stat.error_count != exfat_stat.fixed_count)\n\t\texit_code = FSCK_EXIT_ERRORS_LEFT;\n\telse if (exfat_fsck.dirty)\n\t\texit_code = FSCK_EXIT_CORRECTED;\n\telse\n\t\texit_code = FSCK_EXIT_NO_ERRORS;\n\n\tif (exfat_fsck.buffer_desc)\n\t\texfat_free_buffer(exfat_fsck.buffer_desc, 2);\n\tif (exfat_fsck.exfat)\n\t\texfat_free_exfat(exfat_fsck.exfat);\n\tclose(bd.dev_fd);\n\treturn exit_code;\n}\n"], "filenames": ["fsck/fsck.c"], "buggy_code_start_loc": [814], "buggy_code_end_loc": [848], "fixing_code_start_loc": [814], "fixing_code_end_loc": [848], "type": "CWE-125", "message": "exfatprogs before 1.2.2 allows out-of-bounds memory access, such as in read_file_dentry_set.", "other": {"cve": {"id": "CVE-2023-45897", "sourceIdentifier": "cve@mitre.org", "published": "2023-10-28T21:15:07.577", "lastModified": "2023-11-21T16:33:02.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "exfatprogs before 1.2.2 allows out-of-bounds memory access, such as in read_file_dentry_set."}, {"lang": "es", "value": "exfatprogs anteriores a 1.2.2 permiten el acceso a la memoria fuera de los l\u00edmites, como en read_file_dentry_set."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:namjaejeon:exfatprogs:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.2", "matchCriteriaId": "43240CAA-AAC1-4A9B-926C-F1AFAB7E47EB"}]}]}], "references": [{"url": "https://dfir.ru/2023/11/01/cve-2023-45897-a-vulnerability-in-the-linux-exfat-userspace-tools/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/exfatprogs/exfatprogs/commit/22d0e43e8d24119cbfc6efafabb0dec6517a86c4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/exfatprogs/exfatprogs/commit/4abc55e976573991e6a1117bb2b3711e59da07ae", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/exfatprogs/exfatprogs/commit/ec78688e5fb5a70e13df82b4c0da1e6228d3ccdf", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/exfatprogs/exfatprogs/releases/tag/1.2.2", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/exfatprogs/exfatprogs/commit/22d0e43e8d24119cbfc6efafabb0dec6517a86c4"}}