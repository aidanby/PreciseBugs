{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * I/O Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n/* The configuration header file should be included first. */\n#include \"jasper/jas_config.h\"\n\n#include <assert.h>\n#if defined(JAS_HAVE_FCNTL_H)\n#include <fcntl.h>\n#endif\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#if defined(JAS_HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n#if defined(WIN32) || defined(JAS_HAVE_IO_H)\n#include <io.h>\n#endif\n\n#include \"jasper/jas_debug.h\"\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s);\nstatic void jas_stream_destroy(jas_stream_t *stream);\nstatic jas_stream_t *jas_stream_create(void);\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize);\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int mem_close(jas_stream_obj_t *obj);\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int sfile_close(jas_stream_obj_t *obj);\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int file_close(jas_stream_obj_t *obj);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\nstatic jas_stream_ops_t jas_stream_fileops = {\n\tfile_read,\n\tfile_write,\n\tfile_seek,\n\tfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_sfileops = {\n\tsfile_read,\n\tsfile_write,\n\tsfile_seek,\n\tsfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_memops = {\n\tmem_read,\n\tmem_write,\n\tmem_seek,\n\tmem_close\n};\n\n/******************************************************************************\\\n* Code for opening and closing streams.\n\\******************************************************************************/\n\nstatic jas_stream_t *jas_stream_create()\n{\n\tjas_stream_t *stream;\n\n\tif (!(stream = jas_malloc(sizeof(jas_stream_t)))) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = 0;\n\tstream->bufmode_ = 0;\n\tstream->flags_ = 0;\n\tstream->bufbase_ = 0;\n\tstream->bufstart_ = 0;\n\tstream->bufsize_ = 0;\n\tstream->ptr_ = 0;\n\tstream->cnt_ = 0;\n\tstream->ops_ = 0;\n\tstream->obj_ = 0;\n\tstream->rwcnt_ = 0;\n\tstream->rwlimit_ = -1;\n\n\treturn stream;\n}\n\n#if 0\n\n/* Obsolete code. */\n\njas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (bufsize <= 0) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = (unsigned char *) buf;\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n\n#else\n\n/*\nThis function will eventually replace jas_stream_memopen.\nIf buf is 0 and bufsize > 0:\n\ta buffer is dynamically allocated with size bufsize and this buffer is\n\tnot growable.\nIf buf is 0 and bufsize is 0:\n\ta buffer is dynamically allocated whose size will automatically grow to\n\taccommodate the amount of data written.\nIf buf is not 0:\n\tbufsize (which, in this case, is not currently allowed to be zero) is\n\tthe size of the (nongrowable) buffer pointed to by buf.\n*/\n\njas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\n\tassert((buf && bufsize > 0) || (!buf));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n\n/*\nNOTE:\nThe version of the function jas_stream_memopen only exists for backwards\ncompatibility.\nEventually, it should be replaced by jas_stream_memopen2.\nIn retrospect, it was a very poor choice to have specified the buffer\nsize parameter (bufsize) to have type int.  On some machines, int may only\nbe a 16-bit integer.  This precludes larger-sized buffer allocations, which\nare needed in practice.\n\nIf bufsize <= 0, the buffer is growable; otherwise, the buffer has a fixed\nsize of bufsize.\nIf buf is 0, the buffer is dynamically allocated with jas_malloc.\nIf buf is not 0 and bufsize <= 0 (which is not permitted in any\ncircumstances), bad things will happen (especially if the buf was not\nallocated with jas_malloc).\n*/\njas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\t// This was never a valid thing to do with the old API.\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}\n\n#endif\n\njas_stream_t *jas_stream_fopen(const char *filename, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\tint openflags;\n\n\tJAS_DBGLOG(100, (\"jas_stream_fopen(\\\"%s\\\", \\\"%s\\\")\\n\", filename, mode));\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {\n\t\t// Free the underlying file object, since it will not otherwise\n\t\t// be freed.\n\t\tjas_free(obj);\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_freopen(const char *path, const char *mode, FILE *fp)\n{\n\tjas_stream_t *stream;\n\tint openflags;\n\n\tJAS_DBGLOG(100, (\"jas_stream_freopen(\\\"%s\\\", \\\"%s\\\", %p)\\n\", path, mode,\n\t  fp));\n\n\t/* Eliminate compiler warning about unused variable. */\n\tpath = 0;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\tstream->obj_ = JAS_CAST(void *, fp);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_sfileops;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_tmpfile()\\n\"));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_fdopen(int fd, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_fdopen(%d, \\\"%s\\\")\\n\", fd, mode));\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n#if defined(WIN32)\n\t/* Argh!!!  Someone ought to banish text mode (i.e., O_TEXT) to the\n\t  greatest depths of purgatory! */\n\t/* Ensure that the file descriptor is in binary mode, if the caller\n\t  has specified the binary mode flag.  Arguably, the caller ought to\n\t  take care of this, but text mode is a ugly wart anyways, so we save\n\t  the caller some grief by handling this within the stream library. */\n\t/* This ugliness is mainly for the benefit of those who run the\n\t  JasPer software under Windows from shells that insist on opening\n\t  files in text mode.  For example, in the Cygwin environment,\n\t  shells often open files in text mode when I/O redirection is\n\t  used.  Grr... */\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\tsetmode(fd, O_BINARY);\n\t}\n#endif\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = fd;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Do not close the underlying file descriptor when the stream is\n\tclosed. */\n\tobj->flags |= JAS_STREAM_FILEOBJ_NOCLOSE;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\nstatic void jas_stream_destroy(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_destroy(%p)\\n\", stream));\n\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tJAS_DBGLOG(100, (\"jas_stream_destroy freeing buffer %p\\n\",\n\t\t  stream->bufbase_));\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n\nint jas_stream_close(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_close(%p)\\n\", stream));\n\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for reading and writing streams.\n\\******************************************************************************/\n\nint jas_stream_getc_func(jas_stream_t *stream)\n{\n\tassert(stream->ptr_ - stream->bufbase_ <= stream->bufsize_ +\n\t  JAS_STREAM_MAXPUTBACK);\n\treturn jas_stream_getc_macro(stream);\n}\n\nint jas_stream_putc_func(jas_stream_t *stream, int c)\n{\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\treturn jas_stream_putc_macro(stream, c);\n}\n\nint jas_stream_ungetc(jas_stream_t *stream, int c)\n{\n\tif (!stream->ptr_ || stream->ptr_ == stream->bufbase_) {\n\t\treturn -1;\n\t}\n\n\t/* Reset the EOF indicator (since we now have at least one character\n\t  to read). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\t--stream->rwcnt_;\n\t--stream->ptr_;\n\t++stream->cnt_;\n\t*stream->ptr_ = c;\n\treturn 0;\n}\n\nint jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\n\tJAS_DBGLOG(100, (\"jas_stream_read(%p, %p, %d)\\n\", stream, buf, cnt));\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_read\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\nint jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tJAS_DBGLOG(100, (\"jas_stream_write(%p, %p, %d)\\n\", stream, buf, cnt));\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\n/* Note: This function uses a fixed size buffer.  Therefore, it cannot\n  handle invocations that will produce more output than can be held\n  by the buffer. */\nint jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(buf, sizeof buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}\n\nint jas_stream_puts(jas_stream_t *stream, const char *s)\n{\n\twhile (*s != '\\0') {\n\t\tif (jas_stream_putc_macro(stream, *s) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t++s;\n\t}\n\treturn 0;\n}\n\nchar *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n{\n\tint c;\n\tchar *bufptr;\n\tassert(bufsize > 0);\n\n\tJAS_DBGLOG(100, (\"jas_stream_gets(%p, %p, %d)\\n\", stream, buf, bufsize));\n\n\tbufptr = buf;\n\twhile (bufsize > 1) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t--bufsize;\n\t\tif (c == '\\n') {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufptr = '\\0';\n\treturn buf;\n}\n\nint jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\n\tJAS_DBGLOG(100, (\"jas_stream_gobble(%p, %d)\\n\", stream, n));\n\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}\n\nint jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\n\tJAS_DBGLOG(100, (\"jas_stream_pad(%p, %d, %d)\\n\", stream, n, c));\n\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_pad\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}\n\n/******************************************************************************\\\n* Code for getting and setting the stream position.\n\\******************************************************************************/\n\nint jas_stream_isseekable(jas_stream_t *stream)\n{\n\tif (stream->ops_ == &jas_stream_memops) {\n\t\treturn 1;\n\t} else if (stream->ops_ == &jas_stream_fileops) {\n\t\tif ((*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR) < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint jas_stream_rewind(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_rewind(%p)\\n\", stream));\n\treturn jas_stream_seek(stream, 0, SEEK_SET);\n}\n\nlong jas_stream_seek(jas_stream_t *stream, long offset, int origin)\n{\n\tlong newpos;\n\n\tJAS_DBGLOG(100, (\"jas_stream_seek(%p, %ld, %d)\\n\", stream, offset,\n\t  origin));\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n\nlong jas_stream_tell(jas_stream_t *stream)\n{\n\tint adjust;\n\tint offset;\n\n\tJAS_DBGLOG(100, (\"jas_stream_tell(%p)\\n\", stream));\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tadjust = -stream->cnt_;\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tadjust = stream->ptr_ - stream->bufstart_;\n\t} else {\n\t\tadjust = 0;\n\t}\n\n\tif ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn offset + adjust;\n}\n\n/******************************************************************************\\\n* Buffer initialization code.\n\\******************************************************************************/\n\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize)\n{\n\t/* If this function is being called, the buffer should not have been\n\t  initialized yet. */\n\tassert(!stream->bufbase_);\n\n\tif (bufmode != JAS_STREAM_UNBUF) {\n\t\t/* The full- or line-buffered mode is being employed. */\n\t\tif (!buf) {\n\t\t\t/* The caller has not specified a buffer to employ, so allocate\n\t\t\t  one. */\n\t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +\n\t\t\t  JAS_STREAM_MAXPUTBACK))) {\n\t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;\n\t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;\n\t\t\t} else {\n\t\t\t\t/* The buffer allocation has failed.  Resort to unbuffered\n\t\t\t\t  operation. */\n\t\t\t\tstream->bufbase_ = stream->tinybuf_;\n\t\t\t\tstream->bufsize_ = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* The caller has specified a buffer to employ. */\n\t\t\t/* The buffer must be large enough to accommodate maximum\n\t\t\t  putback. */\n\t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n\t\t\tstream->bufbase_ = JAS_CAST(jas_uchar *, buf);\n\t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n\t\t}\n\t} else {\n\t\t/* The unbuffered mode is being employed. */\n\t\t/* A buffer should not have been supplied by the caller. */\n\t\tassert(!buf);\n\t\t/* Use a trivial one-character buffer. */\n\t\tstream->bufbase_ = stream->tinybuf_;\n\t\tstream->bufsize_ = 1;\n\t}\n\tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];\n\tstream->ptr_ = stream->bufstart_;\n\tstream->cnt_ = 0;\n\tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;\n}\n\n/******************************************************************************\\\n* Buffer filling and flushing code.\n\\******************************************************************************/\n\nint jas_stream_flush(jas_stream_t *stream)\n{\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\treturn 0;\n\t}\n\treturn jas_stream_flushbuf(stream, EOF);\n}\n\nint jas_stream_fillbuf(jas_stream_t *stream, int getflag)\n{\n\tint c;\n\n\t/* The stream must not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for reading. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* Make a half-hearted attempt to confirm that the buffer is not\n\tcurrently being used for writing.  This check is not intended\n\tto be foolproof! */\n\tassert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);\n\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\n\t/* Mark the buffer as being used for reading. */\n\tstream->bufmode_ |= JAS_STREAM_RDBUF;\n\n\t/* Read new data into the buffer. */\n\tstream->ptr_ = stream->bufstart_;\n\tif ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,\n\t  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {\n\t\tif (stream->cnt_ < 0) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t} else {\n\t\t\tstream->flags_ |= JAS_STREAM_EOF;\n\t\t}\n\t\tstream->cnt_ = 0;\n\t\treturn EOF;\n\t}\n\n\tassert(stream->cnt_ > 0);\n\t/* Get or peek at the first character in the buffer. */\n\tc = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);\n\n\treturn c;\n}\n\nint jas_stream_flushbuf(jas_stream_t *stream, int c)\n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s)\n{\n\tint openmode = 0;\n\twhile (*s != '\\0') {\n\t\tswitch (*s) {\n\t\tcase 'r':\n\t\t\topenmode |= JAS_STREAM_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\topenmode |= JAS_STREAM_WRITE | JAS_STREAM_CREATE;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\topenmode |= JAS_STREAM_BINARY;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\topenmode |= JAS_STREAM_APPEND;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\topenmode |= JAS_STREAM_READ | JAS_STREAM_WRITE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t++s;\n\t}\n\treturn openmode;\n}\n\nint jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n{\n\tint all;\n\tint c;\n\tint m;\n\n\tall = (n < 0) ? 1 : 0;\n\n\tm = n;\n\twhile (all || m > 0) {\n\t\tif ((c = jas_stream_getc_macro(in)) == EOF) {\n\t\t\t/* The next character of input could not be read. */\n\t\t\t/* Return with an error if an I/O error occured\n\t\t\t  (not including EOF) or if an explicit copy count\n\t\t\t  was specified. */\n\t\t\treturn (!all || jas_stream_error(in)) ? (-1) : 0;\n\t\t}\n\t\tif (jas_stream_putc_macro(out, c) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t--m;\n\t}\n\treturn 0;\n}\n\nlong jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n{\n\tint old;\n\n\told = stream->rwcnt_;\n\tstream->rwcnt_ = rwcnt;\n\treturn old;\n}\n\nint jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n{\n\tunsigned char buf[16];\n\tint i;\n\tint j;\n\tint m;\n\tint c;\n\tint display;\n\tint cnt;\n\n\tcnt = n - (n % 16);\n\tdisplay = 1;\n\n\tfor (i = 0; i < n; i += 16) {\n\t\tif (n > 16 && i > 0) {\n\t\t\tdisplay = (i >= cnt) ? 1 : 0;\n\t\t}\n\t\tif (display) {\n\t\t\tfprintf(fp, \"%08x:\", i);\n\t\t}\n\t\tm = JAS_MIN(n - i, 16);\n\t\tfor (j = 0; j < m; ++j) {\n\t\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\t\tabort();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbuf[j] = c;\n\t\t}\n\t\tif (display) {\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tfprintf(fp, \" %02x\", buf[j]);\n\t\t\t}\n\t\t\tfputc(' ', fp);\n\t\t\tfor (; j < 16; ++j) {\n\t\t\t\tfprintf(fp, \"   \");\n\t\t\t}\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tif (isprint(buf[j])) {\n\t\t\t\t\tfputc(buf[j], fp);\n\t\t\t\t} else {\n\t\t\t\t\tfputc(' ', fp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(fp, \"\\n\");\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\nlong jas_stream_length(jas_stream_t *stream)\n{\n\tlong oldpos;\n\tlong pos;\n\tif ((oldpos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, 0, SEEK_END) < 0) {\n\t\treturn -1;\n\t}\n\tif ((pos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, oldpos, SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn pos;\n}\n\n/******************************************************************************\\\n* Memory stream object.\n\\******************************************************************************/\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tssize_t n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}\n\nstatic int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n{\n\tunsigned char *buf;\n\n\t//assert(m->buf_);\n\t//assert(bufsize >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %zu)\\n\", m, bufsize));\n\tif (!bufsize) {\n\t\tjas_eprintf(\n\t\t  \"mem_resize was not really designed to handle a buffer of size 0\\n\"\n\t\t  \"This may not work.\\n\"\n\t\t);\n\t}\n\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tsize_t n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newbufsize;\n\tsize_t newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\t//newbufsize <<= 1;\n\t\t\tif (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {\n\t\t\t\tJAS_DBGLOG(100, (\"new buffer size would cause overflow\\n\"));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %zu\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tassert(newbufsize > 0);\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t/* The current position is beyond the end of the file, so\n\t\t  pad the file to the current position with zeros. */\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t/* The buffer is not big enough. */\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}\n\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newpos;\n\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\n\treturn m->pos_;\n}\n\nstatic int mem_close(jas_stream_obj_t *obj)\n{\n\tJAS_DBGLOG(100, (\"mem_close(%p)\\n\", obj));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tJAS_DBGLOG(100, (\"mem_close myalloc=%d\\n\", m->myalloc_));\n\tif (m->myalloc_ && m->buf_) {\n\t\tJAS_DBGLOG(100, (\"mem_close freeing buffer %p\\n\", m->buf_));\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File stream object.\n\\******************************************************************************/\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn read(fileobj->fd, buf, cnt);\n}\n\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn write(fileobj->fd, buf, cnt);\n}\n\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn lseek(fileobj->fd, offset, origin);\n}\n\nstatic int file_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_close(%p)\\n\", obj));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\tint ret;\n\tret = close(fileobj->fd);\n\tif (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) {\n\t\tunlink(fileobj->pathname);\n\t}\n\tjas_free(fileobj);\n\treturn ret;\n}\n\n/******************************************************************************\\\n* Stdio file stream object.\n\\******************************************************************************/\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tsize_t n;\n\tint result;\n\tJAS_DBGLOG(100, (\"sfile_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfp = JAS_CAST(FILE *, obj);\n\tn = fread(buf, 1, cnt, fp);\n\tif (n != cnt) {\n\t\tresult = (!ferror(fp) && feof(fp)) ? 0 : -1;\n\t}\n\tresult = JAS_CAST(int, n);\n\treturn result;\n}\n\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tsize_t n;\n\tJAS_DBGLOG(100, (\"sfile_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfp = JAS_CAST(FILE *, obj);\n\tn = fwrite(buf, 1, cnt, fp);\n\treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n}\n\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tFILE *fp;\n\tJAS_DBGLOG(100, (\"sfile_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fseek(fp, offset, origin);\n}\n\nstatic int sfile_close(jas_stream_obj_t *obj)\n{\n\tFILE *fp;\n\tJAS_DBGLOG(100, (\"sfile_close(%p)\\n\", obj));\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fclose(fp);\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JP2 Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#include <stdlib.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jp2_cod.h\"\n\n/******************************************************************************\\\n* Function prototypes.\n\\******************************************************************************/\n\n#define\tONES(n)\t((1 << (n)) - 1)\n\njp2_boxinfo_t *jp2_boxinfolookup(int type);\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val);\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val);\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val);\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val);\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val);\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val);\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val);\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val);\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val);\n\njp2_box_t *jp2_box_get(jas_stream_t *in);\nvoid jp2_box_dump(jp2_box_t *box, FILE *out);\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_bpcc_destroy(jp2_box_t *box);\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_colr_destroy(jp2_box_t *box);\nstatic void jp2_cdef_destroy(jp2_box_t *box);\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_cmap_destroy(jp2_box_t *box);\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_pclr_destroy(jp2_box_t *box);\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\njp2_boxinfo_t jp2_boxinfos[] = {\n\t{JP2_BOX_JP, \"JP\", 0,\n\t  {0, 0, jp2_jp_getdata, jp2_jp_putdata, 0}},\n\t{JP2_BOX_FTYP, \"FTYP\", 0,\n\t  {0, 0, jp2_ftyp_getdata, jp2_ftyp_putdata, 0}},\n\t{JP2_BOX_JP2H, \"JP2H\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_IHDR, \"IHDR\", 0,\n\t  {0, 0, jp2_ihdr_getdata, jp2_ihdr_putdata, 0}},\n\t{JP2_BOX_BPCC, \"BPCC\", 0,\n\t  {0, jp2_bpcc_destroy, jp2_bpcc_getdata, jp2_bpcc_putdata, 0}},\n\t{JP2_BOX_COLR, \"COLR\", 0,\n\t  {0, jp2_colr_destroy, jp2_colr_getdata, jp2_colr_putdata, jp2_colr_dumpdata}},\n\t{JP2_BOX_PCLR, \"PCLR\", 0,\n\t  {0, jp2_pclr_destroy, jp2_pclr_getdata, jp2_pclr_putdata, jp2_pclr_dumpdata}},\n\t{JP2_BOX_CMAP, \"CMAP\", 0,\n\t  {0, jp2_cmap_destroy, jp2_cmap_getdata, jp2_cmap_putdata, jp2_cmap_dumpdata}},\n\t{JP2_BOX_CDEF, \"CDEF\", 0,\n\t  {0, jp2_cdef_destroy, jp2_cdef_getdata, jp2_cdef_putdata, jp2_cdef_dumpdata}},\n\t{JP2_BOX_RES, \"RES\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESC, \"RESC\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESD, \"RESD\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2C, \"JP2C\", JP2_BOX_NODATA,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2I, \"JP2I\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_XML, \"XML\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UUID, \"UUID\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UINF, \"UINF\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_ULST, \"ULST\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_URL, \"URL\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{0, 0, 0, {0, 0, 0, 0, 0}},\n};\n\njp2_boxinfo_t jp2_boxinfo_unk = {\n\t0, \"Unknown\", 0, {0, 0, 0, 0, 0}\n};\n\n/******************************************************************************\\\n* Box constructor.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}\n\n/******************************************************************************\\\n* Box destructor.\n\\******************************************************************************/\n\nvoid jp2_box_destroy(jp2_box_t *box)\n{\n\tif (box->ops->destroy) {\n\t\t(*box->ops->destroy)(box);\n\t}\n\tjas_free(box);\n}\n\nstatic void jp2_bpcc_destroy(jp2_box_t *box)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tif (bpcc->bpcs) {\n\t\tjas_free(bpcc->bpcs);\n\t\tbpcc->bpcs = 0;\n\t}\n}\n\nstatic void jp2_cdef_destroy(jp2_box_t *box)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tif (cdef->ents) {\n\t\tjas_free(cdef->ents);\n\t\tcdef->ents = 0;\n\t}\n}\n\n/******************************************************************************\\\n* Box input.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n\nvoid jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"',\n\t  boxinfo->name, '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_getuint32(in, &jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_getuint32(in, &ftyp->majver) || jp2_getuint32(in, &ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tftyp->numcompatcodes = (box->datalen - 8) / 4;\n\tif (ftyp->numcompatcodes > JP2_FTYP_MAXCOMPATCODES) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_getuint32(in, &ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_getuint32(in, &ihdr->height) || jp2_getuint32(in, &ihdr->width) ||\n\t  jp2_getuint16(in, &ihdr->numcmpts) || jp2_getuint8(in, &ihdr->bpc) ||\n\t  jp2_getuint8(in, &ihdr->comptype) || jp2_getuint8(in, &ihdr->csunk) ||\n\t  jp2_getuint8(in, &ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tfprintf(out, \"method=%d; pri=%d; approx=%d\\n\", (int)colr->method, (int)colr->pri, (int)colr->approx);\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tfprintf(out, \"csid=%d\\n\", (int)colr->csid);\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tjas_memdump(out, colr->iccp, colr->iccplen);\n\t\tbreak;\n\t}\n}\n\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tcolr->csid = 0;\n\tcolr->iccp = 0;\n\tcolr->iccplen = 0;\n\n\tif (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||\n\t  jp2_getuint8(in, &colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_getuint32(in, &colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tcolr->iccplen = box->datalen - 3;\n\t\tif (!(colr->iccp = jas_alloc2(colr->iccplen, sizeof(uint_fast8_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tfprintf(out,\n\t\t  \"channo=%\"PRIuFAST16\"; type=%\"PRIuFAST16\"; assoc=%\"PRIuFAST16\"\\n\",\n\t\t  cdef->ents[i].channo, cdef->ents[i].type, cdef->ents[i].assoc);\n\t}\n}\n\nstatic void jp2_colr_destroy(jp2_box_t *box)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (colr->iccp) {\n\t\tjas_free(colr->iccp);\n\t}\n}\n\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Box output.\n\\******************************************************************************/\n\nint jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_putuint32(out, jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_putuint32(out, ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_putuint32(out, ihdr->height) || jp2_putuint32(out, ihdr->width) ||\n\t  jp2_putuint16(out, ihdr->numcmpts) || jp2_putuint8(out, ihdr->bpc) ||\n\t  jp2_putuint8(out, ihdr->comptype) || jp2_putuint8(out, ihdr->csunk) ||\n\t  jp2_putuint8(out, ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_putuint8(out, bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (jp2_putuint8(out, colr->method) || jp2_putuint8(out, colr->pri) ||\n\t  jp2_putuint8(out, colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_putuint32(out, colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tif (jas_stream_write(out, colr->iccp,\n\t\t  JAS_CAST(int, colr->iccplen)) != JAS_CAST(int, colr->iccplen))\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tjp2_cdefchan_t *ent;\n\n\tif (jp2_putuint16(out, cdef->numchans)) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tent = &cdef->ents[i];\n\t\tif (jp2_putuint16(out, ent->channo) ||\n\t\t  jp2_putuint16(out, ent->type) ||\n\t\t  jp2_putuint16(out, ent->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Input operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val)\n{\n\tuint_fast64_t tmpval;\n\tint i;\n\tint c;\n\n\ttmpval = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\ttmpval <<= 8;\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\ttmpval |= (c & 0xff);\n\t}\n\t*val = tmpval;\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Output operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val)\n{\n\tif (jp2_putuint32(out, (val >> 32) & 0xffffffffUL) ||\n\t  jp2_putuint32(out, val & 0xffffffffUL)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\njp2_boxinfo_t *jp2_boxinfolookup(int type)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tfor (boxinfo = jp2_boxinfos; boxinfo->name; ++boxinfo) {\n\t\tif (boxinfo->type == type) {\n\t\t\treturn boxinfo;\n\t\t}\n\t}\n\treturn &jp2_boxinfo_unk;\n}\n\n\n\n\n\nstatic void jp2_cmap_destroy(jp2_box_t *box)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tif (cmap->ents) {\n\t\tjas_free(cmap->ents);\n\t}\n}\n\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tbox = 0;\n\tout = 0;\n\n\treturn -1;\n}\n\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tunsigned int i;\n\tjp2_cmapent_t *ent;\n\tfprintf(out, \"numchans = %d\\n\", (int) cmap->numchans);\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tfprintf(out, \"cmptno=%d; map=%d; pcol=%d\\n\",\n\t\t  (int) ent->cmptno, (int) ent->map, (int) ent->pcol);\n\t}\n}\n\nstatic void jp2_pclr_destroy(jp2_box_t *box)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tif (pclr->lutdata) {\n\t\tjas_free(pclr->lutdata);\n\t}\n\tif (pclr->bpc)\n\t\tjas_free(pclr->bpc);\n}\n\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n/* Eliminate warning about unused variable. */\nbox = 0;\nout = 0;\n\treturn -1;\n}\n\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tunsigned int i;\n\tint j;\n\tfprintf(out, \"numents=%d; numchans=%d\\n\", (int) pclr->numlutents,\n\t  (int) pclr->numchans);\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tfprintf(out, \"LUT[%d][%d]=%\"PRIiFAST32\"\\n\", i, j,\n\t\t\t  pclr->lutdata[i * pclr->numchans + j]);\n\t\t}\n\t}\n}\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val)\n{\n\tint c;\n\tint i;\n\tuint_fast32_t v;\n\tint m;\n\n\tm = (n + 7) / 8;\n\n\tv = 0;\n\tfor (i = 0; i < m; ++i) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ONES(n);\n\tif (s) {\n\t\tint sb;\n\t\tsb = v & (1 << (8 * m - 1));\n\t\t*val = ((~v) + 1) & ONES(8 * m);\n\t\tif (sb) {\n\t\t\t*val = -*val;\n\t\t}\n\t} else {\n\t\t*val = v;\n\t}\n\n\treturn 0;\n}\n\njp2_cdefchan_t *jp2_cdef_lookup(jp2_cdef_t *cdef, int channo)\n{\n\tunsigned int i;\n\tjp2_cdefchan_t *cdefent;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tcdefent = &cdef->ents[i];\n\t\tif (cdefent->channo == JAS_CAST(unsigned int, channo)) {\n\t\t\treturn cdefent;\n\t\t}\n\t}\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * I/O Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n/* The configuration header file should be included first. */\n#include \"jasper/jas_config.h\"\n\n#include <assert.h>\n#if defined(JAS_HAVE_FCNTL_H)\n#include <fcntl.h>\n#endif\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#if defined(JAS_HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n#if defined(WIN32) || defined(JAS_HAVE_IO_H)\n#include <io.h>\n#endif\n\n#include \"jasper/jas_debug.h\"\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s);\nstatic void jas_stream_destroy(jas_stream_t *stream);\nstatic jas_stream_t *jas_stream_create(void);\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize);\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int mem_close(jas_stream_obj_t *obj);\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int sfile_close(jas_stream_obj_t *obj);\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int file_close(jas_stream_obj_t *obj);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\nstatic jas_stream_ops_t jas_stream_fileops = {\n\tfile_read,\n\tfile_write,\n\tfile_seek,\n\tfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_sfileops = {\n\tsfile_read,\n\tsfile_write,\n\tsfile_seek,\n\tsfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_memops = {\n\tmem_read,\n\tmem_write,\n\tmem_seek,\n\tmem_close\n};\n\n/******************************************************************************\\\n* Code for opening and closing streams.\n\\******************************************************************************/\n\nstatic jas_stream_t *jas_stream_create()\n{\n\tjas_stream_t *stream;\n\n\tif (!(stream = jas_malloc(sizeof(jas_stream_t)))) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = 0;\n\tstream->bufmode_ = 0;\n\tstream->flags_ = 0;\n\tstream->bufbase_ = 0;\n\tstream->bufstart_ = 0;\n\tstream->bufsize_ = 0;\n\tstream->ptr_ = 0;\n\tstream->cnt_ = 0;\n\tstream->ops_ = 0;\n\tstream->obj_ = 0;\n\tstream->rwcnt_ = 0;\n\tstream->rwlimit_ = -1;\n\n\treturn stream;\n}\n\n#if 0\n\n/* Obsolete code. */\n\njas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (bufsize <= 0) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = (unsigned char *) buf;\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n\n#else\n\n/*\nThis function will eventually replace jas_stream_memopen.\nIf buf is 0 and bufsize > 0:\n\ta buffer is dynamically allocated with size bufsize and this buffer is\n\tnot growable.\nIf buf is 0 and bufsize is 0:\n\ta buffer is dynamically allocated whose size will automatically grow to\n\taccommodate the amount of data written.\nIf buf is not 0:\n\tbufsize (which, in this case, is not currently allowed to be zero) is\n\tthe size of the (nongrowable) buffer pointed to by buf.\n*/\n\njas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\n\tassert((buf && bufsize > 0) || (!buf));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n\n/*\nNOTE:\nThe version of the function jas_stream_memopen only exists for backwards\ncompatibility.\nEventually, it should be replaced by jas_stream_memopen2.\nIn retrospect, it was a very poor choice to have specified the buffer\nsize parameter (bufsize) to have type int.  On some machines, int may only\nbe a 16-bit integer.  This precludes larger-sized buffer allocations, which\nare needed in practice.\n\nIf bufsize <= 0, the buffer is growable; otherwise, the buffer has a fixed\nsize of bufsize.\nIf buf is 0, the buffer is dynamically allocated with jas_malloc.\nIf buf is not 0 and bufsize <= 0 (which is not permitted in any\ncircumstances), bad things will happen (especially if the buf was not\nallocated with jas_malloc).\n*/\njas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\t// This was never a valid thing to do with the old API.\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}\n\n#endif\n\njas_stream_t *jas_stream_fopen(const char *filename, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\tint openflags;\n\n\tJAS_DBGLOG(100, (\"jas_stream_fopen(\\\"%s\\\", \\\"%s\\\")\\n\", filename, mode));\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {\n\t\t// Free the underlying file object, since it will not otherwise\n\t\t// be freed.\n\t\tjas_free(obj);\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_freopen(const char *path, const char *mode, FILE *fp)\n{\n\tjas_stream_t *stream;\n\tint openflags;\n\n\tJAS_DBGLOG(100, (\"jas_stream_freopen(\\\"%s\\\", \\\"%s\\\", %p)\\n\", path, mode,\n\t  fp));\n\n\t/* Eliminate compiler warning about unused variable. */\n\tpath = 0;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\tstream->obj_ = JAS_CAST(void *, fp);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_sfileops;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_tmpfile()\\n\"));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_fdopen(int fd, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_fdopen(%d, \\\"%s\\\")\\n\", fd, mode));\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n#if defined(WIN32)\n\t/* Argh!!!  Someone ought to banish text mode (i.e., O_TEXT) to the\n\t  greatest depths of purgatory! */\n\t/* Ensure that the file descriptor is in binary mode, if the caller\n\t  has specified the binary mode flag.  Arguably, the caller ought to\n\t  take care of this, but text mode is a ugly wart anyways, so we save\n\t  the caller some grief by handling this within the stream library. */\n\t/* This ugliness is mainly for the benefit of those who run the\n\t  JasPer software under Windows from shells that insist on opening\n\t  files in text mode.  For example, in the Cygwin environment,\n\t  shells often open files in text mode when I/O redirection is\n\t  used.  Grr... */\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\tsetmode(fd, O_BINARY);\n\t}\n#endif\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = fd;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Do not close the underlying file descriptor when the stream is\n\tclosed. */\n\tobj->flags |= JAS_STREAM_FILEOBJ_NOCLOSE;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\nstatic void jas_stream_destroy(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_destroy(%p)\\n\", stream));\n\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tJAS_DBGLOG(100, (\"jas_stream_destroy freeing buffer %p\\n\",\n\t\t  stream->bufbase_));\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n\nint jas_stream_close(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_close(%p)\\n\", stream));\n\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for reading and writing streams.\n\\******************************************************************************/\n\nint jas_stream_getc_func(jas_stream_t *stream)\n{\n\tassert(stream->ptr_ - stream->bufbase_ <= stream->bufsize_ +\n\t  JAS_STREAM_MAXPUTBACK);\n\treturn jas_stream_getc_macro(stream);\n}\n\nint jas_stream_putc_func(jas_stream_t *stream, int c)\n{\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\treturn jas_stream_putc_macro(stream, c);\n}\n\nint jas_stream_ungetc(jas_stream_t *stream, int c)\n{\n\tif (!stream->ptr_ || stream->ptr_ == stream->bufbase_) {\n\t\treturn -1;\n\t}\n\n\t/* Reset the EOF indicator (since we now have at least one character\n\t  to read). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\t--stream->rwcnt_;\n\t--stream->ptr_;\n\t++stream->cnt_;\n\t*stream->ptr_ = c;\n\treturn 0;\n}\n\n/* FIXME integral type */\nint jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\n\tJAS_DBGLOG(100, (\"jas_stream_read(%p, %p, %d)\\n\", stream, buf, cnt));\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_read\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\n/* FIXME integral type */\nint jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tJAS_DBGLOG(100, (\"jas_stream_write(%p, %p, %d)\\n\", stream, buf, cnt));\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\n/* Note: This function uses a fixed size buffer.  Therefore, it cannot\n  handle invocations that will produce more output than can be held\n  by the buffer. */\nint jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(buf, sizeof buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}\n\nint jas_stream_puts(jas_stream_t *stream, const char *s)\n{\n\twhile (*s != '\\0') {\n\t\tif (jas_stream_putc_macro(stream, *s) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t++s;\n\t}\n\treturn 0;\n}\n\n/* FIXME integral type */\nchar *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n{\n\tint c;\n\tchar *bufptr;\n\tassert(bufsize > 0);\n\n\tJAS_DBGLOG(100, (\"jas_stream_gets(%p, %p, %d)\\n\", stream, buf, bufsize));\n\n\tbufptr = buf;\n\twhile (bufsize > 1) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t--bufsize;\n\t\tif (c == '\\n') {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufptr = '\\0';\n\treturn buf;\n}\n\n/* FIXME integral type */\nint jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\n\tJAS_DBGLOG(100, (\"jas_stream_gobble(%p, %d)\\n\", stream, n));\n\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}\n\n/* FIXME integral type */\nint jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\n\tJAS_DBGLOG(100, (\"jas_stream_pad(%p, %d, %d)\\n\", stream, n, c));\n\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_pad\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}\n\n/******************************************************************************\\\n* Code for getting and setting the stream position.\n\\******************************************************************************/\n\nint jas_stream_isseekable(jas_stream_t *stream)\n{\n\tif (stream->ops_ == &jas_stream_memops) {\n\t\treturn 1;\n\t} else if (stream->ops_ == &jas_stream_fileops) {\n\t\tif ((*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR) < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint jas_stream_rewind(jas_stream_t *stream)\n{\n\tJAS_DBGLOG(100, (\"jas_stream_rewind(%p)\\n\", stream));\n\treturn jas_stream_seek(stream, 0, SEEK_SET);\n}\n\nlong jas_stream_seek(jas_stream_t *stream, long offset, int origin)\n{\n\tlong newpos;\n\n\tJAS_DBGLOG(100, (\"jas_stream_seek(%p, %ld, %d)\\n\", stream, offset,\n\t  origin));\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n\nlong jas_stream_tell(jas_stream_t *stream)\n{\n\tint adjust;\n\tint offset;\n\n\tJAS_DBGLOG(100, (\"jas_stream_tell(%p)\\n\", stream));\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tadjust = -stream->cnt_;\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tadjust = stream->ptr_ - stream->bufstart_;\n\t} else {\n\t\tadjust = 0;\n\t}\n\n\tif ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn offset + adjust;\n}\n\n/******************************************************************************\\\n* Buffer initialization code.\n\\******************************************************************************/\n\n/* FIXME integral type */\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize)\n{\n\t/* If this function is being called, the buffer should not have been\n\t  initialized yet. */\n\tassert(!stream->bufbase_);\n\n\tif (bufmode != JAS_STREAM_UNBUF) {\n\t\t/* The full- or line-buffered mode is being employed. */\n\t\tif (!buf) {\n\t\t\t/* The caller has not specified a buffer to employ, so allocate\n\t\t\t  one. */\n\t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +\n\t\t\t  JAS_STREAM_MAXPUTBACK))) {\n\t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;\n\t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;\n\t\t\t} else {\n\t\t\t\t/* The buffer allocation has failed.  Resort to unbuffered\n\t\t\t\t  operation. */\n\t\t\t\tstream->bufbase_ = stream->tinybuf_;\n\t\t\t\tstream->bufsize_ = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* The caller has specified a buffer to employ. */\n\t\t\t/* The buffer must be large enough to accommodate maximum\n\t\t\t  putback. */\n\t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n\t\t\tstream->bufbase_ = JAS_CAST(jas_uchar *, buf);\n\t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n\t\t}\n\t} else {\n\t\t/* The unbuffered mode is being employed. */\n\t\t/* A buffer should not have been supplied by the caller. */\n\t\tassert(!buf);\n\t\t/* Use a trivial one-character buffer. */\n\t\tstream->bufbase_ = stream->tinybuf_;\n\t\tstream->bufsize_ = 1;\n\t}\n\tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];\n\tstream->ptr_ = stream->bufstart_;\n\tstream->cnt_ = 0;\n\tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;\n}\n\n/******************************************************************************\\\n* Buffer filling and flushing code.\n\\******************************************************************************/\n\nint jas_stream_flush(jas_stream_t *stream)\n{\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\treturn 0;\n\t}\n\treturn jas_stream_flushbuf(stream, EOF);\n}\n\nint jas_stream_fillbuf(jas_stream_t *stream, int getflag)\n{\n\tint c;\n\n\t/* The stream must not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for reading. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* Make a half-hearted attempt to confirm that the buffer is not\n\tcurrently being used for writing.  This check is not intended\n\tto be foolproof! */\n\tassert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);\n\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\n\t/* Mark the buffer as being used for reading. */\n\tstream->bufmode_ |= JAS_STREAM_RDBUF;\n\n\t/* Read new data into the buffer. */\n\tstream->ptr_ = stream->bufstart_;\n\tif ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,\n\t  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {\n\t\tif (stream->cnt_ < 0) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t} else {\n\t\t\tstream->flags_ |= JAS_STREAM_EOF;\n\t\t}\n\t\tstream->cnt_ = 0;\n\t\treturn EOF;\n\t}\n\n\tassert(stream->cnt_ > 0);\n\t/* Get or peek at the first character in the buffer. */\n\tc = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);\n\n\treturn c;\n}\n\nint jas_stream_flushbuf(jas_stream_t *stream, int c)\n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s)\n{\n\tint openmode = 0;\n\twhile (*s != '\\0') {\n\t\tswitch (*s) {\n\t\tcase 'r':\n\t\t\topenmode |= JAS_STREAM_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\topenmode |= JAS_STREAM_WRITE | JAS_STREAM_CREATE;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\topenmode |= JAS_STREAM_BINARY;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\topenmode |= JAS_STREAM_APPEND;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\topenmode |= JAS_STREAM_READ | JAS_STREAM_WRITE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t++s;\n\t}\n\treturn openmode;\n}\n\n/* FIXME integral type */\nint jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n{\n\tint all;\n\tint c;\n\tint m;\n\n\tall = (n < 0) ? 1 : 0;\n\n\tm = n;\n\twhile (all || m > 0) {\n\t\tif ((c = jas_stream_getc_macro(in)) == EOF) {\n\t\t\t/* The next character of input could not be read. */\n\t\t\t/* Return with an error if an I/O error occured\n\t\t\t  (not including EOF) or if an explicit copy count\n\t\t\t  was specified. */\n\t\t\treturn (!all || jas_stream_error(in)) ? (-1) : 0;\n\t\t}\n\t\tif (jas_stream_putc_macro(out, c) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t--m;\n\t}\n\treturn 0;\n}\n\n/* FIXME integral type */\nlong jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n{\n\tint old;\n\n\told = stream->rwcnt_;\n\tstream->rwcnt_ = rwcnt;\n\treturn old;\n}\n\n/* FIXME integral type */\nint jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n{\n\tunsigned char buf[16];\n\tint i;\n\tint j;\n\tint m;\n\tint c;\n\tint display;\n\tint cnt;\n\n\tcnt = n - (n % 16);\n\tdisplay = 1;\n\n\tfor (i = 0; i < n; i += 16) {\n\t\tif (n > 16 && i > 0) {\n\t\t\tdisplay = (i >= cnt) ? 1 : 0;\n\t\t}\n\t\tif (display) {\n\t\t\tfprintf(fp, \"%08x:\", i);\n\t\t}\n\t\tm = JAS_MIN(n - i, 16);\n\t\tfor (j = 0; j < m; ++j) {\n\t\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\t\tabort();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbuf[j] = c;\n\t\t}\n\t\tif (display) {\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tfprintf(fp, \" %02x\", buf[j]);\n\t\t\t}\n\t\t\tfputc(' ', fp);\n\t\t\tfor (; j < 16; ++j) {\n\t\t\t\tfprintf(fp, \"   \");\n\t\t\t}\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tif (isprint(buf[j])) {\n\t\t\t\t\tfputc(buf[j], fp);\n\t\t\t\t} else {\n\t\t\t\t\tfputc(' ', fp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(fp, \"\\n\");\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\nlong jas_stream_length(jas_stream_t *stream)\n{\n\tlong oldpos;\n\tlong pos;\n\tif ((oldpos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, 0, SEEK_END) < 0) {\n\t\treturn -1;\n\t}\n\tif ((pos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, oldpos, SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn pos;\n}\n\n/******************************************************************************\\\n* Memory stream object.\n\\******************************************************************************/\n\n/* FIXME integral type */\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tssize_t n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}\n\nstatic int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n{\n\tunsigned char *buf;\n\n\t//assert(m->buf_);\n\t//assert(bufsize >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %zu)\\n\", m, bufsize));\n\tif (!bufsize) {\n\t\tjas_eprintf(\n\t\t  \"mem_resize was not really designed to handle a buffer of size 0\\n\"\n\t\t  \"This may not work.\\n\"\n\t\t);\n\t}\n\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n\n/* FIXME integral type */\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tsize_t n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newbufsize;\n\tsize_t newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\t//newbufsize <<= 1;\n\t\t\tif (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {\n\t\t\t\tJAS_DBGLOG(100, (\"new buffer size would cause overflow\\n\"));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %zu\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tassert(newbufsize > 0);\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t/* The current position is beyond the end of the file, so\n\t\t  pad the file to the current position with zeros. */\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t/* The buffer is not big enough. */\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}\n\n/* FIXME integral type */\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newpos;\n\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\n\treturn m->pos_;\n}\n\nstatic int mem_close(jas_stream_obj_t *obj)\n{\n\tJAS_DBGLOG(100, (\"mem_close(%p)\\n\", obj));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tJAS_DBGLOG(100, (\"mem_close myalloc=%d\\n\", m->myalloc_));\n\tif (m->myalloc_ && m->buf_) {\n\t\tJAS_DBGLOG(100, (\"mem_close freeing buffer %p\\n\", m->buf_));\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File stream object.\n\\******************************************************************************/\n\n/* FIXME integral type */\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn read(fileobj->fd, buf, cnt);\n}\n\n/* FIXME integral type */\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn write(fileobj->fd, buf, cnt);\n}\n\n/* FIXME integral type */\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn lseek(fileobj->fd, offset, origin);\n}\n\nstatic int file_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_fileobj_t *fileobj;\n\tJAS_DBGLOG(100, (\"file_close(%p)\\n\", obj));\n\tfileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\tint ret;\n\tret = close(fileobj->fd);\n\tif (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) {\n\t\tunlink(fileobj->pathname);\n\t}\n\tjas_free(fileobj);\n\treturn ret;\n}\n\n/******************************************************************************\\\n* Stdio file stream object.\n\\******************************************************************************/\n\n/* FIXME integral type */\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tsize_t n;\n\tint result;\n\tJAS_DBGLOG(100, (\"sfile_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfp = JAS_CAST(FILE *, obj);\n\tn = fread(buf, 1, cnt, fp);\n\tif (n != cnt) {\n\t\tresult = (!ferror(fp) && feof(fp)) ? 0 : -1;\n\t}\n\tresult = JAS_CAST(int, n);\n\treturn result;\n}\n\n/* FIXME integral type */\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tsize_t n;\n\tJAS_DBGLOG(100, (\"sfile_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfp = JAS_CAST(FILE *, obj);\n\tn = fwrite(buf, 1, cnt, fp);\n\treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n}\n\n/* FIXME integral type */\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tFILE *fp;\n\tJAS_DBGLOG(100, (\"sfile_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fseek(fp, offset, origin);\n}\n\nstatic int sfile_close(jas_stream_obj_t *obj)\n{\n\tFILE *fp;\n\tJAS_DBGLOG(100, (\"sfile_close(%p)\\n\", obj));\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fclose(fp);\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JP2 Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#include <stdlib.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jp2_cod.h\"\n\n/******************************************************************************\\\n* Function prototypes.\n\\******************************************************************************/\n\n#define\tONES(n)\t((1 << (n)) - 1)\n\njp2_boxinfo_t *jp2_boxinfolookup(int type);\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val);\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val);\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val);\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val);\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val);\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val);\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val);\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val);\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val);\n\njp2_box_t *jp2_box_get(jas_stream_t *in);\nvoid jp2_box_dump(jp2_box_t *box, FILE *out);\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_bpcc_destroy(jp2_box_t *box);\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_colr_destroy(jp2_box_t *box);\nstatic void jp2_cdef_destroy(jp2_box_t *box);\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_cmap_destroy(jp2_box_t *box);\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out);\nstatic void jp2_pclr_destroy(jp2_box_t *box);\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in);\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out);\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\njp2_boxinfo_t jp2_boxinfos[] = {\n\t{JP2_BOX_JP, \"JP\", 0,\n\t  {0, 0, jp2_jp_getdata, jp2_jp_putdata, 0}},\n\t{JP2_BOX_FTYP, \"FTYP\", 0,\n\t  {0, 0, jp2_ftyp_getdata, jp2_ftyp_putdata, 0}},\n\t{JP2_BOX_JP2H, \"JP2H\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_IHDR, \"IHDR\", 0,\n\t  {0, 0, jp2_ihdr_getdata, jp2_ihdr_putdata, 0}},\n\t{JP2_BOX_BPCC, \"BPCC\", 0,\n\t  {0, jp2_bpcc_destroy, jp2_bpcc_getdata, jp2_bpcc_putdata, 0}},\n\t{JP2_BOX_COLR, \"COLR\", 0,\n\t  {0, jp2_colr_destroy, jp2_colr_getdata, jp2_colr_putdata, jp2_colr_dumpdata}},\n\t{JP2_BOX_PCLR, \"PCLR\", 0,\n\t  {0, jp2_pclr_destroy, jp2_pclr_getdata, jp2_pclr_putdata, jp2_pclr_dumpdata}},\n\t{JP2_BOX_CMAP, \"CMAP\", 0,\n\t  {0, jp2_cmap_destroy, jp2_cmap_getdata, jp2_cmap_putdata, jp2_cmap_dumpdata}},\n\t{JP2_BOX_CDEF, \"CDEF\", 0,\n\t  {0, jp2_cdef_destroy, jp2_cdef_getdata, jp2_cdef_putdata, jp2_cdef_dumpdata}},\n\t{JP2_BOX_RES, \"RES\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESC, \"RESC\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_RESD, \"RESD\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2C, \"JP2C\", JP2_BOX_NODATA,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_JP2I, \"JP2I\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_XML, \"XML\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UUID, \"UUID\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_UINF, \"UINF\", JP2_BOX_SUPER,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_ULST, \"ULST\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{JP2_BOX_URL, \"URL\", 0,\n\t  {0, 0, 0, 0, 0}},\n\t{0, 0, 0, {0, 0, 0, 0, 0}},\n};\n\njp2_boxinfo_t jp2_boxinfo_unk = {\n\t0, \"Unknown\", 0, {0, 0, 0, 0, 0}\n};\n\n/******************************************************************************\\\n* Box constructor.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_create0()\n{\n\tjp2_box_t *box;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = 0;\n\tbox->len = 0;\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\treturn box;\n}\n\njp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jp2_box_create0())) {\n\t\treturn 0;\n\t}\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}\n\n/******************************************************************************\\\n* Box destructor.\n\\******************************************************************************/\n\nvoid jp2_box_destroy(jp2_box_t *box)\n{\n\tif (box->ops->destroy) {\n\t\t(*box->ops->destroy)(box);\n\t}\n\tjas_free(box);\n}\n\nstatic void jp2_bpcc_destroy(jp2_box_t *box)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tif (bpcc->bpcs) {\n\t\tjas_free(bpcc->bpcs);\n\t\tbpcc->bpcs = 0;\n\t}\n}\n\nstatic void jp2_cdef_destroy(jp2_box_t *box)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tif (cdef->ents) {\n\t\tjas_free(cdef->ents);\n\t\tcdef->ents = 0;\n\t}\n}\n\n/******************************************************************************\\\n* Box input.\n\\******************************************************************************/\n\njp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jp2_box_create0())) {\n\t\tgoto error;\n\t}\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: \"\n\t  \"type=%c%s%c (0x%08x); length=%\"PRIuFAST32\"\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tJAS_DBGLOG(10, (\"big length\\n\"));\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n\nvoid jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"',\n\t  boxinfo->name, '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}\n\nstatic int jp2_jp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_getuint32(in, &jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_getuint32(in, &ftyp->majver) || jp2_getuint32(in, &ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tftyp->numcompatcodes = (box->datalen - 8) / 4;\n\tif (ftyp->numcompatcodes > JP2_FTYP_MAXCOMPATCODES) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_getuint32(in, &ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_getuint32(in, &ihdr->height) || jp2_getuint32(in, &ihdr->width) ||\n\t  jp2_getuint16(in, &ihdr->numcmpts) || jp2_getuint8(in, &ihdr->bpc) ||\n\t  jp2_getuint8(in, &ihdr->comptype) || jp2_getuint8(in, &ihdr->csunk) ||\n\t  jp2_getuint8(in, &ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->bpcs = 0;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void jp2_colr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tfprintf(out, \"method=%d; pri=%d; approx=%d\\n\", (int)colr->method, (int)colr->pri, (int)colr->approx);\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tfprintf(out, \"csid=%d\\n\", (int)colr->csid);\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tjas_memdump(out, colr->iccp, colr->iccplen);\n\t\tbreak;\n\t}\n}\n\nstatic int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tcolr->csid = 0;\n\tcolr->iccp = 0;\n\tcolr->iccplen = 0;\n\n\tif (jp2_getuint8(in, &colr->method) || jp2_getuint8(in, &colr->pri) ||\n\t  jp2_getuint8(in, &colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_getuint32(in, &colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tcolr->iccplen = box->datalen - 3;\n\t\tif (!(colr->iccp = jas_alloc2(colr->iccplen, sizeof(uint_fast8_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void jp2_cdef_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tfprintf(out,\n\t\t  \"channo=%\"PRIuFAST16\"; type=%\"PRIuFAST16\"; assoc=%\"PRIuFAST16\"\\n\",\n\t\t  cdef->ents[i].channo, cdef->ents[i].type, cdef->ents[i].assoc);\n\t}\n}\n\nstatic void jp2_colr_destroy(jp2_box_t *box)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (colr->iccp) {\n\t\tjas_free(colr->iccp);\n\t}\n}\n\nstatic int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Box output.\n\\******************************************************************************/\n\nint jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len -\n\t\t  JP2_BOX_HDRLEN(false))) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n\nstatic int jp2_jp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_jp_t *jp = &box->data.jp;\n\tif (jp2_putuint32(out, jp->magic)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ftyp_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ftyp_t *ftyp = &box->data.ftyp;\n\tunsigned int i;\n\tif (jp2_putuint32(out, ftyp->majver) || jp2_putuint32(out, ftyp->minver)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < ftyp->numcompatcodes; ++i) {\n\t\tif (jp2_putuint32(out, ftyp->compatcodes[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_ihdr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_ihdr_t *ihdr = &box->data.ihdr;\n\tif (jp2_putuint32(out, ihdr->height) || jp2_putuint32(out, ihdr->width) ||\n\t  jp2_putuint16(out, ihdr->numcmpts) || jp2_putuint8(out, ihdr->bpc) ||\n\t  jp2_putuint8(out, ihdr->comptype) || jp2_putuint8(out, ihdr->csunk) ||\n\t  jp2_putuint8(out, ihdr->ipr)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_bpcc_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_putuint8(out, bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_colr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_colr_t *colr = &box->data.colr;\n\tif (jp2_putuint8(out, colr->method) || jp2_putuint8(out, colr->pri) ||\n\t  jp2_putuint8(out, colr->approx)) {\n\t\treturn -1;\n\t}\n\tswitch (colr->method) {\n\tcase JP2_COLR_ENUM:\n\t\tif (jp2_putuint32(out, colr->csid)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\tif (jas_stream_write(out, colr->iccp,\n\t\t  JAS_CAST(int, colr->iccplen)) != JAS_CAST(int, colr->iccplen))\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_cdef_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tunsigned int i;\n\tjp2_cdefchan_t *ent;\n\n\tif (jp2_putuint16(out, cdef->numchans)) {\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tent = &cdef->ents[i];\n\t\tif (jp2_putuint16(out, ent->channo) ||\n\t\t  jp2_putuint16(out, ent->type) ||\n\t\t  jp2_putuint16(out, ent->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Input operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val)\n{\n\tuint_fast64_t tmpval;\n\tint i;\n\tint c;\n\n\ttmpval = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\ttmpval <<= 8;\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\ttmpval |= (c & 0xff);\n\t}\n\t*val = tmpval;\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Output operations for primitive types.\n\\******************************************************************************/\n\nstatic int jp2_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jp2_putuint64(jas_stream_t *out, uint_fast64_t val)\n{\n\tif (jp2_putuint32(out, (val >> 32) & 0xffffffffUL) ||\n\t  jp2_putuint32(out, val & 0xffffffffUL)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\njp2_boxinfo_t *jp2_boxinfolookup(int type)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tfor (boxinfo = jp2_boxinfos; boxinfo->name; ++boxinfo) {\n\t\tif (boxinfo->type == type) {\n\t\t\treturn boxinfo;\n\t\t}\n\t}\n\treturn &jp2_boxinfo_unk;\n}\n\n\n\n\n\nstatic void jp2_cmap_destroy(jp2_box_t *box)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tif (cmap->ents) {\n\t\tjas_free(cmap->ents);\n\t}\n}\n\nstatic int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nstatic int jp2_cmap_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tbox = 0;\n\tout = 0;\n\n\treturn -1;\n}\n\nstatic void jp2_cmap_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tunsigned int i;\n\tjp2_cmapent_t *ent;\n\tfprintf(out, \"numchans = %d\\n\", (int) cmap->numchans);\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tfprintf(out, \"cmptno=%d; map=%d; pcol=%d\\n\",\n\t\t  (int) ent->cmptno, (int) ent->map, (int) ent->pcol);\n\t}\n}\n\nstatic void jp2_pclr_destroy(jp2_box_t *box)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tif (pclr->lutdata) {\n\t\tjas_free(pclr->lutdata);\n\t}\n\tif (pclr->bpc)\n\t\tjas_free(pclr->bpc);\n}\n\nstatic int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\n\tpclr->lutdata = 0;\n\tpclr->bpc = 0;\n\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n\t/* Eliminate warning about unused variable. */\n\tbox = 0;\n\tout = 0;\n\treturn -1;\n}\n\nstatic void jp2_pclr_dumpdata(jp2_box_t *box, FILE *out)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tunsigned int i;\n\tint j;\n\tfprintf(out, \"numents=%d; numchans=%d\\n\", (int) pclr->numlutents,\n\t  (int) pclr->numchans);\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tfprintf(out, \"LUT[%d][%d]=%\"PRIiFAST32\"\\n\", i, j,\n\t\t\t  pclr->lutdata[i * pclr->numchans + j]);\n\t\t}\n\t}\n}\n\nstatic int jp2_getint(jas_stream_t *in, int s, int n, int_fast32_t *val)\n{\n\tint c;\n\tint i;\n\tuint_fast32_t v;\n\tint m;\n\n\tm = (n + 7) / 8;\n\n\tv = 0;\n\tfor (i = 0; i < m; ++i) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 8) | c;\n\t}\n\tv &= ONES(n);\n\tif (s) {\n\t\tint sb;\n\t\tsb = v & (1 << (8 * m - 1));\n\t\t*val = ((~v) + 1) & ONES(8 * m);\n\t\tif (sb) {\n\t\t\t*val = -*val;\n\t\t}\n\t} else {\n\t\t*val = v;\n\t}\n\n\treturn 0;\n}\n\njp2_cdefchan_t *jp2_cdef_lookup(jp2_cdef_t *cdef, int channo)\n{\n\tunsigned int i;\n\tjp2_cdefchan_t *cdefent;\n\tfor (i = 0; i < cdef->numchans; ++i) {\n\t\tcdefent = &cdef->ents[i];\n\t\tif (cdefent->channo == JAS_CAST(unsigned int, channo)) {\n\t\t\treturn cdefent;\n\t\t}\n\t}\n\treturn 0;\n}\n"], "filenames": ["src/libjasper/base/jas_stream.c", "src/libjasper/jp2/jp2_cod.c"], "buggy_code_start_loc": [666, 185], "buggy_code_end_loc": [1379, 875], "fixing_code_start_loc": [667, 186], "fixing_code_end_loc": [1398, 891], "type": "CWE-476", "message": "The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.", "other": {"cve": {"id": "CVE-2017-6850", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-15T14:59:01.557", "lastModified": "2018-06-29T01:29:03.627", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image."}, {"lang": "es", "value": "La funci\u00f3n jp2_cdef_destroy en jp2_cod.c en JasPer en versiones anteriores a 2.0.13 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL) a trav\u00e9s de una imagen manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.12", "matchCriteriaId": "B57ADFF8-1D59-4A9D-AF9F-1CEB4B727362"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/01/25/jasper-null-pointer-dereference-in-jp2_cdef_destroy-jp2_cod-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/mdadams/jasper/issues/112", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3693-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d"}}