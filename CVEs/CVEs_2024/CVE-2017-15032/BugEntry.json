{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     Y   Y   YYYC  BBBB    YYYC  RRRR                        %\n%                      Y Y   C      B   B  C      R   R                       %\n%                       Y    C      BBBB   C      RRRR                        %\n%                       Y    C      B   B  C      R  R                        %\n%                       Y     YYYC  BBBB    YYYC  R   R                       %\n%                                                                             %\n%                                                                             %\n%                     Read/Write Raw YCbCr Image Format                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteYCBCRImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d Y C b C r I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadYCBCRImage() reads an image of raw YCbCr or YCbCrA samples and returns\n%  it. It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadYCBCRImage method is:\n%\n%      Image *ReadYCBCRImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadYCBCRImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const unsigned char\n    *pixels;\n\n  Image\n    *canvas_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  SetImageColorspace(image,YCbCrColorspace,exception);\n  if (image_info->interlace != PartitionInterlace)\n    {\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n    }\n  /*\n    Create virtual canvas to support cropping (i.e. image.rgb[100x100+10+20]).\n  */\n  canvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse,\n    exception);\n  (void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod,\n    exception);\n  quantum_info=AcquireQuantumInfo(image_info,canvas_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  quantum_type=RGBQuantum;\n  if (LocaleCompare(image_info->magick,\"YCbCrA\") == 0)\n    {\n      quantum_type=RGBAQuantum;\n      image->alpha_trait=BlendPixelTrait;\n    }\n  pixels=(const unsigned char *) NULL;\n  if (image_info->number_scenes != 0)\n    while (image->scene < image_info->scene)\n    {\n      /*\n        Skip to next image.\n      */\n      image->scene++;\n      length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        pixels=(const unsigned char *) ReadBlobStream(image,length,\n          GetQuantumPixels(quantum_info),&count);\n        if (count != (ssize_t) length)\n          break;\n      }\n    }\n  count=0;\n  length=0;\n  scene=0;\n  do\n  {\n    /*\n      Read pixels to virtual canvas image then push to image.\n    */\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n    {\n      quantum_info=DestroyQuantumInfo(quantum_info);\n      return(DestroyImageList(image));\n    }\n    SetImageColorspace(image,YCbCrColorspace,exception);\n    switch (image_info->interlace)\n    {\n      case NoInterlace:\n      default:\n      {\n        /*\n          No interlacing:  YCbCrYCbCrYCbCrYCbCrYCbCrYCbCr...\n        */\n        if (scene == 0)\n          {\n            length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=QueueAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,GetPixelRed(canvas_image,p),q);\n                SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);\n                SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        break;\n      }\n      case LineInterlace:\n      {\n        static QuantumType\n          quantum_types[4] =\n          {\n            RedQuantum,\n            GreenQuantum,\n            BlueQuantum,\n            OpacityQuantum\n          };\n\n        /*\n          Line interlacing:  YYY...CbCbCb...CrCrCr...YYY...CbCbCb...CrCrCr...\n        */\n        if (scene == 0)\n          {\n            length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          for (i=0; i < (image->alpha_trait != UndefinedPixelTrait ? 4 : 3); i++)\n          {\n            if (count != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n            quantum_type=quantum_types[i];\n            q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n              quantum_info,quantum_type,pixels,exception);\n            if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n              break;\n            if (((y-image->extract_info.y) >= 0) && \n                ((y-image->extract_info.y) < (ssize_t) image->rows))\n              {\n                p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,\n                  0,canvas_image->columns,1,exception);\n                q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                  image->columns,1,exception);\n                if ((p == (const Quantum *) NULL) ||\n                    (q == (Quantum *) NULL))\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  switch (quantum_type)\n                  {\n                    case RedQuantum:\n                    {\n                      SetPixelRed(image,GetPixelRed(canvas_image,p),q);\n                      break;\n                    }\n                    case GreenQuantum:\n                    {\n                      SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);\n                      break;\n                    }\n                    case BlueQuantum:\n                    {\n                      SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);\n                      break;\n                    }\n                    case OpacityQuantum:\n                    {\n                      SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);\n                      break;\n                    }\n                    default:\n                      break;\n                  }\n                  p+=GetPixelChannels(canvas_image);\n                  q+=GetPixelChannels(image);\n                }\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PlaneInterlace:\n      {\n        /*\n          Plane interlacing:  YYYYYY...CbCbCbCbCbCb...CrCrCrCrCrCr...\n        */\n        if (scene == 0)\n          {\n            length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,RedQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,GetPixelRed(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,1,5);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,GreenQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,2,5);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,BlueQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            {\n              if (count != (ssize_t) length)\n                {\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n              q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n                quantum_info,AlphaQuantum,pixels,exception);\n              if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n                break;\n              if (((y-image->extract_info.y) >= 0) && \n                  ((y-image->extract_info.y) < (ssize_t) image->rows))\n                {\n                  p=GetVirtualPixels(canvas_image,\n                    canvas_image->extract_info.x,0,canvas_image->columns,1,\n                    exception);\n                  q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                    image->columns,1,exception);\n                  if ((p == (const Quantum *) NULL) ||\n                      (q == (Quantum *) NULL))\n                    break;\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);\n                    p+=GetPixelChannels(canvas_image);\n                    q+=GetPixelChannels(image);\n                  }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n              pixels=(const unsigned char *) ReadBlobStream(image,length,\n                GetQuantumPixels(quantum_info),&count);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,4,5);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,5,5);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PartitionInterlace:\n      {\n        /*\n          Partition interlacing:  YYYYYY..., CbCbCbCbCbCb..., CrCrCrCrCrCr...\n        */\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n        length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n          {\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n            if (count != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n          }\n        pixels=(const unsigned char *) ReadBlobStream(image,length,\n          GetQuantumPixels(quantum_info),&count);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,RedQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,GetPixelRed(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,1,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"Cb\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=GetQuantumExtent(canvas_image,quantum_info,GreenQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n          {\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n            if (count != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n          }\n        pixels=(const unsigned char *) ReadBlobStream(image,length,\n          GetQuantumPixels(quantum_info),&count);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,GreenQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,2,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"Cr\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=GetQuantumExtent(canvas_image,quantum_info,BlueQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n          {\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n            if (count != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n          }\n        pixels=(const unsigned char *) ReadBlobStream(image,length,\n          GetQuantumPixels(quantum_info),&count);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,BlueQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            (void) CloseBlob(image);\n            AppendImageFormat(\"A\",image->filename);\n            status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n            if (status == MagickFalse)\n              {\n                canvas_image=DestroyImageList(canvas_image);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            length=GetQuantumExtent(canvas_image,quantum_info,AlphaQuantum);\n            for (i=0; i < (ssize_t) scene; i++)\n              for (y=0; y < (ssize_t) image->extract_info.height; y++)\n              {\n                pixels=(const unsigned char *) ReadBlobStream(image,length,\n                  GetQuantumPixels(quantum_info),&count);\n                if (count != (ssize_t) length)\n                  {\n                    ThrowFileException(exception,CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                    break;\n                  }\n              }\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n            for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            {\n              if (count != (ssize_t) length)\n                {\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n              q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n                quantum_info,BlueQuantum,pixels,exception);\n              if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n                break;\n              if (((y-image->extract_info.y) >= 0) && \n                  ((y-image->extract_info.y) < (ssize_t) image->rows))\n                {\n                  p=GetVirtualPixels(canvas_image,\n                    canvas_image->extract_info.x,0,canvas_image->columns,1,\n                    exception);\n                  q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                    image->columns,1,exception);\n                  if ((p == (const Quantum *) NULL) ||\n                      (q == (Quantum *) NULL))\n                    break;\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);\n                    p+=GetPixelChannels(canvas_image);\n                    q+=GetPixelChannels(image);\n                  }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n               }\n              pixels=(const unsigned char *) ReadBlobStream(image,length,\n                GetQuantumPixels(quantum_info),&count);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,4,5);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,5,5);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n    }\n    SetQuantumImageType(image,quantum_type);\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (count == (ssize_t) length)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (count == (ssize_t) length);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  canvas_image=DestroyImage(canvas_image);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r Y C b C r I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterYCBCRImage() adds attributes for the YCbCr or YCbCrA image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterYCBCRImage method is:\n%\n%      size_t RegisterYCBCRImage(void)\n%\n*/\nModuleExport size_t RegisterYCBCRImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"YCbCr\",\"YCbCr\",\"Raw Y, Cb, and Cr samples\");\n  entry->decoder=(DecodeImageHandler *) ReadYCBCRImage;\n  entry->encoder=(EncodeImageHandler *) WriteYCBCRImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"YCbCr\",\"YCbCrA\",\"Raw Y, Cb, Cr, and alpha samples\");\n  entry->decoder=(DecodeImageHandler *) ReadYCBCRImage;\n  entry->encoder=(EncodeImageHandler *) WriteYCBCRImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r Y C b C r I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterYCBCRImage() removes format registrations made by the\n%  YCbCr module from the list of supported formats.\n%\n%  The format of the UnregisterYCBCRImage method is:\n%\n%      UnregisterYCBCRImage(void)\n%\n*/\nModuleExport void UnregisterYCBCRImage(void)\n{\n  (void) UnregisterMagickInfo(\"YCbCr\");\n  (void) UnregisterMagickInfo(\"YCbCrA\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e Y C b C r I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteYCBCRImage() writes an image to a file in the YCbCr or YCbCrA\n%  rasterfile format.\n%\n%  The format of the WriteYCBCRImage method is:\n%\n%      MagickBooleanType WriteYCBCRImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteYCBCRImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register const Quantum\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Allocate memory for pixels.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image_info->interlace != PartitionInterlace)\n    {\n      /*\n        Open output image file.\n      */\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n    }\n  quantum_type=RGBQuantum;\n  if (LocaleCompare(image_info->magick,\"YCbCrA\") == 0)\n    {\n      quantum_type=RGBAQuantum;\n      image->alpha_trait=BlendPixelTrait;\n    }\n  scene=0;\n  do\n  {\n    /*\n      Convert MIFF to YCbCr raster pixels.\n    */\n    if (image->colorspace != YCbCrColorspace)\n      (void) TransformImageColorspace(image,YCbCrColorspace,exception);\n    if ((LocaleCompare(image_info->magick,\"YCbCrA\") == 0) &&\n        (image->alpha_trait == UndefinedPixelTrait))\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (image_info->interlace)\n    {\n      case NoInterlace:\n      default:\n      {\n        /*\n          No interlacing:  YCbCrYCbCrYCbCrYCbCrYCbCrYCbCr...\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case LineInterlace:\n      {\n        /*\n          Line interlacing:  YYY...CbCbCb...CrCrCr...YYY...CbCbCb...CrCrCr...\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            RedQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GreenQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            BlueQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n          if (quantum_type == RGBAQuantum)\n            {\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                AlphaQuantum,pixels,exception);\n              count=WriteBlob(image,length,pixels);\n              if (count != (ssize_t) length)\n                break;\n            }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PlaneInterlace:\n      {\n        /*\n          Plane interlacing:  YYYYYY...CbCbCbCbCbCb...CrCrCrCrCrCr...\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            RedQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,1,5);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GreenQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,2,5);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            BlueQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        if (quantum_type == RGBAQuantum)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                AlphaQuantum,pixels,exception);\n              count=WriteBlob(image,length,pixels);\n              if (count != (ssize_t) length)\n              break;\n            }\n          }\n        if (image_info->interlace == PartitionInterlace)\n          (void) CopyMagickString(image->filename,image_info->filename,\n            MagickPathExtent);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,5,5);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PartitionInterlace:\n      {\n        /*\n          Partition interlacing:  YYYYYY..., CbCbCbCbCbCb..., CrCrCrCrCrCr...\n        */\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,scene == 0 ? WriteBinaryBlobMode :\n          AppendBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          return(status);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            RedQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,1,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"Cb\",image->filename);\n        status=OpenBlob(image_info,image,scene == 0 ? WriteBinaryBlobMode :\n          AppendBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          return(status);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GreenQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,2,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"Cr\",image->filename);\n        status=OpenBlob(image_info,image,scene == 0 ? WriteBinaryBlobMode :\n          AppendBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          return(status);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            BlueQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        if (quantum_type == RGBAQuantum)\n          {\n            (void) CloseBlob(image);\n            AppendImageFormat(\"A\",image->filename);\n            status=OpenBlob(image_info,image,scene == 0 ? WriteBinaryBlobMode :\n              AppendBinaryBlobMode,exception);\n            if (status == MagickFalse)\n              return(status);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                AlphaQuantum,pixels,exception);\n              count=WriteBlob(image,length,pixels);\n              if (count != (ssize_t) length)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,4,5);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) CloseBlob(image);\n        (void) CopyMagickString(image->filename,image_info->filename,\n          MagickPathExtent);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,5,5);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                     Y   Y   YYYC  BBBB    YYYC  RRRR                        %\n%                      Y Y   C      B   B  C      R   R                       %\n%                       Y    C      BBBB   C      RRRR                        %\n%                       Y    C      B   B  C      R  R                        %\n%                       Y     YYYC  BBBB    YYYC  R   R                       %\n%                                                                             %\n%                                                                             %\n%                     Read/Write Raw YCbCr Image Format                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteYCBCRImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d Y C b C r I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadYCBCRImage() reads an image of raw YCbCr or YCbCrA samples and returns\n%  it. It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadYCBCRImage method is:\n%\n%      Image *ReadYCBCRImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadYCBCRImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const unsigned char\n    *pixels;\n\n  Image\n    *canvas_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  SetImageColorspace(image,YCbCrColorspace,exception);\n  if (image_info->interlace != PartitionInterlace)\n    {\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n    }\n  /*\n    Create virtual canvas to support cropping (i.e. image.rgb[100x100+10+20]).\n  */\n  canvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse,\n    exception);\n  (void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod,\n    exception);\n  quantum_info=AcquireQuantumInfo(image_info,canvas_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  quantum_type=RGBQuantum;\n  if (LocaleCompare(image_info->magick,\"YCbCrA\") == 0)\n    {\n      quantum_type=RGBAQuantum;\n      image->alpha_trait=BlendPixelTrait;\n    }\n  pixels=(const unsigned char *) NULL;\n  if (image_info->number_scenes != 0)\n    while (image->scene < image_info->scene)\n    {\n      /*\n        Skip to next image.\n      */\n      image->scene++;\n      length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        pixels=(const unsigned char *) ReadBlobStream(image,length,\n          GetQuantumPixels(quantum_info),&count);\n        if (count != (ssize_t) length)\n          break;\n      }\n    }\n  count=0;\n  length=0;\n  scene=0;\n  do\n  {\n    /*\n      Read pixels to virtual canvas image then push to image.\n    */\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n    {\n      quantum_info=DestroyQuantumInfo(quantum_info);\n      canvas_image=DestroyImage(canvas_image);\n      return(DestroyImageList(image));\n    }\n    SetImageColorspace(image,YCbCrColorspace,exception);\n    switch (image_info->interlace)\n    {\n      case NoInterlace:\n      default:\n      {\n        /*\n          No interlacing:  YCbCrYCbCrYCbCrYCbCrYCbCrYCbCr...\n        */\n        if (scene == 0)\n          {\n            length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,quantum_type,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=QueueAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,GetPixelRed(canvas_image,p),q);\n                SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);\n                SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        break;\n      }\n      case LineInterlace:\n      {\n        static QuantumType\n          quantum_types[4] =\n          {\n            RedQuantum,\n            GreenQuantum,\n            BlueQuantum,\n            OpacityQuantum\n          };\n\n        /*\n          Line interlacing:  YYY...CbCbCb...CrCrCr...YYY...CbCbCb...CrCrCr...\n        */\n        if (scene == 0)\n          {\n            length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          for (i=0; i < (image->alpha_trait != UndefinedPixelTrait ? 4 : 3); i++)\n          {\n            if (count != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n            quantum_type=quantum_types[i];\n            q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n              exception);\n            if (q == (Quantum *) NULL)\n              break;\n            length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n              quantum_info,quantum_type,pixels,exception);\n            if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n              break;\n            if (((y-image->extract_info.y) >= 0) && \n                ((y-image->extract_info.y) < (ssize_t) image->rows))\n              {\n                p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,\n                  0,canvas_image->columns,1,exception);\n                q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                  image->columns,1,exception);\n                if ((p == (const Quantum *) NULL) ||\n                    (q == (Quantum *) NULL))\n                  break;\n                for (x=0; x < (ssize_t) image->columns; x++)\n                {\n                  switch (quantum_type)\n                  {\n                    case RedQuantum:\n                    {\n                      SetPixelRed(image,GetPixelRed(canvas_image,p),q);\n                      break;\n                    }\n                    case GreenQuantum:\n                    {\n                      SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);\n                      break;\n                    }\n                    case BlueQuantum:\n                    {\n                      SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);\n                      break;\n                    }\n                    case OpacityQuantum:\n                    {\n                      SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);\n                      break;\n                    }\n                    default:\n                      break;\n                  }\n                  p+=GetPixelChannels(canvas_image);\n                  q+=GetPixelChannels(image);\n                }\n                if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                  break;\n              }\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PlaneInterlace:\n      {\n        /*\n          Plane interlacing:  YYYYYY...CbCbCbCbCbCb...CrCrCrCrCrCr...\n        */\n        if (scene == 0)\n          {\n            length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,RedQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,GetPixelRed(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,1,5);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,GreenQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,2,5);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,BlueQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            {\n              if (count != (ssize_t) length)\n                {\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n              q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n                quantum_info,AlphaQuantum,pixels,exception);\n              if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n                break;\n              if (((y-image->extract_info.y) >= 0) && \n                  ((y-image->extract_info.y) < (ssize_t) image->rows))\n                {\n                  p=GetVirtualPixels(canvas_image,\n                    canvas_image->extract_info.x,0,canvas_image->columns,1,\n                    exception);\n                  q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                    image->columns,1,exception);\n                  if ((p == (const Quantum *) NULL) ||\n                      (q == (Quantum *) NULL))\n                    break;\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);\n                    p+=GetPixelChannels(canvas_image);\n                    q+=GetPixelChannels(image);\n                  }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n              pixels=(const unsigned char *) ReadBlobStream(image,length,\n                GetQuantumPixels(quantum_info),&count);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,4,5);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,5,5);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PartitionInterlace:\n      {\n        /*\n          Partition interlacing:  YYYYYY..., CbCbCbCbCbCb..., CrCrCrCrCrCr...\n        */\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n        length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n          {\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n            if (count != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n          }\n        pixels=(const unsigned char *) ReadBlobStream(image,length,\n          GetQuantumPixels(quantum_info),&count);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,RedQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,GetPixelRed(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,1,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"Cb\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=GetQuantumExtent(canvas_image,quantum_info,GreenQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n          {\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n            if (count != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n          }\n        pixels=(const unsigned char *) ReadBlobStream(image,length,\n          GetQuantumPixels(quantum_info),&count);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,GreenQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,2,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"Cr\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            canvas_image=DestroyImageList(canvas_image);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=GetQuantumExtent(canvas_image,quantum_info,BlueQuantum);\n        for (i=0; i < (ssize_t) scene; i++)\n          for (y=0; y < (ssize_t) image->extract_info.height; y++)\n          {\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n            if (count != (ssize_t) length)\n              {\n                ThrowFileException(exception,CorruptImageError,\n                  \"UnexpectedEndOfFile\",image->filename);\n                break;\n              }\n          }\n        pixels=(const unsigned char *) ReadBlobStream(image,length,\n          GetQuantumPixels(quantum_info),&count);\n        for (y=0; y < (ssize_t) image->extract_info.height; y++)\n        {\n          if (count != (ssize_t) length)\n            {\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n            quantum_info,BlueQuantum,pixels,exception);\n          if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n            break;\n          if (((y-image->extract_info.y) >= 0) && \n              ((y-image->extract_info.y) < (ssize_t) image->rows))\n            {\n              p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,\n                canvas_image->columns,1,exception);\n              q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                image->columns,1,exception);\n              if ((p == (const Quantum *) NULL) ||\n                  (q == (Quantum *) NULL))\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);\n                p+=GetPixelChannels(canvas_image);\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n           }\n          pixels=(const unsigned char *) ReadBlobStream(image,length,\n            GetQuantumPixels(quantum_info),&count);\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            (void) CloseBlob(image);\n            AppendImageFormat(\"A\",image->filename);\n            status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n            if (status == MagickFalse)\n              {\n                canvas_image=DestroyImageList(canvas_image);\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            length=GetQuantumExtent(canvas_image,quantum_info,AlphaQuantum);\n            for (i=0; i < (ssize_t) scene; i++)\n              for (y=0; y < (ssize_t) image->extract_info.height; y++)\n              {\n                pixels=(const unsigned char *) ReadBlobStream(image,length,\n                  GetQuantumPixels(quantum_info),&count);\n                if (count != (ssize_t) length)\n                  {\n                    ThrowFileException(exception,CorruptImageError,\n                      \"UnexpectedEndOfFile\",image->filename);\n                    break;\n                  }\n              }\n            pixels=(const unsigned char *) ReadBlobStream(image,length,\n              GetQuantumPixels(quantum_info),&count);\n            for (y=0; y < (ssize_t) image->extract_info.height; y++)\n            {\n              if (count != (ssize_t) length)\n                {\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n              q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,\n                quantum_info,BlueQuantum,pixels,exception);\n              if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)\n                break;\n              if (((y-image->extract_info.y) >= 0) && \n                  ((y-image->extract_info.y) < (ssize_t) image->rows))\n                {\n                  p=GetVirtualPixels(canvas_image,\n                    canvas_image->extract_info.x,0,canvas_image->columns,1,\n                    exception);\n                  q=GetAuthenticPixels(image,0,y-image->extract_info.y,\n                    image->columns,1,exception);\n                  if ((p == (const Quantum *) NULL) ||\n                      (q == (Quantum *) NULL))\n                    break;\n                  for (x=0; x < (ssize_t) image->columns; x++)\n                  {\n                    SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);\n                    p+=GetPixelChannels(canvas_image);\n                    q+=GetPixelChannels(image);\n                  }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n               }\n              pixels=(const unsigned char *) ReadBlobStream(image,length,\n                GetQuantumPixels(quantum_info),&count);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,4,5);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,5,5);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n    }\n    SetQuantumImageType(image,quantum_type);\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (count == (ssize_t) length)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (count == (ssize_t) length);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  canvas_image=DestroyImage(canvas_image);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r Y C b C r I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterYCBCRImage() adds attributes for the YCbCr or YCbCrA image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterYCBCRImage method is:\n%\n%      size_t RegisterYCBCRImage(void)\n%\n*/\nModuleExport size_t RegisterYCBCRImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"YCbCr\",\"YCbCr\",\"Raw Y, Cb, and Cr samples\");\n  entry->decoder=(DecodeImageHandler *) ReadYCBCRImage;\n  entry->encoder=(EncodeImageHandler *) WriteYCBCRImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"YCbCr\",\"YCbCrA\",\"Raw Y, Cb, Cr, and alpha samples\");\n  entry->decoder=(DecodeImageHandler *) ReadYCBCRImage;\n  entry->encoder=(EncodeImageHandler *) WriteYCBCRImage;\n  entry->flags|=CoderRawSupportFlag;\n  entry->flags|=CoderEndianSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r Y C b C r I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterYCBCRImage() removes format registrations made by the\n%  YCbCr module from the list of supported formats.\n%\n%  The format of the UnregisterYCBCRImage method is:\n%\n%      UnregisterYCBCRImage(void)\n%\n*/\nModuleExport void UnregisterYCBCRImage(void)\n{\n  (void) UnregisterMagickInfo(\"YCbCr\");\n  (void) UnregisterMagickInfo(\"YCbCrA\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e Y C b C r I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteYCBCRImage() writes an image to a file in the YCbCr or YCbCrA\n%  rasterfile format.\n%\n%  The format of the WriteYCBCRImage method is:\n%\n%      MagickBooleanType WriteYCBCRImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteYCBCRImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  register const Quantum\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Allocate memory for pixels.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image_info->interlace != PartitionInterlace)\n    {\n      /*\n        Open output image file.\n      */\n      assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        return(status);\n    }\n  quantum_type=RGBQuantum;\n  if (LocaleCompare(image_info->magick,\"YCbCrA\") == 0)\n    {\n      quantum_type=RGBAQuantum;\n      image->alpha_trait=BlendPixelTrait;\n    }\n  scene=0;\n  do\n  {\n    /*\n      Convert MIFF to YCbCr raster pixels.\n    */\n    if (image->colorspace != YCbCrColorspace)\n      (void) TransformImageColorspace(image,YCbCrColorspace,exception);\n    if ((LocaleCompare(image_info->magick,\"YCbCrA\") == 0) &&\n        (image->alpha_trait == UndefinedPixelTrait))\n      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    switch (image_info->interlace)\n    {\n      case NoInterlace:\n      default:\n      {\n        /*\n          No interlacing:  YCbCrYCbCrYCbCrYCbCrYCbCrYCbCr...\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            quantum_type,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case LineInterlace:\n      {\n        /*\n          Line interlacing:  YYY...CbCbCb...CrCrCr...YYY...CbCbCb...CrCrCr...\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            RedQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GreenQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            BlueQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n          if (quantum_type == RGBAQuantum)\n            {\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                AlphaQuantum,pixels,exception);\n              count=WriteBlob(image,length,pixels);\n              if (count != (ssize_t) length)\n                break;\n            }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case PlaneInterlace:\n      {\n        /*\n          Plane interlacing:  YYYYYY...CbCbCbCbCbCb...CrCrCrCrCrCr...\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            RedQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,1,5);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GreenQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,2,5);\n            if (status == MagickFalse)\n              break;\n          }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            BlueQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        if (quantum_type == RGBAQuantum)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                AlphaQuantum,pixels,exception);\n              count=WriteBlob(image,length,pixels);\n              if (count != (ssize_t) length)\n              break;\n            }\n          }\n        if (image_info->interlace == PartitionInterlace)\n          (void) CopyMagickString(image->filename,image_info->filename,\n            MagickPathExtent);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,5,5);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PartitionInterlace:\n      {\n        /*\n          Partition interlacing:  YYYYYY..., CbCbCbCbCbCb..., CrCrCrCrCrCr...\n        */\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,scene == 0 ? WriteBinaryBlobMode :\n          AppendBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          return(status);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            RedQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,1,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"Cb\",image->filename);\n        status=OpenBlob(image_info,image,scene == 0 ? WriteBinaryBlobMode :\n          AppendBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          return(status);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            GreenQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,2,5);\n            if (status == MagickFalse)\n              break;\n          }\n        (void) CloseBlob(image);\n        AppendImageFormat(\"Cr\",image->filename);\n        status=OpenBlob(image_info,image,scene == 0 ? WriteBinaryBlobMode :\n          AppendBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          return(status);\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n            BlueQuantum,pixels,exception);\n          count=WriteBlob(image,length,pixels);\n          if (count != (ssize_t) length)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,3,5);\n            if (status == MagickFalse)\n              break;\n          }\n        if (quantum_type == RGBAQuantum)\n          {\n            (void) CloseBlob(image);\n            AppendImageFormat(\"A\",image->filename);\n            status=OpenBlob(image_info,image,scene == 0 ? WriteBinaryBlobMode :\n              AppendBinaryBlobMode,exception);\n            if (status == MagickFalse)\n              return(status);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              length=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n                AlphaQuantum,pixels,exception);\n              count=WriteBlob(image,length,pixels);\n              if (count != (ssize_t) length)\n                break;\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,4,5);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) CloseBlob(image);\n        (void) CopyMagickString(image->filename,image_info->filename,\n          MagickPathExtent);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,SaveImageTag,5,5);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n    }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/ycbcr.c"], "buggy_code_start_loc": [217], "buggy_code_end_loc": [217], "fixing_code_start_loc": [218], "fixing_code_end_loc": [219], "type": "CWE-772", "message": "ImageMagick version 7.0.7-2 contains a memory leak in ReadYCBCRImage in coders/ycbcr.c.", "other": {"cve": {"id": "CVE-2017-15032", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-05T07:29:00.807", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick version 7.0.7-2 contains a memory leak in ReadYCBCRImage in coders/ycbcr.c."}, {"lang": "es", "value": "ImageMagick 7.0.7-2 tiene una vulnerabilidad de fuga de memoria en ReadYCBCRImage en coders/ycbcr.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.7-2:*:*:*:*:*:*:*", "matchCriteriaId": "AB2E7C40-868A-40F5-B496-3B15AC111320"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/241988ca28139ad970c1d9717c419f41e360ddb0", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3681-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/241988ca28139ad970c1d9717c419f41e360ddb0"}}