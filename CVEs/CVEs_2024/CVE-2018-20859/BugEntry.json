{"buggy_code": ["from __future__ import division\n\nfrom fractions import Fraction\n\nimport nltk\nfrom nltk.tree import Tree\nfrom pyparsing import Literal, OneOrMore, ParseException, StringEnd\n\nARROWS = ('<->', '->')\n\n## Defines a simple pyparsing tokenizer for chemical equations\nelements = ['Ac', 'Ag', 'Al', 'Am', 'Ar', 'As', 'At', 'Au', 'B', 'Ba', 'Be',\n            'Bh', 'Bi', 'Bk', 'Br', 'C', 'Ca', 'Cd', 'Ce', 'Cf', 'Cl', 'Cm',\n            'Cn', 'Co', 'Cr', 'Cs', 'Cu', 'Db', 'Ds', 'Dy', 'Er', 'Es', 'Eu',\n            'F', 'Fe', 'Fl', 'Fm', 'Fr', 'Ga', 'Gd', 'Ge', 'H', 'He', 'Hf',\n            'Hg', 'Ho', 'Hs', 'I', 'In', 'Ir', 'K', 'Kr', 'La', 'Li', 'Lr',\n            'Lu', 'Lv', 'Md', 'Mg', 'Mn', 'Mo', 'Mt', 'N', 'Na', 'Nb', 'Nd',\n            'Ne', 'Ni', 'No', 'Np', 'O', 'Os', 'P', 'Pa', 'Pb', 'Pd', 'Pm',\n            'Po', 'Pr', 'Pt', 'Pu', 'Ra', 'Rb', 'Re', 'Rf', 'Rg', 'Rh', 'Rn',\n            'Ru', 'S', 'Sb', 'Sc', 'Se', 'Sg', 'Si', 'Sm', 'Sn', 'Sr', 'Ta',\n            'Tb', 'Tc', 'Te', 'Th', 'Ti', 'Tl', 'Tm', 'U', 'Uuo', 'Uup',\n            'Uus', 'Uut', 'V', 'W', 'Xe', 'Y', 'Yb', 'Zn', 'Zr']\ndigits = map(str, range(10))\nsymbols = list(\"[](){}^+-/\")\nphases = [\"(s)\", \"(l)\", \"(g)\", \"(aq)\"]\ntokens = reduce(lambda a, b: a ^ b, map(Literal, elements + digits + symbols + phases))\ntokenizer = OneOrMore(tokens) + StringEnd()\n\n\ndef _orjoin(l):\n    return \"'\" + \"' | '\".join(l) + \"'\"\n\n## Defines an NLTK parser for tokenized expressions\ngrammar = \"\"\"\n  S -> multimolecule | multimolecule '+' S\n  multimolecule -> count molecule | molecule\n  count -> number | number '/' number\n  molecule -> unphased | unphased phase\n  unphased -> group | paren_group_round | paren_group_square\n  element -> \"\"\" + _orjoin(elements) + \"\"\"\n  digit -> \"\"\" + _orjoin(digits) + \"\"\"\n  phase -> \"\"\" + _orjoin(phases) + \"\"\"\n  number -> digit | digit number\n  group -> suffixed | suffixed group\n  paren_group_round -> '(' group ')'\n  paren_group_square -> '[' group ']'\n  plus_minus -> '+' | '-'\n  number_suffix -> number\n  ion_suffix -> '^' number plus_minus | '^' plus_minus\n  suffix -> number_suffix | number_suffix ion_suffix | ion_suffix\n  unsuffixed -> element | paren_group_round | paren_group_square\n\n  suffixed -> unsuffixed | unsuffixed suffix\n\"\"\"\nparser = nltk.ChartParser(nltk.parse_cfg(grammar))\n\n\ndef _clean_parse_tree(tree):\n    ''' The parse tree contains a lot of redundant\n    nodes. E.g. paren_groups have groups as children, etc. This will\n    clean up the tree.\n    '''\n    def unparse_number(n):\n        ''' Go from a number parse tree to a number '''\n        if len(n) == 1:\n            rv = n[0][0]\n        else:\n            rv = n[0][0] + unparse_number(n[1])\n        return rv\n\n    def null_tag(n):\n        ''' Remove a tag '''\n        return n[0]\n\n    def ion_suffix(n):\n        '''1. \"if\" part handles special case\n           2. \"else\" part is general behaviour '''\n\n        if n[1:][0].node == 'number' and n[1:][0][0][0] == '1':\n            # if suffix is explicitly 1, like ^1-\n            # strip 1, leave only sign: ^-\n            return nltk.tree.Tree(n.node, n[2:])\n        else:\n            return nltk.tree.Tree(n.node, n[1:])\n\n    dispatch = {'number': lambda x: nltk.tree.Tree(\"number\", [unparse_number(x)]),\n                'unphased': null_tag,\n                'unsuffixed': null_tag,\n                'number_suffix': lambda x: nltk.tree.Tree('number_suffix', [unparse_number(x[0])]),\n                'suffixed': lambda x: len(x) > 1 and x or x[0],\n                'ion_suffix': ion_suffix,\n                'paren_group_square': lambda x: nltk.tree.Tree(x.node, x[1]),\n                'paren_group_round': lambda x: nltk.tree.Tree(x.node, x[1])}\n\n    if isinstance(tree, str):\n        return tree\n\n    old_node = None\n    ## This loop means that if a node is processed, and returns a child,\n    ## the child will be processed.\n    while tree.node in dispatch and tree.node != old_node:\n        old_node = tree.node\n        tree = dispatch[tree.node](tree)\n\n    children = []\n    for child in tree:\n        child = _clean_parse_tree(child)\n        children.append(child)\n\n    tree = nltk.tree.Tree(tree.node, children)\n\n    return tree\n\n\ndef _merge_children(tree, tags):\n    ''' nltk, by documentation, cannot do arbitrary length\n    groups. Instead of:\n    (group 1 2 3 4)\n    It has to handle this recursively:\n    (group 1 (group 2 (group 3 (group 4))))\n    We do the cleanup of converting from the latter to the former.\n    '''\n    if tree is None:\n        # There was a problem--shouldn't have empty trees (NOTE: see this with input e.g. 'H2O(', or 'Xe+').\n        # Haven't grokked the code to tell if this is indeed the right thing to do.\n        raise ParseException(\"Shouldn't have empty trees\")\n\n    if isinstance(tree, str):\n        return tree\n\n    merged_children = []\n    done = False\n    #print '00000', tree\n    ## Merge current tag\n    while not done:\n        done = True\n        for child in tree:\n            if isinstance(child, nltk.tree.Tree) and child.node == tree.node and tree.node in tags:\n                merged_children = merged_children + list(child)\n                done = False\n            else:\n                merged_children = merged_children + [child]\n        tree = nltk.tree.Tree(tree.node, merged_children)\n        merged_children = []\n    #print '======',tree\n\n    # And recurse\n    children = []\n    for child in tree:\n        children.append(_merge_children(child, tags))\n\n    #return tree\n    return nltk.tree.Tree(tree.node, children)\n\n\ndef _render_to_html(tree):\n    ''' Renders a cleaned tree to HTML '''\n\n    def molecule_count(tree, children):\n        # If an integer, return that integer\n        if len(tree) == 1:\n            return tree[0][0]\n        # If a fraction, return the fraction\n        if len(tree) == 3:\n            return \" <sup>{num}</sup>&frasl;<sub>{den}</sub> \".format(num=tree[0][0], den=tree[2][0])\n        return \"Error\"\n\n    def subscript(tree, children):\n        return \"<sub>{sub}</sub>\".format(sub=children)\n\n    def superscript(tree, children):\n        return \"<sup>{sup}</sup>\".format(sup=children)\n\n    def round_brackets(tree, children):\n        return \"({insider})\".format(insider=children)\n\n    def square_brackets(tree, children):\n        return \"[{insider}]\".format(insider=children)\n\n    dispatch = {'count': molecule_count,\n                'number_suffix': subscript,\n                'ion_suffix': superscript,\n                'paren_group_round': round_brackets,\n                'paren_group_square': square_brackets}\n\n    if isinstance(tree, str):\n        return tree\n    else:\n        children = \"\".join(map(_render_to_html, tree))\n        if tree.node in dispatch:\n            return dispatch[tree.node](tree, children)\n        else:\n            return children.replace(' ', '')\n\n\ndef render_to_html(eq):\n    '''\n    Render a chemical equation string to html.\n\n    Renders each molecule separately, and returns invalid input wrapped in a <span>.\n    '''\n    def err(s):\n        \"Render as an error span\"\n        return '<span class=\"inline-error inline\">{0}</span>'.format(s)\n\n    def render_arrow(arrow):\n        \"\"\"Turn text arrows into pretty ones\"\"\"\n        if arrow == '->':\n            return u'\\u2192'\n        if arrow == '<->':\n            return u'\\u2194'\n\n        # this won't be reached unless we add more arrow types, but keep it to avoid explosions when\n        # that happens.\n        return arrow\n\n    def render_expression(ex):\n        \"\"\"\n        Render a chemical expression--no arrows.\n        \"\"\"\n        try:\n            return _render_to_html(_get_final_tree(ex))\n        except ParseException:\n            return err(ex)\n\n    def spanify(s):\n        return u'<span class=\"math\">{0}</span>'.format(s)\n\n    left, arrow, right = split_on_arrow(eq)\n    if arrow == '':\n        # only one side\n        return spanify(render_expression(left))\n\n    return spanify(render_expression(left) + render_arrow(arrow) + render_expression(right))\n\n\ndef _get_final_tree(s):\n    '''\n    Return final tree after merge and clean.\n\n    Raises pyparsing.ParseException if s is invalid.\n    '''\n    tokenized = tokenizer.parseString(s)\n    parsed = parser.parse(tokenized)\n    merged = _merge_children(parsed, {'S', 'group'})\n    final = _clean_parse_tree(merged)\n    return final\n\n\ndef _check_equality(tuple1, tuple2):\n    ''' return True if tuples of multimolecules are equal '''\n    list1 = list(tuple1)\n    list2 = list(tuple2)\n\n    # Hypo: trees where are levels count+molecule vs just molecule\n    # cannot be sorted properly (tested on test_complex_additivity)\n    # But without factors and phases sorting seems to work.\n\n    # Also for lists of multimolecules without factors and phases\n    # sorting seems to work fine.\n    list1.sort()\n    list2.sort()\n    return list1 == list2\n\n\ndef compare_chemical_expression(s1, s2, ignore_state=False):\n    ''' It does comparison between two expressions.\n        It uses divide_chemical_expression and check if division is 1\n    '''\n    return divide_chemical_expression(s1, s2, ignore_state) == 1\n\n\ndef divide_chemical_expression(s1, s2, ignore_state=False):\n    '''Compare two chemical expressions for equivalence up to a multiplicative factor:\n\n    - If they are not the same chemicals, returns False.\n    - If they are the same, \"divide\" s1 by s2 to returns a factor x such that s1 / s2 == x as a Fraction object.\n    - if ignore_state is True, ignores phases when doing the comparison.\n\n    Examples:\n    divide_chemical_expression(\"H2O\", \"3H2O\") -> Fraction(1,3)\n    divide_chemical_expression(\"3H2O\", \"H2O\") -> 3  # actually Fraction(3, 1), but compares == to 3.\n    divide_chemical_expression(\"2H2O(s) + 2CO2\", \"H2O(s)+CO2\") -> 2\n    divide_chemical_expression(\"H2O(s) + CO2\", \"3H2O(s)+2CO2\") -> False\n\n    Implementation sketch:\n        - extract factors and phases to standalone lists,\n        - compare expressions without factors and phases,\n        - divide lists of factors for each other and check\n             for equality of every element in list,\n        - return result of factor division\n\n    '''\n\n    # parsed final trees\n    treedic = {}\n    treedic['1'] = _get_final_tree(s1)\n    treedic['2'] = _get_final_tree(s2)\n\n    # strip phases and factors\n    # collect factors in list\n    for i in ('1', '2'):\n        treedic[i + ' cleaned_mm_list'] = []\n        treedic[i + ' factors'] = []\n        treedic[i + ' phases'] = []\n        for el in treedic[i].subtrees(filter=lambda t: t.node == 'multimolecule'):\n            count_subtree = [t for t in el.subtrees() if t.node == 'count']\n            group_subtree = [t for t in el.subtrees() if t.node == 'group']\n            phase_subtree = [t for t in el.subtrees() if t.node == 'phase']\n            if count_subtree:\n                if len(count_subtree[0]) > 1:\n                    treedic[i + ' factors'].append(\n                        int(count_subtree[0][0][0]) /\n                        int(count_subtree[0][2][0]))\n                else:\n                    treedic[i + ' factors'].append(int(count_subtree[0][0][0]))\n            else:\n                treedic[i + ' factors'].append(1.0)\n            if phase_subtree:\n                treedic[i + ' phases'].append(phase_subtree[0][0])\n            else:\n                treedic[i + ' phases'].append(' ')\n            treedic[i + ' cleaned_mm_list'].append(\n                Tree('multimolecule', [Tree('molecule', group_subtree)]))\n\n    # order of factors and phases must mirror the order of multimolecules,\n    # use 'decorate, sort, undecorate' pattern\n    treedic['1 cleaned_mm_list'], treedic['1 factors'], treedic['1 phases'] = zip(\n        *sorted(zip(treedic['1 cleaned_mm_list'], treedic['1 factors'], treedic['1 phases'])))\n\n    treedic['2 cleaned_mm_list'], treedic['2 factors'], treedic['2 phases'] = zip(\n        *sorted(zip(treedic['2 cleaned_mm_list'], treedic['2 factors'], treedic['2 phases'])))\n\n    # check if expressions are correct without factors\n    if not _check_equality(treedic['1 cleaned_mm_list'], treedic['2 cleaned_mm_list']):\n        return False\n\n    # phases are ruled by ingore_state flag\n    if not ignore_state:  # phases matters\n        if treedic['1 phases'] != treedic['2 phases']:\n            return False\n\n    if any(\n        [\n            x / y - treedic['1 factors'][0] / treedic['2 factors'][0]\n            for (x, y) in zip(treedic['1 factors'], treedic['2 factors'])\n        ]\n    ):\n        # factors are not proportional\n        return False\n    else:\n        # return ratio\n        return Fraction(treedic['1 factors'][0] / treedic['2 factors'][0])\n\n\ndef split_on_arrow(eq):\n    \"\"\"\n    Split a string on an arrow.  Returns left, arrow, right.  If there is no arrow, returns the\n    entire eq in left, and '' in arrow and right.\n\n    Return left, arrow, right.\n    \"\"\"\n    # order matters -- need to try <-> first\n    for arrow in ARROWS:\n        left, a, right = eq.partition(arrow)\n        if a != '':\n            return left, a, right\n\n    return eq, '', ''\n\n\ndef chemical_equations_equal(eq1, eq2, exact=False):\n    \"\"\"\n    Check whether two chemical equations are the same.  (equations have arrows)\n\n    If exact is False, then they are considered equal if they differ by a\n    constant factor.\n\n    arrows matter: -> and <-> are different.\n\n    e.g.\n    chemical_equations_equal('H2 + O2 -> H2O2', 'O2 + H2 -> H2O2') -> True\n    chemical_equations_equal('H2 + O2 -> H2O2', 'O2 + 2H2 -> H2O2') -> False\n\n    chemical_equations_equal('H2 + O2 -> H2O2', 'O2 + H2 <-> H2O2') -> False\n\n    chemical_equations_equal('H2 + O2 -> H2O2', '2 H2 + 2 O2 -> 2 H2O2') -> True\n    chemical_equations_equal('H2 + O2 -> H2O2', '2 H2 + 2 O2 -> 2 H2O2', exact=True) -> False\n\n\n    If there's a syntax error, we return False.\n    \"\"\"\n\n    left1, arrow1, right1 = split_on_arrow(eq1)\n    left2, arrow2, right2 = split_on_arrow(eq2)\n\n    if arrow1 == '' or arrow2 == '':\n        return False\n\n    # TODO: may want to be able to give student helpful feedback about why things didn't work.\n    if arrow1 != arrow2:\n        # arrows don't match\n        return False\n\n    try:\n        factor_left = divide_chemical_expression(left1, left2)\n        if not factor_left:\n            # left sides don't match\n            return False\n\n        factor_right = divide_chemical_expression(right1, right2)\n        if not factor_right:\n            # right sides don't match\n            return False\n\n        if factor_left != factor_right:\n            # factors don't match (molecule counts to add up)\n            return False\n\n        if exact and factor_left != 1:\n            # want an exact match.\n            return False\n\n        return True\n    except ParseException:\n        # Don't want external users to have to deal with parsing exceptions.  Just return False.\n        return False\n", "import codecs\nimport unittest\nfrom fractions import Fraction\n\nimport chem.miller\n\nfrom .chemcalc import chemical_equations_equal, compare_chemical_expression, divide_chemical_expression, render_to_html\n\nLOCAL_DEBUG = None\n\n\ndef log(msg, output_type=None):\n    \"\"\"Logging function for tests\"\"\"\n    if LOCAL_DEBUG:\n        print msg\n        if output_type == 'html':\n            f.write(msg + '\\n<br>\\n')\n\n\nclass Test_Compare_Equations(unittest.TestCase):\n    def test_simple_equation(self):\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 'O2 + H2 -> H2O2'))\n        # left sides don't match\n        self.assertFalse(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                  'O2 + 2H2 -> H2O2'))\n        # right sides don't match\n        self.assertFalse(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                  'O2 + H2 -> H2O'))\n\n        # factors don't match\n        self.assertFalse(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                  'O2 + H2 -> 2H2O2'))\n\n    def test_different_factor(self):\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 '2O2 + 2H2 -> 2H2O2'))\n\n        self.assertFalse(\n            chemical_equations_equal(\n                '2H2 + O2 -> H2O2',\n                '2O2 + 2H2 -> 2H2O2',\n            )\n        )\n\n    def test_different_arrows(self):\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 '2O2 + 2H2 -> 2H2O2'))\n\n        self.assertFalse(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                  'O2 + H2 <-> 2H2O2'))\n\n    def test_exact_match(self):\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 '2O2 + 2H2 -> 2H2O2'))\n\n        self.assertFalse(\n            chemical_equations_equal(\n                'H2 + O2 -> H2O2',\n                '2O2 + 2H2 -> 2H2O2',\n                exact=True,\n            )\n        )\n\n        # order still doesn't matter\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 'O2 + H2 -> H2O2', exact=True))\n\n    def test_syntax_errors(self):\n        self.assertFalse(chemical_equations_equal('H2 + O2 a-> H2O2',\n                                                  '2O2 + 2H2 -> 2H2O2'))\n\n        self.assertFalse(chemical_equations_equal('H2O( -> H2O2',\n                                                  'H2O -> H2O2'))\n\n        self.assertFalse(chemical_equations_equal('H2 + O2 ==> H2O2',   # strange arrow\n                                                  '2O2 + 2H2 -> 2H2O2'))\n\n\nclass Test_Compare_Expressions(unittest.TestCase):\n\n    def test_compare_incorrect_order_of_atoms_in_molecule(self):\n        self.assertFalse(compare_chemical_expression(\"H2O + CO2\", \"O2C + OH2\"))\n\n    def test_compare_same_order_no_phases_no_factors_no_ions(self):\n        self.assertTrue(compare_chemical_expression(\"H2O + CO2\", \"CO2+H2O\"))\n\n    def test_compare_different_order_no_phases_no_factors_no_ions(self):\n        self.assertTrue(compare_chemical_expression(\"H2O + CO2\", \"CO2 + H2O\"))\n\n    def test_compare_different_order_three_multimolecule(self):\n        self.assertTrue(compare_chemical_expression(\"H2O + Fe(OH)3 +  CO2\", \"CO2 + H2O + Fe(OH)3\"))\n\n    def test_compare_same_factors(self):\n        self.assertTrue(compare_chemical_expression(\"3H2O +  2CO2\", \"2CO2 + 3H2O \"))\n\n    def test_compare_different_factors(self):\n        self.assertFalse(compare_chemical_expression(\"2H2O +  3CO2\", \"2CO2 + 3H2O \"))\n\n    def test_compare_correct_ions(self):\n        self.assertTrue(compare_chemical_expression(\"H^+ + OH^-\", \" OH^- + H^+ \"))\n\n    def test_compare_wrong_ions(self):\n        self.assertFalse(compare_chemical_expression(\"H^+ + OH^-\", \" OH^- + H^- \"))\n\n    def test_compare_parent_groups_ions(self):\n        self.assertTrue(compare_chemical_expression(\"Fe(OH)^2- + (OH)^-\", \" (OH)^- + Fe(OH)^2- \"))\n\n    def test_compare_correct_factors_ions_and_one(self):\n        self.assertTrue(compare_chemical_expression(\"3H^+ + 2OH^-\", \" 2OH^- + 3H^+ \"))\n\n    def test_compare_wrong_factors_ions(self):\n        self.assertFalse(compare_chemical_expression(\"2H^+ + 3OH^-\", \" 2OH^- + 3H^+ \"))\n\n    def test_compare_float_factors(self):\n        self.assertTrue(compare_chemical_expression(\"7/2H^+ + 3/5OH^-\", \" 3/5OH^- + 7/2H^+ \"))\n\n    # Phases tests\n    def test_compare_phases_ignored(self):\n        self.assertTrue(compare_chemical_expression(\n            \"H2O(s) + CO2\", \"H2O+CO2\", ignore_state=True))\n\n    def test_compare_phases_not_ignored_explicitly(self):\n        self.assertFalse(compare_chemical_expression(\n            \"H2O(s) + CO2\", \"H2O+CO2\", ignore_state=False))\n\n    def test_compare_phases_not_ignored(self):  # same as previous\n        self.assertFalse(compare_chemical_expression(\n            \"H2O(s) + CO2\", \"H2O+CO2\"))\n\n    # all in one cases\n    def test_complex_additivity(self):\n        self.assertTrue(compare_chemical_expression(\n            \"5(H1H212)^70010- + 2H20 + 7/2HCl + H2O\",\n            \"7/2HCl + 2H20 + H2O + 5(H1H212)^70010-\"))\n\n    def test_complex_additivity_wrong(self):\n        self.assertFalse(compare_chemical_expression(\n            \"5(H1H212)^70010- + 2H20 + 7/2HCl + H2O\",\n            \"2H20 + 7/2HCl + H2O + 5(H1H212)^70011-\"))\n\n    def test_complex_all_grammar(self):\n        self.assertTrue(compare_chemical_expression(\n            \"5[Ni(NH3)4]^2+ + 5/2SO4^2-\",\n            \"5/2SO4^2- + 5[Ni(NH3)4]^2+\"))\n\n    # special cases\n\n    def test_compare_one_superscript_explicitly_set(self):\n        self.assertTrue(compare_chemical_expression(\"H^+ + OH^1-\", \" OH^- + H^+ \"))\n\n    def test_compare_equal_factors_differently_set(self):\n        self.assertTrue(compare_chemical_expression(\"6/2H^+ + OH^-\", \" OH^- + 3H^+ \"))\n\n    def test_compare_one_subscript_explicitly_set(self):\n        self.assertFalse(compare_chemical_expression(\"H2 + CO2\", \"H2 + C102\"))\n\n\nclass Test_Divide_Expressions(unittest.TestCase):\n    ''' as compare_ use divide_,\n    tests here must consider different\n    division (not equality) cases '''\n\n    def test_divide_by_zero(self):\n        self.assertFalse(divide_chemical_expression(\n            \"0H2O\", \"H2O\"))\n\n    def test_divide_wrong_factors(self):\n        self.assertFalse(divide_chemical_expression(\n            \"5(H1H212)^70010- + 10H2O\", \"5H2O + 10(H1H212)^70010-\"))\n\n    def test_divide_right(self):\n        self.assertEqual(divide_chemical_expression(\n            \"5(H1H212)^70010- + 10H2O\", \"10H2O + 5(H1H212)^70010-\"), 1)\n\n    def test_divide_wrong_reagents(self):\n        self.assertFalse(divide_chemical_expression(\n            \"H2O + CO2\", \"CO2\"))\n\n    def test_divide_right_simple(self):\n        self.assertEqual(divide_chemical_expression(\n            \"H2O + CO2\", \"H2O+CO2\"), 1)\n\n    def test_divide_right_phases(self):\n        self.assertEqual(divide_chemical_expression(\n            \"H2O(s) + CO2\", \"2H2O(s)+2CO2\"), Fraction(1, 2))\n\n    def test_divide_right_phases_other_order(self):\n        self.assertEqual(divide_chemical_expression(\n            \"2H2O(s) + 2CO2\", \"H2O(s)+CO2\"), 2)\n\n    def test_divide_wrong_phases(self):\n        self.assertFalse(divide_chemical_expression(\n            \"H2O(s) + CO2\", \"2H2O+2CO2(s)\"))\n\n    def test_divide_wrong_phases_but_phases_ignored(self):\n        self.assertEqual(divide_chemical_expression(\n            \"H2O(s) + CO2\", \"2H2O+2CO2(s)\", ignore_state=True), Fraction(1, 2))\n\n    def test_divide_order(self):\n        self.assertEqual(divide_chemical_expression(\n            \"2CO2 + H2O\", \"2H2O+4CO2\"), Fraction(1, 2))\n\n    def test_divide_fract_to_int(self):\n        self.assertEqual(divide_chemical_expression(\n            \"3/2CO2 + H2O\", \"2H2O+3CO2\"), Fraction(1, 2))\n\n    def test_divide_fract_to_frac(self):\n        self.assertEqual(divide_chemical_expression(\n            \"3/4CO2 + H2O\", \"2H2O+9/6CO2\"), Fraction(1, 2))\n\n    def test_divide_fract_to_frac_wrog(self):\n        self.assertFalse(divide_chemical_expression(\n            \"6/2CO2 + H2O\", \"2H2O+9/6CO2\"), 2)\n\n\nclass Test_Render_Equations(unittest.TestCase):\n    \"\"\"\n    Tests to validate the HTML rendering of plaintext (input) equations\n    \"\"\"\n    # pylint: disable=line-too-long\n    def test_render1(self):\n        test_string = \"H2O + CO2\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sub>2</sub>O+CO<sub>2</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_uncorrect_reaction(self):\n        test_string = \"O2C + OH2\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">O<sub>2</sub>C+OH<sub>2</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render2(self):\n        test_string = \"CO2 + H2O + Fe(OH)3\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">CO<sub>2</sub>+H<sub>2</sub>O+Fe(OH)<sub>3</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render3(self):\n        test_string = \"3H2O + 2CO2\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">3H<sub>2</sub>O+2CO<sub>2</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render4(self):\n        test_string = \"H^+ + OH^-\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sup>+</sup>+OH<sup>-</sup></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render5(self):\n        test_string = \"Fe(OH)^2- + (OH)^-\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">Fe(OH)<sup>2-</sup>+(OH)<sup>-</sup></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render6(self):\n        test_string = \"7/2H^+ + 3/5OH^-\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\"><sup>7</sup>&frasl;<sub>2</sub>H<sup>+</sup>+<sup>3</sup>&frasl;<sub>5</sub>OH<sup>-</sup></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render7(self):\n        test_string = \"5(H1H212)^70010- + 2H2O + 7/2HCl + H2O\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">5(H<sub>1</sub>H<sub>212</sub>)<sup>70010-</sup>+2H<sub>2</sub>O+<sup>7</sup>&frasl;<sub>2</sub>HCl+H<sub>2</sub>O</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render8(self):\n        test_string = \"H2O(s) + CO2\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sub>2</sub>O(s)+CO<sub>2</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render9(self):\n        test_string = \"5[Ni(NH3)4]^2+ + 5/2SO4^2-\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">5[Ni(NH<sub>3</sub>)<sub>4</sub>]<sup>2+</sup>+<sup>5</sup>&frasl;<sub>2</sub>SO<sub>4</sub><sup>2-</sup></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_error(self):\n        test_string = \"5.2H20\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\"><span class=\"inline-error inline\">5.2H20</span></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_simple_brackets(self):\n        test_string = \"(Ar)\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">(Ar)</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_eq1(self):\n        test_string = \"H^+ + OH^- -> H2O\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sup>+</sup>+OH<sup>-</sup>\\u2192H<sub>2</sub>O</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_eq2(self):\n        test_string = \"H^+ + OH^- <-> H2O\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sup>+</sup>+OH<sup>-</sup>\\u2194H<sub>2</sub>O</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_eq3(self):\n        test_string = \"H^+ + OH^- <= H2O\"   # unsupported arrow\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\"><span class=\"inline-error inline\">H^+ + OH^- <= H2O</span></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n\nclass Test_Crystallography_Miller(unittest.TestCase):\n    \"\"\"Tests  for crystallography grade function.\"\"\"\n    # pylint: disable=line-too-long\n    def test_empty_points(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": []}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_only_one_point(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.50\", \"0.00\", \"0.00\"]]}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_only_two_points(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.50\", \"0.00\", \"0.00\"], [\"0.00\", \"0.50\", \"0.00\"]]}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_1(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.50\", \"0.00\", \"0.00\"], [\"0.00\", \"0.50\", \"0.00\"], [\"0.00\", \"0.00\", \"0.50\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_2(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.00\"], [\"0.00\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,1,1)', 'lattice': 'bcc'}))\n\n    def test_3(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.50\", \"1.00\"], [\"1.00\", \"1.00\", \"0.50\"], [\"0.50\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_4(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.33\", \"1.00\", \"0.00\"], [\"0.00\", \"0.664\", \"0.00\"], [\"0.00\", \"1.00\", \"0.33\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(-3, 3, -3)', 'lattice': 'bcc'}))\n\n    def test_5(self):\n        \"\"\" return true only in case points coordinates are exact.\n        But if they transform to closest 0.05 value it is not true\"\"\"\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.33\", \"1.00\", \"0.00\"], [\"0.00\", \"0.33\", \"0.00\"], [\"0.00\", \"1.00\", \"0.33\"]]}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(-6,3,-6)', 'lattice': 'bcc'}))\n\n    def test_6(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.25\", \"0.00\"], [\"0.25\", \"0.00\", \"0.00\"], [\"0.00\", \"0.00\", \"0.25\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(4,4,4)', 'lattice': 'bcc'}))\n\n    def test_7(self):  # goes throug origin\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"1.00\", \"0.00\"], [\"1.00\", \"0.00\", \"0.00\"], [\"0.50\", \"1.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,0,-1)', 'lattice': 'bcc'}))\n\n    def test_8(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"1.00\", \"0.50\"], [\"1.00\", \"0.00\", \"0.50\"], [\"0.50\", \"1.00\", \"0.50\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,0,2)', 'lattice': 'bcc'}))\n\n    def test_9(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"1.00\"], [\"0.00\", \"1.00\", \"1.00\"], [\"1.00\", \"0.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,1,0)', 'lattice': 'bcc'}))\n\n    def test_10(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"1.00\"], [\"0.00\", \"0.00\", \"0.00\"], [\"0.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,1,-1)', 'lattice': 'bcc'}))\n\n    def test_11(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.50\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"1.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,1,2)', 'lattice': 'bcc'}))\n\n    def test_12(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.50\"], [\"0.00\", \"0.00\", \"0.50\"], [\"1.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,1,-2)', 'lattice': 'bcc'}))\n\n    def test_13(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.50\", \"0.00\", \"0.00\"], [\"0.50\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(2,0,1)', 'lattice': 'bcc'}))\n\n    def test_14(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"], [\"0.50\", \"1.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(2,-1,0)', 'lattice': 'bcc'}))\n\n    def test_15(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,-1,1)', 'lattice': 'bcc'}))\n\n    def test_16(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.00\"], [\"0.00\", \"1.00\", \"0.00\"], [\"1.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,1,-1)', 'lattice': 'bcc'}))\n\n    def test_17(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"0.00\", \"1.00\"], [\"1.00\", \"1.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(-1,1,1)', 'lattice': 'bcc'}))\n\n    def test_18(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,-1,1)', 'lattice': 'bcc'}))\n\n    def test_19(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(-1,1,0)', 'lattice': 'bcc'}))\n\n    def test_20(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,0,1)', 'lattice': 'bcc'}))\n\n    def test_21(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"0.00\", \"1.00\", \"0.00\"], [\"1.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(-1,0,1)', 'lattice': 'bcc'}))\n\n    def test_22(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"1.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,1,1)', 'lattice': 'bcc'}))\n\n    def test_23(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,-1,1)', 'lattice': 'bcc'}))\n\n    def test_24(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.66\", \"0.00\", \"0.00\"], [\"0.00\", \"0.66\", \"0.00\"], [\"0.00\", \"0.00\", \"0.66\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(3,3,3)', 'lattice': 'bcc'}))\n\n    def test_25(self):\n        user_input = u'{\"lattice\":\"\",\"points\":[[\"0.00\",\"0.00\",\"0.01\"],[\"1.00\",\"1.00\",\"0.01\"],[\"0.00\",\"1.00\",\"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,-1,1)', 'lattice': ''}))\n\n    def test_26(self):\n        user_input = u'{\"lattice\":\"\",\"points\":[[\"0.00\",\"0.01\",\"0.00\"],[\"1.00\",\"0.00\",\"0.00\"],[\"0.00\",\"0.00\",\"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,-1,0)', 'lattice': ''}))\n\n    def test_27(self):\n        \"\"\" rounding to 0.35\"\"\"\n        user_input = u'{\"lattice\":\"\",\"points\":[[\"0.33\",\"0.00\",\"0.00\"],[\"0.00\",\"0.33\",\"0.00\"],[\"0.00\",\"0.00\",\"0.33\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(3,3,3)', 'lattice': ''}))\n\n    def test_28(self):\n        \"\"\" rounding to 0.30\"\"\"\n        user_input = u'{\"lattice\":\"\",\"points\":[[\"0.30\",\"0.00\",\"0.00\"],[\"0.00\",\"0.30\",\"0.00\"],[\"0.00\",\"0.00\",\"0.30\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(10,10,10)', 'lattice': ''}))\n\n    def test_wrong_lattice(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"1.00\"]]}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(3,3,3)', 'lattice': 'fcc'}))\n\n\ndef suite():\n\n    testcases = [Test_Compare_Expressions,\n                 Test_Divide_Expressions,\n                 Test_Render_Equations,\n                 Test_Crystallography_Miller]\n    suites = []\n    for testcase in testcases:\n        suites.append(unittest.TestLoader().loadTestsFromTestCase(testcase))\n    return unittest.TestSuite(suites)\n\nif __name__ == \"__main__\":\n    LOCAL_DEBUG = True\n    with codecs.open('render.html', 'w', encoding='utf-8') as f:\n        unittest.TextTestRunner(verbosity=2).run(suite())\n    # open render.html to look at rendered equations\n", "from setuptools import setup\n\nsetup(\n    name=\"chem\",\n    version=\"0.1.1\",\n    packages=[\"chem\"],\n    install_requires=[\n        \"pyparsing==2.0.7\",\n        \"numpy==1.6.2\",\n        \"scipy==0.14.0\",\n        \"nltk==2.0.6\",\n    ],\n)\n"], "fixing_code": ["from __future__ import division\n\nfrom fractions import Fraction\n\nimport markupsafe\nimport nltk\nfrom nltk.tree import Tree\nfrom pyparsing import Literal, OneOrMore, ParseException, StringEnd\n\n\nARROWS = ('<->', '->')\n\n## Defines a simple pyparsing tokenizer for chemical equations\nelements = ['Ac', 'Ag', 'Al', 'Am', 'Ar', 'As', 'At', 'Au', 'B', 'Ba', 'Be',\n            'Bh', 'Bi', 'Bk', 'Br', 'C', 'Ca', 'Cd', 'Ce', 'Cf', 'Cl', 'Cm',\n            'Cn', 'Co', 'Cr', 'Cs', 'Cu', 'Db', 'Ds', 'Dy', 'Er', 'Es', 'Eu',\n            'F', 'Fe', 'Fl', 'Fm', 'Fr', 'Ga', 'Gd', 'Ge', 'H', 'He', 'Hf',\n            'Hg', 'Ho', 'Hs', 'I', 'In', 'Ir', 'K', 'Kr', 'La', 'Li', 'Lr',\n            'Lu', 'Lv', 'Md', 'Mg', 'Mn', 'Mo', 'Mt', 'N', 'Na', 'Nb', 'Nd',\n            'Ne', 'Ni', 'No', 'Np', 'O', 'Os', 'P', 'Pa', 'Pb', 'Pd', 'Pm',\n            'Po', 'Pr', 'Pt', 'Pu', 'Ra', 'Rb', 'Re', 'Rf', 'Rg', 'Rh', 'Rn',\n            'Ru', 'S', 'Sb', 'Sc', 'Se', 'Sg', 'Si', 'Sm', 'Sn', 'Sr', 'Ta',\n            'Tb', 'Tc', 'Te', 'Th', 'Ti', 'Tl', 'Tm', 'U', 'Uuo', 'Uup',\n            'Uus', 'Uut', 'V', 'W', 'Xe', 'Y', 'Yb', 'Zn', 'Zr']\ndigits = map(str, range(10))\nsymbols = list(\"[](){}^+-/\")\nphases = [\"(s)\", \"(l)\", \"(g)\", \"(aq)\"]\ntokens = reduce(lambda a, b: a ^ b, map(Literal, elements + digits + symbols + phases))\ntokenizer = OneOrMore(tokens) + StringEnd()\n\n# HTML, Text are temporarily copied from openedx.core.djangolib.markup\n# These libraries need to be moved out of edx-platform to be used by\n# other applications.\n# See LEARNER-5853 for more details.\nText = markupsafe.escape                        # pylint: disable=invalid-name\n\n\ndef HTML(html):                                 # pylint: disable=invalid-name\n    return markupsafe.Markup(html)\n\n\ndef _orjoin(l):\n    return \"'\" + \"' | '\".join(l) + \"'\"\n\n## Defines an NLTK parser for tokenized expressions\ngrammar = \"\"\"\n  S -> multimolecule | multimolecule '+' S\n  multimolecule -> count molecule | molecule\n  count -> number | number '/' number\n  molecule -> unphased | unphased phase\n  unphased -> group | paren_group_round | paren_group_square\n  element -> \"\"\" + _orjoin(elements) + \"\"\"\n  digit -> \"\"\" + _orjoin(digits) + \"\"\"\n  phase -> \"\"\" + _orjoin(phases) + \"\"\"\n  number -> digit | digit number\n  group -> suffixed | suffixed group\n  paren_group_round -> '(' group ')'\n  paren_group_square -> '[' group ']'\n  plus_minus -> '+' | '-'\n  number_suffix -> number\n  ion_suffix -> '^' number plus_minus | '^' plus_minus\n  suffix -> number_suffix | number_suffix ion_suffix | ion_suffix\n  unsuffixed -> element | paren_group_round | paren_group_square\n\n  suffixed -> unsuffixed | unsuffixed suffix\n\"\"\"\nparser = nltk.ChartParser(nltk.parse_cfg(grammar))\n\n\ndef _clean_parse_tree(tree):\n    ''' The parse tree contains a lot of redundant\n    nodes. E.g. paren_groups have groups as children, etc. This will\n    clean up the tree.\n    '''\n    def unparse_number(n):\n        ''' Go from a number parse tree to a number '''\n        if len(n) == 1:\n            rv = n[0][0]\n        else:\n            rv = n[0][0] + unparse_number(n[1])\n        return rv\n\n    def null_tag(n):\n        ''' Remove a tag '''\n        return n[0]\n\n    def ion_suffix(n):\n        '''1. \"if\" part handles special case\n           2. \"else\" part is general behaviour '''\n\n        if n[1:][0].node == 'number' and n[1:][0][0][0] == '1':\n            # if suffix is explicitly 1, like ^1-\n            # strip 1, leave only sign: ^-\n            return nltk.tree.Tree(n.node, n[2:])\n        else:\n            return nltk.tree.Tree(n.node, n[1:])\n\n    dispatch = {'number': lambda x: nltk.tree.Tree(\"number\", [unparse_number(x)]),\n                'unphased': null_tag,\n                'unsuffixed': null_tag,\n                'number_suffix': lambda x: nltk.tree.Tree('number_suffix', [unparse_number(x[0])]),\n                'suffixed': lambda x: len(x) > 1 and x or x[0],\n                'ion_suffix': ion_suffix,\n                'paren_group_square': lambda x: nltk.tree.Tree(x.node, x[1]),\n                'paren_group_round': lambda x: nltk.tree.Tree(x.node, x[1])}\n\n    if isinstance(tree, str):\n        return tree\n\n    old_node = None\n    ## This loop means that if a node is processed, and returns a child,\n    ## the child will be processed.\n    while tree.node in dispatch and tree.node != old_node:\n        old_node = tree.node\n        tree = dispatch[tree.node](tree)\n\n    children = []\n    for child in tree:\n        child = _clean_parse_tree(child)\n        children.append(child)\n\n    tree = nltk.tree.Tree(tree.node, children)\n\n    return tree\n\n\ndef _merge_children(tree, tags):\n    ''' nltk, by documentation, cannot do arbitrary length\n    groups. Instead of:\n    (group 1 2 3 4)\n    It has to handle this recursively:\n    (group 1 (group 2 (group 3 (group 4))))\n    We do the cleanup of converting from the latter to the former.\n    '''\n    if tree is None:\n        # There was a problem--shouldn't have empty trees (NOTE: see this with input e.g. 'H2O(', or 'Xe+').\n        # Haven't grokked the code to tell if this is indeed the right thing to do.\n        raise ParseException(\"Shouldn't have empty trees\")\n\n    if isinstance(tree, str):\n        return tree\n\n    merged_children = []\n    done = False\n    #print '00000', tree\n    ## Merge current tag\n    while not done:\n        done = True\n        for child in tree:\n            if isinstance(child, nltk.tree.Tree) and child.node == tree.node and tree.node in tags:\n                merged_children = merged_children + list(child)\n                done = False\n            else:\n                merged_children = merged_children + [child]\n        tree = nltk.tree.Tree(tree.node, merged_children)\n        merged_children = []\n    #print '======',tree\n\n    # And recurse\n    children = []\n    for child in tree:\n        children.append(_merge_children(child, tags))\n\n    #return tree\n    return nltk.tree.Tree(tree.node, children)\n\n\ndef _render_to_html(tree):\n    ''' Renders a cleaned tree to HTML '''\n\n    def molecule_count(tree, children):\n        # If an integer, return that integer\n        if len(tree) == 1:\n            return tree[0][0]\n        # If a fraction, return the fraction\n        if len(tree) == 3:\n            return HTML(\" <sup>{num}</sup>&frasl;<sub>{den}</sub> \").format(num=tree[0][0], den=tree[2][0])\n        return \"Error\"\n\n    def subscript(tree, children):\n        return HTML(\"<sub>{sub}</sub>\").format(sub=children)\n\n    def superscript(tree, children):\n        return HTML(\"<sup>{sup}</sup>\").format(sup=children)\n\n    def round_brackets(tree, children):\n        return HTML(\"({insider})\").format(insider=children)\n\n    def square_brackets(tree, children):\n        return HTML(\"[{insider}]\").format(insider=children)\n\n    dispatch = {'count': molecule_count,\n                'number_suffix': subscript,\n                'ion_suffix': superscript,\n                'paren_group_round': round_brackets,\n                'paren_group_square': square_brackets}\n\n    if isinstance(tree, str):\n        return tree\n    else:\n        children = HTML(\"\").join(map(_render_to_html, tree))\n        if tree.node in dispatch:\n            return dispatch[tree.node](tree, children)\n        else:\n            return children.replace(' ', '')\n\n\ndef render_to_html(eq):\n    '''\n    Render a chemical equation string to html.\n\n    Renders each molecule separately, and returns invalid input wrapped in a <span>.\n    '''\n    def err(s):\n        \"Render as an error span\"\n        return HTML('<span class=\"inline-error inline\">{0}</span>').format(s)\n\n    def render_arrow(arrow):\n        \"\"\"Turn text arrows into pretty ones\"\"\"\n        if arrow == '->':\n            return HTML(u'\\u2192')\n        if arrow == '<->':\n            return HTML(u'\\u2194')\n\n        # this won't be reached unless we add more arrow types, but keep it to avoid explosions when\n        # that happens. HTML-escape this unknown arrow just in case.\n        return Text(arrow)\n\n    def render_expression(ex):\n        \"\"\"\n        Render a chemical expression--no arrows.\n        \"\"\"\n        try:\n            return _render_to_html(_get_final_tree(ex))\n        except ParseException:\n            return err(ex)\n\n    def spanify(s):\n        return HTML(u'<span class=\"math\">{0}</span>').format(s)\n\n    left, arrow, right = split_on_arrow(eq)\n    if arrow == '':\n        # only one side\n        return spanify(render_expression(left))\n\n    return spanify(render_expression(left) + render_arrow(arrow) + render_expression(right))\n\n\ndef _get_final_tree(s):\n    '''\n    Return final tree after merge and clean.\n\n    Raises pyparsing.ParseException if s is invalid.\n    '''\n    tokenized = tokenizer.parseString(s)\n    parsed = parser.parse(tokenized)\n    merged = _merge_children(parsed, {'S', 'group'})\n    final = _clean_parse_tree(merged)\n    return final\n\n\ndef _check_equality(tuple1, tuple2):\n    ''' return True if tuples of multimolecules are equal '''\n    list1 = list(tuple1)\n    list2 = list(tuple2)\n\n    # Hypo: trees where are levels count+molecule vs just molecule\n    # cannot be sorted properly (tested on test_complex_additivity)\n    # But without factors and phases sorting seems to work.\n\n    # Also for lists of multimolecules without factors and phases\n    # sorting seems to work fine.\n    list1.sort()\n    list2.sort()\n    return list1 == list2\n\n\ndef compare_chemical_expression(s1, s2, ignore_state=False):\n    ''' It does comparison between two expressions.\n        It uses divide_chemical_expression and check if division is 1\n    '''\n    return divide_chemical_expression(s1, s2, ignore_state) == 1\n\n\ndef divide_chemical_expression(s1, s2, ignore_state=False):\n    '''Compare two chemical expressions for equivalence up to a multiplicative factor:\n\n    - If they are not the same chemicals, returns False.\n    - If they are the same, \"divide\" s1 by s2 to returns a factor x such that s1 / s2 == x as a Fraction object.\n    - if ignore_state is True, ignores phases when doing the comparison.\n\n    Examples:\n    divide_chemical_expression(\"H2O\", \"3H2O\") -> Fraction(1,3)\n    divide_chemical_expression(\"3H2O\", \"H2O\") -> 3  # actually Fraction(3, 1), but compares == to 3.\n    divide_chemical_expression(\"2H2O(s) + 2CO2\", \"H2O(s)+CO2\") -> 2\n    divide_chemical_expression(\"H2O(s) + CO2\", \"3H2O(s)+2CO2\") -> False\n\n    Implementation sketch:\n        - extract factors and phases to standalone lists,\n        - compare expressions without factors and phases,\n        - divide lists of factors for each other and check\n             for equality of every element in list,\n        - return result of factor division\n\n    '''\n\n    # parsed final trees\n    treedic = {}\n    treedic['1'] = _get_final_tree(s1)\n    treedic['2'] = _get_final_tree(s2)\n\n    # strip phases and factors\n    # collect factors in list\n    for i in ('1', '2'):\n        treedic[i + ' cleaned_mm_list'] = []\n        treedic[i + ' factors'] = []\n        treedic[i + ' phases'] = []\n        for el in treedic[i].subtrees(filter=lambda t: t.node == 'multimolecule'):\n            count_subtree = [t for t in el.subtrees() if t.node == 'count']\n            group_subtree = [t for t in el.subtrees() if t.node == 'group']\n            phase_subtree = [t for t in el.subtrees() if t.node == 'phase']\n            if count_subtree:\n                if len(count_subtree[0]) > 1:\n                    treedic[i + ' factors'].append(\n                        int(count_subtree[0][0][0]) /\n                        int(count_subtree[0][2][0]))\n                else:\n                    treedic[i + ' factors'].append(int(count_subtree[0][0][0]))\n            else:\n                treedic[i + ' factors'].append(1.0)\n            if phase_subtree:\n                treedic[i + ' phases'].append(phase_subtree[0][0])\n            else:\n                treedic[i + ' phases'].append(' ')\n            treedic[i + ' cleaned_mm_list'].append(\n                Tree('multimolecule', [Tree('molecule', group_subtree)]))\n\n    # order of factors and phases must mirror the order of multimolecules,\n    # use 'decorate, sort, undecorate' pattern\n    treedic['1 cleaned_mm_list'], treedic['1 factors'], treedic['1 phases'] = zip(\n        *sorted(zip(treedic['1 cleaned_mm_list'], treedic['1 factors'], treedic['1 phases'])))\n\n    treedic['2 cleaned_mm_list'], treedic['2 factors'], treedic['2 phases'] = zip(\n        *sorted(zip(treedic['2 cleaned_mm_list'], treedic['2 factors'], treedic['2 phases'])))\n\n    # check if expressions are correct without factors\n    if not _check_equality(treedic['1 cleaned_mm_list'], treedic['2 cleaned_mm_list']):\n        return False\n\n    # phases are ruled by ingore_state flag\n    if not ignore_state:  # phases matters\n        if treedic['1 phases'] != treedic['2 phases']:\n            return False\n\n    if any(\n        [\n            x / y - treedic['1 factors'][0] / treedic['2 factors'][0]\n            for (x, y) in zip(treedic['1 factors'], treedic['2 factors'])\n        ]\n    ):\n        # factors are not proportional\n        return False\n    else:\n        # return ratio\n        return Fraction(treedic['1 factors'][0] / treedic['2 factors'][0])\n\n\ndef split_on_arrow(eq):\n    \"\"\"\n    Split a string on an arrow.  Returns left, arrow, right.  If there is no arrow, returns the\n    entire eq in left, and '' in arrow and right.\n\n    Return left, arrow, right.\n    \"\"\"\n    # order matters -- need to try <-> first\n    for arrow in ARROWS:\n        left, a, right = eq.partition(arrow)\n        if a != '':\n            return left, a, right\n\n    return eq, '', ''\n\n\ndef chemical_equations_equal(eq1, eq2, exact=False):\n    \"\"\"\n    Check whether two chemical equations are the same.  (equations have arrows)\n\n    If exact is False, then they are considered equal if they differ by a\n    constant factor.\n\n    arrows matter: -> and <-> are different.\n\n    e.g.\n    chemical_equations_equal('H2 + O2 -> H2O2', 'O2 + H2 -> H2O2') -> True\n    chemical_equations_equal('H2 + O2 -> H2O2', 'O2 + 2H2 -> H2O2') -> False\n\n    chemical_equations_equal('H2 + O2 -> H2O2', 'O2 + H2 <-> H2O2') -> False\n\n    chemical_equations_equal('H2 + O2 -> H2O2', '2 H2 + 2 O2 -> 2 H2O2') -> True\n    chemical_equations_equal('H2 + O2 -> H2O2', '2 H2 + 2 O2 -> 2 H2O2', exact=True) -> False\n\n\n    If there's a syntax error, we return False.\n    \"\"\"\n\n    left1, arrow1, right1 = split_on_arrow(eq1)\n    left2, arrow2, right2 = split_on_arrow(eq2)\n\n    if arrow1 == '' or arrow2 == '':\n        return False\n\n    # TODO: may want to be able to give student helpful feedback about why things didn't work.\n    if arrow1 != arrow2:\n        # arrows don't match\n        return False\n\n    try:\n        factor_left = divide_chemical_expression(left1, left2)\n        if not factor_left:\n            # left sides don't match\n            return False\n\n        factor_right = divide_chemical_expression(right1, right2)\n        if not factor_right:\n            # right sides don't match\n            return False\n\n        if factor_left != factor_right:\n            # factors don't match (molecule counts to add up)\n            return False\n\n        if exact and factor_left != 1:\n            # want an exact match.\n            return False\n\n        return True\n    except ParseException:\n        # Don't want external users to have to deal with parsing exceptions.  Just return False.\n        return False\n", "import codecs\nimport unittest\nfrom fractions import Fraction\n\nimport chem.miller\n\nfrom .chemcalc import chemical_equations_equal, compare_chemical_expression, divide_chemical_expression, render_to_html\n\nLOCAL_DEBUG = None\n\n\ndef log(msg, output_type=None):\n    \"\"\"Logging function for tests\"\"\"\n    if LOCAL_DEBUG:\n        print msg\n        if output_type == 'html':\n            f.write(msg + '\\n<br>\\n')\n\n\nclass Test_Compare_Equations(unittest.TestCase):\n    def test_simple_equation(self):\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 'O2 + H2 -> H2O2'))\n        # left sides don't match\n        self.assertFalse(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                  'O2 + 2H2 -> H2O2'))\n        # right sides don't match\n        self.assertFalse(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                  'O2 + H2 -> H2O'))\n\n        # factors don't match\n        self.assertFalse(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                  'O2 + H2 -> 2H2O2'))\n\n    def test_different_factor(self):\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 '2O2 + 2H2 -> 2H2O2'))\n\n        self.assertFalse(\n            chemical_equations_equal(\n                '2H2 + O2 -> H2O2',\n                '2O2 + 2H2 -> 2H2O2',\n            )\n        )\n\n    def test_different_arrows(self):\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 '2O2 + 2H2 -> 2H2O2'))\n\n        self.assertFalse(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                  'O2 + H2 <-> 2H2O2'))\n\n    def test_exact_match(self):\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 '2O2 + 2H2 -> 2H2O2'))\n\n        self.assertFalse(\n            chemical_equations_equal(\n                'H2 + O2 -> H2O2',\n                '2O2 + 2H2 -> 2H2O2',\n                exact=True,\n            )\n        )\n\n        # order still doesn't matter\n        self.assertTrue(chemical_equations_equal('H2 + O2 -> H2O2',\n                                                 'O2 + H2 -> H2O2', exact=True))\n\n    def test_syntax_errors(self):\n        self.assertFalse(chemical_equations_equal('H2 + O2 a-> H2O2',\n                                                  '2O2 + 2H2 -> 2H2O2'))\n\n        self.assertFalse(chemical_equations_equal('H2O( -> H2O2',\n                                                  'H2O -> H2O2'))\n\n        self.assertFalse(chemical_equations_equal('H2 + O2 ==> H2O2',   # strange arrow\n                                                  '2O2 + 2H2 -> 2H2O2'))\n\n\nclass Test_Compare_Expressions(unittest.TestCase):\n\n    def test_compare_incorrect_order_of_atoms_in_molecule(self):\n        self.assertFalse(compare_chemical_expression(\"H2O + CO2\", \"O2C + OH2\"))\n\n    def test_compare_same_order_no_phases_no_factors_no_ions(self):\n        self.assertTrue(compare_chemical_expression(\"H2O + CO2\", \"CO2+H2O\"))\n\n    def test_compare_different_order_no_phases_no_factors_no_ions(self):\n        self.assertTrue(compare_chemical_expression(\"H2O + CO2\", \"CO2 + H2O\"))\n\n    def test_compare_different_order_three_multimolecule(self):\n        self.assertTrue(compare_chemical_expression(\"H2O + Fe(OH)3 +  CO2\", \"CO2 + H2O + Fe(OH)3\"))\n\n    def test_compare_same_factors(self):\n        self.assertTrue(compare_chemical_expression(\"3H2O +  2CO2\", \"2CO2 + 3H2O \"))\n\n    def test_compare_different_factors(self):\n        self.assertFalse(compare_chemical_expression(\"2H2O +  3CO2\", \"2CO2 + 3H2O \"))\n\n    def test_compare_correct_ions(self):\n        self.assertTrue(compare_chemical_expression(\"H^+ + OH^-\", \" OH^- + H^+ \"))\n\n    def test_compare_wrong_ions(self):\n        self.assertFalse(compare_chemical_expression(\"H^+ + OH^-\", \" OH^- + H^- \"))\n\n    def test_compare_parent_groups_ions(self):\n        self.assertTrue(compare_chemical_expression(\"Fe(OH)^2- + (OH)^-\", \" (OH)^- + Fe(OH)^2- \"))\n\n    def test_compare_correct_factors_ions_and_one(self):\n        self.assertTrue(compare_chemical_expression(\"3H^+ + 2OH^-\", \" 2OH^- + 3H^+ \"))\n\n    def test_compare_wrong_factors_ions(self):\n        self.assertFalse(compare_chemical_expression(\"2H^+ + 3OH^-\", \" 2OH^- + 3H^+ \"))\n\n    def test_compare_float_factors(self):\n        self.assertTrue(compare_chemical_expression(\"7/2H^+ + 3/5OH^-\", \" 3/5OH^- + 7/2H^+ \"))\n\n    # Phases tests\n    def test_compare_phases_ignored(self):\n        self.assertTrue(compare_chemical_expression(\n            \"H2O(s) + CO2\", \"H2O+CO2\", ignore_state=True))\n\n    def test_compare_phases_not_ignored_explicitly(self):\n        self.assertFalse(compare_chemical_expression(\n            \"H2O(s) + CO2\", \"H2O+CO2\", ignore_state=False))\n\n    def test_compare_phases_not_ignored(self):  # same as previous\n        self.assertFalse(compare_chemical_expression(\n            \"H2O(s) + CO2\", \"H2O+CO2\"))\n\n    # all in one cases\n    def test_complex_additivity(self):\n        self.assertTrue(compare_chemical_expression(\n            \"5(H1H212)^70010- + 2H20 + 7/2HCl + H2O\",\n            \"7/2HCl + 2H20 + H2O + 5(H1H212)^70010-\"))\n\n    def test_complex_additivity_wrong(self):\n        self.assertFalse(compare_chemical_expression(\n            \"5(H1H212)^70010- + 2H20 + 7/2HCl + H2O\",\n            \"2H20 + 7/2HCl + H2O + 5(H1H212)^70011-\"))\n\n    def test_complex_all_grammar(self):\n        self.assertTrue(compare_chemical_expression(\n            \"5[Ni(NH3)4]^2+ + 5/2SO4^2-\",\n            \"5/2SO4^2- + 5[Ni(NH3)4]^2+\"))\n\n    # special cases\n\n    def test_compare_one_superscript_explicitly_set(self):\n        self.assertTrue(compare_chemical_expression(\"H^+ + OH^1-\", \" OH^- + H^+ \"))\n\n    def test_compare_equal_factors_differently_set(self):\n        self.assertTrue(compare_chemical_expression(\"6/2H^+ + OH^-\", \" OH^- + 3H^+ \"))\n\n    def test_compare_one_subscript_explicitly_set(self):\n        self.assertFalse(compare_chemical_expression(\"H2 + CO2\", \"H2 + C102\"))\n\n\nclass Test_Divide_Expressions(unittest.TestCase):\n    ''' as compare_ use divide_,\n    tests here must consider different\n    division (not equality) cases '''\n\n    def test_divide_by_zero(self):\n        self.assertFalse(divide_chemical_expression(\n            \"0H2O\", \"H2O\"))\n\n    def test_divide_wrong_factors(self):\n        self.assertFalse(divide_chemical_expression(\n            \"5(H1H212)^70010- + 10H2O\", \"5H2O + 10(H1H212)^70010-\"))\n\n    def test_divide_right(self):\n        self.assertEqual(divide_chemical_expression(\n            \"5(H1H212)^70010- + 10H2O\", \"10H2O + 5(H1H212)^70010-\"), 1)\n\n    def test_divide_wrong_reagents(self):\n        self.assertFalse(divide_chemical_expression(\n            \"H2O + CO2\", \"CO2\"))\n\n    def test_divide_right_simple(self):\n        self.assertEqual(divide_chemical_expression(\n            \"H2O + CO2\", \"H2O+CO2\"), 1)\n\n    def test_divide_right_phases(self):\n        self.assertEqual(divide_chemical_expression(\n            \"H2O(s) + CO2\", \"2H2O(s)+2CO2\"), Fraction(1, 2))\n\n    def test_divide_right_phases_other_order(self):\n        self.assertEqual(divide_chemical_expression(\n            \"2H2O(s) + 2CO2\", \"H2O(s)+CO2\"), 2)\n\n    def test_divide_wrong_phases(self):\n        self.assertFalse(divide_chemical_expression(\n            \"H2O(s) + CO2\", \"2H2O+2CO2(s)\"))\n\n    def test_divide_wrong_phases_but_phases_ignored(self):\n        self.assertEqual(divide_chemical_expression(\n            \"H2O(s) + CO2\", \"2H2O+2CO2(s)\", ignore_state=True), Fraction(1, 2))\n\n    def test_divide_order(self):\n        self.assertEqual(divide_chemical_expression(\n            \"2CO2 + H2O\", \"2H2O+4CO2\"), Fraction(1, 2))\n\n    def test_divide_fract_to_int(self):\n        self.assertEqual(divide_chemical_expression(\n            \"3/2CO2 + H2O\", \"2H2O+3CO2\"), Fraction(1, 2))\n\n    def test_divide_fract_to_frac(self):\n        self.assertEqual(divide_chemical_expression(\n            \"3/4CO2 + H2O\", \"2H2O+9/6CO2\"), Fraction(1, 2))\n\n    def test_divide_fract_to_frac_wrog(self):\n        self.assertFalse(divide_chemical_expression(\n            \"6/2CO2 + H2O\", \"2H2O+9/6CO2\"), 2)\n\n\nclass Test_Render_Equations(unittest.TestCase):\n    \"\"\"\n    Tests to validate the HTML rendering of plaintext (input) equations\n    \"\"\"\n    # pylint: disable=line-too-long\n    def test_render1(self):\n        test_string = \"H2O + CO2\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sub>2</sub>O+CO<sub>2</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_uncorrect_reaction(self):\n        test_string = \"O2C + OH2\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">O<sub>2</sub>C+OH<sub>2</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render2(self):\n        test_string = \"CO2 + H2O + Fe(OH)3\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">CO<sub>2</sub>+H<sub>2</sub>O+Fe(OH)<sub>3</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render3(self):\n        test_string = \"3H2O + 2CO2\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">3H<sub>2</sub>O+2CO<sub>2</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render4(self):\n        test_string = \"H^+ + OH^-\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sup>+</sup>+OH<sup>-</sup></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render5(self):\n        test_string = \"Fe(OH)^2- + (OH)^-\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">Fe(OH)<sup>2-</sup>+(OH)<sup>-</sup></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render6(self):\n        test_string = \"7/2H^+ + 3/5OH^-\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\"><sup>7</sup>&frasl;<sub>2</sub>H<sup>+</sup>+<sup>3</sup>&frasl;<sub>5</sub>OH<sup>-</sup></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render7(self):\n        test_string = \"5(H1H212)^70010- + 2H2O + 7/2HCl + H2O\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">5(H<sub>1</sub>H<sub>212</sub>)<sup>70010-</sup>+2H<sub>2</sub>O+<sup>7</sup>&frasl;<sub>2</sub>HCl+H<sub>2</sub>O</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render8(self):\n        test_string = \"H2O(s) + CO2\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sub>2</sub>O(s)+CO<sub>2</sub></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render9(self):\n        test_string = \"5[Ni(NH3)4]^2+ + 5/2SO4^2-\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">5[Ni(NH<sub>3</sub>)<sub>4</sub>]<sup>2+</sup>+<sup>5</sup>&frasl;<sub>2</sub>SO<sub>4</sub><sup>2-</sup></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_error(self):\n        test_string = \"5.2H20\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\"><span class=\"inline-error inline\">5.2H20</span></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_simple_round_brackets(self):\n        test_string = \"(Ar)\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">(Ar)</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_simple_square_brackets(self):\n        test_string = \"[Ar]\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">[Ar]</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_eq1(self):\n        test_string = \"H^+ + OH^- -> H2O\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sup>+</sup>+OH<sup>-</sup>\\u2192H<sub>2</sub>O</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_eq2(self):\n        test_string = \"H^+ + OH^- <-> H2O\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">H<sup>+</sup>+OH<sup>-</sup>\\u2194H<sub>2</sub>O</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_eq3(self):\n        test_string = \"H^+ + OH^- <= H2O\"   # unsupported arrow\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\"><span class=\"inline-error inline\">H^+ + OH^- &lt;= H2O</span></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_render_eq4(self):\n        test_string = \"[H^+] + OH^- <-> (H2O)\"  # with brackets\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\">[H<sup>+</sup>]+OH<sup>-</sup>\\u2194(H<sub>2</sub>O)</span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n    def test_escaping(self):\n        \"\"\"\n        Tests that invalid input is escaped.\n        \"\"\"\n        test_string = \"<script>f()</script>\"\n        out = render_to_html(test_string)\n        correct = u'<span class=\"math\"><span class=\"inline-error inline\">&lt;script&gt;f()&lt;/script&gt;</span></span>'\n        log(out + ' ------- ' + correct, 'html')\n        self.assertEqual(out, correct)\n\n\nclass Test_Crystallography_Miller(unittest.TestCase):\n    \"\"\"Tests  for crystallography grade function.\"\"\"\n    # pylint: disable=line-too-long\n    def test_empty_points(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": []}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_only_one_point(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.50\", \"0.00\", \"0.00\"]]}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_only_two_points(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.50\", \"0.00\", \"0.00\"], [\"0.00\", \"0.50\", \"0.00\"]]}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_1(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.50\", \"0.00\", \"0.00\"], [\"0.00\", \"0.50\", \"0.00\"], [\"0.00\", \"0.00\", \"0.50\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_2(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.00\"], [\"0.00\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,1,1)', 'lattice': 'bcc'}))\n\n    def test_3(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.50\", \"1.00\"], [\"1.00\", \"1.00\", \"0.50\"], [\"0.50\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(2,2,2)', 'lattice': 'bcc'}))\n\n    def test_4(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.33\", \"1.00\", \"0.00\"], [\"0.00\", \"0.664\", \"0.00\"], [\"0.00\", \"1.00\", \"0.33\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(-3, 3, -3)', 'lattice': 'bcc'}))\n\n    def test_5(self):\n        \"\"\" return true only in case points coordinates are exact.\n        But if they transform to closest 0.05 value it is not true\"\"\"\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.33\", \"1.00\", \"0.00\"], [\"0.00\", \"0.33\", \"0.00\"], [\"0.00\", \"1.00\", \"0.33\"]]}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(-6,3,-6)', 'lattice': 'bcc'}))\n\n    def test_6(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.25\", \"0.00\"], [\"0.25\", \"0.00\", \"0.00\"], [\"0.00\", \"0.00\", \"0.25\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(4,4,4)', 'lattice': 'bcc'}))\n\n    def test_7(self):  # goes throug origin\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"1.00\", \"0.00\"], [\"1.00\", \"0.00\", \"0.00\"], [\"0.50\", \"1.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,0,-1)', 'lattice': 'bcc'}))\n\n    def test_8(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"1.00\", \"0.50\"], [\"1.00\", \"0.00\", \"0.50\"], [\"0.50\", \"1.00\", \"0.50\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,0,2)', 'lattice': 'bcc'}))\n\n    def test_9(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"1.00\"], [\"0.00\", \"1.00\", \"1.00\"], [\"1.00\", \"0.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,1,0)', 'lattice': 'bcc'}))\n\n    def test_10(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"1.00\"], [\"0.00\", \"0.00\", \"0.00\"], [\"0.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,1,-1)', 'lattice': 'bcc'}))\n\n    def test_11(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.50\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"1.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,1,2)', 'lattice': 'bcc'}))\n\n    def test_12(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.50\"], [\"0.00\", \"0.00\", \"0.50\"], [\"1.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,1,-2)', 'lattice': 'bcc'}))\n\n    def test_13(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.50\", \"0.00\", \"0.00\"], [\"0.50\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(2,0,1)', 'lattice': 'bcc'}))\n\n    def test_14(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"], [\"0.50\", \"1.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(2,-1,0)', 'lattice': 'bcc'}))\n\n    def test_15(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,-1,1)', 'lattice': 'bcc'}))\n\n    def test_16(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.00\"], [\"0.00\", \"1.00\", \"0.00\"], [\"1.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,1,-1)', 'lattice': 'bcc'}))\n\n    def test_17(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"0.00\", \"1.00\"], [\"1.00\", \"1.00\", \"0.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(-1,1,1)', 'lattice': 'bcc'}))\n\n    def test_18(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,-1,1)', 'lattice': 'bcc'}))\n\n    def test_19(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(-1,1,0)', 'lattice': 'bcc'}))\n\n    def test_20(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"1.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,0,1)', 'lattice': 'bcc'}))\n\n    def test_21(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"0.00\", \"1.00\", \"0.00\"], [\"1.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(-1,0,1)', 'lattice': 'bcc'}))\n\n    def test_22(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"1.00\", \"0.00\"], [\"1.00\", \"1.00\", \"0.00\"], [\"0.00\", \"0.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,1,1)', 'lattice': 'bcc'}))\n\n    def test_23(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,-1,1)', 'lattice': 'bcc'}))\n\n    def test_24(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.66\", \"0.00\", \"0.00\"], [\"0.00\", \"0.66\", \"0.00\"], [\"0.00\", \"0.00\", \"0.66\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(3,3,3)', 'lattice': 'bcc'}))\n\n    def test_25(self):\n        user_input = u'{\"lattice\":\"\",\"points\":[[\"0.00\",\"0.00\",\"0.01\"],[\"1.00\",\"1.00\",\"0.01\"],[\"0.00\",\"1.00\",\"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(1,-1,1)', 'lattice': ''}))\n\n    def test_26(self):\n        user_input = u'{\"lattice\":\"\",\"points\":[[\"0.00\",\"0.01\",\"0.00\"],[\"1.00\",\"0.00\",\"0.00\"],[\"0.00\",\"0.00\",\"1.00\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(0,-1,0)', 'lattice': ''}))\n\n    def test_27(self):\n        \"\"\" rounding to 0.35\"\"\"\n        user_input = u'{\"lattice\":\"\",\"points\":[[\"0.33\",\"0.00\",\"0.00\"],[\"0.00\",\"0.33\",\"0.00\"],[\"0.00\",\"0.00\",\"0.33\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(3,3,3)', 'lattice': ''}))\n\n    def test_28(self):\n        \"\"\" rounding to 0.30\"\"\"\n        user_input = u'{\"lattice\":\"\",\"points\":[[\"0.30\",\"0.00\",\"0.00\"],[\"0.00\",\"0.30\",\"0.00\"],[\"0.00\",\"0.00\",\"0.30\"]]}'\n        self.assertTrue(chem.miller.grade(user_input, {'miller': '(10,10,10)', 'lattice': ''}))\n\n    def test_wrong_lattice(self):\n        user_input = '{\"lattice\": \"bcc\", \"points\": [[\"0.00\", \"0.00\", \"0.00\"], [\"1.00\", \"0.00\", \"0.00\"], [\"1.00\", \"1.00\", \"1.00\"]]}'\n        self.assertFalse(chem.miller.grade(user_input, {'miller': '(3,3,3)', 'lattice': 'fcc'}))\n\n\ndef suite():\n\n    testcases = [Test_Compare_Expressions,\n                 Test_Divide_Expressions,\n                 Test_Render_Equations,\n                 Test_Crystallography_Miller]\n    suites = []\n    for testcase in testcases:\n        suites.append(unittest.TestLoader().loadTestsFromTestCase(testcase))\n    return unittest.TestSuite(suites)\n\nif __name__ == \"__main__\":\n    LOCAL_DEBUG = True\n    with codecs.open('render.html', 'w', encoding='utf-8') as f:\n        unittest.TextTestRunner(verbosity=2).run(suite())\n    # open render.html to look at rendered equations\n", "from setuptools import setup\n\nsetup(\n    name=\"chem\",\n    version=\"0.2.0-ginkgo\",\n    packages=[\"chem\"],\n    install_requires=[\n        \"pyparsing==2.0.7\",\n        \"numpy==1.6.2\",\n        \"scipy==0.14.0\",\n        \"nltk==2.0.6\",\n        \"markupsafe\",  # Should be replaced by other utilities. See LEARNER-5853 for more details.\n    ],\n)\n"], "filenames": ["common/lib/chem/chem/chemcalc.py", "common/lib/chem/chem/tests.py", "common/lib/chem/setup.py"], "buggy_code_start_loc": [4, 299, 5], "buggy_code_end_loc": [228, 324, 11], "fixing_code_start_loc": [5, 299, 5], "fixing_code_end_loc": [240, 348, 13], "type": "CWE-79", "message": "edx-platform before 2018-07-18 allows XSS via a response to a Chemical Equation advanced problem.", "other": {"cve": {"id": "CVE-2018-20859", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-30T19:15:12.967", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "edx-platform before 2018-07-18 allows XSS via a response to a Chemical Equation advanced problem."}, {"lang": "es", "value": "La plataforma edx antes del 18-07-2018, permite ataques de tipo XSS por medio de una respuesta a un problema avanzado de una Ecuaci\u00f3n de Qu\u00edmica."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:edx:edx-platform:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-07-18", "matchCriteriaId": "DC642DE7-C56B-4822-A004-7B488D65554F"}]}]}], "references": [{"url": "https://github.com/edx/edx-platform/commit/5b144559fbdba7ff673cc1c165aa2d343e07b6bd.patch", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#!topic/openedx-announce/wsm5mtUhhME", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://patch-diff.githubusercontent.com/raw/edx/edx-platform/pull/18639.patch", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/edx/edx-platform/commit/5b144559fbdba7ff673cc1c165aa2d343e07b6bd.patch"}}