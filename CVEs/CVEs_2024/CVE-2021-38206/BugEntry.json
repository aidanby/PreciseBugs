{"buggy_code": ["/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * mac80211 <-> driver interface\n *\n * Copyright 2002-2005, Devicescape Software, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n * Copyright 2007-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright (C) 2015 - 2017 Intel Deutschland GmbH\n * Copyright (C) 2018 - 2020 Intel Corporation\n */\n\n#ifndef MAC80211_H\n#define MAC80211_H\n\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/ieee80211.h>\n#include <net/cfg80211.h>\n#include <net/codel.h>\n#include <net/ieee80211_radiotap.h>\n#include <asm/unaligned.h>\n\n/**\n * DOC: Introduction\n *\n * mac80211 is the Linux stack for 802.11 hardware that implements\n * only partial functionality in hard- or firmware. This document\n * defines the interface between mac80211 and low-level hardware\n * drivers.\n */\n\n/**\n * DOC: Calling mac80211 from interrupts\n *\n * Only ieee80211_tx_status_irqsafe() and ieee80211_rx_irqsafe() can be\n * called in hardware interrupt context. The low-level driver must not call any\n * other functions in hardware interrupt context. If there is a need for such\n * call, the low-level driver should first ACK the interrupt and perform the\n * IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even\n * tasklet function.\n *\n * NOTE: If the driver opts to use the _irqsafe() functions, it may not also\n *\t use the non-IRQ-safe functions!\n */\n\n/**\n * DOC: Warning\n *\n * If you're reading this document and not the header file itself, it will\n * be incomplete because not all documentation has been converted yet.\n */\n\n/**\n * DOC: Frame format\n *\n * As a general rule, when frames are passed between mac80211 and the driver,\n * they start with the IEEE 802.11 header and include the same octets that are\n * sent over the air except for the FCS which should be calculated by the\n * hardware.\n *\n * There are, however, various exceptions to this rule for advanced features:\n *\n * The first exception is for hardware encryption and decryption offload\n * where the IV/ICV may or may not be generated in hardware.\n *\n * Secondly, when the hardware handles fragmentation, the frame handed to\n * the driver from mac80211 is the MSDU, not the MPDU.\n */\n\n/**\n * DOC: mac80211 workqueue\n *\n * mac80211 provides its own workqueue for drivers and internal mac80211 use.\n * The workqueue is a single threaded workqueue and can only be accessed by\n * helpers for sanity checking. Drivers must ensure all work added onto the\n * mac80211 workqueue should be cancelled on the driver stop() callback.\n *\n * mac80211 will flushed the workqueue upon interface removal and during\n * suspend.\n *\n * All work performed on the mac80211 workqueue must not acquire the RTNL lock.\n *\n */\n\n/**\n * DOC: mac80211 software tx queueing\n *\n * mac80211 provides an optional intermediate queueing implementation designed\n * to allow the driver to keep hardware queues short and provide some fairness\n * between different stations/interfaces.\n * In this model, the driver pulls data frames from the mac80211 queue instead\n * of letting mac80211 push them via drv_tx().\n * Other frames (e.g. control or management) are still pushed using drv_tx().\n *\n * Drivers indicate that they use this model by implementing the .wake_tx_queue\n * driver operation.\n *\n * Intermediate queues (struct ieee80211_txq) are kept per-sta per-tid, with\n * another per-sta for non-data/non-mgmt and bufferable management frames, and\n * a single per-vif queue for multicast data frames.\n *\n * The driver is expected to initialize its private per-queue data for stations\n * and interfaces in the .add_interface and .sta_add ops.\n *\n * The driver can't access the queue directly. To dequeue a frame from a\n * txq, it calls ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a\n * queue, it calls the .wake_tx_queue driver op.\n *\n * Drivers can optionally delegate responsibility for scheduling queues to\n * mac80211, to take advantage of airtime fairness accounting. In this case, to\n * obtain the next queue to pull frames from, the driver calls\n * ieee80211_next_txq(). The driver is then expected to return the txq using\n * ieee80211_return_txq().\n *\n * For AP powersave TIM handling, the driver only needs to indicate if it has\n * buffered packets in the driver specific data structures by calling\n * ieee80211_sta_set_buffered(). For frames buffered in the ieee80211_txq\n * struct, mac80211 sets the appropriate TIM PVB bits and calls\n * .release_buffered_frames().\n * In that callback the driver is therefore expected to release its own\n * buffered frames and afterwards also frames from the ieee80211_txq (obtained\n * via the usual ieee80211_tx_dequeue).\n */\n\nstruct device;\n\n/**\n * enum ieee80211_max_queues - maximum number of queues\n *\n * @IEEE80211_MAX_QUEUES: Maximum number of regular device queues.\n * @IEEE80211_MAX_QUEUE_MAP: bitmap with maximum queues set\n */\nenum ieee80211_max_queues {\n\tIEEE80211_MAX_QUEUES =\t\t16,\n\tIEEE80211_MAX_QUEUE_MAP =\tBIT(IEEE80211_MAX_QUEUES) - 1,\n};\n\n#define IEEE80211_INVAL_HW_QUEUE\t0xff\n\n/**\n * enum ieee80211_ac_numbers - AC numbers as used in mac80211\n * @IEEE80211_AC_VO: voice\n * @IEEE80211_AC_VI: video\n * @IEEE80211_AC_BE: best effort\n * @IEEE80211_AC_BK: background\n */\nenum ieee80211_ac_numbers {\n\tIEEE80211_AC_VO\t\t= 0,\n\tIEEE80211_AC_VI\t\t= 1,\n\tIEEE80211_AC_BE\t\t= 2,\n\tIEEE80211_AC_BK\t\t= 3,\n};\n\n/**\n * struct ieee80211_tx_queue_params - transmit queue configuration\n *\n * The information provided in this structure is required for QoS\n * transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.\n *\n * @aifs: arbitration interframe space [0..255]\n * @cw_min: minimum contention window [a value of the form\n *\t2^n-1 in the range 1..32767]\n * @cw_max: maximum contention window [like @cw_min]\n * @txop: maximum burst time in units of 32 usecs, 0 meaning disabled\n * @acm: is mandatory admission control required for the access category\n * @uapsd: is U-APSD mode enabled for the queue\n * @mu_edca: is the MU EDCA configured\n * @mu_edca_param_rec: MU EDCA Parameter Record for HE\n */\nstruct ieee80211_tx_queue_params {\n\tu16 txop;\n\tu16 cw_min;\n\tu16 cw_max;\n\tu8 aifs;\n\tbool acm;\n\tbool uapsd;\n\tbool mu_edca;\n\tstruct ieee80211_he_mu_edca_param_ac_rec mu_edca_param_rec;\n};\n\nstruct ieee80211_low_level_stats {\n\tunsigned int dot11ACKFailureCount;\n\tunsigned int dot11RTSFailureCount;\n\tunsigned int dot11FCSErrorCount;\n\tunsigned int dot11RTSSuccessCount;\n};\n\n/**\n * enum ieee80211_chanctx_change - change flag for channel context\n * @IEEE80211_CHANCTX_CHANGE_WIDTH: The channel width changed\n * @IEEE80211_CHANCTX_CHANGE_RX_CHAINS: The number of RX chains changed\n * @IEEE80211_CHANCTX_CHANGE_RADAR: radar detection flag changed\n * @IEEE80211_CHANCTX_CHANGE_CHANNEL: switched to another operating channel,\n *\tthis is used only with channel switching with CSA\n * @IEEE80211_CHANCTX_CHANGE_MIN_WIDTH: The min required channel width changed\n */\nenum ieee80211_chanctx_change {\n\tIEEE80211_CHANCTX_CHANGE_WIDTH\t\t= BIT(0),\n\tIEEE80211_CHANCTX_CHANGE_RX_CHAINS\t= BIT(1),\n\tIEEE80211_CHANCTX_CHANGE_RADAR\t\t= BIT(2),\n\tIEEE80211_CHANCTX_CHANGE_CHANNEL\t= BIT(3),\n\tIEEE80211_CHANCTX_CHANGE_MIN_WIDTH\t= BIT(4),\n};\n\n/**\n * struct ieee80211_chanctx_conf - channel context that vifs may be tuned to\n *\n * This is the driver-visible part. The ieee80211_chanctx\n * that contains it is visible in mac80211 only.\n *\n * @def: the channel definition\n * @min_def: the minimum channel definition currently required.\n * @rx_chains_static: The number of RX chains that must always be\n *\tactive on the channel to receive MIMO transmissions\n * @rx_chains_dynamic: The number of RX chains that must be enabled\n *\tafter RTS/CTS handshake to receive SMPS MIMO transmissions;\n *\tthis will always be >= @rx_chains_static.\n * @radar_enabled: whether radar detection is enabled on this channel.\n * @drv_priv: data area for driver use, will always be aligned to\n *\tsizeof(void *), size is determined in hw information.\n */\nstruct ieee80211_chanctx_conf {\n\tstruct cfg80211_chan_def def;\n\tstruct cfg80211_chan_def min_def;\n\n\tu8 rx_chains_static, rx_chains_dynamic;\n\n\tbool radar_enabled;\n\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n/**\n * enum ieee80211_chanctx_switch_mode - channel context switch mode\n * @CHANCTX_SWMODE_REASSIGN_VIF: Both old and new contexts already\n *\texist (and will continue to exist), but the virtual interface\n *\tneeds to be switched from one to the other.\n * @CHANCTX_SWMODE_SWAP_CONTEXTS: The old context exists but will stop\n *      to exist with this call, the new context doesn't exist but\n *      will be active after this call, the virtual interface switches\n *      from the old to the new (note that the driver may of course\n *      implement this as an on-the-fly chandef switch of the existing\n *      hardware context, but the mac80211 pointer for the old context\n *      will cease to exist and only the new one will later be used\n *      for changes/removal.)\n */\nenum ieee80211_chanctx_switch_mode {\n\tCHANCTX_SWMODE_REASSIGN_VIF,\n\tCHANCTX_SWMODE_SWAP_CONTEXTS,\n};\n\n/**\n * struct ieee80211_vif_chanctx_switch - vif chanctx switch information\n *\n * This is structure is used to pass information about a vif that\n * needs to switch from one chanctx to another.  The\n * &ieee80211_chanctx_switch_mode defines how the switch should be\n * done.\n *\n * @vif: the vif that should be switched from old_ctx to new_ctx\n * @old_ctx: the old context to which the vif was assigned\n * @new_ctx: the new context to which the vif must be assigned\n */\nstruct ieee80211_vif_chanctx_switch {\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_chanctx_conf *old_ctx;\n\tstruct ieee80211_chanctx_conf *new_ctx;\n};\n\n/**\n * enum ieee80211_bss_change - BSS change notification flags\n *\n * These flags are used with the bss_info_changed() callback\n * to indicate which BSS parameter changed.\n *\n * @BSS_CHANGED_ASSOC: association status changed (associated/disassociated),\n *\talso implies a change in the AID.\n * @BSS_CHANGED_ERP_CTS_PROT: CTS protection changed\n * @BSS_CHANGED_ERP_PREAMBLE: preamble changed\n * @BSS_CHANGED_ERP_SLOT: slot timing changed\n * @BSS_CHANGED_HT: 802.11n parameters changed\n * @BSS_CHANGED_BASIC_RATES: Basic rateset changed\n * @BSS_CHANGED_BEACON_INT: Beacon interval changed\n * @BSS_CHANGED_BSSID: BSSID changed, for whatever\n *\treason (IBSS and managed mode)\n * @BSS_CHANGED_BEACON: Beacon data changed, retrieve\n *\tnew beacon (beaconing modes)\n * @BSS_CHANGED_BEACON_ENABLED: Beaconing should be\n *\tenabled/disabled (beaconing modes)\n * @BSS_CHANGED_CQM: Connection quality monitor config changed\n * @BSS_CHANGED_IBSS: IBSS join status changed\n * @BSS_CHANGED_ARP_FILTER: Hardware ARP filter address list or state changed.\n * @BSS_CHANGED_QOS: QoS for this association was enabled/disabled. Note\n *\tthat it is only ever disabled for station mode.\n * @BSS_CHANGED_IDLE: Idle changed for this BSS/interface.\n * @BSS_CHANGED_SSID: SSID changed for this BSS (AP and IBSS mode)\n * @BSS_CHANGED_AP_PROBE_RESP: Probe Response changed for this BSS (AP mode)\n * @BSS_CHANGED_PS: PS changed for this BSS (STA mode)\n * @BSS_CHANGED_TXPOWER: TX power setting changed for this interface\n * @BSS_CHANGED_P2P_PS: P2P powersave settings (CTWindow, opportunistic PS)\n *\tchanged\n * @BSS_CHANGED_BEACON_INFO: Data from the AP's beacon became available:\n *\tcurrently dtim_period only is under consideration.\n * @BSS_CHANGED_BANDWIDTH: The bandwidth used by this interface changed,\n *\tnote that this is only called when it changes after the channel\n *\tcontext had been assigned.\n * @BSS_CHANGED_OCB: OCB join status changed\n * @BSS_CHANGED_MU_GROUPS: VHT MU-MIMO group id or user position changed\n * @BSS_CHANGED_KEEP_ALIVE: keep alive options (idle period or protected\n *\tkeep alive) changed.\n * @BSS_CHANGED_MCAST_RATE: Multicast Rate setting changed for this interface\n * @BSS_CHANGED_FTM_RESPONDER: fine timing measurement request responder\n *\tfunctionality changed for this BSS (AP mode).\n * @BSS_CHANGED_TWT: TWT status changed\n * @BSS_CHANGED_HE_OBSS_PD: OBSS Packet Detection status changed.\n * @BSS_CHANGED_HE_BSS_COLOR: BSS Color has changed\n * @BSS_CHANGED_FILS_DISCOVERY: FILS discovery status changed.\n * @BSS_CHANGED_UNSOL_BCAST_PROBE_RESP: Unsolicited broadcast probe response\n *\tstatus changed.\n *\n */\nenum ieee80211_bss_change {\n\tBSS_CHANGED_ASSOC\t\t= 1<<0,\n\tBSS_CHANGED_ERP_CTS_PROT\t= 1<<1,\n\tBSS_CHANGED_ERP_PREAMBLE\t= 1<<2,\n\tBSS_CHANGED_ERP_SLOT\t\t= 1<<3,\n\tBSS_CHANGED_HT\t\t\t= 1<<4,\n\tBSS_CHANGED_BASIC_RATES\t\t= 1<<5,\n\tBSS_CHANGED_BEACON_INT\t\t= 1<<6,\n\tBSS_CHANGED_BSSID\t\t= 1<<7,\n\tBSS_CHANGED_BEACON\t\t= 1<<8,\n\tBSS_CHANGED_BEACON_ENABLED\t= 1<<9,\n\tBSS_CHANGED_CQM\t\t\t= 1<<10,\n\tBSS_CHANGED_IBSS\t\t= 1<<11,\n\tBSS_CHANGED_ARP_FILTER\t\t= 1<<12,\n\tBSS_CHANGED_QOS\t\t\t= 1<<13,\n\tBSS_CHANGED_IDLE\t\t= 1<<14,\n\tBSS_CHANGED_SSID\t\t= 1<<15,\n\tBSS_CHANGED_AP_PROBE_RESP\t= 1<<16,\n\tBSS_CHANGED_PS\t\t\t= 1<<17,\n\tBSS_CHANGED_TXPOWER\t\t= 1<<18,\n\tBSS_CHANGED_P2P_PS\t\t= 1<<19,\n\tBSS_CHANGED_BEACON_INFO\t\t= 1<<20,\n\tBSS_CHANGED_BANDWIDTH\t\t= 1<<21,\n\tBSS_CHANGED_OCB                 = 1<<22,\n\tBSS_CHANGED_MU_GROUPS\t\t= 1<<23,\n\tBSS_CHANGED_KEEP_ALIVE\t\t= 1<<24,\n\tBSS_CHANGED_MCAST_RATE\t\t= 1<<25,\n\tBSS_CHANGED_FTM_RESPONDER\t= 1<<26,\n\tBSS_CHANGED_TWT\t\t\t= 1<<27,\n\tBSS_CHANGED_HE_OBSS_PD\t\t= 1<<28,\n\tBSS_CHANGED_HE_BSS_COLOR\t= 1<<29,\n\tBSS_CHANGED_FILS_DISCOVERY      = 1<<30,\n\tBSS_CHANGED_UNSOL_BCAST_PROBE_RESP = 1<<31,\n\n\t/* when adding here, make sure to change ieee80211_reconfig */\n};\n\n/*\n * The maximum number of IPv4 addresses listed for ARP filtering. If the number\n * of addresses for an interface increase beyond this value, hardware ARP\n * filtering will be disabled.\n */\n#define IEEE80211_BSS_ARP_ADDR_LIST_LEN 4\n\n/**\n * enum ieee80211_event_type - event to be notified to the low level driver\n * @RSSI_EVENT: AP's rssi crossed the a threshold set by the driver.\n * @MLME_EVENT: event related to MLME\n * @BAR_RX_EVENT: a BAR was received\n * @BA_FRAME_TIMEOUT: Frames were released from the reordering buffer because\n *\tthey timed out. This won't be called for each frame released, but only\n *\tonce each time the timeout triggers.\n */\nenum ieee80211_event_type {\n\tRSSI_EVENT,\n\tMLME_EVENT,\n\tBAR_RX_EVENT,\n\tBA_FRAME_TIMEOUT,\n};\n\n/**\n * enum ieee80211_rssi_event_data - relevant when event type is %RSSI_EVENT\n * @RSSI_EVENT_HIGH: AP's rssi went below the threshold set by the driver.\n * @RSSI_EVENT_LOW: AP's rssi went above the threshold set by the driver.\n */\nenum ieee80211_rssi_event_data {\n\tRSSI_EVENT_HIGH,\n\tRSSI_EVENT_LOW,\n};\n\n/**\n * struct ieee80211_rssi_event - data attached to an %RSSI_EVENT\n * @data: See &enum ieee80211_rssi_event_data\n */\nstruct ieee80211_rssi_event {\n\tenum ieee80211_rssi_event_data data;\n};\n\n/**\n * enum ieee80211_mlme_event_data - relevant when event type is %MLME_EVENT\n * @AUTH_EVENT: the MLME operation is authentication\n * @ASSOC_EVENT: the MLME operation is association\n * @DEAUTH_RX_EVENT: deauth received..\n * @DEAUTH_TX_EVENT: deauth sent.\n */\nenum ieee80211_mlme_event_data {\n\tAUTH_EVENT,\n\tASSOC_EVENT,\n\tDEAUTH_RX_EVENT,\n\tDEAUTH_TX_EVENT,\n};\n\n/**\n * enum ieee80211_mlme_event_status - relevant when event type is %MLME_EVENT\n * @MLME_SUCCESS: the MLME operation completed successfully.\n * @MLME_DENIED: the MLME operation was denied by the peer.\n * @MLME_TIMEOUT: the MLME operation timed out.\n */\nenum ieee80211_mlme_event_status {\n\tMLME_SUCCESS,\n\tMLME_DENIED,\n\tMLME_TIMEOUT,\n};\n\n/**\n * struct ieee80211_mlme_event - data attached to an %MLME_EVENT\n * @data: See &enum ieee80211_mlme_event_data\n * @status: See &enum ieee80211_mlme_event_status\n * @reason: the reason code if applicable\n */\nstruct ieee80211_mlme_event {\n\tenum ieee80211_mlme_event_data data;\n\tenum ieee80211_mlme_event_status status;\n\tu16 reason;\n};\n\n/**\n * struct ieee80211_ba_event - data attached for BlockAck related events\n * @sta: pointer to the &ieee80211_sta to which this event relates\n * @tid: the tid\n * @ssn: the starting sequence number (for %BAR_RX_EVENT)\n */\nstruct ieee80211_ba_event {\n\tstruct ieee80211_sta *sta;\n\tu16 tid;\n\tu16 ssn;\n};\n\n/**\n * struct ieee80211_event - event to be sent to the driver\n * @type: The event itself. See &enum ieee80211_event_type.\n * @rssi: relevant if &type is %RSSI_EVENT\n * @mlme: relevant if &type is %AUTH_EVENT\n * @ba: relevant if &type is %BAR_RX_EVENT or %BA_FRAME_TIMEOUT\n * @u:union holding the fields above\n */\nstruct ieee80211_event {\n\tenum ieee80211_event_type type;\n\tunion {\n\t\tstruct ieee80211_rssi_event rssi;\n\t\tstruct ieee80211_mlme_event mlme;\n\t\tstruct ieee80211_ba_event ba;\n\t} u;\n};\n\n/**\n * struct ieee80211_mu_group_data - STA's VHT MU-MIMO group data\n *\n * This structure describes the group id data of VHT MU-MIMO\n *\n * @membership: 64 bits array - a bit is set if station is member of the group\n * @position: 2 bits per group id indicating the position in the group\n */\nstruct ieee80211_mu_group_data {\n\tu8 membership[WLAN_MEMBERSHIP_LEN];\n\tu8 position[WLAN_USER_POSITION_LEN];\n};\n\n/**\n * struct ieee80211_ftm_responder_params - FTM responder parameters\n *\n * @lci: LCI subelement content\n * @civicloc: CIVIC location subelement content\n * @lci_len: LCI data length\n * @civicloc_len: Civic data length\n */\nstruct ieee80211_ftm_responder_params {\n\tconst u8 *lci;\n\tconst u8 *civicloc;\n\tsize_t lci_len;\n\tsize_t civicloc_len;\n};\n\n/**\n * struct ieee80211_fils_discovery - FILS discovery parameters from\n * IEEE Std 802.11ai-2016, Annex C.3 MIB detail.\n *\n * @min_interval: Minimum packet interval in TUs (0 - 10000)\n * @max_interval: Maximum packet interval in TUs (0 - 10000)\n */\nstruct ieee80211_fils_discovery {\n\tu32 min_interval;\n\tu32 max_interval;\n};\n\n/**\n * struct ieee80211_bss_conf - holds the BSS's changing parameters\n *\n * This structure keeps information about a BSS (and an association\n * to that BSS) that can change during the lifetime of the BSS.\n *\n * @htc_trig_based_pkt_ext: default PE in 4us units, if BSS supports HE\n * @multi_sta_back_32bit: supports BA bitmap of 32-bits in Multi-STA BACK\n * @uora_exists: is the UORA element advertised by AP\n * @ack_enabled: indicates support to receive a multi-TID that solicits either\n *\tACK, BACK or both\n * @uora_ocw_range: UORA element's OCW Range field\n * @frame_time_rts_th: HE duration RTS threshold, in units of 32us\n * @he_support: does this BSS support HE\n * @twt_requester: does this BSS support TWT requester (relevant for managed\n *\tmode only, set if the AP advertises TWT responder role)\n * @twt_responder: does this BSS support TWT requester (relevant for managed\n *\tmode only, set if the AP advertises TWT responder role)\n * @twt_protected: does this BSS support protected TWT frames\n * @assoc: association status\n * @ibss_joined: indicates whether this station is part of an IBSS\n *\tor not\n * @ibss_creator: indicates if a new IBSS network is being created\n * @aid: association ID number, valid only when @assoc is true\n * @use_cts_prot: use CTS protection\n * @use_short_preamble: use 802.11b short preamble\n * @use_short_slot: use short slot time (only relevant for ERP)\n * @dtim_period: num of beacons before the next DTIM, for beaconing,\n *\tvalid in station mode only if after the driver was notified\n *\twith the %BSS_CHANGED_BEACON_INFO flag, will be non-zero then.\n * @sync_tsf: last beacon's/probe response's TSF timestamp (could be old\n *\tas it may have been received during scanning long ago). If the\n *\tHW flag %IEEE80211_HW_TIMING_BEACON_ONLY is set, then this can\n *\tonly come from a beacon, but might not become valid until after\n *\tassociation when a beacon is received (which is notified with the\n *\t%BSS_CHANGED_DTIM flag.). See also sync_dtim_count important notice.\n * @sync_device_ts: the device timestamp corresponding to the sync_tsf,\n *\tthe driver/device can use this to calculate synchronisation\n *\t(see @sync_tsf). See also sync_dtim_count important notice.\n * @sync_dtim_count: Only valid when %IEEE80211_HW_TIMING_BEACON_ONLY\n *\tis requested, see @sync_tsf/@sync_device_ts.\n *\tIMPORTANT: These three sync_* parameters would possibly be out of sync\n *\tby the time the driver will use them. The synchronized view is currently\n *\tguaranteed only in certain callbacks.\n * @beacon_int: beacon interval\n * @assoc_capability: capabilities taken from assoc resp\n * @basic_rates: bitmap of basic rates, each bit stands for an\n *\tindex into the rate table configured by the driver in\n *\tthe current band.\n * @beacon_rate: associated AP's beacon TX rate\n * @mcast_rate: per-band multicast rate index + 1 (0: disabled)\n * @bssid: The BSSID for this BSS\n * @enable_beacon: whether beaconing should be enabled or not\n * @chandef: Channel definition for this BSS -- the hardware might be\n *\tconfigured a higher bandwidth than this BSS uses, for example.\n * @mu_group: VHT MU-MIMO group membership data\n * @ht_operation_mode: HT operation mode like in &struct ieee80211_ht_operation.\n *\tThis field is only valid when the channel is a wide HT/VHT channel.\n *\tNote that with TDLS this can be the case (channel is HT, protection must\n *\tbe used from this field) even when the BSS association isn't using HT.\n * @cqm_rssi_thold: Connection quality monitor RSSI threshold, a zero value\n *\timplies disabled. As with the cfg80211 callback, a change here should\n *\tcause an event to be sent indicating where the current value is in\n *\trelation to the newly configured threshold.\n * @cqm_rssi_low: Connection quality monitor RSSI lower threshold, a zero value\n *\timplies disabled.  This is an alternative mechanism to the single\n *\tthreshold event and can't be enabled simultaneously with it.\n * @cqm_rssi_high: Connection quality monitor RSSI upper threshold.\n * @cqm_rssi_hyst: Connection quality monitor RSSI hysteresis\n * @arp_addr_list: List of IPv4 addresses for hardware ARP filtering. The\n *\tmay filter ARP queries targeted for other addresses than listed here.\n *\tThe driver must allow ARP queries targeted for all address listed here\n *\tto pass through. An empty list implies no ARP queries need to pass.\n * @arp_addr_cnt: Number of addresses currently on the list. Note that this\n *\tmay be larger than %IEEE80211_BSS_ARP_ADDR_LIST_LEN (the arp_addr_list\n *\tarray size), it's up to the driver what to do in that case.\n * @qos: This is a QoS-enabled BSS.\n * @idle: This interface is idle. There's also a global idle flag in the\n *\thardware config which may be more appropriate depending on what\n *\tyour driver/device needs to do.\n * @ps: power-save mode (STA only). This flag is NOT affected by\n *\toffchannel/dynamic_ps operations.\n * @ssid: The SSID of the current vif. Valid in AP and IBSS mode.\n * @ssid_len: Length of SSID given in @ssid.\n * @hidden_ssid: The SSID of the current vif is hidden. Only valid in AP-mode.\n * @txpower: TX power in dBm.  INT_MIN means not configured.\n * @txpower_type: TX power adjustment used to control per packet Transmit\n *\tPower Control (TPC) in lower driver for the current vif. In particular\n *\tTPC is enabled if value passed in %txpower_type is\n *\tNL80211_TX_POWER_LIMITED (allow using less than specified from\n *\tuserspace), whereas TPC is disabled if %txpower_type is set to\n *\tNL80211_TX_POWER_FIXED (use value configured from userspace)\n * @p2p_noa_attr: P2P NoA attribute for P2P powersave\n * @allow_p2p_go_ps: indication for AP or P2P GO interface, whether it's allowed\n *\tto use P2P PS mechanism or not. AP/P2P GO is not allowed to use P2P PS\n *\tif it has associated clients without P2P PS support.\n * @max_idle_period: the time period during which the station can refrain from\n *\ttransmitting frames to its associated AP without being disassociated.\n *\tIn units of 1000 TUs. Zero value indicates that the AP did not include\n *\ta (valid) BSS Max Idle Period Element.\n * @protected_keep_alive: if set, indicates that the station should send an RSN\n *\tprotected frame to the AP to reset the idle timer at the AP for the\n *\tstation.\n * @ftm_responder: whether to enable or disable fine timing measurement FTM\n *\tresponder functionality.\n * @ftmr_params: configurable lci/civic parameter when enabling FTM responder.\n * @nontransmitted: this BSS is a nontransmitted BSS profile\n * @transmitter_bssid: the address of transmitter AP\n * @bssid_index: index inside the multiple BSSID set\n * @bssid_indicator: 2^bssid_indicator is the maximum number of APs in set\n * @ema_ap: AP supports enhancements of discovery and advertisement of\n *\tnontransmitted BSSIDs\n * @profile_periodicity: the least number of beacon frames need to be received\n *\tin order to discover all the nontransmitted BSSIDs in the set.\n * @he_oper: HE operation information of the BSS (AP/Mesh) or of the AP we are\n *\tconnected to (STA)\n * @he_obss_pd: OBSS Packet Detection parameters.\n * @he_bss_color: BSS coloring settings, if BSS supports HE\n * @fils_discovery: FILS discovery configuration\n * @unsol_bcast_probe_resp_interval: Unsolicited broadcast probe response\n *\tinterval.\n * @s1g: BSS is S1G BSS (affects Association Request format).\n * @beacon_tx_rate: The configured beacon transmit rate that needs to be passed\n *\tto driver when rate control is offloaded to firmware.\n */\nstruct ieee80211_bss_conf {\n\tconst u8 *bssid;\n\tu8 htc_trig_based_pkt_ext;\n\tbool uora_exists;\n\tu8 uora_ocw_range;\n\tu16 frame_time_rts_th;\n\tbool he_support;\n\tbool twt_requester;\n\tbool twt_responder;\n\tbool twt_protected;\n\t/* association related data */\n\tbool assoc, ibss_joined;\n\tbool ibss_creator;\n\tu16 aid;\n\t/* erp related data */\n\tbool use_cts_prot;\n\tbool use_short_preamble;\n\tbool use_short_slot;\n\tbool enable_beacon;\n\tu8 dtim_period;\n\tu16 beacon_int;\n\tu16 assoc_capability;\n\tu64 sync_tsf;\n\tu32 sync_device_ts;\n\tu8 sync_dtim_count;\n\tu32 basic_rates;\n\tstruct ieee80211_rate *beacon_rate;\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu16 ht_operation_mode;\n\ts32 cqm_rssi_thold;\n\tu32 cqm_rssi_hyst;\n\ts32 cqm_rssi_low;\n\ts32 cqm_rssi_high;\n\tstruct cfg80211_chan_def chandef;\n\tstruct ieee80211_mu_group_data mu_group;\n\t__be32 arp_addr_list[IEEE80211_BSS_ARP_ADDR_LIST_LEN];\n\tint arp_addr_cnt;\n\tbool qos;\n\tbool idle;\n\tbool ps;\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tsize_t ssid_len;\n\tbool hidden_ssid;\n\tint txpower;\n\tenum nl80211_tx_power_setting txpower_type;\n\tstruct ieee80211_p2p_noa_attr p2p_noa_attr;\n\tbool allow_p2p_go_ps;\n\tu16 max_idle_period;\n\tbool protected_keep_alive;\n\tbool ftm_responder;\n\tstruct ieee80211_ftm_responder_params *ftmr_params;\n\t/* Multiple BSSID data */\n\tbool nontransmitted;\n\tu8 transmitter_bssid[ETH_ALEN];\n\tu8 bssid_index;\n\tu8 bssid_indicator;\n\tbool ema_ap;\n\tu8 profile_periodicity;\n\tstruct {\n\t\tu32 params;\n\t\tu16 nss_set;\n\t} he_oper;\n\tstruct ieee80211_he_obss_pd he_obss_pd;\n\tstruct cfg80211_he_bss_color he_bss_color;\n\tstruct ieee80211_fils_discovery fils_discovery;\n\tu32 unsol_bcast_probe_resp_interval;\n\tbool s1g;\n\tstruct cfg80211_bitrate_mask beacon_tx_rate;\n};\n\n/**\n * enum mac80211_tx_info_flags - flags to describe transmission information/status\n *\n * These flags are used with the @flags member of &ieee80211_tx_info.\n *\n * @IEEE80211_TX_CTL_REQ_TX_STATUS: require TX status callback for this frame.\n * @IEEE80211_TX_CTL_ASSIGN_SEQ: The driver has to assign a sequence\n *\tnumber to this frame, taking care of not overwriting the fragment\n *\tnumber and increasing the sequence number only when the\n *\tIEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly\n *\tassign sequence numbers to QoS-data frames but cannot do so correctly\n *\tfor non-QoS-data and management frames because beacons need them from\n *\tthat counter as well and mac80211 cannot guarantee proper sequencing.\n *\tIf this flag is set, the driver should instruct the hardware to\n *\tassign a sequence number to the frame or assign one itself. Cf. IEEE\n *\t802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for\n *\tbeacons and always be clear for frames without a sequence number field.\n * @IEEE80211_TX_CTL_NO_ACK: tell the low level not to wait for an ack\n * @IEEE80211_TX_CTL_CLEAR_PS_FILT: clear powersave filter for destination\n *\tstation\n * @IEEE80211_TX_CTL_FIRST_FRAGMENT: this is a first fragment of the frame\n * @IEEE80211_TX_CTL_SEND_AFTER_DTIM: send this frame after DTIM beacon\n * @IEEE80211_TX_CTL_AMPDU: this frame should be sent as part of an A-MPDU\n * @IEEE80211_TX_CTL_INJECTED: Frame was injected, internal to mac80211.\n * @IEEE80211_TX_STAT_TX_FILTERED: The frame was not transmitted\n *\tbecause the destination STA was in powersave mode. Note that to\n *\tavoid race conditions, the filter must be set by the hardware or\n *\tfirmware upon receiving a frame that indicates that the station\n *\twent to sleep (must be done on device to filter frames already on\n *\tthe queue) and may only be unset after mac80211 gives the OK for\n *\tthat by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),\n *\tsince only then is it guaranteed that no more frames are in the\n *\thardware queue.\n * @IEEE80211_TX_STAT_ACK: Frame was acknowledged\n * @IEEE80211_TX_STAT_AMPDU: The frame was aggregated, so status\n * \tis for the whole aggregation.\n * @IEEE80211_TX_STAT_AMPDU_NO_BACK: no block ack was returned,\n * \tso consider using block ack request (BAR).\n * @IEEE80211_TX_CTL_RATE_CTRL_PROBE: internal to mac80211, can be\n *\tset by rate control algorithms to indicate probe rate, will\n *\tbe cleared for fragmented frames (except on the last fragment)\n * @IEEE80211_TX_INTFL_OFFCHAN_TX_OK: Internal to mac80211. Used to indicate\n *\tthat a frame can be transmitted while the queues are stopped for\n *\toff-channel operation.\n * @IEEE80211_TX_CTL_HW_80211_ENCAP: This frame uses hardware encapsulation\n *\t(header conversion)\n * @IEEE80211_TX_INTFL_RETRIED: completely internal to mac80211,\n *\tused to indicate that a frame was already retried due to PS\n * @IEEE80211_TX_INTFL_DONT_ENCRYPT: completely internal to mac80211,\n *\tused to indicate frame should not be encrypted\n * @IEEE80211_TX_CTL_NO_PS_BUFFER: This frame is a response to a poll\n *\tframe (PS-Poll or uAPSD) or a non-bufferable MMPDU and must\n *\tbe sent although the station is in powersave mode.\n * @IEEE80211_TX_CTL_MORE_FRAMES: More frames will be passed to the\n *\ttransmit function after the current frame, this can be used\n *\tby drivers to kick the DMA queue only if unset or when the\n *\tqueue gets full.\n * @IEEE80211_TX_INTFL_RETRANSMISSION: This frame is being retransmitted\n *\tafter TX status because the destination was asleep, it must not\n *\tbe modified again (no seqno assignment, crypto, etc.)\n * @IEEE80211_TX_INTFL_MLME_CONN_TX: This frame was transmitted by the MLME\n *\tcode for connection establishment, this indicates that its status\n *\tshould kick the MLME state machine.\n * @IEEE80211_TX_INTFL_NL80211_FRAME_TX: Frame was requested through nl80211\n *\tMLME command (internal to mac80211 to figure out whether to send TX\n *\tstatus to user space)\n * @IEEE80211_TX_CTL_LDPC: tells the driver to use LDPC for this frame\n * @IEEE80211_TX_CTL_STBC: Enables Space-Time Block Coding (STBC) for this\n *\tframe and selects the maximum number of streams that it can use.\n * @IEEE80211_TX_CTL_TX_OFFCHAN: Marks this packet to be transmitted on\n *\tthe off-channel channel when a remain-on-channel offload is done\n *\tin hardware -- normal packets still flow and are expected to be\n *\thandled properly by the device.\n * @IEEE80211_TX_INTFL_TKIP_MIC_FAILURE: Marks this packet to be used for TKIP\n *\ttesting. It will be sent out with incorrect Michael MIC key to allow\n *\tTKIP countermeasures to be tested.\n * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.\n *\tThis flag is actually used for management frame especially for P2P\n *\tframes not being sent at CCK rate in 2GHz band.\n * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,\n *\twhen its status is reported the service period ends. For frames in\n *\tan SP that mac80211 transmits, it is already set; for driver frames\n *\tthe driver may set this flag. It is also used to do the same for\n *\tPS-Poll responses.\n * @IEEE80211_TX_CTL_USE_MINRATE: This frame will be sent at lowest rate.\n *\tThis flag is used to send nullfunc frame at minimum rate when\n *\tthe nullfunc is used for connection monitoring purpose.\n * @IEEE80211_TX_CTL_DONTFRAG: Don't fragment this packet even if it\n *\twould be fragmented by size (this is optional, only used for\n *\tmonitor injection).\n * @IEEE80211_TX_STAT_NOACK_TRANSMITTED: A frame that was marked with\n *\tIEEE80211_TX_CTL_NO_ACK has been successfully transmitted without\n *\tany errors (like issues specific to the driver/HW).\n *\tThis flag must not be set for frames that don't request no-ack\n *\tbehaviour with IEEE80211_TX_CTL_NO_ACK.\n *\n * Note: If you have to add new flags to the enumeration, then don't\n *\t forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.\n */\nenum mac80211_tx_info_flags {\n\tIEEE80211_TX_CTL_REQ_TX_STATUS\t\t= BIT(0),\n\tIEEE80211_TX_CTL_ASSIGN_SEQ\t\t= BIT(1),\n\tIEEE80211_TX_CTL_NO_ACK\t\t\t= BIT(2),\n\tIEEE80211_TX_CTL_CLEAR_PS_FILT\t\t= BIT(3),\n\tIEEE80211_TX_CTL_FIRST_FRAGMENT\t\t= BIT(4),\n\tIEEE80211_TX_CTL_SEND_AFTER_DTIM\t= BIT(5),\n\tIEEE80211_TX_CTL_AMPDU\t\t\t= BIT(6),\n\tIEEE80211_TX_CTL_INJECTED\t\t= BIT(7),\n\tIEEE80211_TX_STAT_TX_FILTERED\t\t= BIT(8),\n\tIEEE80211_TX_STAT_ACK\t\t\t= BIT(9),\n\tIEEE80211_TX_STAT_AMPDU\t\t\t= BIT(10),\n\tIEEE80211_TX_STAT_AMPDU_NO_BACK\t\t= BIT(11),\n\tIEEE80211_TX_CTL_RATE_CTRL_PROBE\t= BIT(12),\n\tIEEE80211_TX_INTFL_OFFCHAN_TX_OK\t= BIT(13),\n\tIEEE80211_TX_CTL_HW_80211_ENCAP\t\t= BIT(14),\n\tIEEE80211_TX_INTFL_RETRIED\t\t= BIT(15),\n\tIEEE80211_TX_INTFL_DONT_ENCRYPT\t\t= BIT(16),\n\tIEEE80211_TX_CTL_NO_PS_BUFFER\t\t= BIT(17),\n\tIEEE80211_TX_CTL_MORE_FRAMES\t\t= BIT(18),\n\tIEEE80211_TX_INTFL_RETRANSMISSION\t= BIT(19),\n\tIEEE80211_TX_INTFL_MLME_CONN_TX\t\t= BIT(20),\n\tIEEE80211_TX_INTFL_NL80211_FRAME_TX\t= BIT(21),\n\tIEEE80211_TX_CTL_LDPC\t\t\t= BIT(22),\n\tIEEE80211_TX_CTL_STBC\t\t\t= BIT(23) | BIT(24),\n\tIEEE80211_TX_CTL_TX_OFFCHAN\t\t= BIT(25),\n\tIEEE80211_TX_INTFL_TKIP_MIC_FAILURE\t= BIT(26),\n\tIEEE80211_TX_CTL_NO_CCK_RATE\t\t= BIT(27),\n\tIEEE80211_TX_STATUS_EOSP\t\t= BIT(28),\n\tIEEE80211_TX_CTL_USE_MINRATE\t\t= BIT(29),\n\tIEEE80211_TX_CTL_DONTFRAG\t\t= BIT(30),\n\tIEEE80211_TX_STAT_NOACK_TRANSMITTED\t= BIT(31),\n};\n\n#define IEEE80211_TX_CTL_STBC_SHIFT\t\t23\n\n#define IEEE80211_TX_RC_S1G_MCS IEEE80211_TX_RC_VHT_MCS\n\n/**\n * enum mac80211_tx_control_flags - flags to describe transmit control\n *\n * @IEEE80211_TX_CTRL_PORT_CTRL_PROTO: this frame is a port control\n *\tprotocol frame (e.g. EAP)\n * @IEEE80211_TX_CTRL_PS_RESPONSE: This frame is a response to a poll\n *\tframe (PS-Poll or uAPSD).\n * @IEEE80211_TX_CTRL_RATE_INJECT: This frame is injected with rate information\n * @IEEE80211_TX_CTRL_AMSDU: This frame is an A-MSDU frame\n * @IEEE80211_TX_CTRL_FAST_XMIT: This frame is going through the fast_xmit path\n * @IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP: This frame skips mesh path lookup\n * @IEEE80211_TX_INTCFL_NEED_TXPROCESSING: completely internal to mac80211,\n *\tused to indicate that a pending frame requires TX processing before\n *\tit can be sent out.\n * @IEEE80211_TX_CTRL_NO_SEQNO: Do not overwrite the sequence number that\n *\thas already been assigned to this frame.\n * @IEEE80211_TX_CTRL_DONT_REORDER: This frame should not be reordered\n *\trelative to other frames that have this flag set, independent\n *\tof their QoS TID or other priority field values.\n *\n * These flags are used in tx_info->control.flags.\n */\nenum mac80211_tx_control_flags {\n\tIEEE80211_TX_CTRL_PORT_CTRL_PROTO\t= BIT(0),\n\tIEEE80211_TX_CTRL_PS_RESPONSE\t\t= BIT(1),\n\tIEEE80211_TX_CTRL_RATE_INJECT\t\t= BIT(2),\n\tIEEE80211_TX_CTRL_AMSDU\t\t\t= BIT(3),\n\tIEEE80211_TX_CTRL_FAST_XMIT\t\t= BIT(4),\n\tIEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP\t= BIT(5),\n\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING\t= BIT(6),\n\tIEEE80211_TX_CTRL_NO_SEQNO\t\t= BIT(7),\n\tIEEE80211_TX_CTRL_DONT_REORDER\t\t= BIT(8),\n};\n\n/*\n * This definition is used as a mask to clear all temporary flags, which are\n * set by the tx handlers for each transmission attempt by the mac80211 stack.\n */\n#define IEEE80211_TX_TEMPORARY_FLAGS (IEEE80211_TX_CTL_NO_ACK |\t\t      \\\n\tIEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT |    \\\n\tIEEE80211_TX_CTL_SEND_AFTER_DTIM | IEEE80211_TX_CTL_AMPDU |\t      \\\n\tIEEE80211_TX_STAT_TX_FILTERED |\tIEEE80211_TX_STAT_ACK |\t\t      \\\n\tIEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |\t      \\\n\tIEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \\\n\tIEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |\t\t      \\\n\tIEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)\n\n/**\n * enum mac80211_rate_control_flags - per-rate flags set by the\n *\tRate Control algorithm.\n *\n * These flags are set by the Rate control algorithm for each rate during tx,\n * in the @flags member of struct ieee80211_tx_rate.\n *\n * @IEEE80211_TX_RC_USE_RTS_CTS: Use RTS/CTS exchange for this rate.\n * @IEEE80211_TX_RC_USE_CTS_PROTECT: CTS-to-self protection is required.\n *\tThis is set if the current BSS requires ERP protection.\n * @IEEE80211_TX_RC_USE_SHORT_PREAMBLE: Use short preamble.\n * @IEEE80211_TX_RC_MCS: HT rate.\n * @IEEE80211_TX_RC_VHT_MCS: VHT MCS rate, in this case the idx field is split\n *\tinto a higher 4 bits (Nss) and lower 4 bits (MCS number)\n * @IEEE80211_TX_RC_GREEN_FIELD: Indicates whether this rate should be used in\n *\tGreenfield mode.\n * @IEEE80211_TX_RC_40_MHZ_WIDTH: Indicates if the Channel Width should be 40 MHz.\n * @IEEE80211_TX_RC_80_MHZ_WIDTH: Indicates 80 MHz transmission\n * @IEEE80211_TX_RC_160_MHZ_WIDTH: Indicates 160 MHz transmission\n *\t(80+80 isn't supported yet)\n * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the\n *\tadjacent 20 MHz channels, if the current channel type is\n *\tNL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.\n * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.\n */\nenum mac80211_rate_control_flags {\n\tIEEE80211_TX_RC_USE_RTS_CTS\t\t= BIT(0),\n\tIEEE80211_TX_RC_USE_CTS_PROTECT\t\t= BIT(1),\n\tIEEE80211_TX_RC_USE_SHORT_PREAMBLE\t= BIT(2),\n\n\t/* rate index is an HT/VHT MCS instead of an index */\n\tIEEE80211_TX_RC_MCS\t\t\t= BIT(3),\n\tIEEE80211_TX_RC_GREEN_FIELD\t\t= BIT(4),\n\tIEEE80211_TX_RC_40_MHZ_WIDTH\t\t= BIT(5),\n\tIEEE80211_TX_RC_DUP_DATA\t\t= BIT(6),\n\tIEEE80211_TX_RC_SHORT_GI\t\t= BIT(7),\n\tIEEE80211_TX_RC_VHT_MCS\t\t\t= BIT(8),\n\tIEEE80211_TX_RC_80_MHZ_WIDTH\t\t= BIT(9),\n\tIEEE80211_TX_RC_160_MHZ_WIDTH\t\t= BIT(10),\n};\n\n\n/* there are 40 bytes if you don't need the rateset to be kept */\n#define IEEE80211_TX_INFO_DRIVER_DATA_SIZE 40\n\n/* if you do need the rateset, then you have less space */\n#define IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE 24\n\n/* maximum number of rate stages */\n#define IEEE80211_TX_MAX_RATES\t4\n\n/* maximum number of rate table entries */\n#define IEEE80211_TX_RATE_TABLE_SIZE\t4\n\n/**\n * struct ieee80211_tx_rate - rate selection/status\n *\n * @idx: rate index to attempt to send with\n * @flags: rate control flags (&enum mac80211_rate_control_flags)\n * @count: number of tries in this rate before going to the next rate\n *\n * A value of -1 for @idx indicates an invalid rate and, if used\n * in an array of retry rates, that no more rates should be tried.\n *\n * When used for transmit status reporting, the driver should\n * always report the rate along with the flags it used.\n *\n * &struct ieee80211_tx_info contains an array of these structs\n * in the control information, and it will be filled by the rate\n * control algorithm according to what should be sent. For example,\n * if this array contains, in the format { <idx>, <count> } the\n * information::\n *\n *    { 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }\n *\n * then this means that the frame should be transmitted\n * up to twice at rate 3, up to twice at rate 2, and up to four\n * times at rate 1 if it doesn't get acknowledged. Say it gets\n * acknowledged by the peer after the fifth attempt, the status\n * information should then contain::\n *\n *   { 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...\n *\n * since it was transmitted twice at rate 3, twice at rate 2\n * and once at rate 1 after which we received an acknowledgement.\n */\nstruct ieee80211_tx_rate {\n\ts8 idx;\n\tu16 count:5,\n\t    flags:11;\n} __packed;\n\n#define IEEE80211_MAX_TX_RETRY\t\t31\n\nstatic inline void ieee80211_rate_set_vht(struct ieee80211_tx_rate *rate,\n\t\t\t\t\t  u8 mcs, u8 nss)\n{\n\tWARN_ON(mcs & ~0xF);\n\tWARN_ON((nss - 1) & ~0x7);\n\trate->idx = ((nss - 1) << 4) | mcs;\n}\n\nstatic inline u8\nieee80211_rate_get_vht_mcs(const struct ieee80211_tx_rate *rate)\n{\n\treturn rate->idx & 0xF;\n}\n\nstatic inline u8\nieee80211_rate_get_vht_nss(const struct ieee80211_tx_rate *rate)\n{\n\treturn (rate->idx >> 4) + 1;\n}\n\n/**\n * struct ieee80211_tx_info - skb transmit information\n *\n * This structure is placed in skb->cb for three uses:\n *  (1) mac80211 TX control - mac80211 tells the driver what to do\n *  (2) driver internal use (if applicable)\n *  (3) TX status information - driver tells mac80211 what happened\n *\n * @flags: transmit info flags, defined above\n * @band: the band to transmit on (use for checking for races)\n * @hw_queue: HW queue to put the frame on, skb_get_queue_mapping() gives the AC\n * @ack_frame_id: internal frame ID for TX status, used internally\n * @tx_time_est: TX time estimate in units of 4us, used internally\n * @control: union part for control data\n * @control.rates: TX rates array to try\n * @control.rts_cts_rate_idx: rate for RTS or CTS\n * @control.use_rts: use RTS\n * @control.use_cts_prot: use RTS/CTS\n * @control.short_preamble: use short preamble (CCK only)\n * @control.skip_table: skip externally configured rate table\n * @control.jiffies: timestamp for expiry on powersave clients\n * @control.vif: virtual interface (may be NULL)\n * @control.hw_key: key to encrypt with (may be NULL)\n * @control.flags: control flags, see &enum mac80211_tx_control_flags\n * @control.enqueue_time: enqueue time (for iTXQs)\n * @driver_rates: alias to @control.rates to reserve space\n * @pad: padding\n * @rate_driver_data: driver use area if driver needs @control.rates\n * @status: union part for status data\n * @status.rates: attempted rates\n * @status.ack_signal: ACK signal\n * @status.ampdu_ack_len: AMPDU ack length\n * @status.ampdu_len: AMPDU length\n * @status.antenna: (legacy, kept only for iwlegacy)\n * @status.tx_time: airtime consumed for transmission; note this is only\n *\tused for WMM AC, not for airtime fairness\n * @status.is_valid_ack_signal: ACK signal is valid\n * @status.status_driver_data: driver use area\n * @ack: union part for pure ACK data\n * @ack.cookie: cookie for the ACK\n * @driver_data: array of driver_data pointers\n * @ampdu_ack_len: number of acked aggregated frames.\n * \trelevant only if IEEE80211_TX_STAT_AMPDU was set.\n * @ampdu_len: number of aggregated frames.\n * \trelevant only if IEEE80211_TX_STAT_AMPDU was set.\n * @ack_signal: signal strength of the ACK frame\n */\nstruct ieee80211_tx_info {\n\t/* common information */\n\tu32 flags;\n\tu32 band:3,\n\t    ack_frame_id:13,\n\t    hw_queue:4,\n\t    tx_time_est:10;\n\t/* 2 free bits */\n\n\tunion {\n\t\tstruct {\n\t\t\tunion {\n\t\t\t\t/* rate control */\n\t\t\t\tstruct {\n\t\t\t\t\tstruct ieee80211_tx_rate rates[\n\t\t\t\t\t\tIEEE80211_TX_MAX_RATES];\n\t\t\t\t\ts8 rts_cts_rate_idx;\n\t\t\t\t\tu8 use_rts:1;\n\t\t\t\t\tu8 use_cts_prot:1;\n\t\t\t\t\tu8 short_preamble:1;\n\t\t\t\t\tu8 skip_table:1;\n\t\t\t\t\t/* 2 bytes free */\n\t\t\t\t};\n\t\t\t\t/* only needed before rate control */\n\t\t\t\tunsigned long jiffies;\n\t\t\t};\n\t\t\t/* NB: vif can be NULL for injected frames */\n\t\t\tstruct ieee80211_vif *vif;\n\t\t\tstruct ieee80211_key_conf *hw_key;\n\t\t\tu32 flags;\n\t\t\tcodel_time_t enqueue_time;\n\t\t} control;\n\t\tstruct {\n\t\t\tu64 cookie;\n\t\t} ack;\n\t\tstruct {\n\t\t\tstruct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];\n\t\t\ts32 ack_signal;\n\t\t\tu8 ampdu_ack_len;\n\t\t\tu8 ampdu_len;\n\t\t\tu8 antenna;\n\t\t\tu16 tx_time;\n\t\t\tbool is_valid_ack_signal;\n\t\t\tvoid *status_driver_data[19 / sizeof(void *)];\n\t\t} status;\n\t\tstruct {\n\t\t\tstruct ieee80211_tx_rate driver_rates[\n\t\t\t\tIEEE80211_TX_MAX_RATES];\n\t\t\tu8 pad[4];\n\n\t\t\tvoid *rate_driver_data[\n\t\t\t\tIEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE / sizeof(void *)];\n\t\t};\n\t\tvoid *driver_data[\n\t\t\tIEEE80211_TX_INFO_DRIVER_DATA_SIZE / sizeof(void *)];\n\t};\n};\n\nstatic inline u16\nieee80211_info_set_tx_time_est(struct ieee80211_tx_info *info, u16 tx_time_est)\n{\n\t/* We only have 10 bits in tx_time_est, so store airtime\n\t * in increments of 4us and clamp the maximum to 2**12-1\n\t */\n\tinfo->tx_time_est = min_t(u16, tx_time_est, 4095) >> 2;\n\treturn info->tx_time_est << 2;\n}\n\nstatic inline u16\nieee80211_info_get_tx_time_est(struct ieee80211_tx_info *info)\n{\n\treturn info->tx_time_est << 2;\n}\n\n/**\n * struct ieee80211_tx_status - extended tx status info for rate control\n *\n * @sta: Station that the packet was transmitted for\n * @info: Basic tx status information\n * @skb: Packet skb (can be NULL if not provided by the driver)\n * @rate: The TX rate that was used when sending the packet\n * @free_list: list where processed skbs are stored to be free'd by the driver\n */\nstruct ieee80211_tx_status {\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb;\n\tstruct rate_info *rate;\n\tstruct list_head *free_list;\n};\n\n/**\n * struct ieee80211_scan_ies - descriptors for different blocks of IEs\n *\n * This structure is used to point to different blocks of IEs in HW scan\n * and scheduled scan. These blocks contain the IEs passed by userspace\n * and the ones generated by mac80211.\n *\n * @ies: pointers to band specific IEs.\n * @len: lengths of band_specific IEs.\n * @common_ies: IEs for all bands (especially vendor specific ones)\n * @common_ie_len: length of the common_ies\n */\nstruct ieee80211_scan_ies {\n\tconst u8 *ies[NUM_NL80211_BANDS];\n\tsize_t len[NUM_NL80211_BANDS];\n\tconst u8 *common_ies;\n\tsize_t common_ie_len;\n};\n\n\nstatic inline struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb)\n{\n\treturn (struct ieee80211_tx_info *)skb->cb;\n}\n\nstatic inline struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb)\n{\n\treturn (struct ieee80211_rx_status *)skb->cb;\n}\n\n/**\n * ieee80211_tx_info_clear_status - clear TX status\n *\n * @info: The &struct ieee80211_tx_info to be cleared.\n *\n * When the driver passes an skb back to mac80211, it must report\n * a number of things in TX status. This function clears everything\n * in the TX status but the rate control information (it does clear\n * the count since you need to fill that in anyway).\n *\n * NOTE: You can only use this function if you do NOT use\n *\t info->driver_data! Use info->rate_driver_data\n *\t instead if you need only the less space that allows.\n */\nstatic inline void\nieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)\n{\n\tint i;\n\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=\n\t\t     offsetof(struct ieee80211_tx_info, control.rates));\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=\n\t\t     offsetof(struct ieee80211_tx_info, driver_rates));\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) != 8);\n\t/* clear the rate counts */\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++)\n\t\tinfo->status.rates[i].count = 0;\n\n\tBUILD_BUG_ON(\n\t    offsetof(struct ieee80211_tx_info, status.ack_signal) != 20);\n\tmemset(&info->status.ampdu_ack_len, 0,\n\t       sizeof(struct ieee80211_tx_info) -\n\t       offsetof(struct ieee80211_tx_info, status.ampdu_ack_len));\n}\n\n\n/**\n * enum mac80211_rx_flags - receive flags\n *\n * These flags are used with the @flag member of &struct ieee80211_rx_status.\n * @RX_FLAG_MMIC_ERROR: Michael MIC error was reported on this frame.\n *\tUse together with %RX_FLAG_MMIC_STRIPPED.\n * @RX_FLAG_DECRYPTED: This frame was decrypted in hardware.\n * @RX_FLAG_MMIC_STRIPPED: the Michael MIC is stripped off this frame,\n *\tverification has been done by the hardware.\n * @RX_FLAG_IV_STRIPPED: The IV and ICV are stripped from this frame.\n *\tIf this flag is set, the stack cannot do any replay detection\n *\thence the driver or hardware will have to do that.\n * @RX_FLAG_PN_VALIDATED: Currently only valid for CCMP/GCMP frames, this\n *\tflag indicates that the PN was verified for replay protection.\n *\tNote that this flag is also currently only supported when a frame\n *\tis also decrypted (ie. @RX_FLAG_DECRYPTED must be set)\n * @RX_FLAG_DUP_VALIDATED: The driver should set this flag if it did\n *\tde-duplication by itself.\n * @RX_FLAG_FAILED_FCS_CRC: Set this flag if the FCS check failed on\n *\tthe frame.\n * @RX_FLAG_FAILED_PLCP_CRC: Set this flag if the PCLP check failed on\n *\tthe frame.\n * @RX_FLAG_MACTIME_START: The timestamp passed in the RX status (@mactime\n *\tfield) is valid and contains the time the first symbol of the MPDU\n *\twas received. This is useful in monitor mode and for proper IBSS\n *\tmerging.\n * @RX_FLAG_MACTIME_END: The timestamp passed in the RX status (@mactime\n *\tfield) is valid and contains the time the last symbol of the MPDU\n *\t(including FCS) was received.\n * @RX_FLAG_MACTIME_PLCP_START: The timestamp passed in the RX status (@mactime\n *\tfield) is valid and contains the time the SYNC preamble was received.\n * @RX_FLAG_NO_SIGNAL_VAL: The signal strength value is not present.\n *\tValid only for data frames (mainly A-MPDU)\n * @RX_FLAG_AMPDU_DETAILS: A-MPDU details are known, in particular the reference\n *\tnumber (@ampdu_reference) must be populated and be a distinct number for\n *\teach A-MPDU\n * @RX_FLAG_AMPDU_LAST_KNOWN: last subframe is known, should be set on all\n *\tsubframes of a single A-MPDU\n * @RX_FLAG_AMPDU_IS_LAST: this subframe is the last subframe of the A-MPDU\n * @RX_FLAG_AMPDU_DELIM_CRC_ERROR: A delimiter CRC error has been detected\n *\ton this subframe\n * @RX_FLAG_AMPDU_DELIM_CRC_KNOWN: The delimiter CRC field is known (the CRC\n *\tis stored in the @ampdu_delimiter_crc field)\n * @RX_FLAG_MIC_STRIPPED: The mic was stripped of this packet. Decryption was\n *\tdone by the hardware\n * @RX_FLAG_ONLY_MONITOR: Report frame only to monitor interfaces without\n *\tprocessing it in any regular way.\n *\tThis is useful if drivers offload some frames but still want to report\n *\tthem for sniffing purposes.\n * @RX_FLAG_SKIP_MONITOR: Process and report frame to all interfaces except\n *\tmonitor interfaces.\n *\tThis is useful if drivers offload some frames but still want to report\n *\tthem for sniffing purposes.\n * @RX_FLAG_AMSDU_MORE: Some drivers may prefer to report separate A-MSDU\n *\tsubframes instead of a one huge frame for performance reasons.\n *\tAll, but the last MSDU from an A-MSDU should have this flag set. E.g.\n *\tif an A-MSDU has 3 frames, the first 2 must have the flag set, while\n *\tthe 3rd (last) one must not have this flag set. The flag is used to\n *\tdeal with retransmission/duplication recovery properly since A-MSDU\n *\tsubframes share the same sequence number. Reported subframes can be\n *\teither regular MSDU or singly A-MSDUs. Subframes must not be\n *\tinterleaved with other frames.\n * @RX_FLAG_RADIOTAP_VENDOR_DATA: This frame contains vendor-specific\n *\tradiotap data in the skb->data (before the frame) as described by\n *\tthe &struct ieee80211_vendor_radiotap.\n * @RX_FLAG_ALLOW_SAME_PN: Allow the same PN as same packet before.\n *\tThis is used for AMSDU subframes which can have the same PN as\n *\tthe first subframe.\n * @RX_FLAG_ICV_STRIPPED: The ICV is stripped from this frame. CRC checking must\n *\tbe done in the hardware.\n * @RX_FLAG_AMPDU_EOF_BIT: Value of the EOF bit in the A-MPDU delimiter for this\n *\tframe\n * @RX_FLAG_AMPDU_EOF_BIT_KNOWN: The EOF value is known\n * @RX_FLAG_RADIOTAP_HE: HE radiotap data is present\n *\t(&struct ieee80211_radiotap_he, mac80211 will fill in\n *\t\n *\t - DATA3_DATA_MCS\n *\t - DATA3_DATA_DCM\n *\t - DATA3_CODING\n *\t - DATA5_GI\n *\t - DATA5_DATA_BW_RU_ALLOC\n *\t - DATA6_NSTS\n *\t - DATA3_STBC\n *\t\n *\tfrom the RX info data, so leave those zeroed when building this data)\n * @RX_FLAG_RADIOTAP_HE_MU: HE MU radiotap data is present\n *\t(&struct ieee80211_radiotap_he_mu)\n * @RX_FLAG_RADIOTAP_LSIG: L-SIG radiotap data is present\n * @RX_FLAG_NO_PSDU: use the frame only for radiotap reporting, with\n *\tthe \"0-length PSDU\" field included there.  The value for it is\n *\tin &struct ieee80211_rx_status.  Note that if this value isn't\n *\tknown the frame shouldn't be reported.\n * @RX_FLAG_8023: the frame has an 802.3 header (decap offload performed by\n *\thardware or driver)\n */\nenum mac80211_rx_flags {\n\tRX_FLAG_MMIC_ERROR\t\t= BIT(0),\n\tRX_FLAG_DECRYPTED\t\t= BIT(1),\n\tRX_FLAG_MACTIME_PLCP_START\t= BIT(2),\n\tRX_FLAG_MMIC_STRIPPED\t\t= BIT(3),\n\tRX_FLAG_IV_STRIPPED\t\t= BIT(4),\n\tRX_FLAG_FAILED_FCS_CRC\t\t= BIT(5),\n\tRX_FLAG_FAILED_PLCP_CRC \t= BIT(6),\n\tRX_FLAG_MACTIME_START\t\t= BIT(7),\n\tRX_FLAG_NO_SIGNAL_VAL\t\t= BIT(8),\n\tRX_FLAG_AMPDU_DETAILS\t\t= BIT(9),\n\tRX_FLAG_PN_VALIDATED\t\t= BIT(10),\n\tRX_FLAG_DUP_VALIDATED\t\t= BIT(11),\n\tRX_FLAG_AMPDU_LAST_KNOWN\t= BIT(12),\n\tRX_FLAG_AMPDU_IS_LAST\t\t= BIT(13),\n\tRX_FLAG_AMPDU_DELIM_CRC_ERROR\t= BIT(14),\n\tRX_FLAG_AMPDU_DELIM_CRC_KNOWN\t= BIT(15),\n\tRX_FLAG_MACTIME_END\t\t= BIT(16),\n\tRX_FLAG_ONLY_MONITOR\t\t= BIT(17),\n\tRX_FLAG_SKIP_MONITOR\t\t= BIT(18),\n\tRX_FLAG_AMSDU_MORE\t\t= BIT(19),\n\tRX_FLAG_RADIOTAP_VENDOR_DATA\t= BIT(20),\n\tRX_FLAG_MIC_STRIPPED\t\t= BIT(21),\n\tRX_FLAG_ALLOW_SAME_PN\t\t= BIT(22),\n\tRX_FLAG_ICV_STRIPPED\t\t= BIT(23),\n\tRX_FLAG_AMPDU_EOF_BIT\t\t= BIT(24),\n\tRX_FLAG_AMPDU_EOF_BIT_KNOWN\t= BIT(25),\n\tRX_FLAG_RADIOTAP_HE\t\t= BIT(26),\n\tRX_FLAG_RADIOTAP_HE_MU\t\t= BIT(27),\n\tRX_FLAG_RADIOTAP_LSIG\t\t= BIT(28),\n\tRX_FLAG_NO_PSDU\t\t\t= BIT(29),\n\tRX_FLAG_8023\t\t\t= BIT(30),\n};\n\n/**\n * enum mac80211_rx_encoding_flags - MCS & bandwidth flags\n *\n * @RX_ENC_FLAG_SHORTPRE: Short preamble was used for this frame\n * @RX_ENC_FLAG_SHORT_GI: Short guard interval was used\n * @RX_ENC_FLAG_HT_GF: This frame was received in a HT-greenfield transmission,\n *\tif the driver fills this value it should add\n *\t%IEEE80211_RADIOTAP_MCS_HAVE_FMT\n *\tto @hw.radiotap_mcs_details to advertise that fact.\n * @RX_ENC_FLAG_LDPC: LDPC was used\n * @RX_ENC_FLAG_STBC_MASK: STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3\n * @RX_ENC_FLAG_BF: packet was beamformed\n */\nenum mac80211_rx_encoding_flags {\n\tRX_ENC_FLAG_SHORTPRE\t\t= BIT(0),\n\tRX_ENC_FLAG_SHORT_GI\t\t= BIT(2),\n\tRX_ENC_FLAG_HT_GF\t\t= BIT(3),\n\tRX_ENC_FLAG_STBC_MASK\t\t= BIT(4) | BIT(5),\n\tRX_ENC_FLAG_LDPC\t\t= BIT(6),\n\tRX_ENC_FLAG_BF\t\t\t= BIT(7),\n};\n\n#define RX_ENC_FLAG_STBC_SHIFT\t\t4\n\nenum mac80211_rx_encoding {\n\tRX_ENC_LEGACY = 0,\n\tRX_ENC_HT,\n\tRX_ENC_VHT,\n\tRX_ENC_HE,\n};\n\n/**\n * struct ieee80211_rx_status - receive status\n *\n * The low-level driver should provide this information (the subset\n * supported by hardware) to the 802.11 code with each received\n * frame, in the skb's control buffer (cb).\n *\n * @mactime: value in microseconds of the 64-bit Time Synchronization Function\n * \t(TSF) timer when the first data symbol (MPDU) arrived at the hardware.\n * @boottime_ns: CLOCK_BOOTTIME timestamp the frame was received at, this is\n *\tneeded only for beacons and probe responses that update the scan cache.\n * @device_timestamp: arbitrary timestamp for the device, mac80211 doesn't use\n *\tit but can store it and pass it back to the driver for synchronisation\n * @band: the active band when this frame was received\n * @freq: frequency the radio was tuned to when receiving this frame, in MHz\n *\tThis field must be set for management frames, but isn't strictly needed\n *\tfor data (other) frames - for those it only affects radiotap reporting.\n * @freq_offset: @freq has a positive offset of 500Khz.\n * @signal: signal strength when receiving this frame, either in dBm, in dB or\n *\tunspecified depending on the hardware capabilities flags\n *\t@IEEE80211_HW_SIGNAL_*\n * @chains: bitmask of receive chains for which separate signal strength\n *\tvalues were filled.\n * @chain_signal: per-chain signal strength, in dBm (unlike @signal, doesn't\n *\tsupport dB or unspecified units)\n * @antenna: antenna used\n * @rate_idx: index of data rate into band's supported rates or MCS index if\n *\tHT or VHT is used (%RX_FLAG_HT/%RX_FLAG_VHT)\n * @nss: number of streams (VHT and HE only)\n * @flag: %RX_FLAG_\\*\n * @encoding: &enum mac80211_rx_encoding\n * @bw: &enum rate_info_bw\n * @enc_flags: uses bits from &enum mac80211_rx_encoding_flags\n * @he_ru: HE RU, from &enum nl80211_he_ru_alloc\n * @he_gi: HE GI, from &enum nl80211_he_gi\n * @he_dcm: HE DCM value\n * @rx_flags: internal RX flags for mac80211\n * @ampdu_reference: A-MPDU reference number, must be a different value for\n *\teach A-MPDU but the same for each subframe within one A-MPDU\n * @ampdu_delimiter_crc: A-MPDU delimiter CRC\n * @zero_length_psdu_type: radiotap type of the 0-length PSDU\n */\nstruct ieee80211_rx_status {\n\tu64 mactime;\n\tu64 boottime_ns;\n\tu32 device_timestamp;\n\tu32 ampdu_reference;\n\tu32 flag;\n\tu16 freq: 13, freq_offset: 1;\n\tu8 enc_flags;\n\tu8 encoding:2, bw:3, he_ru:3;\n\tu8 he_gi:2, he_dcm:1;\n\tu8 rate_idx;\n\tu8 nss;\n\tu8 rx_flags;\n\tu8 band;\n\tu8 antenna;\n\ts8 signal;\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n\tu8 ampdu_delimiter_crc;\n\tu8 zero_length_psdu_type;\n};\n\nstatic inline u32\nieee80211_rx_status_to_khz(struct ieee80211_rx_status *rx_status)\n{\n\treturn MHZ_TO_KHZ(rx_status->freq) +\n\t       (rx_status->freq_offset ? 500 : 0);\n}\n\n/**\n * struct ieee80211_vendor_radiotap - vendor radiotap data information\n * @present: presence bitmap for this vendor namespace\n *\t(this could be extended in the future if any vendor needs more\n *\t bits, the radiotap spec does allow for that)\n * @align: radiotap vendor namespace alignment. This defines the needed\n *\talignment for the @data field below, not for the vendor namespace\n *\tdescription itself (which has a fixed 2-byte alignment)\n *\tMust be a power of two, and be set to at least 1!\n * @oui: radiotap vendor namespace OUI\n * @subns: radiotap vendor sub namespace\n * @len: radiotap vendor sub namespace skip length, if alignment is done\n *\tthen that's added to this, i.e. this is only the length of the\n *\t@data field.\n * @pad: number of bytes of padding after the @data, this exists so that\n *\tthe skb data alignment can be preserved even if the data has odd\n *\tlength\n * @data: the actual vendor namespace data\n *\n * This struct, including the vendor data, goes into the skb->data before\n * the 802.11 header. It's split up in mac80211 using the align/oui/subns\n * data.\n */\nstruct ieee80211_vendor_radiotap {\n\tu32 present;\n\tu8 align;\n\tu8 oui[3];\n\tu8 subns;\n\tu8 pad;\n\tu16 len;\n\tu8 data[];\n} __packed;\n\n/**\n * enum ieee80211_conf_flags - configuration flags\n *\n * Flags to define PHY configuration options\n *\n * @IEEE80211_CONF_MONITOR: there's a monitor interface present -- use this\n *\tto determine for example whether to calculate timestamps for packets\n *\tor not, do not use instead of filter flags!\n * @IEEE80211_CONF_PS: Enable 802.11 power save mode (managed mode only).\n *\tThis is the power save mode defined by IEEE 802.11-2007 section 11.2,\n *\tmeaning that the hardware still wakes up for beacons, is able to\n *\ttransmit frames and receive the possible acknowledgment frames.\n *\tNot to be confused with hardware specific wakeup/sleep states,\n *\tdriver is responsible for that. See the section \"Powersave support\"\n *\tfor more.\n * @IEEE80211_CONF_IDLE: The device is running, but idle; if the flag is set\n *\tthe driver should be prepared to handle configuration requests but\n *\tmay turn the device off as much as possible. Typically, this flag will\n *\tbe set when an interface is set UP but not associated or scanning, but\n *\tit can also be unset in that case when monitor interfaces are active.\n * @IEEE80211_CONF_OFFCHANNEL: The device is currently not on its main\n *\toperating channel.\n */\nenum ieee80211_conf_flags {\n\tIEEE80211_CONF_MONITOR\t\t= (1<<0),\n\tIEEE80211_CONF_PS\t\t= (1<<1),\n\tIEEE80211_CONF_IDLE\t\t= (1<<2),\n\tIEEE80211_CONF_OFFCHANNEL\t= (1<<3),\n};\n\n\n/**\n * enum ieee80211_conf_changed - denotes which configuration changed\n *\n * @IEEE80211_CONF_CHANGE_LISTEN_INTERVAL: the listen interval changed\n * @IEEE80211_CONF_CHANGE_MONITOR: the monitor flag changed\n * @IEEE80211_CONF_CHANGE_PS: the PS flag or dynamic PS timeout changed\n * @IEEE80211_CONF_CHANGE_POWER: the TX power changed\n * @IEEE80211_CONF_CHANGE_CHANNEL: the channel/channel_type changed\n * @IEEE80211_CONF_CHANGE_RETRY_LIMITS: retry limits changed\n * @IEEE80211_CONF_CHANGE_IDLE: Idle flag changed\n * @IEEE80211_CONF_CHANGE_SMPS: Spatial multiplexing powersave mode changed\n *\tNote that this is only valid if channel contexts are not used,\n *\totherwise each channel context has the number of chains listed.\n */\nenum ieee80211_conf_changed {\n\tIEEE80211_CONF_CHANGE_SMPS\t\t= BIT(1),\n\tIEEE80211_CONF_CHANGE_LISTEN_INTERVAL\t= BIT(2),\n\tIEEE80211_CONF_CHANGE_MONITOR\t\t= BIT(3),\n\tIEEE80211_CONF_CHANGE_PS\t\t= BIT(4),\n\tIEEE80211_CONF_CHANGE_POWER\t\t= BIT(5),\n\tIEEE80211_CONF_CHANGE_CHANNEL\t\t= BIT(6),\n\tIEEE80211_CONF_CHANGE_RETRY_LIMITS\t= BIT(7),\n\tIEEE80211_CONF_CHANGE_IDLE\t\t= BIT(8),\n};\n\n/**\n * enum ieee80211_smps_mode - spatial multiplexing power save mode\n *\n * @IEEE80211_SMPS_AUTOMATIC: automatic\n * @IEEE80211_SMPS_OFF: off\n * @IEEE80211_SMPS_STATIC: static\n * @IEEE80211_SMPS_DYNAMIC: dynamic\n * @IEEE80211_SMPS_NUM_MODES: internal, don't use\n */\nenum ieee80211_smps_mode {\n\tIEEE80211_SMPS_AUTOMATIC,\n\tIEEE80211_SMPS_OFF,\n\tIEEE80211_SMPS_STATIC,\n\tIEEE80211_SMPS_DYNAMIC,\n\n\t/* keep last */\n\tIEEE80211_SMPS_NUM_MODES,\n};\n\n/**\n * struct ieee80211_conf - configuration of the device\n *\n * This struct indicates how the driver shall configure the hardware.\n *\n * @flags: configuration flags defined above\n *\n * @listen_interval: listen interval in units of beacon interval\n * @ps_dtim_period: The DTIM period of the AP we're connected to, for use\n *\tin power saving. Power saving will not be enabled until a beacon\n *\thas been received and the DTIM period is known.\n * @dynamic_ps_timeout: The dynamic powersave timeout (in ms), see the\n *\tpowersave documentation below. This variable is valid only when\n *\tthe CONF_PS flag is set.\n *\n * @power_level: requested transmit power (in dBm), backward compatibility\n *\tvalue only that is set to the minimum of all interfaces\n *\n * @chandef: the channel definition to tune to\n * @radar_enabled: whether radar detection is enabled\n *\n * @long_frame_max_tx_count: Maximum number of transmissions for a \"long\" frame\n *\t(a frame not RTS protected), called \"dot11LongRetryLimit\" in 802.11,\n *\tbut actually means the number of transmissions not the number of retries\n * @short_frame_max_tx_count: Maximum number of transmissions for a \"short\"\n *\tframe, called \"dot11ShortRetryLimit\" in 802.11, but actually means the\n *\tnumber of transmissions not the number of retries\n *\n * @smps_mode: spatial multiplexing powersave mode; note that\n *\t%IEEE80211_SMPS_STATIC is used when the device is not\n *\tconfigured for an HT channel.\n *\tNote that this is only valid if channel contexts are not used,\n *\totherwise each channel context has the number of chains listed.\n */\nstruct ieee80211_conf {\n\tu32 flags;\n\tint power_level, dynamic_ps_timeout;\n\n\tu16 listen_interval;\n\tu8 ps_dtim_period;\n\n\tu8 long_frame_max_tx_count, short_frame_max_tx_count;\n\n\tstruct cfg80211_chan_def chandef;\n\tbool radar_enabled;\n\tenum ieee80211_smps_mode smps_mode;\n};\n\n/**\n * struct ieee80211_channel_switch - holds the channel switch data\n *\n * The information provided in this structure is required for channel switch\n * operation.\n *\n * @timestamp: value in microseconds of the 64-bit Time Synchronization\n *\tFunction (TSF) timer when the frame containing the channel switch\n *\tannouncement was received. This is simply the rx.mactime parameter\n *\tthe driver passed into mac80211.\n * @device_timestamp: arbitrary timestamp for the device, this is the\n *\trx.device_timestamp parameter the driver passed to mac80211.\n * @block_tx: Indicates whether transmission must be blocked before the\n *\tscheduled channel switch, as indicated by the AP.\n * @chandef: the new channel to switch to\n * @count: the number of TBTT's until the channel switch event\n * @delay: maximum delay between the time the AP transmitted the last beacon in\n  *\tcurrent channel and the expected time of the first beacon in the new\n  *\tchannel, expressed in TU.\n */\nstruct ieee80211_channel_switch {\n\tu64 timestamp;\n\tu32 device_timestamp;\n\tbool block_tx;\n\tstruct cfg80211_chan_def chandef;\n\tu8 count;\n\tu32 delay;\n};\n\n/**\n * enum ieee80211_vif_flags - virtual interface flags\n *\n * @IEEE80211_VIF_BEACON_FILTER: the device performs beacon filtering\n *\ton this virtual interface to avoid unnecessary CPU wakeups\n * @IEEE80211_VIF_SUPPORTS_CQM_RSSI: the device can do connection quality\n *\tmonitoring on this virtual interface -- i.e. it can monitor\n *\tconnection quality related parameters, such as the RSSI level and\n *\tprovide notifications if configured trigger levels are reached.\n * @IEEE80211_VIF_SUPPORTS_UAPSD: The device can do U-APSD for this\n *\tinterface. This flag should be set during interface addition,\n *\tbut may be set/cleared as late as authentication to an AP. It is\n *\tonly valid for managed/station mode interfaces.\n * @IEEE80211_VIF_GET_NOA_UPDATE: request to handle NOA attributes\n *\tand send P2P_PS notification to the driver if NOA changed, even\n *\tthis is not pure P2P vif.\n */\nenum ieee80211_vif_flags {\n\tIEEE80211_VIF_BEACON_FILTER\t\t= BIT(0),\n\tIEEE80211_VIF_SUPPORTS_CQM_RSSI\t\t= BIT(1),\n\tIEEE80211_VIF_SUPPORTS_UAPSD\t\t= BIT(2),\n\tIEEE80211_VIF_GET_NOA_UPDATE\t\t= BIT(3),\n};\n\n\n/**\n * enum ieee80211_offload_flags - virtual interface offload flags\n *\n * @IEEE80211_OFFLOAD_ENCAP_ENABLED: tx encapsulation offload is enabled\n *\tThe driver supports sending frames passed as 802.3 frames by mac80211.\n *\tIt must also support sending 802.11 packets for the same interface.\n * @IEEE80211_OFFLOAD_ENCAP_4ADDR: support 4-address mode encapsulation offload\n * @IEEE80211_OFFLOAD_DECAP_ENABLED: rx encapsulation offload is enabled\n *\tThe driver supports passing received 802.11 frames as 802.3 frames to\n *\tmac80211.\n */\n\nenum ieee80211_offload_flags {\n\tIEEE80211_OFFLOAD_ENCAP_ENABLED\t\t= BIT(0),\n\tIEEE80211_OFFLOAD_ENCAP_4ADDR\t\t= BIT(1),\n\tIEEE80211_OFFLOAD_DECAP_ENABLED\t\t= BIT(2),\n};\n\n/**\n * struct ieee80211_vif - per-interface data\n *\n * Data in this structure is continually present for driver\n * use during the life of a virtual interface.\n *\n * @type: type of this virtual interface\n * @bss_conf: BSS configuration for this interface, either our own\n *\tor the BSS we're associated to\n * @addr: address of this interface\n * @p2p: indicates whether this AP or STA interface is a p2p\n *\tinterface, i.e. a GO or p2p-sta respectively\n * @csa_active: marks whether a channel switch is going on. Internally it is\n *\twrite-protected by sdata_lock and local->mtx so holding either is fine\n *\tfor read access.\n * @mu_mimo_owner: indicates interface owns MU-MIMO capability\n * @driver_flags: flags/capabilities the driver has for this interface,\n *\tthese need to be set (or cleared) when the interface is added\n *\tor, if supported by the driver, the interface type is changed\n *\tat runtime, mac80211 will never touch this field\n * @offloaad_flags: hardware offload capabilities/flags for this interface.\n *\tThese are initialized by mac80211 before calling .add_interface,\n *\t.change_interface or .update_vif_offload and updated by the driver\n *\twithin these ops, based on supported features or runtime change\n *\trestrictions.\n * @hw_queue: hardware queue for each AC\n * @cab_queue: content-after-beacon (DTIM beacon really) queue, AP mode only\n * @chanctx_conf: The channel context this interface is assigned to, or %NULL\n *\twhen it is not assigned. This pointer is RCU-protected due to the TX\n *\tpath needing to access it; even though the netdev carrier will always\n *\tbe off when it is %NULL there can still be races and packets could be\n *\tprocessed after it switches back to %NULL.\n * @debugfs_dir: debugfs dentry, can be used by drivers to create own per\n *\tinterface debug files. Note that it will be NULL for the virtual\n *\tmonitor interface (if that is requested.)\n * @probe_req_reg: probe requests should be reported to mac80211 for this\n *\tinterface.\n * @rx_mcast_action_reg: multicast Action frames should be reported to mac80211\n *\tfor this interface.\n * @drv_priv: data area for driver use, will always be aligned to\n *\tsizeof(void \\*).\n * @txq: the multicast data TX queue (if driver uses the TXQ abstraction)\n * @txqs_stopped: per AC flag to indicate that intermediate TXQs are stopped,\n *\tprotected by fq->lock.\n * @offload_flags: 802.3 -> 802.11 enapsulation offload flags, see\n *\t&enum ieee80211_offload_flags.\n */\nstruct ieee80211_vif {\n\tenum nl80211_iftype type;\n\tstruct ieee80211_bss_conf bss_conf;\n\tu8 addr[ETH_ALEN] __aligned(2);\n\tbool p2p;\n\tbool csa_active;\n\tbool mu_mimo_owner;\n\n\tu8 cab_queue;\n\tu8 hw_queue[IEEE80211_NUM_ACS];\n\n\tstruct ieee80211_txq *txq;\n\n\tstruct ieee80211_chanctx_conf __rcu *chanctx_conf;\n\n\tu32 driver_flags;\n\tu32 offload_flags;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct dentry *debugfs_dir;\n#endif\n\n\tbool probe_req_reg;\n\tbool rx_mcast_action_reg;\n\n\tbool txqs_stopped[IEEE80211_NUM_ACS];\n\n\t/* must be last */\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\nstatic inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)\n{\n#ifdef CONFIG_MAC80211_MESH\n\treturn vif->type == NL80211_IFTYPE_MESH_POINT;\n#endif\n\treturn false;\n}\n\n/**\n * wdev_to_ieee80211_vif - return a vif struct from a wdev\n * @wdev: the wdev to get the vif for\n *\n * This can be used by mac80211 drivers with direct cfg80211 APIs\n * (like the vendor commands) that get a wdev.\n *\n * Note that this function may return %NULL if the given wdev isn't\n * associated with a vif that the driver knows about (e.g. monitor\n * or AP_VLAN interfaces.)\n */\nstruct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);\n\n/**\n * ieee80211_vif_to_wdev - return a wdev struct from a vif\n * @vif: the vif to get the wdev for\n *\n * This can be used by mac80211 drivers with direct cfg80211 APIs\n * (like the vendor commands) that needs to get the wdev for a vif.\n * This can also be useful to get the netdev associated to a vif.\n */\nstruct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif);\n\n/**\n * enum ieee80211_key_flags - key flags\n *\n * These flags are used for communication about keys between the driver\n * and mac80211, with the @flags parameter of &struct ieee80211_key_conf.\n *\n * @IEEE80211_KEY_FLAG_GENERATE_IV: This flag should be set by the\n *\tdriver to indicate that it requires IV generation for this\n *\tparticular key. Setting this flag does not necessarily mean that SKBs\n *\twill have sufficient tailroom for ICV or MIC.\n * @IEEE80211_KEY_FLAG_GENERATE_MMIC: This flag should be set by\n *\tthe driver for a TKIP key if it requires Michael MIC\n *\tgeneration in software.\n * @IEEE80211_KEY_FLAG_PAIRWISE: Set by mac80211, this flag indicates\n *\tthat the key is pairwise rather then a shared key.\n * @IEEE80211_KEY_FLAG_SW_MGMT_TX: This flag should be set by the driver for a\n *\tCCMP/GCMP key if it requires CCMP/GCMP encryption of management frames\n *\t(MFP) to be done in software.\n * @IEEE80211_KEY_FLAG_PUT_IV_SPACE: This flag should be set by the driver\n *\tif space should be prepared for the IV, but the IV\n *\titself should not be generated. Do not set together with\n *\t@IEEE80211_KEY_FLAG_GENERATE_IV on the same key. Setting this flag does\n *\tnot necessarily mean that SKBs will have sufficient tailroom for ICV or\n *\tMIC.\n * @IEEE80211_KEY_FLAG_RX_MGMT: This key will be used to decrypt received\n *\tmanagement frames. The flag can help drivers that have a hardware\n *\tcrypto implementation that doesn't deal with management frames\n *\tproperly by allowing them to not upload the keys to hardware and\n *\tfall back to software crypto. Note that this flag deals only with\n *\tRX, if your crypto engine can't deal with TX you can also set the\n *\t%IEEE80211_KEY_FLAG_SW_MGMT_TX flag to encrypt such frames in SW.\n * @IEEE80211_KEY_FLAG_GENERATE_IV_MGMT: This flag should be set by the\n *\tdriver for a CCMP/GCMP key to indicate that is requires IV generation\n *\tonly for management frames (MFP).\n * @IEEE80211_KEY_FLAG_RESERVE_TAILROOM: This flag should be set by the\n *\tdriver for a key to indicate that sufficient tailroom must always\n *\tbe reserved for ICV or MIC, even when HW encryption is enabled.\n * @IEEE80211_KEY_FLAG_PUT_MIC_SPACE: This flag should be set by the driver for\n *\ta TKIP key if it only requires MIC space. Do not set together with\n *\t@IEEE80211_KEY_FLAG_GENERATE_MMIC on the same key.\n * @IEEE80211_KEY_FLAG_NO_AUTO_TX: Key needs explicit Tx activation.\n * @IEEE80211_KEY_FLAG_GENERATE_MMIE: This flag should be set by the driver\n *\tfor a AES_CMAC key to indicate that it requires sequence number\n *\tgeneration only\n */\nenum ieee80211_key_flags {\n\tIEEE80211_KEY_FLAG_GENERATE_IV_MGMT\t= BIT(0),\n\tIEEE80211_KEY_FLAG_GENERATE_IV\t\t= BIT(1),\n\tIEEE80211_KEY_FLAG_GENERATE_MMIC\t= BIT(2),\n\tIEEE80211_KEY_FLAG_PAIRWISE\t\t= BIT(3),\n\tIEEE80211_KEY_FLAG_SW_MGMT_TX\t\t= BIT(4),\n\tIEEE80211_KEY_FLAG_PUT_IV_SPACE\t\t= BIT(5),\n\tIEEE80211_KEY_FLAG_RX_MGMT\t\t= BIT(6),\n\tIEEE80211_KEY_FLAG_RESERVE_TAILROOM\t= BIT(7),\n\tIEEE80211_KEY_FLAG_PUT_MIC_SPACE\t= BIT(8),\n\tIEEE80211_KEY_FLAG_NO_AUTO_TX\t\t= BIT(9),\n\tIEEE80211_KEY_FLAG_GENERATE_MMIE\t= BIT(10),\n};\n\n/**\n * struct ieee80211_key_conf - key information\n *\n * This key information is given by mac80211 to the driver by\n * the set_key() callback in &struct ieee80211_ops.\n *\n * @hw_key_idx: To be set by the driver, this is the key index the driver\n *\twants to be given when a frame is transmitted and needs to be\n *\tencrypted in hardware.\n * @cipher: The key's cipher suite selector.\n * @tx_pn: PN used for TX keys, may be used by the driver as well if it\n *\tneeds to do software PN assignment by itself (e.g. due to TSO)\n * @flags: key flags, see &enum ieee80211_key_flags.\n * @keyidx: the key index (0-3)\n * @keylen: key material length\n * @key: key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)\n * \tdata block:\n * \t- Temporal Encryption Key (128 bits)\n * \t- Temporal Authenticator Tx MIC Key (64 bits)\n * \t- Temporal Authenticator Rx MIC Key (64 bits)\n * @icv_len: The ICV length for this key type\n * @iv_len: The IV length for this key type\n */\nstruct ieee80211_key_conf {\n\tatomic64_t tx_pn;\n\tu32 cipher;\n\tu8 icv_len;\n\tu8 iv_len;\n\tu8 hw_key_idx;\n\ts8 keyidx;\n\tu16 flags;\n\tu8 keylen;\n\tu8 key[];\n};\n\n#define IEEE80211_MAX_PN_LEN\t16\n\n#define TKIP_PN_TO_IV16(pn) ((u16)(pn & 0xffff))\n#define TKIP_PN_TO_IV32(pn) ((u32)((pn >> 16) & 0xffffffff))\n\n/**\n * struct ieee80211_key_seq - key sequence counter\n *\n * @tkip: TKIP data, containing IV32 and IV16 in host byte order\n * @ccmp: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @aes_cmac: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @aes_gmac: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @gcmp: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @hw: data for HW-only (e.g. cipher scheme) keys\n */\nstruct ieee80211_key_seq {\n\tunion {\n\t\tstruct {\n\t\t\tu32 iv32;\n\t\t\tu16 iv16;\n\t\t} tkip;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} ccmp;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} aes_cmac;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} aes_gmac;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} gcmp;\n\t\tstruct {\n\t\t\tu8 seq[IEEE80211_MAX_PN_LEN];\n\t\t\tu8 seq_len;\n\t\t} hw;\n\t};\n};\n\n/**\n * struct ieee80211_cipher_scheme - cipher scheme\n *\n * This structure contains a cipher scheme information defining\n * the secure packet crypto handling.\n *\n * @cipher: a cipher suite selector\n * @iftype: a cipher iftype bit mask indicating an allowed cipher usage\n * @hdr_len: a length of a security header used the cipher\n * @pn_len: a length of a packet number in the security header\n * @pn_off: an offset of pn from the beginning of the security header\n * @key_idx_off: an offset of key index byte in the security header\n * @key_idx_mask: a bit mask of key_idx bits\n * @key_idx_shift: a bit shift needed to get key_idx\n *     key_idx value calculation:\n *      (sec_header_base[key_idx_off] & key_idx_mask) >> key_idx_shift\n * @mic_len: a mic length in bytes\n */\nstruct ieee80211_cipher_scheme {\n\tu32 cipher;\n\tu16 iftype;\n\tu8 hdr_len;\n\tu8 pn_len;\n\tu8 pn_off;\n\tu8 key_idx_off;\n\tu8 key_idx_mask;\n\tu8 key_idx_shift;\n\tu8 mic_len;\n};\n\n/**\n * enum set_key_cmd - key command\n *\n * Used with the set_key() callback in &struct ieee80211_ops, this\n * indicates whether a key is being removed or added.\n *\n * @SET_KEY: a key is set\n * @DISABLE_KEY: a key must be disabled\n */\nenum set_key_cmd {\n\tSET_KEY, DISABLE_KEY,\n};\n\n/**\n * enum ieee80211_sta_state - station state\n *\n * @IEEE80211_STA_NOTEXIST: station doesn't exist at all,\n *\tthis is a special state for add/remove transitions\n * @IEEE80211_STA_NONE: station exists without special state\n * @IEEE80211_STA_AUTH: station is authenticated\n * @IEEE80211_STA_ASSOC: station is associated\n * @IEEE80211_STA_AUTHORIZED: station is authorized (802.1X)\n */\nenum ieee80211_sta_state {\n\t/* NOTE: These need to be ordered correctly! */\n\tIEEE80211_STA_NOTEXIST,\n\tIEEE80211_STA_NONE,\n\tIEEE80211_STA_AUTH,\n\tIEEE80211_STA_ASSOC,\n\tIEEE80211_STA_AUTHORIZED,\n};\n\n/**\n * enum ieee80211_sta_rx_bandwidth - station RX bandwidth\n * @IEEE80211_STA_RX_BW_20: station can only receive 20 MHz\n * @IEEE80211_STA_RX_BW_40: station can receive up to 40 MHz\n * @IEEE80211_STA_RX_BW_80: station can receive up to 80 MHz\n * @IEEE80211_STA_RX_BW_160: station can receive up to 160 MHz\n *\t(including 80+80 MHz)\n *\n * Implementation note: 20 must be zero to be initialized\n *\tcorrectly, the values must be sorted.\n */\nenum ieee80211_sta_rx_bandwidth {\n\tIEEE80211_STA_RX_BW_20 = 0,\n\tIEEE80211_STA_RX_BW_40,\n\tIEEE80211_STA_RX_BW_80,\n\tIEEE80211_STA_RX_BW_160,\n};\n\n/**\n * struct ieee80211_sta_rates - station rate selection table\n *\n * @rcu_head: RCU head used for freeing the table on update\n * @rate: transmit rates/flags to be used by default.\n *\tOverriding entries per-packet is possible by using cb tx control.\n */\nstruct ieee80211_sta_rates {\n\tstruct rcu_head rcu_head;\n\tstruct {\n\t\ts8 idx;\n\t\tu8 count;\n\t\tu8 count_cts;\n\t\tu8 count_rts;\n\t\tu16 flags;\n\t} rate[IEEE80211_TX_RATE_TABLE_SIZE];\n};\n\n/**\n * struct ieee80211_sta_txpwr - station txpower configuration\n *\n * Used to configure txpower for station.\n *\n * @power: indicates the tx power, in dBm, to be used when sending data frames\n *\tto the STA.\n * @type: In particular if TPC %type is NL80211_TX_POWER_LIMITED then tx power\n *\twill be less than or equal to specified from userspace, whereas if TPC\n *\t%type is NL80211_TX_POWER_AUTOMATIC then it indicates default tx power.\n *\tNL80211_TX_POWER_FIXED is not a valid configuration option for\n *\tper peer TPC.\n */\nstruct ieee80211_sta_txpwr {\n\ts16 power;\n\tenum nl80211_tx_power_setting type;\n};\n\n/**\n * struct ieee80211_sta - station table entry\n *\n * A station table entry represents a station we are possibly\n * communicating with. Since stations are RCU-managed in\n * mac80211, any ieee80211_sta pointer you get access to must\n * either be protected by rcu_read_lock() explicitly or implicitly,\n * or you must take good care to not use such a pointer after a\n * call to your sta_remove callback that removed it.\n *\n * @addr: MAC address\n * @aid: AID we assigned to the station if we're an AP\n * @supp_rates: Bitmap of supported rates (per band)\n * @ht_cap: HT capabilities of this STA; restricted to our own capabilities\n * @vht_cap: VHT capabilities of this STA; restricted to our own capabilities\n * @he_cap: HE capabilities of this STA\n * @he_6ghz_capa: on 6 GHz, holds the HE 6 GHz band capabilities\n * @max_rx_aggregation_subframes: maximal amount of frames in a single AMPDU\n *\tthat this station is allowed to transmit to us.\n *\tCan be modified by driver.\n * @wme: indicates whether the STA supports QoS/WME (if local devices does,\n *\totherwise always false)\n * @drv_priv: data area for driver use, will always be aligned to\n *\tsizeof(void \\*), size is determined in hw information.\n * @uapsd_queues: bitmap of queues configured for uapsd. Only valid\n *\tif wme is supported. The bits order is like in\n *\tIEEE80211_WMM_IE_STA_QOSINFO_AC_*.\n * @max_sp: max Service Period. Only valid if wme is supported.\n * @bandwidth: current bandwidth the station can receive with\n * @rx_nss: in HT/VHT, the maximum number of spatial streams the\n *\tstation can receive at the moment, changed by operating mode\n *\tnotifications and capabilities. The value is only valid after\n *\tthe station moves to associated state.\n * @smps_mode: current SMPS mode (off, static or dynamic)\n * @rates: rate control selection table\n * @tdls: indicates whether the STA is a TDLS peer\n * @tdls_initiator: indicates the STA is an initiator of the TDLS link. Only\n *\tvalid if the STA is a TDLS peer in the first place.\n * @mfp: indicates whether the STA uses management frame protection or not.\n * @max_amsdu_subframes: indicates the maximal number of MSDUs in a single\n *\tA-MSDU. Taken from the Extended Capabilities element. 0 means\n *\tunlimited.\n * @support_p2p_ps: indicates whether the STA supports P2P PS mechanism or not.\n * @max_rc_amsdu_len: Maximum A-MSDU size in bytes recommended by rate control.\n * @max_tid_amsdu_len: Maximum A-MSDU size in bytes for this TID\n * @txpwr: the station tx power configuration\n * @txq: per-TID data TX queues (if driver uses the TXQ abstraction); note that\n *\tthe last entry (%IEEE80211_NUM_TIDS) is used for non-data frames\n */\nstruct ieee80211_sta {\n\tu32 supp_rates[NUM_NL80211_BANDS];\n\tu8 addr[ETH_ALEN];\n\tu16 aid;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct ieee80211_sta_he_cap he_cap;\n\tstruct ieee80211_he_6ghz_capa he_6ghz_capa;\n\tu16 max_rx_aggregation_subframes;\n\tbool wme;\n\tu8 uapsd_queues;\n\tu8 max_sp;\n\tu8 rx_nss;\n\tenum ieee80211_sta_rx_bandwidth bandwidth;\n\tenum ieee80211_smps_mode smps_mode;\n\tstruct ieee80211_sta_rates __rcu *rates;\n\tbool tdls;\n\tbool tdls_initiator;\n\tbool mfp;\n\tu8 max_amsdu_subframes;\n\n\t/**\n\t * @max_amsdu_len:\n\t * indicates the maximal length of an A-MSDU in bytes.\n\t * This field is always valid for packets with a VHT preamble.\n\t * For packets with a HT preamble, additional limits apply:\n\t *\n\t * * If the skb is transmitted as part of a BA agreement, the\n\t *   A-MSDU maximal size is min(max_amsdu_len, 4065) bytes.\n\t * * If the skb is not part of a BA agreement, the A-MSDU maximal\n\t *   size is min(max_amsdu_len, 7935) bytes.\n\t *\n\t * Both additional HT limits must be enforced by the low level\n\t * driver. This is defined by the spec (IEEE 802.11-2012 section\n\t * 8.3.2.2 NOTE 2).\n\t */\n\tu16 max_amsdu_len;\n\tbool support_p2p_ps;\n\tu16 max_rc_amsdu_len;\n\tu16 max_tid_amsdu_len[IEEE80211_NUM_TIDS];\n\tstruct ieee80211_sta_txpwr txpwr;\n\n\tstruct ieee80211_txq *txq[IEEE80211_NUM_TIDS + 1];\n\n\t/* must be last */\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n/**\n * enum sta_notify_cmd - sta notify command\n *\n * Used with the sta_notify() callback in &struct ieee80211_ops, this\n * indicates if an associated station made a power state transition.\n *\n * @STA_NOTIFY_SLEEP: a station is now sleeping\n * @STA_NOTIFY_AWAKE: a sleeping station woke up\n */\nenum sta_notify_cmd {\n\tSTA_NOTIFY_SLEEP, STA_NOTIFY_AWAKE,\n};\n\n/**\n * struct ieee80211_tx_control - TX control data\n *\n * @sta: station table entry, this sta pointer may be NULL and\n * \tit is not allowed to copy the pointer, due to RCU.\n */\nstruct ieee80211_tx_control {\n\tstruct ieee80211_sta *sta;\n};\n\n/**\n * struct ieee80211_txq - Software intermediate tx queue\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @sta: station table entry, %NULL for per-vif queue\n * @tid: the TID for this queue (unused for per-vif queue),\n *\t%IEEE80211_NUM_TIDS for non-data (if enabled)\n * @ac: the AC for this queue\n * @drv_priv: driver private area, sized by hw->txq_data_size\n *\n * The driver can obtain packets from this queue by calling\n * ieee80211_tx_dequeue().\n */\nstruct ieee80211_txq {\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *sta;\n\tu8 tid;\n\tu8 ac;\n\n\t/* must be last */\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n/**\n * enum ieee80211_hw_flags - hardware flags\n *\n * These flags are used to indicate hardware capabilities to\n * the stack. Generally, flags here should have their meaning\n * done in a way that the simplest hardware doesn't need setting\n * any particular flags. There are some exceptions to this rule,\n * however, so you are advised to review these flags carefully.\n *\n * @IEEE80211_HW_HAS_RATE_CONTROL:\n *\tThe hardware or firmware includes rate control, and cannot be\n *\tcontrolled by the stack. As such, no rate control algorithm\n *\tshould be instantiated, and the TX rate reported to userspace\n *\twill be taken from the TX status instead of the rate control\n *\talgorithm.\n *\tNote that this requires that the driver implement a number of\n *\tcallbacks so it has the correct information, it needs to have\n *\tthe @set_rts_threshold callback and must look at the BSS config\n *\t@use_cts_prot for G/N protection, @use_short_slot for slot\n *\ttiming in 2.4 GHz and @use_short_preamble for preambles for\n *\tCCK frames.\n *\n * @IEEE80211_HW_RX_INCLUDES_FCS:\n *\tIndicates that received frames passed to the stack include\n *\tthe FCS at the end.\n *\n * @IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING:\n *\tSome wireless LAN chipsets buffer broadcast/multicast frames\n *\tfor power saving stations in the hardware/firmware and others\n *\trely on the host system for such buffering. This option is used\n *\tto configure the IEEE 802.11 upper layer to buffer broadcast and\n *\tmulticast frames when there are power saving stations so that\n *\tthe driver can fetch them with ieee80211_get_buffered_bc().\n *\n * @IEEE80211_HW_SIGNAL_UNSPEC:\n *\tHardware can provide signal values but we don't know its units. We\n *\texpect values between 0 and @max_signal.\n *\tIf possible please provide dB or dBm instead.\n *\n * @IEEE80211_HW_SIGNAL_DBM:\n *\tHardware gives signal values in dBm, decibel difference from\n *\tone milliwatt. This is the preferred method since it is standardized\n *\tbetween different devices. @max_signal does not need to be set.\n *\n * @IEEE80211_HW_SPECTRUM_MGMT:\n * \tHardware supports spectrum management defined in 802.11h\n * \tMeasurement, Channel Switch, Quieting, TPC\n *\n * @IEEE80211_HW_AMPDU_AGGREGATION:\n *\tHardware supports 11n A-MPDU aggregation.\n *\n * @IEEE80211_HW_SUPPORTS_PS:\n *\tHardware has power save support (i.e. can go to sleep).\n *\n * @IEEE80211_HW_PS_NULLFUNC_STACK:\n *\tHardware requires nullfunc frame handling in stack, implies\n *\tstack support for dynamic PS.\n *\n * @IEEE80211_HW_SUPPORTS_DYNAMIC_PS:\n *\tHardware has support for dynamic PS.\n *\n * @IEEE80211_HW_MFP_CAPABLE:\n *\tHardware supports management frame protection (MFP, IEEE 802.11w).\n *\n * @IEEE80211_HW_REPORTS_TX_ACK_STATUS:\n *\tHardware can provide ack status reports of Tx frames to\n *\tthe stack.\n *\n * @IEEE80211_HW_CONNECTION_MONITOR:\n *\tThe hardware performs its own connection monitoring, including\n *\tperiodic keep-alives to the AP and probing the AP on beacon loss.\n *\n * @IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC:\n *\tThis device needs to get data from beacon before association (i.e.\n *\tdtim_period).\n *\n * @IEEE80211_HW_SUPPORTS_PER_STA_GTK: The device's crypto engine supports\n *\tper-station GTKs as used by IBSS RSN or during fast transition. If\n *\tthe device doesn't support per-station GTKs, but can be asked not\n *\tto decrypt group addressed frames, then IBSS RSN support is still\n *\tpossible but software crypto will be used. Advertise the wiphy flag\n *\tonly in that case.\n *\n * @IEEE80211_HW_AP_LINK_PS: When operating in AP mode the device\n *\tautonomously manages the PS status of connected stations. When\n *\tthis flag is set mac80211 will not trigger PS mode for connected\n *\tstations based on the PM bit of incoming frames.\n *\tUse ieee80211_start_ps()/ieee8021_end_ps() to manually configure\n *\tthe PS mode of connected stations.\n *\n * @IEEE80211_HW_TX_AMPDU_SETUP_IN_HW: The device handles TX A-MPDU session\n *\tsetup strictly in HW. mac80211 should not attempt to do this in\n *\tsoftware.\n *\n * @IEEE80211_HW_WANT_MONITOR_VIF: The driver would like to be informed of\n *\ta virtual monitor interface when monitor interfaces are the only\n *\tactive interfaces.\n *\n * @IEEE80211_HW_NO_AUTO_VIF: The driver would like for no wlanX to\n *\tbe created.  It is expected user-space will create vifs as\n *\tdesired (and thus have them named as desired).\n *\n * @IEEE80211_HW_SW_CRYPTO_CONTROL: The driver wants to control which of the\n *\tcrypto algorithms can be done in software - so don't automatically\n *\ttry to fall back to it if hardware crypto fails, but do so only if\n *\tthe driver returns 1. This also forces the driver to advertise its\n *\tsupported cipher suites.\n *\n * @IEEE80211_HW_SUPPORT_FAST_XMIT: The driver/hardware supports fast-xmit,\n *\tthis currently requires only the ability to calculate the duration\n *\tfor frames.\n *\n * @IEEE80211_HW_QUEUE_CONTROL: The driver wants to control per-interface\n *\tqueue mapping in order to use different queues (not just one per AC)\n *\tfor different virtual interfaces. See the doc section on HW queue\n *\tcontrol for more details.\n *\n * @IEEE80211_HW_SUPPORTS_RC_TABLE: The driver supports using a rate\n *\tselection table provided by the rate control algorithm.\n *\n * @IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF: Use the P2P Device address for any\n *\tP2P Interface. This will be honoured even if more than one interface\n *\tis supported.\n *\n * @IEEE80211_HW_TIMING_BEACON_ONLY: Use sync timing from beacon frames\n *\tonly, to allow getting TBTT of a DTIM beacon.\n *\n * @IEEE80211_HW_SUPPORTS_HT_CCK_RATES: Hardware supports mixing HT/CCK rates\n *\tand can cope with CCK rates in an aggregation session (e.g. by not\n *\tusing aggregation for such frames.)\n *\n * @IEEE80211_HW_CHANCTX_STA_CSA: Support 802.11h based channel-switch (CSA)\n *\tfor a single active channel while using channel contexts. When support\n *\tis not enabled the default action is to disconnect when getting the\n *\tCSA frame.\n *\n * @IEEE80211_HW_SUPPORTS_CLONED_SKBS: The driver will never modify the payload\n *\tor tailroom of TX skbs without copying them first.\n *\n * @IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS: The HW supports scanning on all bands\n *\tin one command, mac80211 doesn't have to run separate scans per band.\n *\n * @IEEE80211_HW_TDLS_WIDER_BW: The device/driver supports wider bandwidth\n *\tthan then BSS bandwidth for a TDLS link on the base channel.\n *\n * @IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU: The driver supports receiving A-MSDUs\n *\twithin A-MPDU.\n *\n * @IEEE80211_HW_BEACON_TX_STATUS: The device/driver provides TX status\n *\tfor sent beacons.\n *\n * @IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR: Hardware (or driver) requires that each\n *\tstation has a unique address, i.e. each station entry can be identified\n *\tby just its MAC address; this prevents, for example, the same station\n *\tfrom connecting to two virtual AP interfaces at the same time.\n *\n * @IEEE80211_HW_SUPPORTS_REORDERING_BUFFER: Hardware (or driver) manages the\n *\treordering buffer internally, guaranteeing mac80211 receives frames in\n *\torder and does not need to manage its own reorder buffer or BA session\n *\ttimeout.\n *\n * @IEEE80211_HW_USES_RSS: The device uses RSS and thus requires parallel RX,\n *\twhich implies using per-CPU station statistics.\n *\n * @IEEE80211_HW_TX_AMSDU: Hardware (or driver) supports software aggregated\n *\tA-MSDU frames. Requires software tx queueing and fast-xmit support.\n *\tWhen not using minstrel/minstrel_ht rate control, the driver must\n *\tlimit the maximum A-MSDU size based on the current tx rate by setting\n *\tmax_rc_amsdu_len in struct ieee80211_sta.\n *\n * @IEEE80211_HW_TX_FRAG_LIST: Hardware (or driver) supports sending frag_list\n *\tskbs, needed for zero-copy software A-MSDU.\n *\n * @IEEE80211_HW_REPORTS_LOW_ACK: The driver (or firmware) reports low ack event\n *\tby ieee80211_report_low_ack() based on its own algorithm. For such\n *\tdrivers, mac80211 packet loss mechanism will not be triggered and driver\n *\tis completely depending on firmware event for station kickout.\n *\n * @IEEE80211_HW_SUPPORTS_TX_FRAG: Hardware does fragmentation by itself.\n *\tThe stack will not do fragmentation.\n *\tThe callback for @set_frag_threshold should be set as well.\n *\n * @IEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA: Hardware supports buffer STA on\n *\tTDLS links.\n *\n * @IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP: The driver requires the\n *\tmgd_prepare_tx() callback to be called before transmission of a\n *\tdeauthentication frame in case the association was completed but no\n *\tbeacon was heard. This is required in multi-channel scenarios, where the\n *\tvirtual interface might not be given air time for the transmission of\n *\tthe frame, as it is not synced with the AP/P2P GO yet, and thus the\n *\tdeauthentication frame might not be transmitted.\n *\n * @IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP: The driver (or firmware) doesn't\n *\tsupport QoS NDP for AP probing - that's most likely a driver bug.\n *\n * @IEEE80211_HW_BUFF_MMPDU_TXQ: use the TXQ for bufferable MMPDUs, this of\n *\tcourse requires the driver to use TXQs to start with.\n *\n * @IEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW: (Hardware) rate control supports VHT\n *\textended NSS BW (dot11VHTExtendedNSSBWCapable). This flag will be set if\n *\tthe selected rate control algorithm sets %RATE_CTRL_CAPA_VHT_EXT_NSS_BW\n *\tbut if the rate control is built-in then it must be set by the driver.\n *\tSee also the documentation for that flag.\n *\n * @IEEE80211_HW_STA_MMPDU_TXQ: use the extra non-TID per-station TXQ for all\n *\tMMPDUs on station interfaces. This of course requires the driver to use\n *\tTXQs to start with.\n *\n * @IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN: Driver does not report accurate A-MPDU\n *\tlength in tx status information\n *\n * @IEEE80211_HW_SUPPORTS_MULTI_BSSID: Hardware supports multi BSSID\n *\n * @IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID: Hardware supports multi BSSID\n *\tonly for HE APs. Applies if @IEEE80211_HW_SUPPORTS_MULTI_BSSID is set.\n *\n * @IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT: The card and driver is only\n *\taggregating MPDUs with the same keyid, allowing mac80211 to keep Tx\n *\tA-MPDU sessions active while rekeying with Extended Key ID.\n *\n * @IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD: Hardware supports tx encapsulation\n *\toffload\n *\n * @IEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD: Hardware supports rx decapsulation\n *\toffload\n *\n * @IEEE80211_HW_SUPPORTS_CONC_MON_RX_DECAP: Hardware supports concurrent rx\n *\tdecapsulation offload and passing raw 802.11 frames for monitor iface.\n *\tIf this is supported, the driver must pass both 802.3 frames for real\n *\tusage and 802.11 frames with %RX_FLAG_ONLY_MONITOR set for monitor to\n *\tthe stack.\n *\n * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays\n */\nenum ieee80211_hw_flags {\n\tIEEE80211_HW_HAS_RATE_CONTROL,\n\tIEEE80211_HW_RX_INCLUDES_FCS,\n\tIEEE80211_HW_HOST_BROADCAST_PS_BUFFERING,\n\tIEEE80211_HW_SIGNAL_UNSPEC,\n\tIEEE80211_HW_SIGNAL_DBM,\n\tIEEE80211_HW_NEED_DTIM_BEFORE_ASSOC,\n\tIEEE80211_HW_SPECTRUM_MGMT,\n\tIEEE80211_HW_AMPDU_AGGREGATION,\n\tIEEE80211_HW_SUPPORTS_PS,\n\tIEEE80211_HW_PS_NULLFUNC_STACK,\n\tIEEE80211_HW_SUPPORTS_DYNAMIC_PS,\n\tIEEE80211_HW_MFP_CAPABLE,\n\tIEEE80211_HW_WANT_MONITOR_VIF,\n\tIEEE80211_HW_NO_AUTO_VIF,\n\tIEEE80211_HW_SW_CRYPTO_CONTROL,\n\tIEEE80211_HW_SUPPORT_FAST_XMIT,\n\tIEEE80211_HW_REPORTS_TX_ACK_STATUS,\n\tIEEE80211_HW_CONNECTION_MONITOR,\n\tIEEE80211_HW_QUEUE_CONTROL,\n\tIEEE80211_HW_SUPPORTS_PER_STA_GTK,\n\tIEEE80211_HW_AP_LINK_PS,\n\tIEEE80211_HW_TX_AMPDU_SETUP_IN_HW,\n\tIEEE80211_HW_SUPPORTS_RC_TABLE,\n\tIEEE80211_HW_P2P_DEV_ADDR_FOR_INTF,\n\tIEEE80211_HW_TIMING_BEACON_ONLY,\n\tIEEE80211_HW_SUPPORTS_HT_CCK_RATES,\n\tIEEE80211_HW_CHANCTX_STA_CSA,\n\tIEEE80211_HW_SUPPORTS_CLONED_SKBS,\n\tIEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS,\n\tIEEE80211_HW_TDLS_WIDER_BW,\n\tIEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU,\n\tIEEE80211_HW_BEACON_TX_STATUS,\n\tIEEE80211_HW_NEEDS_UNIQUE_STA_ADDR,\n\tIEEE80211_HW_SUPPORTS_REORDERING_BUFFER,\n\tIEEE80211_HW_USES_RSS,\n\tIEEE80211_HW_TX_AMSDU,\n\tIEEE80211_HW_TX_FRAG_LIST,\n\tIEEE80211_HW_REPORTS_LOW_ACK,\n\tIEEE80211_HW_SUPPORTS_TX_FRAG,\n\tIEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA,\n\tIEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP,\n\tIEEE80211_HW_DOESNT_SUPPORT_QOS_NDP,\n\tIEEE80211_HW_BUFF_MMPDU_TXQ,\n\tIEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW,\n\tIEEE80211_HW_STA_MMPDU_TXQ,\n\tIEEE80211_HW_TX_STATUS_NO_AMPDU_LEN,\n\tIEEE80211_HW_SUPPORTS_MULTI_BSSID,\n\tIEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID,\n\tIEEE80211_HW_AMPDU_KEYBORDER_SUPPORT,\n\tIEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD,\n\tIEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD,\n\tIEEE80211_HW_SUPPORTS_CONC_MON_RX_DECAP,\n\n\t/* keep last, obviously */\n\tNUM_IEEE80211_HW_FLAGS\n};\n\n/**\n * struct ieee80211_hw - hardware information and state\n *\n * This structure contains the configuration and hardware\n * information for an 802.11 PHY.\n *\n * @wiphy: This points to the &struct wiphy allocated for this\n *\t802.11 PHY. You must fill in the @perm_addr and @dev\n *\tmembers of this structure using SET_IEEE80211_DEV()\n *\tand SET_IEEE80211_PERM_ADDR(). Additionally, all supported\n *\tbands (with channels, bitrates) are registered here.\n *\n * @conf: &struct ieee80211_conf, device configuration, don't use.\n *\n * @priv: pointer to private area that was allocated for driver use\n *\talong with this structure.\n *\n * @flags: hardware flags, see &enum ieee80211_hw_flags.\n *\n * @extra_tx_headroom: headroom to reserve in each transmit skb\n *\tfor use by the driver (e.g. for transmit headers.)\n *\n * @extra_beacon_tailroom: tailroom to reserve in each beacon tx skb.\n *\tCan be used by drivers to add extra IEs.\n *\n * @max_signal: Maximum value for signal (rssi) in RX information, used\n *\tonly when @IEEE80211_HW_SIGNAL_UNSPEC or @IEEE80211_HW_SIGNAL_DB\n *\n * @max_listen_interval: max listen interval in units of beacon interval\n *\tthat HW supports\n *\n * @queues: number of available hardware transmit queues for\n *\tdata packets. WMM/QoS requires at least four, these\n *\tqueues need to have configurable access parameters.\n *\n * @rate_control_algorithm: rate control algorithm for this hardware.\n *\tIf unset (NULL), the default algorithm will be used. Must be\n *\tset before calling ieee80211_register_hw().\n *\n * @vif_data_size: size (in bytes) of the drv_priv data area\n *\twithin &struct ieee80211_vif.\n * @sta_data_size: size (in bytes) of the drv_priv data area\n *\twithin &struct ieee80211_sta.\n * @chanctx_data_size: size (in bytes) of the drv_priv data area\n *\twithin &struct ieee80211_chanctx_conf.\n * @txq_data_size: size (in bytes) of the drv_priv data area\n *\twithin @struct ieee80211_txq.\n *\n * @max_rates: maximum number of alternate rate retry stages the hw\n *\tcan handle.\n * @max_report_rates: maximum number of alternate rate retry stages\n *\tthe hw can report back.\n * @max_rate_tries: maximum number of tries for each stage\n *\n * @max_rx_aggregation_subframes: maximum buffer size (number of\n *\tsub-frames) to be used for A-MPDU block ack receiver\n *\taggregation.\n *\tThis is only relevant if the device has restrictions on the\n *\tnumber of subframes, if it relies on mac80211 to do reordering\n *\tit shouldn't be set.\n *\n * @max_tx_aggregation_subframes: maximum number of subframes in an\n *\taggregate an HT/HE device will transmit. In HT AddBA we'll\n *\tadvertise a constant value of 64 as some older APs crash if\n *\tthe window size is smaller (an example is LinkSys WRT120N\n *\twith FW v1.0.07 build 002 Jun 18 2012).\n *\tFor AddBA to HE capable peers this value will be used.\n *\n * @max_tx_fragments: maximum number of tx buffers per (A)-MSDU, sum\n *\tof 1 + skb_shinfo(skb)->nr_frags for each skb in the frag_list.\n *\n * @offchannel_tx_hw_queue: HW queue ID to use for offchannel TX\n *\t(if %IEEE80211_HW_QUEUE_CONTROL is set)\n *\n * @radiotap_mcs_details: lists which MCS information can the HW\n *\treports, by default it is set to _MCS, _GI and _BW but doesn't\n *\tinclude _FMT. Use %IEEE80211_RADIOTAP_MCS_HAVE_\\* values, only\n *\tadding _BW is supported today.\n *\n * @radiotap_vht_details: lists which VHT MCS information the HW reports,\n *\tthe default is _GI | _BANDWIDTH.\n *\tUse the %IEEE80211_RADIOTAP_VHT_KNOWN_\\* values.\n *\n * @radiotap_he: HE radiotap validity flags\n *\n * @radiotap_timestamp: Information for the radiotap timestamp field; if the\n *\t@units_pos member is set to a non-negative value then the timestamp\n *\tfield will be added and populated from the &struct ieee80211_rx_status\n *\tdevice_timestamp.\n * @radiotap_timestamp.units_pos: Must be set to a combination of a\n *\tIEEE80211_RADIOTAP_TIMESTAMP_UNIT_* and a\n *\tIEEE80211_RADIOTAP_TIMESTAMP_SPOS_* value.\n * @radiotap_timestamp.accuracy: If non-negative, fills the accuracy in the\n *\tradiotap field and the accuracy known flag will be set.\n *\n * @netdev_features: netdev features to be set in each netdev created\n *\tfrom this HW. Note that not all features are usable with mac80211,\n *\tother features will be rejected during HW registration.\n *\n * @uapsd_queues: This bitmap is included in (re)association frame to indicate\n *\tfor each access category if it is uAPSD trigger-enabled and delivery-\n *\tenabled. Use IEEE80211_WMM_IE_STA_QOSINFO_AC_* to set this bitmap.\n *\tEach bit corresponds to different AC. Value '1' in specific bit means\n *\tthat corresponding AC is both trigger- and delivery-enabled. '0' means\n *\tneither enabled.\n *\n * @uapsd_max_sp_len: maximum number of total buffered frames the WMM AP may\n *\tdeliver to a WMM STA during any Service Period triggered by the WMM STA.\n *\tUse IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct values.\n *\n * @n_cipher_schemes: a size of an array of cipher schemes definitions.\n * @cipher_schemes: a pointer to an array of cipher scheme definitions\n *\tsupported by HW.\n * @max_nan_de_entries: maximum number of NAN DE functions supported by the\n *\tdevice.\n *\n * @tx_sk_pacing_shift: Pacing shift to set on TCP sockets when frames from\n *\tthem are encountered. The default should typically not be changed,\n *\tunless the driver has good reasons for needing more buffers.\n *\n * @weight_multiplier: Driver specific airtime weight multiplier used while\n *\trefilling deficit of each TXQ.\n *\n * @max_mtu: the max mtu could be set.\n */\nstruct ieee80211_hw {\n\tstruct ieee80211_conf conf;\n\tstruct wiphy *wiphy;\n\tconst char *rate_control_algorithm;\n\tvoid *priv;\n\tunsigned long flags[BITS_TO_LONGS(NUM_IEEE80211_HW_FLAGS)];\n\tunsigned int extra_tx_headroom;\n\tunsigned int extra_beacon_tailroom;\n\tint vif_data_size;\n\tint sta_data_size;\n\tint chanctx_data_size;\n\tint txq_data_size;\n\tu16 queues;\n\tu16 max_listen_interval;\n\ts8 max_signal;\n\tu8 max_rates;\n\tu8 max_report_rates;\n\tu8 max_rate_tries;\n\tu16 max_rx_aggregation_subframes;\n\tu16 max_tx_aggregation_subframes;\n\tu8 max_tx_fragments;\n\tu8 offchannel_tx_hw_queue;\n\tu8 radiotap_mcs_details;\n\tu16 radiotap_vht_details;\n\tstruct {\n\t\tint units_pos;\n\t\ts16 accuracy;\n\t} radiotap_timestamp;\n\tnetdev_features_t netdev_features;\n\tu8 uapsd_queues;\n\tu8 uapsd_max_sp_len;\n\tu8 n_cipher_schemes;\n\tconst struct ieee80211_cipher_scheme *cipher_schemes;\n\tu8 max_nan_de_entries;\n\tu8 tx_sk_pacing_shift;\n\tu8 weight_multiplier;\n\tu32 max_mtu;\n};\n\nstatic inline bool _ieee80211_hw_check(struct ieee80211_hw *hw,\n\t\t\t\t       enum ieee80211_hw_flags flg)\n{\n\treturn test_bit(flg, hw->flags);\n}\n#define ieee80211_hw_check(hw, flg)\t_ieee80211_hw_check(hw, IEEE80211_HW_##flg)\n\nstatic inline void _ieee80211_hw_set(struct ieee80211_hw *hw,\n\t\t\t\t     enum ieee80211_hw_flags flg)\n{\n\treturn __set_bit(flg, hw->flags);\n}\n#define ieee80211_hw_set(hw, flg)\t_ieee80211_hw_set(hw, IEEE80211_HW_##flg)\n\n/**\n * struct ieee80211_scan_request - hw scan request\n *\n * @ies: pointers different parts of IEs (in req.ie)\n * @req: cfg80211 request.\n */\nstruct ieee80211_scan_request {\n\tstruct ieee80211_scan_ies ies;\n\n\t/* Keep last */\n\tstruct cfg80211_scan_request req;\n};\n\n/**\n * struct ieee80211_tdls_ch_sw_params - TDLS channel switch parameters\n *\n * @sta: peer this TDLS channel-switch request/response came from\n * @chandef: channel referenced in a TDLS channel-switch request\n * @action_code: see &enum ieee80211_tdls_actioncode\n * @status: channel-switch response status\n * @timestamp: time at which the frame was received\n * @switch_time: switch-timing parameter received in the frame\n * @switch_timeout: switch-timing parameter received in the frame\n * @tmpl_skb: TDLS switch-channel response template\n * @ch_sw_tm_ie: offset of the channel-switch timing IE inside @tmpl_skb\n */\nstruct ieee80211_tdls_ch_sw_params {\n\tstruct ieee80211_sta *sta;\n\tstruct cfg80211_chan_def *chandef;\n\tu8 action_code;\n\tu32 status;\n\tu32 timestamp;\n\tu16 switch_time;\n\tu16 switch_timeout;\n\tstruct sk_buff *tmpl_skb;\n\tu32 ch_sw_tm_ie;\n};\n\n/**\n * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy\n *\n * @wiphy: the &struct wiphy which we want to query\n *\n * mac80211 drivers can use this to get to their respective\n * &struct ieee80211_hw. Drivers wishing to get to their own private\n * structure can then access it via hw->priv. Note that mac802111 drivers should\n * not use wiphy_priv() to try to get their private driver structure as this\n * is already used internally by mac80211.\n *\n * Return: The mac80211 driver hw struct of @wiphy.\n */\nstruct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);\n\n/**\n * SET_IEEE80211_DEV - set device for 802.11 hardware\n *\n * @hw: the &struct ieee80211_hw to set the device for\n * @dev: the &struct device of this 802.11 device\n */\nstatic inline void SET_IEEE80211_DEV(struct ieee80211_hw *hw, struct device *dev)\n{\n\tset_wiphy_dev(hw->wiphy, dev);\n}\n\n/**\n * SET_IEEE80211_PERM_ADDR - set the permanent MAC address for 802.11 hardware\n *\n * @hw: the &struct ieee80211_hw to set the MAC address for\n * @addr: the address to set\n */\nstatic inline void SET_IEEE80211_PERM_ADDR(struct ieee80211_hw *hw, const u8 *addr)\n{\n\tmemcpy(hw->wiphy->perm_addr, addr, ETH_ALEN);\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_tx_rate(const struct ieee80211_hw *hw,\n\t\t      const struct ieee80211_tx_info *c)\n{\n\tif (WARN_ON_ONCE(c->control.rates[0].idx < 0))\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rates[0].idx];\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_rts_cts_rate(const struct ieee80211_hw *hw,\n\t\t\t   const struct ieee80211_tx_info *c)\n{\n\tif (c->control.rts_cts_rate_idx < 0)\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rts_cts_rate_idx];\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,\n\t\t\t     const struct ieee80211_tx_info *c, int idx)\n{\n\tif (c->control.rates[idx + 1].idx < 0)\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rates[idx + 1].idx];\n}\n\n/**\n * ieee80211_free_txskb - free TX skb\n * @hw: the hardware\n * @skb: the skb\n *\n * Free a transmit skb. Use this function when some failure\n * to transmit happened and thus status cannot be reported.\n */\nvoid ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);\n\n/**\n * DOC: Hardware crypto acceleration\n *\n * mac80211 is capable of taking advantage of many hardware\n * acceleration designs for encryption and decryption operations.\n *\n * The set_key() callback in the &struct ieee80211_ops for a given\n * device is called to enable hardware acceleration of encryption and\n * decryption. The callback takes a @sta parameter that will be NULL\n * for default keys or keys used for transmission only, or point to\n * the station information for the peer for individual keys.\n * Multiple transmission keys with the same key index may be used when\n * VLANs are configured for an access point.\n *\n * When transmitting, the TX control data will use the @hw_key_idx\n * selected by the driver by modifying the &struct ieee80211_key_conf\n * pointed to by the @key parameter to the set_key() function.\n *\n * The set_key() call for the %SET_KEY command should return 0 if\n * the key is now in use, -%EOPNOTSUPP or -%ENOSPC if it couldn't be\n * added; if you return 0 then hw_key_idx must be assigned to the\n * hardware key index, you are free to use the full u8 range.\n *\n * Note that in the case that the @IEEE80211_HW_SW_CRYPTO_CONTROL flag is\n * set, mac80211 will not automatically fall back to software crypto if\n * enabling hardware crypto failed. The set_key() call may also return the\n * value 1 to permit this specific key/algorithm to be done in software.\n *\n * When the cmd is %DISABLE_KEY then it must succeed.\n *\n * Note that it is permissible to not decrypt a frame even if a key\n * for it has been uploaded to hardware, the stack will not make any\n * decision based on whether a key has been uploaded or not but rather\n * based on the receive flags.\n *\n * The &struct ieee80211_key_conf structure pointed to by the @key\n * parameter is guaranteed to be valid until another call to set_key()\n * removes it, but it can only be used as a cookie to differentiate\n * keys.\n *\n * In TKIP some HW need to be provided a phase 1 key, for RX decryption\n * acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key\n * handler.\n * The update_tkip_key() call updates the driver with the new phase 1 key.\n * This happens every time the iv16 wraps around (every 65536 packets). The\n * set_key() call will happen only once for each key (unless the AP did\n * rekeying), it will not include a valid phase 1 key. The valid phase 1 key is\n * provided by update_tkip_key only. The trigger that makes mac80211 call this\n * handler is software decryption with wrap around of iv16.\n *\n * The set_default_unicast_key() call updates the default WEP key index\n * configured to the hardware for WEP encryption type. This is required\n * for devices that support offload of data packets (e.g. ARP responses).\n *\n * Mac80211 drivers should set the @NL80211_EXT_FEATURE_CAN_REPLACE_PTK0 flag\n * when they are able to replace in-use PTK keys according to the following\n * requirements:\n * 1) They do not hand over frames decrypted with the old key to\n      mac80211 once the call to set_key() with command %DISABLE_KEY has been\n      completed when also setting @IEEE80211_KEY_FLAG_GENERATE_IV for any key,\n   2) either drop or continue to use the old key for any outgoing frames queued\n      at the time of the key deletion (including re-transmits),\n   3) never send out a frame queued prior to the set_key() %SET_KEY command\n      encrypted with the new key and\n   4) never send out a frame unencrypted when it should be encrypted.\n   Mac80211 will not queue any new frames for a deleted key to the driver.\n */\n\n/**\n * DOC: Powersave support\n *\n * mac80211 has support for various powersave implementations.\n *\n * First, it can support hardware that handles all powersaving by itself,\n * such hardware should simply set the %IEEE80211_HW_SUPPORTS_PS hardware\n * flag. In that case, it will be told about the desired powersave mode\n * with the %IEEE80211_CONF_PS flag depending on the association status.\n * The hardware must take care of sending nullfunc frames when necessary,\n * i.e. when entering and leaving powersave mode. The hardware is required\n * to look at the AID in beacons and signal to the AP that it woke up when\n * it finds traffic directed to it.\n *\n * %IEEE80211_CONF_PS flag enabled means that the powersave mode defined in\n * IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused\n * with hardware wakeup and sleep states. Driver is responsible for waking\n * up the hardware before issuing commands to the hardware and putting it\n * back to sleep at appropriate times.\n *\n * When PS is enabled, hardware needs to wakeup for beacons and receive the\n * buffered multicast/broadcast frames after the beacon. Also it must be\n * possible to send frames and receive the acknowledment frame.\n *\n * Other hardware designs cannot send nullfunc frames by themselves and also\n * need software support for parsing the TIM bitmap. This is also supported\n * by mac80211 by combining the %IEEE80211_HW_SUPPORTS_PS and\n * %IEEE80211_HW_PS_NULLFUNC_STACK flags. The hardware is of course still\n * required to pass up beacons. The hardware is still required to handle\n * waking up for multicast traffic; if it cannot the driver must handle that\n * as best as it can, mac80211 is too slow to do that.\n *\n * Dynamic powersave is an extension to normal powersave in which the\n * hardware stays awake for a user-specified period of time after sending a\n * frame so that reply frames need not be buffered and therefore delayed to\n * the next wakeup. It's compromise of getting good enough latency when\n * there's data traffic and still saving significantly power in idle\n * periods.\n *\n * Dynamic powersave is simply supported by mac80211 enabling and disabling\n * PS based on traffic. Driver needs to only set %IEEE80211_HW_SUPPORTS_PS\n * flag and mac80211 will handle everything automatically. Additionally,\n * hardware having support for the dynamic PS feature may set the\n * %IEEE80211_HW_SUPPORTS_DYNAMIC_PS flag to indicate that it can support\n * dynamic PS mode itself. The driver needs to look at the\n * @dynamic_ps_timeout hardware configuration value and use it that value\n * whenever %IEEE80211_CONF_PS is set. In this case mac80211 will disable\n * dynamic PS feature in stack and will just keep %IEEE80211_CONF_PS\n * enabled whenever user has enabled powersave.\n *\n * Driver informs U-APSD client support by enabling\n * %IEEE80211_VIF_SUPPORTS_UAPSD flag. The mode is configured through the\n * uapsd parameter in conf_tx() operation. Hardware needs to send the QoS\n * Nullfunc frames and stay awake until the service period has ended. To\n * utilize U-APSD, dynamic powersave is disabled for voip AC and all frames\n * from that AC are transmitted with powersave enabled.\n *\n * Note: U-APSD client mode is not yet supported with\n * %IEEE80211_HW_PS_NULLFUNC_STACK.\n */\n\n/**\n * DOC: Beacon filter support\n *\n * Some hardware have beacon filter support to reduce host cpu wakeups\n * which will reduce system power consumption. It usually works so that\n * the firmware creates a checksum of the beacon but omits all constantly\n * changing elements (TSF, TIM etc). Whenever the checksum changes the\n * beacon is forwarded to the host, otherwise it will be just dropped. That\n * way the host will only receive beacons where some relevant information\n * (for example ERP protection or WMM settings) have changed.\n *\n * Beacon filter support is advertised with the %IEEE80211_VIF_BEACON_FILTER\n * interface capability. The driver needs to enable beacon filter support\n * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When\n * power save is enabled, the stack will not check for beacon loss and the\n * driver needs to notify about loss of beacons with ieee80211_beacon_loss().\n *\n * The time (or number of beacons missed) until the firmware notifies the\n * driver of a beacon loss event (which in turn causes the driver to call\n * ieee80211_beacon_loss()) should be configurable and will be controlled\n * by mac80211 and the roaming algorithm in the future.\n *\n * Since there may be constantly changing information elements that nothing\n * in the software stack cares about, we will, in the future, have mac80211\n * tell the driver which information elements are interesting in the sense\n * that we want to see changes in them. This will include\n *\n *  - a list of information element IDs\n *  - a list of OUIs for the vendor information element\n *\n * Ideally, the hardware would filter out any beacons without changes in the\n * requested elements, but if it cannot support that it may, at the expense\n * of some efficiency, filter out only a subset. For example, if the device\n * doesn't support checking for OUIs it should pass up all changes in all\n * vendor information elements.\n *\n * Note that change, for the sake of simplification, also includes information\n * elements appearing or disappearing from the beacon.\n *\n * Some hardware supports an \"ignore list\" instead, just make sure nothing\n * that was requested is on the ignore list, and include commonly changing\n * information element IDs in the ignore list, for example 11 (BSS load) and\n * the various vendor-assigned IEs with unknown contents (128, 129, 133-136,\n * 149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility\n * it could also include some currently unused IDs.\n *\n *\n * In addition to these capabilities, hardware should support notifying the\n * host of changes in the beacon RSSI. This is relevant to implement roaming\n * when no traffic is flowing (when traffic is flowing we see the RSSI of\n * the received data packets). This can consist in notifying the host when\n * the RSSI changes significantly or when it drops below or rises above\n * configurable thresholds. In the future these thresholds will also be\n * configured by mac80211 (which gets them from userspace) to implement\n * them as the roaming algorithm requires.\n *\n * If the hardware cannot implement this, the driver should ask it to\n * periodically pass beacon frames to the host so that software can do the\n * signal strength threshold checking.\n */\n\n/**\n * DOC: Spatial multiplexing power save\n *\n * SMPS (Spatial multiplexing power save) is a mechanism to conserve\n * power in an 802.11n implementation. For details on the mechanism\n * and rationale, please refer to 802.11 (as amended by 802.11n-2009)\n * \"11.2.3 SM power save\".\n *\n * The mac80211 implementation is capable of sending action frames\n * to update the AP about the station's SMPS mode, and will instruct\n * the driver to enter the specific mode. It will also announce the\n * requested SMPS mode during the association handshake. Hardware\n * support for this feature is required, and can be indicated by\n * hardware flags.\n *\n * The default mode will be \"automatic\", which nl80211/cfg80211\n * defines to be dynamic SMPS in (regular) powersave, and SMPS\n * turned off otherwise.\n *\n * To support this feature, the driver must set the appropriate\n * hardware support flags, and handle the SMPS flag to the config()\n * operation. It will then with this mechanism be instructed to\n * enter the requested SMPS mode while associated to an HT AP.\n */\n\n/**\n * DOC: Frame filtering\n *\n * mac80211 requires to see many management frames for proper\n * operation, and users may want to see many more frames when\n * in monitor mode. However, for best CPU usage and power consumption,\n * having as few frames as possible percolate through the stack is\n * desirable. Hence, the hardware should filter as much as possible.\n *\n * To achieve this, mac80211 uses filter flags (see below) to tell\n * the driver's configure_filter() function which frames should be\n * passed to mac80211 and which should be filtered out.\n *\n * Before configure_filter() is invoked, the prepare_multicast()\n * callback is invoked with the parameters @mc_count and @mc_list\n * for the combined multicast address list of all virtual interfaces.\n * It's use is optional, and it returns a u64 that is passed to\n * configure_filter(). Additionally, configure_filter() has the\n * arguments @changed_flags telling which flags were changed and\n * @total_flags with the new flag states.\n *\n * If your device has no multicast address filters your driver will\n * need to check both the %FIF_ALLMULTI flag and the @mc_count\n * parameter to see whether multicast frames should be accepted\n * or dropped.\n *\n * All unsupported flags in @total_flags must be cleared.\n * Hardware does not support a flag if it is incapable of _passing_\n * the frame to the stack. Otherwise the driver must ignore\n * the flag, but not clear it.\n * You must _only_ clear the flag (announce no support for the\n * flag to mac80211) if you are not able to pass the packet type\n * to the stack (so the hardware always filters it).\n * So for example, you should clear @FIF_CONTROL, if your hardware\n * always filters control frames. If your hardware always passes\n * control frames to the kernel and is incapable of filtering them,\n * you do _not_ clear the @FIF_CONTROL flag.\n * This rule applies to all other FIF flags as well.\n */\n\n/**\n * DOC: AP support for powersaving clients\n *\n * In order to implement AP and P2P GO modes, mac80211 has support for\n * client powersaving, both \"legacy\" PS (PS-Poll/null data) and uAPSD.\n * There currently is no support for sAPSD.\n *\n * There is one assumption that mac80211 makes, namely that a client\n * will not poll with PS-Poll and trigger with uAPSD at the same time.\n * Both are supported, and both can be used by the same client, but\n * they can't be used concurrently by the same client. This simplifies\n * the driver code.\n *\n * The first thing to keep in mind is that there is a flag for complete\n * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,\n * mac80211 expects the driver to handle most of the state machine for\n * powersaving clients and will ignore the PM bit in incoming frames.\n * Drivers then use ieee80211_sta_ps_transition() to inform mac80211 of\n * stations' powersave transitions. In this mode, mac80211 also doesn't\n * handle PS-Poll/uAPSD.\n *\n * In the mode without %IEEE80211_HW_AP_LINK_PS, mac80211 will check the\n * PM bit in incoming frames for client powersave transitions. When a\n * station goes to sleep, we will stop transmitting to it. There is,\n * however, a race condition: a station might go to sleep while there is\n * data buffered on hardware queues. If the device has support for this\n * it will reject frames, and the driver should give the frames back to\n * mac80211 with the %IEEE80211_TX_STAT_TX_FILTERED flag set which will\n * cause mac80211 to retry the frame when the station wakes up. The\n * driver is also notified of powersave transitions by calling its\n * @sta_notify callback.\n *\n * When the station is asleep, it has three choices: it can wake up,\n * it can PS-Poll, or it can possibly start a uAPSD service period.\n * Waking up is implemented by simply transmitting all buffered (and\n * filtered) frames to the station. This is the easiest case. When\n * the station sends a PS-Poll or a uAPSD trigger frame, mac80211\n * will inform the driver of this with the @allow_buffered_frames\n * callback; this callback is optional. mac80211 will then transmit\n * the frames as usual and set the %IEEE80211_TX_CTL_NO_PS_BUFFER\n * on each frame. The last frame in the service period (or the only\n * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to\n * indicate that it ends the service period; as this frame must have\n * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.\n * When TX status is reported for this frame, the service period is\n * marked has having ended and a new one can be started by the peer.\n *\n * Additionally, non-bufferable MMPDUs can also be transmitted by\n * mac80211 with the %IEEE80211_TX_CTL_NO_PS_BUFFER set in them.\n *\n * Another race condition can happen on some devices like iwlwifi\n * when there are frames queued for the station and it wakes up\n * or polls; the frames that are already queued could end up being\n * transmitted first instead, causing reordering and/or wrong\n * processing of the EOSP. The cause is that allowing frames to be\n * transmitted to a certain station is out-of-band communication to\n * the device. To allow this problem to be solved, the driver can\n * call ieee80211_sta_block_awake() if frames are buffered when it\n * is notified that the station went to sleep. When all these frames\n * have been filtered (see above), it must call the function again\n * to indicate that the station is no longer blocked.\n *\n * If the driver buffers frames in the driver for aggregation in any\n * way, it must use the ieee80211_sta_set_buffered() call when it is\n * notified of the station going to sleep to inform mac80211 of any\n * TIDs that have frames buffered. Note that when a station wakes up\n * this information is reset (hence the requirement to call it when\n * informed of the station going to sleep). Then, when a service\n * period starts for any reason, @release_buffered_frames is called\n * with the number of frames to be released and which TIDs they are\n * to come from. In this case, the driver is responsible for setting\n * the EOSP (for uAPSD) and MORE_DATA bits in the released frames,\n * to help the @more_data parameter is passed to tell the driver if\n * there is more data on other TIDs -- the TIDs to release frames\n * from are ignored since mac80211 doesn't know how many frames the\n * buffers for those TIDs contain.\n *\n * If the driver also implement GO mode, where absence periods may\n * shorten service periods (or abort PS-Poll responses), it must\n * filter those response frames except in the case of frames that\n * are buffered in the driver -- those must remain buffered to avoid\n * reordering. Because it is possible that no frames are released\n * in this case, the driver must call ieee80211_sta_eosp()\n * to indicate to mac80211 that the service period ended anyway.\n *\n * Finally, if frames from multiple TIDs are released from mac80211\n * but the driver might reorder them, it must clear & set the flags\n * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)\n * and also take care of the EOSP and MORE_DATA bits in the frame.\n * The driver may also use ieee80211_sta_eosp() in this case.\n *\n * Note that if the driver ever buffers frames other than QoS-data\n * frames, it must take care to never send a non-QoS-data frame as\n * the last frame in a service period, adding a QoS-nulldata frame\n * after a non-QoS-data frame if needed.\n */\n\n/**\n * DOC: HW queue control\n *\n * Before HW queue control was introduced, mac80211 only had a single static\n * assignment of per-interface AC software queues to hardware queues. This\n * was problematic for a few reasons:\n * 1) off-channel transmissions might get stuck behind other frames\n * 2) multiple virtual interfaces couldn't be handled correctly\n * 3) after-DTIM frames could get stuck behind other frames\n *\n * To solve this, hardware typically uses multiple different queues for all\n * the different usages, and this needs to be propagated into mac80211 so it\n * won't have the same problem with the software queues.\n *\n * Therefore, mac80211 now offers the %IEEE80211_HW_QUEUE_CONTROL capability\n * flag that tells it that the driver implements its own queue control. To do\n * so, the driver will set up the various queues in each &struct ieee80211_vif\n * and the offchannel queue in &struct ieee80211_hw. In response, mac80211 will\n * use those queue IDs in the hw_queue field of &struct ieee80211_tx_info and\n * if necessary will queue the frame on the right software queue that mirrors\n * the hardware queue.\n * Additionally, the driver has to then use these HW queue IDs for the queue\n * management functions (ieee80211_stop_queue() et al.)\n *\n * The driver is free to set up the queue mappings as needed, multiple virtual\n * interfaces may map to the same hardware queues if needed. The setup has to\n * happen during add_interface or change_interface callbacks. For example, a\n * driver supporting station+station and station+AP modes might decide to have\n * 10 hardware queues to handle different scenarios:\n *\n * 4 AC HW queues for 1st vif: 0, 1, 2, 3\n * 4 AC HW queues for 2nd vif: 4, 5, 6, 7\n * after-DTIM queue for AP:   8\n * off-channel queue:         9\n *\n * It would then set up the hardware like this:\n *   hw.offchannel_tx_hw_queue = 9\n *\n * and the first virtual interface that is added as follows:\n *   vif.hw_queue[IEEE80211_AC_VO] = 0\n *   vif.hw_queue[IEEE80211_AC_VI] = 1\n *   vif.hw_queue[IEEE80211_AC_BE] = 2\n *   vif.hw_queue[IEEE80211_AC_BK] = 3\n *   vif.cab_queue = 8 // if AP mode, otherwise %IEEE80211_INVAL_HW_QUEUE\n * and the second virtual interface with 4-7.\n *\n * If queue 6 gets full, for example, mac80211 would only stop the second\n * virtual interface's BE queue since virtual interface queues are per AC.\n *\n * Note that the vif.cab_queue value should be set to %IEEE80211_INVAL_HW_QUEUE\n * whenever the queue is not used (i.e. the interface is not in AP mode) if the\n * queue could potentially be shared since mac80211 will look at cab_queue when\n * a queue is stopped/woken even if the interface is not in AP mode.\n */\n\n/**\n * enum ieee80211_filter_flags - hardware filter flags\n *\n * These flags determine what the filter in hardware should be\n * programmed to let through and what should not be passed to the\n * stack. It is always safe to pass more frames than requested,\n * but this has negative impact on power consumption.\n *\n * @FIF_ALLMULTI: pass all multicast frames, this is used if requested\n *\tby the user or if the hardware is not capable of filtering by\n *\tmulticast address.\n *\n * @FIF_FCSFAIL: pass frames with failed FCS (but you need to set the\n *\t%RX_FLAG_FAILED_FCS_CRC for them)\n *\n * @FIF_PLCPFAIL: pass frames with failed PLCP CRC (but you need to set\n *\tthe %RX_FLAG_FAILED_PLCP_CRC for them\n *\n * @FIF_BCN_PRBRESP_PROMISC: This flag is set during scanning to indicate\n *\tto the hardware that it should not filter beacons or probe responses\n *\tby BSSID. Filtering them can greatly reduce the amount of processing\n *\tmac80211 needs to do and the amount of CPU wakeups, so you should\n *\thonour this flag if possible.\n *\n * @FIF_CONTROL: pass control frames (except for PS Poll) addressed to this\n *\tstation\n *\n * @FIF_OTHER_BSS: pass frames destined to other BSSes\n *\n * @FIF_PSPOLL: pass PS Poll frames\n *\n * @FIF_PROBE_REQ: pass probe request frames\n *\n * @FIF_MCAST_ACTION: pass multicast Action frames\n */\nenum ieee80211_filter_flags {\n\tFIF_ALLMULTI\t\t= 1<<1,\n\tFIF_FCSFAIL\t\t= 1<<2,\n\tFIF_PLCPFAIL\t\t= 1<<3,\n\tFIF_BCN_PRBRESP_PROMISC\t= 1<<4,\n\tFIF_CONTROL\t\t= 1<<5,\n\tFIF_OTHER_BSS\t\t= 1<<6,\n\tFIF_PSPOLL\t\t= 1<<7,\n\tFIF_PROBE_REQ\t\t= 1<<8,\n\tFIF_MCAST_ACTION\t= 1<<9,\n};\n\n/**\n * enum ieee80211_ampdu_mlme_action - A-MPDU actions\n *\n * These flags are used with the ampdu_action() callback in\n * &struct ieee80211_ops to indicate which action is needed.\n *\n * Note that drivers MUST be able to deal with a TX aggregation\n * session being stopped even before they OK'ed starting it by\n * calling ieee80211_start_tx_ba_cb_irqsafe, because the peer\n * might receive the addBA frame and send a delBA right away!\n *\n * @IEEE80211_AMPDU_RX_START: start RX aggregation\n * @IEEE80211_AMPDU_RX_STOP: stop RX aggregation\n * @IEEE80211_AMPDU_TX_START: start TX aggregation, the driver must either\n *\tcall ieee80211_start_tx_ba_cb_irqsafe() or\n *\tcall ieee80211_start_tx_ba_cb_irqsafe() with status\n *\t%IEEE80211_AMPDU_TX_START_DELAY_ADDBA to delay addba after\n *\tieee80211_start_tx_ba_cb_irqsafe is called, or just return the special\n *\tstatus %IEEE80211_AMPDU_TX_START_IMMEDIATE.\n * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational\n * @IEEE80211_AMPDU_TX_STOP_CONT: stop TX aggregation but continue transmitting\n *\tqueued packets, now unaggregated. After all packets are transmitted the\n *\tdriver has to call ieee80211_stop_tx_ba_cb_irqsafe().\n * @IEEE80211_AMPDU_TX_STOP_FLUSH: stop TX aggregation and flush all packets,\n *\tcalled when the station is removed. There's no need or reason to call\n *\tieee80211_stop_tx_ba_cb_irqsafe() in this case as mac80211 assumes the\n *\tsession is gone and removes the station.\n * @IEEE80211_AMPDU_TX_STOP_FLUSH_CONT: called when TX aggregation is stopped\n *\tbut the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe() yet and\n *\tnow the connection is dropped and the station will be removed. Drivers\n *\tshould clean up and drop remaining packets when this is called.\n */\nenum ieee80211_ampdu_mlme_action {\n\tIEEE80211_AMPDU_RX_START,\n\tIEEE80211_AMPDU_RX_STOP,\n\tIEEE80211_AMPDU_TX_START,\n\tIEEE80211_AMPDU_TX_STOP_CONT,\n\tIEEE80211_AMPDU_TX_STOP_FLUSH,\n\tIEEE80211_AMPDU_TX_STOP_FLUSH_CONT,\n\tIEEE80211_AMPDU_TX_OPERATIONAL,\n};\n\n#define IEEE80211_AMPDU_TX_START_IMMEDIATE 1\n#define IEEE80211_AMPDU_TX_START_DELAY_ADDBA 2\n\n/**\n * struct ieee80211_ampdu_params - AMPDU action parameters\n *\n * @action: the ampdu action, value from %ieee80211_ampdu_mlme_action.\n * @sta: peer of this AMPDU session\n * @tid: tid of the BA session\n * @ssn: start sequence number of the session. TX/RX_STOP can pass 0. When\n *\taction is set to %IEEE80211_AMPDU_RX_START the driver passes back the\n *\tactual ssn value used to start the session and writes the value here.\n * @buf_size: reorder buffer size  (number of subframes). Valid only when the\n *\taction is set to %IEEE80211_AMPDU_RX_START or\n *\t%IEEE80211_AMPDU_TX_OPERATIONAL\n * @amsdu: indicates the peer's ability to receive A-MSDU within A-MPDU.\n *\tvalid when the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL\n * @timeout: BA session timeout. Valid only when the action is set to\n *\t%IEEE80211_AMPDU_RX_START\n */\nstruct ieee80211_ampdu_params {\n\tenum ieee80211_ampdu_mlme_action action;\n\tstruct ieee80211_sta *sta;\n\tu16 tid;\n\tu16 ssn;\n\tu16 buf_size;\n\tbool amsdu;\n\tu16 timeout;\n};\n\n/**\n * enum ieee80211_frame_release_type - frame release reason\n * @IEEE80211_FRAME_RELEASE_PSPOLL: frame released for PS-Poll\n * @IEEE80211_FRAME_RELEASE_UAPSD: frame(s) released due to\n *\tframe received on trigger-enabled AC\n */\nenum ieee80211_frame_release_type {\n\tIEEE80211_FRAME_RELEASE_PSPOLL,\n\tIEEE80211_FRAME_RELEASE_UAPSD,\n};\n\n/**\n * enum ieee80211_rate_control_changed - flags to indicate what changed\n *\n * @IEEE80211_RC_BW_CHANGED: The bandwidth that can be used to transmit\n *\tto this station changed. The actual bandwidth is in the station\n *\tinformation -- for HT20/40 the IEEE80211_HT_CAP_SUP_WIDTH_20_40\n *\tflag changes, for HT and VHT the bandwidth field changes.\n * @IEEE80211_RC_SMPS_CHANGED: The SMPS state of the station changed.\n * @IEEE80211_RC_SUPP_RATES_CHANGED: The supported rate set of this peer\n *\tchanged (in IBSS mode) due to discovering more information about\n *\tthe peer.\n * @IEEE80211_RC_NSS_CHANGED: N_SS (number of spatial streams) was changed\n *\tby the peer\n */\nenum ieee80211_rate_control_changed {\n\tIEEE80211_RC_BW_CHANGED\t\t= BIT(0),\n\tIEEE80211_RC_SMPS_CHANGED\t= BIT(1),\n\tIEEE80211_RC_SUPP_RATES_CHANGED\t= BIT(2),\n\tIEEE80211_RC_NSS_CHANGED\t= BIT(3),\n};\n\n/**\n * enum ieee80211_roc_type - remain on channel type\n *\n * With the support for multi channel contexts and multi channel operations,\n * remain on channel operations might be limited/deferred/aborted by other\n * flows/operations which have higher priority (and vice versa).\n * Specifying the ROC type can be used by devices to prioritize the ROC\n * operations compared to other operations/flows.\n *\n * @IEEE80211_ROC_TYPE_NORMAL: There are no special requirements for this ROC.\n * @IEEE80211_ROC_TYPE_MGMT_TX: The remain on channel request is required\n *\tfor sending management frames offchannel.\n */\nenum ieee80211_roc_type {\n\tIEEE80211_ROC_TYPE_NORMAL = 0,\n\tIEEE80211_ROC_TYPE_MGMT_TX,\n};\n\n/**\n * enum ieee80211_reconfig_type - reconfig type\n *\n * This enum is used by the reconfig_complete() callback to indicate what\n * reconfiguration type was completed.\n *\n * @IEEE80211_RECONFIG_TYPE_RESTART: hw restart type\n *\t(also due to resume() callback returning 1)\n * @IEEE80211_RECONFIG_TYPE_SUSPEND: suspend type (regardless\n *\tof wowlan configuration)\n */\nenum ieee80211_reconfig_type {\n\tIEEE80211_RECONFIG_TYPE_RESTART,\n\tIEEE80211_RECONFIG_TYPE_SUSPEND,\n};\n\n/**\n * struct ieee80211_ops - callbacks from mac80211 to the driver\n *\n * This structure contains various callbacks that the driver may\n * handle or, in some cases, must handle, for example to configure\n * the hardware to a new channel or to transmit a frame.\n *\n * @tx: Handler that 802.11 module calls for each transmitted frame.\n *\tskb contains the buffer starting from the IEEE 802.11 header.\n *\tThe low-level driver should send the frame out based on\n *\tconfiguration in the TX control data. This handler should,\n *\tpreferably, never fail and stop queues appropriately.\n *\tMust be atomic.\n *\n * @start: Called before the first netdevice attached to the hardware\n *\tis enabled. This should turn on the hardware and must turn on\n *\tframe reception (for possibly enabled monitor interfaces.)\n *\tReturns negative error codes, these may be seen in userspace,\n *\tor zero.\n *\tWhen the device is started it should not have a MAC address\n *\tto avoid acknowledging frames before a non-monitor device\n *\tis added.\n *\tMust be implemented and can sleep.\n *\n * @stop: Called after last netdevice attached to the hardware\n *\tis disabled. This should turn off the hardware (at least\n *\tit must turn off frame reception.)\n *\tMay be called right after add_interface if that rejects\n *\tan interface. If you added any work onto the mac80211 workqueue\n *\tyou should ensure to cancel it on this callback.\n *\tMust be implemented and can sleep.\n *\n * @suspend: Suspend the device; mac80211 itself will quiesce before and\n *\tstop transmitting and doing any other configuration, and then\n *\task the device to suspend. This is only invoked when WoWLAN is\n *\tconfigured, otherwise the device is deconfigured completely and\n *\treconfigured at resume time.\n *\tThe driver may also impose special conditions under which it\n *\twants to use the \"normal\" suspend (deconfigure), say if it only\n *\tsupports WoWLAN when the device is associated. In this case, it\n *\tmust return 1 from this function.\n *\n * @resume: If WoWLAN was configured, this indicates that mac80211 is\n *\tnow resuming its operation, after this the device must be fully\n *\tfunctional again. If this returns an error, the only way out is\n *\tto also unregister the device. If it returns 1, then mac80211\n *\twill also go through the regular complete restart on resume.\n *\n * @set_wakeup: Enable or disable wakeup when WoWLAN configuration is\n *\tmodified. The reason is that device_set_wakeup_enable() is\n *\tsupposed to be called when the configuration changes, not only\n *\tin suspend().\n *\n * @add_interface: Called when a netdevice attached to the hardware is\n *\tenabled. Because it is not called for monitor mode devices, @start\n *\tand @stop must be implemented.\n *\tThe driver should perform any initialization it needs before\n *\tthe device can be enabled. The initial configuration for the\n *\tinterface is given in the conf parameter.\n *\tThe callback may refuse to add an interface by returning a\n *\tnegative error code (which will be seen in userspace.)\n *\tMust be implemented and can sleep.\n *\n * @change_interface: Called when a netdevice changes type. This callback\n *\tis optional, but only if it is supported can interface types be\n *\tswitched while the interface is UP. The callback may sleep.\n *\tNote that while an interface is being switched, it will not be\n *\tfound by the interface iteration callbacks.\n *\n * @remove_interface: Notifies a driver that an interface is going down.\n *\tThe @stop callback is called after this if it is the last interface\n *\tand no monitor interfaces are present.\n *\tWhen all interfaces are removed, the MAC address in the hardware\n *\tmust be cleared so the device no longer acknowledges packets,\n *\tthe mac_addr member of the conf structure is, however, set to the\n *\tMAC address of the device going away.\n *\tHence, this callback must be implemented. It can sleep.\n *\n * @config: Handler for configuration requests. IEEE 802.11 code calls this\n *\tfunction to change hardware configuration, e.g., channel.\n *\tThis function should never fail but returns a negative error code\n *\tif it does. The callback can sleep.\n *\n * @bss_info_changed: Handler for configuration requests related to BSS\n *\tparameters that may vary during BSS's lifespan, and may affect low\n *\tlevel driver (e.g. assoc/disassoc status, erp parameters).\n *\tThis function should not be used if no BSS has been set, unless\n *\tfor association indication. The @changed parameter indicates which\n *\tof the bss parameters has changed when a call is made. The callback\n *\tcan sleep.\n *\n * @prepare_multicast: Prepare for multicast filter configuration.\n *\tThis callback is optional, and its return value is passed\n *\tto configure_filter(). This callback must be atomic.\n *\n * @configure_filter: Configure the device's RX filter.\n *\tSee the section \"Frame filtering\" for more information.\n *\tThis callback must be implemented and can sleep.\n *\n * @config_iface_filter: Configure the interface's RX filter.\n *\tThis callback is optional and is used to configure which frames\n *\tshould be passed to mac80211. The filter_flags is the combination\n *\tof FIF_* flags. The changed_flags is a bit mask that indicates\n *\twhich flags are changed.\n *\tThis callback can sleep.\n *\n * @set_tim: Set TIM bit. mac80211 calls this function when a TIM bit\n * \tmust be set or cleared for a given STA. Must be atomic.\n *\n * @set_key: See the section \"Hardware crypto acceleration\"\n *\tThis callback is only called between add_interface and\n *\tremove_interface calls, i.e. while the given virtual interface\n *\tis enabled.\n *\tReturns a negative error code if the key can't be added.\n *\tThe callback can sleep.\n *\n * @update_tkip_key: See the section \"Hardware crypto acceleration\"\n * \tThis callback will be called in the context of Rx. Called for drivers\n * \twhich set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.\n *\tThe callback must be atomic.\n *\n * @set_rekey_data: If the device supports GTK rekeying, for example while the\n *\thost is suspended, it can assign this callback to retrieve the data\n *\tnecessary to do GTK rekeying, this is the KEK, KCK and replay counter.\n *\tAfter rekeying was done it should (for example during resume) notify\n *\tuserspace of the new replay counter using ieee80211_gtk_rekey_notify().\n *\n * @set_default_unicast_key: Set the default (unicast) key index, useful for\n *\tWEP when the device sends data packets autonomously, e.g. for ARP\n *\toffloading. The index can be 0-3, or -1 for unsetting it.\n *\n * @hw_scan: Ask the hardware to service the scan request, no need to start\n *\tthe scan state machine in stack. The scan must honour the channel\n *\tconfiguration done by the regulatory agent in the wiphy's\n *\tregistered bands. The hardware (or the driver) needs to make sure\n *\tthat power save is disabled.\n *\tThe @req ie/ie_len members are rewritten by mac80211 to contain the\n *\tentire IEs after the SSID, so that drivers need not look at these\n *\tat all but just send them after the SSID -- mac80211 includes the\n *\t(extended) supported rates and HT information (where applicable).\n *\tWhen the scan finishes, ieee80211_scan_completed() must be called;\n *\tnote that it also must be called when the scan cannot finish due to\n *\tany error unless this callback returned a negative error code.\n *\tThis callback is also allowed to return the special return value 1,\n *\tthis indicates that hardware scan isn't desirable right now and a\n *\tsoftware scan should be done instead. A driver wishing to use this\n *\tcapability must ensure its (hardware) scan capabilities aren't\n *\tadvertised as more capable than mac80211's software scan is.\n *\tThe callback can sleep.\n *\n * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.\n *\tThe driver should ask the hardware to cancel the scan (if possible),\n *\tbut the scan will be completed only after the driver will call\n *\tieee80211_scan_completed().\n *\tThis callback is needed for wowlan, to prevent enqueueing a new\n *\tscan_work after the low-level driver was already suspended.\n *\tThe callback can sleep.\n *\n * @sched_scan_start: Ask the hardware to start scanning repeatedly at\n *\tspecific intervals.  The driver must call the\n *\tieee80211_sched_scan_results() function whenever it finds results.\n *\tThis process will continue until sched_scan_stop is called.\n *\n * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.\n *\tIn this case, ieee80211_sched_scan_stopped() must not be called.\n *\n * @sw_scan_start: Notifier function that is called just before a software scan\n *\tis started. Can be NULL, if the driver doesn't need this notification.\n *\tThe mac_addr parameter allows supporting NL80211_SCAN_FLAG_RANDOM_ADDR,\n *\tthe driver may set the NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR flag if it\n *\tcan use this parameter. The callback can sleep.\n *\n * @sw_scan_complete: Notifier function that is called just after a\n *\tsoftware scan finished. Can be NULL, if the driver doesn't need\n *\tthis notification.\n *\tThe callback can sleep.\n *\n * @get_stats: Return low-level statistics.\n * \tReturns zero if statistics are available.\n *\tThe callback can sleep.\n *\n * @get_key_seq: If your device implements encryption in hardware and does\n *\tIV/PN assignment then this callback should be provided to read the\n *\tIV/PN for the given key from hardware.\n *\tThe callback must be atomic.\n *\n * @set_frag_threshold: Configuration of fragmentation threshold. Assign this\n *\tif the device does fragmentation by itself. Note that to prevent the\n *\tstack from doing fragmentation IEEE80211_HW_SUPPORTS_TX_FRAG\n *\tshould be set as well.\n *\tThe callback can sleep.\n *\n * @set_rts_threshold: Configuration of RTS threshold (if device needs it)\n *\tThe callback can sleep.\n *\n * @sta_add: Notifies low level driver about addition of an associated station,\n *\tAP, IBSS/WDS/mesh peer etc. This callback can sleep.\n *\n * @sta_remove: Notifies low level driver about removal of an associated\n *\tstation, AP, IBSS/WDS/mesh peer etc. Note that after the callback\n *\treturns it isn't safe to use the pointer, not even RCU protected;\n *\tno RCU grace period is guaranteed between returning here and freeing\n *\tthe station. See @sta_pre_rcu_remove if needed.\n *\tThis callback can sleep.\n *\n * @sta_add_debugfs: Drivers can use this callback to add debugfs files\n *\twhen a station is added to mac80211's station list. This callback\n *\tshould be within a CONFIG_MAC80211_DEBUGFS conditional. This\n *\tcallback can sleep.\n *\n * @sta_notify: Notifies low level driver about power state transition of an\n *\tassociated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating\n *\tin AP mode, this callback will not be called when the flag\n *\t%IEEE80211_HW_AP_LINK_PS is set. Must be atomic.\n *\n * @sta_set_txpwr: Configure the station tx power. This callback set the tx\n *\tpower for the station.\n *\tThis callback can sleep.\n *\n * @sta_state: Notifies low level driver about state transition of a\n *\tstation (which can be the AP, a client, IBSS/WDS/mesh peer etc.)\n *\tThis callback is mutually exclusive with @sta_add/@sta_remove.\n *\tIt must not fail for down transitions but may fail for transitions\n *\tup the list of states. Also note that after the callback returns it\n *\tisn't safe to use the pointer, not even RCU protected - no RCU grace\n *\tperiod is guaranteed between returning here and freeing the station.\n *\tSee @sta_pre_rcu_remove if needed.\n *\tThe callback can sleep.\n *\n * @sta_pre_rcu_remove: Notify driver about station removal before RCU\n *\tsynchronisation. This is useful if a driver needs to have station\n *\tpointers protected using RCU, it can then use this call to clear\n *\tthe pointers instead of waiting for an RCU grace period to elapse\n *\tin @sta_state.\n *\tThe callback can sleep.\n *\n * @sta_rc_update: Notifies the driver of changes to the bitrates that can be\n *\tused to transmit to the station. The changes are advertised with bits\n *\tfrom &enum ieee80211_rate_control_changed and the values are reflected\n *\tin the station data. This callback should only be used when the driver\n *\tuses hardware rate control (%IEEE80211_HW_HAS_RATE_CONTROL) since\n *\totherwise the rate control algorithm is notified directly.\n *\tMust be atomic.\n * @sta_rate_tbl_update: Notifies the driver that the rate table changed. This\n *\tis only used if the configured rate control algorithm actually uses\n *\tthe new rate table API, and is therefore optional. Must be atomic.\n *\n * @sta_statistics: Get statistics for this station. For example with beacon\n *\tfiltering, the statistics kept by mac80211 might not be accurate, so\n *\tlet the driver pre-fill the statistics. The driver can fill most of\n *\tthe values (indicating which by setting the filled bitmap), but not\n *\tall of them make sense - see the source for which ones are possible.\n *\tStatistics that the driver doesn't fill will be filled by mac80211.\n *\tThe callback can sleep.\n *\n * @conf_tx: Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),\n *\tbursting) for a hardware TX queue.\n *\tReturns a negative error code on failure.\n *\tThe callback can sleep.\n *\n * @get_tsf: Get the current TSF timer value from firmware/hardware. Currently,\n *\tthis is only used for IBSS mode BSSID merging and debugging. Is not a\n *\trequired function.\n *\tThe callback can sleep.\n *\n * @set_tsf: Set the TSF timer to the specified value in the firmware/hardware.\n *\tCurrently, this is only used for IBSS mode debugging. Is not a\n *\trequired function.\n *\tThe callback can sleep.\n *\n * @offset_tsf: Offset the TSF timer by the specified value in the\n *\tfirmware/hardware.  Preferred to set_tsf as it avoids delay between\n *\tcalling set_tsf() and hardware getting programmed, which will show up\n *\tas TSF delay. Is not a required function.\n *\tThe callback can sleep.\n *\n * @reset_tsf: Reset the TSF timer and allow firmware/hardware to synchronize\n *\twith other STAs in the IBSS. This is only used in IBSS mode. This\n *\tfunction is optional if the firmware/hardware takes full care of\n *\tTSF synchronization.\n *\tThe callback can sleep.\n *\n * @tx_last_beacon: Determine whether the last IBSS beacon was sent by us.\n *\tThis is needed only for IBSS mode and the result of this function is\n *\tused to determine whether to reply to Probe Requests.\n *\tReturns non-zero if this device sent the last beacon.\n *\tThe callback can sleep.\n *\n * @get_survey: Return per-channel survey information\n *\n * @rfkill_poll: Poll rfkill hardware state. If you need this, you also\n *\tneed to set wiphy->rfkill_poll to %true before registration,\n *\tand need to call wiphy_rfkill_set_hw_state() in the callback.\n *\tThe callback can sleep.\n *\n * @set_coverage_class: Set slot time for given coverage class as specified\n *\tin IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout\n *\taccordingly; coverage class equals to -1 to enable ACK timeout\n *\testimation algorithm (dynack). To disable dynack set valid value for\n *\tcoverage class. This callback is not required and may sleep.\n *\n * @testmode_cmd: Implement a cfg80211 test mode command. The passed @vif may\n *\tbe %NULL. The callback can sleep.\n * @testmode_dump: Implement a cfg80211 test mode dump. The callback can sleep.\n *\n * @flush: Flush all pending frames from the hardware queue, making sure\n *\tthat the hardware queues are empty. The @queues parameter is a bitmap\n *\tof queues to flush, which is useful if different virtual interfaces\n *\tuse different hardware queues; it may also indicate all queues.\n *\tIf the parameter @drop is set to %true, pending frames may be dropped.\n *\tNote that vif can be NULL.\n *\tThe callback can sleep.\n *\n * @channel_switch: Drivers that need (or want) to offload the channel\n *\tswitch operation for CSAs received from the AP may implement this\n *\tcallback. They must then call ieee80211_chswitch_done() to indicate\n *\tcompletion of the channel switch.\n *\n * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.\n *\tParameters are bitmaps of allowed antennas to use for TX/RX. Drivers may\n *\treject TX/RX mask combinations they cannot support by returning -EINVAL\n *\t(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).\n *\n * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).\n *\n * @remain_on_channel: Starts an off-channel period on the given channel, must\n *\tcall back to ieee80211_ready_on_channel() when on that channel. Note\n *\tthat normal channel traffic is not stopped as this is intended for hw\n *\toffload. Frames to transmit on the off-channel channel are transmitted\n *\tnormally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the\n *\tduration (which will always be non-zero) expires, the driver must call\n *\tieee80211_remain_on_channel_expired().\n *\tNote that this callback may be called while the device is in IDLE and\n *\tmust be accepted in this case.\n *\tThis callback may sleep.\n * @cancel_remain_on_channel: Requests that an ongoing off-channel period is\n *\taborted before it expires. This callback may sleep.\n *\n * @set_ringparam: Set tx and rx ring sizes.\n *\n * @get_ringparam: Get tx and rx ring current and maximum sizes.\n *\n * @tx_frames_pending: Check if there is any pending frame in the hardware\n *\tqueues before entering power save.\n *\n * @set_bitrate_mask: Set a mask of rates to be used for rate control selection\n *\twhen transmitting a frame. Currently only legacy rates are handled.\n *\tThe callback can sleep.\n * @event_callback: Notify driver about any event in mac80211. See\n *\t&enum ieee80211_event_type for the different types.\n *\tThe callback must be atomic.\n *\n * @release_buffered_frames: Release buffered frames according to the given\n *\tparameters. In the case where the driver buffers some frames for\n *\tsleeping stations mac80211 will use this callback to tell the driver\n *\tto release some frames, either for PS-poll or uAPSD.\n *\tNote that if the @more_data parameter is %false the driver must check\n *\tif there are more frames on the given TIDs, and if there are more than\n *\tthe frames being released then it must still set the more-data bit in\n *\tthe frame. If the @more_data parameter is %true, then of course the\n *\tmore-data bit must always be set.\n *\tThe @tids parameter tells the driver which TIDs to release frames\n *\tfrom, for PS-poll it will always have only a single bit set.\n *\tIn the case this is used for a PS-poll initiated release, the\n *\t@num_frames parameter will always be 1 so code can be shared. In\n *\tthis case the driver must also set %IEEE80211_TX_STATUS_EOSP flag\n *\ton the TX status (and must report TX status) so that the PS-poll\n *\tperiod is properly ended. This is used to avoid sending multiple\n *\tresponses for a retried PS-poll frame.\n *\tIn the case this is used for uAPSD, the @num_frames parameter may be\n *\tbigger than one, but the driver may send fewer frames (it must send\n *\tat least one, however). In this case it is also responsible for\n *\tsetting the EOSP flag in the QoS header of the frames. Also, when the\n *\tservice period ends, the driver must set %IEEE80211_TX_STATUS_EOSP\n *\ton the last frame in the SP. Alternatively, it may call the function\n *\tieee80211_sta_eosp() to inform mac80211 of the end of the SP.\n *\tThis callback must be atomic.\n * @allow_buffered_frames: Prepare device to allow the given number of frames\n *\tto go out to the given station. The frames will be sent by mac80211\n *\tvia the usual TX path after this call. The TX information for frames\n *\treleased will also have the %IEEE80211_TX_CTL_NO_PS_BUFFER flag set\n *\tand the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case\n *\tframes from multiple TIDs are released and the driver might reorder\n *\tthem between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag\n *\ton the last frame and clear it on all others and also handle the EOSP\n *\tbit in the QoS header correctly. Alternatively, it can also call the\n *\tieee80211_sta_eosp() function.\n *\tThe @tids parameter is a bitmap and tells the driver which TIDs the\n *\tframes will be on; it will at most have two bits set.\n *\tThis callback must be atomic.\n *\n * @get_et_sset_count:  Ethtool API to get string-set count.\n *\n * @get_et_stats:  Ethtool API to get a set of u64 stats.\n *\n * @get_et_strings:  Ethtool API to get a set of strings to describe stats\n *\tand perhaps other supported types of ethtool data-sets.\n *\n * @mgd_prepare_tx: Prepare for transmitting a management frame for association\n *\tbefore associated. In multi-channel scenarios, a virtual interface is\n *\tbound to a channel before it is associated, but as it isn't associated\n *\tyet it need not necessarily be given airtime, in particular since any\n *\ttransmission to a P2P GO needs to be synchronized against the GO's\n *\tpowersave state. mac80211 will call this function before transmitting a\n *\tmanagement frame prior to having successfully associated to allow the\n *\tdriver to give it channel time for the transmission, to get a response\n *\tand to be able to synchronize with the GO.\n *\tFor drivers that set %IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP, mac80211\n *\twould also call this function before transmitting a deauthentication\n *\tframe in case that no beacon was heard from the AP/P2P GO.\n *\tThe callback will be called before each transmission and upon return\n *\tmac80211 will transmit the frame right away.\n *      If duration is greater than zero, mac80211 hints to the driver the\n *      duration for which the operation is requested.\n *\tThe callback is optional and can (should!) sleep.\n *\n * @mgd_protect_tdls_discover: Protect a TDLS discovery session. After sending\n *\ta TDLS discovery-request, we expect a reply to arrive on the AP's\n *\tchannel. We must stay on the channel (no PSM, scan, etc.), since a TDLS\n *\tsetup-response is a direct packet not buffered by the AP.\n *\tmac80211 will call this function just before the transmission of a TDLS\n *\tdiscovery-request. The recommended period of protection is at least\n *\t2 * (DTIM period).\n *\tThe callback is optional and can sleep.\n *\n * @add_chanctx: Notifies device driver about new channel context creation.\n *\tThis callback may sleep.\n * @remove_chanctx: Notifies device driver about channel context destruction.\n *\tThis callback may sleep.\n * @change_chanctx: Notifies device driver about channel context changes that\n *\tmay happen when combining different virtual interfaces on the same\n *\tchannel context with different settings\n *\tThis callback may sleep.\n * @assign_vif_chanctx: Notifies device driver about channel context being bound\n *\tto vif. Possible use is for hw queue remapping.\n *\tThis callback may sleep.\n * @unassign_vif_chanctx: Notifies device driver about channel context being\n *\tunbound from vif.\n *\tThis callback may sleep.\n * @switch_vif_chanctx: switch a number of vifs from one chanctx to\n *\tanother, as specified in the list of\n *\t@ieee80211_vif_chanctx_switch passed to the driver, according\n *\tto the mode defined in &ieee80211_chanctx_switch_mode.\n *\tThis callback may sleep.\n *\n * @start_ap: Start operation on the AP interface, this is called after all the\n *\tinformation in bss_conf is set and beacon can be retrieved. A channel\n *\tcontext is bound before this is called. Note that if the driver uses\n *\tsoftware scan or ROC, this (and @stop_ap) isn't called when the AP is\n *\tjust \"paused\" for scanning/ROC, which is indicated by the beacon being\n *\tdisabled/enabled via @bss_info_changed.\n * @stop_ap: Stop operation on the AP interface.\n *\n * @reconfig_complete: Called after a call to ieee80211_restart_hw() and\n *\tduring resume, when the reconfiguration has completed.\n *\tThis can help the driver implement the reconfiguration step (and\n *\tindicate mac80211 is ready to receive frames).\n *\tThis callback may sleep.\n *\n * @ipv6_addr_change: IPv6 address assignment on the given interface changed.\n *\tCurrently, this is only called for managed or P2P client interfaces.\n *\tThis callback is optional; it must not sleep.\n *\n * @channel_switch_beacon: Starts a channel switch to a new channel.\n *\tBeacons are modified to include CSA or ECSA IEs before calling this\n *\tfunction. The corresponding count fields in these IEs must be\n *\tdecremented, and when they reach 1 the driver must call\n *\tieee80211_csa_finish(). Drivers which use ieee80211_beacon_get()\n *\tget the csa counter decremented by mac80211, but must check if it is\n *\t1 using ieee80211_beacon_counter_is_complete() after the beacon has been\n *\ttransmitted and then call ieee80211_csa_finish().\n *\tIf the CSA count starts as zero or 1, this function will not be called,\n *\tsince there won't be any time to beacon before the switch anyway.\n * @pre_channel_switch: This is an optional callback that is called\n *\tbefore a channel switch procedure is started (ie. when a STA\n *\tgets a CSA or a userspace initiated channel-switch), allowing\n *\tthe driver to prepare for the channel switch.\n * @post_channel_switch: This is an optional callback that is called\n *\tafter a channel switch procedure is completed, allowing the\n *\tdriver to go back to a normal configuration.\n * @abort_channel_switch: This is an optional callback that is called\n *\twhen channel switch procedure was completed, allowing the\n *\tdriver to go back to a normal configuration.\n * @channel_switch_rx_beacon: This is an optional callback that is called\n *\twhen channel switch procedure is in progress and additional beacon with\n *\tCSA IE was received, allowing driver to track changes in count.\n * @join_ibss: Join an IBSS (on an IBSS interface); this is called after all\n *\tinformation in bss_conf is set up and the beacon can be retrieved. A\n *\tchannel context is bound before this is called.\n * @leave_ibss: Leave the IBSS again.\n *\n * @get_expected_throughput: extract the expected throughput towards the\n *\tspecified station. The returned value is expressed in Kbps. It returns 0\n *\tif the RC algorithm does not have proper data to provide.\n *\n * @get_txpower: get current maximum tx power (in dBm) based on configuration\n *\tand hardware limits.\n *\n * @tdls_channel_switch: Start channel-switching with a TDLS peer. The driver\n *\tis responsible for continually initiating channel-switching operations\n *\tand returning to the base channel for communication with the AP. The\n *\tdriver receives a channel-switch request template and the location of\n *\tthe switch-timing IE within the template as part of the invocation.\n *\tThe template is valid only within the call, and the driver can\n *\toptionally copy the skb for further re-use.\n * @tdls_cancel_channel_switch: Stop channel-switching with a TDLS peer. Both\n *\tpeers must be on the base channel when the call completes.\n * @tdls_recv_channel_switch: a TDLS channel-switch related frame (request or\n *\tresponse) has been received from a remote peer. The driver gets\n *\tparameters parsed from the incoming frame and may use them to continue\n *\tan ongoing channel-switch operation. In addition, a channel-switch\n *\tresponse template is provided, together with the location of the\n *\tswitch-timing IE within the template. The skb can only be used within\n *\tthe function call.\n *\n * @wake_tx_queue: Called when new packets have been added to the queue.\n * @sync_rx_queues: Process all pending frames in RSS queues. This is a\n *\tsynchronization which is needed in case driver has in its RSS queues\n *\tpending frames that were received prior to the control path action\n *\tcurrently taken (e.g. disassociation) but are not processed yet.\n *\n * @start_nan: join an existing NAN cluster, or create a new one.\n * @stop_nan: leave the NAN cluster.\n * @nan_change_conf: change NAN configuration. The data in cfg80211_nan_conf\n *\tcontains full new configuration and changes specify which parameters\n *\tare changed with respect to the last NAN config.\n *\tThe driver gets both full configuration and the changed parameters since\n *\tsome devices may need the full configuration while others need only the\n *\tchanged parameters.\n * @add_nan_func: Add a NAN function. Returns 0 on success. The data in\n *\tcfg80211_nan_func must not be referenced outside the scope of\n *\tthis call.\n * @del_nan_func: Remove a NAN function. The driver must call\n *\tieee80211_nan_func_terminated() with\n *\tNL80211_NAN_FUNC_TERM_REASON_USER_REQUEST reason code upon removal.\n * @can_aggregate_in_amsdu: Called in order to determine if HW supports\n *\taggregating two specific frames in the same A-MSDU. The relation\n *\tbetween the skbs should be symmetric and transitive. Note that while\n *\tskb is always a real frame, head may or may not be an A-MSDU.\n * @get_ftm_responder_stats: Retrieve FTM responder statistics, if available.\n *\tStatistics should be cumulative, currently no way to reset is provided.\n *\n * @start_pmsr: start peer measurement (e.g. FTM) (this call can sleep)\n * @abort_pmsr: abort peer measurement (this call can sleep)\n * @set_tid_config: Apply TID specific configurations. This callback may sleep.\n * @reset_tid_config: Reset TID specific configuration for the peer.\n *\tThis callback may sleep.\n * @update_vif_offload: Update virtual interface offload flags\n *\tThis callback may sleep.\n * @sta_set_4addr: Called to notify the driver when a station starts/stops using\n *\t4-address mode\n * @set_sar_specs: Update the SAR (TX power) settings.\n * @sta_set_decap_offload: Called to notify the driver when a station is allowed\n *\tto use rx decapsulation offload\n */\nstruct ieee80211_ops {\n\tvoid (*tx)(struct ieee80211_hw *hw,\n\t\t   struct ieee80211_tx_control *control,\n\t\t   struct sk_buff *skb);\n\tint (*start)(struct ieee80211_hw *hw);\n\tvoid (*stop)(struct ieee80211_hw *hw);\n#ifdef CONFIG_PM\n\tint (*suspend)(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);\n\tint (*resume)(struct ieee80211_hw *hw);\n\tvoid (*set_wakeup)(struct ieee80211_hw *hw, bool enabled);\n#endif\n\tint (*add_interface)(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif);\n\tint (*change_interface)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tenum nl80211_iftype new_type, bool p2p);\n\tvoid (*remove_interface)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif);\n\tint (*config)(struct ieee80211_hw *hw, u32 changed);\n\tvoid (*bss_info_changed)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *info,\n\t\t\t\t u32 changed);\n\n\tint (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\n\tu64 (*prepare_multicast)(struct ieee80211_hw *hw,\n\t\t\t\t struct netdev_hw_addr_list *mc_list);\n\tvoid (*configure_filter)(struct ieee80211_hw *hw,\n\t\t\t\t unsigned int changed_flags,\n\t\t\t\t unsigned int *total_flags,\n\t\t\t\t u64 multicast);\n\tvoid (*config_iface_filter)(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    unsigned int filter_flags,\n\t\t\t\t    unsigned int changed_flags);\n\tint (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       bool set);\n\tint (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t       struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key);\n\tvoid (*update_tkip_key)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_key_conf *conf,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tu32 iv32, u16 *phase1key);\n\tvoid (*set_rekey_data)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct cfg80211_gtk_rekey_data *data);\n\tvoid (*set_default_unicast_key)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif, int idx);\n\tint (*hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_scan_request *req);\n\tvoid (*cancel_hw_scan)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif);\n\tint (*sched_scan_start)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_sched_scan_request *req,\n\t\t\t\tstruct ieee80211_scan_ies *ies);\n\tint (*sched_scan_stop)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif);\n\tvoid (*sw_scan_start)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      const u8 *mac_addr);\n\tvoid (*sw_scan_complete)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif);\n\tint (*get_stats)(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_low_level_stats *stats);\n\tvoid (*get_key_seq)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_key_conf *key,\n\t\t\t    struct ieee80211_key_seq *seq);\n\tint (*set_frag_threshold)(struct ieee80211_hw *hw, u32 value);\n\tint (*set_rts_threshold)(struct ieee80211_hw *hw, u32 value);\n\tint (*sta_add)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta);\n\tint (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta);\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tvoid (*sta_add_debugfs)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct dentry *dir);\n#endif\n\tvoid (*sta_notify)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tenum sta_notify_cmd, struct ieee80211_sta *sta);\n\tint (*sta_set_txpwr)(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta);\n\tint (*sta_state)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t enum ieee80211_sta_state old_state,\n\t\t\t enum ieee80211_sta_state new_state);\n\tvoid (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta);\n\tvoid (*sta_rc_update)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      u32 changed);\n\tvoid (*sta_rate_tbl_update)(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta);\n\tvoid (*sta_statistics)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct station_info *sinfo);\n\tint (*conf_tx)(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif, u16 ac,\n\t\t       const struct ieee80211_tx_queue_params *params);\n\tu64 (*get_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*set_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tu64 tsf);\n\tvoid (*offset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   s64 offset);\n\tvoid (*reset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tint (*tx_last_beacon)(struct ieee80211_hw *hw);\n\n\t/**\n\t * @ampdu_action:\n\t * Perform a certain A-MPDU action.\n\t * The RA/TID combination determines the destination and TID we want\n\t * the ampdu action to be performed for. The action is defined through\n\t * ieee80211_ampdu_mlme_action.\n\t * When the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL the driver\n\t * may neither send aggregates containing more subframes than @buf_size\n\t * nor send aggregates in a way that lost frames would exceed the\n\t * buffer size. If just limiting the aggregate size, this would be\n\t * possible with a buf_size of 8:\n\t *\n\t * - ``TX: 1.....7``\n\t * - ``RX:  2....7`` (lost frame #1)\n\t * - ``TX:        8..1...``\n\t *\n\t * which is invalid since #1 was now re-transmitted well past the\n\t * buffer size of 8. Correct ways to retransmit #1 would be:\n\t *\n\t * - ``TX:        1   or``\n\t * - ``TX:        18  or``\n\t * - ``TX:        81``\n\t *\n\t * Even ``189`` would be wrong since 1 could be lost again.\n\t *\n\t * Returns a negative error code on failure. The driver may return\n\t * %IEEE80211_AMPDU_TX_START_IMMEDIATE for %IEEE80211_AMPDU_TX_START\n\t * if the session can start immediately.\n\t *\n\t * The callback can sleep.\n\t */\n\tint (*ampdu_action)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_ampdu_params *params);\n\tint (*get_survey)(struct ieee80211_hw *hw, int idx,\n\t\tstruct survey_info *survey);\n\tvoid (*rfkill_poll)(struct ieee80211_hw *hw);\n\tvoid (*set_coverage_class)(struct ieee80211_hw *hw, s16 coverage_class);\n#ifdef CONFIG_NL80211_TESTMODE\n\tint (*testmode_cmd)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    void *data, int len);\n\tint (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     void *data, int len);\n#endif\n\tvoid (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t      u32 queues, bool drop);\n\tvoid (*channel_switch)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_channel_switch *ch_switch);\n\tint (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);\n\tint (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);\n\n\tint (*remain_on_channel)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_channel *chan,\n\t\t\t\t int duration,\n\t\t\t\t enum ieee80211_roc_type type);\n\tint (*cancel_remain_on_channel)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif);\n\tint (*set_ringparam)(struct ieee80211_hw *hw, u32 tx, u32 rx);\n\tvoid (*get_ringparam)(struct ieee80211_hw *hw,\n\t\t\t      u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);\n\tbool (*tx_frames_pending)(struct ieee80211_hw *hw);\n\tint (*set_bitrate_mask)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t\tconst struct cfg80211_bitrate_mask *mask);\n\tvoid (*event_callback)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       const struct ieee80211_event *event);\n\n\tvoid (*allow_buffered_frames)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      u16 tids, int num_frames,\n\t\t\t\t      enum ieee80211_frame_release_type reason,\n\t\t\t\t      bool more_data);\n\tvoid (*release_buffered_frames)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tu16 tids, int num_frames,\n\t\t\t\t\tenum ieee80211_frame_release_type reason,\n\t\t\t\t\tbool more_data);\n\n\tint\t(*get_et_sset_count)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif, int sset);\n\tvoid\t(*get_et_stats)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ethtool_stats *stats, u64 *data);\n\tvoid\t(*get_et_strings)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u32 sset, u8 *data);\n\n\tvoid\t(*mgd_prepare_tx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u16 duration);\n\n\tvoid\t(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif);\n\n\tint (*add_chanctx)(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_chanctx_conf *ctx);\n\tvoid (*remove_chanctx)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_chanctx_conf *ctx);\n\tvoid (*change_chanctx)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_chanctx_conf *ctx,\n\t\t\t       u32 changed);\n\tint (*assign_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_chanctx_conf *ctx);\n\tvoid (*unassign_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx);\n\tint (*switch_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t  int n_vifs,\n\t\t\t\t  enum ieee80211_chanctx_switch_mode mode);\n\n\tvoid (*reconfig_complete)(struct ieee80211_hw *hw,\n\t\t\t\t  enum ieee80211_reconfig_type reconfig_type);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tvoid (*ipv6_addr_change)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct inet6_dev *idev);\n#endif\n\tvoid (*channel_switch_beacon)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct cfg80211_chan_def *chandef);\n\tint (*pre_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_channel_switch *ch_switch);\n\n\tint (*post_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif);\n\tvoid (*abort_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif);\n\tvoid (*channel_switch_rx_beacon)(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_channel_switch *ch_switch);\n\n\tint (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tu32 (*get_expected_throughput)(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_sta *sta);\n\tint (*get_txpower)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   int *dbm);\n\n\tint (*tdls_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta, u8 oper_class,\n\t\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t\t   struct sk_buff *tmpl_skb, u32 ch_sw_tm_ie);\n\tvoid (*tdls_cancel_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_sta *sta);\n\tvoid (*tdls_recv_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_tdls_ch_sw_params *params);\n\n\tvoid (*wake_tx_queue)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq);\n\tvoid (*sync_rx_queues)(struct ieee80211_hw *hw);\n\n\tint (*start_nan)(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct cfg80211_nan_conf *conf);\n\tint (*stop_nan)(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif);\n\tint (*nan_change_conf)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct cfg80211_nan_conf *conf, u32 changes);\n\tint (*add_nan_func)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    const struct cfg80211_nan_func *nan_func);\n\tvoid (*del_nan_func)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    u8 instance_id);\n\tbool (*can_aggregate_in_amsdu)(struct ieee80211_hw *hw,\n\t\t\t\t       struct sk_buff *head,\n\t\t\t\t       struct sk_buff *skb);\n\tint (*get_ftm_responder_stats)(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct cfg80211_ftm_responder_stats *ftm_stats);\n\tint (*start_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct cfg80211_pmsr_request *request);\n\tvoid (*abort_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct cfg80211_pmsr_request *request);\n\tint (*set_tid_config)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct cfg80211_tid_config *tid_conf);\n\tint (*reset_tid_config)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta, u8 tids);\n\tvoid (*update_vif_offload)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif);\n\tvoid (*sta_set_4addr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta, bool enabled);\n\tint (*set_sar_specs)(struct ieee80211_hw *hw,\n\t\t\t     const struct cfg80211_sar_specs *sar);\n\tvoid (*sta_set_decap_offload)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta, bool enabled);\n};\n\n/**\n * ieee80211_alloc_hw_nm - Allocate a new hardware device\n *\n * This must be called once for each hardware device. The returned pointer\n * must be used to refer to this device when calling other functions.\n * mac80211 allocates a private data area for the driver pointed to by\n * @priv in &struct ieee80211_hw, the size of this area is given as\n * @priv_data_len.\n *\n * @priv_data_len: length of private data\n * @ops: callbacks for this device\n * @requested_name: Requested name for this device.\n *\tNULL is valid value, and means use the default naming (phy%d)\n *\n * Return: A pointer to the new hardware device, or %NULL on error.\n */\nstruct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,\n\t\t\t\t\t   const struct ieee80211_ops *ops,\n\t\t\t\t\t   const char *requested_name);\n\n/**\n * ieee80211_alloc_hw - Allocate a new hardware device\n *\n * This must be called once for each hardware device. The returned pointer\n * must be used to refer to this device when calling other functions.\n * mac80211 allocates a private data area for the driver pointed to by\n * @priv in &struct ieee80211_hw, the size of this area is given as\n * @priv_data_len.\n *\n * @priv_data_len: length of private data\n * @ops: callbacks for this device\n *\n * Return: A pointer to the new hardware device, or %NULL on error.\n */\nstatic inline\nstruct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,\n\t\t\t\t\tconst struct ieee80211_ops *ops)\n{\n\treturn ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);\n}\n\n/**\n * ieee80211_register_hw - Register hardware device\n *\n * You must call this function before any other functions in\n * mac80211. Note that before a hardware can be registered, you\n * need to fill the contained wiphy's information.\n *\n * @hw: the device to register as returned by ieee80211_alloc_hw()\n *\n * Return: 0 on success. An error code otherwise.\n */\nint ieee80211_register_hw(struct ieee80211_hw *hw);\n\n/**\n * struct ieee80211_tpt_blink - throughput blink description\n * @throughput: throughput in Kbit/sec\n * @blink_time: blink time in milliseconds\n *\t(full cycle, ie. one off + one on period)\n */\nstruct ieee80211_tpt_blink {\n\tint throughput;\n\tint blink_time;\n};\n\n/**\n * enum ieee80211_tpt_led_trigger_flags - throughput trigger flags\n * @IEEE80211_TPT_LEDTRIG_FL_RADIO: enable blinking with radio\n * @IEEE80211_TPT_LEDTRIG_FL_WORK: enable blinking when working\n * @IEEE80211_TPT_LEDTRIG_FL_CONNECTED: enable blinking when at least one\n *\tinterface is connected in some way, including being an AP\n */\nenum ieee80211_tpt_led_trigger_flags {\n\tIEEE80211_TPT_LEDTRIG_FL_RADIO\t\t= BIT(0),\n\tIEEE80211_TPT_LEDTRIG_FL_WORK\t\t= BIT(1),\n\tIEEE80211_TPT_LEDTRIG_FL_CONNECTED\t= BIT(2),\n};\n\n#ifdef CONFIG_MAC80211_LEDS\nconst char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);\nconst char *\n__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,\n\t\t\t\t   unsigned int flags,\n\t\t\t\t   const struct ieee80211_tpt_blink *blink_table,\n\t\t\t\t   unsigned int blink_table_len);\n#endif\n/**\n * ieee80211_get_tx_led_name - get name of TX LED\n *\n * mac80211 creates a transmit LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_tx_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_get_rx_led_name - get name of RX LED\n *\n * mac80211 creates a receive LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_rx_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_get_assoc_led_name - get name of association LED\n *\n * mac80211 creates a association LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_assoc_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_get_radio_led_name - get name of radio LED\n *\n * mac80211 creates a radio change LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_radio_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_create_tpt_led_trigger - create throughput LED trigger\n * @hw: the hardware to create the trigger for\n * @flags: trigger flags, see &enum ieee80211_tpt_led_trigger_flags\n * @blink_table: the blink table -- needs to be ordered by throughput\n * @blink_table_len: size of the blink table\n *\n * Return: %NULL (in case of error, or if no LED triggers are\n * configured) or the name of the new trigger.\n *\n * Note: This function must be called before ieee80211_register_hw().\n */\nstatic inline const char *\nieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,\n\t\t\t\t const struct ieee80211_tpt_blink *blink_table,\n\t\t\t\t unsigned int blink_table_len)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,\n\t\t\t\t\t\t  blink_table_len);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_unregister_hw - Unregister a hardware device\n *\n * This function instructs mac80211 to free allocated resources\n * and unregister netdevices from the networking subsystem.\n *\n * @hw: the hardware to unregister\n */\nvoid ieee80211_unregister_hw(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_free_hw - free hardware descriptor\n *\n * This function frees everything that was allocated, including the\n * private data for the driver. You must call ieee80211_unregister_hw()\n * before calling this function.\n *\n * @hw: the hardware to free\n */\nvoid ieee80211_free_hw(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_restart_hw - restart hardware completely\n *\n * Call this function when the hardware was restarted for some reason\n * (hardware error, ...) and the driver is unable to restore its state\n * by itself. mac80211 assumes that at this point the driver/hardware\n * is completely uninitialised and stopped, it starts the process by\n * calling the ->start() operation. The driver will need to reset all\n * internal state that it has prior to calling this function.\n *\n * @hw: the hardware to restart\n */\nvoid ieee80211_restart_hw(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_rx_list - receive frame and store processed skbs in a list\n *\n * Use this function to hand received frames to mac80211. The receive\n * buffer in @skb must start with an IEEE 802.11 header. In case of a\n * paged @skb is used, the driver is recommended to put the ieee80211\n * header of the frame on the linear part of the @skb to avoid memory\n * allocation and/or memcpy by the stack.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls to\n * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be\n * mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * This function must be called with BHs disabled and RCU read lock\n *\n * @hw: the hardware this frame came in on\n * @sta: the station the frame was received from, or %NULL\n * @skb: the buffer to receive, owned by mac80211 after this call\n * @list: the destination list\n */\nvoid ieee80211_rx_list(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb, struct list_head *list);\n\n/**\n * ieee80211_rx_napi - receive frame from NAPI context\n *\n * Use this function to hand received frames to mac80211. The receive\n * buffer in @skb must start with an IEEE 802.11 header. In case of a\n * paged @skb is used, the driver is recommended to put the ieee80211\n * header of the frame on the linear part of the @skb to avoid memory\n * allocation and/or memcpy by the stack.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls to\n * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be\n * mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * This function must be called with BHs disabled.\n *\n * @hw: the hardware this frame came in on\n * @sta: the station the frame was received from, or %NULL\n * @skb: the buffer to receive, owned by mac80211 after this call\n * @napi: the NAPI context\n */\nvoid ieee80211_rx_napi(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb, struct napi_struct *napi);\n\n/**\n * ieee80211_rx - receive frame\n *\n * Use this function to hand received frames to mac80211. The receive\n * buffer in @skb must start with an IEEE 802.11 header. In case of a\n * paged @skb is used, the driver is recommended to put the ieee80211\n * header of the frame on the linear part of the @skb to avoid memory\n * allocation and/or memcpy by the stack.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls to\n * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be\n * mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * In process context use instead ieee80211_rx_ni().\n *\n * @hw: the hardware this frame came in on\n * @skb: the buffer to receive, owned by mac80211 after this call\n */\nstatic inline void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tieee80211_rx_napi(hw, NULL, skb, NULL);\n}\n\n/**\n * ieee80211_rx_irqsafe - receive frame\n *\n * Like ieee80211_rx() but can be called in IRQ context\n * (internally defers to a tasklet.)\n *\n * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not\n * be mixed for a single hardware.Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * @hw: the hardware this frame came in on\n * @skb: the buffer to receive, owned by mac80211 after this call\n */\nvoid ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);\n\n/**\n * ieee80211_rx_ni - receive frame (in process context)\n *\n * Like ieee80211_rx() but can be called in process context\n * (internally disables bottom halves).\n *\n * Calls to this function, ieee80211_rx() and ieee80211_rx_irqsafe() may\n * not be mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * @hw: the hardware this frame came in on\n * @skb: the buffer to receive, owned by mac80211 after this call\n */\nstatic inline void ieee80211_rx_ni(struct ieee80211_hw *hw,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\tieee80211_rx(hw, skb);\n\tlocal_bh_enable();\n}\n\n/**\n * ieee80211_sta_ps_transition - PS transition for connected sta\n *\n * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS\n * flag set, use this function to inform mac80211 about a connected station\n * entering/leaving PS mode.\n *\n * This function may not be called in IRQ context or with softirqs enabled.\n *\n * Calls to this function for a single hardware must be synchronized against\n * each other.\n *\n * @sta: currently connected sta\n * @start: start or stop PS\n *\n * Return: 0 on success. -EINVAL when the requested PS mode is already set.\n */\nint ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);\n\n/**\n * ieee80211_sta_ps_transition_ni - PS transition for connected sta\n *                                  (in process context)\n *\n * Like ieee80211_sta_ps_transition() but can be called in process context\n * (internally disables bottom halves). Concurrent call restriction still\n * applies.\n *\n * @sta: currently connected sta\n * @start: start or stop PS\n *\n * Return: Like ieee80211_sta_ps_transition().\n */\nstatic inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,\n\t\t\t\t\t\t  bool start)\n{\n\tint ret;\n\n\tlocal_bh_disable();\n\tret = ieee80211_sta_ps_transition(sta, start);\n\tlocal_bh_enable();\n\n\treturn ret;\n}\n\n/**\n * ieee80211_sta_pspoll - PS-Poll frame received\n * @sta: currently connected station\n *\n * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS flag set,\n * use this function to inform mac80211 that a PS-Poll frame from a\n * connected station was received.\n * This must be used in conjunction with ieee80211_sta_ps_transition()\n * and possibly ieee80211_sta_uapsd_trigger(); calls to all three must\n * be serialized.\n */\nvoid ieee80211_sta_pspoll(struct ieee80211_sta *sta);\n\n/**\n * ieee80211_sta_uapsd_trigger - (potential) U-APSD trigger frame received\n * @sta: currently connected station\n * @tid: TID of the received (potential) trigger frame\n *\n * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS flag set,\n * use this function to inform mac80211 that a (potential) trigger frame\n * from a connected station was received.\n * This must be used in conjunction with ieee80211_sta_ps_transition()\n * and possibly ieee80211_sta_pspoll(); calls to all three must be\n * serialized.\n * %IEEE80211_NUM_TIDS can be passed as the tid if the tid is unknown.\n * In this case, mac80211 will not check that this tid maps to an AC\n * that is trigger enabled and assume that the caller did the proper\n * checks.\n */\nvoid ieee80211_sta_uapsd_trigger(struct ieee80211_sta *sta, u8 tid);\n\n/*\n * The TX headroom reserved by mac80211 for its own tx_status functions.\n * This is enough for the radiotap header.\n */\n#define IEEE80211_TX_STATUS_HEADROOM\tALIGN(14, 4)\n\n/**\n * ieee80211_sta_set_buffered - inform mac80211 about driver-buffered frames\n * @sta: &struct ieee80211_sta pointer for the sleeping station\n * @tid: the TID that has buffered frames\n * @buffered: indicates whether or not frames are buffered for this TID\n *\n * If a driver buffers frames for a powersave station instead of passing\n * them back to mac80211 for retransmission, the station may still need\n * to be told that there are buffered frames via the TIM bit.\n *\n * This function informs mac80211 whether or not there are frames that are\n * buffered in the driver for a given TID; mac80211 can then use this data\n * to set the TIM bit (NOTE: This may call back into the driver's set_tim\n * call! Beware of the locking!)\n *\n * If all frames are released to the station (due to PS-poll or uAPSD)\n * then the driver needs to inform mac80211 that there no longer are\n * frames buffered. However, when the station wakes up mac80211 assumes\n * that all buffered frames will be transmitted and clears this data,\n * drivers need to make sure they inform mac80211 about all buffered\n * frames on the sleep transition (sta_notify() with %STA_NOTIFY_SLEEP).\n *\n * Note that technically mac80211 only needs to know this per AC, not per\n * TID, but since driver buffering will inevitably happen per TID (since\n * it is related to aggregation) it is easier to make mac80211 map the\n * TID to the AC as required instead of keeping track in all drivers that\n * use this API.\n */\nvoid ieee80211_sta_set_buffered(struct ieee80211_sta *sta,\n\t\t\t\tu8 tid, bool buffered);\n\n/**\n * ieee80211_get_tx_rates - get the selected transmit rates for a packet\n *\n * Call this function in a driver with per-packet rate selection support\n * to combine the rate info in the packet tx info with the most recent\n * rate selection table for the station entry.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @sta: the receiver station to which this packet is sent.\n * @skb: the frame to be transmitted.\n * @dest: buffer for extracted rate/retry information\n * @max_rates: maximum number of rates to fetch\n */\nvoid ieee80211_get_tx_rates(struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct ieee80211_tx_rate *dest,\n\t\t\t    int max_rates);\n\n/**\n * ieee80211_sta_set_expected_throughput - set the expected tpt for a station\n *\n * Call this function to notify mac80211 about a change in expected throughput\n * to a station. A driver for a device that does rate control in firmware can\n * call this function when the expected throughput estimate towards a station\n * changes. The information is used to tune the CoDel AQM applied to traffic\n * going towards that station (which can otherwise be too aggressive and cause\n * slow stations to starve).\n *\n * @pubsta: the station to set throughput for.\n * @thr: the current expected throughput in kbps.\n */\nvoid ieee80211_sta_set_expected_throughput(struct ieee80211_sta *pubsta,\n\t\t\t\t\t   u32 thr);\n\n/**\n * ieee80211_tx_rate_update - transmit rate update callback\n *\n * Drivers should call this functions with a non-NULL pub sta\n * This function can be used in drivers that does not have provision\n * in updating the tx rate in data path.\n *\n * @hw: the hardware the frame was transmitted by\n * @pubsta: the station to update the tx rate for.\n * @info: tx status information\n */\nvoid ieee80211_tx_rate_update(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_sta *pubsta,\n\t\t\t      struct ieee80211_tx_info *info);\n\n/**\n * ieee80211_tx_status - transmit status callback\n *\n * Call this function for all transmitted frames after they have been\n * transmitted. It is permissible to not call this function for\n * multicast frames but this can affect statistics.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls\n * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe()\n * may not be mixed for a single hardware. Must not run concurrently with\n * ieee80211_rx() or ieee80211_rx_ni().\n *\n * @hw: the hardware the frame was transmitted by\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nvoid ieee80211_tx_status(struct ieee80211_hw *hw,\n\t\t\t struct sk_buff *skb);\n\n/**\n * ieee80211_tx_status_ext - extended transmit status callback\n *\n * This function can be used as a replacement for ieee80211_tx_status\n * in drivers that may want to provide extra information that does not\n * fit into &struct ieee80211_tx_info.\n *\n * Calls to this function for a single hardware must be synchronized\n * against each other. Calls to this function, ieee80211_tx_status_ni()\n * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @status: tx status information\n */\nvoid ieee80211_tx_status_ext(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_status *status);\n\n/**\n * ieee80211_tx_status_noskb - transmit status callback without skb\n *\n * This function can be used as a replacement for ieee80211_tx_status\n * in drivers that cannot reliably map tx status information back to\n * specific skbs.\n *\n * Calls to this function for a single hardware must be synchronized\n * against each other. Calls to this function, ieee80211_tx_status_ni()\n * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @sta: the receiver station to which this packet is sent\n *\t(NULL for multicast packets)\n * @info: tx status information\n */\nstatic inline void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t\t     struct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_tx_status status = {\n\t\t.sta = sta,\n\t\t.info = info,\n\t};\n\n\tieee80211_tx_status_ext(hw, &status);\n}\n\n/**\n * ieee80211_tx_status_ni - transmit status callback (in process context)\n *\n * Like ieee80211_tx_status() but can be called in process context.\n *\n * Calls to this function, ieee80211_tx_status() and\n * ieee80211_tx_status_irqsafe() may not be mixed\n * for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nstatic inline void ieee80211_tx_status_ni(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\tieee80211_tx_status(hw, skb);\n\tlocal_bh_enable();\n}\n\n/**\n * ieee80211_tx_status_irqsafe - IRQ-safe transmit status callback\n *\n * Like ieee80211_tx_status() but can be called in IRQ context\n * (internally defers to a tasklet.)\n *\n * Calls to this function, ieee80211_tx_status() and\n * ieee80211_tx_status_ni() may not be mixed for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nvoid ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,\n\t\t\t\t struct sk_buff *skb);\n\n/**\n * ieee80211_tx_status_8023 - transmit status callback for 802.3 frame format\n *\n * Call this function for all transmitted data frames after their transmit\n * completion. This callback should only be called for data frames which\n * are using driver's (or hardware's) offload capability of encap/decap\n * 802.11 frames.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other and all\n * calls in the same tx status family.\n *\n * @hw: the hardware the frame was transmitted by\n * @vif: the interface for which the frame was transmitted\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nvoid ieee80211_tx_status_8023(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct sk_buff *skb);\n\n/**\n * ieee80211_report_low_ack - report non-responding station\n *\n * When operating in AP-mode, call this function to report a non-responding\n * connected STA.\n *\n * @sta: the non-responding connected sta\n * @num_packets: number of packets sent to @sta without a response\n */\nvoid ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);\n\n#define IEEE80211_MAX_CNTDWN_COUNTERS_NUM 2\n\n/**\n * struct ieee80211_mutable_offsets - mutable beacon offsets\n * @tim_offset: position of TIM element\n * @tim_length: size of TIM element\n * @cntdwn_counter_offs: array of IEEE80211_MAX_CNTDWN_COUNTERS_NUM offsets\n *\tto countdown counters.  This array can contain zero values which\n *\tshould be ignored.\n */\nstruct ieee80211_mutable_offsets {\n\tu16 tim_offset;\n\tu16 tim_length;\n\n\tu16 cntdwn_counter_offs[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];\n};\n\n/**\n * ieee80211_beacon_get_template - beacon template generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @offs: &struct ieee80211_mutable_offsets pointer to struct that will\n *\treceive the offsets that may be updated by the driver.\n *\n * If the driver implements beaconing modes, it must use this function to\n * obtain the beacon template.\n *\n * This function should be used if the beacon frames are generated by the\n * device, and then the driver must use the returned beacon as the template\n * The driver or the device are responsible to update the DTIM and, when\n * applicable, the CSA count.\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: The beacon template. %NULL on error.\n */\nstruct sk_buff *\nieee80211_beacon_get_template(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_mutable_offsets *offs);\n\n/**\n * ieee80211_beacon_get_tim - beacon generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @tim_offset: pointer to variable that will receive the TIM IE offset.\n *\tSet to 0 if invalid (in non-AP modes).\n * @tim_length: pointer to variable that will receive the TIM IE length,\n *\t(including the ID and length bytes!).\n *\tSet to 0 if invalid (in non-AP modes).\n *\n * If the driver implements beaconing modes, it must use this function to\n * obtain the beacon frame.\n *\n * If the beacon frames are generated by the host system (i.e., not in\n * hardware/firmware), the driver uses this function to get each beacon\n * frame from mac80211 -- it is responsible for calling this function exactly\n * once before the beacon is needed (e.g. based on hardware interrupt).\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: The beacon template. %NULL on error.\n */\nstruct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u16 *tim_offset, u16 *tim_length);\n\n/**\n * ieee80211_beacon_get - beacon generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * See ieee80211_beacon_get_tim().\n *\n * Return: See ieee80211_beacon_get_tim().\n */\nstatic inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,\n\t\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\treturn ieee80211_beacon_get_tim(hw, vif, NULL, NULL);\n}\n\n/**\n * ieee80211_beacon_update_cntdwn - request mac80211 to decrement the beacon countdown\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * The beacon counter should be updated after each beacon transmission.\n * This function is called implicitly when\n * ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the\n * beacon frames are generated by the device, the driver should call this\n * function after each beacon transmission to sync mac80211's beacon countdown.\n *\n * Return: new countdown value\n */\nu8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_beacon_set_cntdwn - request mac80211 to set beacon countdown\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @counter: the new value for the counter\n *\n * The beacon countdown can be changed by the device, this API should be\n * used by the device driver to update csa counter in mac80211.\n *\n * It should never be used together with ieee80211_beacon_update_cntdwn(),\n * as it will cause a race condition around the counter value.\n */\nvoid ieee80211_beacon_set_cntdwn(struct ieee80211_vif *vif, u8 counter);\n\n/**\n * ieee80211_csa_finish - notify mac80211 about channel switch\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * After a channel switch announcement was scheduled and the counter in this\n * announcement hits 1, this function must be called by the driver to\n * notify mac80211 that the channel can be changed.\n */\nvoid ieee80211_csa_finish(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_beacon_cntdwn_is_complete - find out if countdown reached 1\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * This function returns whether the countdown reached zero.\n */\nbool ieee80211_beacon_cntdwn_is_complete(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_proberesp_get - retrieve a Probe Response template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Creates a Probe Response template which can, for example, be uploaded to\n * hardware. The destination address should be set by the caller.\n *\n * Can only be called in AP mode.\n *\n * Return: The Probe Response template. %NULL on error.\n */\nstruct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif);\n\n/**\n * ieee80211_pspoll_get - retrieve a PS Poll template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Creates a PS Poll a template which can, for example, uploaded to\n * hardware. The template must be updated after association so that correct\n * AID, BSSID and MAC address is used.\n *\n * Note: Caller (or hardware) is responsible for setting the\n * &IEEE80211_FCTL_PM bit.\n *\n * Return: The PS Poll template. %NULL on error.\n */\nstruct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif);\n\n/**\n * ieee80211_nullfunc_get - retrieve a nullfunc template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @qos_ok: QoS NDP is acceptable to the caller, this should be set\n *\tif at all possible\n *\n * Creates a Nullfunc template which can, for example, uploaded to\n * hardware. The template must be updated after association so that correct\n * BSSID and address is used.\n *\n * If @qos_ndp is set and the association is to an AP with QoS/WMM, the\n * returned packet will be QoS NDP.\n *\n * Note: Caller (or hardware) is responsible for setting the\n * &IEEE80211_FCTL_PM bit as well as Duration and Sequence Control fields.\n *\n * Return: The nullfunc template. %NULL on error.\n */\nstruct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       bool qos_ok);\n\n/**\n * ieee80211_probereq_get - retrieve a Probe Request template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @src_addr: source MAC address\n * @ssid: SSID buffer\n * @ssid_len: length of SSID\n * @tailroom: tailroom to reserve at end of SKB for IEs\n *\n * Creates a Probe Request template which can, for example, be uploaded to\n * hardware.\n *\n * Return: The Probe Request template. %NULL on error.\n */\nstruct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t       const u8 *src_addr,\n\t\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t\t       size_t tailroom);\n\n/**\n * ieee80211_rts_get - RTS frame generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame: pointer to the frame that is going to be protected by the RTS.\n * @frame_len: the frame length (in octets).\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n * @rts: The buffer where to store the RTS frame.\n *\n * If the RTS frames are generated by the host system (i.e., not in\n * hardware/firmware), the low-level driver uses this function to receive\n * the next RTS frame from the 802.11 code. The low-level is responsible\n * for calling this function before and RTS frame is needed.\n */\nvoid ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       const void *frame, size_t frame_len,\n\t\t       const struct ieee80211_tx_info *frame_txctl,\n\t\t       struct ieee80211_rts *rts);\n\n/**\n * ieee80211_rts_duration - Get the duration field for an RTS frame\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame_len: the length of the frame that is going to be protected by the RTS.\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n *\n * If the RTS is generated in firmware, but the host system must provide\n * the duration field, the low-level driver uses this function to receive\n * the duration field value in little-endian byteorder.\n *\n * Return: The duration.\n */\n__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, size_t frame_len,\n\t\t\t      const struct ieee80211_tx_info *frame_txctl);\n\n/**\n * ieee80211_ctstoself_get - CTS-to-self frame generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame: pointer to the frame that is going to be protected by the CTS-to-self.\n * @frame_len: the frame length (in octets).\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n * @cts: The buffer where to store the CTS-to-self frame.\n *\n * If the CTS-to-self frames are generated by the host system (i.e., not in\n * hardware/firmware), the low-level driver uses this function to receive\n * the next CTS-to-self frame from the 802.11 code. The low-level is responsible\n * for calling this function before and CTS-to-self frame is needed.\n */\nvoid ieee80211_ctstoself_get(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     const void *frame, size_t frame_len,\n\t\t\t     const struct ieee80211_tx_info *frame_txctl,\n\t\t\t     struct ieee80211_cts *cts);\n\n/**\n * ieee80211_ctstoself_duration - Get the duration field for a CTS-to-self frame\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n *\n * If the CTS-to-self is generated in firmware, but the host system must provide\n * the duration field, the low-level driver uses this function to receive\n * the duration field value in little-endian byteorder.\n *\n * Return: The duration.\n */\n__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    size_t frame_len,\n\t\t\t\t    const struct ieee80211_tx_info *frame_txctl);\n\n/**\n * ieee80211_generic_frame_duration - Calculate the duration field for a frame\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @band: the band to calculate the frame duration on\n * @frame_len: the length of the frame.\n * @rate: the rate at which the frame is going to be transmitted.\n *\n * Calculate the duration field of some generic frame, given its\n * length and transmission rate (in 100kbps).\n *\n * Return: The duration.\n */\n__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tenum nl80211_band band,\n\t\t\t\t\tsize_t frame_len,\n\t\t\t\t\tstruct ieee80211_rate *rate);\n\n/**\n * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Function for accessing buffered broadcast and multicast frames. If\n * hardware/firmware does not implement buffering of broadcast/multicast\n * frames when power saving is used, 802.11 code buffers them in the host\n * memory. The low-level driver uses this function to fetch next buffered\n * frame. In most cases, this is used when generating beacon frame.\n *\n * Return: A pointer to the next buffered skb or NULL if no more buffered\n * frames are available.\n *\n * Note: buffered frames are returned only after DTIM beacon frame was\n * generated with ieee80211_beacon_get() and the low-level driver must thus\n * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns\n * NULL if the previous generated beacon was not DTIM, so the low-level driver\n * does not need to check for DTIM beacons separately and should be able to\n * use common code for all beacons.\n */\nstruct sk_buff *\nieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\n/**\n * ieee80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32\n *\n * This function returns the TKIP phase 1 key for the given IV32.\n *\n * @keyconf: the parameter passed with the set key\n * @iv32: IV32 to get the P1K for\n * @p1k: a buffer to which the key will be written, as 5 u16 values\n */\nvoid ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,\n\t\t\t       u32 iv32, u16 *p1k);\n\n/**\n * ieee80211_get_tkip_p1k - get a TKIP phase 1 key\n *\n * This function returns the TKIP phase 1 key for the IV32 taken\n * from the given packet.\n *\n * @keyconf: the parameter passed with the set key\n * @skb: the packet to take the IV32 value from that will be encrypted\n *\twith this P1K\n * @p1k: a buffer to which the key will be written, as 5 u16 values\n */\nstatic inline void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf,\n\t\t\t\t\t  struct sk_buff *skb, u16 *p1k)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tconst u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);\n\tu32 iv32 = get_unaligned_le32(&data[4]);\n\n\tieee80211_get_tkip_p1k_iv(keyconf, iv32, p1k);\n}\n\n/**\n * ieee80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX\n *\n * This function returns the TKIP phase 1 key for the given IV32\n * and transmitter address.\n *\n * @keyconf: the parameter passed with the set key\n * @ta: TA that will be used with the key\n * @iv32: IV32 to get the P1K for\n * @p1k: a buffer to which the key will be written, as 5 u16 values\n */\nvoid ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,\n\t\t\t       const u8 *ta, u32 iv32, u16 *p1k);\n\n/**\n * ieee80211_get_tkip_p2k - get a TKIP phase 2 key\n *\n * This function computes the TKIP RC4 key for the IV values\n * in the packet.\n *\n * @keyconf: the parameter passed with the set key\n * @skb: the packet to take the IV32/IV16 values from that will be\n *\tencrypted with this key\n * @p2k: a buffer to which the key will be written, 16 bytes\n */\nvoid ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,\n\t\t\t    struct sk_buff *skb, u8 *p2k);\n\n/**\n * ieee80211_tkip_add_iv - write TKIP IV and Ext. IV to pos\n *\n * @pos: start of crypto header\n * @keyconf: the parameter passed with the set key\n * @pn: PN to add\n *\n * Returns: pointer to the octet following IVs (i.e. beginning of\n * the packet payload)\n *\n * This function writes the tkip IV value to pos (which should\n * point to the crypto header)\n */\nu8 *ieee80211_tkip_add_iv(u8 *pos, struct ieee80211_key_conf *keyconf, u64 pn);\n\n/**\n * ieee80211_get_key_rx_seq - get key RX sequence counter\n *\n * @keyconf: the parameter passed with the set key\n * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);\n *\tthe value on TID 0 is also used for non-QoS frames. For\n *\tCMAC, only TID 0 is valid.\n * @seq: buffer to receive the sequence data\n *\n * This function allows a driver to retrieve the current RX IV/PNs\n * for the given key. It must not be called if IV checking is done\n * by the device and not by mac80211.\n *\n * Note that this function may only be called when no RX processing\n * can be done concurrently.\n */\nvoid ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq);\n\n/**\n * ieee80211_set_key_rx_seq - set key RX sequence counter\n *\n * @keyconf: the parameter passed with the set key\n * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);\n *\tthe value on TID 0 is also used for non-QoS frames. For\n *\tCMAC, only TID 0 is valid.\n * @seq: new sequence data\n *\n * This function allows a driver to set the current RX IV/PNs for the\n * given key. This is useful when resuming from WoWLAN sleep and GTK\n * rekey may have been done while suspended. It should not be called\n * if IV checking is done by the device and not by mac80211.\n *\n * Note that this function may only be called when no RX processing\n * can be done concurrently.\n */\nvoid ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq);\n\n/**\n * ieee80211_remove_key - remove the given key\n * @keyconf: the parameter passed with the set key\n *\n * Remove the given key. If the key was uploaded to the hardware at the\n * time this function is called, it is not deleted in the hardware but\n * instead assumed to have been removed already.\n *\n * Note that due to locking considerations this function can (currently)\n * only be called during key iteration (ieee80211_iter_keys().)\n */\nvoid ieee80211_remove_key(struct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_gtk_rekey_add - add a GTK key from rekeying during WoWLAN\n * @vif: the virtual interface to add the key on\n * @keyconf: new key data\n *\n * When GTK rekeying was done while the system was suspended, (a) new\n * key(s) will be available. These will be needed by mac80211 for proper\n * RX processing, so this function allows setting them.\n *\n * The function returns the newly allocated key structure, which will\n * have similar contents to the passed key configuration but point to\n * mac80211-owned memory. In case of errors, the function returns an\n * ERR_PTR(), use IS_ERR() etc.\n *\n * Note that this function assumes the key isn't added to hardware\n * acceleration, so no TX will be done with the key. Since it's a GTK\n * on managed (station) networks, this is true anyway. If the driver\n * calls this function from the resume callback and subsequently uses\n * the return code 1 to reconfigure the device, this key will be part\n * of the reconfiguration.\n *\n * Note that the driver should also call ieee80211_set_key_rx_seq()\n * for the new key for each TID to set up sequence counters properly.\n *\n * IMPORTANT: If this replaces a key that is present in the hardware,\n * then it will attempt to remove it during this call. In many cases\n * this isn't what you want, so call ieee80211_remove_key() first for\n * the key that's being replaced.\n */\nstruct ieee80211_key_conf *\nieee80211_gtk_rekey_add(struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying\n * @vif: virtual interface the rekeying was done on\n * @bssid: The BSSID of the AP, for checking association\n * @replay_ctr: the new replay counter after GTK rekeying\n * @gfp: allocation flags\n */\nvoid ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,\n\t\t\t\tconst u8 *replay_ctr, gfp_t gfp);\n\n/**\n * ieee80211_key_mic_failure - increment MIC failure counter for the key\n *\n * Note: this is really only safe if no other RX function is called\n * at the same time.\n *\n * @keyconf: the key in question\n */\nvoid ieee80211_key_mic_failure(struct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_key_replay - increment replay counter for the key\n *\n * Note: this is really only safe if no other RX function is called\n * at the same time.\n *\n * @keyconf: the key in question\n */\nvoid ieee80211_key_replay(struct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_wake_queue - wake specific queue\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @queue: queue number (counted from zero).\n *\n * Drivers should use this function instead of netif_wake_queue.\n */\nvoid ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);\n\n/**\n * ieee80211_stop_queue - stop specific queue\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @queue: queue number (counted from zero).\n *\n * Drivers should use this function instead of netif_stop_queue.\n */\nvoid ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);\n\n/**\n * ieee80211_queue_stopped - test status of the queue\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @queue: queue number (counted from zero).\n *\n * Drivers should use this function instead of netif_stop_queue.\n *\n * Return: %true if the queue is stopped. %false otherwise.\n */\n\nint ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);\n\n/**\n * ieee80211_stop_queues - stop all queues\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n *\n * Drivers should use this function instead of netif_stop_queue.\n */\nvoid ieee80211_stop_queues(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_wake_queues - wake all queues\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n *\n * Drivers should use this function instead of netif_wake_queue.\n */\nvoid ieee80211_wake_queues(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_scan_completed - completed hardware scan\n *\n * When hardware scan offload is used (i.e. the hw_scan() callback is\n * assigned) this function needs to be called by the driver to notify\n * mac80211 that the scan finished. This function can be called from\n * any context, including hardirq context.\n *\n * @hw: the hardware that finished the scan\n * @info: information about the completed scan\n */\nvoid ieee80211_scan_completed(struct ieee80211_hw *hw,\n\t\t\t      struct cfg80211_scan_info *info);\n\n/**\n * ieee80211_sched_scan_results - got results from scheduled scan\n *\n * When a scheduled scan is running, this function needs to be called by the\n * driver whenever there are new scan results available.\n *\n * @hw: the hardware that is performing scheduled scans\n */\nvoid ieee80211_sched_scan_results(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_sched_scan_stopped - inform that the scheduled scan has stopped\n *\n * When a scheduled scan is running, this function can be called by\n * the driver if it needs to stop the scan to perform another task.\n * Usual scenarios are drivers that cannot continue the scheduled scan\n * while associating, for instance.\n *\n * @hw: the hardware that is performing scheduled scans\n */\nvoid ieee80211_sched_scan_stopped(struct ieee80211_hw *hw);\n\n/**\n * enum ieee80211_interface_iteration_flags - interface iteration flags\n * @IEEE80211_IFACE_ITER_NORMAL: Iterate over all interfaces that have\n *\tbeen added to the driver; However, note that during hardware\n *\treconfiguration (after restart_hw) it will iterate over a new\n *\tinterface and over all the existing interfaces even if they\n *\thaven't been re-added to the driver yet.\n * @IEEE80211_IFACE_ITER_RESUME_ALL: During resume, iterate over all\n *\tinterfaces, even if they haven't been re-added to the driver yet.\n * @IEEE80211_IFACE_ITER_ACTIVE: Iterate only active interfaces (netdev is up).\n * @IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER: Skip any interfaces where SDATA\n *\tis not in the driver.  This may fix crashes during firmware recovery\n *\tfor instance.\n */\nenum ieee80211_interface_iteration_flags {\n\tIEEE80211_IFACE_ITER_NORMAL\t= 0,\n\tIEEE80211_IFACE_ITER_RESUME_ALL\t= BIT(0),\n\tIEEE80211_IFACE_ITER_ACTIVE\t= BIT(1),\n\tIEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER\t= BIT(2),\n};\n\n/**\n * ieee80211_iterate_interfaces - iterate interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware and calls the callback for them. This includes active as well as\n * inactive interfaces. This function allows the iterator function to sleep.\n * Will iterate over a new interface during add_interface().\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_interfaces(struct ieee80211_hw *hw, u32 iter_flags,\n\t\t\t\t  void (*iterator)(void *data, u8 *mac,\n\t\t\t\t\t\t   struct ieee80211_vif *vif),\n\t\t\t\t  void *data);\n\n/**\n * ieee80211_iterate_active_interfaces - iterate active interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware that are currently active and calls the callback for them.\n * This function allows the iterator function to sleep, when the iterator\n * function is atomic @ieee80211_iterate_active_interfaces_atomic can\n * be used.\n * Does not iterate over a new interface during add_interface().\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call\n * @data: first argument of the iterator function\n */\nstatic inline void\nieee80211_iterate_active_interfaces(struct ieee80211_hw *hw, u32 iter_flags,\n\t\t\t\t    void (*iterator)(void *data, u8 *mac,\n\t\t\t\t\t\t     struct ieee80211_vif *vif),\n\t\t\t\t    void *data)\n{\n\tieee80211_iterate_interfaces(hw,\n\t\t\t\t     iter_flags | IEEE80211_IFACE_ITER_ACTIVE,\n\t\t\t\t     iterator, data);\n}\n\n/**\n * ieee80211_iterate_active_interfaces_atomic - iterate active interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware that are currently active and calls the callback for them.\n * This function requires the iterator callback function to be atomic,\n * if that is not desired, use @ieee80211_iterate_active_interfaces instead.\n * Does not iterate over a new interface during add_interface().\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call, cannot sleep\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,\n\t\t\t\t\t\tu32 iter_flags,\n\t\t\t\t\t\tvoid (*iterator)(void *data,\n\t\t\t\t\t\t    u8 *mac,\n\t\t\t\t\t\t    struct ieee80211_vif *vif),\n\t\t\t\t\t\tvoid *data);\n\n/**\n * ieee80211_iterate_active_interfaces_mtx - iterate active interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware that are currently active and calls the callback for them.\n * This version can only be used while holding the wiphy mutex.\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call, cannot sleep\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_active_interfaces_mtx(struct ieee80211_hw *hw,\n\t\t\t\t\t     u32 iter_flags,\n\t\t\t\t\t     void (*iterator)(void *data,\n\t\t\t\t\t\tu8 *mac,\n\t\t\t\t\t\tstruct ieee80211_vif *vif),\n\t\t\t\t\t     void *data);\n\n/**\n * ieee80211_iterate_stations_atomic - iterate stations\n *\n * This function iterates over all stations associated with a given\n * hardware that are currently uploaded to the driver and calls the callback\n * function for them.\n * This function requires the iterator callback function to be atomic,\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iterator: the iterator function to call, cannot sleep\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,\n\t\t\t\t       void (*iterator)(void *data,\n\t\t\t\t\t\tstruct ieee80211_sta *sta),\n\t\t\t\t       void *data);\n/**\n * ieee80211_queue_work - add work onto the mac80211 workqueue\n *\n * Drivers and mac80211 use this to add work onto the mac80211 workqueue.\n * This helper ensures drivers are not queueing work when they should not be.\n *\n * @hw: the hardware struct for the interface we are adding work for\n * @work: the work we want to add onto the mac80211 workqueue\n */\nvoid ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);\n\n/**\n * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue\n *\n * Drivers and mac80211 use this to queue delayed work onto the mac80211\n * workqueue.\n *\n * @hw: the hardware struct for the interface we are adding work for\n * @dwork: delayable work to queue onto the mac80211 workqueue\n * @delay: number of jiffies to wait before queueing\n */\nvoid ieee80211_queue_delayed_work(struct ieee80211_hw *hw,\n\t\t\t\t  struct delayed_work *dwork,\n\t\t\t\t  unsigned long delay);\n\n/**\n * ieee80211_start_tx_ba_session - Start a tx Block Ack session.\n * @sta: the station for which to start a BA session\n * @tid: the TID to BA on.\n * @timeout: session timeout value (in TUs)\n *\n * Return: success if addBA request was sent, failure otherwise\n *\n * Although mac80211/low level driver/user space application can estimate\n * the need to start aggregation on a certain RA/TID, the session level\n * will be managed by the mac80211.\n */\nint ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,\n\t\t\t\t  u16 timeout);\n\n/**\n * ieee80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @ra: receiver address of the BA session recipient.\n * @tid: the TID to BA on.\n *\n * This function must be called by low level driver once it has\n * finished with preparations for the BA session. It can be called\n * from any context.\n */\nvoid ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,\n\t\t\t\t      u16 tid);\n\n/**\n * ieee80211_stop_tx_ba_session - Stop a Block Ack session.\n * @sta: the station whose BA session to stop\n * @tid: the TID to stop BA.\n *\n * Return: negative error if the TID is invalid, or no aggregation active\n *\n * Although mac80211/low level driver/user space application can estimate\n * the need to stop aggregation on a certain RA/TID, the session level\n * will be managed by the mac80211.\n */\nint ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);\n\n/**\n * ieee80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @ra: receiver address of the BA session recipient.\n * @tid: the desired TID to BA on.\n *\n * This function must be called by low level driver once it has\n * finished with preparations for the BA session tear down. It\n * can be called from any context.\n */\nvoid ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,\n\t\t\t\t     u16 tid);\n\n/**\n * ieee80211_find_sta - find a station\n *\n * @vif: virtual interface to look for station on\n * @addr: station's address\n *\n * Return: The station, if found. %NULL otherwise.\n *\n * Note: This function must be called under RCU lock and the\n * resulting pointer is only valid under RCU lock as well.\n */\nstruct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,\n\t\t\t\t\t const u8 *addr);\n\n/**\n * ieee80211_find_sta_by_ifaddr - find a station on hardware\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @addr: remote station's address\n * @localaddr: local address (vif->sdata->vif.addr). Use NULL for 'any'.\n *\n * Return: The station, if found. %NULL otherwise.\n *\n * Note: This function must be called under RCU lock and the\n * resulting pointer is only valid under RCU lock as well.\n *\n * NOTE: You may pass NULL for localaddr, but then you will just get\n *      the first STA that matches the remote address 'addr'.\n *      We can have multiple STA associated with multiple\n *      logical stations (e.g. consider a station connecting to another\n *      BSSID on the same AP hardware without disconnecting first).\n *      In this case, the result of this method with localaddr NULL\n *      is not reliable.\n *\n * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.\n */\nstruct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,\n\t\t\t\t\t       const u8 *addr,\n\t\t\t\t\t       const u8 *localaddr);\n\n/**\n * ieee80211_sta_block_awake - block station from waking up\n * @hw: the hardware\n * @pubsta: the station\n * @block: whether to block or unblock\n *\n * Some devices require that all frames that are on the queues\n * for a specific station that went to sleep are flushed before\n * a poll response or frames after the station woke up can be\n * delivered to that it. Note that such frames must be rejected\n * by the driver as filtered, with the appropriate status flag.\n *\n * This function allows implementing this mode in a race-free\n * manner.\n *\n * To do this, a driver must keep track of the number of frames\n * still enqueued for a specific station. If this number is not\n * zero when the station goes to sleep, the driver must call\n * this function to force mac80211 to consider the station to\n * be asleep regardless of the station's actual state. Once the\n * number of outstanding frames reaches zero, the driver must\n * call this function again to unblock the station. That will\n * cause mac80211 to be able to send ps-poll responses, and if\n * the station queried in the meantime then frames will also\n * be sent out as a result of this. Additionally, the driver\n * will be notified that the station woke up some time after\n * it is unblocked, regardless of whether the station actually\n * woke up while blocked or not.\n */\nvoid ieee80211_sta_block_awake(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *pubsta, bool block);\n\n/**\n * ieee80211_sta_eosp - notify mac80211 about end of SP\n * @pubsta: the station\n *\n * When a device transmits frames in a way that it can't tell\n * mac80211 in the TX status about the EOSP, it must clear the\n * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.\n * This applies for PS-Poll as well as uAPSD.\n *\n * Note that just like with _tx_status() and _rx() drivers must\n * not mix calls to irqsafe/non-irqsafe versions, this function\n * must not be mixed with those either. Use the all irqsafe, or\n * all non-irqsafe, don't mix!\n *\n * NB: the _irqsafe version of this function doesn't exist, no\n *     driver needs it right now. Don't call this function if\n *     you'd need the _irqsafe version, look at the git history\n *     and restore the _irqsafe version!\n */\nvoid ieee80211_sta_eosp(struct ieee80211_sta *pubsta);\n\n/**\n * ieee80211_send_eosp_nullfunc - ask mac80211 to send NDP with EOSP\n * @pubsta: the station\n * @tid: the tid of the NDP\n *\n * Sometimes the device understands that it needs to close\n * the Service Period unexpectedly. This can happen when\n * sending frames that are filling holes in the BA window.\n * In this case, the device can ask mac80211 to send a\n * Nullfunc frame with EOSP set. When that happens, the\n * driver must have called ieee80211_sta_set_buffered() to\n * let mac80211 know that there are no buffered frames any\n * more, otherwise mac80211 will get the more_data bit wrong.\n * The low level driver must have made sure that the frame\n * will be sent despite the station being in power-save.\n * Mac80211 won't call allow_buffered_frames().\n * Note that calling this function, doesn't exempt the driver\n * from closing the EOSP properly, it will still have to call\n * ieee80211_sta_eosp when the NDP is sent.\n */\nvoid ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid);\n\n/**\n * ieee80211_sta_register_airtime - register airtime usage for a sta/tid\n *\n * Register airtime usage for a given sta on a given tid. The driver must call\n * this function to notify mac80211 that a station used a certain amount of\n * airtime. This information will be used by the TXQ scheduler to schedule\n * stations in a way that ensures airtime fairness.\n *\n * The reported airtime should as a minimum include all time that is spent\n * transmitting to the remote station, including overhead and padding, but not\n * including time spent waiting for a TXOP. If the time is not reported by the\n * hardware it can in some cases be calculated from the rate and known frame\n * composition. When possible, the time should include any failed transmission\n * attempts.\n *\n * The driver can either call this function synchronously for every packet or\n * aggregate, or asynchronously as airtime usage information becomes available.\n * TX and RX airtime can be reported together, or separately by setting one of\n * them to 0.\n *\n * @pubsta: the station\n * @tid: the TID to register airtime for\n * @tx_airtime: airtime used during TX (in usec)\n * @rx_airtime: airtime used during RX (in usec)\n */\nvoid ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t    u32 tx_airtime, u32 rx_airtime);\n\n/**\n * ieee80211_txq_airtime_check - check if a txq can send frame to device\n *\n * @hw: pointer obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n *\n * Return true if the AQL's airtime limit has not been reached and the txq can\n * continue to send more packets to the device. Otherwise return false.\n */\nbool\nieee80211_txq_airtime_check(struct ieee80211_hw *hw, struct ieee80211_txq *txq);\n\n/**\n * ieee80211_iter_keys - iterate keys programmed into the device\n * @hw: pointer obtained from ieee80211_alloc_hw()\n * @vif: virtual interface to iterate, may be %NULL for all\n * @iter: iterator function that will be called for each key\n * @iter_data: custom data to pass to the iterator function\n *\n * This function can be used to iterate all the keys known to\n * mac80211, even those that weren't previously programmed into\n * the device. This is intended for use in WoWLAN if the device\n * needs reprogramming of the keys during suspend. Note that due\n * to locking reasons, it is also only safe to call this at few\n * spots since it must hold the RTNL and be able to sleep.\n *\n * The order in which the keys are iterated matches the order\n * in which they were originally installed and handed to the\n * set_key callback.\n */\nvoid ieee80211_iter_keys(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t\t      void *data),\n\t\t\t void *iter_data);\n\n/**\n * ieee80211_iter_keys_rcu - iterate keys programmed into the device\n * @hw: pointer obtained from ieee80211_alloc_hw()\n * @vif: virtual interface to iterate, may be %NULL for all\n * @iter: iterator function that will be called for each key\n * @iter_data: custom data to pass to the iterator function\n *\n * This function can be used to iterate all the keys known to\n * mac80211, even those that weren't previously programmed into\n * the device. Note that due to locking reasons, keys of station\n * in removal process will be skipped.\n *\n * This function requires being called in an RCU critical section,\n * and thus iter must be atomic.\n */\nvoid ieee80211_iter_keys_rcu(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t\t  struct ieee80211_key_conf *key,\n\t\t\t\t\t  void *data),\n\t\t\t     void *iter_data);\n\n/**\n * ieee80211_iter_chan_contexts_atomic - iterate channel contexts\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @iter: iterator function\n * @iter_data: data passed to iterator function\n *\n * Iterate all active channel contexts. This function is atomic and\n * doesn't acquire any locks internally that might be held in other\n * places while calling into the driver.\n *\n * The iterator will not find a context that's being added (during\n * the driver callback to add it) but will find it while it's being\n * removed.\n *\n * Note that during hardware restart, all contexts that existed\n * before the restart are considered already present so will be\n * found while iterating, whether they've been re-added already\n * or not.\n */\nvoid ieee80211_iter_chan_contexts_atomic(\n\tstruct ieee80211_hw *hw,\n\tvoid (*iter)(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_chanctx_conf *chanctx_conf,\n\t\t     void *data),\n\tvoid *iter_data);\n\n/**\n * ieee80211_ap_probereq_get - retrieve a Probe Request template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Creates a Probe Request template which can, for example, be uploaded to\n * hardware. The template is filled with bssid, ssid and supported rate\n * information. This function must only be called from within the\n * .bss_info_changed callback function and only in managed mode. The function\n * is only useful when the interface is associated, otherwise it will return\n * %NULL.\n *\n * Return: The Probe Request template. %NULL on error.\n */\nstruct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif);\n\n/**\n * ieee80211_beacon_loss - inform hardware does not receive beacons\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER and\n * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the\n * hardware is not receiving beacons with this function.\n */\nvoid ieee80211_beacon_loss(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_connection_loss - inform hardware has lost connection to the AP\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER, and\n * %IEEE80211_CONF_PS and %IEEE80211_HW_CONNECTION_MONITOR are set, the driver\n * needs to inform if the connection to the AP has been lost.\n * The function may also be called if the connection needs to be terminated\n * for some other reason, even if %IEEE80211_HW_CONNECTION_MONITOR isn't set.\n *\n * This function will cause immediate change to disassociated state,\n * without connection recovery attempts.\n */\nvoid ieee80211_connection_loss(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_disconnect - request disconnection\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @reconnect: immediate reconnect is desired\n *\n * Request disconnection from the current network and, if enabled, send a\n * hint to the higher layers that immediate reconnect is desired.\n */\nvoid ieee80211_disconnect(struct ieee80211_vif *vif, bool reconnect);\n\n/**\n * ieee80211_resume_disconnect - disconnect from AP after resume\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Instructs mac80211 to disconnect from the AP after resume.\n * Drivers can use this after WoWLAN if they know that the\n * connection cannot be kept up, for example because keys were\n * used while the device was asleep but the replay counters or\n * similar cannot be retrieved from the device during resume.\n *\n * Note that due to implementation issues, if the driver uses\n * the reconfiguration functionality during resume the interface\n * will still be added as associated first during resume and then\n * disconnect normally later.\n *\n * This function can only be called from the resume callback and\n * the driver must not be holding any of its own locks while it\n * calls this function, or at least not any locks it needs in the\n * key configuration paths (if it supports HW crypto).\n */\nvoid ieee80211_resume_disconnect(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_cqm_rssi_notify - inform a configured connection quality monitoring\n *\trssi threshold triggered\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @rssi_event: the RSSI trigger event type\n * @rssi_level: new RSSI level value or 0 if not available\n * @gfp: context flags\n *\n * When the %IEEE80211_VIF_SUPPORTS_CQM_RSSI is set, and a connection quality\n * monitoring is configured with an rssi threshold, the driver will inform\n * whenever the rssi level reaches the threshold.\n */\nvoid ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,\n\t\t\t       enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t       s32 rssi_level,\n\t\t\t       gfp_t gfp);\n\n/**\n * ieee80211_cqm_beacon_loss_notify - inform CQM of beacon loss\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @gfp: context flags\n */\nvoid ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);\n\n/**\n * ieee80211_radar_detected - inform that a radar was detected\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n */\nvoid ieee80211_radar_detected(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_chswitch_done - Complete channel switch process\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @success: make the channel switch successful or not\n *\n * Complete the channel switch post-process: set the new operational channel\n * and wake up the suspended queues.\n */\nvoid ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);\n\n/**\n * ieee80211_request_smps - request SM PS transition\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @smps_mode: new SM PS mode\n *\n * This allows the driver to request an SM PS transition in managed\n * mode. This is useful when the driver has more information than\n * the stack about possible interference, for example by bluetooth.\n */\nvoid ieee80211_request_smps(struct ieee80211_vif *vif,\n\t\t\t    enum ieee80211_smps_mode smps_mode);\n\n/**\n * ieee80211_ready_on_channel - notification of remain-on-channel start\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n */\nvoid ieee80211_ready_on_channel(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_remain_on_channel_expired - remain_on_channel duration expired\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n */\nvoid ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_stop_rx_ba_session - callback to stop existing BA sessions\n *\n * in order not to harm the system performance and user experience, the device\n * may request not to allow any rx ba session and tear down existing rx ba\n * sessions based on system constraints such as periodic BT activity that needs\n * to limit wlan activity (eg.sco or a2dp).\"\n * in such cases, the intention is to limit the duration of the rx ppdu and\n * therefore prevent the peer device to use a-mpdu aggregation.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @ba_rx_bitmap: Bit map of open rx ba per tid\n * @addr: & to bssid mac address\n */\nvoid ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,\n\t\t\t\t  const u8 *addr);\n\n/**\n * ieee80211_mark_rx_ba_filtered_frames - move RX BA window and mark filtered\n * @pubsta: station struct\n * @tid: the session's TID\n * @ssn: starting sequence number of the bitmap, all frames before this are\n *\tassumed to be out of the window after the call\n * @filtered: bitmap of filtered frames, BIT(0) is the @ssn entry etc.\n * @received_mpdus: number of received mpdus in firmware\n *\n * This function moves the BA window and releases all frames before @ssn, and\n * marks frames marked in the bitmap as having been filtered. Afterwards, it\n * checks if any frames in the window starting from @ssn can now be released\n * (in case they were only waiting for frames that were filtered.)\n */\nvoid ieee80211_mark_rx_ba_filtered_frames(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t\t  u16 ssn, u64 filtered,\n\t\t\t\t\t  u16 received_mpdus);\n\n/**\n * ieee80211_send_bar - send a BlockAckReq frame\n *\n * can be used to flush pending frames from the peer's aggregation reorder\n * buffer.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @ra: the peer's destination address\n * @tid: the TID of the aggregation session\n * @ssn: the new starting sequence number for the receiver\n */\nvoid ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);\n\n/**\n * ieee80211_manage_rx_ba_offl - helper to queue an RX BA work\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nvoid ieee80211_manage_rx_ba_offl(struct ieee80211_vif *vif, const u8 *addr,\n\t\t\t\t unsigned int tid);\n\n/**\n * ieee80211_start_rx_ba_session_offl - start a Rx BA session\n *\n * Some device drivers may offload part of the Rx aggregation flow including\n * AddBa/DelBa negotiation but may otherwise be incapable of full Rx\n * reordering.\n *\n * Create structures responsible for reordering so device drivers may call here\n * when they complete AddBa negotiation.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nstatic inline void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,\n\t\t\t\t\t\t      const u8 *addr, u16 tid)\n{\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\tieee80211_manage_rx_ba_offl(vif, addr, tid);\n}\n\n/**\n * ieee80211_stop_rx_ba_session_offl - stop a Rx BA session\n *\n * Some device drivers may offload part of the Rx aggregation flow including\n * AddBa/DelBa negotiation but may otherwise be incapable of full Rx\n * reordering.\n *\n * Destroy structures responsible for reordering so device drivers may call here\n * when they complete DelBa negotiation.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nstatic inline void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,\n\t\t\t\t\t\t     const u8 *addr, u16 tid)\n{\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\tieee80211_manage_rx_ba_offl(vif, addr, tid + IEEE80211_NUM_TIDS);\n}\n\n/**\n * ieee80211_rx_ba_timer_expired - stop a Rx BA session due to timeout\n *\n * Some device drivers do not offload AddBa/DelBa negotiation, but handle rx\n * buffer reording internally, and therefore also handle the session timer.\n *\n * Trigger the timeout flow, which sends a DelBa.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nvoid ieee80211_rx_ba_timer_expired(struct ieee80211_vif *vif,\n\t\t\t\t   const u8 *addr, unsigned int tid);\n\n/* Rate control API */\n\n/**\n * struct ieee80211_tx_rate_control - rate control information for/from RC algo\n *\n * @hw: The hardware the algorithm is invoked for.\n * @sband: The band this frame is being transmitted on.\n * @bss_conf: the current BSS configuration\n * @skb: the skb that will be transmitted, the control information in it needs\n *\tto be filled in\n * @reported_rate: The rate control algorithm can fill this in to indicate\n *\twhich rate should be reported to userspace as the current rate and\n *\tused for rate calculations in the mesh network.\n * @rts: whether RTS will be used for this frame because it is longer than the\n *\tRTS threshold\n * @short_preamble: whether mac80211 will request short-preamble transmission\n *\tif the selected rate supports it\n * @rate_idx_mask: user-requested (legacy) rate mask\n * @rate_idx_mcs_mask: user-requested MCS rate mask (NULL if not in use)\n * @bss: whether this frame is sent out in AP or IBSS mode\n */\nstruct ieee80211_tx_rate_control {\n\tstruct ieee80211_hw *hw;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_bss_conf *bss_conf;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_rate reported_rate;\n\tbool rts, short_preamble;\n\tu32 rate_idx_mask;\n\tu8 *rate_idx_mcs_mask;\n\tbool bss;\n};\n\n/**\n * enum rate_control_capabilities - rate control capabilities\n */\nenum rate_control_capabilities {\n\t/**\n\t * @RATE_CTRL_CAPA_VHT_EXT_NSS_BW:\n\t * Support for extended NSS BW support (dot11VHTExtendedNSSCapable)\n\t * Note that this is only looked at if the minimum number of chains\n\t * that the AP uses is < the number of TX chains the hardware has,\n\t * otherwise the NSS difference doesn't bother us.\n\t */\n\tRATE_CTRL_CAPA_VHT_EXT_NSS_BW = BIT(0),\n};\n\nstruct rate_control_ops {\n\tunsigned long capa;\n\tconst char *name;\n\tvoid *(*alloc)(struct ieee80211_hw *hw);\n\tvoid (*add_debugfs)(struct ieee80211_hw *hw, void *priv,\n\t\t\t    struct dentry *debugfsdir);\n\tvoid (*free)(void *priv);\n\n\tvoid *(*alloc_sta)(void *priv, struct ieee80211_sta *sta, gfp_t gfp);\n\tvoid (*rate_init)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t  struct cfg80211_chan_def *chandef,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta);\n\tvoid (*rate_update)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t    struct cfg80211_chan_def *chandef,\n\t\t\t    struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t    u32 changed);\n\tvoid (*free_sta)(void *priv, struct ieee80211_sta *sta,\n\t\t\t void *priv_sta);\n\n\tvoid (*tx_status_ext)(void *priv,\n\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t      void *priv_sta, struct ieee80211_tx_status *st);\n\tvoid (*tx_status)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t  struct sk_buff *skb);\n\tvoid (*get_rate)(void *priv, struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t struct ieee80211_tx_rate_control *txrc);\n\n\tvoid (*add_sta_debugfs)(void *priv, void *priv_sta,\n\t\t\t\tstruct dentry *dir);\n\n\tu32 (*get_expected_throughput)(void *priv_sta);\n};\n\nstatic inline int rate_supported(struct ieee80211_sta *sta,\n\t\t\t\t enum nl80211_band band,\n\t\t\t\t int index)\n{\n\treturn (sta == NULL || sta->supp_rates[band] & BIT(index));\n}\n\nstatic inline s8\nrate_lowest_index(struct ieee80211_supported_band *sband,\n\t\t  struct ieee80211_sta *sta)\n{\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (rate_supported(sta, sband->band, i))\n\t\t\treturn i;\n\n\t/* warn when we cannot find a rate. */\n\tWARN_ON_ONCE(1);\n\n\t/* and return 0 (the lowest index) */\n\treturn 0;\n}\n\nstatic inline\nbool rate_usable_index_exists(struct ieee80211_supported_band *sband,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (rate_supported(sta, sband->band, i))\n\t\t\treturn true;\n\treturn false;\n}\n\n/**\n * rate_control_set_rates - pass the sta rate selection to mac80211/driver\n *\n * When not doing a rate control probe to test rates, rate control should pass\n * its rate selection to mac80211. If the driver supports receiving a station\n * rate table, it will use it to ensure that frames are always sent based on\n * the most recent rate control module decision.\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @pubsta: &struct ieee80211_sta pointer to the target destination.\n * @rates: new tx rate set to be used for this station.\n */\nint rate_control_set_rates(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_sta *pubsta,\n\t\t\t   struct ieee80211_sta_rates *rates);\n\nint ieee80211_rate_control_register(const struct rate_control_ops *ops);\nvoid ieee80211_rate_control_unregister(const struct rate_control_ops *ops);\n\nstatic inline bool\nconf_is_ht20(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_20;\n}\n\nstatic inline bool\nconf_is_ht40_minus(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40 &&\n\t       conf->chandef.center_freq1 < conf->chandef.chan->center_freq;\n}\n\nstatic inline bool\nconf_is_ht40_plus(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40 &&\n\t       conf->chandef.center_freq1 > conf->chandef.chan->center_freq;\n}\n\nstatic inline bool\nconf_is_ht40(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40;\n}\n\nstatic inline bool\nconf_is_ht(struct ieee80211_conf *conf)\n{\n\treturn (conf->chandef.width != NL80211_CHAN_WIDTH_5) &&\n\t\t(conf->chandef.width != NL80211_CHAN_WIDTH_10) &&\n\t\t(conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT);\n}\n\nstatic inline enum nl80211_iftype\nieee80211_iftype_p2p(enum nl80211_iftype type, bool p2p)\n{\n\tif (p2p) {\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn NL80211_IFTYPE_P2P_CLIENT;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn NL80211_IFTYPE_P2P_GO;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn type;\n}\n\nstatic inline enum nl80211_iftype\nieee80211_vif_type_p2p(struct ieee80211_vif *vif)\n{\n\treturn ieee80211_iftype_p2p(vif->type, vif->p2p);\n}\n\n/**\n * ieee80211_update_mu_groups - set the VHT MU-MIMO groud data\n *\n * @vif: the specified virtual interface\n * @membership: 64 bits array - a bit is set if station is member of the group\n * @position: 2 bits per group id indicating the position in the group\n *\n * Note: This function assumes that the given vif is valid and the position and\n * membership data is of the correct size and are in the same byte order as the\n * matching GroupId management frame.\n * Calls to this function need to be serialized with RX path.\n */\nvoid ieee80211_update_mu_groups(struct ieee80211_vif *vif,\n\t\t\t\tconst u8 *membership, const u8 *position);\n\nvoid ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,\n\t\t\t\t   int rssi_min_thold,\n\t\t\t\t   int rssi_max_thold);\n\nvoid ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_ave_rssi - report the average RSSI for the specified interface\n *\n * @vif: the specified virtual interface\n *\n * Note: This function assumes that the given vif is valid.\n *\n * Return: The average RSSI value for the requested interface, or 0 if not\n * applicable.\n */\nint ieee80211_ave_rssi(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_report_wowlan_wakeup - report WoWLAN wakeup\n * @vif: virtual interface\n * @wakeup: wakeup reason(s)\n * @gfp: allocation flags\n *\n * See cfg80211_report_wowlan_wakeup().\n */\nvoid ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,\n\t\t\t\t    struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t    gfp_t gfp);\n\n/**\n * ieee80211_tx_prepare_skb - prepare an 802.11 skb for transmission\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @vif: virtual interface\n * @skb: frame to be sent from within the driver\n * @band: the band to transmit on\n * @sta: optional pointer to get the station to send the frame to\n *\n * Note: must be called under RCU lock\n */\nbool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, struct sk_buff *skb,\n\t\t\t      int band, struct ieee80211_sta **sta);\n\n/**\n * ieee80211_parse_tx_radiotap - Sanity-check and parse the radiotap header\n *\t\t\t\t of injected frames\n * @skb: packet injected by userspace\n * @dev: the &struct device of this 802.11 device\n */\nbool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev);\n\n/**\n * struct ieee80211_noa_data - holds temporary data for tracking P2P NoA state\n *\n * @next_tsf: TSF timestamp of the next absent state change\n * @has_next_tsf: next absent state change event pending\n *\n * @absent: descriptor bitmask, set if GO is currently absent\n *\n * private:\n *\n * @count: count fields from the NoA descriptors\n * @desc: adjusted data from the NoA\n */\nstruct ieee80211_noa_data {\n\tu32 next_tsf;\n\tbool has_next_tsf;\n\n\tu8 absent;\n\n\tu8 count[IEEE80211_P2P_NOA_DESC_MAX];\n\tstruct {\n\t\tu32 start;\n\t\tu32 duration;\n\t\tu32 interval;\n\t} desc[IEEE80211_P2P_NOA_DESC_MAX];\n};\n\n/**\n * ieee80211_parse_p2p_noa - initialize NoA tracking data from P2P IE\n *\n * @attr: P2P NoA IE\n * @data: NoA tracking data\n * @tsf: current TSF timestamp\n *\n * Return: number of successfully parsed descriptors\n */\nint ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,\n\t\t\t    struct ieee80211_noa_data *data, u32 tsf);\n\n/**\n * ieee80211_update_p2p_noa - get next pending P2P GO absent state change\n *\n * @data: NoA tracking data\n * @tsf: current TSF timestamp\n */\nvoid ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);\n\n/**\n * ieee80211_tdls_oper_request - request userspace to perform a TDLS operation\n * @vif: virtual interface\n * @peer: the peer's destination address\n * @oper: the requested TDLS operation\n * @reason_code: reason code for the operation, valid for TDLS teardown\n * @gfp: allocation flags\n *\n * See cfg80211_tdls_oper_request().\n */\nvoid ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,\n\t\t\t\t enum nl80211_tdls_operation oper,\n\t\t\t\t u16 reason_code, gfp_t gfp);\n\n/**\n * ieee80211_reserve_tid - request to reserve a specific TID\n *\n * There is sometimes a need (such as in TDLS) for blocking the driver from\n * using a specific TID so that the FW can use it for certain operations such\n * as sending PTI requests. To make sure that the driver doesn't use that TID,\n * this function must be called as it flushes out packets on this TID and marks\n * it as blocked, so that any transmit for the station on this TID will be\n * redirected to the alternative TID in the same AC.\n *\n * Note that this function blocks and may call back into the driver, so it\n * should be called without driver locks held. Also note this function should\n * only be called from the driver's @sta_state callback.\n *\n * @sta: the station to reserve the TID for\n * @tid: the TID to reserve\n *\n * Returns: 0 on success, else on failure\n */\nint ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);\n\n/**\n * ieee80211_unreserve_tid - request to unreserve a specific TID\n *\n * Once there is no longer any need for reserving a certain TID, this function\n * should be called, and no longer will packets have their TID modified for\n * preventing use of this TID in the driver.\n *\n * Note that this function blocks and acquires a lock, so it should be called\n * without driver locks held. Also note this function should only be called\n * from the driver's @sta_state callback.\n *\n * @sta: the station\n * @tid: the TID to unreserve\n */\nvoid ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);\n\n/**\n * ieee80211_tx_dequeue - dequeue a packet from a software tx queue\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface, or from\n *\tieee80211_next_txq()\n *\n * Returns the skb if successful, %NULL if no frame was available.\n *\n * Note that this must be called in an rcu_read_lock() critical section,\n * which can only be released after the SKB was handled. Some pointers in\n * skb->cb, e.g. the key pointer, are protected by RCU and thus the\n * critical section must persist not just for the duration of this call\n * but for the duration of the frame handling.\n * However, also note that while in the wake_tx_queue() method,\n * rcu_read_lock() is already held.\n *\n * softirqs must also be disabled when this function is called.\n * In process context, use ieee80211_tx_dequeue_ni() instead.\n */\nstruct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_txq *txq);\n\n/**\n * ieee80211_tx_dequeue_ni - dequeue a packet from a software tx queue\n * (in process context)\n *\n * Like ieee80211_tx_dequeue() but can be called in process context\n * (internally disables bottom halves).\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface, or from\n *\tieee80211_next_txq()\n */\nstatic inline struct sk_buff *ieee80211_tx_dequeue_ni(struct ieee80211_hw *hw,\n\t\t\t\t\t\t      struct ieee80211_txq *txq)\n{\n\tstruct sk_buff *skb;\n\n\tlocal_bh_disable();\n\tskb = ieee80211_tx_dequeue(hw, txq);\n\tlocal_bh_enable();\n\n\treturn skb;\n}\n\n/**\n * ieee80211_next_txq - get next tx queue to pull packets from\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @ac: AC number to return packets from.\n *\n * Returns the next txq if successful, %NULL if no queue is eligible. If a txq\n * is returned, it should be returned with ieee80211_return_txq() after the\n * driver has finished scheduling it.\n */\nstruct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac);\n\n/**\n * ieee80211_txq_schedule_start - start new scheduling round for TXQs\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @ac: AC number to acquire locks for\n *\n * Should be called before ieee80211_next_txq() or ieee80211_return_txq().\n * The driver must not call multiple TXQ scheduling rounds concurrently.\n */\nvoid ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac);\n\n/* (deprecated) */\nstatic inline void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)\n{\n}\n\nvoid __ieee80211_schedule_txq(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq, bool force);\n\n/**\n * ieee80211_schedule_txq - schedule a TXQ for transmission\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n *\n * Schedules a TXQ for transmission if it is not already scheduled,\n * even if mac80211 does not have any packets buffered.\n *\n * The driver may call this function if it has buffered packets for\n * this TXQ internally.\n */\nstatic inline void\nieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)\n{\n\t__ieee80211_schedule_txq(hw, txq, true);\n}\n\n/**\n * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n * @force: schedule txq even if mac80211 does not have any buffered packets.\n *\n * The driver may set force=true if it has buffered packets for this TXQ\n * internally.\n */\nstatic inline void\nieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,\n\t\t     bool force)\n{\n\t__ieee80211_schedule_txq(hw, txq, force);\n}\n\n/**\n * ieee80211_txq_may_transmit - check whether TXQ is allowed to transmit\n *\n * This function is used to check whether given txq is allowed to transmit by\n * the airtime scheduler, and can be used by drivers to access the airtime\n * fairness accounting without going using the scheduling order enfored by\n * next_txq().\n *\n * Returns %true if the airtime scheduler thinks the TXQ should be allowed to\n * transmit, and %false if it should be throttled. This function can also have\n * the side effect of rotating the TXQ in the scheduler rotation, which will\n * eventually bring the deficit to positive and allow the station to transmit\n * again.\n *\n * The API ieee80211_txq_may_transmit() also ensures that TXQ list will be\n * aligned against driver's own round-robin scheduler list. i.e it rotates\n * the TXQ list till it makes the requested node becomes the first entry\n * in TXQ list. Thus both the TXQ list and driver's list are in sync. If this\n * function returns %true, the driver is expected to schedule packets\n * for transmission, and then return the TXQ through ieee80211_return_txq().\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n */\nbool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_txq *txq);\n\n/**\n * ieee80211_txq_get_depth - get pending frame/byte count of given txq\n *\n * The values are not guaranteed to be coherent with regard to each other, i.e.\n * txq state can change half-way of this function and the caller may end up\n * with \"new\" frame_cnt and \"old\" byte_cnt or vice-versa.\n *\n * @txq: pointer obtained from station or virtual interface\n * @frame_cnt: pointer to store frame count\n * @byte_cnt: pointer to store byte count\n */\nvoid ieee80211_txq_get_depth(struct ieee80211_txq *txq,\n\t\t\t     unsigned long *frame_cnt,\n\t\t\t     unsigned long *byte_cnt);\n\n/**\n * ieee80211_nan_func_terminated - notify about NAN function termination.\n *\n * This function is used to notify mac80211 about NAN function termination.\n * Note that this function can't be called from hard irq.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @inst_id: the local instance id\n * @reason: termination reason (one of the NL80211_NAN_FUNC_TERM_REASON_*)\n * @gfp: allocation flags\n */\nvoid ieee80211_nan_func_terminated(struct ieee80211_vif *vif,\n\t\t\t\t   u8 inst_id,\n\t\t\t\t   enum nl80211_nan_func_term_reason reason,\n\t\t\t\t   gfp_t gfp);\n\n/**\n * ieee80211_nan_func_match - notify about NAN function match event.\n *\n * This function is used to notify mac80211 about NAN function match. The\n * cookie inside the match struct will be assigned by mac80211.\n * Note that this function can't be called from hard irq.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @match: match event information\n * @gfp: allocation flags\n */\nvoid ieee80211_nan_func_match(struct ieee80211_vif *vif,\n\t\t\t      struct cfg80211_nan_match_params *match,\n\t\t\t      gfp_t gfp);\n\n/**\n * ieee80211_calc_rx_airtime - calculate estimated transmission airtime for RX.\n *\n * This function calculates the estimated airtime usage of a frame based on the\n * rate information in the RX status struct and the frame length.\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @status: &struct ieee80211_rx_status containing the transmission rate\n *          information.\n * @len: frame length in bytes\n */\nu32 ieee80211_calc_rx_airtime(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_rx_status *status,\n\t\t\t      int len);\n\n/**\n * ieee80211_calc_tx_airtime - calculate estimated transmission airtime for TX.\n *\n * This function calculates the estimated airtime usage of a frame based on the\n * rate information in the TX info struct and the frame length.\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @info: &struct ieee80211_tx_info of the frame.\n * @len: frame length in bytes\n */\nu32 ieee80211_calc_tx_airtime(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_info *info,\n\t\t\t      int len);\n/**\n * ieee80211_set_hw_80211_encap - enable hardware encapsulation offloading.\n *\n * This function is used to notify mac80211 that a vif can be passed raw 802.3\n * frames. The driver needs to then handle the 802.11 encapsulation inside the\n * hardware or firmware.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @enable: indicate if the feature should be turned on or off\n */\nbool ieee80211_set_hw_80211_encap(struct ieee80211_vif *vif, bool enable);\n\n/**\n * ieee80211_get_fils_discovery_tmpl - Get FILS discovery template.\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: FILS discovery template. %NULL on error.\n */\nstruct sk_buff *ieee80211_get_fils_discovery_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct ieee80211_vif *vif);\n\n/**\n * ieee80211_get_unsol_bcast_probe_resp_tmpl - Get unsolicited broadcast\n *\tprobe response template.\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: Unsolicited broadcast probe response template. %NULL on error.\n */\nstruct sk_buff *\nieee80211_get_unsol_bcast_probe_resp_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif);\n#endif /* MAC80211_H */\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2005-2006, Devicescape Software, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n * Copyright 2007\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright (C) 2018-2021 Intel Corporation\n *\n * Transmit and frame generation functions.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/if_vlan.h>\n#include <linux/etherdevice.h>\n#include <linux/bitmap.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <net/net_namespace.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <net/codel.h>\n#include <net/codel_impl.h>\n#include <asm/unaligned.h>\n#include <net/fq_impl.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"led.h\"\n#include \"mesh.h\"\n#include \"wep.h\"\n#include \"wpa.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n/* misc utils */\n\nstatic __le16 ieee80211_duration(struct ieee80211_tx_data *tx,\n\t\t\t\t struct sk_buff *skb, int group_addr,\n\t\t\t\t int next_frag_len)\n{\n\tint rate, mrate, erp, dur, i, shift = 0;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tu32 rate_flags = 0;\n\n\t/* assume HW handles this */\n\tif (tx->rate.flags & (IEEE80211_TX_RC_MCS | IEEE80211_TX_RC_VHT_MCS))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(tx->sdata->vif.chanctx_conf);\n\tif (chanctx_conf) {\n\t\tshift = ieee80211_chandef_get_shift(&chanctx_conf->def);\n\t\trate_flags = ieee80211_chandef_rate_flags(&chanctx_conf->def);\n\t}\n\trcu_read_unlock();\n\n\t/* uh huh? */\n\tif (WARN_ON_ONCE(tx->rate.idx < 0))\n\t\treturn 0;\n\n\tsband = local->hw.wiphy->bands[info->band];\n\ttxrate = &sband->bitrates[tx->rate.idx];\n\n\terp = txrate->flags & IEEE80211_RATE_ERP_G;\n\n\t/* device is expected to do this */\n\tif (sband->band == NL80211_BAND_S1GHZ)\n\t\treturn 0;\n\n\t/*\n\t * data and mgmt (except PS Poll):\n\t * - during CFP: 32768\n\t * - during contention period:\n\t *   if addr1 is group address: 0\n\t *   if more fragments = 0 and addr1 is individual address: time to\n\t *      transmit one ACK plus SIFS\n\t *   if more fragments = 1 and addr1 is individual address: time to\n\t *      transmit next fragment plus 2 x ACK plus 3 x SIFS\n\t *\n\t * IEEE 802.11, 9.6:\n\t * - control response frame (CTS or ACK) shall be transmitted using the\n\t *   same rate as the immediately previous frame in the frame exchange\n\t *   sequence, if this rate belongs to the PHY mandatory rates, or else\n\t *   at the highest possible rate belonging to the PHY rates in the\n\t *   BSSBasicRateSet\n\t */\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tif (ieee80211_is_ctl(hdr->frame_control)) {\n\t\t/* TODO: These control frames are not currently sent by\n\t\t * mac80211, but should they be implemented, this function\n\t\t * needs to be updated to support duration field calculation.\n\t\t *\n\t\t * RTS: time needed to transmit pending data/mgmt frame plus\n\t\t *    one CTS frame plus one ACK frame plus 3 x SIFS\n\t\t * CTS: duration of immediately previous RTS minus time\n\t\t *    required to transmit CTS and its SIFS\n\t\t * ACK: 0 if immediately previous directed data/mgmt had\n\t\t *    more=0, with more=1 duration in ACK frame is duration\n\t\t *    from previous frame minus time needed to transmit ACK\n\t\t *    and its SIFS\n\t\t * PS Poll: BIT(15) | BIT(14) | aid\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/* data/mgmt */\n\tif (0 /* FIX: data/mgmt during CFP */)\n\t\treturn cpu_to_le16(32768);\n\n\tif (group_addr) /* Group address as the destination - no ACK */\n\t\treturn 0;\n\n\t/* Individual destination address:\n\t * IEEE 802.11, Ch. 9.6 (after IEEE 802.11g changes)\n\t * CTS and ACK frames shall be transmitted using the highest rate in\n\t * basic rate set that is less than or equal to the rate of the\n\t * immediately previous frame and that is using the same modulation\n\t * (CCK or OFDM). If no basic rate set matches with these requirements,\n\t * the highest mandatory rate of the PHY that is less than or equal to\n\t * the rate of the previous frame is used.\n\t * Mandatory rates for IEEE 802.11g PHY: 1, 2, 5.5, 11, 6, 12, 24 Mbps\n\t */\n\trate = -1;\n\t/* use lowest available if everything fails */\n\tmrate = sband->bitrates[0].bitrate;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tstruct ieee80211_rate *r = &sband->bitrates[i];\n\n\t\tif (r->bitrate > txrate->bitrate)\n\t\t\tbreak;\n\n\t\tif ((rate_flags & r->flags) != rate_flags)\n\t\t\tcontinue;\n\n\t\tif (tx->sdata->vif.bss_conf.basic_rates & BIT(i))\n\t\t\trate = DIV_ROUND_UP(r->bitrate, 1 << shift);\n\n\t\tswitch (sband->band) {\n\t\tcase NL80211_BAND_2GHZ: {\n\t\t\tu32 flag;\n\t\t\tif (tx->sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_G;\n\t\t\telse\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_B;\n\t\t\tif (r->flags & flag)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\t}\n\t\tcase NL80211_BAND_5GHZ:\n\t\tcase NL80211_BAND_6GHZ:\n\t\t\tif (r->flags & IEEE80211_RATE_MANDATORY_A)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_S1GHZ:\n\t\tcase NL80211_BAND_60GHZ:\n\t\t\t/* TODO, for now fall through */\n\t\tcase NUM_NL80211_BANDS:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rate == -1) {\n\t\t/* No matching basic rate found; use highest suitable mandatory\n\t\t * PHY rate */\n\t\trate = DIV_ROUND_UP(mrate, 1 << shift);\n\t}\n\n\t/* Don't calculate ACKs for QoS Frames with NoAck Policy set */\n\tif (ieee80211_is_data_qos(hdr->frame_control) &&\n\t    *(ieee80211_get_qos_ctl(hdr)) & IEEE80211_QOS_CTL_ACK_POLICY_NOACK)\n\t\tdur = 0;\n\telse\n\t\t/* Time needed to transmit ACK\n\t\t * (10 bytes + 4-byte FCS = 112 bits) plus SIFS; rounded up\n\t\t * to closest integer */\n\t\tdur = ieee80211_frame_duration(sband->band, 10, rate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\n\tif (next_frag_len) {\n\t\t/* Frame is fragmented: duration increases with time needed to\n\t\t * transmit next fragment plus ACK and 2 x SIFS. */\n\t\tdur *= 2; /* ACK + SIFS */\n\t\t/* next fragment */\n\t\tdur += ieee80211_frame_duration(sband->band, next_frag_len,\n\t\t\t\ttxrate->bitrate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\t}\n\n\treturn cpu_to_le16(dur);\n}\n\n/* tx handlers */\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_dynamic_ps(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\n\t/* driver doesn't support power save */\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_PS))\n\t\treturn TX_CONTINUE;\n\n\t/* hardware does dynamic power save */\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS))\n\t\treturn TX_CONTINUE;\n\n\t/* dynamic power save disabled */\n\tif (local->hw.conf.dynamic_ps_timeout <= 0)\n\t\treturn TX_CONTINUE;\n\n\t/* we are scanning, don't enable power save */\n\tif (local->scanning)\n\t\treturn TX_CONTINUE;\n\n\tif (!local->ps_sdata)\n\t\treturn TX_CONTINUE;\n\n\t/* No point if we're going to suspend */\n\tif (local->quiescing)\n\t\treturn TX_CONTINUE;\n\n\t/* dynamic ps is supported only in managed mode */\n\tif (tx->sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_OFFCHAN_TX_OK))\n\t\treturn TX_CONTINUE;\n\n\tifmgd = &tx->sdata->u.mgd;\n\n\t/*\n\t * Don't wakeup from power save if u-apsd is enabled, voip ac has\n\t * u-apsd enabled and the frame is in voip class. This effectively\n\t * means that even if all access categories have u-apsd enabled, in\n\t * practise u-apsd is only used with the voip ac. This is a\n\t * workaround for the case when received voip class packets do not\n\t * have correct qos tag for some reason, due the network or the\n\t * peer application.\n\t *\n\t * Note: ifmgd->uapsd_queues access is racy here. If the value is\n\t * changed via debugfs, user needs to reassociate manually to have\n\t * everything in sync.\n\t */\n\tif ((ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED) &&\n\t    (ifmgd->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO) &&\n\t    skb_get_queue_mapping(tx->skb) == IEEE80211_AC_VO)\n\t\treturn TX_CONTINUE;\n\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tieee80211_stop_queues_by_reason(&local->hw,\n\t\t\t\t\t\tIEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_PS,\n\t\t\t\t\t\tfalse);\n\t\tifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;\n\t\tieee80211_queue_work(&local->hw,\n\t\t\t\t     &local->dynamic_ps_disable_work);\n\t}\n\n\t/* Don't restart the timer if we're not disassociated */\n\tif (!ifmgd->associated)\n\t\treturn TX_CONTINUE;\n\n\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)\n{\n\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tbool assoc = false;\n\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &tx->local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &tx->sdata->state) &&\n\t    !ieee80211_is_probe_req(hdr->frame_control) &&\n\t    !ieee80211_is_any_nullfunc(hdr->frame_control))\n\t\t/*\n\t\t * When software scanning only nullfunc frames (to notify\n\t\t * the sleep state to the AP) and probe requests (for the\n\t\t * active scan) are allowed, all other frames should not be\n\t\t * sent and we should not get here, but if we do\n\t\t * nonetheless, drop them to avoid sending them\n\t\t * off-channel. See the link below and\n\t\t * ieee80211_start_scan() for more.\n\t\t *\n\t\t * http://article.gmane.org/gmane.linux.kernel.wireless.general/30089\n\t\t */\n\t\treturn TX_DROP;\n\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_OCB)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->flags & IEEE80211_TX_PS_BUFFERED)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\tif (likely(tx->flags & IEEE80211_TX_UNICAST)) {\n\t\tif (unlikely(!assoc &&\n\t\t\t     ieee80211_is_data(hdr->frame_control))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tsdata_info(tx->sdata,\n\t\t\t\t   \"dropped data frame to not associated station %pM\\n\",\n\t\t\t\t   hdr->addr1);\n#endif\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else if (unlikely(ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    ieee80211_vif_get_num_mcast_if(tx->sdata) == 0)) {\n\t\t/*\n\t\t * No associated STAs - no need to send multicast\n\t\t * frames.\n\t\t */\n\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n/* This function is called whenever the AP is about to exceed the maximum limit\n * of buffered frames for power saving STAs. This situation should not really\n * happen often during normal operation, so dropping the oldest buffered packet\n * from each queue should be OK to make some room for new frames. */\nstatic void purge_old_ps_buffers(struct ieee80211_local *local)\n{\n\tint total = 0, purged = 0;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tstruct ps_data *ps;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tps = &sdata->u.ap.ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (skb) {\n\t\t\tpurged++;\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t}\n\t\ttotal += skb_queue_len(&ps->bc_buf);\n\t}\n\n\t/*\n\t * Drop one frame from each station from the lowest-priority\n\t * AC that has frames at all.\n\t */\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tint ac;\n\n\t\tfor (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {\n\t\t\tskb = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\ttotal += skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\t\tif (skb) {\n\t\t\t\tpurged++;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlocal->total_ps_buffered = total;\n\tps_dbg_hw(&local->hw, \"PS buffers full - purged %d frames\\n\", purged);\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ps_data *ps;\n\n\t/*\n\t * broadcast/multicast frame\n\t *\n\t * If any of the associated/peer stations is in power save mode,\n\t * the frame is buffered to be sent after DTIM beacon frame.\n\t * This is done either by the hardware or us.\n\t */\n\n\t/* powersaving STAs currently only in AP/VLAN/mesh mode */\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    tx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!tx->sdata->bss)\n\t\t\treturn TX_CONTINUE;\n\n\t\tps = &tx->sdata->bss->ps;\n\t} else if (ieee80211_vif_is_mesh(&tx->sdata->vif)) {\n\t\tps = &tx->sdata->u.mesh.ps;\n\t} else {\n\t\treturn TX_CONTINUE;\n\t}\n\n\n\t/* no buffering for ordered frames */\n\tif (ieee80211_has_order(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_is_probe_req(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hw_check(&tx->local->hw, QUEUE_CONTROL))\n\t\tinfo->hw_queue = tx->sdata->vif.cab_queue;\n\n\t/* no stations in PS mode and no buffered packets */\n\tif (!atomic_read(&ps->num_sta_ps) && skb_queue_empty(&ps->bc_buf))\n\t\treturn TX_CONTINUE;\n\n\tinfo->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;\n\n\t/* device releases frame after DTIM beacon */\n\tif (!ieee80211_hw_check(&tx->local->hw, HOST_BROADCAST_PS_BUFFERING))\n\t\treturn TX_CONTINUE;\n\n\t/* buffered in mac80211 */\n\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\tpurge_old_ps_buffers(tx->local);\n\n\tif (skb_queue_len(&ps->bc_buf) >= AP_MAX_BC_BUFFER) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"BC TX buffer full - dropping the oldest frame\\n\");\n\t\tieee80211_free_txskb(&tx->local->hw, skb_dequeue(&ps->bc_buf));\n\t} else\n\t\ttx->local->total_ps_buffered++;\n\n\tskb_queue_tail(&ps->bc_buf, tx->skb);\n\n\treturn TX_QUEUED;\n}\n\nstatic int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,\n\t\t\t     struct sk_buff *skb)\n{\n\tif (!ieee80211_is_mgmt(fc))\n\t\treturn 0;\n\n\tif (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))\n\t\treturn 0;\n\n\tif (!ieee80211_is_robust_mgmt_frame(skb))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct sta_info *sta = tx->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_local *local = tx->local;\n\n\tif (unlikely(!sta))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DRIVER) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DELIVER)) &&\n\t\t     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {\n\t\tint ac = skb_get_queue_mapping(tx->skb);\n\n\t\tif (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t    !ieee80211_is_bufferable_mmpdu(hdr->frame_control)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;\n\t\t\treturn TX_CONTINUE;\n\t\t}\n\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d: PS buffer for AC %d\\n\",\n\t\t       sta->sta.addr, sta->sta.aid, ac);\n\t\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\t\tpurge_old_ps_buffers(tx->local);\n\n\t\t/* sync with ieee80211_sta_ps_deliver_wakeup */\n\t\tspin_lock(&sta->ps_lock);\n\t\t/*\n\t\t * STA woke up the meantime and all the frames on ps_tx_buf have\n\t\t * been queued to pending queue. No reordering can happen, go\n\t\t * ahead and Tx the packet.\n\t\t */\n\t\tif (!test_sta_flag(sta, WLAN_STA_PS_STA) &&\n\t\t    !test_sta_flag(sta, WLAN_STA_PS_DRIVER) &&\n\t\t    !test_sta_flag(sta, WLAN_STA_PS_DELIVER)) {\n\t\t\tspin_unlock(&sta->ps_lock);\n\t\t\treturn TX_CONTINUE;\n\t\t}\n\n\t\tif (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {\n\t\t\tstruct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\tps_dbg(tx->sdata,\n\t\t\t       \"STA %pM TX buffer for AC %d full - dropping oldest frame\\n\",\n\t\t\t       sta->sta.addr, ac);\n\t\t\tieee80211_free_txskb(&local->hw, old);\n\t\t} else\n\t\t\ttx->local->total_ps_buffered++;\n\n\t\tinfo->control.jiffies = jiffies;\n\t\tinfo->control.vif = &tx->sdata->vif;\n\t\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\tskb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);\n\t\tspin_unlock(&sta->ps_lock);\n\n\t\tif (!timer_pending(&local->sta_cleanup))\n\t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\n\t\t/*\n\t\t * We queued up some frames, so the TIM bit might\n\t\t * need to be set, recalculate it.\n\t\t */\n\t\tsta_info_recalc_tim(sta);\n\n\t\treturn TX_QUEUED;\n\t} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"STA %pM in PS mode, but polling/in SP -> send frame\\n\",\n\t\t       sta->sta.addr);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tif (unlikely(tx->flags & IEEE80211_TX_PS_BUFFERED))\n\t\treturn TX_CONTINUE;\n\n\tif (tx->flags & IEEE80211_TX_UNICAST)\n\t\treturn ieee80211_tx_h_unicast_ps_buf(tx);\n\telse\n\t\treturn ieee80211_tx_h_multicast_ps_buf(tx);\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_control_port_protocol(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\n\tif (unlikely(tx->sdata->control_port_protocol == tx->skb->protocol)) {\n\t\tif (tx->sdata->control_port_no_encrypt)\n\t\t\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_PORT_CTRL_PROTO;\n\t\tinfo->flags |= IEEE80211_TX_CTL_USE_MINRATE;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_select_key(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)) {\n\t\ttx->key = NULL;\n\t\treturn TX_CONTINUE;\n\t}\n\n\tif (tx->sta &&\n\t    (key = rcu_dereference(tx->sta->ptk[tx->sta->ptk_idx])))\n\t\ttx->key = key;\n\telse if (ieee80211_is_group_privacy_action(tx->skb) &&\n\t\t(key = rcu_dereference(tx->sdata->default_multicast_key)))\n\t\ttx->key = key;\n\telse if (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t is_multicast_ether_addr(hdr->addr1) &&\n\t\t ieee80211_is_robust_mgmt_frame(tx->skb) &&\n\t\t (key = rcu_dereference(tx->sdata->default_mgmt_key)))\n\t\ttx->key = key;\n\telse if (is_multicast_ether_addr(hdr->addr1) &&\n\t\t (key = rcu_dereference(tx->sdata->default_multicast_key)))\n\t\ttx->key = key;\n\telse if (!is_multicast_ether_addr(hdr->addr1) &&\n\t\t (key = rcu_dereference(tx->sdata->default_unicast_key)))\n\t\ttx->key = key;\n\telse\n\t\ttx->key = NULL;\n\n\tif (tx->key) {\n\t\tbool skip_hw = false;\n\n\t\t/* TODO: add threshold stuff again */\n\n\t\tswitch (tx->key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control) &&\n\t\t\t    !ieee80211_use_mfp(hdr->frame_control, tx->sta,\n\t\t\t\t\t       tx->skb) &&\n\t\t\t    !ieee80211_is_group_privacy_action(tx->skb))\n\t\t\t\ttx->key = NULL;\n\t\t\telse\n\t\t\t\tskip_hw = (tx->key->conf.flags &\n\t\t\t\t\t   IEEE80211_KEY_FLAG_SW_MGMT_TX) &&\n\t\t\t\t\tieee80211_is_mgmt(hdr->frame_control);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(tx->key && tx->key->flags & KEY_FLAG_TAINTED &&\n\t\t\t     !ieee80211_is_deauth(hdr->frame_control)))\n\t\t\treturn TX_DROP;\n\n\t\tif (!skip_hw && tx->key &&\n\t\t    tx->key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)\n\t\t\tinfo->control.hw_key = &tx->key->conf;\n\t} else if (ieee80211_is_data_present(hdr->frame_control) && tx->sta &&\n\t\t   test_sta_flag(tx->sta, WLAN_STA_USES_ENCRYPTION)) {\n\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_rate_ctrl(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (void *)tx->skb->data;\n\tstruct ieee80211_supported_band *sband;\n\tu32 len;\n\tstruct ieee80211_tx_rate_control txrc;\n\tstruct ieee80211_sta_rates *ratetbl = NULL;\n\tbool assoc = false;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\n\tsband = tx->local->hw.wiphy->bands[info->band];\n\n\tlen = min_t(u32, tx->skb->len + FCS_LEN,\n\t\t\t tx->local->hw.wiphy->frag_threshold);\n\n\t/* set up the tx rate control struct we give the RC algo */\n\ttxrc.hw = &tx->local->hw;\n\ttxrc.sband = sband;\n\ttxrc.bss_conf = &tx->sdata->vif.bss_conf;\n\ttxrc.skb = tx->skb;\n\ttxrc.reported_rate.idx = -1;\n\ttxrc.rate_idx_mask = tx->sdata->rc_rateidx_mask[info->band];\n\n\tif (tx->sdata->rc_has_mcs_mask[info->band])\n\t\ttxrc.rate_idx_mcs_mask =\n\t\t\ttx->sdata->rc_rateidx_mcs_mask[info->band];\n\n\ttxrc.bss = (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_ADHOC ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_OCB);\n\n\t/* set up RTS protection if desired */\n\tif (len > tx->local->hw.wiphy->rts_threshold) {\n\t\ttxrc.rts = true;\n\t}\n\n\tinfo->control.use_rts = txrc.rts;\n\tinfo->control.use_cts_prot = tx->sdata->vif.bss_conf.use_cts_prot;\n\n\t/*\n\t * Use short preamble if the BSS can handle it, but not for\n\t * management frames unless we know the receiver can handle\n\t * that -- the management frame might be to a station that\n\t * just wants a probe response.\n\t */\n\tif (tx->sdata->vif.bss_conf.use_short_preamble &&\n\t    (ieee80211_is_data(hdr->frame_control) ||\n\t     (tx->sta && test_sta_flag(tx->sta, WLAN_STA_SHORT_PREAMBLE))))\n\t\ttxrc.short_preamble = true;\n\n\tinfo->control.short_preamble = txrc.short_preamble;\n\n\t/* don't ask rate control when rate already injected via radiotap */\n\tif (info->control.flags & IEEE80211_TX_CTRL_RATE_INJECT)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\t/*\n\t * Lets not bother rate control if we're associated and cannot\n\t * talk to the sta. This should not happen.\n\t */\n\tif (WARN(test_bit(SCAN_SW_SCANNING, &tx->local->scanning) && assoc &&\n\t\t !rate_usable_index_exists(sband, &tx->sta->sta),\n\t\t \"%s: Dropped data frame as no usable bitrate found while \"\n\t\t \"scanning and associated. Target station: \"\n\t\t \"%pM on %d GHz band\\n\",\n\t\t tx->sdata->name, hdr->addr1,\n\t\t info->band ? 5 : 2))\n\t\treturn TX_DROP;\n\n\t/*\n\t * If we're associated with the sta at this point we know we can at\n\t * least send the frame at the lowest bit rate.\n\t */\n\trate_control_get_rate(tx->sdata, tx->sta, &txrc);\n\n\tif (tx->sta && !info->control.skip_table)\n\t\tratetbl = rcu_dereference(tx->sta->sta.rates);\n\n\tif (unlikely(info->control.rates[0].idx < 0)) {\n\t\tif (ratetbl) {\n\t\t\tstruct ieee80211_tx_rate rate = {\n\t\t\t\t.idx = ratetbl->rate[0].idx,\n\t\t\t\t.flags = ratetbl->rate[0].flags,\n\t\t\t\t.count = ratetbl->rate[0].count\n\t\t\t};\n\n\t\t\tif (ratetbl->rate[0].idx < 0)\n\t\t\t\treturn TX_DROP;\n\n\t\t\ttx->rate = rate;\n\t\t} else {\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else {\n\t\ttx->rate = info->control.rates[0];\n\t}\n\n\tif (txrc.reported_rate.idx < 0) {\n\t\ttxrc.reported_rate = tx->rate;\n\t\tif (tx->sta && ieee80211_is_data(hdr->frame_control))\n\t\t\ttx->sta->tx_stats.last_rate = txrc.reported_rate;\n\t} else if (tx->sta)\n\t\ttx->sta->tx_stats.last_rate = txrc.reported_rate;\n\n\tif (ratetbl)\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(!info->control.rates[0].count))\n\t\tinfo->control.rates[0].count = 1;\n\n\tif (WARN_ON_ONCE((info->control.rates[0].count > 1) &&\n\t\t\t (info->flags & IEEE80211_TX_CTL_NO_ACK)))\n\t\tinfo->control.rates[0].count = 1;\n\n\treturn TX_CONTINUE;\n}\n\nstatic __le16 ieee80211_tx_next_seq(struct sta_info *sta, int tid)\n{\n\tu16 *seq = &sta->tid_seq[tid];\n\t__le16 ret = cpu_to_le16(*seq);\n\n\t/* Increase the sequence number. */\n\t*seq = (*seq + 0x10) & IEEE80211_SCTL_SEQ;\n\n\treturn ret;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_sequence(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tint tid;\n\n\t/*\n\t * Packet injection may want to control the sequence\n\t * number, if we have no matching interface then we\n\t * neither assign one ourselves nor ask the driver to.\n\t */\n\tif (unlikely(info->control.vif->type == NL80211_IFTYPE_MONITOR))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(ieee80211_is_ctl(hdr->frame_control)))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hdrlen(hdr->frame_control) < 24)\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (info->control.flags & IEEE80211_TX_CTRL_NO_SEQNO)\n\t\treturn TX_CONTINUE;\n\n\t/*\n\t * Anything but QoS data that has a sequence number field\n\t * (is long enough) gets a sequence number from the global\n\t * counter.  QoS data frames with a multicast destination\n\t * also use the global counter (802.11-2012 9.3.2.10).\n\t */\n\tif (!ieee80211_is_data_qos(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1)) {\n\t\t/* driver should assign sequence number */\n\t\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\t\t/* for pure STA mode without beacons, we can do it */\n\t\thdr->seq_ctrl = cpu_to_le16(tx->sdata->sequence_number);\n\t\ttx->sdata->sequence_number += 0x10;\n\t\tif (tx->sta)\n\t\t\ttx->sta->tx_stats.msdu[IEEE80211_NUM_TIDS]++;\n\t\treturn TX_CONTINUE;\n\t}\n\n\t/*\n\t * This should be true for injected/management frames only, for\n\t * management frames we have set the IEEE80211_TX_CTL_ASSIGN_SEQ\n\t * above since they are not QoS-data frames.\n\t */\n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\t/* include per-STA, per-TID sequence counter */\n\ttid = ieee80211_get_tid(hdr);\n\ttx->sta->tx_stats.msdu[tid]++;\n\n\thdr->seq_ctrl = ieee80211_tx_next_seq(tx->sta, tid);\n\n\treturn TX_CONTINUE;\n}\n\nstatic int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\n\t/* first fragment was already added to queue by caller */\n\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\n\t\t/* copy control information */\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\n\t\t/* copy header and data */\n\t\tskb_put_data(tmp, skb->data, hdrlen);\n\t\tskb_put_data(tmp, skb->data + pos, fraglen);\n\n\t\tpos += fraglen;\n\t}\n\n\t/* adjust first fragment's length */\n\tskb_trim(skb, hdrlen + per_fragm);\n\treturn 0;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_fragment(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb = tx->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tint frag_threshold = tx->local->hw.wiphy->frag_threshold;\n\tint hdrlen;\n\tint fragnum;\n\n\t/* no matter what happens, tx->skb moves to tx->skbs */\n\t__skb_queue_tail(&tx->skbs, skb);\n\ttx->skb = NULL;\n\n\tif (info->flags & IEEE80211_TX_CTL_DONTFRAG)\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hw_check(&tx->local->hw, SUPPORTS_TX_FRAG))\n\t\treturn TX_CONTINUE;\n\n\t/*\n\t * Warn when submitting a fragmented A-MPDU frame and drop it.\n\t * This scenario is handled in ieee80211_tx_prepare but extra\n\t * caution taken here as fragmented ampdu may cause Tx stop.\n\t */\n\tif (WARN_ON(info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\treturn TX_DROP;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\t/* internal error, why isn't DONTFRAG set? */\n\tif (WARN_ON(skb->len + FCS_LEN <= frag_threshold))\n\t\treturn TX_DROP;\n\n\t/*\n\t * Now fragment the frame. This will allocate all the fragments and\n\t * chain them (using skb as the first fragment) to skb->next.\n\t * During transmission, we will remove the successfully transmitted\n\t * fragments from this list. When the low-level driver rejects one\n\t * of the fragments then we will simply pretend to accept the skb\n\t * but store it away as pending.\n\t */\n\tif (ieee80211_fragment(tx, skb, hdrlen, frag_threshold))\n\t\treturn TX_DROP;\n\n\t/* update duration/seq/flags of fragments */\n\tfragnum = 0;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tconst __le16 morefrags = cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);\n\n\t\thdr = (void *)skb->data;\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\thdr->frame_control |= morefrags;\n\t\t\t/*\n\t\t\t * No multi-rate retries for fragmented frames, that\n\t\t\t * would completely throw off the NAV at other STAs.\n\t\t\t */\n\t\t\tinfo->control.rates[1].idx = -1;\n\t\t\tinfo->control.rates[2].idx = -1;\n\t\t\tinfo->control.rates[3].idx = -1;\n\t\t\tBUILD_BUG_ON(IEEE80211_TX_MAX_RATES != 4);\n\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_RATE_CTRL_PROBE;\n\t\t} else {\n\t\t\thdr->frame_control &= ~morefrags;\n\t\t}\n\t\thdr->seq_ctrl |= cpu_to_le16(fragnum & IEEE80211_SCTL_FRAG);\n\t\tfragnum++;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_stats(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tint ac = -1;\n\n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tac = skb_get_queue_mapping(skb);\n\t\ttx->sta->tx_stats.bytes[ac] += skb->len;\n\t}\n\tif (ac >= 0)\n\t\ttx->sta->tx_stats.packets[ac]++;\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_encrypt(struct ieee80211_tx_data *tx)\n{\n\tif (!tx->key)\n\t\treturn TX_CONTINUE;\n\n\tswitch (tx->key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn ieee80211_crypto_wep_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn ieee80211_crypto_tkip_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn ieee80211_crypto_ccmp_encrypt(\n\t\t\ttx, IEEE80211_CCMP_MIC_LEN);\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\treturn ieee80211_crypto_ccmp_encrypt(\n\t\t\ttx, IEEE80211_CCMP_256_MIC_LEN);\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\treturn ieee80211_crypto_aes_cmac_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\treturn ieee80211_crypto_aes_cmac_256_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\treturn ieee80211_crypto_aes_gmac_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\treturn ieee80211_crypto_gcmp_encrypt(tx);\n\tdefault:\n\t\treturn ieee80211_crypto_hw_encrypt(tx);\n\t}\n\n\treturn TX_DROP;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_calculate_duration(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tint next_len;\n\tbool group_addr;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\thdr = (void *) skb->data;\n\t\tif (unlikely(ieee80211_is_pspoll(hdr->frame_control)))\n\t\t\tbreak; /* must not overwrite AID */\n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\tstruct sk_buff *next = skb_queue_next(&tx->skbs, skb);\n\t\t\tnext_len = next->len;\n\t\t} else\n\t\t\tnext_len = 0;\n\t\tgroup_addr = is_multicast_ether_addr(hdr->addr1);\n\n\t\thdr->duration_id =\n\t\t\tieee80211_duration(tx, skb, group_addr, next_len);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n/* actual transmit path */\n\nstatic bool ieee80211_tx_prep_agg(struct ieee80211_tx_data *tx,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t\t  struct tid_ampdu_tx *tid_tx,\n\t\t\t\t  int tid)\n{\n\tbool queued = false;\n\tbool reset_agg_timer = false;\n\tstruct sk_buff *purge_skb = NULL;\n\n\tif (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\treset_agg_timer = true;\n\t} else if (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {\n\t\t/*\n\t\t * nothing -- this aggregation session is being started\n\t\t * but that might still fail with the driver\n\t\t */\n\t} else if (!tx->sta->sta.txq[tid]) {\n\t\tspin_lock(&tx->sta->lock);\n\t\t/*\n\t\t * Need to re-check now, because we may get here\n\t\t *\n\t\t *  1) in the window during which the setup is actually\n\t\t *     already done, but not marked yet because not all\n\t\t *     packets are spliced over to the driver pending\n\t\t *     queue yet -- if this happened we acquire the lock\n\t\t *     either before or after the splice happens, but\n\t\t *     need to recheck which of these cases happened.\n\t\t *\n\t\t *  2) during session teardown, if the OPERATIONAL bit\n\t\t *     was cleared due to the teardown but the pointer\n\t\t *     hasn't been assigned NULL yet (or we loaded it\n\t\t *     before it was assigned) -- in this case it may\n\t\t *     now be NULL which means we should just let the\n\t\t *     packet pass through because splicing the frames\n\t\t *     back is already done.\n\t\t */\n\t\ttid_tx = rcu_dereference_protected_tid_tx(tx->sta, tid);\n\n\t\tif (!tid_tx) {\n\t\t\t/* do nothing, let packet pass through */\n\t\t} else if (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\t\treset_agg_timer = true;\n\t\t} else {\n\t\t\tqueued = true;\n\t\t\tif (info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER) {\n\t\t\t\tclear_sta_flag(tx->sta, WLAN_STA_SP);\n\t\t\t\tps_dbg(tx->sta->sdata,\n\t\t\t\t       \"STA %pM aid %d: SP frame queued, close the SP w/o telling the peer\\n\",\n\t\t\t\t       tx->sta->sta.addr, tx->sta->sta.aid);\n\t\t\t}\n\t\t\tinfo->control.vif = &tx->sdata->vif;\n\t\t\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\t\t__skb_queue_tail(&tid_tx->pending, skb);\n\t\t\tif (skb_queue_len(&tid_tx->pending) > STA_MAX_TX_BUFFER)\n\t\t\t\tpurge_skb = __skb_dequeue(&tid_tx->pending);\n\t\t}\n\t\tspin_unlock(&tx->sta->lock);\n\n\t\tif (purge_skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, purge_skb);\n\t}\n\n\t/* reset session timer */\n\tif (reset_agg_timer)\n\t\ttid_tx->last_tx = jiffies;\n\n\treturn queued;\n}\n\n/*\n * initialises @tx\n * pass %NULL for the station if unknown, a valid pointer if known\n * or an ERR_PTR() if the station is known not to exist\n */\nstatic ieee80211_tx_result\nieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,\n\t\t     struct ieee80211_tx_data *tx,\n\t\t     struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint tid;\n\n\tmemset(tx, 0, sizeof(*tx));\n\ttx->skb = skb;\n\ttx->local = local;\n\ttx->sdata = sdata;\n\t__skb_queue_head_init(&tx->skbs);\n\n\t/*\n\t * If this flag is set to true anywhere, and we get here,\n\t * we are doing the needed processing, so remove the flag\n\t * now.\n\t */\n\tinfo->control.flags &= ~IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (likely(sta)) {\n\t\tif (!IS_ERR(sta))\n\t\t\ttx->sta = sta;\n\t} else {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\t\ttx->sta = rcu_dereference(sdata->u.vlan.sta);\n\t\t\tif (!tx->sta && sdata->wdev.use_4addr)\n\t\t\t\treturn TX_DROP;\n\t\t} else if (tx->sdata->control_port_protocol == tx->skb->protocol) {\n\t\t\ttx->sta = sta_info_get_bss(sdata, hdr->addr1);\n\t\t}\n\t\tif (!tx->sta && !is_multicast_ether_addr(hdr->addr1))\n\t\t\ttx->sta = sta_info_get(sdata, hdr->addr1);\n\t}\n\n\tif (tx->sta && ieee80211_is_data_qos(hdr->frame_control) &&\n\t    !ieee80211_is_qos_nullfunc(hdr->frame_control) &&\n\t    ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION) &&\n\t    !ieee80211_hw_check(&local->hw, TX_AMPDU_SETUP_IN_HW)) {\n\t\tstruct tid_ampdu_tx *tid_tx;\n\n\t\ttid = ieee80211_get_tid(hdr);\n\n\t\ttid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (tid_tx) {\n\t\t\tbool queued;\n\n\t\t\tqueued = ieee80211_tx_prep_agg(tx, skb, info,\n\t\t\t\t\t\t       tid_tx, tid);\n\n\t\t\tif (unlikely(queued))\n\t\t\t\treturn TX_QUEUED;\n\t\t}\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\ttx->flags &= ~IEEE80211_TX_UNICAST;\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t} else\n\t\ttx->flags |= IEEE80211_TX_UNICAST;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_DONTFRAG)) {\n\t\tif (!(tx->flags & IEEE80211_TX_UNICAST) ||\n\t\t    skb->len + FCS_LEN <= local->hw.wiphy->frag_threshold ||\n\t\t    info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_DONTFRAG;\n\t}\n\n\tif (!tx->sta)\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\telse if (test_and_clear_sta_flag(tx->sta, WLAN_STA_CLEAR_PS_FILT)) {\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\t\tieee80211_check_fast_xmit(tx->sta);\n\t}\n\n\tinfo->flags |= IEEE80211_TX_CTL_FIRST_FRAGMENT;\n\n\treturn TX_CONTINUE;\n}\n\nstatic struct txq_info *ieee80211_get_txq(struct ieee80211_local *local,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct sta_info *sta,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_txq *txq = NULL;\n\n\tif ((info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) ||\n\t    (info->control.flags & IEEE80211_TX_CTRL_PS_RESPONSE))\n\t\treturn NULL;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) &&\n\t    unlikely(!ieee80211_is_data_present(hdr->frame_control))) {\n\t\tif ((!ieee80211_is_mgmt(hdr->frame_control) ||\n\t\t     ieee80211_is_bufferable_mmpdu(hdr->frame_control) ||\n\t\t     vif->type == NL80211_IFTYPE_STATION) &&\n\t\t    sta && sta->uploaded) {\n\t\t\t/*\n\t\t\t * This will be NULL if the driver didn't set the\n\t\t\t * opt-in hardware flag.\n\t\t\t */\n\t\t\ttxq = sta->sta.txq[IEEE80211_NUM_TIDS];\n\t\t}\n\t} else if (sta) {\n\t\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\tif (!sta->uploaded)\n\t\t\treturn NULL;\n\n\t\ttxq = sta->sta.txq[tid];\n\t} else if (vif) {\n\t\ttxq = vif->txq;\n\t}\n\n\tif (!txq)\n\t\treturn NULL;\n\n\treturn to_txq_info(txq);\n}\n\nstatic void ieee80211_set_skb_enqueue_time(struct sk_buff *skb)\n{\n\tIEEE80211_SKB_CB(skb)->control.enqueue_time = codel_get_time();\n}\n\nstatic u32 codel_skb_len_func(const struct sk_buff *skb)\n{\n\treturn skb->len;\n}\n\nstatic codel_time_t codel_skb_time_func(const struct sk_buff *skb)\n{\n\tconst struct ieee80211_tx_info *info;\n\n\tinfo = (const struct ieee80211_tx_info *)skb->cb;\n\treturn info->control.enqueue_time;\n}\n\nstatic struct sk_buff *codel_dequeue_func(struct codel_vars *cvars,\n\t\t\t\t\t  void *ctx)\n{\n\tstruct ieee80211_local *local;\n\tstruct txq_info *txqi;\n\tstruct fq *fq;\n\tstruct fq_flow *flow;\n\n\ttxqi = ctx;\n\tlocal = vif_to_sdata(txqi->txq.vif)->local;\n\tfq = &local->fq;\n\n\tif (cvars == &txqi->def_cvars)\n\t\tflow = &txqi->tin.default_flow;\n\telse\n\t\tflow = &fq->flows[cvars - local->cvars];\n\n\treturn fq_flow_dequeue(fq, flow);\n}\n\nstatic void codel_drop_func(struct sk_buff *skb,\n\t\t\t    void *ctx)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_hw *hw;\n\tstruct txq_info *txqi;\n\n\ttxqi = ctx;\n\tlocal = vif_to_sdata(txqi->txq.vif)->local;\n\thw = &local->hw;\n\n\tieee80211_free_txskb(hw, skb);\n}\n\nstatic struct sk_buff *fq_tin_dequeue_func(struct fq *fq,\n\t\t\t\t\t   struct fq_tin *tin,\n\t\t\t\t\t   struct fq_flow *flow)\n{\n\tstruct ieee80211_local *local;\n\tstruct txq_info *txqi;\n\tstruct codel_vars *cvars;\n\tstruct codel_params *cparams;\n\tstruct codel_stats *cstats;\n\n\tlocal = container_of(fq, struct ieee80211_local, fq);\n\ttxqi = container_of(tin, struct txq_info, tin);\n\tcstats = &txqi->cstats;\n\n\tif (txqi->txq.sta) {\n\t\tstruct sta_info *sta = container_of(txqi->txq.sta,\n\t\t\t\t\t\t    struct sta_info, sta);\n\t\tcparams = &sta->cparams;\n\t} else {\n\t\tcparams = &local->cparams;\n\t}\n\n\tif (flow == &tin->default_flow)\n\t\tcvars = &txqi->def_cvars;\n\telse\n\t\tcvars = &local->cvars[flow - fq->flows];\n\n\treturn codel_dequeue(txqi,\n\t\t\t     &flow->backlog,\n\t\t\t     cparams,\n\t\t\t     cvars,\n\t\t\t     cstats,\n\t\t\t     codel_skb_len_func,\n\t\t\t     codel_skb_time_func,\n\t\t\t     codel_drop_func,\n\t\t\t     codel_dequeue_func);\n}\n\nstatic void fq_skb_free_func(struct fq *fq,\n\t\t\t     struct fq_tin *tin,\n\t\t\t     struct fq_flow *flow,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local;\n\n\tlocal = container_of(fq, struct ieee80211_local, fq);\n\tieee80211_free_txskb(&local->hw, skb);\n}\n\nstatic void ieee80211_txq_enqueue(struct ieee80211_local *local,\n\t\t\t\t  struct txq_info *txqi,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin = &txqi->tin;\n\tu32 flow_idx = fq_flow_idx(fq, skb);\n\n\tieee80211_set_skb_enqueue_time(skb);\n\n\tspin_lock_bh(&fq->lock);\n\t/*\n\t * For management frames, don't really apply codel etc.,\n\t * we don't want to apply any shaping or anything we just\n\t * want to simplify the driver API by having them on the\n\t * txqi.\n\t */\n\tif (unlikely(txqi->txq.tid == IEEE80211_NUM_TIDS)) {\n\t\tIEEE80211_SKB_CB(skb)->control.flags |=\n\t\t\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t\t__skb_queue_tail(&txqi->frags, skb);\n\t} else {\n\t\tfq_tin_enqueue(fq, tin, flow_idx, skb,\n\t\t\t       fq_skb_free_func);\n\t}\n\tspin_unlock_bh(&fq->lock);\n}\n\nstatic bool fq_vlan_filter_func(struct fq *fq, struct fq_tin *tin,\n\t\t\t\tstruct fq_flow *flow, struct sk_buff *skb,\n\t\t\t\tvoid *data)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\treturn info->control.vif == data;\n}\n\nvoid ieee80211_txq_remove_vlan(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata)\n{\n\tstruct fq *fq = &local->fq;\n\tstruct txq_info *txqi;\n\tstruct fq_tin *tin;\n\tstruct ieee80211_sub_if_data *ap;\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_AP_VLAN))\n\t\treturn;\n\n\tap = container_of(sdata->bss, struct ieee80211_sub_if_data, u.ap);\n\n\tif (!ap->vif.txq)\n\t\treturn;\n\n\ttxqi = to_txq_info(ap->vif.txq);\n\ttin = &txqi->tin;\n\n\tspin_lock_bh(&fq->lock);\n\tfq_tin_filter(fq, tin, fq_vlan_filter_func, &sdata->vif,\n\t\t      fq_skb_free_func);\n\tspin_unlock_bh(&fq->lock);\n}\n\nvoid ieee80211_txq_init(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sta_info *sta,\n\t\t\tstruct txq_info *txqi, int tid)\n{\n\tfq_tin_init(&txqi->tin);\n\tcodel_vars_init(&txqi->def_cvars);\n\tcodel_stats_init(&txqi->cstats);\n\t__skb_queue_head_init(&txqi->frags);\n\tINIT_LIST_HEAD(&txqi->schedule_order);\n\n\ttxqi->txq.vif = &sdata->vif;\n\n\tif (!sta) {\n\t\tsdata->vif.txq = &txqi->txq;\n\t\ttxqi->txq.tid = 0;\n\t\ttxqi->txq.ac = IEEE80211_AC_BE;\n\n\t\treturn;\n\t}\n\n\tif (tid == IEEE80211_NUM_TIDS) {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\t\t/* Drivers need to opt in to the management MPDU TXQ */\n\t\t\tif (!ieee80211_hw_check(&sdata->local->hw,\n\t\t\t\t\t\tSTA_MMPDU_TXQ))\n\t\t\t\treturn;\n\t\t} else if (!ieee80211_hw_check(&sdata->local->hw,\n\t\t\t\t\t       BUFF_MMPDU_TXQ)) {\n\t\t\t/* Drivers need to opt in to the bufferable MMPDU TXQ */\n\t\t\treturn;\n\t\t}\n\t\ttxqi->txq.ac = IEEE80211_AC_VO;\n\t} else {\n\t\ttxqi->txq.ac = ieee80211_ac_from_tid(tid);\n\t}\n\n\ttxqi->txq.sta = &sta->sta;\n\ttxqi->txq.tid = tid;\n\tsta->sta.txq[tid] = &txqi->txq;\n}\n\nvoid ieee80211_txq_purge(struct ieee80211_local *local,\n\t\t\t struct txq_info *txqi)\n{\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin = &txqi->tin;\n\n\tspin_lock_bh(&fq->lock);\n\tfq_tin_reset(fq, tin, fq_skb_free_func);\n\tieee80211_purge_tx_queue(&local->hw, &txqi->frags);\n\tspin_unlock_bh(&fq->lock);\n\n\tspin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);\n\tlist_del_init(&txqi->schedule_order);\n\tspin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);\n}\n\nvoid ieee80211_txq_set_params(struct ieee80211_local *local)\n{\n\tif (local->hw.wiphy->txq_limit)\n\t\tlocal->fq.limit = local->hw.wiphy->txq_limit;\n\telse\n\t\tlocal->hw.wiphy->txq_limit = local->fq.limit;\n\n\tif (local->hw.wiphy->txq_memory_limit)\n\t\tlocal->fq.memory_limit = local->hw.wiphy->txq_memory_limit;\n\telse\n\t\tlocal->hw.wiphy->txq_memory_limit = local->fq.memory_limit;\n\n\tif (local->hw.wiphy->txq_quantum)\n\t\tlocal->fq.quantum = local->hw.wiphy->txq_quantum;\n\telse\n\t\tlocal->hw.wiphy->txq_quantum = local->fq.quantum;\n}\n\nint ieee80211_txq_setup_flows(struct ieee80211_local *local)\n{\n\tstruct fq *fq = &local->fq;\n\tint ret;\n\tint i;\n\tbool supp_vht = false;\n\tenum nl80211_band band;\n\n\tif (!local->ops->wake_tx_queue)\n\t\treturn 0;\n\n\tret = fq_init(fq, 4096);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If the hardware doesn't support VHT, it is safe to limit the maximum\n\t * queue size. 4 Mbytes is 64 max-size aggregates in 802.11n.\n\t */\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = local->hw.wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tsupp_vht = supp_vht || sband->vht_cap.vht_supported;\n\t}\n\n\tif (!supp_vht)\n\t\tfq->memory_limit = 4 << 20; /* 4 Mbytes */\n\n\tcodel_params_init(&local->cparams);\n\tlocal->cparams.interval = MS2TIME(100);\n\tlocal->cparams.target = MS2TIME(20);\n\tlocal->cparams.ecn = true;\n\n\tlocal->cvars = kcalloc(fq->flows_cnt, sizeof(local->cvars[0]),\n\t\t\t       GFP_KERNEL);\n\tif (!local->cvars) {\n\t\tspin_lock_bh(&fq->lock);\n\t\tfq_reset(fq, fq_skb_free_func);\n\t\tspin_unlock_bh(&fq->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < fq->flows_cnt; i++)\n\t\tcodel_vars_init(&local->cvars[i]);\n\n\tieee80211_txq_set_params(local);\n\n\treturn 0;\n}\n\nvoid ieee80211_txq_teardown_flows(struct ieee80211_local *local)\n{\n\tstruct fq *fq = &local->fq;\n\n\tif (!local->ops->wake_tx_queue)\n\t\treturn;\n\n\tkfree(local->cvars);\n\tlocal->cvars = NULL;\n\n\tspin_lock_bh(&fq->lock);\n\tfq_reset(fq, fq_skb_free_func);\n\tspin_unlock_bh(&fq->lock);\n}\n\nstatic bool ieee80211_queue_skb(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sta_info *sta,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_vif *vif;\n\tstruct txq_info *txqi;\n\n\tif (!local->ops->wake_tx_queue ||\n\t    sdata->vif.type == NL80211_IFTYPE_MONITOR)\n\t\treturn false;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\n\tvif = &sdata->vif;\n\ttxqi = ieee80211_get_txq(local, vif, sta, skb);\n\n\tif (!txqi)\n\t\treturn false;\n\n\tieee80211_txq_enqueue(local, txqi, skb);\n\n\tschedule_and_wake_txq(local, txqi);\n\n\treturn true;\n}\n\nstatic bool ieee80211_tx_frags(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct sta_info *sta,\n\t\t\t       struct sk_buff_head *skbs,\n\t\t\t       bool txpending)\n{\n\tstruct ieee80211_tx_control control = {};\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\n\tskb_queue_walk_safe(skbs, skb, tmp) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tint q = info->hw_queue;\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tif (WARN_ON_ONCE(q >= local->hw.queues)) {\n\t\t\t__skb_unlink(skb, skbs);\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t\tif (local->queue_stop_reasons[q] ||\n\t\t    (!txpending && !skb_queue_empty(&local->pending[q]))) {\n\t\t\tif (unlikely(info->flags &\n\t\t\t\t     IEEE80211_TX_INTFL_OFFCHAN_TX_OK)) {\n\t\t\t\tif (local->queue_stop_reasons[q] &\n\t\t\t\t    ~BIT(IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Drop off-channel frames if queues\n\t\t\t\t\t * are stopped for any reason other\n\t\t\t\t\t * than off-channel operation. Never\n\t\t\t\t\t * queue them.\n\t\t\t\t\t */\n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tieee80211_purge_tx_queue(&local->hw,\n\t\t\t\t\t\t\t\t skbs);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t/*\n\t\t\t\t * Since queue is stopped, queue up frames for\n\t\t\t\t * later transmission from the tx-pending\n\t\t\t\t * tasklet when the queue is woken again.\n\t\t\t\t */\n\t\t\t\tif (txpending)\n\t\t\t\t\tskb_queue_splice_init(skbs,\n\t\t\t\t\t\t\t      &local->pending[q]);\n\t\t\t\telse\n\t\t\t\t\tskb_queue_splice_tail_init(skbs,\n\t\t\t\t\t\t\t\t   &local->pending[q]);\n\n\t\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\t\tinfo->control.vif = vif;\n\t\tcontrol.sta = sta ? &sta->sta : NULL;\n\n\t\t__skb_unlink(skb, skbs);\n\t\tdrv_tx(local, &control, skb);\n\t}\n\n\treturn true;\n}\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead.\n */\nstatic bool __ieee80211_tx(struct ieee80211_local *local,\n\t\t\t   struct sk_buff_head *skbs, int led_len,\n\t\t\t   struct sta_info *sta, bool txpending)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_vif *vif;\n\tstruct sk_buff *skb;\n\tbool result;\n\t__le16 fc;\n\n\tif (WARN_ON(skb_queue_empty(skbs)))\n\t\treturn true;\n\n\tskb = skb_peek(skbs);\n\tfc = ((struct ieee80211_hdr *)skb->data)->frame_control;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tsdata = vif_to_sdata(info->control.vif);\n\tif (sta && !sta->uploaded)\n\t\tsta = NULL;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tvif = &sdata->vif;\n\t\t\tbreak;\n\t\t}\n\t\tsdata = rcu_dereference(local->monitor_sdata);\n\t\tif (sdata) {\n\t\t\tvif = &sdata->vif;\n\t\t\tinfo->hw_queue =\n\t\t\t\tvif->hw_queue[skb_get_queue_mapping(skb)];\n\t\t} else if (ieee80211_hw_check(&local->hw, QUEUE_CONTROL)) {\n\t\t\tieee80211_purge_tx_queue(&local->hw, skbs);\n\t\t\treturn true;\n\t\t} else\n\t\t\tvif = NULL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\t\tfallthrough;\n\tdefault:\n\t\tvif = &sdata->vif;\n\t\tbreak;\n\t}\n\n\tresult = ieee80211_tx_frags(local, vif, sta, skbs, txpending);\n\n\tieee80211_tpt_led_trig_tx(local, fc, led_len);\n\n\tWARN_ON_ONCE(!skb_queue_empty(skbs));\n\n\treturn result;\n}\n\n/*\n * Invoke TX handlers, return 0 on success and non-zero if the\n * frame was dropped or queued.\n *\n * The handlers are split into an early and late part. The latter is everything\n * that can be sensitive to reordering, and will be deferred to after packets\n * are dequeued from the intermediate queues (when they are enabled).\n */\nstatic int invoke_tx_handlers_early(struct ieee80211_tx_data *tx)\n{\n\tieee80211_tx_result res = TX_DROP;\n\n#define CALL_TXH(txh) \\\n\tdo {\t\t\t\t\\\n\t\tres = txh(tx);\t\t\\\n\t\tif (res != TX_CONTINUE)\t\\\n\t\t\tgoto txh_done;\t\\\n\t} while (0)\n\n\tCALL_TXH(ieee80211_tx_h_dynamic_ps);\n\tCALL_TXH(ieee80211_tx_h_check_assoc);\n\tCALL_TXH(ieee80211_tx_h_ps_buf);\n\tCALL_TXH(ieee80211_tx_h_check_control_port_protocol);\n\tCALL_TXH(ieee80211_tx_h_select_key);\n\tif (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_rate_ctrl);\n\n txh_done:\n\tif (unlikely(res == TX_DROP)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop);\n\t\tif (tx->skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, tx->skb);\n\t\telse\n\t\t\tieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);\n\t\treturn -1;\n\t} else if (unlikely(res == TX_QUEUED)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_queued);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Late handlers can be called while the sta lock is held. Handlers that can\n * cause packets to be generated will cause deadlock!\n */\nstatic int invoke_tx_handlers_late(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tieee80211_tx_result res = TX_CONTINUE;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_RETRANSMISSION)) {\n\t\t__skb_queue_tail(&tx->skbs, tx->skb);\n\t\ttx->skb = NULL;\n\t\tgoto txh_done;\n\t}\n\n\tCALL_TXH(ieee80211_tx_h_michael_mic_add);\n\tCALL_TXH(ieee80211_tx_h_sequence);\n\tCALL_TXH(ieee80211_tx_h_fragment);\n\t/* handlers after fragment must be aware of tx info fragmentation! */\n\tCALL_TXH(ieee80211_tx_h_stats);\n\tCALL_TXH(ieee80211_tx_h_encrypt);\n\tif (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_calculate_duration);\n#undef CALL_TXH\n\n txh_done:\n\tif (unlikely(res == TX_DROP)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop);\n\t\tif (tx->skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, tx->skb);\n\t\telse\n\t\t\tieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);\n\t\treturn -1;\n\t} else if (unlikely(res == TX_QUEUED)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_queued);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int invoke_tx_handlers(struct ieee80211_tx_data *tx)\n{\n\tint r = invoke_tx_handlers_early(tx);\n\n\tif (r)\n\t\treturn r;\n\treturn invoke_tx_handlers_late(tx);\n}\n\nbool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, struct sk_buff *skb,\n\t\t\t      int band, struct ieee80211_sta **sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_data tx;\n\tstruct sk_buff *skb2;\n\n\tif (ieee80211_tx_prepare(sdata, &tx, NULL, skb) == TX_DROP)\n\t\treturn false;\n\n\tinfo->band = band;\n\tinfo->control.vif = vif;\n\tinfo->hw_queue = vif->hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (invoke_tx_handlers(&tx))\n\t\treturn false;\n\n\tif (sta) {\n\t\tif (tx.sta)\n\t\t\t*sta = &tx.sta->sta;\n\t\telse\n\t\t\t*sta = NULL;\n\t}\n\n\t/* this function isn't suitable for fragmented data frames */\n\tskb2 = __skb_dequeue(&tx.skbs);\n\tif (WARN_ON(skb2 != skb || !skb_queue_empty(&tx.skbs))) {\n\t\tieee80211_free_txskb(hw, skb2);\n\t\tieee80211_purge_tx_queue(hw, &tx.skbs);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_tx_prepare_skb);\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead.\n */\nstatic bool ieee80211_tx(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sta_info *sta, struct sk_buff *skb,\n\t\t\t bool txpending)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result res_prepare;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool result = true;\n\tint led_len;\n\n\tif (unlikely(skb->len < 10)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn true;\n\t}\n\n\t/* initialises tx */\n\tled_len = skb->len;\n\tres_prepare = ieee80211_tx_prepare(sdata, &tx, sta, skb);\n\n\tif (unlikely(res_prepare == TX_DROP)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn true;\n\t} else if (unlikely(res_prepare == TX_QUEUED)) {\n\t\treturn true;\n\t}\n\n\t/* set up hw_queue value early */\n\tif (!(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||\n\t    !ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\n\t\tinfo->hw_queue =\n\t\t\tsdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (invoke_tx_handlers_early(&tx))\n\t\treturn true;\n\n\tif (ieee80211_queue_skb(local, sdata, tx.sta, tx.skb))\n\t\treturn true;\n\n\tif (!invoke_tx_handlers_late(&tx))\n\t\tresult = __ieee80211_tx(local, &tx.skbs, led_len,\n\t\t\t\t\ttx.sta, txpending);\n\n\treturn result;\n}\n\n/* device xmit handlers */\n\nenum ieee80211_encrypt {\n\tENCRYPT_NO,\n\tENCRYPT_MGMT,\n\tENCRYPT_DATA,\n};\n\nstatic int ieee80211_skb_resize(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tint head_need,\n\t\t\t\tenum ieee80211_encrypt encrypt)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tbool enc_tailroom;\n\tint tail_need = 0;\n\n\tenc_tailroom = encrypt == ENCRYPT_MGMT ||\n\t\t       (encrypt == ENCRYPT_DATA &&\n\t\t\tsdata->crypto_tx_tailroom_needed_cnt);\n\n\tif (enc_tailroom) {\n\t\ttail_need = IEEE80211_ENCRYPT_TAILROOM;\n\t\ttail_need -= skb_tailroom(skb);\n\t\ttail_need = max_t(int, tail_need, 0);\n\t}\n\n\tif (skb_cloned(skb) &&\n\t    (!ieee80211_hw_check(&local->hw, SUPPORTS_CLONED_SKBS) ||\n\t     !skb_clone_writable(skb, ETH_HLEN) || enc_tailroom))\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head_cloned);\n\telse if (head_need || tail_need)\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head);\n\telse\n\t\treturn 0;\n\n\tif (pskb_expand_head(skb, head_need, tail_need, GFP_ATOMIC)) {\n\t\twiphy_debug(local->hw.wiphy,\n\t\t\t    \"failed to reallocate TX buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_xmit(struct ieee80211_sub_if_data *sdata,\n\t\t    struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tint headroom;\n\tenum ieee80211_encrypt encrypt;\n\n\tif (info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)\n\t\tencrypt = ENCRYPT_NO;\n\telse if (ieee80211_is_mgmt(hdr->frame_control))\n\t\tencrypt = ENCRYPT_MGMT;\n\telse\n\t\tencrypt = ENCRYPT_DATA;\n\n\theadroom = local->tx_headroom;\n\tif (encrypt != ENCRYPT_NO)\n\t\theadroom += sdata->encrypt_headroom;\n\theadroom -= skb_headroom(skb);\n\theadroom = max_t(int, 0, headroom);\n\n\tif (ieee80211_skb_resize(sdata, skb, headroom, encrypt)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn;\n\t}\n\n\t/* reload after potential resize */\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tinfo->control.vif = &sdata->vif;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t    is_unicast_ether_addr(hdr->addr1)) {\n\t\t\tif (mesh_nexthop_resolve(sdata, skb))\n\t\t\t\treturn; /* skb queued: don't free */\n\t\t} else {\n\t\t\tieee80211_mps_set_frame_flags(sdata, NULL, hdr);\n\t\t}\n\t}\n\n\tieee80211_set_qos_hdr(sdata, skb);\n\tieee80211_tx(sdata, sta, skb, false);\n}\n\nbool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_radiotap_iterator iterator;\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_supported_band *sband =\n\t\tlocal->hw.wiphy->bands[info->band];\n\tint ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,\n\t\t\t\t\t\t   NULL);\n\tu16 txflags;\n\tu16 rate = 0;\n\tbool rate_found = false;\n\tu8 rate_retries = 0;\n\tu16 rate_flags = 0;\n\tu8 mcs_known, mcs_flags, mcs_bw;\n\tu16 vht_known;\n\tu8 vht_mcs = 0, vht_nss = 0;\n\tint i;\n\n\t/* check for not even having the fixed radiotap header part */\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false; /* too short to be possibly valid */\n\n\t/* is it a header version we can trust to find length from? */\n\tif (unlikely(rthdr->it_version))\n\t\treturn false; /* only version 0 is supported */\n\n\t/* does the skb contain enough to deliver on the alleged length? */\n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false; /* skb too short for claimed rt header extent */\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t       IEEE80211_TX_CTL_DONTFRAG;\n\n\t/*\n\t * for every radiotap entry that is present\n\t * (ieee80211_radiotap_iterator_next returns -ENOENT when no more\n\t * entries present, or -EINVAL on error)\n\t */\n\n\twhile (!ret) {\n\t\tret = ieee80211_radiotap_iterator_next(&iterator);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* see if this argument is something we can use */\n\t\tswitch (iterator.this_arg_index) {\n\t\t/*\n\t\t * You must take care when dereferencing iterator.this_arg\n\t\t * for multibyte types... the pointer is not aligned.  Use\n\t\t * get_unaligned((type *)iterator.this_arg) to dereference\n\t\t * iterator.this_arg for type \"type\" safely on all arches.\n\t\t*/\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {\n\t\t\t\t/*\n\t\t\t\t * this indicates that the skb we have been\n\t\t\t\t * handed has the 32-bit FCS CRC at the end...\n\t\t\t\t * we should react to that by snipping it off\n\t\t\t\t * because it will be recomputed and added\n\t\t\t\t * on transmission\n\t\t\t\t */\n\t\t\t\tif (skb->len < (iterator._max_length + FCS_LEN))\n\t\t\t\t\treturn false;\n\n\t\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\t\t}\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_DONTFRAG;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_TX_FLAGS:\n\t\t\ttxflags = get_unaligned_le16(iterator.this_arg);\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)\n\t\t\t\tinfo->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)\n\t\t\t\tinfo->control.flags |=\n\t\t\t\t\tIEEE80211_TX_CTRL_DONT_REORDER;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_RATE:\n\t\t\trate = *iterator.this_arg;\n\t\t\trate_flags = 0;\n\t\t\trate_found = true;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DATA_RETRIES:\n\t\t\trate_retries = *iterator.this_arg;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_MCS:\n\t\t\tmcs_known = iterator.this_arg[0];\n\t\t\tmcs_flags = iterator.this_arg[1];\n\t\t\tif (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))\n\t\t\t\tbreak;\n\n\t\t\trate_found = true;\n\t\t\trate = iterator.this_arg[2];\n\t\t\trate_flags = IEEE80211_TX_RC_MCS;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\n\t\t\tmcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&\n\t\t\t    mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_LDPC;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {\n\t\t\t\tu8 stbc = u8_get_bits(mcs_flags,\n\t\t\t\t\t\t      IEEE80211_RADIOTAP_MCS_STBC_MASK);\n\n\t\t\t\tinfo->flags |=\n\t\t\t\t\tu32_encode_bits(stbc,\n\t\t\t\t\t\t\tIEEE80211_TX_CTL_STBC);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_VHT:\n\t\t\tvht_known = get_unaligned_le16(iterator.this_arg);\n\t\t\trate_found = true;\n\n\t\t\trate_flags = IEEE80211_TX_RC_VHT_MCS;\n\t\t\tif ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&\n\t\t\t    (iterator.this_arg[2] &\n\t\t\t     IEEE80211_RADIOTAP_VHT_FLAG_SGI))\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\t\t\tif (vht_known &\n\t\t\t    IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {\n\t\t\t\tif (iterator.this_arg[3] == 1)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 4)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 11)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_160_MHZ_WIDTH;\n\t\t\t}\n\n\t\t\tvht_mcs = iterator.this_arg[4] >> 4;\n\t\t\tvht_nss = iterator.this_arg[4] & 0xF;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Please update the file\n\t\t * Documentation/networking/mac80211-injection.rst\n\t\t * when parsing new fields here.\n\t\t */\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -ENOENT) /* ie, if we didn't simply run out of fields */\n\t\treturn false;\n\n\tif (rate_found) {\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\t\tinfo->control.rates[i].idx = -1;\n\t\t\tinfo->control.rates[i].flags = 0;\n\t\t\tinfo->control.rates[i].count = 0;\n\t\t}\n\n\t\tif (rate_flags & IEEE80211_TX_RC_MCS) {\n\t\t\tinfo->control.rates[0].idx = rate;\n\t\t} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t\tieee80211_rate_set_vht(info->control.rates, vht_mcs,\n\t\t\t\t\t       vht_nss);\n\t\t} else {\n\t\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\t\tif (rate * 5 != sband->bitrates[i].bitrate)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tinfo->control.rates[0].idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info->control.rates[0].idx < 0)\n\t\t\tinfo->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tinfo->control.rates[0].flags = rate_flags;\n\t\tinfo->control.rates[0].count = min_t(u8, rate_retries + 1,\n\t\t\t\t\t\t     local->hw.max_rate_tries);\n\t}\n\n\treturn true;\n}\n\nnetdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* Sanity-check and process the injection radiotap header */\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail;\n\n\t/* we now know there is a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN support we have an nl80211-based mechanism.\n\t *\n\t * This is necessary, for example, for old hostapd versions that\n\t * don't use nl80211-based management TX/RX.\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t/* Initialize skb->priority according to frame type and TID class,\n\t * with respect to the sub interface that the frame will actually\n\t * be transmitted on. If the DONT_REORDER flag is set, the original\n\t * skb-priority is preserved to assure frames injected with this\n\t * flag are not reordered relative to each other.\n\t */\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t/* remove the injection radiotap header */\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}\n\nstatic inline bool ieee80211_is_tdls_setup(struct sk_buff *skb)\n{\n\tu16 ethertype = (skb->data[12] << 8) | skb->data[13];\n\n\treturn ethertype == ETH_P_TDLS &&\n\t       skb->len > 14 &&\n\t       skb->data[14] == WLAN_TDLS_SNAP_RFTYPE;\n}\n\nint ieee80211_lookup_ra_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct sta_info **sta_out)\n{\n\tstruct sta_info *sta;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (sta) {\n\t\t\t*sta_out = sta;\n\t\t\treturn 0;\n\t\t} else if (sdata->wdev.use_4addr) {\n\t\t\treturn -ENOLINK;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (is_multicast_ether_addr(skb->data)) {\n\t\t\t*sta_out = ERR_PTR(-ENOENT);\n\t\t\treturn 0;\n\t\t}\n\t\tsta = sta_info_get_bss(sdata, skb->data);\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t/* determined much later */\n\t\t*sta_out = NULL;\n\t\treturn 0;\n#endif\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sdata->wdev.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\t\tsta = sta_info_get(sdata, skb->data);\n\t\t\tif (sta && test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\t\tif (test_sta_flag(sta,\n\t\t\t\t\t\t  WLAN_STA_TDLS_PEER_AUTH)) {\n\t\t\t\t\t*sta_out = sta;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * TDLS link during setup - throw out frames to\n\t\t\t\t * peer. Allow TDLS-setup frames to unauthorized\n\t\t\t\t * peers for the special case of a link teardown\n\t\t\t\t * after a TDLS sta is removed due to being\n\t\t\t\t * unreachable.\n\t\t\t\t */\n\t\t\t\tif (!ieee80211_is_tdls_setup(skb))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t}\n\n\t\tsta = sta_info_get(sdata, sdata->u.mgd.bssid);\n\t\tif (!sta)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*sta_out = sta ?: ERR_PTR(-ENOENT);\n\treturn 0;\n}\n\nstatic u16 ieee80211_store_ack_skb(struct ieee80211_local *local,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   u32 *info_flags,\n\t\t\t\t   u64 *cookie)\n{\n\tstruct sk_buff *ack_skb;\n\tu16 info_id = 0;\n\n\tif (skb->sk)\n\t\tack_skb = skb_clone_sk(skb);\n\telse\n\t\tack_skb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (ack_skb) {\n\t\tunsigned long flags;\n\t\tint id;\n\n\t\tspin_lock_irqsave(&local->ack_status_lock, flags);\n\t\tid = idr_alloc(&local->ack_status_frames, ack_skb,\n\t\t\t       1, 0x2000, GFP_ATOMIC);\n\t\tspin_unlock_irqrestore(&local->ack_status_lock, flags);\n\n\t\tif (id >= 0) {\n\t\t\tinfo_id = id;\n\t\t\t*info_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\tif (cookie) {\n\t\t\t\t*cookie = ieee80211_mgmt_tx_cookie(local);\n\t\t\t\tIEEE80211_SKB_CB(ack_skb)->ack.cookie = *cookie;\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(ack_skb);\n\t\t}\n\t}\n\n\treturn info_id;\n}\n\n/**\n * ieee80211_build_hdr - build 802.11 header in the given frame\n * @sdata: virtual interface to build the header for\n * @skb: the skb to build the header in\n * @info_flags: skb flags to set\n * @sta: the station pointer\n * @ctrl_flags: info control flags to set\n * @cookie: cookie pointer to fill (if not %NULL)\n *\n * This function takes the skb with 802.3 header and reformats the header to\n * the appropriate IEEE 802.11 header based on which interface the packet is\n * being transmitted on.\n *\n * Note that this function also takes care of the TX status request and\n * potential unsharing of the SKB - this needs to be interleaved with the\n * header building.\n *\n * The function requires the read-side RCU lock held\n *\n * Returns: the (possibly reallocated) skb or an ERR_PTR() code\n */\nstatic struct sk_buff *ieee80211_build_hdr(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct sk_buff *skb, u32 info_flags,\n\t\t\t\t\t   struct sta_info *sta, u32 ctrl_flags,\n\t\t\t\t\t   u64 *cookie)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info;\n\tint head_need;\n\tu16 ethertype, hdrlen,  meshhdrlen = 0;\n\t__le16 fc;\n\tstruct ieee80211_hdr hdr;\n\tstruct ieee80211s_hdr mesh_hdr __maybe_unused;\n\tstruct mesh_path __maybe_unused *mppath = NULL, *mpath = NULL;\n\tconst u8 *encaps_data;\n\tint encaps_len, skip_header_bytes;\n\tbool wme_sta = false, authorized = false;\n\tbool tdls_peer;\n\tbool multicast;\n\tu16 info_id = 0;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_sub_if_data *ap_sdata;\n\tenum nl80211_band band;\n\tint ret;\n\n\tif (IS_ERR(sta))\n\t\tsta = NULL;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tif (local->force_tx_status)\n\t\tinfo_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n#endif\n\n\t/* convert Ethernet header to proper 802.11 header (based on\n\t * operation mode) */\n\tethertype = (skb->data[12] << 8) | skb->data[13];\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (sdata->wdev.use_4addr) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr.addr1, sta->sta.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\t\twme_sta = sta->sta.wme;\n\t\t}\n\t\tap_sdata = container_of(sdata->bss, struct ieee80211_sub_if_data,\n\t\t\t\t\tu.ap);\n\t\tchanctx_conf = rcu_dereference(ap_sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\t\tif (sdata->wdev.use_4addr)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t/* DA BSSID SA */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, skb->data + ETH_ALEN, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!is_multicast_ether_addr(skb->data)) {\n\t\t\tstruct sta_info *next_hop;\n\t\t\tbool mpp_lookup = true;\n\n\t\t\tmpath = mesh_path_lookup(sdata, skb->data);\n\t\t\tif (mpath) {\n\t\t\t\tmpp_lookup = false;\n\t\t\t\tnext_hop = rcu_dereference(mpath->next_hop);\n\t\t\t\tif (!next_hop ||\n\t\t\t\t    !(mpath->flags & (MESH_PATH_ACTIVE |\n\t\t\t\t\t\t      MESH_PATH_RESOLVING)))\n\t\t\t\t\tmpp_lookup = true;\n\t\t\t}\n\n\t\t\tif (mpp_lookup) {\n\t\t\t\tmppath = mpp_path_lookup(sdata, skb->data);\n\t\t\t\tif (mppath)\n\t\t\t\t\tmppath->exp_time = jiffies;\n\t\t\t}\n\n\t\t\tif (mppath && mpath)\n\t\t\t\tmesh_path_del(sdata, mpath->dst);\n\t\t}\n\n\t\t/*\n\t\t * Use address extension if it is a packet from\n\t\t * another interface or if we know the destination\n\t\t * is being proxied by a portal (i.e. portal address\n\t\t * differs from proxied address)\n\t\t */\n\t\tif (ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN) &&\n\t\t    !(mppath && !ether_addr_equal(mppath->mpp, skb->data))) {\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tskb->data, skb->data + ETH_ALEN);\n\t\t\tmeshhdrlen = ieee80211_new_mesh_header(sdata, &mesh_hdr,\n\t\t\t\t\t\t\t       NULL, NULL);\n\t\t} else {\n\t\t\t/* DS -> MBSS (802.11-2012 13.11.3.3).\n\t\t\t * For unicast with unknown forwarding information,\n\t\t\t * destination might be in the MBSS or if that fails\n\t\t\t * forwarded to another mesh gate. In either case\n\t\t\t * resolution will be handled in ieee80211_xmit(), so\n\t\t\t * leave the original DA. This also works for mcast */\n\t\t\tconst u8 *mesh_da = skb->data;\n\n\t\t\tif (mppath)\n\t\t\t\tmesh_da = mppath->mpp;\n\t\t\telse if (mpath)\n\t\t\t\tmesh_da = mpath->dst;\n\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tmesh_da, sdata->vif.addr);\n\t\t\tif (is_multicast_ether_addr(mesh_da))\n\t\t\t\t/* DA TA mSA AE:SA */\n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr,\n\t\t\t\t\t\tskb->data + ETH_ALEN, NULL);\n\t\t\telse\n\t\t\t\t/* RA TA mDA mSA AE:DA SA */\n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr, skb->data,\n\t\t\t\t\t\tskb->data + ETH_ALEN);\n\n\t\t}\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\n\t\t/* For injected frames, fill RA right away as nexthop lookup\n\t\t * will be skipped.\n\t\t */\n\t\tif ((ctrl_flags & IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP) &&\n\t\t    is_zero_ether_addr(hdr.addr1))\n\t\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tbreak;\n#endif\n\tcase NL80211_IFTYPE_STATION:\n\t\t/* we already did checks when looking up the RA STA */\n\t\ttdls_peer = test_sta_flag(sta, WLAN_STA_TDLS_PEER);\n\n\t\tif (tdls_peer) {\n\t\t\t/* DA SA BSSID */\n\t\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}  else if (sdata->u.mgd.use_4addr &&\n\t\t\t    cpu_to_be16(ethertype) != sdata->control_port_protocol) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t} else {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t\t/* BSSID SA DA */\n\t\t\tmemcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tcase NL80211_IFTYPE_OCB:\n\t\t/* DA SA BSSID */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\teth_broadcast_addr(hdr.addr3);\n\t\thdrlen = 24;\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* DA SA BSSID */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, sdata->u.ibss.bssid, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tmulticast = is_multicast_ether_addr(hdr.addr1);\n\n\t/* sta is always NULL for mesh */\n\tif (sta) {\n\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\twme_sta = sta->sta.wme;\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\t/* For mesh, the use of the QoS header is mandatory */\n\t\twme_sta = true;\n\t}\n\n\t/* receiver does QoS (which also means we do) use it */\n\tif (wme_sta) {\n\t\tfc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n\t\thdrlen += 2;\n\t}\n\n\t/*\n\t * Drop unicast frames to unauthorised stations unless they are\n\t * EAPOL frames from the local station.\n\t */\n\tif (unlikely(!ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t     (sdata->vif.type != NL80211_IFTYPE_OCB) &&\n\t\t     !multicast && !authorized &&\n\t\t     (cpu_to_be16(ethertype) != sdata->control_port_protocol ||\n\t\t      !ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN)))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tnet_info_ratelimited(\"%s: dropped frame to %pM (unauthorized port)\\n\",\n\t\t\t\t    sdata->name, hdr.addr1);\n#endif\n\n\t\tI802_DEBUG_INC(local->tx_handlers_drop_unauth_port);\n\n\t\tret = -EPERM;\n\t\tgoto free;\n\t}\n\n\tif (unlikely(!multicast && ((skb->sk &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS) ||\n\t\t     ctrl_flags & IEEE80211_TX_CTL_REQ_TX_STATUS)))\n\t\tinfo_id = ieee80211_store_ack_skb(local, skb, &info_flags,\n\t\t\t\t\t\t  cookie);\n\n\t/*\n\t * If the skb is shared we need to obtain our own copy.\n\t */\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *tmp_skb = skb;\n\n\t\t/* can't happen -- skb is a clone if info_id != 0 */\n\t\tWARN_ON(info_id);\n\n\t\tskb = skb_clone(skb, GFP_ATOMIC);\n\t\tkfree_skb(tmp_skb);\n\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\thdr.frame_control = fc;\n\thdr.duration_id = 0;\n\thdr.seq_ctrl = 0;\n\n\tskip_header_bytes = ETH_HLEN;\n\tif (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {\n\t\tencaps_data = bridge_tunnel_header;\n\t\tencaps_len = sizeof(bridge_tunnel_header);\n\t\tskip_header_bytes -= 2;\n\t} else if (ethertype >= ETH_P_802_3_MIN) {\n\t\tencaps_data = rfc1042_header;\n\t\tencaps_len = sizeof(rfc1042_header);\n\t\tskip_header_bytes -= 2;\n\t} else {\n\t\tencaps_data = NULL;\n\t\tencaps_len = 0;\n\t}\n\n\tskb_pull(skb, skip_header_bytes);\n\thead_need = hdrlen + encaps_len + meshhdrlen - skb_headroom(skb);\n\n\t/*\n\t * So we need to modify the skb header and hence need a copy of\n\t * that. The head_need variable above doesn't, so far, include\n\t * the needed header space that we don't need right away. If we\n\t * can, then we don't reallocate right now but only after the\n\t * frame arrives at the master device (if it does...)\n\t *\n\t * If we cannot, however, then we will reallocate to include all\n\t * the ever needed space. Also, if we need to reallocate it anyway,\n\t * make it big enough for everything we may ever need.\n\t */\n\n\tif (head_need > 0 || skb_cloned(skb)) {\n\t\thead_need += sdata->encrypt_headroom;\n\t\thead_need += local->tx_headroom;\n\t\thead_need = max_t(int, 0, head_need);\n\t\tif (ieee80211_skb_resize(sdata, skb, head_need, ENCRYPT_DATA)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tskb = NULL;\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tif (encaps_data)\n\t\tmemcpy(skb_push(skb, encaps_len), encaps_data, encaps_len);\n\n#ifdef CONFIG_MAC80211_MESH\n\tif (meshhdrlen > 0)\n\t\tmemcpy(skb_push(skb, meshhdrlen), &mesh_hdr, meshhdrlen);\n#endif\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\t__le16 *qos_control;\n\n\t\tqos_control = skb_push(skb, 2);\n\t\tmemcpy(skb_push(skb, hdrlen - 2), &hdr, hdrlen - 2);\n\t\t/*\n\t\t * Maybe we could actually set some fields here, for now just\n\t\t * initialise to zero to indicate no special operation.\n\t\t */\n\t\t*qos_control = 0;\n\t} else\n\t\tmemcpy(skb_push(skb, hdrlen), &hdr, hdrlen);\n\n\tskb_reset_mac_header(skb);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(info, 0, sizeof(*info));\n\n\tinfo->flags = info_flags;\n\tinfo->ack_frame_id = info_id;\n\tinfo->band = band;\n\tinfo->control.flags = ctrl_flags;\n\n\treturn skb;\n free:\n\tkfree_skb(skb);\n\treturn ERR_PTR(ret);\n}\n\n/*\n * fast-xmit overview\n *\n * The core idea of this fast-xmit is to remove per-packet checks by checking\n * them out of band. ieee80211_check_fast_xmit() implements the out-of-band\n * checks that are needed to get the sta->fast_tx pointer assigned, after which\n * much less work can be done per packet. For example, fragmentation must be\n * disabled or the fast_tx pointer will not be set. All the conditions are seen\n * in the code here.\n *\n * Once assigned, the fast_tx data structure also caches the per-packet 802.11\n * header and other data to aid packet processing in ieee80211_xmit_fast().\n *\n * The most difficult part of this is that when any of these assumptions\n * change, an external trigger (i.e. a call to ieee80211_clear_fast_xmit(),\n * ieee80211_check_fast_xmit() or friends) is required to reset the data,\n * since the per-packet code no longer checks the conditions. This is reflected\n * by the calls to these functions throughout the rest of the code, and must be\n * maintained if any of the TX path checks change.\n */\n\nvoid ieee80211_check_fast_xmit(struct sta_info *sta)\n{\n\tstruct ieee80211_fast_tx build = {}, *fast_tx = NULL, *old;\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_hdr *hdr = (void *)build.hdr;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\t__le16 fc;\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORT_FAST_XMIT))\n\t\treturn;\n\n\t/* Locking here protects both the pointer itself, and against concurrent\n\t * invocations winning data access races to, e.g., the key pointer that\n\t * is used.\n\t * Without it, the invocation of this function right after the key\n\t * pointer changes wouldn't be sufficient, as another CPU could access\n\t * the pointer, then stall, and then do the cache update after the CPU\n\t * that invalidated the key.\n\t * With the locking, such scenarios cannot happen as the check for the\n\t * key and the fast-tx assignment are done atomically, so the CPU that\n\t * modifies the key will either wait or other one will see the key\n\t * cleared/changed already.\n\t */\n\tspin_lock_bh(&sta->lock);\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_PS) &&\n\t    !ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS) &&\n\t    sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tgoto out;\n\n\tif (!test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\tgoto out;\n\n\tif (test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t    test_sta_flag(sta, WLAN_STA_PS_DRIVER) ||\n\t    test_sta_flag(sta, WLAN_STA_PS_DELIVER) ||\n\t    test_sta_flag(sta, WLAN_STA_CLEAR_PS_FILT))\n\t\tgoto out;\n\n\tif (sdata->noack_map)\n\t\tgoto out;\n\n\t/* fast-xmit doesn't handle fragmentation at all */\n\tif (local->hw.wiphy->frag_threshold != (u32)-1 &&\n\t    !ieee80211_hw_check(&local->hw, SUPPORTS_TX_FRAG))\n\t\tgoto out;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\tgoto out;\n\t}\n\tbuild.band = chanctx_conf->def.chan->band;\n\trcu_read_unlock();\n\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* DA SA BSSID */\n\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\tmemcpy(hdr->addr3, sdata->u.ibss.bssid, ETH_ALEN);\n\t\tbuild.hdr_len = 24;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\t/* DA SA BSSID */\n\t\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\t\tmemcpy(hdr->addr3, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tbuild.hdr_len = 24;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdata->u.mgd.use_4addr) {\n\t\t\t/* non-regular ethertype cannot use the fastpath */\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr->addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t\tbuild.hdr_len = 30;\n\t\t\tbreak;\n\t\t}\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t/* BSSID SA DA */\n\t\tmemcpy(hdr->addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\tbuild.hdr_len = 24;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (sdata->wdev.use_4addr) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr->addr1, sta->sta.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t\tbuild.hdr_len = 30;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t/* DA BSSID SA */\n\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\tbuild.hdr_len = 24;\n\t\tbreak;\n\tdefault:\n\t\t/* not handled on fast-xmit */\n\t\tgoto out;\n\t}\n\n\tif (sta->sta.wme) {\n\t\tbuild.hdr_len += 2;\n\t\tfc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n\t}\n\n\t/* We store the key here so there's no point in using rcu_dereference()\n\t * but that's fine because the code that changes the pointers will call\n\t * this function after doing so. For a single CPU that would be enough,\n\t * for multiple see the comment above.\n\t */\n\tbuild.key = rcu_access_pointer(sta->ptk[sta->ptk_idx]);\n\tif (!build.key)\n\t\tbuild.key = rcu_access_pointer(sdata->default_unicast_key);\n\tif (build.key) {\n\t\tbool gen_iv, iv_spc, mmic;\n\n\t\tgen_iv = build.key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tiv_spc = build.key->conf.flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE;\n\t\tmmic = build.key->conf.flags &\n\t\t\t(IEEE80211_KEY_FLAG_GENERATE_MMIC |\n\t\t\t IEEE80211_KEY_FLAG_PUT_MIC_SPACE);\n\n\t\t/* don't handle software crypto */\n\t\tif (!(build.key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE))\n\t\t\tgoto out;\n\n\t\t/* Key is being removed */\n\t\tif (build.key->flags & KEY_FLAG_TAINTED)\n\t\t\tgoto out;\n\n\t\tswitch (build.key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\t\tif (gen_iv)\n\t\t\t\tbuild.pn_offs = build.hdr_len;\n\t\t\tif (gen_iv || iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_CCMP_HDR_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tif (gen_iv)\n\t\t\t\tbuild.pn_offs = build.hdr_len;\n\t\t\tif (gen_iv || iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_GCMP_HDR_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\t/* cannot handle MMIC or IV generation in xmit-fast */\n\t\t\tif (mmic || gen_iv)\n\t\t\t\tgoto out;\n\t\t\tif (iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_TKIP_IV_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\t/* cannot handle IV generation in fast-xmit */\n\t\t\tif (gen_iv)\n\t\t\t\tgoto out;\n\t\t\tif (iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_WEP_IV_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t\tWARN(1,\n\t\t\t     \"management cipher suite 0x%x enabled for data\\n\",\n\t\t\t     build.key->conf.cipher);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\t/* we don't know how to generate IVs for this at all */\n\t\t\tif (WARN_ON(gen_iv))\n\t\t\t\tgoto out;\n\t\t\t/* pure hardware keys are OK, of course */\n\t\t\tif (!(build.key->flags & KEY_FLAG_CIPHER_SCHEME))\n\t\t\t\tbreak;\n\t\t\t/* cipher scheme might require space allocation */\n\t\t\tif (iv_spc &&\n\t\t\t    build.key->conf.iv_len > IEEE80211_FAST_XMIT_MAX_IV)\n\t\t\t\tgoto out;\n\t\t\tif (iv_spc)\n\t\t\t\tbuild.hdr_len += build.key->conf.iv_len;\n\t\t}\n\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t}\n\n\thdr->frame_control = fc;\n\n\tmemcpy(build.hdr + build.hdr_len,\n\t       rfc1042_header,  sizeof(rfc1042_header));\n\tbuild.hdr_len += sizeof(rfc1042_header);\n\n\tfast_tx = kmemdup(&build, sizeof(build), GFP_ATOMIC);\n\t/* if the kmemdup fails, continue w/o fast_tx */\n\tif (!fast_tx)\n\t\tgoto out;\n\n out:\n\t/* we might have raced against another call to this function */\n\told = rcu_dereference_protected(sta->fast_tx,\n\t\t\t\t\tlockdep_is_held(&sta->lock));\n\trcu_assign_pointer(sta->fast_tx, fast_tx);\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n\tspin_unlock_bh(&sta->lock);\n}\n\nvoid ieee80211_check_fast_xmit_all(struct ieee80211_local *local)\n{\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list)\n\t\tieee80211_check_fast_xmit(sta);\n\trcu_read_unlock();\n}\n\nvoid ieee80211_check_fast_xmit_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata &&\n\t\t    (!sta->sdata->bss || sta->sdata->bss != sdata->bss))\n\t\t\tcontinue;\n\t\tieee80211_check_fast_xmit(sta);\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid ieee80211_clear_fast_xmit(struct sta_info *sta)\n{\n\tstruct ieee80211_fast_tx *fast_tx;\n\n\tspin_lock_bh(&sta->lock);\n\tfast_tx = rcu_dereference_protected(sta->fast_tx,\n\t\t\t\t\t    lockdep_is_held(&sta->lock));\n\tRCU_INIT_POINTER(sta->fast_tx, NULL);\n\tspin_unlock_bh(&sta->lock);\n\n\tif (fast_tx)\n\t\tkfree_rcu(fast_tx, rcu_head);\n}\n\nstatic bool ieee80211_amsdu_realloc_pad(struct ieee80211_local *local,\n\t\t\t\t\tstruct sk_buff *skb, int headroom)\n{\n\tif (skb_headroom(skb) < headroom) {\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head);\n\n\t\tif (pskb_expand_head(skb, headroom, 0, GFP_ATOMIC)) {\n\t\t\twiphy_debug(local->hw.wiphy,\n\t\t\t\t    \"failed to reallocate TX buffer\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool ieee80211_amsdu_prepare_head(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct ieee80211_fast_tx *fast_tx,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ethhdr *amsdu_hdr;\n\tint hdr_len = fast_tx->hdr_len - sizeof(rfc1042_header);\n\tint subframe_len = skb->len - hdr_len;\n\tvoid *data;\n\tu8 *qc, *h_80211_src, *h_80211_dst;\n\tconst u8 *bssid;\n\n\tif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\n\t\treturn false;\n\n\tif (info->control.flags & IEEE80211_TX_CTRL_AMSDU)\n\t\treturn true;\n\n\tif (!ieee80211_amsdu_realloc_pad(local, skb, sizeof(*amsdu_hdr)))\n\t\treturn false;\n\n\tdata = skb_push(skb, sizeof(*amsdu_hdr));\n\tmemmove(data, data + sizeof(*amsdu_hdr), hdr_len);\n\thdr = data;\n\tamsdu_hdr = data + hdr_len;\n\t/* h_80211_src/dst is addr* field within hdr */\n\th_80211_src = data + fast_tx->sa_offs;\n\th_80211_dst = data + fast_tx->da_offs;\n\n\tamsdu_hdr->h_proto = cpu_to_be16(subframe_len);\n\tether_addr_copy(amsdu_hdr->h_source, h_80211_src);\n\tether_addr_copy(amsdu_hdr->h_dest, h_80211_dst);\n\n\t/* according to IEEE 802.11-2012 8.3.2 table 8-19, the outer SA/DA\n\t * fields needs to be changed to BSSID for A-MSDU frames depending\n\t * on FromDS/ToDS values.\n\t */\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tbssid = sdata->u.mgd.bssid;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbssid = sdata->vif.addr;\n\t\tbreak;\n\tdefault:\n\t\tbssid = NULL;\n\t}\n\n\tif (bssid && ieee80211_has_fromds(hdr->frame_control))\n\t\tether_addr_copy(h_80211_src, bssid);\n\n\tif (bssid && ieee80211_has_tods(hdr->frame_control))\n\t\tether_addr_copy(h_80211_dst, bssid);\n\n\tqc = ieee80211_get_qos_ctl(hdr);\n\t*qc |= IEEE80211_QOS_CTL_A_MSDU_PRESENT;\n\n\tinfo->control.flags |= IEEE80211_TX_CTRL_AMSDU;\n\n\treturn true;\n}\n\nstatic bool ieee80211_amsdu_aggregate(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct sta_info *sta,\n\t\t\t\t      struct ieee80211_fast_tx *fast_tx,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin;\n\tstruct fq_flow *flow;\n\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\tstruct ieee80211_txq *txq = sta->sta.txq[tid];\n\tstruct txq_info *txqi;\n\tstruct sk_buff **frag_tail, *head;\n\tint subframe_len = skb->len - ETH_ALEN;\n\tu8 max_subframes = sta->sta.max_amsdu_subframes;\n\tint max_frags = local->hw.max_tx_fragments;\n\tint max_amsdu_len = sta->sta.max_amsdu_len;\n\tint orig_truesize;\n\tu32 flow_idx;\n\t__be16 len;\n\tvoid *data;\n\tbool ret = false;\n\tunsigned int orig_len;\n\tint n = 2, nfrags, pad = 0;\n\tu16 hdrlen;\n\n\tif (!ieee80211_hw_check(&local->hw, TX_AMSDU))\n\t\treturn false;\n\n\tif (skb_is_gso(skb))\n\t\treturn false;\n\n\tif (!txq)\n\t\treturn false;\n\n\ttxqi = to_txq_info(txq);\n\tif (test_bit(IEEE80211_TXQ_NO_AMSDU, &txqi->flags))\n\t\treturn false;\n\n\tif (sta->sta.max_rc_amsdu_len)\n\t\tmax_amsdu_len = min_t(int, max_amsdu_len,\n\t\t\t\t      sta->sta.max_rc_amsdu_len);\n\n\tif (sta->sta.max_tid_amsdu_len[tid])\n\t\tmax_amsdu_len = min_t(int, max_amsdu_len,\n\t\t\t\t      sta->sta.max_tid_amsdu_len[tid]);\n\n\tflow_idx = fq_flow_idx(fq, skb);\n\n\tspin_lock_bh(&fq->lock);\n\n\t/* TODO: Ideally aggregation should be done on dequeue to remain\n\t * responsive to environment changes.\n\t */\n\n\ttin = &txqi->tin;\n\tflow = fq_flow_classify(fq, tin, flow_idx, skb);\n\thead = skb_peek_tail(&flow->queue);\n\tif (!head || skb_is_gso(head))\n\t\tgoto out;\n\n\torig_truesize = head->truesize;\n\torig_len = head->len;\n\n\tif (skb->len + head->len > max_amsdu_len)\n\t\tgoto out;\n\n\tnfrags = 1 + skb_shinfo(skb)->nr_frags;\n\tnfrags += 1 + skb_shinfo(head)->nr_frags;\n\tfrag_tail = &skb_shinfo(head)->frag_list;\n\twhile (*frag_tail) {\n\t\tnfrags += 1 + skb_shinfo(*frag_tail)->nr_frags;\n\t\tfrag_tail = &(*frag_tail)->next;\n\t\tn++;\n\t}\n\n\tif (max_subframes && n > max_subframes)\n\t\tgoto out;\n\n\tif (max_frags && nfrags > max_frags)\n\t\tgoto out;\n\n\tif (!drv_can_aggregate_in_amsdu(local, head, skb))\n\t\tgoto out;\n\n\tif (!ieee80211_amsdu_prepare_head(sdata, fast_tx, head))\n\t\tgoto out;\n\n\t/*\n\t * Pad out the previous subframe to a multiple of 4 by adding the\n\t * padding to the next one, that's being added. Note that head->len\n\t * is the length of the full A-MSDU, but that works since each time\n\t * we add a new subframe we pad out the previous one to a multiple\n\t * of 4 and thus it no longer matters in the next round.\n\t */\n\thdrlen = fast_tx->hdr_len - sizeof(rfc1042_header);\n\tif ((head->len - hdrlen) & 3)\n\t\tpad = 4 - ((head->len - hdrlen) & 3);\n\n\tif (!ieee80211_amsdu_realloc_pad(local, skb, sizeof(rfc1042_header) +\n\t\t\t\t\t\t     2 + pad))\n\t\tgoto out_recalc;\n\n\tret = true;\n\tdata = skb_push(skb, ETH_ALEN + 2);\n\tmemmove(data, data + ETH_ALEN + 2, 2 * ETH_ALEN);\n\n\tdata += 2 * ETH_ALEN;\n\tlen = cpu_to_be16(subframe_len);\n\tmemcpy(data, &len, 2);\n\tmemcpy(data + 2, rfc1042_header, sizeof(rfc1042_header));\n\n\tmemset(skb_push(skb, pad), 0, pad);\n\n\thead->len += skb->len;\n\thead->data_len += skb->len;\n\t*frag_tail = skb;\n\nout_recalc:\n\tfq->memory_usage += head->truesize - orig_truesize;\n\tif (head->len != orig_len) {\n\t\tflow->backlog += head->len - orig_len;\n\t\ttin->backlog_bytes += head->len - orig_len;\n\t}\nout:\n\tspin_unlock_bh(&fq->lock);\n\n\treturn ret;\n}\n\n/*\n * Can be called while the sta lock is held. Anything that can cause packets to\n * be generated will cause deadlock!\n */\nstatic void ieee80211_xmit_fast_finish(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct sta_info *sta, u8 pn_offs,\n\t\t\t\t       struct ieee80211_key *key,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tu8 tid = IEEE80211_NUM_TIDS;\n\n\tif (key)\n\t\tinfo->control.hw_key = &key->conf;\n\n\tdev_sw_netstats_tx_add(skb->dev, 1, skb->len);\n\n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\t\thdr->seq_ctrl = ieee80211_tx_next_seq(sta, tid);\n\t} else {\n\t\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\t\thdr->seq_ctrl = cpu_to_le16(sdata->sequence_number);\n\t\tsdata->sequence_number += 0x10;\n\t}\n\n\tif (skb_shinfo(skb)->gso_size)\n\t\tsta->tx_stats.msdu[tid] +=\n\t\t\tDIV_ROUND_UP(skb->len, skb_shinfo(skb)->gso_size);\n\telse\n\t\tsta->tx_stats.msdu[tid]++;\n\n\tinfo->hw_queue = sdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\t/* statistics normally done by ieee80211_tx_h_stats (but that\n\t * has to consider fragmentation, so is more complex)\n\t */\n\tsta->tx_stats.bytes[skb_get_queue_mapping(skb)] += skb->len;\n\tsta->tx_stats.packets[skb_get_queue_mapping(skb)]++;\n\n\tif (pn_offs) {\n\t\tu64 pn;\n\t\tu8 *crypto_hdr = skb->data + pn_offs;\n\n\t\tswitch (key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tpn = atomic64_inc_return(&key->conf.tx_pn);\n\t\t\tcrypto_hdr[0] = pn;\n\t\t\tcrypto_hdr[1] = pn >> 8;\n\t\t\tcrypto_hdr[3] = 0x20 | (key->conf.keyidx << 6);\n\t\t\tcrypto_hdr[4] = pn >> 16;\n\t\t\tcrypto_hdr[5] = pn >> 24;\n\t\t\tcrypto_hdr[6] = pn >> 32;\n\t\t\tcrypto_hdr[7] = pn >> 40;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sta_info *sta,\n\t\t\t\tstruct ieee80211_fast_tx *fast_tx,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu16 ethertype = (skb->data[12] << 8) | skb->data[13];\n\tint extra_head = fast_tx->hdr_len - (ETH_HLEN - 2);\n\tint hw_headroom = sdata->local->hw.extra_tx_headroom;\n\tstruct ethhdr eth;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_hdr *hdr = (void *)fast_tx->hdr;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result r;\n\tstruct tid_ampdu_tx *tid_tx = NULL;\n\tu8 tid = IEEE80211_NUM_TIDS;\n\n\t/* control port protocol needs a lot of special handling */\n\tif (cpu_to_be16(ethertype) == sdata->control_port_protocol)\n\t\treturn false;\n\n\t/* only RFC 1042 SNAP */\n\tif (ethertype < ETH_P_802_3_MIN)\n\t\treturn false;\n\n\t/* don't handle TX status request here either */\n\tif (skb->sk && skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)\n\t\treturn false;\n\n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\t\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (tid_tx) {\n\t\t\tif (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state))\n\t\t\t\treturn false;\n\t\t\tif (tid_tx->timeout)\n\t\t\t\ttid_tx->last_tx = jiffies;\n\t\t}\n\t}\n\n\t/* after this point (skb is modified) we cannot return false */\n\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *tmp_skb = skb;\n\n\t\tskb = skb_clone(skb, GFP_ATOMIC);\n\t\tkfree_skb(tmp_skb);\n\n\t\tif (!skb)\n\t\t\treturn true;\n\t}\n\n\tif ((hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) &&\n\t    ieee80211_amsdu_aggregate(sdata, sta, fast_tx, skb))\n\t\treturn true;\n\n\t/* will not be crypto-handled beyond what we do here, so use false\n\t * as the may-encrypt argument for the resize to not account for\n\t * more room than we already have in 'extra_head'\n\t */\n\tif (unlikely(ieee80211_skb_resize(sdata, skb,\n\t\t\t\t\t  max_t(int, extra_head + hw_headroom -\n\t\t\t\t\t\t     skb_headroom(skb), 0),\n\t\t\t\t\t  ENCRYPT_NO))) {\n\t\tkfree_skb(skb);\n\t\treturn true;\n\t}\n\n\tmemcpy(&eth, skb->data, ETH_HLEN - 2);\n\thdr = skb_push(skb, extra_head);\n\tmemcpy(skb->data, fast_tx->hdr, fast_tx->hdr_len);\n\tmemcpy(skb->data + fast_tx->da_offs, eth.h_dest, ETH_ALEN);\n\tmemcpy(skb->data + fast_tx->sa_offs, eth.h_source, ETH_ALEN);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(info, 0, sizeof(*info));\n\tinfo->band = fast_tx->band;\n\tinfo->control.vif = &sdata->vif;\n\tinfo->flags = IEEE80211_TX_CTL_FIRST_FRAGMENT |\n\t\t      IEEE80211_TX_CTL_DONTFRAG |\n\t\t      (tid_tx ? IEEE80211_TX_CTL_AMPDU : 0);\n\tinfo->control.flags = IEEE80211_TX_CTRL_FAST_XMIT;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tif (local->force_tx_status)\n\t\tinfo->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n#endif\n\n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\t\t*ieee80211_get_qos_ctl(hdr) = tid;\n\t}\n\n\t__skb_queue_head_init(&tx.skbs);\n\n\ttx.flags = IEEE80211_TX_UNICAST;\n\ttx.local = local;\n\ttx.sdata = sdata;\n\ttx.sta = sta;\n\ttx.key = fast_tx->key;\n\n\tif (!ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL)) {\n\t\ttx.skb = skb;\n\t\tr = ieee80211_tx_h_rate_ctrl(&tx);\n\t\tskb = tx.skb;\n\t\ttx.skb = NULL;\n\n\t\tif (r != TX_CONTINUE) {\n\t\t\tif (r != TX_QUEUED)\n\t\t\t\tkfree_skb(skb);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (ieee80211_queue_skb(local, sdata, sta, skb))\n\t\treturn true;\n\n\tieee80211_xmit_fast_finish(sdata, sta, fast_tx->pn_offs,\n\t\t\t\t   fast_tx->key, skb);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\n\t__skb_queue_tail(&tx.skbs, skb);\n\tieee80211_tx_frags(local, &sdata->vif, sta, &tx.skbs, false);\n\treturn true;\n}\n\nstruct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_txq *txq)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct txq_info *txqi = container_of(txq, struct txq_info, txq);\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb = NULL;\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin = &txqi->tin;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result r;\n\tstruct ieee80211_vif *vif = txq->vif;\n\n\tWARN_ON_ONCE(softirq_count() == 0);\n\n\tif (!ieee80211_txq_airtime_check(hw, txq))\n\t\treturn NULL;\n\nbegin:\n\tspin_lock_bh(&fq->lock);\n\n\tif (test_bit(IEEE80211_TXQ_STOP, &txqi->flags) ||\n\t    test_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags))\n\t\tgoto out;\n\n\tif (vif->txqs_stopped[txq->ac]) {\n\t\tset_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags);\n\t\tgoto out;\n\t}\n\n\t/* Make sure fragments stay together. */\n\tskb = __skb_dequeue(&txqi->frags);\n\tif (unlikely(skb)) {\n\t\tif (!(IEEE80211_SKB_CB(skb)->control.flags &\n\t\t\t\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING))\n\t\t\tgoto out;\n\t\tIEEE80211_SKB_CB(skb)->control.flags &=\n\t\t\t~IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t} else {\n\t\tskb = fq_tin_dequeue(fq, tin, fq_tin_dequeue_func);\n\t}\n\n\tif (!skb)\n\t\tgoto out;\n\n\tspin_unlock_bh(&fq->lock);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tmemset(&tx, 0, sizeof(tx));\n\t__skb_queue_head_init(&tx.skbs);\n\ttx.local = local;\n\ttx.skb = skb;\n\ttx.sdata = vif_to_sdata(info->control.vif);\n\n\tif (txq->sta) {\n\t\ttx.sta = container_of(txq->sta, struct sta_info, sta);\n\t\t/*\n\t\t * Drop unicast frames to unauthorised stations unless they are\n\t\t * injected frames or EAPOL frames from the local station.\n\t\t */\n\t\tif (unlikely(!(info->flags & IEEE80211_TX_CTL_INJECTED) &&\n\t\t\t     ieee80211_is_data(hdr->frame_control) &&\n\t\t\t     !ieee80211_vif_is_mesh(&tx.sdata->vif) &&\n\t\t\t     tx.sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t\t\t     !is_multicast_ether_addr(hdr->addr1) &&\n\t\t\t     !test_sta_flag(tx.sta, WLAN_STA_AUTHORIZED) &&\n\t\t\t     (!(info->control.flags &\n\t\t\t\tIEEE80211_TX_CTRL_PORT_CTRL_PROTO) ||\n\t\t\t      !ether_addr_equal(tx.sdata->vif.addr,\n\t\t\t\t\t\thdr->addr2)))) {\n\t\t\tI802_DEBUG_INC(local->tx_handlers_drop_unauth_port);\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\n\t/*\n\t * The key can be removed while the packet was queued, so need to call\n\t * this here to get the current key.\n\t */\n\tr = ieee80211_tx_h_select_key(&tx);\n\tif (r != TX_CONTINUE) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\tgoto begin;\n\t}\n\n\tif (test_bit(IEEE80211_TXQ_AMPDU, &txqi->flags))\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\telse\n\t\tinfo->flags &= ~IEEE80211_TX_CTL_AMPDU;\n\n\tif (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)\n\t\tgoto encap_out;\n\n\tif (info->control.flags & IEEE80211_TX_CTRL_FAST_XMIT) {\n\t\tstruct sta_info *sta = container_of(txq->sta, struct sta_info,\n\t\t\t\t\t\t    sta);\n\t\tu8 pn_offs = 0;\n\n\t\tif (tx.key &&\n\t\t    (tx.key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV))\n\t\t\tpn_offs = ieee80211_hdrlen(hdr->frame_control);\n\n\t\tieee80211_xmit_fast_finish(sta->sdata, sta, pn_offs,\n\t\t\t\t\t   tx.key, skb);\n\t} else {\n\t\tif (invoke_tx_handlers_late(&tx))\n\t\t\tgoto begin;\n\n\t\tskb = __skb_dequeue(&tx.skbs);\n\n\t\tif (!skb_queue_empty(&tx.skbs)) {\n\t\t\tspin_lock_bh(&fq->lock);\n\t\t\tskb_queue_splice_tail(&tx.skbs, &txqi->frags);\n\t\t\tspin_unlock_bh(&fq->lock);\n\t\t}\n\t}\n\n\tif (skb_has_frag_list(skb) &&\n\t    !ieee80211_hw_check(&local->hw, TX_FRAG_LIST)) {\n\t\tif (skb_linearize(skb)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\n\tswitch (tx.sdata->vif.type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (tx.sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tvif = &tx.sdata->vif;\n\t\t\tbreak;\n\t\t}\n\t\ttx.sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tx.sdata) {\n\t\t\tvif = &tx.sdata->vif;\n\t\t\tinfo->hw_queue =\n\t\t\t\tvif->hw_queue[skb_get_queue_mapping(skb)];\n\t\t} else if (ieee80211_hw_check(&local->hw, QUEUE_CONTROL)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t} else {\n\t\t\tvif = NULL;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\ttx.sdata = container_of(tx.sdata->bss,\n\t\t\t\t\tstruct ieee80211_sub_if_data, u.ap);\n\t\tfallthrough;\n\tdefault:\n\t\tvif = &tx.sdata->vif;\n\t\tbreak;\n\t}\n\nencap_out:\n\tIEEE80211_SKB_CB(skb)->control.vif = vif;\n\n\tif (vif &&\n\t    wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {\n\t\tbool ampdu = txq->ac != IEEE80211_AC_VO;\n\t\tu32 airtime;\n\n\t\tairtime = ieee80211_calc_expected_tx_airtime(hw, vif, txq->sta,\n\t\t\t\t\t\t\t     skb->len, ampdu);\n\t\tif (airtime) {\n\t\t\tairtime = ieee80211_info_set_tx_time_est(info, airtime);\n\t\t\tieee80211_sta_update_pending_airtime(local, tx.sta,\n\t\t\t\t\t\t\t     txq->ac,\n\t\t\t\t\t\t\t     airtime,\n\t\t\t\t\t\t\t     false);\n\t\t}\n\t}\n\n\treturn skb;\n\nout:\n\tspin_unlock_bh(&fq->lock);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_tx_dequeue);\n\nstruct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_txq *ret = NULL;\n\tstruct txq_info *txqi = NULL, *head = NULL;\n\tbool found_eligible_txq = false;\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\n begin:\n\ttxqi = list_first_entry_or_null(&local->active_txqs[ac],\n\t\t\t\t\tstruct txq_info,\n\t\t\t\t\tschedule_order);\n\tif (!txqi)\n\t\tgoto out;\n\n\tif (txqi == head) {\n\t\tif (!found_eligible_txq)\n\t\t\tgoto out;\n\t\telse\n\t\t\tfound_eligible_txq = false;\n\t}\n\n\tif (!head)\n\t\thead = txqi;\n\n\tif (txqi->txq.sta) {\n\t\tstruct sta_info *sta = container_of(txqi->txq.sta,\n\t\t\t\t\t\t    struct sta_info, sta);\n\t\tbool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);\n\t\ts64 deficit = sta->airtime[txqi->txq.ac].deficit;\n\n\t\tif (aql_check)\n\t\t\tfound_eligible_txq = true;\n\n\t\tif (deficit < 0)\n\t\t\tsta->airtime[txqi->txq.ac].deficit +=\n\t\t\t\tsta->airtime_weight;\n\n\t\tif (deficit < 0 || !aql_check) {\n\t\t\tlist_move_tail(&txqi->schedule_order,\n\t\t\t\t       &local->active_txqs[txqi->txq.ac]);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\n\n\tif (txqi->schedule_round == local->schedule_round[ac])\n\t\tgoto out;\n\n\tlist_del_init(&txqi->schedule_order);\n\ttxqi->schedule_round = local->schedule_round[ac];\n\tret = &txqi->txq;\n\nout:\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_next_txq);\n\nvoid __ieee80211_schedule_txq(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq,\n\t\t\t      bool force)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct txq_info *txqi = to_txq_info(txq);\n\n\tspin_lock_bh(&local->active_txq_lock[txq->ac]);\n\n\tif (list_empty(&txqi->schedule_order) &&\n\t    (force || !skb_queue_empty(&txqi->frags) ||\n\t     txqi->tin.backlog_packets)) {\n\t\t/* If airtime accounting is active, always enqueue STAs at the\n\t\t * head of the list to ensure that they only get moved to the\n\t\t * back by the airtime DRR scheduler once they have a negative\n\t\t * deficit. A station that already has a negative deficit will\n\t\t * get immediately moved to the back of the list on the next\n\t\t * call to ieee80211_next_txq().\n\t\t */\n\t\tif (txqi->txq.sta && local->airtime_flags &&\n\t\t    wiphy_ext_feature_isset(local->hw.wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\t\tlist_add(&txqi->schedule_order,\n\t\t\t\t &local->active_txqs[txq->ac]);\n\t\telse\n\t\t\tlist_add_tail(&txqi->schedule_order,\n\t\t\t\t      &local->active_txqs[txq->ac]);\n\t}\n\n\tspin_unlock_bh(&local->active_txq_lock[txq->ac]);\n}\nEXPORT_SYMBOL(__ieee80211_schedule_txq);\n\nDEFINE_STATIC_KEY_FALSE(aql_disable);\n\nbool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_txq *txq)\n{\n\tstruct sta_info *sta;\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tif (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))\n\t\treturn true;\n\n\tif (static_branch_unlikely(&aql_disable))\n\t\treturn true;\n\n\tif (!txq->sta)\n\t\treturn true;\n\n\tif (unlikely(txq->tid == IEEE80211_NUM_TIDS))\n\t\treturn true;\n\n\tsta = container_of(txq->sta, struct sta_info, sta);\n\tif (atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <\n\t    sta->airtime[txq->ac].aql_limit_low)\n\t\treturn true;\n\n\tif (atomic_read(&local->aql_total_pending_airtime) <\n\t    local->aql_threshold &&\n\t    atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <\n\t    sta->airtime[txq->ac].aql_limit_high)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(ieee80211_txq_airtime_check);\n\nbool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_txq *txq)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct txq_info *iter, *tmp, *txqi = to_txq_info(txq);\n\tstruct sta_info *sta;\n\tu8 ac = txq->ac;\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\n\tif (!txqi->txq.sta)\n\t\tgoto out;\n\n\tif (list_empty(&txqi->schedule_order))\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],\n\t\t\t\t schedule_order) {\n\t\tif (iter == txqi)\n\t\t\tbreak;\n\n\t\tif (!iter->txq.sta) {\n\t\t\tlist_move_tail(&iter->schedule_order,\n\t\t\t\t       &local->active_txqs[ac]);\n\t\t\tcontinue;\n\t\t}\n\t\tsta = container_of(iter->txq.sta, struct sta_info, sta);\n\t\tif (sta->airtime[ac].deficit < 0)\n\t\t\tsta->airtime[ac].deficit += sta->airtime_weight;\n\t\tlist_move_tail(&iter->schedule_order, &local->active_txqs[ac]);\n\t}\n\n\tsta = container_of(txqi->txq.sta, struct sta_info, sta);\n\tif (sta->airtime[ac].deficit >= 0)\n\t\tgoto out;\n\n\tsta->airtime[ac].deficit += sta->airtime_weight;\n\tlist_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\n\treturn false;\nout:\n\tif (!list_empty(&txqi->schedule_order))\n\t\tlist_del_init(&txqi->schedule_order);\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_txq_may_transmit);\n\nvoid ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\tlocal->schedule_round[ac]++;\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n}\nEXPORT_SYMBOL(ieee80211_txq_schedule_start);\n\nvoid __ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  u32 info_flags,\n\t\t\t\t  u32 ctrl_flags,\n\t\t\t\t  u64 *cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct sk_buff *next;\n\n\tif (unlikely(skb->len < ETH_HLEN)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta))\n\t\tgoto out_free;\n\n\tif (IS_ERR(sta))\n\t\tsta = NULL;\n\n\tif (local->ops->wake_tx_queue) {\n\t\tu16 queue = __ieee80211_select_queue(sdata, sta, skb);\n\t\tskb_set_queue_mapping(skb, queue);\n\t\tskb_get_hash(skb);\n\t}\n\n\tif (sta) {\n\t\tstruct ieee80211_fast_tx *fast_tx;\n\n\t\tsk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);\n\n\t\tfast_tx = rcu_dereference(sta->fast_tx);\n\n\t\tif (fast_tx &&\n\t\t    ieee80211_xmit_fast(sdata, sta, fast_tx, skb))\n\t\t\tgoto out;\n\t}\n\n\tif (skb_is_gso(skb)) {\n\t\tstruct sk_buff *segs;\n\n\t\tsegs = skb_gso_segment(skb, 0);\n\t\tif (IS_ERR(segs)) {\n\t\t\tgoto out_free;\n\t\t} else if (segs) {\n\t\t\tconsume_skb(skb);\n\t\t\tskb = segs;\n\t\t}\n\t} else {\n\t\t/* we cannot process non-linear frames on this path */\n\t\tif (skb_linearize(skb)) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* the frame could be fragmented, software-encrypted, and other\n\t\t * things so we cannot really handle checksum offload with it -\n\t\t * fix it up in software before we handle anything else.\n\t\t */\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tskb_set_transport_header(skb,\n\t\t\t\t\t\t skb_checksum_start_offset(skb));\n\t\t\tif (skb_checksum_help(skb))\n\t\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tskb_list_walk_safe(skb, skb, next) {\n\t\tskb_mark_not_on_list(skb);\n\n\t\tif (skb->protocol == sdata->control_port_protocol)\n\t\t\tctrl_flags |= IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP;\n\n\t\tskb = ieee80211_build_hdr(sdata, skb, info_flags,\n\t\t\t\t\t  sta, ctrl_flags, cookie);\n\t\tif (IS_ERR(skb)) {\n\t\t\tkfree_skb_list(next);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev_sw_netstats_tx_add(dev, 1, skb->len);\n\n\t\tieee80211_xmit(sdata, sta, skb);\n\t}\n\tgoto out;\n out_free:\n\tkfree_skb(skb);\n out:\n\trcu_read_unlock();\n}\n\nstatic int ieee80211_change_da(struct sk_buff *skb, struct sta_info *sta)\n{\n\tstruct ethhdr *eth;\n\tint err;\n\n\terr = skb_ensure_writable(skb, ETH_HLEN);\n\tif (unlikely(err))\n\t\treturn err;\n\n\teth = (void *)skb->data;\n\tether_addr_copy(eth->h_dest, sta->sta.addr);\n\n\treturn 0;\n}\n\nstatic bool ieee80211_multicast_to_unicast(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tconst struct ethhdr *eth = (void *)skb->data;\n\tconst struct vlan_ethhdr *ethvlan = (void *)skb->data;\n\t__be16 ethertype;\n\n\tif (likely(!is_multicast_ether_addr(eth->h_dest)))\n\t\treturn false;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (sdata->u.vlan.sta)\n\t\t\treturn false;\n\t\tif (sdata->wdev.use_4addr)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\t/* check runtime toggle for this bss */\n\t\tif (!sdata->bss->multicast_to_unicast)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/* multicast to unicast conversion only for some payload */\n\tethertype = eth->h_proto;\n\tif (ethertype == htons(ETH_P_8021Q) && skb->len >= VLAN_ETH_HLEN)\n\t\tethertype = ethvlan->h_vlan_encapsulated_proto;\n\tswitch (ethertype) {\n\tcase htons(ETH_P_ARP):\n\tcase htons(ETH_P_IP):\n\tcase htons(ETH_P_IPV6):\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void\nieee80211_convert_to_unicast(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     struct sk_buff_head *queue)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tconst struct ethhdr *eth = (struct ethhdr *)skb->data;\n\tstruct sta_info *sta, *first = NULL;\n\tstruct sk_buff *cloned_skb;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\t/* AP-VLAN mismatch */\n\t\t\tcontinue;\n\t\tif (unlikely(ether_addr_equal(eth->h_source, sta->sta.addr)))\n\t\t\t/* do not send back to source */\n\t\t\tcontinue;\n\t\tif (!first) {\n\t\t\tfirst = sta;\n\t\t\tcontinue;\n\t\t}\n\t\tcloned_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!cloned_skb)\n\t\t\tgoto multicast;\n\t\tif (unlikely(ieee80211_change_da(cloned_skb, sta))) {\n\t\t\tdev_kfree_skb(cloned_skb);\n\t\t\tgoto multicast;\n\t\t}\n\t\t__skb_queue_tail(queue, cloned_skb);\n\t}\n\n\tif (likely(first)) {\n\t\tif (unlikely(ieee80211_change_da(skb, first)))\n\t\t\tgoto multicast;\n\t\t__skb_queue_tail(queue, skb);\n\t} else {\n\t\t/* no STA connected, drop */\n\t\tkfree_skb(skb);\n\t\tskb = NULL;\n\t}\n\n\tgoto out;\nmulticast:\n\t__skb_queue_purge(queue);\n\t__skb_queue_tail(queue, skb);\nout:\n\trcu_read_unlock();\n}\n\n/**\n * ieee80211_subif_start_xmit - netif start_xmit function for 802.3 vifs\n * @skb: packet to be sent\n * @dev: incoming interface\n *\n * On failure skb will be freed.\n */\nnetdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tif (unlikely(ieee80211_multicast_to_unicast(skb, dev))) {\n\t\tstruct sk_buff_head queue;\n\n\t\t__skb_queue_head_init(&queue);\n\t\tieee80211_convert_to_unicast(skb, dev, &queue);\n\t\twhile ((skb = __skb_dequeue(&queue)))\n\t\t\t__ieee80211_subif_start_xmit(skb, dev, 0, 0, NULL);\n\t} else {\n\t\t__ieee80211_subif_start_xmit(skb, dev, 0, 0, NULL);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic bool ieee80211_tx_8023(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, int led_len,\n\t\t\t      struct sta_info *sta,\n\t\t\t      bool txpending)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_control control = {};\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sta *pubsta = NULL;\n\tunsigned long flags;\n\tint q = info->hw_queue;\n\n\tif (sta)\n\t\tsk_pacing_shift_update(skb->sk, local->hw.tx_sk_pacing_shift);\n\n\tif (ieee80211_queue_skb(local, sdata, sta, skb))\n\t\treturn true;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\n\tif (local->queue_stop_reasons[q] ||\n\t    (!txpending && !skb_queue_empty(&local->pending[q]))) {\n\t\tif (txpending)\n\t\t\tskb_queue_head(&local->pending[q], skb);\n\t\telse\n\t\t\tskb_queue_tail(&local->pending[q], skb);\n\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\t\treturn false;\n\t}\n\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\tif (sta && sta->uploaded)\n\t\tpubsta = &sta->sta;\n\n\tcontrol.sta = pubsta;\n\n\tdrv_tx(local, &control, skb);\n\n\treturn true;\n}\n\nstatic void ieee80211_8023_xmit(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct net_device *dev, struct sta_info *sta,\n\t\t\t\tstruct ieee80211_key *key, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct tid_ampdu_tx *tid_tx;\n\tu8 tid;\n\n\tif (local->ops->wake_tx_queue) {\n\t\tu16 queue = __ieee80211_select_queue(sdata, sta, skb);\n\t\tskb_set_queue_mapping(skb, queue);\n\t\tskb_get_hash(skb);\n\t}\n\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state))\n\t\tgoto out_free;\n\n\tmemset(info, 0, sizeof(*info));\n\n\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\tif (tid_tx) {\n\t\tif (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\t/* fall back to non-offload slow path */\n\t\t\t__ieee80211_subif_start_xmit(skb, dev, 0, 0, NULL);\n\t\t\treturn;\n\t\t}\n\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\tif (tid_tx->timeout)\n\t\t\ttid_tx->last_tx = jiffies;\n\t}\n\n\tif (unlikely(skb->sk &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS))\n\t\tinfo->ack_frame_id = ieee80211_store_ack_skb(local, skb,\n\t\t\t\t\t\t\t     &info->flags, NULL);\n\n\tinfo->hw_queue = sdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\tdev_sw_netstats_tx_add(dev, 1, skb->len);\n\n\tsta->tx_stats.bytes[skb_get_queue_mapping(skb)] += skb->len;\n\tsta->tx_stats.packets[skb_get_queue_mapping(skb)]++;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\n\tinfo->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;\n\tinfo->control.vif = &sdata->vif;\n\n\tif (key)\n\t\tinfo->control.hw_key = &key->conf;\n\n\tieee80211_tx_8023(sdata, skb, skb->len, sta, false);\n\n\treturn;\n\nout_free:\n\tkfree_skb(skb);\n}\n\nnetdev_tx_t ieee80211_subif_start_xmit_8023(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ethhdr *ehdr = (struct ethhdr *)skb->data;\n\tstruct ieee80211_key *key;\n\tstruct sta_info *sta;\n\n\tif (unlikely(skb->len < ETH_HLEN)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_ERR_OR_NULL(sta) || !sta->uploaded ||\n\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED) ||\n\t    sdata->control_port_protocol == ehdr->h_proto))\n\t\tgoto skip_offload;\n\n\tkey = rcu_dereference(sta->ptk[sta->ptk_idx]);\n\tif (!key)\n\t\tkey = rcu_dereference(sdata->default_unicast_key);\n\n\tif (key && (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE) ||\n\t\t    key->conf.cipher == WLAN_CIPHER_SUITE_TKIP))\n\t\tgoto skip_offload;\n\n\tieee80211_8023_xmit(sdata, dev, sta, key, skb);\n\tgoto out;\n\nskip_offload:\n\tieee80211_subif_start_xmit(skb, dev);\nout:\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n}\n\nstruct sk_buff *\nieee80211_build_data_template(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, u32 info_flags)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_data tx = {\n\t\t.local = sdata->local,\n\t\t.sdata = sdata,\n\t};\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {\n\t\tkfree_skb(skb);\n\t\tskb = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tskb = ieee80211_build_hdr(sdata, skb, info_flags, sta, 0, NULL);\n\tif (IS_ERR(skb))\n\t\tgoto out;\n\n\thdr = (void *)skb->data;\n\ttx.sta = sta_info_get(sdata, hdr->addr1);\n\ttx.skb = skb;\n\n\tif (ieee80211_tx_h_select_key(&tx) != TX_CONTINUE) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn skb;\n}\n\n/*\n * ieee80211_clear_tx_pending may not be called in a context where\n * it is possible that it packets could come in again.\n */\nvoid ieee80211_clear_tx_pending(struct ieee80211_local *local)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\twhile ((skb = skb_dequeue(&local->pending[i])) != NULL)\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n}\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead,\n * which in this case means re-queued -- take as an indication to stop sending\n * more pending frames.\n */\nstatic bool ieee80211_tx_pending_skb(struct ieee80211_local *local,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\tstruct ieee80211_hdr *hdr;\n\tbool result;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(info->control.vif);\n\n\tif (info->control.flags & IEEE80211_TX_INTCFL_NEED_TXPROCESSING) {\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (unlikely(!chanctx_conf)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn true;\n\t\t}\n\t\tinfo->band = chanctx_conf->def.chan->band;\n\t\tresult = ieee80211_tx(sdata, NULL, skb, true);\n\t} else if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {\n\t\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (IS_ERR(sta) || (sta && !sta->uploaded))\n\t\t\tsta = NULL;\n\n\t\tresult = ieee80211_tx_8023(sdata, skb, skb->len, sta, true);\n\t} else {\n\t\tstruct sk_buff_head skbs;\n\n\t\t__skb_queue_head_init(&skbs);\n\t\t__skb_queue_tail(&skbs, skb);\n\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tsta = sta_info_get(sdata, hdr->addr1);\n\n\t\tresult = __ieee80211_tx(local, &skbs, skb->len, sta, true);\n\t}\n\n\treturn result;\n}\n\n/*\n * Transmit all pending packets. Called from tasklet.\n */\nvoid ieee80211_tx_pending(struct tasklet_struct *t)\n{\n\tstruct ieee80211_local *local = from_tasklet(local, t,\n\t\t\t\t\t\t     tx_pending_tasklet);\n\tunsigned long flags;\n\tint i;\n\tbool txok;\n\n\trcu_read_lock();\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\t/*\n\t\t * If queue is stopped by something other than due to pending\n\t\t * frames, or we have no pending frames, proceed to next queue.\n\t\t */\n\t\tif (local->queue_stop_reasons[i] ||\n\t\t    skb_queue_empty(&local->pending[i]))\n\t\t\tcontinue;\n\n\t\twhile (!skb_queue_empty(&local->pending[i])) {\n\t\t\tstruct sk_buff *skb = __skb_dequeue(&local->pending[i]);\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\t\tif (WARN_ON(!info->control.vif)) {\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\n\t\t\ttxok = ieee80211_tx_pending_skb(local, skb);\n\t\t\tspin_lock_irqsave(&local->queue_stop_reason_lock,\n\t\t\t\t\t  flags);\n\t\t\tif (!txok)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (skb_queue_empty(&local->pending[i]))\n\t\t\tieee80211_propagate_queue_wake(local, i);\n\t}\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\trcu_read_unlock();\n}\n\n/* functions for drivers to get certain frames */\n\nstatic void __ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ps_data *ps, struct sk_buff *skb,\n\t\t\t\t       bool is_template)\n{\n\tu8 *pos, *tim;\n\tint aid0 = 0;\n\tint i, have_bits = 0, n1, n2;\n\n\t/* Generate bitmap for TIM only if there are any STAs in power save\n\t * mode. */\n\tif (atomic_read(&ps->num_sta_ps) > 0)\n\t\t/* in the hope that this is faster than\n\t\t * checking byte-for-byte */\n\t\thave_bits = !bitmap_empty((unsigned long *)ps->tim,\n\t\t\t\t\t  IEEE80211_MAX_AID+1);\n\tif (!is_template) {\n\t\tif (ps->dtim_count == 0)\n\t\t\tps->dtim_count = sdata->vif.bss_conf.dtim_period - 1;\n\t\telse\n\t\t\tps->dtim_count--;\n\t}\n\n\ttim = pos = skb_put(skb, 6);\n\t*pos++ = WLAN_EID_TIM;\n\t*pos++ = 4;\n\t*pos++ = ps->dtim_count;\n\t*pos++ = sdata->vif.bss_conf.dtim_period;\n\n\tif (ps->dtim_count == 0 && !skb_queue_empty(&ps->bc_buf))\n\t\taid0 = 1;\n\n\tps->dtim_bc_mc = aid0 == 1;\n\n\tif (have_bits) {\n\t\t/* Find largest even number N1 so that bits numbered 1 through\n\t\t * (N1 x 8) - 1 in the bitmap are 0 and number N2 so that bits\n\t\t * (N2 + 1) x 8 through 2007 are 0. */\n\t\tn1 = 0;\n\t\tfor (i = 0; i < IEEE80211_MAX_TIM_LEN; i++) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn1 = i & 0xfe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn2 = n1;\n\t\tfor (i = IEEE80211_MAX_TIM_LEN - 1; i >= n1; i--) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Bitmap control */\n\t\t*pos++ = n1 | aid0;\n\t\t/* Part Virt Bitmap */\n\t\tskb_put(skb, n2 - n1);\n\t\tmemcpy(pos, ps->tim + n1, n2 - n1 + 1);\n\n\t\ttim[1] = n2 - n1 + 4;\n\t} else {\n\t\t*pos++ = aid0; /* Bitmap control */\n\t\t*pos++ = 0; /* Part Virt Bitmap */\n\t}\n}\n\nstatic int ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ps_data *ps, struct sk_buff *skb,\n\t\t\t\t    bool is_template)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\t/*\n\t * Not very nice, but we want to allow the driver to call\n\t * ieee80211_beacon_get() as a response to the set_tim()\n\t * callback. That, however, is already invoked under the\n\t * sta_lock to guarantee consistent and race-free update\n\t * of the tim bitmap in mac80211 and the driver.\n\t */\n\tif (local->tim_in_locked_section) {\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb, is_template);\n\t} else {\n\t\tspin_lock_bh(&local->tim_lock);\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb, is_template);\n\t\tspin_unlock_bh(&local->tim_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic void ieee80211_set_beacon_cntdwn(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct beacon_data *beacon)\n{\n\tstruct probe_resp *resp;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\tint i;\n\tu8 count = beacon->cntdwn_current_counter;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tfor (i = 0; i < IEEE80211_MAX_CNTDWN_COUNTERS_NUM; ++i) {\n\t\tresp = rcu_dereference(sdata->u.ap.probe_resp);\n\n\t\tif (beacon->cntdwn_counter_offsets[i]) {\n\t\t\tif (WARN_ON_ONCE(beacon->cntdwn_counter_offsets[i] >=\n\t\t\t\t\t beacon_data_len)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbeacon_data[beacon->cntdwn_counter_offsets[i]] = count;\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP && resp)\n\t\t\tresp->data[resp->cntdwn_counter_offsets[i]] = count;\n\t}\n\trcu_read_unlock();\n}\n\nstatic u8 __ieee80211_beacon_update_cntdwn(struct beacon_data *beacon)\n{\n\tbeacon->cntdwn_current_counter--;\n\n\t/* the counter should never reach 0 */\n\tWARN_ON_ONCE(!beacon->cntdwn_current_counter);\n\n\treturn beacon->cntdwn_current_counter;\n}\n\nu8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\tu8 count = 0;\n\n\trcu_read_lock();\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tbeacon = rcu_dereference(sdata->u.ap.beacon);\n\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tbeacon = rcu_dereference(sdata->u.ibss.presp);\n\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tbeacon = rcu_dereference(sdata->u.mesh.beacon);\n\n\tif (!beacon)\n\t\tgoto unlock;\n\n\tcount = __ieee80211_beacon_update_cntdwn(beacon);\n\nunlock:\n\trcu_read_unlock();\n\treturn count;\n}\nEXPORT_SYMBOL(ieee80211_beacon_update_cntdwn);\n\nvoid ieee80211_beacon_set_cntdwn(struct ieee80211_vif *vif, u8 counter)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\n\trcu_read_lock();\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tbeacon = rcu_dereference(sdata->u.ap.beacon);\n\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tbeacon = rcu_dereference(sdata->u.ibss.presp);\n\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tbeacon = rcu_dereference(sdata->u.mesh.beacon);\n\n\tif (!beacon)\n\t\tgoto unlock;\n\n\tif (counter < beacon->cntdwn_current_counter)\n\t\tbeacon->cntdwn_current_counter = counter;\n\nunlock:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_beacon_set_cntdwn);\n\nbool ieee80211_beacon_cntdwn_is_complete(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\tint ret = false;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_if_ap *ap = &sdata->u.ap;\n\n\t\tbeacon = rcu_dereference(ap->beacon);\n\t\tif (WARN_ON(!beacon || !beacon->tail))\n\t\t\tgoto out;\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t} else if (vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\n\t\tbeacon = rcu_dereference(ifibss->presp);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else if (vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\tbeacon = rcu_dereference(ifmsh->beacon);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\tif (!beacon->cntdwn_counter_offsets[0])\n\t\tgoto out;\n\n\tif (WARN_ON_ONCE(beacon->cntdwn_counter_offsets[0] > beacon_data_len))\n\t\tgoto out;\n\n\tif (beacon_data[beacon->cntdwn_counter_offsets[0]] == 1)\n\t\tret = true;\n\n out:\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_beacon_cntdwn_is_complete);\n\nstatic int ieee80211_beacon_protect(struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_local *local,\n\t\t\t\t    struct ieee80211_sub_if_data *sdata)\n{\n\tieee80211_tx_result res;\n\tstruct ieee80211_tx_data tx;\n\tstruct sk_buff *check_skb;\n\n\tmemset(&tx, 0, sizeof(tx));\n\ttx.key = rcu_dereference(sdata->default_beacon_key);\n\tif (!tx.key)\n\t\treturn 0;\n\ttx.local = local;\n\ttx.sdata = sdata;\n\t__skb_queue_head_init(&tx.skbs);\n\t__skb_queue_tail(&tx.skbs, skb);\n\tres = ieee80211_tx_h_encrypt(&tx);\n\tcheck_skb = __skb_dequeue(&tx.skbs);\n\t/* we may crash after this, but it'd be a bug in crypto */\n\tWARN_ON(check_skb != skb);\n\tif (WARN_ON_ONCE(res != TX_CONTINUE))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct sk_buff *\n__ieee80211_beacon_get(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif,\n\t\t       struct ieee80211_mutable_offsets *offs,\n\t\t       bool is_template)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct beacon_data *beacon = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sub_if_data *sdata = NULL;\n\tenum nl80211_band band;\n\tstruct ieee80211_tx_rate_control txrc;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tint csa_off_base = 0;\n\n\trcu_read_lock();\n\n\tsdata = vif_to_sdata(vif);\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\n\tif (!ieee80211_sdata_running(sdata) || !chanctx_conf)\n\t\tgoto out;\n\n\tif (offs)\n\t\tmemset(offs, 0, sizeof(*offs));\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_if_ap *ap = &sdata->u.ap;\n\n\t\tbeacon = rcu_dereference(ap->beacon);\n\t\tif (beacon) {\n\t\t\tif (beacon->cntdwn_counter_offsets[0]) {\n\t\t\t\tif (!is_template)\n\t\t\t\t\tieee80211_beacon_update_cntdwn(vif);\n\n\t\t\t\tieee80211_set_beacon_cntdwn(sdata, beacon);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * headroom, head length,\n\t\t\t * tail length and maximum TIM length\n\t\t\t */\n\t\t\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t\t    beacon->head_len +\n\t\t\t\t\t    beacon->tail_len + 256 +\n\t\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\t\tif (!skb)\n\t\t\t\tgoto out;\n\n\t\t\tskb_reserve(skb, local->tx_headroom);\n\t\t\tskb_put_data(skb, beacon->head, beacon->head_len);\n\n\t\t\tieee80211_beacon_add_tim(sdata, &ap->ps, skb,\n\t\t\t\t\t\t is_template);\n\n\t\t\tif (offs) {\n\t\t\t\toffs->tim_offset = beacon->head_len;\n\t\t\t\toffs->tim_length = skb->len - beacon->head_len;\n\n\t\t\t\t/* for AP the csa offsets are from tail */\n\t\t\t\tcsa_off_base = skb->len;\n\t\t\t}\n\n\t\t\tif (beacon->tail)\n\t\t\t\tskb_put_data(skb, beacon->tail,\n\t\t\t\t\t     beacon->tail_len);\n\n\t\t\tif (ieee80211_beacon_protect(skb, local, sdata) < 0)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tgoto out;\n\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\t\tstruct ieee80211_hdr *hdr;\n\n\t\tbeacon = rcu_dereference(ifibss->presp);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tif (beacon->cntdwn_counter_offsets[0]) {\n\t\t\tif (!is_template)\n\t\t\t\t__ieee80211_beacon_update_cntdwn(beacon);\n\n\t\t\tieee80211_set_beacon_cntdwn(sdata, beacon);\n\t\t}\n\n\t\tskb = dev_alloc_skb(local->tx_headroom + beacon->head_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tskb_put_data(skb, beacon->head, beacon->head_len);\n\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t IEEE80211_STYPE_BEACON);\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\tbeacon = rcu_dereference(ifmsh->beacon);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tif (beacon->cntdwn_counter_offsets[0]) {\n\t\t\tif (!is_template)\n\t\t\t\t/* TODO: For mesh csa_counter is in TU, so\n\t\t\t\t * decrementing it by one isn't correct, but\n\t\t\t\t * for now we leave it consistent with overall\n\t\t\t\t * mac80211's behavior.\n\t\t\t\t */\n\t\t\t\t__ieee80211_beacon_update_cntdwn(beacon);\n\n\t\t\tieee80211_set_beacon_cntdwn(sdata, beacon);\n\t\t}\n\n\t\tif (ifmsh->sync_ops)\n\t\t\tifmsh->sync_ops->adjust_tsf(sdata, beacon);\n\n\t\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    beacon->head_len +\n\t\t\t\t    256 + /* TIM IE */\n\t\t\t\t    beacon->tail_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tskb_put_data(skb, beacon->head, beacon->head_len);\n\t\tieee80211_beacon_add_tim(sdata, &ifmsh->ps, skb, is_template);\n\n\t\tif (offs) {\n\t\t\toffs->tim_offset = beacon->head_len;\n\t\t\toffs->tim_length = skb->len - beacon->head_len;\n\t\t}\n\n\t\tskb_put_data(skb, beacon->tail, beacon->tail_len);\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\t/* CSA offsets */\n\tif (offs && beacon) {\n\t\tint i;\n\n\t\tfor (i = 0; i < IEEE80211_MAX_CNTDWN_COUNTERS_NUM; i++) {\n\t\t\tu16 csa_off = beacon->cntdwn_counter_offsets[i];\n\n\t\t\tif (!csa_off)\n\t\t\t\tcontinue;\n\n\t\t\toffs->cntdwn_counter_offs[i] = csa_off_base + csa_off;\n\t\t}\n\t}\n\n\tband = chanctx_conf->def.chan->band;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\tinfo->band = band;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\ttxrc.hw = hw;\n\ttxrc.sband = local->hw.wiphy->bands[band];\n\ttxrc.bss_conf = &sdata->vif.bss_conf;\n\ttxrc.skb = skb;\n\ttxrc.reported_rate.idx = -1;\n\tif (sdata->beacon_rate_set && sdata->beacon_rateidx_mask[band])\n\t\ttxrc.rate_idx_mask = sdata->beacon_rateidx_mask[band];\n\telse\n\t\ttxrc.rate_idx_mask = sdata->rc_rateidx_mask[band];\n\ttxrc.bss = true;\n\trate_control_get_rate(sdata, NULL, &txrc);\n\n\tinfo->control.vif = vif;\n\n\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\tIEEE80211_TX_CTL_ASSIGN_SEQ |\n\t\t\tIEEE80211_TX_CTL_FIRST_FRAGMENT;\n out:\n\trcu_read_unlock();\n\treturn skb;\n\n}\n\nstruct sk_buff *\nieee80211_beacon_get_template(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_mutable_offsets *offs)\n{\n\treturn __ieee80211_beacon_get(hw, vif, offs, true);\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_template);\n\nstruct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u16 *tim_offset, u16 *tim_length)\n{\n\tstruct ieee80211_mutable_offsets offs = {};\n\tstruct sk_buff *bcn = __ieee80211_beacon_get(hw, vif, &offs, false);\n\tstruct sk_buff *copy;\n\tstruct ieee80211_supported_band *sband;\n\tint shift;\n\n\tif (!bcn)\n\t\treturn bcn;\n\n\tif (tim_offset)\n\t\t*tim_offset = offs.tim_offset;\n\n\tif (tim_length)\n\t\t*tim_length = offs.tim_length;\n\n\tif (ieee80211_hw_check(hw, BEACON_TX_STATUS) ||\n\t    !hw_to_local(hw)->monitors)\n\t\treturn bcn;\n\n\t/* send a copy to monitor interfaces */\n\tcopy = skb_copy(bcn, GFP_ATOMIC);\n\tif (!copy)\n\t\treturn bcn;\n\n\tshift = ieee80211_vif_get_shift(vif);\n\tsband = ieee80211_get_sband(vif_to_sdata(vif));\n\tif (!sband)\n\t\treturn bcn;\n\n\tieee80211_tx_monitor(hw_to_local(hw), copy, sband, 1, shift, false,\n\t\t\t     NULL);\n\n\treturn bcn;\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_tim);\n\nstruct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ieee80211_if_ap *ap = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct probe_resp *presp = NULL;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tap = &sdata->u.ap;\n\tpresp = rcu_dereference(ap->probe_resp);\n\tif (!presp)\n\t\tgoto out;\n\n\tskb = dev_alloc_skb(presp->len);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb_put_data(skb, presp->data, presp->len);\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tmemset(hdr->addr1, 0, sizeof(hdr->addr1));\n\nout:\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_proberesp_get);\n\nstruct sk_buff *ieee80211_get_fils_discovery_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct fils_discovery_data *tmpl = NULL;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttmpl = rcu_dereference(sdata->u.ap.fils_discovery);\n\tif (!tmpl) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\tskb = dev_alloc_skb(sdata->local->hw.extra_tx_headroom + tmpl->len);\n\tif (skb) {\n\t\tskb_reserve(skb, sdata->local->hw.extra_tx_headroom);\n\t\tskb_put_data(skb, tmpl->data, tmpl->len);\n\t}\n\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_fils_discovery_tmpl);\n\nstruct sk_buff *\nieee80211_get_unsol_bcast_probe_resp_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct unsol_bcast_probe_resp_data *tmpl = NULL;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttmpl = rcu_dereference(sdata->u.ap.unsol_bcast_probe_resp);\n\tif (!tmpl) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\tskb = dev_alloc_skb(sdata->local->hw.extra_tx_headroom + tmpl->len);\n\tif (skb) {\n\t\tskb_reserve(skb, sdata->local->hw.extra_tx_headroom);\n\t\tskb_put_data(skb, tmpl->data, tmpl->len);\n\t}\n\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_unsol_bcast_probe_resp_tmpl);\n\nstruct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_pspoll *pspoll;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tifmgd = &sdata->u.mgd;\n\tlocal = sdata->local;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*pspoll));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tpspoll = skb_put_zero(skb, sizeof(*pspoll));\n\tpspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t    IEEE80211_STYPE_PSPOLL);\n\tpspoll->aid = cpu_to_le16(sdata->vif.bss_conf.aid);\n\n\t/* aid in PS-Poll has its two MSBs each set to 1 */\n\tpspoll->aid |= cpu_to_le16(1 << 15 | 1 << 14);\n\n\tmemcpy(pspoll->bssid, ifmgd->bssid, ETH_ALEN);\n\tmemcpy(pspoll->ta, vif->addr, ETH_ALEN);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_pspoll_get);\n\nstruct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       bool qos_ok)\n{\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\tbool qos = false;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tifmgd = &sdata->u.mgd;\n\tlocal = sdata->local;\n\n\tif (qos_ok) {\n\t\tstruct sta_info *sta;\n\n\t\trcu_read_lock();\n\t\tsta = sta_info_get(sdata, ifmgd->bssid);\n\t\tqos = sta && sta->sta.wme;\n\t\trcu_read_unlock();\n\t}\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom +\n\t\t\t    sizeof(*nullfunc) + 2);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = skb_put_zero(skb, sizeof(*nullfunc));\n\tnullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t      IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t      IEEE80211_FCTL_TODS);\n\tif (qos) {\n\t\t__le16 qoshdr = cpu_to_le16(7);\n\n\t\tBUILD_BUG_ON((IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t      IEEE80211_STYPE_NULLFUNC) !=\n\t\t\t     IEEE80211_STYPE_QOS_NULLFUNC);\n\t\tnullfunc->frame_control |=\n\t\t\tcpu_to_le16(IEEE80211_STYPE_QOS_NULLFUNC);\n\t\tskb->priority = 7;\n\t\tskb_set_queue_mapping(skb, IEEE80211_AC_VO);\n\t\tskb_put_data(skb, &qoshdr, sizeof(qoshdr));\n\t}\n\n\tmemcpy(nullfunc->addr1, ifmgd->bssid, ETH_ALEN);\n\tmemcpy(nullfunc->addr2, vif->addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, ifmgd->bssid, ETH_ALEN);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_nullfunc_get);\n\nstruct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t       const u8 *src_addr,\n\t\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t\t       size_t tailroom)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_hdr_3addr *hdr;\n\tstruct sk_buff *skb;\n\tsize_t ie_ssid_len;\n\tu8 *pos;\n\n\tie_ssid_len = 2 + ssid_len;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*hdr) +\n\t\t\t    ie_ssid_len + tailroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\thdr = skb_put_zero(skb, sizeof(*hdr));\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t IEEE80211_STYPE_PROBE_REQ);\n\teth_broadcast_addr(hdr->addr1);\n\tmemcpy(hdr->addr2, src_addr, ETH_ALEN);\n\teth_broadcast_addr(hdr->addr3);\n\n\tpos = skb_put(skb, ie_ssid_len);\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = ssid_len;\n\tif (ssid_len)\n\t\tmemcpy(pos, ssid, ssid_len);\n\tpos += ssid_len;\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_probereq_get);\n\nvoid ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       const void *frame, size_t frame_len,\n\t\t       const struct ieee80211_tx_info *frame_txctl,\n\t\t       struct ieee80211_rts *rts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\trts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);\n\trts->duration = ieee80211_rts_duration(hw, vif, frame_len,\n\t\t\t\t\t       frame_txctl);\n\tmemcpy(rts->ra, hdr->addr1, sizeof(rts->ra));\n\tmemcpy(rts->ta, hdr->addr2, sizeof(rts->ta));\n}\nEXPORT_SYMBOL(ieee80211_rts_get);\n\nvoid ieee80211_ctstoself_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     const void *frame, size_t frame_len,\n\t\t\t     const struct ieee80211_tx_info *frame_txctl,\n\t\t\t     struct ieee80211_cts *cts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\tcts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);\n\tcts->duration = ieee80211_ctstoself_duration(hw, vif,\n\t\t\t\t\t\t     frame_len, frame_txctl);\n\tmemcpy(cts->ra, hdr->addr1, sizeof(cts->ra));\n}\nEXPORT_SYMBOL(ieee80211_ctstoself_get);\n\nstruct sk_buff *\nieee80211_get_buffered_bc(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_data tx;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ps_data *ps;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(vif);\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\n\tif (!chanctx_conf)\n\t\tgoto out;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct beacon_data *beacon =\n\t\t\t\trcu_dereference(sdata->u.ap.beacon);\n\n\t\tif (!beacon || !beacon->head)\n\t\t\tgoto out;\n\n\t\tps = &sdata->u.ap.ps;\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tps = &sdata->u.mesh.ps;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (ps->dtim_count != 0 || !ps->dtim_bc_mc)\n\t\tgoto out; /* send buffered bc/mc only after DTIM beacon */\n\n\twhile (1) {\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tlocal->total_ps_buffered--;\n\n\t\tif (!skb_queue_empty(&ps->bc_buf) && skb->len >= 2) {\n\t\t\tstruct ieee80211_hdr *hdr =\n\t\t\t\t(struct ieee80211_hdr *) skb->data;\n\t\t\t/* more buffered multicast/broadcast frames ==> set\n\t\t\t * MoreData flag in IEEE 802.11 header to inform PS\n\t\t\t * STAs */\n\t\t\thdr->frame_control |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tsdata = IEEE80211_DEV_TO_SUB_IF(skb->dev);\n\t\tif (!ieee80211_tx_prepare(sdata, &tx, NULL, skb))\n\t\t\tbreak;\n\t\tieee80211_free_txskb(hw, skb);\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\ttx.flags |= IEEE80211_TX_PS_BUFFERED;\n\tinfo->band = chanctx_conf->def.chan->band;\n\n\tif (invoke_tx_handlers(&tx))\n\t\tskb = NULL;\n out:\n\trcu_read_unlock();\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_buffered_bc);\n\nint ieee80211_reserve_tid(struct ieee80211_sta *pubsta, u8 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret;\n\tu32 queues;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/* only some cases are supported right now */\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(tid >= IEEE80211_NUM_UPS))\n\t\treturn -EINVAL;\n\n\tif (sta->reserved_tid == tid) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (sta->reserved_tid != IEEE80211_TID_UNRESERVED) {\n\t\tsdata_err(sdata, \"TID reservation already active\\n\");\n\t\tret = -EALREADY;\n\t\tgoto out;\n\t}\n\n\tieee80211_stop_vif_queues(sdata->local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_RESERVE_TID);\n\n\tsynchronize_net();\n\n\t/* Tear down BA sessions so we stop aggregating on this TID */\n\tif (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION)) {\n\t\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\t\t__ieee80211_stop_tx_ba_session(sta, tid,\n\t\t\t\t\t       AGG_STOP_LOCAL_REQUEST);\n\t}\n\n\tqueues = BIT(sdata->vif.hw_queue[ieee802_1d_to_ac[tid]]);\n\t__ieee80211_flush_queues(local, sdata, queues, false);\n\n\tsta->reserved_tid = tid;\n\n\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_RESERVE_TID);\n\n\tif (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION))\n\t\tclear_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\n\tret = 0;\n out:\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_reserve_tid);\n\nvoid ieee80211_unreserve_tid(struct ieee80211_sta *pubsta, u8 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\tlockdep_assert_held(&sdata->local->sta_mtx);\n\n\t/* only some cases are supported right now */\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (tid != sta->reserved_tid) {\n\t\tsdata_err(sdata, \"TID to unreserve (%d) isn't reserved\\n\", tid);\n\t\treturn;\n\t}\n\n\tsta->reserved_tid = IEEE80211_TID_UNRESERVED;\n}\nEXPORT_SYMBOL(ieee80211_unreserve_tid);\n\nvoid __ieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb, int tid,\n\t\t\t\t enum nl80211_band band)\n{\n\tint ac = ieee80211_ac_from_tid(tid);\n\n\tskb_reset_mac_header(skb);\n\tskb_set_queue_mapping(skb, ac);\n\tskb->priority = tid;\n\n\tskb->dev = sdata->dev;\n\n\t/*\n\t * The other path calling ieee80211_xmit is from the tasklet,\n\t * and while we can handle concurrent transmissions locking\n\t * requirements are that we do not come into tx with bhs on.\n\t */\n\tlocal_bh_disable();\n\tIEEE80211_SKB_CB(skb)->band = band;\n\tieee80211_xmit(sdata, NULL, skb);\n\tlocal_bh_enable();\n}\n\nint ieee80211_tx_control_port(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len,\n\t\t\t      const u8 *dest, __be16 proto, bool unencrypted,\n\t\t\t      u64 *cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct sk_buff *skb;\n\tstruct ethhdr *ehdr;\n\tu32 ctrl_flags = 0;\n\tu32 flags = 0;\n\n\t/* Only accept CONTROL_PORT_PROTOCOL configured in CONNECT/ASSOCIATE\n\t * or Pre-Authentication\n\t */\n\tif (proto != sdata->control_port_protocol &&\n\t    proto != cpu_to_be16(ETH_P_PREAUTH))\n\t\treturn -EINVAL;\n\n\tif (proto == sdata->control_port_protocol)\n\t\tctrl_flags |= IEEE80211_TX_CTRL_PORT_CTRL_PROTO |\n\t\t\t      IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP;\n\n\tif (unencrypted)\n\t\tflags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\n\tif (cookie)\n\t\tctrl_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\n\tflags |= IEEE80211_TX_INTFL_NL80211_FRAME_TX;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom +\n\t\t\t    sizeof(struct ethhdr) + len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom + sizeof(struct ethhdr));\n\n\tskb_put_data(skb, buf, len);\n\n\tehdr = skb_push(skb, sizeof(struct ethhdr));\n\tmemcpy(ehdr->h_dest, dest, ETH_ALEN);\n\tmemcpy(ehdr->h_source, sdata->vif.addr, ETH_ALEN);\n\tehdr->h_proto = proto;\n\n\tskb->dev = dev;\n\tskb->protocol = proto;\n\tskb_reset_network_header(skb);\n\tskb_reset_mac_header(skb);\n\n\t/* update QoS header to prioritize control port frames if possible,\n\t * priorization also happens for control port frames send over\n\t * AF_PACKET\n\t */\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta) == 0 && !IS_ERR(sta)) {\n\t\tu16 queue = __ieee80211_select_queue(sdata, sta, skb);\n\n\t\tskb_set_queue_mapping(skb, queue);\n\t\tskb_get_hash(skb);\n\t}\n\n\trcu_read_unlock();\n\n\t/* mutex lock is only needed for incrementing the cookie counter */\n\tmutex_lock(&local->mtx);\n\n\tlocal_bh_disable();\n\t__ieee80211_subif_start_xmit(skb, skb->dev, flags, ctrl_flags, cookie);\n\tlocal_bh_enable();\n\n\tmutex_unlock(&local->mtx);\n\n\treturn 0;\n}\n\nint ieee80211_probe_mesh_link(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + len +\n\t\t\t    30 + /* header size */\n\t\t\t    18); /* 11s header size */\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tskb_put_data(skb, buf, len);\n\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_802_3);\n\tskb_reset_network_header(skb);\n\tskb_reset_mac_header(skb);\n\n\tlocal_bh_disable();\n\t__ieee80211_subif_start_xmit(skb, skb->dev, 0,\n\t\t\t\t     IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP,\n\t\t\t\t     NULL);\n\tlocal_bh_enable();\n\n\treturn 0;\n}\n"], "fixing_code": ["/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * mac80211 <-> driver interface\n *\n * Copyright 2002-2005, Devicescape Software, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n * Copyright 2007-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright (C) 2015 - 2017 Intel Deutschland GmbH\n * Copyright (C) 2018 - 2020 Intel Corporation\n */\n\n#ifndef MAC80211_H\n#define MAC80211_H\n\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/ieee80211.h>\n#include <net/cfg80211.h>\n#include <net/codel.h>\n#include <net/ieee80211_radiotap.h>\n#include <asm/unaligned.h>\n\n/**\n * DOC: Introduction\n *\n * mac80211 is the Linux stack for 802.11 hardware that implements\n * only partial functionality in hard- or firmware. This document\n * defines the interface between mac80211 and low-level hardware\n * drivers.\n */\n\n/**\n * DOC: Calling mac80211 from interrupts\n *\n * Only ieee80211_tx_status_irqsafe() and ieee80211_rx_irqsafe() can be\n * called in hardware interrupt context. The low-level driver must not call any\n * other functions in hardware interrupt context. If there is a need for such\n * call, the low-level driver should first ACK the interrupt and perform the\n * IEEE 802.11 code call after this, e.g. from a scheduled workqueue or even\n * tasklet function.\n *\n * NOTE: If the driver opts to use the _irqsafe() functions, it may not also\n *\t use the non-IRQ-safe functions!\n */\n\n/**\n * DOC: Warning\n *\n * If you're reading this document and not the header file itself, it will\n * be incomplete because not all documentation has been converted yet.\n */\n\n/**\n * DOC: Frame format\n *\n * As a general rule, when frames are passed between mac80211 and the driver,\n * they start with the IEEE 802.11 header and include the same octets that are\n * sent over the air except for the FCS which should be calculated by the\n * hardware.\n *\n * There are, however, various exceptions to this rule for advanced features:\n *\n * The first exception is for hardware encryption and decryption offload\n * where the IV/ICV may or may not be generated in hardware.\n *\n * Secondly, when the hardware handles fragmentation, the frame handed to\n * the driver from mac80211 is the MSDU, not the MPDU.\n */\n\n/**\n * DOC: mac80211 workqueue\n *\n * mac80211 provides its own workqueue for drivers and internal mac80211 use.\n * The workqueue is a single threaded workqueue and can only be accessed by\n * helpers for sanity checking. Drivers must ensure all work added onto the\n * mac80211 workqueue should be cancelled on the driver stop() callback.\n *\n * mac80211 will flushed the workqueue upon interface removal and during\n * suspend.\n *\n * All work performed on the mac80211 workqueue must not acquire the RTNL lock.\n *\n */\n\n/**\n * DOC: mac80211 software tx queueing\n *\n * mac80211 provides an optional intermediate queueing implementation designed\n * to allow the driver to keep hardware queues short and provide some fairness\n * between different stations/interfaces.\n * In this model, the driver pulls data frames from the mac80211 queue instead\n * of letting mac80211 push them via drv_tx().\n * Other frames (e.g. control or management) are still pushed using drv_tx().\n *\n * Drivers indicate that they use this model by implementing the .wake_tx_queue\n * driver operation.\n *\n * Intermediate queues (struct ieee80211_txq) are kept per-sta per-tid, with\n * another per-sta for non-data/non-mgmt and bufferable management frames, and\n * a single per-vif queue for multicast data frames.\n *\n * The driver is expected to initialize its private per-queue data for stations\n * and interfaces in the .add_interface and .sta_add ops.\n *\n * The driver can't access the queue directly. To dequeue a frame from a\n * txq, it calls ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a\n * queue, it calls the .wake_tx_queue driver op.\n *\n * Drivers can optionally delegate responsibility for scheduling queues to\n * mac80211, to take advantage of airtime fairness accounting. In this case, to\n * obtain the next queue to pull frames from, the driver calls\n * ieee80211_next_txq(). The driver is then expected to return the txq using\n * ieee80211_return_txq().\n *\n * For AP powersave TIM handling, the driver only needs to indicate if it has\n * buffered packets in the driver specific data structures by calling\n * ieee80211_sta_set_buffered(). For frames buffered in the ieee80211_txq\n * struct, mac80211 sets the appropriate TIM PVB bits and calls\n * .release_buffered_frames().\n * In that callback the driver is therefore expected to release its own\n * buffered frames and afterwards also frames from the ieee80211_txq (obtained\n * via the usual ieee80211_tx_dequeue).\n */\n\nstruct device;\n\n/**\n * enum ieee80211_max_queues - maximum number of queues\n *\n * @IEEE80211_MAX_QUEUES: Maximum number of regular device queues.\n * @IEEE80211_MAX_QUEUE_MAP: bitmap with maximum queues set\n */\nenum ieee80211_max_queues {\n\tIEEE80211_MAX_QUEUES =\t\t16,\n\tIEEE80211_MAX_QUEUE_MAP =\tBIT(IEEE80211_MAX_QUEUES) - 1,\n};\n\n#define IEEE80211_INVAL_HW_QUEUE\t0xff\n\n/**\n * enum ieee80211_ac_numbers - AC numbers as used in mac80211\n * @IEEE80211_AC_VO: voice\n * @IEEE80211_AC_VI: video\n * @IEEE80211_AC_BE: best effort\n * @IEEE80211_AC_BK: background\n */\nenum ieee80211_ac_numbers {\n\tIEEE80211_AC_VO\t\t= 0,\n\tIEEE80211_AC_VI\t\t= 1,\n\tIEEE80211_AC_BE\t\t= 2,\n\tIEEE80211_AC_BK\t\t= 3,\n};\n\n/**\n * struct ieee80211_tx_queue_params - transmit queue configuration\n *\n * The information provided in this structure is required for QoS\n * transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.\n *\n * @aifs: arbitration interframe space [0..255]\n * @cw_min: minimum contention window [a value of the form\n *\t2^n-1 in the range 1..32767]\n * @cw_max: maximum contention window [like @cw_min]\n * @txop: maximum burst time in units of 32 usecs, 0 meaning disabled\n * @acm: is mandatory admission control required for the access category\n * @uapsd: is U-APSD mode enabled for the queue\n * @mu_edca: is the MU EDCA configured\n * @mu_edca_param_rec: MU EDCA Parameter Record for HE\n */\nstruct ieee80211_tx_queue_params {\n\tu16 txop;\n\tu16 cw_min;\n\tu16 cw_max;\n\tu8 aifs;\n\tbool acm;\n\tbool uapsd;\n\tbool mu_edca;\n\tstruct ieee80211_he_mu_edca_param_ac_rec mu_edca_param_rec;\n};\n\nstruct ieee80211_low_level_stats {\n\tunsigned int dot11ACKFailureCount;\n\tunsigned int dot11RTSFailureCount;\n\tunsigned int dot11FCSErrorCount;\n\tunsigned int dot11RTSSuccessCount;\n};\n\n/**\n * enum ieee80211_chanctx_change - change flag for channel context\n * @IEEE80211_CHANCTX_CHANGE_WIDTH: The channel width changed\n * @IEEE80211_CHANCTX_CHANGE_RX_CHAINS: The number of RX chains changed\n * @IEEE80211_CHANCTX_CHANGE_RADAR: radar detection flag changed\n * @IEEE80211_CHANCTX_CHANGE_CHANNEL: switched to another operating channel,\n *\tthis is used only with channel switching with CSA\n * @IEEE80211_CHANCTX_CHANGE_MIN_WIDTH: The min required channel width changed\n */\nenum ieee80211_chanctx_change {\n\tIEEE80211_CHANCTX_CHANGE_WIDTH\t\t= BIT(0),\n\tIEEE80211_CHANCTX_CHANGE_RX_CHAINS\t= BIT(1),\n\tIEEE80211_CHANCTX_CHANGE_RADAR\t\t= BIT(2),\n\tIEEE80211_CHANCTX_CHANGE_CHANNEL\t= BIT(3),\n\tIEEE80211_CHANCTX_CHANGE_MIN_WIDTH\t= BIT(4),\n};\n\n/**\n * struct ieee80211_chanctx_conf - channel context that vifs may be tuned to\n *\n * This is the driver-visible part. The ieee80211_chanctx\n * that contains it is visible in mac80211 only.\n *\n * @def: the channel definition\n * @min_def: the minimum channel definition currently required.\n * @rx_chains_static: The number of RX chains that must always be\n *\tactive on the channel to receive MIMO transmissions\n * @rx_chains_dynamic: The number of RX chains that must be enabled\n *\tafter RTS/CTS handshake to receive SMPS MIMO transmissions;\n *\tthis will always be >= @rx_chains_static.\n * @radar_enabled: whether radar detection is enabled on this channel.\n * @drv_priv: data area for driver use, will always be aligned to\n *\tsizeof(void *), size is determined in hw information.\n */\nstruct ieee80211_chanctx_conf {\n\tstruct cfg80211_chan_def def;\n\tstruct cfg80211_chan_def min_def;\n\n\tu8 rx_chains_static, rx_chains_dynamic;\n\n\tbool radar_enabled;\n\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n/**\n * enum ieee80211_chanctx_switch_mode - channel context switch mode\n * @CHANCTX_SWMODE_REASSIGN_VIF: Both old and new contexts already\n *\texist (and will continue to exist), but the virtual interface\n *\tneeds to be switched from one to the other.\n * @CHANCTX_SWMODE_SWAP_CONTEXTS: The old context exists but will stop\n *      to exist with this call, the new context doesn't exist but\n *      will be active after this call, the virtual interface switches\n *      from the old to the new (note that the driver may of course\n *      implement this as an on-the-fly chandef switch of the existing\n *      hardware context, but the mac80211 pointer for the old context\n *      will cease to exist and only the new one will later be used\n *      for changes/removal.)\n */\nenum ieee80211_chanctx_switch_mode {\n\tCHANCTX_SWMODE_REASSIGN_VIF,\n\tCHANCTX_SWMODE_SWAP_CONTEXTS,\n};\n\n/**\n * struct ieee80211_vif_chanctx_switch - vif chanctx switch information\n *\n * This is structure is used to pass information about a vif that\n * needs to switch from one chanctx to another.  The\n * &ieee80211_chanctx_switch_mode defines how the switch should be\n * done.\n *\n * @vif: the vif that should be switched from old_ctx to new_ctx\n * @old_ctx: the old context to which the vif was assigned\n * @new_ctx: the new context to which the vif must be assigned\n */\nstruct ieee80211_vif_chanctx_switch {\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_chanctx_conf *old_ctx;\n\tstruct ieee80211_chanctx_conf *new_ctx;\n};\n\n/**\n * enum ieee80211_bss_change - BSS change notification flags\n *\n * These flags are used with the bss_info_changed() callback\n * to indicate which BSS parameter changed.\n *\n * @BSS_CHANGED_ASSOC: association status changed (associated/disassociated),\n *\talso implies a change in the AID.\n * @BSS_CHANGED_ERP_CTS_PROT: CTS protection changed\n * @BSS_CHANGED_ERP_PREAMBLE: preamble changed\n * @BSS_CHANGED_ERP_SLOT: slot timing changed\n * @BSS_CHANGED_HT: 802.11n parameters changed\n * @BSS_CHANGED_BASIC_RATES: Basic rateset changed\n * @BSS_CHANGED_BEACON_INT: Beacon interval changed\n * @BSS_CHANGED_BSSID: BSSID changed, for whatever\n *\treason (IBSS and managed mode)\n * @BSS_CHANGED_BEACON: Beacon data changed, retrieve\n *\tnew beacon (beaconing modes)\n * @BSS_CHANGED_BEACON_ENABLED: Beaconing should be\n *\tenabled/disabled (beaconing modes)\n * @BSS_CHANGED_CQM: Connection quality monitor config changed\n * @BSS_CHANGED_IBSS: IBSS join status changed\n * @BSS_CHANGED_ARP_FILTER: Hardware ARP filter address list or state changed.\n * @BSS_CHANGED_QOS: QoS for this association was enabled/disabled. Note\n *\tthat it is only ever disabled for station mode.\n * @BSS_CHANGED_IDLE: Idle changed for this BSS/interface.\n * @BSS_CHANGED_SSID: SSID changed for this BSS (AP and IBSS mode)\n * @BSS_CHANGED_AP_PROBE_RESP: Probe Response changed for this BSS (AP mode)\n * @BSS_CHANGED_PS: PS changed for this BSS (STA mode)\n * @BSS_CHANGED_TXPOWER: TX power setting changed for this interface\n * @BSS_CHANGED_P2P_PS: P2P powersave settings (CTWindow, opportunistic PS)\n *\tchanged\n * @BSS_CHANGED_BEACON_INFO: Data from the AP's beacon became available:\n *\tcurrently dtim_period only is under consideration.\n * @BSS_CHANGED_BANDWIDTH: The bandwidth used by this interface changed,\n *\tnote that this is only called when it changes after the channel\n *\tcontext had been assigned.\n * @BSS_CHANGED_OCB: OCB join status changed\n * @BSS_CHANGED_MU_GROUPS: VHT MU-MIMO group id or user position changed\n * @BSS_CHANGED_KEEP_ALIVE: keep alive options (idle period or protected\n *\tkeep alive) changed.\n * @BSS_CHANGED_MCAST_RATE: Multicast Rate setting changed for this interface\n * @BSS_CHANGED_FTM_RESPONDER: fine timing measurement request responder\n *\tfunctionality changed for this BSS (AP mode).\n * @BSS_CHANGED_TWT: TWT status changed\n * @BSS_CHANGED_HE_OBSS_PD: OBSS Packet Detection status changed.\n * @BSS_CHANGED_HE_BSS_COLOR: BSS Color has changed\n * @BSS_CHANGED_FILS_DISCOVERY: FILS discovery status changed.\n * @BSS_CHANGED_UNSOL_BCAST_PROBE_RESP: Unsolicited broadcast probe response\n *\tstatus changed.\n *\n */\nenum ieee80211_bss_change {\n\tBSS_CHANGED_ASSOC\t\t= 1<<0,\n\tBSS_CHANGED_ERP_CTS_PROT\t= 1<<1,\n\tBSS_CHANGED_ERP_PREAMBLE\t= 1<<2,\n\tBSS_CHANGED_ERP_SLOT\t\t= 1<<3,\n\tBSS_CHANGED_HT\t\t\t= 1<<4,\n\tBSS_CHANGED_BASIC_RATES\t\t= 1<<5,\n\tBSS_CHANGED_BEACON_INT\t\t= 1<<6,\n\tBSS_CHANGED_BSSID\t\t= 1<<7,\n\tBSS_CHANGED_BEACON\t\t= 1<<8,\n\tBSS_CHANGED_BEACON_ENABLED\t= 1<<9,\n\tBSS_CHANGED_CQM\t\t\t= 1<<10,\n\tBSS_CHANGED_IBSS\t\t= 1<<11,\n\tBSS_CHANGED_ARP_FILTER\t\t= 1<<12,\n\tBSS_CHANGED_QOS\t\t\t= 1<<13,\n\tBSS_CHANGED_IDLE\t\t= 1<<14,\n\tBSS_CHANGED_SSID\t\t= 1<<15,\n\tBSS_CHANGED_AP_PROBE_RESP\t= 1<<16,\n\tBSS_CHANGED_PS\t\t\t= 1<<17,\n\tBSS_CHANGED_TXPOWER\t\t= 1<<18,\n\tBSS_CHANGED_P2P_PS\t\t= 1<<19,\n\tBSS_CHANGED_BEACON_INFO\t\t= 1<<20,\n\tBSS_CHANGED_BANDWIDTH\t\t= 1<<21,\n\tBSS_CHANGED_OCB                 = 1<<22,\n\tBSS_CHANGED_MU_GROUPS\t\t= 1<<23,\n\tBSS_CHANGED_KEEP_ALIVE\t\t= 1<<24,\n\tBSS_CHANGED_MCAST_RATE\t\t= 1<<25,\n\tBSS_CHANGED_FTM_RESPONDER\t= 1<<26,\n\tBSS_CHANGED_TWT\t\t\t= 1<<27,\n\tBSS_CHANGED_HE_OBSS_PD\t\t= 1<<28,\n\tBSS_CHANGED_HE_BSS_COLOR\t= 1<<29,\n\tBSS_CHANGED_FILS_DISCOVERY      = 1<<30,\n\tBSS_CHANGED_UNSOL_BCAST_PROBE_RESP = 1<<31,\n\n\t/* when adding here, make sure to change ieee80211_reconfig */\n};\n\n/*\n * The maximum number of IPv4 addresses listed for ARP filtering. If the number\n * of addresses for an interface increase beyond this value, hardware ARP\n * filtering will be disabled.\n */\n#define IEEE80211_BSS_ARP_ADDR_LIST_LEN 4\n\n/**\n * enum ieee80211_event_type - event to be notified to the low level driver\n * @RSSI_EVENT: AP's rssi crossed the a threshold set by the driver.\n * @MLME_EVENT: event related to MLME\n * @BAR_RX_EVENT: a BAR was received\n * @BA_FRAME_TIMEOUT: Frames were released from the reordering buffer because\n *\tthey timed out. This won't be called for each frame released, but only\n *\tonce each time the timeout triggers.\n */\nenum ieee80211_event_type {\n\tRSSI_EVENT,\n\tMLME_EVENT,\n\tBAR_RX_EVENT,\n\tBA_FRAME_TIMEOUT,\n};\n\n/**\n * enum ieee80211_rssi_event_data - relevant when event type is %RSSI_EVENT\n * @RSSI_EVENT_HIGH: AP's rssi went below the threshold set by the driver.\n * @RSSI_EVENT_LOW: AP's rssi went above the threshold set by the driver.\n */\nenum ieee80211_rssi_event_data {\n\tRSSI_EVENT_HIGH,\n\tRSSI_EVENT_LOW,\n};\n\n/**\n * struct ieee80211_rssi_event - data attached to an %RSSI_EVENT\n * @data: See &enum ieee80211_rssi_event_data\n */\nstruct ieee80211_rssi_event {\n\tenum ieee80211_rssi_event_data data;\n};\n\n/**\n * enum ieee80211_mlme_event_data - relevant when event type is %MLME_EVENT\n * @AUTH_EVENT: the MLME operation is authentication\n * @ASSOC_EVENT: the MLME operation is association\n * @DEAUTH_RX_EVENT: deauth received..\n * @DEAUTH_TX_EVENT: deauth sent.\n */\nenum ieee80211_mlme_event_data {\n\tAUTH_EVENT,\n\tASSOC_EVENT,\n\tDEAUTH_RX_EVENT,\n\tDEAUTH_TX_EVENT,\n};\n\n/**\n * enum ieee80211_mlme_event_status - relevant when event type is %MLME_EVENT\n * @MLME_SUCCESS: the MLME operation completed successfully.\n * @MLME_DENIED: the MLME operation was denied by the peer.\n * @MLME_TIMEOUT: the MLME operation timed out.\n */\nenum ieee80211_mlme_event_status {\n\tMLME_SUCCESS,\n\tMLME_DENIED,\n\tMLME_TIMEOUT,\n};\n\n/**\n * struct ieee80211_mlme_event - data attached to an %MLME_EVENT\n * @data: See &enum ieee80211_mlme_event_data\n * @status: See &enum ieee80211_mlme_event_status\n * @reason: the reason code if applicable\n */\nstruct ieee80211_mlme_event {\n\tenum ieee80211_mlme_event_data data;\n\tenum ieee80211_mlme_event_status status;\n\tu16 reason;\n};\n\n/**\n * struct ieee80211_ba_event - data attached for BlockAck related events\n * @sta: pointer to the &ieee80211_sta to which this event relates\n * @tid: the tid\n * @ssn: the starting sequence number (for %BAR_RX_EVENT)\n */\nstruct ieee80211_ba_event {\n\tstruct ieee80211_sta *sta;\n\tu16 tid;\n\tu16 ssn;\n};\n\n/**\n * struct ieee80211_event - event to be sent to the driver\n * @type: The event itself. See &enum ieee80211_event_type.\n * @rssi: relevant if &type is %RSSI_EVENT\n * @mlme: relevant if &type is %AUTH_EVENT\n * @ba: relevant if &type is %BAR_RX_EVENT or %BA_FRAME_TIMEOUT\n * @u:union holding the fields above\n */\nstruct ieee80211_event {\n\tenum ieee80211_event_type type;\n\tunion {\n\t\tstruct ieee80211_rssi_event rssi;\n\t\tstruct ieee80211_mlme_event mlme;\n\t\tstruct ieee80211_ba_event ba;\n\t} u;\n};\n\n/**\n * struct ieee80211_mu_group_data - STA's VHT MU-MIMO group data\n *\n * This structure describes the group id data of VHT MU-MIMO\n *\n * @membership: 64 bits array - a bit is set if station is member of the group\n * @position: 2 bits per group id indicating the position in the group\n */\nstruct ieee80211_mu_group_data {\n\tu8 membership[WLAN_MEMBERSHIP_LEN];\n\tu8 position[WLAN_USER_POSITION_LEN];\n};\n\n/**\n * struct ieee80211_ftm_responder_params - FTM responder parameters\n *\n * @lci: LCI subelement content\n * @civicloc: CIVIC location subelement content\n * @lci_len: LCI data length\n * @civicloc_len: Civic data length\n */\nstruct ieee80211_ftm_responder_params {\n\tconst u8 *lci;\n\tconst u8 *civicloc;\n\tsize_t lci_len;\n\tsize_t civicloc_len;\n};\n\n/**\n * struct ieee80211_fils_discovery - FILS discovery parameters from\n * IEEE Std 802.11ai-2016, Annex C.3 MIB detail.\n *\n * @min_interval: Minimum packet interval in TUs (0 - 10000)\n * @max_interval: Maximum packet interval in TUs (0 - 10000)\n */\nstruct ieee80211_fils_discovery {\n\tu32 min_interval;\n\tu32 max_interval;\n};\n\n/**\n * struct ieee80211_bss_conf - holds the BSS's changing parameters\n *\n * This structure keeps information about a BSS (and an association\n * to that BSS) that can change during the lifetime of the BSS.\n *\n * @htc_trig_based_pkt_ext: default PE in 4us units, if BSS supports HE\n * @multi_sta_back_32bit: supports BA bitmap of 32-bits in Multi-STA BACK\n * @uora_exists: is the UORA element advertised by AP\n * @ack_enabled: indicates support to receive a multi-TID that solicits either\n *\tACK, BACK or both\n * @uora_ocw_range: UORA element's OCW Range field\n * @frame_time_rts_th: HE duration RTS threshold, in units of 32us\n * @he_support: does this BSS support HE\n * @twt_requester: does this BSS support TWT requester (relevant for managed\n *\tmode only, set if the AP advertises TWT responder role)\n * @twt_responder: does this BSS support TWT requester (relevant for managed\n *\tmode only, set if the AP advertises TWT responder role)\n * @twt_protected: does this BSS support protected TWT frames\n * @assoc: association status\n * @ibss_joined: indicates whether this station is part of an IBSS\n *\tor not\n * @ibss_creator: indicates if a new IBSS network is being created\n * @aid: association ID number, valid only when @assoc is true\n * @use_cts_prot: use CTS protection\n * @use_short_preamble: use 802.11b short preamble\n * @use_short_slot: use short slot time (only relevant for ERP)\n * @dtim_period: num of beacons before the next DTIM, for beaconing,\n *\tvalid in station mode only if after the driver was notified\n *\twith the %BSS_CHANGED_BEACON_INFO flag, will be non-zero then.\n * @sync_tsf: last beacon's/probe response's TSF timestamp (could be old\n *\tas it may have been received during scanning long ago). If the\n *\tHW flag %IEEE80211_HW_TIMING_BEACON_ONLY is set, then this can\n *\tonly come from a beacon, but might not become valid until after\n *\tassociation when a beacon is received (which is notified with the\n *\t%BSS_CHANGED_DTIM flag.). See also sync_dtim_count important notice.\n * @sync_device_ts: the device timestamp corresponding to the sync_tsf,\n *\tthe driver/device can use this to calculate synchronisation\n *\t(see @sync_tsf). See also sync_dtim_count important notice.\n * @sync_dtim_count: Only valid when %IEEE80211_HW_TIMING_BEACON_ONLY\n *\tis requested, see @sync_tsf/@sync_device_ts.\n *\tIMPORTANT: These three sync_* parameters would possibly be out of sync\n *\tby the time the driver will use them. The synchronized view is currently\n *\tguaranteed only in certain callbacks.\n * @beacon_int: beacon interval\n * @assoc_capability: capabilities taken from assoc resp\n * @basic_rates: bitmap of basic rates, each bit stands for an\n *\tindex into the rate table configured by the driver in\n *\tthe current band.\n * @beacon_rate: associated AP's beacon TX rate\n * @mcast_rate: per-band multicast rate index + 1 (0: disabled)\n * @bssid: The BSSID for this BSS\n * @enable_beacon: whether beaconing should be enabled or not\n * @chandef: Channel definition for this BSS -- the hardware might be\n *\tconfigured a higher bandwidth than this BSS uses, for example.\n * @mu_group: VHT MU-MIMO group membership data\n * @ht_operation_mode: HT operation mode like in &struct ieee80211_ht_operation.\n *\tThis field is only valid when the channel is a wide HT/VHT channel.\n *\tNote that with TDLS this can be the case (channel is HT, protection must\n *\tbe used from this field) even when the BSS association isn't using HT.\n * @cqm_rssi_thold: Connection quality monitor RSSI threshold, a zero value\n *\timplies disabled. As with the cfg80211 callback, a change here should\n *\tcause an event to be sent indicating where the current value is in\n *\trelation to the newly configured threshold.\n * @cqm_rssi_low: Connection quality monitor RSSI lower threshold, a zero value\n *\timplies disabled.  This is an alternative mechanism to the single\n *\tthreshold event and can't be enabled simultaneously with it.\n * @cqm_rssi_high: Connection quality monitor RSSI upper threshold.\n * @cqm_rssi_hyst: Connection quality monitor RSSI hysteresis\n * @arp_addr_list: List of IPv4 addresses for hardware ARP filtering. The\n *\tmay filter ARP queries targeted for other addresses than listed here.\n *\tThe driver must allow ARP queries targeted for all address listed here\n *\tto pass through. An empty list implies no ARP queries need to pass.\n * @arp_addr_cnt: Number of addresses currently on the list. Note that this\n *\tmay be larger than %IEEE80211_BSS_ARP_ADDR_LIST_LEN (the arp_addr_list\n *\tarray size), it's up to the driver what to do in that case.\n * @qos: This is a QoS-enabled BSS.\n * @idle: This interface is idle. There's also a global idle flag in the\n *\thardware config which may be more appropriate depending on what\n *\tyour driver/device needs to do.\n * @ps: power-save mode (STA only). This flag is NOT affected by\n *\toffchannel/dynamic_ps operations.\n * @ssid: The SSID of the current vif. Valid in AP and IBSS mode.\n * @ssid_len: Length of SSID given in @ssid.\n * @hidden_ssid: The SSID of the current vif is hidden. Only valid in AP-mode.\n * @txpower: TX power in dBm.  INT_MIN means not configured.\n * @txpower_type: TX power adjustment used to control per packet Transmit\n *\tPower Control (TPC) in lower driver for the current vif. In particular\n *\tTPC is enabled if value passed in %txpower_type is\n *\tNL80211_TX_POWER_LIMITED (allow using less than specified from\n *\tuserspace), whereas TPC is disabled if %txpower_type is set to\n *\tNL80211_TX_POWER_FIXED (use value configured from userspace)\n * @p2p_noa_attr: P2P NoA attribute for P2P powersave\n * @allow_p2p_go_ps: indication for AP or P2P GO interface, whether it's allowed\n *\tto use P2P PS mechanism or not. AP/P2P GO is not allowed to use P2P PS\n *\tif it has associated clients without P2P PS support.\n * @max_idle_period: the time period during which the station can refrain from\n *\ttransmitting frames to its associated AP without being disassociated.\n *\tIn units of 1000 TUs. Zero value indicates that the AP did not include\n *\ta (valid) BSS Max Idle Period Element.\n * @protected_keep_alive: if set, indicates that the station should send an RSN\n *\tprotected frame to the AP to reset the idle timer at the AP for the\n *\tstation.\n * @ftm_responder: whether to enable or disable fine timing measurement FTM\n *\tresponder functionality.\n * @ftmr_params: configurable lci/civic parameter when enabling FTM responder.\n * @nontransmitted: this BSS is a nontransmitted BSS profile\n * @transmitter_bssid: the address of transmitter AP\n * @bssid_index: index inside the multiple BSSID set\n * @bssid_indicator: 2^bssid_indicator is the maximum number of APs in set\n * @ema_ap: AP supports enhancements of discovery and advertisement of\n *\tnontransmitted BSSIDs\n * @profile_periodicity: the least number of beacon frames need to be received\n *\tin order to discover all the nontransmitted BSSIDs in the set.\n * @he_oper: HE operation information of the BSS (AP/Mesh) or of the AP we are\n *\tconnected to (STA)\n * @he_obss_pd: OBSS Packet Detection parameters.\n * @he_bss_color: BSS coloring settings, if BSS supports HE\n * @fils_discovery: FILS discovery configuration\n * @unsol_bcast_probe_resp_interval: Unsolicited broadcast probe response\n *\tinterval.\n * @s1g: BSS is S1G BSS (affects Association Request format).\n * @beacon_tx_rate: The configured beacon transmit rate that needs to be passed\n *\tto driver when rate control is offloaded to firmware.\n */\nstruct ieee80211_bss_conf {\n\tconst u8 *bssid;\n\tu8 htc_trig_based_pkt_ext;\n\tbool uora_exists;\n\tu8 uora_ocw_range;\n\tu16 frame_time_rts_th;\n\tbool he_support;\n\tbool twt_requester;\n\tbool twt_responder;\n\tbool twt_protected;\n\t/* association related data */\n\tbool assoc, ibss_joined;\n\tbool ibss_creator;\n\tu16 aid;\n\t/* erp related data */\n\tbool use_cts_prot;\n\tbool use_short_preamble;\n\tbool use_short_slot;\n\tbool enable_beacon;\n\tu8 dtim_period;\n\tu16 beacon_int;\n\tu16 assoc_capability;\n\tu64 sync_tsf;\n\tu32 sync_device_ts;\n\tu8 sync_dtim_count;\n\tu32 basic_rates;\n\tstruct ieee80211_rate *beacon_rate;\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu16 ht_operation_mode;\n\ts32 cqm_rssi_thold;\n\tu32 cqm_rssi_hyst;\n\ts32 cqm_rssi_low;\n\ts32 cqm_rssi_high;\n\tstruct cfg80211_chan_def chandef;\n\tstruct ieee80211_mu_group_data mu_group;\n\t__be32 arp_addr_list[IEEE80211_BSS_ARP_ADDR_LIST_LEN];\n\tint arp_addr_cnt;\n\tbool qos;\n\tbool idle;\n\tbool ps;\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tsize_t ssid_len;\n\tbool hidden_ssid;\n\tint txpower;\n\tenum nl80211_tx_power_setting txpower_type;\n\tstruct ieee80211_p2p_noa_attr p2p_noa_attr;\n\tbool allow_p2p_go_ps;\n\tu16 max_idle_period;\n\tbool protected_keep_alive;\n\tbool ftm_responder;\n\tstruct ieee80211_ftm_responder_params *ftmr_params;\n\t/* Multiple BSSID data */\n\tbool nontransmitted;\n\tu8 transmitter_bssid[ETH_ALEN];\n\tu8 bssid_index;\n\tu8 bssid_indicator;\n\tbool ema_ap;\n\tu8 profile_periodicity;\n\tstruct {\n\t\tu32 params;\n\t\tu16 nss_set;\n\t} he_oper;\n\tstruct ieee80211_he_obss_pd he_obss_pd;\n\tstruct cfg80211_he_bss_color he_bss_color;\n\tstruct ieee80211_fils_discovery fils_discovery;\n\tu32 unsol_bcast_probe_resp_interval;\n\tbool s1g;\n\tstruct cfg80211_bitrate_mask beacon_tx_rate;\n};\n\n/**\n * enum mac80211_tx_info_flags - flags to describe transmission information/status\n *\n * These flags are used with the @flags member of &ieee80211_tx_info.\n *\n * @IEEE80211_TX_CTL_REQ_TX_STATUS: require TX status callback for this frame.\n * @IEEE80211_TX_CTL_ASSIGN_SEQ: The driver has to assign a sequence\n *\tnumber to this frame, taking care of not overwriting the fragment\n *\tnumber and increasing the sequence number only when the\n *\tIEEE80211_TX_CTL_FIRST_FRAGMENT flag is set. mac80211 will properly\n *\tassign sequence numbers to QoS-data frames but cannot do so correctly\n *\tfor non-QoS-data and management frames because beacons need them from\n *\tthat counter as well and mac80211 cannot guarantee proper sequencing.\n *\tIf this flag is set, the driver should instruct the hardware to\n *\tassign a sequence number to the frame or assign one itself. Cf. IEEE\n *\t802.11-2007 7.1.3.4.1 paragraph 3. This flag will always be set for\n *\tbeacons and always be clear for frames without a sequence number field.\n * @IEEE80211_TX_CTL_NO_ACK: tell the low level not to wait for an ack\n * @IEEE80211_TX_CTL_CLEAR_PS_FILT: clear powersave filter for destination\n *\tstation\n * @IEEE80211_TX_CTL_FIRST_FRAGMENT: this is a first fragment of the frame\n * @IEEE80211_TX_CTL_SEND_AFTER_DTIM: send this frame after DTIM beacon\n * @IEEE80211_TX_CTL_AMPDU: this frame should be sent as part of an A-MPDU\n * @IEEE80211_TX_CTL_INJECTED: Frame was injected, internal to mac80211.\n * @IEEE80211_TX_STAT_TX_FILTERED: The frame was not transmitted\n *\tbecause the destination STA was in powersave mode. Note that to\n *\tavoid race conditions, the filter must be set by the hardware or\n *\tfirmware upon receiving a frame that indicates that the station\n *\twent to sleep (must be done on device to filter frames already on\n *\tthe queue) and may only be unset after mac80211 gives the OK for\n *\tthat by setting the IEEE80211_TX_CTL_CLEAR_PS_FILT (see above),\n *\tsince only then is it guaranteed that no more frames are in the\n *\thardware queue.\n * @IEEE80211_TX_STAT_ACK: Frame was acknowledged\n * @IEEE80211_TX_STAT_AMPDU: The frame was aggregated, so status\n * \tis for the whole aggregation.\n * @IEEE80211_TX_STAT_AMPDU_NO_BACK: no block ack was returned,\n * \tso consider using block ack request (BAR).\n * @IEEE80211_TX_CTL_RATE_CTRL_PROBE: internal to mac80211, can be\n *\tset by rate control algorithms to indicate probe rate, will\n *\tbe cleared for fragmented frames (except on the last fragment)\n * @IEEE80211_TX_INTFL_OFFCHAN_TX_OK: Internal to mac80211. Used to indicate\n *\tthat a frame can be transmitted while the queues are stopped for\n *\toff-channel operation.\n * @IEEE80211_TX_CTL_HW_80211_ENCAP: This frame uses hardware encapsulation\n *\t(header conversion)\n * @IEEE80211_TX_INTFL_RETRIED: completely internal to mac80211,\n *\tused to indicate that a frame was already retried due to PS\n * @IEEE80211_TX_INTFL_DONT_ENCRYPT: completely internal to mac80211,\n *\tused to indicate frame should not be encrypted\n * @IEEE80211_TX_CTL_NO_PS_BUFFER: This frame is a response to a poll\n *\tframe (PS-Poll or uAPSD) or a non-bufferable MMPDU and must\n *\tbe sent although the station is in powersave mode.\n * @IEEE80211_TX_CTL_MORE_FRAMES: More frames will be passed to the\n *\ttransmit function after the current frame, this can be used\n *\tby drivers to kick the DMA queue only if unset or when the\n *\tqueue gets full.\n * @IEEE80211_TX_INTFL_RETRANSMISSION: This frame is being retransmitted\n *\tafter TX status because the destination was asleep, it must not\n *\tbe modified again (no seqno assignment, crypto, etc.)\n * @IEEE80211_TX_INTFL_MLME_CONN_TX: This frame was transmitted by the MLME\n *\tcode for connection establishment, this indicates that its status\n *\tshould kick the MLME state machine.\n * @IEEE80211_TX_INTFL_NL80211_FRAME_TX: Frame was requested through nl80211\n *\tMLME command (internal to mac80211 to figure out whether to send TX\n *\tstatus to user space)\n * @IEEE80211_TX_CTL_LDPC: tells the driver to use LDPC for this frame\n * @IEEE80211_TX_CTL_STBC: Enables Space-Time Block Coding (STBC) for this\n *\tframe and selects the maximum number of streams that it can use.\n * @IEEE80211_TX_CTL_TX_OFFCHAN: Marks this packet to be transmitted on\n *\tthe off-channel channel when a remain-on-channel offload is done\n *\tin hardware -- normal packets still flow and are expected to be\n *\thandled properly by the device.\n * @IEEE80211_TX_INTFL_TKIP_MIC_FAILURE: Marks this packet to be used for TKIP\n *\ttesting. It will be sent out with incorrect Michael MIC key to allow\n *\tTKIP countermeasures to be tested.\n * @IEEE80211_TX_CTL_NO_CCK_RATE: This frame will be sent at non CCK rate.\n *\tThis flag is actually used for management frame especially for P2P\n *\tframes not being sent at CCK rate in 2GHz band.\n * @IEEE80211_TX_STATUS_EOSP: This packet marks the end of service period,\n *\twhen its status is reported the service period ends. For frames in\n *\tan SP that mac80211 transmits, it is already set; for driver frames\n *\tthe driver may set this flag. It is also used to do the same for\n *\tPS-Poll responses.\n * @IEEE80211_TX_CTL_USE_MINRATE: This frame will be sent at lowest rate.\n *\tThis flag is used to send nullfunc frame at minimum rate when\n *\tthe nullfunc is used for connection monitoring purpose.\n * @IEEE80211_TX_CTL_DONTFRAG: Don't fragment this packet even if it\n *\twould be fragmented by size (this is optional, only used for\n *\tmonitor injection).\n * @IEEE80211_TX_STAT_NOACK_TRANSMITTED: A frame that was marked with\n *\tIEEE80211_TX_CTL_NO_ACK has been successfully transmitted without\n *\tany errors (like issues specific to the driver/HW).\n *\tThis flag must not be set for frames that don't request no-ack\n *\tbehaviour with IEEE80211_TX_CTL_NO_ACK.\n *\n * Note: If you have to add new flags to the enumeration, then don't\n *\t forget to update %IEEE80211_TX_TEMPORARY_FLAGS when necessary.\n */\nenum mac80211_tx_info_flags {\n\tIEEE80211_TX_CTL_REQ_TX_STATUS\t\t= BIT(0),\n\tIEEE80211_TX_CTL_ASSIGN_SEQ\t\t= BIT(1),\n\tIEEE80211_TX_CTL_NO_ACK\t\t\t= BIT(2),\n\tIEEE80211_TX_CTL_CLEAR_PS_FILT\t\t= BIT(3),\n\tIEEE80211_TX_CTL_FIRST_FRAGMENT\t\t= BIT(4),\n\tIEEE80211_TX_CTL_SEND_AFTER_DTIM\t= BIT(5),\n\tIEEE80211_TX_CTL_AMPDU\t\t\t= BIT(6),\n\tIEEE80211_TX_CTL_INJECTED\t\t= BIT(7),\n\tIEEE80211_TX_STAT_TX_FILTERED\t\t= BIT(8),\n\tIEEE80211_TX_STAT_ACK\t\t\t= BIT(9),\n\tIEEE80211_TX_STAT_AMPDU\t\t\t= BIT(10),\n\tIEEE80211_TX_STAT_AMPDU_NO_BACK\t\t= BIT(11),\n\tIEEE80211_TX_CTL_RATE_CTRL_PROBE\t= BIT(12),\n\tIEEE80211_TX_INTFL_OFFCHAN_TX_OK\t= BIT(13),\n\tIEEE80211_TX_CTL_HW_80211_ENCAP\t\t= BIT(14),\n\tIEEE80211_TX_INTFL_RETRIED\t\t= BIT(15),\n\tIEEE80211_TX_INTFL_DONT_ENCRYPT\t\t= BIT(16),\n\tIEEE80211_TX_CTL_NO_PS_BUFFER\t\t= BIT(17),\n\tIEEE80211_TX_CTL_MORE_FRAMES\t\t= BIT(18),\n\tIEEE80211_TX_INTFL_RETRANSMISSION\t= BIT(19),\n\tIEEE80211_TX_INTFL_MLME_CONN_TX\t\t= BIT(20),\n\tIEEE80211_TX_INTFL_NL80211_FRAME_TX\t= BIT(21),\n\tIEEE80211_TX_CTL_LDPC\t\t\t= BIT(22),\n\tIEEE80211_TX_CTL_STBC\t\t\t= BIT(23) | BIT(24),\n\tIEEE80211_TX_CTL_TX_OFFCHAN\t\t= BIT(25),\n\tIEEE80211_TX_INTFL_TKIP_MIC_FAILURE\t= BIT(26),\n\tIEEE80211_TX_CTL_NO_CCK_RATE\t\t= BIT(27),\n\tIEEE80211_TX_STATUS_EOSP\t\t= BIT(28),\n\tIEEE80211_TX_CTL_USE_MINRATE\t\t= BIT(29),\n\tIEEE80211_TX_CTL_DONTFRAG\t\t= BIT(30),\n\tIEEE80211_TX_STAT_NOACK_TRANSMITTED\t= BIT(31),\n};\n\n#define IEEE80211_TX_CTL_STBC_SHIFT\t\t23\n\n#define IEEE80211_TX_RC_S1G_MCS IEEE80211_TX_RC_VHT_MCS\n\n/**\n * enum mac80211_tx_control_flags - flags to describe transmit control\n *\n * @IEEE80211_TX_CTRL_PORT_CTRL_PROTO: this frame is a port control\n *\tprotocol frame (e.g. EAP)\n * @IEEE80211_TX_CTRL_PS_RESPONSE: This frame is a response to a poll\n *\tframe (PS-Poll or uAPSD).\n * @IEEE80211_TX_CTRL_RATE_INJECT: This frame is injected with rate information\n * @IEEE80211_TX_CTRL_AMSDU: This frame is an A-MSDU frame\n * @IEEE80211_TX_CTRL_FAST_XMIT: This frame is going through the fast_xmit path\n * @IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP: This frame skips mesh path lookup\n * @IEEE80211_TX_INTCFL_NEED_TXPROCESSING: completely internal to mac80211,\n *\tused to indicate that a pending frame requires TX processing before\n *\tit can be sent out.\n * @IEEE80211_TX_CTRL_NO_SEQNO: Do not overwrite the sequence number that\n *\thas already been assigned to this frame.\n * @IEEE80211_TX_CTRL_DONT_REORDER: This frame should not be reordered\n *\trelative to other frames that have this flag set, independent\n *\tof their QoS TID or other priority field values.\n *\n * These flags are used in tx_info->control.flags.\n */\nenum mac80211_tx_control_flags {\n\tIEEE80211_TX_CTRL_PORT_CTRL_PROTO\t= BIT(0),\n\tIEEE80211_TX_CTRL_PS_RESPONSE\t\t= BIT(1),\n\tIEEE80211_TX_CTRL_RATE_INJECT\t\t= BIT(2),\n\tIEEE80211_TX_CTRL_AMSDU\t\t\t= BIT(3),\n\tIEEE80211_TX_CTRL_FAST_XMIT\t\t= BIT(4),\n\tIEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP\t= BIT(5),\n\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING\t= BIT(6),\n\tIEEE80211_TX_CTRL_NO_SEQNO\t\t= BIT(7),\n\tIEEE80211_TX_CTRL_DONT_REORDER\t\t= BIT(8),\n};\n\n/*\n * This definition is used as a mask to clear all temporary flags, which are\n * set by the tx handlers for each transmission attempt by the mac80211 stack.\n */\n#define IEEE80211_TX_TEMPORARY_FLAGS (IEEE80211_TX_CTL_NO_ACK |\t\t      \\\n\tIEEE80211_TX_CTL_CLEAR_PS_FILT | IEEE80211_TX_CTL_FIRST_FRAGMENT |    \\\n\tIEEE80211_TX_CTL_SEND_AFTER_DTIM | IEEE80211_TX_CTL_AMPDU |\t      \\\n\tIEEE80211_TX_STAT_TX_FILTERED |\tIEEE80211_TX_STAT_ACK |\t\t      \\\n\tIEEE80211_TX_STAT_AMPDU | IEEE80211_TX_STAT_AMPDU_NO_BACK |\t      \\\n\tIEEE80211_TX_CTL_RATE_CTRL_PROBE | IEEE80211_TX_CTL_NO_PS_BUFFER |    \\\n\tIEEE80211_TX_CTL_MORE_FRAMES | IEEE80211_TX_CTL_LDPC |\t\t      \\\n\tIEEE80211_TX_CTL_STBC | IEEE80211_TX_STATUS_EOSP)\n\n/**\n * enum mac80211_rate_control_flags - per-rate flags set by the\n *\tRate Control algorithm.\n *\n * These flags are set by the Rate control algorithm for each rate during tx,\n * in the @flags member of struct ieee80211_tx_rate.\n *\n * @IEEE80211_TX_RC_USE_RTS_CTS: Use RTS/CTS exchange for this rate.\n * @IEEE80211_TX_RC_USE_CTS_PROTECT: CTS-to-self protection is required.\n *\tThis is set if the current BSS requires ERP protection.\n * @IEEE80211_TX_RC_USE_SHORT_PREAMBLE: Use short preamble.\n * @IEEE80211_TX_RC_MCS: HT rate.\n * @IEEE80211_TX_RC_VHT_MCS: VHT MCS rate, in this case the idx field is split\n *\tinto a higher 4 bits (Nss) and lower 4 bits (MCS number)\n * @IEEE80211_TX_RC_GREEN_FIELD: Indicates whether this rate should be used in\n *\tGreenfield mode.\n * @IEEE80211_TX_RC_40_MHZ_WIDTH: Indicates if the Channel Width should be 40 MHz.\n * @IEEE80211_TX_RC_80_MHZ_WIDTH: Indicates 80 MHz transmission\n * @IEEE80211_TX_RC_160_MHZ_WIDTH: Indicates 160 MHz transmission\n *\t(80+80 isn't supported yet)\n * @IEEE80211_TX_RC_DUP_DATA: The frame should be transmitted on both of the\n *\tadjacent 20 MHz channels, if the current channel type is\n *\tNL80211_CHAN_HT40MINUS or NL80211_CHAN_HT40PLUS.\n * @IEEE80211_TX_RC_SHORT_GI: Short Guard interval should be used for this rate.\n */\nenum mac80211_rate_control_flags {\n\tIEEE80211_TX_RC_USE_RTS_CTS\t\t= BIT(0),\n\tIEEE80211_TX_RC_USE_CTS_PROTECT\t\t= BIT(1),\n\tIEEE80211_TX_RC_USE_SHORT_PREAMBLE\t= BIT(2),\n\n\t/* rate index is an HT/VHT MCS instead of an index */\n\tIEEE80211_TX_RC_MCS\t\t\t= BIT(3),\n\tIEEE80211_TX_RC_GREEN_FIELD\t\t= BIT(4),\n\tIEEE80211_TX_RC_40_MHZ_WIDTH\t\t= BIT(5),\n\tIEEE80211_TX_RC_DUP_DATA\t\t= BIT(6),\n\tIEEE80211_TX_RC_SHORT_GI\t\t= BIT(7),\n\tIEEE80211_TX_RC_VHT_MCS\t\t\t= BIT(8),\n\tIEEE80211_TX_RC_80_MHZ_WIDTH\t\t= BIT(9),\n\tIEEE80211_TX_RC_160_MHZ_WIDTH\t\t= BIT(10),\n};\n\n\n/* there are 40 bytes if you don't need the rateset to be kept */\n#define IEEE80211_TX_INFO_DRIVER_DATA_SIZE 40\n\n/* if you do need the rateset, then you have less space */\n#define IEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE 24\n\n/* maximum number of rate stages */\n#define IEEE80211_TX_MAX_RATES\t4\n\n/* maximum number of rate table entries */\n#define IEEE80211_TX_RATE_TABLE_SIZE\t4\n\n/**\n * struct ieee80211_tx_rate - rate selection/status\n *\n * @idx: rate index to attempt to send with\n * @flags: rate control flags (&enum mac80211_rate_control_flags)\n * @count: number of tries in this rate before going to the next rate\n *\n * A value of -1 for @idx indicates an invalid rate and, if used\n * in an array of retry rates, that no more rates should be tried.\n *\n * When used for transmit status reporting, the driver should\n * always report the rate along with the flags it used.\n *\n * &struct ieee80211_tx_info contains an array of these structs\n * in the control information, and it will be filled by the rate\n * control algorithm according to what should be sent. For example,\n * if this array contains, in the format { <idx>, <count> } the\n * information::\n *\n *    { 3, 2 }, { 2, 2 }, { 1, 4 }, { -1, 0 }, { -1, 0 }\n *\n * then this means that the frame should be transmitted\n * up to twice at rate 3, up to twice at rate 2, and up to four\n * times at rate 1 if it doesn't get acknowledged. Say it gets\n * acknowledged by the peer after the fifth attempt, the status\n * information should then contain::\n *\n *   { 3, 2 }, { 2, 2 }, { 1, 1 }, { -1, 0 } ...\n *\n * since it was transmitted twice at rate 3, twice at rate 2\n * and once at rate 1 after which we received an acknowledgement.\n */\nstruct ieee80211_tx_rate {\n\ts8 idx;\n\tu16 count:5,\n\t    flags:11;\n} __packed;\n\n#define IEEE80211_MAX_TX_RETRY\t\t31\n\nstatic inline void ieee80211_rate_set_vht(struct ieee80211_tx_rate *rate,\n\t\t\t\t\t  u8 mcs, u8 nss)\n{\n\tWARN_ON(mcs & ~0xF);\n\tWARN_ON((nss - 1) & ~0x7);\n\trate->idx = ((nss - 1) << 4) | mcs;\n}\n\nstatic inline u8\nieee80211_rate_get_vht_mcs(const struct ieee80211_tx_rate *rate)\n{\n\treturn rate->idx & 0xF;\n}\n\nstatic inline u8\nieee80211_rate_get_vht_nss(const struct ieee80211_tx_rate *rate)\n{\n\treturn (rate->idx >> 4) + 1;\n}\n\n/**\n * struct ieee80211_tx_info - skb transmit information\n *\n * This structure is placed in skb->cb for three uses:\n *  (1) mac80211 TX control - mac80211 tells the driver what to do\n *  (2) driver internal use (if applicable)\n *  (3) TX status information - driver tells mac80211 what happened\n *\n * @flags: transmit info flags, defined above\n * @band: the band to transmit on (use for checking for races)\n * @hw_queue: HW queue to put the frame on, skb_get_queue_mapping() gives the AC\n * @ack_frame_id: internal frame ID for TX status, used internally\n * @tx_time_est: TX time estimate in units of 4us, used internally\n * @control: union part for control data\n * @control.rates: TX rates array to try\n * @control.rts_cts_rate_idx: rate for RTS or CTS\n * @control.use_rts: use RTS\n * @control.use_cts_prot: use RTS/CTS\n * @control.short_preamble: use short preamble (CCK only)\n * @control.skip_table: skip externally configured rate table\n * @control.jiffies: timestamp for expiry on powersave clients\n * @control.vif: virtual interface (may be NULL)\n * @control.hw_key: key to encrypt with (may be NULL)\n * @control.flags: control flags, see &enum mac80211_tx_control_flags\n * @control.enqueue_time: enqueue time (for iTXQs)\n * @driver_rates: alias to @control.rates to reserve space\n * @pad: padding\n * @rate_driver_data: driver use area if driver needs @control.rates\n * @status: union part for status data\n * @status.rates: attempted rates\n * @status.ack_signal: ACK signal\n * @status.ampdu_ack_len: AMPDU ack length\n * @status.ampdu_len: AMPDU length\n * @status.antenna: (legacy, kept only for iwlegacy)\n * @status.tx_time: airtime consumed for transmission; note this is only\n *\tused for WMM AC, not for airtime fairness\n * @status.is_valid_ack_signal: ACK signal is valid\n * @status.status_driver_data: driver use area\n * @ack: union part for pure ACK data\n * @ack.cookie: cookie for the ACK\n * @driver_data: array of driver_data pointers\n * @ampdu_ack_len: number of acked aggregated frames.\n * \trelevant only if IEEE80211_TX_STAT_AMPDU was set.\n * @ampdu_len: number of aggregated frames.\n * \trelevant only if IEEE80211_TX_STAT_AMPDU was set.\n * @ack_signal: signal strength of the ACK frame\n */\nstruct ieee80211_tx_info {\n\t/* common information */\n\tu32 flags;\n\tu32 band:3,\n\t    ack_frame_id:13,\n\t    hw_queue:4,\n\t    tx_time_est:10;\n\t/* 2 free bits */\n\n\tunion {\n\t\tstruct {\n\t\t\tunion {\n\t\t\t\t/* rate control */\n\t\t\t\tstruct {\n\t\t\t\t\tstruct ieee80211_tx_rate rates[\n\t\t\t\t\t\tIEEE80211_TX_MAX_RATES];\n\t\t\t\t\ts8 rts_cts_rate_idx;\n\t\t\t\t\tu8 use_rts:1;\n\t\t\t\t\tu8 use_cts_prot:1;\n\t\t\t\t\tu8 short_preamble:1;\n\t\t\t\t\tu8 skip_table:1;\n\t\t\t\t\t/* 2 bytes free */\n\t\t\t\t};\n\t\t\t\t/* only needed before rate control */\n\t\t\t\tunsigned long jiffies;\n\t\t\t};\n\t\t\t/* NB: vif can be NULL for injected frames */\n\t\t\tstruct ieee80211_vif *vif;\n\t\t\tstruct ieee80211_key_conf *hw_key;\n\t\t\tu32 flags;\n\t\t\tcodel_time_t enqueue_time;\n\t\t} control;\n\t\tstruct {\n\t\t\tu64 cookie;\n\t\t} ack;\n\t\tstruct {\n\t\t\tstruct ieee80211_tx_rate rates[IEEE80211_TX_MAX_RATES];\n\t\t\ts32 ack_signal;\n\t\t\tu8 ampdu_ack_len;\n\t\t\tu8 ampdu_len;\n\t\t\tu8 antenna;\n\t\t\tu16 tx_time;\n\t\t\tbool is_valid_ack_signal;\n\t\t\tvoid *status_driver_data[19 / sizeof(void *)];\n\t\t} status;\n\t\tstruct {\n\t\t\tstruct ieee80211_tx_rate driver_rates[\n\t\t\t\tIEEE80211_TX_MAX_RATES];\n\t\t\tu8 pad[4];\n\n\t\t\tvoid *rate_driver_data[\n\t\t\t\tIEEE80211_TX_INFO_RATE_DRIVER_DATA_SIZE / sizeof(void *)];\n\t\t};\n\t\tvoid *driver_data[\n\t\t\tIEEE80211_TX_INFO_DRIVER_DATA_SIZE / sizeof(void *)];\n\t};\n};\n\nstatic inline u16\nieee80211_info_set_tx_time_est(struct ieee80211_tx_info *info, u16 tx_time_est)\n{\n\t/* We only have 10 bits in tx_time_est, so store airtime\n\t * in increments of 4us and clamp the maximum to 2**12-1\n\t */\n\tinfo->tx_time_est = min_t(u16, tx_time_est, 4095) >> 2;\n\treturn info->tx_time_est << 2;\n}\n\nstatic inline u16\nieee80211_info_get_tx_time_est(struct ieee80211_tx_info *info)\n{\n\treturn info->tx_time_est << 2;\n}\n\n/**\n * struct ieee80211_tx_status - extended tx status info for rate control\n *\n * @sta: Station that the packet was transmitted for\n * @info: Basic tx status information\n * @skb: Packet skb (can be NULL if not provided by the driver)\n * @rate: The TX rate that was used when sending the packet\n * @free_list: list where processed skbs are stored to be free'd by the driver\n */\nstruct ieee80211_tx_status {\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb;\n\tstruct rate_info *rate;\n\tstruct list_head *free_list;\n};\n\n/**\n * struct ieee80211_scan_ies - descriptors for different blocks of IEs\n *\n * This structure is used to point to different blocks of IEs in HW scan\n * and scheduled scan. These blocks contain the IEs passed by userspace\n * and the ones generated by mac80211.\n *\n * @ies: pointers to band specific IEs.\n * @len: lengths of band_specific IEs.\n * @common_ies: IEs for all bands (especially vendor specific ones)\n * @common_ie_len: length of the common_ies\n */\nstruct ieee80211_scan_ies {\n\tconst u8 *ies[NUM_NL80211_BANDS];\n\tsize_t len[NUM_NL80211_BANDS];\n\tconst u8 *common_ies;\n\tsize_t common_ie_len;\n};\n\n\nstatic inline struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb)\n{\n\treturn (struct ieee80211_tx_info *)skb->cb;\n}\n\nstatic inline struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb)\n{\n\treturn (struct ieee80211_rx_status *)skb->cb;\n}\n\n/**\n * ieee80211_tx_info_clear_status - clear TX status\n *\n * @info: The &struct ieee80211_tx_info to be cleared.\n *\n * When the driver passes an skb back to mac80211, it must report\n * a number of things in TX status. This function clears everything\n * in the TX status but the rate control information (it does clear\n * the count since you need to fill that in anyway).\n *\n * NOTE: You can only use this function if you do NOT use\n *\t info->driver_data! Use info->rate_driver_data\n *\t instead if you need only the less space that allows.\n */\nstatic inline void\nieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)\n{\n\tint i;\n\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=\n\t\t     offsetof(struct ieee80211_tx_info, control.rates));\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) !=\n\t\t     offsetof(struct ieee80211_tx_info, driver_rates));\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, status.rates) != 8);\n\t/* clear the rate counts */\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++)\n\t\tinfo->status.rates[i].count = 0;\n\n\tBUILD_BUG_ON(\n\t    offsetof(struct ieee80211_tx_info, status.ack_signal) != 20);\n\tmemset(&info->status.ampdu_ack_len, 0,\n\t       sizeof(struct ieee80211_tx_info) -\n\t       offsetof(struct ieee80211_tx_info, status.ampdu_ack_len));\n}\n\n\n/**\n * enum mac80211_rx_flags - receive flags\n *\n * These flags are used with the @flag member of &struct ieee80211_rx_status.\n * @RX_FLAG_MMIC_ERROR: Michael MIC error was reported on this frame.\n *\tUse together with %RX_FLAG_MMIC_STRIPPED.\n * @RX_FLAG_DECRYPTED: This frame was decrypted in hardware.\n * @RX_FLAG_MMIC_STRIPPED: the Michael MIC is stripped off this frame,\n *\tverification has been done by the hardware.\n * @RX_FLAG_IV_STRIPPED: The IV and ICV are stripped from this frame.\n *\tIf this flag is set, the stack cannot do any replay detection\n *\thence the driver or hardware will have to do that.\n * @RX_FLAG_PN_VALIDATED: Currently only valid for CCMP/GCMP frames, this\n *\tflag indicates that the PN was verified for replay protection.\n *\tNote that this flag is also currently only supported when a frame\n *\tis also decrypted (ie. @RX_FLAG_DECRYPTED must be set)\n * @RX_FLAG_DUP_VALIDATED: The driver should set this flag if it did\n *\tde-duplication by itself.\n * @RX_FLAG_FAILED_FCS_CRC: Set this flag if the FCS check failed on\n *\tthe frame.\n * @RX_FLAG_FAILED_PLCP_CRC: Set this flag if the PCLP check failed on\n *\tthe frame.\n * @RX_FLAG_MACTIME_START: The timestamp passed in the RX status (@mactime\n *\tfield) is valid and contains the time the first symbol of the MPDU\n *\twas received. This is useful in monitor mode and for proper IBSS\n *\tmerging.\n * @RX_FLAG_MACTIME_END: The timestamp passed in the RX status (@mactime\n *\tfield) is valid and contains the time the last symbol of the MPDU\n *\t(including FCS) was received.\n * @RX_FLAG_MACTIME_PLCP_START: The timestamp passed in the RX status (@mactime\n *\tfield) is valid and contains the time the SYNC preamble was received.\n * @RX_FLAG_NO_SIGNAL_VAL: The signal strength value is not present.\n *\tValid only for data frames (mainly A-MPDU)\n * @RX_FLAG_AMPDU_DETAILS: A-MPDU details are known, in particular the reference\n *\tnumber (@ampdu_reference) must be populated and be a distinct number for\n *\teach A-MPDU\n * @RX_FLAG_AMPDU_LAST_KNOWN: last subframe is known, should be set on all\n *\tsubframes of a single A-MPDU\n * @RX_FLAG_AMPDU_IS_LAST: this subframe is the last subframe of the A-MPDU\n * @RX_FLAG_AMPDU_DELIM_CRC_ERROR: A delimiter CRC error has been detected\n *\ton this subframe\n * @RX_FLAG_AMPDU_DELIM_CRC_KNOWN: The delimiter CRC field is known (the CRC\n *\tis stored in the @ampdu_delimiter_crc field)\n * @RX_FLAG_MIC_STRIPPED: The mic was stripped of this packet. Decryption was\n *\tdone by the hardware\n * @RX_FLAG_ONLY_MONITOR: Report frame only to monitor interfaces without\n *\tprocessing it in any regular way.\n *\tThis is useful if drivers offload some frames but still want to report\n *\tthem for sniffing purposes.\n * @RX_FLAG_SKIP_MONITOR: Process and report frame to all interfaces except\n *\tmonitor interfaces.\n *\tThis is useful if drivers offload some frames but still want to report\n *\tthem for sniffing purposes.\n * @RX_FLAG_AMSDU_MORE: Some drivers may prefer to report separate A-MSDU\n *\tsubframes instead of a one huge frame for performance reasons.\n *\tAll, but the last MSDU from an A-MSDU should have this flag set. E.g.\n *\tif an A-MSDU has 3 frames, the first 2 must have the flag set, while\n *\tthe 3rd (last) one must not have this flag set. The flag is used to\n *\tdeal with retransmission/duplication recovery properly since A-MSDU\n *\tsubframes share the same sequence number. Reported subframes can be\n *\teither regular MSDU or singly A-MSDUs. Subframes must not be\n *\tinterleaved with other frames.\n * @RX_FLAG_RADIOTAP_VENDOR_DATA: This frame contains vendor-specific\n *\tradiotap data in the skb->data (before the frame) as described by\n *\tthe &struct ieee80211_vendor_radiotap.\n * @RX_FLAG_ALLOW_SAME_PN: Allow the same PN as same packet before.\n *\tThis is used for AMSDU subframes which can have the same PN as\n *\tthe first subframe.\n * @RX_FLAG_ICV_STRIPPED: The ICV is stripped from this frame. CRC checking must\n *\tbe done in the hardware.\n * @RX_FLAG_AMPDU_EOF_BIT: Value of the EOF bit in the A-MPDU delimiter for this\n *\tframe\n * @RX_FLAG_AMPDU_EOF_BIT_KNOWN: The EOF value is known\n * @RX_FLAG_RADIOTAP_HE: HE radiotap data is present\n *\t(&struct ieee80211_radiotap_he, mac80211 will fill in\n *\t\n *\t - DATA3_DATA_MCS\n *\t - DATA3_DATA_DCM\n *\t - DATA3_CODING\n *\t - DATA5_GI\n *\t - DATA5_DATA_BW_RU_ALLOC\n *\t - DATA6_NSTS\n *\t - DATA3_STBC\n *\t\n *\tfrom the RX info data, so leave those zeroed when building this data)\n * @RX_FLAG_RADIOTAP_HE_MU: HE MU radiotap data is present\n *\t(&struct ieee80211_radiotap_he_mu)\n * @RX_FLAG_RADIOTAP_LSIG: L-SIG radiotap data is present\n * @RX_FLAG_NO_PSDU: use the frame only for radiotap reporting, with\n *\tthe \"0-length PSDU\" field included there.  The value for it is\n *\tin &struct ieee80211_rx_status.  Note that if this value isn't\n *\tknown the frame shouldn't be reported.\n * @RX_FLAG_8023: the frame has an 802.3 header (decap offload performed by\n *\thardware or driver)\n */\nenum mac80211_rx_flags {\n\tRX_FLAG_MMIC_ERROR\t\t= BIT(0),\n\tRX_FLAG_DECRYPTED\t\t= BIT(1),\n\tRX_FLAG_MACTIME_PLCP_START\t= BIT(2),\n\tRX_FLAG_MMIC_STRIPPED\t\t= BIT(3),\n\tRX_FLAG_IV_STRIPPED\t\t= BIT(4),\n\tRX_FLAG_FAILED_FCS_CRC\t\t= BIT(5),\n\tRX_FLAG_FAILED_PLCP_CRC \t= BIT(6),\n\tRX_FLAG_MACTIME_START\t\t= BIT(7),\n\tRX_FLAG_NO_SIGNAL_VAL\t\t= BIT(8),\n\tRX_FLAG_AMPDU_DETAILS\t\t= BIT(9),\n\tRX_FLAG_PN_VALIDATED\t\t= BIT(10),\n\tRX_FLAG_DUP_VALIDATED\t\t= BIT(11),\n\tRX_FLAG_AMPDU_LAST_KNOWN\t= BIT(12),\n\tRX_FLAG_AMPDU_IS_LAST\t\t= BIT(13),\n\tRX_FLAG_AMPDU_DELIM_CRC_ERROR\t= BIT(14),\n\tRX_FLAG_AMPDU_DELIM_CRC_KNOWN\t= BIT(15),\n\tRX_FLAG_MACTIME_END\t\t= BIT(16),\n\tRX_FLAG_ONLY_MONITOR\t\t= BIT(17),\n\tRX_FLAG_SKIP_MONITOR\t\t= BIT(18),\n\tRX_FLAG_AMSDU_MORE\t\t= BIT(19),\n\tRX_FLAG_RADIOTAP_VENDOR_DATA\t= BIT(20),\n\tRX_FLAG_MIC_STRIPPED\t\t= BIT(21),\n\tRX_FLAG_ALLOW_SAME_PN\t\t= BIT(22),\n\tRX_FLAG_ICV_STRIPPED\t\t= BIT(23),\n\tRX_FLAG_AMPDU_EOF_BIT\t\t= BIT(24),\n\tRX_FLAG_AMPDU_EOF_BIT_KNOWN\t= BIT(25),\n\tRX_FLAG_RADIOTAP_HE\t\t= BIT(26),\n\tRX_FLAG_RADIOTAP_HE_MU\t\t= BIT(27),\n\tRX_FLAG_RADIOTAP_LSIG\t\t= BIT(28),\n\tRX_FLAG_NO_PSDU\t\t\t= BIT(29),\n\tRX_FLAG_8023\t\t\t= BIT(30),\n};\n\n/**\n * enum mac80211_rx_encoding_flags - MCS & bandwidth flags\n *\n * @RX_ENC_FLAG_SHORTPRE: Short preamble was used for this frame\n * @RX_ENC_FLAG_SHORT_GI: Short guard interval was used\n * @RX_ENC_FLAG_HT_GF: This frame was received in a HT-greenfield transmission,\n *\tif the driver fills this value it should add\n *\t%IEEE80211_RADIOTAP_MCS_HAVE_FMT\n *\tto @hw.radiotap_mcs_details to advertise that fact.\n * @RX_ENC_FLAG_LDPC: LDPC was used\n * @RX_ENC_FLAG_STBC_MASK: STBC 2 bit bitmask. 1 - Nss=1, 2 - Nss=2, 3 - Nss=3\n * @RX_ENC_FLAG_BF: packet was beamformed\n */\nenum mac80211_rx_encoding_flags {\n\tRX_ENC_FLAG_SHORTPRE\t\t= BIT(0),\n\tRX_ENC_FLAG_SHORT_GI\t\t= BIT(2),\n\tRX_ENC_FLAG_HT_GF\t\t= BIT(3),\n\tRX_ENC_FLAG_STBC_MASK\t\t= BIT(4) | BIT(5),\n\tRX_ENC_FLAG_LDPC\t\t= BIT(6),\n\tRX_ENC_FLAG_BF\t\t\t= BIT(7),\n};\n\n#define RX_ENC_FLAG_STBC_SHIFT\t\t4\n\nenum mac80211_rx_encoding {\n\tRX_ENC_LEGACY = 0,\n\tRX_ENC_HT,\n\tRX_ENC_VHT,\n\tRX_ENC_HE,\n};\n\n/**\n * struct ieee80211_rx_status - receive status\n *\n * The low-level driver should provide this information (the subset\n * supported by hardware) to the 802.11 code with each received\n * frame, in the skb's control buffer (cb).\n *\n * @mactime: value in microseconds of the 64-bit Time Synchronization Function\n * \t(TSF) timer when the first data symbol (MPDU) arrived at the hardware.\n * @boottime_ns: CLOCK_BOOTTIME timestamp the frame was received at, this is\n *\tneeded only for beacons and probe responses that update the scan cache.\n * @device_timestamp: arbitrary timestamp for the device, mac80211 doesn't use\n *\tit but can store it and pass it back to the driver for synchronisation\n * @band: the active band when this frame was received\n * @freq: frequency the radio was tuned to when receiving this frame, in MHz\n *\tThis field must be set for management frames, but isn't strictly needed\n *\tfor data (other) frames - for those it only affects radiotap reporting.\n * @freq_offset: @freq has a positive offset of 500Khz.\n * @signal: signal strength when receiving this frame, either in dBm, in dB or\n *\tunspecified depending on the hardware capabilities flags\n *\t@IEEE80211_HW_SIGNAL_*\n * @chains: bitmask of receive chains for which separate signal strength\n *\tvalues were filled.\n * @chain_signal: per-chain signal strength, in dBm (unlike @signal, doesn't\n *\tsupport dB or unspecified units)\n * @antenna: antenna used\n * @rate_idx: index of data rate into band's supported rates or MCS index if\n *\tHT or VHT is used (%RX_FLAG_HT/%RX_FLAG_VHT)\n * @nss: number of streams (VHT and HE only)\n * @flag: %RX_FLAG_\\*\n * @encoding: &enum mac80211_rx_encoding\n * @bw: &enum rate_info_bw\n * @enc_flags: uses bits from &enum mac80211_rx_encoding_flags\n * @he_ru: HE RU, from &enum nl80211_he_ru_alloc\n * @he_gi: HE GI, from &enum nl80211_he_gi\n * @he_dcm: HE DCM value\n * @rx_flags: internal RX flags for mac80211\n * @ampdu_reference: A-MPDU reference number, must be a different value for\n *\teach A-MPDU but the same for each subframe within one A-MPDU\n * @ampdu_delimiter_crc: A-MPDU delimiter CRC\n * @zero_length_psdu_type: radiotap type of the 0-length PSDU\n */\nstruct ieee80211_rx_status {\n\tu64 mactime;\n\tu64 boottime_ns;\n\tu32 device_timestamp;\n\tu32 ampdu_reference;\n\tu32 flag;\n\tu16 freq: 13, freq_offset: 1;\n\tu8 enc_flags;\n\tu8 encoding:2, bw:3, he_ru:3;\n\tu8 he_gi:2, he_dcm:1;\n\tu8 rate_idx;\n\tu8 nss;\n\tu8 rx_flags;\n\tu8 band;\n\tu8 antenna;\n\ts8 signal;\n\tu8 chains;\n\ts8 chain_signal[IEEE80211_MAX_CHAINS];\n\tu8 ampdu_delimiter_crc;\n\tu8 zero_length_psdu_type;\n};\n\nstatic inline u32\nieee80211_rx_status_to_khz(struct ieee80211_rx_status *rx_status)\n{\n\treturn MHZ_TO_KHZ(rx_status->freq) +\n\t       (rx_status->freq_offset ? 500 : 0);\n}\n\n/**\n * struct ieee80211_vendor_radiotap - vendor radiotap data information\n * @present: presence bitmap for this vendor namespace\n *\t(this could be extended in the future if any vendor needs more\n *\t bits, the radiotap spec does allow for that)\n * @align: radiotap vendor namespace alignment. This defines the needed\n *\talignment for the @data field below, not for the vendor namespace\n *\tdescription itself (which has a fixed 2-byte alignment)\n *\tMust be a power of two, and be set to at least 1!\n * @oui: radiotap vendor namespace OUI\n * @subns: radiotap vendor sub namespace\n * @len: radiotap vendor sub namespace skip length, if alignment is done\n *\tthen that's added to this, i.e. this is only the length of the\n *\t@data field.\n * @pad: number of bytes of padding after the @data, this exists so that\n *\tthe skb data alignment can be preserved even if the data has odd\n *\tlength\n * @data: the actual vendor namespace data\n *\n * This struct, including the vendor data, goes into the skb->data before\n * the 802.11 header. It's split up in mac80211 using the align/oui/subns\n * data.\n */\nstruct ieee80211_vendor_radiotap {\n\tu32 present;\n\tu8 align;\n\tu8 oui[3];\n\tu8 subns;\n\tu8 pad;\n\tu16 len;\n\tu8 data[];\n} __packed;\n\n/**\n * enum ieee80211_conf_flags - configuration flags\n *\n * Flags to define PHY configuration options\n *\n * @IEEE80211_CONF_MONITOR: there's a monitor interface present -- use this\n *\tto determine for example whether to calculate timestamps for packets\n *\tor not, do not use instead of filter flags!\n * @IEEE80211_CONF_PS: Enable 802.11 power save mode (managed mode only).\n *\tThis is the power save mode defined by IEEE 802.11-2007 section 11.2,\n *\tmeaning that the hardware still wakes up for beacons, is able to\n *\ttransmit frames and receive the possible acknowledgment frames.\n *\tNot to be confused with hardware specific wakeup/sleep states,\n *\tdriver is responsible for that. See the section \"Powersave support\"\n *\tfor more.\n * @IEEE80211_CONF_IDLE: The device is running, but idle; if the flag is set\n *\tthe driver should be prepared to handle configuration requests but\n *\tmay turn the device off as much as possible. Typically, this flag will\n *\tbe set when an interface is set UP but not associated or scanning, but\n *\tit can also be unset in that case when monitor interfaces are active.\n * @IEEE80211_CONF_OFFCHANNEL: The device is currently not on its main\n *\toperating channel.\n */\nenum ieee80211_conf_flags {\n\tIEEE80211_CONF_MONITOR\t\t= (1<<0),\n\tIEEE80211_CONF_PS\t\t= (1<<1),\n\tIEEE80211_CONF_IDLE\t\t= (1<<2),\n\tIEEE80211_CONF_OFFCHANNEL\t= (1<<3),\n};\n\n\n/**\n * enum ieee80211_conf_changed - denotes which configuration changed\n *\n * @IEEE80211_CONF_CHANGE_LISTEN_INTERVAL: the listen interval changed\n * @IEEE80211_CONF_CHANGE_MONITOR: the monitor flag changed\n * @IEEE80211_CONF_CHANGE_PS: the PS flag or dynamic PS timeout changed\n * @IEEE80211_CONF_CHANGE_POWER: the TX power changed\n * @IEEE80211_CONF_CHANGE_CHANNEL: the channel/channel_type changed\n * @IEEE80211_CONF_CHANGE_RETRY_LIMITS: retry limits changed\n * @IEEE80211_CONF_CHANGE_IDLE: Idle flag changed\n * @IEEE80211_CONF_CHANGE_SMPS: Spatial multiplexing powersave mode changed\n *\tNote that this is only valid if channel contexts are not used,\n *\totherwise each channel context has the number of chains listed.\n */\nenum ieee80211_conf_changed {\n\tIEEE80211_CONF_CHANGE_SMPS\t\t= BIT(1),\n\tIEEE80211_CONF_CHANGE_LISTEN_INTERVAL\t= BIT(2),\n\tIEEE80211_CONF_CHANGE_MONITOR\t\t= BIT(3),\n\tIEEE80211_CONF_CHANGE_PS\t\t= BIT(4),\n\tIEEE80211_CONF_CHANGE_POWER\t\t= BIT(5),\n\tIEEE80211_CONF_CHANGE_CHANNEL\t\t= BIT(6),\n\tIEEE80211_CONF_CHANGE_RETRY_LIMITS\t= BIT(7),\n\tIEEE80211_CONF_CHANGE_IDLE\t\t= BIT(8),\n};\n\n/**\n * enum ieee80211_smps_mode - spatial multiplexing power save mode\n *\n * @IEEE80211_SMPS_AUTOMATIC: automatic\n * @IEEE80211_SMPS_OFF: off\n * @IEEE80211_SMPS_STATIC: static\n * @IEEE80211_SMPS_DYNAMIC: dynamic\n * @IEEE80211_SMPS_NUM_MODES: internal, don't use\n */\nenum ieee80211_smps_mode {\n\tIEEE80211_SMPS_AUTOMATIC,\n\tIEEE80211_SMPS_OFF,\n\tIEEE80211_SMPS_STATIC,\n\tIEEE80211_SMPS_DYNAMIC,\n\n\t/* keep last */\n\tIEEE80211_SMPS_NUM_MODES,\n};\n\n/**\n * struct ieee80211_conf - configuration of the device\n *\n * This struct indicates how the driver shall configure the hardware.\n *\n * @flags: configuration flags defined above\n *\n * @listen_interval: listen interval in units of beacon interval\n * @ps_dtim_period: The DTIM period of the AP we're connected to, for use\n *\tin power saving. Power saving will not be enabled until a beacon\n *\thas been received and the DTIM period is known.\n * @dynamic_ps_timeout: The dynamic powersave timeout (in ms), see the\n *\tpowersave documentation below. This variable is valid only when\n *\tthe CONF_PS flag is set.\n *\n * @power_level: requested transmit power (in dBm), backward compatibility\n *\tvalue only that is set to the minimum of all interfaces\n *\n * @chandef: the channel definition to tune to\n * @radar_enabled: whether radar detection is enabled\n *\n * @long_frame_max_tx_count: Maximum number of transmissions for a \"long\" frame\n *\t(a frame not RTS protected), called \"dot11LongRetryLimit\" in 802.11,\n *\tbut actually means the number of transmissions not the number of retries\n * @short_frame_max_tx_count: Maximum number of transmissions for a \"short\"\n *\tframe, called \"dot11ShortRetryLimit\" in 802.11, but actually means the\n *\tnumber of transmissions not the number of retries\n *\n * @smps_mode: spatial multiplexing powersave mode; note that\n *\t%IEEE80211_SMPS_STATIC is used when the device is not\n *\tconfigured for an HT channel.\n *\tNote that this is only valid if channel contexts are not used,\n *\totherwise each channel context has the number of chains listed.\n */\nstruct ieee80211_conf {\n\tu32 flags;\n\tint power_level, dynamic_ps_timeout;\n\n\tu16 listen_interval;\n\tu8 ps_dtim_period;\n\n\tu8 long_frame_max_tx_count, short_frame_max_tx_count;\n\n\tstruct cfg80211_chan_def chandef;\n\tbool radar_enabled;\n\tenum ieee80211_smps_mode smps_mode;\n};\n\n/**\n * struct ieee80211_channel_switch - holds the channel switch data\n *\n * The information provided in this structure is required for channel switch\n * operation.\n *\n * @timestamp: value in microseconds of the 64-bit Time Synchronization\n *\tFunction (TSF) timer when the frame containing the channel switch\n *\tannouncement was received. This is simply the rx.mactime parameter\n *\tthe driver passed into mac80211.\n * @device_timestamp: arbitrary timestamp for the device, this is the\n *\trx.device_timestamp parameter the driver passed to mac80211.\n * @block_tx: Indicates whether transmission must be blocked before the\n *\tscheduled channel switch, as indicated by the AP.\n * @chandef: the new channel to switch to\n * @count: the number of TBTT's until the channel switch event\n * @delay: maximum delay between the time the AP transmitted the last beacon in\n  *\tcurrent channel and the expected time of the first beacon in the new\n  *\tchannel, expressed in TU.\n */\nstruct ieee80211_channel_switch {\n\tu64 timestamp;\n\tu32 device_timestamp;\n\tbool block_tx;\n\tstruct cfg80211_chan_def chandef;\n\tu8 count;\n\tu32 delay;\n};\n\n/**\n * enum ieee80211_vif_flags - virtual interface flags\n *\n * @IEEE80211_VIF_BEACON_FILTER: the device performs beacon filtering\n *\ton this virtual interface to avoid unnecessary CPU wakeups\n * @IEEE80211_VIF_SUPPORTS_CQM_RSSI: the device can do connection quality\n *\tmonitoring on this virtual interface -- i.e. it can monitor\n *\tconnection quality related parameters, such as the RSSI level and\n *\tprovide notifications if configured trigger levels are reached.\n * @IEEE80211_VIF_SUPPORTS_UAPSD: The device can do U-APSD for this\n *\tinterface. This flag should be set during interface addition,\n *\tbut may be set/cleared as late as authentication to an AP. It is\n *\tonly valid for managed/station mode interfaces.\n * @IEEE80211_VIF_GET_NOA_UPDATE: request to handle NOA attributes\n *\tand send P2P_PS notification to the driver if NOA changed, even\n *\tthis is not pure P2P vif.\n */\nenum ieee80211_vif_flags {\n\tIEEE80211_VIF_BEACON_FILTER\t\t= BIT(0),\n\tIEEE80211_VIF_SUPPORTS_CQM_RSSI\t\t= BIT(1),\n\tIEEE80211_VIF_SUPPORTS_UAPSD\t\t= BIT(2),\n\tIEEE80211_VIF_GET_NOA_UPDATE\t\t= BIT(3),\n};\n\n\n/**\n * enum ieee80211_offload_flags - virtual interface offload flags\n *\n * @IEEE80211_OFFLOAD_ENCAP_ENABLED: tx encapsulation offload is enabled\n *\tThe driver supports sending frames passed as 802.3 frames by mac80211.\n *\tIt must also support sending 802.11 packets for the same interface.\n * @IEEE80211_OFFLOAD_ENCAP_4ADDR: support 4-address mode encapsulation offload\n * @IEEE80211_OFFLOAD_DECAP_ENABLED: rx encapsulation offload is enabled\n *\tThe driver supports passing received 802.11 frames as 802.3 frames to\n *\tmac80211.\n */\n\nenum ieee80211_offload_flags {\n\tIEEE80211_OFFLOAD_ENCAP_ENABLED\t\t= BIT(0),\n\tIEEE80211_OFFLOAD_ENCAP_4ADDR\t\t= BIT(1),\n\tIEEE80211_OFFLOAD_DECAP_ENABLED\t\t= BIT(2),\n};\n\n/**\n * struct ieee80211_vif - per-interface data\n *\n * Data in this structure is continually present for driver\n * use during the life of a virtual interface.\n *\n * @type: type of this virtual interface\n * @bss_conf: BSS configuration for this interface, either our own\n *\tor the BSS we're associated to\n * @addr: address of this interface\n * @p2p: indicates whether this AP or STA interface is a p2p\n *\tinterface, i.e. a GO or p2p-sta respectively\n * @csa_active: marks whether a channel switch is going on. Internally it is\n *\twrite-protected by sdata_lock and local->mtx so holding either is fine\n *\tfor read access.\n * @mu_mimo_owner: indicates interface owns MU-MIMO capability\n * @driver_flags: flags/capabilities the driver has for this interface,\n *\tthese need to be set (or cleared) when the interface is added\n *\tor, if supported by the driver, the interface type is changed\n *\tat runtime, mac80211 will never touch this field\n * @offloaad_flags: hardware offload capabilities/flags for this interface.\n *\tThese are initialized by mac80211 before calling .add_interface,\n *\t.change_interface or .update_vif_offload and updated by the driver\n *\twithin these ops, based on supported features or runtime change\n *\trestrictions.\n * @hw_queue: hardware queue for each AC\n * @cab_queue: content-after-beacon (DTIM beacon really) queue, AP mode only\n * @chanctx_conf: The channel context this interface is assigned to, or %NULL\n *\twhen it is not assigned. This pointer is RCU-protected due to the TX\n *\tpath needing to access it; even though the netdev carrier will always\n *\tbe off when it is %NULL there can still be races and packets could be\n *\tprocessed after it switches back to %NULL.\n * @debugfs_dir: debugfs dentry, can be used by drivers to create own per\n *\tinterface debug files. Note that it will be NULL for the virtual\n *\tmonitor interface (if that is requested.)\n * @probe_req_reg: probe requests should be reported to mac80211 for this\n *\tinterface.\n * @rx_mcast_action_reg: multicast Action frames should be reported to mac80211\n *\tfor this interface.\n * @drv_priv: data area for driver use, will always be aligned to\n *\tsizeof(void \\*).\n * @txq: the multicast data TX queue (if driver uses the TXQ abstraction)\n * @txqs_stopped: per AC flag to indicate that intermediate TXQs are stopped,\n *\tprotected by fq->lock.\n * @offload_flags: 802.3 -> 802.11 enapsulation offload flags, see\n *\t&enum ieee80211_offload_flags.\n */\nstruct ieee80211_vif {\n\tenum nl80211_iftype type;\n\tstruct ieee80211_bss_conf bss_conf;\n\tu8 addr[ETH_ALEN] __aligned(2);\n\tbool p2p;\n\tbool csa_active;\n\tbool mu_mimo_owner;\n\n\tu8 cab_queue;\n\tu8 hw_queue[IEEE80211_NUM_ACS];\n\n\tstruct ieee80211_txq *txq;\n\n\tstruct ieee80211_chanctx_conf __rcu *chanctx_conf;\n\n\tu32 driver_flags;\n\tu32 offload_flags;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct dentry *debugfs_dir;\n#endif\n\n\tbool probe_req_reg;\n\tbool rx_mcast_action_reg;\n\n\tbool txqs_stopped[IEEE80211_NUM_ACS];\n\n\t/* must be last */\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\nstatic inline bool ieee80211_vif_is_mesh(struct ieee80211_vif *vif)\n{\n#ifdef CONFIG_MAC80211_MESH\n\treturn vif->type == NL80211_IFTYPE_MESH_POINT;\n#endif\n\treturn false;\n}\n\n/**\n * wdev_to_ieee80211_vif - return a vif struct from a wdev\n * @wdev: the wdev to get the vif for\n *\n * This can be used by mac80211 drivers with direct cfg80211 APIs\n * (like the vendor commands) that get a wdev.\n *\n * Note that this function may return %NULL if the given wdev isn't\n * associated with a vif that the driver knows about (e.g. monitor\n * or AP_VLAN interfaces.)\n */\nstruct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev);\n\n/**\n * ieee80211_vif_to_wdev - return a wdev struct from a vif\n * @vif: the vif to get the wdev for\n *\n * This can be used by mac80211 drivers with direct cfg80211 APIs\n * (like the vendor commands) that needs to get the wdev for a vif.\n * This can also be useful to get the netdev associated to a vif.\n */\nstruct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif);\n\n/**\n * enum ieee80211_key_flags - key flags\n *\n * These flags are used for communication about keys between the driver\n * and mac80211, with the @flags parameter of &struct ieee80211_key_conf.\n *\n * @IEEE80211_KEY_FLAG_GENERATE_IV: This flag should be set by the\n *\tdriver to indicate that it requires IV generation for this\n *\tparticular key. Setting this flag does not necessarily mean that SKBs\n *\twill have sufficient tailroom for ICV or MIC.\n * @IEEE80211_KEY_FLAG_GENERATE_MMIC: This flag should be set by\n *\tthe driver for a TKIP key if it requires Michael MIC\n *\tgeneration in software.\n * @IEEE80211_KEY_FLAG_PAIRWISE: Set by mac80211, this flag indicates\n *\tthat the key is pairwise rather then a shared key.\n * @IEEE80211_KEY_FLAG_SW_MGMT_TX: This flag should be set by the driver for a\n *\tCCMP/GCMP key if it requires CCMP/GCMP encryption of management frames\n *\t(MFP) to be done in software.\n * @IEEE80211_KEY_FLAG_PUT_IV_SPACE: This flag should be set by the driver\n *\tif space should be prepared for the IV, but the IV\n *\titself should not be generated. Do not set together with\n *\t@IEEE80211_KEY_FLAG_GENERATE_IV on the same key. Setting this flag does\n *\tnot necessarily mean that SKBs will have sufficient tailroom for ICV or\n *\tMIC.\n * @IEEE80211_KEY_FLAG_RX_MGMT: This key will be used to decrypt received\n *\tmanagement frames. The flag can help drivers that have a hardware\n *\tcrypto implementation that doesn't deal with management frames\n *\tproperly by allowing them to not upload the keys to hardware and\n *\tfall back to software crypto. Note that this flag deals only with\n *\tRX, if your crypto engine can't deal with TX you can also set the\n *\t%IEEE80211_KEY_FLAG_SW_MGMT_TX flag to encrypt such frames in SW.\n * @IEEE80211_KEY_FLAG_GENERATE_IV_MGMT: This flag should be set by the\n *\tdriver for a CCMP/GCMP key to indicate that is requires IV generation\n *\tonly for management frames (MFP).\n * @IEEE80211_KEY_FLAG_RESERVE_TAILROOM: This flag should be set by the\n *\tdriver for a key to indicate that sufficient tailroom must always\n *\tbe reserved for ICV or MIC, even when HW encryption is enabled.\n * @IEEE80211_KEY_FLAG_PUT_MIC_SPACE: This flag should be set by the driver for\n *\ta TKIP key if it only requires MIC space. Do not set together with\n *\t@IEEE80211_KEY_FLAG_GENERATE_MMIC on the same key.\n * @IEEE80211_KEY_FLAG_NO_AUTO_TX: Key needs explicit Tx activation.\n * @IEEE80211_KEY_FLAG_GENERATE_MMIE: This flag should be set by the driver\n *\tfor a AES_CMAC key to indicate that it requires sequence number\n *\tgeneration only\n */\nenum ieee80211_key_flags {\n\tIEEE80211_KEY_FLAG_GENERATE_IV_MGMT\t= BIT(0),\n\tIEEE80211_KEY_FLAG_GENERATE_IV\t\t= BIT(1),\n\tIEEE80211_KEY_FLAG_GENERATE_MMIC\t= BIT(2),\n\tIEEE80211_KEY_FLAG_PAIRWISE\t\t= BIT(3),\n\tIEEE80211_KEY_FLAG_SW_MGMT_TX\t\t= BIT(4),\n\tIEEE80211_KEY_FLAG_PUT_IV_SPACE\t\t= BIT(5),\n\tIEEE80211_KEY_FLAG_RX_MGMT\t\t= BIT(6),\n\tIEEE80211_KEY_FLAG_RESERVE_TAILROOM\t= BIT(7),\n\tIEEE80211_KEY_FLAG_PUT_MIC_SPACE\t= BIT(8),\n\tIEEE80211_KEY_FLAG_NO_AUTO_TX\t\t= BIT(9),\n\tIEEE80211_KEY_FLAG_GENERATE_MMIE\t= BIT(10),\n};\n\n/**\n * struct ieee80211_key_conf - key information\n *\n * This key information is given by mac80211 to the driver by\n * the set_key() callback in &struct ieee80211_ops.\n *\n * @hw_key_idx: To be set by the driver, this is the key index the driver\n *\twants to be given when a frame is transmitted and needs to be\n *\tencrypted in hardware.\n * @cipher: The key's cipher suite selector.\n * @tx_pn: PN used for TX keys, may be used by the driver as well if it\n *\tneeds to do software PN assignment by itself (e.g. due to TSO)\n * @flags: key flags, see &enum ieee80211_key_flags.\n * @keyidx: the key index (0-3)\n * @keylen: key material length\n * @key: key material. For ALG_TKIP the key is encoded as a 256-bit (32 byte)\n * \tdata block:\n * \t- Temporal Encryption Key (128 bits)\n * \t- Temporal Authenticator Tx MIC Key (64 bits)\n * \t- Temporal Authenticator Rx MIC Key (64 bits)\n * @icv_len: The ICV length for this key type\n * @iv_len: The IV length for this key type\n */\nstruct ieee80211_key_conf {\n\tatomic64_t tx_pn;\n\tu32 cipher;\n\tu8 icv_len;\n\tu8 iv_len;\n\tu8 hw_key_idx;\n\ts8 keyidx;\n\tu16 flags;\n\tu8 keylen;\n\tu8 key[];\n};\n\n#define IEEE80211_MAX_PN_LEN\t16\n\n#define TKIP_PN_TO_IV16(pn) ((u16)(pn & 0xffff))\n#define TKIP_PN_TO_IV32(pn) ((u32)((pn >> 16) & 0xffffffff))\n\n/**\n * struct ieee80211_key_seq - key sequence counter\n *\n * @tkip: TKIP data, containing IV32 and IV16 in host byte order\n * @ccmp: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @aes_cmac: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @aes_gmac: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @gcmp: PN data, most significant byte first (big endian,\n *\treverse order than in packet)\n * @hw: data for HW-only (e.g. cipher scheme) keys\n */\nstruct ieee80211_key_seq {\n\tunion {\n\t\tstruct {\n\t\t\tu32 iv32;\n\t\t\tu16 iv16;\n\t\t} tkip;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} ccmp;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} aes_cmac;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} aes_gmac;\n\t\tstruct {\n\t\t\tu8 pn[6];\n\t\t} gcmp;\n\t\tstruct {\n\t\t\tu8 seq[IEEE80211_MAX_PN_LEN];\n\t\t\tu8 seq_len;\n\t\t} hw;\n\t};\n};\n\n/**\n * struct ieee80211_cipher_scheme - cipher scheme\n *\n * This structure contains a cipher scheme information defining\n * the secure packet crypto handling.\n *\n * @cipher: a cipher suite selector\n * @iftype: a cipher iftype bit mask indicating an allowed cipher usage\n * @hdr_len: a length of a security header used the cipher\n * @pn_len: a length of a packet number in the security header\n * @pn_off: an offset of pn from the beginning of the security header\n * @key_idx_off: an offset of key index byte in the security header\n * @key_idx_mask: a bit mask of key_idx bits\n * @key_idx_shift: a bit shift needed to get key_idx\n *     key_idx value calculation:\n *      (sec_header_base[key_idx_off] & key_idx_mask) >> key_idx_shift\n * @mic_len: a mic length in bytes\n */\nstruct ieee80211_cipher_scheme {\n\tu32 cipher;\n\tu16 iftype;\n\tu8 hdr_len;\n\tu8 pn_len;\n\tu8 pn_off;\n\tu8 key_idx_off;\n\tu8 key_idx_mask;\n\tu8 key_idx_shift;\n\tu8 mic_len;\n};\n\n/**\n * enum set_key_cmd - key command\n *\n * Used with the set_key() callback in &struct ieee80211_ops, this\n * indicates whether a key is being removed or added.\n *\n * @SET_KEY: a key is set\n * @DISABLE_KEY: a key must be disabled\n */\nenum set_key_cmd {\n\tSET_KEY, DISABLE_KEY,\n};\n\n/**\n * enum ieee80211_sta_state - station state\n *\n * @IEEE80211_STA_NOTEXIST: station doesn't exist at all,\n *\tthis is a special state for add/remove transitions\n * @IEEE80211_STA_NONE: station exists without special state\n * @IEEE80211_STA_AUTH: station is authenticated\n * @IEEE80211_STA_ASSOC: station is associated\n * @IEEE80211_STA_AUTHORIZED: station is authorized (802.1X)\n */\nenum ieee80211_sta_state {\n\t/* NOTE: These need to be ordered correctly! */\n\tIEEE80211_STA_NOTEXIST,\n\tIEEE80211_STA_NONE,\n\tIEEE80211_STA_AUTH,\n\tIEEE80211_STA_ASSOC,\n\tIEEE80211_STA_AUTHORIZED,\n};\n\n/**\n * enum ieee80211_sta_rx_bandwidth - station RX bandwidth\n * @IEEE80211_STA_RX_BW_20: station can only receive 20 MHz\n * @IEEE80211_STA_RX_BW_40: station can receive up to 40 MHz\n * @IEEE80211_STA_RX_BW_80: station can receive up to 80 MHz\n * @IEEE80211_STA_RX_BW_160: station can receive up to 160 MHz\n *\t(including 80+80 MHz)\n *\n * Implementation note: 20 must be zero to be initialized\n *\tcorrectly, the values must be sorted.\n */\nenum ieee80211_sta_rx_bandwidth {\n\tIEEE80211_STA_RX_BW_20 = 0,\n\tIEEE80211_STA_RX_BW_40,\n\tIEEE80211_STA_RX_BW_80,\n\tIEEE80211_STA_RX_BW_160,\n};\n\n/**\n * struct ieee80211_sta_rates - station rate selection table\n *\n * @rcu_head: RCU head used for freeing the table on update\n * @rate: transmit rates/flags to be used by default.\n *\tOverriding entries per-packet is possible by using cb tx control.\n */\nstruct ieee80211_sta_rates {\n\tstruct rcu_head rcu_head;\n\tstruct {\n\t\ts8 idx;\n\t\tu8 count;\n\t\tu8 count_cts;\n\t\tu8 count_rts;\n\t\tu16 flags;\n\t} rate[IEEE80211_TX_RATE_TABLE_SIZE];\n};\n\n/**\n * struct ieee80211_sta_txpwr - station txpower configuration\n *\n * Used to configure txpower for station.\n *\n * @power: indicates the tx power, in dBm, to be used when sending data frames\n *\tto the STA.\n * @type: In particular if TPC %type is NL80211_TX_POWER_LIMITED then tx power\n *\twill be less than or equal to specified from userspace, whereas if TPC\n *\t%type is NL80211_TX_POWER_AUTOMATIC then it indicates default tx power.\n *\tNL80211_TX_POWER_FIXED is not a valid configuration option for\n *\tper peer TPC.\n */\nstruct ieee80211_sta_txpwr {\n\ts16 power;\n\tenum nl80211_tx_power_setting type;\n};\n\n/**\n * struct ieee80211_sta - station table entry\n *\n * A station table entry represents a station we are possibly\n * communicating with. Since stations are RCU-managed in\n * mac80211, any ieee80211_sta pointer you get access to must\n * either be protected by rcu_read_lock() explicitly or implicitly,\n * or you must take good care to not use such a pointer after a\n * call to your sta_remove callback that removed it.\n *\n * @addr: MAC address\n * @aid: AID we assigned to the station if we're an AP\n * @supp_rates: Bitmap of supported rates (per band)\n * @ht_cap: HT capabilities of this STA; restricted to our own capabilities\n * @vht_cap: VHT capabilities of this STA; restricted to our own capabilities\n * @he_cap: HE capabilities of this STA\n * @he_6ghz_capa: on 6 GHz, holds the HE 6 GHz band capabilities\n * @max_rx_aggregation_subframes: maximal amount of frames in a single AMPDU\n *\tthat this station is allowed to transmit to us.\n *\tCan be modified by driver.\n * @wme: indicates whether the STA supports QoS/WME (if local devices does,\n *\totherwise always false)\n * @drv_priv: data area for driver use, will always be aligned to\n *\tsizeof(void \\*), size is determined in hw information.\n * @uapsd_queues: bitmap of queues configured for uapsd. Only valid\n *\tif wme is supported. The bits order is like in\n *\tIEEE80211_WMM_IE_STA_QOSINFO_AC_*.\n * @max_sp: max Service Period. Only valid if wme is supported.\n * @bandwidth: current bandwidth the station can receive with\n * @rx_nss: in HT/VHT, the maximum number of spatial streams the\n *\tstation can receive at the moment, changed by operating mode\n *\tnotifications and capabilities. The value is only valid after\n *\tthe station moves to associated state.\n * @smps_mode: current SMPS mode (off, static or dynamic)\n * @rates: rate control selection table\n * @tdls: indicates whether the STA is a TDLS peer\n * @tdls_initiator: indicates the STA is an initiator of the TDLS link. Only\n *\tvalid if the STA is a TDLS peer in the first place.\n * @mfp: indicates whether the STA uses management frame protection or not.\n * @max_amsdu_subframes: indicates the maximal number of MSDUs in a single\n *\tA-MSDU. Taken from the Extended Capabilities element. 0 means\n *\tunlimited.\n * @support_p2p_ps: indicates whether the STA supports P2P PS mechanism or not.\n * @max_rc_amsdu_len: Maximum A-MSDU size in bytes recommended by rate control.\n * @max_tid_amsdu_len: Maximum A-MSDU size in bytes for this TID\n * @txpwr: the station tx power configuration\n * @txq: per-TID data TX queues (if driver uses the TXQ abstraction); note that\n *\tthe last entry (%IEEE80211_NUM_TIDS) is used for non-data frames\n */\nstruct ieee80211_sta {\n\tu32 supp_rates[NUM_NL80211_BANDS];\n\tu8 addr[ETH_ALEN];\n\tu16 aid;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct ieee80211_sta_he_cap he_cap;\n\tstruct ieee80211_he_6ghz_capa he_6ghz_capa;\n\tu16 max_rx_aggregation_subframes;\n\tbool wme;\n\tu8 uapsd_queues;\n\tu8 max_sp;\n\tu8 rx_nss;\n\tenum ieee80211_sta_rx_bandwidth bandwidth;\n\tenum ieee80211_smps_mode smps_mode;\n\tstruct ieee80211_sta_rates __rcu *rates;\n\tbool tdls;\n\tbool tdls_initiator;\n\tbool mfp;\n\tu8 max_amsdu_subframes;\n\n\t/**\n\t * @max_amsdu_len:\n\t * indicates the maximal length of an A-MSDU in bytes.\n\t * This field is always valid for packets with a VHT preamble.\n\t * For packets with a HT preamble, additional limits apply:\n\t *\n\t * * If the skb is transmitted as part of a BA agreement, the\n\t *   A-MSDU maximal size is min(max_amsdu_len, 4065) bytes.\n\t * * If the skb is not part of a BA agreement, the A-MSDU maximal\n\t *   size is min(max_amsdu_len, 7935) bytes.\n\t *\n\t * Both additional HT limits must be enforced by the low level\n\t * driver. This is defined by the spec (IEEE 802.11-2012 section\n\t * 8.3.2.2 NOTE 2).\n\t */\n\tu16 max_amsdu_len;\n\tbool support_p2p_ps;\n\tu16 max_rc_amsdu_len;\n\tu16 max_tid_amsdu_len[IEEE80211_NUM_TIDS];\n\tstruct ieee80211_sta_txpwr txpwr;\n\n\tstruct ieee80211_txq *txq[IEEE80211_NUM_TIDS + 1];\n\n\t/* must be last */\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n/**\n * enum sta_notify_cmd - sta notify command\n *\n * Used with the sta_notify() callback in &struct ieee80211_ops, this\n * indicates if an associated station made a power state transition.\n *\n * @STA_NOTIFY_SLEEP: a station is now sleeping\n * @STA_NOTIFY_AWAKE: a sleeping station woke up\n */\nenum sta_notify_cmd {\n\tSTA_NOTIFY_SLEEP, STA_NOTIFY_AWAKE,\n};\n\n/**\n * struct ieee80211_tx_control - TX control data\n *\n * @sta: station table entry, this sta pointer may be NULL and\n * \tit is not allowed to copy the pointer, due to RCU.\n */\nstruct ieee80211_tx_control {\n\tstruct ieee80211_sta *sta;\n};\n\n/**\n * struct ieee80211_txq - Software intermediate tx queue\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @sta: station table entry, %NULL for per-vif queue\n * @tid: the TID for this queue (unused for per-vif queue),\n *\t%IEEE80211_NUM_TIDS for non-data (if enabled)\n * @ac: the AC for this queue\n * @drv_priv: driver private area, sized by hw->txq_data_size\n *\n * The driver can obtain packets from this queue by calling\n * ieee80211_tx_dequeue().\n */\nstruct ieee80211_txq {\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *sta;\n\tu8 tid;\n\tu8 ac;\n\n\t/* must be last */\n\tu8 drv_priv[] __aligned(sizeof(void *));\n};\n\n/**\n * enum ieee80211_hw_flags - hardware flags\n *\n * These flags are used to indicate hardware capabilities to\n * the stack. Generally, flags here should have their meaning\n * done in a way that the simplest hardware doesn't need setting\n * any particular flags. There are some exceptions to this rule,\n * however, so you are advised to review these flags carefully.\n *\n * @IEEE80211_HW_HAS_RATE_CONTROL:\n *\tThe hardware or firmware includes rate control, and cannot be\n *\tcontrolled by the stack. As such, no rate control algorithm\n *\tshould be instantiated, and the TX rate reported to userspace\n *\twill be taken from the TX status instead of the rate control\n *\talgorithm.\n *\tNote that this requires that the driver implement a number of\n *\tcallbacks so it has the correct information, it needs to have\n *\tthe @set_rts_threshold callback and must look at the BSS config\n *\t@use_cts_prot for G/N protection, @use_short_slot for slot\n *\ttiming in 2.4 GHz and @use_short_preamble for preambles for\n *\tCCK frames.\n *\n * @IEEE80211_HW_RX_INCLUDES_FCS:\n *\tIndicates that received frames passed to the stack include\n *\tthe FCS at the end.\n *\n * @IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING:\n *\tSome wireless LAN chipsets buffer broadcast/multicast frames\n *\tfor power saving stations in the hardware/firmware and others\n *\trely on the host system for such buffering. This option is used\n *\tto configure the IEEE 802.11 upper layer to buffer broadcast and\n *\tmulticast frames when there are power saving stations so that\n *\tthe driver can fetch them with ieee80211_get_buffered_bc().\n *\n * @IEEE80211_HW_SIGNAL_UNSPEC:\n *\tHardware can provide signal values but we don't know its units. We\n *\texpect values between 0 and @max_signal.\n *\tIf possible please provide dB or dBm instead.\n *\n * @IEEE80211_HW_SIGNAL_DBM:\n *\tHardware gives signal values in dBm, decibel difference from\n *\tone milliwatt. This is the preferred method since it is standardized\n *\tbetween different devices. @max_signal does not need to be set.\n *\n * @IEEE80211_HW_SPECTRUM_MGMT:\n * \tHardware supports spectrum management defined in 802.11h\n * \tMeasurement, Channel Switch, Quieting, TPC\n *\n * @IEEE80211_HW_AMPDU_AGGREGATION:\n *\tHardware supports 11n A-MPDU aggregation.\n *\n * @IEEE80211_HW_SUPPORTS_PS:\n *\tHardware has power save support (i.e. can go to sleep).\n *\n * @IEEE80211_HW_PS_NULLFUNC_STACK:\n *\tHardware requires nullfunc frame handling in stack, implies\n *\tstack support for dynamic PS.\n *\n * @IEEE80211_HW_SUPPORTS_DYNAMIC_PS:\n *\tHardware has support for dynamic PS.\n *\n * @IEEE80211_HW_MFP_CAPABLE:\n *\tHardware supports management frame protection (MFP, IEEE 802.11w).\n *\n * @IEEE80211_HW_REPORTS_TX_ACK_STATUS:\n *\tHardware can provide ack status reports of Tx frames to\n *\tthe stack.\n *\n * @IEEE80211_HW_CONNECTION_MONITOR:\n *\tThe hardware performs its own connection monitoring, including\n *\tperiodic keep-alives to the AP and probing the AP on beacon loss.\n *\n * @IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC:\n *\tThis device needs to get data from beacon before association (i.e.\n *\tdtim_period).\n *\n * @IEEE80211_HW_SUPPORTS_PER_STA_GTK: The device's crypto engine supports\n *\tper-station GTKs as used by IBSS RSN or during fast transition. If\n *\tthe device doesn't support per-station GTKs, but can be asked not\n *\tto decrypt group addressed frames, then IBSS RSN support is still\n *\tpossible but software crypto will be used. Advertise the wiphy flag\n *\tonly in that case.\n *\n * @IEEE80211_HW_AP_LINK_PS: When operating in AP mode the device\n *\tautonomously manages the PS status of connected stations. When\n *\tthis flag is set mac80211 will not trigger PS mode for connected\n *\tstations based on the PM bit of incoming frames.\n *\tUse ieee80211_start_ps()/ieee8021_end_ps() to manually configure\n *\tthe PS mode of connected stations.\n *\n * @IEEE80211_HW_TX_AMPDU_SETUP_IN_HW: The device handles TX A-MPDU session\n *\tsetup strictly in HW. mac80211 should not attempt to do this in\n *\tsoftware.\n *\n * @IEEE80211_HW_WANT_MONITOR_VIF: The driver would like to be informed of\n *\ta virtual monitor interface when monitor interfaces are the only\n *\tactive interfaces.\n *\n * @IEEE80211_HW_NO_AUTO_VIF: The driver would like for no wlanX to\n *\tbe created.  It is expected user-space will create vifs as\n *\tdesired (and thus have them named as desired).\n *\n * @IEEE80211_HW_SW_CRYPTO_CONTROL: The driver wants to control which of the\n *\tcrypto algorithms can be done in software - so don't automatically\n *\ttry to fall back to it if hardware crypto fails, but do so only if\n *\tthe driver returns 1. This also forces the driver to advertise its\n *\tsupported cipher suites.\n *\n * @IEEE80211_HW_SUPPORT_FAST_XMIT: The driver/hardware supports fast-xmit,\n *\tthis currently requires only the ability to calculate the duration\n *\tfor frames.\n *\n * @IEEE80211_HW_QUEUE_CONTROL: The driver wants to control per-interface\n *\tqueue mapping in order to use different queues (not just one per AC)\n *\tfor different virtual interfaces. See the doc section on HW queue\n *\tcontrol for more details.\n *\n * @IEEE80211_HW_SUPPORTS_RC_TABLE: The driver supports using a rate\n *\tselection table provided by the rate control algorithm.\n *\n * @IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF: Use the P2P Device address for any\n *\tP2P Interface. This will be honoured even if more than one interface\n *\tis supported.\n *\n * @IEEE80211_HW_TIMING_BEACON_ONLY: Use sync timing from beacon frames\n *\tonly, to allow getting TBTT of a DTIM beacon.\n *\n * @IEEE80211_HW_SUPPORTS_HT_CCK_RATES: Hardware supports mixing HT/CCK rates\n *\tand can cope with CCK rates in an aggregation session (e.g. by not\n *\tusing aggregation for such frames.)\n *\n * @IEEE80211_HW_CHANCTX_STA_CSA: Support 802.11h based channel-switch (CSA)\n *\tfor a single active channel while using channel contexts. When support\n *\tis not enabled the default action is to disconnect when getting the\n *\tCSA frame.\n *\n * @IEEE80211_HW_SUPPORTS_CLONED_SKBS: The driver will never modify the payload\n *\tor tailroom of TX skbs without copying them first.\n *\n * @IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS: The HW supports scanning on all bands\n *\tin one command, mac80211 doesn't have to run separate scans per band.\n *\n * @IEEE80211_HW_TDLS_WIDER_BW: The device/driver supports wider bandwidth\n *\tthan then BSS bandwidth for a TDLS link on the base channel.\n *\n * @IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU: The driver supports receiving A-MSDUs\n *\twithin A-MPDU.\n *\n * @IEEE80211_HW_BEACON_TX_STATUS: The device/driver provides TX status\n *\tfor sent beacons.\n *\n * @IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR: Hardware (or driver) requires that each\n *\tstation has a unique address, i.e. each station entry can be identified\n *\tby just its MAC address; this prevents, for example, the same station\n *\tfrom connecting to two virtual AP interfaces at the same time.\n *\n * @IEEE80211_HW_SUPPORTS_REORDERING_BUFFER: Hardware (or driver) manages the\n *\treordering buffer internally, guaranteeing mac80211 receives frames in\n *\torder and does not need to manage its own reorder buffer or BA session\n *\ttimeout.\n *\n * @IEEE80211_HW_USES_RSS: The device uses RSS and thus requires parallel RX,\n *\twhich implies using per-CPU station statistics.\n *\n * @IEEE80211_HW_TX_AMSDU: Hardware (or driver) supports software aggregated\n *\tA-MSDU frames. Requires software tx queueing and fast-xmit support.\n *\tWhen not using minstrel/minstrel_ht rate control, the driver must\n *\tlimit the maximum A-MSDU size based on the current tx rate by setting\n *\tmax_rc_amsdu_len in struct ieee80211_sta.\n *\n * @IEEE80211_HW_TX_FRAG_LIST: Hardware (or driver) supports sending frag_list\n *\tskbs, needed for zero-copy software A-MSDU.\n *\n * @IEEE80211_HW_REPORTS_LOW_ACK: The driver (or firmware) reports low ack event\n *\tby ieee80211_report_low_ack() based on its own algorithm. For such\n *\tdrivers, mac80211 packet loss mechanism will not be triggered and driver\n *\tis completely depending on firmware event for station kickout.\n *\n * @IEEE80211_HW_SUPPORTS_TX_FRAG: Hardware does fragmentation by itself.\n *\tThe stack will not do fragmentation.\n *\tThe callback for @set_frag_threshold should be set as well.\n *\n * @IEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA: Hardware supports buffer STA on\n *\tTDLS links.\n *\n * @IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP: The driver requires the\n *\tmgd_prepare_tx() callback to be called before transmission of a\n *\tdeauthentication frame in case the association was completed but no\n *\tbeacon was heard. This is required in multi-channel scenarios, where the\n *\tvirtual interface might not be given air time for the transmission of\n *\tthe frame, as it is not synced with the AP/P2P GO yet, and thus the\n *\tdeauthentication frame might not be transmitted.\n *\n * @IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP: The driver (or firmware) doesn't\n *\tsupport QoS NDP for AP probing - that's most likely a driver bug.\n *\n * @IEEE80211_HW_BUFF_MMPDU_TXQ: use the TXQ for bufferable MMPDUs, this of\n *\tcourse requires the driver to use TXQs to start with.\n *\n * @IEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW: (Hardware) rate control supports VHT\n *\textended NSS BW (dot11VHTExtendedNSSBWCapable). This flag will be set if\n *\tthe selected rate control algorithm sets %RATE_CTRL_CAPA_VHT_EXT_NSS_BW\n *\tbut if the rate control is built-in then it must be set by the driver.\n *\tSee also the documentation for that flag.\n *\n * @IEEE80211_HW_STA_MMPDU_TXQ: use the extra non-TID per-station TXQ for all\n *\tMMPDUs on station interfaces. This of course requires the driver to use\n *\tTXQs to start with.\n *\n * @IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN: Driver does not report accurate A-MPDU\n *\tlength in tx status information\n *\n * @IEEE80211_HW_SUPPORTS_MULTI_BSSID: Hardware supports multi BSSID\n *\n * @IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID: Hardware supports multi BSSID\n *\tonly for HE APs. Applies if @IEEE80211_HW_SUPPORTS_MULTI_BSSID is set.\n *\n * @IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT: The card and driver is only\n *\taggregating MPDUs with the same keyid, allowing mac80211 to keep Tx\n *\tA-MPDU sessions active while rekeying with Extended Key ID.\n *\n * @IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD: Hardware supports tx encapsulation\n *\toffload\n *\n * @IEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD: Hardware supports rx decapsulation\n *\toffload\n *\n * @IEEE80211_HW_SUPPORTS_CONC_MON_RX_DECAP: Hardware supports concurrent rx\n *\tdecapsulation offload and passing raw 802.11 frames for monitor iface.\n *\tIf this is supported, the driver must pass both 802.3 frames for real\n *\tusage and 802.11 frames with %RX_FLAG_ONLY_MONITOR set for monitor to\n *\tthe stack.\n *\n * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays\n */\nenum ieee80211_hw_flags {\n\tIEEE80211_HW_HAS_RATE_CONTROL,\n\tIEEE80211_HW_RX_INCLUDES_FCS,\n\tIEEE80211_HW_HOST_BROADCAST_PS_BUFFERING,\n\tIEEE80211_HW_SIGNAL_UNSPEC,\n\tIEEE80211_HW_SIGNAL_DBM,\n\tIEEE80211_HW_NEED_DTIM_BEFORE_ASSOC,\n\tIEEE80211_HW_SPECTRUM_MGMT,\n\tIEEE80211_HW_AMPDU_AGGREGATION,\n\tIEEE80211_HW_SUPPORTS_PS,\n\tIEEE80211_HW_PS_NULLFUNC_STACK,\n\tIEEE80211_HW_SUPPORTS_DYNAMIC_PS,\n\tIEEE80211_HW_MFP_CAPABLE,\n\tIEEE80211_HW_WANT_MONITOR_VIF,\n\tIEEE80211_HW_NO_AUTO_VIF,\n\tIEEE80211_HW_SW_CRYPTO_CONTROL,\n\tIEEE80211_HW_SUPPORT_FAST_XMIT,\n\tIEEE80211_HW_REPORTS_TX_ACK_STATUS,\n\tIEEE80211_HW_CONNECTION_MONITOR,\n\tIEEE80211_HW_QUEUE_CONTROL,\n\tIEEE80211_HW_SUPPORTS_PER_STA_GTK,\n\tIEEE80211_HW_AP_LINK_PS,\n\tIEEE80211_HW_TX_AMPDU_SETUP_IN_HW,\n\tIEEE80211_HW_SUPPORTS_RC_TABLE,\n\tIEEE80211_HW_P2P_DEV_ADDR_FOR_INTF,\n\tIEEE80211_HW_TIMING_BEACON_ONLY,\n\tIEEE80211_HW_SUPPORTS_HT_CCK_RATES,\n\tIEEE80211_HW_CHANCTX_STA_CSA,\n\tIEEE80211_HW_SUPPORTS_CLONED_SKBS,\n\tIEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS,\n\tIEEE80211_HW_TDLS_WIDER_BW,\n\tIEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU,\n\tIEEE80211_HW_BEACON_TX_STATUS,\n\tIEEE80211_HW_NEEDS_UNIQUE_STA_ADDR,\n\tIEEE80211_HW_SUPPORTS_REORDERING_BUFFER,\n\tIEEE80211_HW_USES_RSS,\n\tIEEE80211_HW_TX_AMSDU,\n\tIEEE80211_HW_TX_FRAG_LIST,\n\tIEEE80211_HW_REPORTS_LOW_ACK,\n\tIEEE80211_HW_SUPPORTS_TX_FRAG,\n\tIEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA,\n\tIEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP,\n\tIEEE80211_HW_DOESNT_SUPPORT_QOS_NDP,\n\tIEEE80211_HW_BUFF_MMPDU_TXQ,\n\tIEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW,\n\tIEEE80211_HW_STA_MMPDU_TXQ,\n\tIEEE80211_HW_TX_STATUS_NO_AMPDU_LEN,\n\tIEEE80211_HW_SUPPORTS_MULTI_BSSID,\n\tIEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID,\n\tIEEE80211_HW_AMPDU_KEYBORDER_SUPPORT,\n\tIEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD,\n\tIEEE80211_HW_SUPPORTS_RX_DECAP_OFFLOAD,\n\tIEEE80211_HW_SUPPORTS_CONC_MON_RX_DECAP,\n\n\t/* keep last, obviously */\n\tNUM_IEEE80211_HW_FLAGS\n};\n\n/**\n * struct ieee80211_hw - hardware information and state\n *\n * This structure contains the configuration and hardware\n * information for an 802.11 PHY.\n *\n * @wiphy: This points to the &struct wiphy allocated for this\n *\t802.11 PHY. You must fill in the @perm_addr and @dev\n *\tmembers of this structure using SET_IEEE80211_DEV()\n *\tand SET_IEEE80211_PERM_ADDR(). Additionally, all supported\n *\tbands (with channels, bitrates) are registered here.\n *\n * @conf: &struct ieee80211_conf, device configuration, don't use.\n *\n * @priv: pointer to private area that was allocated for driver use\n *\talong with this structure.\n *\n * @flags: hardware flags, see &enum ieee80211_hw_flags.\n *\n * @extra_tx_headroom: headroom to reserve in each transmit skb\n *\tfor use by the driver (e.g. for transmit headers.)\n *\n * @extra_beacon_tailroom: tailroom to reserve in each beacon tx skb.\n *\tCan be used by drivers to add extra IEs.\n *\n * @max_signal: Maximum value for signal (rssi) in RX information, used\n *\tonly when @IEEE80211_HW_SIGNAL_UNSPEC or @IEEE80211_HW_SIGNAL_DB\n *\n * @max_listen_interval: max listen interval in units of beacon interval\n *\tthat HW supports\n *\n * @queues: number of available hardware transmit queues for\n *\tdata packets. WMM/QoS requires at least four, these\n *\tqueues need to have configurable access parameters.\n *\n * @rate_control_algorithm: rate control algorithm for this hardware.\n *\tIf unset (NULL), the default algorithm will be used. Must be\n *\tset before calling ieee80211_register_hw().\n *\n * @vif_data_size: size (in bytes) of the drv_priv data area\n *\twithin &struct ieee80211_vif.\n * @sta_data_size: size (in bytes) of the drv_priv data area\n *\twithin &struct ieee80211_sta.\n * @chanctx_data_size: size (in bytes) of the drv_priv data area\n *\twithin &struct ieee80211_chanctx_conf.\n * @txq_data_size: size (in bytes) of the drv_priv data area\n *\twithin @struct ieee80211_txq.\n *\n * @max_rates: maximum number of alternate rate retry stages the hw\n *\tcan handle.\n * @max_report_rates: maximum number of alternate rate retry stages\n *\tthe hw can report back.\n * @max_rate_tries: maximum number of tries for each stage\n *\n * @max_rx_aggregation_subframes: maximum buffer size (number of\n *\tsub-frames) to be used for A-MPDU block ack receiver\n *\taggregation.\n *\tThis is only relevant if the device has restrictions on the\n *\tnumber of subframes, if it relies on mac80211 to do reordering\n *\tit shouldn't be set.\n *\n * @max_tx_aggregation_subframes: maximum number of subframes in an\n *\taggregate an HT/HE device will transmit. In HT AddBA we'll\n *\tadvertise a constant value of 64 as some older APs crash if\n *\tthe window size is smaller (an example is LinkSys WRT120N\n *\twith FW v1.0.07 build 002 Jun 18 2012).\n *\tFor AddBA to HE capable peers this value will be used.\n *\n * @max_tx_fragments: maximum number of tx buffers per (A)-MSDU, sum\n *\tof 1 + skb_shinfo(skb)->nr_frags for each skb in the frag_list.\n *\n * @offchannel_tx_hw_queue: HW queue ID to use for offchannel TX\n *\t(if %IEEE80211_HW_QUEUE_CONTROL is set)\n *\n * @radiotap_mcs_details: lists which MCS information can the HW\n *\treports, by default it is set to _MCS, _GI and _BW but doesn't\n *\tinclude _FMT. Use %IEEE80211_RADIOTAP_MCS_HAVE_\\* values, only\n *\tadding _BW is supported today.\n *\n * @radiotap_vht_details: lists which VHT MCS information the HW reports,\n *\tthe default is _GI | _BANDWIDTH.\n *\tUse the %IEEE80211_RADIOTAP_VHT_KNOWN_\\* values.\n *\n * @radiotap_he: HE radiotap validity flags\n *\n * @radiotap_timestamp: Information for the radiotap timestamp field; if the\n *\t@units_pos member is set to a non-negative value then the timestamp\n *\tfield will be added and populated from the &struct ieee80211_rx_status\n *\tdevice_timestamp.\n * @radiotap_timestamp.units_pos: Must be set to a combination of a\n *\tIEEE80211_RADIOTAP_TIMESTAMP_UNIT_* and a\n *\tIEEE80211_RADIOTAP_TIMESTAMP_SPOS_* value.\n * @radiotap_timestamp.accuracy: If non-negative, fills the accuracy in the\n *\tradiotap field and the accuracy known flag will be set.\n *\n * @netdev_features: netdev features to be set in each netdev created\n *\tfrom this HW. Note that not all features are usable with mac80211,\n *\tother features will be rejected during HW registration.\n *\n * @uapsd_queues: This bitmap is included in (re)association frame to indicate\n *\tfor each access category if it is uAPSD trigger-enabled and delivery-\n *\tenabled. Use IEEE80211_WMM_IE_STA_QOSINFO_AC_* to set this bitmap.\n *\tEach bit corresponds to different AC. Value '1' in specific bit means\n *\tthat corresponding AC is both trigger- and delivery-enabled. '0' means\n *\tneither enabled.\n *\n * @uapsd_max_sp_len: maximum number of total buffered frames the WMM AP may\n *\tdeliver to a WMM STA during any Service Period triggered by the WMM STA.\n *\tUse IEEE80211_WMM_IE_STA_QOSINFO_SP_* for correct values.\n *\n * @n_cipher_schemes: a size of an array of cipher schemes definitions.\n * @cipher_schemes: a pointer to an array of cipher scheme definitions\n *\tsupported by HW.\n * @max_nan_de_entries: maximum number of NAN DE functions supported by the\n *\tdevice.\n *\n * @tx_sk_pacing_shift: Pacing shift to set on TCP sockets when frames from\n *\tthem are encountered. The default should typically not be changed,\n *\tunless the driver has good reasons for needing more buffers.\n *\n * @weight_multiplier: Driver specific airtime weight multiplier used while\n *\trefilling deficit of each TXQ.\n *\n * @max_mtu: the max mtu could be set.\n */\nstruct ieee80211_hw {\n\tstruct ieee80211_conf conf;\n\tstruct wiphy *wiphy;\n\tconst char *rate_control_algorithm;\n\tvoid *priv;\n\tunsigned long flags[BITS_TO_LONGS(NUM_IEEE80211_HW_FLAGS)];\n\tunsigned int extra_tx_headroom;\n\tunsigned int extra_beacon_tailroom;\n\tint vif_data_size;\n\tint sta_data_size;\n\tint chanctx_data_size;\n\tint txq_data_size;\n\tu16 queues;\n\tu16 max_listen_interval;\n\ts8 max_signal;\n\tu8 max_rates;\n\tu8 max_report_rates;\n\tu8 max_rate_tries;\n\tu16 max_rx_aggregation_subframes;\n\tu16 max_tx_aggregation_subframes;\n\tu8 max_tx_fragments;\n\tu8 offchannel_tx_hw_queue;\n\tu8 radiotap_mcs_details;\n\tu16 radiotap_vht_details;\n\tstruct {\n\t\tint units_pos;\n\t\ts16 accuracy;\n\t} radiotap_timestamp;\n\tnetdev_features_t netdev_features;\n\tu8 uapsd_queues;\n\tu8 uapsd_max_sp_len;\n\tu8 n_cipher_schemes;\n\tconst struct ieee80211_cipher_scheme *cipher_schemes;\n\tu8 max_nan_de_entries;\n\tu8 tx_sk_pacing_shift;\n\tu8 weight_multiplier;\n\tu32 max_mtu;\n};\n\nstatic inline bool _ieee80211_hw_check(struct ieee80211_hw *hw,\n\t\t\t\t       enum ieee80211_hw_flags flg)\n{\n\treturn test_bit(flg, hw->flags);\n}\n#define ieee80211_hw_check(hw, flg)\t_ieee80211_hw_check(hw, IEEE80211_HW_##flg)\n\nstatic inline void _ieee80211_hw_set(struct ieee80211_hw *hw,\n\t\t\t\t     enum ieee80211_hw_flags flg)\n{\n\treturn __set_bit(flg, hw->flags);\n}\n#define ieee80211_hw_set(hw, flg)\t_ieee80211_hw_set(hw, IEEE80211_HW_##flg)\n\n/**\n * struct ieee80211_scan_request - hw scan request\n *\n * @ies: pointers different parts of IEs (in req.ie)\n * @req: cfg80211 request.\n */\nstruct ieee80211_scan_request {\n\tstruct ieee80211_scan_ies ies;\n\n\t/* Keep last */\n\tstruct cfg80211_scan_request req;\n};\n\n/**\n * struct ieee80211_tdls_ch_sw_params - TDLS channel switch parameters\n *\n * @sta: peer this TDLS channel-switch request/response came from\n * @chandef: channel referenced in a TDLS channel-switch request\n * @action_code: see &enum ieee80211_tdls_actioncode\n * @status: channel-switch response status\n * @timestamp: time at which the frame was received\n * @switch_time: switch-timing parameter received in the frame\n * @switch_timeout: switch-timing parameter received in the frame\n * @tmpl_skb: TDLS switch-channel response template\n * @ch_sw_tm_ie: offset of the channel-switch timing IE inside @tmpl_skb\n */\nstruct ieee80211_tdls_ch_sw_params {\n\tstruct ieee80211_sta *sta;\n\tstruct cfg80211_chan_def *chandef;\n\tu8 action_code;\n\tu32 status;\n\tu32 timestamp;\n\tu16 switch_time;\n\tu16 switch_timeout;\n\tstruct sk_buff *tmpl_skb;\n\tu32 ch_sw_tm_ie;\n};\n\n/**\n * wiphy_to_ieee80211_hw - return a mac80211 driver hw struct from a wiphy\n *\n * @wiphy: the &struct wiphy which we want to query\n *\n * mac80211 drivers can use this to get to their respective\n * &struct ieee80211_hw. Drivers wishing to get to their own private\n * structure can then access it via hw->priv. Note that mac802111 drivers should\n * not use wiphy_priv() to try to get their private driver structure as this\n * is already used internally by mac80211.\n *\n * Return: The mac80211 driver hw struct of @wiphy.\n */\nstruct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy);\n\n/**\n * SET_IEEE80211_DEV - set device for 802.11 hardware\n *\n * @hw: the &struct ieee80211_hw to set the device for\n * @dev: the &struct device of this 802.11 device\n */\nstatic inline void SET_IEEE80211_DEV(struct ieee80211_hw *hw, struct device *dev)\n{\n\tset_wiphy_dev(hw->wiphy, dev);\n}\n\n/**\n * SET_IEEE80211_PERM_ADDR - set the permanent MAC address for 802.11 hardware\n *\n * @hw: the &struct ieee80211_hw to set the MAC address for\n * @addr: the address to set\n */\nstatic inline void SET_IEEE80211_PERM_ADDR(struct ieee80211_hw *hw, const u8 *addr)\n{\n\tmemcpy(hw->wiphy->perm_addr, addr, ETH_ALEN);\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_tx_rate(const struct ieee80211_hw *hw,\n\t\t      const struct ieee80211_tx_info *c)\n{\n\tif (WARN_ON_ONCE(c->control.rates[0].idx < 0))\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rates[0].idx];\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_rts_cts_rate(const struct ieee80211_hw *hw,\n\t\t\t   const struct ieee80211_tx_info *c)\n{\n\tif (c->control.rts_cts_rate_idx < 0)\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rts_cts_rate_idx];\n}\n\nstatic inline struct ieee80211_rate *\nieee80211_get_alt_retry_rate(const struct ieee80211_hw *hw,\n\t\t\t     const struct ieee80211_tx_info *c, int idx)\n{\n\tif (c->control.rates[idx + 1].idx < 0)\n\t\treturn NULL;\n\treturn &hw->wiphy->bands[c->band]->bitrates[c->control.rates[idx + 1].idx];\n}\n\n/**\n * ieee80211_free_txskb - free TX skb\n * @hw: the hardware\n * @skb: the skb\n *\n * Free a transmit skb. Use this function when some failure\n * to transmit happened and thus status cannot be reported.\n */\nvoid ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);\n\n/**\n * DOC: Hardware crypto acceleration\n *\n * mac80211 is capable of taking advantage of many hardware\n * acceleration designs for encryption and decryption operations.\n *\n * The set_key() callback in the &struct ieee80211_ops for a given\n * device is called to enable hardware acceleration of encryption and\n * decryption. The callback takes a @sta parameter that will be NULL\n * for default keys or keys used for transmission only, or point to\n * the station information for the peer for individual keys.\n * Multiple transmission keys with the same key index may be used when\n * VLANs are configured for an access point.\n *\n * When transmitting, the TX control data will use the @hw_key_idx\n * selected by the driver by modifying the &struct ieee80211_key_conf\n * pointed to by the @key parameter to the set_key() function.\n *\n * The set_key() call for the %SET_KEY command should return 0 if\n * the key is now in use, -%EOPNOTSUPP or -%ENOSPC if it couldn't be\n * added; if you return 0 then hw_key_idx must be assigned to the\n * hardware key index, you are free to use the full u8 range.\n *\n * Note that in the case that the @IEEE80211_HW_SW_CRYPTO_CONTROL flag is\n * set, mac80211 will not automatically fall back to software crypto if\n * enabling hardware crypto failed. The set_key() call may also return the\n * value 1 to permit this specific key/algorithm to be done in software.\n *\n * When the cmd is %DISABLE_KEY then it must succeed.\n *\n * Note that it is permissible to not decrypt a frame even if a key\n * for it has been uploaded to hardware, the stack will not make any\n * decision based on whether a key has been uploaded or not but rather\n * based on the receive flags.\n *\n * The &struct ieee80211_key_conf structure pointed to by the @key\n * parameter is guaranteed to be valid until another call to set_key()\n * removes it, but it can only be used as a cookie to differentiate\n * keys.\n *\n * In TKIP some HW need to be provided a phase 1 key, for RX decryption\n * acceleration (i.e. iwlwifi). Those drivers should provide update_tkip_key\n * handler.\n * The update_tkip_key() call updates the driver with the new phase 1 key.\n * This happens every time the iv16 wraps around (every 65536 packets). The\n * set_key() call will happen only once for each key (unless the AP did\n * rekeying), it will not include a valid phase 1 key. The valid phase 1 key is\n * provided by update_tkip_key only. The trigger that makes mac80211 call this\n * handler is software decryption with wrap around of iv16.\n *\n * The set_default_unicast_key() call updates the default WEP key index\n * configured to the hardware for WEP encryption type. This is required\n * for devices that support offload of data packets (e.g. ARP responses).\n *\n * Mac80211 drivers should set the @NL80211_EXT_FEATURE_CAN_REPLACE_PTK0 flag\n * when they are able to replace in-use PTK keys according to the following\n * requirements:\n * 1) They do not hand over frames decrypted with the old key to\n      mac80211 once the call to set_key() with command %DISABLE_KEY has been\n      completed when also setting @IEEE80211_KEY_FLAG_GENERATE_IV for any key,\n   2) either drop or continue to use the old key for any outgoing frames queued\n      at the time of the key deletion (including re-transmits),\n   3) never send out a frame queued prior to the set_key() %SET_KEY command\n      encrypted with the new key and\n   4) never send out a frame unencrypted when it should be encrypted.\n   Mac80211 will not queue any new frames for a deleted key to the driver.\n */\n\n/**\n * DOC: Powersave support\n *\n * mac80211 has support for various powersave implementations.\n *\n * First, it can support hardware that handles all powersaving by itself,\n * such hardware should simply set the %IEEE80211_HW_SUPPORTS_PS hardware\n * flag. In that case, it will be told about the desired powersave mode\n * with the %IEEE80211_CONF_PS flag depending on the association status.\n * The hardware must take care of sending nullfunc frames when necessary,\n * i.e. when entering and leaving powersave mode. The hardware is required\n * to look at the AID in beacons and signal to the AP that it woke up when\n * it finds traffic directed to it.\n *\n * %IEEE80211_CONF_PS flag enabled means that the powersave mode defined in\n * IEEE 802.11-2007 section 11.2 is enabled. This is not to be confused\n * with hardware wakeup and sleep states. Driver is responsible for waking\n * up the hardware before issuing commands to the hardware and putting it\n * back to sleep at appropriate times.\n *\n * When PS is enabled, hardware needs to wakeup for beacons and receive the\n * buffered multicast/broadcast frames after the beacon. Also it must be\n * possible to send frames and receive the acknowledment frame.\n *\n * Other hardware designs cannot send nullfunc frames by themselves and also\n * need software support for parsing the TIM bitmap. This is also supported\n * by mac80211 by combining the %IEEE80211_HW_SUPPORTS_PS and\n * %IEEE80211_HW_PS_NULLFUNC_STACK flags. The hardware is of course still\n * required to pass up beacons. The hardware is still required to handle\n * waking up for multicast traffic; if it cannot the driver must handle that\n * as best as it can, mac80211 is too slow to do that.\n *\n * Dynamic powersave is an extension to normal powersave in which the\n * hardware stays awake for a user-specified period of time after sending a\n * frame so that reply frames need not be buffered and therefore delayed to\n * the next wakeup. It's compromise of getting good enough latency when\n * there's data traffic and still saving significantly power in idle\n * periods.\n *\n * Dynamic powersave is simply supported by mac80211 enabling and disabling\n * PS based on traffic. Driver needs to only set %IEEE80211_HW_SUPPORTS_PS\n * flag and mac80211 will handle everything automatically. Additionally,\n * hardware having support for the dynamic PS feature may set the\n * %IEEE80211_HW_SUPPORTS_DYNAMIC_PS flag to indicate that it can support\n * dynamic PS mode itself. The driver needs to look at the\n * @dynamic_ps_timeout hardware configuration value and use it that value\n * whenever %IEEE80211_CONF_PS is set. In this case mac80211 will disable\n * dynamic PS feature in stack and will just keep %IEEE80211_CONF_PS\n * enabled whenever user has enabled powersave.\n *\n * Driver informs U-APSD client support by enabling\n * %IEEE80211_VIF_SUPPORTS_UAPSD flag. The mode is configured through the\n * uapsd parameter in conf_tx() operation. Hardware needs to send the QoS\n * Nullfunc frames and stay awake until the service period has ended. To\n * utilize U-APSD, dynamic powersave is disabled for voip AC and all frames\n * from that AC are transmitted with powersave enabled.\n *\n * Note: U-APSD client mode is not yet supported with\n * %IEEE80211_HW_PS_NULLFUNC_STACK.\n */\n\n/**\n * DOC: Beacon filter support\n *\n * Some hardware have beacon filter support to reduce host cpu wakeups\n * which will reduce system power consumption. It usually works so that\n * the firmware creates a checksum of the beacon but omits all constantly\n * changing elements (TSF, TIM etc). Whenever the checksum changes the\n * beacon is forwarded to the host, otherwise it will be just dropped. That\n * way the host will only receive beacons where some relevant information\n * (for example ERP protection or WMM settings) have changed.\n *\n * Beacon filter support is advertised with the %IEEE80211_VIF_BEACON_FILTER\n * interface capability. The driver needs to enable beacon filter support\n * whenever power save is enabled, that is %IEEE80211_CONF_PS is set. When\n * power save is enabled, the stack will not check for beacon loss and the\n * driver needs to notify about loss of beacons with ieee80211_beacon_loss().\n *\n * The time (or number of beacons missed) until the firmware notifies the\n * driver of a beacon loss event (which in turn causes the driver to call\n * ieee80211_beacon_loss()) should be configurable and will be controlled\n * by mac80211 and the roaming algorithm in the future.\n *\n * Since there may be constantly changing information elements that nothing\n * in the software stack cares about, we will, in the future, have mac80211\n * tell the driver which information elements are interesting in the sense\n * that we want to see changes in them. This will include\n *\n *  - a list of information element IDs\n *  - a list of OUIs for the vendor information element\n *\n * Ideally, the hardware would filter out any beacons without changes in the\n * requested elements, but if it cannot support that it may, at the expense\n * of some efficiency, filter out only a subset. For example, if the device\n * doesn't support checking for OUIs it should pass up all changes in all\n * vendor information elements.\n *\n * Note that change, for the sake of simplification, also includes information\n * elements appearing or disappearing from the beacon.\n *\n * Some hardware supports an \"ignore list\" instead, just make sure nothing\n * that was requested is on the ignore list, and include commonly changing\n * information element IDs in the ignore list, for example 11 (BSS load) and\n * the various vendor-assigned IEs with unknown contents (128, 129, 133-136,\n * 149, 150, 155, 156, 173, 176, 178, 179, 219); for forward compatibility\n * it could also include some currently unused IDs.\n *\n *\n * In addition to these capabilities, hardware should support notifying the\n * host of changes in the beacon RSSI. This is relevant to implement roaming\n * when no traffic is flowing (when traffic is flowing we see the RSSI of\n * the received data packets). This can consist in notifying the host when\n * the RSSI changes significantly or when it drops below or rises above\n * configurable thresholds. In the future these thresholds will also be\n * configured by mac80211 (which gets them from userspace) to implement\n * them as the roaming algorithm requires.\n *\n * If the hardware cannot implement this, the driver should ask it to\n * periodically pass beacon frames to the host so that software can do the\n * signal strength threshold checking.\n */\n\n/**\n * DOC: Spatial multiplexing power save\n *\n * SMPS (Spatial multiplexing power save) is a mechanism to conserve\n * power in an 802.11n implementation. For details on the mechanism\n * and rationale, please refer to 802.11 (as amended by 802.11n-2009)\n * \"11.2.3 SM power save\".\n *\n * The mac80211 implementation is capable of sending action frames\n * to update the AP about the station's SMPS mode, and will instruct\n * the driver to enter the specific mode. It will also announce the\n * requested SMPS mode during the association handshake. Hardware\n * support for this feature is required, and can be indicated by\n * hardware flags.\n *\n * The default mode will be \"automatic\", which nl80211/cfg80211\n * defines to be dynamic SMPS in (regular) powersave, and SMPS\n * turned off otherwise.\n *\n * To support this feature, the driver must set the appropriate\n * hardware support flags, and handle the SMPS flag to the config()\n * operation. It will then with this mechanism be instructed to\n * enter the requested SMPS mode while associated to an HT AP.\n */\n\n/**\n * DOC: Frame filtering\n *\n * mac80211 requires to see many management frames for proper\n * operation, and users may want to see many more frames when\n * in monitor mode. However, for best CPU usage and power consumption,\n * having as few frames as possible percolate through the stack is\n * desirable. Hence, the hardware should filter as much as possible.\n *\n * To achieve this, mac80211 uses filter flags (see below) to tell\n * the driver's configure_filter() function which frames should be\n * passed to mac80211 and which should be filtered out.\n *\n * Before configure_filter() is invoked, the prepare_multicast()\n * callback is invoked with the parameters @mc_count and @mc_list\n * for the combined multicast address list of all virtual interfaces.\n * It's use is optional, and it returns a u64 that is passed to\n * configure_filter(). Additionally, configure_filter() has the\n * arguments @changed_flags telling which flags were changed and\n * @total_flags with the new flag states.\n *\n * If your device has no multicast address filters your driver will\n * need to check both the %FIF_ALLMULTI flag and the @mc_count\n * parameter to see whether multicast frames should be accepted\n * or dropped.\n *\n * All unsupported flags in @total_flags must be cleared.\n * Hardware does not support a flag if it is incapable of _passing_\n * the frame to the stack. Otherwise the driver must ignore\n * the flag, but not clear it.\n * You must _only_ clear the flag (announce no support for the\n * flag to mac80211) if you are not able to pass the packet type\n * to the stack (so the hardware always filters it).\n * So for example, you should clear @FIF_CONTROL, if your hardware\n * always filters control frames. If your hardware always passes\n * control frames to the kernel and is incapable of filtering them,\n * you do _not_ clear the @FIF_CONTROL flag.\n * This rule applies to all other FIF flags as well.\n */\n\n/**\n * DOC: AP support for powersaving clients\n *\n * In order to implement AP and P2P GO modes, mac80211 has support for\n * client powersaving, both \"legacy\" PS (PS-Poll/null data) and uAPSD.\n * There currently is no support for sAPSD.\n *\n * There is one assumption that mac80211 makes, namely that a client\n * will not poll with PS-Poll and trigger with uAPSD at the same time.\n * Both are supported, and both can be used by the same client, but\n * they can't be used concurrently by the same client. This simplifies\n * the driver code.\n *\n * The first thing to keep in mind is that there is a flag for complete\n * driver implementation: %IEEE80211_HW_AP_LINK_PS. If this flag is set,\n * mac80211 expects the driver to handle most of the state machine for\n * powersaving clients and will ignore the PM bit in incoming frames.\n * Drivers then use ieee80211_sta_ps_transition() to inform mac80211 of\n * stations' powersave transitions. In this mode, mac80211 also doesn't\n * handle PS-Poll/uAPSD.\n *\n * In the mode without %IEEE80211_HW_AP_LINK_PS, mac80211 will check the\n * PM bit in incoming frames for client powersave transitions. When a\n * station goes to sleep, we will stop transmitting to it. There is,\n * however, a race condition: a station might go to sleep while there is\n * data buffered on hardware queues. If the device has support for this\n * it will reject frames, and the driver should give the frames back to\n * mac80211 with the %IEEE80211_TX_STAT_TX_FILTERED flag set which will\n * cause mac80211 to retry the frame when the station wakes up. The\n * driver is also notified of powersave transitions by calling its\n * @sta_notify callback.\n *\n * When the station is asleep, it has three choices: it can wake up,\n * it can PS-Poll, or it can possibly start a uAPSD service period.\n * Waking up is implemented by simply transmitting all buffered (and\n * filtered) frames to the station. This is the easiest case. When\n * the station sends a PS-Poll or a uAPSD trigger frame, mac80211\n * will inform the driver of this with the @allow_buffered_frames\n * callback; this callback is optional. mac80211 will then transmit\n * the frames as usual and set the %IEEE80211_TX_CTL_NO_PS_BUFFER\n * on each frame. The last frame in the service period (or the only\n * response to a PS-Poll) also has %IEEE80211_TX_STATUS_EOSP set to\n * indicate that it ends the service period; as this frame must have\n * TX status report it also sets %IEEE80211_TX_CTL_REQ_TX_STATUS.\n * When TX status is reported for this frame, the service period is\n * marked has having ended and a new one can be started by the peer.\n *\n * Additionally, non-bufferable MMPDUs can also be transmitted by\n * mac80211 with the %IEEE80211_TX_CTL_NO_PS_BUFFER set in them.\n *\n * Another race condition can happen on some devices like iwlwifi\n * when there are frames queued for the station and it wakes up\n * or polls; the frames that are already queued could end up being\n * transmitted first instead, causing reordering and/or wrong\n * processing of the EOSP. The cause is that allowing frames to be\n * transmitted to a certain station is out-of-band communication to\n * the device. To allow this problem to be solved, the driver can\n * call ieee80211_sta_block_awake() if frames are buffered when it\n * is notified that the station went to sleep. When all these frames\n * have been filtered (see above), it must call the function again\n * to indicate that the station is no longer blocked.\n *\n * If the driver buffers frames in the driver for aggregation in any\n * way, it must use the ieee80211_sta_set_buffered() call when it is\n * notified of the station going to sleep to inform mac80211 of any\n * TIDs that have frames buffered. Note that when a station wakes up\n * this information is reset (hence the requirement to call it when\n * informed of the station going to sleep). Then, when a service\n * period starts for any reason, @release_buffered_frames is called\n * with the number of frames to be released and which TIDs they are\n * to come from. In this case, the driver is responsible for setting\n * the EOSP (for uAPSD) and MORE_DATA bits in the released frames,\n * to help the @more_data parameter is passed to tell the driver if\n * there is more data on other TIDs -- the TIDs to release frames\n * from are ignored since mac80211 doesn't know how many frames the\n * buffers for those TIDs contain.\n *\n * If the driver also implement GO mode, where absence periods may\n * shorten service periods (or abort PS-Poll responses), it must\n * filter those response frames except in the case of frames that\n * are buffered in the driver -- those must remain buffered to avoid\n * reordering. Because it is possible that no frames are released\n * in this case, the driver must call ieee80211_sta_eosp()\n * to indicate to mac80211 that the service period ended anyway.\n *\n * Finally, if frames from multiple TIDs are released from mac80211\n * but the driver might reorder them, it must clear & set the flags\n * appropriately (only the last frame may have %IEEE80211_TX_STATUS_EOSP)\n * and also take care of the EOSP and MORE_DATA bits in the frame.\n * The driver may also use ieee80211_sta_eosp() in this case.\n *\n * Note that if the driver ever buffers frames other than QoS-data\n * frames, it must take care to never send a non-QoS-data frame as\n * the last frame in a service period, adding a QoS-nulldata frame\n * after a non-QoS-data frame if needed.\n */\n\n/**\n * DOC: HW queue control\n *\n * Before HW queue control was introduced, mac80211 only had a single static\n * assignment of per-interface AC software queues to hardware queues. This\n * was problematic for a few reasons:\n * 1) off-channel transmissions might get stuck behind other frames\n * 2) multiple virtual interfaces couldn't be handled correctly\n * 3) after-DTIM frames could get stuck behind other frames\n *\n * To solve this, hardware typically uses multiple different queues for all\n * the different usages, and this needs to be propagated into mac80211 so it\n * won't have the same problem with the software queues.\n *\n * Therefore, mac80211 now offers the %IEEE80211_HW_QUEUE_CONTROL capability\n * flag that tells it that the driver implements its own queue control. To do\n * so, the driver will set up the various queues in each &struct ieee80211_vif\n * and the offchannel queue in &struct ieee80211_hw. In response, mac80211 will\n * use those queue IDs in the hw_queue field of &struct ieee80211_tx_info and\n * if necessary will queue the frame on the right software queue that mirrors\n * the hardware queue.\n * Additionally, the driver has to then use these HW queue IDs for the queue\n * management functions (ieee80211_stop_queue() et al.)\n *\n * The driver is free to set up the queue mappings as needed, multiple virtual\n * interfaces may map to the same hardware queues if needed. The setup has to\n * happen during add_interface or change_interface callbacks. For example, a\n * driver supporting station+station and station+AP modes might decide to have\n * 10 hardware queues to handle different scenarios:\n *\n * 4 AC HW queues for 1st vif: 0, 1, 2, 3\n * 4 AC HW queues for 2nd vif: 4, 5, 6, 7\n * after-DTIM queue for AP:   8\n * off-channel queue:         9\n *\n * It would then set up the hardware like this:\n *   hw.offchannel_tx_hw_queue = 9\n *\n * and the first virtual interface that is added as follows:\n *   vif.hw_queue[IEEE80211_AC_VO] = 0\n *   vif.hw_queue[IEEE80211_AC_VI] = 1\n *   vif.hw_queue[IEEE80211_AC_BE] = 2\n *   vif.hw_queue[IEEE80211_AC_BK] = 3\n *   vif.cab_queue = 8 // if AP mode, otherwise %IEEE80211_INVAL_HW_QUEUE\n * and the second virtual interface with 4-7.\n *\n * If queue 6 gets full, for example, mac80211 would only stop the second\n * virtual interface's BE queue since virtual interface queues are per AC.\n *\n * Note that the vif.cab_queue value should be set to %IEEE80211_INVAL_HW_QUEUE\n * whenever the queue is not used (i.e. the interface is not in AP mode) if the\n * queue could potentially be shared since mac80211 will look at cab_queue when\n * a queue is stopped/woken even if the interface is not in AP mode.\n */\n\n/**\n * enum ieee80211_filter_flags - hardware filter flags\n *\n * These flags determine what the filter in hardware should be\n * programmed to let through and what should not be passed to the\n * stack. It is always safe to pass more frames than requested,\n * but this has negative impact on power consumption.\n *\n * @FIF_ALLMULTI: pass all multicast frames, this is used if requested\n *\tby the user or if the hardware is not capable of filtering by\n *\tmulticast address.\n *\n * @FIF_FCSFAIL: pass frames with failed FCS (but you need to set the\n *\t%RX_FLAG_FAILED_FCS_CRC for them)\n *\n * @FIF_PLCPFAIL: pass frames with failed PLCP CRC (but you need to set\n *\tthe %RX_FLAG_FAILED_PLCP_CRC for them\n *\n * @FIF_BCN_PRBRESP_PROMISC: This flag is set during scanning to indicate\n *\tto the hardware that it should not filter beacons or probe responses\n *\tby BSSID. Filtering them can greatly reduce the amount of processing\n *\tmac80211 needs to do and the amount of CPU wakeups, so you should\n *\thonour this flag if possible.\n *\n * @FIF_CONTROL: pass control frames (except for PS Poll) addressed to this\n *\tstation\n *\n * @FIF_OTHER_BSS: pass frames destined to other BSSes\n *\n * @FIF_PSPOLL: pass PS Poll frames\n *\n * @FIF_PROBE_REQ: pass probe request frames\n *\n * @FIF_MCAST_ACTION: pass multicast Action frames\n */\nenum ieee80211_filter_flags {\n\tFIF_ALLMULTI\t\t= 1<<1,\n\tFIF_FCSFAIL\t\t= 1<<2,\n\tFIF_PLCPFAIL\t\t= 1<<3,\n\tFIF_BCN_PRBRESP_PROMISC\t= 1<<4,\n\tFIF_CONTROL\t\t= 1<<5,\n\tFIF_OTHER_BSS\t\t= 1<<6,\n\tFIF_PSPOLL\t\t= 1<<7,\n\tFIF_PROBE_REQ\t\t= 1<<8,\n\tFIF_MCAST_ACTION\t= 1<<9,\n};\n\n/**\n * enum ieee80211_ampdu_mlme_action - A-MPDU actions\n *\n * These flags are used with the ampdu_action() callback in\n * &struct ieee80211_ops to indicate which action is needed.\n *\n * Note that drivers MUST be able to deal with a TX aggregation\n * session being stopped even before they OK'ed starting it by\n * calling ieee80211_start_tx_ba_cb_irqsafe, because the peer\n * might receive the addBA frame and send a delBA right away!\n *\n * @IEEE80211_AMPDU_RX_START: start RX aggregation\n * @IEEE80211_AMPDU_RX_STOP: stop RX aggregation\n * @IEEE80211_AMPDU_TX_START: start TX aggregation, the driver must either\n *\tcall ieee80211_start_tx_ba_cb_irqsafe() or\n *\tcall ieee80211_start_tx_ba_cb_irqsafe() with status\n *\t%IEEE80211_AMPDU_TX_START_DELAY_ADDBA to delay addba after\n *\tieee80211_start_tx_ba_cb_irqsafe is called, or just return the special\n *\tstatus %IEEE80211_AMPDU_TX_START_IMMEDIATE.\n * @IEEE80211_AMPDU_TX_OPERATIONAL: TX aggregation has become operational\n * @IEEE80211_AMPDU_TX_STOP_CONT: stop TX aggregation but continue transmitting\n *\tqueued packets, now unaggregated. After all packets are transmitted the\n *\tdriver has to call ieee80211_stop_tx_ba_cb_irqsafe().\n * @IEEE80211_AMPDU_TX_STOP_FLUSH: stop TX aggregation and flush all packets,\n *\tcalled when the station is removed. There's no need or reason to call\n *\tieee80211_stop_tx_ba_cb_irqsafe() in this case as mac80211 assumes the\n *\tsession is gone and removes the station.\n * @IEEE80211_AMPDU_TX_STOP_FLUSH_CONT: called when TX aggregation is stopped\n *\tbut the driver hasn't called ieee80211_stop_tx_ba_cb_irqsafe() yet and\n *\tnow the connection is dropped and the station will be removed. Drivers\n *\tshould clean up and drop remaining packets when this is called.\n */\nenum ieee80211_ampdu_mlme_action {\n\tIEEE80211_AMPDU_RX_START,\n\tIEEE80211_AMPDU_RX_STOP,\n\tIEEE80211_AMPDU_TX_START,\n\tIEEE80211_AMPDU_TX_STOP_CONT,\n\tIEEE80211_AMPDU_TX_STOP_FLUSH,\n\tIEEE80211_AMPDU_TX_STOP_FLUSH_CONT,\n\tIEEE80211_AMPDU_TX_OPERATIONAL,\n};\n\n#define IEEE80211_AMPDU_TX_START_IMMEDIATE 1\n#define IEEE80211_AMPDU_TX_START_DELAY_ADDBA 2\n\n/**\n * struct ieee80211_ampdu_params - AMPDU action parameters\n *\n * @action: the ampdu action, value from %ieee80211_ampdu_mlme_action.\n * @sta: peer of this AMPDU session\n * @tid: tid of the BA session\n * @ssn: start sequence number of the session. TX/RX_STOP can pass 0. When\n *\taction is set to %IEEE80211_AMPDU_RX_START the driver passes back the\n *\tactual ssn value used to start the session and writes the value here.\n * @buf_size: reorder buffer size  (number of subframes). Valid only when the\n *\taction is set to %IEEE80211_AMPDU_RX_START or\n *\t%IEEE80211_AMPDU_TX_OPERATIONAL\n * @amsdu: indicates the peer's ability to receive A-MSDU within A-MPDU.\n *\tvalid when the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL\n * @timeout: BA session timeout. Valid only when the action is set to\n *\t%IEEE80211_AMPDU_RX_START\n */\nstruct ieee80211_ampdu_params {\n\tenum ieee80211_ampdu_mlme_action action;\n\tstruct ieee80211_sta *sta;\n\tu16 tid;\n\tu16 ssn;\n\tu16 buf_size;\n\tbool amsdu;\n\tu16 timeout;\n};\n\n/**\n * enum ieee80211_frame_release_type - frame release reason\n * @IEEE80211_FRAME_RELEASE_PSPOLL: frame released for PS-Poll\n * @IEEE80211_FRAME_RELEASE_UAPSD: frame(s) released due to\n *\tframe received on trigger-enabled AC\n */\nenum ieee80211_frame_release_type {\n\tIEEE80211_FRAME_RELEASE_PSPOLL,\n\tIEEE80211_FRAME_RELEASE_UAPSD,\n};\n\n/**\n * enum ieee80211_rate_control_changed - flags to indicate what changed\n *\n * @IEEE80211_RC_BW_CHANGED: The bandwidth that can be used to transmit\n *\tto this station changed. The actual bandwidth is in the station\n *\tinformation -- for HT20/40 the IEEE80211_HT_CAP_SUP_WIDTH_20_40\n *\tflag changes, for HT and VHT the bandwidth field changes.\n * @IEEE80211_RC_SMPS_CHANGED: The SMPS state of the station changed.\n * @IEEE80211_RC_SUPP_RATES_CHANGED: The supported rate set of this peer\n *\tchanged (in IBSS mode) due to discovering more information about\n *\tthe peer.\n * @IEEE80211_RC_NSS_CHANGED: N_SS (number of spatial streams) was changed\n *\tby the peer\n */\nenum ieee80211_rate_control_changed {\n\tIEEE80211_RC_BW_CHANGED\t\t= BIT(0),\n\tIEEE80211_RC_SMPS_CHANGED\t= BIT(1),\n\tIEEE80211_RC_SUPP_RATES_CHANGED\t= BIT(2),\n\tIEEE80211_RC_NSS_CHANGED\t= BIT(3),\n};\n\n/**\n * enum ieee80211_roc_type - remain on channel type\n *\n * With the support for multi channel contexts and multi channel operations,\n * remain on channel operations might be limited/deferred/aborted by other\n * flows/operations which have higher priority (and vice versa).\n * Specifying the ROC type can be used by devices to prioritize the ROC\n * operations compared to other operations/flows.\n *\n * @IEEE80211_ROC_TYPE_NORMAL: There are no special requirements for this ROC.\n * @IEEE80211_ROC_TYPE_MGMT_TX: The remain on channel request is required\n *\tfor sending management frames offchannel.\n */\nenum ieee80211_roc_type {\n\tIEEE80211_ROC_TYPE_NORMAL = 0,\n\tIEEE80211_ROC_TYPE_MGMT_TX,\n};\n\n/**\n * enum ieee80211_reconfig_type - reconfig type\n *\n * This enum is used by the reconfig_complete() callback to indicate what\n * reconfiguration type was completed.\n *\n * @IEEE80211_RECONFIG_TYPE_RESTART: hw restart type\n *\t(also due to resume() callback returning 1)\n * @IEEE80211_RECONFIG_TYPE_SUSPEND: suspend type (regardless\n *\tof wowlan configuration)\n */\nenum ieee80211_reconfig_type {\n\tIEEE80211_RECONFIG_TYPE_RESTART,\n\tIEEE80211_RECONFIG_TYPE_SUSPEND,\n};\n\n/**\n * struct ieee80211_ops - callbacks from mac80211 to the driver\n *\n * This structure contains various callbacks that the driver may\n * handle or, in some cases, must handle, for example to configure\n * the hardware to a new channel or to transmit a frame.\n *\n * @tx: Handler that 802.11 module calls for each transmitted frame.\n *\tskb contains the buffer starting from the IEEE 802.11 header.\n *\tThe low-level driver should send the frame out based on\n *\tconfiguration in the TX control data. This handler should,\n *\tpreferably, never fail and stop queues appropriately.\n *\tMust be atomic.\n *\n * @start: Called before the first netdevice attached to the hardware\n *\tis enabled. This should turn on the hardware and must turn on\n *\tframe reception (for possibly enabled monitor interfaces.)\n *\tReturns negative error codes, these may be seen in userspace,\n *\tor zero.\n *\tWhen the device is started it should not have a MAC address\n *\tto avoid acknowledging frames before a non-monitor device\n *\tis added.\n *\tMust be implemented and can sleep.\n *\n * @stop: Called after last netdevice attached to the hardware\n *\tis disabled. This should turn off the hardware (at least\n *\tit must turn off frame reception.)\n *\tMay be called right after add_interface if that rejects\n *\tan interface. If you added any work onto the mac80211 workqueue\n *\tyou should ensure to cancel it on this callback.\n *\tMust be implemented and can sleep.\n *\n * @suspend: Suspend the device; mac80211 itself will quiesce before and\n *\tstop transmitting and doing any other configuration, and then\n *\task the device to suspend. This is only invoked when WoWLAN is\n *\tconfigured, otherwise the device is deconfigured completely and\n *\treconfigured at resume time.\n *\tThe driver may also impose special conditions under which it\n *\twants to use the \"normal\" suspend (deconfigure), say if it only\n *\tsupports WoWLAN when the device is associated. In this case, it\n *\tmust return 1 from this function.\n *\n * @resume: If WoWLAN was configured, this indicates that mac80211 is\n *\tnow resuming its operation, after this the device must be fully\n *\tfunctional again. If this returns an error, the only way out is\n *\tto also unregister the device. If it returns 1, then mac80211\n *\twill also go through the regular complete restart on resume.\n *\n * @set_wakeup: Enable or disable wakeup when WoWLAN configuration is\n *\tmodified. The reason is that device_set_wakeup_enable() is\n *\tsupposed to be called when the configuration changes, not only\n *\tin suspend().\n *\n * @add_interface: Called when a netdevice attached to the hardware is\n *\tenabled. Because it is not called for monitor mode devices, @start\n *\tand @stop must be implemented.\n *\tThe driver should perform any initialization it needs before\n *\tthe device can be enabled. The initial configuration for the\n *\tinterface is given in the conf parameter.\n *\tThe callback may refuse to add an interface by returning a\n *\tnegative error code (which will be seen in userspace.)\n *\tMust be implemented and can sleep.\n *\n * @change_interface: Called when a netdevice changes type. This callback\n *\tis optional, but only if it is supported can interface types be\n *\tswitched while the interface is UP. The callback may sleep.\n *\tNote that while an interface is being switched, it will not be\n *\tfound by the interface iteration callbacks.\n *\n * @remove_interface: Notifies a driver that an interface is going down.\n *\tThe @stop callback is called after this if it is the last interface\n *\tand no monitor interfaces are present.\n *\tWhen all interfaces are removed, the MAC address in the hardware\n *\tmust be cleared so the device no longer acknowledges packets,\n *\tthe mac_addr member of the conf structure is, however, set to the\n *\tMAC address of the device going away.\n *\tHence, this callback must be implemented. It can sleep.\n *\n * @config: Handler for configuration requests. IEEE 802.11 code calls this\n *\tfunction to change hardware configuration, e.g., channel.\n *\tThis function should never fail but returns a negative error code\n *\tif it does. The callback can sleep.\n *\n * @bss_info_changed: Handler for configuration requests related to BSS\n *\tparameters that may vary during BSS's lifespan, and may affect low\n *\tlevel driver (e.g. assoc/disassoc status, erp parameters).\n *\tThis function should not be used if no BSS has been set, unless\n *\tfor association indication. The @changed parameter indicates which\n *\tof the bss parameters has changed when a call is made. The callback\n *\tcan sleep.\n *\n * @prepare_multicast: Prepare for multicast filter configuration.\n *\tThis callback is optional, and its return value is passed\n *\tto configure_filter(). This callback must be atomic.\n *\n * @configure_filter: Configure the device's RX filter.\n *\tSee the section \"Frame filtering\" for more information.\n *\tThis callback must be implemented and can sleep.\n *\n * @config_iface_filter: Configure the interface's RX filter.\n *\tThis callback is optional and is used to configure which frames\n *\tshould be passed to mac80211. The filter_flags is the combination\n *\tof FIF_* flags. The changed_flags is a bit mask that indicates\n *\twhich flags are changed.\n *\tThis callback can sleep.\n *\n * @set_tim: Set TIM bit. mac80211 calls this function when a TIM bit\n * \tmust be set or cleared for a given STA. Must be atomic.\n *\n * @set_key: See the section \"Hardware crypto acceleration\"\n *\tThis callback is only called between add_interface and\n *\tremove_interface calls, i.e. while the given virtual interface\n *\tis enabled.\n *\tReturns a negative error code if the key can't be added.\n *\tThe callback can sleep.\n *\n * @update_tkip_key: See the section \"Hardware crypto acceleration\"\n * \tThis callback will be called in the context of Rx. Called for drivers\n * \twhich set IEEE80211_KEY_FLAG_TKIP_REQ_RX_P1_KEY.\n *\tThe callback must be atomic.\n *\n * @set_rekey_data: If the device supports GTK rekeying, for example while the\n *\thost is suspended, it can assign this callback to retrieve the data\n *\tnecessary to do GTK rekeying, this is the KEK, KCK and replay counter.\n *\tAfter rekeying was done it should (for example during resume) notify\n *\tuserspace of the new replay counter using ieee80211_gtk_rekey_notify().\n *\n * @set_default_unicast_key: Set the default (unicast) key index, useful for\n *\tWEP when the device sends data packets autonomously, e.g. for ARP\n *\toffloading. The index can be 0-3, or -1 for unsetting it.\n *\n * @hw_scan: Ask the hardware to service the scan request, no need to start\n *\tthe scan state machine in stack. The scan must honour the channel\n *\tconfiguration done by the regulatory agent in the wiphy's\n *\tregistered bands. The hardware (or the driver) needs to make sure\n *\tthat power save is disabled.\n *\tThe @req ie/ie_len members are rewritten by mac80211 to contain the\n *\tentire IEs after the SSID, so that drivers need not look at these\n *\tat all but just send them after the SSID -- mac80211 includes the\n *\t(extended) supported rates and HT information (where applicable).\n *\tWhen the scan finishes, ieee80211_scan_completed() must be called;\n *\tnote that it also must be called when the scan cannot finish due to\n *\tany error unless this callback returned a negative error code.\n *\tThis callback is also allowed to return the special return value 1,\n *\tthis indicates that hardware scan isn't desirable right now and a\n *\tsoftware scan should be done instead. A driver wishing to use this\n *\tcapability must ensure its (hardware) scan capabilities aren't\n *\tadvertised as more capable than mac80211's software scan is.\n *\tThe callback can sleep.\n *\n * @cancel_hw_scan: Ask the low-level tp cancel the active hw scan.\n *\tThe driver should ask the hardware to cancel the scan (if possible),\n *\tbut the scan will be completed only after the driver will call\n *\tieee80211_scan_completed().\n *\tThis callback is needed for wowlan, to prevent enqueueing a new\n *\tscan_work after the low-level driver was already suspended.\n *\tThe callback can sleep.\n *\n * @sched_scan_start: Ask the hardware to start scanning repeatedly at\n *\tspecific intervals.  The driver must call the\n *\tieee80211_sched_scan_results() function whenever it finds results.\n *\tThis process will continue until sched_scan_stop is called.\n *\n * @sched_scan_stop: Tell the hardware to stop an ongoing scheduled scan.\n *\tIn this case, ieee80211_sched_scan_stopped() must not be called.\n *\n * @sw_scan_start: Notifier function that is called just before a software scan\n *\tis started. Can be NULL, if the driver doesn't need this notification.\n *\tThe mac_addr parameter allows supporting NL80211_SCAN_FLAG_RANDOM_ADDR,\n *\tthe driver may set the NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR flag if it\n *\tcan use this parameter. The callback can sleep.\n *\n * @sw_scan_complete: Notifier function that is called just after a\n *\tsoftware scan finished. Can be NULL, if the driver doesn't need\n *\tthis notification.\n *\tThe callback can sleep.\n *\n * @get_stats: Return low-level statistics.\n * \tReturns zero if statistics are available.\n *\tThe callback can sleep.\n *\n * @get_key_seq: If your device implements encryption in hardware and does\n *\tIV/PN assignment then this callback should be provided to read the\n *\tIV/PN for the given key from hardware.\n *\tThe callback must be atomic.\n *\n * @set_frag_threshold: Configuration of fragmentation threshold. Assign this\n *\tif the device does fragmentation by itself. Note that to prevent the\n *\tstack from doing fragmentation IEEE80211_HW_SUPPORTS_TX_FRAG\n *\tshould be set as well.\n *\tThe callback can sleep.\n *\n * @set_rts_threshold: Configuration of RTS threshold (if device needs it)\n *\tThe callback can sleep.\n *\n * @sta_add: Notifies low level driver about addition of an associated station,\n *\tAP, IBSS/WDS/mesh peer etc. This callback can sleep.\n *\n * @sta_remove: Notifies low level driver about removal of an associated\n *\tstation, AP, IBSS/WDS/mesh peer etc. Note that after the callback\n *\treturns it isn't safe to use the pointer, not even RCU protected;\n *\tno RCU grace period is guaranteed between returning here and freeing\n *\tthe station. See @sta_pre_rcu_remove if needed.\n *\tThis callback can sleep.\n *\n * @sta_add_debugfs: Drivers can use this callback to add debugfs files\n *\twhen a station is added to mac80211's station list. This callback\n *\tshould be within a CONFIG_MAC80211_DEBUGFS conditional. This\n *\tcallback can sleep.\n *\n * @sta_notify: Notifies low level driver about power state transition of an\n *\tassociated station, AP,  IBSS/WDS/mesh peer etc. For a VIF operating\n *\tin AP mode, this callback will not be called when the flag\n *\t%IEEE80211_HW_AP_LINK_PS is set. Must be atomic.\n *\n * @sta_set_txpwr: Configure the station tx power. This callback set the tx\n *\tpower for the station.\n *\tThis callback can sleep.\n *\n * @sta_state: Notifies low level driver about state transition of a\n *\tstation (which can be the AP, a client, IBSS/WDS/mesh peer etc.)\n *\tThis callback is mutually exclusive with @sta_add/@sta_remove.\n *\tIt must not fail for down transitions but may fail for transitions\n *\tup the list of states. Also note that after the callback returns it\n *\tisn't safe to use the pointer, not even RCU protected - no RCU grace\n *\tperiod is guaranteed between returning here and freeing the station.\n *\tSee @sta_pre_rcu_remove if needed.\n *\tThe callback can sleep.\n *\n * @sta_pre_rcu_remove: Notify driver about station removal before RCU\n *\tsynchronisation. This is useful if a driver needs to have station\n *\tpointers protected using RCU, it can then use this call to clear\n *\tthe pointers instead of waiting for an RCU grace period to elapse\n *\tin @sta_state.\n *\tThe callback can sleep.\n *\n * @sta_rc_update: Notifies the driver of changes to the bitrates that can be\n *\tused to transmit to the station. The changes are advertised with bits\n *\tfrom &enum ieee80211_rate_control_changed and the values are reflected\n *\tin the station data. This callback should only be used when the driver\n *\tuses hardware rate control (%IEEE80211_HW_HAS_RATE_CONTROL) since\n *\totherwise the rate control algorithm is notified directly.\n *\tMust be atomic.\n * @sta_rate_tbl_update: Notifies the driver that the rate table changed. This\n *\tis only used if the configured rate control algorithm actually uses\n *\tthe new rate table API, and is therefore optional. Must be atomic.\n *\n * @sta_statistics: Get statistics for this station. For example with beacon\n *\tfiltering, the statistics kept by mac80211 might not be accurate, so\n *\tlet the driver pre-fill the statistics. The driver can fill most of\n *\tthe values (indicating which by setting the filled bitmap), but not\n *\tall of them make sense - see the source for which ones are possible.\n *\tStatistics that the driver doesn't fill will be filled by mac80211.\n *\tThe callback can sleep.\n *\n * @conf_tx: Configure TX queue parameters (EDCF (aifs, cw_min, cw_max),\n *\tbursting) for a hardware TX queue.\n *\tReturns a negative error code on failure.\n *\tThe callback can sleep.\n *\n * @get_tsf: Get the current TSF timer value from firmware/hardware. Currently,\n *\tthis is only used for IBSS mode BSSID merging and debugging. Is not a\n *\trequired function.\n *\tThe callback can sleep.\n *\n * @set_tsf: Set the TSF timer to the specified value in the firmware/hardware.\n *\tCurrently, this is only used for IBSS mode debugging. Is not a\n *\trequired function.\n *\tThe callback can sleep.\n *\n * @offset_tsf: Offset the TSF timer by the specified value in the\n *\tfirmware/hardware.  Preferred to set_tsf as it avoids delay between\n *\tcalling set_tsf() and hardware getting programmed, which will show up\n *\tas TSF delay. Is not a required function.\n *\tThe callback can sleep.\n *\n * @reset_tsf: Reset the TSF timer and allow firmware/hardware to synchronize\n *\twith other STAs in the IBSS. This is only used in IBSS mode. This\n *\tfunction is optional if the firmware/hardware takes full care of\n *\tTSF synchronization.\n *\tThe callback can sleep.\n *\n * @tx_last_beacon: Determine whether the last IBSS beacon was sent by us.\n *\tThis is needed only for IBSS mode and the result of this function is\n *\tused to determine whether to reply to Probe Requests.\n *\tReturns non-zero if this device sent the last beacon.\n *\tThe callback can sleep.\n *\n * @get_survey: Return per-channel survey information\n *\n * @rfkill_poll: Poll rfkill hardware state. If you need this, you also\n *\tneed to set wiphy->rfkill_poll to %true before registration,\n *\tand need to call wiphy_rfkill_set_hw_state() in the callback.\n *\tThe callback can sleep.\n *\n * @set_coverage_class: Set slot time for given coverage class as specified\n *\tin IEEE 802.11-2007 section 17.3.8.6 and modify ACK timeout\n *\taccordingly; coverage class equals to -1 to enable ACK timeout\n *\testimation algorithm (dynack). To disable dynack set valid value for\n *\tcoverage class. This callback is not required and may sleep.\n *\n * @testmode_cmd: Implement a cfg80211 test mode command. The passed @vif may\n *\tbe %NULL. The callback can sleep.\n * @testmode_dump: Implement a cfg80211 test mode dump. The callback can sleep.\n *\n * @flush: Flush all pending frames from the hardware queue, making sure\n *\tthat the hardware queues are empty. The @queues parameter is a bitmap\n *\tof queues to flush, which is useful if different virtual interfaces\n *\tuse different hardware queues; it may also indicate all queues.\n *\tIf the parameter @drop is set to %true, pending frames may be dropped.\n *\tNote that vif can be NULL.\n *\tThe callback can sleep.\n *\n * @channel_switch: Drivers that need (or want) to offload the channel\n *\tswitch operation for CSAs received from the AP may implement this\n *\tcallback. They must then call ieee80211_chswitch_done() to indicate\n *\tcompletion of the channel switch.\n *\n * @set_antenna: Set antenna configuration (tx_ant, rx_ant) on the device.\n *\tParameters are bitmaps of allowed antennas to use for TX/RX. Drivers may\n *\treject TX/RX mask combinations they cannot support by returning -EINVAL\n *\t(also see nl80211.h @NL80211_ATTR_WIPHY_ANTENNA_TX).\n *\n * @get_antenna: Get current antenna configuration from device (tx_ant, rx_ant).\n *\n * @remain_on_channel: Starts an off-channel period on the given channel, must\n *\tcall back to ieee80211_ready_on_channel() when on that channel. Note\n *\tthat normal channel traffic is not stopped as this is intended for hw\n *\toffload. Frames to transmit on the off-channel channel are transmitted\n *\tnormally except for the %IEEE80211_TX_CTL_TX_OFFCHAN flag. When the\n *\tduration (which will always be non-zero) expires, the driver must call\n *\tieee80211_remain_on_channel_expired().\n *\tNote that this callback may be called while the device is in IDLE and\n *\tmust be accepted in this case.\n *\tThis callback may sleep.\n * @cancel_remain_on_channel: Requests that an ongoing off-channel period is\n *\taborted before it expires. This callback may sleep.\n *\n * @set_ringparam: Set tx and rx ring sizes.\n *\n * @get_ringparam: Get tx and rx ring current and maximum sizes.\n *\n * @tx_frames_pending: Check if there is any pending frame in the hardware\n *\tqueues before entering power save.\n *\n * @set_bitrate_mask: Set a mask of rates to be used for rate control selection\n *\twhen transmitting a frame. Currently only legacy rates are handled.\n *\tThe callback can sleep.\n * @event_callback: Notify driver about any event in mac80211. See\n *\t&enum ieee80211_event_type for the different types.\n *\tThe callback must be atomic.\n *\n * @release_buffered_frames: Release buffered frames according to the given\n *\tparameters. In the case where the driver buffers some frames for\n *\tsleeping stations mac80211 will use this callback to tell the driver\n *\tto release some frames, either for PS-poll or uAPSD.\n *\tNote that if the @more_data parameter is %false the driver must check\n *\tif there are more frames on the given TIDs, and if there are more than\n *\tthe frames being released then it must still set the more-data bit in\n *\tthe frame. If the @more_data parameter is %true, then of course the\n *\tmore-data bit must always be set.\n *\tThe @tids parameter tells the driver which TIDs to release frames\n *\tfrom, for PS-poll it will always have only a single bit set.\n *\tIn the case this is used for a PS-poll initiated release, the\n *\t@num_frames parameter will always be 1 so code can be shared. In\n *\tthis case the driver must also set %IEEE80211_TX_STATUS_EOSP flag\n *\ton the TX status (and must report TX status) so that the PS-poll\n *\tperiod is properly ended. This is used to avoid sending multiple\n *\tresponses for a retried PS-poll frame.\n *\tIn the case this is used for uAPSD, the @num_frames parameter may be\n *\tbigger than one, but the driver may send fewer frames (it must send\n *\tat least one, however). In this case it is also responsible for\n *\tsetting the EOSP flag in the QoS header of the frames. Also, when the\n *\tservice period ends, the driver must set %IEEE80211_TX_STATUS_EOSP\n *\ton the last frame in the SP. Alternatively, it may call the function\n *\tieee80211_sta_eosp() to inform mac80211 of the end of the SP.\n *\tThis callback must be atomic.\n * @allow_buffered_frames: Prepare device to allow the given number of frames\n *\tto go out to the given station. The frames will be sent by mac80211\n *\tvia the usual TX path after this call. The TX information for frames\n *\treleased will also have the %IEEE80211_TX_CTL_NO_PS_BUFFER flag set\n *\tand the last one will also have %IEEE80211_TX_STATUS_EOSP set. In case\n *\tframes from multiple TIDs are released and the driver might reorder\n *\tthem between the TIDs, it must set the %IEEE80211_TX_STATUS_EOSP flag\n *\ton the last frame and clear it on all others and also handle the EOSP\n *\tbit in the QoS header correctly. Alternatively, it can also call the\n *\tieee80211_sta_eosp() function.\n *\tThe @tids parameter is a bitmap and tells the driver which TIDs the\n *\tframes will be on; it will at most have two bits set.\n *\tThis callback must be atomic.\n *\n * @get_et_sset_count:  Ethtool API to get string-set count.\n *\n * @get_et_stats:  Ethtool API to get a set of u64 stats.\n *\n * @get_et_strings:  Ethtool API to get a set of strings to describe stats\n *\tand perhaps other supported types of ethtool data-sets.\n *\n * @mgd_prepare_tx: Prepare for transmitting a management frame for association\n *\tbefore associated. In multi-channel scenarios, a virtual interface is\n *\tbound to a channel before it is associated, but as it isn't associated\n *\tyet it need not necessarily be given airtime, in particular since any\n *\ttransmission to a P2P GO needs to be synchronized against the GO's\n *\tpowersave state. mac80211 will call this function before transmitting a\n *\tmanagement frame prior to having successfully associated to allow the\n *\tdriver to give it channel time for the transmission, to get a response\n *\tand to be able to synchronize with the GO.\n *\tFor drivers that set %IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP, mac80211\n *\twould also call this function before transmitting a deauthentication\n *\tframe in case that no beacon was heard from the AP/P2P GO.\n *\tThe callback will be called before each transmission and upon return\n *\tmac80211 will transmit the frame right away.\n *      If duration is greater than zero, mac80211 hints to the driver the\n *      duration for which the operation is requested.\n *\tThe callback is optional and can (should!) sleep.\n *\n * @mgd_protect_tdls_discover: Protect a TDLS discovery session. After sending\n *\ta TDLS discovery-request, we expect a reply to arrive on the AP's\n *\tchannel. We must stay on the channel (no PSM, scan, etc.), since a TDLS\n *\tsetup-response is a direct packet not buffered by the AP.\n *\tmac80211 will call this function just before the transmission of a TDLS\n *\tdiscovery-request. The recommended period of protection is at least\n *\t2 * (DTIM period).\n *\tThe callback is optional and can sleep.\n *\n * @add_chanctx: Notifies device driver about new channel context creation.\n *\tThis callback may sleep.\n * @remove_chanctx: Notifies device driver about channel context destruction.\n *\tThis callback may sleep.\n * @change_chanctx: Notifies device driver about channel context changes that\n *\tmay happen when combining different virtual interfaces on the same\n *\tchannel context with different settings\n *\tThis callback may sleep.\n * @assign_vif_chanctx: Notifies device driver about channel context being bound\n *\tto vif. Possible use is for hw queue remapping.\n *\tThis callback may sleep.\n * @unassign_vif_chanctx: Notifies device driver about channel context being\n *\tunbound from vif.\n *\tThis callback may sleep.\n * @switch_vif_chanctx: switch a number of vifs from one chanctx to\n *\tanother, as specified in the list of\n *\t@ieee80211_vif_chanctx_switch passed to the driver, according\n *\tto the mode defined in &ieee80211_chanctx_switch_mode.\n *\tThis callback may sleep.\n *\n * @start_ap: Start operation on the AP interface, this is called after all the\n *\tinformation in bss_conf is set and beacon can be retrieved. A channel\n *\tcontext is bound before this is called. Note that if the driver uses\n *\tsoftware scan or ROC, this (and @stop_ap) isn't called when the AP is\n *\tjust \"paused\" for scanning/ROC, which is indicated by the beacon being\n *\tdisabled/enabled via @bss_info_changed.\n * @stop_ap: Stop operation on the AP interface.\n *\n * @reconfig_complete: Called after a call to ieee80211_restart_hw() and\n *\tduring resume, when the reconfiguration has completed.\n *\tThis can help the driver implement the reconfiguration step (and\n *\tindicate mac80211 is ready to receive frames).\n *\tThis callback may sleep.\n *\n * @ipv6_addr_change: IPv6 address assignment on the given interface changed.\n *\tCurrently, this is only called for managed or P2P client interfaces.\n *\tThis callback is optional; it must not sleep.\n *\n * @channel_switch_beacon: Starts a channel switch to a new channel.\n *\tBeacons are modified to include CSA or ECSA IEs before calling this\n *\tfunction. The corresponding count fields in these IEs must be\n *\tdecremented, and when they reach 1 the driver must call\n *\tieee80211_csa_finish(). Drivers which use ieee80211_beacon_get()\n *\tget the csa counter decremented by mac80211, but must check if it is\n *\t1 using ieee80211_beacon_counter_is_complete() after the beacon has been\n *\ttransmitted and then call ieee80211_csa_finish().\n *\tIf the CSA count starts as zero or 1, this function will not be called,\n *\tsince there won't be any time to beacon before the switch anyway.\n * @pre_channel_switch: This is an optional callback that is called\n *\tbefore a channel switch procedure is started (ie. when a STA\n *\tgets a CSA or a userspace initiated channel-switch), allowing\n *\tthe driver to prepare for the channel switch.\n * @post_channel_switch: This is an optional callback that is called\n *\tafter a channel switch procedure is completed, allowing the\n *\tdriver to go back to a normal configuration.\n * @abort_channel_switch: This is an optional callback that is called\n *\twhen channel switch procedure was completed, allowing the\n *\tdriver to go back to a normal configuration.\n * @channel_switch_rx_beacon: This is an optional callback that is called\n *\twhen channel switch procedure is in progress and additional beacon with\n *\tCSA IE was received, allowing driver to track changes in count.\n * @join_ibss: Join an IBSS (on an IBSS interface); this is called after all\n *\tinformation in bss_conf is set up and the beacon can be retrieved. A\n *\tchannel context is bound before this is called.\n * @leave_ibss: Leave the IBSS again.\n *\n * @get_expected_throughput: extract the expected throughput towards the\n *\tspecified station. The returned value is expressed in Kbps. It returns 0\n *\tif the RC algorithm does not have proper data to provide.\n *\n * @get_txpower: get current maximum tx power (in dBm) based on configuration\n *\tand hardware limits.\n *\n * @tdls_channel_switch: Start channel-switching with a TDLS peer. The driver\n *\tis responsible for continually initiating channel-switching operations\n *\tand returning to the base channel for communication with the AP. The\n *\tdriver receives a channel-switch request template and the location of\n *\tthe switch-timing IE within the template as part of the invocation.\n *\tThe template is valid only within the call, and the driver can\n *\toptionally copy the skb for further re-use.\n * @tdls_cancel_channel_switch: Stop channel-switching with a TDLS peer. Both\n *\tpeers must be on the base channel when the call completes.\n * @tdls_recv_channel_switch: a TDLS channel-switch related frame (request or\n *\tresponse) has been received from a remote peer. The driver gets\n *\tparameters parsed from the incoming frame and may use them to continue\n *\tan ongoing channel-switch operation. In addition, a channel-switch\n *\tresponse template is provided, together with the location of the\n *\tswitch-timing IE within the template. The skb can only be used within\n *\tthe function call.\n *\n * @wake_tx_queue: Called when new packets have been added to the queue.\n * @sync_rx_queues: Process all pending frames in RSS queues. This is a\n *\tsynchronization which is needed in case driver has in its RSS queues\n *\tpending frames that were received prior to the control path action\n *\tcurrently taken (e.g. disassociation) but are not processed yet.\n *\n * @start_nan: join an existing NAN cluster, or create a new one.\n * @stop_nan: leave the NAN cluster.\n * @nan_change_conf: change NAN configuration. The data in cfg80211_nan_conf\n *\tcontains full new configuration and changes specify which parameters\n *\tare changed with respect to the last NAN config.\n *\tThe driver gets both full configuration and the changed parameters since\n *\tsome devices may need the full configuration while others need only the\n *\tchanged parameters.\n * @add_nan_func: Add a NAN function. Returns 0 on success. The data in\n *\tcfg80211_nan_func must not be referenced outside the scope of\n *\tthis call.\n * @del_nan_func: Remove a NAN function. The driver must call\n *\tieee80211_nan_func_terminated() with\n *\tNL80211_NAN_FUNC_TERM_REASON_USER_REQUEST reason code upon removal.\n * @can_aggregate_in_amsdu: Called in order to determine if HW supports\n *\taggregating two specific frames in the same A-MSDU. The relation\n *\tbetween the skbs should be symmetric and transitive. Note that while\n *\tskb is always a real frame, head may or may not be an A-MSDU.\n * @get_ftm_responder_stats: Retrieve FTM responder statistics, if available.\n *\tStatistics should be cumulative, currently no way to reset is provided.\n *\n * @start_pmsr: start peer measurement (e.g. FTM) (this call can sleep)\n * @abort_pmsr: abort peer measurement (this call can sleep)\n * @set_tid_config: Apply TID specific configurations. This callback may sleep.\n * @reset_tid_config: Reset TID specific configuration for the peer.\n *\tThis callback may sleep.\n * @update_vif_offload: Update virtual interface offload flags\n *\tThis callback may sleep.\n * @sta_set_4addr: Called to notify the driver when a station starts/stops using\n *\t4-address mode\n * @set_sar_specs: Update the SAR (TX power) settings.\n * @sta_set_decap_offload: Called to notify the driver when a station is allowed\n *\tto use rx decapsulation offload\n */\nstruct ieee80211_ops {\n\tvoid (*tx)(struct ieee80211_hw *hw,\n\t\t   struct ieee80211_tx_control *control,\n\t\t   struct sk_buff *skb);\n\tint (*start)(struct ieee80211_hw *hw);\n\tvoid (*stop)(struct ieee80211_hw *hw);\n#ifdef CONFIG_PM\n\tint (*suspend)(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan);\n\tint (*resume)(struct ieee80211_hw *hw);\n\tvoid (*set_wakeup)(struct ieee80211_hw *hw, bool enabled);\n#endif\n\tint (*add_interface)(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif);\n\tint (*change_interface)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tenum nl80211_iftype new_type, bool p2p);\n\tvoid (*remove_interface)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif);\n\tint (*config)(struct ieee80211_hw *hw, u32 changed);\n\tvoid (*bss_info_changed)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *info,\n\t\t\t\t u32 changed);\n\n\tint (*start_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*stop_ap)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\n\tu64 (*prepare_multicast)(struct ieee80211_hw *hw,\n\t\t\t\t struct netdev_hw_addr_list *mc_list);\n\tvoid (*configure_filter)(struct ieee80211_hw *hw,\n\t\t\t\t unsigned int changed_flags,\n\t\t\t\t unsigned int *total_flags,\n\t\t\t\t u64 multicast);\n\tvoid (*config_iface_filter)(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    unsigned int filter_flags,\n\t\t\t\t    unsigned int changed_flags);\n\tint (*set_tim)(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       bool set);\n\tint (*set_key)(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t       struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key);\n\tvoid (*update_tkip_key)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_key_conf *conf,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tu32 iv32, u16 *phase1key);\n\tvoid (*set_rekey_data)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct cfg80211_gtk_rekey_data *data);\n\tvoid (*set_default_unicast_key)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif, int idx);\n\tint (*hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_scan_request *req);\n\tvoid (*cancel_hw_scan)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif);\n\tint (*sched_scan_start)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct cfg80211_sched_scan_request *req,\n\t\t\t\tstruct ieee80211_scan_ies *ies);\n\tint (*sched_scan_stop)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif);\n\tvoid (*sw_scan_start)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      const u8 *mac_addr);\n\tvoid (*sw_scan_complete)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif);\n\tint (*get_stats)(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_low_level_stats *stats);\n\tvoid (*get_key_seq)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_key_conf *key,\n\t\t\t    struct ieee80211_key_seq *seq);\n\tint (*set_frag_threshold)(struct ieee80211_hw *hw, u32 value);\n\tint (*set_rts_threshold)(struct ieee80211_hw *hw, u32 value);\n\tint (*sta_add)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta);\n\tint (*sta_remove)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta);\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tvoid (*sta_add_debugfs)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct dentry *dir);\n#endif\n\tvoid (*sta_notify)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tenum sta_notify_cmd, struct ieee80211_sta *sta);\n\tint (*sta_set_txpwr)(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta);\n\tint (*sta_state)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t enum ieee80211_sta_state old_state,\n\t\t\t enum ieee80211_sta_state new_state);\n\tvoid (*sta_pre_rcu_remove)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta);\n\tvoid (*sta_rc_update)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      u32 changed);\n\tvoid (*sta_rate_tbl_update)(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta);\n\tvoid (*sta_statistics)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct station_info *sinfo);\n\tint (*conf_tx)(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif, u16 ac,\n\t\t       const struct ieee80211_tx_queue_params *params);\n\tu64 (*get_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*set_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tu64 tsf);\n\tvoid (*offset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   s64 offset);\n\tvoid (*reset_tsf)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tint (*tx_last_beacon)(struct ieee80211_hw *hw);\n\n\t/**\n\t * @ampdu_action:\n\t * Perform a certain A-MPDU action.\n\t * The RA/TID combination determines the destination and TID we want\n\t * the ampdu action to be performed for. The action is defined through\n\t * ieee80211_ampdu_mlme_action.\n\t * When the action is set to %IEEE80211_AMPDU_TX_OPERATIONAL the driver\n\t * may neither send aggregates containing more subframes than @buf_size\n\t * nor send aggregates in a way that lost frames would exceed the\n\t * buffer size. If just limiting the aggregate size, this would be\n\t * possible with a buf_size of 8:\n\t *\n\t * - ``TX: 1.....7``\n\t * - ``RX:  2....7`` (lost frame #1)\n\t * - ``TX:        8..1...``\n\t *\n\t * which is invalid since #1 was now re-transmitted well past the\n\t * buffer size of 8. Correct ways to retransmit #1 would be:\n\t *\n\t * - ``TX:        1   or``\n\t * - ``TX:        18  or``\n\t * - ``TX:        81``\n\t *\n\t * Even ``189`` would be wrong since 1 could be lost again.\n\t *\n\t * Returns a negative error code on failure. The driver may return\n\t * %IEEE80211_AMPDU_TX_START_IMMEDIATE for %IEEE80211_AMPDU_TX_START\n\t * if the session can start immediately.\n\t *\n\t * The callback can sleep.\n\t */\n\tint (*ampdu_action)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_ampdu_params *params);\n\tint (*get_survey)(struct ieee80211_hw *hw, int idx,\n\t\tstruct survey_info *survey);\n\tvoid (*rfkill_poll)(struct ieee80211_hw *hw);\n\tvoid (*set_coverage_class)(struct ieee80211_hw *hw, s16 coverage_class);\n#ifdef CONFIG_NL80211_TESTMODE\n\tint (*testmode_cmd)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    void *data, int len);\n\tint (*testmode_dump)(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     void *data, int len);\n#endif\n\tvoid (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t      u32 queues, bool drop);\n\tvoid (*channel_switch)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_channel_switch *ch_switch);\n\tint (*set_antenna)(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);\n\tint (*get_antenna)(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);\n\n\tint (*remain_on_channel)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_channel *chan,\n\t\t\t\t int duration,\n\t\t\t\t enum ieee80211_roc_type type);\n\tint (*cancel_remain_on_channel)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif);\n\tint (*set_ringparam)(struct ieee80211_hw *hw, u32 tx, u32 rx);\n\tvoid (*get_ringparam)(struct ieee80211_hw *hw,\n\t\t\t      u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max);\n\tbool (*tx_frames_pending)(struct ieee80211_hw *hw);\n\tint (*set_bitrate_mask)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t\tconst struct cfg80211_bitrate_mask *mask);\n\tvoid (*event_callback)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       const struct ieee80211_event *event);\n\n\tvoid (*allow_buffered_frames)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      u16 tids, int num_frames,\n\t\t\t\t      enum ieee80211_frame_release_type reason,\n\t\t\t\t      bool more_data);\n\tvoid (*release_buffered_frames)(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tu16 tids, int num_frames,\n\t\t\t\t\tenum ieee80211_frame_release_type reason,\n\t\t\t\t\tbool more_data);\n\n\tint\t(*get_et_sset_count)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif, int sset);\n\tvoid\t(*get_et_stats)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ethtool_stats *stats, u64 *data);\n\tvoid\t(*get_et_strings)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u32 sset, u8 *data);\n\n\tvoid\t(*mgd_prepare_tx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  u16 duration);\n\n\tvoid\t(*mgd_protect_tdls_discover)(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif);\n\n\tint (*add_chanctx)(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_chanctx_conf *ctx);\n\tvoid (*remove_chanctx)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_chanctx_conf *ctx);\n\tvoid (*change_chanctx)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_chanctx_conf *ctx,\n\t\t\t       u32 changed);\n\tint (*assign_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_chanctx_conf *ctx);\n\tvoid (*unassign_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx);\n\tint (*switch_vif_chanctx)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t  int n_vifs,\n\t\t\t\t  enum ieee80211_chanctx_switch_mode mode);\n\n\tvoid (*reconfig_complete)(struct ieee80211_hw *hw,\n\t\t\t\t  enum ieee80211_reconfig_type reconfig_type);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tvoid (*ipv6_addr_change)(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct inet6_dev *idev);\n#endif\n\tvoid (*channel_switch_beacon)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct cfg80211_chan_def *chandef);\n\tint (*pre_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_channel_switch *ch_switch);\n\n\tint (*post_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif);\n\tvoid (*abort_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif);\n\tvoid (*channel_switch_rx_beacon)(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_channel_switch *ch_switch);\n\n\tint (*join_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tvoid (*leave_ibss)(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\tu32 (*get_expected_throughput)(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_sta *sta);\n\tint (*get_txpower)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   int *dbm);\n\n\tint (*tdls_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta, u8 oper_class,\n\t\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t\t   struct sk_buff *tmpl_skb, u32 ch_sw_tm_ie);\n\tvoid (*tdls_cancel_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_sta *sta);\n\tvoid (*tdls_recv_channel_switch)(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_tdls_ch_sw_params *params);\n\n\tvoid (*wake_tx_queue)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq);\n\tvoid (*sync_rx_queues)(struct ieee80211_hw *hw);\n\n\tint (*start_nan)(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct cfg80211_nan_conf *conf);\n\tint (*stop_nan)(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif);\n\tint (*nan_change_conf)(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct cfg80211_nan_conf *conf, u32 changes);\n\tint (*add_nan_func)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    const struct cfg80211_nan_func *nan_func);\n\tvoid (*del_nan_func)(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    u8 instance_id);\n\tbool (*can_aggregate_in_amsdu)(struct ieee80211_hw *hw,\n\t\t\t\t       struct sk_buff *head,\n\t\t\t\t       struct sk_buff *skb);\n\tint (*get_ftm_responder_stats)(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct cfg80211_ftm_responder_stats *ftm_stats);\n\tint (*start_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct cfg80211_pmsr_request *request);\n\tvoid (*abort_pmsr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct cfg80211_pmsr_request *request);\n\tint (*set_tid_config)(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct cfg80211_tid_config *tid_conf);\n\tint (*reset_tid_config)(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta, u8 tids);\n\tvoid (*update_vif_offload)(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif);\n\tvoid (*sta_set_4addr)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta, bool enabled);\n\tint (*set_sar_specs)(struct ieee80211_hw *hw,\n\t\t\t     const struct cfg80211_sar_specs *sar);\n\tvoid (*sta_set_decap_offload)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta, bool enabled);\n};\n\n/**\n * ieee80211_alloc_hw_nm - Allocate a new hardware device\n *\n * This must be called once for each hardware device. The returned pointer\n * must be used to refer to this device when calling other functions.\n * mac80211 allocates a private data area for the driver pointed to by\n * @priv in &struct ieee80211_hw, the size of this area is given as\n * @priv_data_len.\n *\n * @priv_data_len: length of private data\n * @ops: callbacks for this device\n * @requested_name: Requested name for this device.\n *\tNULL is valid value, and means use the default naming (phy%d)\n *\n * Return: A pointer to the new hardware device, or %NULL on error.\n */\nstruct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,\n\t\t\t\t\t   const struct ieee80211_ops *ops,\n\t\t\t\t\t   const char *requested_name);\n\n/**\n * ieee80211_alloc_hw - Allocate a new hardware device\n *\n * This must be called once for each hardware device. The returned pointer\n * must be used to refer to this device when calling other functions.\n * mac80211 allocates a private data area for the driver pointed to by\n * @priv in &struct ieee80211_hw, the size of this area is given as\n * @priv_data_len.\n *\n * @priv_data_len: length of private data\n * @ops: callbacks for this device\n *\n * Return: A pointer to the new hardware device, or %NULL on error.\n */\nstatic inline\nstruct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len,\n\t\t\t\t\tconst struct ieee80211_ops *ops)\n{\n\treturn ieee80211_alloc_hw_nm(priv_data_len, ops, NULL);\n}\n\n/**\n * ieee80211_register_hw - Register hardware device\n *\n * You must call this function before any other functions in\n * mac80211. Note that before a hardware can be registered, you\n * need to fill the contained wiphy's information.\n *\n * @hw: the device to register as returned by ieee80211_alloc_hw()\n *\n * Return: 0 on success. An error code otherwise.\n */\nint ieee80211_register_hw(struct ieee80211_hw *hw);\n\n/**\n * struct ieee80211_tpt_blink - throughput blink description\n * @throughput: throughput in Kbit/sec\n * @blink_time: blink time in milliseconds\n *\t(full cycle, ie. one off + one on period)\n */\nstruct ieee80211_tpt_blink {\n\tint throughput;\n\tint blink_time;\n};\n\n/**\n * enum ieee80211_tpt_led_trigger_flags - throughput trigger flags\n * @IEEE80211_TPT_LEDTRIG_FL_RADIO: enable blinking with radio\n * @IEEE80211_TPT_LEDTRIG_FL_WORK: enable blinking when working\n * @IEEE80211_TPT_LEDTRIG_FL_CONNECTED: enable blinking when at least one\n *\tinterface is connected in some way, including being an AP\n */\nenum ieee80211_tpt_led_trigger_flags {\n\tIEEE80211_TPT_LEDTRIG_FL_RADIO\t\t= BIT(0),\n\tIEEE80211_TPT_LEDTRIG_FL_WORK\t\t= BIT(1),\n\tIEEE80211_TPT_LEDTRIG_FL_CONNECTED\t= BIT(2),\n};\n\n#ifdef CONFIG_MAC80211_LEDS\nconst char *__ieee80211_get_tx_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_rx_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_assoc_led_name(struct ieee80211_hw *hw);\nconst char *__ieee80211_get_radio_led_name(struct ieee80211_hw *hw);\nconst char *\n__ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw,\n\t\t\t\t   unsigned int flags,\n\t\t\t\t   const struct ieee80211_tpt_blink *blink_table,\n\t\t\t\t   unsigned int blink_table_len);\n#endif\n/**\n * ieee80211_get_tx_led_name - get name of TX LED\n *\n * mac80211 creates a transmit LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_tx_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_tx_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_get_rx_led_name - get name of RX LED\n *\n * mac80211 creates a receive LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_rx_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_rx_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_get_assoc_led_name - get name of association LED\n *\n * mac80211 creates a association LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_assoc_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_assoc_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_get_radio_led_name - get name of radio LED\n *\n * mac80211 creates a radio change LED trigger for each wireless hardware\n * that can be used to drive LEDs if your driver registers a LED device.\n * This function returns the name (or %NULL if not configured for LEDs)\n * of the trigger so you can automatically link the LED device.\n *\n * @hw: the hardware to get the LED trigger name for\n *\n * Return: The name of the LED trigger. %NULL if not configured for LEDs.\n */\nstatic inline const char *ieee80211_get_radio_led_name(struct ieee80211_hw *hw)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_get_radio_led_name(hw);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_create_tpt_led_trigger - create throughput LED trigger\n * @hw: the hardware to create the trigger for\n * @flags: trigger flags, see &enum ieee80211_tpt_led_trigger_flags\n * @blink_table: the blink table -- needs to be ordered by throughput\n * @blink_table_len: size of the blink table\n *\n * Return: %NULL (in case of error, or if no LED triggers are\n * configured) or the name of the new trigger.\n *\n * Note: This function must be called before ieee80211_register_hw().\n */\nstatic inline const char *\nieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw, unsigned int flags,\n\t\t\t\t const struct ieee80211_tpt_blink *blink_table,\n\t\t\t\t unsigned int blink_table_len)\n{\n#ifdef CONFIG_MAC80211_LEDS\n\treturn __ieee80211_create_tpt_led_trigger(hw, flags, blink_table,\n\t\t\t\t\t\t  blink_table_len);\n#else\n\treturn NULL;\n#endif\n}\n\n/**\n * ieee80211_unregister_hw - Unregister a hardware device\n *\n * This function instructs mac80211 to free allocated resources\n * and unregister netdevices from the networking subsystem.\n *\n * @hw: the hardware to unregister\n */\nvoid ieee80211_unregister_hw(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_free_hw - free hardware descriptor\n *\n * This function frees everything that was allocated, including the\n * private data for the driver. You must call ieee80211_unregister_hw()\n * before calling this function.\n *\n * @hw: the hardware to free\n */\nvoid ieee80211_free_hw(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_restart_hw - restart hardware completely\n *\n * Call this function when the hardware was restarted for some reason\n * (hardware error, ...) and the driver is unable to restore its state\n * by itself. mac80211 assumes that at this point the driver/hardware\n * is completely uninitialised and stopped, it starts the process by\n * calling the ->start() operation. The driver will need to reset all\n * internal state that it has prior to calling this function.\n *\n * @hw: the hardware to restart\n */\nvoid ieee80211_restart_hw(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_rx_list - receive frame and store processed skbs in a list\n *\n * Use this function to hand received frames to mac80211. The receive\n * buffer in @skb must start with an IEEE 802.11 header. In case of a\n * paged @skb is used, the driver is recommended to put the ieee80211\n * header of the frame on the linear part of the @skb to avoid memory\n * allocation and/or memcpy by the stack.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls to\n * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be\n * mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * This function must be called with BHs disabled and RCU read lock\n *\n * @hw: the hardware this frame came in on\n * @sta: the station the frame was received from, or %NULL\n * @skb: the buffer to receive, owned by mac80211 after this call\n * @list: the destination list\n */\nvoid ieee80211_rx_list(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb, struct list_head *list);\n\n/**\n * ieee80211_rx_napi - receive frame from NAPI context\n *\n * Use this function to hand received frames to mac80211. The receive\n * buffer in @skb must start with an IEEE 802.11 header. In case of a\n * paged @skb is used, the driver is recommended to put the ieee80211\n * header of the frame on the linear part of the @skb to avoid memory\n * allocation and/or memcpy by the stack.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls to\n * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be\n * mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * This function must be called with BHs disabled.\n *\n * @hw: the hardware this frame came in on\n * @sta: the station the frame was received from, or %NULL\n * @skb: the buffer to receive, owned by mac80211 after this call\n * @napi: the NAPI context\n */\nvoid ieee80211_rx_napi(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t       struct sk_buff *skb, struct napi_struct *napi);\n\n/**\n * ieee80211_rx - receive frame\n *\n * Use this function to hand received frames to mac80211. The receive\n * buffer in @skb must start with an IEEE 802.11 header. In case of a\n * paged @skb is used, the driver is recommended to put the ieee80211\n * header of the frame on the linear part of the @skb to avoid memory\n * allocation and/or memcpy by the stack.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls to\n * this function, ieee80211_rx_ni() and ieee80211_rx_irqsafe() may not be\n * mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * In process context use instead ieee80211_rx_ni().\n *\n * @hw: the hardware this frame came in on\n * @skb: the buffer to receive, owned by mac80211 after this call\n */\nstatic inline void ieee80211_rx(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tieee80211_rx_napi(hw, NULL, skb, NULL);\n}\n\n/**\n * ieee80211_rx_irqsafe - receive frame\n *\n * Like ieee80211_rx() but can be called in IRQ context\n * (internally defers to a tasklet.)\n *\n * Calls to this function, ieee80211_rx() or ieee80211_rx_ni() may not\n * be mixed for a single hardware.Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * @hw: the hardware this frame came in on\n * @skb: the buffer to receive, owned by mac80211 after this call\n */\nvoid ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb);\n\n/**\n * ieee80211_rx_ni - receive frame (in process context)\n *\n * Like ieee80211_rx() but can be called in process context\n * (internally disables bottom halves).\n *\n * Calls to this function, ieee80211_rx() and ieee80211_rx_irqsafe() may\n * not be mixed for a single hardware. Must not run concurrently with\n * ieee80211_tx_status() or ieee80211_tx_status_ni().\n *\n * @hw: the hardware this frame came in on\n * @skb: the buffer to receive, owned by mac80211 after this call\n */\nstatic inline void ieee80211_rx_ni(struct ieee80211_hw *hw,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\tieee80211_rx(hw, skb);\n\tlocal_bh_enable();\n}\n\n/**\n * ieee80211_sta_ps_transition - PS transition for connected sta\n *\n * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS\n * flag set, use this function to inform mac80211 about a connected station\n * entering/leaving PS mode.\n *\n * This function may not be called in IRQ context or with softirqs enabled.\n *\n * Calls to this function for a single hardware must be synchronized against\n * each other.\n *\n * @sta: currently connected sta\n * @start: start or stop PS\n *\n * Return: 0 on success. -EINVAL when the requested PS mode is already set.\n */\nint ieee80211_sta_ps_transition(struct ieee80211_sta *sta, bool start);\n\n/**\n * ieee80211_sta_ps_transition_ni - PS transition for connected sta\n *                                  (in process context)\n *\n * Like ieee80211_sta_ps_transition() but can be called in process context\n * (internally disables bottom halves). Concurrent call restriction still\n * applies.\n *\n * @sta: currently connected sta\n * @start: start or stop PS\n *\n * Return: Like ieee80211_sta_ps_transition().\n */\nstatic inline int ieee80211_sta_ps_transition_ni(struct ieee80211_sta *sta,\n\t\t\t\t\t\t  bool start)\n{\n\tint ret;\n\n\tlocal_bh_disable();\n\tret = ieee80211_sta_ps_transition(sta, start);\n\tlocal_bh_enable();\n\n\treturn ret;\n}\n\n/**\n * ieee80211_sta_pspoll - PS-Poll frame received\n * @sta: currently connected station\n *\n * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS flag set,\n * use this function to inform mac80211 that a PS-Poll frame from a\n * connected station was received.\n * This must be used in conjunction with ieee80211_sta_ps_transition()\n * and possibly ieee80211_sta_uapsd_trigger(); calls to all three must\n * be serialized.\n */\nvoid ieee80211_sta_pspoll(struct ieee80211_sta *sta);\n\n/**\n * ieee80211_sta_uapsd_trigger - (potential) U-APSD trigger frame received\n * @sta: currently connected station\n * @tid: TID of the received (potential) trigger frame\n *\n * When operating in AP mode with the %IEEE80211_HW_AP_LINK_PS flag set,\n * use this function to inform mac80211 that a (potential) trigger frame\n * from a connected station was received.\n * This must be used in conjunction with ieee80211_sta_ps_transition()\n * and possibly ieee80211_sta_pspoll(); calls to all three must be\n * serialized.\n * %IEEE80211_NUM_TIDS can be passed as the tid if the tid is unknown.\n * In this case, mac80211 will not check that this tid maps to an AC\n * that is trigger enabled and assume that the caller did the proper\n * checks.\n */\nvoid ieee80211_sta_uapsd_trigger(struct ieee80211_sta *sta, u8 tid);\n\n/*\n * The TX headroom reserved by mac80211 for its own tx_status functions.\n * This is enough for the radiotap header.\n */\n#define IEEE80211_TX_STATUS_HEADROOM\tALIGN(14, 4)\n\n/**\n * ieee80211_sta_set_buffered - inform mac80211 about driver-buffered frames\n * @sta: &struct ieee80211_sta pointer for the sleeping station\n * @tid: the TID that has buffered frames\n * @buffered: indicates whether or not frames are buffered for this TID\n *\n * If a driver buffers frames for a powersave station instead of passing\n * them back to mac80211 for retransmission, the station may still need\n * to be told that there are buffered frames via the TIM bit.\n *\n * This function informs mac80211 whether or not there are frames that are\n * buffered in the driver for a given TID; mac80211 can then use this data\n * to set the TIM bit (NOTE: This may call back into the driver's set_tim\n * call! Beware of the locking!)\n *\n * If all frames are released to the station (due to PS-poll or uAPSD)\n * then the driver needs to inform mac80211 that there no longer are\n * frames buffered. However, when the station wakes up mac80211 assumes\n * that all buffered frames will be transmitted and clears this data,\n * drivers need to make sure they inform mac80211 about all buffered\n * frames on the sleep transition (sta_notify() with %STA_NOTIFY_SLEEP).\n *\n * Note that technically mac80211 only needs to know this per AC, not per\n * TID, but since driver buffering will inevitably happen per TID (since\n * it is related to aggregation) it is easier to make mac80211 map the\n * TID to the AC as required instead of keeping track in all drivers that\n * use this API.\n */\nvoid ieee80211_sta_set_buffered(struct ieee80211_sta *sta,\n\t\t\t\tu8 tid, bool buffered);\n\n/**\n * ieee80211_get_tx_rates - get the selected transmit rates for a packet\n *\n * Call this function in a driver with per-packet rate selection support\n * to combine the rate info in the packet tx info with the most recent\n * rate selection table for the station entry.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @sta: the receiver station to which this packet is sent.\n * @skb: the frame to be transmitted.\n * @dest: buffer for extracted rate/retry information\n * @max_rates: maximum number of rates to fetch\n */\nvoid ieee80211_get_tx_rates(struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct ieee80211_tx_rate *dest,\n\t\t\t    int max_rates);\n\n/**\n * ieee80211_sta_set_expected_throughput - set the expected tpt for a station\n *\n * Call this function to notify mac80211 about a change in expected throughput\n * to a station. A driver for a device that does rate control in firmware can\n * call this function when the expected throughput estimate towards a station\n * changes. The information is used to tune the CoDel AQM applied to traffic\n * going towards that station (which can otherwise be too aggressive and cause\n * slow stations to starve).\n *\n * @pubsta: the station to set throughput for.\n * @thr: the current expected throughput in kbps.\n */\nvoid ieee80211_sta_set_expected_throughput(struct ieee80211_sta *pubsta,\n\t\t\t\t\t   u32 thr);\n\n/**\n * ieee80211_tx_rate_update - transmit rate update callback\n *\n * Drivers should call this functions with a non-NULL pub sta\n * This function can be used in drivers that does not have provision\n * in updating the tx rate in data path.\n *\n * @hw: the hardware the frame was transmitted by\n * @pubsta: the station to update the tx rate for.\n * @info: tx status information\n */\nvoid ieee80211_tx_rate_update(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_sta *pubsta,\n\t\t\t      struct ieee80211_tx_info *info);\n\n/**\n * ieee80211_tx_status - transmit status callback\n *\n * Call this function for all transmitted frames after they have been\n * transmitted. It is permissible to not call this function for\n * multicast frames but this can affect statistics.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other. Calls\n * to this function, ieee80211_tx_status_ni() and ieee80211_tx_status_irqsafe()\n * may not be mixed for a single hardware. Must not run concurrently with\n * ieee80211_rx() or ieee80211_rx_ni().\n *\n * @hw: the hardware the frame was transmitted by\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nvoid ieee80211_tx_status(struct ieee80211_hw *hw,\n\t\t\t struct sk_buff *skb);\n\n/**\n * ieee80211_tx_status_ext - extended transmit status callback\n *\n * This function can be used as a replacement for ieee80211_tx_status\n * in drivers that may want to provide extra information that does not\n * fit into &struct ieee80211_tx_info.\n *\n * Calls to this function for a single hardware must be synchronized\n * against each other. Calls to this function, ieee80211_tx_status_ni()\n * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @status: tx status information\n */\nvoid ieee80211_tx_status_ext(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_status *status);\n\n/**\n * ieee80211_tx_status_noskb - transmit status callback without skb\n *\n * This function can be used as a replacement for ieee80211_tx_status\n * in drivers that cannot reliably map tx status information back to\n * specific skbs.\n *\n * Calls to this function for a single hardware must be synchronized\n * against each other. Calls to this function, ieee80211_tx_status_ni()\n * and ieee80211_tx_status_irqsafe() may not be mixed for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @sta: the receiver station to which this packet is sent\n *\t(NULL for multicast packets)\n * @info: tx status information\n */\nstatic inline void ieee80211_tx_status_noskb(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t\t     struct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_tx_status status = {\n\t\t.sta = sta,\n\t\t.info = info,\n\t};\n\n\tieee80211_tx_status_ext(hw, &status);\n}\n\n/**\n * ieee80211_tx_status_ni - transmit status callback (in process context)\n *\n * Like ieee80211_tx_status() but can be called in process context.\n *\n * Calls to this function, ieee80211_tx_status() and\n * ieee80211_tx_status_irqsafe() may not be mixed\n * for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nstatic inline void ieee80211_tx_status_ni(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tlocal_bh_disable();\n\tieee80211_tx_status(hw, skb);\n\tlocal_bh_enable();\n}\n\n/**\n * ieee80211_tx_status_irqsafe - IRQ-safe transmit status callback\n *\n * Like ieee80211_tx_status() but can be called in IRQ context\n * (internally defers to a tasklet.)\n *\n * Calls to this function, ieee80211_tx_status() and\n * ieee80211_tx_status_ni() may not be mixed for a single hardware.\n *\n * @hw: the hardware the frame was transmitted by\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nvoid ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,\n\t\t\t\t struct sk_buff *skb);\n\n/**\n * ieee80211_tx_status_8023 - transmit status callback for 802.3 frame format\n *\n * Call this function for all transmitted data frames after their transmit\n * completion. This callback should only be called for data frames which\n * are using driver's (or hardware's) offload capability of encap/decap\n * 802.11 frames.\n *\n * This function may not be called in IRQ context. Calls to this function\n * for a single hardware must be synchronized against each other and all\n * calls in the same tx status family.\n *\n * @hw: the hardware the frame was transmitted by\n * @vif: the interface for which the frame was transmitted\n * @skb: the frame that was transmitted, owned by mac80211 after this call\n */\nvoid ieee80211_tx_status_8023(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct sk_buff *skb);\n\n/**\n * ieee80211_report_low_ack - report non-responding station\n *\n * When operating in AP-mode, call this function to report a non-responding\n * connected STA.\n *\n * @sta: the non-responding connected sta\n * @num_packets: number of packets sent to @sta without a response\n */\nvoid ieee80211_report_low_ack(struct ieee80211_sta *sta, u32 num_packets);\n\n#define IEEE80211_MAX_CNTDWN_COUNTERS_NUM 2\n\n/**\n * struct ieee80211_mutable_offsets - mutable beacon offsets\n * @tim_offset: position of TIM element\n * @tim_length: size of TIM element\n * @cntdwn_counter_offs: array of IEEE80211_MAX_CNTDWN_COUNTERS_NUM offsets\n *\tto countdown counters.  This array can contain zero values which\n *\tshould be ignored.\n */\nstruct ieee80211_mutable_offsets {\n\tu16 tim_offset;\n\tu16 tim_length;\n\n\tu16 cntdwn_counter_offs[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];\n};\n\n/**\n * ieee80211_beacon_get_template - beacon template generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @offs: &struct ieee80211_mutable_offsets pointer to struct that will\n *\treceive the offsets that may be updated by the driver.\n *\n * If the driver implements beaconing modes, it must use this function to\n * obtain the beacon template.\n *\n * This function should be used if the beacon frames are generated by the\n * device, and then the driver must use the returned beacon as the template\n * The driver or the device are responsible to update the DTIM and, when\n * applicable, the CSA count.\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: The beacon template. %NULL on error.\n */\nstruct sk_buff *\nieee80211_beacon_get_template(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_mutable_offsets *offs);\n\n/**\n * ieee80211_beacon_get_tim - beacon generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @tim_offset: pointer to variable that will receive the TIM IE offset.\n *\tSet to 0 if invalid (in non-AP modes).\n * @tim_length: pointer to variable that will receive the TIM IE length,\n *\t(including the ID and length bytes!).\n *\tSet to 0 if invalid (in non-AP modes).\n *\n * If the driver implements beaconing modes, it must use this function to\n * obtain the beacon frame.\n *\n * If the beacon frames are generated by the host system (i.e., not in\n * hardware/firmware), the driver uses this function to get each beacon\n * frame from mac80211 -- it is responsible for calling this function exactly\n * once before the beacon is needed (e.g. based on hardware interrupt).\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: The beacon template. %NULL on error.\n */\nstruct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u16 *tim_offset, u16 *tim_length);\n\n/**\n * ieee80211_beacon_get - beacon generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * See ieee80211_beacon_get_tim().\n *\n * Return: See ieee80211_beacon_get_tim().\n */\nstatic inline struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw,\n\t\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\treturn ieee80211_beacon_get_tim(hw, vif, NULL, NULL);\n}\n\n/**\n * ieee80211_beacon_update_cntdwn - request mac80211 to decrement the beacon countdown\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * The beacon counter should be updated after each beacon transmission.\n * This function is called implicitly when\n * ieee80211_beacon_get/ieee80211_beacon_get_tim are called, however if the\n * beacon frames are generated by the device, the driver should call this\n * function after each beacon transmission to sync mac80211's beacon countdown.\n *\n * Return: new countdown value\n */\nu8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_beacon_set_cntdwn - request mac80211 to set beacon countdown\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @counter: the new value for the counter\n *\n * The beacon countdown can be changed by the device, this API should be\n * used by the device driver to update csa counter in mac80211.\n *\n * It should never be used together with ieee80211_beacon_update_cntdwn(),\n * as it will cause a race condition around the counter value.\n */\nvoid ieee80211_beacon_set_cntdwn(struct ieee80211_vif *vif, u8 counter);\n\n/**\n * ieee80211_csa_finish - notify mac80211 about channel switch\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * After a channel switch announcement was scheduled and the counter in this\n * announcement hits 1, this function must be called by the driver to\n * notify mac80211 that the channel can be changed.\n */\nvoid ieee80211_csa_finish(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_beacon_cntdwn_is_complete - find out if countdown reached 1\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * This function returns whether the countdown reached zero.\n */\nbool ieee80211_beacon_cntdwn_is_complete(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_proberesp_get - retrieve a Probe Response template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Creates a Probe Response template which can, for example, be uploaded to\n * hardware. The destination address should be set by the caller.\n *\n * Can only be called in AP mode.\n *\n * Return: The Probe Response template. %NULL on error.\n */\nstruct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif);\n\n/**\n * ieee80211_pspoll_get - retrieve a PS Poll template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Creates a PS Poll a template which can, for example, uploaded to\n * hardware. The template must be updated after association so that correct\n * AID, BSSID and MAC address is used.\n *\n * Note: Caller (or hardware) is responsible for setting the\n * &IEEE80211_FCTL_PM bit.\n *\n * Return: The PS Poll template. %NULL on error.\n */\nstruct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif);\n\n/**\n * ieee80211_nullfunc_get - retrieve a nullfunc template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @qos_ok: QoS NDP is acceptable to the caller, this should be set\n *\tif at all possible\n *\n * Creates a Nullfunc template which can, for example, uploaded to\n * hardware. The template must be updated after association so that correct\n * BSSID and address is used.\n *\n * If @qos_ndp is set and the association is to an AP with QoS/WMM, the\n * returned packet will be QoS NDP.\n *\n * Note: Caller (or hardware) is responsible for setting the\n * &IEEE80211_FCTL_PM bit as well as Duration and Sequence Control fields.\n *\n * Return: The nullfunc template. %NULL on error.\n */\nstruct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       bool qos_ok);\n\n/**\n * ieee80211_probereq_get - retrieve a Probe Request template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @src_addr: source MAC address\n * @ssid: SSID buffer\n * @ssid_len: length of SSID\n * @tailroom: tailroom to reserve at end of SKB for IEs\n *\n * Creates a Probe Request template which can, for example, be uploaded to\n * hardware.\n *\n * Return: The Probe Request template. %NULL on error.\n */\nstruct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t       const u8 *src_addr,\n\t\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t\t       size_t tailroom);\n\n/**\n * ieee80211_rts_get - RTS frame generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame: pointer to the frame that is going to be protected by the RTS.\n * @frame_len: the frame length (in octets).\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n * @rts: The buffer where to store the RTS frame.\n *\n * If the RTS frames are generated by the host system (i.e., not in\n * hardware/firmware), the low-level driver uses this function to receive\n * the next RTS frame from the 802.11 code. The low-level is responsible\n * for calling this function before and RTS frame is needed.\n */\nvoid ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       const void *frame, size_t frame_len,\n\t\t       const struct ieee80211_tx_info *frame_txctl,\n\t\t       struct ieee80211_rts *rts);\n\n/**\n * ieee80211_rts_duration - Get the duration field for an RTS frame\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame_len: the length of the frame that is going to be protected by the RTS.\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n *\n * If the RTS is generated in firmware, but the host system must provide\n * the duration field, the low-level driver uses this function to receive\n * the duration field value in little-endian byteorder.\n *\n * Return: The duration.\n */\n__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, size_t frame_len,\n\t\t\t      const struct ieee80211_tx_info *frame_txctl);\n\n/**\n * ieee80211_ctstoself_get - CTS-to-self frame generation function\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame: pointer to the frame that is going to be protected by the CTS-to-self.\n * @frame_len: the frame length (in octets).\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n * @cts: The buffer where to store the CTS-to-self frame.\n *\n * If the CTS-to-self frames are generated by the host system (i.e., not in\n * hardware/firmware), the low-level driver uses this function to receive\n * the next CTS-to-self frame from the 802.11 code. The low-level is responsible\n * for calling this function before and CTS-to-self frame is needed.\n */\nvoid ieee80211_ctstoself_get(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     const void *frame, size_t frame_len,\n\t\t\t     const struct ieee80211_tx_info *frame_txctl,\n\t\t\t     struct ieee80211_cts *cts);\n\n/**\n * ieee80211_ctstoself_duration - Get the duration field for a CTS-to-self frame\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @frame_len: the length of the frame that is going to be protected by the CTS-to-self.\n * @frame_txctl: &struct ieee80211_tx_info of the frame.\n *\n * If the CTS-to-self is generated in firmware, but the host system must provide\n * the duration field, the low-level driver uses this function to receive\n * the duration field value in little-endian byteorder.\n *\n * Return: The duration.\n */\n__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    size_t frame_len,\n\t\t\t\t    const struct ieee80211_tx_info *frame_txctl);\n\n/**\n * ieee80211_generic_frame_duration - Calculate the duration field for a frame\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @band: the band to calculate the frame duration on\n * @frame_len: the length of the frame.\n * @rate: the rate at which the frame is going to be transmitted.\n *\n * Calculate the duration field of some generic frame, given its\n * length and transmission rate (in 100kbps).\n *\n * Return: The duration.\n */\n__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tenum nl80211_band band,\n\t\t\t\t\tsize_t frame_len,\n\t\t\t\t\tstruct ieee80211_rate *rate);\n\n/**\n * ieee80211_get_buffered_bc - accessing buffered broadcast and multicast frames\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Function for accessing buffered broadcast and multicast frames. If\n * hardware/firmware does not implement buffering of broadcast/multicast\n * frames when power saving is used, 802.11 code buffers them in the host\n * memory. The low-level driver uses this function to fetch next buffered\n * frame. In most cases, this is used when generating beacon frame.\n *\n * Return: A pointer to the next buffered skb or NULL if no more buffered\n * frames are available.\n *\n * Note: buffered frames are returned only after DTIM beacon frame was\n * generated with ieee80211_beacon_get() and the low-level driver must thus\n * call ieee80211_beacon_get() first. ieee80211_get_buffered_bc() returns\n * NULL if the previous generated beacon was not DTIM, so the low-level driver\n * does not need to check for DTIM beacons separately and should be able to\n * use common code for all beacons.\n */\nstruct sk_buff *\nieee80211_get_buffered_bc(struct ieee80211_hw *hw, struct ieee80211_vif *vif);\n\n/**\n * ieee80211_get_tkip_p1k_iv - get a TKIP phase 1 key for IV32\n *\n * This function returns the TKIP phase 1 key for the given IV32.\n *\n * @keyconf: the parameter passed with the set key\n * @iv32: IV32 to get the P1K for\n * @p1k: a buffer to which the key will be written, as 5 u16 values\n */\nvoid ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,\n\t\t\t       u32 iv32, u16 *p1k);\n\n/**\n * ieee80211_get_tkip_p1k - get a TKIP phase 1 key\n *\n * This function returns the TKIP phase 1 key for the IV32 taken\n * from the given packet.\n *\n * @keyconf: the parameter passed with the set key\n * @skb: the packet to take the IV32 value from that will be encrypted\n *\twith this P1K\n * @p1k: a buffer to which the key will be written, as 5 u16 values\n */\nstatic inline void ieee80211_get_tkip_p1k(struct ieee80211_key_conf *keyconf,\n\t\t\t\t\t  struct sk_buff *skb, u16 *p1k)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tconst u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);\n\tu32 iv32 = get_unaligned_le32(&data[4]);\n\n\tieee80211_get_tkip_p1k_iv(keyconf, iv32, p1k);\n}\n\n/**\n * ieee80211_get_tkip_rx_p1k - get a TKIP phase 1 key for RX\n *\n * This function returns the TKIP phase 1 key for the given IV32\n * and transmitter address.\n *\n * @keyconf: the parameter passed with the set key\n * @ta: TA that will be used with the key\n * @iv32: IV32 to get the P1K for\n * @p1k: a buffer to which the key will be written, as 5 u16 values\n */\nvoid ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,\n\t\t\t       const u8 *ta, u32 iv32, u16 *p1k);\n\n/**\n * ieee80211_get_tkip_p2k - get a TKIP phase 2 key\n *\n * This function computes the TKIP RC4 key for the IV values\n * in the packet.\n *\n * @keyconf: the parameter passed with the set key\n * @skb: the packet to take the IV32/IV16 values from that will be\n *\tencrypted with this key\n * @p2k: a buffer to which the key will be written, 16 bytes\n */\nvoid ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,\n\t\t\t    struct sk_buff *skb, u8 *p2k);\n\n/**\n * ieee80211_tkip_add_iv - write TKIP IV and Ext. IV to pos\n *\n * @pos: start of crypto header\n * @keyconf: the parameter passed with the set key\n * @pn: PN to add\n *\n * Returns: pointer to the octet following IVs (i.e. beginning of\n * the packet payload)\n *\n * This function writes the tkip IV value to pos (which should\n * point to the crypto header)\n */\nu8 *ieee80211_tkip_add_iv(u8 *pos, struct ieee80211_key_conf *keyconf, u64 pn);\n\n/**\n * ieee80211_get_key_rx_seq - get key RX sequence counter\n *\n * @keyconf: the parameter passed with the set key\n * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);\n *\tthe value on TID 0 is also used for non-QoS frames. For\n *\tCMAC, only TID 0 is valid.\n * @seq: buffer to receive the sequence data\n *\n * This function allows a driver to retrieve the current RX IV/PNs\n * for the given key. It must not be called if IV checking is done\n * by the device and not by mac80211.\n *\n * Note that this function may only be called when no RX processing\n * can be done concurrently.\n */\nvoid ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq);\n\n/**\n * ieee80211_set_key_rx_seq - set key RX sequence counter\n *\n * @keyconf: the parameter passed with the set key\n * @tid: The TID, or -1 for the management frame value (CCMP/GCMP only);\n *\tthe value on TID 0 is also used for non-QoS frames. For\n *\tCMAC, only TID 0 is valid.\n * @seq: new sequence data\n *\n * This function allows a driver to set the current RX IV/PNs for the\n * given key. This is useful when resuming from WoWLAN sleep and GTK\n * rekey may have been done while suspended. It should not be called\n * if IV checking is done by the device and not by mac80211.\n *\n * Note that this function may only be called when no RX processing\n * can be done concurrently.\n */\nvoid ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq);\n\n/**\n * ieee80211_remove_key - remove the given key\n * @keyconf: the parameter passed with the set key\n *\n * Remove the given key. If the key was uploaded to the hardware at the\n * time this function is called, it is not deleted in the hardware but\n * instead assumed to have been removed already.\n *\n * Note that due to locking considerations this function can (currently)\n * only be called during key iteration (ieee80211_iter_keys().)\n */\nvoid ieee80211_remove_key(struct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_gtk_rekey_add - add a GTK key from rekeying during WoWLAN\n * @vif: the virtual interface to add the key on\n * @keyconf: new key data\n *\n * When GTK rekeying was done while the system was suspended, (a) new\n * key(s) will be available. These will be needed by mac80211 for proper\n * RX processing, so this function allows setting them.\n *\n * The function returns the newly allocated key structure, which will\n * have similar contents to the passed key configuration but point to\n * mac80211-owned memory. In case of errors, the function returns an\n * ERR_PTR(), use IS_ERR() etc.\n *\n * Note that this function assumes the key isn't added to hardware\n * acceleration, so no TX will be done with the key. Since it's a GTK\n * on managed (station) networks, this is true anyway. If the driver\n * calls this function from the resume callback and subsequently uses\n * the return code 1 to reconfigure the device, this key will be part\n * of the reconfiguration.\n *\n * Note that the driver should also call ieee80211_set_key_rx_seq()\n * for the new key for each TID to set up sequence counters properly.\n *\n * IMPORTANT: If this replaces a key that is present in the hardware,\n * then it will attempt to remove it during this call. In many cases\n * this isn't what you want, so call ieee80211_remove_key() first for\n * the key that's being replaced.\n */\nstruct ieee80211_key_conf *\nieee80211_gtk_rekey_add(struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_gtk_rekey_notify - notify userspace supplicant of rekeying\n * @vif: virtual interface the rekeying was done on\n * @bssid: The BSSID of the AP, for checking association\n * @replay_ctr: the new replay counter after GTK rekeying\n * @gfp: allocation flags\n */\nvoid ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,\n\t\t\t\tconst u8 *replay_ctr, gfp_t gfp);\n\n/**\n * ieee80211_key_mic_failure - increment MIC failure counter for the key\n *\n * Note: this is really only safe if no other RX function is called\n * at the same time.\n *\n * @keyconf: the key in question\n */\nvoid ieee80211_key_mic_failure(struct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_key_replay - increment replay counter for the key\n *\n * Note: this is really only safe if no other RX function is called\n * at the same time.\n *\n * @keyconf: the key in question\n */\nvoid ieee80211_key_replay(struct ieee80211_key_conf *keyconf);\n\n/**\n * ieee80211_wake_queue - wake specific queue\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @queue: queue number (counted from zero).\n *\n * Drivers should use this function instead of netif_wake_queue.\n */\nvoid ieee80211_wake_queue(struct ieee80211_hw *hw, int queue);\n\n/**\n * ieee80211_stop_queue - stop specific queue\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @queue: queue number (counted from zero).\n *\n * Drivers should use this function instead of netif_stop_queue.\n */\nvoid ieee80211_stop_queue(struct ieee80211_hw *hw, int queue);\n\n/**\n * ieee80211_queue_stopped - test status of the queue\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n * @queue: queue number (counted from zero).\n *\n * Drivers should use this function instead of netif_stop_queue.\n *\n * Return: %true if the queue is stopped. %false otherwise.\n */\n\nint ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue);\n\n/**\n * ieee80211_stop_queues - stop all queues\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n *\n * Drivers should use this function instead of netif_stop_queue.\n */\nvoid ieee80211_stop_queues(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_wake_queues - wake all queues\n * @hw: pointer as obtained from ieee80211_alloc_hw().\n *\n * Drivers should use this function instead of netif_wake_queue.\n */\nvoid ieee80211_wake_queues(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_scan_completed - completed hardware scan\n *\n * When hardware scan offload is used (i.e. the hw_scan() callback is\n * assigned) this function needs to be called by the driver to notify\n * mac80211 that the scan finished. This function can be called from\n * any context, including hardirq context.\n *\n * @hw: the hardware that finished the scan\n * @info: information about the completed scan\n */\nvoid ieee80211_scan_completed(struct ieee80211_hw *hw,\n\t\t\t      struct cfg80211_scan_info *info);\n\n/**\n * ieee80211_sched_scan_results - got results from scheduled scan\n *\n * When a scheduled scan is running, this function needs to be called by the\n * driver whenever there are new scan results available.\n *\n * @hw: the hardware that is performing scheduled scans\n */\nvoid ieee80211_sched_scan_results(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_sched_scan_stopped - inform that the scheduled scan has stopped\n *\n * When a scheduled scan is running, this function can be called by\n * the driver if it needs to stop the scan to perform another task.\n * Usual scenarios are drivers that cannot continue the scheduled scan\n * while associating, for instance.\n *\n * @hw: the hardware that is performing scheduled scans\n */\nvoid ieee80211_sched_scan_stopped(struct ieee80211_hw *hw);\n\n/**\n * enum ieee80211_interface_iteration_flags - interface iteration flags\n * @IEEE80211_IFACE_ITER_NORMAL: Iterate over all interfaces that have\n *\tbeen added to the driver; However, note that during hardware\n *\treconfiguration (after restart_hw) it will iterate over a new\n *\tinterface and over all the existing interfaces even if they\n *\thaven't been re-added to the driver yet.\n * @IEEE80211_IFACE_ITER_RESUME_ALL: During resume, iterate over all\n *\tinterfaces, even if they haven't been re-added to the driver yet.\n * @IEEE80211_IFACE_ITER_ACTIVE: Iterate only active interfaces (netdev is up).\n * @IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER: Skip any interfaces where SDATA\n *\tis not in the driver.  This may fix crashes during firmware recovery\n *\tfor instance.\n */\nenum ieee80211_interface_iteration_flags {\n\tIEEE80211_IFACE_ITER_NORMAL\t= 0,\n\tIEEE80211_IFACE_ITER_RESUME_ALL\t= BIT(0),\n\tIEEE80211_IFACE_ITER_ACTIVE\t= BIT(1),\n\tIEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER\t= BIT(2),\n};\n\n/**\n * ieee80211_iterate_interfaces - iterate interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware and calls the callback for them. This includes active as well as\n * inactive interfaces. This function allows the iterator function to sleep.\n * Will iterate over a new interface during add_interface().\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_interfaces(struct ieee80211_hw *hw, u32 iter_flags,\n\t\t\t\t  void (*iterator)(void *data, u8 *mac,\n\t\t\t\t\t\t   struct ieee80211_vif *vif),\n\t\t\t\t  void *data);\n\n/**\n * ieee80211_iterate_active_interfaces - iterate active interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware that are currently active and calls the callback for them.\n * This function allows the iterator function to sleep, when the iterator\n * function is atomic @ieee80211_iterate_active_interfaces_atomic can\n * be used.\n * Does not iterate over a new interface during add_interface().\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call\n * @data: first argument of the iterator function\n */\nstatic inline void\nieee80211_iterate_active_interfaces(struct ieee80211_hw *hw, u32 iter_flags,\n\t\t\t\t    void (*iterator)(void *data, u8 *mac,\n\t\t\t\t\t\t     struct ieee80211_vif *vif),\n\t\t\t\t    void *data)\n{\n\tieee80211_iterate_interfaces(hw,\n\t\t\t\t     iter_flags | IEEE80211_IFACE_ITER_ACTIVE,\n\t\t\t\t     iterator, data);\n}\n\n/**\n * ieee80211_iterate_active_interfaces_atomic - iterate active interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware that are currently active and calls the callback for them.\n * This function requires the iterator callback function to be atomic,\n * if that is not desired, use @ieee80211_iterate_active_interfaces instead.\n * Does not iterate over a new interface during add_interface().\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call, cannot sleep\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_active_interfaces_atomic(struct ieee80211_hw *hw,\n\t\t\t\t\t\tu32 iter_flags,\n\t\t\t\t\t\tvoid (*iterator)(void *data,\n\t\t\t\t\t\t    u8 *mac,\n\t\t\t\t\t\t    struct ieee80211_vif *vif),\n\t\t\t\t\t\tvoid *data);\n\n/**\n * ieee80211_iterate_active_interfaces_mtx - iterate active interfaces\n *\n * This function iterates over the interfaces associated with a given\n * hardware that are currently active and calls the callback for them.\n * This version can only be used while holding the wiphy mutex.\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iter_flags: iteration flags, see &enum ieee80211_interface_iteration_flags\n * @iterator: the iterator function to call, cannot sleep\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_active_interfaces_mtx(struct ieee80211_hw *hw,\n\t\t\t\t\t     u32 iter_flags,\n\t\t\t\t\t     void (*iterator)(void *data,\n\t\t\t\t\t\tu8 *mac,\n\t\t\t\t\t\tstruct ieee80211_vif *vif),\n\t\t\t\t\t     void *data);\n\n/**\n * ieee80211_iterate_stations_atomic - iterate stations\n *\n * This function iterates over all stations associated with a given\n * hardware that are currently uploaded to the driver and calls the callback\n * function for them.\n * This function requires the iterator callback function to be atomic,\n *\n * @hw: the hardware struct of which the interfaces should be iterated over\n * @iterator: the iterator function to call, cannot sleep\n * @data: first argument of the iterator function\n */\nvoid ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,\n\t\t\t\t       void (*iterator)(void *data,\n\t\t\t\t\t\tstruct ieee80211_sta *sta),\n\t\t\t\t       void *data);\n/**\n * ieee80211_queue_work - add work onto the mac80211 workqueue\n *\n * Drivers and mac80211 use this to add work onto the mac80211 workqueue.\n * This helper ensures drivers are not queueing work when they should not be.\n *\n * @hw: the hardware struct for the interface we are adding work for\n * @work: the work we want to add onto the mac80211 workqueue\n */\nvoid ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work);\n\n/**\n * ieee80211_queue_delayed_work - add work onto the mac80211 workqueue\n *\n * Drivers and mac80211 use this to queue delayed work onto the mac80211\n * workqueue.\n *\n * @hw: the hardware struct for the interface we are adding work for\n * @dwork: delayable work to queue onto the mac80211 workqueue\n * @delay: number of jiffies to wait before queueing\n */\nvoid ieee80211_queue_delayed_work(struct ieee80211_hw *hw,\n\t\t\t\t  struct delayed_work *dwork,\n\t\t\t\t  unsigned long delay);\n\n/**\n * ieee80211_start_tx_ba_session - Start a tx Block Ack session.\n * @sta: the station for which to start a BA session\n * @tid: the TID to BA on.\n * @timeout: session timeout value (in TUs)\n *\n * Return: success if addBA request was sent, failure otherwise\n *\n * Although mac80211/low level driver/user space application can estimate\n * the need to start aggregation on a certain RA/TID, the session level\n * will be managed by the mac80211.\n */\nint ieee80211_start_tx_ba_session(struct ieee80211_sta *sta, u16 tid,\n\t\t\t\t  u16 timeout);\n\n/**\n * ieee80211_start_tx_ba_cb_irqsafe - low level driver ready to aggregate.\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @ra: receiver address of the BA session recipient.\n * @tid: the TID to BA on.\n *\n * This function must be called by low level driver once it has\n * finished with preparations for the BA session. It can be called\n * from any context.\n */\nvoid ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,\n\t\t\t\t      u16 tid);\n\n/**\n * ieee80211_stop_tx_ba_session - Stop a Block Ack session.\n * @sta: the station whose BA session to stop\n * @tid: the TID to stop BA.\n *\n * Return: negative error if the TID is invalid, or no aggregation active\n *\n * Although mac80211/low level driver/user space application can estimate\n * the need to stop aggregation on a certain RA/TID, the session level\n * will be managed by the mac80211.\n */\nint ieee80211_stop_tx_ba_session(struct ieee80211_sta *sta, u16 tid);\n\n/**\n * ieee80211_stop_tx_ba_cb_irqsafe - low level driver ready to stop aggregate.\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @ra: receiver address of the BA session recipient.\n * @tid: the desired TID to BA on.\n *\n * This function must be called by low level driver once it has\n * finished with preparations for the BA session tear down. It\n * can be called from any context.\n */\nvoid ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif, const u8 *ra,\n\t\t\t\t     u16 tid);\n\n/**\n * ieee80211_find_sta - find a station\n *\n * @vif: virtual interface to look for station on\n * @addr: station's address\n *\n * Return: The station, if found. %NULL otherwise.\n *\n * Note: This function must be called under RCU lock and the\n * resulting pointer is only valid under RCU lock as well.\n */\nstruct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,\n\t\t\t\t\t const u8 *addr);\n\n/**\n * ieee80211_find_sta_by_ifaddr - find a station on hardware\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @addr: remote station's address\n * @localaddr: local address (vif->sdata->vif.addr). Use NULL for 'any'.\n *\n * Return: The station, if found. %NULL otherwise.\n *\n * Note: This function must be called under RCU lock and the\n * resulting pointer is only valid under RCU lock as well.\n *\n * NOTE: You may pass NULL for localaddr, but then you will just get\n *      the first STA that matches the remote address 'addr'.\n *      We can have multiple STA associated with multiple\n *      logical stations (e.g. consider a station connecting to another\n *      BSSID on the same AP hardware without disconnecting first).\n *      In this case, the result of this method with localaddr NULL\n *      is not reliable.\n *\n * DO NOT USE THIS FUNCTION with localaddr NULL if at all possible.\n */\nstruct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,\n\t\t\t\t\t       const u8 *addr,\n\t\t\t\t\t       const u8 *localaddr);\n\n/**\n * ieee80211_sta_block_awake - block station from waking up\n * @hw: the hardware\n * @pubsta: the station\n * @block: whether to block or unblock\n *\n * Some devices require that all frames that are on the queues\n * for a specific station that went to sleep are flushed before\n * a poll response or frames after the station woke up can be\n * delivered to that it. Note that such frames must be rejected\n * by the driver as filtered, with the appropriate status flag.\n *\n * This function allows implementing this mode in a race-free\n * manner.\n *\n * To do this, a driver must keep track of the number of frames\n * still enqueued for a specific station. If this number is not\n * zero when the station goes to sleep, the driver must call\n * this function to force mac80211 to consider the station to\n * be asleep regardless of the station's actual state. Once the\n * number of outstanding frames reaches zero, the driver must\n * call this function again to unblock the station. That will\n * cause mac80211 to be able to send ps-poll responses, and if\n * the station queried in the meantime then frames will also\n * be sent out as a result of this. Additionally, the driver\n * will be notified that the station woke up some time after\n * it is unblocked, regardless of whether the station actually\n * woke up while blocked or not.\n */\nvoid ieee80211_sta_block_awake(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *pubsta, bool block);\n\n/**\n * ieee80211_sta_eosp - notify mac80211 about end of SP\n * @pubsta: the station\n *\n * When a device transmits frames in a way that it can't tell\n * mac80211 in the TX status about the EOSP, it must clear the\n * %IEEE80211_TX_STATUS_EOSP bit and call this function instead.\n * This applies for PS-Poll as well as uAPSD.\n *\n * Note that just like with _tx_status() and _rx() drivers must\n * not mix calls to irqsafe/non-irqsafe versions, this function\n * must not be mixed with those either. Use the all irqsafe, or\n * all non-irqsafe, don't mix!\n *\n * NB: the _irqsafe version of this function doesn't exist, no\n *     driver needs it right now. Don't call this function if\n *     you'd need the _irqsafe version, look at the git history\n *     and restore the _irqsafe version!\n */\nvoid ieee80211_sta_eosp(struct ieee80211_sta *pubsta);\n\n/**\n * ieee80211_send_eosp_nullfunc - ask mac80211 to send NDP with EOSP\n * @pubsta: the station\n * @tid: the tid of the NDP\n *\n * Sometimes the device understands that it needs to close\n * the Service Period unexpectedly. This can happen when\n * sending frames that are filling holes in the BA window.\n * In this case, the device can ask mac80211 to send a\n * Nullfunc frame with EOSP set. When that happens, the\n * driver must have called ieee80211_sta_set_buffered() to\n * let mac80211 know that there are no buffered frames any\n * more, otherwise mac80211 will get the more_data bit wrong.\n * The low level driver must have made sure that the frame\n * will be sent despite the station being in power-save.\n * Mac80211 won't call allow_buffered_frames().\n * Note that calling this function, doesn't exempt the driver\n * from closing the EOSP properly, it will still have to call\n * ieee80211_sta_eosp when the NDP is sent.\n */\nvoid ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid);\n\n/**\n * ieee80211_sta_register_airtime - register airtime usage for a sta/tid\n *\n * Register airtime usage for a given sta on a given tid. The driver must call\n * this function to notify mac80211 that a station used a certain amount of\n * airtime. This information will be used by the TXQ scheduler to schedule\n * stations in a way that ensures airtime fairness.\n *\n * The reported airtime should as a minimum include all time that is spent\n * transmitting to the remote station, including overhead and padding, but not\n * including time spent waiting for a TXOP. If the time is not reported by the\n * hardware it can in some cases be calculated from the rate and known frame\n * composition. When possible, the time should include any failed transmission\n * attempts.\n *\n * The driver can either call this function synchronously for every packet or\n * aggregate, or asynchronously as airtime usage information becomes available.\n * TX and RX airtime can be reported together, or separately by setting one of\n * them to 0.\n *\n * @pubsta: the station\n * @tid: the TID to register airtime for\n * @tx_airtime: airtime used during TX (in usec)\n * @rx_airtime: airtime used during RX (in usec)\n */\nvoid ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t    u32 tx_airtime, u32 rx_airtime);\n\n/**\n * ieee80211_txq_airtime_check - check if a txq can send frame to device\n *\n * @hw: pointer obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n *\n * Return true if the AQL's airtime limit has not been reached and the txq can\n * continue to send more packets to the device. Otherwise return false.\n */\nbool\nieee80211_txq_airtime_check(struct ieee80211_hw *hw, struct ieee80211_txq *txq);\n\n/**\n * ieee80211_iter_keys - iterate keys programmed into the device\n * @hw: pointer obtained from ieee80211_alloc_hw()\n * @vif: virtual interface to iterate, may be %NULL for all\n * @iter: iterator function that will be called for each key\n * @iter_data: custom data to pass to the iterator function\n *\n * This function can be used to iterate all the keys known to\n * mac80211, even those that weren't previously programmed into\n * the device. This is intended for use in WoWLAN if the device\n * needs reprogramming of the keys during suspend. Note that due\n * to locking reasons, it is also only safe to call this at few\n * spots since it must hold the RTNL and be able to sleep.\n *\n * The order in which the keys are iterated matches the order\n * in which they were originally installed and handed to the\n * set_key callback.\n */\nvoid ieee80211_iter_keys(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t\t      void *data),\n\t\t\t void *iter_data);\n\n/**\n * ieee80211_iter_keys_rcu - iterate keys programmed into the device\n * @hw: pointer obtained from ieee80211_alloc_hw()\n * @vif: virtual interface to iterate, may be %NULL for all\n * @iter: iterator function that will be called for each key\n * @iter_data: custom data to pass to the iterator function\n *\n * This function can be used to iterate all the keys known to\n * mac80211, even those that weren't previously programmed into\n * the device. Note that due to locking reasons, keys of station\n * in removal process will be skipped.\n *\n * This function requires being called in an RCU critical section,\n * and thus iter must be atomic.\n */\nvoid ieee80211_iter_keys_rcu(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t\t  struct ieee80211_key_conf *key,\n\t\t\t\t\t  void *data),\n\t\t\t     void *iter_data);\n\n/**\n * ieee80211_iter_chan_contexts_atomic - iterate channel contexts\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @iter: iterator function\n * @iter_data: data passed to iterator function\n *\n * Iterate all active channel contexts. This function is atomic and\n * doesn't acquire any locks internally that might be held in other\n * places while calling into the driver.\n *\n * The iterator will not find a context that's being added (during\n * the driver callback to add it) but will find it while it's being\n * removed.\n *\n * Note that during hardware restart, all contexts that existed\n * before the restart are considered already present so will be\n * found while iterating, whether they've been re-added already\n * or not.\n */\nvoid ieee80211_iter_chan_contexts_atomic(\n\tstruct ieee80211_hw *hw,\n\tvoid (*iter)(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_chanctx_conf *chanctx_conf,\n\t\t     void *data),\n\tvoid *iter_data);\n\n/**\n * ieee80211_ap_probereq_get - retrieve a Probe Request template\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Creates a Probe Request template which can, for example, be uploaded to\n * hardware. The template is filled with bssid, ssid and supported rate\n * information. This function must only be called from within the\n * .bss_info_changed callback function and only in managed mode. The function\n * is only useful when the interface is associated, otherwise it will return\n * %NULL.\n *\n * Return: The Probe Request template. %NULL on error.\n */\nstruct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif);\n\n/**\n * ieee80211_beacon_loss - inform hardware does not receive beacons\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER and\n * %IEEE80211_CONF_PS is set, the driver needs to inform whenever the\n * hardware is not receiving beacons with this function.\n */\nvoid ieee80211_beacon_loss(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_connection_loss - inform hardware has lost connection to the AP\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * When beacon filtering is enabled with %IEEE80211_VIF_BEACON_FILTER, and\n * %IEEE80211_CONF_PS and %IEEE80211_HW_CONNECTION_MONITOR are set, the driver\n * needs to inform if the connection to the AP has been lost.\n * The function may also be called if the connection needs to be terminated\n * for some other reason, even if %IEEE80211_HW_CONNECTION_MONITOR isn't set.\n *\n * This function will cause immediate change to disassociated state,\n * without connection recovery attempts.\n */\nvoid ieee80211_connection_loss(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_disconnect - request disconnection\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @reconnect: immediate reconnect is desired\n *\n * Request disconnection from the current network and, if enabled, send a\n * hint to the higher layers that immediate reconnect is desired.\n */\nvoid ieee80211_disconnect(struct ieee80211_vif *vif, bool reconnect);\n\n/**\n * ieee80211_resume_disconnect - disconnect from AP after resume\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * Instructs mac80211 to disconnect from the AP after resume.\n * Drivers can use this after WoWLAN if they know that the\n * connection cannot be kept up, for example because keys were\n * used while the device was asleep but the replay counters or\n * similar cannot be retrieved from the device during resume.\n *\n * Note that due to implementation issues, if the driver uses\n * the reconfiguration functionality during resume the interface\n * will still be added as associated first during resume and then\n * disconnect normally later.\n *\n * This function can only be called from the resume callback and\n * the driver must not be holding any of its own locks while it\n * calls this function, or at least not any locks it needs in the\n * key configuration paths (if it supports HW crypto).\n */\nvoid ieee80211_resume_disconnect(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_cqm_rssi_notify - inform a configured connection quality monitoring\n *\trssi threshold triggered\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @rssi_event: the RSSI trigger event type\n * @rssi_level: new RSSI level value or 0 if not available\n * @gfp: context flags\n *\n * When the %IEEE80211_VIF_SUPPORTS_CQM_RSSI is set, and a connection quality\n * monitoring is configured with an rssi threshold, the driver will inform\n * whenever the rssi level reaches the threshold.\n */\nvoid ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,\n\t\t\t       enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t       s32 rssi_level,\n\t\t\t       gfp_t gfp);\n\n/**\n * ieee80211_cqm_beacon_loss_notify - inform CQM of beacon loss\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @gfp: context flags\n */\nvoid ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp);\n\n/**\n * ieee80211_radar_detected - inform that a radar was detected\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n */\nvoid ieee80211_radar_detected(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_chswitch_done - Complete channel switch process\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @success: make the channel switch successful or not\n *\n * Complete the channel switch post-process: set the new operational channel\n * and wake up the suspended queues.\n */\nvoid ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success);\n\n/**\n * ieee80211_request_smps - request SM PS transition\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @smps_mode: new SM PS mode\n *\n * This allows the driver to request an SM PS transition in managed\n * mode. This is useful when the driver has more information than\n * the stack about possible interference, for example by bluetooth.\n */\nvoid ieee80211_request_smps(struct ieee80211_vif *vif,\n\t\t\t    enum ieee80211_smps_mode smps_mode);\n\n/**\n * ieee80211_ready_on_channel - notification of remain-on-channel start\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n */\nvoid ieee80211_ready_on_channel(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_remain_on_channel_expired - remain_on_channel duration expired\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n */\nvoid ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw);\n\n/**\n * ieee80211_stop_rx_ba_session - callback to stop existing BA sessions\n *\n * in order not to harm the system performance and user experience, the device\n * may request not to allow any rx ba session and tear down existing rx ba\n * sessions based on system constraints such as periodic BT activity that needs\n * to limit wlan activity (eg.sco or a2dp).\"\n * in such cases, the intention is to limit the duration of the rx ppdu and\n * therefore prevent the peer device to use a-mpdu aggregation.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @ba_rx_bitmap: Bit map of open rx ba per tid\n * @addr: & to bssid mac address\n */\nvoid ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,\n\t\t\t\t  const u8 *addr);\n\n/**\n * ieee80211_mark_rx_ba_filtered_frames - move RX BA window and mark filtered\n * @pubsta: station struct\n * @tid: the session's TID\n * @ssn: starting sequence number of the bitmap, all frames before this are\n *\tassumed to be out of the window after the call\n * @filtered: bitmap of filtered frames, BIT(0) is the @ssn entry etc.\n * @received_mpdus: number of received mpdus in firmware\n *\n * This function moves the BA window and releases all frames before @ssn, and\n * marks frames marked in the bitmap as having been filtered. Afterwards, it\n * checks if any frames in the window starting from @ssn can now be released\n * (in case they were only waiting for frames that were filtered.)\n */\nvoid ieee80211_mark_rx_ba_filtered_frames(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t\t  u16 ssn, u64 filtered,\n\t\t\t\t\t  u16 received_mpdus);\n\n/**\n * ieee80211_send_bar - send a BlockAckReq frame\n *\n * can be used to flush pending frames from the peer's aggregation reorder\n * buffer.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @ra: the peer's destination address\n * @tid: the TID of the aggregation session\n * @ssn: the new starting sequence number for the receiver\n */\nvoid ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn);\n\n/**\n * ieee80211_manage_rx_ba_offl - helper to queue an RX BA work\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nvoid ieee80211_manage_rx_ba_offl(struct ieee80211_vif *vif, const u8 *addr,\n\t\t\t\t unsigned int tid);\n\n/**\n * ieee80211_start_rx_ba_session_offl - start a Rx BA session\n *\n * Some device drivers may offload part of the Rx aggregation flow including\n * AddBa/DelBa negotiation but may otherwise be incapable of full Rx\n * reordering.\n *\n * Create structures responsible for reordering so device drivers may call here\n * when they complete AddBa negotiation.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nstatic inline void ieee80211_start_rx_ba_session_offl(struct ieee80211_vif *vif,\n\t\t\t\t\t\t      const u8 *addr, u16 tid)\n{\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\tieee80211_manage_rx_ba_offl(vif, addr, tid);\n}\n\n/**\n * ieee80211_stop_rx_ba_session_offl - stop a Rx BA session\n *\n * Some device drivers may offload part of the Rx aggregation flow including\n * AddBa/DelBa negotiation but may otherwise be incapable of full Rx\n * reordering.\n *\n * Destroy structures responsible for reordering so device drivers may call here\n * when they complete DelBa negotiation.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nstatic inline void ieee80211_stop_rx_ba_session_offl(struct ieee80211_vif *vif,\n\t\t\t\t\t\t     const u8 *addr, u16 tid)\n{\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\tieee80211_manage_rx_ba_offl(vif, addr, tid + IEEE80211_NUM_TIDS);\n}\n\n/**\n * ieee80211_rx_ba_timer_expired - stop a Rx BA session due to timeout\n *\n * Some device drivers do not offload AddBa/DelBa negotiation, but handle rx\n * buffer reording internally, and therefore also handle the session timer.\n *\n * Trigger the timeout flow, which sends a DelBa.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback\n * @addr: station mac address\n * @tid: the rx tid\n */\nvoid ieee80211_rx_ba_timer_expired(struct ieee80211_vif *vif,\n\t\t\t\t   const u8 *addr, unsigned int tid);\n\n/* Rate control API */\n\n/**\n * struct ieee80211_tx_rate_control - rate control information for/from RC algo\n *\n * @hw: The hardware the algorithm is invoked for.\n * @sband: The band this frame is being transmitted on.\n * @bss_conf: the current BSS configuration\n * @skb: the skb that will be transmitted, the control information in it needs\n *\tto be filled in\n * @reported_rate: The rate control algorithm can fill this in to indicate\n *\twhich rate should be reported to userspace as the current rate and\n *\tused for rate calculations in the mesh network.\n * @rts: whether RTS will be used for this frame because it is longer than the\n *\tRTS threshold\n * @short_preamble: whether mac80211 will request short-preamble transmission\n *\tif the selected rate supports it\n * @rate_idx_mask: user-requested (legacy) rate mask\n * @rate_idx_mcs_mask: user-requested MCS rate mask (NULL if not in use)\n * @bss: whether this frame is sent out in AP or IBSS mode\n */\nstruct ieee80211_tx_rate_control {\n\tstruct ieee80211_hw *hw;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_bss_conf *bss_conf;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_rate reported_rate;\n\tbool rts, short_preamble;\n\tu32 rate_idx_mask;\n\tu8 *rate_idx_mcs_mask;\n\tbool bss;\n};\n\n/**\n * enum rate_control_capabilities - rate control capabilities\n */\nenum rate_control_capabilities {\n\t/**\n\t * @RATE_CTRL_CAPA_VHT_EXT_NSS_BW:\n\t * Support for extended NSS BW support (dot11VHTExtendedNSSCapable)\n\t * Note that this is only looked at if the minimum number of chains\n\t * that the AP uses is < the number of TX chains the hardware has,\n\t * otherwise the NSS difference doesn't bother us.\n\t */\n\tRATE_CTRL_CAPA_VHT_EXT_NSS_BW = BIT(0),\n};\n\nstruct rate_control_ops {\n\tunsigned long capa;\n\tconst char *name;\n\tvoid *(*alloc)(struct ieee80211_hw *hw);\n\tvoid (*add_debugfs)(struct ieee80211_hw *hw, void *priv,\n\t\t\t    struct dentry *debugfsdir);\n\tvoid (*free)(void *priv);\n\n\tvoid *(*alloc_sta)(void *priv, struct ieee80211_sta *sta, gfp_t gfp);\n\tvoid (*rate_init)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t  struct cfg80211_chan_def *chandef,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta);\n\tvoid (*rate_update)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t    struct cfg80211_chan_def *chandef,\n\t\t\t    struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t    u32 changed);\n\tvoid (*free_sta)(void *priv, struct ieee80211_sta *sta,\n\t\t\t void *priv_sta);\n\n\tvoid (*tx_status_ext)(void *priv,\n\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t      void *priv_sta, struct ieee80211_tx_status *st);\n\tvoid (*tx_status)(void *priv, struct ieee80211_supported_band *sband,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t  struct sk_buff *skb);\n\tvoid (*get_rate)(void *priv, struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t struct ieee80211_tx_rate_control *txrc);\n\n\tvoid (*add_sta_debugfs)(void *priv, void *priv_sta,\n\t\t\t\tstruct dentry *dir);\n\n\tu32 (*get_expected_throughput)(void *priv_sta);\n};\n\nstatic inline int rate_supported(struct ieee80211_sta *sta,\n\t\t\t\t enum nl80211_band band,\n\t\t\t\t int index)\n{\n\treturn (sta == NULL || sta->supp_rates[band] & BIT(index));\n}\n\nstatic inline s8\nrate_lowest_index(struct ieee80211_supported_band *sband,\n\t\t  struct ieee80211_sta *sta)\n{\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (rate_supported(sta, sband->band, i))\n\t\t\treturn i;\n\n\t/* warn when we cannot find a rate. */\n\tWARN_ON_ONCE(1);\n\n\t/* and return 0 (the lowest index) */\n\treturn 0;\n}\n\nstatic inline\nbool rate_usable_index_exists(struct ieee80211_supported_band *sband,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (rate_supported(sta, sband->band, i))\n\t\t\treturn true;\n\treturn false;\n}\n\n/**\n * rate_control_set_rates - pass the sta rate selection to mac80211/driver\n *\n * When not doing a rate control probe to test rates, rate control should pass\n * its rate selection to mac80211. If the driver supports receiving a station\n * rate table, it will use it to ensure that frames are always sent based on\n * the most recent rate control module decision.\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @pubsta: &struct ieee80211_sta pointer to the target destination.\n * @rates: new tx rate set to be used for this station.\n */\nint rate_control_set_rates(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_sta *pubsta,\n\t\t\t   struct ieee80211_sta_rates *rates);\n\nint ieee80211_rate_control_register(const struct rate_control_ops *ops);\nvoid ieee80211_rate_control_unregister(const struct rate_control_ops *ops);\n\nstatic inline bool\nconf_is_ht20(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_20;\n}\n\nstatic inline bool\nconf_is_ht40_minus(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40 &&\n\t       conf->chandef.center_freq1 < conf->chandef.chan->center_freq;\n}\n\nstatic inline bool\nconf_is_ht40_plus(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40 &&\n\t       conf->chandef.center_freq1 > conf->chandef.chan->center_freq;\n}\n\nstatic inline bool\nconf_is_ht40(struct ieee80211_conf *conf)\n{\n\treturn conf->chandef.width == NL80211_CHAN_WIDTH_40;\n}\n\nstatic inline bool\nconf_is_ht(struct ieee80211_conf *conf)\n{\n\treturn (conf->chandef.width != NL80211_CHAN_WIDTH_5) &&\n\t\t(conf->chandef.width != NL80211_CHAN_WIDTH_10) &&\n\t\t(conf->chandef.width != NL80211_CHAN_WIDTH_20_NOHT);\n}\n\nstatic inline enum nl80211_iftype\nieee80211_iftype_p2p(enum nl80211_iftype type, bool p2p)\n{\n\tif (p2p) {\n\t\tswitch (type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\treturn NL80211_IFTYPE_P2P_CLIENT;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\treturn NL80211_IFTYPE_P2P_GO;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn type;\n}\n\nstatic inline enum nl80211_iftype\nieee80211_vif_type_p2p(struct ieee80211_vif *vif)\n{\n\treturn ieee80211_iftype_p2p(vif->type, vif->p2p);\n}\n\n/**\n * ieee80211_update_mu_groups - set the VHT MU-MIMO groud data\n *\n * @vif: the specified virtual interface\n * @membership: 64 bits array - a bit is set if station is member of the group\n * @position: 2 bits per group id indicating the position in the group\n *\n * Note: This function assumes that the given vif is valid and the position and\n * membership data is of the correct size and are in the same byte order as the\n * matching GroupId management frame.\n * Calls to this function need to be serialized with RX path.\n */\nvoid ieee80211_update_mu_groups(struct ieee80211_vif *vif,\n\t\t\t\tconst u8 *membership, const u8 *position);\n\nvoid ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,\n\t\t\t\t   int rssi_min_thold,\n\t\t\t\t   int rssi_max_thold);\n\nvoid ieee80211_disable_rssi_reports(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_ave_rssi - report the average RSSI for the specified interface\n *\n * @vif: the specified virtual interface\n *\n * Note: This function assumes that the given vif is valid.\n *\n * Return: The average RSSI value for the requested interface, or 0 if not\n * applicable.\n */\nint ieee80211_ave_rssi(struct ieee80211_vif *vif);\n\n/**\n * ieee80211_report_wowlan_wakeup - report WoWLAN wakeup\n * @vif: virtual interface\n * @wakeup: wakeup reason(s)\n * @gfp: allocation flags\n *\n * See cfg80211_report_wowlan_wakeup().\n */\nvoid ieee80211_report_wowlan_wakeup(struct ieee80211_vif *vif,\n\t\t\t\t    struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t    gfp_t gfp);\n\n/**\n * ieee80211_tx_prepare_skb - prepare an 802.11 skb for transmission\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @vif: virtual interface\n * @skb: frame to be sent from within the driver\n * @band: the band to transmit on\n * @sta: optional pointer to get the station to send the frame to\n *\n * Note: must be called under RCU lock\n */\nbool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, struct sk_buff *skb,\n\t\t\t      int band, struct ieee80211_sta **sta);\n\n/**\n * ieee80211_parse_tx_radiotap - Sanity-check and parse the radiotap header\n *\t\t\t\t of injected frames.\n *\n * To accurately parse and take into account rate and retransmission fields,\n * you must initialize the chandef field in the ieee80211_tx_info structure\n * of the skb before calling this function.\n *\n * @skb: packet injected by userspace\n * @dev: the &struct device of this 802.11 device\n */\nbool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev);\n\n/**\n * struct ieee80211_noa_data - holds temporary data for tracking P2P NoA state\n *\n * @next_tsf: TSF timestamp of the next absent state change\n * @has_next_tsf: next absent state change event pending\n *\n * @absent: descriptor bitmask, set if GO is currently absent\n *\n * private:\n *\n * @count: count fields from the NoA descriptors\n * @desc: adjusted data from the NoA\n */\nstruct ieee80211_noa_data {\n\tu32 next_tsf;\n\tbool has_next_tsf;\n\n\tu8 absent;\n\n\tu8 count[IEEE80211_P2P_NOA_DESC_MAX];\n\tstruct {\n\t\tu32 start;\n\t\tu32 duration;\n\t\tu32 interval;\n\t} desc[IEEE80211_P2P_NOA_DESC_MAX];\n};\n\n/**\n * ieee80211_parse_p2p_noa - initialize NoA tracking data from P2P IE\n *\n * @attr: P2P NoA IE\n * @data: NoA tracking data\n * @tsf: current TSF timestamp\n *\n * Return: number of successfully parsed descriptors\n */\nint ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,\n\t\t\t    struct ieee80211_noa_data *data, u32 tsf);\n\n/**\n * ieee80211_update_p2p_noa - get next pending P2P GO absent state change\n *\n * @data: NoA tracking data\n * @tsf: current TSF timestamp\n */\nvoid ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf);\n\n/**\n * ieee80211_tdls_oper_request - request userspace to perform a TDLS operation\n * @vif: virtual interface\n * @peer: the peer's destination address\n * @oper: the requested TDLS operation\n * @reason_code: reason code for the operation, valid for TDLS teardown\n * @gfp: allocation flags\n *\n * See cfg80211_tdls_oper_request().\n */\nvoid ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,\n\t\t\t\t enum nl80211_tdls_operation oper,\n\t\t\t\t u16 reason_code, gfp_t gfp);\n\n/**\n * ieee80211_reserve_tid - request to reserve a specific TID\n *\n * There is sometimes a need (such as in TDLS) for blocking the driver from\n * using a specific TID so that the FW can use it for certain operations such\n * as sending PTI requests. To make sure that the driver doesn't use that TID,\n * this function must be called as it flushes out packets on this TID and marks\n * it as blocked, so that any transmit for the station on this TID will be\n * redirected to the alternative TID in the same AC.\n *\n * Note that this function blocks and may call back into the driver, so it\n * should be called without driver locks held. Also note this function should\n * only be called from the driver's @sta_state callback.\n *\n * @sta: the station to reserve the TID for\n * @tid: the TID to reserve\n *\n * Returns: 0 on success, else on failure\n */\nint ieee80211_reserve_tid(struct ieee80211_sta *sta, u8 tid);\n\n/**\n * ieee80211_unreserve_tid - request to unreserve a specific TID\n *\n * Once there is no longer any need for reserving a certain TID, this function\n * should be called, and no longer will packets have their TID modified for\n * preventing use of this TID in the driver.\n *\n * Note that this function blocks and acquires a lock, so it should be called\n * without driver locks held. Also note this function should only be called\n * from the driver's @sta_state callback.\n *\n * @sta: the station\n * @tid: the TID to unreserve\n */\nvoid ieee80211_unreserve_tid(struct ieee80211_sta *sta, u8 tid);\n\n/**\n * ieee80211_tx_dequeue - dequeue a packet from a software tx queue\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface, or from\n *\tieee80211_next_txq()\n *\n * Returns the skb if successful, %NULL if no frame was available.\n *\n * Note that this must be called in an rcu_read_lock() critical section,\n * which can only be released after the SKB was handled. Some pointers in\n * skb->cb, e.g. the key pointer, are protected by RCU and thus the\n * critical section must persist not just for the duration of this call\n * but for the duration of the frame handling.\n * However, also note that while in the wake_tx_queue() method,\n * rcu_read_lock() is already held.\n *\n * softirqs must also be disabled when this function is called.\n * In process context, use ieee80211_tx_dequeue_ni() instead.\n */\nstruct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_txq *txq);\n\n/**\n * ieee80211_tx_dequeue_ni - dequeue a packet from a software tx queue\n * (in process context)\n *\n * Like ieee80211_tx_dequeue() but can be called in process context\n * (internally disables bottom halves).\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface, or from\n *\tieee80211_next_txq()\n */\nstatic inline struct sk_buff *ieee80211_tx_dequeue_ni(struct ieee80211_hw *hw,\n\t\t\t\t\t\t      struct ieee80211_txq *txq)\n{\n\tstruct sk_buff *skb;\n\n\tlocal_bh_disable();\n\tskb = ieee80211_tx_dequeue(hw, txq);\n\tlocal_bh_enable();\n\n\treturn skb;\n}\n\n/**\n * ieee80211_next_txq - get next tx queue to pull packets from\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @ac: AC number to return packets from.\n *\n * Returns the next txq if successful, %NULL if no queue is eligible. If a txq\n * is returned, it should be returned with ieee80211_return_txq() after the\n * driver has finished scheduling it.\n */\nstruct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac);\n\n/**\n * ieee80211_txq_schedule_start - start new scheduling round for TXQs\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @ac: AC number to acquire locks for\n *\n * Should be called before ieee80211_next_txq() or ieee80211_return_txq().\n * The driver must not call multiple TXQ scheduling rounds concurrently.\n */\nvoid ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac);\n\n/* (deprecated) */\nstatic inline void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)\n{\n}\n\nvoid __ieee80211_schedule_txq(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq, bool force);\n\n/**\n * ieee80211_schedule_txq - schedule a TXQ for transmission\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n *\n * Schedules a TXQ for transmission if it is not already scheduled,\n * even if mac80211 does not have any packets buffered.\n *\n * The driver may call this function if it has buffered packets for\n * this TXQ internally.\n */\nstatic inline void\nieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)\n{\n\t__ieee80211_schedule_txq(hw, txq, true);\n}\n\n/**\n * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n * @force: schedule txq even if mac80211 does not have any buffered packets.\n *\n * The driver may set force=true if it has buffered packets for this TXQ\n * internally.\n */\nstatic inline void\nieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,\n\t\t     bool force)\n{\n\t__ieee80211_schedule_txq(hw, txq, force);\n}\n\n/**\n * ieee80211_txq_may_transmit - check whether TXQ is allowed to transmit\n *\n * This function is used to check whether given txq is allowed to transmit by\n * the airtime scheduler, and can be used by drivers to access the airtime\n * fairness accounting without going using the scheduling order enfored by\n * next_txq().\n *\n * Returns %true if the airtime scheduler thinks the TXQ should be allowed to\n * transmit, and %false if it should be throttled. This function can also have\n * the side effect of rotating the TXQ in the scheduler rotation, which will\n * eventually bring the deficit to positive and allow the station to transmit\n * again.\n *\n * The API ieee80211_txq_may_transmit() also ensures that TXQ list will be\n * aligned against driver's own round-robin scheduler list. i.e it rotates\n * the TXQ list till it makes the requested node becomes the first entry\n * in TXQ list. Thus both the TXQ list and driver's list are in sync. If this\n * function returns %true, the driver is expected to schedule packets\n * for transmission, and then return the TXQ through ieee80211_return_txq().\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @txq: pointer obtained from station or virtual interface\n */\nbool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_txq *txq);\n\n/**\n * ieee80211_txq_get_depth - get pending frame/byte count of given txq\n *\n * The values are not guaranteed to be coherent with regard to each other, i.e.\n * txq state can change half-way of this function and the caller may end up\n * with \"new\" frame_cnt and \"old\" byte_cnt or vice-versa.\n *\n * @txq: pointer obtained from station or virtual interface\n * @frame_cnt: pointer to store frame count\n * @byte_cnt: pointer to store byte count\n */\nvoid ieee80211_txq_get_depth(struct ieee80211_txq *txq,\n\t\t\t     unsigned long *frame_cnt,\n\t\t\t     unsigned long *byte_cnt);\n\n/**\n * ieee80211_nan_func_terminated - notify about NAN function termination.\n *\n * This function is used to notify mac80211 about NAN function termination.\n * Note that this function can't be called from hard irq.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @inst_id: the local instance id\n * @reason: termination reason (one of the NL80211_NAN_FUNC_TERM_REASON_*)\n * @gfp: allocation flags\n */\nvoid ieee80211_nan_func_terminated(struct ieee80211_vif *vif,\n\t\t\t\t   u8 inst_id,\n\t\t\t\t   enum nl80211_nan_func_term_reason reason,\n\t\t\t\t   gfp_t gfp);\n\n/**\n * ieee80211_nan_func_match - notify about NAN function match event.\n *\n * This function is used to notify mac80211 about NAN function match. The\n * cookie inside the match struct will be assigned by mac80211.\n * Note that this function can't be called from hard irq.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @match: match event information\n * @gfp: allocation flags\n */\nvoid ieee80211_nan_func_match(struct ieee80211_vif *vif,\n\t\t\t      struct cfg80211_nan_match_params *match,\n\t\t\t      gfp_t gfp);\n\n/**\n * ieee80211_calc_rx_airtime - calculate estimated transmission airtime for RX.\n *\n * This function calculates the estimated airtime usage of a frame based on the\n * rate information in the RX status struct and the frame length.\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @status: &struct ieee80211_rx_status containing the transmission rate\n *          information.\n * @len: frame length in bytes\n */\nu32 ieee80211_calc_rx_airtime(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_rx_status *status,\n\t\t\t      int len);\n\n/**\n * ieee80211_calc_tx_airtime - calculate estimated transmission airtime for TX.\n *\n * This function calculates the estimated airtime usage of a frame based on the\n * rate information in the TX info struct and the frame length.\n *\n * @hw: pointer as obtained from ieee80211_alloc_hw()\n * @info: &struct ieee80211_tx_info of the frame.\n * @len: frame length in bytes\n */\nu32 ieee80211_calc_tx_airtime(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_info *info,\n\t\t\t      int len);\n/**\n * ieee80211_set_hw_80211_encap - enable hardware encapsulation offloading.\n *\n * This function is used to notify mac80211 that a vif can be passed raw 802.3\n * frames. The driver needs to then handle the 802.11 encapsulation inside the\n * hardware or firmware.\n *\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n * @enable: indicate if the feature should be turned on or off\n */\nbool ieee80211_set_hw_80211_encap(struct ieee80211_vif *vif, bool enable);\n\n/**\n * ieee80211_get_fils_discovery_tmpl - Get FILS discovery template.\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: FILS discovery template. %NULL on error.\n */\nstruct sk_buff *ieee80211_get_fils_discovery_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct ieee80211_vif *vif);\n\n/**\n * ieee80211_get_unsol_bcast_probe_resp_tmpl - Get unsolicited broadcast\n *\tprobe response template.\n * @hw: pointer obtained from ieee80211_alloc_hw().\n * @vif: &struct ieee80211_vif pointer from the add_interface callback.\n *\n * The driver is responsible for freeing the returned skb.\n *\n * Return: Unsolicited broadcast probe response template. %NULL on error.\n */\nstruct sk_buff *\nieee80211_get_unsol_bcast_probe_resp_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif);\n#endif /* MAC80211_H */\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2005-2006, Devicescape Software, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n * Copyright 2007\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright (C) 2018-2021 Intel Corporation\n *\n * Transmit and frame generation functions.\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/if_vlan.h>\n#include <linux/etherdevice.h>\n#include <linux/bitmap.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <net/net_namespace.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <net/codel.h>\n#include <net/codel_impl.h>\n#include <asm/unaligned.h>\n#include <net/fq_impl.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"led.h\"\n#include \"mesh.h\"\n#include \"wep.h\"\n#include \"wpa.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n/* misc utils */\n\nstatic __le16 ieee80211_duration(struct ieee80211_tx_data *tx,\n\t\t\t\t struct sk_buff *skb, int group_addr,\n\t\t\t\t int next_frag_len)\n{\n\tint rate, mrate, erp, dur, i, shift = 0;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tu32 rate_flags = 0;\n\n\t/* assume HW handles this */\n\tif (tx->rate.flags & (IEEE80211_TX_RC_MCS | IEEE80211_TX_RC_VHT_MCS))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(tx->sdata->vif.chanctx_conf);\n\tif (chanctx_conf) {\n\t\tshift = ieee80211_chandef_get_shift(&chanctx_conf->def);\n\t\trate_flags = ieee80211_chandef_rate_flags(&chanctx_conf->def);\n\t}\n\trcu_read_unlock();\n\n\t/* uh huh? */\n\tif (WARN_ON_ONCE(tx->rate.idx < 0))\n\t\treturn 0;\n\n\tsband = local->hw.wiphy->bands[info->band];\n\ttxrate = &sband->bitrates[tx->rate.idx];\n\n\terp = txrate->flags & IEEE80211_RATE_ERP_G;\n\n\t/* device is expected to do this */\n\tif (sband->band == NL80211_BAND_S1GHZ)\n\t\treturn 0;\n\n\t/*\n\t * data and mgmt (except PS Poll):\n\t * - during CFP: 32768\n\t * - during contention period:\n\t *   if addr1 is group address: 0\n\t *   if more fragments = 0 and addr1 is individual address: time to\n\t *      transmit one ACK plus SIFS\n\t *   if more fragments = 1 and addr1 is individual address: time to\n\t *      transmit next fragment plus 2 x ACK plus 3 x SIFS\n\t *\n\t * IEEE 802.11, 9.6:\n\t * - control response frame (CTS or ACK) shall be transmitted using the\n\t *   same rate as the immediately previous frame in the frame exchange\n\t *   sequence, if this rate belongs to the PHY mandatory rates, or else\n\t *   at the highest possible rate belonging to the PHY rates in the\n\t *   BSSBasicRateSet\n\t */\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tif (ieee80211_is_ctl(hdr->frame_control)) {\n\t\t/* TODO: These control frames are not currently sent by\n\t\t * mac80211, but should they be implemented, this function\n\t\t * needs to be updated to support duration field calculation.\n\t\t *\n\t\t * RTS: time needed to transmit pending data/mgmt frame plus\n\t\t *    one CTS frame plus one ACK frame plus 3 x SIFS\n\t\t * CTS: duration of immediately previous RTS minus time\n\t\t *    required to transmit CTS and its SIFS\n\t\t * ACK: 0 if immediately previous directed data/mgmt had\n\t\t *    more=0, with more=1 duration in ACK frame is duration\n\t\t *    from previous frame minus time needed to transmit ACK\n\t\t *    and its SIFS\n\t\t * PS Poll: BIT(15) | BIT(14) | aid\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/* data/mgmt */\n\tif (0 /* FIX: data/mgmt during CFP */)\n\t\treturn cpu_to_le16(32768);\n\n\tif (group_addr) /* Group address as the destination - no ACK */\n\t\treturn 0;\n\n\t/* Individual destination address:\n\t * IEEE 802.11, Ch. 9.6 (after IEEE 802.11g changes)\n\t * CTS and ACK frames shall be transmitted using the highest rate in\n\t * basic rate set that is less than or equal to the rate of the\n\t * immediately previous frame and that is using the same modulation\n\t * (CCK or OFDM). If no basic rate set matches with these requirements,\n\t * the highest mandatory rate of the PHY that is less than or equal to\n\t * the rate of the previous frame is used.\n\t * Mandatory rates for IEEE 802.11g PHY: 1, 2, 5.5, 11, 6, 12, 24 Mbps\n\t */\n\trate = -1;\n\t/* use lowest available if everything fails */\n\tmrate = sband->bitrates[0].bitrate;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tstruct ieee80211_rate *r = &sband->bitrates[i];\n\n\t\tif (r->bitrate > txrate->bitrate)\n\t\t\tbreak;\n\n\t\tif ((rate_flags & r->flags) != rate_flags)\n\t\t\tcontinue;\n\n\t\tif (tx->sdata->vif.bss_conf.basic_rates & BIT(i))\n\t\t\trate = DIV_ROUND_UP(r->bitrate, 1 << shift);\n\n\t\tswitch (sband->band) {\n\t\tcase NL80211_BAND_2GHZ: {\n\t\t\tu32 flag;\n\t\t\tif (tx->sdata->flags & IEEE80211_SDATA_OPERATING_GMODE)\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_G;\n\t\t\telse\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_B;\n\t\t\tif (r->flags & flag)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\t}\n\t\tcase NL80211_BAND_5GHZ:\n\t\tcase NL80211_BAND_6GHZ:\n\t\t\tif (r->flags & IEEE80211_RATE_MANDATORY_A)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_S1GHZ:\n\t\tcase NL80211_BAND_60GHZ:\n\t\t\t/* TODO, for now fall through */\n\t\tcase NUM_NL80211_BANDS:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rate == -1) {\n\t\t/* No matching basic rate found; use highest suitable mandatory\n\t\t * PHY rate */\n\t\trate = DIV_ROUND_UP(mrate, 1 << shift);\n\t}\n\n\t/* Don't calculate ACKs for QoS Frames with NoAck Policy set */\n\tif (ieee80211_is_data_qos(hdr->frame_control) &&\n\t    *(ieee80211_get_qos_ctl(hdr)) & IEEE80211_QOS_CTL_ACK_POLICY_NOACK)\n\t\tdur = 0;\n\telse\n\t\t/* Time needed to transmit ACK\n\t\t * (10 bytes + 4-byte FCS = 112 bits) plus SIFS; rounded up\n\t\t * to closest integer */\n\t\tdur = ieee80211_frame_duration(sband->band, 10, rate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\n\tif (next_frag_len) {\n\t\t/* Frame is fragmented: duration increases with time needed to\n\t\t * transmit next fragment plus ACK and 2 x SIFS. */\n\t\tdur *= 2; /* ACK + SIFS */\n\t\t/* next fragment */\n\t\tdur += ieee80211_frame_duration(sband->band, next_frag_len,\n\t\t\t\ttxrate->bitrate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\t}\n\n\treturn cpu_to_le16(dur);\n}\n\n/* tx handlers */\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_dynamic_ps(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\n\t/* driver doesn't support power save */\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_PS))\n\t\treturn TX_CONTINUE;\n\n\t/* hardware does dynamic power save */\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS))\n\t\treturn TX_CONTINUE;\n\n\t/* dynamic power save disabled */\n\tif (local->hw.conf.dynamic_ps_timeout <= 0)\n\t\treturn TX_CONTINUE;\n\n\t/* we are scanning, don't enable power save */\n\tif (local->scanning)\n\t\treturn TX_CONTINUE;\n\n\tif (!local->ps_sdata)\n\t\treturn TX_CONTINUE;\n\n\t/* No point if we're going to suspend */\n\tif (local->quiescing)\n\t\treturn TX_CONTINUE;\n\n\t/* dynamic ps is supported only in managed mode */\n\tif (tx->sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_OFFCHAN_TX_OK))\n\t\treturn TX_CONTINUE;\n\n\tifmgd = &tx->sdata->u.mgd;\n\n\t/*\n\t * Don't wakeup from power save if u-apsd is enabled, voip ac has\n\t * u-apsd enabled and the frame is in voip class. This effectively\n\t * means that even if all access categories have u-apsd enabled, in\n\t * practise u-apsd is only used with the voip ac. This is a\n\t * workaround for the case when received voip class packets do not\n\t * have correct qos tag for some reason, due the network or the\n\t * peer application.\n\t *\n\t * Note: ifmgd->uapsd_queues access is racy here. If the value is\n\t * changed via debugfs, user needs to reassociate manually to have\n\t * everything in sync.\n\t */\n\tif ((ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED) &&\n\t    (ifmgd->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO) &&\n\t    skb_get_queue_mapping(tx->skb) == IEEE80211_AC_VO)\n\t\treturn TX_CONTINUE;\n\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tieee80211_stop_queues_by_reason(&local->hw,\n\t\t\t\t\t\tIEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_PS,\n\t\t\t\t\t\tfalse);\n\t\tifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;\n\t\tieee80211_queue_work(&local->hw,\n\t\t\t\t     &local->dynamic_ps_disable_work);\n\t}\n\n\t/* Don't restart the timer if we're not disassociated */\n\tif (!ifmgd->associated)\n\t\treturn TX_CONTINUE;\n\n\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)\n{\n\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tbool assoc = false;\n\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &tx->local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &tx->sdata->state) &&\n\t    !ieee80211_is_probe_req(hdr->frame_control) &&\n\t    !ieee80211_is_any_nullfunc(hdr->frame_control))\n\t\t/*\n\t\t * When software scanning only nullfunc frames (to notify\n\t\t * the sleep state to the AP) and probe requests (for the\n\t\t * active scan) are allowed, all other frames should not be\n\t\t * sent and we should not get here, but if we do\n\t\t * nonetheless, drop them to avoid sending them\n\t\t * off-channel. See the link below and\n\t\t * ieee80211_start_scan() for more.\n\t\t *\n\t\t * http://article.gmane.org/gmane.linux.kernel.wireless.general/30089\n\t\t */\n\t\treturn TX_DROP;\n\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_OCB)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->flags & IEEE80211_TX_PS_BUFFERED)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\tif (likely(tx->flags & IEEE80211_TX_UNICAST)) {\n\t\tif (unlikely(!assoc &&\n\t\t\t     ieee80211_is_data(hdr->frame_control))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tsdata_info(tx->sdata,\n\t\t\t\t   \"dropped data frame to not associated station %pM\\n\",\n\t\t\t\t   hdr->addr1);\n#endif\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else if (unlikely(ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    ieee80211_vif_get_num_mcast_if(tx->sdata) == 0)) {\n\t\t/*\n\t\t * No associated STAs - no need to send multicast\n\t\t * frames.\n\t\t */\n\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n/* This function is called whenever the AP is about to exceed the maximum limit\n * of buffered frames for power saving STAs. This situation should not really\n * happen often during normal operation, so dropping the oldest buffered packet\n * from each queue should be OK to make some room for new frames. */\nstatic void purge_old_ps_buffers(struct ieee80211_local *local)\n{\n\tint total = 0, purged = 0;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tstruct ps_data *ps;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tps = &sdata->u.ap.ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (skb) {\n\t\t\tpurged++;\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t}\n\t\ttotal += skb_queue_len(&ps->bc_buf);\n\t}\n\n\t/*\n\t * Drop one frame from each station from the lowest-priority\n\t * AC that has frames at all.\n\t */\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tint ac;\n\n\t\tfor (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {\n\t\t\tskb = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\ttotal += skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\t\tif (skb) {\n\t\t\t\tpurged++;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlocal->total_ps_buffered = total;\n\tps_dbg_hw(&local->hw, \"PS buffers full - purged %d frames\\n\", purged);\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ps_data *ps;\n\n\t/*\n\t * broadcast/multicast frame\n\t *\n\t * If any of the associated/peer stations is in power save mode,\n\t * the frame is buffered to be sent after DTIM beacon frame.\n\t * This is done either by the hardware or us.\n\t */\n\n\t/* powersaving STAs currently only in AP/VLAN/mesh mode */\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    tx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!tx->sdata->bss)\n\t\t\treturn TX_CONTINUE;\n\n\t\tps = &tx->sdata->bss->ps;\n\t} else if (ieee80211_vif_is_mesh(&tx->sdata->vif)) {\n\t\tps = &tx->sdata->u.mesh.ps;\n\t} else {\n\t\treturn TX_CONTINUE;\n\t}\n\n\n\t/* no buffering for ordered frames */\n\tif (ieee80211_has_order(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_is_probe_req(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hw_check(&tx->local->hw, QUEUE_CONTROL))\n\t\tinfo->hw_queue = tx->sdata->vif.cab_queue;\n\n\t/* no stations in PS mode and no buffered packets */\n\tif (!atomic_read(&ps->num_sta_ps) && skb_queue_empty(&ps->bc_buf))\n\t\treturn TX_CONTINUE;\n\n\tinfo->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;\n\n\t/* device releases frame after DTIM beacon */\n\tif (!ieee80211_hw_check(&tx->local->hw, HOST_BROADCAST_PS_BUFFERING))\n\t\treturn TX_CONTINUE;\n\n\t/* buffered in mac80211 */\n\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\tpurge_old_ps_buffers(tx->local);\n\n\tif (skb_queue_len(&ps->bc_buf) >= AP_MAX_BC_BUFFER) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"BC TX buffer full - dropping the oldest frame\\n\");\n\t\tieee80211_free_txskb(&tx->local->hw, skb_dequeue(&ps->bc_buf));\n\t} else\n\t\ttx->local->total_ps_buffered++;\n\n\tskb_queue_tail(&ps->bc_buf, tx->skb);\n\n\treturn TX_QUEUED;\n}\n\nstatic int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,\n\t\t\t     struct sk_buff *skb)\n{\n\tif (!ieee80211_is_mgmt(fc))\n\t\treturn 0;\n\n\tif (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))\n\t\treturn 0;\n\n\tif (!ieee80211_is_robust_mgmt_frame(skb))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct sta_info *sta = tx->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_local *local = tx->local;\n\n\tif (unlikely(!sta))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DRIVER) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DELIVER)) &&\n\t\t     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {\n\t\tint ac = skb_get_queue_mapping(tx->skb);\n\n\t\tif (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t    !ieee80211_is_bufferable_mmpdu(hdr->frame_control)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;\n\t\t\treturn TX_CONTINUE;\n\t\t}\n\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d: PS buffer for AC %d\\n\",\n\t\t       sta->sta.addr, sta->sta.aid, ac);\n\t\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\t\tpurge_old_ps_buffers(tx->local);\n\n\t\t/* sync with ieee80211_sta_ps_deliver_wakeup */\n\t\tspin_lock(&sta->ps_lock);\n\t\t/*\n\t\t * STA woke up the meantime and all the frames on ps_tx_buf have\n\t\t * been queued to pending queue. No reordering can happen, go\n\t\t * ahead and Tx the packet.\n\t\t */\n\t\tif (!test_sta_flag(sta, WLAN_STA_PS_STA) &&\n\t\t    !test_sta_flag(sta, WLAN_STA_PS_DRIVER) &&\n\t\t    !test_sta_flag(sta, WLAN_STA_PS_DELIVER)) {\n\t\t\tspin_unlock(&sta->ps_lock);\n\t\t\treturn TX_CONTINUE;\n\t\t}\n\n\t\tif (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {\n\t\t\tstruct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\tps_dbg(tx->sdata,\n\t\t\t       \"STA %pM TX buffer for AC %d full - dropping oldest frame\\n\",\n\t\t\t       sta->sta.addr, ac);\n\t\t\tieee80211_free_txskb(&local->hw, old);\n\t\t} else\n\t\t\ttx->local->total_ps_buffered++;\n\n\t\tinfo->control.jiffies = jiffies;\n\t\tinfo->control.vif = &tx->sdata->vif;\n\t\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\tskb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);\n\t\tspin_unlock(&sta->ps_lock);\n\n\t\tif (!timer_pending(&local->sta_cleanup))\n\t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\n\t\t/*\n\t\t * We queued up some frames, so the TIM bit might\n\t\t * need to be set, recalculate it.\n\t\t */\n\t\tsta_info_recalc_tim(sta);\n\n\t\treturn TX_QUEUED;\n\t} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"STA %pM in PS mode, but polling/in SP -> send frame\\n\",\n\t\t       sta->sta.addr);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tif (unlikely(tx->flags & IEEE80211_TX_PS_BUFFERED))\n\t\treturn TX_CONTINUE;\n\n\tif (tx->flags & IEEE80211_TX_UNICAST)\n\t\treturn ieee80211_tx_h_unicast_ps_buf(tx);\n\telse\n\t\treturn ieee80211_tx_h_multicast_ps_buf(tx);\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_control_port_protocol(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\n\tif (unlikely(tx->sdata->control_port_protocol == tx->skb->protocol)) {\n\t\tif (tx->sdata->control_port_no_encrypt)\n\t\t\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_PORT_CTRL_PROTO;\n\t\tinfo->flags |= IEEE80211_TX_CTL_USE_MINRATE;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_select_key(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)) {\n\t\ttx->key = NULL;\n\t\treturn TX_CONTINUE;\n\t}\n\n\tif (tx->sta &&\n\t    (key = rcu_dereference(tx->sta->ptk[tx->sta->ptk_idx])))\n\t\ttx->key = key;\n\telse if (ieee80211_is_group_privacy_action(tx->skb) &&\n\t\t(key = rcu_dereference(tx->sdata->default_multicast_key)))\n\t\ttx->key = key;\n\telse if (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t is_multicast_ether_addr(hdr->addr1) &&\n\t\t ieee80211_is_robust_mgmt_frame(tx->skb) &&\n\t\t (key = rcu_dereference(tx->sdata->default_mgmt_key)))\n\t\ttx->key = key;\n\telse if (is_multicast_ether_addr(hdr->addr1) &&\n\t\t (key = rcu_dereference(tx->sdata->default_multicast_key)))\n\t\ttx->key = key;\n\telse if (!is_multicast_ether_addr(hdr->addr1) &&\n\t\t (key = rcu_dereference(tx->sdata->default_unicast_key)))\n\t\ttx->key = key;\n\telse\n\t\ttx->key = NULL;\n\n\tif (tx->key) {\n\t\tbool skip_hw = false;\n\n\t\t/* TODO: add threshold stuff again */\n\n\t\tswitch (tx->key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control) &&\n\t\t\t    !ieee80211_use_mfp(hdr->frame_control, tx->sta,\n\t\t\t\t\t       tx->skb) &&\n\t\t\t    !ieee80211_is_group_privacy_action(tx->skb))\n\t\t\t\ttx->key = NULL;\n\t\t\telse\n\t\t\t\tskip_hw = (tx->key->conf.flags &\n\t\t\t\t\t   IEEE80211_KEY_FLAG_SW_MGMT_TX) &&\n\t\t\t\t\tieee80211_is_mgmt(hdr->frame_control);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(tx->key && tx->key->flags & KEY_FLAG_TAINTED &&\n\t\t\t     !ieee80211_is_deauth(hdr->frame_control)))\n\t\t\treturn TX_DROP;\n\n\t\tif (!skip_hw && tx->key &&\n\t\t    tx->key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)\n\t\t\tinfo->control.hw_key = &tx->key->conf;\n\t} else if (ieee80211_is_data_present(hdr->frame_control) && tx->sta &&\n\t\t   test_sta_flag(tx->sta, WLAN_STA_USES_ENCRYPTION)) {\n\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_rate_ctrl(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (void *)tx->skb->data;\n\tstruct ieee80211_supported_band *sband;\n\tu32 len;\n\tstruct ieee80211_tx_rate_control txrc;\n\tstruct ieee80211_sta_rates *ratetbl = NULL;\n\tbool assoc = false;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\n\tsband = tx->local->hw.wiphy->bands[info->band];\n\n\tlen = min_t(u32, tx->skb->len + FCS_LEN,\n\t\t\t tx->local->hw.wiphy->frag_threshold);\n\n\t/* set up the tx rate control struct we give the RC algo */\n\ttxrc.hw = &tx->local->hw;\n\ttxrc.sband = sband;\n\ttxrc.bss_conf = &tx->sdata->vif.bss_conf;\n\ttxrc.skb = tx->skb;\n\ttxrc.reported_rate.idx = -1;\n\ttxrc.rate_idx_mask = tx->sdata->rc_rateidx_mask[info->band];\n\n\tif (tx->sdata->rc_has_mcs_mask[info->band])\n\t\ttxrc.rate_idx_mcs_mask =\n\t\t\ttx->sdata->rc_rateidx_mcs_mask[info->band];\n\n\ttxrc.bss = (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_ADHOC ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_OCB);\n\n\t/* set up RTS protection if desired */\n\tif (len > tx->local->hw.wiphy->rts_threshold) {\n\t\ttxrc.rts = true;\n\t}\n\n\tinfo->control.use_rts = txrc.rts;\n\tinfo->control.use_cts_prot = tx->sdata->vif.bss_conf.use_cts_prot;\n\n\t/*\n\t * Use short preamble if the BSS can handle it, but not for\n\t * management frames unless we know the receiver can handle\n\t * that -- the management frame might be to a station that\n\t * just wants a probe response.\n\t */\n\tif (tx->sdata->vif.bss_conf.use_short_preamble &&\n\t    (ieee80211_is_data(hdr->frame_control) ||\n\t     (tx->sta && test_sta_flag(tx->sta, WLAN_STA_SHORT_PREAMBLE))))\n\t\ttxrc.short_preamble = true;\n\n\tinfo->control.short_preamble = txrc.short_preamble;\n\n\t/* don't ask rate control when rate already injected via radiotap */\n\tif (info->control.flags & IEEE80211_TX_CTRL_RATE_INJECT)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\t/*\n\t * Lets not bother rate control if we're associated and cannot\n\t * talk to the sta. This should not happen.\n\t */\n\tif (WARN(test_bit(SCAN_SW_SCANNING, &tx->local->scanning) && assoc &&\n\t\t !rate_usable_index_exists(sband, &tx->sta->sta),\n\t\t \"%s: Dropped data frame as no usable bitrate found while \"\n\t\t \"scanning and associated. Target station: \"\n\t\t \"%pM on %d GHz band\\n\",\n\t\t tx->sdata->name, hdr->addr1,\n\t\t info->band ? 5 : 2))\n\t\treturn TX_DROP;\n\n\t/*\n\t * If we're associated with the sta at this point we know we can at\n\t * least send the frame at the lowest bit rate.\n\t */\n\trate_control_get_rate(tx->sdata, tx->sta, &txrc);\n\n\tif (tx->sta && !info->control.skip_table)\n\t\tratetbl = rcu_dereference(tx->sta->sta.rates);\n\n\tif (unlikely(info->control.rates[0].idx < 0)) {\n\t\tif (ratetbl) {\n\t\t\tstruct ieee80211_tx_rate rate = {\n\t\t\t\t.idx = ratetbl->rate[0].idx,\n\t\t\t\t.flags = ratetbl->rate[0].flags,\n\t\t\t\t.count = ratetbl->rate[0].count\n\t\t\t};\n\n\t\t\tif (ratetbl->rate[0].idx < 0)\n\t\t\t\treturn TX_DROP;\n\n\t\t\ttx->rate = rate;\n\t\t} else {\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else {\n\t\ttx->rate = info->control.rates[0];\n\t}\n\n\tif (txrc.reported_rate.idx < 0) {\n\t\ttxrc.reported_rate = tx->rate;\n\t\tif (tx->sta && ieee80211_is_data(hdr->frame_control))\n\t\t\ttx->sta->tx_stats.last_rate = txrc.reported_rate;\n\t} else if (tx->sta)\n\t\ttx->sta->tx_stats.last_rate = txrc.reported_rate;\n\n\tif (ratetbl)\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(!info->control.rates[0].count))\n\t\tinfo->control.rates[0].count = 1;\n\n\tif (WARN_ON_ONCE((info->control.rates[0].count > 1) &&\n\t\t\t (info->flags & IEEE80211_TX_CTL_NO_ACK)))\n\t\tinfo->control.rates[0].count = 1;\n\n\treturn TX_CONTINUE;\n}\n\nstatic __le16 ieee80211_tx_next_seq(struct sta_info *sta, int tid)\n{\n\tu16 *seq = &sta->tid_seq[tid];\n\t__le16 ret = cpu_to_le16(*seq);\n\n\t/* Increase the sequence number. */\n\t*seq = (*seq + 0x10) & IEEE80211_SCTL_SEQ;\n\n\treturn ret;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_sequence(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tint tid;\n\n\t/*\n\t * Packet injection may want to control the sequence\n\t * number, if we have no matching interface then we\n\t * neither assign one ourselves nor ask the driver to.\n\t */\n\tif (unlikely(info->control.vif->type == NL80211_IFTYPE_MONITOR))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(ieee80211_is_ctl(hdr->frame_control)))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hdrlen(hdr->frame_control) < 24)\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (info->control.flags & IEEE80211_TX_CTRL_NO_SEQNO)\n\t\treturn TX_CONTINUE;\n\n\t/*\n\t * Anything but QoS data that has a sequence number field\n\t * (is long enough) gets a sequence number from the global\n\t * counter.  QoS data frames with a multicast destination\n\t * also use the global counter (802.11-2012 9.3.2.10).\n\t */\n\tif (!ieee80211_is_data_qos(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1)) {\n\t\t/* driver should assign sequence number */\n\t\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\t\t/* for pure STA mode without beacons, we can do it */\n\t\thdr->seq_ctrl = cpu_to_le16(tx->sdata->sequence_number);\n\t\ttx->sdata->sequence_number += 0x10;\n\t\tif (tx->sta)\n\t\t\ttx->sta->tx_stats.msdu[IEEE80211_NUM_TIDS]++;\n\t\treturn TX_CONTINUE;\n\t}\n\n\t/*\n\t * This should be true for injected/management frames only, for\n\t * management frames we have set the IEEE80211_TX_CTL_ASSIGN_SEQ\n\t * above since they are not QoS-data frames.\n\t */\n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\t/* include per-STA, per-TID sequence counter */\n\ttid = ieee80211_get_tid(hdr);\n\ttx->sta->tx_stats.msdu[tid]++;\n\n\thdr->seq_ctrl = ieee80211_tx_next_seq(tx->sta, tid);\n\n\treturn TX_CONTINUE;\n}\n\nstatic int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\n\t/* first fragment was already added to queue by caller */\n\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\n\t\t/* copy control information */\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\n\t\t/* copy header and data */\n\t\tskb_put_data(tmp, skb->data, hdrlen);\n\t\tskb_put_data(tmp, skb->data + pos, fraglen);\n\n\t\tpos += fraglen;\n\t}\n\n\t/* adjust first fragment's length */\n\tskb_trim(skb, hdrlen + per_fragm);\n\treturn 0;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_fragment(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb = tx->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tint frag_threshold = tx->local->hw.wiphy->frag_threshold;\n\tint hdrlen;\n\tint fragnum;\n\n\t/* no matter what happens, tx->skb moves to tx->skbs */\n\t__skb_queue_tail(&tx->skbs, skb);\n\ttx->skb = NULL;\n\n\tif (info->flags & IEEE80211_TX_CTL_DONTFRAG)\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hw_check(&tx->local->hw, SUPPORTS_TX_FRAG))\n\t\treturn TX_CONTINUE;\n\n\t/*\n\t * Warn when submitting a fragmented A-MPDU frame and drop it.\n\t * This scenario is handled in ieee80211_tx_prepare but extra\n\t * caution taken here as fragmented ampdu may cause Tx stop.\n\t */\n\tif (WARN_ON(info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\treturn TX_DROP;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\t/* internal error, why isn't DONTFRAG set? */\n\tif (WARN_ON(skb->len + FCS_LEN <= frag_threshold))\n\t\treturn TX_DROP;\n\n\t/*\n\t * Now fragment the frame. This will allocate all the fragments and\n\t * chain them (using skb as the first fragment) to skb->next.\n\t * During transmission, we will remove the successfully transmitted\n\t * fragments from this list. When the low-level driver rejects one\n\t * of the fragments then we will simply pretend to accept the skb\n\t * but store it away as pending.\n\t */\n\tif (ieee80211_fragment(tx, skb, hdrlen, frag_threshold))\n\t\treturn TX_DROP;\n\n\t/* update duration/seq/flags of fragments */\n\tfragnum = 0;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tconst __le16 morefrags = cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);\n\n\t\thdr = (void *)skb->data;\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\thdr->frame_control |= morefrags;\n\t\t\t/*\n\t\t\t * No multi-rate retries for fragmented frames, that\n\t\t\t * would completely throw off the NAV at other STAs.\n\t\t\t */\n\t\t\tinfo->control.rates[1].idx = -1;\n\t\t\tinfo->control.rates[2].idx = -1;\n\t\t\tinfo->control.rates[3].idx = -1;\n\t\t\tBUILD_BUG_ON(IEEE80211_TX_MAX_RATES != 4);\n\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_RATE_CTRL_PROBE;\n\t\t} else {\n\t\t\thdr->frame_control &= ~morefrags;\n\t\t}\n\t\thdr->seq_ctrl |= cpu_to_le16(fragnum & IEEE80211_SCTL_FRAG);\n\t\tfragnum++;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_stats(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tint ac = -1;\n\n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tac = skb_get_queue_mapping(skb);\n\t\ttx->sta->tx_stats.bytes[ac] += skb->len;\n\t}\n\tif (ac >= 0)\n\t\ttx->sta->tx_stats.packets[ac]++;\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_encrypt(struct ieee80211_tx_data *tx)\n{\n\tif (!tx->key)\n\t\treturn TX_CONTINUE;\n\n\tswitch (tx->key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn ieee80211_crypto_wep_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn ieee80211_crypto_tkip_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn ieee80211_crypto_ccmp_encrypt(\n\t\t\ttx, IEEE80211_CCMP_MIC_LEN);\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\treturn ieee80211_crypto_ccmp_encrypt(\n\t\t\ttx, IEEE80211_CCMP_256_MIC_LEN);\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\treturn ieee80211_crypto_aes_cmac_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\treturn ieee80211_crypto_aes_cmac_256_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\treturn ieee80211_crypto_aes_gmac_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\treturn ieee80211_crypto_gcmp_encrypt(tx);\n\tdefault:\n\t\treturn ieee80211_crypto_hw_encrypt(tx);\n\t}\n\n\treturn TX_DROP;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_calculate_duration(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tint next_len;\n\tbool group_addr;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\thdr = (void *) skb->data;\n\t\tif (unlikely(ieee80211_is_pspoll(hdr->frame_control)))\n\t\t\tbreak; /* must not overwrite AID */\n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\tstruct sk_buff *next = skb_queue_next(&tx->skbs, skb);\n\t\t\tnext_len = next->len;\n\t\t} else\n\t\t\tnext_len = 0;\n\t\tgroup_addr = is_multicast_ether_addr(hdr->addr1);\n\n\t\thdr->duration_id =\n\t\t\tieee80211_duration(tx, skb, group_addr, next_len);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n/* actual transmit path */\n\nstatic bool ieee80211_tx_prep_agg(struct ieee80211_tx_data *tx,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t\t  struct tid_ampdu_tx *tid_tx,\n\t\t\t\t  int tid)\n{\n\tbool queued = false;\n\tbool reset_agg_timer = false;\n\tstruct sk_buff *purge_skb = NULL;\n\n\tif (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\treset_agg_timer = true;\n\t} else if (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {\n\t\t/*\n\t\t * nothing -- this aggregation session is being started\n\t\t * but that might still fail with the driver\n\t\t */\n\t} else if (!tx->sta->sta.txq[tid]) {\n\t\tspin_lock(&tx->sta->lock);\n\t\t/*\n\t\t * Need to re-check now, because we may get here\n\t\t *\n\t\t *  1) in the window during which the setup is actually\n\t\t *     already done, but not marked yet because not all\n\t\t *     packets are spliced over to the driver pending\n\t\t *     queue yet -- if this happened we acquire the lock\n\t\t *     either before or after the splice happens, but\n\t\t *     need to recheck which of these cases happened.\n\t\t *\n\t\t *  2) during session teardown, if the OPERATIONAL bit\n\t\t *     was cleared due to the teardown but the pointer\n\t\t *     hasn't been assigned NULL yet (or we loaded it\n\t\t *     before it was assigned) -- in this case it may\n\t\t *     now be NULL which means we should just let the\n\t\t *     packet pass through because splicing the frames\n\t\t *     back is already done.\n\t\t */\n\t\ttid_tx = rcu_dereference_protected_tid_tx(tx->sta, tid);\n\n\t\tif (!tid_tx) {\n\t\t\t/* do nothing, let packet pass through */\n\t\t} else if (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\t\treset_agg_timer = true;\n\t\t} else {\n\t\t\tqueued = true;\n\t\t\tif (info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER) {\n\t\t\t\tclear_sta_flag(tx->sta, WLAN_STA_SP);\n\t\t\t\tps_dbg(tx->sta->sdata,\n\t\t\t\t       \"STA %pM aid %d: SP frame queued, close the SP w/o telling the peer\\n\",\n\t\t\t\t       tx->sta->sta.addr, tx->sta->sta.aid);\n\t\t\t}\n\t\t\tinfo->control.vif = &tx->sdata->vif;\n\t\t\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\t\t__skb_queue_tail(&tid_tx->pending, skb);\n\t\t\tif (skb_queue_len(&tid_tx->pending) > STA_MAX_TX_BUFFER)\n\t\t\t\tpurge_skb = __skb_dequeue(&tid_tx->pending);\n\t\t}\n\t\tspin_unlock(&tx->sta->lock);\n\n\t\tif (purge_skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, purge_skb);\n\t}\n\n\t/* reset session timer */\n\tif (reset_agg_timer)\n\t\ttid_tx->last_tx = jiffies;\n\n\treturn queued;\n}\n\n/*\n * initialises @tx\n * pass %NULL for the station if unknown, a valid pointer if known\n * or an ERR_PTR() if the station is known not to exist\n */\nstatic ieee80211_tx_result\nieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,\n\t\t     struct ieee80211_tx_data *tx,\n\t\t     struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint tid;\n\n\tmemset(tx, 0, sizeof(*tx));\n\ttx->skb = skb;\n\ttx->local = local;\n\ttx->sdata = sdata;\n\t__skb_queue_head_init(&tx->skbs);\n\n\t/*\n\t * If this flag is set to true anywhere, and we get here,\n\t * we are doing the needed processing, so remove the flag\n\t * now.\n\t */\n\tinfo->control.flags &= ~IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (likely(sta)) {\n\t\tif (!IS_ERR(sta))\n\t\t\ttx->sta = sta;\n\t} else {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\t\ttx->sta = rcu_dereference(sdata->u.vlan.sta);\n\t\t\tif (!tx->sta && sdata->wdev.use_4addr)\n\t\t\t\treturn TX_DROP;\n\t\t} else if (tx->sdata->control_port_protocol == tx->skb->protocol) {\n\t\t\ttx->sta = sta_info_get_bss(sdata, hdr->addr1);\n\t\t}\n\t\tif (!tx->sta && !is_multicast_ether_addr(hdr->addr1))\n\t\t\ttx->sta = sta_info_get(sdata, hdr->addr1);\n\t}\n\n\tif (tx->sta && ieee80211_is_data_qos(hdr->frame_control) &&\n\t    !ieee80211_is_qos_nullfunc(hdr->frame_control) &&\n\t    ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION) &&\n\t    !ieee80211_hw_check(&local->hw, TX_AMPDU_SETUP_IN_HW)) {\n\t\tstruct tid_ampdu_tx *tid_tx;\n\n\t\ttid = ieee80211_get_tid(hdr);\n\n\t\ttid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (tid_tx) {\n\t\t\tbool queued;\n\n\t\t\tqueued = ieee80211_tx_prep_agg(tx, skb, info,\n\t\t\t\t\t\t       tid_tx, tid);\n\n\t\t\tif (unlikely(queued))\n\t\t\t\treturn TX_QUEUED;\n\t\t}\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\ttx->flags &= ~IEEE80211_TX_UNICAST;\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t} else\n\t\ttx->flags |= IEEE80211_TX_UNICAST;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_DONTFRAG)) {\n\t\tif (!(tx->flags & IEEE80211_TX_UNICAST) ||\n\t\t    skb->len + FCS_LEN <= local->hw.wiphy->frag_threshold ||\n\t\t    info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_DONTFRAG;\n\t}\n\n\tif (!tx->sta)\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\telse if (test_and_clear_sta_flag(tx->sta, WLAN_STA_CLEAR_PS_FILT)) {\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\t\tieee80211_check_fast_xmit(tx->sta);\n\t}\n\n\tinfo->flags |= IEEE80211_TX_CTL_FIRST_FRAGMENT;\n\n\treturn TX_CONTINUE;\n}\n\nstatic struct txq_info *ieee80211_get_txq(struct ieee80211_local *local,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct sta_info *sta,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_txq *txq = NULL;\n\n\tif ((info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) ||\n\t    (info->control.flags & IEEE80211_TX_CTRL_PS_RESPONSE))\n\t\treturn NULL;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) &&\n\t    unlikely(!ieee80211_is_data_present(hdr->frame_control))) {\n\t\tif ((!ieee80211_is_mgmt(hdr->frame_control) ||\n\t\t     ieee80211_is_bufferable_mmpdu(hdr->frame_control) ||\n\t\t     vif->type == NL80211_IFTYPE_STATION) &&\n\t\t    sta && sta->uploaded) {\n\t\t\t/*\n\t\t\t * This will be NULL if the driver didn't set the\n\t\t\t * opt-in hardware flag.\n\t\t\t */\n\t\t\ttxq = sta->sta.txq[IEEE80211_NUM_TIDS];\n\t\t}\n\t} else if (sta) {\n\t\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\tif (!sta->uploaded)\n\t\t\treturn NULL;\n\n\t\ttxq = sta->sta.txq[tid];\n\t} else if (vif) {\n\t\ttxq = vif->txq;\n\t}\n\n\tif (!txq)\n\t\treturn NULL;\n\n\treturn to_txq_info(txq);\n}\n\nstatic void ieee80211_set_skb_enqueue_time(struct sk_buff *skb)\n{\n\tIEEE80211_SKB_CB(skb)->control.enqueue_time = codel_get_time();\n}\n\nstatic u32 codel_skb_len_func(const struct sk_buff *skb)\n{\n\treturn skb->len;\n}\n\nstatic codel_time_t codel_skb_time_func(const struct sk_buff *skb)\n{\n\tconst struct ieee80211_tx_info *info;\n\n\tinfo = (const struct ieee80211_tx_info *)skb->cb;\n\treturn info->control.enqueue_time;\n}\n\nstatic struct sk_buff *codel_dequeue_func(struct codel_vars *cvars,\n\t\t\t\t\t  void *ctx)\n{\n\tstruct ieee80211_local *local;\n\tstruct txq_info *txqi;\n\tstruct fq *fq;\n\tstruct fq_flow *flow;\n\n\ttxqi = ctx;\n\tlocal = vif_to_sdata(txqi->txq.vif)->local;\n\tfq = &local->fq;\n\n\tif (cvars == &txqi->def_cvars)\n\t\tflow = &txqi->tin.default_flow;\n\telse\n\t\tflow = &fq->flows[cvars - local->cvars];\n\n\treturn fq_flow_dequeue(fq, flow);\n}\n\nstatic void codel_drop_func(struct sk_buff *skb,\n\t\t\t    void *ctx)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_hw *hw;\n\tstruct txq_info *txqi;\n\n\ttxqi = ctx;\n\tlocal = vif_to_sdata(txqi->txq.vif)->local;\n\thw = &local->hw;\n\n\tieee80211_free_txskb(hw, skb);\n}\n\nstatic struct sk_buff *fq_tin_dequeue_func(struct fq *fq,\n\t\t\t\t\t   struct fq_tin *tin,\n\t\t\t\t\t   struct fq_flow *flow)\n{\n\tstruct ieee80211_local *local;\n\tstruct txq_info *txqi;\n\tstruct codel_vars *cvars;\n\tstruct codel_params *cparams;\n\tstruct codel_stats *cstats;\n\n\tlocal = container_of(fq, struct ieee80211_local, fq);\n\ttxqi = container_of(tin, struct txq_info, tin);\n\tcstats = &txqi->cstats;\n\n\tif (txqi->txq.sta) {\n\t\tstruct sta_info *sta = container_of(txqi->txq.sta,\n\t\t\t\t\t\t    struct sta_info, sta);\n\t\tcparams = &sta->cparams;\n\t} else {\n\t\tcparams = &local->cparams;\n\t}\n\n\tif (flow == &tin->default_flow)\n\t\tcvars = &txqi->def_cvars;\n\telse\n\t\tcvars = &local->cvars[flow - fq->flows];\n\n\treturn codel_dequeue(txqi,\n\t\t\t     &flow->backlog,\n\t\t\t     cparams,\n\t\t\t     cvars,\n\t\t\t     cstats,\n\t\t\t     codel_skb_len_func,\n\t\t\t     codel_skb_time_func,\n\t\t\t     codel_drop_func,\n\t\t\t     codel_dequeue_func);\n}\n\nstatic void fq_skb_free_func(struct fq *fq,\n\t\t\t     struct fq_tin *tin,\n\t\t\t     struct fq_flow *flow,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local;\n\n\tlocal = container_of(fq, struct ieee80211_local, fq);\n\tieee80211_free_txskb(&local->hw, skb);\n}\n\nstatic void ieee80211_txq_enqueue(struct ieee80211_local *local,\n\t\t\t\t  struct txq_info *txqi,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin = &txqi->tin;\n\tu32 flow_idx = fq_flow_idx(fq, skb);\n\n\tieee80211_set_skb_enqueue_time(skb);\n\n\tspin_lock_bh(&fq->lock);\n\t/*\n\t * For management frames, don't really apply codel etc.,\n\t * we don't want to apply any shaping or anything we just\n\t * want to simplify the driver API by having them on the\n\t * txqi.\n\t */\n\tif (unlikely(txqi->txq.tid == IEEE80211_NUM_TIDS)) {\n\t\tIEEE80211_SKB_CB(skb)->control.flags |=\n\t\t\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t\t__skb_queue_tail(&txqi->frags, skb);\n\t} else {\n\t\tfq_tin_enqueue(fq, tin, flow_idx, skb,\n\t\t\t       fq_skb_free_func);\n\t}\n\tspin_unlock_bh(&fq->lock);\n}\n\nstatic bool fq_vlan_filter_func(struct fq *fq, struct fq_tin *tin,\n\t\t\t\tstruct fq_flow *flow, struct sk_buff *skb,\n\t\t\t\tvoid *data)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\treturn info->control.vif == data;\n}\n\nvoid ieee80211_txq_remove_vlan(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata)\n{\n\tstruct fq *fq = &local->fq;\n\tstruct txq_info *txqi;\n\tstruct fq_tin *tin;\n\tstruct ieee80211_sub_if_data *ap;\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_AP_VLAN))\n\t\treturn;\n\n\tap = container_of(sdata->bss, struct ieee80211_sub_if_data, u.ap);\n\n\tif (!ap->vif.txq)\n\t\treturn;\n\n\ttxqi = to_txq_info(ap->vif.txq);\n\ttin = &txqi->tin;\n\n\tspin_lock_bh(&fq->lock);\n\tfq_tin_filter(fq, tin, fq_vlan_filter_func, &sdata->vif,\n\t\t      fq_skb_free_func);\n\tspin_unlock_bh(&fq->lock);\n}\n\nvoid ieee80211_txq_init(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sta_info *sta,\n\t\t\tstruct txq_info *txqi, int tid)\n{\n\tfq_tin_init(&txqi->tin);\n\tcodel_vars_init(&txqi->def_cvars);\n\tcodel_stats_init(&txqi->cstats);\n\t__skb_queue_head_init(&txqi->frags);\n\tINIT_LIST_HEAD(&txqi->schedule_order);\n\n\ttxqi->txq.vif = &sdata->vif;\n\n\tif (!sta) {\n\t\tsdata->vif.txq = &txqi->txq;\n\t\ttxqi->txq.tid = 0;\n\t\ttxqi->txq.ac = IEEE80211_AC_BE;\n\n\t\treturn;\n\t}\n\n\tif (tid == IEEE80211_NUM_TIDS) {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\t\t/* Drivers need to opt in to the management MPDU TXQ */\n\t\t\tif (!ieee80211_hw_check(&sdata->local->hw,\n\t\t\t\t\t\tSTA_MMPDU_TXQ))\n\t\t\t\treturn;\n\t\t} else if (!ieee80211_hw_check(&sdata->local->hw,\n\t\t\t\t\t       BUFF_MMPDU_TXQ)) {\n\t\t\t/* Drivers need to opt in to the bufferable MMPDU TXQ */\n\t\t\treturn;\n\t\t}\n\t\ttxqi->txq.ac = IEEE80211_AC_VO;\n\t} else {\n\t\ttxqi->txq.ac = ieee80211_ac_from_tid(tid);\n\t}\n\n\ttxqi->txq.sta = &sta->sta;\n\ttxqi->txq.tid = tid;\n\tsta->sta.txq[tid] = &txqi->txq;\n}\n\nvoid ieee80211_txq_purge(struct ieee80211_local *local,\n\t\t\t struct txq_info *txqi)\n{\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin = &txqi->tin;\n\n\tspin_lock_bh(&fq->lock);\n\tfq_tin_reset(fq, tin, fq_skb_free_func);\n\tieee80211_purge_tx_queue(&local->hw, &txqi->frags);\n\tspin_unlock_bh(&fq->lock);\n\n\tspin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);\n\tlist_del_init(&txqi->schedule_order);\n\tspin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);\n}\n\nvoid ieee80211_txq_set_params(struct ieee80211_local *local)\n{\n\tif (local->hw.wiphy->txq_limit)\n\t\tlocal->fq.limit = local->hw.wiphy->txq_limit;\n\telse\n\t\tlocal->hw.wiphy->txq_limit = local->fq.limit;\n\n\tif (local->hw.wiphy->txq_memory_limit)\n\t\tlocal->fq.memory_limit = local->hw.wiphy->txq_memory_limit;\n\telse\n\t\tlocal->hw.wiphy->txq_memory_limit = local->fq.memory_limit;\n\n\tif (local->hw.wiphy->txq_quantum)\n\t\tlocal->fq.quantum = local->hw.wiphy->txq_quantum;\n\telse\n\t\tlocal->hw.wiphy->txq_quantum = local->fq.quantum;\n}\n\nint ieee80211_txq_setup_flows(struct ieee80211_local *local)\n{\n\tstruct fq *fq = &local->fq;\n\tint ret;\n\tint i;\n\tbool supp_vht = false;\n\tenum nl80211_band band;\n\n\tif (!local->ops->wake_tx_queue)\n\t\treturn 0;\n\n\tret = fq_init(fq, 4096);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If the hardware doesn't support VHT, it is safe to limit the maximum\n\t * queue size. 4 Mbytes is 64 max-size aggregates in 802.11n.\n\t */\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = local->hw.wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tsupp_vht = supp_vht || sband->vht_cap.vht_supported;\n\t}\n\n\tif (!supp_vht)\n\t\tfq->memory_limit = 4 << 20; /* 4 Mbytes */\n\n\tcodel_params_init(&local->cparams);\n\tlocal->cparams.interval = MS2TIME(100);\n\tlocal->cparams.target = MS2TIME(20);\n\tlocal->cparams.ecn = true;\n\n\tlocal->cvars = kcalloc(fq->flows_cnt, sizeof(local->cvars[0]),\n\t\t\t       GFP_KERNEL);\n\tif (!local->cvars) {\n\t\tspin_lock_bh(&fq->lock);\n\t\tfq_reset(fq, fq_skb_free_func);\n\t\tspin_unlock_bh(&fq->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < fq->flows_cnt; i++)\n\t\tcodel_vars_init(&local->cvars[i]);\n\n\tieee80211_txq_set_params(local);\n\n\treturn 0;\n}\n\nvoid ieee80211_txq_teardown_flows(struct ieee80211_local *local)\n{\n\tstruct fq *fq = &local->fq;\n\n\tif (!local->ops->wake_tx_queue)\n\t\treturn;\n\n\tkfree(local->cvars);\n\tlocal->cvars = NULL;\n\n\tspin_lock_bh(&fq->lock);\n\tfq_reset(fq, fq_skb_free_func);\n\tspin_unlock_bh(&fq->lock);\n}\n\nstatic bool ieee80211_queue_skb(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sta_info *sta,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_vif *vif;\n\tstruct txq_info *txqi;\n\n\tif (!local->ops->wake_tx_queue ||\n\t    sdata->vif.type == NL80211_IFTYPE_MONITOR)\n\t\treturn false;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\n\tvif = &sdata->vif;\n\ttxqi = ieee80211_get_txq(local, vif, sta, skb);\n\n\tif (!txqi)\n\t\treturn false;\n\n\tieee80211_txq_enqueue(local, txqi, skb);\n\n\tschedule_and_wake_txq(local, txqi);\n\n\treturn true;\n}\n\nstatic bool ieee80211_tx_frags(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct sta_info *sta,\n\t\t\t       struct sk_buff_head *skbs,\n\t\t\t       bool txpending)\n{\n\tstruct ieee80211_tx_control control = {};\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\n\tskb_queue_walk_safe(skbs, skb, tmp) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tint q = info->hw_queue;\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tif (WARN_ON_ONCE(q >= local->hw.queues)) {\n\t\t\t__skb_unlink(skb, skbs);\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t\tif (local->queue_stop_reasons[q] ||\n\t\t    (!txpending && !skb_queue_empty(&local->pending[q]))) {\n\t\t\tif (unlikely(info->flags &\n\t\t\t\t     IEEE80211_TX_INTFL_OFFCHAN_TX_OK)) {\n\t\t\t\tif (local->queue_stop_reasons[q] &\n\t\t\t\t    ~BIT(IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Drop off-channel frames if queues\n\t\t\t\t\t * are stopped for any reason other\n\t\t\t\t\t * than off-channel operation. Never\n\t\t\t\t\t * queue them.\n\t\t\t\t\t */\n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tieee80211_purge_tx_queue(&local->hw,\n\t\t\t\t\t\t\t\t skbs);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t/*\n\t\t\t\t * Since queue is stopped, queue up frames for\n\t\t\t\t * later transmission from the tx-pending\n\t\t\t\t * tasklet when the queue is woken again.\n\t\t\t\t */\n\t\t\t\tif (txpending)\n\t\t\t\t\tskb_queue_splice_init(skbs,\n\t\t\t\t\t\t\t      &local->pending[q]);\n\t\t\t\telse\n\t\t\t\t\tskb_queue_splice_tail_init(skbs,\n\t\t\t\t\t\t\t\t   &local->pending[q]);\n\n\t\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\t\tinfo->control.vif = vif;\n\t\tcontrol.sta = sta ? &sta->sta : NULL;\n\n\t\t__skb_unlink(skb, skbs);\n\t\tdrv_tx(local, &control, skb);\n\t}\n\n\treturn true;\n}\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead.\n */\nstatic bool __ieee80211_tx(struct ieee80211_local *local,\n\t\t\t   struct sk_buff_head *skbs, int led_len,\n\t\t\t   struct sta_info *sta, bool txpending)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_vif *vif;\n\tstruct sk_buff *skb;\n\tbool result;\n\t__le16 fc;\n\n\tif (WARN_ON(skb_queue_empty(skbs)))\n\t\treturn true;\n\n\tskb = skb_peek(skbs);\n\tfc = ((struct ieee80211_hdr *)skb->data)->frame_control;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tsdata = vif_to_sdata(info->control.vif);\n\tif (sta && !sta->uploaded)\n\t\tsta = NULL;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tvif = &sdata->vif;\n\t\t\tbreak;\n\t\t}\n\t\tsdata = rcu_dereference(local->monitor_sdata);\n\t\tif (sdata) {\n\t\t\tvif = &sdata->vif;\n\t\t\tinfo->hw_queue =\n\t\t\t\tvif->hw_queue[skb_get_queue_mapping(skb)];\n\t\t} else if (ieee80211_hw_check(&local->hw, QUEUE_CONTROL)) {\n\t\t\tieee80211_purge_tx_queue(&local->hw, skbs);\n\t\t\treturn true;\n\t\t} else\n\t\t\tvif = NULL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\t\tfallthrough;\n\tdefault:\n\t\tvif = &sdata->vif;\n\t\tbreak;\n\t}\n\n\tresult = ieee80211_tx_frags(local, vif, sta, skbs, txpending);\n\n\tieee80211_tpt_led_trig_tx(local, fc, led_len);\n\n\tWARN_ON_ONCE(!skb_queue_empty(skbs));\n\n\treturn result;\n}\n\n/*\n * Invoke TX handlers, return 0 on success and non-zero if the\n * frame was dropped or queued.\n *\n * The handlers are split into an early and late part. The latter is everything\n * that can be sensitive to reordering, and will be deferred to after packets\n * are dequeued from the intermediate queues (when they are enabled).\n */\nstatic int invoke_tx_handlers_early(struct ieee80211_tx_data *tx)\n{\n\tieee80211_tx_result res = TX_DROP;\n\n#define CALL_TXH(txh) \\\n\tdo {\t\t\t\t\\\n\t\tres = txh(tx);\t\t\\\n\t\tif (res != TX_CONTINUE)\t\\\n\t\t\tgoto txh_done;\t\\\n\t} while (0)\n\n\tCALL_TXH(ieee80211_tx_h_dynamic_ps);\n\tCALL_TXH(ieee80211_tx_h_check_assoc);\n\tCALL_TXH(ieee80211_tx_h_ps_buf);\n\tCALL_TXH(ieee80211_tx_h_check_control_port_protocol);\n\tCALL_TXH(ieee80211_tx_h_select_key);\n\tif (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_rate_ctrl);\n\n txh_done:\n\tif (unlikely(res == TX_DROP)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop);\n\t\tif (tx->skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, tx->skb);\n\t\telse\n\t\t\tieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);\n\t\treturn -1;\n\t} else if (unlikely(res == TX_QUEUED)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_queued);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Late handlers can be called while the sta lock is held. Handlers that can\n * cause packets to be generated will cause deadlock!\n */\nstatic int invoke_tx_handlers_late(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tieee80211_tx_result res = TX_CONTINUE;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_RETRANSMISSION)) {\n\t\t__skb_queue_tail(&tx->skbs, tx->skb);\n\t\ttx->skb = NULL;\n\t\tgoto txh_done;\n\t}\n\n\tCALL_TXH(ieee80211_tx_h_michael_mic_add);\n\tCALL_TXH(ieee80211_tx_h_sequence);\n\tCALL_TXH(ieee80211_tx_h_fragment);\n\t/* handlers after fragment must be aware of tx info fragmentation! */\n\tCALL_TXH(ieee80211_tx_h_stats);\n\tCALL_TXH(ieee80211_tx_h_encrypt);\n\tif (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_calculate_duration);\n#undef CALL_TXH\n\n txh_done:\n\tif (unlikely(res == TX_DROP)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop);\n\t\tif (tx->skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, tx->skb);\n\t\telse\n\t\t\tieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);\n\t\treturn -1;\n\t} else if (unlikely(res == TX_QUEUED)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_queued);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int invoke_tx_handlers(struct ieee80211_tx_data *tx)\n{\n\tint r = invoke_tx_handlers_early(tx);\n\n\tif (r)\n\t\treturn r;\n\treturn invoke_tx_handlers_late(tx);\n}\n\nbool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, struct sk_buff *skb,\n\t\t\t      int band, struct ieee80211_sta **sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_data tx;\n\tstruct sk_buff *skb2;\n\n\tif (ieee80211_tx_prepare(sdata, &tx, NULL, skb) == TX_DROP)\n\t\treturn false;\n\n\tinfo->band = band;\n\tinfo->control.vif = vif;\n\tinfo->hw_queue = vif->hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (invoke_tx_handlers(&tx))\n\t\treturn false;\n\n\tif (sta) {\n\t\tif (tx.sta)\n\t\t\t*sta = &tx.sta->sta;\n\t\telse\n\t\t\t*sta = NULL;\n\t}\n\n\t/* this function isn't suitable for fragmented data frames */\n\tskb2 = __skb_dequeue(&tx.skbs);\n\tif (WARN_ON(skb2 != skb || !skb_queue_empty(&tx.skbs))) {\n\t\tieee80211_free_txskb(hw, skb2);\n\t\tieee80211_purge_tx_queue(hw, &tx.skbs);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_tx_prepare_skb);\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead.\n */\nstatic bool ieee80211_tx(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sta_info *sta, struct sk_buff *skb,\n\t\t\t bool txpending)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result res_prepare;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool result = true;\n\tint led_len;\n\n\tif (unlikely(skb->len < 10)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn true;\n\t}\n\n\t/* initialises tx */\n\tled_len = skb->len;\n\tres_prepare = ieee80211_tx_prepare(sdata, &tx, sta, skb);\n\n\tif (unlikely(res_prepare == TX_DROP)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn true;\n\t} else if (unlikely(res_prepare == TX_QUEUED)) {\n\t\treturn true;\n\t}\n\n\t/* set up hw_queue value early */\n\tif (!(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||\n\t    !ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\n\t\tinfo->hw_queue =\n\t\t\tsdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (invoke_tx_handlers_early(&tx))\n\t\treturn true;\n\n\tif (ieee80211_queue_skb(local, sdata, tx.sta, tx.skb))\n\t\treturn true;\n\n\tif (!invoke_tx_handlers_late(&tx))\n\t\tresult = __ieee80211_tx(local, &tx.skbs, led_len,\n\t\t\t\t\ttx.sta, txpending);\n\n\treturn result;\n}\n\n/* device xmit handlers */\n\nenum ieee80211_encrypt {\n\tENCRYPT_NO,\n\tENCRYPT_MGMT,\n\tENCRYPT_DATA,\n};\n\nstatic int ieee80211_skb_resize(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tint head_need,\n\t\t\t\tenum ieee80211_encrypt encrypt)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tbool enc_tailroom;\n\tint tail_need = 0;\n\n\tenc_tailroom = encrypt == ENCRYPT_MGMT ||\n\t\t       (encrypt == ENCRYPT_DATA &&\n\t\t\tsdata->crypto_tx_tailroom_needed_cnt);\n\n\tif (enc_tailroom) {\n\t\ttail_need = IEEE80211_ENCRYPT_TAILROOM;\n\t\ttail_need -= skb_tailroom(skb);\n\t\ttail_need = max_t(int, tail_need, 0);\n\t}\n\n\tif (skb_cloned(skb) &&\n\t    (!ieee80211_hw_check(&local->hw, SUPPORTS_CLONED_SKBS) ||\n\t     !skb_clone_writable(skb, ETH_HLEN) || enc_tailroom))\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head_cloned);\n\telse if (head_need || tail_need)\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head);\n\telse\n\t\treturn 0;\n\n\tif (pskb_expand_head(skb, head_need, tail_need, GFP_ATOMIC)) {\n\t\twiphy_debug(local->hw.wiphy,\n\t\t\t    \"failed to reallocate TX buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_xmit(struct ieee80211_sub_if_data *sdata,\n\t\t    struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tint headroom;\n\tenum ieee80211_encrypt encrypt;\n\n\tif (info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)\n\t\tencrypt = ENCRYPT_NO;\n\telse if (ieee80211_is_mgmt(hdr->frame_control))\n\t\tencrypt = ENCRYPT_MGMT;\n\telse\n\t\tencrypt = ENCRYPT_DATA;\n\n\theadroom = local->tx_headroom;\n\tif (encrypt != ENCRYPT_NO)\n\t\theadroom += sdata->encrypt_headroom;\n\theadroom -= skb_headroom(skb);\n\theadroom = max_t(int, 0, headroom);\n\n\tif (ieee80211_skb_resize(sdata, skb, headroom, encrypt)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn;\n\t}\n\n\t/* reload after potential resize */\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tinfo->control.vif = &sdata->vif;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t    is_unicast_ether_addr(hdr->addr1)) {\n\t\t\tif (mesh_nexthop_resolve(sdata, skb))\n\t\t\t\treturn; /* skb queued: don't free */\n\t\t} else {\n\t\t\tieee80211_mps_set_frame_flags(sdata, NULL, hdr);\n\t\t}\n\t}\n\n\tieee80211_set_qos_hdr(sdata, skb);\n\tieee80211_tx(sdata, sta, skb, false);\n}\n\nstatic bool ieee80211_validate_radiotap_len(struct sk_buff *skb)\n{\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *)skb->data;\n\n\t/* check for not even having the fixed radiotap header part */\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false; /* too short to be possibly valid */\n\n\t/* is it a header version we can trust to find length from? */\n\tif (unlikely(rthdr->it_version))\n\t\treturn false; /* only version 0 is supported */\n\n\t/* does the skb contain enough to deliver on the alleged length? */\n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false; /* skb too short for claimed rt header extent */\n\n\treturn true;\n}\n\nbool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_radiotap_iterator iterator;\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,\n\t\t\t\t\t\t   NULL);\n\tu16 txflags;\n\tu16 rate = 0;\n\tbool rate_found = false;\n\tu8 rate_retries = 0;\n\tu16 rate_flags = 0;\n\tu8 mcs_known, mcs_flags, mcs_bw;\n\tu16 vht_known;\n\tu8 vht_mcs = 0, vht_nss = 0;\n\tint i;\n\n\tif (!ieee80211_validate_radiotap_len(skb))\n\t\treturn false;\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t       IEEE80211_TX_CTL_DONTFRAG;\n\n\t/*\n\t * for every radiotap entry that is present\n\t * (ieee80211_radiotap_iterator_next returns -ENOENT when no more\n\t * entries present, or -EINVAL on error)\n\t */\n\n\twhile (!ret) {\n\t\tret = ieee80211_radiotap_iterator_next(&iterator);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t/* see if this argument is something we can use */\n\t\tswitch (iterator.this_arg_index) {\n\t\t/*\n\t\t * You must take care when dereferencing iterator.this_arg\n\t\t * for multibyte types... the pointer is not aligned.  Use\n\t\t * get_unaligned((type *)iterator.this_arg) to dereference\n\t\t * iterator.this_arg for type \"type\" safely on all arches.\n\t\t*/\n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {\n\t\t\t\t/*\n\t\t\t\t * this indicates that the skb we have been\n\t\t\t\t * handed has the 32-bit FCS CRC at the end...\n\t\t\t\t * we should react to that by snipping it off\n\t\t\t\t * because it will be recomputed and added\n\t\t\t\t * on transmission\n\t\t\t\t */\n\t\t\t\tif (skb->len < (iterator._max_length + FCS_LEN))\n\t\t\t\t\treturn false;\n\n\t\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\t\t}\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_DONTFRAG;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_TX_FLAGS:\n\t\t\ttxflags = get_unaligned_le16(iterator.this_arg);\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)\n\t\t\t\tinfo->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)\n\t\t\t\tinfo->control.flags |=\n\t\t\t\t\tIEEE80211_TX_CTRL_DONT_REORDER;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_RATE:\n\t\t\trate = *iterator.this_arg;\n\t\t\trate_flags = 0;\n\t\t\trate_found = true;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DATA_RETRIES:\n\t\t\trate_retries = *iterator.this_arg;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_MCS:\n\t\t\tmcs_known = iterator.this_arg[0];\n\t\t\tmcs_flags = iterator.this_arg[1];\n\t\t\tif (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))\n\t\t\t\tbreak;\n\n\t\t\trate_found = true;\n\t\t\trate = iterator.this_arg[2];\n\t\t\trate_flags = IEEE80211_TX_RC_MCS;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\n\t\t\tmcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&\n\t\t\t    mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_LDPC;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {\n\t\t\t\tu8 stbc = u8_get_bits(mcs_flags,\n\t\t\t\t\t\t      IEEE80211_RADIOTAP_MCS_STBC_MASK);\n\n\t\t\t\tinfo->flags |=\n\t\t\t\t\tu32_encode_bits(stbc,\n\t\t\t\t\t\t\tIEEE80211_TX_CTL_STBC);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_VHT:\n\t\t\tvht_known = get_unaligned_le16(iterator.this_arg);\n\t\t\trate_found = true;\n\n\t\t\trate_flags = IEEE80211_TX_RC_VHT_MCS;\n\t\t\tif ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&\n\t\t\t    (iterator.this_arg[2] &\n\t\t\t     IEEE80211_RADIOTAP_VHT_FLAG_SGI))\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\t\t\tif (vht_known &\n\t\t\t    IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {\n\t\t\t\tif (iterator.this_arg[3] == 1)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 4)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 11)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_160_MHZ_WIDTH;\n\t\t\t}\n\n\t\t\tvht_mcs = iterator.this_arg[4] >> 4;\n\t\t\tvht_nss = iterator.this_arg[4] & 0xF;\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Please update the file\n\t\t * Documentation/networking/mac80211-injection.rst\n\t\t * when parsing new fields here.\n\t\t */\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -ENOENT) /* ie, if we didn't simply run out of fields */\n\t\treturn false;\n\n\tif (rate_found) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\tlocal->hw.wiphy->bands[info->band];\n\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\t\tinfo->control.rates[i].idx = -1;\n\t\t\tinfo->control.rates[i].flags = 0;\n\t\t\tinfo->control.rates[i].count = 0;\n\t\t}\n\n\t\tif (rate_flags & IEEE80211_TX_RC_MCS) {\n\t\t\tinfo->control.rates[0].idx = rate;\n\t\t} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t\tieee80211_rate_set_vht(info->control.rates, vht_mcs,\n\t\t\t\t\t       vht_nss);\n\t\t} else if (sband) {\n\t\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\t\tif (rate * 5 != sband->bitrates[i].bitrate)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tinfo->control.rates[0].idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info->control.rates[0].idx < 0)\n\t\t\tinfo->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tinfo->control.rates[0].flags = rate_flags;\n\t\tinfo->control.rates[0].count = min_t(u8, rate_retries + 1,\n\t\t\t\t\t\t     local->hw.max_rate_tries);\n\t}\n\n\treturn true;\n}\n\nnetdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t/* Sanity-check the length of the radiotap header */\n\tif (!ieee80211_validate_radiotap_len(skb))\n\t\tgoto fail;\n\n\t/* we now know there is a radiotap header with a length we can use */\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t/*\n\t * fix up the pointers accounting for the radiotap\n\t * header still being in there.  We are being given\n\t * a precooked IEEE80211 header so no need for\n\t * normal processing\n\t */\n\tskb_set_mac_header(skb, len_rthdr);\n\t/*\n\t * these are just fixed to the end of the rt area since we\n\t * don't have any better information and at this point, nobody cares\n\t */\n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t/*\n\t * Initialize skb->protocol if the injected frame is a data frame\n\t * carrying a rfc1042 header\n\t */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t/*\n\t * We process outgoing injected frames that have a local address\n\t * we handle as though they are non-injected frames.\n\t * This code here isn't entirely correct, the local MAC address\n\t * isn't always enough to find the interface to use; for proper\n\t * VLAN support we have an nl80211-based mechanism.\n\t *\n\t * This is necessary, for example, for old hostapd versions that\n\t * don't use nl80211-based management TX/RX.\n\t */\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t/*\n\t * Frame injection is not allowed if beaconing is not allowed\n\t * or if we need radar detection. Beaconing is usually not allowed when\n\t * the mode or operation (Adhoc, AP, Mesh) does not support DFS.\n\t * Passive scan is also used in world regulatory domains where\n\t * your country is not known and as such it should be treated as\n\t * NO TX unless the channel is explicitly allowed in which case\n\t * your current regulatory domain would not have the passive scan\n\t * flag.\n\t *\n\t * Since AP mode uses monitor interfaces to inject/TX management\n\t * frames we can make AP mode the exception to this rule once it\n\t * supports radar detection as its implementation can deal with\n\t * radar detection by itself. We can do that later by adding a\n\t * monitor flag interfaces used for AP support.\n\t */\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t/* Initialize skb->priority according to frame type and TID class,\n\t * with respect to the sub interface that the frame will actually\n\t * be transmitted on. If the DONT_REORDER flag is set, the original\n\t * skb-priority is preserved to assure frames injected with this\n\t * flag are not reordered relative to each other.\n\t */\n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t/*\n\t * Process the radiotap header. This will now take into account the\n\t * selected chandef above to accurately set injection rates and\n\t * retransmissions.\n\t */\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail_rcu;\n\n\t/* remove the injection radiotap header */\n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK; /* meaning, we dealt with the skb */\n}\n\nstatic inline bool ieee80211_is_tdls_setup(struct sk_buff *skb)\n{\n\tu16 ethertype = (skb->data[12] << 8) | skb->data[13];\n\n\treturn ethertype == ETH_P_TDLS &&\n\t       skb->len > 14 &&\n\t       skb->data[14] == WLAN_TDLS_SNAP_RFTYPE;\n}\n\nint ieee80211_lookup_ra_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct sta_info **sta_out)\n{\n\tstruct sta_info *sta;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (sta) {\n\t\t\t*sta_out = sta;\n\t\t\treturn 0;\n\t\t} else if (sdata->wdev.use_4addr) {\n\t\t\treturn -ENOLINK;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (is_multicast_ether_addr(skb->data)) {\n\t\t\t*sta_out = ERR_PTR(-ENOENT);\n\t\t\treturn 0;\n\t\t}\n\t\tsta = sta_info_get_bss(sdata, skb->data);\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t/* determined much later */\n\t\t*sta_out = NULL;\n\t\treturn 0;\n#endif\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sdata->wdev.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\t\tsta = sta_info_get(sdata, skb->data);\n\t\t\tif (sta && test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\t\tif (test_sta_flag(sta,\n\t\t\t\t\t\t  WLAN_STA_TDLS_PEER_AUTH)) {\n\t\t\t\t\t*sta_out = sta;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * TDLS link during setup - throw out frames to\n\t\t\t\t * peer. Allow TDLS-setup frames to unauthorized\n\t\t\t\t * peers for the special case of a link teardown\n\t\t\t\t * after a TDLS sta is removed due to being\n\t\t\t\t * unreachable.\n\t\t\t\t */\n\t\t\t\tif (!ieee80211_is_tdls_setup(skb))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t}\n\n\t\tsta = sta_info_get(sdata, sdata->u.mgd.bssid);\n\t\tif (!sta)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*sta_out = sta ?: ERR_PTR(-ENOENT);\n\treturn 0;\n}\n\nstatic u16 ieee80211_store_ack_skb(struct ieee80211_local *local,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   u32 *info_flags,\n\t\t\t\t   u64 *cookie)\n{\n\tstruct sk_buff *ack_skb;\n\tu16 info_id = 0;\n\n\tif (skb->sk)\n\t\tack_skb = skb_clone_sk(skb);\n\telse\n\t\tack_skb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (ack_skb) {\n\t\tunsigned long flags;\n\t\tint id;\n\n\t\tspin_lock_irqsave(&local->ack_status_lock, flags);\n\t\tid = idr_alloc(&local->ack_status_frames, ack_skb,\n\t\t\t       1, 0x2000, GFP_ATOMIC);\n\t\tspin_unlock_irqrestore(&local->ack_status_lock, flags);\n\n\t\tif (id >= 0) {\n\t\t\tinfo_id = id;\n\t\t\t*info_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\tif (cookie) {\n\t\t\t\t*cookie = ieee80211_mgmt_tx_cookie(local);\n\t\t\t\tIEEE80211_SKB_CB(ack_skb)->ack.cookie = *cookie;\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(ack_skb);\n\t\t}\n\t}\n\n\treturn info_id;\n}\n\n/**\n * ieee80211_build_hdr - build 802.11 header in the given frame\n * @sdata: virtual interface to build the header for\n * @skb: the skb to build the header in\n * @info_flags: skb flags to set\n * @sta: the station pointer\n * @ctrl_flags: info control flags to set\n * @cookie: cookie pointer to fill (if not %NULL)\n *\n * This function takes the skb with 802.3 header and reformats the header to\n * the appropriate IEEE 802.11 header based on which interface the packet is\n * being transmitted on.\n *\n * Note that this function also takes care of the TX status request and\n * potential unsharing of the SKB - this needs to be interleaved with the\n * header building.\n *\n * The function requires the read-side RCU lock held\n *\n * Returns: the (possibly reallocated) skb or an ERR_PTR() code\n */\nstatic struct sk_buff *ieee80211_build_hdr(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct sk_buff *skb, u32 info_flags,\n\t\t\t\t\t   struct sta_info *sta, u32 ctrl_flags,\n\t\t\t\t\t   u64 *cookie)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info;\n\tint head_need;\n\tu16 ethertype, hdrlen,  meshhdrlen = 0;\n\t__le16 fc;\n\tstruct ieee80211_hdr hdr;\n\tstruct ieee80211s_hdr mesh_hdr __maybe_unused;\n\tstruct mesh_path __maybe_unused *mppath = NULL, *mpath = NULL;\n\tconst u8 *encaps_data;\n\tint encaps_len, skip_header_bytes;\n\tbool wme_sta = false, authorized = false;\n\tbool tdls_peer;\n\tbool multicast;\n\tu16 info_id = 0;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_sub_if_data *ap_sdata;\n\tenum nl80211_band band;\n\tint ret;\n\n\tif (IS_ERR(sta))\n\t\tsta = NULL;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tif (local->force_tx_status)\n\t\tinfo_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n#endif\n\n\t/* convert Ethernet header to proper 802.11 header (based on\n\t * operation mode) */\n\tethertype = (skb->data[12] << 8) | skb->data[13];\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (sdata->wdev.use_4addr) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr.addr1, sta->sta.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\t\twme_sta = sta->sta.wme;\n\t\t}\n\t\tap_sdata = container_of(sdata->bss, struct ieee80211_sub_if_data,\n\t\t\t\t\tu.ap);\n\t\tchanctx_conf = rcu_dereference(ap_sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\t\tif (sdata->wdev.use_4addr)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t/* DA BSSID SA */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, skb->data + ETH_ALEN, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!is_multicast_ether_addr(skb->data)) {\n\t\t\tstruct sta_info *next_hop;\n\t\t\tbool mpp_lookup = true;\n\n\t\t\tmpath = mesh_path_lookup(sdata, skb->data);\n\t\t\tif (mpath) {\n\t\t\t\tmpp_lookup = false;\n\t\t\t\tnext_hop = rcu_dereference(mpath->next_hop);\n\t\t\t\tif (!next_hop ||\n\t\t\t\t    !(mpath->flags & (MESH_PATH_ACTIVE |\n\t\t\t\t\t\t      MESH_PATH_RESOLVING)))\n\t\t\t\t\tmpp_lookup = true;\n\t\t\t}\n\n\t\t\tif (mpp_lookup) {\n\t\t\t\tmppath = mpp_path_lookup(sdata, skb->data);\n\t\t\t\tif (mppath)\n\t\t\t\t\tmppath->exp_time = jiffies;\n\t\t\t}\n\n\t\t\tif (mppath && mpath)\n\t\t\t\tmesh_path_del(sdata, mpath->dst);\n\t\t}\n\n\t\t/*\n\t\t * Use address extension if it is a packet from\n\t\t * another interface or if we know the destination\n\t\t * is being proxied by a portal (i.e. portal address\n\t\t * differs from proxied address)\n\t\t */\n\t\tif (ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN) &&\n\t\t    !(mppath && !ether_addr_equal(mppath->mpp, skb->data))) {\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tskb->data, skb->data + ETH_ALEN);\n\t\t\tmeshhdrlen = ieee80211_new_mesh_header(sdata, &mesh_hdr,\n\t\t\t\t\t\t\t       NULL, NULL);\n\t\t} else {\n\t\t\t/* DS -> MBSS (802.11-2012 13.11.3.3).\n\t\t\t * For unicast with unknown forwarding information,\n\t\t\t * destination might be in the MBSS or if that fails\n\t\t\t * forwarded to another mesh gate. In either case\n\t\t\t * resolution will be handled in ieee80211_xmit(), so\n\t\t\t * leave the original DA. This also works for mcast */\n\t\t\tconst u8 *mesh_da = skb->data;\n\n\t\t\tif (mppath)\n\t\t\t\tmesh_da = mppath->mpp;\n\t\t\telse if (mpath)\n\t\t\t\tmesh_da = mpath->dst;\n\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tmesh_da, sdata->vif.addr);\n\t\t\tif (is_multicast_ether_addr(mesh_da))\n\t\t\t\t/* DA TA mSA AE:SA */\n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr,\n\t\t\t\t\t\tskb->data + ETH_ALEN, NULL);\n\t\t\telse\n\t\t\t\t/* RA TA mDA mSA AE:DA SA */\n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr, skb->data,\n\t\t\t\t\t\tskb->data + ETH_ALEN);\n\n\t\t}\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\n\t\t/* For injected frames, fill RA right away as nexthop lookup\n\t\t * will be skipped.\n\t\t */\n\t\tif ((ctrl_flags & IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP) &&\n\t\t    is_zero_ether_addr(hdr.addr1))\n\t\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tbreak;\n#endif\n\tcase NL80211_IFTYPE_STATION:\n\t\t/* we already did checks when looking up the RA STA */\n\t\ttdls_peer = test_sta_flag(sta, WLAN_STA_TDLS_PEER);\n\n\t\tif (tdls_peer) {\n\t\t\t/* DA SA BSSID */\n\t\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}  else if (sdata->u.mgd.use_4addr &&\n\t\t\t    cpu_to_be16(ethertype) != sdata->control_port_protocol) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t} else {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t\t/* BSSID SA DA */\n\t\t\tmemcpy(hdr.addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tcase NL80211_IFTYPE_OCB:\n\t\t/* DA SA BSSID */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\teth_broadcast_addr(hdr.addr3);\n\t\thdrlen = 24;\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* DA SA BSSID */\n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, sdata->u.ibss.bssid, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tmulticast = is_multicast_ether_addr(hdr.addr1);\n\n\t/* sta is always NULL for mesh */\n\tif (sta) {\n\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\twme_sta = sta->sta.wme;\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\t/* For mesh, the use of the QoS header is mandatory */\n\t\twme_sta = true;\n\t}\n\n\t/* receiver does QoS (which also means we do) use it */\n\tif (wme_sta) {\n\t\tfc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n\t\thdrlen += 2;\n\t}\n\n\t/*\n\t * Drop unicast frames to unauthorised stations unless they are\n\t * EAPOL frames from the local station.\n\t */\n\tif (unlikely(!ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t     (sdata->vif.type != NL80211_IFTYPE_OCB) &&\n\t\t     !multicast && !authorized &&\n\t\t     (cpu_to_be16(ethertype) != sdata->control_port_protocol ||\n\t\t      !ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN)))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tnet_info_ratelimited(\"%s: dropped frame to %pM (unauthorized port)\\n\",\n\t\t\t\t    sdata->name, hdr.addr1);\n#endif\n\n\t\tI802_DEBUG_INC(local->tx_handlers_drop_unauth_port);\n\n\t\tret = -EPERM;\n\t\tgoto free;\n\t}\n\n\tif (unlikely(!multicast && ((skb->sk &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS) ||\n\t\t     ctrl_flags & IEEE80211_TX_CTL_REQ_TX_STATUS)))\n\t\tinfo_id = ieee80211_store_ack_skb(local, skb, &info_flags,\n\t\t\t\t\t\t  cookie);\n\n\t/*\n\t * If the skb is shared we need to obtain our own copy.\n\t */\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *tmp_skb = skb;\n\n\t\t/* can't happen -- skb is a clone if info_id != 0 */\n\t\tWARN_ON(info_id);\n\n\t\tskb = skb_clone(skb, GFP_ATOMIC);\n\t\tkfree_skb(tmp_skb);\n\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\thdr.frame_control = fc;\n\thdr.duration_id = 0;\n\thdr.seq_ctrl = 0;\n\n\tskip_header_bytes = ETH_HLEN;\n\tif (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {\n\t\tencaps_data = bridge_tunnel_header;\n\t\tencaps_len = sizeof(bridge_tunnel_header);\n\t\tskip_header_bytes -= 2;\n\t} else if (ethertype >= ETH_P_802_3_MIN) {\n\t\tencaps_data = rfc1042_header;\n\t\tencaps_len = sizeof(rfc1042_header);\n\t\tskip_header_bytes -= 2;\n\t} else {\n\t\tencaps_data = NULL;\n\t\tencaps_len = 0;\n\t}\n\n\tskb_pull(skb, skip_header_bytes);\n\thead_need = hdrlen + encaps_len + meshhdrlen - skb_headroom(skb);\n\n\t/*\n\t * So we need to modify the skb header and hence need a copy of\n\t * that. The head_need variable above doesn't, so far, include\n\t * the needed header space that we don't need right away. If we\n\t * can, then we don't reallocate right now but only after the\n\t * frame arrives at the master device (if it does...)\n\t *\n\t * If we cannot, however, then we will reallocate to include all\n\t * the ever needed space. Also, if we need to reallocate it anyway,\n\t * make it big enough for everything we may ever need.\n\t */\n\n\tif (head_need > 0 || skb_cloned(skb)) {\n\t\thead_need += sdata->encrypt_headroom;\n\t\thead_need += local->tx_headroom;\n\t\thead_need = max_t(int, 0, head_need);\n\t\tif (ieee80211_skb_resize(sdata, skb, head_need, ENCRYPT_DATA)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tskb = NULL;\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tif (encaps_data)\n\t\tmemcpy(skb_push(skb, encaps_len), encaps_data, encaps_len);\n\n#ifdef CONFIG_MAC80211_MESH\n\tif (meshhdrlen > 0)\n\t\tmemcpy(skb_push(skb, meshhdrlen), &mesh_hdr, meshhdrlen);\n#endif\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\t__le16 *qos_control;\n\n\t\tqos_control = skb_push(skb, 2);\n\t\tmemcpy(skb_push(skb, hdrlen - 2), &hdr, hdrlen - 2);\n\t\t/*\n\t\t * Maybe we could actually set some fields here, for now just\n\t\t * initialise to zero to indicate no special operation.\n\t\t */\n\t\t*qos_control = 0;\n\t} else\n\t\tmemcpy(skb_push(skb, hdrlen), &hdr, hdrlen);\n\n\tskb_reset_mac_header(skb);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(info, 0, sizeof(*info));\n\n\tinfo->flags = info_flags;\n\tinfo->ack_frame_id = info_id;\n\tinfo->band = band;\n\tinfo->control.flags = ctrl_flags;\n\n\treturn skb;\n free:\n\tkfree_skb(skb);\n\treturn ERR_PTR(ret);\n}\n\n/*\n * fast-xmit overview\n *\n * The core idea of this fast-xmit is to remove per-packet checks by checking\n * them out of band. ieee80211_check_fast_xmit() implements the out-of-band\n * checks that are needed to get the sta->fast_tx pointer assigned, after which\n * much less work can be done per packet. For example, fragmentation must be\n * disabled or the fast_tx pointer will not be set. All the conditions are seen\n * in the code here.\n *\n * Once assigned, the fast_tx data structure also caches the per-packet 802.11\n * header and other data to aid packet processing in ieee80211_xmit_fast().\n *\n * The most difficult part of this is that when any of these assumptions\n * change, an external trigger (i.e. a call to ieee80211_clear_fast_xmit(),\n * ieee80211_check_fast_xmit() or friends) is required to reset the data,\n * since the per-packet code no longer checks the conditions. This is reflected\n * by the calls to these functions throughout the rest of the code, and must be\n * maintained if any of the TX path checks change.\n */\n\nvoid ieee80211_check_fast_xmit(struct sta_info *sta)\n{\n\tstruct ieee80211_fast_tx build = {}, *fast_tx = NULL, *old;\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_hdr *hdr = (void *)build.hdr;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\t__le16 fc;\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORT_FAST_XMIT))\n\t\treturn;\n\n\t/* Locking here protects both the pointer itself, and against concurrent\n\t * invocations winning data access races to, e.g., the key pointer that\n\t * is used.\n\t * Without it, the invocation of this function right after the key\n\t * pointer changes wouldn't be sufficient, as another CPU could access\n\t * the pointer, then stall, and then do the cache update after the CPU\n\t * that invalidated the key.\n\t * With the locking, such scenarios cannot happen as the check for the\n\t * key and the fast-tx assignment are done atomically, so the CPU that\n\t * modifies the key will either wait or other one will see the key\n\t * cleared/changed already.\n\t */\n\tspin_lock_bh(&sta->lock);\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_PS) &&\n\t    !ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS) &&\n\t    sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tgoto out;\n\n\tif (!test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\tgoto out;\n\n\tif (test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t    test_sta_flag(sta, WLAN_STA_PS_DRIVER) ||\n\t    test_sta_flag(sta, WLAN_STA_PS_DELIVER) ||\n\t    test_sta_flag(sta, WLAN_STA_CLEAR_PS_FILT))\n\t\tgoto out;\n\n\tif (sdata->noack_map)\n\t\tgoto out;\n\n\t/* fast-xmit doesn't handle fragmentation at all */\n\tif (local->hw.wiphy->frag_threshold != (u32)-1 &&\n\t    !ieee80211_hw_check(&local->hw, SUPPORTS_TX_FRAG))\n\t\tgoto out;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\tgoto out;\n\t}\n\tbuild.band = chanctx_conf->def.chan->band;\n\trcu_read_unlock();\n\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* DA SA BSSID */\n\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\tmemcpy(hdr->addr3, sdata->u.ibss.bssid, ETH_ALEN);\n\t\tbuild.hdr_len = 24;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\t/* DA SA BSSID */\n\t\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\t\tmemcpy(hdr->addr3, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tbuild.hdr_len = 24;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdata->u.mgd.use_4addr) {\n\t\t\t/* non-regular ethertype cannot use the fastpath */\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr->addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t\tbuild.hdr_len = 30;\n\t\t\tbreak;\n\t\t}\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t/* BSSID SA DA */\n\t\tmemcpy(hdr->addr1, sdata->u.mgd.bssid, ETH_ALEN);\n\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\tbuild.hdr_len = 24;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (sdata->wdev.use_4addr) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t/* RA TA DA SA */\n\t\t\tmemcpy(hdr->addr1, sta->sta.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t\tbuild.hdr_len = 30;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t/* DA BSSID SA */\n\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\tbuild.hdr_len = 24;\n\t\tbreak;\n\tdefault:\n\t\t/* not handled on fast-xmit */\n\t\tgoto out;\n\t}\n\n\tif (sta->sta.wme) {\n\t\tbuild.hdr_len += 2;\n\t\tfc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n\t}\n\n\t/* We store the key here so there's no point in using rcu_dereference()\n\t * but that's fine because the code that changes the pointers will call\n\t * this function after doing so. For a single CPU that would be enough,\n\t * for multiple see the comment above.\n\t */\n\tbuild.key = rcu_access_pointer(sta->ptk[sta->ptk_idx]);\n\tif (!build.key)\n\t\tbuild.key = rcu_access_pointer(sdata->default_unicast_key);\n\tif (build.key) {\n\t\tbool gen_iv, iv_spc, mmic;\n\n\t\tgen_iv = build.key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tiv_spc = build.key->conf.flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE;\n\t\tmmic = build.key->conf.flags &\n\t\t\t(IEEE80211_KEY_FLAG_GENERATE_MMIC |\n\t\t\t IEEE80211_KEY_FLAG_PUT_MIC_SPACE);\n\n\t\t/* don't handle software crypto */\n\t\tif (!(build.key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE))\n\t\t\tgoto out;\n\n\t\t/* Key is being removed */\n\t\tif (build.key->flags & KEY_FLAG_TAINTED)\n\t\t\tgoto out;\n\n\t\tswitch (build.key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\t\tif (gen_iv)\n\t\t\t\tbuild.pn_offs = build.hdr_len;\n\t\t\tif (gen_iv || iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_CCMP_HDR_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tif (gen_iv)\n\t\t\t\tbuild.pn_offs = build.hdr_len;\n\t\t\tif (gen_iv || iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_GCMP_HDR_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\t/* cannot handle MMIC or IV generation in xmit-fast */\n\t\t\tif (mmic || gen_iv)\n\t\t\t\tgoto out;\n\t\t\tif (iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_TKIP_IV_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\t/* cannot handle IV generation in fast-xmit */\n\t\t\tif (gen_iv)\n\t\t\t\tgoto out;\n\t\t\tif (iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_WEP_IV_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t\tWARN(1,\n\t\t\t     \"management cipher suite 0x%x enabled for data\\n\",\n\t\t\t     build.key->conf.cipher);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\t/* we don't know how to generate IVs for this at all */\n\t\t\tif (WARN_ON(gen_iv))\n\t\t\t\tgoto out;\n\t\t\t/* pure hardware keys are OK, of course */\n\t\t\tif (!(build.key->flags & KEY_FLAG_CIPHER_SCHEME))\n\t\t\t\tbreak;\n\t\t\t/* cipher scheme might require space allocation */\n\t\t\tif (iv_spc &&\n\t\t\t    build.key->conf.iv_len > IEEE80211_FAST_XMIT_MAX_IV)\n\t\t\t\tgoto out;\n\t\t\tif (iv_spc)\n\t\t\t\tbuild.hdr_len += build.key->conf.iv_len;\n\t\t}\n\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t}\n\n\thdr->frame_control = fc;\n\n\tmemcpy(build.hdr + build.hdr_len,\n\t       rfc1042_header,  sizeof(rfc1042_header));\n\tbuild.hdr_len += sizeof(rfc1042_header);\n\n\tfast_tx = kmemdup(&build, sizeof(build), GFP_ATOMIC);\n\t/* if the kmemdup fails, continue w/o fast_tx */\n\tif (!fast_tx)\n\t\tgoto out;\n\n out:\n\t/* we might have raced against another call to this function */\n\told = rcu_dereference_protected(sta->fast_tx,\n\t\t\t\t\tlockdep_is_held(&sta->lock));\n\trcu_assign_pointer(sta->fast_tx, fast_tx);\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n\tspin_unlock_bh(&sta->lock);\n}\n\nvoid ieee80211_check_fast_xmit_all(struct ieee80211_local *local)\n{\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list)\n\t\tieee80211_check_fast_xmit(sta);\n\trcu_read_unlock();\n}\n\nvoid ieee80211_check_fast_xmit_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata &&\n\t\t    (!sta->sdata->bss || sta->sdata->bss != sdata->bss))\n\t\t\tcontinue;\n\t\tieee80211_check_fast_xmit(sta);\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid ieee80211_clear_fast_xmit(struct sta_info *sta)\n{\n\tstruct ieee80211_fast_tx *fast_tx;\n\n\tspin_lock_bh(&sta->lock);\n\tfast_tx = rcu_dereference_protected(sta->fast_tx,\n\t\t\t\t\t    lockdep_is_held(&sta->lock));\n\tRCU_INIT_POINTER(sta->fast_tx, NULL);\n\tspin_unlock_bh(&sta->lock);\n\n\tif (fast_tx)\n\t\tkfree_rcu(fast_tx, rcu_head);\n}\n\nstatic bool ieee80211_amsdu_realloc_pad(struct ieee80211_local *local,\n\t\t\t\t\tstruct sk_buff *skb, int headroom)\n{\n\tif (skb_headroom(skb) < headroom) {\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head);\n\n\t\tif (pskb_expand_head(skb, headroom, 0, GFP_ATOMIC)) {\n\t\t\twiphy_debug(local->hw.wiphy,\n\t\t\t\t    \"failed to reallocate TX buffer\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool ieee80211_amsdu_prepare_head(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct ieee80211_fast_tx *fast_tx,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ethhdr *amsdu_hdr;\n\tint hdr_len = fast_tx->hdr_len - sizeof(rfc1042_header);\n\tint subframe_len = skb->len - hdr_len;\n\tvoid *data;\n\tu8 *qc, *h_80211_src, *h_80211_dst;\n\tconst u8 *bssid;\n\n\tif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\n\t\treturn false;\n\n\tif (info->control.flags & IEEE80211_TX_CTRL_AMSDU)\n\t\treturn true;\n\n\tif (!ieee80211_amsdu_realloc_pad(local, skb, sizeof(*amsdu_hdr)))\n\t\treturn false;\n\n\tdata = skb_push(skb, sizeof(*amsdu_hdr));\n\tmemmove(data, data + sizeof(*amsdu_hdr), hdr_len);\n\thdr = data;\n\tamsdu_hdr = data + hdr_len;\n\t/* h_80211_src/dst is addr* field within hdr */\n\th_80211_src = data + fast_tx->sa_offs;\n\th_80211_dst = data + fast_tx->da_offs;\n\n\tamsdu_hdr->h_proto = cpu_to_be16(subframe_len);\n\tether_addr_copy(amsdu_hdr->h_source, h_80211_src);\n\tether_addr_copy(amsdu_hdr->h_dest, h_80211_dst);\n\n\t/* according to IEEE 802.11-2012 8.3.2 table 8-19, the outer SA/DA\n\t * fields needs to be changed to BSSID for A-MSDU frames depending\n\t * on FromDS/ToDS values.\n\t */\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tbssid = sdata->u.mgd.bssid;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbssid = sdata->vif.addr;\n\t\tbreak;\n\tdefault:\n\t\tbssid = NULL;\n\t}\n\n\tif (bssid && ieee80211_has_fromds(hdr->frame_control))\n\t\tether_addr_copy(h_80211_src, bssid);\n\n\tif (bssid && ieee80211_has_tods(hdr->frame_control))\n\t\tether_addr_copy(h_80211_dst, bssid);\n\n\tqc = ieee80211_get_qos_ctl(hdr);\n\t*qc |= IEEE80211_QOS_CTL_A_MSDU_PRESENT;\n\n\tinfo->control.flags |= IEEE80211_TX_CTRL_AMSDU;\n\n\treturn true;\n}\n\nstatic bool ieee80211_amsdu_aggregate(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct sta_info *sta,\n\t\t\t\t      struct ieee80211_fast_tx *fast_tx,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin;\n\tstruct fq_flow *flow;\n\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\tstruct ieee80211_txq *txq = sta->sta.txq[tid];\n\tstruct txq_info *txqi;\n\tstruct sk_buff **frag_tail, *head;\n\tint subframe_len = skb->len - ETH_ALEN;\n\tu8 max_subframes = sta->sta.max_amsdu_subframes;\n\tint max_frags = local->hw.max_tx_fragments;\n\tint max_amsdu_len = sta->sta.max_amsdu_len;\n\tint orig_truesize;\n\tu32 flow_idx;\n\t__be16 len;\n\tvoid *data;\n\tbool ret = false;\n\tunsigned int orig_len;\n\tint n = 2, nfrags, pad = 0;\n\tu16 hdrlen;\n\n\tif (!ieee80211_hw_check(&local->hw, TX_AMSDU))\n\t\treturn false;\n\n\tif (skb_is_gso(skb))\n\t\treturn false;\n\n\tif (!txq)\n\t\treturn false;\n\n\ttxqi = to_txq_info(txq);\n\tif (test_bit(IEEE80211_TXQ_NO_AMSDU, &txqi->flags))\n\t\treturn false;\n\n\tif (sta->sta.max_rc_amsdu_len)\n\t\tmax_amsdu_len = min_t(int, max_amsdu_len,\n\t\t\t\t      sta->sta.max_rc_amsdu_len);\n\n\tif (sta->sta.max_tid_amsdu_len[tid])\n\t\tmax_amsdu_len = min_t(int, max_amsdu_len,\n\t\t\t\t      sta->sta.max_tid_amsdu_len[tid]);\n\n\tflow_idx = fq_flow_idx(fq, skb);\n\n\tspin_lock_bh(&fq->lock);\n\n\t/* TODO: Ideally aggregation should be done on dequeue to remain\n\t * responsive to environment changes.\n\t */\n\n\ttin = &txqi->tin;\n\tflow = fq_flow_classify(fq, tin, flow_idx, skb);\n\thead = skb_peek_tail(&flow->queue);\n\tif (!head || skb_is_gso(head))\n\t\tgoto out;\n\n\torig_truesize = head->truesize;\n\torig_len = head->len;\n\n\tif (skb->len + head->len > max_amsdu_len)\n\t\tgoto out;\n\n\tnfrags = 1 + skb_shinfo(skb)->nr_frags;\n\tnfrags += 1 + skb_shinfo(head)->nr_frags;\n\tfrag_tail = &skb_shinfo(head)->frag_list;\n\twhile (*frag_tail) {\n\t\tnfrags += 1 + skb_shinfo(*frag_tail)->nr_frags;\n\t\tfrag_tail = &(*frag_tail)->next;\n\t\tn++;\n\t}\n\n\tif (max_subframes && n > max_subframes)\n\t\tgoto out;\n\n\tif (max_frags && nfrags > max_frags)\n\t\tgoto out;\n\n\tif (!drv_can_aggregate_in_amsdu(local, head, skb))\n\t\tgoto out;\n\n\tif (!ieee80211_amsdu_prepare_head(sdata, fast_tx, head))\n\t\tgoto out;\n\n\t/*\n\t * Pad out the previous subframe to a multiple of 4 by adding the\n\t * padding to the next one, that's being added. Note that head->len\n\t * is the length of the full A-MSDU, but that works since each time\n\t * we add a new subframe we pad out the previous one to a multiple\n\t * of 4 and thus it no longer matters in the next round.\n\t */\n\thdrlen = fast_tx->hdr_len - sizeof(rfc1042_header);\n\tif ((head->len - hdrlen) & 3)\n\t\tpad = 4 - ((head->len - hdrlen) & 3);\n\n\tif (!ieee80211_amsdu_realloc_pad(local, skb, sizeof(rfc1042_header) +\n\t\t\t\t\t\t     2 + pad))\n\t\tgoto out_recalc;\n\n\tret = true;\n\tdata = skb_push(skb, ETH_ALEN + 2);\n\tmemmove(data, data + ETH_ALEN + 2, 2 * ETH_ALEN);\n\n\tdata += 2 * ETH_ALEN;\n\tlen = cpu_to_be16(subframe_len);\n\tmemcpy(data, &len, 2);\n\tmemcpy(data + 2, rfc1042_header, sizeof(rfc1042_header));\n\n\tmemset(skb_push(skb, pad), 0, pad);\n\n\thead->len += skb->len;\n\thead->data_len += skb->len;\n\t*frag_tail = skb;\n\nout_recalc:\n\tfq->memory_usage += head->truesize - orig_truesize;\n\tif (head->len != orig_len) {\n\t\tflow->backlog += head->len - orig_len;\n\t\ttin->backlog_bytes += head->len - orig_len;\n\t}\nout:\n\tspin_unlock_bh(&fq->lock);\n\n\treturn ret;\n}\n\n/*\n * Can be called while the sta lock is held. Anything that can cause packets to\n * be generated will cause deadlock!\n */\nstatic void ieee80211_xmit_fast_finish(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct sta_info *sta, u8 pn_offs,\n\t\t\t\t       struct ieee80211_key *key,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tu8 tid = IEEE80211_NUM_TIDS;\n\n\tif (key)\n\t\tinfo->control.hw_key = &key->conf;\n\n\tdev_sw_netstats_tx_add(skb->dev, 1, skb->len);\n\n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\t\thdr->seq_ctrl = ieee80211_tx_next_seq(sta, tid);\n\t} else {\n\t\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\t\thdr->seq_ctrl = cpu_to_le16(sdata->sequence_number);\n\t\tsdata->sequence_number += 0x10;\n\t}\n\n\tif (skb_shinfo(skb)->gso_size)\n\t\tsta->tx_stats.msdu[tid] +=\n\t\t\tDIV_ROUND_UP(skb->len, skb_shinfo(skb)->gso_size);\n\telse\n\t\tsta->tx_stats.msdu[tid]++;\n\n\tinfo->hw_queue = sdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\t/* statistics normally done by ieee80211_tx_h_stats (but that\n\t * has to consider fragmentation, so is more complex)\n\t */\n\tsta->tx_stats.bytes[skb_get_queue_mapping(skb)] += skb->len;\n\tsta->tx_stats.packets[skb_get_queue_mapping(skb)]++;\n\n\tif (pn_offs) {\n\t\tu64 pn;\n\t\tu8 *crypto_hdr = skb->data + pn_offs;\n\n\t\tswitch (key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tpn = atomic64_inc_return(&key->conf.tx_pn);\n\t\t\tcrypto_hdr[0] = pn;\n\t\t\tcrypto_hdr[1] = pn >> 8;\n\t\t\tcrypto_hdr[3] = 0x20 | (key->conf.keyidx << 6);\n\t\t\tcrypto_hdr[4] = pn >> 16;\n\t\t\tcrypto_hdr[5] = pn >> 24;\n\t\t\tcrypto_hdr[6] = pn >> 32;\n\t\t\tcrypto_hdr[7] = pn >> 40;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sta_info *sta,\n\t\t\t\tstruct ieee80211_fast_tx *fast_tx,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu16 ethertype = (skb->data[12] << 8) | skb->data[13];\n\tint extra_head = fast_tx->hdr_len - (ETH_HLEN - 2);\n\tint hw_headroom = sdata->local->hw.extra_tx_headroom;\n\tstruct ethhdr eth;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_hdr *hdr = (void *)fast_tx->hdr;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result r;\n\tstruct tid_ampdu_tx *tid_tx = NULL;\n\tu8 tid = IEEE80211_NUM_TIDS;\n\n\t/* control port protocol needs a lot of special handling */\n\tif (cpu_to_be16(ethertype) == sdata->control_port_protocol)\n\t\treturn false;\n\n\t/* only RFC 1042 SNAP */\n\tif (ethertype < ETH_P_802_3_MIN)\n\t\treturn false;\n\n\t/* don't handle TX status request here either */\n\tif (skb->sk && skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)\n\t\treturn false;\n\n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\t\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (tid_tx) {\n\t\t\tif (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state))\n\t\t\t\treturn false;\n\t\t\tif (tid_tx->timeout)\n\t\t\t\ttid_tx->last_tx = jiffies;\n\t\t}\n\t}\n\n\t/* after this point (skb is modified) we cannot return false */\n\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *tmp_skb = skb;\n\n\t\tskb = skb_clone(skb, GFP_ATOMIC);\n\t\tkfree_skb(tmp_skb);\n\n\t\tif (!skb)\n\t\t\treturn true;\n\t}\n\n\tif ((hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) &&\n\t    ieee80211_amsdu_aggregate(sdata, sta, fast_tx, skb))\n\t\treturn true;\n\n\t/* will not be crypto-handled beyond what we do here, so use false\n\t * as the may-encrypt argument for the resize to not account for\n\t * more room than we already have in 'extra_head'\n\t */\n\tif (unlikely(ieee80211_skb_resize(sdata, skb,\n\t\t\t\t\t  max_t(int, extra_head + hw_headroom -\n\t\t\t\t\t\t     skb_headroom(skb), 0),\n\t\t\t\t\t  ENCRYPT_NO))) {\n\t\tkfree_skb(skb);\n\t\treturn true;\n\t}\n\n\tmemcpy(&eth, skb->data, ETH_HLEN - 2);\n\thdr = skb_push(skb, extra_head);\n\tmemcpy(skb->data, fast_tx->hdr, fast_tx->hdr_len);\n\tmemcpy(skb->data + fast_tx->da_offs, eth.h_dest, ETH_ALEN);\n\tmemcpy(skb->data + fast_tx->sa_offs, eth.h_source, ETH_ALEN);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(info, 0, sizeof(*info));\n\tinfo->band = fast_tx->band;\n\tinfo->control.vif = &sdata->vif;\n\tinfo->flags = IEEE80211_TX_CTL_FIRST_FRAGMENT |\n\t\t      IEEE80211_TX_CTL_DONTFRAG |\n\t\t      (tid_tx ? IEEE80211_TX_CTL_AMPDU : 0);\n\tinfo->control.flags = IEEE80211_TX_CTRL_FAST_XMIT;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tif (local->force_tx_status)\n\t\tinfo->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n#endif\n\n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\t\t*ieee80211_get_qos_ctl(hdr) = tid;\n\t}\n\n\t__skb_queue_head_init(&tx.skbs);\n\n\ttx.flags = IEEE80211_TX_UNICAST;\n\ttx.local = local;\n\ttx.sdata = sdata;\n\ttx.sta = sta;\n\ttx.key = fast_tx->key;\n\n\tif (!ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL)) {\n\t\ttx.skb = skb;\n\t\tr = ieee80211_tx_h_rate_ctrl(&tx);\n\t\tskb = tx.skb;\n\t\ttx.skb = NULL;\n\n\t\tif (r != TX_CONTINUE) {\n\t\t\tif (r != TX_QUEUED)\n\t\t\t\tkfree_skb(skb);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (ieee80211_queue_skb(local, sdata, sta, skb))\n\t\treturn true;\n\n\tieee80211_xmit_fast_finish(sdata, sta, fast_tx->pn_offs,\n\t\t\t\t   fast_tx->key, skb);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\n\t__skb_queue_tail(&tx.skbs, skb);\n\tieee80211_tx_frags(local, &sdata->vif, sta, &tx.skbs, false);\n\treturn true;\n}\n\nstruct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_txq *txq)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct txq_info *txqi = container_of(txq, struct txq_info, txq);\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb = NULL;\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin = &txqi->tin;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result r;\n\tstruct ieee80211_vif *vif = txq->vif;\n\n\tWARN_ON_ONCE(softirq_count() == 0);\n\n\tif (!ieee80211_txq_airtime_check(hw, txq))\n\t\treturn NULL;\n\nbegin:\n\tspin_lock_bh(&fq->lock);\n\n\tif (test_bit(IEEE80211_TXQ_STOP, &txqi->flags) ||\n\t    test_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags))\n\t\tgoto out;\n\n\tif (vif->txqs_stopped[txq->ac]) {\n\t\tset_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags);\n\t\tgoto out;\n\t}\n\n\t/* Make sure fragments stay together. */\n\tskb = __skb_dequeue(&txqi->frags);\n\tif (unlikely(skb)) {\n\t\tif (!(IEEE80211_SKB_CB(skb)->control.flags &\n\t\t\t\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING))\n\t\t\tgoto out;\n\t\tIEEE80211_SKB_CB(skb)->control.flags &=\n\t\t\t~IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t} else {\n\t\tskb = fq_tin_dequeue(fq, tin, fq_tin_dequeue_func);\n\t}\n\n\tif (!skb)\n\t\tgoto out;\n\n\tspin_unlock_bh(&fq->lock);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tmemset(&tx, 0, sizeof(tx));\n\t__skb_queue_head_init(&tx.skbs);\n\ttx.local = local;\n\ttx.skb = skb;\n\ttx.sdata = vif_to_sdata(info->control.vif);\n\n\tif (txq->sta) {\n\t\ttx.sta = container_of(txq->sta, struct sta_info, sta);\n\t\t/*\n\t\t * Drop unicast frames to unauthorised stations unless they are\n\t\t * injected frames or EAPOL frames from the local station.\n\t\t */\n\t\tif (unlikely(!(info->flags & IEEE80211_TX_CTL_INJECTED) &&\n\t\t\t     ieee80211_is_data(hdr->frame_control) &&\n\t\t\t     !ieee80211_vif_is_mesh(&tx.sdata->vif) &&\n\t\t\t     tx.sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t\t\t     !is_multicast_ether_addr(hdr->addr1) &&\n\t\t\t     !test_sta_flag(tx.sta, WLAN_STA_AUTHORIZED) &&\n\t\t\t     (!(info->control.flags &\n\t\t\t\tIEEE80211_TX_CTRL_PORT_CTRL_PROTO) ||\n\t\t\t      !ether_addr_equal(tx.sdata->vif.addr,\n\t\t\t\t\t\thdr->addr2)))) {\n\t\t\tI802_DEBUG_INC(local->tx_handlers_drop_unauth_port);\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\n\t/*\n\t * The key can be removed while the packet was queued, so need to call\n\t * this here to get the current key.\n\t */\n\tr = ieee80211_tx_h_select_key(&tx);\n\tif (r != TX_CONTINUE) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\tgoto begin;\n\t}\n\n\tif (test_bit(IEEE80211_TXQ_AMPDU, &txqi->flags))\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\telse\n\t\tinfo->flags &= ~IEEE80211_TX_CTL_AMPDU;\n\n\tif (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)\n\t\tgoto encap_out;\n\n\tif (info->control.flags & IEEE80211_TX_CTRL_FAST_XMIT) {\n\t\tstruct sta_info *sta = container_of(txq->sta, struct sta_info,\n\t\t\t\t\t\t    sta);\n\t\tu8 pn_offs = 0;\n\n\t\tif (tx.key &&\n\t\t    (tx.key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV))\n\t\t\tpn_offs = ieee80211_hdrlen(hdr->frame_control);\n\n\t\tieee80211_xmit_fast_finish(sta->sdata, sta, pn_offs,\n\t\t\t\t\t   tx.key, skb);\n\t} else {\n\t\tif (invoke_tx_handlers_late(&tx))\n\t\t\tgoto begin;\n\n\t\tskb = __skb_dequeue(&tx.skbs);\n\n\t\tif (!skb_queue_empty(&tx.skbs)) {\n\t\t\tspin_lock_bh(&fq->lock);\n\t\t\tskb_queue_splice_tail(&tx.skbs, &txqi->frags);\n\t\t\tspin_unlock_bh(&fq->lock);\n\t\t}\n\t}\n\n\tif (skb_has_frag_list(skb) &&\n\t    !ieee80211_hw_check(&local->hw, TX_FRAG_LIST)) {\n\t\tif (skb_linearize(skb)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\n\tswitch (tx.sdata->vif.type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (tx.sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tvif = &tx.sdata->vif;\n\t\t\tbreak;\n\t\t}\n\t\ttx.sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tx.sdata) {\n\t\t\tvif = &tx.sdata->vif;\n\t\t\tinfo->hw_queue =\n\t\t\t\tvif->hw_queue[skb_get_queue_mapping(skb)];\n\t\t} else if (ieee80211_hw_check(&local->hw, QUEUE_CONTROL)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t} else {\n\t\t\tvif = NULL;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\ttx.sdata = container_of(tx.sdata->bss,\n\t\t\t\t\tstruct ieee80211_sub_if_data, u.ap);\n\t\tfallthrough;\n\tdefault:\n\t\tvif = &tx.sdata->vif;\n\t\tbreak;\n\t}\n\nencap_out:\n\tIEEE80211_SKB_CB(skb)->control.vif = vif;\n\n\tif (vif &&\n\t    wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {\n\t\tbool ampdu = txq->ac != IEEE80211_AC_VO;\n\t\tu32 airtime;\n\n\t\tairtime = ieee80211_calc_expected_tx_airtime(hw, vif, txq->sta,\n\t\t\t\t\t\t\t     skb->len, ampdu);\n\t\tif (airtime) {\n\t\t\tairtime = ieee80211_info_set_tx_time_est(info, airtime);\n\t\t\tieee80211_sta_update_pending_airtime(local, tx.sta,\n\t\t\t\t\t\t\t     txq->ac,\n\t\t\t\t\t\t\t     airtime,\n\t\t\t\t\t\t\t     false);\n\t\t}\n\t}\n\n\treturn skb;\n\nout:\n\tspin_unlock_bh(&fq->lock);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_tx_dequeue);\n\nstruct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_txq *ret = NULL;\n\tstruct txq_info *txqi = NULL, *head = NULL;\n\tbool found_eligible_txq = false;\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\n begin:\n\ttxqi = list_first_entry_or_null(&local->active_txqs[ac],\n\t\t\t\t\tstruct txq_info,\n\t\t\t\t\tschedule_order);\n\tif (!txqi)\n\t\tgoto out;\n\n\tif (txqi == head) {\n\t\tif (!found_eligible_txq)\n\t\t\tgoto out;\n\t\telse\n\t\t\tfound_eligible_txq = false;\n\t}\n\n\tif (!head)\n\t\thead = txqi;\n\n\tif (txqi->txq.sta) {\n\t\tstruct sta_info *sta = container_of(txqi->txq.sta,\n\t\t\t\t\t\t    struct sta_info, sta);\n\t\tbool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);\n\t\ts64 deficit = sta->airtime[txqi->txq.ac].deficit;\n\n\t\tif (aql_check)\n\t\t\tfound_eligible_txq = true;\n\n\t\tif (deficit < 0)\n\t\t\tsta->airtime[txqi->txq.ac].deficit +=\n\t\t\t\tsta->airtime_weight;\n\n\t\tif (deficit < 0 || !aql_check) {\n\t\t\tlist_move_tail(&txqi->schedule_order,\n\t\t\t\t       &local->active_txqs[txqi->txq.ac]);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\n\n\tif (txqi->schedule_round == local->schedule_round[ac])\n\t\tgoto out;\n\n\tlist_del_init(&txqi->schedule_order);\n\ttxqi->schedule_round = local->schedule_round[ac];\n\tret = &txqi->txq;\n\nout:\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_next_txq);\n\nvoid __ieee80211_schedule_txq(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq,\n\t\t\t      bool force)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct txq_info *txqi = to_txq_info(txq);\n\n\tspin_lock_bh(&local->active_txq_lock[txq->ac]);\n\n\tif (list_empty(&txqi->schedule_order) &&\n\t    (force || !skb_queue_empty(&txqi->frags) ||\n\t     txqi->tin.backlog_packets)) {\n\t\t/* If airtime accounting is active, always enqueue STAs at the\n\t\t * head of the list to ensure that they only get moved to the\n\t\t * back by the airtime DRR scheduler once they have a negative\n\t\t * deficit. A station that already has a negative deficit will\n\t\t * get immediately moved to the back of the list on the next\n\t\t * call to ieee80211_next_txq().\n\t\t */\n\t\tif (txqi->txq.sta && local->airtime_flags &&\n\t\t    wiphy_ext_feature_isset(local->hw.wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\t\tlist_add(&txqi->schedule_order,\n\t\t\t\t &local->active_txqs[txq->ac]);\n\t\telse\n\t\t\tlist_add_tail(&txqi->schedule_order,\n\t\t\t\t      &local->active_txqs[txq->ac]);\n\t}\n\n\tspin_unlock_bh(&local->active_txq_lock[txq->ac]);\n}\nEXPORT_SYMBOL(__ieee80211_schedule_txq);\n\nDEFINE_STATIC_KEY_FALSE(aql_disable);\n\nbool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_txq *txq)\n{\n\tstruct sta_info *sta;\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tif (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))\n\t\treturn true;\n\n\tif (static_branch_unlikely(&aql_disable))\n\t\treturn true;\n\n\tif (!txq->sta)\n\t\treturn true;\n\n\tif (unlikely(txq->tid == IEEE80211_NUM_TIDS))\n\t\treturn true;\n\n\tsta = container_of(txq->sta, struct sta_info, sta);\n\tif (atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <\n\t    sta->airtime[txq->ac].aql_limit_low)\n\t\treturn true;\n\n\tif (atomic_read(&local->aql_total_pending_airtime) <\n\t    local->aql_threshold &&\n\t    atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <\n\t    sta->airtime[txq->ac].aql_limit_high)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(ieee80211_txq_airtime_check);\n\nbool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_txq *txq)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct txq_info *iter, *tmp, *txqi = to_txq_info(txq);\n\tstruct sta_info *sta;\n\tu8 ac = txq->ac;\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\n\tif (!txqi->txq.sta)\n\t\tgoto out;\n\n\tif (list_empty(&txqi->schedule_order))\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],\n\t\t\t\t schedule_order) {\n\t\tif (iter == txqi)\n\t\t\tbreak;\n\n\t\tif (!iter->txq.sta) {\n\t\t\tlist_move_tail(&iter->schedule_order,\n\t\t\t\t       &local->active_txqs[ac]);\n\t\t\tcontinue;\n\t\t}\n\t\tsta = container_of(iter->txq.sta, struct sta_info, sta);\n\t\tif (sta->airtime[ac].deficit < 0)\n\t\t\tsta->airtime[ac].deficit += sta->airtime_weight;\n\t\tlist_move_tail(&iter->schedule_order, &local->active_txqs[ac]);\n\t}\n\n\tsta = container_of(txqi->txq.sta, struct sta_info, sta);\n\tif (sta->airtime[ac].deficit >= 0)\n\t\tgoto out;\n\n\tsta->airtime[ac].deficit += sta->airtime_weight;\n\tlist_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\n\treturn false;\nout:\n\tif (!list_empty(&txqi->schedule_order))\n\t\tlist_del_init(&txqi->schedule_order);\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_txq_may_transmit);\n\nvoid ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\tlocal->schedule_round[ac]++;\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n}\nEXPORT_SYMBOL(ieee80211_txq_schedule_start);\n\nvoid __ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  u32 info_flags,\n\t\t\t\t  u32 ctrl_flags,\n\t\t\t\t  u64 *cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct sk_buff *next;\n\n\tif (unlikely(skb->len < ETH_HLEN)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta))\n\t\tgoto out_free;\n\n\tif (IS_ERR(sta))\n\t\tsta = NULL;\n\n\tif (local->ops->wake_tx_queue) {\n\t\tu16 queue = __ieee80211_select_queue(sdata, sta, skb);\n\t\tskb_set_queue_mapping(skb, queue);\n\t\tskb_get_hash(skb);\n\t}\n\n\tif (sta) {\n\t\tstruct ieee80211_fast_tx *fast_tx;\n\n\t\tsk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);\n\n\t\tfast_tx = rcu_dereference(sta->fast_tx);\n\n\t\tif (fast_tx &&\n\t\t    ieee80211_xmit_fast(sdata, sta, fast_tx, skb))\n\t\t\tgoto out;\n\t}\n\n\tif (skb_is_gso(skb)) {\n\t\tstruct sk_buff *segs;\n\n\t\tsegs = skb_gso_segment(skb, 0);\n\t\tif (IS_ERR(segs)) {\n\t\t\tgoto out_free;\n\t\t} else if (segs) {\n\t\t\tconsume_skb(skb);\n\t\t\tskb = segs;\n\t\t}\n\t} else {\n\t\t/* we cannot process non-linear frames on this path */\n\t\tif (skb_linearize(skb)) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* the frame could be fragmented, software-encrypted, and other\n\t\t * things so we cannot really handle checksum offload with it -\n\t\t * fix it up in software before we handle anything else.\n\t\t */\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tskb_set_transport_header(skb,\n\t\t\t\t\t\t skb_checksum_start_offset(skb));\n\t\t\tif (skb_checksum_help(skb))\n\t\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tskb_list_walk_safe(skb, skb, next) {\n\t\tskb_mark_not_on_list(skb);\n\n\t\tif (skb->protocol == sdata->control_port_protocol)\n\t\t\tctrl_flags |= IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP;\n\n\t\tskb = ieee80211_build_hdr(sdata, skb, info_flags,\n\t\t\t\t\t  sta, ctrl_flags, cookie);\n\t\tif (IS_ERR(skb)) {\n\t\t\tkfree_skb_list(next);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev_sw_netstats_tx_add(dev, 1, skb->len);\n\n\t\tieee80211_xmit(sdata, sta, skb);\n\t}\n\tgoto out;\n out_free:\n\tkfree_skb(skb);\n out:\n\trcu_read_unlock();\n}\n\nstatic int ieee80211_change_da(struct sk_buff *skb, struct sta_info *sta)\n{\n\tstruct ethhdr *eth;\n\tint err;\n\n\terr = skb_ensure_writable(skb, ETH_HLEN);\n\tif (unlikely(err))\n\t\treturn err;\n\n\teth = (void *)skb->data;\n\tether_addr_copy(eth->h_dest, sta->sta.addr);\n\n\treturn 0;\n}\n\nstatic bool ieee80211_multicast_to_unicast(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tconst struct ethhdr *eth = (void *)skb->data;\n\tconst struct vlan_ethhdr *ethvlan = (void *)skb->data;\n\t__be16 ethertype;\n\n\tif (likely(!is_multicast_ether_addr(eth->h_dest)))\n\t\treturn false;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (sdata->u.vlan.sta)\n\t\t\treturn false;\n\t\tif (sdata->wdev.use_4addr)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\t/* check runtime toggle for this bss */\n\t\tif (!sdata->bss->multicast_to_unicast)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/* multicast to unicast conversion only for some payload */\n\tethertype = eth->h_proto;\n\tif (ethertype == htons(ETH_P_8021Q) && skb->len >= VLAN_ETH_HLEN)\n\t\tethertype = ethvlan->h_vlan_encapsulated_proto;\n\tswitch (ethertype) {\n\tcase htons(ETH_P_ARP):\n\tcase htons(ETH_P_IP):\n\tcase htons(ETH_P_IPV6):\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void\nieee80211_convert_to_unicast(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     struct sk_buff_head *queue)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tconst struct ethhdr *eth = (struct ethhdr *)skb->data;\n\tstruct sta_info *sta, *first = NULL;\n\tstruct sk_buff *cloned_skb;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\t/* AP-VLAN mismatch */\n\t\t\tcontinue;\n\t\tif (unlikely(ether_addr_equal(eth->h_source, sta->sta.addr)))\n\t\t\t/* do not send back to source */\n\t\t\tcontinue;\n\t\tif (!first) {\n\t\t\tfirst = sta;\n\t\t\tcontinue;\n\t\t}\n\t\tcloned_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!cloned_skb)\n\t\t\tgoto multicast;\n\t\tif (unlikely(ieee80211_change_da(cloned_skb, sta))) {\n\t\t\tdev_kfree_skb(cloned_skb);\n\t\t\tgoto multicast;\n\t\t}\n\t\t__skb_queue_tail(queue, cloned_skb);\n\t}\n\n\tif (likely(first)) {\n\t\tif (unlikely(ieee80211_change_da(skb, first)))\n\t\t\tgoto multicast;\n\t\t__skb_queue_tail(queue, skb);\n\t} else {\n\t\t/* no STA connected, drop */\n\t\tkfree_skb(skb);\n\t\tskb = NULL;\n\t}\n\n\tgoto out;\nmulticast:\n\t__skb_queue_purge(queue);\n\t__skb_queue_tail(queue, skb);\nout:\n\trcu_read_unlock();\n}\n\n/**\n * ieee80211_subif_start_xmit - netif start_xmit function for 802.3 vifs\n * @skb: packet to be sent\n * @dev: incoming interface\n *\n * On failure skb will be freed.\n */\nnetdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tif (unlikely(ieee80211_multicast_to_unicast(skb, dev))) {\n\t\tstruct sk_buff_head queue;\n\n\t\t__skb_queue_head_init(&queue);\n\t\tieee80211_convert_to_unicast(skb, dev, &queue);\n\t\twhile ((skb = __skb_dequeue(&queue)))\n\t\t\t__ieee80211_subif_start_xmit(skb, dev, 0, 0, NULL);\n\t} else {\n\t\t__ieee80211_subif_start_xmit(skb, dev, 0, 0, NULL);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic bool ieee80211_tx_8023(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, int led_len,\n\t\t\t      struct sta_info *sta,\n\t\t\t      bool txpending)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_control control = {};\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sta *pubsta = NULL;\n\tunsigned long flags;\n\tint q = info->hw_queue;\n\n\tif (sta)\n\t\tsk_pacing_shift_update(skb->sk, local->hw.tx_sk_pacing_shift);\n\n\tif (ieee80211_queue_skb(local, sdata, sta, skb))\n\t\treturn true;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\n\tif (local->queue_stop_reasons[q] ||\n\t    (!txpending && !skb_queue_empty(&local->pending[q]))) {\n\t\tif (txpending)\n\t\t\tskb_queue_head(&local->pending[q], skb);\n\t\telse\n\t\t\tskb_queue_tail(&local->pending[q], skb);\n\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\t\treturn false;\n\t}\n\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\tif (sta && sta->uploaded)\n\t\tpubsta = &sta->sta;\n\n\tcontrol.sta = pubsta;\n\n\tdrv_tx(local, &control, skb);\n\n\treturn true;\n}\n\nstatic void ieee80211_8023_xmit(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct net_device *dev, struct sta_info *sta,\n\t\t\t\tstruct ieee80211_key *key, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct tid_ampdu_tx *tid_tx;\n\tu8 tid;\n\n\tif (local->ops->wake_tx_queue) {\n\t\tu16 queue = __ieee80211_select_queue(sdata, sta, skb);\n\t\tskb_set_queue_mapping(skb, queue);\n\t\tskb_get_hash(skb);\n\t}\n\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state))\n\t\tgoto out_free;\n\n\tmemset(info, 0, sizeof(*info));\n\n\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\tif (tid_tx) {\n\t\tif (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\t/* fall back to non-offload slow path */\n\t\t\t__ieee80211_subif_start_xmit(skb, dev, 0, 0, NULL);\n\t\t\treturn;\n\t\t}\n\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\tif (tid_tx->timeout)\n\t\t\ttid_tx->last_tx = jiffies;\n\t}\n\n\tif (unlikely(skb->sk &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS))\n\t\tinfo->ack_frame_id = ieee80211_store_ack_skb(local, skb,\n\t\t\t\t\t\t\t     &info->flags, NULL);\n\n\tinfo->hw_queue = sdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\tdev_sw_netstats_tx_add(dev, 1, skb->len);\n\n\tsta->tx_stats.bytes[skb_get_queue_mapping(skb)] += skb->len;\n\tsta->tx_stats.packets[skb_get_queue_mapping(skb)]++;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\n\tinfo->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;\n\tinfo->control.vif = &sdata->vif;\n\n\tif (key)\n\t\tinfo->control.hw_key = &key->conf;\n\n\tieee80211_tx_8023(sdata, skb, skb->len, sta, false);\n\n\treturn;\n\nout_free:\n\tkfree_skb(skb);\n}\n\nnetdev_tx_t ieee80211_subif_start_xmit_8023(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ethhdr *ehdr = (struct ethhdr *)skb->data;\n\tstruct ieee80211_key *key;\n\tstruct sta_info *sta;\n\n\tif (unlikely(skb->len < ETH_HLEN)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_ERR_OR_NULL(sta) || !sta->uploaded ||\n\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED) ||\n\t    sdata->control_port_protocol == ehdr->h_proto))\n\t\tgoto skip_offload;\n\n\tkey = rcu_dereference(sta->ptk[sta->ptk_idx]);\n\tif (!key)\n\t\tkey = rcu_dereference(sdata->default_unicast_key);\n\n\tif (key && (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE) ||\n\t\t    key->conf.cipher == WLAN_CIPHER_SUITE_TKIP))\n\t\tgoto skip_offload;\n\n\tieee80211_8023_xmit(sdata, dev, sta, key, skb);\n\tgoto out;\n\nskip_offload:\n\tieee80211_subif_start_xmit(skb, dev);\nout:\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n}\n\nstruct sk_buff *\nieee80211_build_data_template(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, u32 info_flags)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_data tx = {\n\t\t.local = sdata->local,\n\t\t.sdata = sdata,\n\t};\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {\n\t\tkfree_skb(skb);\n\t\tskb = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tskb = ieee80211_build_hdr(sdata, skb, info_flags, sta, 0, NULL);\n\tif (IS_ERR(skb))\n\t\tgoto out;\n\n\thdr = (void *)skb->data;\n\ttx.sta = sta_info_get(sdata, hdr->addr1);\n\ttx.skb = skb;\n\n\tif (ieee80211_tx_h_select_key(&tx) != TX_CONTINUE) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn skb;\n}\n\n/*\n * ieee80211_clear_tx_pending may not be called in a context where\n * it is possible that it packets could come in again.\n */\nvoid ieee80211_clear_tx_pending(struct ieee80211_local *local)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\twhile ((skb = skb_dequeue(&local->pending[i])) != NULL)\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n}\n\n/*\n * Returns false if the frame couldn't be transmitted but was queued instead,\n * which in this case means re-queued -- take as an indication to stop sending\n * more pending frames.\n */\nstatic bool ieee80211_tx_pending_skb(struct ieee80211_local *local,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\tstruct ieee80211_hdr *hdr;\n\tbool result;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(info->control.vif);\n\n\tif (info->control.flags & IEEE80211_TX_INTCFL_NEED_TXPROCESSING) {\n\t\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\t\tif (unlikely(!chanctx_conf)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn true;\n\t\t}\n\t\tinfo->band = chanctx_conf->def.chan->band;\n\t\tresult = ieee80211_tx(sdata, NULL, skb, true);\n\t} else if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {\n\t\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (IS_ERR(sta) || (sta && !sta->uploaded))\n\t\t\tsta = NULL;\n\n\t\tresult = ieee80211_tx_8023(sdata, skb, skb->len, sta, true);\n\t} else {\n\t\tstruct sk_buff_head skbs;\n\n\t\t__skb_queue_head_init(&skbs);\n\t\t__skb_queue_tail(&skbs, skb);\n\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tsta = sta_info_get(sdata, hdr->addr1);\n\n\t\tresult = __ieee80211_tx(local, &skbs, skb->len, sta, true);\n\t}\n\n\treturn result;\n}\n\n/*\n * Transmit all pending packets. Called from tasklet.\n */\nvoid ieee80211_tx_pending(struct tasklet_struct *t)\n{\n\tstruct ieee80211_local *local = from_tasklet(local, t,\n\t\t\t\t\t\t     tx_pending_tasklet);\n\tunsigned long flags;\n\tint i;\n\tbool txok;\n\n\trcu_read_lock();\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\t/*\n\t\t * If queue is stopped by something other than due to pending\n\t\t * frames, or we have no pending frames, proceed to next queue.\n\t\t */\n\t\tif (local->queue_stop_reasons[i] ||\n\t\t    skb_queue_empty(&local->pending[i]))\n\t\t\tcontinue;\n\n\t\twhile (!skb_queue_empty(&local->pending[i])) {\n\t\t\tstruct sk_buff *skb = __skb_dequeue(&local->pending[i]);\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\t\tif (WARN_ON(!info->control.vif)) {\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\n\t\t\ttxok = ieee80211_tx_pending_skb(local, skb);\n\t\t\tspin_lock_irqsave(&local->queue_stop_reason_lock,\n\t\t\t\t\t  flags);\n\t\t\tif (!txok)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (skb_queue_empty(&local->pending[i]))\n\t\t\tieee80211_propagate_queue_wake(local, i);\n\t}\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\trcu_read_unlock();\n}\n\n/* functions for drivers to get certain frames */\n\nstatic void __ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ps_data *ps, struct sk_buff *skb,\n\t\t\t\t       bool is_template)\n{\n\tu8 *pos, *tim;\n\tint aid0 = 0;\n\tint i, have_bits = 0, n1, n2;\n\n\t/* Generate bitmap for TIM only if there are any STAs in power save\n\t * mode. */\n\tif (atomic_read(&ps->num_sta_ps) > 0)\n\t\t/* in the hope that this is faster than\n\t\t * checking byte-for-byte */\n\t\thave_bits = !bitmap_empty((unsigned long *)ps->tim,\n\t\t\t\t\t  IEEE80211_MAX_AID+1);\n\tif (!is_template) {\n\t\tif (ps->dtim_count == 0)\n\t\t\tps->dtim_count = sdata->vif.bss_conf.dtim_period - 1;\n\t\telse\n\t\t\tps->dtim_count--;\n\t}\n\n\ttim = pos = skb_put(skb, 6);\n\t*pos++ = WLAN_EID_TIM;\n\t*pos++ = 4;\n\t*pos++ = ps->dtim_count;\n\t*pos++ = sdata->vif.bss_conf.dtim_period;\n\n\tif (ps->dtim_count == 0 && !skb_queue_empty(&ps->bc_buf))\n\t\taid0 = 1;\n\n\tps->dtim_bc_mc = aid0 == 1;\n\n\tif (have_bits) {\n\t\t/* Find largest even number N1 so that bits numbered 1 through\n\t\t * (N1 x 8) - 1 in the bitmap are 0 and number N2 so that bits\n\t\t * (N2 + 1) x 8 through 2007 are 0. */\n\t\tn1 = 0;\n\t\tfor (i = 0; i < IEEE80211_MAX_TIM_LEN; i++) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn1 = i & 0xfe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn2 = n1;\n\t\tfor (i = IEEE80211_MAX_TIM_LEN - 1; i >= n1; i--) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* Bitmap control */\n\t\t*pos++ = n1 | aid0;\n\t\t/* Part Virt Bitmap */\n\t\tskb_put(skb, n2 - n1);\n\t\tmemcpy(pos, ps->tim + n1, n2 - n1 + 1);\n\n\t\ttim[1] = n2 - n1 + 4;\n\t} else {\n\t\t*pos++ = aid0; /* Bitmap control */\n\t\t*pos++ = 0; /* Part Virt Bitmap */\n\t}\n}\n\nstatic int ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ps_data *ps, struct sk_buff *skb,\n\t\t\t\t    bool is_template)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\t/*\n\t * Not very nice, but we want to allow the driver to call\n\t * ieee80211_beacon_get() as a response to the set_tim()\n\t * callback. That, however, is already invoked under the\n\t * sta_lock to guarantee consistent and race-free update\n\t * of the tim bitmap in mac80211 and the driver.\n\t */\n\tif (local->tim_in_locked_section) {\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb, is_template);\n\t} else {\n\t\tspin_lock_bh(&local->tim_lock);\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb, is_template);\n\t\tspin_unlock_bh(&local->tim_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic void ieee80211_set_beacon_cntdwn(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct beacon_data *beacon)\n{\n\tstruct probe_resp *resp;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\tint i;\n\tu8 count = beacon->cntdwn_current_counter;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tfor (i = 0; i < IEEE80211_MAX_CNTDWN_COUNTERS_NUM; ++i) {\n\t\tresp = rcu_dereference(sdata->u.ap.probe_resp);\n\n\t\tif (beacon->cntdwn_counter_offsets[i]) {\n\t\t\tif (WARN_ON_ONCE(beacon->cntdwn_counter_offsets[i] >=\n\t\t\t\t\t beacon_data_len)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbeacon_data[beacon->cntdwn_counter_offsets[i]] = count;\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP && resp)\n\t\t\tresp->data[resp->cntdwn_counter_offsets[i]] = count;\n\t}\n\trcu_read_unlock();\n}\n\nstatic u8 __ieee80211_beacon_update_cntdwn(struct beacon_data *beacon)\n{\n\tbeacon->cntdwn_current_counter--;\n\n\t/* the counter should never reach 0 */\n\tWARN_ON_ONCE(!beacon->cntdwn_current_counter);\n\n\treturn beacon->cntdwn_current_counter;\n}\n\nu8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\tu8 count = 0;\n\n\trcu_read_lock();\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tbeacon = rcu_dereference(sdata->u.ap.beacon);\n\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tbeacon = rcu_dereference(sdata->u.ibss.presp);\n\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tbeacon = rcu_dereference(sdata->u.mesh.beacon);\n\n\tif (!beacon)\n\t\tgoto unlock;\n\n\tcount = __ieee80211_beacon_update_cntdwn(beacon);\n\nunlock:\n\trcu_read_unlock();\n\treturn count;\n}\nEXPORT_SYMBOL(ieee80211_beacon_update_cntdwn);\n\nvoid ieee80211_beacon_set_cntdwn(struct ieee80211_vif *vif, u8 counter)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\n\trcu_read_lock();\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tbeacon = rcu_dereference(sdata->u.ap.beacon);\n\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tbeacon = rcu_dereference(sdata->u.ibss.presp);\n\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tbeacon = rcu_dereference(sdata->u.mesh.beacon);\n\n\tif (!beacon)\n\t\tgoto unlock;\n\n\tif (counter < beacon->cntdwn_current_counter)\n\t\tbeacon->cntdwn_current_counter = counter;\n\nunlock:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_beacon_set_cntdwn);\n\nbool ieee80211_beacon_cntdwn_is_complete(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\tint ret = false;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_if_ap *ap = &sdata->u.ap;\n\n\t\tbeacon = rcu_dereference(ap->beacon);\n\t\tif (WARN_ON(!beacon || !beacon->tail))\n\t\t\tgoto out;\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t} else if (vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\n\t\tbeacon = rcu_dereference(ifibss->presp);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else if (vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\tbeacon = rcu_dereference(ifmsh->beacon);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\tif (!beacon->cntdwn_counter_offsets[0])\n\t\tgoto out;\n\n\tif (WARN_ON_ONCE(beacon->cntdwn_counter_offsets[0] > beacon_data_len))\n\t\tgoto out;\n\n\tif (beacon_data[beacon->cntdwn_counter_offsets[0]] == 1)\n\t\tret = true;\n\n out:\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_beacon_cntdwn_is_complete);\n\nstatic int ieee80211_beacon_protect(struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_local *local,\n\t\t\t\t    struct ieee80211_sub_if_data *sdata)\n{\n\tieee80211_tx_result res;\n\tstruct ieee80211_tx_data tx;\n\tstruct sk_buff *check_skb;\n\n\tmemset(&tx, 0, sizeof(tx));\n\ttx.key = rcu_dereference(sdata->default_beacon_key);\n\tif (!tx.key)\n\t\treturn 0;\n\ttx.local = local;\n\ttx.sdata = sdata;\n\t__skb_queue_head_init(&tx.skbs);\n\t__skb_queue_tail(&tx.skbs, skb);\n\tres = ieee80211_tx_h_encrypt(&tx);\n\tcheck_skb = __skb_dequeue(&tx.skbs);\n\t/* we may crash after this, but it'd be a bug in crypto */\n\tWARN_ON(check_skb != skb);\n\tif (WARN_ON_ONCE(res != TX_CONTINUE))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct sk_buff *\n__ieee80211_beacon_get(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif,\n\t\t       struct ieee80211_mutable_offsets *offs,\n\t\t       bool is_template)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct beacon_data *beacon = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sub_if_data *sdata = NULL;\n\tenum nl80211_band band;\n\tstruct ieee80211_tx_rate_control txrc;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tint csa_off_base = 0;\n\n\trcu_read_lock();\n\n\tsdata = vif_to_sdata(vif);\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\n\tif (!ieee80211_sdata_running(sdata) || !chanctx_conf)\n\t\tgoto out;\n\n\tif (offs)\n\t\tmemset(offs, 0, sizeof(*offs));\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_if_ap *ap = &sdata->u.ap;\n\n\t\tbeacon = rcu_dereference(ap->beacon);\n\t\tif (beacon) {\n\t\t\tif (beacon->cntdwn_counter_offsets[0]) {\n\t\t\t\tif (!is_template)\n\t\t\t\t\tieee80211_beacon_update_cntdwn(vif);\n\n\t\t\t\tieee80211_set_beacon_cntdwn(sdata, beacon);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * headroom, head length,\n\t\t\t * tail length and maximum TIM length\n\t\t\t */\n\t\t\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t\t    beacon->head_len +\n\t\t\t\t\t    beacon->tail_len + 256 +\n\t\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\t\tif (!skb)\n\t\t\t\tgoto out;\n\n\t\t\tskb_reserve(skb, local->tx_headroom);\n\t\t\tskb_put_data(skb, beacon->head, beacon->head_len);\n\n\t\t\tieee80211_beacon_add_tim(sdata, &ap->ps, skb,\n\t\t\t\t\t\t is_template);\n\n\t\t\tif (offs) {\n\t\t\t\toffs->tim_offset = beacon->head_len;\n\t\t\t\toffs->tim_length = skb->len - beacon->head_len;\n\n\t\t\t\t/* for AP the csa offsets are from tail */\n\t\t\t\tcsa_off_base = skb->len;\n\t\t\t}\n\n\t\t\tif (beacon->tail)\n\t\t\t\tskb_put_data(skb, beacon->tail,\n\t\t\t\t\t     beacon->tail_len);\n\n\t\t\tif (ieee80211_beacon_protect(skb, local, sdata) < 0)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tgoto out;\n\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\t\tstruct ieee80211_hdr *hdr;\n\n\t\tbeacon = rcu_dereference(ifibss->presp);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tif (beacon->cntdwn_counter_offsets[0]) {\n\t\t\tif (!is_template)\n\t\t\t\t__ieee80211_beacon_update_cntdwn(beacon);\n\n\t\t\tieee80211_set_beacon_cntdwn(sdata, beacon);\n\t\t}\n\n\t\tskb = dev_alloc_skb(local->tx_headroom + beacon->head_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tskb_put_data(skb, beacon->head, beacon->head_len);\n\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t IEEE80211_STYPE_BEACON);\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\tbeacon = rcu_dereference(ifmsh->beacon);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tif (beacon->cntdwn_counter_offsets[0]) {\n\t\t\tif (!is_template)\n\t\t\t\t/* TODO: For mesh csa_counter is in TU, so\n\t\t\t\t * decrementing it by one isn't correct, but\n\t\t\t\t * for now we leave it consistent with overall\n\t\t\t\t * mac80211's behavior.\n\t\t\t\t */\n\t\t\t\t__ieee80211_beacon_update_cntdwn(beacon);\n\n\t\t\tieee80211_set_beacon_cntdwn(sdata, beacon);\n\t\t}\n\n\t\tif (ifmsh->sync_ops)\n\t\t\tifmsh->sync_ops->adjust_tsf(sdata, beacon);\n\n\t\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    beacon->head_len +\n\t\t\t\t    256 + /* TIM IE */\n\t\t\t\t    beacon->tail_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tskb_put_data(skb, beacon->head, beacon->head_len);\n\t\tieee80211_beacon_add_tim(sdata, &ifmsh->ps, skb, is_template);\n\n\t\tif (offs) {\n\t\t\toffs->tim_offset = beacon->head_len;\n\t\t\toffs->tim_length = skb->len - beacon->head_len;\n\t\t}\n\n\t\tskb_put_data(skb, beacon->tail, beacon->tail_len);\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\t/* CSA offsets */\n\tif (offs && beacon) {\n\t\tint i;\n\n\t\tfor (i = 0; i < IEEE80211_MAX_CNTDWN_COUNTERS_NUM; i++) {\n\t\t\tu16 csa_off = beacon->cntdwn_counter_offsets[i];\n\n\t\t\tif (!csa_off)\n\t\t\t\tcontinue;\n\n\t\t\toffs->cntdwn_counter_offs[i] = csa_off_base + csa_off;\n\t\t}\n\t}\n\n\tband = chanctx_conf->def.chan->band;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\tinfo->band = band;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\ttxrc.hw = hw;\n\ttxrc.sband = local->hw.wiphy->bands[band];\n\ttxrc.bss_conf = &sdata->vif.bss_conf;\n\ttxrc.skb = skb;\n\ttxrc.reported_rate.idx = -1;\n\tif (sdata->beacon_rate_set && sdata->beacon_rateidx_mask[band])\n\t\ttxrc.rate_idx_mask = sdata->beacon_rateidx_mask[band];\n\telse\n\t\ttxrc.rate_idx_mask = sdata->rc_rateidx_mask[band];\n\ttxrc.bss = true;\n\trate_control_get_rate(sdata, NULL, &txrc);\n\n\tinfo->control.vif = vif;\n\n\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\tIEEE80211_TX_CTL_ASSIGN_SEQ |\n\t\t\tIEEE80211_TX_CTL_FIRST_FRAGMENT;\n out:\n\trcu_read_unlock();\n\treturn skb;\n\n}\n\nstruct sk_buff *\nieee80211_beacon_get_template(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_mutable_offsets *offs)\n{\n\treturn __ieee80211_beacon_get(hw, vif, offs, true);\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_template);\n\nstruct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u16 *tim_offset, u16 *tim_length)\n{\n\tstruct ieee80211_mutable_offsets offs = {};\n\tstruct sk_buff *bcn = __ieee80211_beacon_get(hw, vif, &offs, false);\n\tstruct sk_buff *copy;\n\tstruct ieee80211_supported_band *sband;\n\tint shift;\n\n\tif (!bcn)\n\t\treturn bcn;\n\n\tif (tim_offset)\n\t\t*tim_offset = offs.tim_offset;\n\n\tif (tim_length)\n\t\t*tim_length = offs.tim_length;\n\n\tif (ieee80211_hw_check(hw, BEACON_TX_STATUS) ||\n\t    !hw_to_local(hw)->monitors)\n\t\treturn bcn;\n\n\t/* send a copy to monitor interfaces */\n\tcopy = skb_copy(bcn, GFP_ATOMIC);\n\tif (!copy)\n\t\treturn bcn;\n\n\tshift = ieee80211_vif_get_shift(vif);\n\tsband = ieee80211_get_sband(vif_to_sdata(vif));\n\tif (!sband)\n\t\treturn bcn;\n\n\tieee80211_tx_monitor(hw_to_local(hw), copy, sband, 1, shift, false,\n\t\t\t     NULL);\n\n\treturn bcn;\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_tim);\n\nstruct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ieee80211_if_ap *ap = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct probe_resp *presp = NULL;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\n\tap = &sdata->u.ap;\n\tpresp = rcu_dereference(ap->probe_resp);\n\tif (!presp)\n\t\tgoto out;\n\n\tskb = dev_alloc_skb(presp->len);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb_put_data(skb, presp->data, presp->len);\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tmemset(hdr->addr1, 0, sizeof(hdr->addr1));\n\nout:\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_proberesp_get);\n\nstruct sk_buff *ieee80211_get_fils_discovery_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct fils_discovery_data *tmpl = NULL;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttmpl = rcu_dereference(sdata->u.ap.fils_discovery);\n\tif (!tmpl) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\tskb = dev_alloc_skb(sdata->local->hw.extra_tx_headroom + tmpl->len);\n\tif (skb) {\n\t\tskb_reserve(skb, sdata->local->hw.extra_tx_headroom);\n\t\tskb_put_data(skb, tmpl->data, tmpl->len);\n\t}\n\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_fils_discovery_tmpl);\n\nstruct sk_buff *\nieee80211_get_unsol_bcast_probe_resp_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct unsol_bcast_probe_resp_data *tmpl = NULL;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttmpl = rcu_dereference(sdata->u.ap.unsol_bcast_probe_resp);\n\tif (!tmpl) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\tskb = dev_alloc_skb(sdata->local->hw.extra_tx_headroom + tmpl->len);\n\tif (skb) {\n\t\tskb_reserve(skb, sdata->local->hw.extra_tx_headroom);\n\t\tskb_put_data(skb, tmpl->data, tmpl->len);\n\t}\n\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_unsol_bcast_probe_resp_tmpl);\n\nstruct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_pspoll *pspoll;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tifmgd = &sdata->u.mgd;\n\tlocal = sdata->local;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*pspoll));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tpspoll = skb_put_zero(skb, sizeof(*pspoll));\n\tpspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t    IEEE80211_STYPE_PSPOLL);\n\tpspoll->aid = cpu_to_le16(sdata->vif.bss_conf.aid);\n\n\t/* aid in PS-Poll has its two MSBs each set to 1 */\n\tpspoll->aid |= cpu_to_le16(1 << 15 | 1 << 14);\n\n\tmemcpy(pspoll->bssid, ifmgd->bssid, ETH_ALEN);\n\tmemcpy(pspoll->ta, vif->addr, ETH_ALEN);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_pspoll_get);\n\nstruct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       bool qos_ok)\n{\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\tbool qos = false;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tifmgd = &sdata->u.mgd;\n\tlocal = sdata->local;\n\n\tif (qos_ok) {\n\t\tstruct sta_info *sta;\n\n\t\trcu_read_lock();\n\t\tsta = sta_info_get(sdata, ifmgd->bssid);\n\t\tqos = sta && sta->sta.wme;\n\t\trcu_read_unlock();\n\t}\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom +\n\t\t\t    sizeof(*nullfunc) + 2);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = skb_put_zero(skb, sizeof(*nullfunc));\n\tnullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t      IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t      IEEE80211_FCTL_TODS);\n\tif (qos) {\n\t\t__le16 qoshdr = cpu_to_le16(7);\n\n\t\tBUILD_BUG_ON((IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t      IEEE80211_STYPE_NULLFUNC) !=\n\t\t\t     IEEE80211_STYPE_QOS_NULLFUNC);\n\t\tnullfunc->frame_control |=\n\t\t\tcpu_to_le16(IEEE80211_STYPE_QOS_NULLFUNC);\n\t\tskb->priority = 7;\n\t\tskb_set_queue_mapping(skb, IEEE80211_AC_VO);\n\t\tskb_put_data(skb, &qoshdr, sizeof(qoshdr));\n\t}\n\n\tmemcpy(nullfunc->addr1, ifmgd->bssid, ETH_ALEN);\n\tmemcpy(nullfunc->addr2, vif->addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, ifmgd->bssid, ETH_ALEN);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_nullfunc_get);\n\nstruct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t       const u8 *src_addr,\n\t\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t\t       size_t tailroom)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_hdr_3addr *hdr;\n\tstruct sk_buff *skb;\n\tsize_t ie_ssid_len;\n\tu8 *pos;\n\n\tie_ssid_len = 2 + ssid_len;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*hdr) +\n\t\t\t    ie_ssid_len + tailroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\thdr = skb_put_zero(skb, sizeof(*hdr));\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t IEEE80211_STYPE_PROBE_REQ);\n\teth_broadcast_addr(hdr->addr1);\n\tmemcpy(hdr->addr2, src_addr, ETH_ALEN);\n\teth_broadcast_addr(hdr->addr3);\n\n\tpos = skb_put(skb, ie_ssid_len);\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = ssid_len;\n\tif (ssid_len)\n\t\tmemcpy(pos, ssid, ssid_len);\n\tpos += ssid_len;\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_probereq_get);\n\nvoid ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       const void *frame, size_t frame_len,\n\t\t       const struct ieee80211_tx_info *frame_txctl,\n\t\t       struct ieee80211_rts *rts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\trts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);\n\trts->duration = ieee80211_rts_duration(hw, vif, frame_len,\n\t\t\t\t\t       frame_txctl);\n\tmemcpy(rts->ra, hdr->addr1, sizeof(rts->ra));\n\tmemcpy(rts->ta, hdr->addr2, sizeof(rts->ta));\n}\nEXPORT_SYMBOL(ieee80211_rts_get);\n\nvoid ieee80211_ctstoself_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     const void *frame, size_t frame_len,\n\t\t\t     const struct ieee80211_tx_info *frame_txctl,\n\t\t\t     struct ieee80211_cts *cts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\tcts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);\n\tcts->duration = ieee80211_ctstoself_duration(hw, vif,\n\t\t\t\t\t\t     frame_len, frame_txctl);\n\tmemcpy(cts->ra, hdr->addr1, sizeof(cts->ra));\n}\nEXPORT_SYMBOL(ieee80211_ctstoself_get);\n\nstruct sk_buff *\nieee80211_get_buffered_bc(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_data tx;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ps_data *ps;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(vif);\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\n\tif (!chanctx_conf)\n\t\tgoto out;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct beacon_data *beacon =\n\t\t\t\trcu_dereference(sdata->u.ap.beacon);\n\n\t\tif (!beacon || !beacon->head)\n\t\t\tgoto out;\n\n\t\tps = &sdata->u.ap.ps;\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tps = &sdata->u.mesh.ps;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (ps->dtim_count != 0 || !ps->dtim_bc_mc)\n\t\tgoto out; /* send buffered bc/mc only after DTIM beacon */\n\n\twhile (1) {\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tlocal->total_ps_buffered--;\n\n\t\tif (!skb_queue_empty(&ps->bc_buf) && skb->len >= 2) {\n\t\t\tstruct ieee80211_hdr *hdr =\n\t\t\t\t(struct ieee80211_hdr *) skb->data;\n\t\t\t/* more buffered multicast/broadcast frames ==> set\n\t\t\t * MoreData flag in IEEE 802.11 header to inform PS\n\t\t\t * STAs */\n\t\t\thdr->frame_control |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tsdata = IEEE80211_DEV_TO_SUB_IF(skb->dev);\n\t\tif (!ieee80211_tx_prepare(sdata, &tx, NULL, skb))\n\t\t\tbreak;\n\t\tieee80211_free_txskb(hw, skb);\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\ttx.flags |= IEEE80211_TX_PS_BUFFERED;\n\tinfo->band = chanctx_conf->def.chan->band;\n\n\tif (invoke_tx_handlers(&tx))\n\t\tskb = NULL;\n out:\n\trcu_read_unlock();\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_buffered_bc);\n\nint ieee80211_reserve_tid(struct ieee80211_sta *pubsta, u8 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret;\n\tu32 queues;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/* only some cases are supported right now */\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(tid >= IEEE80211_NUM_UPS))\n\t\treturn -EINVAL;\n\n\tif (sta->reserved_tid == tid) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (sta->reserved_tid != IEEE80211_TID_UNRESERVED) {\n\t\tsdata_err(sdata, \"TID reservation already active\\n\");\n\t\tret = -EALREADY;\n\t\tgoto out;\n\t}\n\n\tieee80211_stop_vif_queues(sdata->local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_RESERVE_TID);\n\n\tsynchronize_net();\n\n\t/* Tear down BA sessions so we stop aggregating on this TID */\n\tif (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION)) {\n\t\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\t\t__ieee80211_stop_tx_ba_session(sta, tid,\n\t\t\t\t\t       AGG_STOP_LOCAL_REQUEST);\n\t}\n\n\tqueues = BIT(sdata->vif.hw_queue[ieee802_1d_to_ac[tid]]);\n\t__ieee80211_flush_queues(local, sdata, queues, false);\n\n\tsta->reserved_tid = tid;\n\n\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_RESERVE_TID);\n\n\tif (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION))\n\t\tclear_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\n\tret = 0;\n out:\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_reserve_tid);\n\nvoid ieee80211_unreserve_tid(struct ieee80211_sta *pubsta, u8 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\tlockdep_assert_held(&sdata->local->sta_mtx);\n\n\t/* only some cases are supported right now */\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (tid != sta->reserved_tid) {\n\t\tsdata_err(sdata, \"TID to unreserve (%d) isn't reserved\\n\", tid);\n\t\treturn;\n\t}\n\n\tsta->reserved_tid = IEEE80211_TID_UNRESERVED;\n}\nEXPORT_SYMBOL(ieee80211_unreserve_tid);\n\nvoid __ieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb, int tid,\n\t\t\t\t enum nl80211_band band)\n{\n\tint ac = ieee80211_ac_from_tid(tid);\n\n\tskb_reset_mac_header(skb);\n\tskb_set_queue_mapping(skb, ac);\n\tskb->priority = tid;\n\n\tskb->dev = sdata->dev;\n\n\t/*\n\t * The other path calling ieee80211_xmit is from the tasklet,\n\t * and while we can handle concurrent transmissions locking\n\t * requirements are that we do not come into tx with bhs on.\n\t */\n\tlocal_bh_disable();\n\tIEEE80211_SKB_CB(skb)->band = band;\n\tieee80211_xmit(sdata, NULL, skb);\n\tlocal_bh_enable();\n}\n\nint ieee80211_tx_control_port(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len,\n\t\t\t      const u8 *dest, __be16 proto, bool unencrypted,\n\t\t\t      u64 *cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct sk_buff *skb;\n\tstruct ethhdr *ehdr;\n\tu32 ctrl_flags = 0;\n\tu32 flags = 0;\n\n\t/* Only accept CONTROL_PORT_PROTOCOL configured in CONNECT/ASSOCIATE\n\t * or Pre-Authentication\n\t */\n\tif (proto != sdata->control_port_protocol &&\n\t    proto != cpu_to_be16(ETH_P_PREAUTH))\n\t\treturn -EINVAL;\n\n\tif (proto == sdata->control_port_protocol)\n\t\tctrl_flags |= IEEE80211_TX_CTRL_PORT_CTRL_PROTO |\n\t\t\t      IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP;\n\n\tif (unencrypted)\n\t\tflags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\n\tif (cookie)\n\t\tctrl_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\n\tflags |= IEEE80211_TX_INTFL_NL80211_FRAME_TX;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom +\n\t\t\t    sizeof(struct ethhdr) + len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom + sizeof(struct ethhdr));\n\n\tskb_put_data(skb, buf, len);\n\n\tehdr = skb_push(skb, sizeof(struct ethhdr));\n\tmemcpy(ehdr->h_dest, dest, ETH_ALEN);\n\tmemcpy(ehdr->h_source, sdata->vif.addr, ETH_ALEN);\n\tehdr->h_proto = proto;\n\n\tskb->dev = dev;\n\tskb->protocol = proto;\n\tskb_reset_network_header(skb);\n\tskb_reset_mac_header(skb);\n\n\t/* update QoS header to prioritize control port frames if possible,\n\t * priorization also happens for control port frames send over\n\t * AF_PACKET\n\t */\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta) == 0 && !IS_ERR(sta)) {\n\t\tu16 queue = __ieee80211_select_queue(sdata, sta, skb);\n\n\t\tskb_set_queue_mapping(skb, queue);\n\t\tskb_get_hash(skb);\n\t}\n\n\trcu_read_unlock();\n\n\t/* mutex lock is only needed for incrementing the cookie counter */\n\tmutex_lock(&local->mtx);\n\n\tlocal_bh_disable();\n\t__ieee80211_subif_start_xmit(skb, skb->dev, flags, ctrl_flags, cookie);\n\tlocal_bh_enable();\n\n\tmutex_unlock(&local->mtx);\n\n\treturn 0;\n}\n\nint ieee80211_probe_mesh_link(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + len +\n\t\t\t    30 + /* header size */\n\t\t\t    18); /* 11s header size */\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tskb_put_data(skb, buf, len);\n\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_802_3);\n\tskb_reset_network_header(skb);\n\tskb_reset_mac_header(skb);\n\n\tlocal_bh_disable();\n\t__ieee80211_subif_start_xmit(skb, skb->dev, 0,\n\t\t\t\t     IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP,\n\t\t\t\t     NULL);\n\tlocal_bh_enable();\n\n\treturn 0;\n}\n"], "filenames": ["include/net/mac80211.h", "net/mac80211/tx.c"], "buggy_code_start_loc": [6395, 2016], "buggy_code_end_loc": [6396, 2352], "fixing_code_start_loc": [6395, 2017], "fixing_code_end_loc": [6401, 2373], "type": "CWE-476", "message": "The mac80211 subsystem in the Linux kernel before 5.12.13, when a device supporting only 5 GHz is used, allows attackers to cause a denial of service (NULL pointer dereference in the radiotap parser) by injecting a frame with 802.11a rates.", "other": {"cve": {"id": "CVE-2021-38206", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.320", "lastModified": "2021-08-12T13:33:43.250", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The mac80211 subsystem in the Linux kernel before 5.12.13, when a device supporting only 5 GHz is used, allows attackers to cause a denial of service (NULL pointer dereference in the radiotap parser) by injecting a frame with 802.11a rates."}, {"lang": "es", "value": "El subsistema mac80211 en el kernel de Linux versiones anteriores a 5.12.13, cuando se utiliza un dispositivo que s\u00f3lo soporta 5 GHz, permite a atacantes causar una denegaci\u00f3n de servicio (desreferencia de puntero NULL en el analizador de radiotap) al inyectar una trama con tasas 802.11a"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.12.13", "matchCriteriaId": "4C096241-6457-4DB4-80C3-DD650F628184"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.12.13", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/bddc0c411a45d3718ac535a070f349be8eca8d48", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bddc0c411a45d3718ac535a070f349be8eca8d48"}}