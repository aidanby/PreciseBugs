{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  Bluetooth Software UART Qualcomm protocol\n *\n *  HCI_IBS (HCI In-Band Sleep) is Qualcomm's power management\n *  protocol extension to H4.\n *\n *  Copyright (C) 2007 Texas Instruments, Inc.\n *  Copyright (c) 2010, 2012, 2018 The Linux Foundation. All rights reserved.\n *\n *  Acknowledgements:\n *  This file is based on hci_ll.c, which was...\n *  Written by Ohad Ben-Cohen <ohad@bencohen.org>\n *  which was in turn based on hci_h4.c, which was written\n *  by Maxim Krasnyansky and Marcel Holtmann.\n */\n\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/devcoredump.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/acpi.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/serdev.h>\n#include <linux/mutex.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n#include \"btqca.h\"\n\n/* HCI_IBS protocol messages */\n#define HCI_IBS_SLEEP_IND\t0xFE\n#define HCI_IBS_WAKE_IND\t0xFD\n#define HCI_IBS_WAKE_ACK\t0xFC\n#define HCI_MAX_IBS_SIZE\t10\n\n#define IBS_WAKE_RETRANS_TIMEOUT_MS\t100\n#define IBS_BTSOC_TX_IDLE_TIMEOUT_MS\t200\n#define IBS_HOST_TX_IDLE_TIMEOUT_MS\t2000\n#define CMD_TRANS_TIMEOUT_MS\t\t100\n#define MEMDUMP_TIMEOUT_MS\t\t8000\n#define IBS_DISABLE_SSR_TIMEOUT_MS \\\n\t(MEMDUMP_TIMEOUT_MS + FW_DOWNLOAD_TIMEOUT_MS)\n#define FW_DOWNLOAD_TIMEOUT_MS\t\t3000\n\n/* susclk rate */\n#define SUSCLK_RATE_32KHZ\t32768\n\n/* Controller debug log header */\n#define QCA_DEBUG_HANDLE\t0x2EDC\n\n/* max retry count when init fails */\n#define MAX_INIT_RETRIES 3\n\n/* Controller dump header */\n#define QCA_SSR_DUMP_HANDLE\t\t0x0108\n#define QCA_DUMP_PACKET_SIZE\t\t255\n#define QCA_LAST_SEQUENCE_NUM\t\t0xFFFF\n#define QCA_CRASHBYTE_PACKET_LEN\t1096\n#define QCA_MEMDUMP_BYTE\t\t0xFB\n\nenum qca_flags {\n\tQCA_IBS_DISABLED,\n\tQCA_DROP_VENDOR_EVENT,\n\tQCA_SUSPENDING,\n\tQCA_MEMDUMP_COLLECTION,\n\tQCA_HW_ERROR_EVENT,\n\tQCA_SSR_TRIGGERED,\n\tQCA_BT_OFF,\n\tQCA_ROM_FW\n};\n\nenum qca_capabilities {\n\tQCA_CAP_WIDEBAND_SPEECH = BIT(0),\n\tQCA_CAP_VALID_LE_STATES = BIT(1),\n};\n\n/* HCI_IBS transmit side sleep protocol states */\nenum tx_ibs_states {\n\tHCI_IBS_TX_ASLEEP,\n\tHCI_IBS_TX_WAKING,\n\tHCI_IBS_TX_AWAKE,\n};\n\n/* HCI_IBS receive side sleep protocol states */\nenum rx_states {\n\tHCI_IBS_RX_ASLEEP,\n\tHCI_IBS_RX_AWAKE,\n};\n\n/* HCI_IBS transmit and receive side clock state vote */\nenum hci_ibs_clock_state_vote {\n\tHCI_IBS_VOTE_STATS_UPDATE,\n\tHCI_IBS_TX_VOTE_CLOCK_ON,\n\tHCI_IBS_TX_VOTE_CLOCK_OFF,\n\tHCI_IBS_RX_VOTE_CLOCK_ON,\n\tHCI_IBS_RX_VOTE_CLOCK_OFF,\n};\n\n/* Controller memory dump states */\nenum qca_memdump_states {\n\tQCA_MEMDUMP_IDLE,\n\tQCA_MEMDUMP_COLLECTING,\n\tQCA_MEMDUMP_COLLECTED,\n\tQCA_MEMDUMP_TIMEOUT,\n};\n\nstruct qca_memdump_data {\n\tchar *memdump_buf_head;\n\tchar *memdump_buf_tail;\n\tu32 current_seq_no;\n\tu32 received_dump;\n\tu32 ram_dump_size;\n};\n\nstruct qca_memdump_event_hdr {\n\t__u8    evt;\n\t__u8    plen;\n\t__u16   opcode;\n\t__u16   seq_no;\n\t__u8    reserved;\n} __packed;\n\n\nstruct qca_dump_size {\n\tu32 dump_size;\n} __packed;\n\nstruct qca_data {\n\tstruct hci_uart *hu;\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n\tstruct sk_buff_head tx_wait_q;\t/* HCI_IBS wait queue\t*/\n\tstruct sk_buff_head rx_memdump_q;\t/* Memdump wait queue\t*/\n\tspinlock_t hci_ibs_lock;\t/* HCI_IBS state lock\t*/\n\tu8 tx_ibs_state;\t/* HCI_IBS transmit side power state*/\n\tu8 rx_ibs_state;\t/* HCI_IBS receive side power state */\n\tbool tx_vote;\t\t/* Clock must be on for TX */\n\tbool rx_vote;\t\t/* Clock must be on for RX */\n\tstruct timer_list tx_idle_timer;\n\tu32 tx_idle_delay;\n\tstruct timer_list wake_retrans_timer;\n\tu32 wake_retrans;\n\tstruct workqueue_struct *workqueue;\n\tstruct work_struct ws_awake_rx;\n\tstruct work_struct ws_awake_device;\n\tstruct work_struct ws_rx_vote_off;\n\tstruct work_struct ws_tx_vote_off;\n\tstruct work_struct ctrl_memdump_evt;\n\tstruct delayed_work ctrl_memdump_timeout;\n\tstruct qca_memdump_data *qca_memdump;\n\tunsigned long flags;\n\tstruct completion drop_ev_comp;\n\twait_queue_head_t suspend_wait_q;\n\tenum qca_memdump_states memdump_state;\n\tstruct mutex hci_memdump_lock;\n\n\t/* For debugging purpose */\n\tu64 ibs_sent_wacks;\n\tu64 ibs_sent_slps;\n\tu64 ibs_sent_wakes;\n\tu64 ibs_recv_wacks;\n\tu64 ibs_recv_slps;\n\tu64 ibs_recv_wakes;\n\tu64 vote_last_jif;\n\tu32 vote_on_ms;\n\tu32 vote_off_ms;\n\tu64 tx_votes_on;\n\tu64 rx_votes_on;\n\tu64 tx_votes_off;\n\tu64 rx_votes_off;\n\tu64 votes_on;\n\tu64 votes_off;\n};\n\nenum qca_speed_type {\n\tQCA_INIT_SPEED = 1,\n\tQCA_OPER_SPEED\n};\n\n/*\n * Voltage regulator information required for configuring the\n * QCA Bluetooth chipset\n */\nstruct qca_vreg {\n\tconst char *name;\n\tunsigned int load_uA;\n};\n\nstruct qca_device_data {\n\tenum qca_btsoc_type soc_type;\n\tstruct qca_vreg *vregs;\n\tsize_t num_vregs;\n\tuint32_t capabilities;\n};\n\n/*\n * Platform data for the QCA Bluetooth power driver.\n */\nstruct qca_power {\n\tstruct device *dev;\n\tstruct regulator_bulk_data *vreg_bulk;\n\tint num_vregs;\n\tbool vregs_on;\n};\n\nstruct qca_serdev {\n\tstruct hci_uart\t serdev_hu;\n\tstruct gpio_desc *bt_en;\n\tstruct gpio_desc *sw_ctrl;\n\tstruct clk\t *susclk;\n\tenum qca_btsoc_type btsoc_type;\n\tstruct qca_power *bt_power;\n\tu32 init_speed;\n\tu32 oper_speed;\n\tconst char *firmware_name;\n};\n\nstatic int qca_regulator_enable(struct qca_serdev *qcadev);\nstatic void qca_regulator_disable(struct qca_serdev *qcadev);\nstatic void qca_power_shutdown(struct hci_uart *hu);\nstatic int qca_power_off(struct hci_dev *hdev);\nstatic void qca_controller_memdump(struct work_struct *work);\n\nstatic enum qca_btsoc_type qca_soc_type(struct hci_uart *hu)\n{\n\tenum qca_btsoc_type soc_type;\n\n\tif (hu->serdev) {\n\t\tstruct qca_serdev *qsd = serdev_device_get_drvdata(hu->serdev);\n\n\t\tsoc_type = qsd->btsoc_type;\n\t} else {\n\t\tsoc_type = QCA_ROME;\n\t}\n\n\treturn soc_type;\n}\n\nstatic const char *qca_get_firmware_name(struct hci_uart *hu)\n{\n\tif (hu->serdev) {\n\t\tstruct qca_serdev *qsd = serdev_device_get_drvdata(hu->serdev);\n\n\t\treturn qsd->firmware_name;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nstatic void __serial_clock_on(struct tty_struct *tty)\n{\n\t/* TODO: Some chipset requires to enable UART clock on client\n\t * side to save power consumption or manual work is required.\n\t * Please put your code to control UART clock here if needed\n\t */\n}\n\nstatic void __serial_clock_off(struct tty_struct *tty)\n{\n\t/* TODO: Some chipset requires to disable UART clock on client\n\t * side to save power consumption or manual work is required.\n\t * Please put your code to control UART clock off here if needed\n\t */\n}\n\n/* serial_clock_vote needs to be called with the ibs lock held */\nstatic void serial_clock_vote(unsigned long vote, struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\tunsigned int diff;\n\n\tbool old_vote = (qca->tx_vote | qca->rx_vote);\n\tbool new_vote;\n\n\tswitch (vote) {\n\tcase HCI_IBS_VOTE_STATS_UPDATE:\n\t\tdiff = jiffies_to_msecs(jiffies - qca->vote_last_jif);\n\n\t\tif (old_vote)\n\t\t\tqca->vote_off_ms += diff;\n\t\telse\n\t\t\tqca->vote_on_ms += diff;\n\t\treturn;\n\n\tcase HCI_IBS_TX_VOTE_CLOCK_ON:\n\t\tqca->tx_vote = true;\n\t\tqca->tx_votes_on++;\n\t\tbreak;\n\n\tcase HCI_IBS_RX_VOTE_CLOCK_ON:\n\t\tqca->rx_vote = true;\n\t\tqca->rx_votes_on++;\n\t\tbreak;\n\n\tcase HCI_IBS_TX_VOTE_CLOCK_OFF:\n\t\tqca->tx_vote = false;\n\t\tqca->tx_votes_off++;\n\t\tbreak;\n\n\tcase HCI_IBS_RX_VOTE_CLOCK_OFF:\n\t\tqca->rx_vote = false;\n\t\tqca->rx_votes_off++;\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Voting irregularity\");\n\t\treturn;\n\t}\n\n\tnew_vote = qca->rx_vote | qca->tx_vote;\n\n\tif (new_vote != old_vote) {\n\t\tif (new_vote)\n\t\t\t__serial_clock_on(hu->tty);\n\t\telse\n\t\t\t__serial_clock_off(hu->tty);\n\n\t\tBT_DBG(\"Vote serial clock %s(%s)\", new_vote ? \"true\" : \"false\",\n\t\t       vote ? \"true\" : \"false\");\n\n\t\tdiff = jiffies_to_msecs(jiffies - qca->vote_last_jif);\n\n\t\tif (new_vote) {\n\t\t\tqca->votes_on++;\n\t\t\tqca->vote_off_ms += diff;\n\t\t} else {\n\t\t\tqca->votes_off++;\n\t\t\tqca->vote_on_ms += diff;\n\t\t}\n\t\tqca->vote_last_jif = jiffies;\n\t}\n}\n\n/* Builds and sends an HCI_IBS command packet.\n * These are very simple packets with only 1 cmd byte.\n */\nstatic int send_hci_ibs_cmd(u8 cmd, struct hci_uart *hu)\n{\n\tint err = 0;\n\tstruct sk_buff *skb = NULL;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p send hci ibs cmd 0x%x\", hu, cmd);\n\n\tskb = bt_skb_alloc(1, GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR(\"Failed to allocate memory for HCI_IBS packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Assign HCI_IBS type */\n\tskb_put_u8(skb, cmd);\n\n\tskb_queue_tail(&qca->txq, skb);\n\n\treturn err;\n}\n\nstatic void qca_wq_awake_device(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_awake_device);\n\tstruct hci_uart *hu = qca->hu;\n\tunsigned long retrans_delay;\n\tunsigned long flags;\n\n\tBT_DBG(\"hu %p wq awake device\", hu);\n\n\t/* Vote for serial clock */\n\tserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_ON, hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\t/* Send wake indication to device */\n\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0)\n\t\tBT_ERR(\"Failed to send WAKE to device\");\n\n\tqca->ibs_sent_wakes++;\n\n\t/* Start retransmit timer */\n\tretrans_delay = msecs_to_jiffies(qca->wake_retrans);\n\tmod_timer(&qca->wake_retrans_timer, jiffies + retrans_delay);\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic void qca_wq_awake_rx(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_awake_rx);\n\tstruct hci_uart *hu = qca->hu;\n\tunsigned long flags;\n\n\tBT_DBG(\"hu %p wq awake rx\", hu);\n\n\tserial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_ON, hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\tqca->rx_ibs_state = HCI_IBS_RX_AWAKE;\n\n\t/* Always acknowledge device wake up,\n\t * sending IBS message doesn't count as TX ON.\n\t */\n\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0)\n\t\tBT_ERR(\"Failed to acknowledge device wake up\");\n\n\tqca->ibs_sent_wacks++;\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic void qca_wq_serial_rx_clock_vote_off(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_rx_vote_off);\n\tstruct hci_uart *hu = qca->hu;\n\n\tBT_DBG(\"hu %p rx clock vote off\", hu);\n\n\tserial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_OFF, hu);\n}\n\nstatic void qca_wq_serial_tx_clock_vote_off(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_tx_vote_off);\n\tstruct hci_uart *hu = qca->hu;\n\n\tBT_DBG(\"hu %p tx clock vote off\", hu);\n\n\t/* Run HCI tx handling unlocked */\n\thci_uart_tx_wakeup(hu);\n\n\t/* Now that message queued to tty driver, vote for tty clocks off.\n\t * It is up to the tty driver to pend the clocks off until tx done.\n\t */\n\tserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_OFF, hu);\n}\n\nstatic void hci_ibs_tx_idle_timeout(struct timer_list *t)\n{\n\tstruct qca_data *qca = from_timer(qca, t, tx_idle_timer);\n\tstruct hci_uart *hu = qca->hu;\n\tunsigned long flags;\n\n\tBT_DBG(\"hu %p idle timeout in %d state\", hu, qca->tx_ibs_state);\n\n\tspin_lock_irqsave_nested(&qca->hci_ibs_lock,\n\t\t\t\t flags, SINGLE_DEPTH_NESTING);\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_AWAKE:\n\t\t/* TX_IDLE, go to SLEEP */\n\t\tif (send_hci_ibs_cmd(HCI_IBS_SLEEP_IND, hu) < 0) {\n\t\t\tBT_ERR(\"Failed to send SLEEP to device\");\n\t\t\tbreak;\n\t\t}\n\t\tqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\n\t\tqca->ibs_sent_slps++;\n\t\tqueue_work(qca->workqueue, &qca->ws_tx_vote_off);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\tcase HCI_IBS_TX_WAKING:\n\tdefault:\n\t\tBT_ERR(\"Spurious timeout tx state %d\", qca->tx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n}\n\nstatic void hci_ibs_wake_retrans_timeout(struct timer_list *t)\n{\n\tstruct qca_data *qca = from_timer(qca, t, wake_retrans_timer);\n\tstruct hci_uart *hu = qca->hu;\n\tunsigned long flags, retrans_delay;\n\tbool retransmit = false;\n\n\tBT_DBG(\"hu %p wake retransmit timeout in %d state\",\n\t\thu, qca->tx_ibs_state);\n\n\tspin_lock_irqsave_nested(&qca->hci_ibs_lock,\n\t\t\t\t flags, SINGLE_DEPTH_NESTING);\n\n\t/* Don't retransmit the HCI_IBS_WAKE_IND when suspending. */\n\tif (test_bit(QCA_SUSPENDING, &qca->flags)) {\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn;\n\t}\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_WAKING:\n\t\t/* No WAKE_ACK, retransmit WAKE */\n\t\tretransmit = true;\n\t\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0) {\n\t\t\tBT_ERR(\"Failed to acknowledge device wake up\");\n\t\t\tbreak;\n\t\t}\n\t\tqca->ibs_sent_wakes++;\n\t\tretrans_delay = msecs_to_jiffies(qca->wake_retrans);\n\t\tmod_timer(&qca->wake_retrans_timer, jiffies + retrans_delay);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\tcase HCI_IBS_TX_AWAKE:\n\tdefault:\n\t\tBT_ERR(\"Spurious timeout tx state %d\", qca->tx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\tif (retransmit)\n\t\thci_uart_tx_wakeup(hu);\n}\n\n\nstatic void qca_controller_memdump_timeout(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\tctrl_memdump_timeout.work);\n\tstruct hci_uart *hu = qca->hu;\n\n\tmutex_lock(&qca->hci_memdump_lock);\n\tif (test_bit(QCA_MEMDUMP_COLLECTION, &qca->flags)) {\n\t\tqca->memdump_state = QCA_MEMDUMP_TIMEOUT;\n\t\tif (!test_bit(QCA_HW_ERROR_EVENT, &qca->flags)) {\n\t\t\t/* Inject hw error event to reset the device\n\t\t\t * and driver.\n\t\t\t */\n\t\t\thci_reset_dev(hu->hdev);\n\t\t}\n\t}\n\n\tmutex_unlock(&qca->hci_memdump_lock);\n}\n\n\n/* Initialize protocol */\nstatic int qca_open(struct hci_uart *hu)\n{\n\tstruct qca_serdev *qcadev;\n\tstruct qca_data *qca;\n\n\tBT_DBG(\"hu %p qca_open\", hu);\n\n\tif (!hci_uart_has_flow_control(hu))\n\t\treturn -EOPNOTSUPP;\n\n\tqca = kzalloc(sizeof(struct qca_data), GFP_KERNEL);\n\tif (!qca)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&qca->txq);\n\tskb_queue_head_init(&qca->tx_wait_q);\n\tskb_queue_head_init(&qca->rx_memdump_q);\n\tspin_lock_init(&qca->hci_ibs_lock);\n\tmutex_init(&qca->hci_memdump_lock);\n\tqca->workqueue = alloc_ordered_workqueue(\"qca_wq\", 0);\n\tif (!qca->workqueue) {\n\t\tBT_ERR(\"QCA Workqueue not initialized properly\");\n\t\tkfree(qca);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_WORK(&qca->ws_awake_rx, qca_wq_awake_rx);\n\tINIT_WORK(&qca->ws_awake_device, qca_wq_awake_device);\n\tINIT_WORK(&qca->ws_rx_vote_off, qca_wq_serial_rx_clock_vote_off);\n\tINIT_WORK(&qca->ws_tx_vote_off, qca_wq_serial_tx_clock_vote_off);\n\tINIT_WORK(&qca->ctrl_memdump_evt, qca_controller_memdump);\n\tINIT_DELAYED_WORK(&qca->ctrl_memdump_timeout,\n\t\t\t  qca_controller_memdump_timeout);\n\tinit_waitqueue_head(&qca->suspend_wait_q);\n\n\tqca->hu = hu;\n\tinit_completion(&qca->drop_ev_comp);\n\n\t/* Assume we start with both sides asleep -- extra wakes OK */\n\tqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\n\tqca->rx_ibs_state = HCI_IBS_RX_ASLEEP;\n\n\tqca->vote_last_jif = jiffies;\n\n\thu->priv = qca;\n\n\tif (hu->serdev) {\n\t\tqcadev = serdev_device_get_drvdata(hu->serdev);\n\n\t\tif (qca_is_wcn399x(qcadev->btsoc_type) ||\n\t\t    qca_is_wcn6750(qcadev->btsoc_type))\n\t\t\thu->init_speed = qcadev->init_speed;\n\n\t\tif (qcadev->oper_speed)\n\t\t\thu->oper_speed = qcadev->oper_speed;\n\t}\n\n\ttimer_setup(&qca->wake_retrans_timer, hci_ibs_wake_retrans_timeout, 0);\n\tqca->wake_retrans = IBS_WAKE_RETRANS_TIMEOUT_MS;\n\n\ttimer_setup(&qca->tx_idle_timer, hci_ibs_tx_idle_timeout, 0);\n\tqca->tx_idle_delay = IBS_HOST_TX_IDLE_TIMEOUT_MS;\n\n\tBT_DBG(\"HCI_UART_QCA open, tx_idle_delay=%u, wake_retrans=%u\",\n\t       qca->tx_idle_delay, qca->wake_retrans);\n\n\treturn 0;\n}\n\nstatic void qca_debugfs_init(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\tstruct dentry *ibs_dir;\n\tumode_t mode;\n\n\tif (!hdev->debugfs)\n\t\treturn;\n\n\tibs_dir = debugfs_create_dir(\"ibs\", hdev->debugfs);\n\n\t/* read only */\n\tmode = 0444;\n\tdebugfs_create_u8(\"tx_ibs_state\", mode, ibs_dir, &qca->tx_ibs_state);\n\tdebugfs_create_u8(\"rx_ibs_state\", mode, ibs_dir, &qca->rx_ibs_state);\n\tdebugfs_create_u64(\"ibs_sent_sleeps\", mode, ibs_dir,\n\t\t\t   &qca->ibs_sent_slps);\n\tdebugfs_create_u64(\"ibs_sent_wakes\", mode, ibs_dir,\n\t\t\t   &qca->ibs_sent_wakes);\n\tdebugfs_create_u64(\"ibs_sent_wake_acks\", mode, ibs_dir,\n\t\t\t   &qca->ibs_sent_wacks);\n\tdebugfs_create_u64(\"ibs_recv_sleeps\", mode, ibs_dir,\n\t\t\t   &qca->ibs_recv_slps);\n\tdebugfs_create_u64(\"ibs_recv_wakes\", mode, ibs_dir,\n\t\t\t   &qca->ibs_recv_wakes);\n\tdebugfs_create_u64(\"ibs_recv_wake_acks\", mode, ibs_dir,\n\t\t\t   &qca->ibs_recv_wacks);\n\tdebugfs_create_bool(\"tx_vote\", mode, ibs_dir, &qca->tx_vote);\n\tdebugfs_create_u64(\"tx_votes_on\", mode, ibs_dir, &qca->tx_votes_on);\n\tdebugfs_create_u64(\"tx_votes_off\", mode, ibs_dir, &qca->tx_votes_off);\n\tdebugfs_create_bool(\"rx_vote\", mode, ibs_dir, &qca->rx_vote);\n\tdebugfs_create_u64(\"rx_votes_on\", mode, ibs_dir, &qca->rx_votes_on);\n\tdebugfs_create_u64(\"rx_votes_off\", mode, ibs_dir, &qca->rx_votes_off);\n\tdebugfs_create_u64(\"votes_on\", mode, ibs_dir, &qca->votes_on);\n\tdebugfs_create_u64(\"votes_off\", mode, ibs_dir, &qca->votes_off);\n\tdebugfs_create_u32(\"vote_on_ms\", mode, ibs_dir, &qca->vote_on_ms);\n\tdebugfs_create_u32(\"vote_off_ms\", mode, ibs_dir, &qca->vote_off_ms);\n\n\t/* read/write */\n\tmode = 0644;\n\tdebugfs_create_u32(\"wake_retrans\", mode, ibs_dir, &qca->wake_retrans);\n\tdebugfs_create_u32(\"tx_idle_delay\", mode, ibs_dir,\n\t\t\t   &qca->tx_idle_delay);\n}\n\n/* Flush protocol data */\nstatic int qca_flush(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p qca flush\", hu);\n\n\tskb_queue_purge(&qca->tx_wait_q);\n\tskb_queue_purge(&qca->txq);\n\n\treturn 0;\n}\n\n/* Close protocol */\nstatic int qca_close(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p qca close\", hu);\n\n\tserial_clock_vote(HCI_IBS_VOTE_STATS_UPDATE, hu);\n\n\tskb_queue_purge(&qca->tx_wait_q);\n\tskb_queue_purge(&qca->txq);\n\tskb_queue_purge(&qca->rx_memdump_q);\n\tdel_timer(&qca->tx_idle_timer);\n\tdel_timer(&qca->wake_retrans_timer);\n\tdestroy_workqueue(qca->workqueue);\n\tqca->hu = NULL;\n\n\tkfree_skb(qca->rx_skb);\n\n\thu->priv = NULL;\n\n\tkfree(qca);\n\n\treturn 0;\n}\n\n/* Called upon a wake-up-indication from the device.\n */\nstatic void device_want_to_wakeup(struct hci_uart *hu)\n{\n\tunsigned long flags;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p want to wake up\", hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\tqca->ibs_recv_wakes++;\n\n\t/* Don't wake the rx up when suspending. */\n\tif (test_bit(QCA_SUSPENDING, &qca->flags)) {\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn;\n\t}\n\n\tswitch (qca->rx_ibs_state) {\n\tcase HCI_IBS_RX_ASLEEP:\n\t\t/* Make sure clock is on - we may have turned clock off since\n\t\t * receiving the wake up indicator awake rx clock.\n\t\t */\n\t\tqueue_work(qca->workqueue, &qca->ws_awake_rx);\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn;\n\n\tcase HCI_IBS_RX_AWAKE:\n\t\t/* Always acknowledge device wake up,\n\t\t * sending IBS message doesn't count as TX ON.\n\t\t */\n\t\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0) {\n\t\t\tBT_ERR(\"Failed to acknowledge device wake up\");\n\t\t\tbreak;\n\t\t}\n\t\tqca->ibs_sent_wacks++;\n\t\tbreak;\n\n\tdefault:\n\t\t/* Any other state is illegal */\n\t\tBT_ERR(\"Received HCI_IBS_WAKE_IND in rx state %d\",\n\t\t       qca->rx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\n/* Called upon a sleep-indication from the device.\n */\nstatic void device_want_to_sleep(struct hci_uart *hu)\n{\n\tunsigned long flags;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p want to sleep in %d state\", hu, qca->rx_ibs_state);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\tqca->ibs_recv_slps++;\n\n\tswitch (qca->rx_ibs_state) {\n\tcase HCI_IBS_RX_AWAKE:\n\t\t/* Update state */\n\t\tqca->rx_ibs_state = HCI_IBS_RX_ASLEEP;\n\t\t/* Vote off rx clock under workqueue */\n\t\tqueue_work(qca->workqueue, &qca->ws_rx_vote_off);\n\t\tbreak;\n\n\tcase HCI_IBS_RX_ASLEEP:\n\t\tbreak;\n\n\tdefault:\n\t\t/* Any other state is illegal */\n\t\tBT_ERR(\"Received HCI_IBS_SLEEP_IND in rx state %d\",\n\t\t       qca->rx_ibs_state);\n\t\tbreak;\n\t}\n\n\twake_up_interruptible(&qca->suspend_wait_q);\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n}\n\n/* Called upon wake-up-acknowledgement from the device\n */\nstatic void device_woke_up(struct hci_uart *hu)\n{\n\tunsigned long flags, idle_delay;\n\tstruct qca_data *qca = hu->priv;\n\tstruct sk_buff *skb = NULL;\n\n\tBT_DBG(\"hu %p woke up\", hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\tqca->ibs_recv_wacks++;\n\n\t/* Don't react to the wake-up-acknowledgment when suspending. */\n\tif (test_bit(QCA_SUSPENDING, &qca->flags)) {\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn;\n\t}\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_AWAKE:\n\t\t/* Expect one if we send 2 WAKEs */\n\t\tBT_DBG(\"Received HCI_IBS_WAKE_ACK in tx state %d\",\n\t\t       qca->tx_ibs_state);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_WAKING:\n\t\t/* Send pending packets */\n\t\twhile ((skb = skb_dequeue(&qca->tx_wait_q)))\n\t\t\tskb_queue_tail(&qca->txq, skb);\n\n\t\t/* Switch timers and change state to HCI_IBS_TX_AWAKE */\n\t\tdel_timer(&qca->wake_retrans_timer);\n\t\tidle_delay = msecs_to_jiffies(qca->tx_idle_delay);\n\t\tmod_timer(&qca->tx_idle_timer, jiffies + idle_delay);\n\t\tqca->tx_ibs_state = HCI_IBS_TX_AWAKE;\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\tdefault:\n\t\tBT_ERR(\"Received HCI_IBS_WAKE_ACK in tx state %d\",\n\t\t       qca->tx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\n/* Enqueue frame for transmittion (padding, crc, etc) may be called from\n * two simultaneous tasklets.\n */\nstatic int qca_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tunsigned long flags = 0, idle_delay;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p qca enq skb %p tx_ibs_state %d\", hu, skb,\n\t       qca->tx_ibs_state);\n\n\tif (test_bit(QCA_SSR_TRIGGERED, &qca->flags)) {\n\t\t/* As SSR is in progress, ignore the packets */\n\t\tbt_dev_dbg(hu->hdev, \"SSR is in progress\");\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\t/* Prepend skb with frame type */\n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\t/* Don't go to sleep in middle of patch download or\n\t * Out-Of-Band(GPIOs control) sleep is selected.\n\t * Don't wake the device up when suspending.\n\t */\n\tif (test_bit(QCA_IBS_DISABLED, &qca->flags) ||\n\t    test_bit(QCA_SUSPENDING, &qca->flags)) {\n\t\tskb_queue_tail(&qca->txq, skb);\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn 0;\n\t}\n\n\t/* Act according to current state */\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_AWAKE:\n\t\tBT_DBG(\"Device awake, sending normally\");\n\t\tskb_queue_tail(&qca->txq, skb);\n\t\tidle_delay = msecs_to_jiffies(qca->tx_idle_delay);\n\t\tmod_timer(&qca->tx_idle_timer, jiffies + idle_delay);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\t\tBT_DBG(\"Device asleep, waking up and queueing packet\");\n\t\t/* Save packet for later */\n\t\tskb_queue_tail(&qca->tx_wait_q, skb);\n\n\t\tqca->tx_ibs_state = HCI_IBS_TX_WAKING;\n\t\t/* Schedule a work queue to wake up device */\n\t\tqueue_work(qca->workqueue, &qca->ws_awake_device);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_WAKING:\n\t\tBT_DBG(\"Device waking up, queueing packet\");\n\t\t/* Transient state; just keep packet for later */\n\t\tskb_queue_tail(&qca->tx_wait_q, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Illegal tx state: %d (losing packet)\",\n\t\t       qca->tx_ibs_state);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\treturn 0;\n}\n\nstatic int qca_ibs_sleep_ind(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"hu %p recv hci ibs cmd 0x%x\", hu, HCI_IBS_SLEEP_IND);\n\n\tdevice_want_to_sleep(hu);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int qca_ibs_wake_ind(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"hu %p recv hci ibs cmd 0x%x\", hu, HCI_IBS_WAKE_IND);\n\n\tdevice_want_to_wakeup(hu);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int qca_ibs_wake_ack(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"hu %p recv hci ibs cmd 0x%x\", hu, HCI_IBS_WAKE_ACK);\n\n\tdevice_woke_up(hu);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int qca_recv_acl_data(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\t/* We receive debug logs from chip as an ACL packets.\n\t * Instead of sending the data to ACL to decode the\n\t * received data, we are pushing them to the above layers\n\t * as a diagnostic packet.\n\t */\n\tif (get_unaligned_le16(skb->data) == QCA_DEBUG_HANDLE)\n\t\treturn hci_recv_diag(hdev, skb);\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic void qca_controller_memdump(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ctrl_memdump_evt);\n\tstruct hci_uart *hu = qca->hu;\n\tstruct sk_buff *skb;\n\tstruct qca_memdump_event_hdr *cmd_hdr;\n\tstruct qca_memdump_data *qca_memdump = qca->qca_memdump;\n\tstruct qca_dump_size *dump;\n\tchar *memdump_buf;\n\tchar nullBuff[QCA_DUMP_PACKET_SIZE] = { 0 };\n\tu16 seq_no;\n\tu32 dump_size;\n\tu32 rx_size;\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\n\twhile ((skb = skb_dequeue(&qca->rx_memdump_q))) {\n\n\t\tmutex_lock(&qca->hci_memdump_lock);\n\t\t/* Skip processing the received packets if timeout detected\n\t\t * or memdump collection completed.\n\t\t */\n\t\tif (qca->memdump_state == QCA_MEMDUMP_TIMEOUT ||\n\t\t    qca->memdump_state == QCA_MEMDUMP_COLLECTED) {\n\t\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!qca_memdump) {\n\t\t\tqca_memdump = kzalloc(sizeof(struct qca_memdump_data),\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tif (!qca_memdump) {\n\t\t\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tqca->qca_memdump = qca_memdump;\n\t\t}\n\n\t\tqca->memdump_state = QCA_MEMDUMP_COLLECTING;\n\t\tcmd_hdr = (void *) skb->data;\n\t\tseq_no = __le16_to_cpu(cmd_hdr->seq_no);\n\t\tskb_pull(skb, sizeof(struct qca_memdump_event_hdr));\n\n\t\tif (!seq_no) {\n\n\t\t\t/* This is the first frame of memdump packet from\n\t\t\t * the controller, Disable IBS to recevie dump\n\t\t\t * with out any interruption, ideally time required for\n\t\t\t * the controller to send the dump is 8 seconds. let us\n\t\t\t * start timer to handle this asynchronous activity.\n\t\t\t */\n\t\t\tset_bit(QCA_IBS_DISABLED, &qca->flags);\n\t\t\tset_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n\t\t\tdump = (void *) skb->data;\n\t\t\tdump_size = __le32_to_cpu(dump->dump_size);\n\t\t\tif (!(dump_size)) {\n\t\t\t\tbt_dev_err(hu->hdev, \"Rx invalid memdump size\");\n\t\t\t\tkfree(qca_memdump);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tqca->qca_memdump = NULL;\n\t\t\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbt_dev_info(hu->hdev, \"QCA collecting dump of size:%u\",\n\t\t\t\t    dump_size);\n\t\t\tqueue_delayed_work(qca->workqueue,\n\t\t\t\t\t   &qca->ctrl_memdump_timeout,\n\t\t\t\t\t   msecs_to_jiffies(MEMDUMP_TIMEOUT_MS)\n\t\t\t\t\t  );\n\n\t\t\tskb_pull(skb, sizeof(dump_size));\n\t\t\tmemdump_buf = vmalloc(dump_size);\n\t\t\tqca_memdump->ram_dump_size = dump_size;\n\t\t\tqca_memdump->memdump_buf_head = memdump_buf;\n\t\t\tqca_memdump->memdump_buf_tail = memdump_buf;\n\t\t}\n\n\t\tmemdump_buf = qca_memdump->memdump_buf_tail;\n\n\t\t/* If sequence no 0 is missed then there is no point in\n\t\t * accepting the other sequences.\n\t\t */\n\t\tif (!memdump_buf) {\n\t\t\tbt_dev_err(hu->hdev, \"QCA: Discarding other packets\");\n\t\t\tkfree(qca_memdump);\n\t\t\tkfree_skb(skb);\n\t\t\tqca->qca_memdump = NULL;\n\t\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t\t\treturn;\n\t\t}\n\n\t\t/* There could be chance of missing some packets from\n\t\t * the controller. In such cases let us store the dummy\n\t\t * packets in the buffer.\n\t\t */\n\t\t/* For QCA6390, controller does not lost packets but\n\t\t * sequence number field of packet sometimes has error\n\t\t * bits, so skip this checking for missing packet.\n\t\t */\n\t\twhile ((seq_no > qca_memdump->current_seq_no + 1) &&\n\t\t       (soc_type != QCA_QCA6390) &&\n\t\t       seq_no != QCA_LAST_SEQUENCE_NUM) {\n\t\t\tbt_dev_err(hu->hdev, \"QCA controller missed packet:%d\",\n\t\t\t\t   qca_memdump->current_seq_no);\n\t\t\trx_size = qca_memdump->received_dump;\n\t\t\trx_size += QCA_DUMP_PACKET_SIZE;\n\t\t\tif (rx_size > qca_memdump->ram_dump_size) {\n\t\t\t\tbt_dev_err(hu->hdev,\n\t\t\t\t\t   \"QCA memdump received %d, no space for missed packet\",\n\t\t\t\t\t   qca_memdump->received_dump);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(memdump_buf, nullBuff, QCA_DUMP_PACKET_SIZE);\n\t\t\tmemdump_buf = memdump_buf + QCA_DUMP_PACKET_SIZE;\n\t\t\tqca_memdump->received_dump += QCA_DUMP_PACKET_SIZE;\n\t\t\tqca_memdump->current_seq_no++;\n\t\t}\n\n\t\trx_size = qca_memdump->received_dump + skb->len;\n\t\tif (rx_size <= qca_memdump->ram_dump_size) {\n\t\t\tif ((seq_no != QCA_LAST_SEQUENCE_NUM) &&\n\t\t\t    (seq_no != qca_memdump->current_seq_no))\n\t\t\t\tbt_dev_err(hu->hdev,\n\t\t\t\t\t   \"QCA memdump unexpected packet %d\",\n\t\t\t\t\t   seq_no);\n\t\t\tbt_dev_dbg(hu->hdev,\n\t\t\t\t   \"QCA memdump packet %d with length %d\",\n\t\t\t\t   seq_no, skb->len);\n\t\t\tmemcpy(memdump_buf, (unsigned char *)skb->data,\n\t\t\t       skb->len);\n\t\t\tmemdump_buf = memdump_buf + skb->len;\n\t\t\tqca_memdump->memdump_buf_tail = memdump_buf;\n\t\t\tqca_memdump->current_seq_no = seq_no + 1;\n\t\t\tqca_memdump->received_dump += skb->len;\n\t\t} else {\n\t\t\tbt_dev_err(hu->hdev,\n\t\t\t\t   \"QCA memdump received %d, no space for packet %d\",\n\t\t\t\t   qca_memdump->received_dump, seq_no);\n\t\t}\n\t\tqca->qca_memdump = qca_memdump;\n\t\tkfree_skb(skb);\n\t\tif (seq_no == QCA_LAST_SEQUENCE_NUM) {\n\t\t\tbt_dev_info(hu->hdev,\n\t\t\t\t    \"QCA memdump Done, received %d, total %d\",\n\t\t\t\t    qca_memdump->received_dump,\n\t\t\t\t    qca_memdump->ram_dump_size);\n\t\t\tmemdump_buf = qca_memdump->memdump_buf_head;\n\t\t\tdev_coredumpv(&hu->serdev->dev, memdump_buf,\n\t\t\t\t      qca_memdump->received_dump, GFP_KERNEL);\n\t\t\tcancel_delayed_work(&qca->ctrl_memdump_timeout);\n\t\t\tkfree(qca->qca_memdump);\n\t\t\tqca->qca_memdump = NULL;\n\t\t\tqca->memdump_state = QCA_MEMDUMP_COLLECTED;\n\t\t\tclear_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n\t\t}\n\n\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t}\n\n}\n\nstatic int qca_controller_memdump_event(struct hci_dev *hdev,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\tset_bit(QCA_SSR_TRIGGERED, &qca->flags);\n\tskb_queue_tail(&qca->rx_memdump_q, skb);\n\tqueue_work(qca->workqueue, &qca->ctrl_memdump_evt);\n\n\treturn 0;\n}\n\nstatic int qca_recv_event(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\tif (test_bit(QCA_DROP_VENDOR_EVENT, &qca->flags)) {\n\t\tstruct hci_event_hdr *hdr = (void *)skb->data;\n\n\t\t/* For the WCN3990 the vendor command for a baudrate change\n\t\t * isn't sent as synchronous HCI command, because the\n\t\t * controller sends the corresponding vendor event with the\n\t\t * new baudrate. The event is received and properly decoded\n\t\t * after changing the baudrate of the host port. It needs to\n\t\t * be dropped, otherwise it can be misinterpreted as\n\t\t * response to a later firmware download command (also a\n\t\t * vendor command).\n\t\t */\n\n\t\tif (hdr->evt == HCI_EV_VENDOR)\n\t\t\tcomplete(&qca->drop_ev_comp);\n\n\t\tkfree_skb(skb);\n\n\t\treturn 0;\n\t}\n\t/* We receive chip memory dump as an event packet, With a dedicated\n\t * handler followed by a hardware error event. When this event is\n\t * received we store dump into a file before closing hci. This\n\t * dump will help in triaging the issues.\n\t */\n\tif ((skb->data[0] == HCI_VENDOR_PKT) &&\n\t    (get_unaligned_be16(skb->data + 2) == QCA_SSR_DUMP_HANDLE))\n\t\treturn qca_controller_memdump_event(hdev, skb);\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\n#define QCA_IBS_SLEEP_IND_EVENT \\\n\t.type = HCI_IBS_SLEEP_IND, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = HCI_MAX_IBS_SIZE\n\n#define QCA_IBS_WAKE_IND_EVENT \\\n\t.type = HCI_IBS_WAKE_IND, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = HCI_MAX_IBS_SIZE\n\n#define QCA_IBS_WAKE_ACK_EVENT \\\n\t.type = HCI_IBS_WAKE_ACK, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = HCI_MAX_IBS_SIZE\n\nstatic const struct h4_recv_pkt qca_recv_pkts[] = {\n\t{ H4_RECV_ACL,             .recv = qca_recv_acl_data },\n\t{ H4_RECV_SCO,             .recv = hci_recv_frame    },\n\t{ H4_RECV_EVENT,           .recv = qca_recv_event    },\n\t{ QCA_IBS_WAKE_IND_EVENT,  .recv = qca_ibs_wake_ind  },\n\t{ QCA_IBS_WAKE_ACK_EVENT,  .recv = qca_ibs_wake_ack  },\n\t{ QCA_IBS_SLEEP_IND_EVENT, .recv = qca_ibs_sleep_ind },\n};\n\nstatic int qca_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\tqca->rx_skb = h4_recv_buf(hu->hdev, qca->rx_skb, data, count,\n\t\t\t\t  qca_recv_pkts, ARRAY_SIZE(qca_recv_pkts));\n\tif (IS_ERR(qca->rx_skb)) {\n\t\tint err = PTR_ERR(qca->rx_skb);\n\t\tbt_dev_err(hu->hdev, \"Frame reassembly failed (%d)\", err);\n\t\tqca->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic struct sk_buff *qca_dequeue(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\treturn skb_dequeue(&qca->txq);\n}\n\nstatic uint8_t qca_get_baudrate_value(int speed)\n{\n\tswitch (speed) {\n\tcase 9600:\n\t\treturn QCA_BAUDRATE_9600;\n\tcase 19200:\n\t\treturn QCA_BAUDRATE_19200;\n\tcase 38400:\n\t\treturn QCA_BAUDRATE_38400;\n\tcase 57600:\n\t\treturn QCA_BAUDRATE_57600;\n\tcase 115200:\n\t\treturn QCA_BAUDRATE_115200;\n\tcase 230400:\n\t\treturn QCA_BAUDRATE_230400;\n\tcase 460800:\n\t\treturn QCA_BAUDRATE_460800;\n\tcase 500000:\n\t\treturn QCA_BAUDRATE_500000;\n\tcase 921600:\n\t\treturn QCA_BAUDRATE_921600;\n\tcase 1000000:\n\t\treturn QCA_BAUDRATE_1000000;\n\tcase 2000000:\n\t\treturn QCA_BAUDRATE_2000000;\n\tcase 3000000:\n\t\treturn QCA_BAUDRATE_3000000;\n\tcase 3200000:\n\t\treturn QCA_BAUDRATE_3200000;\n\tcase 3500000:\n\t\treturn QCA_BAUDRATE_3500000;\n\tdefault:\n\t\treturn QCA_BAUDRATE_115200;\n\t}\n}\n\nstatic int qca_set_baudrate(struct hci_dev *hdev, uint8_t baudrate)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\tstruct sk_buff *skb;\n\tu8 cmd[] = { 0x01, 0x48, 0xFC, 0x01, 0x00 };\n\n\tif (baudrate > QCA_BAUDRATE_3200000)\n\t\treturn -EINVAL;\n\n\tcmd[4] = baudrate;\n\n\tskb = bt_skb_alloc(sizeof(cmd), GFP_KERNEL);\n\tif (!skb) {\n\t\tbt_dev_err(hdev, \"Failed to allocate baudrate packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Assign commands to change baudrate and packet type. */\n\tskb_put_data(skb, cmd, sizeof(cmd));\n\thci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\n\n\tskb_queue_tail(&qca->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\t/* Wait for the baudrate change request to be sent */\n\n\twhile (!skb_queue_empty(&qca->txq))\n\t\tusleep_range(100, 200);\n\n\tif (hu->serdev)\n\t\tserdev_device_wait_until_sent(hu->serdev,\n\t\t      msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS));\n\n\t/* Give the controller time to process the request */\n\tif (qca_is_wcn399x(qca_soc_type(hu)) ||\n\t    qca_is_wcn6750(qca_soc_type(hu)))\n\t\tusleep_range(1000, 10000);\n\telse\n\t\tmsleep(300);\n\n\treturn 0;\n}\n\nstatic inline void host_set_baudrate(struct hci_uart *hu, unsigned int speed)\n{\n\tif (hu->serdev)\n\t\tserdev_device_set_baudrate(hu->serdev, speed);\n\telse\n\t\thci_uart_set_baudrate(hu, speed);\n}\n\nstatic int qca_send_power_pulse(struct hci_uart *hu, bool on)\n{\n\tint ret;\n\tint timeout = msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS);\n\tu8 cmd = on ? QCA_WCN3990_POWERON_PULSE : QCA_WCN3990_POWEROFF_PULSE;\n\n\t/* These power pulses are single byte command which are sent\n\t * at required baudrate to wcn3990. On wcn3990, we have an external\n\t * circuit at Tx pin which decodes the pulse sent at specific baudrate.\n\t * For example, wcn3990 supports RF COEX antenna for both Wi-Fi/BT\n\t * and also we use the same power inputs to turn on and off for\n\t * Wi-Fi/BT. Powering up the power sources will not enable BT, until\n\t * we send a power on pulse at 115200 bps. This algorithm will help to\n\t * save power. Disabling hardware flow control is mandatory while\n\t * sending power pulses to SoC.\n\t */\n\tbt_dev_dbg(hu->hdev, \"sending power pulse %02x to controller\", cmd);\n\n\tserdev_device_write_flush(hu->serdev);\n\thci_uart_set_flow_control(hu, true);\n\tret = serdev_device_write_buf(hu->serdev, &cmd, sizeof(cmd));\n\tif (ret < 0) {\n\t\tbt_dev_err(hu->hdev, \"failed to send power pulse %02x\", cmd);\n\t\treturn ret;\n\t}\n\n\tserdev_device_wait_until_sent(hu->serdev, timeout);\n\thci_uart_set_flow_control(hu, false);\n\n\t/* Give to controller time to boot/shutdown */\n\tif (on)\n\t\tmsleep(100);\n\telse\n\t\tusleep_range(1000, 10000);\n\n\treturn 0;\n}\n\nstatic unsigned int qca_get_speed(struct hci_uart *hu,\n\t\t\t\t  enum qca_speed_type speed_type)\n{\n\tunsigned int speed = 0;\n\n\tif (speed_type == QCA_INIT_SPEED) {\n\t\tif (hu->init_speed)\n\t\t\tspeed = hu->init_speed;\n\t\telse if (hu->proto->init_speed)\n\t\t\tspeed = hu->proto->init_speed;\n\t} else {\n\t\tif (hu->oper_speed)\n\t\t\tspeed = hu->oper_speed;\n\t\telse if (hu->proto->oper_speed)\n\t\t\tspeed = hu->proto->oper_speed;\n\t}\n\n\treturn speed;\n}\n\nstatic int qca_check_speeds(struct hci_uart *hu)\n{\n\tif (qca_is_wcn399x(qca_soc_type(hu)) ||\n\t    qca_is_wcn6750(qca_soc_type(hu))) {\n\t\tif (!qca_get_speed(hu, QCA_INIT_SPEED) &&\n\t\t    !qca_get_speed(hu, QCA_OPER_SPEED))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!qca_get_speed(hu, QCA_INIT_SPEED) ||\n\t\t    !qca_get_speed(hu, QCA_OPER_SPEED))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int qca_set_speed(struct hci_uart *hu, enum qca_speed_type speed_type)\n{\n\tunsigned int speed, qca_baudrate;\n\tstruct qca_data *qca = hu->priv;\n\tint ret = 0;\n\n\tif (speed_type == QCA_INIT_SPEED) {\n\t\tspeed = qca_get_speed(hu, QCA_INIT_SPEED);\n\t\tif (speed)\n\t\t\thost_set_baudrate(hu, speed);\n\t} else {\n\t\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\n\t\tspeed = qca_get_speed(hu, QCA_OPER_SPEED);\n\t\tif (!speed)\n\t\t\treturn 0;\n\n\t\t/* Disable flow control for wcn3990 to deassert RTS while\n\t\t * changing the baudrate of chip and host.\n\t\t */\n\t\tif (qca_is_wcn399x(soc_type) ||\n\t\t    qca_is_wcn6750(soc_type))\n\t\t\thci_uart_set_flow_control(hu, true);\n\n\t\tif (soc_type == QCA_WCN3990) {\n\t\t\treinit_completion(&qca->drop_ev_comp);\n\t\t\tset_bit(QCA_DROP_VENDOR_EVENT, &qca->flags);\n\t\t}\n\n\t\tqca_baudrate = qca_get_baudrate_value(speed);\n\t\tbt_dev_dbg(hu->hdev, \"Set UART speed to %d\", speed);\n\t\tret = qca_set_baudrate(hu->hdev, qca_baudrate);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\thost_set_baudrate(hu, speed);\n\nerror:\n\t\tif (qca_is_wcn399x(soc_type) ||\n\t\t    qca_is_wcn6750(soc_type))\n\t\t\thci_uart_set_flow_control(hu, false);\n\n\t\tif (soc_type == QCA_WCN3990) {\n\t\t\t/* Wait for the controller to send the vendor event\n\t\t\t * for the baudrate change command.\n\t\t\t */\n\t\t\tif (!wait_for_completion_timeout(&qca->drop_ev_comp,\n\t\t\t\t\t\t msecs_to_jiffies(100))) {\n\t\t\t\tbt_dev_err(hu->hdev,\n\t\t\t\t\t   \"Failed to change controller baudrate\\n\");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t}\n\n\t\t\tclear_bit(QCA_DROP_VENDOR_EVENT, &qca->flags);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int qca_send_crashbuffer(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(QCA_CRASHBYTE_PACKET_LEN, GFP_KERNEL);\n\tif (!skb) {\n\t\tbt_dev_err(hu->hdev, \"Failed to allocate memory for skb packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* We forcefully crash the controller, by sending 0xfb byte for\n\t * 1024 times. We also might have chance of losing data, To be\n\t * on safer side we send 1096 bytes to the SoC.\n\t */\n\tmemset(skb_put(skb, QCA_CRASHBYTE_PACKET_LEN), QCA_MEMDUMP_BYTE,\n\t       QCA_CRASHBYTE_PACKET_LEN);\n\thci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\n\tbt_dev_info(hu->hdev, \"crash the soc to collect controller dump\");\n\tskb_queue_tail(&qca->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\treturn 0;\n}\n\nstatic void qca_wait_for_dump_collection(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\twait_on_bit_timeout(&qca->flags, QCA_MEMDUMP_COLLECTION,\n\t\t\t    TASK_UNINTERRUPTIBLE, MEMDUMP_TIMEOUT_MS);\n\n\tclear_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n}\n\nstatic void qca_hw_error(struct hci_dev *hdev, u8 code)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\tset_bit(QCA_SSR_TRIGGERED, &qca->flags);\n\tset_bit(QCA_HW_ERROR_EVENT, &qca->flags);\n\tbt_dev_info(hdev, \"mem_dump_status: %d\", qca->memdump_state);\n\n\tif (qca->memdump_state == QCA_MEMDUMP_IDLE) {\n\t\t/* If hardware error event received for other than QCA\n\t\t * soc memory dump event, then we need to crash the SOC\n\t\t * and wait here for 8 seconds to get the dump packets.\n\t\t * This will block main thread to be on hold until we\n\t\t * collect dump.\n\t\t */\n\t\tset_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n\t\tqca_send_crashbuffer(hu);\n\t\tqca_wait_for_dump_collection(hdev);\n\t} else if (qca->memdump_state == QCA_MEMDUMP_COLLECTING) {\n\t\t/* Let us wait here until memory dump collected or\n\t\t * memory dump timer expired.\n\t\t */\n\t\tbt_dev_info(hdev, \"waiting for dump to complete\");\n\t\tqca_wait_for_dump_collection(hdev);\n\t}\n\n\tmutex_lock(&qca->hci_memdump_lock);\n\tif (qca->memdump_state != QCA_MEMDUMP_COLLECTED) {\n\t\tbt_dev_err(hu->hdev, \"clearing allocated memory due to memdump timeout\");\n\t\tif (qca->qca_memdump) {\n\t\t\tvfree(qca->qca_memdump->memdump_buf_head);\n\t\t\tkfree(qca->qca_memdump);\n\t\t\tqca->qca_memdump = NULL;\n\t\t}\n\t\tqca->memdump_state = QCA_MEMDUMP_TIMEOUT;\n\t\tcancel_delayed_work(&qca->ctrl_memdump_timeout);\n\t}\n\tmutex_unlock(&qca->hci_memdump_lock);\n\n\tif (qca->memdump_state == QCA_MEMDUMP_TIMEOUT ||\n\t    qca->memdump_state == QCA_MEMDUMP_COLLECTED) {\n\t\tcancel_work_sync(&qca->ctrl_memdump_evt);\n\t\tskb_queue_purge(&qca->rx_memdump_q);\n\t}\n\n\tclear_bit(QCA_HW_ERROR_EVENT, &qca->flags);\n}\n\nstatic void qca_cmd_timeout(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\tset_bit(QCA_SSR_TRIGGERED, &qca->flags);\n\tif (qca->memdump_state == QCA_MEMDUMP_IDLE) {\n\t\tset_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n\t\tqca_send_crashbuffer(hu);\n\t\tqca_wait_for_dump_collection(hdev);\n\t} else if (qca->memdump_state == QCA_MEMDUMP_COLLECTING) {\n\t\t/* Let us wait here until memory dump collected or\n\t\t * memory dump timer expired.\n\t\t */\n\t\tbt_dev_info(hdev, \"waiting for dump to complete\");\n\t\tqca_wait_for_dump_collection(hdev);\n\t}\n\n\tmutex_lock(&qca->hci_memdump_lock);\n\tif (qca->memdump_state != QCA_MEMDUMP_COLLECTED) {\n\t\tqca->memdump_state = QCA_MEMDUMP_TIMEOUT;\n\t\tif (!test_bit(QCA_HW_ERROR_EVENT, &qca->flags)) {\n\t\t\t/* Inject hw error event to reset the device\n\t\t\t * and driver.\n\t\t\t */\n\t\t\thci_reset_dev(hu->hdev);\n\t\t}\n\t}\n\tmutex_unlock(&qca->hci_memdump_lock);\n}\n\nstatic bool qca_wakeup(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tbool wakeup;\n\n\t/* UART driver handles the interrupt from BT SoC.So we need to use\n\t * device handle of UART driver to get the status of device may wakeup.\n\t */\n\twakeup = device_may_wakeup(hu->serdev->ctrl->dev.parent);\n\tbt_dev_dbg(hu->hdev, \"wakeup status : %d\", wakeup);\n\n\treturn !wakeup;\n}\n\nstatic int qca_regulator_init(struct hci_uart *hu)\n{\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\tstruct qca_serdev *qcadev;\n\tint ret;\n\tbool sw_ctrl_state;\n\n\t/* Check for vregs status, may be hci down has turned\n\t * off the voltage regulator.\n\t */\n\tqcadev = serdev_device_get_drvdata(hu->serdev);\n\tif (!qcadev->bt_power->vregs_on) {\n\t\tserdev_device_close(hu->serdev);\n\t\tret = qca_regulator_enable(qcadev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = serdev_device_open(hu->serdev);\n\t\tif (ret) {\n\t\t\tbt_dev_err(hu->hdev, \"failed to open port\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (qca_is_wcn399x(soc_type)) {\n\t\t/* Forcefully enable wcn399x to enter in to boot mode. */\n\t\thost_set_baudrate(hu, 2400);\n\t\tret = qca_send_power_pulse(hu, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* For wcn6750 need to enable gpio bt_en */\n\tif (qcadev->bt_en) {\n\t\tgpiod_set_value_cansleep(qcadev->bt_en, 0);\n\t\tmsleep(50);\n\t\tgpiod_set_value_cansleep(qcadev->bt_en, 1);\n\t\tmsleep(50);\n\t\tif (qcadev->sw_ctrl) {\n\t\t\tsw_ctrl_state = gpiod_get_value_cansleep(qcadev->sw_ctrl);\n\t\t\tbt_dev_dbg(hu->hdev, \"SW_CTRL is %d\", sw_ctrl_state);\n\t\t}\n\t}\n\n\tqca_set_speed(hu, QCA_INIT_SPEED);\n\n\tif (qca_is_wcn399x(soc_type)) {\n\t\tret = qca_send_power_pulse(hu, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Now the device is in ready state to communicate with host.\n\t * To sync host with device we need to reopen port.\n\t * Without this, we will have RTS and CTS synchronization\n\t * issues.\n\t */\n\tserdev_device_close(hu->serdev);\n\tret = serdev_device_open(hu->serdev);\n\tif (ret) {\n\t\tbt_dev_err(hu->hdev, \"failed to open port\");\n\t\treturn ret;\n\t}\n\n\thci_uart_set_flow_control(hu, false);\n\n\treturn 0;\n}\n\nstatic int qca_power_on(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\tstruct qca_serdev *qcadev;\n\tstruct qca_data *qca = hu->priv;\n\tint ret = 0;\n\n\t/* Non-serdev device usually is powered by external power\n\t * and don't need additional action in driver for power on\n\t */\n\tif (!hu->serdev)\n\t\treturn 0;\n\n\tif (qca_is_wcn399x(soc_type) ||\n\t    qca_is_wcn6750(soc_type)) {\n\t\tret = qca_regulator_init(hu);\n\t} else {\n\t\tqcadev = serdev_device_get_drvdata(hu->serdev);\n\t\tif (qcadev->bt_en) {\n\t\t\tgpiod_set_value_cansleep(qcadev->bt_en, 1);\n\t\t\t/* Controller needs time to bootup. */\n\t\t\tmsleep(150);\n\t\t}\n\t}\n\n\tclear_bit(QCA_BT_OFF, &qca->flags);\n\treturn ret;\n}\n\nstatic int qca_setup(struct hci_uart *hu)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct qca_data *qca = hu->priv;\n\tunsigned int speed, qca_baudrate = QCA_BAUDRATE_115200;\n\tunsigned int retries = 0;\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\tconst char *firmware_name = qca_get_firmware_name(hu);\n\tint ret;\n\tstruct qca_btsoc_version ver;\n\n\tret = qca_check_speeds(hu);\n\tif (ret)\n\t\treturn ret;\n\n\tclear_bit(QCA_ROM_FW, &qca->flags);\n\t/* Patch downloading has to be done without IBS mode */\n\tset_bit(QCA_IBS_DISABLED, &qca->flags);\n\n\t/* Enable controller to do both LE scan and BR/EDR inquiry\n\t * simultaneously.\n\t */\n\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\n\tbt_dev_info(hdev, \"setting up %s\",\n\t\tqca_is_wcn399x(soc_type) ? \"wcn399x\" :\n\t\t(soc_type == QCA_WCN6750) ? \"wcn6750\" : \"ROME/QCA6390\");\n\n\tqca->memdump_state = QCA_MEMDUMP_IDLE;\n\nretry:\n\tret = qca_power_on(hdev);\n\tif (ret)\n\t\tgoto out;\n\n\tclear_bit(QCA_SSR_TRIGGERED, &qca->flags);\n\n\tif (qca_is_wcn399x(soc_type) ||\n\t    qca_is_wcn6750(soc_type)) {\n\t\tset_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks);\n\t\thci_set_aosp_capable(hdev);\n\n\t\tret = qca_read_soc_version(hdev, &ver, soc_type);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tqca_set_speed(hu, QCA_INIT_SPEED);\n\t}\n\n\t/* Setup user speed if needed */\n\tspeed = qca_get_speed(hu, QCA_OPER_SPEED);\n\tif (speed) {\n\t\tret = qca_set_speed(hu, QCA_OPER_SPEED);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tqca_baudrate = qca_get_baudrate_value(speed);\n\t}\n\n\tif (!(qca_is_wcn399x(soc_type) ||\n\t     qca_is_wcn6750(soc_type))) {\n\t\t/* Get QCA version information */\n\t\tret = qca_read_soc_version(hdev, &ver, soc_type);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* Setup patch / NVM configurations */\n\tret = qca_uart_setup(hdev, qca_baudrate, soc_type, ver,\n\t\t\tfirmware_name);\n\tif (!ret) {\n\t\tclear_bit(QCA_IBS_DISABLED, &qca->flags);\n\t\tqca_debugfs_init(hdev);\n\t\thu->hdev->hw_error = qca_hw_error;\n\t\thu->hdev->cmd_timeout = qca_cmd_timeout;\n\t\thu->hdev->wakeup = qca_wakeup;\n\t} else if (ret == -ENOENT) {\n\t\t/* No patch/nvm-config found, run with original fw/config */\n\t\tset_bit(QCA_ROM_FW, &qca->flags);\n\t\tret = 0;\n\t} else if (ret == -EAGAIN) {\n\t\t/*\n\t\t * Userspace firmware loader will return -EAGAIN in case no\n\t\t * patch/nvm-config is found, so run with original fw/config.\n\t\t */\n\t\tset_bit(QCA_ROM_FW, &qca->flags);\n\t\tret = 0;\n\t}\n\nout:\n\tif (ret && retries < MAX_INIT_RETRIES) {\n\t\tbt_dev_warn(hdev, \"Retry BT power ON:%d\", retries);\n\t\tqca_power_shutdown(hu);\n\t\tif (hu->serdev) {\n\t\t\tserdev_device_close(hu->serdev);\n\t\t\tret = serdev_device_open(hu->serdev);\n\t\t\tif (ret) {\n\t\t\t\tbt_dev_err(hdev, \"failed to open port\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tretries++;\n\t\tgoto retry;\n\t}\n\n\t/* Setup bdaddr */\n\tif (soc_type == QCA_ROME)\n\t\thu->hdev->set_bdaddr = qca_set_bdaddr_rome;\n\telse\n\t\thu->hdev->set_bdaddr = qca_set_bdaddr;\n\n\treturn ret;\n}\n\nstatic const struct hci_uart_proto qca_proto = {\n\t.id\t\t= HCI_UART_QCA,\n\t.name\t\t= \"QCA\",\n\t.manufacturer\t= 29,\n\t.init_speed\t= 115200,\n\t.oper_speed\t= 3000000,\n\t.open\t\t= qca_open,\n\t.close\t\t= qca_close,\n\t.flush\t\t= qca_flush,\n\t.setup\t\t= qca_setup,\n\t.recv\t\t= qca_recv,\n\t.enqueue\t= qca_enqueue,\n\t.dequeue\t= qca_dequeue,\n};\n\nstatic const struct qca_device_data qca_soc_data_wcn3990 = {\n\t.soc_type = QCA_WCN3990,\n\t.vregs = (struct qca_vreg []) {\n\t\t{ \"vddio\", 15000  },\n\t\t{ \"vddxo\", 80000  },\n\t\t{ \"vddrf\", 300000 },\n\t\t{ \"vddch0\", 450000 },\n\t},\n\t.num_vregs = 4,\n};\n\nstatic const struct qca_device_data qca_soc_data_wcn3991 = {\n\t.soc_type = QCA_WCN3991,\n\t.vregs = (struct qca_vreg []) {\n\t\t{ \"vddio\", 15000  },\n\t\t{ \"vddxo\", 80000  },\n\t\t{ \"vddrf\", 300000 },\n\t\t{ \"vddch0\", 450000 },\n\t},\n\t.num_vregs = 4,\n\t.capabilities = QCA_CAP_WIDEBAND_SPEECH | QCA_CAP_VALID_LE_STATES,\n};\n\nstatic const struct qca_device_data qca_soc_data_wcn3998 = {\n\t.soc_type = QCA_WCN3998,\n\t.vregs = (struct qca_vreg []) {\n\t\t{ \"vddio\", 10000  },\n\t\t{ \"vddxo\", 80000  },\n\t\t{ \"vddrf\", 300000 },\n\t\t{ \"vddch0\", 450000 },\n\t},\n\t.num_vregs = 4,\n};\n\nstatic const struct qca_device_data qca_soc_data_qca6390 = {\n\t.soc_type = QCA_QCA6390,\n\t.num_vregs = 0,\n};\n\nstatic const struct qca_device_data qca_soc_data_wcn6750 = {\n\t.soc_type = QCA_WCN6750,\n\t.vregs = (struct qca_vreg []) {\n\t\t{ \"vddio\", 5000 },\n\t\t{ \"vddaon\", 26000 },\n\t\t{ \"vddbtcxmx\", 126000 },\n\t\t{ \"vddrfacmn\", 12500 },\n\t\t{ \"vddrfa0p8\", 102000 },\n\t\t{ \"vddrfa1p7\", 302000 },\n\t\t{ \"vddrfa1p2\", 257000 },\n\t\t{ \"vddrfa2p2\", 1700000 },\n\t\t{ \"vddasd\", 200 },\n\t},\n\t.num_vregs = 9,\n\t.capabilities = QCA_CAP_WIDEBAND_SPEECH | QCA_CAP_VALID_LE_STATES,\n};\n\nstatic void qca_power_shutdown(struct hci_uart *hu)\n{\n\tstruct qca_serdev *qcadev;\n\tstruct qca_data *qca = hu->priv;\n\tunsigned long flags;\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\tbool sw_ctrl_state;\n\n\t/* From this point we go into power off state. But serial port is\n\t * still open, stop queueing the IBS data and flush all the buffered\n\t * data in skb's.\n\t */\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\tset_bit(QCA_IBS_DISABLED, &qca->flags);\n\tqca_flush(hu);\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Non-serdev device usually is powered by external power\n\t * and don't need additional action in driver for power down\n\t */\n\tif (!hu->serdev)\n\t\treturn;\n\n\tqcadev = serdev_device_get_drvdata(hu->serdev);\n\n\tif (qca_is_wcn399x(soc_type)) {\n\t\thost_set_baudrate(hu, 2400);\n\t\tqca_send_power_pulse(hu, false);\n\t\tqca_regulator_disable(qcadev);\n\t} else if (soc_type == QCA_WCN6750) {\n\t\tgpiod_set_value_cansleep(qcadev->bt_en, 0);\n\t\tmsleep(100);\n\t\tqca_regulator_disable(qcadev);\n\t\tif (qcadev->sw_ctrl) {\n\t\t\tsw_ctrl_state = gpiod_get_value_cansleep(qcadev->sw_ctrl);\n\t\t\tbt_dev_dbg(hu->hdev, \"SW_CTRL is %d\", sw_ctrl_state);\n\t\t}\n\t} else if (qcadev->bt_en) {\n\t\tgpiod_set_value_cansleep(qcadev->bt_en, 0);\n\t}\n\n\tset_bit(QCA_BT_OFF, &qca->flags);\n}\n\nstatic int qca_power_off(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\n\thu->hdev->hw_error = NULL;\n\thu->hdev->cmd_timeout = NULL;\n\n\tdel_timer_sync(&qca->wake_retrans_timer);\n\tdel_timer_sync(&qca->tx_idle_timer);\n\n\t/* Stop sending shutdown command if soc crashes. */\n\tif (soc_type != QCA_ROME\n\t\t&& qca->memdump_state == QCA_MEMDUMP_IDLE) {\n\t\tqca_send_pre_shutdown_cmd(hdev);\n\t\tusleep_range(8000, 10000);\n\t}\n\n\tqca_power_shutdown(hu);\n\treturn 0;\n}\n\nstatic int qca_regulator_enable(struct qca_serdev *qcadev)\n{\n\tstruct qca_power *power = qcadev->bt_power;\n\tint ret;\n\n\t/* Already enabled */\n\tif (power->vregs_on)\n\t\treturn 0;\n\n\tBT_DBG(\"enabling %d regulators)\", power->num_vregs);\n\n\tret = regulator_bulk_enable(power->num_vregs, power->vreg_bulk);\n\tif (ret)\n\t\treturn ret;\n\n\tpower->vregs_on = true;\n\n\tret = clk_prepare_enable(qcadev->susclk);\n\tif (ret)\n\t\tqca_regulator_disable(qcadev);\n\n\treturn ret;\n}\n\nstatic void qca_regulator_disable(struct qca_serdev *qcadev)\n{\n\tstruct qca_power *power;\n\n\tif (!qcadev)\n\t\treturn;\n\n\tpower = qcadev->bt_power;\n\n\t/* Already disabled? */\n\tif (!power->vregs_on)\n\t\treturn;\n\n\tregulator_bulk_disable(power->num_vregs, power->vreg_bulk);\n\tpower->vregs_on = false;\n\n\tclk_disable_unprepare(qcadev->susclk);\n}\n\nstatic int qca_init_regulators(struct qca_power *qca,\n\t\t\t\tconst struct qca_vreg *vregs, size_t num_vregs)\n{\n\tstruct regulator_bulk_data *bulk;\n\tint ret;\n\tint i;\n\n\tbulk = devm_kcalloc(qca->dev, num_vregs, sizeof(*bulk), GFP_KERNEL);\n\tif (!bulk)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_vregs; i++)\n\t\tbulk[i].supply = vregs[i].name;\n\n\tret = devm_regulator_bulk_get(qca->dev, num_vregs, bulk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_vregs; i++) {\n\t\tret = regulator_set_load(bulk[i].consumer, vregs[i].load_uA);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tqca->vreg_bulk = bulk;\n\tqca->num_vregs = num_vregs;\n\n\treturn 0;\n}\n\nstatic int qca_serdev_probe(struct serdev_device *serdev)\n{\n\tstruct qca_serdev *qcadev;\n\tstruct hci_dev *hdev;\n\tconst struct qca_device_data *data;\n\tint err;\n\tbool power_ctrl_enabled = true;\n\n\tqcadev = devm_kzalloc(&serdev->dev, sizeof(*qcadev), GFP_KERNEL);\n\tif (!qcadev)\n\t\treturn -ENOMEM;\n\n\tqcadev->serdev_hu.serdev = serdev;\n\tdata = device_get_match_data(&serdev->dev);\n\tserdev_device_set_drvdata(serdev, qcadev);\n\tdevice_property_read_string(&serdev->dev, \"firmware-name\",\n\t\t\t\t\t &qcadev->firmware_name);\n\tdevice_property_read_u32(&serdev->dev, \"max-speed\",\n\t\t\t\t &qcadev->oper_speed);\n\tif (!qcadev->oper_speed)\n\t\tBT_DBG(\"UART will pick default operating speed\");\n\n\tif (data &&\n\t    (qca_is_wcn399x(data->soc_type) ||\n\t    qca_is_wcn6750(data->soc_type))) {\n\t\tqcadev->btsoc_type = data->soc_type;\n\t\tqcadev->bt_power = devm_kzalloc(&serdev->dev,\n\t\t\t\t\t\tsizeof(struct qca_power),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!qcadev->bt_power)\n\t\t\treturn -ENOMEM;\n\n\t\tqcadev->bt_power->dev = &serdev->dev;\n\t\terr = qca_init_regulators(qcadev->bt_power, data->vregs,\n\t\t\t\t\t  data->num_vregs);\n\t\tif (err) {\n\t\t\tBT_ERR(\"Failed to init regulators:%d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tqcadev->bt_power->vregs_on = false;\n\n\t\tqcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\",\n\t\t\t\t\t       GPIOD_OUT_LOW);\n\t\tif (!qcadev->bt_en && data->soc_type == QCA_WCN6750) {\n\t\t\tdev_err(&serdev->dev, \"failed to acquire BT_EN gpio\\n\");\n\t\t\tpower_ctrl_enabled = false;\n\t\t}\n\n\t\tqcadev->sw_ctrl = devm_gpiod_get_optional(&serdev->dev, \"swctrl\",\n\t\t\t\t\t       GPIOD_IN);\n\t\tif (!qcadev->sw_ctrl && data->soc_type == QCA_WCN6750)\n\t\t\tdev_warn(&serdev->dev, \"failed to acquire SW_CTRL gpio\\n\");\n\n\t\tqcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);\n\t\tif (IS_ERR(qcadev->susclk)) {\n\t\t\tdev_err(&serdev->dev, \"failed to acquire clk\\n\");\n\t\t\treturn PTR_ERR(qcadev->susclk);\n\t\t}\n\n\t\terr = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);\n\t\tif (err) {\n\t\t\tBT_ERR(\"wcn3990 serdev registration failed\");\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (data)\n\t\t\tqcadev->btsoc_type = data->soc_type;\n\t\telse\n\t\t\tqcadev->btsoc_type = QCA_ROME;\n\n\t\tqcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\",\n\t\t\t\t\t       GPIOD_OUT_LOW);\n\t\tif (!qcadev->bt_en) {\n\t\t\tdev_warn(&serdev->dev, \"failed to acquire enable gpio\\n\");\n\t\t\tpower_ctrl_enabled = false;\n\t\t}\n\n\t\tqcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);\n\t\tif (IS_ERR(qcadev->susclk)) {\n\t\t\tdev_warn(&serdev->dev, \"failed to acquire clk\\n\");\n\t\t\treturn PTR_ERR(qcadev->susclk);\n\t\t}\n\t\terr = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = clk_prepare_enable(qcadev->susclk);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);\n\t\tif (err) {\n\t\t\tBT_ERR(\"Rome serdev registration failed\");\n\t\t\tclk_disable_unprepare(qcadev->susclk);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\thdev = qcadev->serdev_hu.hdev;\n\n\tif (power_ctrl_enabled) {\n\t\tset_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);\n\t\thdev->shutdown = qca_power_off;\n\t}\n\n\tif (data) {\n\t\t/* Wideband speech support must be set per driver since it can't\n\t\t * be queried via hci. Same with the valid le states quirk.\n\t\t */\n\t\tif (data->capabilities & QCA_CAP_WIDEBAND_SPEECH)\n\t\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,\n\t\t\t\t&hdev->quirks);\n\n\t\tif (data->capabilities & QCA_CAP_VALID_LE_STATES)\n\t\t\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\t}\n\n\treturn 0;\n}\n\nstatic void qca_serdev_remove(struct serdev_device *serdev)\n{\n\tstruct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);\n\tstruct qca_power *power = qcadev->bt_power;\n\n\tif ((qca_is_wcn399x(qcadev->btsoc_type) ||\n\t     qca_is_wcn6750(qcadev->btsoc_type)) &&\n\t     power->vregs_on)\n\t\tqca_power_shutdown(&qcadev->serdev_hu);\n\telse if (qcadev->susclk)\n\t\tclk_disable_unprepare(qcadev->susclk);\n\n\thci_uart_unregister_device(&qcadev->serdev_hu);\n}\n\nstatic void qca_serdev_shutdown(struct device *dev)\n{\n\tint ret;\n\tint timeout = msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS);\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\tstruct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);\n\tconst u8 ibs_wake_cmd[] = { 0xFD };\n\tconst u8 edl_reset_soc_cmd[] = { 0x01, 0x00, 0xFC, 0x01, 0x05 };\n\n\tif (qcadev->btsoc_type == QCA_QCA6390) {\n\t\tserdev_device_write_flush(serdev);\n\t\tret = serdev_device_write_buf(serdev, ibs_wake_cmd,\n\t\t\t\t\t      sizeof(ibs_wake_cmd));\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"QCA send IBS_WAKE_IND error: %d\", ret);\n\t\t\treturn;\n\t\t}\n\t\tserdev_device_wait_until_sent(serdev, timeout);\n\t\tusleep_range(8000, 10000);\n\n\t\tserdev_device_write_flush(serdev);\n\t\tret = serdev_device_write_buf(serdev, edl_reset_soc_cmd,\n\t\t\t\t\t      sizeof(edl_reset_soc_cmd));\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"QCA send EDL_RESET_REQ error: %d\", ret);\n\t\t\treturn;\n\t\t}\n\t\tserdev_device_wait_until_sent(serdev, timeout);\n\t\tusleep_range(8000, 10000);\n\t}\n}\n\nstatic int __maybe_unused qca_suspend(struct device *dev)\n{\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\tstruct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);\n\tstruct hci_uart *hu = &qcadev->serdev_hu;\n\tstruct qca_data *qca = hu->priv;\n\tunsigned long flags;\n\tbool tx_pending = false;\n\tint ret = 0;\n\tu8 cmd;\n\tu32 wait_timeout = 0;\n\n\tset_bit(QCA_SUSPENDING, &qca->flags);\n\n\t/* if BT SoC is running with default firmware then it does not\n\t * support in-band sleep\n\t */\n\tif (test_bit(QCA_ROM_FW, &qca->flags))\n\t\treturn 0;\n\n\t/* During SSR after memory dump collection, controller will be\n\t * powered off and then powered on.If controller is powered off\n\t * during SSR then we should wait until SSR is completed.\n\t */\n\tif (test_bit(QCA_BT_OFF, &qca->flags) &&\n\t    !test_bit(QCA_SSR_TRIGGERED, &qca->flags))\n\t\treturn 0;\n\n\tif (test_bit(QCA_IBS_DISABLED, &qca->flags) ||\n\t    test_bit(QCA_SSR_TRIGGERED, &qca->flags)) {\n\t\twait_timeout = test_bit(QCA_SSR_TRIGGERED, &qca->flags) ?\n\t\t\t\t\tIBS_DISABLE_SSR_TIMEOUT_MS :\n\t\t\t\t\tFW_DOWNLOAD_TIMEOUT_MS;\n\n\t\t/* QCA_IBS_DISABLED flag is set to true, During FW download\n\t\t * and during memory dump collection. It is reset to false,\n\t\t * After FW download complete.\n\t\t */\n\t\twait_on_bit_timeout(&qca->flags, QCA_IBS_DISABLED,\n\t\t\t    TASK_UNINTERRUPTIBLE, msecs_to_jiffies(wait_timeout));\n\n\t\tif (test_bit(QCA_IBS_DISABLED, &qca->flags)) {\n\t\t\tbt_dev_err(hu->hdev, \"SSR or FW download time out\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tcancel_work_sync(&qca->ws_awake_device);\n\tcancel_work_sync(&qca->ws_awake_rx);\n\n\tspin_lock_irqsave_nested(&qca->hci_ibs_lock,\n\t\t\t\t flags, SINGLE_DEPTH_NESTING);\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_WAKING:\n\t\tdel_timer(&qca->wake_retrans_timer);\n\t\tfallthrough;\n\tcase HCI_IBS_TX_AWAKE:\n\t\tdel_timer(&qca->tx_idle_timer);\n\n\t\tserdev_device_write_flush(hu->serdev);\n\t\tcmd = HCI_IBS_SLEEP_IND;\n\t\tret = serdev_device_write_buf(hu->serdev, &cmd, sizeof(cmd));\n\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"Failed to send SLEEP to device\");\n\t\t\tbreak;\n\t\t}\n\n\t\tqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\n\t\tqca->ibs_sent_slps++;\n\t\ttx_pending = true;\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Spurious tx state %d\", qca->tx_ibs_state);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (tx_pending) {\n\t\tserdev_device_wait_until_sent(hu->serdev,\n\t\t\t\t\t      msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS));\n\t\tserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_OFF, hu);\n\t}\n\n\t/* Wait for HCI_IBS_SLEEP_IND sent by device to indicate its Tx is going\n\t * to sleep, so that the packet does not wake the system later.\n\t */\n\tret = wait_event_interruptible_timeout(qca->suspend_wait_q,\n\t\t\tqca->rx_ibs_state == HCI_IBS_RX_ASLEEP,\n\t\t\tmsecs_to_jiffies(IBS_BTSOC_TX_IDLE_TIMEOUT_MS));\n\tif (ret == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tclear_bit(QCA_SUSPENDING, &qca->flags);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused qca_resume(struct device *dev)\n{\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\tstruct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);\n\tstruct hci_uart *hu = &qcadev->serdev_hu;\n\tstruct qca_data *qca = hu->priv;\n\n\tclear_bit(QCA_SUSPENDING, &qca->flags);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(qca_pm_ops, qca_suspend, qca_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id qca_bluetooth_of_match[] = {\n\t{ .compatible = \"qcom,qca6174-bt\" },\n\t{ .compatible = \"qcom,qca6390-bt\", .data = &qca_soc_data_qca6390},\n\t{ .compatible = \"qcom,qca9377-bt\" },\n\t{ .compatible = \"qcom,wcn3990-bt\", .data = &qca_soc_data_wcn3990},\n\t{ .compatible = \"qcom,wcn3991-bt\", .data = &qca_soc_data_wcn3991},\n\t{ .compatible = \"qcom,wcn3998-bt\", .data = &qca_soc_data_wcn3998},\n\t{ .compatible = \"qcom,wcn6750-bt\", .data = &qca_soc_data_wcn6750},\n\t{ /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, qca_bluetooth_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id qca_bluetooth_acpi_match[] = {\n\t{ \"QCOM6390\", (kernel_ulong_t)&qca_soc_data_qca6390 },\n\t{ \"DLA16390\", (kernel_ulong_t)&qca_soc_data_qca6390 },\n\t{ \"DLB16390\", (kernel_ulong_t)&qca_soc_data_qca6390 },\n\t{ \"DLB26390\", (kernel_ulong_t)&qca_soc_data_qca6390 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, qca_bluetooth_acpi_match);\n#endif\n\n\nstatic struct serdev_device_driver qca_serdev_driver = {\n\t.probe = qca_serdev_probe,\n\t.remove = qca_serdev_remove,\n\t.driver = {\n\t\t.name = \"hci_uart_qca\",\n\t\t.of_match_table = of_match_ptr(qca_bluetooth_of_match),\n\t\t.acpi_match_table = ACPI_PTR(qca_bluetooth_acpi_match),\n\t\t.shutdown = qca_serdev_shutdown,\n\t\t.pm = &qca_pm_ops,\n\t},\n};\n\nint __init qca_init(void)\n{\n\tserdev_device_driver_register(&qca_serdev_driver);\n\n\treturn hci_uart_register_proto(&qca_proto);\n}\n\nint __exit qca_deinit(void)\n{\n\tserdev_device_driver_unregister(&qca_serdev_driver);\n\n\treturn hci_uart_unregister_proto(&qca_proto);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  Bluetooth Software UART Qualcomm protocol\n *\n *  HCI_IBS (HCI In-Band Sleep) is Qualcomm's power management\n *  protocol extension to H4.\n *\n *  Copyright (C) 2007 Texas Instruments, Inc.\n *  Copyright (c) 2010, 2012, 2018 The Linux Foundation. All rights reserved.\n *\n *  Acknowledgements:\n *  This file is based on hci_ll.c, which was...\n *  Written by Ohad Ben-Cohen <ohad@bencohen.org>\n *  which was in turn based on hci_h4.c, which was written\n *  by Maxim Krasnyansky and Marcel Holtmann.\n */\n\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/devcoredump.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/acpi.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/serdev.h>\n#include <linux/mutex.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n#include \"btqca.h\"\n\n/* HCI_IBS protocol messages */\n#define HCI_IBS_SLEEP_IND\t0xFE\n#define HCI_IBS_WAKE_IND\t0xFD\n#define HCI_IBS_WAKE_ACK\t0xFC\n#define HCI_MAX_IBS_SIZE\t10\n\n#define IBS_WAKE_RETRANS_TIMEOUT_MS\t100\n#define IBS_BTSOC_TX_IDLE_TIMEOUT_MS\t200\n#define IBS_HOST_TX_IDLE_TIMEOUT_MS\t2000\n#define CMD_TRANS_TIMEOUT_MS\t\t100\n#define MEMDUMP_TIMEOUT_MS\t\t8000\n#define IBS_DISABLE_SSR_TIMEOUT_MS \\\n\t(MEMDUMP_TIMEOUT_MS + FW_DOWNLOAD_TIMEOUT_MS)\n#define FW_DOWNLOAD_TIMEOUT_MS\t\t3000\n\n/* susclk rate */\n#define SUSCLK_RATE_32KHZ\t32768\n\n/* Controller debug log header */\n#define QCA_DEBUG_HANDLE\t0x2EDC\n\n/* max retry count when init fails */\n#define MAX_INIT_RETRIES 3\n\n/* Controller dump header */\n#define QCA_SSR_DUMP_HANDLE\t\t0x0108\n#define QCA_DUMP_PACKET_SIZE\t\t255\n#define QCA_LAST_SEQUENCE_NUM\t\t0xFFFF\n#define QCA_CRASHBYTE_PACKET_LEN\t1096\n#define QCA_MEMDUMP_BYTE\t\t0xFB\n\nenum qca_flags {\n\tQCA_IBS_DISABLED,\n\tQCA_DROP_VENDOR_EVENT,\n\tQCA_SUSPENDING,\n\tQCA_MEMDUMP_COLLECTION,\n\tQCA_HW_ERROR_EVENT,\n\tQCA_SSR_TRIGGERED,\n\tQCA_BT_OFF,\n\tQCA_ROM_FW\n};\n\nenum qca_capabilities {\n\tQCA_CAP_WIDEBAND_SPEECH = BIT(0),\n\tQCA_CAP_VALID_LE_STATES = BIT(1),\n};\n\n/* HCI_IBS transmit side sleep protocol states */\nenum tx_ibs_states {\n\tHCI_IBS_TX_ASLEEP,\n\tHCI_IBS_TX_WAKING,\n\tHCI_IBS_TX_AWAKE,\n};\n\n/* HCI_IBS receive side sleep protocol states */\nenum rx_states {\n\tHCI_IBS_RX_ASLEEP,\n\tHCI_IBS_RX_AWAKE,\n};\n\n/* HCI_IBS transmit and receive side clock state vote */\nenum hci_ibs_clock_state_vote {\n\tHCI_IBS_VOTE_STATS_UPDATE,\n\tHCI_IBS_TX_VOTE_CLOCK_ON,\n\tHCI_IBS_TX_VOTE_CLOCK_OFF,\n\tHCI_IBS_RX_VOTE_CLOCK_ON,\n\tHCI_IBS_RX_VOTE_CLOCK_OFF,\n};\n\n/* Controller memory dump states */\nenum qca_memdump_states {\n\tQCA_MEMDUMP_IDLE,\n\tQCA_MEMDUMP_COLLECTING,\n\tQCA_MEMDUMP_COLLECTED,\n\tQCA_MEMDUMP_TIMEOUT,\n};\n\nstruct qca_memdump_data {\n\tchar *memdump_buf_head;\n\tchar *memdump_buf_tail;\n\tu32 current_seq_no;\n\tu32 received_dump;\n\tu32 ram_dump_size;\n};\n\nstruct qca_memdump_event_hdr {\n\t__u8    evt;\n\t__u8    plen;\n\t__u16   opcode;\n\t__u16   seq_no;\n\t__u8    reserved;\n} __packed;\n\n\nstruct qca_dump_size {\n\tu32 dump_size;\n} __packed;\n\nstruct qca_data {\n\tstruct hci_uart *hu;\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n\tstruct sk_buff_head tx_wait_q;\t/* HCI_IBS wait queue\t*/\n\tstruct sk_buff_head rx_memdump_q;\t/* Memdump wait queue\t*/\n\tspinlock_t hci_ibs_lock;\t/* HCI_IBS state lock\t*/\n\tu8 tx_ibs_state;\t/* HCI_IBS transmit side power state*/\n\tu8 rx_ibs_state;\t/* HCI_IBS receive side power state */\n\tbool tx_vote;\t\t/* Clock must be on for TX */\n\tbool rx_vote;\t\t/* Clock must be on for RX */\n\tstruct timer_list tx_idle_timer;\n\tu32 tx_idle_delay;\n\tstruct timer_list wake_retrans_timer;\n\tu32 wake_retrans;\n\tstruct workqueue_struct *workqueue;\n\tstruct work_struct ws_awake_rx;\n\tstruct work_struct ws_awake_device;\n\tstruct work_struct ws_rx_vote_off;\n\tstruct work_struct ws_tx_vote_off;\n\tstruct work_struct ctrl_memdump_evt;\n\tstruct delayed_work ctrl_memdump_timeout;\n\tstruct qca_memdump_data *qca_memdump;\n\tunsigned long flags;\n\tstruct completion drop_ev_comp;\n\twait_queue_head_t suspend_wait_q;\n\tenum qca_memdump_states memdump_state;\n\tstruct mutex hci_memdump_lock;\n\n\t/* For debugging purpose */\n\tu64 ibs_sent_wacks;\n\tu64 ibs_sent_slps;\n\tu64 ibs_sent_wakes;\n\tu64 ibs_recv_wacks;\n\tu64 ibs_recv_slps;\n\tu64 ibs_recv_wakes;\n\tu64 vote_last_jif;\n\tu32 vote_on_ms;\n\tu32 vote_off_ms;\n\tu64 tx_votes_on;\n\tu64 rx_votes_on;\n\tu64 tx_votes_off;\n\tu64 rx_votes_off;\n\tu64 votes_on;\n\tu64 votes_off;\n};\n\nenum qca_speed_type {\n\tQCA_INIT_SPEED = 1,\n\tQCA_OPER_SPEED\n};\n\n/*\n * Voltage regulator information required for configuring the\n * QCA Bluetooth chipset\n */\nstruct qca_vreg {\n\tconst char *name;\n\tunsigned int load_uA;\n};\n\nstruct qca_device_data {\n\tenum qca_btsoc_type soc_type;\n\tstruct qca_vreg *vregs;\n\tsize_t num_vregs;\n\tuint32_t capabilities;\n};\n\n/*\n * Platform data for the QCA Bluetooth power driver.\n */\nstruct qca_power {\n\tstruct device *dev;\n\tstruct regulator_bulk_data *vreg_bulk;\n\tint num_vregs;\n\tbool vregs_on;\n};\n\nstruct qca_serdev {\n\tstruct hci_uart\t serdev_hu;\n\tstruct gpio_desc *bt_en;\n\tstruct gpio_desc *sw_ctrl;\n\tstruct clk\t *susclk;\n\tenum qca_btsoc_type btsoc_type;\n\tstruct qca_power *bt_power;\n\tu32 init_speed;\n\tu32 oper_speed;\n\tconst char *firmware_name;\n};\n\nstatic int qca_regulator_enable(struct qca_serdev *qcadev);\nstatic void qca_regulator_disable(struct qca_serdev *qcadev);\nstatic void qca_power_shutdown(struct hci_uart *hu);\nstatic int qca_power_off(struct hci_dev *hdev);\nstatic void qca_controller_memdump(struct work_struct *work);\n\nstatic enum qca_btsoc_type qca_soc_type(struct hci_uart *hu)\n{\n\tenum qca_btsoc_type soc_type;\n\n\tif (hu->serdev) {\n\t\tstruct qca_serdev *qsd = serdev_device_get_drvdata(hu->serdev);\n\n\t\tsoc_type = qsd->btsoc_type;\n\t} else {\n\t\tsoc_type = QCA_ROME;\n\t}\n\n\treturn soc_type;\n}\n\nstatic const char *qca_get_firmware_name(struct hci_uart *hu)\n{\n\tif (hu->serdev) {\n\t\tstruct qca_serdev *qsd = serdev_device_get_drvdata(hu->serdev);\n\n\t\treturn qsd->firmware_name;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nstatic void __serial_clock_on(struct tty_struct *tty)\n{\n\t/* TODO: Some chipset requires to enable UART clock on client\n\t * side to save power consumption or manual work is required.\n\t * Please put your code to control UART clock here if needed\n\t */\n}\n\nstatic void __serial_clock_off(struct tty_struct *tty)\n{\n\t/* TODO: Some chipset requires to disable UART clock on client\n\t * side to save power consumption or manual work is required.\n\t * Please put your code to control UART clock off here if needed\n\t */\n}\n\n/* serial_clock_vote needs to be called with the ibs lock held */\nstatic void serial_clock_vote(unsigned long vote, struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\tunsigned int diff;\n\n\tbool old_vote = (qca->tx_vote | qca->rx_vote);\n\tbool new_vote;\n\n\tswitch (vote) {\n\tcase HCI_IBS_VOTE_STATS_UPDATE:\n\t\tdiff = jiffies_to_msecs(jiffies - qca->vote_last_jif);\n\n\t\tif (old_vote)\n\t\t\tqca->vote_off_ms += diff;\n\t\telse\n\t\t\tqca->vote_on_ms += diff;\n\t\treturn;\n\n\tcase HCI_IBS_TX_VOTE_CLOCK_ON:\n\t\tqca->tx_vote = true;\n\t\tqca->tx_votes_on++;\n\t\tbreak;\n\n\tcase HCI_IBS_RX_VOTE_CLOCK_ON:\n\t\tqca->rx_vote = true;\n\t\tqca->rx_votes_on++;\n\t\tbreak;\n\n\tcase HCI_IBS_TX_VOTE_CLOCK_OFF:\n\t\tqca->tx_vote = false;\n\t\tqca->tx_votes_off++;\n\t\tbreak;\n\n\tcase HCI_IBS_RX_VOTE_CLOCK_OFF:\n\t\tqca->rx_vote = false;\n\t\tqca->rx_votes_off++;\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Voting irregularity\");\n\t\treturn;\n\t}\n\n\tnew_vote = qca->rx_vote | qca->tx_vote;\n\n\tif (new_vote != old_vote) {\n\t\tif (new_vote)\n\t\t\t__serial_clock_on(hu->tty);\n\t\telse\n\t\t\t__serial_clock_off(hu->tty);\n\n\t\tBT_DBG(\"Vote serial clock %s(%s)\", new_vote ? \"true\" : \"false\",\n\t\t       vote ? \"true\" : \"false\");\n\n\t\tdiff = jiffies_to_msecs(jiffies - qca->vote_last_jif);\n\n\t\tif (new_vote) {\n\t\t\tqca->votes_on++;\n\t\t\tqca->vote_off_ms += diff;\n\t\t} else {\n\t\t\tqca->votes_off++;\n\t\t\tqca->vote_on_ms += diff;\n\t\t}\n\t\tqca->vote_last_jif = jiffies;\n\t}\n}\n\n/* Builds and sends an HCI_IBS command packet.\n * These are very simple packets with only 1 cmd byte.\n */\nstatic int send_hci_ibs_cmd(u8 cmd, struct hci_uart *hu)\n{\n\tint err = 0;\n\tstruct sk_buff *skb = NULL;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p send hci ibs cmd 0x%x\", hu, cmd);\n\n\tskb = bt_skb_alloc(1, GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR(\"Failed to allocate memory for HCI_IBS packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Assign HCI_IBS type */\n\tskb_put_u8(skb, cmd);\n\n\tskb_queue_tail(&qca->txq, skb);\n\n\treturn err;\n}\n\nstatic void qca_wq_awake_device(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_awake_device);\n\tstruct hci_uart *hu = qca->hu;\n\tunsigned long retrans_delay;\n\tunsigned long flags;\n\n\tBT_DBG(\"hu %p wq awake device\", hu);\n\n\t/* Vote for serial clock */\n\tserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_ON, hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\t/* Send wake indication to device */\n\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0)\n\t\tBT_ERR(\"Failed to send WAKE to device\");\n\n\tqca->ibs_sent_wakes++;\n\n\t/* Start retransmit timer */\n\tretrans_delay = msecs_to_jiffies(qca->wake_retrans);\n\tmod_timer(&qca->wake_retrans_timer, jiffies + retrans_delay);\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic void qca_wq_awake_rx(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_awake_rx);\n\tstruct hci_uart *hu = qca->hu;\n\tunsigned long flags;\n\n\tBT_DBG(\"hu %p wq awake rx\", hu);\n\n\tserial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_ON, hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\tqca->rx_ibs_state = HCI_IBS_RX_AWAKE;\n\n\t/* Always acknowledge device wake up,\n\t * sending IBS message doesn't count as TX ON.\n\t */\n\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0)\n\t\tBT_ERR(\"Failed to acknowledge device wake up\");\n\n\tqca->ibs_sent_wacks++;\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic void qca_wq_serial_rx_clock_vote_off(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_rx_vote_off);\n\tstruct hci_uart *hu = qca->hu;\n\n\tBT_DBG(\"hu %p rx clock vote off\", hu);\n\n\tserial_clock_vote(HCI_IBS_RX_VOTE_CLOCK_OFF, hu);\n}\n\nstatic void qca_wq_serial_tx_clock_vote_off(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ws_tx_vote_off);\n\tstruct hci_uart *hu = qca->hu;\n\n\tBT_DBG(\"hu %p tx clock vote off\", hu);\n\n\t/* Run HCI tx handling unlocked */\n\thci_uart_tx_wakeup(hu);\n\n\t/* Now that message queued to tty driver, vote for tty clocks off.\n\t * It is up to the tty driver to pend the clocks off until tx done.\n\t */\n\tserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_OFF, hu);\n}\n\nstatic void hci_ibs_tx_idle_timeout(struct timer_list *t)\n{\n\tstruct qca_data *qca = from_timer(qca, t, tx_idle_timer);\n\tstruct hci_uart *hu = qca->hu;\n\tunsigned long flags;\n\n\tBT_DBG(\"hu %p idle timeout in %d state\", hu, qca->tx_ibs_state);\n\n\tspin_lock_irqsave_nested(&qca->hci_ibs_lock,\n\t\t\t\t flags, SINGLE_DEPTH_NESTING);\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_AWAKE:\n\t\t/* TX_IDLE, go to SLEEP */\n\t\tif (send_hci_ibs_cmd(HCI_IBS_SLEEP_IND, hu) < 0) {\n\t\t\tBT_ERR(\"Failed to send SLEEP to device\");\n\t\t\tbreak;\n\t\t}\n\t\tqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\n\t\tqca->ibs_sent_slps++;\n\t\tqueue_work(qca->workqueue, &qca->ws_tx_vote_off);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\tcase HCI_IBS_TX_WAKING:\n\tdefault:\n\t\tBT_ERR(\"Spurious timeout tx state %d\", qca->tx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n}\n\nstatic void hci_ibs_wake_retrans_timeout(struct timer_list *t)\n{\n\tstruct qca_data *qca = from_timer(qca, t, wake_retrans_timer);\n\tstruct hci_uart *hu = qca->hu;\n\tunsigned long flags, retrans_delay;\n\tbool retransmit = false;\n\n\tBT_DBG(\"hu %p wake retransmit timeout in %d state\",\n\t\thu, qca->tx_ibs_state);\n\n\tspin_lock_irqsave_nested(&qca->hci_ibs_lock,\n\t\t\t\t flags, SINGLE_DEPTH_NESTING);\n\n\t/* Don't retransmit the HCI_IBS_WAKE_IND when suspending. */\n\tif (test_bit(QCA_SUSPENDING, &qca->flags)) {\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn;\n\t}\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_WAKING:\n\t\t/* No WAKE_ACK, retransmit WAKE */\n\t\tretransmit = true;\n\t\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_IND, hu) < 0) {\n\t\t\tBT_ERR(\"Failed to acknowledge device wake up\");\n\t\t\tbreak;\n\t\t}\n\t\tqca->ibs_sent_wakes++;\n\t\tretrans_delay = msecs_to_jiffies(qca->wake_retrans);\n\t\tmod_timer(&qca->wake_retrans_timer, jiffies + retrans_delay);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\tcase HCI_IBS_TX_AWAKE:\n\tdefault:\n\t\tBT_ERR(\"Spurious timeout tx state %d\", qca->tx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\tif (retransmit)\n\t\thci_uart_tx_wakeup(hu);\n}\n\n\nstatic void qca_controller_memdump_timeout(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\tctrl_memdump_timeout.work);\n\tstruct hci_uart *hu = qca->hu;\n\n\tmutex_lock(&qca->hci_memdump_lock);\n\tif (test_bit(QCA_MEMDUMP_COLLECTION, &qca->flags)) {\n\t\tqca->memdump_state = QCA_MEMDUMP_TIMEOUT;\n\t\tif (!test_bit(QCA_HW_ERROR_EVENT, &qca->flags)) {\n\t\t\t/* Inject hw error event to reset the device\n\t\t\t * and driver.\n\t\t\t */\n\t\t\thci_reset_dev(hu->hdev);\n\t\t}\n\t}\n\n\tmutex_unlock(&qca->hci_memdump_lock);\n}\n\n\n/* Initialize protocol */\nstatic int qca_open(struct hci_uart *hu)\n{\n\tstruct qca_serdev *qcadev;\n\tstruct qca_data *qca;\n\n\tBT_DBG(\"hu %p qca_open\", hu);\n\n\tif (!hci_uart_has_flow_control(hu))\n\t\treturn -EOPNOTSUPP;\n\n\tqca = kzalloc(sizeof(struct qca_data), GFP_KERNEL);\n\tif (!qca)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&qca->txq);\n\tskb_queue_head_init(&qca->tx_wait_q);\n\tskb_queue_head_init(&qca->rx_memdump_q);\n\tspin_lock_init(&qca->hci_ibs_lock);\n\tmutex_init(&qca->hci_memdump_lock);\n\tqca->workqueue = alloc_ordered_workqueue(\"qca_wq\", 0);\n\tif (!qca->workqueue) {\n\t\tBT_ERR(\"QCA Workqueue not initialized properly\");\n\t\tkfree(qca);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_WORK(&qca->ws_awake_rx, qca_wq_awake_rx);\n\tINIT_WORK(&qca->ws_awake_device, qca_wq_awake_device);\n\tINIT_WORK(&qca->ws_rx_vote_off, qca_wq_serial_rx_clock_vote_off);\n\tINIT_WORK(&qca->ws_tx_vote_off, qca_wq_serial_tx_clock_vote_off);\n\tINIT_WORK(&qca->ctrl_memdump_evt, qca_controller_memdump);\n\tINIT_DELAYED_WORK(&qca->ctrl_memdump_timeout,\n\t\t\t  qca_controller_memdump_timeout);\n\tinit_waitqueue_head(&qca->suspend_wait_q);\n\n\tqca->hu = hu;\n\tinit_completion(&qca->drop_ev_comp);\n\n\t/* Assume we start with both sides asleep -- extra wakes OK */\n\tqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\n\tqca->rx_ibs_state = HCI_IBS_RX_ASLEEP;\n\n\tqca->vote_last_jif = jiffies;\n\n\thu->priv = qca;\n\n\tif (hu->serdev) {\n\t\tqcadev = serdev_device_get_drvdata(hu->serdev);\n\n\t\tif (qca_is_wcn399x(qcadev->btsoc_type) ||\n\t\t    qca_is_wcn6750(qcadev->btsoc_type))\n\t\t\thu->init_speed = qcadev->init_speed;\n\n\t\tif (qcadev->oper_speed)\n\t\t\thu->oper_speed = qcadev->oper_speed;\n\t}\n\n\ttimer_setup(&qca->wake_retrans_timer, hci_ibs_wake_retrans_timeout, 0);\n\tqca->wake_retrans = IBS_WAKE_RETRANS_TIMEOUT_MS;\n\n\ttimer_setup(&qca->tx_idle_timer, hci_ibs_tx_idle_timeout, 0);\n\tqca->tx_idle_delay = IBS_HOST_TX_IDLE_TIMEOUT_MS;\n\n\tBT_DBG(\"HCI_UART_QCA open, tx_idle_delay=%u, wake_retrans=%u\",\n\t       qca->tx_idle_delay, qca->wake_retrans);\n\n\treturn 0;\n}\n\nstatic void qca_debugfs_init(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\tstruct dentry *ibs_dir;\n\tumode_t mode;\n\n\tif (!hdev->debugfs)\n\t\treturn;\n\n\tibs_dir = debugfs_create_dir(\"ibs\", hdev->debugfs);\n\n\t/* read only */\n\tmode = 0444;\n\tdebugfs_create_u8(\"tx_ibs_state\", mode, ibs_dir, &qca->tx_ibs_state);\n\tdebugfs_create_u8(\"rx_ibs_state\", mode, ibs_dir, &qca->rx_ibs_state);\n\tdebugfs_create_u64(\"ibs_sent_sleeps\", mode, ibs_dir,\n\t\t\t   &qca->ibs_sent_slps);\n\tdebugfs_create_u64(\"ibs_sent_wakes\", mode, ibs_dir,\n\t\t\t   &qca->ibs_sent_wakes);\n\tdebugfs_create_u64(\"ibs_sent_wake_acks\", mode, ibs_dir,\n\t\t\t   &qca->ibs_sent_wacks);\n\tdebugfs_create_u64(\"ibs_recv_sleeps\", mode, ibs_dir,\n\t\t\t   &qca->ibs_recv_slps);\n\tdebugfs_create_u64(\"ibs_recv_wakes\", mode, ibs_dir,\n\t\t\t   &qca->ibs_recv_wakes);\n\tdebugfs_create_u64(\"ibs_recv_wake_acks\", mode, ibs_dir,\n\t\t\t   &qca->ibs_recv_wacks);\n\tdebugfs_create_bool(\"tx_vote\", mode, ibs_dir, &qca->tx_vote);\n\tdebugfs_create_u64(\"tx_votes_on\", mode, ibs_dir, &qca->tx_votes_on);\n\tdebugfs_create_u64(\"tx_votes_off\", mode, ibs_dir, &qca->tx_votes_off);\n\tdebugfs_create_bool(\"rx_vote\", mode, ibs_dir, &qca->rx_vote);\n\tdebugfs_create_u64(\"rx_votes_on\", mode, ibs_dir, &qca->rx_votes_on);\n\tdebugfs_create_u64(\"rx_votes_off\", mode, ibs_dir, &qca->rx_votes_off);\n\tdebugfs_create_u64(\"votes_on\", mode, ibs_dir, &qca->votes_on);\n\tdebugfs_create_u64(\"votes_off\", mode, ibs_dir, &qca->votes_off);\n\tdebugfs_create_u32(\"vote_on_ms\", mode, ibs_dir, &qca->vote_on_ms);\n\tdebugfs_create_u32(\"vote_off_ms\", mode, ibs_dir, &qca->vote_off_ms);\n\n\t/* read/write */\n\tmode = 0644;\n\tdebugfs_create_u32(\"wake_retrans\", mode, ibs_dir, &qca->wake_retrans);\n\tdebugfs_create_u32(\"tx_idle_delay\", mode, ibs_dir,\n\t\t\t   &qca->tx_idle_delay);\n}\n\n/* Flush protocol data */\nstatic int qca_flush(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p qca flush\", hu);\n\n\tskb_queue_purge(&qca->tx_wait_q);\n\tskb_queue_purge(&qca->txq);\n\n\treturn 0;\n}\n\n/* Close protocol */\nstatic int qca_close(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p qca close\", hu);\n\n\tserial_clock_vote(HCI_IBS_VOTE_STATS_UPDATE, hu);\n\n\tskb_queue_purge(&qca->tx_wait_q);\n\tskb_queue_purge(&qca->txq);\n\tskb_queue_purge(&qca->rx_memdump_q);\n\tdel_timer(&qca->tx_idle_timer);\n\tdel_timer(&qca->wake_retrans_timer);\n\tdestroy_workqueue(qca->workqueue);\n\tqca->hu = NULL;\n\n\tkfree_skb(qca->rx_skb);\n\n\thu->priv = NULL;\n\n\tkfree(qca);\n\n\treturn 0;\n}\n\n/* Called upon a wake-up-indication from the device.\n */\nstatic void device_want_to_wakeup(struct hci_uart *hu)\n{\n\tunsigned long flags;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p want to wake up\", hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\tqca->ibs_recv_wakes++;\n\n\t/* Don't wake the rx up when suspending. */\n\tif (test_bit(QCA_SUSPENDING, &qca->flags)) {\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn;\n\t}\n\n\tswitch (qca->rx_ibs_state) {\n\tcase HCI_IBS_RX_ASLEEP:\n\t\t/* Make sure clock is on - we may have turned clock off since\n\t\t * receiving the wake up indicator awake rx clock.\n\t\t */\n\t\tqueue_work(qca->workqueue, &qca->ws_awake_rx);\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn;\n\n\tcase HCI_IBS_RX_AWAKE:\n\t\t/* Always acknowledge device wake up,\n\t\t * sending IBS message doesn't count as TX ON.\n\t\t */\n\t\tif (send_hci_ibs_cmd(HCI_IBS_WAKE_ACK, hu) < 0) {\n\t\t\tBT_ERR(\"Failed to acknowledge device wake up\");\n\t\t\tbreak;\n\t\t}\n\t\tqca->ibs_sent_wacks++;\n\t\tbreak;\n\n\tdefault:\n\t\t/* Any other state is illegal */\n\t\tBT_ERR(\"Received HCI_IBS_WAKE_IND in rx state %d\",\n\t\t       qca->rx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\n/* Called upon a sleep-indication from the device.\n */\nstatic void device_want_to_sleep(struct hci_uart *hu)\n{\n\tunsigned long flags;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p want to sleep in %d state\", hu, qca->rx_ibs_state);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\tqca->ibs_recv_slps++;\n\n\tswitch (qca->rx_ibs_state) {\n\tcase HCI_IBS_RX_AWAKE:\n\t\t/* Update state */\n\t\tqca->rx_ibs_state = HCI_IBS_RX_ASLEEP;\n\t\t/* Vote off rx clock under workqueue */\n\t\tqueue_work(qca->workqueue, &qca->ws_rx_vote_off);\n\t\tbreak;\n\n\tcase HCI_IBS_RX_ASLEEP:\n\t\tbreak;\n\n\tdefault:\n\t\t/* Any other state is illegal */\n\t\tBT_ERR(\"Received HCI_IBS_SLEEP_IND in rx state %d\",\n\t\t       qca->rx_ibs_state);\n\t\tbreak;\n\t}\n\n\twake_up_interruptible(&qca->suspend_wait_q);\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n}\n\n/* Called upon wake-up-acknowledgement from the device\n */\nstatic void device_woke_up(struct hci_uart *hu)\n{\n\tunsigned long flags, idle_delay;\n\tstruct qca_data *qca = hu->priv;\n\tstruct sk_buff *skb = NULL;\n\n\tBT_DBG(\"hu %p woke up\", hu);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\tqca->ibs_recv_wacks++;\n\n\t/* Don't react to the wake-up-acknowledgment when suspending. */\n\tif (test_bit(QCA_SUSPENDING, &qca->flags)) {\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn;\n\t}\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_AWAKE:\n\t\t/* Expect one if we send 2 WAKEs */\n\t\tBT_DBG(\"Received HCI_IBS_WAKE_ACK in tx state %d\",\n\t\t       qca->tx_ibs_state);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_WAKING:\n\t\t/* Send pending packets */\n\t\twhile ((skb = skb_dequeue(&qca->tx_wait_q)))\n\t\t\tskb_queue_tail(&qca->txq, skb);\n\n\t\t/* Switch timers and change state to HCI_IBS_TX_AWAKE */\n\t\tdel_timer(&qca->wake_retrans_timer);\n\t\tidle_delay = msecs_to_jiffies(qca->tx_idle_delay);\n\t\tmod_timer(&qca->tx_idle_timer, jiffies + idle_delay);\n\t\tqca->tx_ibs_state = HCI_IBS_TX_AWAKE;\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\tdefault:\n\t\tBT_ERR(\"Received HCI_IBS_WAKE_ACK in tx state %d\",\n\t\t       qca->tx_ibs_state);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Actually send the packets */\n\thci_uart_tx_wakeup(hu);\n}\n\n/* Enqueue frame for transmittion (padding, crc, etc) may be called from\n * two simultaneous tasklets.\n */\nstatic int qca_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tunsigned long flags = 0, idle_delay;\n\tstruct qca_data *qca = hu->priv;\n\n\tBT_DBG(\"hu %p qca enq skb %p tx_ibs_state %d\", hu, skb,\n\t       qca->tx_ibs_state);\n\n\tif (test_bit(QCA_SSR_TRIGGERED, &qca->flags)) {\n\t\t/* As SSR is in progress, ignore the packets */\n\t\tbt_dev_dbg(hu->hdev, \"SSR is in progress\");\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\t/* Prepend skb with frame type */\n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\n\t/* Don't go to sleep in middle of patch download or\n\t * Out-Of-Band(GPIOs control) sleep is selected.\n\t * Don't wake the device up when suspending.\n\t */\n\tif (test_bit(QCA_IBS_DISABLED, &qca->flags) ||\n\t    test_bit(QCA_SUSPENDING, &qca->flags)) {\n\t\tskb_queue_tail(&qca->txq, skb);\n\t\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\t\treturn 0;\n\t}\n\n\t/* Act according to current state */\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_AWAKE:\n\t\tBT_DBG(\"Device awake, sending normally\");\n\t\tskb_queue_tail(&qca->txq, skb);\n\t\tidle_delay = msecs_to_jiffies(qca->tx_idle_delay);\n\t\tmod_timer(&qca->tx_idle_timer, jiffies + idle_delay);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\t\tBT_DBG(\"Device asleep, waking up and queueing packet\");\n\t\t/* Save packet for later */\n\t\tskb_queue_tail(&qca->tx_wait_q, skb);\n\n\t\tqca->tx_ibs_state = HCI_IBS_TX_WAKING;\n\t\t/* Schedule a work queue to wake up device */\n\t\tqueue_work(qca->workqueue, &qca->ws_awake_device);\n\t\tbreak;\n\n\tcase HCI_IBS_TX_WAKING:\n\t\tBT_DBG(\"Device waking up, queueing packet\");\n\t\t/* Transient state; just keep packet for later */\n\t\tskb_queue_tail(&qca->tx_wait_q, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Illegal tx state: %d (losing packet)\",\n\t\t       qca->tx_ibs_state);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\treturn 0;\n}\n\nstatic int qca_ibs_sleep_ind(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"hu %p recv hci ibs cmd 0x%x\", hu, HCI_IBS_SLEEP_IND);\n\n\tdevice_want_to_sleep(hu);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int qca_ibs_wake_ind(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"hu %p recv hci ibs cmd 0x%x\", hu, HCI_IBS_WAKE_IND);\n\n\tdevice_want_to_wakeup(hu);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int qca_ibs_wake_ack(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"hu %p recv hci ibs cmd 0x%x\", hu, HCI_IBS_WAKE_ACK);\n\n\tdevice_woke_up(hu);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int qca_recv_acl_data(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\t/* We receive debug logs from chip as an ACL packets.\n\t * Instead of sending the data to ACL to decode the\n\t * received data, we are pushing them to the above layers\n\t * as a diagnostic packet.\n\t */\n\tif (get_unaligned_le16(skb->data) == QCA_DEBUG_HANDLE)\n\t\treturn hci_recv_diag(hdev, skb);\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic void qca_controller_memdump(struct work_struct *work)\n{\n\tstruct qca_data *qca = container_of(work, struct qca_data,\n\t\t\t\t\t    ctrl_memdump_evt);\n\tstruct hci_uart *hu = qca->hu;\n\tstruct sk_buff *skb;\n\tstruct qca_memdump_event_hdr *cmd_hdr;\n\tstruct qca_memdump_data *qca_memdump = qca->qca_memdump;\n\tstruct qca_dump_size *dump;\n\tchar *memdump_buf;\n\tchar nullBuff[QCA_DUMP_PACKET_SIZE] = { 0 };\n\tu16 seq_no;\n\tu32 dump_size;\n\tu32 rx_size;\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\n\twhile ((skb = skb_dequeue(&qca->rx_memdump_q))) {\n\n\t\tmutex_lock(&qca->hci_memdump_lock);\n\t\t/* Skip processing the received packets if timeout detected\n\t\t * or memdump collection completed.\n\t\t */\n\t\tif (qca->memdump_state == QCA_MEMDUMP_TIMEOUT ||\n\t\t    qca->memdump_state == QCA_MEMDUMP_COLLECTED) {\n\t\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!qca_memdump) {\n\t\t\tqca_memdump = kzalloc(sizeof(struct qca_memdump_data),\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tif (!qca_memdump) {\n\t\t\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tqca->qca_memdump = qca_memdump;\n\t\t}\n\n\t\tqca->memdump_state = QCA_MEMDUMP_COLLECTING;\n\t\tcmd_hdr = (void *) skb->data;\n\t\tseq_no = __le16_to_cpu(cmd_hdr->seq_no);\n\t\tskb_pull(skb, sizeof(struct qca_memdump_event_hdr));\n\n\t\tif (!seq_no) {\n\n\t\t\t/* This is the first frame of memdump packet from\n\t\t\t * the controller, Disable IBS to recevie dump\n\t\t\t * with out any interruption, ideally time required for\n\t\t\t * the controller to send the dump is 8 seconds. let us\n\t\t\t * start timer to handle this asynchronous activity.\n\t\t\t */\n\t\t\tset_bit(QCA_IBS_DISABLED, &qca->flags);\n\t\t\tset_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n\t\t\tdump = (void *) skb->data;\n\t\t\tdump_size = __le32_to_cpu(dump->dump_size);\n\t\t\tif (!(dump_size)) {\n\t\t\t\tbt_dev_err(hu->hdev, \"Rx invalid memdump size\");\n\t\t\t\tkfree(qca_memdump);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tqca->qca_memdump = NULL;\n\t\t\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tbt_dev_info(hu->hdev, \"QCA collecting dump of size:%u\",\n\t\t\t\t    dump_size);\n\t\t\tqueue_delayed_work(qca->workqueue,\n\t\t\t\t\t   &qca->ctrl_memdump_timeout,\n\t\t\t\t\t   msecs_to_jiffies(MEMDUMP_TIMEOUT_MS)\n\t\t\t\t\t  );\n\n\t\t\tskb_pull(skb, sizeof(dump_size));\n\t\t\tmemdump_buf = vmalloc(dump_size);\n\t\t\tqca_memdump->ram_dump_size = dump_size;\n\t\t\tqca_memdump->memdump_buf_head = memdump_buf;\n\t\t\tqca_memdump->memdump_buf_tail = memdump_buf;\n\t\t}\n\n\t\tmemdump_buf = qca_memdump->memdump_buf_tail;\n\n\t\t/* If sequence no 0 is missed then there is no point in\n\t\t * accepting the other sequences.\n\t\t */\n\t\tif (!memdump_buf) {\n\t\t\tbt_dev_err(hu->hdev, \"QCA: Discarding other packets\");\n\t\t\tkfree(qca_memdump);\n\t\t\tkfree_skb(skb);\n\t\t\tqca->qca_memdump = NULL;\n\t\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t\t\treturn;\n\t\t}\n\n\t\t/* There could be chance of missing some packets from\n\t\t * the controller. In such cases let us store the dummy\n\t\t * packets in the buffer.\n\t\t */\n\t\t/* For QCA6390, controller does not lost packets but\n\t\t * sequence number field of packet sometimes has error\n\t\t * bits, so skip this checking for missing packet.\n\t\t */\n\t\twhile ((seq_no > qca_memdump->current_seq_no + 1) &&\n\t\t       (soc_type != QCA_QCA6390) &&\n\t\t       seq_no != QCA_LAST_SEQUENCE_NUM) {\n\t\t\tbt_dev_err(hu->hdev, \"QCA controller missed packet:%d\",\n\t\t\t\t   qca_memdump->current_seq_no);\n\t\t\trx_size = qca_memdump->received_dump;\n\t\t\trx_size += QCA_DUMP_PACKET_SIZE;\n\t\t\tif (rx_size > qca_memdump->ram_dump_size) {\n\t\t\t\tbt_dev_err(hu->hdev,\n\t\t\t\t\t   \"QCA memdump received %d, no space for missed packet\",\n\t\t\t\t\t   qca_memdump->received_dump);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(memdump_buf, nullBuff, QCA_DUMP_PACKET_SIZE);\n\t\t\tmemdump_buf = memdump_buf + QCA_DUMP_PACKET_SIZE;\n\t\t\tqca_memdump->received_dump += QCA_DUMP_PACKET_SIZE;\n\t\t\tqca_memdump->current_seq_no++;\n\t\t}\n\n\t\trx_size = qca_memdump->received_dump + skb->len;\n\t\tif (rx_size <= qca_memdump->ram_dump_size) {\n\t\t\tif ((seq_no != QCA_LAST_SEQUENCE_NUM) &&\n\t\t\t    (seq_no != qca_memdump->current_seq_no))\n\t\t\t\tbt_dev_err(hu->hdev,\n\t\t\t\t\t   \"QCA memdump unexpected packet %d\",\n\t\t\t\t\t   seq_no);\n\t\t\tbt_dev_dbg(hu->hdev,\n\t\t\t\t   \"QCA memdump packet %d with length %d\",\n\t\t\t\t   seq_no, skb->len);\n\t\t\tmemcpy(memdump_buf, (unsigned char *)skb->data,\n\t\t\t       skb->len);\n\t\t\tmemdump_buf = memdump_buf + skb->len;\n\t\t\tqca_memdump->memdump_buf_tail = memdump_buf;\n\t\t\tqca_memdump->current_seq_no = seq_no + 1;\n\t\t\tqca_memdump->received_dump += skb->len;\n\t\t} else {\n\t\t\tbt_dev_err(hu->hdev,\n\t\t\t\t   \"QCA memdump received %d, no space for packet %d\",\n\t\t\t\t   qca_memdump->received_dump, seq_no);\n\t\t}\n\t\tqca->qca_memdump = qca_memdump;\n\t\tkfree_skb(skb);\n\t\tif (seq_no == QCA_LAST_SEQUENCE_NUM) {\n\t\t\tbt_dev_info(hu->hdev,\n\t\t\t\t    \"QCA memdump Done, received %d, total %d\",\n\t\t\t\t    qca_memdump->received_dump,\n\t\t\t\t    qca_memdump->ram_dump_size);\n\t\t\tmemdump_buf = qca_memdump->memdump_buf_head;\n\t\t\tdev_coredumpv(&hu->serdev->dev, memdump_buf,\n\t\t\t\t      qca_memdump->received_dump, GFP_KERNEL);\n\t\t\tcancel_delayed_work(&qca->ctrl_memdump_timeout);\n\t\t\tkfree(qca->qca_memdump);\n\t\t\tqca->qca_memdump = NULL;\n\t\t\tqca->memdump_state = QCA_MEMDUMP_COLLECTED;\n\t\t\tclear_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n\t\t}\n\n\t\tmutex_unlock(&qca->hci_memdump_lock);\n\t}\n\n}\n\nstatic int qca_controller_memdump_event(struct hci_dev *hdev,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\tset_bit(QCA_SSR_TRIGGERED, &qca->flags);\n\tskb_queue_tail(&qca->rx_memdump_q, skb);\n\tqueue_work(qca->workqueue, &qca->ctrl_memdump_evt);\n\n\treturn 0;\n}\n\nstatic int qca_recv_event(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\tif (test_bit(QCA_DROP_VENDOR_EVENT, &qca->flags)) {\n\t\tstruct hci_event_hdr *hdr = (void *)skb->data;\n\n\t\t/* For the WCN3990 the vendor command for a baudrate change\n\t\t * isn't sent as synchronous HCI command, because the\n\t\t * controller sends the corresponding vendor event with the\n\t\t * new baudrate. The event is received and properly decoded\n\t\t * after changing the baudrate of the host port. It needs to\n\t\t * be dropped, otherwise it can be misinterpreted as\n\t\t * response to a later firmware download command (also a\n\t\t * vendor command).\n\t\t */\n\n\t\tif (hdr->evt == HCI_EV_VENDOR)\n\t\t\tcomplete(&qca->drop_ev_comp);\n\n\t\tkfree_skb(skb);\n\n\t\treturn 0;\n\t}\n\t/* We receive chip memory dump as an event packet, With a dedicated\n\t * handler followed by a hardware error event. When this event is\n\t * received we store dump into a file before closing hci. This\n\t * dump will help in triaging the issues.\n\t */\n\tif ((skb->data[0] == HCI_VENDOR_PKT) &&\n\t    (get_unaligned_be16(skb->data + 2) == QCA_SSR_DUMP_HANDLE))\n\t\treturn qca_controller_memdump_event(hdev, skb);\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\n#define QCA_IBS_SLEEP_IND_EVENT \\\n\t.type = HCI_IBS_SLEEP_IND, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = HCI_MAX_IBS_SIZE\n\n#define QCA_IBS_WAKE_IND_EVENT \\\n\t.type = HCI_IBS_WAKE_IND, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = HCI_MAX_IBS_SIZE\n\n#define QCA_IBS_WAKE_ACK_EVENT \\\n\t.type = HCI_IBS_WAKE_ACK, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = HCI_MAX_IBS_SIZE\n\nstatic const struct h4_recv_pkt qca_recv_pkts[] = {\n\t{ H4_RECV_ACL,             .recv = qca_recv_acl_data },\n\t{ H4_RECV_SCO,             .recv = hci_recv_frame    },\n\t{ H4_RECV_EVENT,           .recv = qca_recv_event    },\n\t{ QCA_IBS_WAKE_IND_EVENT,  .recv = qca_ibs_wake_ind  },\n\t{ QCA_IBS_WAKE_ACK_EVENT,  .recv = qca_ibs_wake_ack  },\n\t{ QCA_IBS_SLEEP_IND_EVENT, .recv = qca_ibs_sleep_ind },\n};\n\nstatic int qca_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\tqca->rx_skb = h4_recv_buf(hu->hdev, qca->rx_skb, data, count,\n\t\t\t\t  qca_recv_pkts, ARRAY_SIZE(qca_recv_pkts));\n\tif (IS_ERR(qca->rx_skb)) {\n\t\tint err = PTR_ERR(qca->rx_skb);\n\t\tbt_dev_err(hu->hdev, \"Frame reassembly failed (%d)\", err);\n\t\tqca->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic struct sk_buff *qca_dequeue(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\n\treturn skb_dequeue(&qca->txq);\n}\n\nstatic uint8_t qca_get_baudrate_value(int speed)\n{\n\tswitch (speed) {\n\tcase 9600:\n\t\treturn QCA_BAUDRATE_9600;\n\tcase 19200:\n\t\treturn QCA_BAUDRATE_19200;\n\tcase 38400:\n\t\treturn QCA_BAUDRATE_38400;\n\tcase 57600:\n\t\treturn QCA_BAUDRATE_57600;\n\tcase 115200:\n\t\treturn QCA_BAUDRATE_115200;\n\tcase 230400:\n\t\treturn QCA_BAUDRATE_230400;\n\tcase 460800:\n\t\treturn QCA_BAUDRATE_460800;\n\tcase 500000:\n\t\treturn QCA_BAUDRATE_500000;\n\tcase 921600:\n\t\treturn QCA_BAUDRATE_921600;\n\tcase 1000000:\n\t\treturn QCA_BAUDRATE_1000000;\n\tcase 2000000:\n\t\treturn QCA_BAUDRATE_2000000;\n\tcase 3000000:\n\t\treturn QCA_BAUDRATE_3000000;\n\tcase 3200000:\n\t\treturn QCA_BAUDRATE_3200000;\n\tcase 3500000:\n\t\treturn QCA_BAUDRATE_3500000;\n\tdefault:\n\t\treturn QCA_BAUDRATE_115200;\n\t}\n}\n\nstatic int qca_set_baudrate(struct hci_dev *hdev, uint8_t baudrate)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\tstruct sk_buff *skb;\n\tu8 cmd[] = { 0x01, 0x48, 0xFC, 0x01, 0x00 };\n\n\tif (baudrate > QCA_BAUDRATE_3200000)\n\t\treturn -EINVAL;\n\n\tcmd[4] = baudrate;\n\n\tskb = bt_skb_alloc(sizeof(cmd), GFP_KERNEL);\n\tif (!skb) {\n\t\tbt_dev_err(hdev, \"Failed to allocate baudrate packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Assign commands to change baudrate and packet type. */\n\tskb_put_data(skb, cmd, sizeof(cmd));\n\thci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\n\n\tskb_queue_tail(&qca->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\t/* Wait for the baudrate change request to be sent */\n\n\twhile (!skb_queue_empty(&qca->txq))\n\t\tusleep_range(100, 200);\n\n\tif (hu->serdev)\n\t\tserdev_device_wait_until_sent(hu->serdev,\n\t\t      msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS));\n\n\t/* Give the controller time to process the request */\n\tif (qca_is_wcn399x(qca_soc_type(hu)) ||\n\t    qca_is_wcn6750(qca_soc_type(hu)))\n\t\tusleep_range(1000, 10000);\n\telse\n\t\tmsleep(300);\n\n\treturn 0;\n}\n\nstatic inline void host_set_baudrate(struct hci_uart *hu, unsigned int speed)\n{\n\tif (hu->serdev)\n\t\tserdev_device_set_baudrate(hu->serdev, speed);\n\telse\n\t\thci_uart_set_baudrate(hu, speed);\n}\n\nstatic int qca_send_power_pulse(struct hci_uart *hu, bool on)\n{\n\tint ret;\n\tint timeout = msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS);\n\tu8 cmd = on ? QCA_WCN3990_POWERON_PULSE : QCA_WCN3990_POWEROFF_PULSE;\n\n\t/* These power pulses are single byte command which are sent\n\t * at required baudrate to wcn3990. On wcn3990, we have an external\n\t * circuit at Tx pin which decodes the pulse sent at specific baudrate.\n\t * For example, wcn3990 supports RF COEX antenna for both Wi-Fi/BT\n\t * and also we use the same power inputs to turn on and off for\n\t * Wi-Fi/BT. Powering up the power sources will not enable BT, until\n\t * we send a power on pulse at 115200 bps. This algorithm will help to\n\t * save power. Disabling hardware flow control is mandatory while\n\t * sending power pulses to SoC.\n\t */\n\tbt_dev_dbg(hu->hdev, \"sending power pulse %02x to controller\", cmd);\n\n\tserdev_device_write_flush(hu->serdev);\n\thci_uart_set_flow_control(hu, true);\n\tret = serdev_device_write_buf(hu->serdev, &cmd, sizeof(cmd));\n\tif (ret < 0) {\n\t\tbt_dev_err(hu->hdev, \"failed to send power pulse %02x\", cmd);\n\t\treturn ret;\n\t}\n\n\tserdev_device_wait_until_sent(hu->serdev, timeout);\n\thci_uart_set_flow_control(hu, false);\n\n\t/* Give to controller time to boot/shutdown */\n\tif (on)\n\t\tmsleep(100);\n\telse\n\t\tusleep_range(1000, 10000);\n\n\treturn 0;\n}\n\nstatic unsigned int qca_get_speed(struct hci_uart *hu,\n\t\t\t\t  enum qca_speed_type speed_type)\n{\n\tunsigned int speed = 0;\n\n\tif (speed_type == QCA_INIT_SPEED) {\n\t\tif (hu->init_speed)\n\t\t\tspeed = hu->init_speed;\n\t\telse if (hu->proto->init_speed)\n\t\t\tspeed = hu->proto->init_speed;\n\t} else {\n\t\tif (hu->oper_speed)\n\t\t\tspeed = hu->oper_speed;\n\t\telse if (hu->proto->oper_speed)\n\t\t\tspeed = hu->proto->oper_speed;\n\t}\n\n\treturn speed;\n}\n\nstatic int qca_check_speeds(struct hci_uart *hu)\n{\n\tif (qca_is_wcn399x(qca_soc_type(hu)) ||\n\t    qca_is_wcn6750(qca_soc_type(hu))) {\n\t\tif (!qca_get_speed(hu, QCA_INIT_SPEED) &&\n\t\t    !qca_get_speed(hu, QCA_OPER_SPEED))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!qca_get_speed(hu, QCA_INIT_SPEED) ||\n\t\t    !qca_get_speed(hu, QCA_OPER_SPEED))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int qca_set_speed(struct hci_uart *hu, enum qca_speed_type speed_type)\n{\n\tunsigned int speed, qca_baudrate;\n\tstruct qca_data *qca = hu->priv;\n\tint ret = 0;\n\n\tif (speed_type == QCA_INIT_SPEED) {\n\t\tspeed = qca_get_speed(hu, QCA_INIT_SPEED);\n\t\tif (speed)\n\t\t\thost_set_baudrate(hu, speed);\n\t} else {\n\t\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\n\t\tspeed = qca_get_speed(hu, QCA_OPER_SPEED);\n\t\tif (!speed)\n\t\t\treturn 0;\n\n\t\t/* Disable flow control for wcn3990 to deassert RTS while\n\t\t * changing the baudrate of chip and host.\n\t\t */\n\t\tif (qca_is_wcn399x(soc_type) ||\n\t\t    qca_is_wcn6750(soc_type))\n\t\t\thci_uart_set_flow_control(hu, true);\n\n\t\tif (soc_type == QCA_WCN3990) {\n\t\t\treinit_completion(&qca->drop_ev_comp);\n\t\t\tset_bit(QCA_DROP_VENDOR_EVENT, &qca->flags);\n\t\t}\n\n\t\tqca_baudrate = qca_get_baudrate_value(speed);\n\t\tbt_dev_dbg(hu->hdev, \"Set UART speed to %d\", speed);\n\t\tret = qca_set_baudrate(hu->hdev, qca_baudrate);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\thost_set_baudrate(hu, speed);\n\nerror:\n\t\tif (qca_is_wcn399x(soc_type) ||\n\t\t    qca_is_wcn6750(soc_type))\n\t\t\thci_uart_set_flow_control(hu, false);\n\n\t\tif (soc_type == QCA_WCN3990) {\n\t\t\t/* Wait for the controller to send the vendor event\n\t\t\t * for the baudrate change command.\n\t\t\t */\n\t\t\tif (!wait_for_completion_timeout(&qca->drop_ev_comp,\n\t\t\t\t\t\t msecs_to_jiffies(100))) {\n\t\t\t\tbt_dev_err(hu->hdev,\n\t\t\t\t\t   \"Failed to change controller baudrate\\n\");\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t}\n\n\t\t\tclear_bit(QCA_DROP_VENDOR_EVENT, &qca->flags);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int qca_send_crashbuffer(struct hci_uart *hu)\n{\n\tstruct qca_data *qca = hu->priv;\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(QCA_CRASHBYTE_PACKET_LEN, GFP_KERNEL);\n\tif (!skb) {\n\t\tbt_dev_err(hu->hdev, \"Failed to allocate memory for skb packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* We forcefully crash the controller, by sending 0xfb byte for\n\t * 1024 times. We also might have chance of losing data, To be\n\t * on safer side we send 1096 bytes to the SoC.\n\t */\n\tmemset(skb_put(skb, QCA_CRASHBYTE_PACKET_LEN), QCA_MEMDUMP_BYTE,\n\t       QCA_CRASHBYTE_PACKET_LEN);\n\thci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\n\tbt_dev_info(hu->hdev, \"crash the soc to collect controller dump\");\n\tskb_queue_tail(&qca->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\treturn 0;\n}\n\nstatic void qca_wait_for_dump_collection(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\twait_on_bit_timeout(&qca->flags, QCA_MEMDUMP_COLLECTION,\n\t\t\t    TASK_UNINTERRUPTIBLE, MEMDUMP_TIMEOUT_MS);\n\n\tclear_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n}\n\nstatic void qca_hw_error(struct hci_dev *hdev, u8 code)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\tset_bit(QCA_SSR_TRIGGERED, &qca->flags);\n\tset_bit(QCA_HW_ERROR_EVENT, &qca->flags);\n\tbt_dev_info(hdev, \"mem_dump_status: %d\", qca->memdump_state);\n\n\tif (qca->memdump_state == QCA_MEMDUMP_IDLE) {\n\t\t/* If hardware error event received for other than QCA\n\t\t * soc memory dump event, then we need to crash the SOC\n\t\t * and wait here for 8 seconds to get the dump packets.\n\t\t * This will block main thread to be on hold until we\n\t\t * collect dump.\n\t\t */\n\t\tset_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n\t\tqca_send_crashbuffer(hu);\n\t\tqca_wait_for_dump_collection(hdev);\n\t} else if (qca->memdump_state == QCA_MEMDUMP_COLLECTING) {\n\t\t/* Let us wait here until memory dump collected or\n\t\t * memory dump timer expired.\n\t\t */\n\t\tbt_dev_info(hdev, \"waiting for dump to complete\");\n\t\tqca_wait_for_dump_collection(hdev);\n\t}\n\n\tmutex_lock(&qca->hci_memdump_lock);\n\tif (qca->memdump_state != QCA_MEMDUMP_COLLECTED) {\n\t\tbt_dev_err(hu->hdev, \"clearing allocated memory due to memdump timeout\");\n\t\tif (qca->qca_memdump) {\n\t\t\tvfree(qca->qca_memdump->memdump_buf_head);\n\t\t\tkfree(qca->qca_memdump);\n\t\t\tqca->qca_memdump = NULL;\n\t\t}\n\t\tqca->memdump_state = QCA_MEMDUMP_TIMEOUT;\n\t\tcancel_delayed_work(&qca->ctrl_memdump_timeout);\n\t}\n\tmutex_unlock(&qca->hci_memdump_lock);\n\n\tif (qca->memdump_state == QCA_MEMDUMP_TIMEOUT ||\n\t    qca->memdump_state == QCA_MEMDUMP_COLLECTED) {\n\t\tcancel_work_sync(&qca->ctrl_memdump_evt);\n\t\tskb_queue_purge(&qca->rx_memdump_q);\n\t}\n\n\tclear_bit(QCA_HW_ERROR_EVENT, &qca->flags);\n}\n\nstatic void qca_cmd_timeout(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\n\tset_bit(QCA_SSR_TRIGGERED, &qca->flags);\n\tif (qca->memdump_state == QCA_MEMDUMP_IDLE) {\n\t\tset_bit(QCA_MEMDUMP_COLLECTION, &qca->flags);\n\t\tqca_send_crashbuffer(hu);\n\t\tqca_wait_for_dump_collection(hdev);\n\t} else if (qca->memdump_state == QCA_MEMDUMP_COLLECTING) {\n\t\t/* Let us wait here until memory dump collected or\n\t\t * memory dump timer expired.\n\t\t */\n\t\tbt_dev_info(hdev, \"waiting for dump to complete\");\n\t\tqca_wait_for_dump_collection(hdev);\n\t}\n\n\tmutex_lock(&qca->hci_memdump_lock);\n\tif (qca->memdump_state != QCA_MEMDUMP_COLLECTED) {\n\t\tqca->memdump_state = QCA_MEMDUMP_TIMEOUT;\n\t\tif (!test_bit(QCA_HW_ERROR_EVENT, &qca->flags)) {\n\t\t\t/* Inject hw error event to reset the device\n\t\t\t * and driver.\n\t\t\t */\n\t\t\thci_reset_dev(hu->hdev);\n\t\t}\n\t}\n\tmutex_unlock(&qca->hci_memdump_lock);\n}\n\nstatic bool qca_wakeup(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tbool wakeup;\n\n\t/* UART driver handles the interrupt from BT SoC.So we need to use\n\t * device handle of UART driver to get the status of device may wakeup.\n\t */\n\twakeup = device_may_wakeup(hu->serdev->ctrl->dev.parent);\n\tbt_dev_dbg(hu->hdev, \"wakeup status : %d\", wakeup);\n\n\treturn !wakeup;\n}\n\nstatic int qca_regulator_init(struct hci_uart *hu)\n{\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\tstruct qca_serdev *qcadev;\n\tint ret;\n\tbool sw_ctrl_state;\n\n\t/* Check for vregs status, may be hci down has turned\n\t * off the voltage regulator.\n\t */\n\tqcadev = serdev_device_get_drvdata(hu->serdev);\n\tif (!qcadev->bt_power->vregs_on) {\n\t\tserdev_device_close(hu->serdev);\n\t\tret = qca_regulator_enable(qcadev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = serdev_device_open(hu->serdev);\n\t\tif (ret) {\n\t\t\tbt_dev_err(hu->hdev, \"failed to open port\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (qca_is_wcn399x(soc_type)) {\n\t\t/* Forcefully enable wcn399x to enter in to boot mode. */\n\t\thost_set_baudrate(hu, 2400);\n\t\tret = qca_send_power_pulse(hu, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* For wcn6750 need to enable gpio bt_en */\n\tif (qcadev->bt_en) {\n\t\tgpiod_set_value_cansleep(qcadev->bt_en, 0);\n\t\tmsleep(50);\n\t\tgpiod_set_value_cansleep(qcadev->bt_en, 1);\n\t\tmsleep(50);\n\t\tif (qcadev->sw_ctrl) {\n\t\t\tsw_ctrl_state = gpiod_get_value_cansleep(qcadev->sw_ctrl);\n\t\t\tbt_dev_dbg(hu->hdev, \"SW_CTRL is %d\", sw_ctrl_state);\n\t\t}\n\t}\n\n\tqca_set_speed(hu, QCA_INIT_SPEED);\n\n\tif (qca_is_wcn399x(soc_type)) {\n\t\tret = qca_send_power_pulse(hu, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Now the device is in ready state to communicate with host.\n\t * To sync host with device we need to reopen port.\n\t * Without this, we will have RTS and CTS synchronization\n\t * issues.\n\t */\n\tserdev_device_close(hu->serdev);\n\tret = serdev_device_open(hu->serdev);\n\tif (ret) {\n\t\tbt_dev_err(hu->hdev, \"failed to open port\");\n\t\treturn ret;\n\t}\n\n\thci_uart_set_flow_control(hu, false);\n\n\treturn 0;\n}\n\nstatic int qca_power_on(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\tstruct qca_serdev *qcadev;\n\tstruct qca_data *qca = hu->priv;\n\tint ret = 0;\n\n\t/* Non-serdev device usually is powered by external power\n\t * and don't need additional action in driver for power on\n\t */\n\tif (!hu->serdev)\n\t\treturn 0;\n\n\tif (qca_is_wcn399x(soc_type) ||\n\t    qca_is_wcn6750(soc_type)) {\n\t\tret = qca_regulator_init(hu);\n\t} else {\n\t\tqcadev = serdev_device_get_drvdata(hu->serdev);\n\t\tif (qcadev->bt_en) {\n\t\t\tgpiod_set_value_cansleep(qcadev->bt_en, 1);\n\t\t\t/* Controller needs time to bootup. */\n\t\t\tmsleep(150);\n\t\t}\n\t}\n\n\tclear_bit(QCA_BT_OFF, &qca->flags);\n\treturn ret;\n}\n\nstatic int qca_setup(struct hci_uart *hu)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct qca_data *qca = hu->priv;\n\tunsigned int speed, qca_baudrate = QCA_BAUDRATE_115200;\n\tunsigned int retries = 0;\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\tconst char *firmware_name = qca_get_firmware_name(hu);\n\tint ret;\n\tstruct qca_btsoc_version ver;\n\n\tret = qca_check_speeds(hu);\n\tif (ret)\n\t\treturn ret;\n\n\tclear_bit(QCA_ROM_FW, &qca->flags);\n\t/* Patch downloading has to be done without IBS mode */\n\tset_bit(QCA_IBS_DISABLED, &qca->flags);\n\n\t/* Enable controller to do both LE scan and BR/EDR inquiry\n\t * simultaneously.\n\t */\n\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\n\tbt_dev_info(hdev, \"setting up %s\",\n\t\tqca_is_wcn399x(soc_type) ? \"wcn399x\" :\n\t\t(soc_type == QCA_WCN6750) ? \"wcn6750\" : \"ROME/QCA6390\");\n\n\tqca->memdump_state = QCA_MEMDUMP_IDLE;\n\nretry:\n\tret = qca_power_on(hdev);\n\tif (ret)\n\t\tgoto out;\n\n\tclear_bit(QCA_SSR_TRIGGERED, &qca->flags);\n\n\tif (qca_is_wcn399x(soc_type) ||\n\t    qca_is_wcn6750(soc_type)) {\n\t\tset_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks);\n\t\thci_set_aosp_capable(hdev);\n\n\t\tret = qca_read_soc_version(hdev, &ver, soc_type);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\tqca_set_speed(hu, QCA_INIT_SPEED);\n\t}\n\n\t/* Setup user speed if needed */\n\tspeed = qca_get_speed(hu, QCA_OPER_SPEED);\n\tif (speed) {\n\t\tret = qca_set_speed(hu, QCA_OPER_SPEED);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tqca_baudrate = qca_get_baudrate_value(speed);\n\t}\n\n\tif (!(qca_is_wcn399x(soc_type) ||\n\t     qca_is_wcn6750(soc_type))) {\n\t\t/* Get QCA version information */\n\t\tret = qca_read_soc_version(hdev, &ver, soc_type);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* Setup patch / NVM configurations */\n\tret = qca_uart_setup(hdev, qca_baudrate, soc_type, ver,\n\t\t\tfirmware_name);\n\tif (!ret) {\n\t\tclear_bit(QCA_IBS_DISABLED, &qca->flags);\n\t\tqca_debugfs_init(hdev);\n\t\thu->hdev->hw_error = qca_hw_error;\n\t\thu->hdev->cmd_timeout = qca_cmd_timeout;\n\t\thu->hdev->wakeup = qca_wakeup;\n\t} else if (ret == -ENOENT) {\n\t\t/* No patch/nvm-config found, run with original fw/config */\n\t\tset_bit(QCA_ROM_FW, &qca->flags);\n\t\tret = 0;\n\t} else if (ret == -EAGAIN) {\n\t\t/*\n\t\t * Userspace firmware loader will return -EAGAIN in case no\n\t\t * patch/nvm-config is found, so run with original fw/config.\n\t\t */\n\t\tset_bit(QCA_ROM_FW, &qca->flags);\n\t\tret = 0;\n\t}\n\nout:\n\tif (ret && retries < MAX_INIT_RETRIES) {\n\t\tbt_dev_warn(hdev, \"Retry BT power ON:%d\", retries);\n\t\tqca_power_shutdown(hu);\n\t\tif (hu->serdev) {\n\t\t\tserdev_device_close(hu->serdev);\n\t\t\tret = serdev_device_open(hu->serdev);\n\t\t\tif (ret) {\n\t\t\t\tbt_dev_err(hdev, \"failed to open port\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tretries++;\n\t\tgoto retry;\n\t}\n\n\t/* Setup bdaddr */\n\tif (soc_type == QCA_ROME)\n\t\thu->hdev->set_bdaddr = qca_set_bdaddr_rome;\n\telse\n\t\thu->hdev->set_bdaddr = qca_set_bdaddr;\n\n\treturn ret;\n}\n\nstatic const struct hci_uart_proto qca_proto = {\n\t.id\t\t= HCI_UART_QCA,\n\t.name\t\t= \"QCA\",\n\t.manufacturer\t= 29,\n\t.init_speed\t= 115200,\n\t.oper_speed\t= 3000000,\n\t.open\t\t= qca_open,\n\t.close\t\t= qca_close,\n\t.flush\t\t= qca_flush,\n\t.setup\t\t= qca_setup,\n\t.recv\t\t= qca_recv,\n\t.enqueue\t= qca_enqueue,\n\t.dequeue\t= qca_dequeue,\n};\n\nstatic const struct qca_device_data qca_soc_data_wcn3990 = {\n\t.soc_type = QCA_WCN3990,\n\t.vregs = (struct qca_vreg []) {\n\t\t{ \"vddio\", 15000  },\n\t\t{ \"vddxo\", 80000  },\n\t\t{ \"vddrf\", 300000 },\n\t\t{ \"vddch0\", 450000 },\n\t},\n\t.num_vregs = 4,\n};\n\nstatic const struct qca_device_data qca_soc_data_wcn3991 = {\n\t.soc_type = QCA_WCN3991,\n\t.vregs = (struct qca_vreg []) {\n\t\t{ \"vddio\", 15000  },\n\t\t{ \"vddxo\", 80000  },\n\t\t{ \"vddrf\", 300000 },\n\t\t{ \"vddch0\", 450000 },\n\t},\n\t.num_vregs = 4,\n\t.capabilities = QCA_CAP_WIDEBAND_SPEECH | QCA_CAP_VALID_LE_STATES,\n};\n\nstatic const struct qca_device_data qca_soc_data_wcn3998 = {\n\t.soc_type = QCA_WCN3998,\n\t.vregs = (struct qca_vreg []) {\n\t\t{ \"vddio\", 10000  },\n\t\t{ \"vddxo\", 80000  },\n\t\t{ \"vddrf\", 300000 },\n\t\t{ \"vddch0\", 450000 },\n\t},\n\t.num_vregs = 4,\n};\n\nstatic const struct qca_device_data qca_soc_data_qca6390 = {\n\t.soc_type = QCA_QCA6390,\n\t.num_vregs = 0,\n};\n\nstatic const struct qca_device_data qca_soc_data_wcn6750 = {\n\t.soc_type = QCA_WCN6750,\n\t.vregs = (struct qca_vreg []) {\n\t\t{ \"vddio\", 5000 },\n\t\t{ \"vddaon\", 26000 },\n\t\t{ \"vddbtcxmx\", 126000 },\n\t\t{ \"vddrfacmn\", 12500 },\n\t\t{ \"vddrfa0p8\", 102000 },\n\t\t{ \"vddrfa1p7\", 302000 },\n\t\t{ \"vddrfa1p2\", 257000 },\n\t\t{ \"vddrfa2p2\", 1700000 },\n\t\t{ \"vddasd\", 200 },\n\t},\n\t.num_vregs = 9,\n\t.capabilities = QCA_CAP_WIDEBAND_SPEECH | QCA_CAP_VALID_LE_STATES,\n};\n\nstatic void qca_power_shutdown(struct hci_uart *hu)\n{\n\tstruct qca_serdev *qcadev;\n\tstruct qca_data *qca = hu->priv;\n\tunsigned long flags;\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\tbool sw_ctrl_state;\n\n\t/* From this point we go into power off state. But serial port is\n\t * still open, stop queueing the IBS data and flush all the buffered\n\t * data in skb's.\n\t */\n\tspin_lock_irqsave(&qca->hci_ibs_lock, flags);\n\tset_bit(QCA_IBS_DISABLED, &qca->flags);\n\tqca_flush(hu);\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\t/* Non-serdev device usually is powered by external power\n\t * and don't need additional action in driver for power down\n\t */\n\tif (!hu->serdev)\n\t\treturn;\n\n\tqcadev = serdev_device_get_drvdata(hu->serdev);\n\n\tif (qca_is_wcn399x(soc_type)) {\n\t\thost_set_baudrate(hu, 2400);\n\t\tqca_send_power_pulse(hu, false);\n\t\tqca_regulator_disable(qcadev);\n\t} else if (soc_type == QCA_WCN6750) {\n\t\tgpiod_set_value_cansleep(qcadev->bt_en, 0);\n\t\tmsleep(100);\n\t\tqca_regulator_disable(qcadev);\n\t\tif (qcadev->sw_ctrl) {\n\t\t\tsw_ctrl_state = gpiod_get_value_cansleep(qcadev->sw_ctrl);\n\t\t\tbt_dev_dbg(hu->hdev, \"SW_CTRL is %d\", sw_ctrl_state);\n\t\t}\n\t} else if (qcadev->bt_en) {\n\t\tgpiod_set_value_cansleep(qcadev->bt_en, 0);\n\t}\n\n\tset_bit(QCA_BT_OFF, &qca->flags);\n}\n\nstatic int qca_power_off(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct qca_data *qca = hu->priv;\n\tenum qca_btsoc_type soc_type = qca_soc_type(hu);\n\n\thu->hdev->hw_error = NULL;\n\thu->hdev->cmd_timeout = NULL;\n\n\tdel_timer_sync(&qca->wake_retrans_timer);\n\tdel_timer_sync(&qca->tx_idle_timer);\n\n\t/* Stop sending shutdown command if soc crashes. */\n\tif (soc_type != QCA_ROME\n\t\t&& qca->memdump_state == QCA_MEMDUMP_IDLE) {\n\t\tqca_send_pre_shutdown_cmd(hdev);\n\t\tusleep_range(8000, 10000);\n\t}\n\n\tqca_power_shutdown(hu);\n\treturn 0;\n}\n\nstatic int qca_regulator_enable(struct qca_serdev *qcadev)\n{\n\tstruct qca_power *power = qcadev->bt_power;\n\tint ret;\n\n\t/* Already enabled */\n\tif (power->vregs_on)\n\t\treturn 0;\n\n\tBT_DBG(\"enabling %d regulators)\", power->num_vregs);\n\n\tret = regulator_bulk_enable(power->num_vregs, power->vreg_bulk);\n\tif (ret)\n\t\treturn ret;\n\n\tpower->vregs_on = true;\n\n\tret = clk_prepare_enable(qcadev->susclk);\n\tif (ret)\n\t\tqca_regulator_disable(qcadev);\n\n\treturn ret;\n}\n\nstatic void qca_regulator_disable(struct qca_serdev *qcadev)\n{\n\tstruct qca_power *power;\n\n\tif (!qcadev)\n\t\treturn;\n\n\tpower = qcadev->bt_power;\n\n\t/* Already disabled? */\n\tif (!power->vregs_on)\n\t\treturn;\n\n\tregulator_bulk_disable(power->num_vregs, power->vreg_bulk);\n\tpower->vregs_on = false;\n\n\tclk_disable_unprepare(qcadev->susclk);\n}\n\nstatic int qca_init_regulators(struct qca_power *qca,\n\t\t\t\tconst struct qca_vreg *vregs, size_t num_vregs)\n{\n\tstruct regulator_bulk_data *bulk;\n\tint ret;\n\tint i;\n\n\tbulk = devm_kcalloc(qca->dev, num_vregs, sizeof(*bulk), GFP_KERNEL);\n\tif (!bulk)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_vregs; i++)\n\t\tbulk[i].supply = vregs[i].name;\n\n\tret = devm_regulator_bulk_get(qca->dev, num_vregs, bulk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_vregs; i++) {\n\t\tret = regulator_set_load(bulk[i].consumer, vregs[i].load_uA);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tqca->vreg_bulk = bulk;\n\tqca->num_vregs = num_vregs;\n\n\treturn 0;\n}\n\nstatic int qca_serdev_probe(struct serdev_device *serdev)\n{\n\tstruct qca_serdev *qcadev;\n\tstruct hci_dev *hdev;\n\tconst struct qca_device_data *data;\n\tint err;\n\tbool power_ctrl_enabled = true;\n\n\tqcadev = devm_kzalloc(&serdev->dev, sizeof(*qcadev), GFP_KERNEL);\n\tif (!qcadev)\n\t\treturn -ENOMEM;\n\n\tqcadev->serdev_hu.serdev = serdev;\n\tdata = device_get_match_data(&serdev->dev);\n\tserdev_device_set_drvdata(serdev, qcadev);\n\tdevice_property_read_string(&serdev->dev, \"firmware-name\",\n\t\t\t\t\t &qcadev->firmware_name);\n\tdevice_property_read_u32(&serdev->dev, \"max-speed\",\n\t\t\t\t &qcadev->oper_speed);\n\tif (!qcadev->oper_speed)\n\t\tBT_DBG(\"UART will pick default operating speed\");\n\n\tif (data &&\n\t    (qca_is_wcn399x(data->soc_type) ||\n\t    qca_is_wcn6750(data->soc_type))) {\n\t\tqcadev->btsoc_type = data->soc_type;\n\t\tqcadev->bt_power = devm_kzalloc(&serdev->dev,\n\t\t\t\t\t\tsizeof(struct qca_power),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!qcadev->bt_power)\n\t\t\treturn -ENOMEM;\n\n\t\tqcadev->bt_power->dev = &serdev->dev;\n\t\terr = qca_init_regulators(qcadev->bt_power, data->vregs,\n\t\t\t\t\t  data->num_vregs);\n\t\tif (err) {\n\t\t\tBT_ERR(\"Failed to init regulators:%d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tqcadev->bt_power->vregs_on = false;\n\n\t\tqcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\",\n\t\t\t\t\t       GPIOD_OUT_LOW);\n\t\tif (IS_ERR_OR_NULL(qcadev->bt_en) && data->soc_type == QCA_WCN6750) {\n\t\t\tdev_err(&serdev->dev, \"failed to acquire BT_EN gpio\\n\");\n\t\t\tpower_ctrl_enabled = false;\n\t\t}\n\n\t\tqcadev->sw_ctrl = devm_gpiod_get_optional(&serdev->dev, \"swctrl\",\n\t\t\t\t\t       GPIOD_IN);\n\t\tif (IS_ERR_OR_NULL(qcadev->sw_ctrl) && data->soc_type == QCA_WCN6750)\n\t\t\tdev_warn(&serdev->dev, \"failed to acquire SW_CTRL gpio\\n\");\n\n\t\tqcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);\n\t\tif (IS_ERR(qcadev->susclk)) {\n\t\t\tdev_err(&serdev->dev, \"failed to acquire clk\\n\");\n\t\t\treturn PTR_ERR(qcadev->susclk);\n\t\t}\n\n\t\terr = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);\n\t\tif (err) {\n\t\t\tBT_ERR(\"wcn3990 serdev registration failed\");\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tif (data)\n\t\t\tqcadev->btsoc_type = data->soc_type;\n\t\telse\n\t\t\tqcadev->btsoc_type = QCA_ROME;\n\n\t\tqcadev->bt_en = devm_gpiod_get_optional(&serdev->dev, \"enable\",\n\t\t\t\t\t       GPIOD_OUT_LOW);\n\t\tif (IS_ERR_OR_NULL(qcadev->bt_en)) {\n\t\t\tdev_warn(&serdev->dev, \"failed to acquire enable gpio\\n\");\n\t\t\tpower_ctrl_enabled = false;\n\t\t}\n\n\t\tqcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);\n\t\tif (IS_ERR(qcadev->susclk)) {\n\t\t\tdev_warn(&serdev->dev, \"failed to acquire clk\\n\");\n\t\t\treturn PTR_ERR(qcadev->susclk);\n\t\t}\n\t\terr = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = clk_prepare_enable(qcadev->susclk);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);\n\t\tif (err) {\n\t\t\tBT_ERR(\"Rome serdev registration failed\");\n\t\t\tclk_disable_unprepare(qcadev->susclk);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\thdev = qcadev->serdev_hu.hdev;\n\n\tif (power_ctrl_enabled) {\n\t\tset_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);\n\t\thdev->shutdown = qca_power_off;\n\t}\n\n\tif (data) {\n\t\t/* Wideband speech support must be set per driver since it can't\n\t\t * be queried via hci. Same with the valid le states quirk.\n\t\t */\n\t\tif (data->capabilities & QCA_CAP_WIDEBAND_SPEECH)\n\t\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,\n\t\t\t\t&hdev->quirks);\n\n\t\tif (data->capabilities & QCA_CAP_VALID_LE_STATES)\n\t\t\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\t}\n\n\treturn 0;\n}\n\nstatic void qca_serdev_remove(struct serdev_device *serdev)\n{\n\tstruct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);\n\tstruct qca_power *power = qcadev->bt_power;\n\n\tif ((qca_is_wcn399x(qcadev->btsoc_type) ||\n\t     qca_is_wcn6750(qcadev->btsoc_type)) &&\n\t     power->vregs_on)\n\t\tqca_power_shutdown(&qcadev->serdev_hu);\n\telse if (qcadev->susclk)\n\t\tclk_disable_unprepare(qcadev->susclk);\n\n\thci_uart_unregister_device(&qcadev->serdev_hu);\n}\n\nstatic void qca_serdev_shutdown(struct device *dev)\n{\n\tint ret;\n\tint timeout = msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS);\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\tstruct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);\n\tconst u8 ibs_wake_cmd[] = { 0xFD };\n\tconst u8 edl_reset_soc_cmd[] = { 0x01, 0x00, 0xFC, 0x01, 0x05 };\n\n\tif (qcadev->btsoc_type == QCA_QCA6390) {\n\t\tserdev_device_write_flush(serdev);\n\t\tret = serdev_device_write_buf(serdev, ibs_wake_cmd,\n\t\t\t\t\t      sizeof(ibs_wake_cmd));\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"QCA send IBS_WAKE_IND error: %d\", ret);\n\t\t\treturn;\n\t\t}\n\t\tserdev_device_wait_until_sent(serdev, timeout);\n\t\tusleep_range(8000, 10000);\n\n\t\tserdev_device_write_flush(serdev);\n\t\tret = serdev_device_write_buf(serdev, edl_reset_soc_cmd,\n\t\t\t\t\t      sizeof(edl_reset_soc_cmd));\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"QCA send EDL_RESET_REQ error: %d\", ret);\n\t\t\treturn;\n\t\t}\n\t\tserdev_device_wait_until_sent(serdev, timeout);\n\t\tusleep_range(8000, 10000);\n\t}\n}\n\nstatic int __maybe_unused qca_suspend(struct device *dev)\n{\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\tstruct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);\n\tstruct hci_uart *hu = &qcadev->serdev_hu;\n\tstruct qca_data *qca = hu->priv;\n\tunsigned long flags;\n\tbool tx_pending = false;\n\tint ret = 0;\n\tu8 cmd;\n\tu32 wait_timeout = 0;\n\n\tset_bit(QCA_SUSPENDING, &qca->flags);\n\n\t/* if BT SoC is running with default firmware then it does not\n\t * support in-band sleep\n\t */\n\tif (test_bit(QCA_ROM_FW, &qca->flags))\n\t\treturn 0;\n\n\t/* During SSR after memory dump collection, controller will be\n\t * powered off and then powered on.If controller is powered off\n\t * during SSR then we should wait until SSR is completed.\n\t */\n\tif (test_bit(QCA_BT_OFF, &qca->flags) &&\n\t    !test_bit(QCA_SSR_TRIGGERED, &qca->flags))\n\t\treturn 0;\n\n\tif (test_bit(QCA_IBS_DISABLED, &qca->flags) ||\n\t    test_bit(QCA_SSR_TRIGGERED, &qca->flags)) {\n\t\twait_timeout = test_bit(QCA_SSR_TRIGGERED, &qca->flags) ?\n\t\t\t\t\tIBS_DISABLE_SSR_TIMEOUT_MS :\n\t\t\t\t\tFW_DOWNLOAD_TIMEOUT_MS;\n\n\t\t/* QCA_IBS_DISABLED flag is set to true, During FW download\n\t\t * and during memory dump collection. It is reset to false,\n\t\t * After FW download complete.\n\t\t */\n\t\twait_on_bit_timeout(&qca->flags, QCA_IBS_DISABLED,\n\t\t\t    TASK_UNINTERRUPTIBLE, msecs_to_jiffies(wait_timeout));\n\n\t\tif (test_bit(QCA_IBS_DISABLED, &qca->flags)) {\n\t\t\tbt_dev_err(hu->hdev, \"SSR or FW download time out\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tcancel_work_sync(&qca->ws_awake_device);\n\tcancel_work_sync(&qca->ws_awake_rx);\n\n\tspin_lock_irqsave_nested(&qca->hci_ibs_lock,\n\t\t\t\t flags, SINGLE_DEPTH_NESTING);\n\n\tswitch (qca->tx_ibs_state) {\n\tcase HCI_IBS_TX_WAKING:\n\t\tdel_timer(&qca->wake_retrans_timer);\n\t\tfallthrough;\n\tcase HCI_IBS_TX_AWAKE:\n\t\tdel_timer(&qca->tx_idle_timer);\n\n\t\tserdev_device_write_flush(hu->serdev);\n\t\tcmd = HCI_IBS_SLEEP_IND;\n\t\tret = serdev_device_write_buf(hu->serdev, &cmd, sizeof(cmd));\n\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"Failed to send SLEEP to device\");\n\t\t\tbreak;\n\t\t}\n\n\t\tqca->tx_ibs_state = HCI_IBS_TX_ASLEEP;\n\t\tqca->ibs_sent_slps++;\n\t\ttx_pending = true;\n\t\tbreak;\n\n\tcase HCI_IBS_TX_ASLEEP:\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Spurious tx state %d\", qca->tx_ibs_state);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&qca->hci_ibs_lock, flags);\n\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (tx_pending) {\n\t\tserdev_device_wait_until_sent(hu->serdev,\n\t\t\t\t\t      msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS));\n\t\tserial_clock_vote(HCI_IBS_TX_VOTE_CLOCK_OFF, hu);\n\t}\n\n\t/* Wait for HCI_IBS_SLEEP_IND sent by device to indicate its Tx is going\n\t * to sleep, so that the packet does not wake the system later.\n\t */\n\tret = wait_event_interruptible_timeout(qca->suspend_wait_q,\n\t\t\tqca->rx_ibs_state == HCI_IBS_RX_ASLEEP,\n\t\t\tmsecs_to_jiffies(IBS_BTSOC_TX_IDLE_TIMEOUT_MS));\n\tif (ret == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tclear_bit(QCA_SUSPENDING, &qca->flags);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused qca_resume(struct device *dev)\n{\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\tstruct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);\n\tstruct hci_uart *hu = &qcadev->serdev_hu;\n\tstruct qca_data *qca = hu->priv;\n\n\tclear_bit(QCA_SUSPENDING, &qca->flags);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(qca_pm_ops, qca_suspend, qca_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id qca_bluetooth_of_match[] = {\n\t{ .compatible = \"qcom,qca6174-bt\" },\n\t{ .compatible = \"qcom,qca6390-bt\", .data = &qca_soc_data_qca6390},\n\t{ .compatible = \"qcom,qca9377-bt\" },\n\t{ .compatible = \"qcom,wcn3990-bt\", .data = &qca_soc_data_wcn3990},\n\t{ .compatible = \"qcom,wcn3991-bt\", .data = &qca_soc_data_wcn3991},\n\t{ .compatible = \"qcom,wcn3998-bt\", .data = &qca_soc_data_wcn3998},\n\t{ .compatible = \"qcom,wcn6750-bt\", .data = &qca_soc_data_wcn6750},\n\t{ /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, qca_bluetooth_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id qca_bluetooth_acpi_match[] = {\n\t{ \"QCOM6390\", (kernel_ulong_t)&qca_soc_data_qca6390 },\n\t{ \"DLA16390\", (kernel_ulong_t)&qca_soc_data_qca6390 },\n\t{ \"DLB16390\", (kernel_ulong_t)&qca_soc_data_qca6390 },\n\t{ \"DLB26390\", (kernel_ulong_t)&qca_soc_data_qca6390 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, qca_bluetooth_acpi_match);\n#endif\n\n\nstatic struct serdev_device_driver qca_serdev_driver = {\n\t.probe = qca_serdev_probe,\n\t.remove = qca_serdev_remove,\n\t.driver = {\n\t\t.name = \"hci_uart_qca\",\n\t\t.of_match_table = of_match_ptr(qca_bluetooth_of_match),\n\t\t.acpi_match_table = ACPI_PTR(qca_bluetooth_acpi_match),\n\t\t.shutdown = qca_serdev_shutdown,\n\t\t.pm = &qca_pm_ops,\n\t},\n};\n\nint __init qca_init(void)\n{\n\tserdev_device_driver_register(&qca_serdev_driver);\n\n\treturn hci_uart_register_proto(&qca_proto);\n}\n\nint __exit qca_deinit(void)\n{\n\tserdev_device_driver_unregister(&qca_serdev_driver);\n\n\treturn hci_uart_unregister_proto(&qca_proto);\n}\n"], "filenames": ["drivers/bluetooth/hci_qca.c"], "buggy_code_start_loc": [2062], "buggy_code_end_loc": [2092], "fixing_code_start_loc": [2062], "fixing_code_end_loc": [2092], "type": "CWE-476", "message": "In the Linux kernel before 5.16.3, drivers/bluetooth/hci_qca.c misinterprets the devm_gpiod_get_index_optional return value (expects it to be NULL in the error case, whereas it is actually an error pointer).", "other": {"cve": {"id": "CVE-2023-23002", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-01T20:15:13.813", "lastModified": "2023-03-13T15:02:28.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.16.3, drivers/bluetooth/hci_qca.c misinterprets the devm_gpiod_get_index_optional return value (expects it to be NULL in the error case, whereas it is actually an error pointer)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.16.3", "matchCriteriaId": "6FBCF385-C05A-44CC-AF30-EDA38785D4BD"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/6845667146a28c09b5dfc401c1ad112374087944", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6845667146a28c09b5dfc401c1ad112374087944"}}