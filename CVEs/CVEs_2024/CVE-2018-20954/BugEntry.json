{"buggy_code": ["#coding:utf-8\nimport os\nimport string\nimport sys\nimport time\nimport re\nimport StringIO\nimport tempfile\nimport threading\nimport traceback\nimport select\nimport pgpdump\nimport base64\nimport quopri\nfrom datetime import datetime\nfrom email.parser import Parser\nfrom email.message import Message\nfrom threading import Thread\n\nimport mailpile.platforms\nfrom mailpile.i18n import gettext\nfrom mailpile.i18n import ngettext as _n\nfrom mailpile.crypto.state import *\nfrom mailpile.crypto.mime import MimeSigningWrapper, MimeEncryptingWrapper\nfrom mailpile.safe_popen import Popen, PIPE, Safe_Pipe\n\n\n_ = lambda s: s\n\nDEFAULT_KEYSERVERS = [\"hkps://hkps.pool.sks-keyservers.net\",\n                      \"hkp://subset.pool.sks-keyservers.net\"]\nDEFAULT_KEYSERVER_OPTIONS = [\n  'ca-cert-file=%s' % __file__.replace('.pyc', '.py')]\n\nGPG_KEYID_LENGTH = 8\nGNUPG_HOMEDIR = None  # None=use what gpg uses\nGPG_BINARY = mailpile.platforms.GetDefaultGnuPGCommand()\nGPG_VERSIONS = {}\nBLOCKSIZE = 65536\n\nopenpgp_algorithms = {1: _(\"RSA\"),\n                      2: _(\"RSA (encrypt only)\"),\n                      3: _(\"RSA (sign only)\"),\n                      16: _(\"ElGamal (encrypt only)\"),\n                      17: _(\"DSA\"),\n                      20: _(\"ElGamal (encrypt/sign) [COMPROMISED]\"),\n                      22: _(\"EdDSA\"),\n                      999: _(\"Unknown\")}\n# For details on type 20 compromisation, see\n# http://lists.gnupg.org/pipermail/gnupg-announce/2003q4/000160.html\n\nENTROPY_LOCK = threading.Lock()\n\nclass GnuPGEventUpdater:\n    \"\"\"\n    Parse the GPG response into something useful for the Event Log.\n    \"\"\"\n    def __init__(self, event):\n        from mailpile.eventlog import Event\n        self.event = event or Event()\n\n    def _log(self, section, message):\n        data = section.get('gnupg', [])\n        if data:\n            data[-1].append(message)\n\n    def _log_private(self, message):\n        self._log(self.event.private_data, message)\n\n    def _log_public(self, message):\n        self._log(self.event.private_data, message)\n        self._log(self.event.data, message)\n\n    def running_gpg(self, why):\n        for section in (self.event.data, self.event.private_data):\n            data = section.get('gnupg', [])\n            data.append([why, int(time.time())])\n            section['gnupg'] = data\n\n    def update_args(self, args):\n        self._log_public(' '.join(args))\n\n    def update_sent_passphrase(self):\n        self._log_public('Sent passphrase')\n\n    def _parse_gpg_line(self, line):\n        if line.startswith('[GNUPG:] '):\n            pass  # FIXME: Parse for machine-readable data\n        elif line.startswith('gpg: '):\n            self._log_private(line[5:].strip())\n\n    def update_stdout(self, line):\n        self._parse_gpg_line(line)\n\n    def update_stderr(self, line):\n        self._parse_gpg_line(line)\n\n    def update_return_code(self, code):\n        self._log_public('GnuPG returned %s' % code)\n\n\nclass GnuPGResultParser:\n    \"\"\"\n    Parse the GPG response into EncryptionInfo and SignatureInfo.\n    \"\"\"\n    def __init__(rp, decrypt_requires_MDC=True, debug=None):\n        rp.decrypt_requires_MDC = decrypt_requires_MDC\n        rp.debug = debug or (lambda t: True)\n\n        rp.signature_info = SignatureInfo()\n        rp.signature_info[\"protocol\"] = \"openpgp\"\n\n        rp.encryption_info = EncryptionInfo()\n        rp.encryption_info[\"protocol\"] = \"openpgp\"\n\n        rp.plaintext = \"\"\n\n    def parse(rp, retvals):\n        signature_info = rp.signature_info\n        encryption_info = rp.encryption_info\n        from mailpile.mailutils.emails import ExtractEmailAndName\n\n        # Belt & suspenders: work around some buggy GnuPG status codes\n        gpg_stderr = ''.join(retvals[1][\"stderr\"])\n\n        # First pass, set some initial state.\n        locked, missing = [], []\n        for data in retvals[1][\"status\"]:\n            keyword = data[0].strip()  # The last keyword often ends in \\n\n\n            if keyword == 'NEED_PASSPHRASE':\n                locked += [data[2]]\n                encryption_info.part_status = \"lockedkey\"\n                encryption_info[\"locked_keys\"] = list(set(locked))\n\n            elif keyword == 'GOOD_PASSPHRASE':\n                encryption_info[\"locked_keys\"] = []\n\n            elif keyword == \"DECRYPTION_FAILED\":\n                missing += [x[1].strip() for x in retvals[1][\"status\"]\n                            if x[0] == \"NO_SECKEY\"]\n                if missing:\n                    encryption_info[\"missing_keys\"] = list(set(missing))\n                if encryption_info.part_status != \"lockedkey\":\n                    if missing:\n                        encryption_info.part_status = \"missingkey\"\n                    else:\n                        encryption_info.part_status = \"error\"\n\n            elif keyword == \"DECRYPTION_OKAY\":\n                if (rp.decrypt_requires_MDC and\n                       'message was not integrity protected' in gpg_stderr):\n                    rp.debug('Message not integrity protected, failing.')\n                    encryption_info.part_status = \"error\"\n                else:\n                    encryption_info.part_status = \"decrypted\"\n                    rp.plaintext = \"\".join(retvals[1][\"stdout\"])\n\n            elif keyword == \"ENC_TO\":\n                keylist = encryption_info.get(\"have_keys\", [])\n                if data[1] not in keylist:\n                    keylist.append(data[1].strip())\n                encryption_info[\"have_keys\"] = list(set(keylist))\n                \n            elif keyword == \"PLAINTEXT\":\n                encryption_info.filename = data[3].strip()\n\n            elif signature_info.part_status == \"none\":\n                # Only one of these will ever be emitted per key, use\n                # this to set initial state. We may end up revising\n                # the status depending on more info later.\n                if keyword in (\"GOODSIG\", \"BADSIG\"):\n                    email, fn = ExtractEmailAndName(\n                        \" \".join(data[2:]).decode('utf-8'))\n                    signature_info[\"name\"] = fn\n                    signature_info[\"email\"] = email\n                    signature_info.part_status = ((keyword == \"GOODSIG\")\n                                                  and \"unverified\"\n                                                  or \"invalid\")\n                    rp.plaintext = \"\".join(retvals[1][\"stdout\"])\n                                                  \n                elif keyword == \"ERRSIG\":\n                    signature_info.part_status = \"error\"\n                    signature_info[\"keyinfo\"] = data[1]\n                    signature_info[\"timestamp\"] = int(data[5])\n\n        # Second pass, this may update/mutate the state set above\n        for data in retvals[1][\"status\"]:\n            keyword = data[0].strip()  # The last keyword often ends in \\n\n\n            if keyword == \"NO_SECKEY\":\n                keyid = data[1].strip()\n                if \"missing_keys\" not in encryption_info:\n                    encryption_info[\"missing_keys\"] = [keyid]\n                elif keyid not in encryption_info[\"missing_keys\"]:\n                    encryption_info[\"missing_keys\"].append(keyid)\n                while keyid in encryption_info[\"have_keys\"]:\n                    encryption_info[\"have_keys\"].remove(keyid)\n\n            elif keyword == \"VALIDSIG\":\n                # FIXME: Determine trust level, between new, unverified,\n                #        verified, untrusted.\n                signature_info[\"keyinfo\"] = data[1]\n                signature_info[\"timestamp\"] = int(data[3])\n\n            elif keyword in (\"EXPKEYSIG\", \"REVKEYSIG\"):\n                email, fn = ExtractEmailAndName(\n                    \" \".join(data[2:]).decode('utf-8'))\n                signature_info[\"name\"] = fn\n                signature_info[\"email\"] = email\n                signature_info.part_status = ((keyword == \"EXPKEYSIG\")\n                                              and \"expired\"\n                                              or \"revoked\")\n\n          # FIXME: This appears to be spammy. Is my key borked, or\n          #        is GnuPG being stupid?\n          #\n          # elif keyword == \"KEYEXPIRED\":  # Ignoring: SIGEXPIRED\n          #     signature_info.part_status = \"expired\"\n            elif keyword == \"KEYREVOKED\":\n                signature_info.part_status = \"revoked\"\n            elif keyword == \"NO_PUBKEY\":\n                signature_info.part_status = \"unknown\"\n\n            elif keyword in (\"TRUST_ULTIMATE\", \"TRUST_FULLY\"):\n                if signature_info.part_status == \"unverified\":\n                    signature_info.part_status = \"verified\"\n\n        if encryption_info.part_status == \"error\":\n            rp.plaintext = \"\"\n\n        return rp\n\n\nclass GnuPGRecordParser:\n    def __init__(self):\n        self.keys = {}\n        self.curkeyid = None\n        self.curdata = None\n\n        self.record_fields = [\"record\", \"validity\", \"keysize\", \"keytype\",\n                              \"keyid\", \"creation_date\", \"expiration_date\",\n                              \"uidhash\", \"ownertrust\", \"uid\", \"sigclass\",\n                              \"capabilities\", \"flag\", \"sn\", \"hashtype\",\n                              \"curve\"]\n        self.record_types = [\"pub\", \"sub\", \"ssb\", \"fpr\", \"uat\", \"sec\", \"tru\",\n                             \"sig\", \"rev\", \"uid\", \"gpg\", \"rvk\", \"grp\"]\n        self.record_parsers = [self.parse_pubkey, self.parse_subkey,\n                               self.parse_subkey, self.parse_fingerprint,\n                               self.parse_userattribute, self.parse_privkey,\n                               self.parse_trust, self.parse_signature,\n                               self.parse_revoke, self.parse_uidline,\n                               self.parse_none, self.parse_revocation_key,\n                               self.parse_keygrip]\n\n        self.dispatch = dict(zip(self.record_types, self.record_parsers))\n\n    def parse(self, lines):\n        for line in lines:\n            self.parse_line(line)\n        return self.keys\n\n    def parse_line(self, line):\n        line = dict(zip(self.record_fields,\n                        map(lambda s: s.replace(\"\\\\x3a\", \":\"),\n                        stubborn_decode(line).strip().split(\":\"))))\n        r = self.dispatch.get(line[\"record\"], self.parse_unknown)\n        r(line)\n\n    def _parse_dates(self, line):\n        for ts in ('expiration_date', 'creation_date'):\n            if line.get(ts) and '-' not in line[ts]:\n                try:\n                    unixtime = int(line[ts])\n                    if unixtime > 946684800:  # 2000-01-01\n                        dt = datetime.fromtimestamp(unixtime)\n                        line[ts] = dt.strftime('%Y-%m-%d')\n                except ValueError:\n                    line[ts+'_unparsed'] = line[ts]\n                    line[ts] = '1970-01-01'\n\n    def _parse_keydata(self, line):\n        line[\"keytype_name\"] = _(openpgp_algorithms.get(int(line[\"keytype\"]),\n                                                        'Unknown'))\n        line[\"capabilities_map\"] = {\n            \"encrypt\": \"E\" in line[\"capabilities\"],\n            \"sign\": \"S\" in line[\"capabilities\"],\n            \"certify\": \"C\" in line[\"capabilities\"],\n            \"authenticate\": \"A\" in line[\"capabilities\"],\n        }\n        line[\"disabled\"] = \"D\" in line[\"capabilities\"]\n        line[\"revoked\"] = \"r\" in line[\"validity\"]\n\n        self._parse_dates(line)\n\n        return line\n\n    def _clean_curdata(self):\n        for v in self.curdata.keys():\n            if self.curdata[v] == \"\":\n                del self.curdata[v]\n        del self.curdata[\"record\"]\n\n    def parse_pubkey(self, line):\n        self.curkeyid = line[\"keyid\"]\n        self.curdata = self.keys[self.curkeyid] = self._parse_keydata(line)\n        self.curdata[\"subkeys\"] = []\n        self.curdata[\"uids\"] = []\n        self.curdata[\"secret\"] = (self.curdata[\"record\"] == \"sec\")\n        self.parse_uidline(self.curdata)\n        self._clean_curdata()\n\n    def parse_subkey(self, line):\n        self.curdata = self._parse_keydata(line)\n        self.keys[self.curkeyid][\"subkeys\"].append(self.curdata)\n        self._clean_curdata()\n\n    def parse_fingerprint(self, line):\n        fpr = line[\"uid\"]\n        self.curdata[\"fingerprint\"] = fpr\n        if len(self.curkeyid) < len(fpr):\n            self.keys[fpr] = self.keys[self.curkeyid]\n            del(self.keys[self.curkeyid])\n            self.curkeyid = fpr\n\n    def parse_userattribute(self, line):\n        # TODO: We are currently ignoring user attributes as not useful.\n        #       We may at some point want to use --attribute-fd and read\n        #       in user photos and such?\n        pass\n\n    def parse_privkey(self, line):\n        self.parse_pubkey(line)\n\n    def parse_uidline(self, line):\n        email, name, comment = parse_uid(line[\"uid\"])\n        self._parse_dates(line)\n        if email or name or comment:\n            self.keys[self.curkeyid][\"uids\"].append({\n                \"email\": email,\n                \"name\": name,\n                \"comment\": comment,\n                \"creation_date\": line[\"creation_date\"]\n            })\n        else:\n            pass  # This is the case where a uid or sec line have no\n                  # information aside from the creation date, which we\n                  # parse elsewhere. As these lines are effectively blank,\n                  # we omit them to simplify presentation to the user.\n\n    def parse_trust(self, line):\n        # FIXME: We are currently ignoring commentary from the Trust DB.\n        pass\n\n    def parse_signature(self, line):\n        # FIXME: This is probably wrong; signatures are on UIDs and not\n        #        the key itself. No? Yes? Figure this out.\n        if \"signatures\" not in self.keys[self.curkeyid]:\n            self.keys[self.curkeyid][\"signatures\"] = []\n        sig = {\n            \"signer\": line[9],\n            \"signature_date\": line[5],\n            \"keyid\": line[4],\n            \"trust\": line[10],\n            \"keytype\": line[4]\n        }\n        self.keys[self.curkeyid][\"signatures\"].append(sig)\n\n    def parse_keygrip(self, line):\n        self.curdata[\"keygrip\"] = line[\"uid\"]\n\n    def parse_revoke(self, line):\n        pass  # FIXME\n\n    def parse_revocation_key(self, line):\n        pass  # FIXME\n\n    def parse_unknown(self, line):\n        print \"Unknown line with code '%s'\" % (line,)\n\n    def parse_none(line):\n        pass\n\n\nUID_PARSE_RE = \"^([^\\(\\<]+?){0,1}( \\((.+?)\\)){0,1}( \\<(.+?)\\>){0,1}\\s*$\"\n\n\ndef stubborn_decode(text):\n    if isinstance(text, unicode):\n        return text\n    try:\n        return text.decode(\"utf-8\")\n    except UnicodeDecodeError:\n        try:\n            return text.decode(\"iso-8859-1\")\n        except UnicodeDecodeError:\n            return uidstr.decode(\"utf-8\", \"replace\")\n\n\ndef parse_uid(uidstr):\n    matches = re.match(UID_PARSE_RE, uidstr)\n    if matches:\n        email = matches.groups(0)[4] or \"\"\n        comment = matches.groups(0)[2] or \"\"\n        name = matches.groups(0)[0] or \"\"\n    else:\n        if '@' in uidstr and ' ' not in uidstr:\n            email, name = uidstr, \"\"\n        else:\n            email, name = \"\", uidstr\n        comment = \"\"\n\n    return email, name, comment\n\n\nclass StreamReader(Thread):\n    def __init__(self, name, fd, callback, lines=True):\n        Thread.__init__(self, target=self.readin, args=(fd, callback))\n        self.name = name\n        self.state = 'startup'\n        self.lines = lines\n        self.start()\n\n    def __str__(self):\n        return '%s(%s/%s, lines=%s)' % (Thread.__str__(self),\n                                        self.name, self.state, self.lines)\n\n    def readin(self, fd, callback):\n        try:\n            if self.lines:\n                self.state = 'read'\n                for line in iter(fd.readline, b''):\n                    self.state = 'callback'\n                    callback(line)\n                    self.state = 'read'\n            else:\n                while True:\n                    self.state = 'read'\n                    buf = fd.read(BLOCKSIZE)\n                    self.state = 'callback'\n                    callback(buf)\n                    if buf == \"\":\n                        break\n        except:\n            traceback.print_exc()\n        finally:\n            self.state = 'done'\n            fd.close()\n\n\nclass StreamWriter(Thread):\n    def __init__(self, name, fd, output, partial_write_ok=False):\n        Thread.__init__(self, target=self.writeout, args=(fd, output))\n        self.name = name\n        self.state = 'startup'\n        self.partial_write_ok = partial_write_ok\n        self.start()\n\n    def __str__(self):\n        return '%s(%s/%s)' % (Thread.__str__(self), self.name, self.state)\n\n    def writeout(self, fd, output):\n        if isinstance(output, (str, unicode)):\n            total = len(output)\n            output = StringIO.StringIO(output)\n        else:\n            total = 0\n        try:\n            while True:\n                self.state = 'read'\n                line = output.read(BLOCKSIZE)\n                if line == \"\":\n                    break\n                self.state = 'write'\n                fd.write(line)\n                total -= len(line)\n            output.close()\n        except:\n            if not self.partial_write_ok:\n                print '%s: %s bytes left' % (self, total)\n                traceback.print_exc()\n        finally:\n            self.state = 'done'\n            fd.close()\n\n\nDEBUG_GNUPG = False\n\nclass GnuPG:\n    \"\"\"\n    Wrap GnuPG and make all functionality feel Pythonic.\n    \"\"\"\n    ARMOR_BEGIN_SIGNED    = '-----BEGIN PGP SIGNED MESSAGE-----'\n    ARMOR_BEGIN_SIGNATURE = '-----BEGIN PGP SIGNATURE-----'\n    ARMOR_END_SIGNED      = '-----END PGP SIGNATURE-----'\n    ARMOR_END_SIGNATURE   = '-----END PGP SIGNATURE-----'\n\n    ARMOR_BEGIN_ENCRYPTED = '-----BEGIN PGP MESSAGE-----'\n    ARMOR_END_ENCRYPTED   = '-----END PGP MESSAGE-----'\n\n    ARMOR_BEGIN_PUB_KEY   = '-----BEGIN PGP PUBLIC KEY BLOCK-----'\n    ARMOR_END_PUB_KEY     = '-----END PGP PUBLIC KEY BLOCK-----'\n\n    LAST_KEY_USED = 'DEFAULT'  # This is a 1-value global cache\n\n    def __init__(self, config,\n                 session=None, use_agent=None, debug=False, dry_run=False,\n                 event=None, passphrase=None):\n        global DEBUG_GNUPG\n        self.available = None\n        self.outputfds = [\"stdout\", \"stderr\", \"status\"]\n        self.errors = []\n        self.event = GnuPGEventUpdater(event)\n        self.session = session\n        self.config = config or (session and session.config) or None\n        if self.config:\n            DEBUG_GNUPG = ('gnupg' in self.config.sys.debug)\n            self.homedir = self.config.sys.gpg_home or GNUPG_HOMEDIR\n            self.gpgbinary = self.config.sys.gpg_binary or GPG_BINARY\n            self.passphrases = self.config.passphrases\n            self.passphrase = (passphrase if (passphrase is not None) else\n                               self.passphrases['DEFAULT']).get_reader()\n            self.use_agent = (use_agent if (use_agent is not None)\n                              else self.config.prefs.gpg_use_agent)\n        else:\n            self.homedir = GNUPG_HOMEDIR\n            self.gpgbinary = GPG_BINARY\n            self.passphrases = None\n            if passphrase:\n                self.passphrase = passphrase.get_reader()\n            else:\n                self.passphrase = None\n            self.use_agent = use_agent\n        self.dry_run = dry_run\n        self.debug = (self._debug_all if (debug or DEBUG_GNUPG)\n                      else self._debug_none)\n\n    def prepare_passphrase(self, keyid, signing=False, decrypting=False):\n        \"\"\"Query the Mailpile secrets for a usable passphrase.\"\"\"\n        def _use(kid, sps_reader):\n            self.passphrase = sps_reader\n            GnuPG.LAST_KEY_USED = kid\n            return True\n\n        if self.config:\n            message = []\n            if decrypting:\n                message.append(_(\"Your PGP key is needed for decrypting.\"))\n            if signing:\n                message.append(_(\"Your PGP key is needed for signing.\"))\n            match, sps = self.config.get_passphrase(keyid,\n                prompt=_('Unlock your encryption key'),\n                description=' '.join(message))\n            if match:\n                return _use(match, sps.get_reader())\n\n        self.passphrase = None  # This *may* allow use of the GnuPG agent\n        return False\n\n    def _debug_all(self, msg):\n        if self.session:\n            self.session.debug(msg.rstrip())\n        else:\n            print '%s' % str(msg).rstrip()\n\n    def _debug_none(self, msg):\n        pass\n\n    def set_home(self, path):\n        self.homedir = path\n\n    def version(self):\n        \"\"\"Returns a string representing the GnuPG version number.\"\"\"\n        self.event.running_gpg(_('Checking GnuPG version'))\n        retvals = self.run([\"--version\"], novercheck=True)\n        return retvals[1][\"stdout\"][0].split('\\n')[0]\n\n    def version_tuple(self, update=False):\n        \"\"\"Returns a tuple representing the GnuPG version number.\"\"\"\n        global GPG_VERSIONS\n        if update or not GPG_VERSIONS.get(self.gpgbinary):\n            match = re.search( \"(\\d+).(\\d+).(\\d+)\", self.version() )\n            version = tuple(int(v) for v in match.groups())\n            GPG_VERSIONS[self.gpgbinary] = version\n        return GPG_VERSIONS[self.gpgbinary]\n\n    def gnupghome(self):\n        \"\"\"Returns the location of the GnuPG keyring\"\"\"\n        self.event.running_gpg(_('Checking GnuPG home directory'))\n        rv = self.run([\"--version\"], novercheck=True)[1][\"stdout\"][0]\n        for l in rv.splitlines():\n            if l.startswith('Home: '):\n                return os.path.expanduser(l[6:].strip())\n        return os.path.expanduser(os.getenv('GNUPGHOME', '~/.gnupg'))\n\n    def is_available(self):\n        try:\n            self.event.running_gpg(_('Checking GnuPG availability'))\n            self.version_tuple(update=True)\n            self.available = True\n        except OSError:\n            self.available = False\n\n        return self.available\n\n    def common_args(self, args=None, version=None, will_send_passphrase=False):\n        if args is None:\n            args = []\n        if version is None:\n            version = self.version_tuple()\n\n        args.insert(0, self.gpgbinary)\n        args.insert(1, \"--utf8-strings\")\n        args.insert(1, \"--with-colons\")\n        args.insert(1, \"--verbose\")\n        args.insert(1, \"--batch\")\n        args.insert(1, \"--enable-progress-filter\")\n\n        # Disable SHA1 in all things GnuPG\n        args[1:1] = [\"--personal-digest-preferences=SHA512\",\n                     \"--digest-algo=SHA512\",\n                     \"--cert-digest-algo=SHA512\"]\n\n        if (not self.use_agent) or will_send_passphrase:\n            if version < (1, 5):\n                args.insert(1, \"--no-use-agent\")\n            elif version > (2, 1, 11):\n                args.insert(1, \"--pinentry-mode=loopback\")\n            else:\n                raise ImportError('Mailpile requires GnuPG 1.4.x or 2.1.12+ !')\n\n        if self.homedir:\n            args.insert(1, \"--homedir=%s\" % self.homedir)\n\n        args.insert(1, \"--status-fd=2\")\n        if will_send_passphrase:\n            args.insert(2, \"--passphrase-fd=0\")\n\n        if self.dry_run:\n            args.insert(1, \"--dry-run\")\n\n        return args\n\n    def run(self,\n            args=None, gpg_input=None, outputfd=None, partial_read_ok=False,\n            send_passphrase=False, _raise=None, novercheck=False):\n        if novercheck:\n            version = (1, 4)\n        else:\n            version = self.version_tuple()\n\n        args = self.common_args(\n            args=list(args if args else []),\n            version=version,\n            will_send_passphrase=(self.passphrase and send_passphrase))\n\n        self.outputbuffers = dict([(x, []) for x in self.outputfds])\n        self.threads = {}\n        gpg_retcode = -1\n        proc = None\n        try:\n            if send_passphrase and (self.passphrase is None):\n                self.debug('Running WITHOUT PASSPHRASE %s' % ' '.join(args))\n                self.debug(''.join(traceback.format_stack()))\n            else:\n                self.debug('Running %s' % ' '.join(args))\n\n            # Here we go!\n            self.event.update_args(args)\n            proc = Popen(args, stdin=PIPE, stdout=PIPE, stderr=PIPE, bufsize=0)\n\n            # GnuPG is a bit crazy, and requires that the passphrase\n            # be sent and the filehandle closed before anything else\n            # interesting happens.\n            if send_passphrase and self.passphrase is not None:\n                self.passphrase.seek(0, 0)\n                c = self.passphrase.read(BLOCKSIZE)\n                while c != '':\n                    proc.stdin.write(c)\n                    c = self.passphrase.read(BLOCKSIZE)\n                proc.stdin.write('\\n')\n                self.event.update_sent_passphrase()\n\n            wtf = ' '.join(args)\n            self.threads = {\n                \"stderr\": StreamReader('gpgi-stderr(%s)' % wtf,\n                                       proc.stderr, self.parse_stderr)\n            }\n\n            if outputfd:\n                self.threads[\"stdout\"] = StreamReader(\n                    'gpgi-stdout-to-fd(%s)' % wtf,\n                    proc.stdout, outputfd.write, lines=False)\n            else:\n                self.threads[\"stdout\"] = StreamReader(\n                    'gpgi-stdout-parsed(%s)' % wtf,\n                    proc.stdout, self.parse_stdout)\n\n            if gpg_input:\n                # If we have output, we just stream it. Technically, this\n                # doesn't really need to be a thread at the moment.\n                self.debug('<<STDOUT<< %s' % gpg_input)\n                StreamWriter('gpgi-output(%s)' % wtf,\n                             proc.stdin, gpg_input,\n                             partial_write_ok=partial_read_ok).join()\n            else:\n                proc.stdin.close()\n\n            # Reap GnuPG\n            gpg_retcode = proc.wait()\n\n        finally:\n            # Close this so GPG will terminate. This should already have\n            # been done, but we're handling errors here...\n            if proc and proc.stdin:\n                proc.stdin.close()\n\n        # Update event with return code\n        self.event.update_return_code(gpg_retcode)\n\n        # Reap the threads\n        self._reap_threads()\n\n        if outputfd:\n            outputfd.close()\n\n        if gpg_retcode != 0 and _raise:\n            raise _raise('GnuPG failed, exit code: %s' % gpg_retcode)\n\n        return gpg_retcode, self.outputbuffers\n\n    def _reap_threads(self):\n        for tries in (1, 2, 3):\n            for name, thr in self.threads.iteritems():\n                if thr.isAlive():\n                    thr.join(timeout=15)\n                    if thr.isAlive() and tries > 1:\n                        print 'WARNING: Failed to reap thread %s' % thr\n\n    def parse_status(self, line, *args):\n        self.debug('<<STATUS<< %s' % line)\n        line = line.replace(\"[GNUPG:] \", \"\")\n        if line == \"\":\n            return\n        elems = line.split(\" \")\n        self.outputbuffers[\"status\"].append(elems)\n\n    def parse_stdout(self, line):\n        self.event.update_stdout(line)\n        self.debug('<<STDOUT<< %s' % line)\n        self.outputbuffers[\"stdout\"].append(line)\n\n    def parse_stderr(self, line):\n        self.event.update_stderr(line)\n        if line.startswith(\"[GNUPG:] \"):\n            return self.parse_status(line)\n        self.debug('<<STDERR<< %s' % line)\n        self.outputbuffers[\"stderr\"].append(line)\n\n    def parse_keylist(self, keylist):\n        rlp = GnuPGRecordParser()\n        return rlp.parse(keylist)\n\n    def list_keys(self, selectors=None):\n        \"\"\"\n        >>> g = GnuPG(None)\n        >>> g.list_keys()[0]\n        0\n        \"\"\"\n        list_keys = [\"--fingerprint\"]\n        for sel in set(selectors or []):\n            list_keys += [\"--list-keys\", sel]\n        if not selectors:\n            list_keys += [\"--list-keys\"]\n        self.event.running_gpg(_('Fetching GnuPG public key list (selectors=%s)'\n                                 ) % ', '.join(selectors or []))\n        retvals = self.run(list_keys)\n        return self.parse_keylist(retvals[1][\"stdout\"])\n\n    def list_secret_keys(self, selectors=None):\n        #\n        # Note: The selectors that are passed by default work around a bug\n        #       in GnuPG < 2.1, where --list-secret-keys does not list\n        #       details about key capabilities or expiry for\n        #       --list-secret-keys unless a selector is provided. A dot\n        #       is reasonably likely to appear in all PGP keys, as it is\n        #       a common component of e-mail addresses (and @ does not\n        #       work as a selector for some reason...)\n        #\n        #       The downside of this workaround is that keys with no e-mail\n        #       address or an address like alice@localhost won't be found.\n        #       So we disable this hack on GnuPG >= 2.1.\n        #\n        if not selectors and self.version_tuple() < (2, 1):\n            selectors = [\".\", \"a\", \"e\", \"i\", \"p\", \"t\", \"k\"]\n\n        list_keys = [\"--fingerprint\"]\n        if selectors:\n            for sel in selectors:\n                list_keys += [\"--list-secret-keys\", sel]\n        else:\n            list_keys += [\"--list-secret-keys\"]\n\n        self.event.running_gpg(_('Fetching GnuPG secret key list (selectors=%s)'\n                                 ) % ', '.join(selectors or ['None']))\n        retvals = self.run(list_keys)\n        secret_keys = self.parse_keylist(retvals[1][\"stdout\"])\n\n        # Another unfortunate thing GPG does, is it hides the disabled\n        # state when listing secret keys; it seems internally only the\n        # public key is disabled. This makes it hard for us to reason about\n        # which keys can actually be used, so we compensate...\n        list_keys = [\"--fingerprint\"]\n        for fprint in set(secret_keys):\n            list_keys += [\"--list-keys\", fprint]\n        retvals = self.run(list_keys)\n        public_keys = self.parse_keylist(retvals[1][\"stdout\"])\n        for fprint, info in public_keys.iteritems():\n            if fprint in set(secret_keys):\n                for k in (\"disabled\", \"revoked\"):  # FIXME: Copy more?\n                    secret_keys[fprint][k] = info[k]\n\n        return secret_keys\n\n    def import_keys(self, key_data=None):\n        \"\"\"\n        Imports gpg keys from a file object or string.\n        >>> key_data = open(\"testing/pub.key\").read()\n        >>> g = GnuPG(None)\n        >>> g.import_keys(key_data)\n        {'failed': [], 'updated': [{'details_text': 'unchanged', 'details': 0, 'fingerprint': '08A650B8E2CBC1B02297915DC65626EED13C70DA'}], 'imported': [], 'results': {'sec_dups': 0, 'unchanged': 1, 'num_uids': 0, 'skipped_new_keys': 0, 'no_userids': 0, 'num_signatures': 0, 'num_revoked': 0, 'sec_imported': 0, 'sec_read': 0, 'not_imported': 0, 'count': 1, 'imported_rsa': 0, 'imported': 0, 'num_subkeys': 0}}\n        \"\"\"\n        self.event.running_gpg(_('Importing key to GnuPG key chain'))\n        retvals = self.run([\"--import\"], gpg_input=key_data)\n        return self._parse_import(retvals[1][\"status\"])\n\n    def _parse_import(self, output):\n        res = {\"imported\": [], \"updated\": [], \"failed\": []}\n        for x in output:\n            if x[0] == \"IMPORTED\":\n                res[\"imported\"].append({\n                    \"fingerprint\": x[1],\n                    \"username\": x[2].rstrip()\n                })\n            elif x[0] == \"IMPORT_OK\":\n                reasons = {\n                    \"0\": \"unchanged\",\n                    \"1\": \"new key\",\n                    \"2\": \"new user IDs\",\n                    \"4\": \"new signatures\",\n                    \"8\": \"new subkeys\",\n                    \"16\": \"contains private key\",\n                    \"17\": \"contains new private key\",\n                }\n                res[\"updated\"].append({\n                    \"details\": int(x[1]),\n                    # FIXME: Reasons may be ORed! This does NOT handle that.\n                    \"details_text\": reasons.get(x[1], str(x[1])),\n                    \"fingerprint\": x[2].rstrip(),\n                })\n            elif x[0] == \"IMPORT_PROBLEM\":\n                reasons = {\n                    \"0\": \"no reason given\",\n                    \"1\": \"invalid certificate\",\n                    \"2\": \"issuer certificate missing\",\n                    \"3\": \"certificate chain too long\",\n                    \"4\": \"error storing certificate\",\n                }\n                res[\"failed\"].append({\n                    \"details\": int(x[1]),\n                    \"details_text\": reasons.get(x[1], str(x[1])),\n                    \"fingerprint\": x[2].rstrip()\n                })\n            elif x[0] == \"IMPORT_RES\":\n                res[\"results\"] = {\n                    \"count\": int(x[1]),\n                    \"no_userids\": int(x[2]),\n                    \"imported\": int(x[3]),\n                    \"imported_rsa\": int(x[4]),\n                    \"unchanged\": int(x[5]),\n                    \"num_uids\": int(x[6]),\n                    \"num_subkeys\": int(x[7]),\n                    \"num_signatures\": int(x[8]),\n                    \"num_revoked\": int(x[9]),\n                    \"sec_read\": int(x[10]),\n                    \"sec_imported\": int(x[11]),\n                    \"sec_dups\": int(x[12]),\n                    \"skipped_new_keys\": int(x[13]),\n                    \"not_imported\": int(x[14].rstrip()),\n                }\n        return res\n\n    def decrypt(self, data,\n            outputfd=None, passphrase=None, as_lines=False, require_MDC=True):\n        \"\"\"\n        Note that this test will fail if you don't replace the recipient with\n        one whose key you control.\n        >>> g = GnuPG(None)\n        >>> ct = g.encrypt(\"Hello, World\", to=[\"smari@mailpile.is\"])[1]\n        >>> g.decrypt(ct)[\"text\"]\n        'Hello, World'\n        \"\"\"\n        if passphrase is not None:\n            self.passphrase = passphrase.get_reader()\n        elif GnuPG.LAST_KEY_USED:\n            # This is an opportunistic approach to passphrase usage... we\n            # just hope the passphrase we used last time will work again.\n            # If we are right, we are done. If we are wrong, the output\n            # will tell us which key IDs to look for in our secret stash.\n            self.prepare_passphrase(GnuPG.LAST_KEY_USED, decrypting=True)\n\n        self.event.running_gpg(_('Decrypting %d bytes of data') % len(data))\n        for tries in (1, 2):\n            retvals = self.run([\"--decrypt\"], gpg_input=data,\n                                              outputfd=outputfd,\n                                              send_passphrase=True)\n            if tries == 1:\n                keyid = None\n                for msg in reversed(retvals[1]['status']):\n                    # Reverse order so DECRYPTION_OKAY overrides KEY_CONSIDERED.\n                    # If decryption is not ok, look for good passphrase, retry.\n                    if  msg[0] == 'DECRYPTION_OKAY':\n                        break\n                    elif (msg[0] == 'NEED_PASSPHRASE') and (passphrase is None):\n                        # This message is output by gpg 1.4 but not 2.1.\n                        if self.prepare_passphrase(msg[2], decrypting=True):\n                            keyid = msg[2]\n                            break\n                    elif (msg[0] == 'KEY_CONSIDERED') and (passphrase is None):                       \n                        # This message is output by gpg 2.1 but not 1.4.\n                        if self.prepare_passphrase(msg[1], decrypting=True):\n                            keyid = msg[1]\n                            break\n                if not keyid:\n                    break\n\n        if as_lines:\n            as_lines = retvals[1][\"stdout\"]\n            retvals[1][\"stdout\"] = []\n\n        rp = GnuPGResultParser(decrypt_requires_MDC=require_MDC,\n                               debug=self.debug).parse(retvals)\n        return (rp.signature_info, rp.encryption_info,\n                as_lines or rp.plaintext)\n                \n    def base64_segment(self, dec_start, dec_end, skip, line_len, line_end = 2):\n        \"\"\"\n        Given the start and end index of a desired segment of decoded data,\n        this function finds smallest segment of an encoded base64 array that\n        when decoded will include the desired decoded segment.\n        It's assumed that the base64 data has a uniform line structure of\n        line_len encoded characters including line_end eol characters,\n        and that there are skip header characters preceding the base64 data.\n        \"\"\"\n        enc_start =  4*(dec_start/3)\n        dec_skip  =  dec_start - 3*enc_start/4\n        enc_start += line_end*(enc_start/(line_len-line_end))\n        enc_end =    4*(dec_end/3)\n        enc_end +=   line_end*(enc_end/(line_len-line_end))\n\n        return enc_start, enc_end, dec_skip\n        \n    def pgp_packet_hdr_parse(self, header, prev_partial = False):\n        \"\"\"\n        Parse the header of a PGP packet to get the packet type, header length,\n        and data length.  Extra trailing characters in header are ignored.\n        prev_partial indicates that the previous packet was a partial packet.\n        An illegal header returns type -1, lengths 0.\n        Header format is defined in RFC4880 section 4.\n        \"\"\"\n        hdr = bytearray(header.ljust( 6, chr(0)))\n        if not prev_partial:\n            hdr_len = 1\n        else:\n            hdr[1:] = hdr           # Partial block headers don't have a tag\n            hdr[0] = 0              # Insert a dummy tag.\n            hdr_len = 0\n        is_partial = False\n        \n        if prev_partial or (hdr[0] & 0xC0) == 0xC0:\n            # New format packet\n            ptag = hdr[0] & 0x3F\n            body_len = hdr[1]\n            lengthtype = 0\n            hdr_len += 1\n            if body_len < 192:\n                pass\n            elif body_len <= 223:\n                hdr_len += 1\n                body_len = ((body_len - 192) << 8) + hdr[2] + 192\n            elif body_len == 255:\n                hdr_len += 4\n                body_len =  ( (hdr[2] << 24) + (hdr[3] << 16) +\n                                (hdr[4] << 8)  + hdr[5] )\n            else:\n                # Partial packet headers are only legal for data packets.\n                if not prev_partial and not ptag in {8,9,11,18}:\n                    return (-1, 0, 0, False)\n                # Could do extra testing here.\n                is_partial = True\n                body_len = 1 << (hdr[1] & 0x1F)\n                \n        elif (hdr[0] & 0xC0) == 0x80:\n            # Old format packet\n            ptag = (hdr[0] & 0x3C) >> 2\n            lengthtype = hdr[0] & 0x03\n            if lengthtype < 3:\n                hdr_len = 2\n                body_len = hdr[1]\n                if lengthtype > 0:\n                    hdr_len = 3\n                    body_len = (body_len << 8) + hdr[2]\n                if lengthtype > 1:\n                    hdr_len = 5\n                    body_len = ( \n                        (body_len << 16) + (hdr[3] << 8) + hdr[4] )\n            else:\n                # Kludgy extra test for compressed packets w/ \"unknown\" length\n                # gpg generates these in signed-only files. Check for valid\n                # compression algorithm id to minimize false positives.\n                if ptag != 8 or (hdr[1] < 1 or hdr[1] > 3):\n                    return (-1, 0, 0, False)\n                hdr_len = 1\n                body_len = -1               \n        else:\n            return (-1, 0, 0, False)\n        \n        if hdr_len > len(header):\n            return (-1, 0, 0, False)    \n    \n        return ptag, hdr_len, body_len, is_partial\n\n\n    def sniff(self, data, encoding = None):\n        \"\"\"\n        Checks arbitrary data to see if it is a PGP object and returns a set\n        that indicates the kind(s) of object found. The names of the set\n        elements are based on RFC3156 content types with 'pgp-' stripped so\n        they can be used in sniffers for other protocols, e.g. S/MIME.\n        There are additional set elements 'armored' and 'unencrypted'.\n        \n        This code should give no false negatives, but may give false positives.\n        For efficient handling of encoded data, only small segments are decoded.\n        Armored files are detected by their armor header alone.\n        Non-armored data is detected by looking for a sequence of valid PGP\n        packet headers.\n        \"\"\"\n     \n        found = set()\n        is_base64 = False\n        is_quopri = False\n        line_len = 0\n        line_end = 1\n        enc_start = 0\n        enc_end = 0\n        dec_start = 0\n        skip = 0\n        ptag = 0\n        hdr_len = 0\n        body_len = 0\n        partial = False\n        offset_enc = 0\n        offset_dec = 0\n        offset_packet = 0\n        \n        # Identify encoding and base64 line length.                                      \n        if encoding and encoding.lower() == 'base64':\n            line_len = data.find('\\n') + 1          # Assume uniform length           \n            if line_len < 0:\n                line_len = len(data)\n            elif line_len > 1 and data[line_len-2] == '\\r':\n                line_end = 2\n            if line_len - line_end > 76:            # Maximum per RFC2045 6.8\n                return found \n            enc_end = line_len\n            try:\n                segment = base64.b64decode(data[enc_start:enc_end])\n            except TypeError:\n                return found\n            is_base64 = True\n                            \n        elif encoding and encoding.lower() == 'quoted-printable':\n            # Can't selectively decode quopri because encoded length is data\n            # dependent due to escapes!  Just decode one medium length segment.\n            # This is enough to contain the first few packets of a long file.\n            try:\n                segment = quopri.decodestring(data[0:1500])\n            except TypeError:                         \n                return found                # *** ? Docs don't list exceptions\n            is_quopri = True\n        else:\n            line_len = len(data)\n            segment = data                          # *** Shallow copy?\n                  \n        if not segment:\n            found = set()\n        elif not (ord(segment[0]) & 0x80):\n            # Not a PGP packet header if MSbit is 0.  Check for armoured data.\n            found.add('armored')\n            if segment.startswith(self.ARMOR_BEGIN_SIGNED):\n                # Clearsigned\n                found.add('unencrypted')                           \n                found.add('signature')                \n            elif segment.startswith(self.ARMOR_BEGIN_SIGNATURE):\n                # Detached signature\n                found.add('signature')                               \n            elif segment.startswith(self.ARMOR_BEGIN_ENCRYPTED):\n                # PGP uses the same armor header for encrypted and signed only\n                # Fortunately gpg --decrypt handles both!\n                found.add('encrypted')           \n            elif segment.startswith(self.ARMOR_BEGIN_PUB_KEY):\n                found.add('key')              \n            else:\n                found = set()\n        else:\n            # Could be PGP packet header. Check for sequence of legal headers.\n            while skip < len(segment) and body_len <> -1:\n                # Check this packet header.\n                prev_partial = partial\n                ptag, hdr_len, body_len, partial = ( \n                    self.pgp_packet_hdr_parse(segment[skip:], prev_partial) )\n                    \n                if prev_partial or partial:\n                    pass\n                elif ptag == 11:               \n                    found.add('unencrypted')    # Literal Data\n                elif ptag ==  1:\n                    found.add('encrypted')      # Encrypted Session Key\n                elif ptag ==  9:\n                    found.add('encrypted')      # Symmetrically Encrypted Data\n                elif ptag ==  18:\n                    found.add('encrypted')      # Symmetrically Encrypted & MDC\n                elif ptag ==  2:\n                    found.add('signature')      # Signature\n                elif ptag ==  4:\n                    found.add('signature')      # One-Pass Signature\n                elif ptag ==  6:\n                    found.add('key')            # Public Key\n                elif ptag ==  14:\n                    found.add('key')            # Public Subkey\n                elif ptag == 8:                 # Compressed Data Packet\n                    # This is a kludge.  Signed, non-encrypted files made by gpg\n                    # (but no other gpg files) consist of one compressed data\n                    # packet of unknown length which contains the signature\n                    # and data packets.\n                    # This appears to be an interpretation of RFC4880 2.3.\n                    # The compression prevents selective parsing of headers.\n                    # So such packets are assumed to be signed messages.\n                    if dec_start == 0 and body_len == -1: \n                        found.add('signature')\n                        found.add('unencrypted')                   \n                elif ptag < 0  or ptag > 19:\n                    found = set()\n                    return found\n                    \n                dec_start += hdr_len + body_len\n                skip = dec_start    \n                if is_base64 and body_len <> -1:    \n                    enc_start, enc_end, skip = self.base64_segment( dec_start, \n                                        dec_start + 6, 0, line_len, line_end )\n                    segment = base64.b64decode(data[enc_start:enc_end])\n \n            if is_base64 and body_len <> -1 and skip <> len(segment):\n                # End of last packet does not match end of data.\n                found = set()\n        return found\n    \n    \n    def remove_armor(self, text):\n        lines = text.strip().splitlines(True)\n        if lines[0].startswith(self.ARMOR_BEGIN_SIGNED):\n            for idx in reversed(range(0, len(lines))):\n                if lines[idx].startswith(self.ARMOR_BEGIN_SIGNATURE):\n                    lines = lines[:idx]\n                    while lines and lines[0].strip():\n                        lines.pop(0)\n                    break\n        return ''.join(lines).strip()\n\n    def verify(self, data, signature=None):\n        \"\"\"\n        >>> g = GnuPG(None)\n        >>> s = g.sign(\"Hello, World\", _from=\"smari@mailpile.is\",\n            clearsign=True)[1]\n        >>> g.verify(s)\n        \"\"\"\n        params = [\"--verify\"]\n        if signature:\n            sig = tempfile.NamedTemporaryFile()\n            sig.write(signature)\n            sig.flush()\n            params.append(sig.name)\n            params.append(\"-\")\n\n        self.event.running_gpg(_('Checking signature in %d bytes of data'\n                                 ) % len(data))\n        ret, retvals = self.run(params, gpg_input=data, partial_read_ok=True)\n\n        rp = GnuPGResultParser(debug=self.debug)\n        return rp.parse([None, retvals]).signature_info\n\n    def encrypt(self, data, tokeys=[], armor=True,\n                            sign=False, fromkey=None, throw_keyids=False):\n        \"\"\"\n        >>> g = GnuPG(None)\n        >>> g.encrypt(\"Hello, World\", to=[\"smari@mailpile.is\"])[0]\n        0\n        \"\"\"\n        if tokeys:\n            action = [\"--encrypt\", \"--yes\", \"--expert\",\n                      \"--trust-model\", \"always\"]\n            for r in tokeys:\n                action.append(\"--recipient\")\n                action.append(r)\n            action.extend([])\n            self.event.running_gpg(_('Encrypting %d bytes of data to %s'\n                                     ) % (len(data), ', '.join(tokeys)))\n        else:\n            action = [\"--symmetric\", \"--yes\", \"--expert\"]\n            self.event.running_gpg(_('Encrypting %d bytes of data with password'\n                                     ) % len(data))\n\n        if armor:\n            action.append(\"--armor\")\n        if sign:\n            action.append(\"--sign\")\n        if sign and fromkey:\n            action.append(\"--local-user\")\n            action.append(fromkey)\n        if throw_keyids:\n            action.append(\"--throw-keyids\")\n        if fromkey:\n            self.prepare_passphrase(fromkey, signing=True)\n\n        retvals = self.run(action, gpg_input=data,\n                           send_passphrase=(sign or not tokeys))\n\n        return retvals[0], \"\".join(retvals[1][\"stdout\"])\n\n    def sign(self, data,\n             fromkey=None, armor=True, detach=True, clearsign=False,\n             passphrase=None):\n        \"\"\"\n        >>> g = GnuPG(None)\n        >>> g.sign(\"Hello, World\", fromkey=\"smari@mailpile.is\")[0]\n        0\n        \"\"\"\n        if passphrase is not None:\n            self.passphrase = passphrase.get_reader()\n        if fromkey and passphrase is None:\n            self.prepare_passphrase(fromkey, signing=True)\n\n        if detach and not clearsign:\n            action = [\"--detach-sign\"]\n        elif clearsign:\n            action = [\"--clearsign\"]\n        else:\n            action = [\"--sign\"]\n        if armor:\n            action.append(\"--armor\")\n        if fromkey:\n            action.append(\"--local-user\")\n            action.append(fromkey)\n\n        self.event.running_gpg(_('Signing %d bytes of data with %s'\n                                 ) % (len(data), fromkey or _('default')))\n        retvals = self.run(action, gpg_input=data, send_passphrase=True)\n\n        self.passphrase = None\n        return retvals[0], \"\".join(retvals[1][\"stdout\"])\n\n    def sign_key(self, keyid, signingkey=None):\n        action = [\"--yes\", \"--sign-key\", keyid]\n        if signingkey:\n            action.insert(1, \"-u\")\n            action.insert(2, signingkey)\n\n        self.event.running_gpg(_('Signing key %s with %s'\n                                 ) % (keyid, signingkey or _('default')))\n        retvals = self.run(action, send_passphrase=True)\n\n        return retvals\n\n    def delete_key(self, key_fingerprint):\n        cmd = ['--yes', '--delete-secret-and-public-key', key_fingerprint]\n        return self.run(cmd)\n\n    def recv_key(self, keyid,\n                 keyservers=DEFAULT_KEYSERVERS,\n                 keyserver_options=DEFAULT_KEYSERVER_OPTIONS):\n        self.event.running_gpg(_('Downloading key %s from key servers'\n                                 ) % (keyid))\n        for keyserver in keyservers:\n            cmd = ['--keyserver', keyserver,\n                   '--recv-key', self._escape_hex_keyid_term(keyid)]\n            for opt in keyserver_options:\n                cmd[2:2] = ['--keyserver-options', opt]\n            retvals = self.run(cmd)\n            if 'unsupported' not in ''.join(retvals[1][\"stdout\"]):\n                break\n        return self._parse_import(retvals[1][\"status\"])\n\n    def search_key(self, term,\n                   keyservers=DEFAULT_KEYSERVERS,\n                   keyserver_options=DEFAULT_KEYSERVER_OPTIONS):\n        self.event.running_gpg(_('Searching for key for %s in key servers'\n                                 ) % (term))\n        for keyserver in keyservers:\n            cmd = ['--keyserver', keyserver,\n                   '--fingerprint',\n                   '--search-key', self._escape_hex_keyid_term(term)]\n            for opt in keyserver_options:\n                cmd[2:2] = ['--keyserver-options', opt]\n            retvals = self.run(cmd)\n            if 'unsupported' not in ''.join(retvals[1][\"stdout\"]):\n                break\n        results = {}\n        lines = [x.strip().split(\":\") for x in retvals[1][\"stdout\"]]\n        curpub = None\n        for line in lines:\n            if line[0] == \"info\":\n                pass\n            elif line[0] == \"pub\":\n                curpub = line[1]\n                validity = line[6]\n                if line[5]:\n                    if int(line[5]) < time.time():\n                        validity += 'e'\n                results[curpub] = {\n                    \"created\": datetime.fromtimestamp(int(line[4])),\n                    \"keytype_name\": _(openpgp_algorithms.get(int(line[2]),\n                                                             'Unknown')),\n                    \"keysize\": line[3],\n                    \"validity\": validity,\n                    \"uids\": [],\n                    \"fingerprint\": curpub\n                }\n            elif line[0] == \"uid\":\n                email, name, comment = parse_uid(line[1])\n                results[curpub][\"uids\"].append({\"name\": name,\n                                                \"email\": email,\n                                                \"comment\": comment})\n        return results\n\n    def get_pubkey(self, keyid):\n        return self.export_pubkeys(selectors=[keyid])\n\n    def export_pubkeys(self, selectors=None):\n        self.event.running_gpg(_('Exporting keys %s from keychain'\n                                 ) % (selectors,))\n        retvals = self.run(['--armor',\n                            '--export'] + (selectors or [])\n                            )[1][\"stdout\"]\n        return \"\".join(retvals)\n\n    def export_privkeys(self, selectors=None):\n        retvals = self.run(['--armor',\n                            '--export-secret-keys'] + (selectors or [])\n                            )[1][\"stdout\"]\n        return \"\".join(retvals)\n\n    def address_to_keys(self, address):\n        res = {}\n        keys = self.list_keys(selectors=[address])\n        for key, props in keys.iteritems():\n            if any([x[\"email\"] == address for x in props[\"uids\"]]):\n                res[key] = props\n\n        return res\n\n    def _escape_hex_keyid_term(self, term):\n        \"\"\"Prepends a 0x to hexadecimal key ids.\n\n        For example, D13C70DA is converted to 0xD13C70DA. This is required\n        by version 2.x of GnuPG (and is accepted by 1.x).\n        \"\"\"\n        is_hex_keyid = False\n        if len(term) == GPG_KEYID_LENGTH or len(term) == 2*GPG_KEYID_LENGTH:\n            hex_digits = set(string.hexdigits)\n            is_hex_keyid = all(c in hex_digits for c in term)\n\n        if is_hex_keyid:\n            return '0x%s' % term\n        else:\n            return term\n\n    def chat(self, gpg_args, callback, *args, **kwargs):\n        \"\"\"This lets a callback have a chat with the GPG process...\"\"\"\n        gpg_args = [self.gpgbinary,\n                    \"--utf8-strings\",\n                    # Disable SHA1 in all things GnuPG\n                    \"--personal-digest-preferences=SHA512\",\n                    \"--digest-algo=SHA512\",\n                    \"--cert-digest-algo=SHA512\",\n                    # We're not a human!\n                    \"--no-tty\",\n                    \"--command-fd=0\",\n                    \"--status-fd=1\"] + (gpg_args or [])\n        if self.homedir:\n            gpg_args.insert(1, \"--homedir=%s\" % self.homedir)\n\n        if self.version_tuple() > (2, 1):\n            gpg_args.insert(2, \"--pinentry-mode=loopback\")\n        else:\n            gpg_args.insert(2, \"--no-use-agent\")\n\n        proc = None\n        try:\n            # Here we go!\n            self.debug('Running %s' % ' '.join(gpg_args))\n            self.event.update_args(gpg_args)\n            proc = Popen(gpg_args, stdin=PIPE, stdout=PIPE, stderr=PIPE,\n                         bufsize=0, long_running=True)\n\n            return callback(proc, *args, **kwargs)\n        finally:\n            # Close this so GPG will terminate. This should already have\n            # been done, but we're handling errors here...\n            if proc and proc.stdin:\n                proc.stdin.close()\n            if proc:\n                self.event.update_return_code(proc.wait())\n            else:\n                self.event.update_return_code(-1)\n\n\ndef GetKeys(gnupg, config, people):\n    keys = []\n    missing = []\n    ambig = []\n\n    # First, we go to the contact database and get a list of keys.\n    for person in set(people):\n        if '#' in person:\n            keys.append(person.rsplit('#', 1)[1])\n        else:\n            vcard = config.vcards.get_vcard(person)\n            if vcard:\n                # It is the VCard's job to give us the best key first.\n                lines = [vcl for vcl in vcard.get_all('KEY')\n                         if vcl.value.startswith('data:application'\n                                                 '/x-pgp-fingerprint,')]\n                if len(lines) > 0:\n                    keys.append(lines[0].value.split(',', 1)[1])\n                else:\n                    missing.append(person)\n            else:\n                missing.append(person)\n\n    # Load key data from gnupg for use below\n    if keys:\n        all_keys = gnupg.list_keys(selectors=keys)\n    else:\n        all_keys = {}\n\n    if missing:\n        # Keys are missing, so we try to just search the keychain\n        all_keys.update(gnupg.list_keys(selectors=missing))\n        found = []\n        for key_id, key in all_keys.iteritems():\n            for uid in key.get(\"uids\", []):\n                if uid.get(\"email\", None) in missing:\n                    missing.remove(uid[\"email\"])\n                    found.append(uid[\"email\"])\n                    keys.append(key_id)\n                elif uid.get(\"email\", None) in found:\n                    ambig.append(uid[\"email\"])\n\n    # Next, we go make sure all those keys are really in our keychain.\n    fprints = all_keys.keys()\n    for key in keys:\n        key = key.upper()\n        if key.startswith('0x'):\n            key = key[2:]\n        if key not in fprints:\n            match = [k for k in fprints if k.endswith(key)]\n            if len(match) == 0:\n                missing.append(key)\n            elif len(match) > 1:\n                ambig.append(key)\n\n    if missing:\n        raise KeyLookupError(_('Keys missing for %s'\n                               ) % ', '.join(missing), missing)\n    elif ambig:\n        ambig = list(set(ambig))\n        raise KeyLookupError(_('Keys ambiguous for %s'\n                               ) % ', '.join(ambig), ambig)\n    return keys\n\n\nclass OpenPGPMimeSigningWrapper(MimeSigningWrapper):\n    CONTAINER_PARAMS = (('micalg', 'pgp-sha512'),\n                        ('protocol', 'application/pgp-signature'))\n    SIGNATURE_TYPE = 'application/pgp-signature'\n    SIGNATURE_DESC = 'OpenPGP Digital Signature'\n\n    def crypto(self):\n        return GnuPG(self.config, event=self.event)\n\n    def get_keys(self, who):\n        return GetKeys(self.crypto(), self.config, who)\n\n\nclass OpenPGPMimeEncryptingWrapper(MimeEncryptingWrapper):\n    CONTAINER_PARAMS = (('protocol', 'application/pgp-encrypted'), )\n    ENCRYPTION_TYPE = 'application/pgp-encrypted'\n    ENCRYPTION_VERSION = 1\n\n    # FIXME: Define _encrypt, allow throw_keyids\n\n    def crypto(self):\n        return GnuPG(self.config, event=self.event)\n\n    def get_keys(self, who):\n        return GetKeys(self.crypto(), self.config, who)\n\n\nclass OpenPGPMimeSignEncryptWrapper(OpenPGPMimeEncryptingWrapper):\n    CONTAINER_PARAMS = (('protocol', 'application/pgp-encrypted'), )\n    ENCRYPTION_TYPE = 'application/pgp-encrypted'\n    ENCRYPTION_VERSION = 1\n\n    def crypto(self):\n        return GnuPG(self.config)\n\n    def _encrypt(self, message_text, tokeys=None, armor=False):\n        from_key = self.get_keys([self.sender])[0]\n        # FIXME: Allow throw_keyids here.\n        return self.crypto().encrypt(message_text,\n                                     tokeys=tokeys, armor=True,\n                                     sign=True, fromkey=from_key)\n\n    def _update_crypto_status(self, part):\n        part.signature_info.part_status = 'verified'\n        part.encryption_info.part_status = 'decrypted'\n\n\nclass GnuPGExpectScript(threading.Thread):\n    STARTUP = 'Startup'\n    START_GPG = 'Start GPG'\n    FINISHED = 'Finished'\n    SCRIPT = []\n    VARIABLES = {}\n    DESCRIPTION = 'GnuPG Expect Script'\n    RUNNING_STATES = [STARTUP, START_GPG]\n\n    DEFAULT_TIMEOUT = 60 # Infinite wait isn't desirable\n\n    def __init__(self, gnupg,\n                 sps=None, event=None, variables={}, on_complete=None):\n        threading.Thread.__init__(self)\n        self.daemon = True\n        self._lock = threading.RLock()\n        self.before = ''\n        with self._lock:\n            self.state = self.STARTUP\n            self.gnupg = gnupg\n            self.event = event\n            self.variables = variables or self.VARIABLES\n            self._on_complete = [on_complete] if on_complete else []\n            self.main_script = self.SCRIPT[:]\n            self.sps = sps\n            if sps:\n                self.variables['passphrase'] = '!!<SPS'\n\n    def __str__(self):\n        return '%s: %s' % (threading.Thread.__str__(self), self.state)\n\n    running = property(lambda self: (self.state in self.RUNNING_STATES))\n    failed = property(lambda self: False)\n\n    def in_state(self, state):\n        pass\n\n    def set_state(self, state):\n        self.state = state\n        self.in_state(state)\n\n    def sendline(self, proc, line):\n        if line == '!!<SPS':\n            reader = self.sps.get_reader()\n            while True:\n                c = reader.read()\n                if c != '':\n                    proc.stdin.write(c)\n                else:\n                    proc.stdin.write('\\n')\n                    break\n        else:\n            proc.stdin.write(line.encode('utf-8'))\n            proc.stdin.write('\\n')\n\n    def _expecter(self, proc, exp, timebox):\n        while timebox[0] > 0:\n            self.before += proc.stdout.read(1)\n            if exp in self.before:\n                self.before = self.before.split(exp)[0]\n                return True\n        return False\n\n    def expect_exact(self, proc, exp, timeout=None):\n        from mailpile.util import RunTimed, TimedOut\n        timeout = timeout if (timeout and timeout > 0) else self.DEFAULT_TIMEOUT\n        timebox = [timeout]\n        self.before = ''\n        try:\n            self.gnupg.debug('Expect: %s' % exp)\n            if RunTimed(timeout, self._expecter, proc, exp, timebox):\n                return True\n            else:\n                raise TimedOut()\n        except TimedOut:\n            timebox[0] = 0\n            self.gnupg.debug('Timed out')\n            print 'Boo! %s not found in %s' % (exp, self.before)\n            raise\n\n    def run_script(self, proc, script):\n        for exp, rpl, tmo, state in script:\n            self.expect_exact(proc, exp, timeout=tmo)\n            if rpl:\n                self.sendline(proc, (rpl % self.variables).strip())\n            if state:\n                self.set_state(state)\n\n    def gpg_args(self):\n        return ['--no-use-agent', '--list-keys']\n\n    def run(self):\n        try:\n            self.set_state(self.START_GPG)\n            gpg = self.gnupg\n            gpg.event.running_gpg(_(self.DESCRIPTION) % self.variables)\n            gpg.chat(self.gpg_args(), self.run_script, self.main_script)\n            self.set_state(self.FINISHED)\n        except:\n            import traceback\n            traceback.print_exc()\n        finally:\n            with self._lock:\n                if self.state != self.FINISHED:\n                    self.state = 'Failed: ' + self.state\n                for name, callback in self._on_complete:\n                    callback()\n                self._on_complete = None\n\n    def on_complete(self, name, callback):\n        with self._lock:\n            if self._on_complete is not None:\n                if name not in [o[0] for o in self._on_complete]:\n                    self._on_complete.append((name, callback))\n            else:\n                callback()\n\n\nclass GnuPGBaseKeyGenerator(GnuPGExpectScript):\n    \"\"\"This is a background thread which generates a new PGP key.\"\"\"\n    AWAITING_LOCK = 'Pending keygen'\n    KEY_SETUP = 'Key Setup'\n    GATHER_ENTROPY = 'Creating key'\n    CREATED_KEY = 'Created key'\n    HAVE_KEY = 'Have Key'\n    VARIABLES = {\n        'keytype': '1',\n        'bits': '2048',\n        'name': 'Mailpile Generated Key',\n        'email': '',\n        'comment': 'www.mailpile.is',\n        'passphrase': 'mailpile'}\n    DESCRIPTION = _('Creating a %(bits)s bit GnuPG key')\n    RUNNING_STATES = (GnuPGExpectScript.RUNNING_STATES +\n                      [AWAITING_LOCK, KEY_SETUP, GATHER_ENTROPY, HAVE_KEY])\n\n    failed = property(lambda self: (not self.running and\n                                    not self.generated_key))\n\n    def __init__(self, *args, **kwargs):\n        super(GnuPGBaseKeyGenerator, self).__init__(*args, **kwargs)\n        self.generated_key = None\n\n    def in_state(self, state):\n        if state == self.HAVE_KEY:\n             self.generated_key = self.before.strip().split()[-1]\n\n    def run(self):\n        # In order to minimize risk of timeout during key generation (due to\n        # lack of entropy), we serialize them here using a global lock\n        self.set_state(self.AWAITING_LOCK)\n        self.event.message = _('Waiting to generate a %d bit GnuPG key.'\n                               % self.variables['bits'])\n        with ENTROPY_LOCK:\n            self.event.data['keygen_gotlock'] = 1\n            self.event.message = _('Generating new %d bit PGP key.'\n                                   % self.variables['bits'])\n            super(GnuPGBaseKeyGenerator, self).run()\n\n\nclass GnuPG14KeyGenerator(GnuPGBaseKeyGenerator):\n    \"\"\"This is the GnuPG 1.4x specific PGP key generation script.\"\"\"\n    B = GnuPGBaseKeyGenerator\n\n    # FIXME: If GnuPG starts asking for things in a different order,\n    #        we'll needlessly fail. To address this, we need to make\n    #        the expect logic smarter. For now, we just assume the GnuPG\n    #        team  will be hesitant to change things.\n\n    SCRIPT = [\n        ('GET_LINE keygen.algo',        '%(keytype)s',   -1, B.KEY_SETUP),\n        ('GET_LINE keygen.size',           '%(bits)s',   -1, None),\n        ('GET_LINE keygen.valid',                 '0',   -1, None),\n        ('GET_LINE keygen.name',           '%(name)s',   -1, None),\n        ('GET_LINE keygen.email',         '%(email)s',   -1, None),\n        ('GET_LINE keygen.comment',     '%(comment)s',   -1, None),\n        ('GET_HIDDEN passphrase',    '%(passphrase)s',   -1, None),\n        ('GOT_IT',                               None,   -1, B.GATHER_ENTROPY),\n        ('KEY_CREATED',                          None, 7200, B.CREATED_KEY),\n        ('\\n',                                   None,   -1, B.HAVE_KEY)]\n\n    def gpg_args(self):\n        return ['--no-use-agent', '--allow-freeform-uid', '--gen-key']\n\n\nclass GnuPG21KeyGenerator(GnuPG14KeyGenerator):\n    \"\"\"This is the GnuPG 2.1.x specific PGP key generation script.\"\"\"\n\n    # Note: We don't use the nice --quick-generate-key function, because\n    #       it won't let us generate a usable key with custom parameters in\n    #       a single pass. So using the existing expect logic turns out to\n    #       be less work in practice. Oh well.\n\n    def gpg_args(self):\n        # --yes should keep GnuPG from complaining if there already exists\n        #       a key with this UID.\n        return ['--yes', '--allow-freeform-uid', '--full-gen-key']\n\n\nclass GnuPGDummyKeyGenerator(GnuPGBaseKeyGenerator):\n    \"\"\"A dummy key generator class, for incompatible versions of GnuPG.\"\"\"\n\n    DESCRIPTION = _('Unable to create a %(bits)s bit key, wrong GnuPG version')\n\n    def __init__(self, *args, **kwargs):\n        GnuPGBaseKeyGenerator.__init__(self, *args, **kwargs)\n        self.generated_key = False\n\n    def run(self):\n        with self._lock:\n            self.gnupg.event.running_gpg(_(self.DESCRIPTION) % self.variables)\n            self.set_state(self.FINISHED)\n            for name, callback in self._on_complete:\n                callback()\n            self._on_complete = None\n\n\ndef GnuPGKeyGenerator(gnupg, **kwargs):\n    \"\"\"Return an instanciated generator, depending on GnuPG version.\"\"\"\n    version = gnupg.version_tuple()\n    if version < (1, 5):\n        return GnuPG14KeyGenerator(gnupg, **kwargs)\n    elif version >= (2, 1):\n        return GnuPG21KeyGenerator(gnupg, **kwargs)\n    else:\n        return GnuPGDummyKeyGenerator(gnupg, **kwargs)\n\n\n# Reset our translation variable\n_ = gettext\n\n## Include the SKS keyserver certificate here ##\nKEYSERVER_CERTIFICATE=\"\"\"\n-----BEGIN CERTIFICATE-----\nMIIFizCCA3OgAwIBAgIJAK9zyLTPn4CPMA0GCSqGSIb3DQEBBQUAMFwxCzAJBgNV\nBAYTAk5PMQ0wCwYDVQQIDARPc2xvMR4wHAYDVQQKDBVza3Mta2V5c2VydmVycy5u\nZXQgQ0ExHjAcBgNVBAMMFXNrcy1rZXlzZXJ2ZXJzLm5ldCBDQTAeFw0xMjEwMDkw\nMDMzMzdaFw0yMjEwMDcwMDMzMzdaMFwxCzAJBgNVBAYTAk5PMQ0wCwYDVQQIDARP\nc2xvMR4wHAYDVQQKDBVza3Mta2V5c2VydmVycy5uZXQgQ0ExHjAcBgNVBAMMFXNr\ncy1rZXlzZXJ2ZXJzLm5ldCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC\nggIBANdsWy4PXWNUCkS3L//nrd0GqN3dVwoBGZ6w94Tw2jPDPifegwxQozFXkG6I\n6A4TK1CJLXPvfz0UP0aBYyPmTNadDinaB9T4jIwd4rnxl+59GiEmqkN3IfPsv5Jj\nMkKUmJnvOT0DEVlEaO1UZIwx5WpfprB3mR81/qm4XkAgmYrmgnLXd/pJDAMk7y1F\n45b5zWofiD5l677lplcIPRbFhpJ6kDTODXh/XEdtF71EAeaOdEGOvyGDmCO0GWqS\nFDkMMPTlieLA/0rgFTcz4xwUYj/cD5e0ZBuSkYsYFAU3hd1cGfBue0cPZaQH2HYx\nQk4zXD8S3F4690fRhr+tki5gyG6JDR67aKp3BIGLqm7f45WkX1hYp+YXywmEziM4\naSbGYhx8hoFGfq9UcfPEvp2aoc8u5sdqjDslhyUzM1v3m3ZGbhwEOnVjljY6JJLx\nMxagxnZZSAY424ZZ3t71E/Mn27dm2w+xFRuoy8JEjv1d+BT3eChM5KaNwrj0IO/y\nu8kFIgWYA1vZ/15qMT+tyJTfyrNVV/7Df7TNeWyNqjJ5rBmt0M6NpHG7CrUSkBy9\np8JhimgjP5r0FlEkgg+lyD+V79H98gQfVgP3pbJICz0SpBQf2F/2tyS4rLm+49rP\nfcOajiXEuyhpcmzgusAj/1FjrtlynH1r9mnNaX4e+rLWzvU5AgMBAAGjUDBOMB0G\nA1UdDgQWBBTkwyoJFGfYTVISTpM8E+igjdq28zAfBgNVHSMEGDAWgBTkwyoJFGfY\nTVISTpM8E+igjdq28zAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4ICAQAR\nOXnYwu3g1ZjHyley3fZI5aLPsaE17cOImVTehC8DcIphm2HOMR/hYTTL+V0G4P+u\ngH+6xeRLKSHMHZTtSBIa6GDL03434y9CBuwGvAFCMU2GV8w92/Z7apkAhdLToZA/\nX/iWP2jeaVJhxgEcH8uPrnSlqoPBcKC9PrgUzQYfSZJkLmB+3jEa3HKruy1abJP5\ngAdQvwvcPpvYRnIzUc9fZODsVmlHVFBCl2dlu/iHh2h4GmL4Da2rRkUMlbVTdioB\nUYIvMycdOkpH5wJftzw7cpjsudGas0PARDXCFfGyKhwBRFY7Xp7lbjtU5Rz0Gc04\nlPrhDf0pFE98Aw4jJRpFeWMjpXUEaG1cq7D641RpgcMfPFvOHY47rvDTS7XJOaUT\nBwRjmDt896s6vMDcaG/uXJbQjuzmmx3W2Idyh3s5SI0GTHb0IwMKYb4eBUIpQOnB\ncE77VnCYqKvN1NVYAqhWjXbY7XasZvszCRcOG+W3FqNaHOK/n/0ueb0uijdLan+U\nf4p1bjbAox8eAOQS/8a3bzkJzdyBNUKGx1BIK2IBL9bn/HravSDOiNRSnZ/R3l9G\nZauX0tu7IIDlRCILXSyeazu0aj/vdT3YFQXPcvt5Fkf5wiNTo53f72/jYEJd6qph\nWrpoKqrwGwTpRUCMhYIUt65hsTxCiJJ5nKe39h46sg==\n-----END CERTIFICATE-----\n\"\"\"\n", "import datetime\nimport re\nimport time\nimport urllib2\nfrom email import encoders\nfrom email.mime.base import MIMEBase\n\nimport mailpile.security as security\nfrom mailpile.conn_brokers import Master as ConnBroker\nfrom mailpile.i18n import gettext as _\nfrom mailpile.i18n import ngettext as _n\nfrom mailpile.commands import Command\nfrom mailpile.crypto.gpgi import GnuPG\nfrom mailpile.crypto.gpgi import OpenPGPMimeSigningWrapper\nfrom mailpile.crypto.gpgi import OpenPGPMimeEncryptingWrapper\nfrom mailpile.crypto.gpgi import OpenPGPMimeSignEncryptWrapper\nfrom mailpile.crypto.mime import UnwrapMimeCrypto, MessageAsString\nfrom mailpile.crypto.mime import OBSCURE_HEADERS_MILD, OBSCURE_HEADERS_EXTREME\nfrom mailpile.crypto.mime import ObscureSubject\nfrom mailpile.crypto.state import EncryptionInfo, SignatureInfo\nfrom mailpile.eventlog import GetThreadEvent\nfrom mailpile.mailutils.addresses import AddressHeaderParser\nfrom mailpile.mailutils.emails import Email, MakeContentID, ClearParseCache\nfrom mailpile.plugins import PluginManager, EmailTransform\nfrom mailpile.plugins.vcard_gnupg import PGPKeysImportAsVCards\nfrom mailpile.plugins.search import Search\n\n_plugins = PluginManager(builtin=__file__)\n\n\n##[ GnuPG e-mail processing ]#################################################\n\nclass ContentTxf(EmailTransform):\n    def _wrap_key_in_html(self, title, keydata):\n        return ((\n            \"<html><head><meta charset='utf-8'></head><body>\\n\"\n            \"<h1>%(title)s</h1><p>\\n\\n%(description)s\\n\\n</p>\"\n            \"<pre>\\n%(key)s\\n</pre><hr>\"\n            \"<i><a href='%(ad_url)s'>%(ad)s</a>.</i></body></html>\"\n            ) % self._wrap_key_in_html_vars(title, keydata)).encode('utf-8')\n\n    def _wrap_key_in_html_vars(self, title, keydata):\n        return {\n            \"title\": title,\n            \"description\": _(\n                \"This is a digital encryption key, which you can use to send\\n\"\n                \"confidential messages to the owner, or to verify their\\n\"\n                \"digital signatures. You can safely discard or ignore this\\n\"\n                \"file if you do not use e-mail encryption or signatures.\"),\n            \"ad\": _(\"Generated by Mailpile and GnuPG\"),\n            \"ad_url\": \"https://www.mailpile.is/\",  # FIXME: Link to help?\n            \"key\": keydata}\n\n    def TransformOutgoing(self, sender, rcpts, msg, **kwargs):\n        matched = False\n        gnupg = None\n        sender_keyid = None\n\n        # Prefer to just get everything from the profile VCard, in the\n        # common case...\n        profile = self._get_sender_profile(sender, kwargs)\n        if profile['vcard'] is not None:\n            sender_keyid = profile['vcard'].pgp_key\n        crypto_format = profile.get('crypto_format') or 'none'\n\n        # Parse the openpgp_header data from the crypto_format\n        openpgp_header = [p.split(':')[-1]\n                          for p in crypto_format.split('+')\n                          if p.startswith('openpgp_header:')]\n        if not openpgp_header:\n            openpgp_header = self.config.prefs.openpgp_header and ['CFG']\n\n        if openpgp_header[0] != 'N' and not sender_keyid:\n            # This is a fallback: this shouldn't happen much in normal use\n            try:\n                gnupg = gnupg or GnuPG(self.config, event=GetThreadEvent())\n                seckeys = dict([(uid[\"email\"], fp) for fp, key\n                                in gnupg.list_secret_keys().iteritems()\n                                if key[\"capabilities_map\"].get(\"encrypt\")\n                                and key[\"capabilities_map\"].get(\"sign\")\n                                for uid in key[\"uids\"]])\n                sender_keyid = seckeys.get(sender)\n            except (KeyError, TypeError, IndexError, ValueError):\n                traceback.print_exc()\n\n        if sender_keyid and openpgp_header:\n            preference = {\n                'ES': 'signencrypt',\n                'SE': 'signencrypt',\n                'E': 'encrypt',\n                'S': 'sign',\n                'N': 'unprotected',\n                'CFG': self.config.prefs.openpgp_header\n            }[openpgp_header[0].upper()]\n            msg[\"OpenPGP\"] = (\"id=%s; preference=%s\"\n                              % (sender_keyid, preference))\n\n        if ('attach-pgp-pubkey' in msg and\n                msg['attach-pgp-pubkey'][:3].lower() in ('yes', 'tru')):\n            gnupg = gnupg or GnuPG(self.config, event=GetThreadEvent())\n            if sender_keyid:\n                keys = gnupg.list_keys(selectors=[sender_keyid])\n            else:\n                keys = gnupg.address_to_keys(AddressHeaderParser(sender).addresses_list()[0])\n\n            key_count = 0\n            for fp, key in keys.iteritems():\n                if not any(key[\"capabilities_map\"].values()):\n                    continue\n                # We should never really hit this more than once. But if we\n                # do, should still be fine.\n                keyid = key[\"keyid\"]\n                data = gnupg.get_pubkey(keyid)\n\n                try:\n                    from_name = key[\"uids\"][0][\"name\"]\n                    filename = _('Encryption key for %s') % from_name\n                except:\n                    filename = _('My encryption key')\n\n                if self.config.prefs.gpg_html_wrap:\n                    data = self._wrap_key_in_html(filename, data)\n                    ext = 'html'\n                else:\n                    ext = 'asc'\n\n                att = MIMEBase('application', 'pgp-keys')\n                att.set_payload(data)\n                encoders.encode_base64(att)\n                del att['MIME-Version']\n                att.add_header('Content-Id', MakeContentID())\n                att.add_header('Content-Disposition', 'attachment',\n                               filename=filename + '.' + ext)\n                att.signature_info = SignatureInfo(parent=msg.signature_info)\n                att.encryption_info = EncryptionInfo(parent=msg.encryption_info)\n                msg.attach(att)\n                key_count += 1\n\n            if key_count > 0:\n                msg['x-mp-internal-pubkeys-attached'] = \"Yes\"\n\n        return sender, rcpts, msg, matched, True\n\nclass CryptoTxf(EmailTransform):\n    def TransformOutgoing(self, sender, rcpts, msg,\n                          crypto_policy='none',\n                          crypto_format='default',\n                          cleaner=lambda m: m,\n                          **kwargs):\n        matched = False\n        if 'pgp' in crypto_policy or 'gpg' in crypto_policy:\n            wrapper = None\n\n            # Set defaults\n            prefer_inline = kwargs.get('prefer_inline', False)\n            if 'obscure_all_meta' in crypto_format:\n                obscured = OBSCURE_HEADERS_EXTREME\n            elif 'obscure_meta' in crypto_format:\n                obscured = OBSCURE_HEADERS_MILD\n            elif self.config.prefs.encrypt_subject:\n                obscured = {'subject': ObscureSubject}\n            else:\n                obscured = {}\n\n            if 'sign' in crypto_policy and 'encrypt' in crypto_policy:\n                wrapper = OpenPGPMimeSignEncryptWrapper\n                prefer_inline = 'prefer_inline' in crypto_format\n            elif 'encrypt' in crypto_policy:\n                wrapper = OpenPGPMimeEncryptingWrapper\n                prefer_inline = 'prefer_inline' in crypto_format\n            elif 'sign' in crypto_policy:\n                # When signing only, we 1) prefer inline by default, based\n                # on this: https://github.com/mailpile/Mailpile/issues/1693\n                # and 2) don't obscure any headers as that's pointless.\n                wrapper = OpenPGPMimeSigningWrapper\n                prefer_inline = 'pgpmime' not in crypto_format\n                obscured = {}\n\n            if wrapper:\n                msg = wrapper(self.config,\n                              sender=sender,\n                              cleaner=cleaner,\n                              recipients=rcpts,\n                              use_html_wrapper=self.config.prefs.gpg_html_wrap,\n                              obscured_headers=obscured\n                              ).wrap(msg, prefer_inline=prefer_inline)\n                matched = True\n\n        return sender, rcpts, msg, matched, (not matched)\n\n\n_plugins.register_outgoing_email_content_transform('500_gnupg', ContentTxf)\n_plugins.register_outgoing_email_crypto_transform('500_gnupg', CryptoTxf)\n\n##[ Misc. GPG-related API commands ]##########################################\n\nclass GPGKeySearch(Command):\n    \"\"\"Search for a GPG Key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/searchkey', 'crypto/gpg/searchkey', '<terms>')\n    HTTP_CALLABLE = ('GET', )\n    HTTP_QUERY_VARS = {'q': 'search terms'}\n\n    class CommandResult(Command.CommandResult):\n        def as_text(self):\n            if self.result:\n                return '\\n'.join([\"%s: %s <%s>\" % (keyid, x[\"name\"], x[\"email\"]) for keyid, det in self.result.iteritems() for x in det[\"uids\"]])\n            else:\n                return _(\"No results\")\n\n    def command(self):\n        args = list(self.args)\n        for q in self.data.get('q', []):\n            args.extend(q.split())\n\n        return self._gnupg().search_key(\" \".join(args))\n\n\nclass GPGKeyReceive(Command):\n    \"\"\"Fetch a GPG Key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/receivekey', 'crypto/gpg/receivekey', '<keyid>')\n    HTTP_CALLABLE = ('POST', )\n    HTTP_QUERY_VARS = {'keyid': 'ID of key to fetch'}\n    COMMAND_SECURITY = security.CC_CHANGE_GNUPG\n\n    def command(self):\n        keyid = self.data.get(\"keyid\", self.args)\n        res = []\n        for key in keyid:\n            res.append(self._gnupg().recv_key(key))\n\n        # Previous crypto evaluations may now be out of date, so we\n        # clear the cache so users can see results right away.\n        ClearParseCache(pgpmime=True)\n\n        return res\n\n\nclass GPGKeyImport(Command):\n    \"\"\"Import a GPG Key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/importkey', 'crypto/gpg/importkey',\n                '<key_file>')\n    HTTP_CALLABLE = ('POST', )\n    HTTP_QUERY_VARS = {\n        'key_data': 'ASCII armor of public key to be imported',\n        'key_file': 'Location of file containing the public key',\n        'key_url': 'URL of file containing the public key',\n        'name': '(ignored)'\n    }\n    COMMAND_SECURITY = security.CC_CHANGE_GNUPG\n\n    def command(self):\n        key_files = self.data.get(\"key_file\", []) + [a for a in self.args\n                                                     if not '://' in a]\n        key_urls = self.data.get(\"key_url\", []) + [a for a in self.args\n                                                   if '://' in a]\n        key_data = []\n        key_data.extend(self.data.get(\"key_data\", []))\n        for key_file in key_files:\n            with open(key_file) as file:\n                key_data.append(file.read())\n        for key_url in key_urls:\n            with ConnBroker.context(need=[ConnBroker.OUTGOING_HTTP]):\n                uo = urllib2.urlopen(key_url)\n            key_data.append(uo.read())\n\n        rv = self._gnupg().import_keys('\\n'.join(key_data))\n\n        # Previous crypto evaluations may now be out of date, so we\n        # clear the cache so users can see results right away.\n        ClearParseCache(pgpmime=True)\n\n        # Update the VCards!\n        PGPKeysImportAsVCards(self.session,\n                              arg=([i['fingerprint'] for i in rv['updated']] +\n                                   [i['fingerprint'] for i in rv['imported']])\n                              ).run()\n\n        return self._success(_(\"Imported %d keys\") % len(key_data), rv)\n\n\nclass GPGKeySign(Command):\n    \"\"\"Sign a key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/signkey', 'crypto/gpg/signkey', '<keyid> [<signingkey>]')\n    HTTP_CALLABLE = ('POST',)\n    HTTP_QUERY_VARS = {'keyid': 'The key to sign',\n                       'signingkey': 'The key to sign with'}\n    COMMAND_SECURITY = security.CC_CHANGE_GNUPG\n\n    def command(self):\n        signingkey = None\n        keyid = None\n        args = list(self.args)\n        try: keyid = args.pop(0)\n        except: keyid = self.data.get(\"keyid\", None)\n        try: signingkey = args.pop(0)\n        except: signingkey = self.data.get(\"signingkey\", None)\n\n        print keyid\n        if not keyid:\n            return self._error(\"You must supply a keyid\", None)\n        rv = self._gnupg().sign_key(keyid, signingkey)\n\n        # Previous crypto evaluations may now be out of date, so we\n        # clear the cache so users can see results right away.\n        ClearParseCache(pgpmime=True)\n\n        return rv\n\n\nclass GPGKeyImportFromMail(Search):\n    \"\"\"Import a GPG Key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/importkeyfrommail',\n                'crypto/gpg/importkeyfrommail', '<mid>')\n    HTTP_CALLABLE = ('POST', )\n    HTTP_QUERY_VARS = {'mid': 'Message ID', 'att': 'Attachment ID'}\n    COMMAND_CACHE_TTL = 0\n    COMMAND_SECURITY = security.CC_CHANGE_GNUPG\n\n    class CommandResult(Command.CommandResult):\n        def __init__(self, *args, **kwargs):\n            Command.CommandResult.__init__(self, *args, **kwargs)\n\n        def as_text(self):\n            if self.result:\n                return \"Imported %d keys (%d updated, %d unchanged) from the mail\" % (\n                    self.result[\"results\"][\"count\"],\n                    self.result[\"results\"][\"imported\"],\n                    self.result[\"results\"][\"unchanged\"])\n            return \"\"\n\n    def command(self):\n        session, config, idx = self.session, self.session.config, self._idx()\n        args = list(self.args)\n        if args and args[-1][0] == \"#\":\n            attid = args.pop()\n        else:\n            attid = self.data.get(\"att\", 'application/pgp-keys')\n        args.extend([\"=%s\" % x for x in self.data.get(\"mid\", [])])\n        eids = self._choose_messages(args)\n        if len(eids) < 0:\n            return self._error(\"No messages selected\", None)\n        elif len(eids) > 1:\n            return self._error(\"One message at a time, please\", None)\n\n        email = Email(idx, list(eids)[0])\n        fn, attr = email.extract_attachment(session, attid, mode='inline')\n        if attr and attr[\"data\"]:\n            res = self._gnupg().import_keys(attr[\"data\"])\n\n            # Previous crypto evaluations may now be out of date, so we\n            # clear the cache so users can see results right away.\n            ClearParseCache(pgpmime=True)\n\n            return self._success(\"Imported key\", res)\n\n        return self._error(\"No results found\", None)\n\n\nclass GPGKeyList(Command):\n    \"\"\"List GPG Keys.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/keylist',\n                'crypto/gpg/keylist', '<address>')\n    HTTP_CALLABLE = ('GET', )\n    HTTP_QUERY_VARS = {'address': 'E-mail address'}\n\n    def command(self):\n        args = list(self.args)\n        if len(args) > 0:\n            addr = args[0]\n        else:\n            addr = self.data.get(\"address\", None)\n\n        if addr is None:\n            return self._error(\"Must supply e-mail address\", None)\n\n        res = self._gnupg().address_to_keys(addr)\n        return self._success(\"Searched for keys for e-mail address\", res)\n\n\nclass GPGKeyListSecret(Command):\n    \"\"\"List Secret GPG Keys\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/keylist/secret',\n                'crypto/gpg/keylist/secret', '<address>')\n    HTTP_CALLABLE = ('GET', )\n\n    def command(self):\n        res = self._gnupg().list_secret_keys()\n        return self._success(\"Searched for secret keys\", res)\n\n\nclass GPGUsageStatistics(Search):\n    \"\"\"Get usage statistics from mail, given an address\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/statistics',\n                'crypto/gpg/statistics', '<address>')\n    HTTP_CALLABLE = ('GET', )\n    HTTP_QUERY_VARS = {'address': 'E-mail address'}\n    COMMAND_CACHE_TTL = 0\n\n    class CommandResult(Command.CommandResult):\n        def __init__(self, *args, **kwargs):\n            Command.CommandResult.__init__(self, *args, **kwargs)\n\n        def as_text(self):\n            if self.result:\n                return \"%d%% of e-mail from %s has PGP signatures (%d/%d)\" % (\n                    100*self.result[\"ratio\"],\n                    self.result[\"address\"],\n                    self.result[\"pgpsigned\"],\n                    self.result[\"messages\"])\n            return \"\"\n\n    def command(self):\n        args = list(self.args)\n        if len(args) > 0:\n            addr = args[0]\n        else:\n            addr = self.data.get(\"address\", None)\n\n        if addr is None:\n            return self._error(\"Must supply an address\", None)\n\n        session, idx = self._do_search(search=[\"from:%s\" % addr])\n        total = 0\n        for messageid in session.results:\n            total += 1\n\n        session, idx = self._do_search(search=[\"from:%s\" % addr,  \"has:pgp\"])\n        pgp = 0\n        for messageid in session.results:\n            pgp += 1\n\n        if total > 0:\n            ratio = float(pgp)/total\n        else:\n            ratio = 0\n\n        res = {\"messages\": total,\n               \"pgpsigned\": pgp,\n               \"ratio\": ratio,\n               \"address\": addr}\n\n        return self._success(\"Got statistics for address\", res)\n\n\nclass GPGCheckKeys(Search):\n    \"\"\"Sanity check your keys and profiles\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/check_keys', 'crypto/gpg/check_keys',\n                '[--all-keys]')\n    HTTP_CALLABLE = ('GET', )\n    COMMAND_CACHE_TTL = 0\n\n    MIN_KEYSIZE = 2048\n\n    class CommandResult(Command.CommandResult):\n        def __init__(self, *args, **kwargs):\n            Command.CommandResult.__init__(self, *args, **kwargs)\n\n        def as_text(self):\n            if not isinstance(self.result, (dict,)):\n                return ''\n            if self.result.get('details'):\n                message = '%s.\\n - %s' % (self.message, '\\n - '.join(\n                    p['description'] for p in self.result['details']\n                ))\n            else:\n                message = '%s. %s' % (self.message, _('Looks good!'))\n            if self.result.get('fixes'):\n                message += '\\n\\n%s\\n - %s' % (_('Proposed fixes:'),\n                                            '\\n - '.join(\n                    '\\n    * '.join(f) for f in self.result['fixes']\n                ))\n            return message\n\n    def _fix_gen_key(self, min_bits=2048):\n        return [\n            _(\"You need a new key!\"),\n            _(\"Run: %s\") % '`gpg --gen-key`',\n            _(\"Answer the tool\\'s questions: use RSA and RSA, %d bits or more\"\n              ) % min_bits]\n\n    def _fix_mp_config(self, good_key=None):\n        fprint = (good_key['fingerprint'] if good_key else '<FINGERPRINT>')\n        return [\n           _('Update the Mailpile config to use a good key:'),\n           _('IMPORTANT: This MUST be done before disabling the key!'),\n           _('Run: %s') % ('`set prefs.gpg_recipient = %s`' % fprint),\n           _('Run: %s') % ('`optimize`'),\n           _('This key\\'s passphrase will be used to log in to Mailpile')]\n\n    def _fix_revoke_key(self, fprint, comment=''):\n        return [\n            _('Revoke bad keys:') + ('  ' + comment if comment else ''),\n            _('Run: %s') % ('`gpg --gen-revoke %s`' % fprint),\n            _('Say yes to the first question, then follow the instructions'),\n            _('A revocation certificate will be shown on screen'),\n            _('Copy & paste that, save, and send to people who have the old key'),\n            _('You can search for %s to find such people'\n              ) % '`is:encrypted to:me`']\n\n    def _fix_disable_key(self, fprint, comment=''):\n        return [\n            _('Disable bad keys:') + ('  ' + comment if comment else ''),\n            _('Run: %s') % ('`gpg --edit-key %s`' % fprint),\n            _('Type %s') % '`disable`',\n            _('Type %s') % '`save`']\n\n    def command(self):\n        session, config = self.session, self.session.config\n        args = list(self.args)\n\n        all_keys = '--all-keys' in args\n        quiet = '--quiet' in args\n\n        date = datetime.date.today()\n        today = date.strftime(\"%Y-%m-%d\")\n        date += datetime.timedelta(days=14)\n        fortnight = date.strftime(\"%Y-%m-%d\")\n\n        serious = 0\n        details = []\n        fixes = []\n        bad_keys = {}\n        good_key = None\n        good_keys = {}\n        secret_keys = self._gnupg().list_secret_keys()\n\n        for fprint, info in secret_keys.iteritems():\n            k_info = {\n                'description': None,\n                'key': fprint,\n                'keysize': int(info.get('keysize', 0)),\n            }\n            is_serious = True\n            exp = info.get('expiration_date')\n            if info[\"disabled\"]:\n                k_info['description'] = _('%s: --- Disabled.') % fprint\n                is_serious = False\n            elif (not info['capabilities_map'].get('encrypt') or\n                    not info['capabilities_map'].get('sign')):\n                if info.get(\"revoked\"):\n                    k_info['description'] = _('%s: --- Revoked.'\n                                              ) % fprint\n                    is_serious = False\n                elif exp and exp <= today:\n                    k_info['description'] = _('%s: Bad: Expired on %s'\n                                              ) % (fprint,\n                                                   info['expiration_date'])\n                else:\n                    k_info['description'] = _('%s: Bad: Key is useless'\n                                              ) % fprint\n            elif exp and exp <= fortnight:\n                k_info['description'] = _('%s: Bad: Expires on %s'\n                                          ) % (fprint, info['expiration_date'])\n            elif k_info['keysize'] < self.MIN_KEYSIZE:\n                k_info['description'] = _('%s: Bad: Too small (%d bits)'\n                                          ) % (fprint, k_info['keysize'])\n            else:\n                good_keys[fprint] = info\n                if (not good_key\n                        or int(good_key['keysize']) < k_info['keysize']):\n                    good_key = info\n                k_info['description'] = _('%s: OK: %d bits, looks good!'\n                                          ) % (fprint, k_info['keysize'])\n                is_serious = False\n\n            if k_info['description'] is not None:\n                details.append(k_info)\n            if is_serious:\n                fixes += [self._fix_revoke_key(fprint, _('(optional)')),\n                          self._fix_disable_key(fprint)]\n                serious += 1\n            if fprint not in good_keys:\n                bad_keys[fprint] = info\n\n        bad_recipient = False\n        if config.prefs.gpg_recipient:\n            for k in bad_keys:\n                if k.endswith(config.prefs.gpg_recipient):\n                    details.append({\n                        'gpg_recipient': True,\n                        'description': _('%s: Mailpile config uses bad key'\n                                         ) % k,\n                        'key': k\n                    })\n                    bad_recipient = True\n                    serious += 1\n\n        if bad_recipient and good_key:\n            fixes[:0] = [self._fix_mp_config(good_key)]\n\n        profiles = config.vcards.find_vcards([], kinds=['profile'])\n        for vc in profiles:\n            p_info = {\n                'profile': vc.get('x-mailpile-rid').value,\n                'email': vc.email,\n                'fn': vc.fn\n            }\n            try:\n                if all_keys:\n                    vcls = [k.value for k in vc.get_all('key') if k.value]\n                else:\n                    vcls = [vc.get('key').value]\n            except (IndexError, AttributeError):\n                vcls = []\n            for key in vcls:\n                fprint = key.split(',')[-1]\n                if fprint and fprint in bad_keys:\n                    p_info['key'] = fprint\n                    p_info['description'] = _('%(key)s: Bad key in profile'\n                                              ' %(fn)s <%(email)s>'\n                                              ' (%(profile)s)') % p_info\n                    details.append(p_info)\n                    serious += 1\n            if not vcls:\n                p_info['description'] = _('No key for %(fn)s <%(email)s>'\n                                          ' (%(profile)s)') % p_info\n                details.append(p_info)\n                serious += 1\n\n        if len(good_keys) == 0:\n            fixes[:0] = [self._fix_gen_key(min_bits=self.MIN_KEYSIZE),\n                         self._fix_mp_config()]\n\n        if quiet and not serious:\n            return self._success('OK')\n\n        ret = self._error if serious else self._success\n        return ret(_('Sanity checked: %d keys in GPG keyring, %d profiles')\n                     % (len(secret_keys), len(profiles)),\n                   result={'passed': not serious,\n                           'details': details,\n                           'fixes': fixes})\n\n\n_plugins.register_commands(GPGKeySearch)\n_plugins.register_commands(GPGKeyReceive)\n_plugins.register_commands(GPGKeyImport)\n_plugins.register_commands(GPGKeyImportFromMail)\n_plugins.register_commands(GPGKeySign)\n_plugins.register_commands(GPGKeyList)\n_plugins.register_commands(GPGUsageStatistics)\n_plugins.register_commands(GPGKeyListSecret)\n_plugins.register_commands(GPGCheckKeys)\n", "{#\n\n  This is a self-contained modal for adding (and editing) account details.\n  This is a single form which handles profiles, routes and basic source\n  configuration.\n\n  The basic section of the form captures name, e-mail and password.\n\n  If the user allows auto-detection of settings, the Thunderbird ISPDB\n  will be queried and possibly other heuristics employed to figure out\n  correct connection settings. If successful, the route and source forms\n  will be filled in automatically (and skipped on Next).\n\n  Manual settings for routes and sources are as expected; local or\n  remote options, SMTP, IMAP, POP3, SSL, ports, hostnames, auth, ...\n\n  The security section of the form allows the user to choose which PGP key\n  to associate with this account or create a new one if he has none, which\n  will take place in a long-running background process.\n\n  The user can at any time skip forward or backwards in the form by\n  clicking on the section headlines, which are kept visible for that\n  purpose.\n\n#}{% set new_src_id = result.new_src_id %}\n\n  <script>\n    var _fpa = (function() {\n      var pf = '#form-profile-editor ';\n      var new_src_id = '{{ new_src_id }}';\n      var old = {username: ''};\n      return {\n        pre_submit: function(elem) {\n        },\n        display: function(elem, disp) {\n          if (disp) { elem.show() } else { elem.hide() };\n        },\n        validate: function() {\n          var basic_problems = 0;\n          if ($(pf + 'input[name=name]').val() == \"\" ||\n              $(pf + 'input[name=email]').val().indexOf('@') < 0) {\n            basic_problems += 1;\n            $(pf + 'input[name=name], ' + pf + 'input[name=email]'\n              ).on('change', _fpa.validate);\n          }\n          // FIXME: Validate other things too, improve e-mail validation\n          //_fpa.display($('.fpa-basics-ok'), basic_problems < 1);\n          _fpa.display($('.fpa-basics-bad'), basic_problems > 0);\n          _fpa.display($('#fpa-submit'),\n                       (basic_problems < 1) &&\n                       (!$(pf + '.fpa-autoconfig').is(':checked')));\n        },\n        next: function(show) {\n          $(pf + 'div.section').slideUp();\n          $(pf + 'div.' + show).slideDown().find(':tabbable').eq(0).focus();\n          $(pf + '.fpa-login-failed').hide();\n          $(pf + '.fpa-detection-failed').hide();\n          // Any navigation disables the auto-detection\n          $(pf + '.fpa-autoconfig').prop('checked', false);\n          _fpa.validate();\n          return false;\n        },\n        more: function(show) {\n          $(pf + '.' + show + '-show').hide();\n          $(pf + '.' + show).slideDown();\n          return false;\n        },\n        select: function(sel, cls) {\n          var val = $(sel).val();\n          $(pf + '.' + cls).hide();\n          if (val) {\n            $(pf + '.' + cls + '.any').show();\n            if (val[0] != '!') $(pf + '.' + cls + '.' + val).show();\n          }\n          else {\n            $(pf + '.' + cls + '.undefined').show();\n          }\n        },\n        mark_copied: function(elem, what) {\n          var $elem = $(elem);\n          if ($elem.val() == old[what]) {\n            $elem.parent().find('.fpa-' + what + '-copied').show();\n          }\n          else {\n            $elem.parent().find('.fpa-' + what + '-copied').hide();\n          }\n        },\n        copy_basic: function(what) {\n          var value = $(pf + '.fpa-basic-' + what).val();\n          var old_old = old[what];\n          old[what] = value;\n          $(pf + '.fpa-' + what).each(function(i) {\n            var $t = $(this);\n            if (old_old == $t.val() || '' == $t.val()) $t.val(value);\n            _fpa.mark_copied(this, what);\n          });\n        },\n        exclude: function(elem, s1, s2, s3, s4) {\n          if ($(elem).is(':checked')) {\n            if (s1) $(pf + 'input[name=\"' + s1 +'\"]').removeAttr('checked');\n            if (s2) $(pf + 'input[name=\"' + s2 +'\"]').removeAttr('checked');\n            if (s3) $(pf + 'input[name=\"' + s3 +'\"]').removeAttr('checked');\n            if (s4) $(pf + 'input[name=\"' + s4 +'\"]').removeAttr('checked');\n          }\n        },\n        require: function(elem, s1, s2, s3) {\n          if ($(elem).is(':checked')) {\n            if (s1) $(pf + 'input[name=\"' + s1 +'\"]').prop('checked', true);\n            if (s2) $(pf + 'input[name=\"' + s2 +'\"]').prop('checked', true);\n            if (s3) $(pf + 'input[name=\"' + s3 +'\"]').prop('checked', true);\n          }\n        },\n        requiredby: function(elem, s1, s2, s3) {\n          if (!$(elem).is(':checked')) {\n            if (s1) $(pf + 'input[name=\"' + s1 +'\"]').removeAttr('checked');\n            if (s2) $(pf + 'input[name=\"' + s2 +'\"]').removeAttr('checked');\n            if (s3) $(pf + 'input[name=\"' + s3 +'\"]').removeAttr('checked');\n          }\n        },\n        email_changed: function() {\n          // If the e-mail in basics changes, try to select the matching\n          // PGP key, if there is one. This may override user selections,\n          // which might be lame but should rarely be an issue because of\n          // the \"order of progression\" of the form.\n          var email = $(pf + '.fpa-email').val();\n          var found = 0;\n          $(pf + '.fpa-pgp-key option').each(function(i) {\n            var uid = $(this).data('uid');\n            if (found == 0 && uid == email) {\n              $(this).prop('selected', true).removeClass('hide');\n              found = 1;\n            }\n            else {\n              $(this).prop('selected', false);\n              if (uid) $(this).addClass('hide');\n            }\n            if (!found) {\n              $(pf + '.fpa-pgp-key-default').prop('selected', true);\n              _fpa.select($('.fpa-pgp-key'), 'security-opt');\n            }\n          });\n          _fpa.copy_basic('username');\n        },\n        basics_next: function() {\n          var email = $(pf + '.fpa-email').val();\n          if (!email) {\n            // FIXME: Improve validation...\n            alert('{{_(\"You need at least an e-mail address to proceed.\")|escapejs}}');\n          }\n          else if ($(pf + '.fpa-autoconfig').is(':checked')) {\n            $(pf + 'div.section, ' + pf + 'div.fpa-network-settings').slideUp();\n            $(pf + 'div.fpa-detection-in-progress').slideDown();\n            $(pf + '.fpa-detection-progress').html('{{_(\"Detecting settings for: \")|escapejs}}' + email);\n            var ev_source = '.*.SetupGetEmailSettings';\n            var watch_id = EventLog.subscribe(ev_source, function(ev) {\n              if (ev.private_data['track-id'] == new_src_id) {\n                $(pf + '.fpa-detection-progress').html(ev.message);\n              }\n            });\n            Mailpile.API.setup_email_servers_get({\n              'track-id': new_src_id,\n              '_timeout': (Mailpile.ajax_timeout * 30), // AJAX timeout\n              'timeout': 240000,  // Server-side deadline\n              'email': email,\n              '_error_callback': function(response, _status) {\n                console.log(\"Detection error \" + _status);\n                $(pf + 'div.fpa-detection-in-progress').slideUp();\n                $(pf + 'div.fpa-network-settings').slideDown();\n                _fpa.next('profile-add-route');\n                $(pf + '.fpa-detection-failed').slideDown();\n                EventLog.unsubscribe(ev_source, watch_id);\n              }\n            }, function(data) {\n              EventLog.unsubscribe(ev_source, watch_id);\n              $(pf + 'div.fpa-detection-in-progress').slideUp();\n              $(pf + 'div.fpa-network-settings').slideDown();\n              $('.edit-provider-settings').hide();\n              var nxt = undefined;\n              var result = undefined;\n              if (data.result) result = data.result[email];\n              if (result) nxt = _fpa.copy_email_settings(result);\n              if (data.result && data.result['login_failed']) {\n                _fpa.next('profile-add-basics');\n                $(pf + '.fpa-autoconfig').prop('checked', true);\n                $(pf + '.fpa-login-failed').slideDown();\n              }\n              else if (nxt) {\n                _fpa.next(nxt);\n              }\n              else {\n                _fpa.next('profile-add-route');\n                $(pf + '.fpa-detection-failed').slideDown();\n              }\n            });\n            return false;\n          }\n          else {\n            return _fpa.next(\"profile-add-route\");\n          }\n        },\n        copy_email_settings: function(result) {\n          var next = 0;\n          var oauth = 0;\n          if (result.routes && result.routes.length > 0) {\n            var found = result.routes[0];\n            if (found.auth_type == 'OAuth2') oauth += 1;\n            $(\"input[name='route-host']\").val(found.host);\n            $(\"input[name='route-port']\").val(found.port);\n            $(\"input[name='route-username']\").val(found.username);\n            var $s = $(\"select[name='route-protocol']\");\n            $s.find('option').prop('selected', false);\n            $s.find(\"option[value='\" + found.protocol + \"']\").prop('selected', true);\n            var $a = $(\"select[name='route-auth_type']\");\n            $a.find('option').prop('selected', false);\n            $a.find(\"option[value='\" + found.auth_type.substring(0, 8) + \"']\").prop('selected', true);\n            _fpa.select($s, 'route-settings');\n            next = 'profile-add-source';\n          }\n          if (result.sources && result.sources.length > 0) {\n            var found = result.sources[0];\n            if (found.auth_type == 'OAuth2') oauth += 1;\n            $(\"input[name='source-{{ new_src_id }}-host']\").val(found.host);\n            $(\"input[name='source-{{ new_src_id }}-port']\").val(found.port);\n            $(\"input[name='source-{{ new_src_id }}-username']\").val(found.username);\n            var $s = $(\"select[name='source-{{ new_src_id }}-protocol']\");\n            $s.find(\"option\").prop('selected', false);\n            $s.find(\"option[value='\" + found.protocol + \"']\").prop('selected', true);\n            var $a = $(\"select[name='source-{{ new_src_id }}-auth_type']\");\n            $a.find('option').prop('selected', false);\n            $a.find(\"option[value='\" + found.auth_type.substring(0, 8) + \"']\").prop('selected', true);\n            _fpa.select($s, 'source-settings-{{ new_src_id }}');\n            next = 'profile-add-security';\n          }\n          if (oauth) {\n            // Do nothing...?\n          }\n          else if (result.enable) {\n            $('.edit-provider-settings').attr('href', result.enable[0].url).show();\n            $('.fpa-warning .description').html(result.enable[0].description);\n            $('.fpa-warning ul.docs').html(' ');\n            if (result.docs) {\n              for (var i = 0; i < result.docs.length; i++) {\n                 var doc = result.docs[i];\n                 if (doc.description.indexOf('TB') == -1 &&\n                     doc.description.indexOf('Thunder') == -1) {\n                   $('.fpa-warning ul.docs').append($(\n                     '<li><a target=_blank href=\"' + doc.url + '\">' + doc.description + '</a></li>'\n                   ));\n                 }\n              }\n            }\n            next = 'fpa-warning';\n          }\n          return next;\n        },\n        setup: function() {\n          $('input[name=name]').focus();\n          $('#form-profile-editor').on('keydown', ':tabbable', function(e) {\n            // Make ENTER behave like TAB, to avoid accidental form submission.\n            if (document.activeElement.tagName == \"TEXTAREA\") {\n              // Do nothing\n            }\n            else if (e.which == 13 || e.keyCode == 13) {\n              e.preventDefault();\n              var nxt = $(document.activeElement).data(\"next\");\n              if (nxt) {\n                $(nxt).trigger('click');\n              }\n              else {\n                var $canfocus = $(':tabbable:visible')\n                var index = $canfocus.index(document.activeElement) + 1;\n                if (index >= $canfocus.length) index = 0;\n                $canfocus.eq(index).focus();\n              }\n            }\n          });\n        }\n      };\n    })();\n    setTimeout(\"_fpa.setup();\", 100);\n\n    $(function() {\n      // Make authentication popups forget about the current profile:\n      EventLog.forget_about_event(\"{{result.rid}}\");\n    });\n  </script>\n\n  <form id=\"form-profile-editor\" class=\"standard\"\n        method=\"POST\" action=\"{{ U(state.command_url) }}\"\n        style=\"position: relative; max-width: 60em;\">{{ csrf_field|safe }}\n    {%- if result.rid %}\n    <input type=\"hidden\" name=\"rid\" value=\"{{ result.rid }}\">\n    {%- endif %}\n\n    <p class=\"message paragraph-important\"\n       onclick='javascript:_fpa.next(\"profile-add-basics\");'>\n      <span class=\"icon-user\"></span> {{_(\"Basic Details\")}}\n      <span class=\"icon-signature-unknown fpa-basics-bad right hide\" style=\"padding: 5px; color: #ff5;\"\n            title=\"{{_('At least a name and e-mail are required!')}}\"></span>\n      <span class=\"icon-checkmark fpa-basics-ok right hide\" style=\"padding: 5px; color: #0d0;\"></span>\n    </p>\n    <div class=\"section profile-add-basics {% if ui_open and ui_open != 'basics' %}hide{% endif %}\"\n         style=\"position: relative;\">\n\n{%- if 0 %}{# TODO: Partner and make it possible to create e-mail accounts #}\n      {%- if not result.rid %}\n      <select class=\"right\" style=\"width: auto;\"\n              onchange=\"javascript:_fpa.select(this, 'basics');\">\n        <option value=\"old\" selected>{{_(\"Existing Account\")}}</option>\n        <option value=\"new\">{{_(\"New Address\")}}</option>\n      </select>\n      {% endif %}\n{%- endif %}\n\n      <div style=\"padding-right: 0em; width: 29em;\">\n        <label>{{_(\"Name\")}}</label>\n        <input type=\"text\" name=\"name\" style=\"width: 100%\"\n               value=\"{{ result.name }}\" placeholder=\"Ada Lovelace\">\n      </div>\n      <div class=\"basics old\">\n        <div class=\"left\" style=\"margin-right: 1em; width: 29em;\">\n          <label>{{_(\"E-mail\")}}</label>\n          <input type=\"text\" name=\"email\" style=\"width: 100%\"\n                 class='fpa-email fpa-basic-username' data-next=\"#basics-next\"\n                 placeholder=\"ada@example.com\" value=\"{{ result.email }}\"\n                 onchange=\"javascript:_fpa.email_changed();\">\n        </div>\n      </div>\n      <div class=\"basics new hide\">\n        <br><i>FIXME ... add signup with partners here!</i><br>\n      </div>\n      <div class=\"more-basics left{%- if not result.rid %} hide{% endif %}\"\n           style=\"width: 39em; padding: 0;\">\n        <label>{{_(\"Signature\")}}</label>\n        <textarea placeholder=\"{{_(\"Everyone needs a unique, witty signature!\")}}\"\n                  style=\"width: 100%; font-size: 0.85em;\"\n                  name=\"signature\">{{ result.signature }}</textarea>\n      </div>\n      <br clear=\"both\"><label>&nbsp;</label>\n      <div style=\"position: absolute; text-align: right; right: 0; bottom: 1.5em;\">\n        {%- if not result.rid %}\n        <a class=\"more-basics-show clickable\" onclick=\"javascript:_fpa.more('more-basics');\">\n          {{_(\"Add custom signature\")}} ...\n        </a> &nbsp;&nbsp;\n        {% endif %}\n        {%- if not result.sources %}\n        <input type=\"checkbox\" class=\"fpa-autoconfig\" value=\"yes\"\n               {%- if not result.rid %}checked{% endif %}>\n        <span class=\"checkbox\">\n          {{ _(\"Detect settings\") }}\n        </span> &nbsp;\n        {% endif %}\n        <button id=\"basics-next\" onclick='javascript:_fpa.basics_next();'\n                class=\"button button-secondary\" type=\"button\">{{_(\"Next\")}} ...</button>\n      </div>\n      <br clear=\"both\">\n    </div>\n\n    <div class=\"fpa-detection-in-progress hide\">\n      <p class=\"message paragraph-important\">\n        <span class=\"icon-robot\"></span> {{_(\"Auto-detecting settings\")}} ...\n      </p>\n      <div class=\"text-center\">\n      {% if config.sys.proxy.protocol in (\"tor\", \"tor-risky\") %}\n        <p>{{_(\"Connecting over Tor, this may take a while.\")}}</p>\n      {% endif %}\n        <p>{% include(\"../img/loading-ellipsis.svg\") %}</p>\n        <p><i class='fpa-detection-progress'></i></p>\n      </div>\n    </div>\n\n    <div class=\"fpa-network-settings\">\n      <div class=\"fpa-detection-failed hide\">\n        <p class=\"message paragraph-alert\">\n          <span class=\"icon-robot\"></span>\n          <b>{{_(\"Failed to detect settings, manual configuration required\")}}!</b>\n          <span class=\"description\" href=\"\"></span>\n        </p>\n        <p class=\"text-center\">\n          <a href=\"{{ U('/logs/network/') }}\" data-dismiss=\"modal\">\n             <span class=\"icon icon-work\"></span>\n             {{_(\"Troubleshoot recent Network Activity.\")}}\n          </a>\n        </p>\n      </div>\n      <p class=\"message paragraph-alert fpa-login-failed hide\">\n        <span class=\"icon-robot\"></span> <b>{{_(\"Failed to log in, check the username and password\")}}!</b>\n        <span class=\"description\" href=\"\"></span>\n      </p>\n      <p class=\"message paragraph-important\"\n         onclick='javascript:_fpa.next(\"profile-add-route\");'>\n        <span class=\"icon-outbox\"></span> {{_(\"Sending Mail\")}}\n        <span class=\"icon-checkmark fpa-route-ok right hide\" style=\"padding: 5px; color: #4f4;\"></span>\n      </p>\n      <div class=\"section profile-add-route {% if ui_open != 'route' %}hide{% endif %}\"\n           style=\"position: relative;\">\n        <select class=\"right\" name=\"route-protocol\" style=\"width: auto;\"\n                data-next=\"#next-route\"\n                onchange=\"javascript:_fpa.select(this, 'route-settings');\">\n          {%- set protocol = result['route-protocol'] %}\n          {%- for val, txt in (('smtp', 'SMTP'),\n                              ('smtpssl', 'SMTP/TLS'),\n                              ('smtptls', 'SMTP/STARTTLS'),\n                              ('local', _(\"Local\")),\n                              ('none', _(\"None\"))) %}\n          <option value=\"{{val}}\"{% if val == protocol %} selected\n                                 {%- endif %}>{{txt}}</option>\n          {%- endfor %}\n        </select>\n        <div class=\"route-settings smtp smtpssl smtptls\n                    {%- if protocol not in ('smtp', 'smtpssl', 'smtptls') %} hide{% endif %}\">\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            <label>{{_(\"Host name\")}}</label>\n            <input type=\"text\" name=\"route-host\" value=\"{{ result['route-host'] }}\" placeholder=\"mail.server.com\">\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 10em;\">\n            <label>{{_(\"Port number\")}}</label>\n            <input type=\"text\" name=\"route-port\" value=\"{{ result['route-port'] }}\" placeholder=\"25, 465 or 587\">\n          </div>\n          <br clear=\"both\">\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            <small class=\"right fpa-username-copied hide\">({{ _(\"copied\") }})</small>\n            <label>{{_(\"Username\")}}</label>\n            <input type=\"text\" name=\"route-username\" class=\"fpa-username\"\n                   onchange=\"javascript:_fpa.mark_copied(this, 'username');\"\n                   value=\"{{ result['route-username'] }}\" placeholder=\"you123\">\n          </div>\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            {%- set auth_type = result['route-auth_type'][:8] %}\n            <label>{{_(\"Authentication\")}}</label>\n            <select name=\"route-auth_type\" style=\"width: 14em;\">\n              {%- for val, txt in (('password', 'Password'),\n                                   ('OAuth2', 'OAuth2')) %}\n              <option value=\"{{val}}\"{% if val == auth_type %} selected\n                                     {%- endif %}>{{txt}}</option>\n              {%- endfor %}\n            </select>\n          </div>\n\n          {%- set password = result['route-password'] %}\n          {%- if password %}\n          <div class=\"left\" style=\"margin-right: 0; width: 29em;\">\n            <input type=\"checkbox\" name=\"route-password\" value=\"\">\n            <span class=\"checkbox\">\n              {{_(\"Forget password\")}}\n            </span><br>\n          </div>\n          {%- endif %}\n        </div>\n        <div class=\"route-settings local\n                    {%- if protocol != 'local' %} hide{% endif %}\">\n          <div style=\"margin-right: 0; width: 25em;\">\n            <p><i>\n              {{_(\"Send mail using local Unix tools.\")}}\n              {{_(\"Use this setting if you have a working mail server on this machine.\")}}\n            </i></p>\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 29em;\">\n            <label>{{_(\"Shell command\")}}</label>\n            <input type=\"text\" name=\"route-command\" style=\"width: 100%;\"\n                   value=\"{{ result['route-command'] }}\"\n                   placeholder=\"- {{_('Leave blank to auto-detect')}} -\">\n          </div>\n        </div>\n        <div style=\"width: 70%;\" class=\"route-settings none\n                                        {%- if protocol != 'none' %} hide{% endif %}\">\n          <br>\n          <br>\n          <p class=\"text-center\"><i>\n            {{_(\"No outgoing mail for this account.\")}}\n          </i></p>\n          <br>\n        </div>\n        <br clear=\"both\">\n        <div style=\"position: absolute; right: 0; bottom: 1.5em;\">\n          <button onclick='javascript:_fpa.next(\"profile-add-source\");'\n                  class=\"button button-secondary\" type=\"button\">{{_(\"Next\")}} ...</button>\n        </div>\n        <br clear=\"both\">\n      </div>\n\n      <p class=\"message paragraph-important\"\n         onclick='javascript:_fpa.next(\"profile-add-source\");'>\n        <span class=\"icon-mailsource\"></span> {{_(\"Receiving Mail\")}}\n        <span class=\"icon-checkmark right hide\" style=\"padding: 5px; color: #5f5;\"></span>\n      </p>\n      <div class=\"section profile-add-source {% if ui_open != 'sources' %}hide{% endif %}\"\n           style=\"position: relative;\">\n{% macro source_editor(rid, new_rid) %}\n        {% set protocol = result['source-' + rid + '-protocol'] %}\n        <select class=\"right\" style=\"width: auto;\"\n                onchange=\"javascript:_fpa.select(this, 'source-settings-{{ new_rid }}');\"\n                name=\"source-{{ new_rid }}-protocol\">\n          {% for val, txt in (('imap', 'IMAP'),\n                              ('imap_ssl', 'IMAP/TLS'),\n                              ('pop3', 'POP3'),\n                              ('pop3_ssl', 'POP3/TLS'),\n                              ('spool', _(\"Mail spool\")),\n                              ('local', _(\"Local files\")),\n                              ('none', _(\"None\"))) %}\n           {%- if rid != new_rid or val[:4] == protocol[:4] %}\n            <option value=\"{{val}}\"\n                    {%- if val == protocol or\n                           (val == \"imap\" and protocol == \"imap_tls\") %}\n                    selected{% endif %}>{{txt}}</option>\n           {%- endif %}\n          {%- endfor %}\n        </select>\n\n        <div class=\"source-settings-{{ new_rid }} imap imap_ssl pop3 pop3_ssl\n                    {%- if protocol[:4] not in ('imap', 'pop3') %} hide{% endif %}\">\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            <label>{{_(\"Host name\")}}</label>\n            <input type=\"text\" name=\"source-{{ new_rid }}-host\"\n                   value=\"{{ result['source-' + rid + '-host'] }}\"\n                   placeholder=\"mail.server.com\">\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 13em;\">\n            <label>{{_(\"Port number\")}}</label>\n            <input type=\"text\" name=\"source-{{ new_rid }}-port\"\n                   value=\"{{ result['source-' + rid + '-port'] }}\"\n                   placeholder=\"110, 143, 993 or 995\">\n          </div>\n          <br clear=\"both\">\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            <small class=\"right fpa-username-copied hide\">({{ _(\"copied\") }})</small>\n            <label>{{_(\"Username\")}}</label>\n            <input type=\"text\" name=\"source-{{ new_rid }}-username\" class=\"fpa-username\"\n                   onchange=\"javascript:_fpa.mark_copied(this, 'username');\"\n                   value=\"{{ result['source-' + rid + '-username'] }}\"\n                   placeholder=\"you123\">\n          </div>\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            {%- set auth_type = result['source-' + rid + '-auth_type'] %}\n            <label>{{_(\"Authentication\")}}</label>\n            <select name=\"source-{{ new_rid }}-auth_type\" style=\"width: 14em;\">\n              {%- for val, txt in (('password', 'Password'),\n                                   ('OAuth2', 'OAuth2')) %}\n              <option value=\"{{val}}\"{% if val == auth_type %} selected\n                                     {%- endif %}>{{txt}}</option>\n              {%- endfor %}\n            </select>\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 29em;\">\n          {%- set password = result['source-' + rid + '-password'] %}\n          {%- if password %}\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-password\" value=\"\">\n            <span class=\"checkbox\">\n              {{_(\"Forget password\")}}\n            </span><br>\n          {%- endif %}\n\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-leave-on-server\" value=\"yes\"\n                   {% if result['source-' + rid + '-leave-on-server'] %}checked{% endif %}>\n            <span class=\"checkbox\">\n              {{_(\"Leave mail on server\")}}\n            </span><br>\n\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-index-all-mail\" value=\"yes\"\n                   {% if result['source-' + rid + '-index-all-mail'] %}checked{% endif %}>\n            <span class=\"checkbox\">\n              {{_(\"Copy all mail and add to search engine\")}}\n            </span>\n\n            <span class=\"source-settings-{{ new_rid }}\n                         {%- if protocol not in ('imap', 'imap_tls') %} hide{% endif %}\n                         imap\">\n              <br>\n              <input type=\"checkbox\" name=\"source-{{ new_rid }}-force-starttls\" value=\"yes\"\n                     {% if result['source-' + rid + '-force-starttls'] or\n                           result['source-' + rid + '-protocol'] == 'imap_tls'\n                           %}checked{% endif %}>\n              <span class=\"checkbox\">\n                {{_(\"Require STARTTLS encryption\")}}\n              </span>\n            </span>\n\n            <div class='edit-provider-settings hide'><br>\n              <a target=_blank class='edit-provider-settings button-secondary'>\n                <span class=\"icon-settings\"></span> {{_(\"Enable IMAP\")}}\n              </a>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"source-settings-{{ new_rid }} spool\n                    {%- if protocol[:4] != 'spool' %} hide{% endif %}\">\n          <div class=\"source-settings-{{ new_rid }} spool left\" style=\"margin-right: 0; width: 29em;\">\n            <p><i>\n              {{_(\"Receive mail from local Unix mail spool.\")}}\n              {{_(\"Use this setting if you have a working mail server on this machine.\")}}\n            </i></p>\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 29em;\">\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-copy-local\" value=\"yes\"\n                   onchange='javascript:_fpa.requiredby(this, \"source-{{ new_rid }}-delete-source\");'\n                   {% if result['source-' + rid + '-copy-local'] %}checked{% endif %}>\n            <span class=\"checkbox\">\n              {{_(\"Copy mail to Mailpile secure storage\")}}\n            </span><br>\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-delete-source\" value=\"yes\"\n                   onchange='javascript:_fpa.require(this, \"source-{{ new_rid }}-copy-local\");'\n                   {% if result['source-' + rid + '-delete-source'] %}checked{% endif %}>\n            <span class=\"checkbox\">\n              {{_(\"Delete from Unix mail spool\")}} ({{_(\"after copying\")}})\n            </span>\n          </div>\n        </div>\n\n        <div class=\"source-settings-{{ new_rid }} none local\n             {%- if protocol not in ('none', 'local') %} hide{% endif %}\"\n             style=\"width: 70%;\">\n          <div class=\"source-settings-{{ new_rid }} none left\n               {%- if protocol[:4] != 'none' %} hide{% endif %}\"\n               style=\"margin-right: 0; width: 29em;\">\n            <br><br>\n            <p class=\"text-center\"><i>\n            {%- if result.sources %}\n              {{_(\"Choose a protocol for the new mail source...\")}}\n            {%- else %}\n              {{_(\"No incoming mail for this account.\")}}\n            {%- endif %}\n            </i></p>\n            <br>\n          </div>\n          <div class=\"source-settings-{{ new_rid }} local left\n               {%- if protocol != 'local' %} hide{% endif %}\"\n               style=\"margin-right: 0; width: 29em;\">\n            <p><i>\n              {{_(\"Use this setting if you would like Mailpile to read e-mails already downloaded by Thunderbird, Mac Mail or another local application on this machine.\")}}\n            </i></p>\n            <p>\n              {{_(\"Use the Browse tool to import local mailboxes later on.\")}}\n            </p>\n          </div>\n        </div>\n\n        {%- if rid == new_rid %}\n        <div class=\"source-settings-{{ new_rid }}\n                    imap imap_ssl pop3 pop3_ssl local spool\n                    {%- if protocol[:4] == 'none' %} hide{% endif %}\">\n          <br clear=\"both\">\n          <input type=\"checkbox\" name=\"source-{{ new_rid }}-enabled\" value=\"yes\"\n                 onchange='javascript:_fpa.require(this, \"source-{{ new_rid }}-copy-local\");'\n                 {% if result['source-' + rid + '-enabled'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Enable this mail source\")}}\n          </span>\n        </div>\n        {% else %}\n        <input type=\"hidden\" name=\"source-{{ new_rid }}-enabled\" value=\"yes\">\n        {% endif %}\n{%- endmacro %}\n        {%- for sid in result.sources %}\n\n          {%- if not loop.first %}<br clear=\"both\"><hr style=\"margin: 1em 0 5px 0;\">{% endif %}\n          {{- source_editor(sid, sid) }}\n        {%- endfor %}\n        <div class=\"source-add-new{% if result.sources %} hide{% endif %}\">\n          {%- if result.sources %}<br clear=\"both\"><hr style=\"margin: 1em 0 5px 0;\">{% endif %}\n          {{- source_editor('NEW', new_src_id) }}\n        </div>\n        <br clear=\"both\">\n        <div style=\"position: absolute; right: 0; bottom: 1.5em;\">\n          {% if result.sources %}\n          <input type=\"checkbox\" class=\"fpa-add-new-source\" value=\"yes\"\n                 style=\"padding-right: 0;\"\n                 onchange=\"javascript:$('.source-add-new').toggle();\">\n          <span class=\"checkbox\">{{ _(\"Add New\") }} &nbsp; </span>\n          {% endif %}\n          <button onclick='javascript:_fpa.next(\"profile-add-security\");'\n                  class=\"button button-secondary\" type=\"button\">{{_(\"Next\")}} ...</button>\n        </div>\n        <br clear=\"both\">\n      </div>\n    </div>\n\n    {% set enable_imap_pop3_message = _(\"Mailpile may not be able to access your mail unless you log on to your account and enable IMAP and/or POP3.\") %}\n    <div class='section fpa-warning hide' style='position: relative'>\n      <p class=\"message paragraph-alert\">\n        <span class=\"icon-settings\"></span> <b>{{_(\"Important\")}}!</b>\n        <span class=\"description\" href=\"\"></span>\n      </p>\n      <p>\n        {{ enable_imap_pop3_message }}\n        {{_(\"Without this, some providers will even mistake Mailpile for an intruder!\")}}\n      </p>\n      <ul style=\"list-style: disc; margin-left: 2em;\" class=\"docs\"></ul>\n      <p>\n        <a target=_blank class='edit-provider-settings button-secondary right'\n           onclick=\"javascript:$(this).removeClass('button-secondary').addClass('button-info');\n                               $('#fpa-gotit').removeClass('button-info').addClass('button-secondary');\">\n          <span class=\"icon-settings\"></span> {{_(\"Enable IMAP\")}}\n        </a>\n        <br clear=\"both\">\n      </p>\n      <div style=\"position: absolute; left: 0; bottom: 0;\">\n        <button onclick='javascript:_fpa.next(\"profile-add-security\");'\n                class=\"button-info\" id=\"fpa-gotit\" type=\"button\">{{_(\"Got it\")}} ...</button>\n      </div>\n    </div>\n\n    <p class=\"message paragraph-important\"\n       onclick='javascript:_fpa.next(\"profile-add-security\");'>\n      <span class=\"icon-lock-closed\"></span> {{_(\"Security and Privacy\")}}\n      <span class=\"icon-checkmark right hide\" style=\"padding: 5px; color: #5f5;\"></span>\n    </p>\n    <div class=\"section profile-add-security  {% if ui_open != 'security' %}hide{% endif %}\"\n         style=\"position: relative;\">\n      <div class=\"left\" style=\"margin-right: 0; width: 100%;\">\n        <label>{{_(\"Encryption key\")}}</label>\n        <select class='fpa-pgp-key' style=\"width: 100%\"\n                onchange=\"javascript:_fpa.select(this, 'security-opt');\"\n                name=\"security-pgp-key\">\n          <option value=\"!CREATE:RSA2048\">{{_(\"Create a new 2048 bit RSA key\")}}</option>\n          <option value=\"!CREATE:RSA3072\" class=\"fpa-pgp-key-default\">{{_(\"Create a new 3072 bit RSA key\")}}</option>\n        {%- set pgp_keys = mailpile('crypto/gpg/keylist/secret').result %}\n        {%- for fingerprint in pgp_keys -%}\n          {%- set key = pgp_keys[fingerprint] -%}\n          {%- for uid in key.uids %}\n          <option value=\"{{fingerprint}}\" data-uid=\"{{ uid.email }}\"\n                  {%- if (fingerprint == result['security-pgp-key']) and (uid.email == result.email) %} selected{% endif %}\n                  {%- if (uid.email != result.email) %} class=\"hide\"{% endif %}>\n            {{key.creation_date}}/{{key.keytype_name}}{{key.keysize}}:\n            {{uid.name}} &lt;{{uid.email}}&gt;\n            ({% if uid.comment %}{{uid.comment}}{% else %}0x{{ fingerprint[-8:] }}{% endif %})\n          </option>\n          {%- endfor %}\n        {%- endfor %}\n          <option value=\"!CREATE:RSA4096\">{{_(\"Create a new 4096 bit RSA key (slow)\")}}</option>\n          <option {% if not result['security-pgp-key'] %}selected {% endif -%}\n                  value=\"\">{{_(\"Disable encryption for this account\")}}</option>\n        </select>\n        <div class=\"security-opt any text-right\n             {%- if not result['security-pgp-key'] %} hide{% endif %}\"\n             style=\"margin: -13px 0 13px 0;\">\n          <a class=\"more-crypto-show\" onclick=\"javascript:_fpa.more('more-crypto');\">\n            {{_(\"Show too many encryption settings\")}}\n          </a>\n        </div>\n      </div>\n      <div class=\"security-opt any left\n           {%- if not result['security-pgp-key'] %} hide{% endif %}\"\n           style=\"margin-right: 0; width: 29em;\">\n        <div class=\"more-crypto {% if not result['security-best-effort-crypto'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-best-effort-crypto\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-always-sign\", \"security-always-encrypt\", \"security-obscure-metadata\", \"security-prefer-inline\");'\n                 {% if result['security-best-effort-crypto'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Best-effort: Encrypt and/or sign mail whenever possible\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-always-sign'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-always-sign\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-best-effort-crypto\");'\n                 {% if result['security-always-sign'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Always digitally sign outgoing mail\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-always-encrypt'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-always-encrypt\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-best-effort-crypto\");_fpa.require(this, \"security-always-sign\");'\n                 {% if result['security-always-encrypt'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Always encrypt (warn when sending unencrypted mail)\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-obscure-metadata'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-obscure-metadata\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-prefer-inline\");'\n                 {% if result['security-obscure-metadata'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Minimize metadata (may make mail unreadable)\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-prefer-inline'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-prefer-inline\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-obscure-metadata\", \"security-prefer-pgpmime\");'\n                 {% if result['security-prefer-inline'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Prefer compatibility; avoid PGP/MIME (makes mail ugly)\")}}\n          </span>\n        </div>\n{% if config.web.developer_mode %}\n        <div class=\"more-crypto {% if not result['security-prefer-pgpmime'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-prefer-pgpmime\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-prefer-inline\");'\n                 {% if result['security-prefer-pgpmime'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Prefer PGP/MIME\")}}\n          </span>\n        </div>\n{% endif %}\n        <div style=\"margin-top: 0.7em\"\n             class=\"more-crypto {% if not result['security-openpgp-header-encrypt'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-openpgp-header-encrypt\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-openpgp-header-none\");_fpa.require(this, \"security-openpgp-header-sign\");'\n                 {% if result['security-openpgp-header-encrypt'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Signal a preference for encrypted mail\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-openpgp-header-sign'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-openpgp-header-sign\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-openpgp-header-none\");'\n                 {% if result['security-openpgp-header-sign'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Signal a preference for signed mail\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-openpgp-header-none'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-openpgp-header-none\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-openpgp-header-sign\", \"security-openpgp-header-encrypt\");'\n                 {% if result['security-openpgp-header-none'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Signal a preference for un-signed, un-encrypted mail\")}}\n          </span>\n        </div>\n{# FIXME - make this work!\n        <div style=\"margin-top: 0.7em\"\n             class=\"more-crypto {% if not result['security-use-autocrypt'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-use-autocrypt\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-attach-keys\");'\n                 {% if result['security-use-autocrypt'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Use AutoCrypt headers to share encryption keys\")}}\n          </span><br>\n        </div>\n#}\n        <div class=\"more-crypto {% if not result['security-attach-keys'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-attach-keys\" value=\"yes\"\n                 {% if result['security-attach-keys'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Automatically attach encryption keys to outgoing mail\")}}\n          </span>\n        </div>\n{# FIXME - make this work!\n        <div class=\"more-crypto {% if not result['security-publish-to-keyserver'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-publish-to-keyserver\" value=\"yes\"\n                 {% if result['security-publish-to-keyserver'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Upload key to public directory (key server)\")}}\n          </span>\n        </div>\n#}\n      </div>\n    </div>\n\n    <br clear=\"both\">\n    <button type=\"submit\" id=\"fpa-submit\" class=\"button-primary right{%- if not result.rid %} hide{% endif %}\">\n      <span class=\"icon {{ form_icon or \"icon-plus\"}}\"></span>\n      {{ form_action or _(\"Add\")}}\n    </button>\n  </form>\n"], "fixing_code": ["#coding:utf-8\nimport os\nimport string\nimport sys\nimport time\nimport re\nimport StringIO\nimport tempfile\nimport threading\nimport traceback\nimport select\nimport pgpdump\nimport base64\nimport quopri\nfrom datetime import datetime\nfrom email.parser import Parser\nfrom email.message import Message\nfrom threading import Thread\n\nimport mailpile.platforms\nfrom mailpile.i18n import gettext\nfrom mailpile.i18n import ngettext as _n\nfrom mailpile.crypto.state import *\nfrom mailpile.crypto.mime import MimeSigningWrapper, MimeEncryptingWrapper\nfrom mailpile.safe_popen import Popen, PIPE, Safe_Pipe\n\n\n_ = lambda s: s\n\nDEFAULT_KEYSERVERS = [\"hkps://hkps.pool.sks-keyservers.net\",\n                      \"hkp://subset.pool.sks-keyservers.net\"]\nDEFAULT_KEYSERVER_OPTIONS = [\n  'ca-cert-file=%s' % __file__.replace('.pyc', '.py')]\n\nGPG_KEYID_LENGTH = 8\nGNUPG_HOMEDIR = None  # None=use what gpg uses\nGPG_BINARY = mailpile.platforms.GetDefaultGnuPGCommand()\nGPG_VERSIONS = {}\nBLOCKSIZE = 65536\n\nopenpgp_algorithms = {1: _(\"RSA\"),\n                      2: _(\"RSA (encrypt only)\"),\n                      3: _(\"RSA (sign only)\"),\n                      16: _(\"ElGamal (encrypt only)\"),\n                      17: _(\"DSA\"),\n                      20: _(\"ElGamal (encrypt/sign) [COMPROMISED]\"),\n                      22: _(\"EdDSA\"),\n                      999: _(\"Unknown\")}\n# For details on type 20 compromisation, see\n# http://lists.gnupg.org/pipermail/gnupg-announce/2003q4/000160.html\n\nENTROPY_LOCK = threading.Lock()\n\nclass GnuPGEventUpdater:\n    \"\"\"\n    Parse the GPG response into something useful for the Event Log.\n    \"\"\"\n    def __init__(self, event):\n        from mailpile.eventlog import Event\n        self.event = event or Event()\n\n    def _log(self, section, message):\n        data = section.get('gnupg', [])\n        if data:\n            data[-1].append(message)\n\n    def _log_private(self, message):\n        self._log(self.event.private_data, message)\n\n    def _log_public(self, message):\n        self._log(self.event.private_data, message)\n        self._log(self.event.data, message)\n\n    def running_gpg(self, why):\n        for section in (self.event.data, self.event.private_data):\n            data = section.get('gnupg', [])\n            data.append([why, int(time.time())])\n            section['gnupg'] = data\n\n    def update_args(self, args):\n        self._log_public(' '.join(args))\n\n    def update_sent_passphrase(self):\n        self._log_public('Sent passphrase')\n\n    def _parse_gpg_line(self, line):\n        if line.startswith('[GNUPG:] '):\n            pass  # FIXME: Parse for machine-readable data\n        elif line.startswith('gpg: '):\n            self._log_private(line[5:].strip())\n\n    def update_stdout(self, line):\n        self._parse_gpg_line(line)\n\n    def update_stderr(self, line):\n        self._parse_gpg_line(line)\n\n    def update_return_code(self, code):\n        self._log_public('GnuPG returned %s' % code)\n\n\nclass GnuPGResultParser:\n    \"\"\"\n    Parse the GPG response into EncryptionInfo and SignatureInfo.\n    \"\"\"\n    def __init__(rp, decrypt_requires_MDC=True, debug=None):\n        rp.decrypt_requires_MDC = decrypt_requires_MDC\n        rp.debug = debug or (lambda t: True)\n\n        rp.signature_info = SignatureInfo()\n        rp.signature_info[\"protocol\"] = \"openpgp\"\n\n        rp.encryption_info = EncryptionInfo()\n        rp.encryption_info[\"protocol\"] = \"openpgp\"\n\n        rp.plaintext = \"\"\n\n    def parse(rp, retvals):\n        signature_info = rp.signature_info\n        encryption_info = rp.encryption_info\n        from mailpile.mailutils.emails import ExtractEmailAndName\n\n        # Belt & suspenders: work around some buggy GnuPG status codes\n        gpg_stderr = ''.join(retvals[1][\"stderr\"])\n\n        # First pass, set some initial state.\n        locked, missing = [], []\n        for data in retvals[1][\"status\"]:\n            keyword = data[0].strip()  # The last keyword often ends in \\n\n\n            if keyword == 'NEED_PASSPHRASE':\n                locked += [data[2]]\n                encryption_info.part_status = \"lockedkey\"\n                encryption_info[\"locked_keys\"] = list(set(locked))\n\n            elif keyword == 'GOOD_PASSPHRASE':\n                encryption_info[\"locked_keys\"] = []\n\n            elif keyword == \"DECRYPTION_FAILED\":\n                missing += [x[1].strip() for x in retvals[1][\"status\"]\n                            if x[0] == \"NO_SECKEY\"]\n                if missing:\n                    encryption_info[\"missing_keys\"] = list(set(missing))\n                if encryption_info.part_status != \"lockedkey\":\n                    if missing:\n                        encryption_info.part_status = \"missingkey\"\n                    else:\n                        encryption_info.part_status = \"error\"\n\n            elif keyword == \"DECRYPTION_OKAY\":\n                if (rp.decrypt_requires_MDC and\n                       'message was not integrity protected' in gpg_stderr):\n                    rp.debug('Message not integrity protected, failing.')\n                    encryption_info.part_status = \"error\"\n                else:\n                    encryption_info.part_status = \"decrypted\"\n                    rp.plaintext = \"\".join(retvals[1][\"stdout\"])\n\n            elif keyword == \"ENC_TO\":\n                keylist = encryption_info.get(\"have_keys\", [])\n                if data[1] not in keylist:\n                    keylist.append(data[1].strip())\n                encryption_info[\"have_keys\"] = list(set(keylist))\n                \n            elif keyword == \"PLAINTEXT\":\n                encryption_info.filename = data[3].strip()\n\n            elif signature_info.part_status == \"none\":\n                # Only one of these will ever be emitted per key, use\n                # this to set initial state. We may end up revising\n                # the status depending on more info later.\n                if keyword in (\"GOODSIG\", \"BADSIG\"):\n                    email, fn = ExtractEmailAndName(\n                        \" \".join(data[2:]).decode('utf-8'))\n                    signature_info[\"name\"] = fn\n                    signature_info[\"email\"] = email\n                    signature_info.part_status = ((keyword == \"GOODSIG\")\n                                                  and \"unverified\"\n                                                  or \"invalid\")\n                    rp.plaintext = \"\".join(retvals[1][\"stdout\"])\n                                                  \n                elif keyword == \"ERRSIG\":\n                    signature_info.part_status = \"error\"\n                    signature_info[\"keyinfo\"] = data[1]\n                    signature_info[\"timestamp\"] = int(data[5])\n\n        # Second pass, this may update/mutate the state set above\n        for data in retvals[1][\"status\"]:\n            keyword = data[0].strip()  # The last keyword often ends in \\n\n\n            if keyword == \"NO_SECKEY\":\n                keyid = data[1].strip()\n                if \"missing_keys\" not in encryption_info:\n                    encryption_info[\"missing_keys\"] = [keyid]\n                elif keyid not in encryption_info[\"missing_keys\"]:\n                    encryption_info[\"missing_keys\"].append(keyid)\n                while keyid in encryption_info[\"have_keys\"]:\n                    encryption_info[\"have_keys\"].remove(keyid)\n\n            elif keyword == \"VALIDSIG\":\n                # FIXME: Determine trust level, between new, unverified,\n                #        verified, untrusted.\n                signature_info[\"keyinfo\"] = data[1]\n                signature_info[\"timestamp\"] = int(data[3])\n\n            elif keyword in (\"EXPKEYSIG\", \"REVKEYSIG\"):\n                email, fn = ExtractEmailAndName(\n                    \" \".join(data[2:]).decode('utf-8'))\n                signature_info[\"name\"] = fn\n                signature_info[\"email\"] = email\n                signature_info.part_status = ((keyword == \"EXPKEYSIG\")\n                                              and \"expired\"\n                                              or \"revoked\")\n\n          # FIXME: This appears to be spammy. Is my key borked, or\n          #        is GnuPG being stupid?\n          #\n          # elif keyword == \"KEYEXPIRED\":  # Ignoring: SIGEXPIRED\n          #     signature_info.part_status = \"expired\"\n            elif keyword == \"KEYREVOKED\":\n                signature_info.part_status = \"revoked\"\n            elif keyword == \"NO_PUBKEY\":\n                signature_info.part_status = \"unknown\"\n\n            elif keyword in (\"TRUST_ULTIMATE\", \"TRUST_FULLY\"):\n                if signature_info.part_status == \"unverified\":\n                    signature_info.part_status = \"verified\"\n\n        if encryption_info.part_status == \"error\":\n            rp.plaintext = \"\"\n\n        return rp\n\n\nclass GnuPGRecordParser:\n    def __init__(self):\n        self.keys = {}\n        self.curkeyid = None\n        self.curdata = None\n\n        self.record_fields = [\"record\", \"validity\", \"keysize\", \"keytype\",\n                              \"keyid\", \"creation_date\", \"expiration_date\",\n                              \"uidhash\", \"ownertrust\", \"uid\", \"sigclass\",\n                              \"capabilities\", \"flag\", \"sn\", \"hashtype\",\n                              \"curve\"]\n        self.record_types = [\"pub\", \"sub\", \"ssb\", \"fpr\", \"uat\", \"sec\", \"tru\",\n                             \"sig\", \"rev\", \"uid\", \"gpg\", \"rvk\", \"grp\"]\n        self.record_parsers = [self.parse_pubkey, self.parse_subkey,\n                               self.parse_subkey, self.parse_fingerprint,\n                               self.parse_userattribute, self.parse_privkey,\n                               self.parse_trust, self.parse_signature,\n                               self.parse_revoke, self.parse_uidline,\n                               self.parse_none, self.parse_revocation_key,\n                               self.parse_keygrip]\n\n        self.dispatch = dict(zip(self.record_types, self.record_parsers))\n\n    def parse(self, lines):\n        for line in lines:\n            self.parse_line(line)\n        return self.keys\n\n    def parse_line(self, line):\n        line = dict(zip(self.record_fields,\n                        map(lambda s: s.replace(\"\\\\x3a\", \":\"),\n                        stubborn_decode(line).strip().split(\":\"))))\n        r = self.dispatch.get(line[\"record\"], self.parse_unknown)\n        r(line)\n\n    def _parse_dates(self, line):\n        for ts in ('expiration_date', 'creation_date'):\n            if line.get(ts) and '-' not in line[ts]:\n                try:\n                    unixtime = int(line[ts])\n                    if unixtime > 946684800:  # 2000-01-01\n                        dt = datetime.fromtimestamp(unixtime)\n                        line[ts] = dt.strftime('%Y-%m-%d')\n                except ValueError:\n                    line[ts+'_unparsed'] = line[ts]\n                    line[ts] = '1970-01-01'\n\n    def _parse_keydata(self, line):\n        line[\"keytype_name\"] = _(openpgp_algorithms.get(int(line[\"keytype\"]),\n                                                        'Unknown'))\n        line[\"capabilities_map\"] = {\n            \"encrypt\": \"E\" in line[\"capabilities\"],\n            \"sign\": \"S\" in line[\"capabilities\"],\n            \"certify\": \"C\" in line[\"capabilities\"],\n            \"authenticate\": \"A\" in line[\"capabilities\"],\n        }\n        line[\"disabled\"] = \"D\" in line[\"capabilities\"]\n        line[\"revoked\"] = \"r\" in line[\"validity\"]\n\n        self._parse_dates(line)\n\n        return line\n\n    def _clean_curdata(self):\n        for v in self.curdata.keys():\n            if self.curdata[v] == \"\":\n                del self.curdata[v]\n        del self.curdata[\"record\"]\n\n    def parse_pubkey(self, line):\n        self.curkeyid = line[\"keyid\"]\n        self.curdata = self.keys[self.curkeyid] = self._parse_keydata(line)\n        self.curdata[\"subkeys\"] = []\n        self.curdata[\"uids\"] = []\n        self.curdata[\"secret\"] = (self.curdata[\"record\"] == \"sec\")\n        self.parse_uidline(self.curdata)\n        self._clean_curdata()\n\n    def parse_subkey(self, line):\n        self.curdata = self._parse_keydata(line)\n        self.keys[self.curkeyid][\"subkeys\"].append(self.curdata)\n        self._clean_curdata()\n\n    def parse_fingerprint(self, line):\n        fpr = line[\"uid\"]\n        self.curdata[\"fingerprint\"] = fpr\n        if len(self.curkeyid) < len(fpr):\n            self.keys[fpr] = self.keys[self.curkeyid]\n            del(self.keys[self.curkeyid])\n            self.curkeyid = fpr\n\n    def parse_userattribute(self, line):\n        # TODO: We are currently ignoring user attributes as not useful.\n        #       We may at some point want to use --attribute-fd and read\n        #       in user photos and such?\n        pass\n\n    def parse_privkey(self, line):\n        self.parse_pubkey(line)\n\n    def parse_uidline(self, line):\n        email, name, comment = parse_uid(line[\"uid\"])\n        self._parse_dates(line)\n        if email or name or comment:\n            self.keys[self.curkeyid][\"uids\"].append({\n                \"email\": email,\n                \"name\": name,\n                \"comment\": comment,\n                \"creation_date\": line[\"creation_date\"]\n            })\n        else:\n            pass  # This is the case where a uid or sec line have no\n                  # information aside from the creation date, which we\n                  # parse elsewhere. As these lines are effectively blank,\n                  # we omit them to simplify presentation to the user.\n\n    def parse_trust(self, line):\n        # FIXME: We are currently ignoring commentary from the Trust DB.\n        pass\n\n    def parse_signature(self, line):\n        # FIXME: This is probably wrong; signatures are on UIDs and not\n        #        the key itself. No? Yes? Figure this out.\n        if \"signatures\" not in self.keys[self.curkeyid]:\n            self.keys[self.curkeyid][\"signatures\"] = []\n        sig = {\n            \"signer\": line[9],\n            \"signature_date\": line[5],\n            \"keyid\": line[4],\n            \"trust\": line[10],\n            \"keytype\": line[4]\n        }\n        self.keys[self.curkeyid][\"signatures\"].append(sig)\n\n    def parse_keygrip(self, line):\n        self.curdata[\"keygrip\"] = line[\"uid\"]\n\n    def parse_revoke(self, line):\n        pass  # FIXME\n\n    def parse_revocation_key(self, line):\n        pass  # FIXME\n\n    def parse_unknown(self, line):\n        print \"Unknown line with code '%s'\" % (line,)\n\n    def parse_none(line):\n        pass\n\n\nUID_PARSE_RE = \"^([^\\(\\<]+?){0,1}( \\((.+?)\\)){0,1}( \\<(.+?)\\>){0,1}\\s*$\"\n\n\ndef stubborn_decode(text):\n    if isinstance(text, unicode):\n        return text\n    try:\n        return text.decode(\"utf-8\")\n    except UnicodeDecodeError:\n        try:\n            return text.decode(\"iso-8859-1\")\n        except UnicodeDecodeError:\n            return uidstr.decode(\"utf-8\", \"replace\")\n\n\ndef parse_uid(uidstr):\n    matches = re.match(UID_PARSE_RE, uidstr)\n    if matches:\n        email = matches.groups(0)[4] or \"\"\n        comment = matches.groups(0)[2] or \"\"\n        name = matches.groups(0)[0] or \"\"\n    else:\n        if '@' in uidstr and ' ' not in uidstr:\n            email, name = uidstr, \"\"\n        else:\n            email, name = \"\", uidstr\n        comment = \"\"\n\n    return email, name, comment\n\n\nclass StreamReader(Thread):\n    def __init__(self, name, fd, callback, lines=True):\n        Thread.__init__(self, target=self.readin, args=(fd, callback))\n        self.name = name\n        self.state = 'startup'\n        self.lines = lines\n        self.start()\n\n    def __str__(self):\n        return '%s(%s/%s, lines=%s)' % (Thread.__str__(self),\n                                        self.name, self.state, self.lines)\n\n    def readin(self, fd, callback):\n        try:\n            if self.lines:\n                self.state = 'read'\n                for line in iter(fd.readline, b''):\n                    self.state = 'callback'\n                    callback(line)\n                    self.state = 'read'\n            else:\n                while True:\n                    self.state = 'read'\n                    buf = fd.read(BLOCKSIZE)\n                    self.state = 'callback'\n                    callback(buf)\n                    if buf == \"\":\n                        break\n        except:\n            traceback.print_exc()\n        finally:\n            self.state = 'done'\n            fd.close()\n\n\nclass StreamWriter(Thread):\n    def __init__(self, name, fd, output, partial_write_ok=False):\n        Thread.__init__(self, target=self.writeout, args=(fd, output))\n        self.name = name\n        self.state = 'startup'\n        self.partial_write_ok = partial_write_ok\n        self.start()\n\n    def __str__(self):\n        return '%s(%s/%s)' % (Thread.__str__(self), self.name, self.state)\n\n    def writeout(self, fd, output):\n        if isinstance(output, (str, unicode)):\n            total = len(output)\n            output = StringIO.StringIO(output)\n        else:\n            total = 0\n        try:\n            while True:\n                self.state = 'read'\n                line = output.read(BLOCKSIZE)\n                if line == \"\":\n                    break\n                self.state = 'write'\n                fd.write(line)\n                total -= len(line)\n            output.close()\n        except:\n            if not self.partial_write_ok:\n                print '%s: %s bytes left' % (self, total)\n                traceback.print_exc()\n        finally:\n            self.state = 'done'\n            fd.close()\n\n\nDEBUG_GNUPG = False\n\nclass GnuPG:\n    \"\"\"\n    Wrap GnuPG and make all functionality feel Pythonic.\n    \"\"\"\n    ARMOR_BEGIN_SIGNED    = '-----BEGIN PGP SIGNED MESSAGE-----'\n    ARMOR_BEGIN_SIGNATURE = '-----BEGIN PGP SIGNATURE-----'\n    ARMOR_END_SIGNED      = '-----END PGP SIGNATURE-----'\n    ARMOR_END_SIGNATURE   = '-----END PGP SIGNATURE-----'\n\n    ARMOR_BEGIN_ENCRYPTED = '-----BEGIN PGP MESSAGE-----'\n    ARMOR_END_ENCRYPTED   = '-----END PGP MESSAGE-----'\n\n    ARMOR_BEGIN_PUB_KEY   = '-----BEGIN PGP PUBLIC KEY BLOCK-----'\n    ARMOR_END_PUB_KEY     = '-----END PGP PUBLIC KEY BLOCK-----'\n\n    LAST_KEY_USED = 'DEFAULT'  # This is a 1-value global cache\n\n    def __init__(self, config,\n                 session=None, use_agent=None, debug=False, dry_run=False,\n                 event=None, passphrase=None):\n        global DEBUG_GNUPG\n        self.available = None\n        self.outputfds = [\"stdout\", \"stderr\", \"status\"]\n        self.errors = []\n        self.event = GnuPGEventUpdater(event)\n        self.session = session\n        self.config = config or (session and session.config) or None\n        if self.config:\n            DEBUG_GNUPG = ('gnupg' in self.config.sys.debug)\n            self.homedir = self.config.sys.gpg_home or GNUPG_HOMEDIR\n            self.gpgbinary = self.config.sys.gpg_binary or GPG_BINARY\n            self.passphrases = self.config.passphrases\n            self.passphrase = (passphrase if (passphrase is not None) else\n                               self.passphrases['DEFAULT']).get_reader()\n            self.use_agent = (use_agent if (use_agent is not None)\n                              else self.config.prefs.gpg_use_agent)\n        else:\n            self.homedir = GNUPG_HOMEDIR\n            self.gpgbinary = GPG_BINARY\n            self.passphrases = None\n            if passphrase:\n                self.passphrase = passphrase.get_reader()\n            else:\n                self.passphrase = None\n            self.use_agent = use_agent\n        self.dry_run = dry_run\n        self.debug = (self._debug_all if (debug or DEBUG_GNUPG)\n                      else self._debug_none)\n\n    def prepare_passphrase(self, keyid, signing=False, decrypting=False):\n        \"\"\"Query the Mailpile secrets for a usable passphrase.\"\"\"\n        def _use(kid, sps_reader):\n            self.passphrase = sps_reader\n            GnuPG.LAST_KEY_USED = kid\n            return True\n\n        if self.config:\n            message = []\n            if decrypting:\n                message.append(_(\"Your PGP key is needed for decrypting.\"))\n            if signing:\n                message.append(_(\"Your PGP key is needed for signing.\"))\n            match, sps = self.config.get_passphrase(keyid,\n                prompt=_('Unlock your encryption key'),\n                description=' '.join(message))\n            if match:\n                return _use(match, sps.get_reader())\n\n        self.passphrase = None  # This *may* allow use of the GnuPG agent\n        return False\n\n    def _debug_all(self, msg):\n        if self.session:\n            self.session.debug(msg.rstrip())\n        else:\n            print '%s' % str(msg).rstrip()\n\n    def _debug_none(self, msg):\n        pass\n\n    def set_home(self, path):\n        self.homedir = path\n\n    def version(self):\n        \"\"\"Returns a string representing the GnuPG version number.\"\"\"\n        self.event.running_gpg(_('Checking GnuPG version'))\n        retvals = self.run([\"--version\"], novercheck=True)\n        return retvals[1][\"stdout\"][0].split('\\n')[0]\n\n    def version_tuple(self, update=False):\n        \"\"\"Returns a tuple representing the GnuPG version number.\"\"\"\n        global GPG_VERSIONS\n        if update or not GPG_VERSIONS.get(self.gpgbinary):\n            match = re.search( \"(\\d+).(\\d+).(\\d+)\", self.version() )\n            version = tuple(int(v) for v in match.groups())\n            GPG_VERSIONS[self.gpgbinary] = version\n        return GPG_VERSIONS[self.gpgbinary]\n\n    def gnupghome(self):\n        \"\"\"Returns the location of the GnuPG keyring\"\"\"\n        self.event.running_gpg(_('Checking GnuPG home directory'))\n        rv = self.run([\"--version\"], novercheck=True)[1][\"stdout\"][0]\n        for l in rv.splitlines():\n            if l.startswith('Home: '):\n                return os.path.expanduser(l[6:].strip())\n        return os.path.expanduser(os.getenv('GNUPGHOME', '~/.gnupg'))\n\n    def is_available(self):\n        try:\n            self.event.running_gpg(_('Checking GnuPG availability'))\n            self.version_tuple(update=True)\n            self.available = True\n        except OSError:\n            self.available = False\n\n        return self.available\n\n    def common_args(self, args=None, version=None, will_send_passphrase=False):\n        if args is None:\n            args = []\n        if version is None:\n            version = self.version_tuple()\n\n        args.insert(0, self.gpgbinary)\n        args.insert(1, \"--utf8-strings\")\n        args.insert(1, \"--with-colons\")\n        args.insert(1, \"--verbose\")\n        args.insert(1, \"--batch\")\n        args.insert(1, \"--enable-progress-filter\")\n\n        # Disable SHA1 in all things GnuPG\n        args[1:1] = [\"--personal-digest-preferences=SHA512\",\n                     \"--digest-algo=SHA512\",\n                     \"--cert-digest-algo=SHA512\"]\n\n        if (not self.use_agent) or will_send_passphrase:\n            if version < (1, 5):\n                args.insert(1, \"--no-use-agent\")\n            elif version > (2, 1, 11):\n                args.insert(1, \"--pinentry-mode=loopback\")\n            else:\n                raise ImportError('Mailpile requires GnuPG 1.4.x or 2.1.12+ !')\n\n        if self.homedir:\n            args.insert(1, \"--homedir=%s\" % self.homedir)\n\n        args.insert(1, \"--status-fd=2\")\n        if will_send_passphrase:\n            args.insert(2, \"--passphrase-fd=0\")\n\n        if self.dry_run:\n            args.insert(1, \"--dry-run\")\n\n        return args\n\n    def run(self,\n            args=None, gpg_input=None, outputfd=None, partial_read_ok=False,\n            send_passphrase=False, _raise=None, novercheck=False):\n        if novercheck:\n            version = (1, 4)\n        else:\n            version = self.version_tuple()\n\n        args = self.common_args(\n            args=list(args if args else []),\n            version=version,\n            will_send_passphrase=(self.passphrase and send_passphrase))\n\n        self.outputbuffers = dict([(x, []) for x in self.outputfds])\n        self.threads = {}\n        gpg_retcode = -1\n        proc = None\n        try:\n            if send_passphrase and (self.passphrase is None):\n                self.debug('Running WITHOUT PASSPHRASE %s' % ' '.join(args))\n                self.debug(''.join(traceback.format_stack()))\n            else:\n                self.debug('Running %s' % ' '.join(args))\n\n            # Here we go!\n            self.event.update_args(args)\n            proc = Popen(args, stdin=PIPE, stdout=PIPE, stderr=PIPE, bufsize=0)\n\n            # GnuPG is a bit crazy, and requires that the passphrase\n            # be sent and the filehandle closed before anything else\n            # interesting happens.\n            if send_passphrase and self.passphrase is not None:\n                self.passphrase.seek(0, 0)\n                c = self.passphrase.read(BLOCKSIZE)\n                while c != '':\n                    proc.stdin.write(c)\n                    c = self.passphrase.read(BLOCKSIZE)\n                proc.stdin.write('\\n')\n                self.event.update_sent_passphrase()\n\n            wtf = ' '.join(args)\n            self.threads = {\n                \"stderr\": StreamReader('gpgi-stderr(%s)' % wtf,\n                                       proc.stderr, self.parse_stderr)\n            }\n\n            if outputfd:\n                self.threads[\"stdout\"] = StreamReader(\n                    'gpgi-stdout-to-fd(%s)' % wtf,\n                    proc.stdout, outputfd.write, lines=False)\n            else:\n                self.threads[\"stdout\"] = StreamReader(\n                    'gpgi-stdout-parsed(%s)' % wtf,\n                    proc.stdout, self.parse_stdout)\n\n            if gpg_input:\n                # If we have output, we just stream it. Technically, this\n                # doesn't really need to be a thread at the moment.\n                self.debug('<<STDOUT<< %s' % gpg_input)\n                StreamWriter('gpgi-output(%s)' % wtf,\n                             proc.stdin, gpg_input,\n                             partial_write_ok=partial_read_ok).join()\n            else:\n                proc.stdin.close()\n\n            # Reap GnuPG\n            gpg_retcode = proc.wait()\n\n        finally:\n            # Close this so GPG will terminate. This should already have\n            # been done, but we're handling errors here...\n            if proc and proc.stdin:\n                proc.stdin.close()\n\n        # Update event with return code\n        self.event.update_return_code(gpg_retcode)\n\n        # Reap the threads\n        self._reap_threads()\n\n        if outputfd:\n            outputfd.close()\n\n        if gpg_retcode != 0 and _raise:\n            raise _raise('GnuPG failed, exit code: %s' % gpg_retcode)\n\n        return gpg_retcode, self.outputbuffers\n\n    def _reap_threads(self):\n        for tries in (1, 2, 3):\n            for name, thr in self.threads.iteritems():\n                if thr.isAlive():\n                    thr.join(timeout=15)\n                    if thr.isAlive() and tries > 1:\n                        print 'WARNING: Failed to reap thread %s' % thr\n\n    def parse_status(self, line, *args):\n        self.debug('<<STATUS<< %s' % line)\n        line = line.replace(\"[GNUPG:] \", \"\")\n        if line == \"\":\n            return\n        elems = line.split(\" \")\n        self.outputbuffers[\"status\"].append(elems)\n\n    def parse_stdout(self, line):\n        self.event.update_stdout(line)\n        self.debug('<<STDOUT<< %s' % line)\n        self.outputbuffers[\"stdout\"].append(line)\n\n    def parse_stderr(self, line):\n        self.event.update_stderr(line)\n        if line.startswith(\"[GNUPG:] \"):\n            return self.parse_status(line)\n        self.debug('<<STDERR<< %s' % line)\n        self.outputbuffers[\"stderr\"].append(line)\n\n    def parse_keylist(self, keylist):\n        rlp = GnuPGRecordParser()\n        return rlp.parse(keylist)\n\n    def list_keys(self, selectors=None):\n        \"\"\"\n        >>> g = GnuPG(None)\n        >>> g.list_keys()[0]\n        0\n        \"\"\"\n        list_keys = [\"--fingerprint\"]\n        for sel in set(selectors or []):\n            list_keys += [\"--list-keys\", sel]\n        if not selectors:\n            list_keys += [\"--list-keys\"]\n        self.event.running_gpg(_('Fetching GnuPG public key list (selectors=%s)'\n                                 ) % ', '.join(selectors or []))\n        retvals = self.run(list_keys)\n        return self.parse_keylist(retvals[1][\"stdout\"])\n\n    def list_secret_keys(self, selectors=None):\n        #\n        # Note: The selectors that are passed by default work around a bug\n        #       in GnuPG < 2.1, where --list-secret-keys does not list\n        #       details about key capabilities or expiry for\n        #       --list-secret-keys unless a selector is provided. A dot\n        #       is reasonably likely to appear in all PGP keys, as it is\n        #       a common component of e-mail addresses (and @ does not\n        #       work as a selector for some reason...)\n        #\n        #       The downside of this workaround is that keys with no e-mail\n        #       address or an address like alice@localhost won't be found.\n        #       So we disable this hack on GnuPG >= 2.1.\n        #\n        if not selectors and self.version_tuple() < (2, 1):\n            selectors = [\".\", \"a\", \"e\", \"i\", \"p\", \"t\", \"k\"]\n\n        list_keys = [\"--fingerprint\"]\n        if selectors:\n            for sel in selectors:\n                list_keys += [\"--list-secret-keys\", sel]\n        else:\n            list_keys += [\"--list-secret-keys\"]\n\n        self.event.running_gpg(_('Fetching GnuPG secret key list (selectors=%s)'\n                                 ) % ', '.join(selectors or ['None']))\n        retvals = self.run(list_keys)\n        secret_keys = self.parse_keylist(retvals[1][\"stdout\"])\n\n        # Another unfortunate thing GPG does, is it hides the disabled\n        # state when listing secret keys; it seems internally only the\n        # public key is disabled. This makes it hard for us to reason about\n        # which keys can actually be used, so we compensate...\n        # *** FIXME JackDca 2018-09-21 - Above behaviour not seen in 2.1.18 if\n        # --with-colons is used (but true for human-readable output) so this\n        # code could be deleted.\n        list_keys = [\"--fingerprint\"]\n        for fprint in set(secret_keys):\n            list_keys += [\"--list-keys\", fprint]\n        retvals = self.run(list_keys)\n        public_keys = self.parse_keylist(retvals[1][\"stdout\"])\n        for fprint, info in public_keys.iteritems():\n            if fprint in set(secret_keys):\n                for k in (\"disabled\", \"revoked\"):  # FIXME: Copy more?\n                    secret_keys[fprint][k] = info[k]\n\n        return secret_keys\n\n    def import_keys(self, key_data=None):\n        \"\"\"\n        Imports gpg keys from a file object or string.\n        >>> key_data = open(\"testing/pub.key\").read()\n        >>> g = GnuPG(None)\n        >>> g.import_keys(key_data)\n        {'failed': [], 'updated': [{'details_text': 'unchanged', 'details': 0, 'fingerprint': '08A650B8E2CBC1B02297915DC65626EED13C70DA'}], 'imported': [], 'results': {'sec_dups': 0, 'unchanged': 1, 'num_uids': 0, 'skipped_new_keys': 0, 'no_userids': 0, 'num_signatures': 0, 'num_revoked': 0, 'sec_imported': 0, 'sec_read': 0, 'not_imported': 0, 'count': 1, 'imported_rsa': 0, 'imported': 0, 'num_subkeys': 0}}\n        \"\"\"\n        self.event.running_gpg(_('Importing key to GnuPG key chain'))\n        retvals = self.run([\"--import\"], gpg_input=key_data)\n        return self._parse_import(retvals[1][\"status\"])\n\n    def _parse_import(self, output):\n        res = {\"imported\": [], \"updated\": [], \"failed\": []}\n        for x in output:\n            if x[0] == \"IMPORTED\":\n                res[\"imported\"].append({\n                    \"fingerprint\": x[1],\n                    \"username\": x[2].rstrip()\n                })\n            elif x[0] == \"IMPORT_OK\":\n                reasons = {\n                    \"0\": \"unchanged\",\n                    \"1\": \"new key\",\n                    \"2\": \"new user IDs\",\n                    \"4\": \"new signatures\",\n                    \"8\": \"new subkeys\",\n                    \"16\": \"contains private key\",\n                    \"17\": \"contains new private key\",\n                }\n                res[\"updated\"].append({\n                    \"details\": int(x[1]),\n                    # FIXME: Reasons may be ORed! This does NOT handle that.\n                    \"details_text\": reasons.get(x[1], str(x[1])),\n                    \"fingerprint\": x[2].rstrip(),\n                })\n            elif x[0] == \"IMPORT_PROBLEM\":\n                reasons = {\n                    \"0\": \"no reason given\",\n                    \"1\": \"invalid certificate\",\n                    \"2\": \"issuer certificate missing\",\n                    \"3\": \"certificate chain too long\",\n                    \"4\": \"error storing certificate\",\n                }\n                res[\"failed\"].append({\n                    \"details\": int(x[1]),\n                    \"details_text\": reasons.get(x[1], str(x[1])),\n                    \"fingerprint\": x[2].rstrip()\n                })\n            elif x[0] == \"IMPORT_RES\":\n                res[\"results\"] = {\n                    \"count\": int(x[1]),\n                    \"no_userids\": int(x[2]),\n                    \"imported\": int(x[3]),\n                    \"imported_rsa\": int(x[4]),\n                    \"unchanged\": int(x[5]),\n                    \"num_uids\": int(x[6]),\n                    \"num_subkeys\": int(x[7]),\n                    \"num_signatures\": int(x[8]),\n                    \"num_revoked\": int(x[9]),\n                    \"sec_read\": int(x[10]),\n                    \"sec_imported\": int(x[11]),\n                    \"sec_dups\": int(x[12]),\n                    \"skipped_new_keys\": int(x[13]),\n                    \"not_imported\": int(x[14].rstrip()),\n                }\n        return res\n\n    def decrypt(self, data,\n            outputfd=None, passphrase=None, as_lines=False, require_MDC=True):\n        \"\"\"\n        Note that this test will fail if you don't replace the recipient with\n        one whose key you control.\n        >>> g = GnuPG(None)\n        >>> ct = g.encrypt(\"Hello, World\", to=[\"smari@mailpile.is\"])[1]\n        >>> g.decrypt(ct)[\"text\"]\n        'Hello, World'\n        \"\"\"\n        if passphrase is not None:\n            self.passphrase = passphrase.get_reader()\n        elif GnuPG.LAST_KEY_USED:\n            # This is an opportunistic approach to passphrase usage... we\n            # just hope the passphrase we used last time will work again.\n            # If we are right, we are done. If we are wrong, the output\n            # will tell us which key IDs to look for in our secret stash.\n            self.prepare_passphrase(GnuPG.LAST_KEY_USED, decrypting=True)\n\n        self.event.running_gpg(_('Decrypting %d bytes of data') % len(data))\n        for tries in (1, 2):\n            retvals = self.run([\"--decrypt\"], gpg_input=data,\n                                              outputfd=outputfd,\n                                              send_passphrase=True)\n            if tries == 1:\n                keyid = None\n                for msg in reversed(retvals[1]['status']):\n                    # Reverse order so DECRYPTION_OKAY overrides KEY_CONSIDERED.\n                    # If decryption is not ok, look for good passphrase, retry.\n                    if  msg[0] == 'DECRYPTION_OKAY':\n                        break\n                    elif (msg[0] == 'NEED_PASSPHRASE') and (passphrase is None):\n                        # This message is output by gpg 1.4 but not 2.1.\n                        if self.prepare_passphrase(msg[2], decrypting=True):\n                            keyid = msg[2]\n                            break\n                    elif (msg[0] == 'KEY_CONSIDERED') and (passphrase is None):                       \n                        # This message is output by gpg 2.1 but not 1.4.\n                        if self.prepare_passphrase(msg[1], decrypting=True):\n                            keyid = msg[1]\n                            break\n                if not keyid:\n                    break\n\n        if as_lines:\n            as_lines = retvals[1][\"stdout\"]\n            retvals[1][\"stdout\"] = []\n\n        rp = GnuPGResultParser(decrypt_requires_MDC=require_MDC,\n                               debug=self.debug).parse(retvals)\n        return (rp.signature_info, rp.encryption_info,\n                as_lines or rp.plaintext)\n                \n    def base64_segment(self, dec_start, dec_end, skip, line_len, line_end = 2):\n        \"\"\"\n        Given the start and end index of a desired segment of decoded data,\n        this function finds smallest segment of an encoded base64 array that\n        when decoded will include the desired decoded segment.\n        It's assumed that the base64 data has a uniform line structure of\n        line_len encoded characters including line_end eol characters,\n        and that there are skip header characters preceding the base64 data.\n        \"\"\"\n        enc_start =  4*(dec_start/3)\n        dec_skip  =  dec_start - 3*enc_start/4\n        enc_start += line_end*(enc_start/(line_len-line_end))\n        enc_end =    4*(dec_end/3)\n        enc_end +=   line_end*(enc_end/(line_len-line_end))\n\n        return enc_start, enc_end, dec_skip\n        \n    def pgp_packet_hdr_parse(self, header, prev_partial = False):\n        \"\"\"\n        Parse the header of a PGP packet to get the packet type, header length,\n        and data length.  Extra trailing characters in header are ignored.\n        prev_partial indicates that the previous packet was a partial packet.\n        An illegal header returns type -1, lengths 0.\n        Header format is defined in RFC4880 section 4.\n        \"\"\"\n        hdr = bytearray(header.ljust( 6, chr(0)))\n        if not prev_partial:\n            hdr_len = 1\n        else:\n            hdr[1:] = hdr           # Partial block headers don't have a tag\n            hdr[0] = 0              # Insert a dummy tag.\n            hdr_len = 0\n        is_partial = False\n        \n        if prev_partial or (hdr[0] & 0xC0) == 0xC0:\n            # New format packet\n            ptag = hdr[0] & 0x3F\n            body_len = hdr[1]\n            lengthtype = 0\n            hdr_len += 1\n            if body_len < 192:\n                pass\n            elif body_len <= 223:\n                hdr_len += 1\n                body_len = ((body_len - 192) << 8) + hdr[2] + 192\n            elif body_len == 255:\n                hdr_len += 4\n                body_len =  ( (hdr[2] << 24) + (hdr[3] << 16) +\n                                (hdr[4] << 8)  + hdr[5] )\n            else:\n                # Partial packet headers are only legal for data packets.\n                if not prev_partial and not ptag in {8,9,11,18}:\n                    return (-1, 0, 0, False)\n                # Could do extra testing here.\n                is_partial = True\n                body_len = 1 << (hdr[1] & 0x1F)\n                \n        elif (hdr[0] & 0xC0) == 0x80:\n            # Old format packet\n            ptag = (hdr[0] & 0x3C) >> 2\n            lengthtype = hdr[0] & 0x03\n            if lengthtype < 3:\n                hdr_len = 2\n                body_len = hdr[1]\n                if lengthtype > 0:\n                    hdr_len = 3\n                    body_len = (body_len << 8) + hdr[2]\n                if lengthtype > 1:\n                    hdr_len = 5\n                    body_len = ( \n                        (body_len << 16) + (hdr[3] << 8) + hdr[4] )\n            else:\n                # Kludgy extra test for compressed packets w/ \"unknown\" length\n                # gpg generates these in signed-only files. Check for valid\n                # compression algorithm id to minimize false positives.\n                if ptag != 8 or (hdr[1] < 1 or hdr[1] > 3):\n                    return (-1, 0, 0, False)\n                hdr_len = 1\n                body_len = -1               \n        else:\n            return (-1, 0, 0, False)\n        \n        if hdr_len > len(header):\n            return (-1, 0, 0, False)    \n    \n        return ptag, hdr_len, body_len, is_partial\n\n\n    def sniff(self, data, encoding = None):\n        \"\"\"\n        Checks arbitrary data to see if it is a PGP object and returns a set\n        that indicates the kind(s) of object found. The names of the set\n        elements are based on RFC3156 content types with 'pgp-' stripped so\n        they can be used in sniffers for other protocols, e.g. S/MIME.\n        There are additional set elements 'armored' and 'unencrypted'.\n        \n        This code should give no false negatives, but may give false positives.\n        For efficient handling of encoded data, only small segments are decoded.\n        Armored files are detected by their armor header alone.\n        Non-armored data is detected by looking for a sequence of valid PGP\n        packet headers.\n        \"\"\"\n     \n        found = set()\n        is_base64 = False\n        is_quopri = False\n        line_len = 0\n        line_end = 1\n        enc_start = 0\n        enc_end = 0\n        dec_start = 0\n        skip = 0\n        ptag = 0\n        hdr_len = 0\n        body_len = 0\n        partial = False\n        offset_enc = 0\n        offset_dec = 0\n        offset_packet = 0\n        \n        # Identify encoding and base64 line length.                                      \n        if encoding and encoding.lower() == 'base64':\n            line_len = data.find('\\n') + 1          # Assume uniform length           \n            if line_len < 0:\n                line_len = len(data)\n            elif line_len > 1 and data[line_len-2] == '\\r':\n                line_end = 2\n            if line_len - line_end > 76:            # Maximum per RFC2045 6.8\n                return found \n            enc_end = line_len\n            try:\n                segment = base64.b64decode(data[enc_start:enc_end])\n            except TypeError:\n                return found\n            is_base64 = True\n                            \n        elif encoding and encoding.lower() == 'quoted-printable':\n            # Can't selectively decode quopri because encoded length is data\n            # dependent due to escapes!  Just decode one medium length segment.\n            # This is enough to contain the first few packets of a long file.\n            try:\n                segment = quopri.decodestring(data[0:1500])\n            except TypeError:                         \n                return found                # *** ? Docs don't list exceptions\n            is_quopri = True\n        else:\n            line_len = len(data)\n            segment = data                          # *** Shallow copy?\n                  \n        if not segment:\n            found = set()\n        elif not (ord(segment[0]) & 0x80):\n            # Not a PGP packet header if MSbit is 0.  Check for armoured data.\n            found.add('armored')\n            if segment.startswith(self.ARMOR_BEGIN_SIGNED):\n                # Clearsigned\n                found.add('unencrypted')                           \n                found.add('signature')                \n            elif segment.startswith(self.ARMOR_BEGIN_SIGNATURE):\n                # Detached signature\n                found.add('signature')                               \n            elif segment.startswith(self.ARMOR_BEGIN_ENCRYPTED):\n                # PGP uses the same armor header for encrypted and signed only\n                # Fortunately gpg --decrypt handles both!\n                found.add('encrypted')           \n            elif segment.startswith(self.ARMOR_BEGIN_PUB_KEY):\n                found.add('key')              \n            else:\n                found = set()\n        else:\n            # Could be PGP packet header. Check for sequence of legal headers.\n            while skip < len(segment) and body_len <> -1:\n                # Check this packet header.\n                prev_partial = partial\n                ptag, hdr_len, body_len, partial = ( \n                    self.pgp_packet_hdr_parse(segment[skip:], prev_partial) )\n                    \n                if prev_partial or partial:\n                    pass\n                elif ptag == 11:               \n                    found.add('unencrypted')    # Literal Data\n                elif ptag ==  1:\n                    found.add('encrypted')      # Encrypted Session Key\n                elif ptag ==  9:\n                    found.add('encrypted')      # Symmetrically Encrypted Data\n                elif ptag ==  18:\n                    found.add('encrypted')      # Symmetrically Encrypted & MDC\n                elif ptag ==  2:\n                    found.add('signature')      # Signature\n                elif ptag ==  4:\n                    found.add('signature')      # One-Pass Signature\n                elif ptag ==  6:\n                    found.add('key')            # Public Key\n                elif ptag ==  14:\n                    found.add('key')            # Public Subkey\n                elif ptag == 8:                 # Compressed Data Packet\n                    # This is a kludge.  Signed, non-encrypted files made by gpg\n                    # (but no other gpg files) consist of one compressed data\n                    # packet of unknown length which contains the signature\n                    # and data packets.\n                    # This appears to be an interpretation of RFC4880 2.3.\n                    # The compression prevents selective parsing of headers.\n                    # So such packets are assumed to be signed messages.\n                    if dec_start == 0 and body_len == -1: \n                        found.add('signature')\n                        found.add('unencrypted')                   \n                elif ptag < 0  or ptag > 19:\n                    found = set()\n                    return found\n                    \n                dec_start += hdr_len + body_len\n                skip = dec_start    \n                if is_base64 and body_len <> -1:    \n                    enc_start, enc_end, skip = self.base64_segment( dec_start, \n                                        dec_start + 6, 0, line_len, line_end )\n                    segment = base64.b64decode(data[enc_start:enc_end])\n \n            if is_base64 and body_len <> -1 and skip <> len(segment):\n                # End of last packet does not match end of data.\n                found = set()\n        return found\n    \n    \n    def remove_armor(self, text):\n        lines = text.strip().splitlines(True)\n        if lines[0].startswith(self.ARMOR_BEGIN_SIGNED):\n            for idx in reversed(range(0, len(lines))):\n                if lines[idx].startswith(self.ARMOR_BEGIN_SIGNATURE):\n                    lines = lines[:idx]\n                    while lines and lines[0].strip():\n                        lines.pop(0)\n                    break\n        return ''.join(lines).strip()\n\n    def verify(self, data, signature=None):\n        \"\"\"\n        >>> g = GnuPG(None)\n        >>> s = g.sign(\"Hello, World\", _from=\"smari@mailpile.is\",\n            clearsign=True)[1]\n        >>> g.verify(s)\n        \"\"\"\n        params = [\"--verify\"]\n        if signature:\n            sig = tempfile.NamedTemporaryFile()\n            sig.write(signature)\n            sig.flush()\n            params.append(sig.name)\n            params.append(\"-\")\n\n        self.event.running_gpg(_('Checking signature in %d bytes of data'\n                                 ) % len(data))\n        ret, retvals = self.run(params, gpg_input=data, partial_read_ok=True)\n\n        rp = GnuPGResultParser(debug=self.debug)\n        return rp.parse([None, retvals]).signature_info\n\n    def encrypt(self, data, tokeys=[], armor=True,\n                            sign=False, fromkey=None, throw_keyids=False):\n        \"\"\"\n        >>> g = GnuPG(None)\n        >>> g.encrypt(\"Hello, World\", to=[\"smari@mailpile.is\"])[0]\n        0\n        \"\"\"\n        if tokeys:\n            action = [\"--encrypt\", \"--yes\", \"--expert\",\n                      \"--trust-model\", \"always\"]\n            for r in tokeys:\n                action.append(\"--recipient\")\n                action.append(r)\n            action.extend([])\n            self.event.running_gpg(_('Encrypting %d bytes of data to %s'\n                                     ) % (len(data), ', '.join(tokeys)))\n        else:\n            action = [\"--symmetric\", \"--yes\", \"--expert\"]\n            self.event.running_gpg(_('Encrypting %d bytes of data with password'\n                                     ) % len(data))\n\n        if armor:\n            action.append(\"--armor\")\n        if sign:\n            action.append(\"--sign\")\n        if sign and fromkey:\n            action.append(\"--local-user\")\n            action.append(fromkey)\n        if throw_keyids:\n            action.append(\"--throw-keyids\")\n        if fromkey:\n            self.prepare_passphrase(fromkey, signing=True)\n\n        retvals = self.run(action, gpg_input=data,\n                           send_passphrase=(sign or not tokeys))\n\n        return retvals[0], \"\".join(retvals[1][\"stdout\"])\n\n    def sign(self, data,\n             fromkey=None, armor=True, detach=True, clearsign=False,\n             passphrase=None):\n        \"\"\"\n        >>> g = GnuPG(None)\n        >>> g.sign(\"Hello, World\", fromkey=\"smari@mailpile.is\")[0]\n        0\n        \"\"\"\n        if passphrase is not None:\n            self.passphrase = passphrase.get_reader()\n        if fromkey and passphrase is None:\n            self.prepare_passphrase(fromkey, signing=True)\n\n        if detach and not clearsign:\n            action = [\"--detach-sign\"]\n        elif clearsign:\n            action = [\"--clearsign\"]\n        else:\n            action = [\"--sign\"]\n        if armor:\n            action.append(\"--armor\")\n        if fromkey:\n            action.append(\"--local-user\")\n            action.append(fromkey)\n\n        self.event.running_gpg(_('Signing %d bytes of data with %s'\n                                 ) % (len(data), fromkey or _('default')))\n        retvals = self.run(action, gpg_input=data, send_passphrase=True)\n\n        self.passphrase = None\n        return retvals[0], \"\".join(retvals[1][\"stdout\"])\n\n    def sign_key(self, keyid, signingkey=None):\n        action = [\"--yes\", \"--sign-key\", keyid]\n        if signingkey:\n            action.insert(1, \"-u\")\n            action.insert(2, signingkey)\n\n        self.event.running_gpg(_('Signing key %s with %s'\n                                 ) % (keyid, signingkey or _('default')))\n        retvals = self.run(action, send_passphrase=True)\n\n        return retvals\n\n    def delete_key(self, key_fingerprint):\n        cmd = ['--yes', '--delete-secret-and-public-key', key_fingerprint]\n        return self.run(cmd)\n\n    def recv_key(self, keyid,\n                 keyservers=DEFAULT_KEYSERVERS,\n                 keyserver_options=DEFAULT_KEYSERVER_OPTIONS):\n        self.event.running_gpg(_('Downloading key %s from key servers'\n                                 ) % (keyid))\n        for keyserver in keyservers:\n            cmd = ['--keyserver', keyserver,\n                   '--recv-key', self._escape_hex_keyid_term(keyid)]\n            for opt in keyserver_options:\n                cmd[2:2] = ['--keyserver-options', opt]\n            retvals = self.run(cmd)\n            if 'unsupported' not in ''.join(retvals[1][\"stdout\"]):\n                break\n        return self._parse_import(retvals[1][\"status\"])\n\n    def search_key(self, term,\n                   keyservers=DEFAULT_KEYSERVERS,\n                   keyserver_options=DEFAULT_KEYSERVER_OPTIONS):\n        self.event.running_gpg(_('Searching for key for %s in key servers'\n                                 ) % (term))\n        for keyserver in keyservers:\n            cmd = ['--keyserver', keyserver,\n                   '--fingerprint',\n                   '--search-key', self._escape_hex_keyid_term(term)]\n            for opt in keyserver_options:\n                cmd[2:2] = ['--keyserver-options', opt]\n            retvals = self.run(cmd)\n            if 'unsupported' not in ''.join(retvals[1][\"stdout\"]):\n                break\n        results = {}\n        lines = [x.strip().split(\":\") for x in retvals[1][\"stdout\"]]\n        curpub = None\n        for line in lines:\n            if line[0] == \"info\":\n                pass\n            elif line[0] == \"pub\":\n                curpub = line[1]\n                validity = line[6]\n                if line[5]:\n                    if int(line[5]) < time.time():\n                        validity += 'e'\n                results[curpub] = {\n                    \"created\": datetime.fromtimestamp(int(line[4])),\n                    \"keytype_name\": _(openpgp_algorithms.get(int(line[2]),\n                                                             'Unknown')),\n                    \"keysize\": line[3],\n                    \"validity\": validity,\n                    \"uids\": [],\n                    \"fingerprint\": curpub\n                }\n            elif line[0] == \"uid\":\n                email, name, comment = parse_uid(line[1])\n                results[curpub][\"uids\"].append({\"name\": name,\n                                                \"email\": email,\n                                                \"comment\": comment})\n        return results\n\n    def get_pubkey(self, keyid):\n        return self.export_pubkeys(selectors=[keyid])\n\n    def export_pubkeys(self, selectors=None):\n        self.event.running_gpg(_('Exporting keys %s from keychain'\n                                 ) % (selectors,))\n        retvals = self.run(['--armor',\n                            '--export'] + (selectors or [])\n                            )[1][\"stdout\"]\n        return \"\".join(retvals)\n\n    def export_privkeys(self, selectors=None):\n        retvals = self.run(['--armor',\n                            '--export-secret-keys'] + (selectors or [])\n                            )[1][\"stdout\"]\n        return \"\".join(retvals)\n\n    def address_to_keys(self, address):\n        res = {}\n        keys = self.list_keys(selectors=[address])\n        for key, props in keys.iteritems():\n            if any([x[\"email\"] == address for x in props[\"uids\"]]):\n                res[key] = props\n\n        return res\n\n    def _escape_hex_keyid_term(self, term):\n        \"\"\"Prepends a 0x to hexadecimal key ids.\n\n        For example, D13C70DA is converted to 0xD13C70DA. This is required\n        by version 2.x of GnuPG (and is accepted by 1.x).\n        \"\"\"\n        is_hex_keyid = False\n        if len(term) == GPG_KEYID_LENGTH or len(term) == 2*GPG_KEYID_LENGTH:\n            hex_digits = set(string.hexdigits)\n            is_hex_keyid = all(c in hex_digits for c in term)\n\n        if is_hex_keyid:\n            return '0x%s' % term\n        else:\n            return term\n\n    def chat(self, gpg_args, callback, *args, **kwargs):\n        \"\"\"This lets a callback have a chat with the GPG process...\"\"\"\n        gpg_args = [self.gpgbinary,\n                    \"--utf8-strings\",\n                    # Disable SHA1 in all things GnuPG\n                    \"--personal-digest-preferences=SHA512\",\n                    \"--digest-algo=SHA512\",\n                    \"--cert-digest-algo=SHA512\",\n                    # We're not a human!\n                    \"--no-tty\",\n                    \"--command-fd=0\",\n                    \"--status-fd=1\"] + (gpg_args or [])\n        if self.homedir:\n            gpg_args.insert(1, \"--homedir=%s\" % self.homedir)\n\n        if self.version_tuple() > (2, 1):\n            gpg_args.insert(2, \"--pinentry-mode=loopback\")\n        else:\n            gpg_args.insert(2, \"--no-use-agent\")\n\n        proc = None\n        try:\n            # Here we go!\n            self.debug('Running %s' % ' '.join(gpg_args))\n            self.event.update_args(gpg_args)\n            proc = Popen(gpg_args, stdin=PIPE, stdout=PIPE, stderr=PIPE,\n                         bufsize=0, long_running=True)\n\n            return callback(proc, *args, **kwargs)\n        finally:\n            # Close this so GPG will terminate. This should already have\n            # been done, but we're handling errors here...\n            if proc and proc.stdin:\n                proc.stdin.close()\n            if proc:\n                self.event.update_return_code(proc.wait())\n            else:\n                self.event.update_return_code(-1)\n\n\ndef GetKeys(gnupg, config, people):\n    keys = []\n    missing = []\n    ambig = []\n\n    # First, we go to the contact database and get a list of keys.\n    for person in set(people):\n        if '#' in person:\n            keys.append(person.rsplit('#', 1)[1])\n        else:\n            vcard = config.vcards.get_vcard(person)\n            if vcard:\n                # It is the VCard's job to give us the best key first.\n                lines = [vcl for vcl in vcard.get_all('KEY')\n                         if vcl.value.startswith('data:application'\n                                                 '/x-pgp-fingerprint,')]\n                if len(lines) > 0:\n                    keys.append(lines[0].value.split(',', 1)[1])\n                else:\n                    missing.append(person)\n            else:\n                missing.append(person)\n\n    # Load key data from gnupg for use below\n    if keys:\n        all_keys = gnupg.list_keys(selectors=keys)\n    else:\n        all_keys = {}\n\n    if missing:\n        # Keys are missing, so we try to just search the keychain\n        all_keys.update(gnupg.list_keys(selectors=missing))\n        found = []\n        for key_id, key in all_keys.iteritems():\n            for uid in key.get(\"uids\", []):\n                if uid.get(\"email\", None) in missing:\n                    missing.remove(uid[\"email\"])\n                    found.append(uid[\"email\"])\n                    keys.append(key_id)\n                elif uid.get(\"email\", None) in found:\n                    ambig.append(uid[\"email\"])\n\n    # Next, we go make sure all those keys are really in our keychain.\n    fprints = all_keys.keys()\n    for key in keys:\n        key = key.upper()\n        if key.startswith('0x'):\n            key = key[2:]\n        if key not in fprints:\n            match = [k for k in fprints if k.endswith(key)]\n            if len(match) == 0:\n                missing.append(key)\n            elif len(match) > 1:\n                ambig.append(key)\n\n    if missing:\n        raise KeyLookupError(_('Keys missing for %s'\n                               ) % ', '.join(missing), missing)\n    elif ambig:\n        ambig = list(set(ambig))\n        raise KeyLookupError(_('Keys ambiguous for %s'\n                               ) % ', '.join(ambig), ambig)\n    return keys\n\n\nclass OpenPGPMimeSigningWrapper(MimeSigningWrapper):\n    CONTAINER_PARAMS = (('micalg', 'pgp-sha512'),\n                        ('protocol', 'application/pgp-signature'))\n    SIGNATURE_TYPE = 'application/pgp-signature'\n    SIGNATURE_DESC = 'OpenPGP Digital Signature'\n\n    def crypto(self):\n        return GnuPG(self.config, event=self.event)\n\n    def get_keys(self, who):\n        return GetKeys(self.crypto(), self.config, who)\n\n\nclass OpenPGPMimeEncryptingWrapper(MimeEncryptingWrapper):\n    CONTAINER_PARAMS = (('protocol', 'application/pgp-encrypted'), )\n    ENCRYPTION_TYPE = 'application/pgp-encrypted'\n    ENCRYPTION_VERSION = 1\n\n    # FIXME: Define _encrypt, allow throw_keyids\n\n    def crypto(self):\n        return GnuPG(self.config, event=self.event)\n\n    def get_keys(self, who):\n        return GetKeys(self.crypto(), self.config, who)\n\n\nclass OpenPGPMimeSignEncryptWrapper(OpenPGPMimeEncryptingWrapper):\n    CONTAINER_PARAMS = (('protocol', 'application/pgp-encrypted'), )\n    ENCRYPTION_TYPE = 'application/pgp-encrypted'\n    ENCRYPTION_VERSION = 1\n\n    def crypto(self):\n        return GnuPG(self.config)\n\n    def _encrypt(self, message_text, tokeys=None, armor=False):\n        from_key = self.get_keys([self.sender])[0]\n        # FIXME: Allow throw_keyids here.\n        return self.crypto().encrypt(message_text,\n                                     tokeys=tokeys, armor=True,\n                                     sign=True, fromkey=from_key)\n\n    def _update_crypto_status(self, part):\n        part.signature_info.part_status = 'verified'\n        part.encryption_info.part_status = 'decrypted'\n\n\nclass GnuPGExpectScript(threading.Thread):\n    STARTUP = 'Startup'\n    START_GPG = 'Start GPG'\n    FINISHED = 'Finished'\n    SCRIPT = []\n    VARIABLES = {}\n    DESCRIPTION = 'GnuPG Expect Script'\n    RUNNING_STATES = [STARTUP, START_GPG]\n\n    DEFAULT_TIMEOUT = 60 # Infinite wait isn't desirable\n\n    def __init__(self, gnupg,\n                 sps=None, event=None, variables={}, on_complete=None):\n        threading.Thread.__init__(self)\n        self.daemon = True\n        self._lock = threading.RLock()\n        self.before = ''\n        with self._lock:\n            self.state = self.STARTUP\n            self.gnupg = gnupg\n            self.event = event\n            self.variables = variables or self.VARIABLES\n            self._on_complete = [on_complete] if on_complete else []\n            self.main_script = self.SCRIPT[:]\n            self.sps = sps\n            if sps:\n                self.variables['passphrase'] = '!!<SPS'\n\n    def __str__(self):\n        return '%s: %s' % (threading.Thread.__str__(self), self.state)\n\n    running = property(lambda self: (self.state in self.RUNNING_STATES))\n    failed = property(lambda self: False)\n\n    def in_state(self, state):\n        pass\n\n    def set_state(self, state):\n        self.state = state\n        self.in_state(state)\n\n    def sendline(self, proc, line):\n        if line == '!!<SPS':\n            reader = self.sps.get_reader()\n            while True:\n                c = reader.read()\n                if c != '':\n                    proc.stdin.write(c)\n                else:\n                    proc.stdin.write('\\n')\n                    break\n        else:\n            proc.stdin.write(line.encode('utf-8'))\n            proc.stdin.write('\\n')\n\n    def _expecter(self, proc, exp, timebox):\n        while timebox[0] > 0:\n            self.before += proc.stdout.read(1)\n            if exp in self.before:\n                self.before = self.before.split(exp)[0]\n                return True\n        return False\n\n    def expect_exact(self, proc, exp, timeout=None):\n        from mailpile.util import RunTimed, TimedOut\n        timeout = timeout if (timeout and timeout > 0) else self.DEFAULT_TIMEOUT\n        timebox = [timeout]\n        self.before = ''\n        try:\n            self.gnupg.debug('Expect: %s' % exp)\n            if RunTimed(timeout, self._expecter, proc, exp, timebox):\n                return True\n            else:\n                raise TimedOut()\n        except TimedOut:\n            timebox[0] = 0\n            self.gnupg.debug('Timed out')\n            print 'Boo! %s not found in %s' % (exp, self.before)\n            raise\n\n    def run_script(self, proc, script):\n        for exp, rpl, tmo, state in script:\n            self.expect_exact(proc, exp, timeout=tmo)\n            if rpl:\n                self.sendline(proc, (rpl % self.variables).strip())\n            if state:\n                self.set_state(state)\n\n    def gpg_args(self):\n        return ['--no-use-agent', '--list-keys']\n\n    def run(self):\n        try:\n            self.set_state(self.START_GPG)\n            gpg = self.gnupg\n            gpg.event.running_gpg(_(self.DESCRIPTION) % self.variables)\n            gpg.chat(self.gpg_args(), self.run_script, self.main_script)\n            self.set_state(self.FINISHED)\n        except:\n            import traceback\n            traceback.print_exc()\n        finally:\n            with self._lock:\n                if self.state != self.FINISHED:\n                    self.state = 'Failed: ' + self.state\n                for name, callback in self._on_complete:\n                    callback()\n                self._on_complete = None\n\n    def on_complete(self, name, callback):\n        with self._lock:\n            if self._on_complete is not None:\n                if name not in [o[0] for o in self._on_complete]:\n                    self._on_complete.append((name, callback))\n            else:\n                callback()\n\n\nclass GnuPGBaseKeyGenerator(GnuPGExpectScript):\n    \"\"\"This is a background thread which generates a new PGP key.\"\"\"\n    AWAITING_LOCK = 'Pending keygen'\n    KEY_SETUP = 'Key Setup'\n    GATHER_ENTROPY = 'Creating key'\n    CREATED_KEY = 'Created key'\n    HAVE_KEY = 'Have Key'\n    VARIABLES = {\n        'keytype': '1',\n        'bits': '2048',\n        'name': 'Mailpile Generated Key',\n        'email': '',\n        'comment': 'www.mailpile.is',\n        'passphrase': 'mailpile'}\n    DESCRIPTION = _('Creating a %(bits)s bit GnuPG key')\n    RUNNING_STATES = (GnuPGExpectScript.RUNNING_STATES +\n                      [AWAITING_LOCK, KEY_SETUP, GATHER_ENTROPY, HAVE_KEY])\n\n    failed = property(lambda self: (not self.running and\n                                    not self.generated_key))\n\n    def __init__(self, *args, **kwargs):\n        super(GnuPGBaseKeyGenerator, self).__init__(*args, **kwargs)\n        self.generated_key = None\n\n    def in_state(self, state):\n        if state == self.HAVE_KEY:\n             self.generated_key = self.before.strip().split()[-1]\n\n    def run(self):\n        # In order to minimize risk of timeout during key generation (due to\n        # lack of entropy), we serialize them here using a global lock\n        self.set_state(self.AWAITING_LOCK)\n        self.event.message = _('Waiting to generate a %d bit GnuPG key.'\n                               % self.variables['bits'])\n        with ENTROPY_LOCK:\n            self.event.data['keygen_gotlock'] = 1\n            self.event.message = _('Generating new %d bit PGP key.'\n                                   % self.variables['bits'])\n            super(GnuPGBaseKeyGenerator, self).run()\n\n\nclass GnuPG14KeyGenerator(GnuPGBaseKeyGenerator):\n    \"\"\"This is the GnuPG 1.4x specific PGP key generation script.\"\"\"\n    B = GnuPGBaseKeyGenerator\n\n    # FIXME: If GnuPG starts asking for things in a different order,\n    #        we'll needlessly fail. To address this, we need to make\n    #        the expect logic smarter. For now, we just assume the GnuPG\n    #        team  will be hesitant to change things.\n\n    SCRIPT = [\n        ('GET_LINE keygen.algo',        '%(keytype)s',   -1, B.KEY_SETUP),\n        ('GET_LINE keygen.size',           '%(bits)s',   -1, None),\n        ('GET_LINE keygen.valid',                 '0',   -1, None),\n        ('GET_LINE keygen.name',           '%(name)s',   -1, None),\n        ('GET_LINE keygen.email',         '%(email)s',   -1, None),\n        ('GET_LINE keygen.comment',     '%(comment)s',   -1, None),\n        ('GET_HIDDEN passphrase',    '%(passphrase)s',   -1, None),\n        ('GOT_IT',                               None,   -1, B.GATHER_ENTROPY),\n        ('KEY_CREATED',                          None, 7200, B.CREATED_KEY),\n        ('\\n',                                   None,   -1, B.HAVE_KEY)]\n\n    def gpg_args(self):\n        return ['--no-use-agent', '--allow-freeform-uid', '--gen-key']\n\n\nclass GnuPG21KeyGenerator(GnuPG14KeyGenerator):\n    \"\"\"This is the GnuPG 2.1.x specific PGP key generation script.\"\"\"\n\n    # Note: We don't use the nice --quick-generate-key function, because\n    #       it won't let us generate a usable key with custom parameters in\n    #       a single pass. So using the existing expect logic turns out to\n    #       be less work in practice. Oh well.\n\n    def gpg_args(self):\n        # --yes should keep GnuPG from complaining if there already exists\n        #       a key with this UID.\n        return ['--yes', '--allow-freeform-uid', '--full-gen-key']\n\n\nclass GnuPGDummyKeyGenerator(GnuPGBaseKeyGenerator):\n    \"\"\"A dummy key generator class, for incompatible versions of GnuPG.\"\"\"\n\n    DESCRIPTION = _('Unable to create a %(bits)s bit key, wrong GnuPG version')\n\n    def __init__(self, *args, **kwargs):\n        GnuPGBaseKeyGenerator.__init__(self, *args, **kwargs)\n        self.generated_key = False\n\n    def run(self):\n        with self._lock:\n            self.gnupg.event.running_gpg(_(self.DESCRIPTION) % self.variables)\n            self.set_state(self.FINISHED)\n            for name, callback in self._on_complete:\n                callback()\n            self._on_complete = None\n\n\ndef GnuPGKeyGenerator(gnupg, **kwargs):\n    \"\"\"Return an instanciated generator, depending on GnuPG version.\"\"\"\n    version = gnupg.version_tuple()\n    if version < (1, 5):\n        return GnuPG14KeyGenerator(gnupg, **kwargs)\n    elif version >= (2, 1):\n        return GnuPG21KeyGenerator(gnupg, **kwargs)\n    else:\n        return GnuPGDummyKeyGenerator(gnupg, **kwargs)\n\n\n# Reset our translation variable\n_ = gettext\n\n## Include the SKS keyserver certificate here ##\nKEYSERVER_CERTIFICATE=\"\"\"\n-----BEGIN CERTIFICATE-----\nMIIFizCCA3OgAwIBAgIJAK9zyLTPn4CPMA0GCSqGSIb3DQEBBQUAMFwxCzAJBgNV\nBAYTAk5PMQ0wCwYDVQQIDARPc2xvMR4wHAYDVQQKDBVza3Mta2V5c2VydmVycy5u\nZXQgQ0ExHjAcBgNVBAMMFXNrcy1rZXlzZXJ2ZXJzLm5ldCBDQTAeFw0xMjEwMDkw\nMDMzMzdaFw0yMjEwMDcwMDMzMzdaMFwxCzAJBgNVBAYTAk5PMQ0wCwYDVQQIDARP\nc2xvMR4wHAYDVQQKDBVza3Mta2V5c2VydmVycy5uZXQgQ0ExHjAcBgNVBAMMFXNr\ncy1rZXlzZXJ2ZXJzLm5ldCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC\nggIBANdsWy4PXWNUCkS3L//nrd0GqN3dVwoBGZ6w94Tw2jPDPifegwxQozFXkG6I\n6A4TK1CJLXPvfz0UP0aBYyPmTNadDinaB9T4jIwd4rnxl+59GiEmqkN3IfPsv5Jj\nMkKUmJnvOT0DEVlEaO1UZIwx5WpfprB3mR81/qm4XkAgmYrmgnLXd/pJDAMk7y1F\n45b5zWofiD5l677lplcIPRbFhpJ6kDTODXh/XEdtF71EAeaOdEGOvyGDmCO0GWqS\nFDkMMPTlieLA/0rgFTcz4xwUYj/cD5e0ZBuSkYsYFAU3hd1cGfBue0cPZaQH2HYx\nQk4zXD8S3F4690fRhr+tki5gyG6JDR67aKp3BIGLqm7f45WkX1hYp+YXywmEziM4\naSbGYhx8hoFGfq9UcfPEvp2aoc8u5sdqjDslhyUzM1v3m3ZGbhwEOnVjljY6JJLx\nMxagxnZZSAY424ZZ3t71E/Mn27dm2w+xFRuoy8JEjv1d+BT3eChM5KaNwrj0IO/y\nu8kFIgWYA1vZ/15qMT+tyJTfyrNVV/7Df7TNeWyNqjJ5rBmt0M6NpHG7CrUSkBy9\np8JhimgjP5r0FlEkgg+lyD+V79H98gQfVgP3pbJICz0SpBQf2F/2tyS4rLm+49rP\nfcOajiXEuyhpcmzgusAj/1FjrtlynH1r9mnNaX4e+rLWzvU5AgMBAAGjUDBOMB0G\nA1UdDgQWBBTkwyoJFGfYTVISTpM8E+igjdq28zAfBgNVHSMEGDAWgBTkwyoJFGfY\nTVISTpM8E+igjdq28zAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4ICAQAR\nOXnYwu3g1ZjHyley3fZI5aLPsaE17cOImVTehC8DcIphm2HOMR/hYTTL+V0G4P+u\ngH+6xeRLKSHMHZTtSBIa6GDL03434y9CBuwGvAFCMU2GV8w92/Z7apkAhdLToZA/\nX/iWP2jeaVJhxgEcH8uPrnSlqoPBcKC9PrgUzQYfSZJkLmB+3jEa3HKruy1abJP5\ngAdQvwvcPpvYRnIzUc9fZODsVmlHVFBCl2dlu/iHh2h4GmL4Da2rRkUMlbVTdioB\nUYIvMycdOkpH5wJftzw7cpjsudGas0PARDXCFfGyKhwBRFY7Xp7lbjtU5Rz0Gc04\nlPrhDf0pFE98Aw4jJRpFeWMjpXUEaG1cq7D641RpgcMfPFvOHY47rvDTS7XJOaUT\nBwRjmDt896s6vMDcaG/uXJbQjuzmmx3W2Idyh3s5SI0GTHb0IwMKYb4eBUIpQOnB\ncE77VnCYqKvN1NVYAqhWjXbY7XasZvszCRcOG+W3FqNaHOK/n/0ueb0uijdLan+U\nf4p1bjbAox8eAOQS/8a3bzkJzdyBNUKGx1BIK2IBL9bn/HravSDOiNRSnZ/R3l9G\nZauX0tu7IIDlRCILXSyeazu0aj/vdT3YFQXPcvt5Fkf5wiNTo53f72/jYEJd6qph\nWrpoKqrwGwTpRUCMhYIUt65hsTxCiJJ5nKe39h46sg==\n-----END CERTIFICATE-----\n\"\"\"\n", "import datetime\nimport re\nimport time\nimport urllib2\nfrom email import encoders\nfrom email.mime.base import MIMEBase\n\nimport mailpile.security as security\nfrom mailpile.conn_brokers import Master as ConnBroker\nfrom mailpile.i18n import gettext as _\nfrom mailpile.i18n import ngettext as _n\nfrom mailpile.commands import Command\nfrom mailpile.crypto.gpgi import GnuPG\nfrom mailpile.crypto.gpgi import OpenPGPMimeSigningWrapper\nfrom mailpile.crypto.gpgi import OpenPGPMimeEncryptingWrapper\nfrom mailpile.crypto.gpgi import OpenPGPMimeSignEncryptWrapper\nfrom mailpile.crypto.mime import UnwrapMimeCrypto, MessageAsString\nfrom mailpile.crypto.mime import OBSCURE_HEADERS_MILD, OBSCURE_HEADERS_EXTREME\nfrom mailpile.crypto.mime import ObscureSubject\nfrom mailpile.crypto.state import EncryptionInfo, SignatureInfo\nfrom mailpile.eventlog import GetThreadEvent\nfrom mailpile.mailutils.addresses import AddressHeaderParser\nfrom mailpile.mailutils.emails import Email, MakeContentID, ClearParseCache\nfrom mailpile.plugins import PluginManager, EmailTransform\nfrom mailpile.plugins.vcard_gnupg import PGPKeysImportAsVCards\nfrom mailpile.plugins.search import Search\n\n_plugins = PluginManager(builtin=__file__)\n\n\n##[ GnuPG e-mail processing ]#################################################\n\nclass ContentTxf(EmailTransform):\n    def _wrap_key_in_html(self, title, keydata):\n        return ((\n            \"<html><head><meta charset='utf-8'></head><body>\\n\"\n            \"<h1>%(title)s</h1><p>\\n\\n%(description)s\\n\\n</p>\"\n            \"<pre>\\n%(key)s\\n</pre><hr>\"\n            \"<i><a href='%(ad_url)s'>%(ad)s</a>.</i></body></html>\"\n            ) % self._wrap_key_in_html_vars(title, keydata)).encode('utf-8')\n\n    def _wrap_key_in_html_vars(self, title, keydata):\n        return {\n            \"title\": title,\n            \"description\": _(\n                \"This is a digital encryption key, which you can use to send\\n\"\n                \"confidential messages to the owner, or to verify their\\n\"\n                \"digital signatures. You can safely discard or ignore this\\n\"\n                \"file if you do not use e-mail encryption or signatures.\"),\n            \"ad\": _(\"Generated by Mailpile and GnuPG\"),\n            \"ad_url\": \"https://www.mailpile.is/\",  # FIXME: Link to help?\n            \"key\": keydata}\n\n    def TransformOutgoing(self, sender, rcpts, msg, **kwargs):\n        matched = False\n        gnupg = None\n        sender_keyid = None\n\n        # Prefer to just get everything from the profile VCard, in the\n        # common case...\n        profile = self._get_sender_profile(sender, kwargs)\n        if profile['vcard'] is not None:\n            sender_keyid = profile['vcard'].pgp_key\n        crypto_format = profile.get('crypto_format') or 'none'\n\n        # Parse the openpgp_header data from the crypto_format\n        openpgp_header = [p.split(':')[-1]\n                          for p in crypto_format.split('+')\n                          if p.startswith('openpgp_header:')]\n        if not openpgp_header:\n            openpgp_header = self.config.prefs.openpgp_header and ['CFG']\n\n        if openpgp_header[0] != 'N' and not sender_keyid:\n            # This is a fallback: this shouldn't happen much in normal use\n            try:\n                gnupg = gnupg or GnuPG(self.config, event=GetThreadEvent())\n                seckeys = dict([(uid[\"email\"], fp) for fp, key\n                                in gnupg.list_secret_keys().iteritems()\n                                if key[\"capabilities_map\"].get(\"encrypt\")\n                                and key[\"capabilities_map\"].get(\"sign\")\n                                for uid in key[\"uids\"]])\n                sender_keyid = seckeys.get(sender)\n            except (KeyError, TypeError, IndexError, ValueError):\n                traceback.print_exc()\n\n        if sender_keyid and openpgp_header:\n            preference = {\n                'ES': 'signencrypt',\n                'SE': 'signencrypt',\n                'E': 'encrypt',\n                'S': 'sign',\n                'N': 'unprotected',\n                'CFG': self.config.prefs.openpgp_header\n            }[openpgp_header[0].upper()]\n            msg[\"OpenPGP\"] = (\"id=%s; preference=%s\"\n                              % (sender_keyid, preference))\n\n        if ('attach-pgp-pubkey' in msg and\n                msg['attach-pgp-pubkey'][:3].lower() in ('yes', 'tru')):\n            gnupg = gnupg or GnuPG(self.config, event=GetThreadEvent())\n            if sender_keyid:\n                keys = gnupg.list_keys(selectors=[sender_keyid])\n            else:\n                keys = gnupg.address_to_keys(AddressHeaderParser(sender).addresses_list()[0])\n\n            key_count = 0\n            for fp, key in keys.iteritems():\n                if not any(key[\"capabilities_map\"].values()):\n                    continue\n                # We should never really hit this more than once. But if we\n                # do, should still be fine.\n                keyid = key[\"keyid\"]\n                data = gnupg.get_pubkey(keyid)\n\n                try:\n                    from_name = key[\"uids\"][0][\"name\"]\n                    filename = _('Encryption key for %s') % from_name\n                except:\n                    filename = _('My encryption key')\n\n                if self.config.prefs.gpg_html_wrap:\n                    data = self._wrap_key_in_html(filename, data)\n                    ext = 'html'\n                else:\n                    ext = 'asc'\n\n                att = MIMEBase('application', 'pgp-keys')\n                att.set_payload(data)\n                encoders.encode_base64(att)\n                del att['MIME-Version']\n                att.add_header('Content-Id', MakeContentID())\n                att.add_header('Content-Disposition', 'attachment',\n                               filename=filename + '.' + ext)\n                att.signature_info = SignatureInfo(parent=msg.signature_info)\n                att.encryption_info = EncryptionInfo(parent=msg.encryption_info)\n                msg.attach(att)\n                key_count += 1\n\n            if key_count > 0:\n                msg['x-mp-internal-pubkeys-attached'] = \"Yes\"\n\n        return sender, rcpts, msg, matched, True\n\nclass CryptoTxf(EmailTransform):\n    def TransformOutgoing(self, sender, rcpts, msg,\n                          crypto_policy='none',\n                          crypto_format='default',\n                          cleaner=lambda m: m,\n                          **kwargs):\n        matched = False\n        if 'pgp' in crypto_policy or 'gpg' in crypto_policy:\n            wrapper = None\n\n            # Set defaults\n            prefer_inline = kwargs.get('prefer_inline', False)\n            if 'obscure_all_meta' in crypto_format:\n                obscured = OBSCURE_HEADERS_EXTREME\n            elif 'obscure_meta' in crypto_format:\n                obscured = OBSCURE_HEADERS_MILD\n            elif self.config.prefs.encrypt_subject:\n                obscured = {'subject': ObscureSubject}\n            else:\n                obscured = {}\n\n            if 'sign' in crypto_policy and 'encrypt' in crypto_policy:\n                wrapper = OpenPGPMimeSignEncryptWrapper\n                prefer_inline = 'prefer_inline' in crypto_format\n            elif 'encrypt' in crypto_policy:\n                wrapper = OpenPGPMimeEncryptingWrapper\n                prefer_inline = 'prefer_inline' in crypto_format\n            elif 'sign' in crypto_policy:\n                # When signing only, we 1) prefer inline by default, based\n                # on this: https://github.com/mailpile/Mailpile/issues/1693\n                # and 2) don't obscure any headers as that's pointless.\n                wrapper = OpenPGPMimeSigningWrapper\n                prefer_inline = 'pgpmime' not in crypto_format\n                obscured = {}\n\n            if wrapper:\n                msg = wrapper(self.config,\n                              sender=sender,\n                              cleaner=cleaner,\n                              recipients=rcpts,\n                              use_html_wrapper=self.config.prefs.gpg_html_wrap,\n                              obscured_headers=obscured\n                              ).wrap(msg, prefer_inline=prefer_inline)\n                matched = True\n\n        return sender, rcpts, msg, matched, (not matched)\n\n\n_plugins.register_outgoing_email_content_transform('500_gnupg', ContentTxf)\n_plugins.register_outgoing_email_crypto_transform('500_gnupg', CryptoTxf)\n\n##[ Misc. GPG-related API commands ]##########################################\n\nclass GPGKeySearch(Command):\n    \"\"\"Search for a GPG Key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/searchkey', 'crypto/gpg/searchkey', '<terms>')\n    HTTP_CALLABLE = ('GET', )\n    HTTP_QUERY_VARS = {'q': 'search terms'}\n\n    class CommandResult(Command.CommandResult):\n        def as_text(self):\n            if self.result:\n                return '\\n'.join([\"%s: %s <%s>\" % (keyid, x[\"name\"], x[\"email\"]) for keyid, det in self.result.iteritems() for x in det[\"uids\"]])\n            else:\n                return _(\"No results\")\n\n    def command(self):\n        args = list(self.args)\n        for q in self.data.get('q', []):\n            args.extend(q.split())\n\n        return self._gnupg().search_key(\" \".join(args))\n\n\nclass GPGKeyReceive(Command):\n    \"\"\"Fetch a GPG Key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/receivekey', 'crypto/gpg/receivekey', '<keyid>')\n    HTTP_CALLABLE = ('POST', )\n    HTTP_QUERY_VARS = {'keyid': 'ID of key to fetch'}\n    COMMAND_SECURITY = security.CC_CHANGE_GNUPG\n\n    def command(self):\n        keyid = self.data.get(\"keyid\", self.args)\n        res = []\n        for key in keyid:\n            res.append(self._gnupg().recv_key(key))\n\n        # Previous crypto evaluations may now be out of date, so we\n        # clear the cache so users can see results right away.\n        ClearParseCache(pgpmime=True)\n\n        return res\n\n\nclass GPGKeyImport(Command):\n    \"\"\"Import a GPG Key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/importkey', 'crypto/gpg/importkey',\n                '<key_file>')\n    HTTP_CALLABLE = ('POST', )\n    HTTP_QUERY_VARS = {\n        'key_data': 'ASCII armor of public key to be imported',\n        'key_file': 'Location of file containing the public key',\n        'key_url': 'URL of file containing the public key',\n        'name': '(ignored)'\n    }\n    COMMAND_SECURITY = security.CC_CHANGE_GNUPG\n\n    def command(self):\n        key_files = self.data.get(\"key_file\", []) + [a for a in self.args\n                                                     if not '://' in a]\n        key_urls = self.data.get(\"key_url\", []) + [a for a in self.args\n                                                   if '://' in a]\n        key_data = []\n        key_data.extend(self.data.get(\"key_data\", []))\n        for key_file in key_files:\n            with open(key_file) as file:\n                key_data.append(file.read())\n        for key_url in key_urls:\n            with ConnBroker.context(need=[ConnBroker.OUTGOING_HTTP]):\n                uo = urllib2.urlopen(key_url)\n            key_data.append(uo.read())\n\n        rv = self._gnupg().import_keys('\\n'.join(key_data))\n\n        # Previous crypto evaluations may now be out of date, so we\n        # clear the cache so users can see results right away.\n        ClearParseCache(pgpmime=True)\n\n        # Update the VCards!\n        PGPKeysImportAsVCards(self.session,\n                              arg=([i['fingerprint'] for i in rv['updated']] +\n                                   [i['fingerprint'] for i in rv['imported']])\n                              ).run()\n\n        return self._success(_(\"Imported %d keys\") % len(key_data), rv)\n\n\nclass GPGKeySign(Command):\n    \"\"\"Sign a key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/signkey', 'crypto/gpg/signkey', '<keyid> [<signingkey>]')\n    HTTP_CALLABLE = ('POST',)\n    HTTP_QUERY_VARS = {'keyid': 'The key to sign',\n                       'signingkey': 'The key to sign with'}\n    COMMAND_SECURITY = security.CC_CHANGE_GNUPG\n\n    def command(self):\n        signingkey = None\n        keyid = None\n        args = list(self.args)\n        try: keyid = args.pop(0)\n        except: keyid = self.data.get(\"keyid\", None)\n        try: signingkey = args.pop(0)\n        except: signingkey = self.data.get(\"signingkey\", None)\n\n        print keyid\n        if not keyid:\n            return self._error(\"You must supply a keyid\", None)\n        rv = self._gnupg().sign_key(keyid, signingkey)\n\n        # Previous crypto evaluations may now be out of date, so we\n        # clear the cache so users can see results right away.\n        ClearParseCache(pgpmime=True)\n\n        return rv\n\n\nclass GPGKeyImportFromMail(Search):\n    \"\"\"Import a GPG Key.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/importkeyfrommail',\n                'crypto/gpg/importkeyfrommail', '<mid>')\n    HTTP_CALLABLE = ('POST', )\n    HTTP_QUERY_VARS = {'mid': 'Message ID', 'att': 'Attachment ID'}\n    COMMAND_CACHE_TTL = 0\n    COMMAND_SECURITY = security.CC_CHANGE_GNUPG\n\n    class CommandResult(Command.CommandResult):\n        def __init__(self, *args, **kwargs):\n            Command.CommandResult.__init__(self, *args, **kwargs)\n\n        def as_text(self):\n            if self.result:\n                return \"Imported %d keys (%d updated, %d unchanged) from the mail\" % (\n                    self.result[\"results\"][\"count\"],\n                    self.result[\"results\"][\"imported\"],\n                    self.result[\"results\"][\"unchanged\"])\n            return \"\"\n\n    def command(self):\n        session, config, idx = self.session, self.session.config, self._idx()\n        args = list(self.args)\n        if args and args[-1][0] == \"#\":\n            attid = args.pop()\n        else:\n            attid = self.data.get(\"att\", 'application/pgp-keys')\n        args.extend([\"=%s\" % x for x in self.data.get(\"mid\", [])])\n        eids = self._choose_messages(args)\n        if len(eids) < 0:\n            return self._error(\"No messages selected\", None)\n        elif len(eids) > 1:\n            return self._error(\"One message at a time, please\", None)\n\n        email = Email(idx, list(eids)[0])\n        fn, attr = email.extract_attachment(session, attid, mode='inline')\n        if attr and attr[\"data\"]:\n            res = self._gnupg().import_keys(attr[\"data\"])\n\n            # Previous crypto evaluations may now be out of date, so we\n            # clear the cache so users can see results right away.\n            ClearParseCache(pgpmime=True)\n\n            return self._success(\"Imported key\", res)\n\n        return self._error(\"No results found\", None)\n\n\nclass GPGKeyList(Command):\n    \"\"\"List GPG Keys.\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/keylist',\n                'crypto/gpg/keylist', '<address>')\n    HTTP_CALLABLE = ('GET', )\n    HTTP_QUERY_VARS = {'address': 'E-mail address'}\n\n    def command(self):\n        args = list(self.args)\n        if len(args) > 0:\n            addr = args[0]\n        else:\n            addr = self.data.get(\"address\", None)\n\n        if addr is None:\n            return self._error(\"Must supply e-mail address\", None)\n\n        res = self._gnupg().address_to_keys(addr)\n        return self._success(\"Searched for keys for e-mail address\", res)\n\n\nclass GPGKeyListSecret(Command):\n    \"\"\"List Secret GPG Keys\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/keylist/secret',\n                                    'crypto/gpg/keylist/secret', '[<check>]')\n    HTTP_CALLABLE = ('GET', )\n    HTTP_QUERY_VARS = {'check': 'True to omit disabled, expired, revoked keys'}\n\n    def command(self):\n        args = list(self.args)\n        if len(args) > 0:\n            check = args[0]\n        else:\n            check = self.data.get('check', '')\n        check = 'True' in check\n        \n        all = self._gnupg().list_secret_keys()\n        if check:\n            res = {fprint : all[fprint] for fprint in all\n                if not (all[fprint]['revoked'] or all[fprint]['disabled'])}\n        else:\n            res = all\n        return self._success(\"Searched for secret keys\", res)\n\n\nclass GPGUsageStatistics(Search):\n    \"\"\"Get usage statistics from mail, given an address\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/statistics',\n                'crypto/gpg/statistics', '<address>')\n    HTTP_CALLABLE = ('GET', )\n    HTTP_QUERY_VARS = {'address': 'E-mail address'}\n    COMMAND_CACHE_TTL = 0\n\n    class CommandResult(Command.CommandResult):\n        def __init__(self, *args, **kwargs):\n            Command.CommandResult.__init__(self, *args, **kwargs)\n\n        def as_text(self):\n            if self.result:\n                return \"%d%% of e-mail from %s has PGP signatures (%d/%d)\" % (\n                    100*self.result[\"ratio\"],\n                    self.result[\"address\"],\n                    self.result[\"pgpsigned\"],\n                    self.result[\"messages\"])\n            return \"\"\n\n    def command(self):\n        args = list(self.args)\n        if len(args) > 0:\n            addr = args[0]\n        else:\n            addr = self.data.get(\"address\", None)\n\n        if addr is None:\n            return self._error(\"Must supply an address\", None)\n\n        session, idx = self._do_search(search=[\"from:%s\" % addr])\n        total = 0\n        for messageid in session.results:\n            total += 1\n\n        session, idx = self._do_search(search=[\"from:%s\" % addr,  \"has:pgp\"])\n        pgp = 0\n        for messageid in session.results:\n            pgp += 1\n\n        if total > 0:\n            ratio = float(pgp)/total\n        else:\n            ratio = 0\n\n        res = {\"messages\": total,\n               \"pgpsigned\": pgp,\n               \"ratio\": ratio,\n               \"address\": addr}\n\n        return self._success(\"Got statistics for address\", res)\n\n\nclass GPGCheckKeys(Search):\n    \"\"\"Sanity check your keys and profiles\"\"\"\n    ORDER = ('', 0)\n    SYNOPSIS = (None, 'crypto/gpg/check_keys', 'crypto/gpg/check_keys',\n                '[--all-keys]')\n    HTTP_CALLABLE = ('GET', )\n    COMMAND_CACHE_TTL = 0\n\n    MIN_KEYSIZE = 2048\n\n    class CommandResult(Command.CommandResult):\n        def __init__(self, *args, **kwargs):\n            Command.CommandResult.__init__(self, *args, **kwargs)\n\n        def as_text(self):\n            if not isinstance(self.result, (dict,)):\n                return ''\n            if self.result.get('details'):\n                message = '%s.\\n - %s' % (self.message, '\\n - '.join(\n                    p['description'] for p in self.result['details']\n                ))\n            else:\n                message = '%s. %s' % (self.message, _('Looks good!'))\n            if self.result.get('fixes'):\n                message += '\\n\\n%s\\n - %s' % (_('Proposed fixes:'),\n                                            '\\n - '.join(\n                    '\\n    * '.join(f) for f in self.result['fixes']\n                ))\n            return message\n\n    def _fix_gen_key(self, min_bits=2048):\n        return [\n            _(\"You need a new key!\"),\n            _(\"Run: %s\") % '`gpg --gen-key`',\n            _(\"Answer the tool\\'s questions: use RSA and RSA, %d bits or more\"\n              ) % min_bits]\n\n    def _fix_mp_config(self, good_key=None):\n        fprint = (good_key['fingerprint'] if good_key else '<FINGERPRINT>')\n        return [\n           _('Update the Mailpile config to use a good key:'),\n           _('IMPORTANT: This MUST be done before disabling the key!'),\n           _('Run: %s') % ('`set prefs.gpg_recipient = %s`' % fprint),\n           _('Run: %s') % ('`optimize`'),\n           _('This key\\'s passphrase will be used to log in to Mailpile')]\n\n    def _fix_revoke_key(self, fprint, comment=''):\n        return [\n            _('Revoke bad keys:') + ('  ' + comment if comment else ''),\n            _('Run: %s') % ('`gpg --gen-revoke %s`' % fprint),\n            _('Say yes to the first question, then follow the instructions'),\n            _('A revocation certificate will be shown on screen'),\n            _('Copy & paste that, save, and send to people who have the old key'),\n            _('You can search for %s to find such people'\n              ) % '`is:encrypted to:me`']\n\n    def _fix_disable_key(self, fprint, comment=''):\n        return [\n            _('Disable bad keys:') + ('  ' + comment if comment else ''),\n            _('Run: %s') % ('`gpg --edit-key %s`' % fprint),\n            _('Type %s') % '`disable`',\n            _('Type %s') % '`save`']\n\n    def command(self):\n        session, config = self.session, self.session.config\n        args = list(self.args)\n\n        all_keys = '--all-keys' in args\n        quiet = '--quiet' in args\n\n        date = datetime.date.today()\n        today = date.strftime(\"%Y-%m-%d\")\n        date += datetime.timedelta(days=14)\n        fortnight = date.strftime(\"%Y-%m-%d\")\n\n        serious = 0\n        details = []\n        fixes = []\n        bad_keys = {}\n        good_key = None\n        good_keys = {}\n        secret_keys = self._gnupg().list_secret_keys()\n\n        for fprint, info in secret_keys.iteritems():\n            k_info = {\n                'description': None,\n                'key': fprint,\n                'keysize': int(info.get('keysize', 0)),\n            }\n            is_serious = True\n            exp = info.get('expiration_date')\n            if info[\"disabled\"]:\n                k_info['description'] = _('%s: --- Disabled.') % fprint\n                is_serious = False\n            elif (not info['capabilities_map'].get('encrypt') or\n                    not info['capabilities_map'].get('sign')):\n                if info.get(\"revoked\"):\n                    k_info['description'] = _('%s: --- Revoked.'\n                                              ) % fprint\n                    is_serious = False\n                elif exp and exp <= today:\n                    k_info['description'] = _('%s: Bad: Expired on %s'\n                                              ) % (fprint,\n                                                   info['expiration_date'])\n                else:\n                    k_info['description'] = _('%s: Bad: Key is useless'\n                                              ) % fprint\n            elif exp and exp <= fortnight:\n                k_info['description'] = _('%s: Bad: Expires on %s'\n                                          ) % (fprint, info['expiration_date'])\n            elif k_info['keysize'] < self.MIN_KEYSIZE:\n                k_info['description'] = _('%s: Bad: Too small (%d bits)'\n                                          ) % (fprint, k_info['keysize'])\n            else:\n                good_keys[fprint] = info\n                if (not good_key\n                        or int(good_key['keysize']) < k_info['keysize']):\n                    good_key = info\n                k_info['description'] = _('%s: OK: %d bits, looks good!'\n                                          ) % (fprint, k_info['keysize'])\n                is_serious = False\n\n            if k_info['description'] is not None:\n                details.append(k_info)\n            if is_serious:\n                fixes += [self._fix_revoke_key(fprint, _('(optional)')),\n                          self._fix_disable_key(fprint)]\n                serious += 1\n            if fprint not in good_keys:\n                bad_keys[fprint] = info\n\n        bad_recipient = False\n        if config.prefs.gpg_recipient:\n            for k in bad_keys:\n                if k.endswith(config.prefs.gpg_recipient):\n                    details.append({\n                        'gpg_recipient': True,\n                        'description': _('%s: Mailpile config uses bad key'\n                                         ) % k,\n                        'key': k\n                    })\n                    bad_recipient = True\n                    serious += 1\n\n        if bad_recipient and good_key:\n            fixes[:0] = [self._fix_mp_config(good_key)]\n\n        profiles = config.vcards.find_vcards([], kinds=['profile'])\n        for vc in profiles:\n            p_info = {\n                'profile': vc.get('x-mailpile-rid').value,\n                'email': vc.email,\n                'fn': vc.fn\n            }\n            try:\n                if all_keys:\n                    vcls = [k.value for k in vc.get_all('key') if k.value]\n                else:\n                    vcls = [vc.get('key').value]\n            except (IndexError, AttributeError):\n                vcls = []\n            for key in vcls:\n                fprint = key.split(',')[-1]\n                if fprint and fprint in bad_keys:\n                    p_info['key'] = fprint\n                    p_info['description'] = _('%(key)s: Bad key in profile'\n                                              ' %(fn)s <%(email)s>'\n                                              ' (%(profile)s)') % p_info\n                    details.append(p_info)\n                    serious += 1\n            if not vcls:\n                p_info['description'] = _('No key for %(fn)s <%(email)s>'\n                                          ' (%(profile)s)') % p_info\n                details.append(p_info)\n                serious += 1\n\n        if len(good_keys) == 0:\n            fixes[:0] = [self._fix_gen_key(min_bits=self.MIN_KEYSIZE),\n                         self._fix_mp_config()]\n\n        if quiet and not serious:\n            return self._success('OK')\n\n        ret = self._error if serious else self._success\n        return ret(_('Sanity checked: %d keys in GPG keyring, %d profiles')\n                     % (len(secret_keys), len(profiles)),\n                   result={'passed': not serious,\n                           'details': details,\n                           'fixes': fixes})\n\n\n_plugins.register_commands(GPGKeySearch)\n_plugins.register_commands(GPGKeyReceive)\n_plugins.register_commands(GPGKeyImport)\n_plugins.register_commands(GPGKeyImportFromMail)\n_plugins.register_commands(GPGKeySign)\n_plugins.register_commands(GPGKeyList)\n_plugins.register_commands(GPGUsageStatistics)\n_plugins.register_commands(GPGKeyListSecret)\n_plugins.register_commands(GPGCheckKeys)\n", "{#\n\n  This is a self-contained modal for adding (and editing) account details.\n  This is a single form which handles profiles, routes and basic source\n  configuration.\n\n  The basic section of the form captures name, e-mail and password.\n\n  If the user allows auto-detection of settings, the Thunderbird ISPDB\n  will be queried and possibly other heuristics employed to figure out\n  correct connection settings. If successful, the route and source forms\n  will be filled in automatically (and skipped on Next).\n\n  Manual settings for routes and sources are as expected; local or\n  remote options, SMTP, IMAP, POP3, SSL, ports, hostnames, auth, ...\n\n  The security section of the form allows the user to choose which PGP key\n  to associate with this account or create a new one if he has none, which\n  will take place in a long-running background process.\n\n  The user can at any time skip forward or backwards in the form by\n  clicking on the section headlines, which are kept visible for that\n  purpose.\n\n#}{% set new_src_id = result.new_src_id %}\n\n  <script>\n    var _fpa = (function() {\n      var pf = '#form-profile-editor ';\n      var new_src_id = '{{ new_src_id }}';\n      var old = {username: ''};\n      return {\n        pre_submit: function(elem) {\n        },\n        display: function(elem, disp) {\n          if (disp) { elem.show() } else { elem.hide() };\n        },\n        validate: function() {\n          var basic_problems = 0;\n          if ($(pf + 'input[name=name]').val() == \"\" ||\n              $(pf + 'input[name=email]').val().indexOf('@') < 0) {\n            basic_problems += 1;\n            $(pf + 'input[name=name], ' + pf + 'input[name=email]'\n              ).on('change', _fpa.validate);\n          }\n          // FIXME: Validate other things too, improve e-mail validation\n          //_fpa.display($('.fpa-basics-ok'), basic_problems < 1);\n          _fpa.display($('.fpa-basics-bad'), basic_problems > 0);\n          _fpa.display($('#fpa-submit'),\n                       (basic_problems < 1) &&\n                       (!$(pf + '.fpa-autoconfig').is(':checked')));\n        },\n        next: function(show) {\n          $(pf + 'div.section').slideUp();\n          $(pf + 'div.' + show).slideDown().find(':tabbable').eq(0).focus();\n          $(pf + '.fpa-login-failed').hide();\n          $(pf + '.fpa-detection-failed').hide();\n          // Any navigation disables the auto-detection\n          $(pf + '.fpa-autoconfig').prop('checked', false);\n          _fpa.validate();\n          return false;\n        },\n        more: function(show) {\n          $(pf + '.' + show + '-show').hide();\n          $(pf + '.' + show).slideDown();\n          return false;\n        },\n        select: function(sel, cls) {\n          var val = $(sel).val();\n          $(pf + '.' + cls).hide();\n          if (val) {\n            $(pf + '.' + cls + '.any').show();\n            if (val[0] != '!') $(pf + '.' + cls + '.' + val).show();\n          }\n          else {\n            $(pf + '.' + cls + '.undefined').show();\n          }\n        },\n        mark_copied: function(elem, what) {\n          var $elem = $(elem);\n          if ($elem.val() == old[what]) {\n            $elem.parent().find('.fpa-' + what + '-copied').show();\n          }\n          else {\n            $elem.parent().find('.fpa-' + what + '-copied').hide();\n          }\n        },\n        copy_basic: function(what) {\n          var value = $(pf + '.fpa-basic-' + what).val();\n          var old_old = old[what];\n          old[what] = value;\n          $(pf + '.fpa-' + what).each(function(i) {\n            var $t = $(this);\n            if (old_old == $t.val() || '' == $t.val()) $t.val(value);\n            _fpa.mark_copied(this, what);\n          });\n        },\n        exclude: function(elem, s1, s2, s3, s4) {\n          if ($(elem).is(':checked')) {\n            if (s1) $(pf + 'input[name=\"' + s1 +'\"]').removeAttr('checked');\n            if (s2) $(pf + 'input[name=\"' + s2 +'\"]').removeAttr('checked');\n            if (s3) $(pf + 'input[name=\"' + s3 +'\"]').removeAttr('checked');\n            if (s4) $(pf + 'input[name=\"' + s4 +'\"]').removeAttr('checked');\n          }\n        },\n        require: function(elem, s1, s2, s3) {\n          if ($(elem).is(':checked')) {\n            if (s1) $(pf + 'input[name=\"' + s1 +'\"]').prop('checked', true);\n            if (s2) $(pf + 'input[name=\"' + s2 +'\"]').prop('checked', true);\n            if (s3) $(pf + 'input[name=\"' + s3 +'\"]').prop('checked', true);\n          }\n        },\n        requiredby: function(elem, s1, s2, s3) {\n          if (!$(elem).is(':checked')) {\n            if (s1) $(pf + 'input[name=\"' + s1 +'\"]').removeAttr('checked');\n            if (s2) $(pf + 'input[name=\"' + s2 +'\"]').removeAttr('checked');\n            if (s3) $(pf + 'input[name=\"' + s3 +'\"]').removeAttr('checked');\n          }\n        },\n        email_changed: function() {\n          // If the e-mail in basics changes, try to select the matching\n          // PGP key, if there is one. This may override user selections,\n          // which might be lame but should rarely be an issue because of\n          // the \"order of progression\" of the form.\n          var email = $(pf + '.fpa-email').val();\n          var found = 0;\n          $(pf + '.fpa-pgp-key option').each(function(i) {\n            var uid = $(this).data('uid');\n            if (found == 0 && uid == email) {\n              $(this).prop('selected', true).removeClass('hide');\n              found = 1;\n            }\n            else {\n              $(this).prop('selected', false);\n              if (uid) $(this).addClass('hide');\n            }\n            if (!found) {\n              $(pf + '.fpa-pgp-key-default').prop('selected', true);\n              _fpa.select($('.fpa-pgp-key'), 'security-opt');\n            }\n          });\n          _fpa.copy_basic('username');\n        },\n        basics_next: function() {\n          var email = $(pf + '.fpa-email').val();\n          if (!email) {\n            // FIXME: Improve validation...\n            alert('{{_(\"You need at least an e-mail address to proceed.\")|escapejs}}');\n          }\n          else if ($(pf + '.fpa-autoconfig').is(':checked')) {\n            $(pf + 'div.section, ' + pf + 'div.fpa-network-settings').slideUp();\n            $(pf + 'div.fpa-detection-in-progress').slideDown();\n            $(pf + '.fpa-detection-progress').html('{{_(\"Detecting settings for: \")|escapejs}}' + email);\n            var ev_source = '.*.SetupGetEmailSettings';\n            var watch_id = EventLog.subscribe(ev_source, function(ev) {\n              if (ev.private_data['track-id'] == new_src_id) {\n                $(pf + '.fpa-detection-progress').html(ev.message);\n              }\n            });\n            Mailpile.API.setup_email_servers_get({\n              'track-id': new_src_id,\n              '_timeout': (Mailpile.ajax_timeout * 30), // AJAX timeout\n              'timeout': 240000,  // Server-side deadline\n              'email': email,\n              '_error_callback': function(response, _status) {\n                console.log(\"Detection error \" + _status);\n                $(pf + 'div.fpa-detection-in-progress').slideUp();\n                $(pf + 'div.fpa-network-settings').slideDown();\n                _fpa.next('profile-add-route');\n                $(pf + '.fpa-detection-failed').slideDown();\n                EventLog.unsubscribe(ev_source, watch_id);\n              }\n            }, function(data) {\n              EventLog.unsubscribe(ev_source, watch_id);\n              $(pf + 'div.fpa-detection-in-progress').slideUp();\n              $(pf + 'div.fpa-network-settings').slideDown();\n              $('.edit-provider-settings').hide();\n              var nxt = undefined;\n              var result = undefined;\n              if (data.result) result = data.result[email];\n              if (result) nxt = _fpa.copy_email_settings(result);\n              if (data.result && data.result['login_failed']) {\n                _fpa.next('profile-add-basics');\n                $(pf + '.fpa-autoconfig').prop('checked', true);\n                $(pf + '.fpa-login-failed').slideDown();\n              }\n              else if (nxt) {\n                _fpa.next(nxt);\n              }\n              else {\n                _fpa.next('profile-add-route');\n                $(pf + '.fpa-detection-failed').slideDown();\n              }\n            });\n            return false;\n          }\n          else {\n            return _fpa.next(\"profile-add-route\");\n          }\n        },\n        copy_email_settings: function(result) {\n          var next = 0;\n          var oauth = 0;\n          if (result.routes && result.routes.length > 0) {\n            var found = result.routes[0];\n            if (found.auth_type == 'OAuth2') oauth += 1;\n            $(\"input[name='route-host']\").val(found.host);\n            $(\"input[name='route-port']\").val(found.port);\n            $(\"input[name='route-username']\").val(found.username);\n            var $s = $(\"select[name='route-protocol']\");\n            $s.find('option').prop('selected', false);\n            $s.find(\"option[value='\" + found.protocol + \"']\").prop('selected', true);\n            var $a = $(\"select[name='route-auth_type']\");\n            $a.find('option').prop('selected', false);\n            $a.find(\"option[value='\" + found.auth_type.substring(0, 8) + \"']\").prop('selected', true);\n            _fpa.select($s, 'route-settings');\n            next = 'profile-add-source';\n          }\n          if (result.sources && result.sources.length > 0) {\n            var found = result.sources[0];\n            if (found.auth_type == 'OAuth2') oauth += 1;\n            $(\"input[name='source-{{ new_src_id }}-host']\").val(found.host);\n            $(\"input[name='source-{{ new_src_id }}-port']\").val(found.port);\n            $(\"input[name='source-{{ new_src_id }}-username']\").val(found.username);\n            var $s = $(\"select[name='source-{{ new_src_id }}-protocol']\");\n            $s.find(\"option\").prop('selected', false);\n            $s.find(\"option[value='\" + found.protocol + \"']\").prop('selected', true);\n            var $a = $(\"select[name='source-{{ new_src_id }}-auth_type']\");\n            $a.find('option').prop('selected', false);\n            $a.find(\"option[value='\" + found.auth_type.substring(0, 8) + \"']\").prop('selected', true);\n            _fpa.select($s, 'source-settings-{{ new_src_id }}');\n            next = 'profile-add-security';\n          }\n          if (oauth) {\n            // Do nothing...?\n          }\n          else if (result.enable) {\n            $('.edit-provider-settings').attr('href', result.enable[0].url).show();\n            $('.fpa-warning .description').html(result.enable[0].description);\n            $('.fpa-warning ul.docs').html(' ');\n            if (result.docs) {\n              for (var i = 0; i < result.docs.length; i++) {\n                 var doc = result.docs[i];\n                 if (doc.description.indexOf('TB') == -1 &&\n                     doc.description.indexOf('Thunder') == -1) {\n                   $('.fpa-warning ul.docs').append($(\n                     '<li><a target=_blank href=\"' + doc.url + '\">' + doc.description + '</a></li>'\n                   ));\n                 }\n              }\n            }\n            next = 'fpa-warning';\n          }\n          return next;\n        },\n        setup: function() {\n          $('input[name=name]').focus();\n          $('#form-profile-editor').on('keydown', ':tabbable', function(e) {\n            // Make ENTER behave like TAB, to avoid accidental form submission.\n            if (document.activeElement.tagName == \"TEXTAREA\") {\n              // Do nothing\n            }\n            else if (e.which == 13 || e.keyCode == 13) {\n              e.preventDefault();\n              var nxt = $(document.activeElement).data(\"next\");\n              if (nxt) {\n                $(nxt).trigger('click');\n              }\n              else {\n                var $canfocus = $(':tabbable:visible')\n                var index = $canfocus.index(document.activeElement) + 1;\n                if (index >= $canfocus.length) index = 0;\n                $canfocus.eq(index).focus();\n              }\n            }\n          });\n        }\n      };\n    })();\n    setTimeout(\"_fpa.setup();\", 100);\n\n    $(function() {\n      // Make authentication popups forget about the current profile:\n      EventLog.forget_about_event(\"{{result.rid}}\");\n    });\n  </script>\n\n  <form id=\"form-profile-editor\" class=\"standard\"\n        method=\"POST\" action=\"{{ U(state.command_url) }}\"\n        style=\"position: relative; max-width: 60em;\">{{ csrf_field|safe }}\n    {%- if result.rid %}\n    <input type=\"hidden\" name=\"rid\" value=\"{{ result.rid }}\">\n    {%- endif %}\n\n    <p class=\"message paragraph-important\"\n       onclick='javascript:_fpa.next(\"profile-add-basics\");'>\n      <span class=\"icon-user\"></span> {{_(\"Basic Details\")}}\n      <span class=\"icon-signature-unknown fpa-basics-bad right hide\" style=\"padding: 5px; color: #ff5;\"\n            title=\"{{_('At least a name and e-mail are required!')}}\"></span>\n      <span class=\"icon-checkmark fpa-basics-ok right hide\" style=\"padding: 5px; color: #0d0;\"></span>\n    </p>\n    <div class=\"section profile-add-basics {% if ui_open and ui_open != 'basics' %}hide{% endif %}\"\n         style=\"position: relative;\">\n\n{%- if 0 %}{# TODO: Partner and make it possible to create e-mail accounts #}\n      {%- if not result.rid %}\n      <select class=\"right\" style=\"width: auto;\"\n              onchange=\"javascript:_fpa.select(this, 'basics');\">\n        <option value=\"old\" selected>{{_(\"Existing Account\")}}</option>\n        <option value=\"new\">{{_(\"New Address\")}}</option>\n      </select>\n      {% endif %}\n{%- endif %}\n\n      <div style=\"padding-right: 0em; width: 29em;\">\n        <label>{{_(\"Name\")}}</label>\n        <input type=\"text\" name=\"name\" style=\"width: 100%\"\n               value=\"{{ result.name }}\" placeholder=\"Ada Lovelace\">\n      </div>\n      <div class=\"basics old\">\n        <div class=\"left\" style=\"margin-right: 1em; width: 29em;\">\n          <label>{{_(\"E-mail\")}}</label>\n          <input type=\"text\" name=\"email\" style=\"width: 100%\"\n                 class='fpa-email fpa-basic-username' data-next=\"#basics-next\"\n                 placeholder=\"ada@example.com\" value=\"{{ result.email }}\"\n                 onchange=\"javascript:_fpa.email_changed();\">\n        </div>\n      </div>\n      <div class=\"basics new hide\">\n        <br><i>FIXME ... add signup with partners here!</i><br>\n      </div>\n      <div class=\"more-basics left{%- if not result.rid %} hide{% endif %}\"\n           style=\"width: 39em; padding: 0;\">\n        <label>{{_(\"Signature\")}}</label>\n        <textarea placeholder=\"{{_(\"Everyone needs a unique, witty signature!\")}}\"\n                  style=\"width: 100%; font-size: 0.85em;\"\n                  name=\"signature\">{{ result.signature }}</textarea>\n      </div>\n      <br clear=\"both\"><label>&nbsp;</label>\n      <div style=\"position: absolute; text-align: right; right: 0; bottom: 1.5em;\">\n        {%- if not result.rid %}\n        <a class=\"more-basics-show clickable\" onclick=\"javascript:_fpa.more('more-basics');\">\n          {{_(\"Add custom signature\")}} ...\n        </a> &nbsp;&nbsp;\n        {% endif %}\n        {%- if not result.sources %}\n        <input type=\"checkbox\" class=\"fpa-autoconfig\" value=\"yes\"\n               {%- if not result.rid %}checked{% endif %}>\n        <span class=\"checkbox\">\n          {{ _(\"Detect settings\") }}\n        </span> &nbsp;\n        {% endif %}\n        <button id=\"basics-next\" onclick='javascript:_fpa.basics_next();'\n                class=\"button button-secondary\" type=\"button\">{{_(\"Next\")}} ...</button>\n      </div>\n      <br clear=\"both\">\n    </div>\n\n    <div class=\"fpa-detection-in-progress hide\">\n      <p class=\"message paragraph-important\">\n        <span class=\"icon-robot\"></span> {{_(\"Auto-detecting settings\")}} ...\n      </p>\n      <div class=\"text-center\">\n      {% if config.sys.proxy.protocol in (\"tor\", \"tor-risky\") %}\n        <p>{{_(\"Connecting over Tor, this may take a while.\")}}</p>\n      {% endif %}\n        <p>{% include(\"../img/loading-ellipsis.svg\") %}</p>\n        <p><i class='fpa-detection-progress'></i></p>\n      </div>\n    </div>\n\n    <div class=\"fpa-network-settings\">\n      <div class=\"fpa-detection-failed hide\">\n        <p class=\"message paragraph-alert\">\n          <span class=\"icon-robot\"></span>\n          <b>{{_(\"Failed to detect settings, manual configuration required\")}}!</b>\n          <span class=\"description\" href=\"\"></span>\n        </p>\n        <p class=\"text-center\">\n          <a href=\"{{ U('/logs/network/') }}\" data-dismiss=\"modal\">\n             <span class=\"icon icon-work\"></span>\n             {{_(\"Troubleshoot recent Network Activity.\")}}\n          </a>\n        </p>\n      </div>\n      <p class=\"message paragraph-alert fpa-login-failed hide\">\n        <span class=\"icon-robot\"></span> <b>{{_(\"Failed to log in, check the username and password\")}}!</b>\n        <span class=\"description\" href=\"\"></span>\n      </p>\n      <p class=\"message paragraph-important\"\n         onclick='javascript:_fpa.next(\"profile-add-route\");'>\n        <span class=\"icon-outbox\"></span> {{_(\"Sending Mail\")}}\n        <span class=\"icon-checkmark fpa-route-ok right hide\" style=\"padding: 5px; color: #4f4;\"></span>\n      </p>\n      <div class=\"section profile-add-route {% if ui_open != 'route' %}hide{% endif %}\"\n           style=\"position: relative;\">\n        <select class=\"right\" name=\"route-protocol\" style=\"width: auto;\"\n                data-next=\"#next-route\"\n                onchange=\"javascript:_fpa.select(this, 'route-settings');\">\n          {%- set protocol = result['route-protocol'] %}\n          {%- for val, txt in (('smtp', 'SMTP'),\n                              ('smtpssl', 'SMTP/TLS'),\n                              ('smtptls', 'SMTP/STARTTLS'),\n                              ('local', _(\"Local\")),\n                              ('none', _(\"None\"))) %}\n          <option value=\"{{val}}\"{% if val == protocol %} selected\n                                 {%- endif %}>{{txt}}</option>\n          {%- endfor %}\n        </select>\n        <div class=\"route-settings smtp smtpssl smtptls\n                    {%- if protocol not in ('smtp', 'smtpssl', 'smtptls') %} hide{% endif %}\">\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            <label>{{_(\"Host name\")}}</label>\n            <input type=\"text\" name=\"route-host\" value=\"{{ result['route-host'] }}\" placeholder=\"mail.server.com\">\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 10em;\">\n            <label>{{_(\"Port number\")}}</label>\n            <input type=\"text\" name=\"route-port\" value=\"{{ result['route-port'] }}\" placeholder=\"25, 465 or 587\">\n          </div>\n          <br clear=\"both\">\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            <small class=\"right fpa-username-copied hide\">({{ _(\"copied\") }})</small>\n            <label>{{_(\"Username\")}}</label>\n            <input type=\"text\" name=\"route-username\" class=\"fpa-username\"\n                   onchange=\"javascript:_fpa.mark_copied(this, 'username');\"\n                   value=\"{{ result['route-username'] }}\" placeholder=\"you123\">\n          </div>\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            {%- set auth_type = result['route-auth_type'][:8] %}\n            <label>{{_(\"Authentication\")}}</label>\n            <select name=\"route-auth_type\" style=\"width: 14em;\">\n              {%- for val, txt in (('password', 'Password'),\n                                   ('OAuth2', 'OAuth2')) %}\n              <option value=\"{{val}}\"{% if val == auth_type %} selected\n                                     {%- endif %}>{{txt}}</option>\n              {%- endfor %}\n            </select>\n          </div>\n\n          {%- set password = result['route-password'] %}\n          {%- if password %}\n          <div class=\"left\" style=\"margin-right: 0; width: 29em;\">\n            <input type=\"checkbox\" name=\"route-password\" value=\"\">\n            <span class=\"checkbox\">\n              {{_(\"Forget password\")}}\n            </span><br>\n          </div>\n          {%- endif %}\n        </div>\n        <div class=\"route-settings local\n                    {%- if protocol != 'local' %} hide{% endif %}\">\n          <div style=\"margin-right: 0; width: 25em;\">\n            <p><i>\n              {{_(\"Send mail using local Unix tools.\")}}\n              {{_(\"Use this setting if you have a working mail server on this machine.\")}}\n            </i></p>\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 29em;\">\n            <label>{{_(\"Shell command\")}}</label>\n            <input type=\"text\" name=\"route-command\" style=\"width: 100%;\"\n                   value=\"{{ result['route-command'] }}\"\n                   placeholder=\"- {{_('Leave blank to auto-detect')}} -\">\n          </div>\n        </div>\n        <div style=\"width: 70%;\" class=\"route-settings none\n                                        {%- if protocol != 'none' %} hide{% endif %}\">\n          <br>\n          <br>\n          <p class=\"text-center\"><i>\n            {{_(\"No outgoing mail for this account.\")}}\n          </i></p>\n          <br>\n        </div>\n        <br clear=\"both\">\n        <div style=\"position: absolute; right: 0; bottom: 1.5em;\">\n          <button onclick='javascript:_fpa.next(\"profile-add-source\");'\n                  class=\"button button-secondary\" type=\"button\">{{_(\"Next\")}} ...</button>\n        </div>\n        <br clear=\"both\">\n      </div>\n\n      <p class=\"message paragraph-important\"\n         onclick='javascript:_fpa.next(\"profile-add-source\");'>\n        <span class=\"icon-mailsource\"></span> {{_(\"Receiving Mail\")}}\n        <span class=\"icon-checkmark right hide\" style=\"padding: 5px; color: #5f5;\"></span>\n      </p>\n      <div class=\"section profile-add-source {% if ui_open != 'sources' %}hide{% endif %}\"\n           style=\"position: relative;\">\n{% macro source_editor(rid, new_rid) %}\n        {% set protocol = result['source-' + rid + '-protocol'] %}\n        <select class=\"right\" style=\"width: auto;\"\n                onchange=\"javascript:_fpa.select(this, 'source-settings-{{ new_rid }}');\"\n                name=\"source-{{ new_rid }}-protocol\">\n          {% for val, txt in (('imap', 'IMAP'),\n                              ('imap_ssl', 'IMAP/TLS'),\n                              ('pop3', 'POP3'),\n                              ('pop3_ssl', 'POP3/TLS'),\n                              ('spool', _(\"Mail spool\")),\n                              ('local', _(\"Local files\")),\n                              ('none', _(\"None\"))) %}\n           {%- if rid != new_rid or val[:4] == protocol[:4] %}\n            <option value=\"{{val}}\"\n                    {%- if val == protocol or\n                           (val == \"imap\" and protocol == \"imap_tls\") %}\n                    selected{% endif %}>{{txt}}</option>\n           {%- endif %}\n          {%- endfor %}\n        </select>\n\n        <div class=\"source-settings-{{ new_rid }} imap imap_ssl pop3 pop3_ssl\n                    {%- if protocol[:4] not in ('imap', 'pop3') %} hide{% endif %}\">\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            <label>{{_(\"Host name\")}}</label>\n            <input type=\"text\" name=\"source-{{ new_rid }}-host\"\n                   value=\"{{ result['source-' + rid + '-host'] }}\"\n                   placeholder=\"mail.server.com\">\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 13em;\">\n            <label>{{_(\"Port number\")}}</label>\n            <input type=\"text\" name=\"source-{{ new_rid }}-port\"\n                   value=\"{{ result['source-' + rid + '-port'] }}\"\n                   placeholder=\"110, 143, 993 or 995\">\n          </div>\n          <br clear=\"both\">\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            <small class=\"right fpa-username-copied hide\">({{ _(\"copied\") }})</small>\n            <label>{{_(\"Username\")}}</label>\n            <input type=\"text\" name=\"source-{{ new_rid }}-username\" class=\"fpa-username\"\n                   onchange=\"javascript:_fpa.mark_copied(this, 'username');\"\n                   value=\"{{ result['source-' + rid + '-username'] }}\"\n                   placeholder=\"you123\">\n          </div>\n          <div class=\"left\" style=\"margin-right: 1em; width: 14em;\">\n            {%- set auth_type = result['source-' + rid + '-auth_type'] %}\n            <label>{{_(\"Authentication\")}}</label>\n            <select name=\"source-{{ new_rid }}-auth_type\" style=\"width: 14em;\">\n              {%- for val, txt in (('password', 'Password'),\n                                   ('OAuth2', 'OAuth2')) %}\n              <option value=\"{{val}}\"{% if val == auth_type %} selected\n                                     {%- endif %}>{{txt}}</option>\n              {%- endfor %}\n            </select>\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 29em;\">\n          {%- set password = result['source-' + rid + '-password'] %}\n          {%- if password %}\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-password\" value=\"\">\n            <span class=\"checkbox\">\n              {{_(\"Forget password\")}}\n            </span><br>\n          {%- endif %}\n\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-leave-on-server\" value=\"yes\"\n                   {% if result['source-' + rid + '-leave-on-server'] %}checked{% endif %}>\n            <span class=\"checkbox\">\n              {{_(\"Leave mail on server\")}}\n            </span><br>\n\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-index-all-mail\" value=\"yes\"\n                   {% if result['source-' + rid + '-index-all-mail'] %}checked{% endif %}>\n            <span class=\"checkbox\">\n              {{_(\"Copy all mail and add to search engine\")}}\n            </span>\n\n            <span class=\"source-settings-{{ new_rid }}\n                         {%- if protocol not in ('imap', 'imap_tls') %} hide{% endif %}\n                         imap\">\n              <br>\n              <input type=\"checkbox\" name=\"source-{{ new_rid }}-force-starttls\" value=\"yes\"\n                     {% if result['source-' + rid + '-force-starttls'] or\n                           result['source-' + rid + '-protocol'] == 'imap_tls'\n                           %}checked{% endif %}>\n              <span class=\"checkbox\">\n                {{_(\"Require STARTTLS encryption\")}}\n              </span>\n            </span>\n\n            <div class='edit-provider-settings hide'><br>\n              <a target=_blank class='edit-provider-settings button-secondary'>\n                <span class=\"icon-settings\"></span> {{_(\"Enable IMAP\")}}\n              </a>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"source-settings-{{ new_rid }} spool\n                    {%- if protocol[:4] != 'spool' %} hide{% endif %}\">\n          <div class=\"source-settings-{{ new_rid }} spool left\" style=\"margin-right: 0; width: 29em;\">\n            <p><i>\n              {{_(\"Receive mail from local Unix mail spool.\")}}\n              {{_(\"Use this setting if you have a working mail server on this machine.\")}}\n            </i></p>\n          </div>\n          <div class=\"left\" style=\"margin-right: 0; width: 29em;\">\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-copy-local\" value=\"yes\"\n                   onchange='javascript:_fpa.requiredby(this, \"source-{{ new_rid }}-delete-source\");'\n                   {% if result['source-' + rid + '-copy-local'] %}checked{% endif %}>\n            <span class=\"checkbox\">\n              {{_(\"Copy mail to Mailpile secure storage\")}}\n            </span><br>\n            <input type=\"checkbox\" name=\"source-{{ new_rid }}-delete-source\" value=\"yes\"\n                   onchange='javascript:_fpa.require(this, \"source-{{ new_rid }}-copy-local\");'\n                   {% if result['source-' + rid + '-delete-source'] %}checked{% endif %}>\n            <span class=\"checkbox\">\n              {{_(\"Delete from Unix mail spool\")}} ({{_(\"after copying\")}})\n            </span>\n          </div>\n        </div>\n\n        <div class=\"source-settings-{{ new_rid }} none local\n             {%- if protocol not in ('none', 'local') %} hide{% endif %}\"\n             style=\"width: 70%;\">\n          <div class=\"source-settings-{{ new_rid }} none left\n               {%- if protocol[:4] != 'none' %} hide{% endif %}\"\n               style=\"margin-right: 0; width: 29em;\">\n            <br><br>\n            <p class=\"text-center\"><i>\n            {%- if result.sources %}\n              {{_(\"Choose a protocol for the new mail source...\")}}\n            {%- else %}\n              {{_(\"No incoming mail for this account.\")}}\n            {%- endif %}\n            </i></p>\n            <br>\n          </div>\n          <div class=\"source-settings-{{ new_rid }} local left\n               {%- if protocol != 'local' %} hide{% endif %}\"\n               style=\"margin-right: 0; width: 29em;\">\n            <p><i>\n              {{_(\"Use this setting if you would like Mailpile to read e-mails already downloaded by Thunderbird, Mac Mail or another local application on this machine.\")}}\n            </i></p>\n            <p>\n              {{_(\"Use the Browse tool to import local mailboxes later on.\")}}\n            </p>\n          </div>\n        </div>\n\n        {%- if rid == new_rid %}\n        <div class=\"source-settings-{{ new_rid }}\n                    imap imap_ssl pop3 pop3_ssl local spool\n                    {%- if protocol[:4] == 'none' %} hide{% endif %}\">\n          <br clear=\"both\">\n          <input type=\"checkbox\" name=\"source-{{ new_rid }}-enabled\" value=\"yes\"\n                 onchange='javascript:_fpa.require(this, \"source-{{ new_rid }}-copy-local\");'\n                 {% if result['source-' + rid + '-enabled'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Enable this mail source\")}}\n          </span>\n        </div>\n        {% else %}\n        <input type=\"hidden\" name=\"source-{{ new_rid }}-enabled\" value=\"yes\">\n        {% endif %}\n{%- endmacro %}\n        {%- for sid in result.sources %}\n\n          {%- if not loop.first %}<br clear=\"both\"><hr style=\"margin: 1em 0 5px 0;\">{% endif %}\n          {{- source_editor(sid, sid) }}\n        {%- endfor %}\n        <div class=\"source-add-new{% if result.sources %} hide{% endif %}\">\n          {%- if result.sources %}<br clear=\"both\"><hr style=\"margin: 1em 0 5px 0;\">{% endif %}\n          {{- source_editor('NEW', new_src_id) }}\n        </div>\n        <br clear=\"both\">\n        <div style=\"position: absolute; right: 0; bottom: 1.5em;\">\n          {% if result.sources %}\n          <input type=\"checkbox\" class=\"fpa-add-new-source\" value=\"yes\"\n                 style=\"padding-right: 0;\"\n                 onchange=\"javascript:$('.source-add-new').toggle();\">\n          <span class=\"checkbox\">{{ _(\"Add New\") }} &nbsp; </span>\n          {% endif %}\n          <button onclick='javascript:_fpa.next(\"profile-add-security\");'\n                  class=\"button button-secondary\" type=\"button\">{{_(\"Next\")}} ...</button>\n        </div>\n        <br clear=\"both\">\n      </div>\n    </div>\n\n    {% set enable_imap_pop3_message = _(\"Mailpile may not be able to access your mail unless you log on to your account and enable IMAP and/or POP3.\") %}\n    <div class='section fpa-warning hide' style='position: relative'>\n      <p class=\"message paragraph-alert\">\n        <span class=\"icon-settings\"></span> <b>{{_(\"Important\")}}!</b>\n        <span class=\"description\" href=\"\"></span>\n      </p>\n      <p>\n        {{ enable_imap_pop3_message }}\n        {{_(\"Without this, some providers will even mistake Mailpile for an intruder!\")}}\n      </p>\n      <ul style=\"list-style: disc; margin-left: 2em;\" class=\"docs\"></ul>\n      <p>\n        <a target=_blank class='edit-provider-settings button-secondary right'\n           onclick=\"javascript:$(this).removeClass('button-secondary').addClass('button-info');\n                               $('#fpa-gotit').removeClass('button-info').addClass('button-secondary');\">\n          <span class=\"icon-settings\"></span> {{_(\"Enable IMAP\")}}\n        </a>\n        <br clear=\"both\">\n      </p>\n      <div style=\"position: absolute; left: 0; bottom: 0;\">\n        <button onclick='javascript:_fpa.next(\"profile-add-security\");'\n                class=\"button-info\" id=\"fpa-gotit\" type=\"button\">{{_(\"Got it\")}} ...</button>\n      </div>\n    </div>\n\n    <p class=\"message paragraph-important\"\n       onclick='javascript:_fpa.next(\"profile-add-security\");'>\n      <span class=\"icon-lock-closed\"></span> {{_(\"Security and Privacy\")}}\n      <span class=\"icon-checkmark right hide\" style=\"padding: 5px; color: #5f5;\"></span>\n    </p>\n    <div class=\"section profile-add-security  {% if ui_open != 'security' %}hide{% endif %}\"\n         style=\"position: relative;\">\n      <div class=\"left\" style=\"margin-right: 0; width: 100%;\">\n        <label>{{_(\"Encryption key\")}}</label>\n        <select class='fpa-pgp-key' style=\"width: 100%\"\n                onchange=\"javascript:_fpa.select(this, 'security-opt');\"\n                name=\"security-pgp-key\">\n          <option value=\"!CREATE:RSA2048\">{{_(\"Create a new 2048 bit RSA key\")}}</option>\n          <option value=\"!CREATE:RSA3072\" class=\"fpa-pgp-key-default\">{{_(\"Create a new 3072 bit RSA key\")}}</option>\n        {%- set pgp_keys = mailpile('crypto/gpg/keylist/secret','True').result %}\n        {%- for fingerprint in pgp_keys -%}\n          {%- set key = pgp_keys[fingerprint] -%}\n          {%- for uid in key.uids %}\n          <option value=\"{{fingerprint}}\" data-uid=\"{{ uid.email }}\"\n                  {%- if (fingerprint == result['security-pgp-key']) and (uid.email == result.email) %} selected{% endif %}\n                  {%- if (uid.email != result.email) %} class=\"hide\"{% endif %}>\n            {{key.creation_date}}/{{key.keytype_name}}{{key.keysize}}:\n            {{uid.name}} &lt;{{uid.email}}&gt;\n            ({% if uid.comment %}{{uid.comment}}{% else %}0x{{ fingerprint[-8:] }}{% endif %})\n          </option>\n          {%- endfor %}\n        {%- endfor %}\n          <option value=\"!CREATE:RSA4096\">{{_(\"Create a new 4096 bit RSA key (slow)\")}}</option>\n          <option {% if not result['security-pgp-key'] %}selected {% endif -%}\n                  value=\"\">{{_(\"Disable encryption for this account\")}}</option>\n        </select>\n        <div class=\"security-opt any text-right\n             {%- if not result['security-pgp-key'] %} hide{% endif %}\"\n             style=\"margin: -13px 0 13px 0;\">\n          <a class=\"more-crypto-show\" onclick=\"javascript:_fpa.more('more-crypto');\">\n            {{_(\"Show too many encryption settings\")}}\n          </a>\n        </div>\n      </div>\n      <div class=\"security-opt any left\n           {%- if not result['security-pgp-key'] %} hide{% endif %}\"\n           style=\"margin-right: 0; width: 29em;\">\n        <div class=\"more-crypto {% if not result['security-best-effort-crypto'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-best-effort-crypto\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-always-sign\", \"security-always-encrypt\", \"security-obscure-metadata\", \"security-prefer-inline\");'\n                 {% if result['security-best-effort-crypto'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Best-effort: Encrypt and/or sign mail whenever possible\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-always-sign'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-always-sign\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-best-effort-crypto\");'\n                 {% if result['security-always-sign'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Always digitally sign outgoing mail\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-always-encrypt'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-always-encrypt\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-best-effort-crypto\");_fpa.require(this, \"security-always-sign\");'\n                 {% if result['security-always-encrypt'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Always encrypt (warn when sending unencrypted mail)\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-obscure-metadata'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-obscure-metadata\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-prefer-inline\");'\n                 {% if result['security-obscure-metadata'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Minimize metadata (may make mail unreadable)\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-prefer-inline'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-prefer-inline\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-obscure-metadata\", \"security-prefer-pgpmime\");'\n                 {% if result['security-prefer-inline'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Prefer compatibility; avoid PGP/MIME (makes mail ugly)\")}}\n          </span>\n        </div>\n{% if config.web.developer_mode %}\n        <div class=\"more-crypto {% if not result['security-prefer-pgpmime'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-prefer-pgpmime\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-prefer-inline\");'\n                 {% if result['security-prefer-pgpmime'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Prefer PGP/MIME\")}}\n          </span>\n        </div>\n{% endif %}\n        <div style=\"margin-top: 0.7em\"\n             class=\"more-crypto {% if not result['security-openpgp-header-encrypt'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-openpgp-header-encrypt\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-openpgp-header-none\");_fpa.require(this, \"security-openpgp-header-sign\");'\n                 {% if result['security-openpgp-header-encrypt'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Signal a preference for encrypted mail\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-openpgp-header-sign'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-openpgp-header-sign\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-openpgp-header-none\");'\n                 {% if result['security-openpgp-header-sign'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Signal a preference for signed mail\")}}\n          </span>\n        </div>\n        <div class=\"more-crypto {% if not result['security-openpgp-header-none'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-openpgp-header-none\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-openpgp-header-sign\", \"security-openpgp-header-encrypt\");'\n                 {% if result['security-openpgp-header-none'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Signal a preference for un-signed, un-encrypted mail\")}}\n          </span>\n        </div>\n{# FIXME - make this work!\n        <div style=\"margin-top: 0.7em\"\n             class=\"more-crypto {% if not result['security-use-autocrypt'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-use-autocrypt\" value=\"yes\"\n                 onchange='javascript:_fpa.exclude(this, \"security-attach-keys\");'\n                 {% if result['security-use-autocrypt'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Use AutoCrypt headers to share encryption keys\")}}\n          </span><br>\n        </div>\n#}\n        <div class=\"more-crypto {% if not result['security-attach-keys'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-attach-keys\" value=\"yes\"\n                 {% if result['security-attach-keys'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Automatically attach encryption keys to outgoing mail\")}}\n          </span>\n        </div>\n{# FIXME - make this work!\n        <div class=\"more-crypto {% if not result['security-publish-to-keyserver'] %}hide{% endif %}\">\n          <input type=\"checkbox\" name=\"security-publish-to-keyserver\" value=\"yes\"\n                 {% if result['security-publish-to-keyserver'] %}checked{% endif %}>\n          <span class=\"checkbox\">\n            {{_(\"Upload key to public directory (key server)\")}}\n          </span>\n        </div>\n#}\n      </div>\n    </div>\n\n    <br clear=\"both\">\n    <button type=\"submit\" id=\"fpa-submit\" class=\"button-primary right{%- if not result.rid %} hide{% endif %}\">\n      <span class=\"icon {{ form_icon or \"icon-plus\"}}\"></span>\n      {{ form_action or _(\"Add\")}}\n    </button>\n  </form>\n"], "filenames": ["mailpile/crypto/gpgi.py", "mailpile/plugins/crypto_gnupg.py", "shared-data/default-theme/html/profiles/account-form.html"], "buggy_code_start_loc": [812, 390, 717], "buggy_code_end_loc": [812, 395, 718], "fixing_code_start_loc": [813, 390, 717], "fixing_code_end_loc": [816, 408, 718], "type": "CWE-287", "message": "The \"Security and Privacy\" Encryption feature in Mailpile before 1.0.0rc4 does not exclude disabled, revoked, and expired keys.", "other": {"cve": {"id": "CVE-2018-20954", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-08T21:15:11.490", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The \"Security and Privacy\" Encryption feature in Mailpile before 1.0.0rc4 does not exclude disabled, revoked, and expired keys."}, {"lang": "es", "value": "La funci\u00f3n de cifrado \"Seguridad y privacidad\" en Mailpile anteriores a la versi\u00f3n 1.0.0rc4 no excluye las claves deshabilitadas, revocadas y caducadas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mailpile:mailpile:0.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A456464-BF2D-4F0E-B856-4BE3836B143F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mailpile:mailpile:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "3583944F-FA80-4DC9-A919-7DFAE3BE774D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mailpile:mailpile:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "C25F2328-C093-4AD6-836F-36C4AC81244E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mailpile:mailpile:1.0.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "3ADD9DC8-7504-4E04-A763-710FEB35EE8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mailpile:mailpile:1.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "022F8F59-46DF-40B1-B5ED-7A69D89BFD29"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mailpile:mailpile:1.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "52E34F82-8F01-47DD-BCE8-7E5615103A48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mailpile:mailpile:1.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "847A88F0-AE02-4147-842F-2520505C08C1"}]}]}], "references": [{"url": "https://github.com/mailpile/Mailpile/commit/49b64f62ade9ade3dff9337c7bbc1171eab3d59e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mailpile/Mailpile/compare/1.0.0rc3...1.0.0rc4", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/mailpile/Mailpile/pull/2145", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mailpile/Mailpile/commit/49b64f62ade9ade3dff9337c7bbc1171eab3d59e"}}