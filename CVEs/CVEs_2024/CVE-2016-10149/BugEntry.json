{"buggy_code": ["#!/usr/bin/env python\nimport re\n\nimport sys\n\nfrom setuptools import setup\nfrom setuptools.command.test import test as TestCommand\n\ninstall_requires = [\n    # core dependencies\n    'decorator',\n    'requests >= 1.0.0',\n    'future',\n    'paste',\n    'zope.interface',\n    'repoze.who',\n    'pycryptodomex',\n    'pytz',\n    'pyOpenSSL',\n    'python-dateutil',\n    'six'\n]\n\nversion = ''\nwith open('src/saml2/__init__.py', 'r') as fd:\n    version = re.search(r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]',\n                        fd.read(), re.MULTILINE).group(1)\n\nsetup(\n    name='pysaml2',\n    version=version,\n    description='Python implementation of SAML Version 2',\n    # long_description = read(\"README\"),\n    author='Roland Hedberg',\n    author_email='roland.hedberg@adm.umu.se',\n    license='Apache 2.0',\n    url='https://github.com/rohe/pysaml2',\n\n    packages=['saml2', 'saml2/xmldsig', 'saml2/xmlenc', 'saml2/s2repoze',\n              'saml2/s2repoze.plugins', \"saml2/profile\", \"saml2/schema\",\n              \"saml2/extension\", \"saml2/attributemaps\", \"saml2/authn_context\",\n              \"saml2/entity_category\", \"saml2/userinfo\", \"saml2/ws\"],\n\n    package_dir={'': 'src'},\n    package_data={'': ['xml/*.xml']},\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Programming Language :: Python :: 2.7\",\n        \"Programming Language :: Python :: 3.4\",\n        \"Programming Language :: Python :: 3.5\"\n    ],\n\n    scripts=[\"tools/parse_xsd2.py\", \"tools/make_metadata.py\",\n             \"tools/mdexport.py\", \"tools/merge_metadata.py\"],\n    install_requires=install_requires,\n    zip_safe=False,\n)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Contains base classes representing SAML elements.\n\n    These codes were originally written by Jeffrey Scudder for\n    representing Saml elements. Takashi Matsuo had added some codes, and\n    changed some. Roland Hedberg rewrote the whole thing from bottom up so\n    barely anything but the original structures remained.\n\n    Module objective: provide data classes for SAML constructs. These\n    classes hide the XML-ness of SAML and provide a set of native Python\n    classes to interact with.\n\n    Conversions to and from XML should only be necessary when the SAML classes\n    \"touch the wire\" and are sent over HTTP. For this reason this module\n    provides methods and functions to convert SAML classes to and from strings.\n\"\"\"\n\n__version__ = \"4.4.0\"\n\nimport logging\nimport six\nfrom saml2.validate import valid_instance\n\ntry:\n    from xml.etree import cElementTree as ElementTree\n\n    if ElementTree.VERSION < '1.3.0':\n        # cElementTree has no support for register_namespace\n        # neither _namespace_map, thus we sacrify performance\n        # for correctness\n        from xml.etree import ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        from elementtree import ElementTree\n\nroot_logger = logging.getLogger(__name__)\nroot_logger.level = logging.NOTSET\n\nNAMESPACE = 'urn:oasis:names:tc:SAML:2.0:assertion'\n# TEMPLATE = '{urn:oasis:names:tc:SAML:2.0:assertion}%s'\n# XSI_NAMESPACE = 'http://www.w3.org/2001/XMLSchema-instance'\n\nNAMEID_FORMAT_EMAILADDRESS = (\n    \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\")\n\n# These are defined in saml2.saml\n# NAME_FORMAT_UNSPECIFIED = (\n#    \"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\")\n# NAME_FORMAT_URI = \"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\"\n# NAME_FORMAT_BASIC = \"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\"\n\nDECISION_TYPE_PERMIT = \"Permit\"\nDECISION_TYPE_DENY = \"Deny\"\nDECISION_TYPE_INDETERMINATE = \"Indeterminate\"\n\nVERSION = \"2.0\"\n\nBINDING_SOAP = 'urn:oasis:names:tc:SAML:2.0:bindings:SOAP'\nBINDING_PAOS = 'urn:oasis:names:tc:SAML:2.0:bindings:PAOS'\nBINDING_HTTP_REDIRECT = 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect'\nBINDING_HTTP_POST = 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST'\nBINDING_HTTP_ARTIFACT = 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Artifact'\nBINDING_URI = 'urn:oasis:names:tc:SAML:2.0:bindings:URI'\n\n\ndef class_name(instance):\n    return \"%s:%s\" % (instance.c_namespace, instance.c_tag)\n\n\ndef create_class_from_xml_string(target_class, xml_string):\n    \"\"\"Creates an instance of the target class from a string.\n\n    :param target_class: The class which will be instantiated and populated\n        with the contents of the XML. This class must have a c_tag and a\n        c_namespace class variable.\n    :param xml_string: A string which contains valid XML. The root element\n        of the XML string should match the tag and namespace of the desired\n        class.\n\n    :return: An instance of the target class with members assigned according to\n        the contents of the XML - or None if the root XML tag and namespace did\n        not match those of the target class.\n    \"\"\"\n    if not isinstance(xml_string, six.binary_type):\n        xml_string = xml_string.encode('utf-8')\n    tree = ElementTree.fromstring(xml_string)\n    return create_class_from_element_tree(target_class, tree)\n\n\ndef create_class_from_element_tree(target_class, tree, namespace=None,\n                                   tag=None):\n    \"\"\"Instantiates the class and populates members according to the tree.\n\n    Note: Only use this function with classes that have c_namespace and c_tag\n    class members.\n\n    :param target_class: The class which will be instantiated and populated\n        with the contents of the XML.\n    :param tree: An element tree whose contents will be converted into\n        members of the new target_class instance.\n    :param namespace: The namespace which the XML tree's root node must\n        match. If omitted, the namespace defaults to the c_namespace of the\n        target class.\n    :param tag: The tag which the XML tree's root node must match. If\n        omitted, the tag defaults to the c_tag class member of the target\n        class.\n\n    :return: An instance of the target class - or None if the tag and namespace\n        of the XML tree's root node did not match the desired namespace and tag.\n    \"\"\"\n    if namespace is None:\n        namespace = target_class.c_namespace\n    if tag is None:\n        tag = target_class.c_tag\n    if tree.tag == '{%s}%s' % (namespace, tag):\n        target = target_class()\n        target.harvest_element_tree(tree)\n        return target\n    else:\n        return None\n\n\nclass Error(Exception):\n    \"\"\"Exception class thrown by this module.\"\"\"\n    pass\n\n\nclass SAMLError(Exception):\n    pass\n\n\nclass ExtensionElement(object):\n    \"\"\"XML which is not part of the SAML specification,\n    these are called extension elements. If a classes parser\n    encounters an unexpected XML construct, it is translated into an\n    ExtensionElement instance. ExtensionElement is designed to fully\n    capture the information in the XML. Child nodes in an XML\n    extension are turned into ExtensionElements as well.\n    \"\"\"\n\n    def __init__(self, tag, namespace=None, attributes=None,\n                 children=None, text=None):\n        \"\"\"Constructor for ExtensionElement\n\n        :param namespace: The XML namespace for this element.\n        :param tag: The tag (without the namespace qualifier) for\n            this element. To reconstruct the full qualified name of the\n            element, combine this tag with the namespace.\n        :param attributes: The attribute value string pairs for the XML\n            attributes of this element.\n        :param children: list (optional) A list of ExtensionElements which\n            represent the XML child nodes of this element.\n        \"\"\"\n\n        self.namespace = namespace\n        self.tag = tag\n        self.attributes = attributes or {}\n        self.children = children or []\n        self.text = text\n\n    def to_string(self):\n        \"\"\" Serialize the object into a XML string \"\"\"\n        element_tree = self.transfer_to_element_tree()\n        return ElementTree.tostring(element_tree, encoding=\"UTF-8\")\n\n    def transfer_to_element_tree(self):\n        if self.tag is None:\n            return None\n\n        element_tree = ElementTree.Element('')\n\n        if self.namespace is not None:\n            element_tree.tag = '{%s}%s' % (self.namespace, self.tag)\n        else:\n            element_tree.tag = self.tag\n\n        for key, value in iter(self.attributes.items()):\n            element_tree.attrib[key] = value\n\n        for child in self.children:\n            child.become_child_element_of(element_tree)\n\n        element_tree.text = self.text\n\n        return element_tree\n\n    def become_child_element_of(self, element_tree):\n        \"\"\"Converts this object into an etree element and adds it as a child\n        node in an etree element.\n\n        Adds self to the ElementTree. This method is required to avoid verbose\n        XML which constantly redefines the namespace.\n\n        :param element_tree: ElementTree._Element The element to which this\n            object's XML will be added.\n        \"\"\"\n        new_element = self.transfer_to_element_tree()\n        element_tree.append(new_element)\n\n    def find_children(self, tag=None, namespace=None):\n        \"\"\"Searches child nodes for objects with the desired tag/namespace.\n\n        Returns a list of extension elements within this object whose tag\n        and/or namespace match those passed in. To find all children in\n        a particular namespace, specify the namespace but not the tag name.\n        If you specify only the tag, the result list may contain extension\n        elements in multiple namespaces.\n\n        :param tag: str (optional) The desired tag\n        :param namespace: str (optional) The desired namespace\n\n        :return: A list of elements whose tag and/or namespace match the\n            parameters values\n        \"\"\"\n\n        results = []\n\n        if tag and namespace:\n            for element in self.children:\n                if element.tag == tag and element.namespace == namespace:\n                    results.append(element)\n        elif tag and not namespace:\n            for element in self.children:\n                if element.tag == tag:\n                    results.append(element)\n        elif namespace and not tag:\n            for element in self.children:\n                if element.namespace == namespace:\n                    results.append(element)\n        else:\n            for element in self.children:\n                results.append(element)\n\n        return results\n\n    def loadd(self, ava):\n        \"\"\" expects a special set of keys \"\"\"\n\n        if \"attributes\" in ava:\n            for key, val in ava[\"attributes\"].items():\n                self.attributes[key] = val\n\n        try:\n            self.tag = ava[\"tag\"]\n        except KeyError:\n            if not self.tag:\n                raise KeyError(\"ExtensionElement must have a tag\")\n\n        try:\n            self.namespace = ava[\"namespace\"]\n        except KeyError:\n            if not self.namespace:\n                raise KeyError(\"ExtensionElement must belong to a namespace\")\n\n        try:\n            self.text = ava[\"text\"]\n        except KeyError:\n            pass\n\n        if \"children\" in ava:\n            for item in ava[\"children\"]:\n                self.children.append(ExtensionElement(item[\"tag\"]).loadd(item))\n\n        return self\n\n\ndef extension_element_from_string(xml_string):\n    element_tree = ElementTree.fromstring(xml_string)\n    return _extension_element_from_element_tree(element_tree)\n\n\ndef _extension_element_from_element_tree(element_tree):\n    elementc_tag = element_tree.tag\n    if '}' in elementc_tag:\n        namespace = elementc_tag[1:elementc_tag.index('}')]\n        tag = elementc_tag[elementc_tag.index('}') + 1:]\n    else:\n        namespace = None\n        tag = elementc_tag\n    extension = ExtensionElement(namespace=namespace, tag=tag)\n    for key, value in iter(element_tree.attrib.items()):\n        extension.attributes[key] = value\n    for child in element_tree:\n        extension.children.append(_extension_element_from_element_tree(child))\n    extension.text = element_tree.text\n    return extension\n\n\nclass ExtensionContainer(object):\n    c_tag = \"\"\n    c_namespace = \"\"\n\n    def __init__(self, text=None, extension_elements=None,\n                 extension_attributes=None):\n\n        self.text = text\n        self.extension_elements = extension_elements or []\n        self.extension_attributes = extension_attributes or {}\n        self.encrypted_assertion = None\n\n    # Three methods to create an object from an ElementTree\n    def harvest_element_tree(self, tree):\n        # Fill in the instance members from the contents of the XML tree.\n        for child in tree:\n            self._convert_element_tree_to_member(child)\n        for attribute, value in iter(tree.attrib.items()):\n            self._convert_element_attribute_to_member(attribute, value)\n        self.text = tree.text\n\n    def _convert_element_tree_to_member(self, child_tree):\n        self.extension_elements.append(_extension_element_from_element_tree(\n            child_tree))\n\n    def _convert_element_attribute_to_member(self, attribute, value):\n        self.extension_attributes[attribute] = value\n\n    # One method to create an ElementTree from an object\n    def _add_members_to_element_tree(self, tree):\n        for child in self.extension_elements:\n            child.become_child_element_of(tree)\n        for attribute, value in iter(self.extension_attributes.items()):\n            tree.attrib[attribute] = value\n        tree.text = self.text\n\n    def find_extensions(self, tag=None, namespace=None):\n        \"\"\"Searches extension elements for child nodes with the desired name.\n\n        Returns a list of extension elements within this object whose tag\n        and/or namespace match those passed in. To find all extensions in\n        a particular namespace, specify the namespace but not the tag name.\n        If you specify only the tag, the result list may contain extension\n        elements in multiple namespaces.\n\n        :param tag: str (optional) The desired tag\n        :param namespace: str (optional) The desired namespace\n\n        :Return: A list of elements whose tag and/or namespace match the\n            parameters values\n        \"\"\"\n\n        results = []\n\n        if tag and namespace:\n            for element in self.extension_elements:\n                if element.tag == tag and element.namespace == namespace:\n                    results.append(element)\n        elif tag and not namespace:\n            for element in self.extension_elements:\n                if element.tag == tag:\n                    results.append(element)\n        elif namespace and not tag:\n            for element in self.extension_elements:\n                if element.namespace == namespace:\n                    results.append(element)\n        else:\n            for element in self.extension_elements:\n                results.append(element)\n\n        return results\n\n    def extensions_as_elements(self, tag, schema):\n        \"\"\" Return extensions that has the given tag and belongs to the\n        given schema as native elements of that schema.\n\n        :param tag: The tag of the element\n        :param schema: Which schema the element should originate from\n        :return: a list of native elements\n        \"\"\"\n        result = []\n        for ext in self.find_extensions(tag, schema.NAMESPACE):\n            ets = schema.ELEMENT_FROM_STRING[tag]\n            result.append(ets(ext.to_string()))\n        return result\n\n    def add_extension_elements(self, items):\n        for item in items:\n            self.extension_elements.append(element_to_extension_element(item))\n\n    def add_extension_element(self, item):\n        self.extension_elements.append(element_to_extension_element(item))\n\n    def add_extension_attribute(self, name, value):\n        self.extension_attributes[name] = value\n\n\ndef make_vals(val, klass, klass_inst=None, prop=None, part=False,\n              base64encode=False):\n    \"\"\"\n    Creates a class instance with a specified value, the specified\n    class instance may be a value on a property in a defined class instance.\n\n    :param val: The value\n    :param klass: The value class\n    :param klass_inst: The class instance which has a property on which\n        what this function returns is a value.\n    :param prop: The property which the value should be assigned to.\n    :param part: If the value is one of a possible list of values it should be\n        handled slightly different compared to if it isn't.\n    :return: Value class instance\n    \"\"\"\n    cinst = None\n\n    # print(\"make_vals(%s, %s)\" % (val, klass))\n\n    if isinstance(val, dict):\n        cinst = klass().loadd(val, base64encode=base64encode)\n    else:\n        try:\n            cinst = klass().set_text(val)\n        except ValueError:\n            if not part:\n                cis = [make_vals(sval, klass, klass_inst, prop, True,\n                                 base64encode) for sval in val]\n                setattr(klass_inst, prop, cis)\n            else:\n                raise\n\n    if part:\n        return cinst\n    else:\n        if cinst:\n            cis = [cinst]\n            setattr(klass_inst, prop, cis)\n\n\ndef make_instance(klass, spec, base64encode=False):\n    \"\"\"\n    Constructs a class instance containing the specified information\n\n    :param klass: The class\n    :param spec: Information to be placed in the instance (a dictionary)\n    :return: The instance\n    \"\"\"\n\n    return klass().loadd(spec, base64encode)\n\n\nclass SamlBase(ExtensionContainer):\n    \"\"\"A foundation class on which SAML classes are built. It\n    handles the parsing of attributes and children which are common to all\n    SAML classes. By default, the SamlBase class translates all XML child\n    nodes into ExtensionElements.\n    \"\"\"\n\n    c_children = {}\n    c_attributes = {}\n    c_attribute_type = {}\n    c_child_order = []\n    c_cardinality = {}\n    c_any = None\n    c_any_attribute = None\n    c_value_type = None\n    c_ns_prefix = None\n\n    def _get_all_c_children_with_order(self):\n        if len(self.c_child_order) > 0:\n            for child in self.c_child_order:\n                yield child\n        else:\n            for _, values in iter(self.__class__.c_children.items()):\n                yield values[0]\n\n    def _convert_element_tree_to_member(self, child_tree):\n        # Find the element's tag in this class's list of child members\n        if child_tree.tag in self.__class__.c_children:\n            member_name = self.__class__.c_children[child_tree.tag][0]\n            member_class = self.__class__.c_children[child_tree.tag][1]\n            # If the class member is supposed to contain a list, make sure the\n            # matching member is set to a list, then append the new member\n            # instance to the list.\n            if isinstance(member_class, list):\n                if getattr(self, member_name) is None:\n                    setattr(self, member_name, [])\n                getattr(self, member_name).append(\n                    create_class_from_element_tree(member_class[0], child_tree))\n            else:\n                setattr(self, member_name,\n                        create_class_from_element_tree(member_class,\n                                                       child_tree))\n        else:\n            ExtensionContainer._convert_element_tree_to_member(self, child_tree)\n\n    def _convert_element_attribute_to_member(self, attribute, value):\n        # Find the attribute in this class's list of attributes.\n        if attribute in self.__class__.c_attributes:\n            # Find the member of this class which corresponds to the XML\n            # attribute(lookup in current_class.c_attributes) and set this\n            # member to the desired value (using self.__dict__).\n            setattr(self, self.__class__.c_attributes[attribute][0], value)\n        else:\n            # If it doesn't appear in the attribute list it's an extension\n            ExtensionContainer._convert_element_attribute_to_member(\n                self, attribute, value)\n\n    # Three methods to create an ElementTree from an object\n    def _add_members_to_element_tree(self, tree):\n        # Convert the members of this class which are XML child nodes.\n        # This uses the class's c_children dictionary to find the members which\n        # should become XML child nodes.\n        for member_name in self._get_all_c_children_with_order():\n            member = getattr(self, member_name)\n            if member is None:\n                pass\n            elif isinstance(member, list):\n                for instance in member:\n                    instance.become_child_element_of(tree)\n            else:\n                member.become_child_element_of(tree)\n        # Convert the members of this class which are XML attributes.\n        for xml_attribute, attribute_info in \\\n                iter(self.__class__.c_attributes.items()):\n            (member_name, member_type, required) = attribute_info\n            member = getattr(self, member_name)\n            if member is not None:\n                tree.attrib[xml_attribute] = member\n\n        # Lastly, call the ExtensionContainers's _add_members_to_element_tree\n        # to convert any extension attributes.\n        ExtensionContainer._add_members_to_element_tree(self, tree)\n\n    def become_child_element_of(self, node):\n        \"\"\"\n        Note: Only for use with classes that have a c_tag and c_namespace class\n        member. It is in SamlBase so that it can be inherited but it should\n        not be called on instances of SamlBase.\n\n        :param node: The node to which this instance should be a child\n        \"\"\"\n        new_child = self._to_element_tree()\n        node.append(new_child)\n\n    def _to_element_tree(self):\n        \"\"\"\n\n        Note, this method is designed to be used only with classes that have a\n        c_tag and c_namespace. It is placed in SamlBase for inheritance but\n        should not be called on in this class.\n\n        \"\"\"\n        new_tree = ElementTree.Element('{%s}%s' % (self.__class__.c_namespace,\n                                                   self.__class__.c_tag))\n        self._add_members_to_element_tree(new_tree)\n        return new_tree\n\n    def register_prefix(self, nspair):\n        \"\"\"\n        Register with ElementTree a set of namespaces\n\n        :param nspair: A dictionary of prefixes and uris to use when\n            constructing the text representation.\n        :return:\n        \"\"\"\n        for prefix, uri in nspair.items():\n            try:\n                ElementTree.register_namespace(prefix, uri)\n            except AttributeError:\n                # Backwards compatibility with ET < 1.3\n                ElementTree._namespace_map[uri] = prefix\n            except ValueError:\n                pass\n\n    def get_ns_map_attribute(self, attributes, uri_set):\n        for attribute in attributes:\n            if attribute[0] == \"{\":\n                uri, tag = attribute[1:].split(\"}\")\n                uri_set.add(uri)\n        return uri_set\n\n    def tag_get_uri(self, elem):\n        if elem.tag[0] == \"{\":\n            uri, tag = elem.tag[1:].split(\"}\")\n            return uri\n        return None\n\n    def get_ns_map(self, elements, uri_set):\n\n        for elem in elements:\n            uri_set = self.get_ns_map_attribute(elem.attrib, uri_set)\n            uri_set = self.get_ns_map(elem.getchildren(), uri_set)\n            uri = self.tag_get_uri(elem)\n            if uri is not None:\n                uri_set.add(uri)\n        return uri_set\n\n    def get_prefix_map(self, elements):\n        uri_set = self.get_ns_map(elements, set())\n        prefix_map = {}\n        for uri in sorted(uri_set):\n            prefix_map[\"encas%d\" % len(prefix_map)] = uri\n        return prefix_map\n\n    def get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n            self, assertion_tag, advice_tag):\n        for tmp_encrypted_assertion in \\\n                self.assertion.advice.encrypted_assertion:\n            if tmp_encrypted_assertion.encrypted_data is None:\n                prefix_map = self.get_prefix_map([\n                                                     tmp_encrypted_assertion._to_element_tree().find(\n                                                         assertion_tag)])\n                tree = self._to_element_tree()\n                encs = tree.find(assertion_tag).find(advice_tag).findall(\n                    tmp_encrypted_assertion._to_element_tree().tag)\n                for enc in encs:\n                    assertion = enc.find(assertion_tag)\n                    if assertion is not None:\n                        self.set_prefixes(assertion, prefix_map)\n\n        return ElementTree.tostring(tree, encoding=\"UTF-8\").decode('utf-8')\n\n    def get_xml_string_with_self_contained_assertion_within_encrypted_assertion(\n            self, assertion_tag):\n        \"\"\" Makes a encrypted assertion only containing self contained\n        namespaces.\n\n        :param assertion_tag: Tag for the assertion to be transformed.\n        :return: A new samlp.Resonse in string representation.\n        \"\"\"\n        prefix_map = self.get_prefix_map(\n            [self.encrypted_assertion._to_element_tree().find(assertion_tag)])\n\n        tree = self._to_element_tree()\n\n        self.set_prefixes(\n            tree.find(\n                self.encrypted_assertion._to_element_tree().tag).find(\n                assertion_tag), prefix_map)\n\n        return ElementTree.tostring(tree, encoding=\"UTF-8\").decode('utf-8')\n\n    def set_prefixes(self, elem, prefix_map):\n\n        # check if this is a tree wrapper\n        if not ElementTree.iselement(elem):\n            elem = elem.getroot()\n\n        # build uri map and add to root element\n        uri_map = {}\n        for prefix, uri in prefix_map.items():\n            uri_map[uri] = prefix\n            elem.set(\"xmlns:\" + prefix, uri)\n\n        # fixup all elements in the tree\n        memo = {}\n        for elem in elem.getiterator():\n            self.fixup_element_prefixes(elem, uri_map, memo)\n\n    def fixup_element_prefixes(self, elem, uri_map, memo):\n        def fixup(name):\n            try:\n                return memo[name]\n            except KeyError:\n                if name[0] != \"{\":\n                    return\n                uri, tag = name[1:].split(\"}\")\n                if uri in uri_map:\n                    new_name = uri_map[uri] + \":\" + tag\n                    memo[name] = new_name\n                    return new_name\n\n        # fix element name\n        name = fixup(elem.tag)\n        if name:\n            elem.tag = name\n        # fix attribute names\n        for key, value in elem.items():\n            name = fixup(key)\n            if name:\n                elem.set(name, value)\n                del elem.attrib[key]\n\n    def to_string_force_namespace(self, nspair):\n\n        elem = self._to_element_tree()\n\n        self.set_prefixes(elem, nspair)\n\n        return ElementTree.tostring(elem, encoding=\"UTF-8\")\n\n    def to_string(self, nspair=None):\n        \"\"\"Converts the Saml object to a string containing XML.\n\n        :param nspair: A dictionary of prefixes and uris to use when\n            constructing the text representation.\n        :return: String representation of the object\n        \"\"\"\n        if not nspair and self.c_ns_prefix:\n            nspair = self.c_ns_prefix\n\n        if nspair:\n            self.register_prefix(nspair)\n\n        return ElementTree.tostring(self._to_element_tree(), encoding=\"UTF-8\")\n\n    def __str__(self):\n        # Yes this is confusing. http://bugs.python.org/issue10942\n        x = self.to_string()\n        if not isinstance(x, six.string_types):\n            x = x.decode('utf-8')\n        return x\n\n    def keyswv(self):\n        \"\"\" Return the keys of attributes or children that has values\n\n        :return: list of keys\n        \"\"\"\n        return [key for key, val in self.__dict__.items() if val]\n\n    def keys(self):\n        \"\"\" Return all the keys that represent possible attributes and\n        children.\n\n        :return: list of keys\n        \"\"\"\n        keys = ['text']\n        keys.extend([n for (n, t, r) in self.c_attributes.values()])\n        keys.extend([v[0] for v in self.c_children.values()])\n        return keys\n\n    def children_with_values(self):\n        \"\"\" Returns all children that has values\n\n        :return: Possibly empty list of children.\n        \"\"\"\n        childs = []\n        for attribute in self._get_all_c_children_with_order():\n            member = getattr(self, attribute)\n            if member is None or member == []:\n                pass\n            elif isinstance(member, list):\n                for instance in member:\n                    childs.append(instance)\n            else:\n                childs.append(member)\n        return childs\n\n    # noinspection PyUnusedLocal\n    def set_text(self, val, base64encode=False):\n        \"\"\" Sets the text property of this instance.\n\n        :param val: The value of the text property\n        :param base64encode: Whether the value should be base64encoded\n        :return: The instance\n        \"\"\"\n\n        # print(\"set_text: %s\" % (val,))\n        if isinstance(val, bool):\n            if val:\n                setattr(self, \"text\", \"true\")\n            else:\n                setattr(self, \"text\", \"false\")\n        elif isinstance(val, int):\n            setattr(self, \"text\", \"%d\" % val)\n        elif isinstance(val, six.string_types):\n            setattr(self, \"text\", val)\n        elif val is None:\n            pass\n        else:\n            raise ValueError(\"Type shouldn't be '%s'\" % (val,))\n\n        return self\n\n    def loadd(self, ava, base64encode=False):\n        \"\"\"\n        Sets attributes, children, extension elements and extension\n        attributes of this element instance depending on what is in\n        the given dictionary. If there are already values on properties\n        those will be overwritten. If the keys in the dictionary does\n        not correspond to known attributes/children/.. they are ignored.\n\n        :param ava: The dictionary\n        :param base64encode: Whether the values on attributes or texts on\n            children shoule be base64encoded.\n        :return: The instance\n        \"\"\"\n\n        for prop, _typ, _req in self.c_attributes.values():\n            # print(\"# %s\" % (prop))\n            if prop in ava:\n                if isinstance(ava[prop], bool):\n                    setattr(self, prop, \"%s\" % ava[prop])\n                elif isinstance(ava[prop], int):\n                    setattr(self, prop, \"%d\" % ava[prop])\n                else:\n                    setattr(self, prop, ava[prop])\n\n        if \"text\" in ava:\n            self.set_text(ava[\"text\"], base64encode)\n\n        for prop, klassdef in self.c_children.values():\n            # print(\"## %s, %s\" % (prop, klassdef))\n            if prop in ava:\n                # print(\"### %s\" % ava[prop])\n                # means there can be a list of values\n                if isinstance(klassdef, list):\n                    make_vals(ava[prop], klassdef[0], self, prop,\n                              base64encode=base64encode)\n                else:\n                    cis = make_vals(ava[prop], klassdef, self, prop, True,\n                                    base64encode)\n                    setattr(self, prop, cis)\n\n        if \"extension_elements\" in ava:\n            for item in ava[\"extension_elements\"]:\n                self.extension_elements.append(ExtensionElement(\n                    item[\"tag\"]).loadd(item))\n\n        if \"extension_attributes\" in ava:\n            for key, val in ava[\"extension_attributes\"].items():\n                self.extension_attributes[key] = val\n\n        return self\n\n    def clear_text(self):\n        if self.text:\n            _text = self.text.strip()\n            if _text == \"\":\n                self.text = None\n\n    def __eq__(self, other):\n        try:\n            assert isinstance(other, SamlBase)\n        except AssertionError:\n            return False\n\n        self.clear_text()\n        other.clear_text()\n        if len(self.keyswv()) != len(other.keyswv()):\n            return False\n\n        for key in self.keyswv():\n            if key in [\"_extatt\"]:\n                continue\n            svals = self.__dict__[key]\n            ovals = other.__dict__[key]\n            if isinstance(svals, six.string_types):\n                if svals != ovals:\n                    return False\n            elif isinstance(svals, list):\n                for sval in svals:\n                    try:\n                        for oval in ovals:\n                            if sval == oval:\n                                break\n                        else:\n                            return False\n                    except TypeError:\n                        # ovals isn't iterable\n                        return False\n            else:\n                if svals == ovals:  # Since I only support '=='\n                    pass\n                else:\n                    return False\n        return True\n\n    def child_class(self, child):\n        \"\"\" Return the class a child element should be an instance of\n\n        :param child: The name of the child element\n        :return: The class\n        \"\"\"\n        for prop, klassdef in self.c_children.values():\n            if child == prop:\n                if isinstance(klassdef, list):\n                    return klassdef[0]\n                else:\n                    return klassdef\n        return None\n\n    def child_cardinality(self, child):\n        \"\"\" Return the cardinality of a child element\n\n        :param child: The name of the child element\n        :return: The cardinality as a 2-tuple (min, max).\n            The max value is either a number or the string \"unbounded\".\n            The min value is always a number.\n        \"\"\"\n        for prop, klassdef in self.c_children.values():\n            if child == prop:\n                if isinstance(klassdef, list):\n                    try:\n                        _min = self.c_cardinality[\"min\"]\n                    except KeyError:\n                        _min = 1\n                    try:\n                        _max = self.c_cardinality[\"max\"]\n                    except KeyError:\n                        _max = \"unbounded\"\n\n                    return _min, _max\n                else:\n                    return 1, 1\n        return None\n\n    def verify(self):\n        return valid_instance(self)\n\n    def empty(self):\n        for prop, _typ, _req in self.c_attributes.values():\n            if getattr(self, prop, None):\n                return False\n\n        for prop, klassdef in self.c_children.values():\n            if getattr(self, prop):\n                return False\n\n        for param in [\"text\", \"extension_elements\", \"extension_attributes\"]:\n            if getattr(self, param):\n                return False\n\n        return True\n\n\n# ----------------------------------------------------------------------------\n\n\ndef element_to_extension_element(element):\n    \"\"\"\n    Convert an element into a extension element\n\n    :param element: The element instance\n    :return: An extension element instance\n    \"\"\"\n\n    exel = ExtensionElement(element.c_tag, element.c_namespace,\n                            text=element.text)\n\n    exel.attributes.update(element.extension_attributes)\n    exel.children.extend(element.extension_elements)\n\n    for xml_attribute, (member_name, typ, req) in \\\n            iter(element.c_attributes.items()):\n        member_value = getattr(element, member_name)\n        if member_value is not None:\n            exel.attributes[xml_attribute] = member_value\n\n    exel.children.extend([element_to_extension_element(c) for c in\n                          element.children_with_values()])\n\n    return exel\n\n\ndef extension_element_to_element(extension_element, translation_functions,\n                                 namespace=None):\n    \"\"\" Convert an extension element to a normal element.\n    In order to do this you need to have an idea of what type of\n    element it is. Or rather which module it belongs to.\n\n    :param extension_element: The extension element\n    :param translation_functions: A dictionary with class identifiers\n        as keys and string-to-element translations functions as values\n    :param namespace: The namespace of the translation functions.\n    :return: An element instance or None\n    \"\"\"\n\n    try:\n        element_namespace = extension_element.namespace\n    except AttributeError:\n        element_namespace = extension_element.c_namespace\n    if element_namespace == namespace:\n        try:\n            try:\n                ets = translation_functions[extension_element.tag]\n            except AttributeError:\n                ets = translation_functions[extension_element.c_tag]\n            return ets(extension_element.to_string())\n        except KeyError:\n            pass\n\n    return None\n\n\ndef extension_elements_to_elements(extension_elements, schemas):\n    \"\"\" Create a list of elements each one matching one of the\n    given extension elements. This is of course dependent on the access\n    to schemas that describe the extension elements.\n\n    :param extension_elements: The list of extension elements\n    :param schemas: Imported Python modules that represent the different\n        known schemas used for the extension elements\n    :return: A list of elements, representing the set of extension elements\n        that was possible to match against a Class in the given schemas.\n        The elements returned are the native representation of the elements\n        according to the schemas.\n    \"\"\"\n    res = []\n\n    if isinstance(schemas, list):\n        pass\n    elif isinstance(schemas, dict):\n        schemas = list(schemas.values())\n    else:\n        return res\n\n    for extension_element in extension_elements:\n        for schema in schemas:\n            inst = extension_element_to_element(extension_element,\n                                                schema.ELEMENT_FROM_STRING,\n                                                schema.NAMESPACE)\n            if inst:\n                res.append(inst)\n                break\n\n    return res\n\n\ndef extension_elements_as_dict(extension_elements, onts):\n    ees_ = extension_elements_to_elements(extension_elements, onts)\n    res = {}\n    for elem in ees_:\n        try:\n            res[elem.c_tag].append(elem)\n        except KeyError:\n            res[elem.c_tag] = [elem]\n    return res\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n\n\"\"\"Contains classes and functions that are necessary to implement\ndifferent bindings.\n\nBindings normally consists of three parts:\n- rules about what to send\n- how to package the information\n- which protocol to use\n\"\"\"\nfrom six.moves.urllib.parse import urlparse, urlencode\nimport saml2\nimport base64\nfrom saml2.s_utils import deflate_and_base64_encode\nfrom saml2.s_utils import Unsupported\nimport logging\nfrom saml2.sigver import REQ_ORDER\nfrom saml2.sigver import RESP_ORDER\nfrom saml2.sigver import SIGNER_ALGS\nimport six\nfrom saml2.xmldsig import SIG_ALLOWED_ALG\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    from xml.etree import cElementTree as ElementTree\n\n    if ElementTree.VERSION < '1.3.0':\n        # cElementTree has no support for register_namespace\n        # neither _namespace_map, thus we sacrify performance\n        # for correctness\n        from xml.etree import ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        from elementtree import ElementTree\n\nNAMESPACE = \"http://schemas.xmlsoap.org/soap/envelope/\"\nFORM_SPEC = \"\"\"<form method=\"post\" action=\"%s\">\n   <input type=\"hidden\" name=\"%s\" value=\"%s\" />\n   <input type=\"hidden\" name=\"RelayState\" value=\"%s\" />\n   <input type=\"submit\" value=\"Submit\" />\n</form>\"\"\"\n\n\ndef http_form_post_message(message, location, relay_state=\"\",\n                           typ=\"SAMLRequest\", **kwargs):\n    \"\"\"The HTTP POST binding defines a mechanism by which SAML protocol\n    messages may be transmitted within the base64-encoded content of a\n    HTML form control.\n\n    :param message: The message\n    :param location: Where the form should be posted to\n    :param relay_state: for preserving and conveying state information\n    :return: A tuple containing header information and a HTML message.\n    \"\"\"\n    response = [\"<head>\", \"\"\"<title>SAML 2.0 POST</title>\"\"\", \"</head><body>\"]\n\n    if not isinstance(message, six.string_types):\n        message = str(message)\n    if not isinstance(message, six.binary_type):\n        message = message.encode('utf-8')\n\n    if typ == \"SAMLRequest\" or typ == \"SAMLResponse\":\n        _msg = base64.b64encode(message)\n    else:\n        _msg = message\n    _msg = _msg.decode('ascii')\n\n    response.append(FORM_SPEC % (location, typ, _msg, relay_state))\n\n    response.append(\"\"\"<script type=\"text/javascript\">\"\"\")\n    response.append(\"     window.onload = function ()\")\n    response.append(\" { document.forms[0].submit(); }\")\n    response.append(\"\"\"</script>\"\"\")\n    response.append(\"</body>\")\n\n    return {\"headers\": [(\"Content-type\", \"text/html\")], \"data\": response}\n\n\ndef http_post_message(message, relay_state=\"\", typ=\"SAMLRequest\", **kwargs):\n    \"\"\"\n\n    :param message: The message\n    :param relay_state: for preserving and conveying state information\n    :return: A tuple containing header information and a HTML message.\n    \"\"\"\n    if not isinstance(message, six.string_types):\n        message = str(message)\n    if not isinstance(message, six.binary_type):\n        message = message.encode('utf-8')\n\n    if typ == \"SAMLRequest\" or typ == \"SAMLResponse\":\n        _msg = base64.b64encode(message)\n    else:\n        _msg = message\n    _msg = _msg.decode('ascii')\n\n    part = {typ: _msg}\n    if relay_state:\n        part[\"RelayState\"] = relay_state\n\n    return {\"headers\": [(\"Content-type\", 'application/x-www-form-urlencoded')],\n            \"data\": urlencode(part)}\n\n\ndef http_redirect_message(message, location, relay_state=\"\", typ=\"SAMLRequest\",\n                          sigalg='', signer=None, **kwargs):\n    \"\"\"The HTTP Redirect binding defines a mechanism by which SAML protocol\n    messages can be transmitted within URL parameters.\n    Messages are encoded for use with this binding using a URL encoding\n    technique, and transmitted using the HTTP GET method.\n\n    The DEFLATE Encoding is used in this function.\n\n    :param message: The message\n    :param location: Where the message should be posted to\n    :param relay_state: for preserving and conveying state information\n    :param typ: What type of message it is SAMLRequest/SAMLResponse/SAMLart\n    :param sigalg: Which algorithm the signature function will use to sign\n        the message\n    :param signer: A signature function that can be used to sign the message\n    :return: A tuple containing header information and a HTML message.\n    \"\"\"\n\n    if not isinstance(message, six.string_types):\n        message = \"%s\" % (message,)\n\n    _order = None\n    if typ in [\"SAMLRequest\", \"SAMLResponse\"]:\n        if typ == \"SAMLRequest\":\n            _order = REQ_ORDER\n        else:\n            _order = RESP_ORDER\n        args = {typ: deflate_and_base64_encode(message)}\n    elif typ == \"SAMLart\":\n        args = {typ: message}\n    else:\n        raise Exception(\"Unknown message type: %s\" % typ)\n\n    if relay_state:\n        args[\"RelayState\"] = relay_state\n\n    if signer:\n        # sigalgs, should be one defined in xmldsig\n        assert sigalg in [b for a, b in SIG_ALLOWED_ALG]\n        args[\"SigAlg\"] = sigalg\n\n        string = \"&\".join([urlencode({k: args[k]})\n                           for k in _order if k in args]).encode('ascii')\n        args[\"Signature\"] = base64.b64encode(signer.sign(string))\n        string = urlencode(args)\n    else:\n        string = urlencode(args)\n\n    glue_char = \"&\" if urlparse(location).query else \"?\"\n    login_url = glue_char.join([location, string])\n    headers = [('Location', str(login_url))]\n    body = []\n\n    return {\"headers\": headers, \"data\": body}\n\n\nDUMMY_NAMESPACE = \"http://example.org/\"\nPREFIX = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n\n\ndef make_soap_enveloped_saml_thingy(thingy, header_parts=None):\n    \"\"\" Returns a soap envelope containing a SAML request\n    as a text string.\n\n    :param thingy: The SAML thingy\n    :return: The SOAP envelope as a string\n    \"\"\"\n    envelope = ElementTree.Element('')\n    envelope.tag = '{%s}Envelope' % NAMESPACE\n\n    if header_parts:\n        header = ElementTree.Element('')\n        header.tag = '{%s}Header' % NAMESPACE\n        envelope.append(header)\n        for part in header_parts:\n            # This doesn't work if the headers are signed\n            part.become_child_element_of(header)\n\n    body = ElementTree.Element('')\n    body.tag = '{%s}Body' % NAMESPACE\n    envelope.append(body)\n\n    if isinstance(thingy, six.string_types):\n        # remove the first XML version/encoding line\n        if thingy[0:5].lower() == '<?xml':\n            logger.debug(\"thingy0: %s\", thingy)\n            _part = thingy.split(\"\\n\")\n            thingy = \"\".join(_part[1:])\n        thingy = thingy.replace(PREFIX, \"\")\n        logger.debug(\"thingy: %s\", thingy)\n        _child = ElementTree.Element('')\n        _child.tag = '{%s}FuddleMuddle' % DUMMY_NAMESPACE\n        body.append(_child)\n        _str = ElementTree.tostring(envelope, encoding=\"UTF-8\")\n        if isinstance(_str, six.binary_type):\n            _str = _str.decode('utf-8')\n        logger.debug(\"SOAP precursor: %s\", _str)\n        # find an remove the namespace definition\n        i = _str.find(DUMMY_NAMESPACE)\n        j = _str.rfind(\"xmlns:\", 0, i)\n        cut1 = _str[j:i + len(DUMMY_NAMESPACE) + 1]\n        _str = _str.replace(cut1, \"\")\n        first = _str.find(\"<%s:FuddleMuddle\" % (cut1[6:9],))\n        last = _str.find(\">\", first + 14)\n        cut2 = _str[first:last + 1]\n        return _str.replace(cut2, thingy)\n    else:\n        thingy.become_child_element_of(body)\n        return ElementTree.tostring(envelope, encoding=\"UTF-8\")\n\n\ndef http_soap_message(message):\n    return {\"headers\": [(\"Content-type\", \"application/soap+xml\")],\n            \"data\": make_soap_enveloped_saml_thingy(message)}\n\n\ndef http_paos(message, extra=None):\n    return {\"headers\": [(\"Content-type\", \"application/soap+xml\")],\n            \"data\": make_soap_enveloped_saml_thingy(message, extra)}\n\n\ndef parse_soap_enveloped_saml(text, body_class, header_class=None):\n    \"\"\"Parses a SOAP enveloped SAML thing and returns header parts and body\n\n    :param text: The SOAP object as XML\n    :return: header parts and body as saml.samlbase instances\n    \"\"\"\n    envelope = ElementTree.fromstring(text)\n    assert envelope.tag == '{%s}Envelope' % NAMESPACE\n\n    # print(len(envelope))\n    body = None\n    header = {}\n    for part in envelope:\n        # print(\">\",part.tag)\n        if part.tag == '{%s}Body' % NAMESPACE:\n            for sub in part:\n                try:\n                    body = saml2.create_class_from_element_tree(body_class, sub)\n                except Exception:\n                    raise Exception(\n                        \"Wrong body type (%s) in SOAP envelope\" % sub.tag)\n        elif part.tag == '{%s}Header' % NAMESPACE:\n            if not header_class:\n                raise Exception(\"Header where I didn't expect one\")\n            # print(\"--- HEADER ---\")\n            for sub in part:\n                # print(\">>\",sub.tag)\n                for klass in header_class:\n                    # print(\"?{%s}%s\" % (klass.c_namespace,klass.c_tag))\n                    if sub.tag == \"{%s}%s\" % (klass.c_namespace, klass.c_tag):\n                        header[sub.tag] = \\\n                            saml2.create_class_from_element_tree(klass, sub)\n                        break\n\n    return body, header\n\n\n# -----------------------------------------------------------------------------\n\nPACKING = {\n    saml2.BINDING_HTTP_REDIRECT: http_redirect_message,\n    saml2.BINDING_HTTP_POST: http_form_post_message,\n}\n\n\ndef packager(identifier):\n    try:\n        return PACKING[identifier]\n    except KeyError:\n        raise Exception(\"Unknown binding type: %s\" % identifier)\n\n\ndef factory(binding, message, location, relay_state=\"\", typ=\"SAMLRequest\",\n            **kwargs):\n    return PACKING[binding](message, location, relay_state, typ, **kwargs)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n\n\"\"\"\nSuppport for the client part of the SAML2.0 SOAP binding.\n\"\"\"\nimport logging\n\nfrom saml2 import create_class_from_element_tree\nfrom saml2.samlp import NAMESPACE as SAMLP_NAMESPACE\nfrom saml2.schema import soapenv\n\ntry:\n    from xml.etree import cElementTree as ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        #noinspection PyUnresolvedReferences\n        from elementtree import ElementTree\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass XmlParseError(Exception):\n    pass\n\n\nclass WrongMessageType(Exception):\n    pass\n\n\ndef parse_soap_enveloped_saml_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE,\n            '{%s}LogoutResponse' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_logout_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE,\n            '{%s}LogoutResponse' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_attribute_query(text):\n    expected_tag = '{%s}AttributeQuery' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_attribute_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE,\n            '{%s}AttributeResponse' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_logout_request(text):\n    expected_tag = '{%s}LogoutRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_authn_request(text):\n    expected_tag = '{%s}AuthnRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_artifact_resolve(text):\n    expected_tag = '{%s}ArtifactResolve' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_artifact_response(text):\n    expected_tag = '{%s}ArtifactResponse' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_name_id_mapping_request(text):\n    expected_tag = '{%s}NameIDMappingRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_name_id_mapping_response(text):\n    expected_tag = '{%s}NameIDMappingResponse' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_manage_name_id_request(text):\n    expected_tag = '{%s}ManageNameIDRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_manage_name_id_response(text):\n    expected_tag = '{%s}ManageNameIDResponse' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_assertion_id_request(text):\n    expected_tag = '{%s}AssertionIDRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_assertion_id_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE,\n            '{%s}AssertionIDResponse' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_authn_query(text):\n    expected_tag = '{%s}AuthnQuery' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_authn_query_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_authn_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\n#def parse_soap_enveloped_saml_logout_response(text):\n#    expected_tag = '{%s}LogoutResponse' % SAMLP_NAMESPACE\n#    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\ndef parse_soap_enveloped_saml_thingy(text, expected_tags):\n    \"\"\"Parses a SOAP enveloped SAML thing and returns the thing as\n    a string.\n\n    :param text: The SOAP object as XML string\n    :param expected_tags: What the tag of the SAML thingy is expected to be.\n    :return: SAML thingy as a string\n    \"\"\"\n    envelope = ElementTree.fromstring(text)\n\n    # Make sure it's a SOAP message\n    assert envelope.tag == '{%s}Envelope' % soapenv.NAMESPACE\n\n    assert len(envelope) >= 1\n    body = None\n    for part in envelope:\n        if part.tag == '{%s}Body' % soapenv.NAMESPACE:\n            assert len(part) == 1\n            body = part\n            break\n\n    if body is None:\n        return \"\"\n\n    saml_part = body[0]\n    if saml_part.tag in expected_tags:\n        return ElementTree.tostring(saml_part, encoding=\"UTF-8\")\n    else:\n        raise WrongMessageType(\"Was '%s' expected one of %s\" % (saml_part.tag,\n                                                                expected_tags))\n\nimport re\n\nNS_AND_TAG = re.compile(\"\\{([^}]+)\\}(.*)\")\n\n\ndef instanciate_class(item, modules):\n    m = NS_AND_TAG.match(item.tag)\n    ns, tag = m.groups()\n    for module in modules:\n        if module.NAMESPACE == ns:\n            try:\n                target = module.ELEMENT_BY_TAG[tag]\n                return create_class_from_element_tree(target, item)\n            except KeyError:\n                continue\n    raise Exception(\"Unknown class: ns='%s', tag='%s'\" % (ns, tag))\n\n\ndef class_instances_from_soap_enveloped_saml_thingies(text, modules):\n    \"\"\"Parses a SOAP enveloped header and body SAML thing and returns the\n    thing as a dictionary class instance.\n\n    :param text: The SOAP object as XML\n    :param modules: modules representing xsd schemas\n    :return: The body and headers as class instances\n    \"\"\"\n    try:\n        envelope = ElementTree.fromstring(text)\n    except Exception as exc:\n        raise XmlParseError(\"%s\" % exc)\n\n    assert envelope.tag == '{%s}Envelope' % soapenv.NAMESPACE\n    assert len(envelope) >= 1\n    env = {\"header\": [], \"body\": None}\n\n    for part in envelope:\n        if part.tag == '{%s}Body' % soapenv.NAMESPACE:\n            assert len(part) == 1\n            env[\"body\"] = instanciate_class(part[0], modules)\n        elif part.tag == \"{%s}Header\" % soapenv.NAMESPACE:\n            for item in part:\n                env[\"header\"].append(instanciate_class(item, modules))\n\n    return env\n\n\ndef open_soap_envelope(text):\n    \"\"\"\n\n    :param text: SOAP message\n    :return: dictionary with two keys \"body\"/\"header\"\n    \"\"\"\n    try:\n        envelope = ElementTree.fromstring(text)\n    except Exception as exc:\n        raise XmlParseError(\"%s\" % exc)\n\n    assert envelope.tag == '{%s}Envelope' % soapenv.NAMESPACE\n    assert len(envelope) >= 1\n    content = {\"header\": [], \"body\": None}\n\n    for part in envelope:\n        if part.tag == '{%s}Body' % soapenv.NAMESPACE:\n            assert len(part) == 1\n            content[\"body\"] = ElementTree.tostring(part[0], encoding=\"UTF-8\")\n        elif part.tag == \"{%s}Header\" % soapenv.NAMESPACE:\n            for item in part:\n                _str = ElementTree.tostring(item, encoding=\"UTF-8\")\n                content[\"header\"].append(_str)\n\n    return content\n\n\ndef make_soap_enveloped_saml_thingy(thingy, headers=None):\n    \"\"\" Returns a soap envelope containing a SAML request\n    as a text string.\n\n    :param thingy: The SAML thingy\n    :return: The SOAP envelope as a string\n    \"\"\"\n    soap_envelope = soapenv.Envelope()\n\n    if headers:\n        _header = soapenv.Header()\n        _header.add_extension_elements(headers)\n        soap_envelope.header = _header\n\n    soap_envelope.body = soapenv.Body()\n    soap_envelope.body.add_extension_element(thingy)\n\n    return \"%s\" % soap_envelope\n\n\ndef soap_fault(message=None, actor=None, code=None, detail=None):\n    \"\"\" Create a SOAP Fault message\n\n    :param message: Human readable error message\n    :param actor: Who discovered the error\n    :param code: Error code\n    :param detail: More specific error message\n    :return: A SOAP Fault message as a string\n    \"\"\"\n    _string = _actor = _code = _detail = None\n\n    if message:\n        _string = soapenv.Fault_faultstring(text=message)\n    if actor:\n        _actor = soapenv.Fault_faultactor(text=actor)\n    if code:\n        _code = soapenv.Fault_faultcode(text=code)\n    if detail:\n        _detail = soapenv.Fault_detail(text=detail)\n\n    fault = soapenv.Fault(\n        faultcode=_code,\n        faultstring=_string,\n        faultactor=_actor,\n        detail=_detail,\n    )\n\n    return \"%s\" % fault\n", "#!/usr/bin/env python\n\nimport saml2\n\nfrom saml2 import create_class_from_xml_string, class_name, make_vals, md\nfrom saml2.saml import NameID, Issuer, SubjectLocality, AuthnContextClassRef\nfrom saml2.saml import SubjectConfirmationData, SubjectConfirmation\nfrom saml2.saml import Attribute\n\nfrom py.test import raises\nimport saml2_data\n\ntry:\n    from xml.etree import cElementTree as ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        from elementtree import ElementTree\n\nITEMS = {\n    NameID: [\"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<NameID xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n  Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n  SPProvidedID=\"sp provided id\">\n  roland@example.com\n</NameID>\n\"\"\", \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<NameID xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n  SPNameQualifier=\"https://foo.example.com/sp\" \n  Format=\"urn:oasis:names:tc:SAML:2.0:nameid-format:transient\">_1632879f09d08ea5ede2dc667cbed7e429ebc4335c</NameID>\n\"\"\", \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<NameID xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\nFormat=\"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\"\nNameQualifier=\"http://authentic.example.com/saml/metadata\"\nSPNameQualifier=\"http://auth.example.com/saml/metadata\">test\n</NameID>\"\"\"],\n    Issuer: \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Issuer xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\">\n  http://www.example.com/test\n</Issuer>\n\"\"\",\n    SubjectLocality: \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<SubjectLocality xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n  Address=\"127.0.0.1\" DNSName=\"localhost\"/>\n\"\"\",\n    SubjectConfirmationData:\n        \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<SubjectConfirmationData xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\nInResponseTo=\"_1683146e27983964fbe7bf8f08961108d166a652e5\" \nNotOnOrAfter=\"2010-02-18T13:52:13.959Z\" \nNotBefore=\"2010-01-16T12:00:00Z\" \nRecipient=\"http://192.168.0.10/saml/sp\" />\"\"\",\n    SubjectConfirmation:\n        \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<SubjectConfirmation xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\nMethod=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\"><NameID\nFormat=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\nNameQualifier=\"http://authentic.example.com/saml/metadata\">test@example.com\n</NameID>\n<SubjectConfirmationData\nNotOnOrAfter=\"2010-02-17T17:02:38Z\"\nRecipient=\"http://auth.example.com/saml/proxySingleSignOnRedirect\"\nInResponseTo=\"_59B3A01B03334032C31E434C63F89E3E\"/></SubjectConfirmation>\"\"\"\n}\n\n#def pytest_generate_tests(metafunc):\n#    if \"target_class\" in metafunc.funcargnames:\n#        for tcl,xml in ITEMS.items():\n#            metafunc.addcall(funcargs={\"target_class\":tcl,\"xml_string\":xml})\n\ndef _eq(l1, l2):\n    return set(l1) == set(l2)\n\n\ndef test_create_class_from_xml_string_nameid():\n    kl = create_class_from_xml_string(NameID, ITEMS[NameID][0])\n    assert kl != None\n    assert kl.format == \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n    assert kl.sp_provided_id == \"sp provided id\"\n    assert kl.text.strip() == \"roland@example.com\"\n    assert _eq(kl.keyswv(), ['sp_provided_id', 'format', 'text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:NameID\"\n    assert _eq(kl.keys(), ['sp_provided_id', 'sp_name_qualifier',\n                           'name_qualifier', 'format', 'text'])\n\n    kl = create_class_from_xml_string(NameID, ITEMS[NameID][1])\n    assert kl != None\n    assert kl.format == \"urn:oasis:names:tc:SAML:2.0:nameid-format:transient\"\n    assert kl.sp_name_qualifier == \"https://foo.example.com/sp\"\n    assert kl.text.strip() == \"_1632879f09d08ea5ede2dc667cbed7e429ebc4335c\"\n    assert _eq(kl.keyswv(), ['sp_name_qualifier', 'format', 'text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:NameID\"\n\n    kl = create_class_from_xml_string(NameID, ITEMS[NameID][2])\n    assert kl != None\n    assert kl.format == \"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\"\n    assert kl.name_qualifier == \"http://authentic.example.com/saml/metadata\"\n    assert kl.sp_name_qualifier == \"http://auth.example.com/saml/metadata\"\n    assert kl.text.strip() == \"test\"\n    assert _eq(kl.keyswv(), ['sp_name_qualifier', 'format', 'name_qualifier',\n                             'text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:NameID\"\n\n\ndef test_create_class_from_xml_string_issuer():\n    kl = create_class_from_xml_string(Issuer, ITEMS[Issuer])\n    assert kl != None\n    assert kl.text.strip() == \"http://www.example.com/test\"\n    assert _eq(kl.keyswv(), ['text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:Issuer\"\n\n\ndef test_create_class_from_xml_string_subject_locality():\n    kl = create_class_from_xml_string(SubjectLocality, ITEMS[SubjectLocality])\n    assert kl != None\n    assert _eq(kl.keyswv(), ['address', \"dns_name\"])\n    assert kl.address == \"127.0.0.1\"\n    assert kl.dns_name == \"localhost\"\n    assert class_name(\n        kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:SubjectLocality\"\n\n\ndef test_create_class_from_xml_string_subject_confirmation_data():\n    kl = create_class_from_xml_string(SubjectConfirmationData,\n                                      ITEMS[SubjectConfirmationData])\n    assert kl != None\n    assert _eq(kl.keyswv(), ['in_response_to', 'not_on_or_after',\n                             'not_before', 'recipient'])\n    assert kl.in_response_to == \"_1683146e27983964fbe7bf8f08961108d166a652e5\"\n    assert kl.not_on_or_after == \"2010-02-18T13:52:13.959Z\"\n    assert kl.not_before == \"2010-01-16T12:00:00Z\"\n    assert kl.recipient == \"http://192.168.0.10/saml/sp\"\n    assert class_name(kl) == \\\n           \"urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmationData\"\n\n\ndef test_create_class_from_xml_string_subject_confirmation():\n    kl = create_class_from_xml_string(SubjectConfirmation,\n                                      ITEMS[SubjectConfirmation])\n    assert kl != None\n    assert _eq(kl.keyswv(), ['method', 'name_id',\n                             'subject_confirmation_data'])\n    assert kl.method == \"urn:oasis:names:tc:SAML:2.0:cm:bearer\"\n    name_id = kl.name_id\n    assert _eq(name_id.keyswv(), ['format', 'name_qualifier', 'text'])\n    assert name_id.format == \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n    assert name_id.name_qualifier == \"http://authentic.example.com/saml/metadata\"\n    assert name_id.text.strip() == \"test@example.com\"\n    subject_confirmation_data = kl.subject_confirmation_data\n    assert _eq(subject_confirmation_data.keyswv(), ['not_on_or_after',\n                                                    'recipient',\n                                                    'in_response_to'])\n    assert subject_confirmation_data.recipient == \\\n           \"http://auth.example.com/saml/proxySingleSignOnRedirect\"\n    assert subject_confirmation_data.not_on_or_after == \"2010-02-17T17:02:38Z\"\n    assert subject_confirmation_data.in_response_to == \\\n           \"_59B3A01B03334032C31E434C63F89E3E\"\n    assert class_name(kl) == \\\n           \"urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmation\"\n\n\ndef test_create_class_from_xml_string_wrong_class_spec():\n    kl = create_class_from_xml_string(SubjectConfirmationData,\n                                      ITEMS[SubjectConfirmation])\n    assert kl == None\n\n\ndef test_ee_1():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?><foo>bar</foo>\"\"\")\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == None\n    assert ee.children == []\n    assert ee.text == \"bar\"\n\n\ndef test_ee_2():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?><foo id=\"xyz\">bar</foo>\"\"\")\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {\"id\": \"xyz\"}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == None\n    assert ee.children == []\n    assert ee.text == \"bar\"\n\n\ndef test_ee_3():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <foo xmlns=\"urn:mace:example.com:saml:ns\" \n        id=\"xyz\">bar</foo>\"\"\")\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {\"id\": \"xyz\"}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == \"urn:mace:example.com:saml:ns\"\n    assert ee.children == []\n    assert ee.text == \"bar\"\n\n\ndef test_ee_4():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <foo xmlns=\"urn:mace:example.com:saml:ns\">\n        <id>xyz</id><bar>tre</bar></foo>\"\"\")\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == \"urn:mace:example.com:saml:ns\"\n    assert len(ee.children) == 2\n    assert ee.text.strip() == \"\"\n    cid = ee.find_children(\"id\", \"urn:mace:example.com:saml:namespace\")\n    assert cid == []\n    ids = ee.find_children(\"id\", \"urn:mace:example.com:saml:ns\")\n    assert ids != []\n    cid = ids[0]\n    print(cid.__dict__)\n    assert cid.attributes == {}\n    assert cid.tag == \"id\"\n    assert cid.namespace == \"urn:mace:example.com:saml:ns\"\n    assert cid.children == []\n    assert cid.text.strip() == \"xyz\"\n\n\ndef test_ee_5():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <foo xmlns=\"urn:mace:example.com:saml:ns\">bar</foo>\"\"\")\n\n    ce = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <educause xmlns=\"urn:mace:example.com:saml:cu\">rev</educause>\"\"\")\n\n    ee.children.append(ce)\n\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == \"urn:mace:example.com:saml:ns\"\n    assert len(ee.children) == 1\n    assert ee.text.strip() == \"bar\"\n\n    c = ee.children[0]\n    print(c.__dict__)\n\n    child = ee.find_children(namespace=\"urn:mace:example.com:saml:cu\")\n    assert len(child) == 1\n    child = ee.find_children(namespace=\"urn:mace:example.com:saml:ns\")\n    assert len(child) == 0\n    child = ee.find_children(\"educause\", \"urn:mace:example.com:saml:cu\")\n    assert len(child) == 1\n    child = ee.find_children(\"edugain\", \"urn:mace:example.com:saml:cu\")\n    assert len(child) == 0\n    print(ee.to_string())\n\n\ndef test_ee_6():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <foo xmlns=\"urn:mace:example.com:saml:ns\">bar</foo>\"\"\")\n\n    ce = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <educause xmlns=\"urn:mace:example.com:saml:cu\">rev</educause>\"\"\")\n\n    et = ee.transfer_to_element_tree()\n    ce.become_child_element_of(et)\n\n    pee = saml2._extension_element_from_element_tree(et)\n\n    assert pee != None\n    print(pee.__dict__)\n    assert pee.attributes == {}\n    assert pee.tag == \"foo\"\n    assert pee.namespace == \"urn:mace:example.com:saml:ns\"\n    assert len(pee.children) == 1\n    assert pee.text.strip() == \"bar\"\n\n    c = pee.children[0]\n    print(c.__dict__)\n\n    child = pee.find_children(namespace=\"urn:mace:example.com:saml:cu\")\n    assert len(child) == 1\n    child = pee.find_children(namespace=\"urn:mace:example.com:saml:ns\")\n    assert len(child) == 0\n    child = pee.find_children(\"educause\", \"urn:mace:example.com:saml:cu\")\n    assert len(child) == 1\n    child = pee.find_children(\"edugain\", \"urn:mace:example.com:saml:cu\")\n    assert len(child) == 0\n    print(pee.to_string())\n\n\nNAMEID_WITH_ATTRIBUTE_EXTENSION = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<NameID xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n  xmlns:local=\"urn:mace:example.com:saml:assertion\"\n  Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n  SPProvidedID=\"sp provided id\"\n  local:Foo=\"BAR\">\n  roland@example.com\n</NameID>\n\"\"\"\n\n\ndef test_nameid_with_extension():\n    kl = create_class_from_xml_string(NameID, NAMEID_WITH_ATTRIBUTE_EXTENSION)\n    assert kl != None\n    print(kl.__dict__)\n    assert kl.format == \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n    assert kl.sp_provided_id == \"sp provided id\"\n    assert kl.text.strip() == \"roland@example.com\"\n    assert _eq(kl.keyswv(), ['sp_provided_id', 'format',\n                             'extension_attributes', 'text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:NameID\"\n    assert _eq(kl.keys(), ['sp_provided_id', 'sp_name_qualifier',\n                           'name_qualifier', 'format', 'text'])\n    assert kl.extension_attributes == {\n        '{urn:mace:example.com:saml:assertion}Foo': 'BAR'}\n\n\nSUBJECT_CONFIRMATION_WITH_MEMBER_EXTENSION = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<SubjectConfirmation xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\nMethod=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\">\n<NameID\nFormat=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\nNameQualifier=\"http://authentic.example.com/saml/metadata\">test@example.com\n</NameID>\n<SubjectConfirmationData\nNotOnOrAfter=\"2010-02-17T17:02:38Z\"\nRecipient=\"http://auth.example.com/saml/proxySingleSignOnRedirect\"\nInResponseTo=\"_59B3A01B03334032C31E434C63F89E3E\"/>\n<local:Trustlevel xmlns:local=\"urn:mace:example.com:saml:assertion\">\nExcellent\n</local:Trustlevel>\n</SubjectConfirmation>\"\"\"\n\n\ndef test_subject_confirmation_with_extension():\n    kl = create_class_from_xml_string(SubjectConfirmation,\n                                      SUBJECT_CONFIRMATION_WITH_MEMBER_EXTENSION)\n    assert kl != None\n    print(kl.__dict__)\n    assert kl.extension_attributes == {}\n    assert kl.method == \"urn:oasis:names:tc:SAML:2.0:cm:bearer\"\n    name_id = kl.name_id\n    assert _eq(name_id.keyswv(), ['format', 'name_qualifier', 'text'])\n    assert name_id.format == \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n    assert name_id.name_qualifier == \"http://authentic.example.com/saml/metadata\"\n    assert name_id.text.strip() == \"test@example.com\"\n    subject_confirmation_data = kl.subject_confirmation_data\n    assert _eq(subject_confirmation_data.keyswv(), ['not_on_or_after',\n                                                    'recipient',\n                                                    'in_response_to'])\n    assert subject_confirmation_data.recipient == \\\n           \"http://auth.example.com/saml/proxySingleSignOnRedirect\"\n    assert subject_confirmation_data.not_on_or_after == \"2010-02-17T17:02:38Z\"\n    assert subject_confirmation_data.in_response_to == \\\n           \"_59B3A01B03334032C31E434C63F89E3E\"\n    assert len(kl.extension_elements) == 1\n    ee = kl.extension_elements[0]\n    assert ee.tag == \"Trustlevel\"\n    assert ee.namespace == \"urn:mace:example.com:saml:assertion\"\n    assert ee.text.strip() == \"Excellent\"\n\n\ndef test_to_fro_string_1():\n    kl = create_class_from_xml_string(SubjectConfirmation,\n                                      SUBJECT_CONFIRMATION_WITH_MEMBER_EXTENSION)\n    txt = kl.to_string()\n    cpy = create_class_from_xml_string(SubjectConfirmation, txt)\n\n    print(kl.__dict__)\n    print(cpy.__dict__)\n\n    assert kl.text.strip() == cpy.text.strip()\n    assert _eq(kl.keyswv(), cpy.keyswv())\n    assert len(kl.extension_elements) == len(cpy.extension_elements)\n    klee = kl.extension_elements[0]\n    cpyee = cpy.extension_elements[0]\n    assert klee.text.strip() == cpyee.text.strip()\n    assert klee.tag == cpyee.tag\n    assert klee.namespace == cpyee.namespace\n\n\ndef test_make_vals_str():\n    kl = make_vals(\"Jeter\", md.GivenName, part=True)\n    assert isinstance(kl, md.GivenName)\n    assert kl.text == \"Jeter\"\n\n\ndef test_make_vals_list_of_strs():\n    cp = md.ContactPerson()\n    make_vals([\"Derek\", \"Sanderson\"], md.GivenName, cp, \"given_name\")\n    assert len(cp.given_name) == 2\n    assert _eq([i.text for i in cp.given_name], [\"Sanderson\", \"Derek\"])\n\n\ndef test_attribute_element_to_extension_element():\n    attr = create_class_from_xml_string(Attribute, saml2_data.TEST_ATTRIBUTE)\n    ee = saml2.element_to_extension_element(attr)\n    print(ee.__dict__)\n    assert ee.tag == \"Attribute\"\n    assert ee.namespace == 'urn:oasis:names:tc:SAML:2.0:assertion'\n    assert _eq(ee.attributes.keys(), ['FriendlyName', 'Name', 'NameFormat'])\n    assert ee.attributes[\"FriendlyName\"] == 'test attribute'\n    assert ee.attributes[\"Name\"] == \"testAttribute\"\n    assert ee.attributes[\"NameFormat\"] == \\\n           'urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified'\n    assert len(ee.children) == 2\n    for child in ee.children:\n        # children are also extension element instances\n        assert child.namespace == 'urn:oasis:names:tc:SAML:2.0:assertion'\n        assert child.tag == \"AttributeValue\"\n\n\ndef test_ee_7():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n   <ExternalEntityAttributeAuthority\n       xmlns=\"urn:oasis:names:tc:SAML:metadata:dynamicsaml\">\n       <AssertingEntity>\n           <NameID Format=\"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\">\n               http://federationX.org\n           </NameID>\n       </AssertingEntity>\n       <RetrievalEndpoint>\n           https://federationX.org/?ID=a87s76a5765da76576a57as\n       </RetrievalEndpoint>\n   </ExternalEntityAttributeAuthority>\n\"\"\")\n\n    print(ee.__dict__)\n    assert len(ee.children) == 2\n    for child in ee.children:\n        assert child.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert _eq([\"AssertingEntity\", \"RetrievalEndpoint\"],\n               [c.tag for c in ee.children])\n    aes = [c for c in ee.children if c.tag == \"AssertingEntity\"]\n    assert len(aes) == 1\n    assert len(aes[0].children) == 1\n    assert _eq(aes[0].attributes.keys(), [])\n    nid = aes[0].children[0]\n    assert nid.tag == \"NameID\"\n    assert nid.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert len(nid.children) == 0\n    assert _eq(nid.attributes.keys(), [\"Format\"])\n    assert nid.text.strip() == \"http://federationX.org\"\n\n\ndef test_extension_element_loadd():\n    ava = {'attributes': {},\n           'tag': 'ExternalEntityAttributeAuthority',\n           'namespace': 'urn:oasis:names:tc:SAML:metadata:dynamicsaml',\n           'children': [{\n                            \"tag\": \"AssertingEntity\",\n                            \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n\n                            \"children\": [{\n                                             \"tag\": \"NameID\",\n                                             \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n                                             \"text\": \"http://federationX.org\",\n                                             \"attributes\": {\n                                                 \"Format\": \"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\"\n                                             },\n                                         }]\n                        }, {\n                            \"tag\": \"RetrievalEndpoint\",\n                            \"namespace\": \"urn:oasis:names:tc:SAML:metadata\"\n                                         \":dynamicsaml\",\n                            \"text\": \"https://federationX.org/?ID=a87s76a5765da76576a57as\",\n                        }],\n    }\n\n    ee = saml2.ExtensionElement(ava[\"tag\"]).loadd(ava)\n    print(ee.__dict__)\n    assert len(ee.children) == 2\n    for child in ee.children:\n        assert child.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert _eq([\"AssertingEntity\", \"RetrievalEndpoint\"],\n               [c.tag for c in ee.children])\n    aes = [c for c in ee.children if c.tag == \"AssertingEntity\"]\n    assert len(aes) == 1\n    assert len(aes[0].children) == 1\n    assert _eq(aes[0].attributes.keys(), [])\n    nid = aes[0].children[0]\n    assert nid.tag == \"NameID\"\n    assert nid.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert len(nid.children) == 0\n    assert _eq(nid.attributes.keys(), [\"Format\"])\n    assert nid.text.strip() == \"http://federationX.org\"\n\n\ndef test_extensions_loadd():\n    ava = {\"extension_elements\": [\n        {\n            'attributes': {},\n            'tag': 'ExternalEntityAttributeAuthority',\n            'namespace': 'urn:oasis:names:tc:SAML:metadata:dynamicsaml',\n            'children': [\n                {\"tag\": \"AssertingEntity\",\n                 \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n                 \"children\": [\n                     {\"tag\": \"NameID\",\n                      \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n                      \"text\": \"http://federationX.org\",\n                      \"attributes\": {\n                          \"Format\": \"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\"\n                          },\n                      }]\n                },\n                {\n                    \"tag\": \"RetrievalEndpoint\",\n                    \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n                    \"text\": \"https://federationX.org/?ID=a87s76a5765da76576a57as\",\n                }],\n            }],\n           \"extension_attributes\": {\n               \"foo\": \"bar\",\n           }\n    }\n\n    extension = saml2.SamlBase()\n    extension.loadd(ava)\n\n    print(extension.__dict__)\n    assert len(extension.extension_elements) == 1\n    ee = extension.extension_elements[0]\n    assert len(ee.children) == 2\n    for child in ee.children:\n        assert child.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert _eq([\"AssertingEntity\", \"RetrievalEndpoint\"],\n               [c.tag for c in ee.children])\n    aes = [c for c in ee.children if c.tag == \"AssertingEntity\"]\n    assert len(aes) == 1\n    assert len(aes[0].children) == 1\n    assert _eq(aes[0].attributes.keys(), [])\n    nid = aes[0].children[0]\n    assert nid.tag == \"NameID\"\n    assert nid.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert len(nid.children) == 0\n    assert _eq(nid.attributes.keys(), [\"Format\"])\n    assert nid.text.strip() == \"http://federationX.org\"\n\n    assert list(extension.extension_attributes.keys()) == [\"foo\"]\n    assert extension.extension_attributes[\"foo\"] == \"bar\"\n", "#!/usr/bin/env python\n\ntry:\n    from xml.etree import cElementTree as ElementTree\n    if ElementTree.VERSION < '1.3.0':\n        # cElementTree has no support for register_namespace\n        # neither _namespace_map, thus we sacrify performance\n        # for correctness\n        from xml.etree import ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        from elementtree import ElementTree\n\nimport saml2.samlp as samlp\nfrom saml2.samlp import NAMESPACE as SAMLP_NAMESPACE\n\nNAMESPACE = \"http://schemas.xmlsoap.org/soap/envelope/\"\n\nexample = \"\"\"<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\">\n    <Body>\n        <samlp:Response xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\" \n            xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\" \n            ID=\"_6c3a4f8b9c2d\" Version=\"2.0\" IssueInstant=\"2004-03-27T08:42:00Z\">\n        <saml:Issuer>https://www.example.com/SAML</saml:Issuer>\n        <Status>\n        <StatusCode Value='urn:oasis:names:tc:SAML:2.0:status:Success'/>\n        </Status>\n        <saml:Assertion>\n        <saml:Subject></saml:Subject>\n        <saml:AttributeStatement></saml:AttributeStatement>\n        </saml:Assertion>\n        </samlp:Response>\n    </Body>\n</Envelope>\n\"\"\"\n\n\ndef test_parse_soap_envelope():\n    envelope = ElementTree.fromstring(example)\n    assert envelope.tag == '{%s}Envelope' % NAMESPACE\n    # How to check that it's the right type ?\n    assert len(envelope) == 1\n    body = envelope[0]\n    assert body.tag == '{%s}Body' % NAMESPACE\n    assert len(body) == 1\n    saml_part = body[0]\n    assert saml_part.tag == '{%s}Response' % SAMLP_NAMESPACE\n    # {http://schemas.xmlsoap.org/soap/envelope/}Envelope\n\n\ndef test_make_soap_envelope():\n    envelope = ElementTree.Element('')\n    envelope.tag = '{%s}Envelope' % NAMESPACE\n    body = ElementTree.Element('')\n    body.tag = '{%s}Body' % NAMESPACE\n    envelope.append(body)    \n    request = samlp.AuthnRequest()\n    request.become_child_element_of(body)\n\n    assert envelope.tag == '{%s}Envelope' % NAMESPACE\n    assert len(envelope) == 1\n    body = envelope[0]\n    assert body.tag == '{%s}Body' % NAMESPACE\n    assert len(body) == 1\n    saml_part = body[0]\n    assert saml_part.tag == '{%s}AuthnRequest' % SAMLP_NAMESPACE\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport base64\nimport uuid\nimport six\nfrom future.backports.urllib.parse import parse_qs\nfrom future.backports.urllib.parse import urlencode\nfrom future.backports.urllib.parse import urlparse\n\nfrom saml2.argtree import add_path\nfrom saml2.cert import OpenSSLWrapper\nfrom saml2.xmldsig import SIG_RSA_SHA256\nfrom saml2 import BINDING_HTTP_POST\nfrom saml2 import BINDING_HTTP_REDIRECT\nfrom saml2 import config\nfrom saml2 import class_name\nfrom saml2 import extension_elements_to_elements\nfrom saml2 import saml\nfrom saml2 import samlp\nfrom saml2 import sigver\nfrom saml2 import s_utils\nfrom saml2.assertion import Assertion\n\nfrom saml2.authn_context import INTERNETPROTOCOLPASSWORD\nfrom saml2.client import Saml2Client\nfrom saml2.config import SPConfig\nfrom saml2.response import LogoutResponse\nfrom saml2.saml import NAMEID_FORMAT_PERSISTENT, EncryptedAssertion, Advice\nfrom saml2.saml import NAMEID_FORMAT_TRANSIENT\nfrom saml2.saml import NameID\nfrom saml2.samlp import SessionIndex\nfrom saml2.server import Server\nfrom saml2.sigver import pre_encryption_part, make_temp, pre_encrypt_assertion\nfrom saml2.sigver import rm_xmltag\nfrom saml2.sigver import verify_redirect_signature\nfrom saml2.s_utils import do_attribute_statement\nfrom saml2.s_utils import factory\nfrom saml2.time_util import in_a_while, a_while_ago\n\nfrom fakeIDP import FakeIDP\nfrom fakeIDP import unpack_form\nfrom pathutils import full_path\n\nAUTHN = {\n    \"class_ref\": INTERNETPROTOCOLPASSWORD,\n    \"authn_auth\": \"http://www.example.com/login\"\n}\n\n\ndef generate_cert():\n    sn = uuid.uuid4().urn\n    cert_info = {\n        \"cn\": \"localhost\",\n        \"country_code\": \"se\",\n        \"state\": \"ac\",\n        \"city\": \"Umea\",\n        \"organization\": \"ITS\",\n        \"organization_unit\": \"DIRG\"\n    }\n    osw = OpenSSLWrapper()\n    ca_cert_str = osw.read_str_from_file(\n        full_path(\"root_cert/localhost.ca.crt\"))\n    ca_key_str = osw.read_str_from_file(\n        full_path(\"root_cert/localhost.ca.key\"))\n    req_cert_str, req_key_str = osw.create_certificate(cert_info, request=True,\n                                                       sn=sn, key_length=2048)\n    cert_str = osw.create_cert_signed_certificate(ca_cert_str, ca_key_str,\n                                                  req_cert_str)\n    return cert_str, req_key_str\n\n\ndef add_subelement(xmldoc, node_name, subelem):\n    s = xmldoc.find(node_name)\n    if s > 0:\n        x = xmldoc.rindex(\"<\", 0, s)\n        tag = xmldoc[x + 1:s - 1]\n        c = s + len(node_name)\n        spaces = \"\"\n        while xmldoc[c] == \" \":\n            spaces += \" \"\n            c += 1\n        # Sometimes we get an xml header, sometimes we don't.\n        subelem_str = str(subelem)\n        if subelem_str[0:5].lower() == '<?xml':\n            subelem_str = subelem_str.split(\"\\n\", 1)[1]\n        xmldoc = xmldoc.replace(\n            \"<%s:%s%s/>\" % (tag, node_name, spaces),\n            \"<%s:%s%s>%s</%s:%s>\" % (tag, node_name, spaces, subelem_str, tag,\n                                     node_name))\n\n    return xmldoc\n\n\ndef for_me(condition, me):\n    for restriction in condition.audience_restriction:\n        audience = restriction.audience\n        if audience.text.strip() == me:\n            return True\n\n\ndef ava(attribute_statement):\n    result = {}\n    for attribute in attribute_statement.attribute:\n        # Check name_format ??\n        name = attribute.name.strip()\n        result[name] = []\n        for value in attribute.attribute_value:\n            result[name].append(value.text.strip())\n    return result\n\n\ndef _leq(l1, l2):\n    return set(l1) == set(l2)\n\n\n# def test_parse_3():\n#     xml_response = open(XML_RESPONSE_FILE3).read()\n#     response = samlp.response_from_string(xml_response)\n#     client = Saml2Client({})\n#     (ava, name_id, real_uri) = \\\n#             client.do_response(response, \"xenosmilus.umdc.umu.se\")\n#     print(40*\"=\")\n#     print(ava)\n#     print(40*\",\")\n#     print(name_id)\n#     assert False\n\nREQ1 = {\"1.2.14\": \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n<ns0:AttributeQuery Destination=\"https://idp.example.com/idp/\" ID=\"id1\"\nIssueInstant=\"%s\" Version=\"2.0\" xmlns:ns0=\"urn:oasis:names:tc:SAML:2\n.0:protocol\"><ns1:Issuer Format=\"urn:oasis:names:tc:SAML:2\n.0:nameid-format:entity\" xmlns:ns1=\"urn:oasis:names:tc:SAML:2\n.0:assertion\">urn:mace:example.com:saml:roland:sp</ns1:Issuer><ns1:Subject\nxmlns:ns1=\"urn:oasis:names:tc:SAML:2.0:assertion\"><ns1:NameID\nFormat=\"urn:oasis:names:tc:SAML:2\n.0:nameid-format:persistent\">E8042FB4-4D5B-48C3-8E14-8EDD852790DD</ns1:NameID\n></ns1:Subject></ns0:AttributeQuery>\"\"\",\n        \"1.2.16\": \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n<ns0:AttributeQuery xmlns:ns0=\"urn:oasis:names:tc:SAML:2.0:protocol\"\nxmlns:ns1=\"urn:oasis:names:tc:SAML:2.0:assertion\" Destination=\"https://idp\n.example.com/idp/\" ID=\"id1\" IssueInstant=\"%s\" Version=\"2.0\"><ns1:Issuer\nFormat=\"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\">urn:mace:example\n.com:saml:roland:sp</ns1:Issuer><ns1:Subject><ns1:NameID\nFormat=\"urn:oasis:names:tc:SAML:2\n.0:nameid-format:persistent\">E8042FB4-4D5B-48C3-8E14-8EDD852790DD</ns1:NameID\n></ns1:Subject></ns0:AttributeQuery>\"\"\"}\n\nnid = NameID(name_qualifier=\"foo\", format=NAMEID_FORMAT_TRANSIENT,\n             text=\"123456\")\n\n\ndef list_values2simpletons(_dict):\n    return dict([(k, v[0]) for k, v in _dict.items()])\n\n\nclass TestClient:\n    def setup_class(self):\n        self.server = Server(\"idp_conf\")\n\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        self.client = Saml2Client(conf)\n\n    def teardown_class(self):\n        self.server.close()\n\n    def test_create_attribute_query1(self):\n        req_id, req = self.client.create_attribute_query(\n            \"https://idp.example.com/idp/\",\n            \"E8042FB4-4D5B-48C3-8E14-8EDD852790DD\",\n            format=saml.NAMEID_FORMAT_PERSISTENT,\n            message_id=\"id1\")\n        reqstr = \"%s\" % req.to_string().decode('utf-8')\n\n        assert req.destination == \"https://idp.example.com/idp/\"\n        assert req.id == \"id1\"\n        assert req.version == \"2.0\"\n        subject = req.subject\n        name_id = subject.name_id\n        assert name_id.format == saml.NAMEID_FORMAT_PERSISTENT\n        assert name_id.text == \"E8042FB4-4D5B-48C3-8E14-8EDD852790DD\"\n        issuer = req.issuer\n        assert issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n\n        attrq = samlp.attribute_query_from_string(reqstr)\n\n        print(attrq.keyswv())\n        assert _leq(attrq.keyswv(), ['destination', 'subject', 'issue_instant',\n                                     'version', 'id', 'issuer'])\n\n        assert attrq.destination == req.destination\n        assert attrq.id == req.id\n        assert attrq.version == req.version\n        assert attrq.issuer.text == issuer.text\n        assert attrq.issue_instant == req.issue_instant\n        assert attrq.subject.name_id.format == name_id.format\n        assert attrq.subject.name_id.text == name_id.text\n\n    def test_create_attribute_query2(self):\n        req_id, req = self.client.create_attribute_query(\n            \"https://idp.example.com/idp/\",\n            \"E8042FB4-4D5B-48C3-8E14-8EDD852790DD\",\n            attribute={\n                (\"urn:oid:2.5.4.42\",\n                 \"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\",\n                 \"givenName\"): None,\n                (\"urn:oid:2.5.4.4\",\n                 \"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\",\n                 \"surname\"): None,\n                (\"urn:oid:1.2.840.113549.1.9.1\",\n                 \"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\"): None,\n            },\n            format=saml.NAMEID_FORMAT_PERSISTENT,\n            message_id=\"id1\")\n\n        print(req.to_string())\n        assert req.destination == \"https://idp.example.com/idp/\"\n        assert req.id == \"id1\"\n        assert req.version == \"2.0\"\n        subject = req.subject\n        name_id = subject.name_id\n        assert name_id.format == saml.NAMEID_FORMAT_PERSISTENT\n        assert name_id.text == \"E8042FB4-4D5B-48C3-8E14-8EDD852790DD\"\n        assert len(req.attribute) == 3\n        # one is givenName\n        seen = []\n        for attribute in req.attribute:\n            if attribute.name == \"urn:oid:2.5.4.42\":\n                assert attribute.name_format == saml.NAME_FORMAT_URI\n                assert attribute.friendly_name == \"givenName\"\n                seen.append(\"givenName\")\n            elif attribute.name == \"urn:oid:2.5.4.4\":\n                assert attribute.name_format == saml.NAME_FORMAT_URI\n                assert attribute.friendly_name == \"surname\"\n                seen.append(\"surname\")\n            elif attribute.name == \"urn:oid:1.2.840.113549.1.9.1\":\n                assert attribute.name_format == saml.NAME_FORMAT_URI\n                if getattr(attribute, \"friendly_name\"):\n                    assert False\n                seen.append(\"email\")\n        assert _leq(seen, [\"givenName\", \"surname\", \"email\"])\n\n    def test_create_attribute_query_3(self):\n        req_id, req = self.client.create_attribute_query(\n            \"https://aai-demo-idp.switch.ch/idp/shibboleth\",\n            \"_e7b68a04488f715cda642fbdd90099f5\",\n            format=saml.NAMEID_FORMAT_TRANSIENT,\n            message_id=\"id1\")\n\n        assert isinstance(req, samlp.AttributeQuery)\n        assert req.destination == \"https://aai-demo-idp.switch\" \\\n                                  \".ch/idp/shibboleth\"\n        assert req.id == \"id1\"\n        assert req.version == \"2.0\"\n        assert req.issue_instant\n        assert req.issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n        nameid = req.subject.name_id\n        assert nameid.format == saml.NAMEID_FORMAT_TRANSIENT\n        assert nameid.text == \"_e7b68a04488f715cda642fbdd90099f5\"\n\n    def test_create_auth_request_0(self):\n        ar_str = \"%s\" % self.client.create_authn_request(\n            \"http://www.example.com/sso\", message_id=\"id1\")[1]\n\n        ar = samlp.authn_request_from_string(ar_str)\n        print(ar)\n        assert ar.assertion_consumer_service_url == (\"http://lingon.catalogix\"\n                                                     \".se:8087/\")\n        assert ar.destination == \"http://www.example.com/sso\"\n        assert ar.protocol_binding == BINDING_HTTP_POST\n        assert ar.version == \"2.0\"\n        assert ar.provider_name == \"urn:mace:example.com:saml:roland:sp\"\n        assert ar.issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n        nid_policy = ar.name_id_policy\n        assert nid_policy.allow_create == \"false\"\n        assert nid_policy.format == saml.NAMEID_FORMAT_TRANSIENT\n\n    def test_create_auth_request_vo(self):\n        assert list(self.client.config.vorg.keys()) == [\n            \"urn:mace:example.com:it:tek\"]\n\n        ar_str = \"%s\" % self.client.create_authn_request(\n            \"http://www.example.com/sso\",\n            \"urn:mace:example.com:it:tek\",  # vo\n            nameid_format=NAMEID_FORMAT_PERSISTENT,\n            message_id=\"666\")[1]\n\n        ar = samlp.authn_request_from_string(ar_str)\n        print(ar)\n        assert ar.id == \"666\"\n        assert ar.assertion_consumer_service_url == \"http://lingon.catalogix\" \\\n                                                    \".se:8087/\"\n        assert ar.destination == \"http://www.example.com/sso\"\n        assert ar.protocol_binding == BINDING_HTTP_POST\n        assert ar.version == \"2.0\"\n        assert ar.provider_name == \"urn:mace:example.com:saml:roland:sp\"\n        assert ar.issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n        nid_policy = ar.name_id_policy\n        assert nid_policy.allow_create == \"false\"\n        assert nid_policy.format == saml.NAMEID_FORMAT_PERSISTENT\n        assert nid_policy.sp_name_qualifier == \"urn:mace:example.com:it:tek\"\n\n    def test_sign_auth_request_0(self):\n        # print(self.client.config)\n\n        req_id, areq = self.client.create_authn_request(\n            \"http://www.example.com/sso\", sign=True, message_id=\"id1\")\n\n        ar_str = \"%s\" % areq\n        ar = samlp.authn_request_from_string(ar_str)\n\n        assert ar\n        assert ar.signature\n        assert ar.signature.signature_value\n        signed_info = ar.signature.signed_info\n        # print(signed_info)\n        assert len(signed_info.reference) == 1\n        assert signed_info.reference[0].uri == \"#id1\"\n        assert signed_info.reference[0].digest_value\n        print(\"------------------------------------------------\")\n        try:\n            assert self.client.sec.correctly_signed_authn_request(\n                ar_str, self.client.config.xmlsec_binary,\n                self.client.config.metadata)\n        except Exception:  # missing certificate\n            self.client.sec.verify_signature(ar_str, node_name=class_name(ar))\n\n    def test_create_logout_request(self):\n        req_id, req = self.client.create_logout_request(\n            \"http://localhost:8088/slo\", \"urn:mace:example.com:saml:roland:idp\",\n            name_id=nid, reason=\"Tired\", expire=in_a_while(minutes=15),\n            session_indexes=[\"_foo\"])\n\n        assert req.destination == \"http://localhost:8088/slo\"\n        assert req.reason == \"Tired\"\n        assert req.version == \"2.0\"\n        assert req.name_id == nid\n        assert req.issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n        assert req.session_index == [SessionIndex(\"_foo\")]\n\n    def test_response_1(self):\n        IDP = \"urn:mace:example.com:saml:roland:idp\"\n\n        ava = {\"givenName\": [\"Derek\"], \"surName\": [\"Jeter\"],\n               \"mail\": [\"derek@nyy.mlb.com\"], \"title\": [\"The man\"]}\n\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id_policy=nameid_policy,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN)\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"})\n\n        assert authn_response is not None\n        assert authn_response.issuer() == IDP\n        assert authn_response.response.assertion[0].issuer.text == IDP\n        session_info = authn_response.session_info()\n\n        print(session_info)\n        assert session_info[\"ava\"] == {'mail': ['derek@nyy.mlb.com'],\n                                       'givenName': ['Derek'],\n                                       'sn': ['Jeter'],\n                                       'title': [\"The man\"]}\n        assert session_info[\"issuer\"] == IDP\n        assert session_info[\"came_from\"] == \"http://foo.example.com/service\"\n        response = samlp.response_from_string(authn_response.xmlstr)\n        assert response.destination == \"http://lingon.catalogix.se:8087/\"\n        assert \"session_index\" in session_info\n\n        # One person in the cache\n        assert len(self.client.users.subjects()) == 1\n        subject_id = self.client.users.subjects()[0]\n        print(\"||||\", self.client.users.get_info_from(subject_id, IDP))\n        # The information I have about the subject comes from one source\n        assert self.client.users.issuers_of_info(subject_id) == [IDP]\n\n        # --- authenticate another person\n\n        ava = {\"givenName\": [\"Alfonson\"], \"surName\": [\"Soriano\"],\n               \"mail\": [\"alfonson@chc.mlb.com\"], \"title\": [\"outfielder\"]}\n\n        resp_str = \"%s\" % self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id2\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id_policy=nameid_policy,\n            userid=\"also0001@example.com\",\n            authn=AUTHN)\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id2\": \"http://foo.example.com/service\"})\n\n        # Two persons in the cache\n        assert len(self.client.users.subjects()) == 2\n        issuers = [self.client.users.issuers_of_info(s) for s in\n                   self.client.users.subjects()]\n        # The information I have about the subjects comes from the same source\n        print(issuers)\n        assert issuers == [[IDP], [IDP]]\n\n    def test_response_2(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        cert_str, cert_key_str = generate_cert()\n\n        cert = \\\n            {\n                \"cert\": cert_str,\n                \"key\": cert_key_str\n            }\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=False,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n            encrypt_cert_advice=cert_str\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"}, {\"id1\": cert})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_3(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=False,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_4(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_5(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        cert_str, cert_key_str = generate_cert()\n\n        cert = \\\n            {\n                \"cert\": cert_str,\n                \"key\": cert_key_str\n            }\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n            encrypt_cert_assertion=cert_str\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"}, {\"id1\": cert})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_6(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        cert_assertion_str, cert_key_assertion_str = generate_cert()\n\n        cert_assertion = \\\n            {\n                \"cert\": cert_assertion_str,\n                \"key\": cert_key_assertion_str\n            }\n\n        cert_advice_str, cert_key_advice_str = generate_cert()\n\n        cert_advice = \\\n            {\n                \"cert\": cert_advice_str,\n                \"key\": cert_key_advice_str\n            }\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n            encrypt_cert_assertion=cert_assertion_str,\n            encrypt_cert_advice=cert_advice_str\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"},\n            {\"id1\": [cert_assertion, cert_advice]})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_7(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            encrypted_advice_attributes=True,\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_8(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        cert_str, cert_key_str = generate_cert()\n\n        cert = \\\n            {\n                \"cert\": cert_str,\n                \"key\": cert_key_str\n            }\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            encrypt_cert_assertion=cert_str\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"}, {\"id1\": cert})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def setup_verify_authn_response(self):\n        idp = \"urn:mace:example.com:saml:roland:idp\"\n        ava = {\"givenName\": [\"Derek\"], \"surName\": [\"Jeter\"],\n               \"mail\": [\"derek@nyy.mlb.com\"], \"title\": [\"The man\"]}\n        ava_verify = {'mail': ['derek@nyy.mlb.com'], 'givenName': ['Derek'],\n                      'sn': ['Jeter'], 'title': [\"The man\"]}\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n        return idp, ava, ava_verify, nameid_policy\n\n    def verify_authn_response(self, idp, authn_response, _client, ava_verify):\n        assert authn_response is not None\n        assert authn_response.issuer() == idp\n        assert authn_response.assertion.issuer.text == idp\n        session_info = authn_response.session_info()\n\n        assert session_info[\"ava\"] == ava_verify\n        assert session_info[\"issuer\"] == idp\n        assert session_info[\"came_from\"] == \"http://foo.example.com/service\"\n        response = samlp.response_from_string(authn_response.xmlstr)\n        assert response.destination == \"http://lingon.catalogix.se:8087/\"\n\n        # One person in the cache\n        assert len(_client.users.subjects()) == 1\n        subject_id = _client.users.subjects()[0]\n        # The information I have about the subject comes from one source\n        assert _client.users.issuers_of_info(subject_id) == [idp]\n\n    def test_init_values(self):\n        entityid = self.client.config.entityid\n        print(entityid)\n        assert entityid == \"urn:mace:example.com:saml:roland:sp\"\n        print(self.client.metadata.with_descriptor(\"idpsso\"))\n        location = self.client._sso_location()\n        print(location)\n        assert location == 'http://localhost:8088/sso'\n        my_name = self.client._my_name()\n        print(my_name)\n        assert my_name == \"urn:mace:example.com:saml:roland:sp\"\n\n    def test_sign_then_encrypt_assertion(self):\n        # Begin with the IdPs side\n        _sec = self.server.sec\n\n        assertion = s_utils.assertion_factory(\n            subject=factory(saml.Subject, text=\"_aaa\",\n                            name_id=factory(\n                                saml.NameID,\n                                format=saml.NAMEID_FORMAT_TRANSIENT)),\n            attribute_statement=do_attribute_statement(\n                {\n                    (\"\", \"\", \"surName\"): (\"Jeter\", \"\"),\n                    (\"\", \"\", \"givenName\"): (\"Derek\", \"\"),\n                }\n            ),\n            issuer=self.server._issuer(),\n        )\n\n        assertion.signature = sigver.pre_signature_part(\n            assertion.id, _sec.my_cert, 1)\n\n        sigass = _sec.sign_statement(assertion, class_name(assertion),\n                                     key_file=full_path(\"test.key\"),\n                                     node_id=assertion.id)\n        # Create an Assertion instance from the signed assertion\n        _ass = saml.assertion_from_string(sigass)\n\n        response = sigver.response_factory(\n            in_response_to=\"_012345\",\n            destination=\"https:#www.example.com\",\n            status=s_utils.success_status_factory(),\n            issuer=self.server._issuer(),\n            assertion=_ass\n        )\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    0][\"cert_file\"],\n                                                pre_encryption_part())\n\n        seresp = samlp.response_from_string(enctext)\n\n        # Now over to the client side\n        _csec = self.client.sec\n        if seresp.encrypted_assertion:\n            decr_text = _csec.decrypt(enctext)\n            seresp = samlp.response_from_string(decr_text)\n            resp_ass = []\n\n            sign_cert_file = full_path(\"test.pem\")\n            for enc_ass in seresp.encrypted_assertion:\n                assers = extension_elements_to_elements(\n                    enc_ass.extension_elements, [saml, samlp])\n                for ass in assers:\n                    if ass.signature:\n                        if not _csec.verify_signature(\"%s\" % ass,\n                                                      sign_cert_file,\n                                                      node_name=class_name(\n                                                          ass)):\n                            continue\n                    resp_ass.append(ass)\n\n            seresp.assertion = resp_ass\n            seresp.encrypted_assertion = None\n            # print(_sresp)\n\n        assert seresp.assertion\n\n    def test_sign_then_encrypt_assertion2(self):\n        # Begin with the IdPs side\n        _sec = self.server.sec\n\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n\n        asser = Assertion({\"givenName\": \"Derek\", \"surName\": \"Jeter\"})\n        farg = add_path(\n            {},\n            ['assertion', 'subject', 'subject_confirmation', 'method',\n             saml.SCM_BEARER])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'in_response_to',\n             '_012345'])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'recipient',\n             \"http://lingon.catalogix.se:8087/\"])\n\n        assertion = asser.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            name_id=factory(saml.NameID, format=saml.NAMEID_FORMAT_TRANSIENT),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            farg=farg['assertion']\n        )\n\n        assertion.signature = sigver.pre_signature_part(\n            assertion.id, _sec.my_cert, 1)\n\n        sigass = _sec.sign_statement(assertion, class_name(assertion),\n                                     key_file=self.client.sec.key_file,\n                                     node_id=assertion.id)\n\n        sigass = rm_xmltag(sigass)\n\n        response = sigver.response_factory(\n            in_response_to=\"_012345\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            status=s_utils.success_status_factory(),\n            issuer=self.server._issuer(),\n            encrypted_assertion=EncryptedAssertion()\n        )\n\n        xmldoc = \"%s\" % response\n        # strangely enough I get different tags if I run this test separately\n        # or as part of a bunch of tests.\n        xmldoc = add_subelement(xmldoc, \"EncryptedAssertion\", sigass)\n\n        enctext = _sec.crypto.encrypt_assertion(xmldoc,\n                                                self.client.sec.encryption_keypairs[\n                                                    1][\"cert_file\"],\n                                                pre_encryption_part())\n\n        # seresp = samlp.response_from_string(enctext)\n\n        resp_str = base64.encodestring(enctext.encode('utf-8'))\n        # Now over to the client side\n        resp = self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"_012345\": \"http://foo.example.com/service\"})\n\n        # assert resp.encrypted_assertion == []\n        assert resp.assertion\n        assert resp.ava == {'givenName': ['Derek'], 'sn': ['Jeter']}\n\n    def test_sign_then_encrypt_assertion_advice_1(self):\n        # Begin with the IdPs side\n        _sec = self.server.sec\n\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n\n        asser = Assertion({\"givenName\": \"Derek\", \"surName\": \"Jeter\"})\n\n        subject_confirmation_specs = {\n            'recipient': \"http://lingon.catalogix.se:8087/\",\n            'in_response_to': \"_012345\",\n            'subject_confirmation_method': saml.SCM_BEARER\n        }\n        name_id = factory(saml.NameID, format=saml.NAMEID_FORMAT_TRANSIENT)\n\n        farg = add_path(\n            {},\n            ['assertion', 'subject', 'subject_confirmation', 'method',\n             saml.SCM_BEARER])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'in_response_to',\n             '_012345'])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'recipient',\n             \"http://lingon.catalogix.se:8087/\"])\n\n        assertion = asser.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            name_id=name_id,\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            farg=farg['assertion'])\n\n        a_asser = Assertion({\"uid\": \"test01\", \"email\": \"test.testsson@test.se\"})\n        a_assertion = a_asser.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_assertion.signature = sigver.pre_signature_part(\n            a_assertion.id, _sec.my_cert, 1)\n\n        assertion.advice = Advice()\n\n        assertion.advice.encrypted_assertion = []\n        assertion.advice.encrypted_assertion.append(EncryptedAssertion())\n\n        assertion.advice.encrypted_assertion[0].add_extension_element(\n            a_assertion)\n\n        response = sigver.response_factory(\n            in_response_to=\"_012345\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            status=s_utils.success_status_factory(),\n            issuer=self.server._issuer()\n        )\n\n        response.assertion.append(assertion)\n\n        response = _sec.sign_statement(\"%s\" % response, class_name(a_assertion),\n                                       key_file=self.client.sec.key_file,\n                                       node_id=a_assertion.id)\n\n        # xmldoc = \"%s\" % response\n        # strangely enough I get different tags if I run this test separately\n        # or as part of a bunch of tests.\n        # xmldoc = add_subelement(xmldoc, \"EncryptedAssertion\", sigass)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    0][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        # seresp = samlp.response_from_string(enctext)\n\n        resp_str = base64.encodestring(enctext.encode('utf-8'))\n        # Now over to the client side\n        resp = self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"_012345\": \"http://foo.example.com/service\"})\n\n        # assert resp.encrypted_assertion == []\n        assert resp.assertion\n        assert resp.assertion.advice\n        assert resp.assertion.advice.assertion\n        assert resp.ava == \\\n               {'sn': ['Jeter'], 'givenName': ['Derek'], 'uid': ['test01'],\n                'email': ['test.testsson@test.se']}\n\n    def test_sign_then_encrypt_assertion_advice_2(self):\n        # Begin with the IdPs side\n        _sec = self.server.sec\n\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n\n        asser_1 = Assertion({\"givenName\": \"Derek\"})\n\n        farg = add_path(\n            {},\n            ['assertion', 'subject', 'subject_confirmation', 'method',\n             saml.SCM_BEARER])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'in_response_to',\n             '_012345'])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'recipient',\n             \"http://lingon.catalogix.se:8087/\"])\n        name_id = factory(saml.NameID, format=saml.NAMEID_FORMAT_TRANSIENT)\n\n        assertion_1 = asser_1.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        asser_2 = Assertion({\"surName\": \"Jeter\"})\n\n        assertion_2 = asser_2.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_asser_1 = Assertion({\"uid\": \"test01\"})\n        a_assertion_1 = a_asser_1.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_asser_2 = Assertion({\"email\": \"test.testsson@test.se\"})\n        a_assertion_2 = a_asser_2.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_asser_3 = Assertion({\"street\": \"street\"})\n        a_assertion_3 = a_asser_3.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_asser_4 = Assertion({\"title\": \"title\"})\n        a_assertion_4 = a_asser_4.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_assertion_1.signature = sigver.pre_signature_part(\n            a_assertion_1.id, _sec.my_cert, 1)\n\n        a_assertion_2.signature = sigver.pre_signature_part(\n            a_assertion_2.id, _sec.my_cert, 1)\n\n        a_assertion_3.signature = sigver.pre_signature_part(\n            a_assertion_3.id, _sec.my_cert, 1)\n\n        a_assertion_4.signature = sigver.pre_signature_part(\n            a_assertion_4.id, _sec.my_cert, 1)\n\n        assertion_1.signature = sigver.pre_signature_part(assertion_1.id,\n                                                          _sec.my_cert, 1)\n\n        assertion_2.signature = sigver.pre_signature_part(assertion_2.id,\n                                                          _sec.my_cert, 1)\n\n        response = sigver.response_factory(\n            in_response_to=\"_012345\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            status=s_utils.success_status_factory(),\n            issuer=self.server._issuer()\n        )\n\n        response.assertion = assertion_1\n\n        response.assertion.advice = Advice()\n\n        response.assertion.advice.encrypted_assertion = []\n        response.assertion.advice.encrypted_assertion.append(\n            EncryptedAssertion())\n\n        response.assertion.advice.encrypted_assertion[0].add_extension_element(\n            a_assertion_1)\n\n        advice_tag = response.assertion.advice._to_element_tree().tag\n        assertion_tag = a_assertion_1._to_element_tree().tag\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n                assertion_tag, advice_tag)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(a_assertion_1),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=a_assertion_1.id)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    1][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        response = samlp.response_from_string(enctext)\n\n        response.assertion = response.assertion[0]\n\n        response.assertion.advice.encrypted_assertion.append(\n            EncryptedAssertion())\n        response.assertion.advice.encrypted_assertion[1].add_extension_element(\n            a_assertion_2)\n\n        advice_tag = response.assertion.advice._to_element_tree().tag\n        assertion_tag = a_assertion_2._to_element_tree().tag\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n                assertion_tag, advice_tag)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(a_assertion_2),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=a_assertion_2.id)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    0][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        response = samlp.response_from_string(enctext)\n\n        response.assertion = response.assertion[0]\n\n        assertion_tag = response.assertion._to_element_tree().tag\n        response = pre_encrypt_assertion(response)\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_encrypted_assertion(\n            assertion_tag)\n\n        response = _sec.sign_statement(\"%s\" % response, class_name(assertion_1),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=assertion_1.id)\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    1][\"cert_file\"],\n                                                pre_encryption_part())\n\n        response = samlp.response_from_string(enctext)\n\n        response.assertion = assertion_2\n\n        response.assertion.advice = Advice()\n\n        response.assertion.advice.encrypted_assertion = []\n        response.assertion.advice.encrypted_assertion.append(\n            EncryptedAssertion())\n\n        response.assertion.advice.encrypted_assertion[0].add_extension_element(\n            a_assertion_3)\n\n        advice_tag = response.assertion.advice._to_element_tree().tag\n        assertion_tag = a_assertion_3._to_element_tree().tag\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n                assertion_tag, advice_tag)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(a_assertion_3),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=a_assertion_3.id)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    0][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        response = samlp.response_from_string(enctext)\n\n        response.assertion = response.assertion[0]\n\n        response.assertion.advice.encrypted_assertion.append(\n            EncryptedAssertion())\n\n        response.assertion.advice.encrypted_assertion[1].add_extension_element(\n            a_assertion_4)\n\n        advice_tag = response.assertion.advice._to_element_tree().tag\n        assertion_tag = a_assertion_4._to_element_tree().tag\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n                assertion_tag, advice_tag)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(a_assertion_4),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=a_assertion_4.id)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    1][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        response = samlp.response_from_string(enctext)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(response.assertion[0]),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=response.assertion[0].id)\n\n        response = samlp.response_from_string(response)\n\n        # seresp = samlp.response_from_string(enctext)\n\n        resp_str = base64.encodestring(str(response).encode('utf-8'))\n        # Now over to the client side\n        resp = self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"_012345\": \"http://foo.example.com/service\"})\n\n        # assert resp.encrypted_assertion == []\n        assert resp.assertion\n        assert resp.assertion.advice\n        assert resp.assertion.advice.assertion\n        assert resp.ava == \\\n               {'street': ['street'], 'uid': ['test01'], 'title': ['title'],\n                'givenName': ['Derek'], 'email':\n                    ['test.testsson@test.se'], 'sn': ['Jeter']}\n\n    def test_signed_redirect(self):\n\n        msg_str = \"%s\" % self.client.create_authn_request(\n            \"http://localhost:8088/sso\", message_id=\"id1\")[1]\n\n        info = self.client.apply_binding(\n            BINDING_HTTP_REDIRECT, msg_str, destination=\"\",\n            relay_state=\"relay2\", sigalg=SIG_RSA_SHA256)\n\n        loc = info[\"headers\"][0][1]\n        qs = parse_qs(loc[1:])\n        assert _leq(qs.keys(),\n                    ['SigAlg', 'SAMLRequest', 'RelayState', 'Signature'])\n\n        assert verify_redirect_signature(list_values2simpletons(qs),\n                                         self.client.sec.sec_backend)\n\n        res = self.server.parse_authn_request(qs[\"SAMLRequest\"][0],\n                                              BINDING_HTTP_REDIRECT)\n        print(res)\n\n    def test_do_logout_signed_redirect(self):\n        conf = config.SPConfig()\n        conf.load_file(\"sp_slo_redirect_conf\")\n        client = Saml2Client(conf)\n\n        # information about the user from an IdP\n        session_info = {\n            \"name_id\": nid,\n            \"issuer\": \"urn:mace:example.com:saml:roland:idp\",\n            \"not_on_or_after\": in_a_while(minutes=15),\n            \"ava\": {\n                \"givenName\": \"Anders\",\n                \"surName\": \"Andersson\",\n                \"mail\": \"anders.andersson@example.com\"\n            }\n        }\n        client.users.add_information_about_person(session_info)\n        entity_ids = client.users.issuers_of_info(nid)\n        assert entity_ids == [\"urn:mace:example.com:saml:roland:idp\"]\n\n        resp = client.do_logout(nid, entity_ids, \"Tired\", in_a_while(minutes=5),\n                                sign=True,\n                                expected_binding=BINDING_HTTP_REDIRECT)\n\n        assert list(resp.keys()) == entity_ids\n        binding, info = resp[entity_ids[0]]\n        assert binding == BINDING_HTTP_REDIRECT\n\n        loc = info[\"headers\"][0][1]\n        _, _, _, _, qs, _ = urlparse(loc)\n        qs = parse_qs(qs)\n        assert _leq(qs.keys(),\n                    ['SigAlg', 'SAMLRequest', 'RelayState', 'Signature'])\n\n        assert verify_redirect_signature(list_values2simpletons(qs),\n                                         client.sec.sec_backend)\n\n        res = self.server.parse_logout_request(qs[\"SAMLRequest\"][0],\n                                               BINDING_HTTP_REDIRECT)\n        print(res)\n\n    def test_do_logout_post(self):\n        # information about the user from an IdP\n        session_info = {\n            \"name_id\": nid,\n            \"issuer\": \"urn:mace:example.com:saml:roland:idp\",\n            \"not_on_or_after\": in_a_while(minutes=15),\n            \"ava\": {\n                \"givenName\": \"Anders\",\n                \"surName\": \"Andersson\",\n                \"mail\": \"anders.andersson@example.com\"\n            },\n            \"session_index\": SessionIndex(\"_foo\")\n        }\n        self.client.users.add_information_about_person(session_info)\n        entity_ids = self.client.users.issuers_of_info(nid)\n        assert entity_ids == [\"urn:mace:example.com:saml:roland:idp\"]\n        resp = self.client.do_logout(nid, entity_ids, \"Tired\",\n                                     in_a_while(minutes=5), sign=True,\n                                     expected_binding=BINDING_HTTP_POST)\n        assert resp\n        assert len(resp) == 1\n        assert list(resp.keys()) == entity_ids\n        binding, info = resp[entity_ids[0]]\n        assert binding == BINDING_HTTP_POST\n\n        _dic = unpack_form(info[\"data\"][3])\n        res = self.server.parse_logout_request(_dic[\"SAMLRequest\"],\n                                               BINDING_HTTP_POST)\n        assert b'<ns0:SessionIndex>_foo</ns0:SessionIndex>' in res.xmlstr\n\n    def test_do_logout_session_expired(self):\n        # information about the user from an IdP\n        session_info = {\n            \"name_id\": nid,\n            \"issuer\": \"urn:mace:example.com:saml:roland:idp\",\n            \"not_on_or_after\": a_while_ago(minutes=15),\n            \"ava\": {\n                \"givenName\": \"Anders\",\n                \"surName\": \"Andersson\",\n                \"mail\": \"anders.andersson@example.com\"\n            },\n            \"session_index\": SessionIndex(\"_foo\")\n        }\n        self.client.users.add_information_about_person(session_info)\n        entity_ids = self.client.users.issuers_of_info(nid)\n        assert entity_ids == [\"urn:mace:example.com:saml:roland:idp\"]\n        resp = self.client.do_logout(nid, entity_ids, \"Tired\",\n                                     in_a_while(minutes=5), sign=True,\n                                     expected_binding=BINDING_HTTP_POST)\n        assert resp\n        assert len(resp) == 1\n        assert list(resp.keys()) == entity_ids\n        binding, info = resp[entity_ids[0]]\n        assert binding == BINDING_HTTP_POST\n\n        _dic = unpack_form(info[\"data\"][3])\n        res = self.server.parse_logout_request(_dic[\"SAMLRequest\"],\n                                               BINDING_HTTP_POST)\n        assert b'<ns0:SessionIndex>_foo</ns0:SessionIndex>' in res.xmlstr\n\n\n# Below can only be done with dummy Server\nIDP = \"urn:mace:example.com:saml:roland:idp\"\n\n\nclass TestClientWithDummy():\n    def setup_class(self):\n        self.server = FakeIDP(\"idp_all_conf\")\n\n        conf = SPConfig()\n        conf.load_file(\"servera_conf\")\n        self.client = Saml2Client(conf)\n\n        self.client.send = self.server.receive\n\n    def test_do_authn(self):\n        binding = BINDING_HTTP_REDIRECT\n        response_binding = BINDING_HTTP_POST\n        sid, http_args = self.client.prepare_for_authenticate(\n            IDP, \"http://www.example.com/relay_state\",\n            binding=binding, response_binding=response_binding)\n\n        assert isinstance(sid, six.string_types)\n        assert len(http_args) == 4\n        assert http_args[\"headers\"][0][0] == \"Location\"\n        assert http_args[\"data\"] == []\n        redirect_url = http_args[\"headers\"][0][1]\n        _, _, _, _, qs, _ = urlparse(redirect_url)\n        qs_dict = parse_qs(qs)\n        req = self.server.parse_authn_request(qs_dict[\"SAMLRequest\"][0],\n                                              binding)\n        resp_args = self.server.response_args(req.message, [response_binding])\n        assert resp_args[\"binding\"] == response_binding\n\n    def test_do_negotiated_authn(self):\n        binding = BINDING_HTTP_REDIRECT\n        response_binding = BINDING_HTTP_POST\n        sid, auth_binding, http_args = \\\n            self.client.prepare_for_negotiated_authenticate(\n            IDP, \"http://www.example.com/relay_state\",\n            binding=binding, response_binding=response_binding)\n\n        assert binding == auth_binding\n        assert isinstance(sid, six.string_types)\n        assert len(http_args) == 4\n        assert http_args[\"headers\"][0][0] == \"Location\"\n        assert http_args[\"data\"] == []\n        redirect_url = http_args[\"headers\"][0][1]\n        _, _, _, _, qs, _ = urlparse(redirect_url)\n        qs_dict = parse_qs(qs)\n        req = self.server.parse_authn_request(qs_dict[\"SAMLRequest\"][0],\n                                              binding)\n        resp_args = self.server.response_args(req.message, [response_binding])\n        assert resp_args[\"binding\"] == response_binding\n\n    def test_do_attribute_query(self):\n        response = self.client.do_attribute_query(\n            IDP, \"_e7b68a04488f715cda642fbdd90099f5\",\n            attribute={\"eduPersonAffiliation\": None},\n            nameid_format=NAMEID_FORMAT_TRANSIENT)\n\n    def test_logout_1(self):\n        \"\"\" one IdP/AA logout from\"\"\"\n\n        # information about the user from an IdP\n        session_info = {\n            \"name_id\": nid,\n            \"issuer\": \"urn:mace:example.com:saml:roland:idp\",\n            \"not_on_or_after\": in_a_while(minutes=15),\n            \"ava\": {\n                \"givenName\": \"Anders\",\n                \"surName\": \"Andersson\",\n                \"mail\": \"anders.andersson@example.com\"\n            }\n        }\n        self.client.users.add_information_about_person(session_info)\n        entity_ids = self.client.users.issuers_of_info(nid)\n        assert entity_ids == [\"urn:mace:example.com:saml:roland:idp\"]\n        resp = self.client.global_logout(nid, \"Tired\", in_a_while(minutes=5))\n        print(resp)\n        assert resp\n        assert len(resp) == 1\n        assert list(resp.keys()) == entity_ids\n        response = resp[entity_ids[0]]\n        assert isinstance(response, LogoutResponse)\n\n    def test_post_sso(self):\n        binding = BINDING_HTTP_POST\n        response_binding = BINDING_HTTP_POST\n        sid, http_args = self.client.prepare_for_authenticate(\n            \"urn:mace:example.com:saml:roland:idp\", relay_state=\"really\",\n            binding=binding, response_binding=response_binding)\n        _dic = unpack_form(http_args[\"data\"][3])\n\n        req = self.server.parse_authn_request(_dic[\"SAMLRequest\"], binding)\n        resp_args = self.server.response_args(req.message, [response_binding])\n        assert resp_args[\"binding\"] == response_binding\n\n        # Normally a response would now be sent back to the users web client\n        # Here I fake what the client will do\n        # create the form post\n\n        http_args[\"data\"] = urlencode(_dic)\n        http_args[\"method\"] = \"POST\"\n        http_args[\"dummy\"] = _dic[\"SAMLRequest\"]\n        http_args[\"headers\"] = [('Content-type',\n                                 'application/x-www-form-urlencoded')]\n\n        response = self.client.send(**http_args)\n        print(response.text)\n        _dic = unpack_form(response.text[3], \"SAMLResponse\")\n        resp = self.client.parse_authn_request_response(_dic[\"SAMLResponse\"],\n                                                        BINDING_HTTP_POST,\n                                                        {sid: \"/\"})\n        ac = resp.assertion.authn_statement[0].authn_context\n        assert ac.authenticating_authority[0].text == \\\n               'http://www.example.com/login'\n        assert ac.authn_context_class_ref.text == INTERNETPROTOCOLPASSWORD\n\n    def test_negotiated_post_sso(self):\n        binding = BINDING_HTTP_POST\n        response_binding = BINDING_HTTP_POST\n        sid, auth_binding, http_args = self.client.prepare_for_negotiated_authenticate(\n            \"urn:mace:example.com:saml:roland:idp\", relay_state=\"really\",\n            binding=binding, response_binding=response_binding)\n        _dic = unpack_form(http_args[\"data\"][3])\n\n        assert binding == auth_binding\n\n        req = self.server.parse_authn_request(_dic[\"SAMLRequest\"], binding)\n        resp_args = self.server.response_args(req.message, [response_binding])\n        assert resp_args[\"binding\"] == response_binding\n\n        # Normally a response would now be sent back to the users web client\n        # Here I fake what the client will do\n        # create the form post\n\n        http_args[\"data\"] = urlencode(_dic)\n        http_args[\"method\"] = \"POST\"\n        http_args[\"dummy\"] = _dic[\"SAMLRequest\"]\n        http_args[\"headers\"] = [('Content-type',\n                                 'application/x-www-form-urlencoded')]\n\n        response = self.client.send(**http_args)\n        print(response.text)\n        _dic = unpack_form(response.text[3], \"SAMLResponse\")\n        resp = self.client.parse_authn_request_response(_dic[\"SAMLResponse\"],\n                                                        BINDING_HTTP_POST,\n                                                        {sid: \"/\"})\n        ac = resp.assertion.authn_statement[0].authn_context\n        assert ac.authenticating_authority[0].text == \\\n               'http://www.example.com/login'\n        assert ac.authn_context_class_ref.text == INTERNETPROTOCOLPASSWORD\n\n\n# if __name__ == \"__main__\":\n#     tc = TestClient()\n#     tc.setup_class()\n#     tc.test_response()\n\nif __name__ == \"__main__\":\n    tc = TestClient()\n    tc.setup_class()\n    tc.test_sign_then_encrypt_assertion()\n"], "fixing_code": ["#!/usr/bin/env python\nimport re\n\nimport sys\n\nfrom setuptools import setup\nfrom setuptools.command.test import test as TestCommand\n\ninstall_requires = [\n    # core dependencies\n    'decorator',\n    'requests >= 1.0.0',\n    'future',\n    'paste',\n    'zope.interface',\n    'repoze.who',\n    'pycryptodomex',\n    'pytz',\n    'pyOpenSSL',\n    'python-dateutil',\n    'defusedxml',\n    'six'\n]\n\nversion = ''\nwith open('src/saml2/__init__.py', 'r') as fd:\n    version = re.search(r'^__version__\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]',\n                        fd.read(), re.MULTILINE).group(1)\n\nsetup(\n    name='pysaml2',\n    version=version,\n    description='Python implementation of SAML Version 2',\n    # long_description = read(\"README\"),\n    author='Roland Hedberg',\n    author_email='roland.hedberg@adm.umu.se',\n    license='Apache 2.0',\n    url='https://github.com/rohe/pysaml2',\n\n    packages=['saml2', 'saml2/xmldsig', 'saml2/xmlenc', 'saml2/s2repoze',\n              'saml2/s2repoze.plugins', \"saml2/profile\", \"saml2/schema\",\n              \"saml2/extension\", \"saml2/attributemaps\", \"saml2/authn_context\",\n              \"saml2/entity_category\", \"saml2/userinfo\", \"saml2/ws\"],\n\n    package_dir={'': 'src'},\n    package_data={'': ['xml/*.xml']},\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Programming Language :: Python :: 2.7\",\n        \"Programming Language :: Python :: 3.4\",\n        \"Programming Language :: Python :: 3.5\"\n    ],\n\n    scripts=[\"tools/parse_xsd2.py\", \"tools/make_metadata.py\",\n             \"tools/mdexport.py\", \"tools/merge_metadata.py\"],\n    install_requires=install_requires,\n    zip_safe=False,\n)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Contains base classes representing SAML elements.\n\n    These codes were originally written by Jeffrey Scudder for\n    representing Saml elements. Takashi Matsuo had added some codes, and\n    changed some. Roland Hedberg rewrote the whole thing from bottom up so\n    barely anything but the original structures remained.\n\n    Module objective: provide data classes for SAML constructs. These\n    classes hide the XML-ness of SAML and provide a set of native Python\n    classes to interact with.\n\n    Conversions to and from XML should only be necessary when the SAML classes\n    \"touch the wire\" and are sent over HTTP. For this reason this module\n    provides methods and functions to convert SAML classes to and from strings.\n\"\"\"\n\n__version__ = \"4.4.0\"\n\nimport logging\nimport six\nfrom saml2.validate import valid_instance\n\ntry:\n    from xml.etree import cElementTree as ElementTree\n\n    if ElementTree.VERSION < '1.3.0':\n        # cElementTree has no support for register_namespace\n        # neither _namespace_map, thus we sacrify performance\n        # for correctness\n        from xml.etree import ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        from elementtree import ElementTree\nimport defusedxml.ElementTree\n\nroot_logger = logging.getLogger(__name__)\nroot_logger.level = logging.NOTSET\n\nNAMESPACE = 'urn:oasis:names:tc:SAML:2.0:assertion'\n# TEMPLATE = '{urn:oasis:names:tc:SAML:2.0:assertion}%s'\n# XSI_NAMESPACE = 'http://www.w3.org/2001/XMLSchema-instance'\n\nNAMEID_FORMAT_EMAILADDRESS = (\n    \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\")\n\n# These are defined in saml2.saml\n# NAME_FORMAT_UNSPECIFIED = (\n#    \"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\")\n# NAME_FORMAT_URI = \"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\"\n# NAME_FORMAT_BASIC = \"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\"\n\nDECISION_TYPE_PERMIT = \"Permit\"\nDECISION_TYPE_DENY = \"Deny\"\nDECISION_TYPE_INDETERMINATE = \"Indeterminate\"\n\nVERSION = \"2.0\"\n\nBINDING_SOAP = 'urn:oasis:names:tc:SAML:2.0:bindings:SOAP'\nBINDING_PAOS = 'urn:oasis:names:tc:SAML:2.0:bindings:PAOS'\nBINDING_HTTP_REDIRECT = 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect'\nBINDING_HTTP_POST = 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST'\nBINDING_HTTP_ARTIFACT = 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Artifact'\nBINDING_URI = 'urn:oasis:names:tc:SAML:2.0:bindings:URI'\n\n\ndef class_name(instance):\n    return \"%s:%s\" % (instance.c_namespace, instance.c_tag)\n\n\ndef create_class_from_xml_string(target_class, xml_string):\n    \"\"\"Creates an instance of the target class from a string.\n\n    :param target_class: The class which will be instantiated and populated\n        with the contents of the XML. This class must have a c_tag and a\n        c_namespace class variable.\n    :param xml_string: A string which contains valid XML. The root element\n        of the XML string should match the tag and namespace of the desired\n        class.\n\n    :return: An instance of the target class with members assigned according to\n        the contents of the XML - or None if the root XML tag and namespace did\n        not match those of the target class.\n    \"\"\"\n    if not isinstance(xml_string, six.binary_type):\n        xml_string = xml_string.encode('utf-8')\n    tree = defusedxml.ElementTree.fromstring(xml_string)\n    return create_class_from_element_tree(target_class, tree)\n\n\ndef create_class_from_element_tree(target_class, tree, namespace=None,\n                                   tag=None):\n    \"\"\"Instantiates the class and populates members according to the tree.\n\n    Note: Only use this function with classes that have c_namespace and c_tag\n    class members.\n\n    :param target_class: The class which will be instantiated and populated\n        with the contents of the XML.\n    :param tree: An element tree whose contents will be converted into\n        members of the new target_class instance.\n    :param namespace: The namespace which the XML tree's root node must\n        match. If omitted, the namespace defaults to the c_namespace of the\n        target class.\n    :param tag: The tag which the XML tree's root node must match. If\n        omitted, the tag defaults to the c_tag class member of the target\n        class.\n\n    :return: An instance of the target class - or None if the tag and namespace\n        of the XML tree's root node did not match the desired namespace and tag.\n    \"\"\"\n    if namespace is None:\n        namespace = target_class.c_namespace\n    if tag is None:\n        tag = target_class.c_tag\n    if tree.tag == '{%s}%s' % (namespace, tag):\n        target = target_class()\n        target.harvest_element_tree(tree)\n        return target\n    else:\n        return None\n\n\nclass Error(Exception):\n    \"\"\"Exception class thrown by this module.\"\"\"\n    pass\n\n\nclass SAMLError(Exception):\n    pass\n\n\nclass ExtensionElement(object):\n    \"\"\"XML which is not part of the SAML specification,\n    these are called extension elements. If a classes parser\n    encounters an unexpected XML construct, it is translated into an\n    ExtensionElement instance. ExtensionElement is designed to fully\n    capture the information in the XML. Child nodes in an XML\n    extension are turned into ExtensionElements as well.\n    \"\"\"\n\n    def __init__(self, tag, namespace=None, attributes=None,\n                 children=None, text=None):\n        \"\"\"Constructor for ExtensionElement\n\n        :param namespace: The XML namespace for this element.\n        :param tag: The tag (without the namespace qualifier) for\n            this element. To reconstruct the full qualified name of the\n            element, combine this tag with the namespace.\n        :param attributes: The attribute value string pairs for the XML\n            attributes of this element.\n        :param children: list (optional) A list of ExtensionElements which\n            represent the XML child nodes of this element.\n        \"\"\"\n\n        self.namespace = namespace\n        self.tag = tag\n        self.attributes = attributes or {}\n        self.children = children or []\n        self.text = text\n\n    def to_string(self):\n        \"\"\" Serialize the object into a XML string \"\"\"\n        element_tree = self.transfer_to_element_tree()\n        return ElementTree.tostring(element_tree, encoding=\"UTF-8\")\n\n    def transfer_to_element_tree(self):\n        if self.tag is None:\n            return None\n\n        element_tree = ElementTree.Element('')\n\n        if self.namespace is not None:\n            element_tree.tag = '{%s}%s' % (self.namespace, self.tag)\n        else:\n            element_tree.tag = self.tag\n\n        for key, value in iter(self.attributes.items()):\n            element_tree.attrib[key] = value\n\n        for child in self.children:\n            child.become_child_element_of(element_tree)\n\n        element_tree.text = self.text\n\n        return element_tree\n\n    def become_child_element_of(self, element_tree):\n        \"\"\"Converts this object into an etree element and adds it as a child\n        node in an etree element.\n\n        Adds self to the ElementTree. This method is required to avoid verbose\n        XML which constantly redefines the namespace.\n\n        :param element_tree: ElementTree._Element The element to which this\n            object's XML will be added.\n        \"\"\"\n        new_element = self.transfer_to_element_tree()\n        element_tree.append(new_element)\n\n    def find_children(self, tag=None, namespace=None):\n        \"\"\"Searches child nodes for objects with the desired tag/namespace.\n\n        Returns a list of extension elements within this object whose tag\n        and/or namespace match those passed in. To find all children in\n        a particular namespace, specify the namespace but not the tag name.\n        If you specify only the tag, the result list may contain extension\n        elements in multiple namespaces.\n\n        :param tag: str (optional) The desired tag\n        :param namespace: str (optional) The desired namespace\n\n        :return: A list of elements whose tag and/or namespace match the\n            parameters values\n        \"\"\"\n\n        results = []\n\n        if tag and namespace:\n            for element in self.children:\n                if element.tag == tag and element.namespace == namespace:\n                    results.append(element)\n        elif tag and not namespace:\n            for element in self.children:\n                if element.tag == tag:\n                    results.append(element)\n        elif namespace and not tag:\n            for element in self.children:\n                if element.namespace == namespace:\n                    results.append(element)\n        else:\n            for element in self.children:\n                results.append(element)\n\n        return results\n\n    def loadd(self, ava):\n        \"\"\" expects a special set of keys \"\"\"\n\n        if \"attributes\" in ava:\n            for key, val in ava[\"attributes\"].items():\n                self.attributes[key] = val\n\n        try:\n            self.tag = ava[\"tag\"]\n        except KeyError:\n            if not self.tag:\n                raise KeyError(\"ExtensionElement must have a tag\")\n\n        try:\n            self.namespace = ava[\"namespace\"]\n        except KeyError:\n            if not self.namespace:\n                raise KeyError(\"ExtensionElement must belong to a namespace\")\n\n        try:\n            self.text = ava[\"text\"]\n        except KeyError:\n            pass\n\n        if \"children\" in ava:\n            for item in ava[\"children\"]:\n                self.children.append(ExtensionElement(item[\"tag\"]).loadd(item))\n\n        return self\n\n\ndef extension_element_from_string(xml_string):\n    element_tree = defusedxml.ElementTree.fromstring(xml_string)\n    return _extension_element_from_element_tree(element_tree)\n\n\ndef _extension_element_from_element_tree(element_tree):\n    elementc_tag = element_tree.tag\n    if '}' in elementc_tag:\n        namespace = elementc_tag[1:elementc_tag.index('}')]\n        tag = elementc_tag[elementc_tag.index('}') + 1:]\n    else:\n        namespace = None\n        tag = elementc_tag\n    extension = ExtensionElement(namespace=namespace, tag=tag)\n    for key, value in iter(element_tree.attrib.items()):\n        extension.attributes[key] = value\n    for child in element_tree:\n        extension.children.append(_extension_element_from_element_tree(child))\n    extension.text = element_tree.text\n    return extension\n\n\nclass ExtensionContainer(object):\n    c_tag = \"\"\n    c_namespace = \"\"\n\n    def __init__(self, text=None, extension_elements=None,\n                 extension_attributes=None):\n\n        self.text = text\n        self.extension_elements = extension_elements or []\n        self.extension_attributes = extension_attributes or {}\n        self.encrypted_assertion = None\n\n    # Three methods to create an object from an ElementTree\n    def harvest_element_tree(self, tree):\n        # Fill in the instance members from the contents of the XML tree.\n        for child in tree:\n            self._convert_element_tree_to_member(child)\n        for attribute, value in iter(tree.attrib.items()):\n            self._convert_element_attribute_to_member(attribute, value)\n        self.text = tree.text\n\n    def _convert_element_tree_to_member(self, child_tree):\n        self.extension_elements.append(_extension_element_from_element_tree(\n            child_tree))\n\n    def _convert_element_attribute_to_member(self, attribute, value):\n        self.extension_attributes[attribute] = value\n\n    # One method to create an ElementTree from an object\n    def _add_members_to_element_tree(self, tree):\n        for child in self.extension_elements:\n            child.become_child_element_of(tree)\n        for attribute, value in iter(self.extension_attributes.items()):\n            tree.attrib[attribute] = value\n        tree.text = self.text\n\n    def find_extensions(self, tag=None, namespace=None):\n        \"\"\"Searches extension elements for child nodes with the desired name.\n\n        Returns a list of extension elements within this object whose tag\n        and/or namespace match those passed in. To find all extensions in\n        a particular namespace, specify the namespace but not the tag name.\n        If you specify only the tag, the result list may contain extension\n        elements in multiple namespaces.\n\n        :param tag: str (optional) The desired tag\n        :param namespace: str (optional) The desired namespace\n\n        :Return: A list of elements whose tag and/or namespace match the\n            parameters values\n        \"\"\"\n\n        results = []\n\n        if tag and namespace:\n            for element in self.extension_elements:\n                if element.tag == tag and element.namespace == namespace:\n                    results.append(element)\n        elif tag and not namespace:\n            for element in self.extension_elements:\n                if element.tag == tag:\n                    results.append(element)\n        elif namespace and not tag:\n            for element in self.extension_elements:\n                if element.namespace == namespace:\n                    results.append(element)\n        else:\n            for element in self.extension_elements:\n                results.append(element)\n\n        return results\n\n    def extensions_as_elements(self, tag, schema):\n        \"\"\" Return extensions that has the given tag and belongs to the\n        given schema as native elements of that schema.\n\n        :param tag: The tag of the element\n        :param schema: Which schema the element should originate from\n        :return: a list of native elements\n        \"\"\"\n        result = []\n        for ext in self.find_extensions(tag, schema.NAMESPACE):\n            ets = schema.ELEMENT_FROM_STRING[tag]\n            result.append(ets(ext.to_string()))\n        return result\n\n    def add_extension_elements(self, items):\n        for item in items:\n            self.extension_elements.append(element_to_extension_element(item))\n\n    def add_extension_element(self, item):\n        self.extension_elements.append(element_to_extension_element(item))\n\n    def add_extension_attribute(self, name, value):\n        self.extension_attributes[name] = value\n\n\ndef make_vals(val, klass, klass_inst=None, prop=None, part=False,\n              base64encode=False):\n    \"\"\"\n    Creates a class instance with a specified value, the specified\n    class instance may be a value on a property in a defined class instance.\n\n    :param val: The value\n    :param klass: The value class\n    :param klass_inst: The class instance which has a property on which\n        what this function returns is a value.\n    :param prop: The property which the value should be assigned to.\n    :param part: If the value is one of a possible list of values it should be\n        handled slightly different compared to if it isn't.\n    :return: Value class instance\n    \"\"\"\n    cinst = None\n\n    # print(\"make_vals(%s, %s)\" % (val, klass))\n\n    if isinstance(val, dict):\n        cinst = klass().loadd(val, base64encode=base64encode)\n    else:\n        try:\n            cinst = klass().set_text(val)\n        except ValueError:\n            if not part:\n                cis = [make_vals(sval, klass, klass_inst, prop, True,\n                                 base64encode) for sval in val]\n                setattr(klass_inst, prop, cis)\n            else:\n                raise\n\n    if part:\n        return cinst\n    else:\n        if cinst:\n            cis = [cinst]\n            setattr(klass_inst, prop, cis)\n\n\ndef make_instance(klass, spec, base64encode=False):\n    \"\"\"\n    Constructs a class instance containing the specified information\n\n    :param klass: The class\n    :param spec: Information to be placed in the instance (a dictionary)\n    :return: The instance\n    \"\"\"\n\n    return klass().loadd(spec, base64encode)\n\n\nclass SamlBase(ExtensionContainer):\n    \"\"\"A foundation class on which SAML classes are built. It\n    handles the parsing of attributes and children which are common to all\n    SAML classes. By default, the SamlBase class translates all XML child\n    nodes into ExtensionElements.\n    \"\"\"\n\n    c_children = {}\n    c_attributes = {}\n    c_attribute_type = {}\n    c_child_order = []\n    c_cardinality = {}\n    c_any = None\n    c_any_attribute = None\n    c_value_type = None\n    c_ns_prefix = None\n\n    def _get_all_c_children_with_order(self):\n        if len(self.c_child_order) > 0:\n            for child in self.c_child_order:\n                yield child\n        else:\n            for _, values in iter(self.__class__.c_children.items()):\n                yield values[0]\n\n    def _convert_element_tree_to_member(self, child_tree):\n        # Find the element's tag in this class's list of child members\n        if child_tree.tag in self.__class__.c_children:\n            member_name = self.__class__.c_children[child_tree.tag][0]\n            member_class = self.__class__.c_children[child_tree.tag][1]\n            # If the class member is supposed to contain a list, make sure the\n            # matching member is set to a list, then append the new member\n            # instance to the list.\n            if isinstance(member_class, list):\n                if getattr(self, member_name) is None:\n                    setattr(self, member_name, [])\n                getattr(self, member_name).append(\n                    create_class_from_element_tree(member_class[0], child_tree))\n            else:\n                setattr(self, member_name,\n                        create_class_from_element_tree(member_class,\n                                                       child_tree))\n        else:\n            ExtensionContainer._convert_element_tree_to_member(self, child_tree)\n\n    def _convert_element_attribute_to_member(self, attribute, value):\n        # Find the attribute in this class's list of attributes.\n        if attribute in self.__class__.c_attributes:\n            # Find the member of this class which corresponds to the XML\n            # attribute(lookup in current_class.c_attributes) and set this\n            # member to the desired value (using self.__dict__).\n            setattr(self, self.__class__.c_attributes[attribute][0], value)\n        else:\n            # If it doesn't appear in the attribute list it's an extension\n            ExtensionContainer._convert_element_attribute_to_member(\n                self, attribute, value)\n\n    # Three methods to create an ElementTree from an object\n    def _add_members_to_element_tree(self, tree):\n        # Convert the members of this class which are XML child nodes.\n        # This uses the class's c_children dictionary to find the members which\n        # should become XML child nodes.\n        for member_name in self._get_all_c_children_with_order():\n            member = getattr(self, member_name)\n            if member is None:\n                pass\n            elif isinstance(member, list):\n                for instance in member:\n                    instance.become_child_element_of(tree)\n            else:\n                member.become_child_element_of(tree)\n        # Convert the members of this class which are XML attributes.\n        for xml_attribute, attribute_info in \\\n                iter(self.__class__.c_attributes.items()):\n            (member_name, member_type, required) = attribute_info\n            member = getattr(self, member_name)\n            if member is not None:\n                tree.attrib[xml_attribute] = member\n\n        # Lastly, call the ExtensionContainers's _add_members_to_element_tree\n        # to convert any extension attributes.\n        ExtensionContainer._add_members_to_element_tree(self, tree)\n\n    def become_child_element_of(self, node):\n        \"\"\"\n        Note: Only for use with classes that have a c_tag and c_namespace class\n        member. It is in SamlBase so that it can be inherited but it should\n        not be called on instances of SamlBase.\n\n        :param node: The node to which this instance should be a child\n        \"\"\"\n        new_child = self._to_element_tree()\n        node.append(new_child)\n\n    def _to_element_tree(self):\n        \"\"\"\n\n        Note, this method is designed to be used only with classes that have a\n        c_tag and c_namespace. It is placed in SamlBase for inheritance but\n        should not be called on in this class.\n\n        \"\"\"\n        new_tree = ElementTree.Element('{%s}%s' % (self.__class__.c_namespace,\n                                                   self.__class__.c_tag))\n        self._add_members_to_element_tree(new_tree)\n        return new_tree\n\n    def register_prefix(self, nspair):\n        \"\"\"\n        Register with ElementTree a set of namespaces\n\n        :param nspair: A dictionary of prefixes and uris to use when\n            constructing the text representation.\n        :return:\n        \"\"\"\n        for prefix, uri in nspair.items():\n            try:\n                ElementTree.register_namespace(prefix, uri)\n            except AttributeError:\n                # Backwards compatibility with ET < 1.3\n                ElementTree._namespace_map[uri] = prefix\n            except ValueError:\n                pass\n\n    def get_ns_map_attribute(self, attributes, uri_set):\n        for attribute in attributes:\n            if attribute[0] == \"{\":\n                uri, tag = attribute[1:].split(\"}\")\n                uri_set.add(uri)\n        return uri_set\n\n    def tag_get_uri(self, elem):\n        if elem.tag[0] == \"{\":\n            uri, tag = elem.tag[1:].split(\"}\")\n            return uri\n        return None\n\n    def get_ns_map(self, elements, uri_set):\n\n        for elem in elements:\n            uri_set = self.get_ns_map_attribute(elem.attrib, uri_set)\n            uri_set = self.get_ns_map(elem.getchildren(), uri_set)\n            uri = self.tag_get_uri(elem)\n            if uri is not None:\n                uri_set.add(uri)\n        return uri_set\n\n    def get_prefix_map(self, elements):\n        uri_set = self.get_ns_map(elements, set())\n        prefix_map = {}\n        for uri in sorted(uri_set):\n            prefix_map[\"encas%d\" % len(prefix_map)] = uri\n        return prefix_map\n\n    def get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n            self, assertion_tag, advice_tag):\n        for tmp_encrypted_assertion in \\\n                self.assertion.advice.encrypted_assertion:\n            if tmp_encrypted_assertion.encrypted_data is None:\n                prefix_map = self.get_prefix_map([\n                                                     tmp_encrypted_assertion._to_element_tree().find(\n                                                         assertion_tag)])\n                tree = self._to_element_tree()\n                encs = tree.find(assertion_tag).find(advice_tag).findall(\n                    tmp_encrypted_assertion._to_element_tree().tag)\n                for enc in encs:\n                    assertion = enc.find(assertion_tag)\n                    if assertion is not None:\n                        self.set_prefixes(assertion, prefix_map)\n\n        return ElementTree.tostring(tree, encoding=\"UTF-8\").decode('utf-8')\n\n    def get_xml_string_with_self_contained_assertion_within_encrypted_assertion(\n            self, assertion_tag):\n        \"\"\" Makes a encrypted assertion only containing self contained\n        namespaces.\n\n        :param assertion_tag: Tag for the assertion to be transformed.\n        :return: A new samlp.Resonse in string representation.\n        \"\"\"\n        prefix_map = self.get_prefix_map(\n            [self.encrypted_assertion._to_element_tree().find(assertion_tag)])\n\n        tree = self._to_element_tree()\n\n        self.set_prefixes(\n            tree.find(\n                self.encrypted_assertion._to_element_tree().tag).find(\n                assertion_tag), prefix_map)\n\n        return ElementTree.tostring(tree, encoding=\"UTF-8\").decode('utf-8')\n\n    def set_prefixes(self, elem, prefix_map):\n\n        # check if this is a tree wrapper\n        if not ElementTree.iselement(elem):\n            elem = elem.getroot()\n\n        # build uri map and add to root element\n        uri_map = {}\n        for prefix, uri in prefix_map.items():\n            uri_map[uri] = prefix\n            elem.set(\"xmlns:\" + prefix, uri)\n\n        # fixup all elements in the tree\n        memo = {}\n        for elem in elem.getiterator():\n            self.fixup_element_prefixes(elem, uri_map, memo)\n\n    def fixup_element_prefixes(self, elem, uri_map, memo):\n        def fixup(name):\n            try:\n                return memo[name]\n            except KeyError:\n                if name[0] != \"{\":\n                    return\n                uri, tag = name[1:].split(\"}\")\n                if uri in uri_map:\n                    new_name = uri_map[uri] + \":\" + tag\n                    memo[name] = new_name\n                    return new_name\n\n        # fix element name\n        name = fixup(elem.tag)\n        if name:\n            elem.tag = name\n        # fix attribute names\n        for key, value in elem.items():\n            name = fixup(key)\n            if name:\n                elem.set(name, value)\n                del elem.attrib[key]\n\n    def to_string_force_namespace(self, nspair):\n\n        elem = self._to_element_tree()\n\n        self.set_prefixes(elem, nspair)\n\n        return ElementTree.tostring(elem, encoding=\"UTF-8\")\n\n    def to_string(self, nspair=None):\n        \"\"\"Converts the Saml object to a string containing XML.\n\n        :param nspair: A dictionary of prefixes and uris to use when\n            constructing the text representation.\n        :return: String representation of the object\n        \"\"\"\n        if not nspair and self.c_ns_prefix:\n            nspair = self.c_ns_prefix\n\n        if nspair:\n            self.register_prefix(nspair)\n\n        return ElementTree.tostring(self._to_element_tree(), encoding=\"UTF-8\")\n\n    def __str__(self):\n        # Yes this is confusing. http://bugs.python.org/issue10942\n        x = self.to_string()\n        if not isinstance(x, six.string_types):\n            x = x.decode('utf-8')\n        return x\n\n    def keyswv(self):\n        \"\"\" Return the keys of attributes or children that has values\n\n        :return: list of keys\n        \"\"\"\n        return [key for key, val in self.__dict__.items() if val]\n\n    def keys(self):\n        \"\"\" Return all the keys that represent possible attributes and\n        children.\n\n        :return: list of keys\n        \"\"\"\n        keys = ['text']\n        keys.extend([n for (n, t, r) in self.c_attributes.values()])\n        keys.extend([v[0] for v in self.c_children.values()])\n        return keys\n\n    def children_with_values(self):\n        \"\"\" Returns all children that has values\n\n        :return: Possibly empty list of children.\n        \"\"\"\n        childs = []\n        for attribute in self._get_all_c_children_with_order():\n            member = getattr(self, attribute)\n            if member is None or member == []:\n                pass\n            elif isinstance(member, list):\n                for instance in member:\n                    childs.append(instance)\n            else:\n                childs.append(member)\n        return childs\n\n    # noinspection PyUnusedLocal\n    def set_text(self, val, base64encode=False):\n        \"\"\" Sets the text property of this instance.\n\n        :param val: The value of the text property\n        :param base64encode: Whether the value should be base64encoded\n        :return: The instance\n        \"\"\"\n\n        # print(\"set_text: %s\" % (val,))\n        if isinstance(val, bool):\n            if val:\n                setattr(self, \"text\", \"true\")\n            else:\n                setattr(self, \"text\", \"false\")\n        elif isinstance(val, int):\n            setattr(self, \"text\", \"%d\" % val)\n        elif isinstance(val, six.string_types):\n            setattr(self, \"text\", val)\n        elif val is None:\n            pass\n        else:\n            raise ValueError(\"Type shouldn't be '%s'\" % (val,))\n\n        return self\n\n    def loadd(self, ava, base64encode=False):\n        \"\"\"\n        Sets attributes, children, extension elements and extension\n        attributes of this element instance depending on what is in\n        the given dictionary. If there are already values on properties\n        those will be overwritten. If the keys in the dictionary does\n        not correspond to known attributes/children/.. they are ignored.\n\n        :param ava: The dictionary\n        :param base64encode: Whether the values on attributes or texts on\n            children shoule be base64encoded.\n        :return: The instance\n        \"\"\"\n\n        for prop, _typ, _req in self.c_attributes.values():\n            # print(\"# %s\" % (prop))\n            if prop in ava:\n                if isinstance(ava[prop], bool):\n                    setattr(self, prop, \"%s\" % ava[prop])\n                elif isinstance(ava[prop], int):\n                    setattr(self, prop, \"%d\" % ava[prop])\n                else:\n                    setattr(self, prop, ava[prop])\n\n        if \"text\" in ava:\n            self.set_text(ava[\"text\"], base64encode)\n\n        for prop, klassdef in self.c_children.values():\n            # print(\"## %s, %s\" % (prop, klassdef))\n            if prop in ava:\n                # print(\"### %s\" % ava[prop])\n                # means there can be a list of values\n                if isinstance(klassdef, list):\n                    make_vals(ava[prop], klassdef[0], self, prop,\n                              base64encode=base64encode)\n                else:\n                    cis = make_vals(ava[prop], klassdef, self, prop, True,\n                                    base64encode)\n                    setattr(self, prop, cis)\n\n        if \"extension_elements\" in ava:\n            for item in ava[\"extension_elements\"]:\n                self.extension_elements.append(ExtensionElement(\n                    item[\"tag\"]).loadd(item))\n\n        if \"extension_attributes\" in ava:\n            for key, val in ava[\"extension_attributes\"].items():\n                self.extension_attributes[key] = val\n\n        return self\n\n    def clear_text(self):\n        if self.text:\n            _text = self.text.strip()\n            if _text == \"\":\n                self.text = None\n\n    def __eq__(self, other):\n        try:\n            assert isinstance(other, SamlBase)\n        except AssertionError:\n            return False\n\n        self.clear_text()\n        other.clear_text()\n        if len(self.keyswv()) != len(other.keyswv()):\n            return False\n\n        for key in self.keyswv():\n            if key in [\"_extatt\"]:\n                continue\n            svals = self.__dict__[key]\n            ovals = other.__dict__[key]\n            if isinstance(svals, six.string_types):\n                if svals != ovals:\n                    return False\n            elif isinstance(svals, list):\n                for sval in svals:\n                    try:\n                        for oval in ovals:\n                            if sval == oval:\n                                break\n                        else:\n                            return False\n                    except TypeError:\n                        # ovals isn't iterable\n                        return False\n            else:\n                if svals == ovals:  # Since I only support '=='\n                    pass\n                else:\n                    return False\n        return True\n\n    def child_class(self, child):\n        \"\"\" Return the class a child element should be an instance of\n\n        :param child: The name of the child element\n        :return: The class\n        \"\"\"\n        for prop, klassdef in self.c_children.values():\n            if child == prop:\n                if isinstance(klassdef, list):\n                    return klassdef[0]\n                else:\n                    return klassdef\n        return None\n\n    def child_cardinality(self, child):\n        \"\"\" Return the cardinality of a child element\n\n        :param child: The name of the child element\n        :return: The cardinality as a 2-tuple (min, max).\n            The max value is either a number or the string \"unbounded\".\n            The min value is always a number.\n        \"\"\"\n        for prop, klassdef in self.c_children.values():\n            if child == prop:\n                if isinstance(klassdef, list):\n                    try:\n                        _min = self.c_cardinality[\"min\"]\n                    except KeyError:\n                        _min = 1\n                    try:\n                        _max = self.c_cardinality[\"max\"]\n                    except KeyError:\n                        _max = \"unbounded\"\n\n                    return _min, _max\n                else:\n                    return 1, 1\n        return None\n\n    def verify(self):\n        return valid_instance(self)\n\n    def empty(self):\n        for prop, _typ, _req in self.c_attributes.values():\n            if getattr(self, prop, None):\n                return False\n\n        for prop, klassdef in self.c_children.values():\n            if getattr(self, prop):\n                return False\n\n        for param in [\"text\", \"extension_elements\", \"extension_attributes\"]:\n            if getattr(self, param):\n                return False\n\n        return True\n\n\n# ----------------------------------------------------------------------------\n\n\ndef element_to_extension_element(element):\n    \"\"\"\n    Convert an element into a extension element\n\n    :param element: The element instance\n    :return: An extension element instance\n    \"\"\"\n\n    exel = ExtensionElement(element.c_tag, element.c_namespace,\n                            text=element.text)\n\n    exel.attributes.update(element.extension_attributes)\n    exel.children.extend(element.extension_elements)\n\n    for xml_attribute, (member_name, typ, req) in \\\n            iter(element.c_attributes.items()):\n        member_value = getattr(element, member_name)\n        if member_value is not None:\n            exel.attributes[xml_attribute] = member_value\n\n    exel.children.extend([element_to_extension_element(c) for c in\n                          element.children_with_values()])\n\n    return exel\n\n\ndef extension_element_to_element(extension_element, translation_functions,\n                                 namespace=None):\n    \"\"\" Convert an extension element to a normal element.\n    In order to do this you need to have an idea of what type of\n    element it is. Or rather which module it belongs to.\n\n    :param extension_element: The extension element\n    :param translation_functions: A dictionary with class identifiers\n        as keys and string-to-element translations functions as values\n    :param namespace: The namespace of the translation functions.\n    :return: An element instance or None\n    \"\"\"\n\n    try:\n        element_namespace = extension_element.namespace\n    except AttributeError:\n        element_namespace = extension_element.c_namespace\n    if element_namespace == namespace:\n        try:\n            try:\n                ets = translation_functions[extension_element.tag]\n            except AttributeError:\n                ets = translation_functions[extension_element.c_tag]\n            return ets(extension_element.to_string())\n        except KeyError:\n            pass\n\n    return None\n\n\ndef extension_elements_to_elements(extension_elements, schemas):\n    \"\"\" Create a list of elements each one matching one of the\n    given extension elements. This is of course dependent on the access\n    to schemas that describe the extension elements.\n\n    :param extension_elements: The list of extension elements\n    :param schemas: Imported Python modules that represent the different\n        known schemas used for the extension elements\n    :return: A list of elements, representing the set of extension elements\n        that was possible to match against a Class in the given schemas.\n        The elements returned are the native representation of the elements\n        according to the schemas.\n    \"\"\"\n    res = []\n\n    if isinstance(schemas, list):\n        pass\n    elif isinstance(schemas, dict):\n        schemas = list(schemas.values())\n    else:\n        return res\n\n    for extension_element in extension_elements:\n        for schema in schemas:\n            inst = extension_element_to_element(extension_element,\n                                                schema.ELEMENT_FROM_STRING,\n                                                schema.NAMESPACE)\n            if inst:\n                res.append(inst)\n                break\n\n    return res\n\n\ndef extension_elements_as_dict(extension_elements, onts):\n    ees_ = extension_elements_to_elements(extension_elements, onts)\n    res = {}\n    for elem in ees_:\n        try:\n            res[elem.c_tag].append(elem)\n        except KeyError:\n            res[elem.c_tag] = [elem]\n    return res\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n\n\"\"\"Contains classes and functions that are necessary to implement\ndifferent bindings.\n\nBindings normally consists of three parts:\n- rules about what to send\n- how to package the information\n- which protocol to use\n\"\"\"\nfrom six.moves.urllib.parse import urlparse, urlencode\nimport saml2\nimport base64\nfrom saml2.s_utils import deflate_and_base64_encode\nfrom saml2.s_utils import Unsupported\nimport logging\nfrom saml2.sigver import REQ_ORDER\nfrom saml2.sigver import RESP_ORDER\nfrom saml2.sigver import SIGNER_ALGS\nimport six\nfrom saml2.xmldsig import SIG_ALLOWED_ALG\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    from xml.etree import cElementTree as ElementTree\n\n    if ElementTree.VERSION < '1.3.0':\n        # cElementTree has no support for register_namespace\n        # neither _namespace_map, thus we sacrify performance\n        # for correctness\n        from xml.etree import ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        from elementtree import ElementTree\nimport defusedxml.ElementTree\n\nNAMESPACE = \"http://schemas.xmlsoap.org/soap/envelope/\"\nFORM_SPEC = \"\"\"<form method=\"post\" action=\"%s\">\n   <input type=\"hidden\" name=\"%s\" value=\"%s\" />\n   <input type=\"hidden\" name=\"RelayState\" value=\"%s\" />\n   <input type=\"submit\" value=\"Submit\" />\n</form>\"\"\"\n\n\ndef http_form_post_message(message, location, relay_state=\"\",\n                           typ=\"SAMLRequest\", **kwargs):\n    \"\"\"The HTTP POST binding defines a mechanism by which SAML protocol\n    messages may be transmitted within the base64-encoded content of a\n    HTML form control.\n\n    :param message: The message\n    :param location: Where the form should be posted to\n    :param relay_state: for preserving and conveying state information\n    :return: A tuple containing header information and a HTML message.\n    \"\"\"\n    response = [\"<head>\", \"\"\"<title>SAML 2.0 POST</title>\"\"\", \"</head><body>\"]\n\n    if not isinstance(message, six.string_types):\n        message = str(message)\n    if not isinstance(message, six.binary_type):\n        message = message.encode('utf-8')\n\n    if typ == \"SAMLRequest\" or typ == \"SAMLResponse\":\n        _msg = base64.b64encode(message)\n    else:\n        _msg = message\n    _msg = _msg.decode('ascii')\n\n    response.append(FORM_SPEC % (location, typ, _msg, relay_state))\n\n    response.append(\"\"\"<script type=\"text/javascript\">\"\"\")\n    response.append(\"     window.onload = function ()\")\n    response.append(\" { document.forms[0].submit(); }\")\n    response.append(\"\"\"</script>\"\"\")\n    response.append(\"</body>\")\n\n    return {\"headers\": [(\"Content-type\", \"text/html\")], \"data\": response}\n\n\ndef http_post_message(message, relay_state=\"\", typ=\"SAMLRequest\", **kwargs):\n    \"\"\"\n\n    :param message: The message\n    :param relay_state: for preserving and conveying state information\n    :return: A tuple containing header information and a HTML message.\n    \"\"\"\n    if not isinstance(message, six.string_types):\n        message = str(message)\n    if not isinstance(message, six.binary_type):\n        message = message.encode('utf-8')\n\n    if typ == \"SAMLRequest\" or typ == \"SAMLResponse\":\n        _msg = base64.b64encode(message)\n    else:\n        _msg = message\n    _msg = _msg.decode('ascii')\n\n    part = {typ: _msg}\n    if relay_state:\n        part[\"RelayState\"] = relay_state\n\n    return {\"headers\": [(\"Content-type\", 'application/x-www-form-urlencoded')],\n            \"data\": urlencode(part)}\n\n\ndef http_redirect_message(message, location, relay_state=\"\", typ=\"SAMLRequest\",\n                          sigalg='', signer=None, **kwargs):\n    \"\"\"The HTTP Redirect binding defines a mechanism by which SAML protocol\n    messages can be transmitted within URL parameters.\n    Messages are encoded for use with this binding using a URL encoding\n    technique, and transmitted using the HTTP GET method.\n\n    The DEFLATE Encoding is used in this function.\n\n    :param message: The message\n    :param location: Where the message should be posted to\n    :param relay_state: for preserving and conveying state information\n    :param typ: What type of message it is SAMLRequest/SAMLResponse/SAMLart\n    :param sigalg: Which algorithm the signature function will use to sign\n        the message\n    :param signer: A signature function that can be used to sign the message\n    :return: A tuple containing header information and a HTML message.\n    \"\"\"\n\n    if not isinstance(message, six.string_types):\n        message = \"%s\" % (message,)\n\n    _order = None\n    if typ in [\"SAMLRequest\", \"SAMLResponse\"]:\n        if typ == \"SAMLRequest\":\n            _order = REQ_ORDER\n        else:\n            _order = RESP_ORDER\n        args = {typ: deflate_and_base64_encode(message)}\n    elif typ == \"SAMLart\":\n        args = {typ: message}\n    else:\n        raise Exception(\"Unknown message type: %s\" % typ)\n\n    if relay_state:\n        args[\"RelayState\"] = relay_state\n\n    if signer:\n        # sigalgs, should be one defined in xmldsig\n        assert sigalg in [b for a, b in SIG_ALLOWED_ALG]\n        args[\"SigAlg\"] = sigalg\n\n        string = \"&\".join([urlencode({k: args[k]})\n                           for k in _order if k in args]).encode('ascii')\n        args[\"Signature\"] = base64.b64encode(signer.sign(string))\n        string = urlencode(args)\n    else:\n        string = urlencode(args)\n\n    glue_char = \"&\" if urlparse(location).query else \"?\"\n    login_url = glue_char.join([location, string])\n    headers = [('Location', str(login_url))]\n    body = []\n\n    return {\"headers\": headers, \"data\": body}\n\n\nDUMMY_NAMESPACE = \"http://example.org/\"\nPREFIX = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n\n\ndef make_soap_enveloped_saml_thingy(thingy, header_parts=None):\n    \"\"\" Returns a soap envelope containing a SAML request\n    as a text string.\n\n    :param thingy: The SAML thingy\n    :return: The SOAP envelope as a string\n    \"\"\"\n    envelope = ElementTree.Element('')\n    envelope.tag = '{%s}Envelope' % NAMESPACE\n\n    if header_parts:\n        header = ElementTree.Element('')\n        header.tag = '{%s}Header' % NAMESPACE\n        envelope.append(header)\n        for part in header_parts:\n            # This doesn't work if the headers are signed\n            part.become_child_element_of(header)\n\n    body = ElementTree.Element('')\n    body.tag = '{%s}Body' % NAMESPACE\n    envelope.append(body)\n\n    if isinstance(thingy, six.string_types):\n        # remove the first XML version/encoding line\n        if thingy[0:5].lower() == '<?xml':\n            logger.debug(\"thingy0: %s\", thingy)\n            _part = thingy.split(\"\\n\")\n            thingy = \"\".join(_part[1:])\n        thingy = thingy.replace(PREFIX, \"\")\n        logger.debug(\"thingy: %s\", thingy)\n        _child = ElementTree.Element('')\n        _child.tag = '{%s}FuddleMuddle' % DUMMY_NAMESPACE\n        body.append(_child)\n        _str = ElementTree.tostring(envelope, encoding=\"UTF-8\")\n        if isinstance(_str, six.binary_type):\n            _str = _str.decode('utf-8')\n        logger.debug(\"SOAP precursor: %s\", _str)\n        # find an remove the namespace definition\n        i = _str.find(DUMMY_NAMESPACE)\n        j = _str.rfind(\"xmlns:\", 0, i)\n        cut1 = _str[j:i + len(DUMMY_NAMESPACE) + 1]\n        _str = _str.replace(cut1, \"\")\n        first = _str.find(\"<%s:FuddleMuddle\" % (cut1[6:9],))\n        last = _str.find(\">\", first + 14)\n        cut2 = _str[first:last + 1]\n        return _str.replace(cut2, thingy)\n    else:\n        thingy.become_child_element_of(body)\n        return ElementTree.tostring(envelope, encoding=\"UTF-8\")\n\n\ndef http_soap_message(message):\n    return {\"headers\": [(\"Content-type\", \"application/soap+xml\")],\n            \"data\": make_soap_enveloped_saml_thingy(message)}\n\n\ndef http_paos(message, extra=None):\n    return {\"headers\": [(\"Content-type\", \"application/soap+xml\")],\n            \"data\": make_soap_enveloped_saml_thingy(message, extra)}\n\n\ndef parse_soap_enveloped_saml(text, body_class, header_class=None):\n    \"\"\"Parses a SOAP enveloped SAML thing and returns header parts and body\n\n    :param text: The SOAP object as XML\n    :return: header parts and body as saml.samlbase instances\n    \"\"\"\n    envelope = defusedxml.ElementTree.fromstring(text)\n    assert envelope.tag == '{%s}Envelope' % NAMESPACE\n\n    # print(len(envelope))\n    body = None\n    header = {}\n    for part in envelope:\n        # print(\">\",part.tag)\n        if part.tag == '{%s}Body' % NAMESPACE:\n            for sub in part:\n                try:\n                    body = saml2.create_class_from_element_tree(body_class, sub)\n                except Exception:\n                    raise Exception(\n                        \"Wrong body type (%s) in SOAP envelope\" % sub.tag)\n        elif part.tag == '{%s}Header' % NAMESPACE:\n            if not header_class:\n                raise Exception(\"Header where I didn't expect one\")\n            # print(\"--- HEADER ---\")\n            for sub in part:\n                # print(\">>\",sub.tag)\n                for klass in header_class:\n                    # print(\"?{%s}%s\" % (klass.c_namespace,klass.c_tag))\n                    if sub.tag == \"{%s}%s\" % (klass.c_namespace, klass.c_tag):\n                        header[sub.tag] = \\\n                            saml2.create_class_from_element_tree(klass, sub)\n                        break\n\n    return body, header\n\n\n# -----------------------------------------------------------------------------\n\nPACKING = {\n    saml2.BINDING_HTTP_REDIRECT: http_redirect_message,\n    saml2.BINDING_HTTP_POST: http_form_post_message,\n}\n\n\ndef packager(identifier):\n    try:\n        return PACKING[identifier]\n    except KeyError:\n        raise Exception(\"Unknown binding type: %s\" % identifier)\n\n\ndef factory(binding, message, location, relay_state=\"\", typ=\"SAMLRequest\",\n            **kwargs):\n    return PACKING[binding](message, location, relay_state, typ, **kwargs)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n\n\"\"\"\nSuppport for the client part of the SAML2.0 SOAP binding.\n\"\"\"\nimport logging\n\nfrom saml2 import create_class_from_element_tree\nfrom saml2.samlp import NAMESPACE as SAMLP_NAMESPACE\nfrom saml2.schema import soapenv\n\ntry:\n    from xml.etree import cElementTree as ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        #noinspection PyUnresolvedReferences\n        from elementtree import ElementTree\nimport defusedxml.ElementTree\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass XmlParseError(Exception):\n    pass\n\n\nclass WrongMessageType(Exception):\n    pass\n\n\ndef parse_soap_enveloped_saml_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE,\n            '{%s}LogoutResponse' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_logout_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE,\n            '{%s}LogoutResponse' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_attribute_query(text):\n    expected_tag = '{%s}AttributeQuery' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_attribute_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE,\n            '{%s}AttributeResponse' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_logout_request(text):\n    expected_tag = '{%s}LogoutRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_authn_request(text):\n    expected_tag = '{%s}AuthnRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_artifact_resolve(text):\n    expected_tag = '{%s}ArtifactResolve' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_artifact_response(text):\n    expected_tag = '{%s}ArtifactResponse' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_name_id_mapping_request(text):\n    expected_tag = '{%s}NameIDMappingRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_name_id_mapping_response(text):\n    expected_tag = '{%s}NameIDMappingResponse' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_manage_name_id_request(text):\n    expected_tag = '{%s}ManageNameIDRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_manage_name_id_response(text):\n    expected_tag = '{%s}ManageNameIDResponse' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_assertion_id_request(text):\n    expected_tag = '{%s}AssertionIDRequest' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_assertion_id_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE,\n            '{%s}AssertionIDResponse' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_authn_query(text):\n    expected_tag = '{%s}AuthnQuery' % SAMLP_NAMESPACE\n    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\n\ndef parse_soap_enveloped_saml_authn_query_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\ndef parse_soap_enveloped_saml_authn_response(text):\n    tags = ['{%s}Response' % SAMLP_NAMESPACE]\n    return parse_soap_enveloped_saml_thingy(text, tags)\n\n\n#def parse_soap_enveloped_saml_logout_response(text):\n#    expected_tag = '{%s}LogoutResponse' % SAMLP_NAMESPACE\n#    return parse_soap_enveloped_saml_thingy(text, [expected_tag])\n\ndef parse_soap_enveloped_saml_thingy(text, expected_tags):\n    \"\"\"Parses a SOAP enveloped SAML thing and returns the thing as\n    a string.\n\n    :param text: The SOAP object as XML string\n    :param expected_tags: What the tag of the SAML thingy is expected to be.\n    :return: SAML thingy as a string\n    \"\"\"\n    envelope = defusedxml.ElementTree.fromstring(text)\n\n    # Make sure it's a SOAP message\n    assert envelope.tag == '{%s}Envelope' % soapenv.NAMESPACE\n\n    assert len(envelope) >= 1\n    body = None\n    for part in envelope:\n        if part.tag == '{%s}Body' % soapenv.NAMESPACE:\n            assert len(part) == 1\n            body = part\n            break\n\n    if body is None:\n        return \"\"\n\n    saml_part = body[0]\n    if saml_part.tag in expected_tags:\n        return ElementTree.tostring(saml_part, encoding=\"UTF-8\")\n    else:\n        raise WrongMessageType(\"Was '%s' expected one of %s\" % (saml_part.tag,\n                                                                expected_tags))\n\nimport re\n\nNS_AND_TAG = re.compile(\"\\{([^}]+)\\}(.*)\")\n\n\ndef instanciate_class(item, modules):\n    m = NS_AND_TAG.match(item.tag)\n    ns, tag = m.groups()\n    for module in modules:\n        if module.NAMESPACE == ns:\n            try:\n                target = module.ELEMENT_BY_TAG[tag]\n                return create_class_from_element_tree(target, item)\n            except KeyError:\n                continue\n    raise Exception(\"Unknown class: ns='%s', tag='%s'\" % (ns, tag))\n\n\ndef class_instances_from_soap_enveloped_saml_thingies(text, modules):\n    \"\"\"Parses a SOAP enveloped header and body SAML thing and returns the\n    thing as a dictionary class instance.\n\n    :param text: The SOAP object as XML\n    :param modules: modules representing xsd schemas\n    :return: The body and headers as class instances\n    \"\"\"\n    try:\n        envelope = defusedxml.ElementTree.fromstring(text)\n    except Exception as exc:\n        raise XmlParseError(\"%s\" % exc)\n\n    assert envelope.tag == '{%s}Envelope' % soapenv.NAMESPACE\n    assert len(envelope) >= 1\n    env = {\"header\": [], \"body\": None}\n\n    for part in envelope:\n        if part.tag == '{%s}Body' % soapenv.NAMESPACE:\n            assert len(part) == 1\n            env[\"body\"] = instanciate_class(part[0], modules)\n        elif part.tag == \"{%s}Header\" % soapenv.NAMESPACE:\n            for item in part:\n                env[\"header\"].append(instanciate_class(item, modules))\n\n    return env\n\n\ndef open_soap_envelope(text):\n    \"\"\"\n\n    :param text: SOAP message\n    :return: dictionary with two keys \"body\"/\"header\"\n    \"\"\"\n    try:\n        envelope = defusedxml.ElementTree.fromstring(text)\n    except Exception as exc:\n        raise XmlParseError(\"%s\" % exc)\n\n    assert envelope.tag == '{%s}Envelope' % soapenv.NAMESPACE\n    assert len(envelope) >= 1\n    content = {\"header\": [], \"body\": None}\n\n    for part in envelope:\n        if part.tag == '{%s}Body' % soapenv.NAMESPACE:\n            assert len(part) == 1\n            content[\"body\"] = ElementTree.tostring(part[0], encoding=\"UTF-8\")\n        elif part.tag == \"{%s}Header\" % soapenv.NAMESPACE:\n            for item in part:\n                _str = ElementTree.tostring(item, encoding=\"UTF-8\")\n                content[\"header\"].append(_str)\n\n    return content\n\n\ndef make_soap_enveloped_saml_thingy(thingy, headers=None):\n    \"\"\" Returns a soap envelope containing a SAML request\n    as a text string.\n\n    :param thingy: The SAML thingy\n    :return: The SOAP envelope as a string\n    \"\"\"\n    soap_envelope = soapenv.Envelope()\n\n    if headers:\n        _header = soapenv.Header()\n        _header.add_extension_elements(headers)\n        soap_envelope.header = _header\n\n    soap_envelope.body = soapenv.Body()\n    soap_envelope.body.add_extension_element(thingy)\n\n    return \"%s\" % soap_envelope\n\n\ndef soap_fault(message=None, actor=None, code=None, detail=None):\n    \"\"\" Create a SOAP Fault message\n\n    :param message: Human readable error message\n    :param actor: Who discovered the error\n    :param code: Error code\n    :param detail: More specific error message\n    :return: A SOAP Fault message as a string\n    \"\"\"\n    _string = _actor = _code = _detail = None\n\n    if message:\n        _string = soapenv.Fault_faultstring(text=message)\n    if actor:\n        _actor = soapenv.Fault_faultactor(text=actor)\n    if code:\n        _code = soapenv.Fault_faultcode(text=code)\n    if detail:\n        _detail = soapenv.Fault_detail(text=detail)\n\n    fault = soapenv.Fault(\n        faultcode=_code,\n        faultstring=_string,\n        faultactor=_actor,\n        detail=_detail,\n    )\n\n    return \"%s\" % fault\n", "#!/usr/bin/env python\n\nimport saml2\n\nfrom saml2 import create_class_from_xml_string, class_name, make_vals, md\nfrom saml2.saml import NameID, Issuer, SubjectLocality, AuthnContextClassRef\nfrom saml2.saml import SubjectConfirmationData, SubjectConfirmation\nfrom saml2.saml import Attribute\n\nfrom py.test import raises\nimport saml2_data\n\ntry:\n    from xml.etree import cElementTree as ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        from elementtree import ElementTree\nfrom defusedxml.common import EntitiesForbidden\n\nITEMS = {\n    NameID: [\"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<NameID xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n  Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n  SPProvidedID=\"sp provided id\">\n  roland@example.com\n</NameID>\n\"\"\", \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<NameID xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n  SPNameQualifier=\"https://foo.example.com/sp\" \n  Format=\"urn:oasis:names:tc:SAML:2.0:nameid-format:transient\">_1632879f09d08ea5ede2dc667cbed7e429ebc4335c</NameID>\n\"\"\", \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<NameID xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\nFormat=\"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\"\nNameQualifier=\"http://authentic.example.com/saml/metadata\"\nSPNameQualifier=\"http://auth.example.com/saml/metadata\">test\n</NameID>\"\"\"],\n    Issuer: \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Issuer xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\">\n  http://www.example.com/test\n</Issuer>\n\"\"\",\n    SubjectLocality: \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<SubjectLocality xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n  Address=\"127.0.0.1\" DNSName=\"localhost\"/>\n\"\"\",\n    SubjectConfirmationData:\n        \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<SubjectConfirmationData xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\nInResponseTo=\"_1683146e27983964fbe7bf8f08961108d166a652e5\" \nNotOnOrAfter=\"2010-02-18T13:52:13.959Z\" \nNotBefore=\"2010-01-16T12:00:00Z\" \nRecipient=\"http://192.168.0.10/saml/sp\" />\"\"\",\n    SubjectConfirmation:\n        \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<SubjectConfirmation xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\nMethod=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\"><NameID\nFormat=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\nNameQualifier=\"http://authentic.example.com/saml/metadata\">test@example.com\n</NameID>\n<SubjectConfirmationData\nNotOnOrAfter=\"2010-02-17T17:02:38Z\"\nRecipient=\"http://auth.example.com/saml/proxySingleSignOnRedirect\"\nInResponseTo=\"_59B3A01B03334032C31E434C63F89E3E\"/></SubjectConfirmation>\"\"\"\n}\n\n#def pytest_generate_tests(metafunc):\n#    if \"target_class\" in metafunc.funcargnames:\n#        for tcl,xml in ITEMS.items():\n#            metafunc.addcall(funcargs={\"target_class\":tcl,\"xml_string\":xml})\n\ndef _eq(l1, l2):\n    return set(l1) == set(l2)\n\n\ndef test_create_class_from_xml_string_nameid():\n    kl = create_class_from_xml_string(NameID, ITEMS[NameID][0])\n    assert kl != None\n    assert kl.format == \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n    assert kl.sp_provided_id == \"sp provided id\"\n    assert kl.text.strip() == \"roland@example.com\"\n    assert _eq(kl.keyswv(), ['sp_provided_id', 'format', 'text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:NameID\"\n    assert _eq(kl.keys(), ['sp_provided_id', 'sp_name_qualifier',\n                           'name_qualifier', 'format', 'text'])\n\n    kl = create_class_from_xml_string(NameID, ITEMS[NameID][1])\n    assert kl != None\n    assert kl.format == \"urn:oasis:names:tc:SAML:2.0:nameid-format:transient\"\n    assert kl.sp_name_qualifier == \"https://foo.example.com/sp\"\n    assert kl.text.strip() == \"_1632879f09d08ea5ede2dc667cbed7e429ebc4335c\"\n    assert _eq(kl.keyswv(), ['sp_name_qualifier', 'format', 'text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:NameID\"\n\n    kl = create_class_from_xml_string(NameID, ITEMS[NameID][2])\n    assert kl != None\n    assert kl.format == \"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\"\n    assert kl.name_qualifier == \"http://authentic.example.com/saml/metadata\"\n    assert kl.sp_name_qualifier == \"http://auth.example.com/saml/metadata\"\n    assert kl.text.strip() == \"test\"\n    assert _eq(kl.keyswv(), ['sp_name_qualifier', 'format', 'name_qualifier',\n                             'text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:NameID\"\n\n\ndef test_create_class_from_xml_string_issuer():\n    kl = create_class_from_xml_string(Issuer, ITEMS[Issuer])\n    assert kl != None\n    assert kl.text.strip() == \"http://www.example.com/test\"\n    assert _eq(kl.keyswv(), ['text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:Issuer\"\n\n\ndef test_create_class_from_xml_string_subject_locality():\n    kl = create_class_from_xml_string(SubjectLocality, ITEMS[SubjectLocality])\n    assert kl != None\n    assert _eq(kl.keyswv(), ['address', \"dns_name\"])\n    assert kl.address == \"127.0.0.1\"\n    assert kl.dns_name == \"localhost\"\n    assert class_name(\n        kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:SubjectLocality\"\n\n\ndef test_create_class_from_xml_string_subject_confirmation_data():\n    kl = create_class_from_xml_string(SubjectConfirmationData,\n                                      ITEMS[SubjectConfirmationData])\n    assert kl != None\n    assert _eq(kl.keyswv(), ['in_response_to', 'not_on_or_after',\n                             'not_before', 'recipient'])\n    assert kl.in_response_to == \"_1683146e27983964fbe7bf8f08961108d166a652e5\"\n    assert kl.not_on_or_after == \"2010-02-18T13:52:13.959Z\"\n    assert kl.not_before == \"2010-01-16T12:00:00Z\"\n    assert kl.recipient == \"http://192.168.0.10/saml/sp\"\n    assert class_name(kl) == \\\n           \"urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmationData\"\n\n\ndef test_create_class_from_xml_string_subject_confirmation():\n    kl = create_class_from_xml_string(SubjectConfirmation,\n                                      ITEMS[SubjectConfirmation])\n    assert kl != None\n    assert _eq(kl.keyswv(), ['method', 'name_id',\n                             'subject_confirmation_data'])\n    assert kl.method == \"urn:oasis:names:tc:SAML:2.0:cm:bearer\"\n    name_id = kl.name_id\n    assert _eq(name_id.keyswv(), ['format', 'name_qualifier', 'text'])\n    assert name_id.format == \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n    assert name_id.name_qualifier == \"http://authentic.example.com/saml/metadata\"\n    assert name_id.text.strip() == \"test@example.com\"\n    subject_confirmation_data = kl.subject_confirmation_data\n    assert _eq(subject_confirmation_data.keyswv(), ['not_on_or_after',\n                                                    'recipient',\n                                                    'in_response_to'])\n    assert subject_confirmation_data.recipient == \\\n           \"http://auth.example.com/saml/proxySingleSignOnRedirect\"\n    assert subject_confirmation_data.not_on_or_after == \"2010-02-17T17:02:38Z\"\n    assert subject_confirmation_data.in_response_to == \\\n           \"_59B3A01B03334032C31E434C63F89E3E\"\n    assert class_name(kl) == \\\n           \"urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmation\"\n\n\ndef test_create_class_from_xml_string_wrong_class_spec():\n    kl = create_class_from_xml_string(SubjectConfirmationData,\n                                      ITEMS[SubjectConfirmation])\n    assert kl == None\n\n\ndef test_create_class_from_xml_string_xxe():\n    xml = \"\"\"<?xml version=\"1.0\"?>\n    <!DOCTYPE lolz [\n    <!ENTITY lol \"lol\">\n    <!ELEMENT lolz (#PCDATA)>\n    <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">\n    ]>\n    <lolz>&lol1;</lolz>\n    \"\"\"\n    with raises(EntitiesForbidden) as err:\n        create_class_from_xml_string(NameID, xml)\n\n\ndef test_ee_1():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?><foo>bar</foo>\"\"\")\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == None\n    assert ee.children == []\n    assert ee.text == \"bar\"\n\n\ndef test_ee_2():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?><foo id=\"xyz\">bar</foo>\"\"\")\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {\"id\": \"xyz\"}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == None\n    assert ee.children == []\n    assert ee.text == \"bar\"\n\n\ndef test_ee_3():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <foo xmlns=\"urn:mace:example.com:saml:ns\" \n        id=\"xyz\">bar</foo>\"\"\")\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {\"id\": \"xyz\"}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == \"urn:mace:example.com:saml:ns\"\n    assert ee.children == []\n    assert ee.text == \"bar\"\n\n\ndef test_ee_4():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <foo xmlns=\"urn:mace:example.com:saml:ns\">\n        <id>xyz</id><bar>tre</bar></foo>\"\"\")\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == \"urn:mace:example.com:saml:ns\"\n    assert len(ee.children) == 2\n    assert ee.text.strip() == \"\"\n    cid = ee.find_children(\"id\", \"urn:mace:example.com:saml:namespace\")\n    assert cid == []\n    ids = ee.find_children(\"id\", \"urn:mace:example.com:saml:ns\")\n    assert ids != []\n    cid = ids[0]\n    print(cid.__dict__)\n    assert cid.attributes == {}\n    assert cid.tag == \"id\"\n    assert cid.namespace == \"urn:mace:example.com:saml:ns\"\n    assert cid.children == []\n    assert cid.text.strip() == \"xyz\"\n\n\ndef test_ee_5():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <foo xmlns=\"urn:mace:example.com:saml:ns\">bar</foo>\"\"\")\n\n    ce = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <educause xmlns=\"urn:mace:example.com:saml:cu\">rev</educause>\"\"\")\n\n    ee.children.append(ce)\n\n    assert ee != None\n    print(ee.__dict__)\n    assert ee.attributes == {}\n    assert ee.tag == \"foo\"\n    assert ee.namespace == \"urn:mace:example.com:saml:ns\"\n    assert len(ee.children) == 1\n    assert ee.text.strip() == \"bar\"\n\n    c = ee.children[0]\n    print(c.__dict__)\n\n    child = ee.find_children(namespace=\"urn:mace:example.com:saml:cu\")\n    assert len(child) == 1\n    child = ee.find_children(namespace=\"urn:mace:example.com:saml:ns\")\n    assert len(child) == 0\n    child = ee.find_children(\"educause\", \"urn:mace:example.com:saml:cu\")\n    assert len(child) == 1\n    child = ee.find_children(\"edugain\", \"urn:mace:example.com:saml:cu\")\n    assert len(child) == 0\n    print(ee.to_string())\n\n\ndef test_ee_6():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <foo xmlns=\"urn:mace:example.com:saml:ns\">bar</foo>\"\"\")\n\n    ce = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n        <educause xmlns=\"urn:mace:example.com:saml:cu\">rev</educause>\"\"\")\n\n    et = ee.transfer_to_element_tree()\n    ce.become_child_element_of(et)\n\n    pee = saml2._extension_element_from_element_tree(et)\n\n    assert pee != None\n    print(pee.__dict__)\n    assert pee.attributes == {}\n    assert pee.tag == \"foo\"\n    assert pee.namespace == \"urn:mace:example.com:saml:ns\"\n    assert len(pee.children) == 1\n    assert pee.text.strip() == \"bar\"\n\n    c = pee.children[0]\n    print(c.__dict__)\n\n    child = pee.find_children(namespace=\"urn:mace:example.com:saml:cu\")\n    assert len(child) == 1\n    child = pee.find_children(namespace=\"urn:mace:example.com:saml:ns\")\n    assert len(child) == 0\n    child = pee.find_children(\"educause\", \"urn:mace:example.com:saml:cu\")\n    assert len(child) == 1\n    child = pee.find_children(\"edugain\", \"urn:mace:example.com:saml:cu\")\n    assert len(child) == 0\n    print(pee.to_string())\n\n\nNAMEID_WITH_ATTRIBUTE_EXTENSION = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<NameID xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\n  xmlns:local=\"urn:mace:example.com:saml:assertion\"\n  Format=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n  SPProvidedID=\"sp provided id\"\n  local:Foo=\"BAR\">\n  roland@example.com\n</NameID>\n\"\"\"\n\n\ndef test_nameid_with_extension():\n    kl = create_class_from_xml_string(NameID, NAMEID_WITH_ATTRIBUTE_EXTENSION)\n    assert kl != None\n    print(kl.__dict__)\n    assert kl.format == \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n    assert kl.sp_provided_id == \"sp provided id\"\n    assert kl.text.strip() == \"roland@example.com\"\n    assert _eq(kl.keyswv(), ['sp_provided_id', 'format',\n                             'extension_attributes', 'text'])\n    assert class_name(kl) == \"urn:oasis:names:tc:SAML:2.0:assertion:NameID\"\n    assert _eq(kl.keys(), ['sp_provided_id', 'sp_name_qualifier',\n                           'name_qualifier', 'format', 'text'])\n    assert kl.extension_attributes == {\n        '{urn:mace:example.com:saml:assertion}Foo': 'BAR'}\n\n\nSUBJECT_CONFIRMATION_WITH_MEMBER_EXTENSION = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<SubjectConfirmation xmlns=\"urn:oasis:names:tc:SAML:2.0:assertion\"\nMethod=\"urn:oasis:names:tc:SAML:2.0:cm:bearer\">\n<NameID\nFormat=\"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\nNameQualifier=\"http://authentic.example.com/saml/metadata\">test@example.com\n</NameID>\n<SubjectConfirmationData\nNotOnOrAfter=\"2010-02-17T17:02:38Z\"\nRecipient=\"http://auth.example.com/saml/proxySingleSignOnRedirect\"\nInResponseTo=\"_59B3A01B03334032C31E434C63F89E3E\"/>\n<local:Trustlevel xmlns:local=\"urn:mace:example.com:saml:assertion\">\nExcellent\n</local:Trustlevel>\n</SubjectConfirmation>\"\"\"\n\n\ndef test_subject_confirmation_with_extension():\n    kl = create_class_from_xml_string(SubjectConfirmation,\n                                      SUBJECT_CONFIRMATION_WITH_MEMBER_EXTENSION)\n    assert kl != None\n    print(kl.__dict__)\n    assert kl.extension_attributes == {}\n    assert kl.method == \"urn:oasis:names:tc:SAML:2.0:cm:bearer\"\n    name_id = kl.name_id\n    assert _eq(name_id.keyswv(), ['format', 'name_qualifier', 'text'])\n    assert name_id.format == \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\"\n    assert name_id.name_qualifier == \"http://authentic.example.com/saml/metadata\"\n    assert name_id.text.strip() == \"test@example.com\"\n    subject_confirmation_data = kl.subject_confirmation_data\n    assert _eq(subject_confirmation_data.keyswv(), ['not_on_or_after',\n                                                    'recipient',\n                                                    'in_response_to'])\n    assert subject_confirmation_data.recipient == \\\n           \"http://auth.example.com/saml/proxySingleSignOnRedirect\"\n    assert subject_confirmation_data.not_on_or_after == \"2010-02-17T17:02:38Z\"\n    assert subject_confirmation_data.in_response_to == \\\n           \"_59B3A01B03334032C31E434C63F89E3E\"\n    assert len(kl.extension_elements) == 1\n    ee = kl.extension_elements[0]\n    assert ee.tag == \"Trustlevel\"\n    assert ee.namespace == \"urn:mace:example.com:saml:assertion\"\n    assert ee.text.strip() == \"Excellent\"\n\n\ndef test_to_fro_string_1():\n    kl = create_class_from_xml_string(SubjectConfirmation,\n                                      SUBJECT_CONFIRMATION_WITH_MEMBER_EXTENSION)\n    txt = kl.to_string()\n    cpy = create_class_from_xml_string(SubjectConfirmation, txt)\n\n    print(kl.__dict__)\n    print(cpy.__dict__)\n\n    assert kl.text.strip() == cpy.text.strip()\n    assert _eq(kl.keyswv(), cpy.keyswv())\n    assert len(kl.extension_elements) == len(cpy.extension_elements)\n    klee = kl.extension_elements[0]\n    cpyee = cpy.extension_elements[0]\n    assert klee.text.strip() == cpyee.text.strip()\n    assert klee.tag == cpyee.tag\n    assert klee.namespace == cpyee.namespace\n\n\ndef test_make_vals_str():\n    kl = make_vals(\"Jeter\", md.GivenName, part=True)\n    assert isinstance(kl, md.GivenName)\n    assert kl.text == \"Jeter\"\n\n\ndef test_make_vals_list_of_strs():\n    cp = md.ContactPerson()\n    make_vals([\"Derek\", \"Sanderson\"], md.GivenName, cp, \"given_name\")\n    assert len(cp.given_name) == 2\n    assert _eq([i.text for i in cp.given_name], [\"Sanderson\", \"Derek\"])\n\n\ndef test_attribute_element_to_extension_element():\n    attr = create_class_from_xml_string(Attribute, saml2_data.TEST_ATTRIBUTE)\n    ee = saml2.element_to_extension_element(attr)\n    print(ee.__dict__)\n    assert ee.tag == \"Attribute\"\n    assert ee.namespace == 'urn:oasis:names:tc:SAML:2.0:assertion'\n    assert _eq(ee.attributes.keys(), ['FriendlyName', 'Name', 'NameFormat'])\n    assert ee.attributes[\"FriendlyName\"] == 'test attribute'\n    assert ee.attributes[\"Name\"] == \"testAttribute\"\n    assert ee.attributes[\"NameFormat\"] == \\\n           'urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified'\n    assert len(ee.children) == 2\n    for child in ee.children:\n        # children are also extension element instances\n        assert child.namespace == 'urn:oasis:names:tc:SAML:2.0:assertion'\n        assert child.tag == \"AttributeValue\"\n\n\ndef test_ee_7():\n    ee = saml2.extension_element_from_string(\n        \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n   <ExternalEntityAttributeAuthority\n       xmlns=\"urn:oasis:names:tc:SAML:metadata:dynamicsaml\">\n       <AssertingEntity>\n           <NameID Format=\"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\">\n               http://federationX.org\n           </NameID>\n       </AssertingEntity>\n       <RetrievalEndpoint>\n           https://federationX.org/?ID=a87s76a5765da76576a57as\n       </RetrievalEndpoint>\n   </ExternalEntityAttributeAuthority>\n\"\"\")\n\n    print(ee.__dict__)\n    assert len(ee.children) == 2\n    for child in ee.children:\n        assert child.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert _eq([\"AssertingEntity\", \"RetrievalEndpoint\"],\n               [c.tag for c in ee.children])\n    aes = [c for c in ee.children if c.tag == \"AssertingEntity\"]\n    assert len(aes) == 1\n    assert len(aes[0].children) == 1\n    assert _eq(aes[0].attributes.keys(), [])\n    nid = aes[0].children[0]\n    assert nid.tag == \"NameID\"\n    assert nid.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert len(nid.children) == 0\n    assert _eq(nid.attributes.keys(), [\"Format\"])\n    assert nid.text.strip() == \"http://federationX.org\"\n\n\ndef test_ee_xxe():\n    xml = \"\"\"<?xml version=\"1.0\"?>\n    <!DOCTYPE lolz [\n    <!ENTITY lol \"lol\">\n    <!ELEMENT lolz (#PCDATA)>\n    <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">\n    ]>\n    <lolz>&lol1;</lolz>\n    \"\"\"\n    with raises(EntitiesForbidden):\n        saml2.extension_element_from_string(xml)\n\n\ndef test_extension_element_loadd():\n    ava = {'attributes': {},\n           'tag': 'ExternalEntityAttributeAuthority',\n           'namespace': 'urn:oasis:names:tc:SAML:metadata:dynamicsaml',\n           'children': [{\n                            \"tag\": \"AssertingEntity\",\n                            \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n\n                            \"children\": [{\n                                             \"tag\": \"NameID\",\n                                             \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n                                             \"text\": \"http://federationX.org\",\n                                             \"attributes\": {\n                                                 \"Format\": \"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\"\n                                             },\n                                         }]\n                        }, {\n                            \"tag\": \"RetrievalEndpoint\",\n                            \"namespace\": \"urn:oasis:names:tc:SAML:metadata\"\n                                         \":dynamicsaml\",\n                            \"text\": \"https://federationX.org/?ID=a87s76a5765da76576a57as\",\n                        }],\n    }\n\n    ee = saml2.ExtensionElement(ava[\"tag\"]).loadd(ava)\n    print(ee.__dict__)\n    assert len(ee.children) == 2\n    for child in ee.children:\n        assert child.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert _eq([\"AssertingEntity\", \"RetrievalEndpoint\"],\n               [c.tag for c in ee.children])\n    aes = [c for c in ee.children if c.tag == \"AssertingEntity\"]\n    assert len(aes) == 1\n    assert len(aes[0].children) == 1\n    assert _eq(aes[0].attributes.keys(), [])\n    nid = aes[0].children[0]\n    assert nid.tag == \"NameID\"\n    assert nid.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert len(nid.children) == 0\n    assert _eq(nid.attributes.keys(), [\"Format\"])\n    assert nid.text.strip() == \"http://federationX.org\"\n\n\ndef test_extensions_loadd():\n    ava = {\"extension_elements\": [\n        {\n            'attributes': {},\n            'tag': 'ExternalEntityAttributeAuthority',\n            'namespace': 'urn:oasis:names:tc:SAML:metadata:dynamicsaml',\n            'children': [\n                {\"tag\": \"AssertingEntity\",\n                 \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n                 \"children\": [\n                     {\"tag\": \"NameID\",\n                      \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n                      \"text\": \"http://federationX.org\",\n                      \"attributes\": {\n                          \"Format\": \"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\"\n                          },\n                      }]\n                },\n                {\n                    \"tag\": \"RetrievalEndpoint\",\n                    \"namespace\": \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\",\n                    \"text\": \"https://federationX.org/?ID=a87s76a5765da76576a57as\",\n                }],\n            }],\n           \"extension_attributes\": {\n               \"foo\": \"bar\",\n           }\n    }\n\n    extension = saml2.SamlBase()\n    extension.loadd(ava)\n\n    print(extension.__dict__)\n    assert len(extension.extension_elements) == 1\n    ee = extension.extension_elements[0]\n    assert len(ee.children) == 2\n    for child in ee.children:\n        assert child.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert _eq([\"AssertingEntity\", \"RetrievalEndpoint\"],\n               [c.tag for c in ee.children])\n    aes = [c for c in ee.children if c.tag == \"AssertingEntity\"]\n    assert len(aes) == 1\n    assert len(aes[0].children) == 1\n    assert _eq(aes[0].attributes.keys(), [])\n    nid = aes[0].children[0]\n    assert nid.tag == \"NameID\"\n    assert nid.namespace == \"urn:oasis:names:tc:SAML:metadata:dynamicsaml\"\n    assert len(nid.children) == 0\n    assert _eq(nid.attributes.keys(), [\"Format\"])\n    assert nid.text.strip() == \"http://federationX.org\"\n\n    assert list(extension.extension_attributes.keys()) == [\"foo\"]\n    assert extension.extension_attributes[\"foo\"] == \"bar\"\n", "#!/usr/bin/env python\n\ntry:\n    from xml.etree import cElementTree as ElementTree\n    if ElementTree.VERSION < '1.3.0':\n        # cElementTree has no support for register_namespace\n        # neither _namespace_map, thus we sacrify performance\n        # for correctness\n        from xml.etree import ElementTree\nexcept ImportError:\n    try:\n        import cElementTree as ElementTree\n    except ImportError:\n        from elementtree import ElementTree\nfrom defusedxml.common import EntitiesForbidden\n\nfrom pytest import raises\n\nimport saml2.samlp as samlp\nfrom saml2.samlp import NAMESPACE as SAMLP_NAMESPACE\nfrom saml2 import soap\n\nNAMESPACE = \"http://schemas.xmlsoap.org/soap/envelope/\"\n\nexample = \"\"\"<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\">\n    <Body>\n        <samlp:Response xmlns:samlp=\"urn:oasis:names:tc:SAML:2.0:protocol\" \n            xmlns:saml=\"urn:oasis:names:tc:SAML:2.0:assertion\" \n            ID=\"_6c3a4f8b9c2d\" Version=\"2.0\" IssueInstant=\"2004-03-27T08:42:00Z\">\n        <saml:Issuer>https://www.example.com/SAML</saml:Issuer>\n        <Status>\n        <StatusCode Value='urn:oasis:names:tc:SAML:2.0:status:Success'/>\n        </Status>\n        <saml:Assertion>\n        <saml:Subject></saml:Subject>\n        <saml:AttributeStatement></saml:AttributeStatement>\n        </saml:Assertion>\n        </samlp:Response>\n    </Body>\n</Envelope>\n\"\"\"\n\n\ndef test_parse_soap_envelope():\n    envelope = ElementTree.fromstring(example)\n    assert envelope.tag == '{%s}Envelope' % NAMESPACE\n    # How to check that it's the right type ?\n    assert len(envelope) == 1\n    body = envelope[0]\n    assert body.tag == '{%s}Body' % NAMESPACE\n    assert len(body) == 1\n    saml_part = body[0]\n    assert saml_part.tag == '{%s}Response' % SAMLP_NAMESPACE\n    # {http://schemas.xmlsoap.org/soap/envelope/}Envelope\n\n\ndef test_make_soap_envelope():\n    envelope = ElementTree.Element('')\n    envelope.tag = '{%s}Envelope' % NAMESPACE\n    body = ElementTree.Element('')\n    body.tag = '{%s}Body' % NAMESPACE\n    envelope.append(body)    \n    request = samlp.AuthnRequest()\n    request.become_child_element_of(body)\n\n    assert envelope.tag == '{%s}Envelope' % NAMESPACE\n    assert len(envelope) == 1\n    body = envelope[0]\n    assert body.tag == '{%s}Body' % NAMESPACE\n    assert len(body) == 1\n    saml_part = body[0]\n    assert saml_part.tag == '{%s}AuthnRequest' % SAMLP_NAMESPACE\n\n\ndef test_parse_soap_enveloped_saml_thingy_xxe():\n    xml = \"\"\"<?xml version=\"1.0\"?>\n    <!DOCTYPE lolz [\n    <!ENTITY lol \"lol\">\n    <!ELEMENT lolz (#PCDATA)>\n    <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">\n    ]>\n    <lolz>&lol1;</lolz>\n    \"\"\"\n    with raises(EntitiesForbidden):\n        soap.parse_soap_enveloped_saml_thingy(xml, None)\n\n\ndef test_class_instances_from_soap_enveloped_saml_thingies_xxe():\n    xml = \"\"\"<?xml version=\"1.0\"?>\n    <!DOCTYPE lolz [\n    <!ENTITY lol \"lol\">\n    <!ELEMENT lolz (#PCDATA)>\n    <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">\n    ]>\n    <lolz>&lol1;</lolz>\n    \"\"\"\n    with raises(soap.XmlParseError):\n        soap.class_instances_from_soap_enveloped_saml_thingies(xml, None)\n\n\ndef test_open_soap_envelope_xxe():\n    xml = \"\"\"<?xml version=\"1.0\"?>\n    <!DOCTYPE lolz [\n    <!ENTITY lol \"lol\">\n    <!ELEMENT lolz (#PCDATA)>\n    <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">\n    ]>\n    <lolz>&lol1;</lolz>\n    \"\"\"\n    with raises(soap.XmlParseError):\n        soap.open_soap_envelope(xml)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport base64\nimport uuid\nimport six\nfrom future.backports.urllib.parse import parse_qs\nfrom future.backports.urllib.parse import urlencode\nfrom future.backports.urllib.parse import urlparse\nfrom pytest import raises\n\nfrom saml2.argtree import add_path\nfrom saml2.cert import OpenSSLWrapper\nfrom saml2.xmldsig import SIG_RSA_SHA256\nfrom saml2 import BINDING_HTTP_POST\nfrom saml2 import BINDING_HTTP_REDIRECT\nfrom saml2 import config\nfrom saml2 import class_name\nfrom saml2 import extension_elements_to_elements\nfrom saml2 import saml\nfrom saml2 import samlp\nfrom saml2 import sigver\nfrom saml2 import s_utils\nfrom saml2.assertion import Assertion\n\nfrom saml2.authn_context import INTERNETPROTOCOLPASSWORD\nfrom saml2.client import Saml2Client\nfrom saml2.config import SPConfig\nfrom saml2.pack import parse_soap_enveloped_saml\nfrom saml2.response import LogoutResponse\nfrom saml2.saml import NAMEID_FORMAT_PERSISTENT, EncryptedAssertion, Advice\nfrom saml2.saml import NAMEID_FORMAT_TRANSIENT\nfrom saml2.saml import NameID\nfrom saml2.samlp import SessionIndex\nfrom saml2.server import Server\nfrom saml2.sigver import pre_encryption_part, make_temp, pre_encrypt_assertion\nfrom saml2.sigver import rm_xmltag\nfrom saml2.sigver import verify_redirect_signature\nfrom saml2.s_utils import do_attribute_statement\nfrom saml2.s_utils import factory\nfrom saml2.time_util import in_a_while, a_while_ago\n\nfrom defusedxml.common import EntitiesForbidden\n\nfrom fakeIDP import FakeIDP\nfrom fakeIDP import unpack_form\nfrom pathutils import full_path\n\nAUTHN = {\n    \"class_ref\": INTERNETPROTOCOLPASSWORD,\n    \"authn_auth\": \"http://www.example.com/login\"\n}\n\n\ndef generate_cert():\n    sn = uuid.uuid4().urn\n    cert_info = {\n        \"cn\": \"localhost\",\n        \"country_code\": \"se\",\n        \"state\": \"ac\",\n        \"city\": \"Umea\",\n        \"organization\": \"ITS\",\n        \"organization_unit\": \"DIRG\"\n    }\n    osw = OpenSSLWrapper()\n    ca_cert_str = osw.read_str_from_file(\n        full_path(\"root_cert/localhost.ca.crt\"))\n    ca_key_str = osw.read_str_from_file(\n        full_path(\"root_cert/localhost.ca.key\"))\n    req_cert_str, req_key_str = osw.create_certificate(cert_info, request=True,\n                                                       sn=sn, key_length=2048)\n    cert_str = osw.create_cert_signed_certificate(ca_cert_str, ca_key_str,\n                                                  req_cert_str)\n    return cert_str, req_key_str\n\n\ndef add_subelement(xmldoc, node_name, subelem):\n    s = xmldoc.find(node_name)\n    if s > 0:\n        x = xmldoc.rindex(\"<\", 0, s)\n        tag = xmldoc[x + 1:s - 1]\n        c = s + len(node_name)\n        spaces = \"\"\n        while xmldoc[c] == \" \":\n            spaces += \" \"\n            c += 1\n        # Sometimes we get an xml header, sometimes we don't.\n        subelem_str = str(subelem)\n        if subelem_str[0:5].lower() == '<?xml':\n            subelem_str = subelem_str.split(\"\\n\", 1)[1]\n        xmldoc = xmldoc.replace(\n            \"<%s:%s%s/>\" % (tag, node_name, spaces),\n            \"<%s:%s%s>%s</%s:%s>\" % (tag, node_name, spaces, subelem_str, tag,\n                                     node_name))\n\n    return xmldoc\n\n\ndef for_me(condition, me):\n    for restriction in condition.audience_restriction:\n        audience = restriction.audience\n        if audience.text.strip() == me:\n            return True\n\n\ndef ava(attribute_statement):\n    result = {}\n    for attribute in attribute_statement.attribute:\n        # Check name_format ??\n        name = attribute.name.strip()\n        result[name] = []\n        for value in attribute.attribute_value:\n            result[name].append(value.text.strip())\n    return result\n\n\ndef _leq(l1, l2):\n    return set(l1) == set(l2)\n\n\n# def test_parse_3():\n#     xml_response = open(XML_RESPONSE_FILE3).read()\n#     response = samlp.response_from_string(xml_response)\n#     client = Saml2Client({})\n#     (ava, name_id, real_uri) = \\\n#             client.do_response(response, \"xenosmilus.umdc.umu.se\")\n#     print(40*\"=\")\n#     print(ava)\n#     print(40*\",\")\n#     print(name_id)\n#     assert False\n\nREQ1 = {\"1.2.14\": \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n<ns0:AttributeQuery Destination=\"https://idp.example.com/idp/\" ID=\"id1\"\nIssueInstant=\"%s\" Version=\"2.0\" xmlns:ns0=\"urn:oasis:names:tc:SAML:2\n.0:protocol\"><ns1:Issuer Format=\"urn:oasis:names:tc:SAML:2\n.0:nameid-format:entity\" xmlns:ns1=\"urn:oasis:names:tc:SAML:2\n.0:assertion\">urn:mace:example.com:saml:roland:sp</ns1:Issuer><ns1:Subject\nxmlns:ns1=\"urn:oasis:names:tc:SAML:2.0:assertion\"><ns1:NameID\nFormat=\"urn:oasis:names:tc:SAML:2\n.0:nameid-format:persistent\">E8042FB4-4D5B-48C3-8E14-8EDD852790DD</ns1:NameID\n></ns1:Subject></ns0:AttributeQuery>\"\"\",\n        \"1.2.16\": \"\"\"<?xml version='1.0' encoding='UTF-8'?>\n<ns0:AttributeQuery xmlns:ns0=\"urn:oasis:names:tc:SAML:2.0:protocol\"\nxmlns:ns1=\"urn:oasis:names:tc:SAML:2.0:assertion\" Destination=\"https://idp\n.example.com/idp/\" ID=\"id1\" IssueInstant=\"%s\" Version=\"2.0\"><ns1:Issuer\nFormat=\"urn:oasis:names:tc:SAML:2.0:nameid-format:entity\">urn:mace:example\n.com:saml:roland:sp</ns1:Issuer><ns1:Subject><ns1:NameID\nFormat=\"urn:oasis:names:tc:SAML:2\n.0:nameid-format:persistent\">E8042FB4-4D5B-48C3-8E14-8EDD852790DD</ns1:NameID\n></ns1:Subject></ns0:AttributeQuery>\"\"\"}\n\nnid = NameID(name_qualifier=\"foo\", format=NAMEID_FORMAT_TRANSIENT,\n             text=\"123456\")\n\n\ndef list_values2simpletons(_dict):\n    return dict([(k, v[0]) for k, v in _dict.items()])\n\n\nclass TestClient:\n    def setup_class(self):\n        self.server = Server(\"idp_conf\")\n\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        self.client = Saml2Client(conf)\n\n    def teardown_class(self):\n        self.server.close()\n\n    def test_create_attribute_query1(self):\n        req_id, req = self.client.create_attribute_query(\n            \"https://idp.example.com/idp/\",\n            \"E8042FB4-4D5B-48C3-8E14-8EDD852790DD\",\n            format=saml.NAMEID_FORMAT_PERSISTENT,\n            message_id=\"id1\")\n        reqstr = \"%s\" % req.to_string().decode('utf-8')\n\n        assert req.destination == \"https://idp.example.com/idp/\"\n        assert req.id == \"id1\"\n        assert req.version == \"2.0\"\n        subject = req.subject\n        name_id = subject.name_id\n        assert name_id.format == saml.NAMEID_FORMAT_PERSISTENT\n        assert name_id.text == \"E8042FB4-4D5B-48C3-8E14-8EDD852790DD\"\n        issuer = req.issuer\n        assert issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n\n        attrq = samlp.attribute_query_from_string(reqstr)\n\n        print(attrq.keyswv())\n        assert _leq(attrq.keyswv(), ['destination', 'subject', 'issue_instant',\n                                     'version', 'id', 'issuer'])\n\n        assert attrq.destination == req.destination\n        assert attrq.id == req.id\n        assert attrq.version == req.version\n        assert attrq.issuer.text == issuer.text\n        assert attrq.issue_instant == req.issue_instant\n        assert attrq.subject.name_id.format == name_id.format\n        assert attrq.subject.name_id.text == name_id.text\n\n    def test_create_attribute_query2(self):\n        req_id, req = self.client.create_attribute_query(\n            \"https://idp.example.com/idp/\",\n            \"E8042FB4-4D5B-48C3-8E14-8EDD852790DD\",\n            attribute={\n                (\"urn:oid:2.5.4.42\",\n                 \"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\",\n                 \"givenName\"): None,\n                (\"urn:oid:2.5.4.4\",\n                 \"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\",\n                 \"surname\"): None,\n                (\"urn:oid:1.2.840.113549.1.9.1\",\n                 \"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\"): None,\n            },\n            format=saml.NAMEID_FORMAT_PERSISTENT,\n            message_id=\"id1\")\n\n        print(req.to_string())\n        assert req.destination == \"https://idp.example.com/idp/\"\n        assert req.id == \"id1\"\n        assert req.version == \"2.0\"\n        subject = req.subject\n        name_id = subject.name_id\n        assert name_id.format == saml.NAMEID_FORMAT_PERSISTENT\n        assert name_id.text == \"E8042FB4-4D5B-48C3-8E14-8EDD852790DD\"\n        assert len(req.attribute) == 3\n        # one is givenName\n        seen = []\n        for attribute in req.attribute:\n            if attribute.name == \"urn:oid:2.5.4.42\":\n                assert attribute.name_format == saml.NAME_FORMAT_URI\n                assert attribute.friendly_name == \"givenName\"\n                seen.append(\"givenName\")\n            elif attribute.name == \"urn:oid:2.5.4.4\":\n                assert attribute.name_format == saml.NAME_FORMAT_URI\n                assert attribute.friendly_name == \"surname\"\n                seen.append(\"surname\")\n            elif attribute.name == \"urn:oid:1.2.840.113549.1.9.1\":\n                assert attribute.name_format == saml.NAME_FORMAT_URI\n                if getattr(attribute, \"friendly_name\"):\n                    assert False\n                seen.append(\"email\")\n        assert _leq(seen, [\"givenName\", \"surname\", \"email\"])\n\n    def test_create_attribute_query_3(self):\n        req_id, req = self.client.create_attribute_query(\n            \"https://aai-demo-idp.switch.ch/idp/shibboleth\",\n            \"_e7b68a04488f715cda642fbdd90099f5\",\n            format=saml.NAMEID_FORMAT_TRANSIENT,\n            message_id=\"id1\")\n\n        assert isinstance(req, samlp.AttributeQuery)\n        assert req.destination == \"https://aai-demo-idp.switch\" \\\n                                  \".ch/idp/shibboleth\"\n        assert req.id == \"id1\"\n        assert req.version == \"2.0\"\n        assert req.issue_instant\n        assert req.issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n        nameid = req.subject.name_id\n        assert nameid.format == saml.NAMEID_FORMAT_TRANSIENT\n        assert nameid.text == \"_e7b68a04488f715cda642fbdd90099f5\"\n\n    def test_create_auth_request_0(self):\n        ar_str = \"%s\" % self.client.create_authn_request(\n            \"http://www.example.com/sso\", message_id=\"id1\")[1]\n\n        ar = samlp.authn_request_from_string(ar_str)\n        print(ar)\n        assert ar.assertion_consumer_service_url == (\"http://lingon.catalogix\"\n                                                     \".se:8087/\")\n        assert ar.destination == \"http://www.example.com/sso\"\n        assert ar.protocol_binding == BINDING_HTTP_POST\n        assert ar.version == \"2.0\"\n        assert ar.provider_name == \"urn:mace:example.com:saml:roland:sp\"\n        assert ar.issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n        nid_policy = ar.name_id_policy\n        assert nid_policy.allow_create == \"false\"\n        assert nid_policy.format == saml.NAMEID_FORMAT_TRANSIENT\n\n    def test_create_auth_request_vo(self):\n        assert list(self.client.config.vorg.keys()) == [\n            \"urn:mace:example.com:it:tek\"]\n\n        ar_str = \"%s\" % self.client.create_authn_request(\n            \"http://www.example.com/sso\",\n            \"urn:mace:example.com:it:tek\",  # vo\n            nameid_format=NAMEID_FORMAT_PERSISTENT,\n            message_id=\"666\")[1]\n\n        ar = samlp.authn_request_from_string(ar_str)\n        print(ar)\n        assert ar.id == \"666\"\n        assert ar.assertion_consumer_service_url == \"http://lingon.catalogix\" \\\n                                                    \".se:8087/\"\n        assert ar.destination == \"http://www.example.com/sso\"\n        assert ar.protocol_binding == BINDING_HTTP_POST\n        assert ar.version == \"2.0\"\n        assert ar.provider_name == \"urn:mace:example.com:saml:roland:sp\"\n        assert ar.issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n        nid_policy = ar.name_id_policy\n        assert nid_policy.allow_create == \"false\"\n        assert nid_policy.format == saml.NAMEID_FORMAT_PERSISTENT\n        assert nid_policy.sp_name_qualifier == \"urn:mace:example.com:it:tek\"\n\n    def test_sign_auth_request_0(self):\n        # print(self.client.config)\n\n        req_id, areq = self.client.create_authn_request(\n            \"http://www.example.com/sso\", sign=True, message_id=\"id1\")\n\n        ar_str = \"%s\" % areq\n        ar = samlp.authn_request_from_string(ar_str)\n\n        assert ar\n        assert ar.signature\n        assert ar.signature.signature_value\n        signed_info = ar.signature.signed_info\n        # print(signed_info)\n        assert len(signed_info.reference) == 1\n        assert signed_info.reference[0].uri == \"#id1\"\n        assert signed_info.reference[0].digest_value\n        print(\"------------------------------------------------\")\n        try:\n            assert self.client.sec.correctly_signed_authn_request(\n                ar_str, self.client.config.xmlsec_binary,\n                self.client.config.metadata)\n        except Exception:  # missing certificate\n            self.client.sec.verify_signature(ar_str, node_name=class_name(ar))\n\n    def test_create_logout_request(self):\n        req_id, req = self.client.create_logout_request(\n            \"http://localhost:8088/slo\", \"urn:mace:example.com:saml:roland:idp\",\n            name_id=nid, reason=\"Tired\", expire=in_a_while(minutes=15),\n            session_indexes=[\"_foo\"])\n\n        assert req.destination == \"http://localhost:8088/slo\"\n        assert req.reason == \"Tired\"\n        assert req.version == \"2.0\"\n        assert req.name_id == nid\n        assert req.issuer.text == \"urn:mace:example.com:saml:roland:sp\"\n        assert req.session_index == [SessionIndex(\"_foo\")]\n\n    def test_response_1(self):\n        IDP = \"urn:mace:example.com:saml:roland:idp\"\n\n        ava = {\"givenName\": [\"Derek\"], \"surName\": [\"Jeter\"],\n               \"mail\": [\"derek@nyy.mlb.com\"], \"title\": [\"The man\"]}\n\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id_policy=nameid_policy,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN)\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"})\n\n        assert authn_response is not None\n        assert authn_response.issuer() == IDP\n        assert authn_response.response.assertion[0].issuer.text == IDP\n        session_info = authn_response.session_info()\n\n        print(session_info)\n        assert session_info[\"ava\"] == {'mail': ['derek@nyy.mlb.com'],\n                                       'givenName': ['Derek'],\n                                       'sn': ['Jeter'],\n                                       'title': [\"The man\"]}\n        assert session_info[\"issuer\"] == IDP\n        assert session_info[\"came_from\"] == \"http://foo.example.com/service\"\n        response = samlp.response_from_string(authn_response.xmlstr)\n        assert response.destination == \"http://lingon.catalogix.se:8087/\"\n        assert \"session_index\" in session_info\n\n        # One person in the cache\n        assert len(self.client.users.subjects()) == 1\n        subject_id = self.client.users.subjects()[0]\n        print(\"||||\", self.client.users.get_info_from(subject_id, IDP))\n        # The information I have about the subject comes from one source\n        assert self.client.users.issuers_of_info(subject_id) == [IDP]\n\n        # --- authenticate another person\n\n        ava = {\"givenName\": [\"Alfonson\"], \"surName\": [\"Soriano\"],\n               \"mail\": [\"alfonson@chc.mlb.com\"], \"title\": [\"outfielder\"]}\n\n        resp_str = \"%s\" % self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id2\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id_policy=nameid_policy,\n            userid=\"also0001@example.com\",\n            authn=AUTHN)\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id2\": \"http://foo.example.com/service\"})\n\n        # Two persons in the cache\n        assert len(self.client.users.subjects()) == 2\n        issuers = [self.client.users.issuers_of_info(s) for s in\n                   self.client.users.subjects()]\n        # The information I have about the subjects comes from the same source\n        print(issuers)\n        assert issuers == [[IDP], [IDP]]\n\n    def test_response_2(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        cert_str, cert_key_str = generate_cert()\n\n        cert = \\\n            {\n                \"cert\": cert_str,\n                \"key\": cert_key_str\n            }\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=False,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n            encrypt_cert_advice=cert_str\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"}, {\"id1\": cert})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_3(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=False,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_4(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_5(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        cert_str, cert_key_str = generate_cert()\n\n        cert = \\\n            {\n                \"cert\": cert_str,\n                \"key\": cert_key_str\n            }\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n            encrypt_cert_assertion=cert_str\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"}, {\"id1\": cert})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_6(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        cert_assertion_str, cert_key_assertion_str = generate_cert()\n\n        cert_assertion = \\\n            {\n                \"cert\": cert_assertion_str,\n                \"key\": cert_key_assertion_str\n            }\n\n        cert_advice_str, cert_key_advice_str = generate_cert()\n\n        cert_advice = \\\n            {\n                \"cert\": cert_advice_str,\n                \"key\": cert_key_advice_str\n            }\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            pefim=True,\n            encrypt_cert_assertion=cert_assertion_str,\n            encrypt_cert_advice=cert_advice_str\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"},\n            {\"id1\": [cert_assertion, cert_advice]})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_7(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            encrypted_advice_attributes=True,\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def test_response_8(self):\n        conf = config.SPConfig()\n        conf.load_file(\"server_conf\")\n        _client = Saml2Client(conf)\n\n        idp, ava, ava_verify, nameid_policy = self.setup_verify_authn_response()\n\n        self.name_id = self.server.ident.transient_nameid(\n            \"urn:mace:example.com:saml:roland:sp\", \"id1\")\n\n        cert_str, cert_key_str = generate_cert()\n\n        cert = \\\n            {\n                \"cert\": cert_str,\n                \"key\": cert_key_str\n            }\n\n        resp = self.server.create_authn_response(\n            identity=ava,\n            in_response_to=\"id1\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            sp_entity_id=\"urn:mace:example.com:saml:roland:sp\",\n            name_id=self.name_id,\n            userid=\"foba0001@example.com\",\n            authn=AUTHN,\n            sign_response=True,\n            sign_assertion=True,\n            encrypt_assertion=True,\n            encrypt_assertion_self_contained=True,\n            encrypt_cert_assertion=cert_str\n        )\n\n        resp_str = \"%s\" % resp\n\n        resp_str = base64.encodestring(resp_str.encode('utf-8'))\n\n        authn_response = _client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"id1\": \"http://foo.example.com/service\"}, {\"id1\": cert})\n\n        self.verify_authn_response(idp, authn_response, _client, ava_verify)\n\n    def setup_verify_authn_response(self):\n        idp = \"urn:mace:example.com:saml:roland:idp\"\n        ava = {\"givenName\": [\"Derek\"], \"surName\": [\"Jeter\"],\n               \"mail\": [\"derek@nyy.mlb.com\"], \"title\": [\"The man\"]}\n        ava_verify = {'mail': ['derek@nyy.mlb.com'], 'givenName': ['Derek'],\n                      'sn': ['Jeter'], 'title': [\"The man\"]}\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n        return idp, ava, ava_verify, nameid_policy\n\n    def verify_authn_response(self, idp, authn_response, _client, ava_verify):\n        assert authn_response is not None\n        assert authn_response.issuer() == idp\n        assert authn_response.assertion.issuer.text == idp\n        session_info = authn_response.session_info()\n\n        assert session_info[\"ava\"] == ava_verify\n        assert session_info[\"issuer\"] == idp\n        assert session_info[\"came_from\"] == \"http://foo.example.com/service\"\n        response = samlp.response_from_string(authn_response.xmlstr)\n        assert response.destination == \"http://lingon.catalogix.se:8087/\"\n\n        # One person in the cache\n        assert len(_client.users.subjects()) == 1\n        subject_id = _client.users.subjects()[0]\n        # The information I have about the subject comes from one source\n        assert _client.users.issuers_of_info(subject_id) == [idp]\n\n    def test_init_values(self):\n        entityid = self.client.config.entityid\n        print(entityid)\n        assert entityid == \"urn:mace:example.com:saml:roland:sp\"\n        print(self.client.metadata.with_descriptor(\"idpsso\"))\n        location = self.client._sso_location()\n        print(location)\n        assert location == 'http://localhost:8088/sso'\n        my_name = self.client._my_name()\n        print(my_name)\n        assert my_name == \"urn:mace:example.com:saml:roland:sp\"\n\n    def test_sign_then_encrypt_assertion(self):\n        # Begin with the IdPs side\n        _sec = self.server.sec\n\n        assertion = s_utils.assertion_factory(\n            subject=factory(saml.Subject, text=\"_aaa\",\n                            name_id=factory(\n                                saml.NameID,\n                                format=saml.NAMEID_FORMAT_TRANSIENT)),\n            attribute_statement=do_attribute_statement(\n                {\n                    (\"\", \"\", \"surName\"): (\"Jeter\", \"\"),\n                    (\"\", \"\", \"givenName\"): (\"Derek\", \"\"),\n                }\n            ),\n            issuer=self.server._issuer(),\n        )\n\n        assertion.signature = sigver.pre_signature_part(\n            assertion.id, _sec.my_cert, 1)\n\n        sigass = _sec.sign_statement(assertion, class_name(assertion),\n                                     key_file=full_path(\"test.key\"),\n                                     node_id=assertion.id)\n        # Create an Assertion instance from the signed assertion\n        _ass = saml.assertion_from_string(sigass)\n\n        response = sigver.response_factory(\n            in_response_to=\"_012345\",\n            destination=\"https:#www.example.com\",\n            status=s_utils.success_status_factory(),\n            issuer=self.server._issuer(),\n            assertion=_ass\n        )\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    0][\"cert_file\"],\n                                                pre_encryption_part())\n\n        seresp = samlp.response_from_string(enctext)\n\n        # Now over to the client side\n        _csec = self.client.sec\n        if seresp.encrypted_assertion:\n            decr_text = _csec.decrypt(enctext)\n            seresp = samlp.response_from_string(decr_text)\n            resp_ass = []\n\n            sign_cert_file = full_path(\"test.pem\")\n            for enc_ass in seresp.encrypted_assertion:\n                assers = extension_elements_to_elements(\n                    enc_ass.extension_elements, [saml, samlp])\n                for ass in assers:\n                    if ass.signature:\n                        if not _csec.verify_signature(\"%s\" % ass,\n                                                      sign_cert_file,\n                                                      node_name=class_name(\n                                                          ass)):\n                            continue\n                    resp_ass.append(ass)\n\n            seresp.assertion = resp_ass\n            seresp.encrypted_assertion = None\n            # print(_sresp)\n\n        assert seresp.assertion\n\n    def test_sign_then_encrypt_assertion2(self):\n        # Begin with the IdPs side\n        _sec = self.server.sec\n\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n\n        asser = Assertion({\"givenName\": \"Derek\", \"surName\": \"Jeter\"})\n        farg = add_path(\n            {},\n            ['assertion', 'subject', 'subject_confirmation', 'method',\n             saml.SCM_BEARER])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'in_response_to',\n             '_012345'])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'recipient',\n             \"http://lingon.catalogix.se:8087/\"])\n\n        assertion = asser.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            name_id=factory(saml.NameID, format=saml.NAMEID_FORMAT_TRANSIENT),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            farg=farg['assertion']\n        )\n\n        assertion.signature = sigver.pre_signature_part(\n            assertion.id, _sec.my_cert, 1)\n\n        sigass = _sec.sign_statement(assertion, class_name(assertion),\n                                     key_file=self.client.sec.key_file,\n                                     node_id=assertion.id)\n\n        sigass = rm_xmltag(sigass)\n\n        response = sigver.response_factory(\n            in_response_to=\"_012345\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            status=s_utils.success_status_factory(),\n            issuer=self.server._issuer(),\n            encrypted_assertion=EncryptedAssertion()\n        )\n\n        xmldoc = \"%s\" % response\n        # strangely enough I get different tags if I run this test separately\n        # or as part of a bunch of tests.\n        xmldoc = add_subelement(xmldoc, \"EncryptedAssertion\", sigass)\n\n        enctext = _sec.crypto.encrypt_assertion(xmldoc,\n                                                self.client.sec.encryption_keypairs[\n                                                    1][\"cert_file\"],\n                                                pre_encryption_part())\n\n        # seresp = samlp.response_from_string(enctext)\n\n        resp_str = base64.encodestring(enctext.encode('utf-8'))\n        # Now over to the client side\n        resp = self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"_012345\": \"http://foo.example.com/service\"})\n\n        # assert resp.encrypted_assertion == []\n        assert resp.assertion\n        assert resp.ava == {'givenName': ['Derek'], 'sn': ['Jeter']}\n\n    def test_sign_then_encrypt_assertion_advice_1(self):\n        # Begin with the IdPs side\n        _sec = self.server.sec\n\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n\n        asser = Assertion({\"givenName\": \"Derek\", \"surName\": \"Jeter\"})\n\n        subject_confirmation_specs = {\n            'recipient': \"http://lingon.catalogix.se:8087/\",\n            'in_response_to': \"_012345\",\n            'subject_confirmation_method': saml.SCM_BEARER\n        }\n        name_id = factory(saml.NameID, format=saml.NAMEID_FORMAT_TRANSIENT)\n\n        farg = add_path(\n            {},\n            ['assertion', 'subject', 'subject_confirmation', 'method',\n             saml.SCM_BEARER])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'in_response_to',\n             '_012345'])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'recipient',\n             \"http://lingon.catalogix.se:8087/\"])\n\n        assertion = asser.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            name_id=name_id,\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            farg=farg['assertion'])\n\n        a_asser = Assertion({\"uid\": \"test01\", \"email\": \"test.testsson@test.se\"})\n        a_assertion = a_asser.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_assertion.signature = sigver.pre_signature_part(\n            a_assertion.id, _sec.my_cert, 1)\n\n        assertion.advice = Advice()\n\n        assertion.advice.encrypted_assertion = []\n        assertion.advice.encrypted_assertion.append(EncryptedAssertion())\n\n        assertion.advice.encrypted_assertion[0].add_extension_element(\n            a_assertion)\n\n        response = sigver.response_factory(\n            in_response_to=\"_012345\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            status=s_utils.success_status_factory(),\n            issuer=self.server._issuer()\n        )\n\n        response.assertion.append(assertion)\n\n        response = _sec.sign_statement(\"%s\" % response, class_name(a_assertion),\n                                       key_file=self.client.sec.key_file,\n                                       node_id=a_assertion.id)\n\n        # xmldoc = \"%s\" % response\n        # strangely enough I get different tags if I run this test separately\n        # or as part of a bunch of tests.\n        # xmldoc = add_subelement(xmldoc, \"EncryptedAssertion\", sigass)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    0][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        # seresp = samlp.response_from_string(enctext)\n\n        resp_str = base64.encodestring(enctext.encode('utf-8'))\n        # Now over to the client side\n        resp = self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"_012345\": \"http://foo.example.com/service\"})\n\n        # assert resp.encrypted_assertion == []\n        assert resp.assertion\n        assert resp.assertion.advice\n        assert resp.assertion.advice.assertion\n        assert resp.ava == \\\n               {'sn': ['Jeter'], 'givenName': ['Derek'], 'uid': ['test01'],\n                'email': ['test.testsson@test.se']}\n\n    def test_sign_then_encrypt_assertion_advice_2(self):\n        # Begin with the IdPs side\n        _sec = self.server.sec\n\n        nameid_policy = samlp.NameIDPolicy(allow_create=\"false\",\n                                           format=saml.NAMEID_FORMAT_PERSISTENT)\n\n        asser_1 = Assertion({\"givenName\": \"Derek\"})\n\n        farg = add_path(\n            {},\n            ['assertion', 'subject', 'subject_confirmation', 'method',\n             saml.SCM_BEARER])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'in_response_to',\n             '_012345'])\n        add_path(\n            farg['assertion']['subject']['subject_confirmation'],\n            ['subject_confirmation_data', 'recipient',\n             \"http://lingon.catalogix.se:8087/\"])\n        name_id = factory(saml.NameID, format=saml.NAMEID_FORMAT_TRANSIENT)\n\n        assertion_1 = asser_1.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        asser_2 = Assertion({\"surName\": \"Jeter\"})\n\n        assertion_2 = asser_2.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_asser_1 = Assertion({\"uid\": \"test01\"})\n        a_assertion_1 = a_asser_1.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_asser_2 = Assertion({\"email\": \"test.testsson@test.se\"})\n        a_assertion_2 = a_asser_2.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_asser_3 = Assertion({\"street\": \"street\"})\n        a_assertion_3 = a_asser_3.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_asser_4 = Assertion({\"title\": \"title\"})\n        a_assertion_4 = a_asser_4.construct(\n            self.client.config.entityid,\n            self.server.config.attribute_converters,\n            self.server.config.getattr(\"policy\", \"idp\"),\n            issuer=self.server._issuer(),\n            authn_class=INTERNETPROTOCOLPASSWORD,\n            authn_auth=\"http://www.example.com/login\",\n            name_id=name_id,\n            farg=farg['assertion'])\n\n        a_assertion_1.signature = sigver.pre_signature_part(\n            a_assertion_1.id, _sec.my_cert, 1)\n\n        a_assertion_2.signature = sigver.pre_signature_part(\n            a_assertion_2.id, _sec.my_cert, 1)\n\n        a_assertion_3.signature = sigver.pre_signature_part(\n            a_assertion_3.id, _sec.my_cert, 1)\n\n        a_assertion_4.signature = sigver.pre_signature_part(\n            a_assertion_4.id, _sec.my_cert, 1)\n\n        assertion_1.signature = sigver.pre_signature_part(assertion_1.id,\n                                                          _sec.my_cert, 1)\n\n        assertion_2.signature = sigver.pre_signature_part(assertion_2.id,\n                                                          _sec.my_cert, 1)\n\n        response = sigver.response_factory(\n            in_response_to=\"_012345\",\n            destination=\"http://lingon.catalogix.se:8087/\",\n            status=s_utils.success_status_factory(),\n            issuer=self.server._issuer()\n        )\n\n        response.assertion = assertion_1\n\n        response.assertion.advice = Advice()\n\n        response.assertion.advice.encrypted_assertion = []\n        response.assertion.advice.encrypted_assertion.append(\n            EncryptedAssertion())\n\n        response.assertion.advice.encrypted_assertion[0].add_extension_element(\n            a_assertion_1)\n\n        advice_tag = response.assertion.advice._to_element_tree().tag\n        assertion_tag = a_assertion_1._to_element_tree().tag\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n                assertion_tag, advice_tag)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(a_assertion_1),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=a_assertion_1.id)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    1][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        response = samlp.response_from_string(enctext)\n\n        response.assertion = response.assertion[0]\n\n        response.assertion.advice.encrypted_assertion.append(\n            EncryptedAssertion())\n        response.assertion.advice.encrypted_assertion[1].add_extension_element(\n            a_assertion_2)\n\n        advice_tag = response.assertion.advice._to_element_tree().tag\n        assertion_tag = a_assertion_2._to_element_tree().tag\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n                assertion_tag, advice_tag)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(a_assertion_2),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=a_assertion_2.id)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    0][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        response = samlp.response_from_string(enctext)\n\n        response.assertion = response.assertion[0]\n\n        assertion_tag = response.assertion._to_element_tree().tag\n        response = pre_encrypt_assertion(response)\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_encrypted_assertion(\n            assertion_tag)\n\n        response = _sec.sign_statement(\"%s\" % response, class_name(assertion_1),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=assertion_1.id)\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    1][\"cert_file\"],\n                                                pre_encryption_part())\n\n        response = samlp.response_from_string(enctext)\n\n        response.assertion = assertion_2\n\n        response.assertion.advice = Advice()\n\n        response.assertion.advice.encrypted_assertion = []\n        response.assertion.advice.encrypted_assertion.append(\n            EncryptedAssertion())\n\n        response.assertion.advice.encrypted_assertion[0].add_extension_element(\n            a_assertion_3)\n\n        advice_tag = response.assertion.advice._to_element_tree().tag\n        assertion_tag = a_assertion_3._to_element_tree().tag\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n                assertion_tag, advice_tag)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(a_assertion_3),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=a_assertion_3.id)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    0][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        response = samlp.response_from_string(enctext)\n\n        response.assertion = response.assertion[0]\n\n        response.assertion.advice.encrypted_assertion.append(\n            EncryptedAssertion())\n\n        response.assertion.advice.encrypted_assertion[1].add_extension_element(\n            a_assertion_4)\n\n        advice_tag = response.assertion.advice._to_element_tree().tag\n        assertion_tag = a_assertion_4._to_element_tree().tag\n        response = \\\n            response.get_xml_string_with_self_contained_assertion_within_advice_encrypted_assertion(\n                assertion_tag, advice_tag)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(a_assertion_4),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=a_assertion_4.id)\n\n        node_xpath = ''.join([\"/*[local-name()=\\\"%s\\\"]\" % v for v in\n                              [\"Response\", \"Assertion\", \"Advice\",\n                               \"EncryptedAssertion\", \"Assertion\"]])\n\n        enctext = _sec.crypto.encrypt_assertion(response,\n                                                self.client.sec.encryption_keypairs[\n                                                    1][\"cert_file\"],\n                                                pre_encryption_part(),\n                                                node_xpath=node_xpath)\n\n        response = samlp.response_from_string(enctext)\n\n        response = _sec.sign_statement(\"%s\" % response,\n                                       class_name(response.assertion[0]),\n                                       key_file=self.server.sec.key_file,\n                                       node_id=response.assertion[0].id)\n\n        response = samlp.response_from_string(response)\n\n        # seresp = samlp.response_from_string(enctext)\n\n        resp_str = base64.encodestring(str(response).encode('utf-8'))\n        # Now over to the client side\n        resp = self.client.parse_authn_request_response(\n            resp_str, BINDING_HTTP_POST,\n            {\"_012345\": \"http://foo.example.com/service\"})\n\n        # assert resp.encrypted_assertion == []\n        assert resp.assertion\n        assert resp.assertion.advice\n        assert resp.assertion.advice.assertion\n        assert resp.ava == \\\n               {'street': ['street'], 'uid': ['test01'], 'title': ['title'],\n                'givenName': ['Derek'], 'email':\n                    ['test.testsson@test.se'], 'sn': ['Jeter']}\n\n    def test_signed_redirect(self):\n\n        msg_str = \"%s\" % self.client.create_authn_request(\n            \"http://localhost:8088/sso\", message_id=\"id1\")[1]\n\n        info = self.client.apply_binding(\n            BINDING_HTTP_REDIRECT, msg_str, destination=\"\",\n            relay_state=\"relay2\", sigalg=SIG_RSA_SHA256)\n\n        loc = info[\"headers\"][0][1]\n        qs = parse_qs(loc[1:])\n        assert _leq(qs.keys(),\n                    ['SigAlg', 'SAMLRequest', 'RelayState', 'Signature'])\n\n        assert verify_redirect_signature(list_values2simpletons(qs),\n                                         self.client.sec.sec_backend)\n\n        res = self.server.parse_authn_request(qs[\"SAMLRequest\"][0],\n                                              BINDING_HTTP_REDIRECT)\n        print(res)\n\n    def test_do_logout_signed_redirect(self):\n        conf = config.SPConfig()\n        conf.load_file(\"sp_slo_redirect_conf\")\n        client = Saml2Client(conf)\n\n        # information about the user from an IdP\n        session_info = {\n            \"name_id\": nid,\n            \"issuer\": \"urn:mace:example.com:saml:roland:idp\",\n            \"not_on_or_after\": in_a_while(minutes=15),\n            \"ava\": {\n                \"givenName\": \"Anders\",\n                \"surName\": \"Andersson\",\n                \"mail\": \"anders.andersson@example.com\"\n            }\n        }\n        client.users.add_information_about_person(session_info)\n        entity_ids = client.users.issuers_of_info(nid)\n        assert entity_ids == [\"urn:mace:example.com:saml:roland:idp\"]\n\n        resp = client.do_logout(nid, entity_ids, \"Tired\", in_a_while(minutes=5),\n                                sign=True,\n                                expected_binding=BINDING_HTTP_REDIRECT)\n\n        assert list(resp.keys()) == entity_ids\n        binding, info = resp[entity_ids[0]]\n        assert binding == BINDING_HTTP_REDIRECT\n\n        loc = info[\"headers\"][0][1]\n        _, _, _, _, qs, _ = urlparse(loc)\n        qs = parse_qs(qs)\n        assert _leq(qs.keys(),\n                    ['SigAlg', 'SAMLRequest', 'RelayState', 'Signature'])\n\n        assert verify_redirect_signature(list_values2simpletons(qs),\n                                         client.sec.sec_backend)\n\n        res = self.server.parse_logout_request(qs[\"SAMLRequest\"][0],\n                                               BINDING_HTTP_REDIRECT)\n        print(res)\n\n    def test_do_logout_post(self):\n        # information about the user from an IdP\n        session_info = {\n            \"name_id\": nid,\n            \"issuer\": \"urn:mace:example.com:saml:roland:idp\",\n            \"not_on_or_after\": in_a_while(minutes=15),\n            \"ava\": {\n                \"givenName\": \"Anders\",\n                \"surName\": \"Andersson\",\n                \"mail\": \"anders.andersson@example.com\"\n            },\n            \"session_index\": SessionIndex(\"_foo\")\n        }\n        self.client.users.add_information_about_person(session_info)\n        entity_ids = self.client.users.issuers_of_info(nid)\n        assert entity_ids == [\"urn:mace:example.com:saml:roland:idp\"]\n        resp = self.client.do_logout(nid, entity_ids, \"Tired\",\n                                     in_a_while(minutes=5), sign=True,\n                                     expected_binding=BINDING_HTTP_POST)\n        assert resp\n        assert len(resp) == 1\n        assert list(resp.keys()) == entity_ids\n        binding, info = resp[entity_ids[0]]\n        assert binding == BINDING_HTTP_POST\n\n        _dic = unpack_form(info[\"data\"][3])\n        res = self.server.parse_logout_request(_dic[\"SAMLRequest\"],\n                                               BINDING_HTTP_POST)\n        assert b'<ns0:SessionIndex>_foo</ns0:SessionIndex>' in res.xmlstr\n\n    def test_do_logout_session_expired(self):\n        # information about the user from an IdP\n        session_info = {\n            \"name_id\": nid,\n            \"issuer\": \"urn:mace:example.com:saml:roland:idp\",\n            \"not_on_or_after\": a_while_ago(minutes=15),\n            \"ava\": {\n                \"givenName\": \"Anders\",\n                \"surName\": \"Andersson\",\n                \"mail\": \"anders.andersson@example.com\"\n            },\n            \"session_index\": SessionIndex(\"_foo\")\n        }\n        self.client.users.add_information_about_person(session_info)\n        entity_ids = self.client.users.issuers_of_info(nid)\n        assert entity_ids == [\"urn:mace:example.com:saml:roland:idp\"]\n        resp = self.client.do_logout(nid, entity_ids, \"Tired\",\n                                     in_a_while(minutes=5), sign=True,\n                                     expected_binding=BINDING_HTTP_POST)\n        assert resp\n        assert len(resp) == 1\n        assert list(resp.keys()) == entity_ids\n        binding, info = resp[entity_ids[0]]\n        assert binding == BINDING_HTTP_POST\n\n        _dic = unpack_form(info[\"data\"][3])\n        res = self.server.parse_logout_request(_dic[\"SAMLRequest\"],\n                                               BINDING_HTTP_POST)\n        assert b'<ns0:SessionIndex>_foo</ns0:SessionIndex>' in res.xmlstr\n\n\n# Below can only be done with dummy Server\nIDP = \"urn:mace:example.com:saml:roland:idp\"\n\n\nclass TestClientWithDummy():\n    def setup_class(self):\n        self.server = FakeIDP(\"idp_all_conf\")\n\n        conf = SPConfig()\n        conf.load_file(\"servera_conf\")\n        self.client = Saml2Client(conf)\n\n        self.client.send = self.server.receive\n\n    def test_do_authn(self):\n        binding = BINDING_HTTP_REDIRECT\n        response_binding = BINDING_HTTP_POST\n        sid, http_args = self.client.prepare_for_authenticate(\n            IDP, \"http://www.example.com/relay_state\",\n            binding=binding, response_binding=response_binding)\n\n        assert isinstance(sid, six.string_types)\n        assert len(http_args) == 4\n        assert http_args[\"headers\"][0][0] == \"Location\"\n        assert http_args[\"data\"] == []\n        redirect_url = http_args[\"headers\"][0][1]\n        _, _, _, _, qs, _ = urlparse(redirect_url)\n        qs_dict = parse_qs(qs)\n        req = self.server.parse_authn_request(qs_dict[\"SAMLRequest\"][0],\n                                              binding)\n        resp_args = self.server.response_args(req.message, [response_binding])\n        assert resp_args[\"binding\"] == response_binding\n\n    def test_do_negotiated_authn(self):\n        binding = BINDING_HTTP_REDIRECT\n        response_binding = BINDING_HTTP_POST\n        sid, auth_binding, http_args = \\\n            self.client.prepare_for_negotiated_authenticate(\n            IDP, \"http://www.example.com/relay_state\",\n            binding=binding, response_binding=response_binding)\n\n        assert binding == auth_binding\n        assert isinstance(sid, six.string_types)\n        assert len(http_args) == 4\n        assert http_args[\"headers\"][0][0] == \"Location\"\n        assert http_args[\"data\"] == []\n        redirect_url = http_args[\"headers\"][0][1]\n        _, _, _, _, qs, _ = urlparse(redirect_url)\n        qs_dict = parse_qs(qs)\n        req = self.server.parse_authn_request(qs_dict[\"SAMLRequest\"][0],\n                                              binding)\n        resp_args = self.server.response_args(req.message, [response_binding])\n        assert resp_args[\"binding\"] == response_binding\n\n    def test_do_attribute_query(self):\n        response = self.client.do_attribute_query(\n            IDP, \"_e7b68a04488f715cda642fbdd90099f5\",\n            attribute={\"eduPersonAffiliation\": None},\n            nameid_format=NAMEID_FORMAT_TRANSIENT)\n\n    def test_logout_1(self):\n        \"\"\" one IdP/AA logout from\"\"\"\n\n        # information about the user from an IdP\n        session_info = {\n            \"name_id\": nid,\n            \"issuer\": \"urn:mace:example.com:saml:roland:idp\",\n            \"not_on_or_after\": in_a_while(minutes=15),\n            \"ava\": {\n                \"givenName\": \"Anders\",\n                \"surName\": \"Andersson\",\n                \"mail\": \"anders.andersson@example.com\"\n            }\n        }\n        self.client.users.add_information_about_person(session_info)\n        entity_ids = self.client.users.issuers_of_info(nid)\n        assert entity_ids == [\"urn:mace:example.com:saml:roland:idp\"]\n        resp = self.client.global_logout(nid, \"Tired\", in_a_while(minutes=5))\n        print(resp)\n        assert resp\n        assert len(resp) == 1\n        assert list(resp.keys()) == entity_ids\n        response = resp[entity_ids[0]]\n        assert isinstance(response, LogoutResponse)\n\n    def test_post_sso(self):\n        binding = BINDING_HTTP_POST\n        response_binding = BINDING_HTTP_POST\n        sid, http_args = self.client.prepare_for_authenticate(\n            \"urn:mace:example.com:saml:roland:idp\", relay_state=\"really\",\n            binding=binding, response_binding=response_binding)\n        _dic = unpack_form(http_args[\"data\"][3])\n\n        req = self.server.parse_authn_request(_dic[\"SAMLRequest\"], binding)\n        resp_args = self.server.response_args(req.message, [response_binding])\n        assert resp_args[\"binding\"] == response_binding\n\n        # Normally a response would now be sent back to the users web client\n        # Here I fake what the client will do\n        # create the form post\n\n        http_args[\"data\"] = urlencode(_dic)\n        http_args[\"method\"] = \"POST\"\n        http_args[\"dummy\"] = _dic[\"SAMLRequest\"]\n        http_args[\"headers\"] = [('Content-type',\n                                 'application/x-www-form-urlencoded')]\n\n        response = self.client.send(**http_args)\n        print(response.text)\n        _dic = unpack_form(response.text[3], \"SAMLResponse\")\n        resp = self.client.parse_authn_request_response(_dic[\"SAMLResponse\"],\n                                                        BINDING_HTTP_POST,\n                                                        {sid: \"/\"})\n        ac = resp.assertion.authn_statement[0].authn_context\n        assert ac.authenticating_authority[0].text == \\\n               'http://www.example.com/login'\n        assert ac.authn_context_class_ref.text == INTERNETPROTOCOLPASSWORD\n\n    def test_negotiated_post_sso(self):\n        binding = BINDING_HTTP_POST\n        response_binding = BINDING_HTTP_POST\n        sid, auth_binding, http_args = self.client.prepare_for_negotiated_authenticate(\n            \"urn:mace:example.com:saml:roland:idp\", relay_state=\"really\",\n            binding=binding, response_binding=response_binding)\n        _dic = unpack_form(http_args[\"data\"][3])\n\n        assert binding == auth_binding\n\n        req = self.server.parse_authn_request(_dic[\"SAMLRequest\"], binding)\n        resp_args = self.server.response_args(req.message, [response_binding])\n        assert resp_args[\"binding\"] == response_binding\n\n        # Normally a response would now be sent back to the users web client\n        # Here I fake what the client will do\n        # create the form post\n\n        http_args[\"data\"] = urlencode(_dic)\n        http_args[\"method\"] = \"POST\"\n        http_args[\"dummy\"] = _dic[\"SAMLRequest\"]\n        http_args[\"headers\"] = [('Content-type',\n                                 'application/x-www-form-urlencoded')]\n\n        response = self.client.send(**http_args)\n        print(response.text)\n        _dic = unpack_form(response.text[3], \"SAMLResponse\")\n        resp = self.client.parse_authn_request_response(_dic[\"SAMLResponse\"],\n                                                        BINDING_HTTP_POST,\n                                                        {sid: \"/\"})\n        ac = resp.assertion.authn_statement[0].authn_context\n        assert ac.authenticating_authority[0].text == \\\n               'http://www.example.com/login'\n        assert ac.authn_context_class_ref.text == INTERNETPROTOCOLPASSWORD\n\ndef test_parse_soap_enveloped_saml_xxe():\n    xml = \"\"\"<?xml version=\"1.0\"?>\n    <!DOCTYPE lolz [\n    <!ENTITY lol \"lol\">\n    <!ELEMENT lolz (#PCDATA)>\n    <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">\n    ]>\n    <lolz>&lol1;</lolz>\n    \"\"\"\n    with raises(EntitiesForbidden):\n        parse_soap_enveloped_saml(xml, None)\n\n# if __name__ == \"__main__\":\n#     tc = TestClient()\n#     tc.setup_class()\n#     tc.test_response()\n\nif __name__ == \"__main__\":\n    tc = TestClient()\n    tc.setup_class()\n    tc.test_sign_then_encrypt_assertion()\n"], "filenames": ["setup.py", "src/saml2/__init__.py", "src/saml2/pack.py", "src/saml2/soap.py", "tests/test_03_saml2.py", "tests/test_43_soap.py", "tests/test_51_client.py"], "buggy_code_start_loc": [20, 38, 39, 21, 19, 14, 9], "buggy_code_end_loc": [20, 273, 239, 213, 454, 68, 1554], "fixing_code_start_loc": [21, 39, 40, 22, 20, 15, 10], "fixing_code_end_loc": [22, 274, 240, 214, 482, 112, 1570], "type": "CWE-611", "message": "XML External Entity (XXE) vulnerability in PySAML2 4.4.0 and earlier allows remote attackers to read arbitrary files via a crafted SAML XML request or response.", "other": {"cve": {"id": "CVE-2016-10149", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-24T14:59:00.227", "lastModified": "2018-01-05T02:30:31.603", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "XML External Entity (XXE) vulnerability in PySAML2 4.4.0 and earlier allows remote attackers to read arbitrary files via a crafted SAML XML request or response."}, {"lang": "es", "value": "Vulnerabilidad de XXE en PySAML2 4.4.0 y versiones anteriores permite a atacantes remotos leer archivos arbitrarios a trav\u00e9s de una solicitud o respuesta SAMPL XML manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pysaml2_project:pysaml2:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.4.0", "matchCriteriaId": "24F2FB4E-4F43-4B09-B01C-1B3FCB88AB2C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3759", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/19/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97692", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:0936", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:0937", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:0938", "source": "cve@mitre.org"}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=850716", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/rohe/pysaml2/commit/6e09a25d9b4b7aa7a506853210a9a14100b8bc9b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/rohe/pysaml2/issues/366", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/rohe/pysaml2/pull/379", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rohe/pysaml2/commit/6e09a25d9b4b7aa7a506853210a9a14100b8bc9b"}}